commit a2806ef77ff9a965a70d6c194bb3a4801bbdb07d
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Mon Apr 13 18:32:46 2020 +0300

    tracing: Remove DECLARE_TRACE_NOARGS
    
    This macro was intentionally broken so that the kernel code is not
    poluted with such noargs macro used simply as markers. This use case
    can be satisfied by using dummy no inline functions. Just remove it.
    
    Link: http://lkml.kernel.org/r/20200413153246.8511-1-nborisov@suse.com
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 1fb11daa5c53..a1fecf311621 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -156,8 +156,7 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
  * Note, the proto and args passed in includes "__data" as the first parameter.
  * The reason for this is to handle the "void" prototype. If a tracepoint
  * has a "void" prototype, then it is invalid to declare a function
- * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
- * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
+ * as "(void *, void)".
  */
 #define __DO_TRACE(tp, proto, args, cond, rcuidle)			\
 	do {								\
@@ -373,25 +372,6 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
 # define __tracepoint_string
 #endif
 
-/*
- * The need for the DECLARE_TRACE_NOARGS() is to handle the prototype
- * (void). "void" is a special value in a function prototype and can
- * not be combined with other arguments. Since the DECLARE_TRACE()
- * macro adds a data element at the beginning of the prototype,
- * we need a way to differentiate "(void *data, proto)" from
- * "(void *data, void)". The second prototype is invalid.
- *
- * DECLARE_TRACE_NOARGS() passes "void" as the tracepoint prototype
- * and "void *__data" as the callback prototype.
- *
- * DECLARE_TRACE() passes "proto" as the tracepoint protoype and
- * "void *__data, proto" as the callback prototype.
- */
-#define DECLARE_TRACE_NOARGS(name)					\
-	__DECLARE_TRACE(name, void, ,					\
-			cpu_online(raw_smp_processor_id()),		\
-			void *__data, __data)
-
 #define DECLARE_TRACE(name, proto, args)				\
 	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
 			cpu_online(raw_smp_processor_id()),		\

commit 52a6e82ac27288f591c750f201de5c3e6ef24385
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:26 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 365
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2 see the file copying for more
      details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 3 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081035.872590698@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 86b019aa2839..1fb11daa5c53 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 #ifndef _LINUX_TRACEPOINT_H
 #define _LINUX_TRACEPOINT_H
 
@@ -9,9 +10,6 @@
  * Copyright (C) 2008-2014 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
  *
  * Heavily inspired from the Linux Kernel Markers.
- *
- * This file is released under the GPLv2.
- * See the file COPYING for more details.
  */
 
 #include <linux/smp.h>

commit 163363455b42a1cf833742177149d1352dfe673e
Author: Yafang Shao <laoar.shao@gmail.com>
Date:   Tue Mar 26 20:13:09 2019 +0800

    tracing: introduce TRACE_EVENT_NOP()
    
    Sometimes we want to define a tracepoint as a do-nothing function.
    So I introduce TRACE_EVENT_NOP, DECLARE_EVENT_CLASS_NOP and
    DEFINE_EVENT_NOP for this kind of usage.
    
    Link: http://lkml.kernel.org/r/1553602391-11926-2-git-send-email-laoar.shao@gmail.com
    
    Signed-off-by: Yafang Shao <laoar.shao@gmail.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 9c3186578ce0..86b019aa2839 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -548,4 +548,19 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
 
 #define TRACE_EVENT_PERF_PERM(event, expr...)
 
+#define DECLARE_EVENT_NOP(name, proto, args)				\
+	static inline void trace_##name(proto)				\
+	{ }								\
+	static inline bool trace_##name##_enabled(void)			\
+	{								\
+		return false;						\
+	}
+
+#define TRACE_EVENT_NOP(name, proto, args, struct, assign, print)	\
+	DECLARE_EVENT_NOP(name, PARAMS(proto), PARAMS(args))
+
+#define DECLARE_EVENT_CLASS_NOP(name, proto, args, tstruct, assign, print)
+#define DEFINE_EVENT_NOP(template, name, proto, args)			\
+	DECLARE_EVENT_NOP(name, PARAMS(proto), PARAMS(args))
+
 #endif /* ifdef TRACE_EVENT (see note above) */

commit 4bbfd7467cfc7d42e18d3008fa6a28ffd56e901a
Merge: 2595646791c3 5ac7cdc29897
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Dec 4 07:52:30 2018 +0100

    Merge branch 'for-mingo' of git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/linux-rcu into core/rcu
    
    Pull RCU changes from Paul E. McKenney:
    
    - Convert RCU's BUG_ON() and similar calls to WARN_ON() and similar.
    
    - Replace calls of RCU-bh and RCU-sched update-side functions
      to their vanilla RCU counterparts.  This series is a step
      towards complete removal of the RCU-bh and RCU-sched update-side
      functions.
    
      ( Note that some of these conversions are going upstream via their
        respective maintainers. )
    
    - Documentation updates, including a number of flavor-consolidation
      updates from Joel Fernandes.
    
    - Miscellaneous fixes.
    
    - Automate generation of the initrd filesystem used for
      rcutorture testing.
    
    - Convert spin_is_locked() assertions to instead use lockdep.
    
      ( Note that some of these conversions are going upstream via their
        respective maintainers. )
    
    - SRCU updates, especially including a fix from Dennis Krein
      for a bag-on-head-class bug.
    
    - RCU torture-test updates.
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 0c7a52e4d4b5c4d35b31f3c3ad32af814f1bf491
Author: Zenghui Yu <yuzenghui@huawei.com>
Date:   Wed Nov 28 03:35:23 2018 +0000

    tracepoint: Use __idx instead of idx in DO_TRACE macro to make it unique
    
    After enabling KVM event tracing, almost all of trace_kvm_exit()'s
    printk shows
    
            "kvm_exit: IRQ: ..."
    
    even if the actual exception_type is NOT IRQ.  More specifically,
    trace_kvm_exit() is defined in virt/kvm/arm/trace.h by TRACE_EVENT.
    
    This slight problem may have existed after commit e6753f23d961
    ("tracepoint: Make rcuidle tracepoint callers use SRCU"). There are
    two variables in trace_kvm_exit() and __DO_TRACE() which have the
    same name, *idx*. Thus the actual value of *idx* will be overwritten
    when tracing. Fix it by adding a simple prefix.
    
    Cc: Joel Fernandes <joel@joelfernandes.org>
    Cc: Wang Haibin <wanghaibin.wang@huawei.com>
    Cc: linux-trace-devel@vger.kernel.org
    Cc: stable@vger.kernel.org
    Fixes: e6753f23d961 ("tracepoint: Make rcuidle tracepoint callers use SRCU")
    Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Zenghui Yu <yuzenghui@huawei.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 538ba1a58f5b..e9de8ad0bad7 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -166,7 +166,7 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
 		struct tracepoint_func *it_func_ptr;			\
 		void *it_func;						\
 		void *__data;						\
-		int __maybe_unused idx = 0;				\
+		int __maybe_unused __idx = 0;				\
 									\
 		if (!(cond))						\
 			return;						\
@@ -182,7 +182,7 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
 		 * doesn't work from the idle path.			\
 		 */							\
 		if (rcuidle) {						\
-			idx = srcu_read_lock_notrace(&tracepoint_srcu);	\
+			__idx = srcu_read_lock_notrace(&tracepoint_srcu);\
 			rcu_irq_enter_irqson();				\
 		}							\
 									\
@@ -198,7 +198,7 @@ static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
 									\
 		if (rcuidle) {						\
 			rcu_irq_exit_irqson();				\
-			srcu_read_unlock_notrace(&tracepoint_srcu, idx);\
+			srcu_read_unlock_notrace(&tracepoint_srcu, __idx);\
 		}							\
 									\
 		preempt_enable_notrace();				\

commit 7440172974e85b1828bdd84ac6b23b5bcad9c5eb
Author: Paul E. McKenney <paulmck@linux.ibm.com>
Date:   Tue Nov 6 18:44:52 2018 -0800

    tracing: Replace synchronize_sched() and call_rcu_sched()
    
    Now that synchronize_rcu() waits for preempt-disable regions of code
    as well as RCU read-side critical sections, synchronize_sched() can
    be replaced by synchronize_rcu().  Similarly, call_rcu_sched() can be
    replaced by call_rcu().  This commit therefore makes these changes.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: <linux-kernel@vger.kernel.org>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 538ba1a58f5b..432080b59c26 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -82,7 +82,7 @@ int unregister_tracepoint_module_notifier(struct notifier_block *nb)
 static inline void tracepoint_synchronize_unregister(void)
 {
 	synchronize_srcu(&tracepoint_srcu);
-	synchronize_sched();
+	synchronize_rcu();
 }
 #else
 static inline void tracepoint_synchronize_unregister(void)

commit 9c0be3f6b5d776dfe3ed249862c244a4486414dc
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Sat Oct 13 15:10:50 2018 -0400

    tracepoint: Fix tracepoint array element size mismatch
    
    commit 46e0c9be206f ("kernel: tracepoints: add support for relative
    references") changes the layout of the __tracepoint_ptrs section on
    architectures supporting relative references. However, it does so
    without turning struct tracepoint * const into const int elsewhere in
    the tracepoint code, which has the following side-effect:
    
    Setting mod->num_tracepoints is done in by module.c:
    
        mod->tracepoints_ptrs = section_objs(info, "__tracepoints_ptrs",
                                             sizeof(*mod->tracepoints_ptrs),
                                             &mod->num_tracepoints);
    
    Basically, since sizeof(*mod->tracepoints_ptrs) is a pointer size
    (rather than sizeof(int)), num_tracepoints is erroneously set to half the
    size it should be on 64-bit arch. So a module with an odd number of
    tracepoints misses the last tracepoint due to effect of integer
    division.
    
    So in the module going notifier:
    
            for_each_tracepoint_range(mod->tracepoints_ptrs,
                    mod->tracepoints_ptrs + mod->num_tracepoints,
                    tp_module_going_check_quiescent, NULL);
    
    the expression (mod->tracepoints_ptrs + mod->num_tracepoints) actually
    evaluates to something within the bounds of the array, but miss the
    last tracepoint if the number of tracepoints is odd on 64-bit arch.
    
    Fix this by introducing a new typedef: tracepoint_ptr_t, which
    is either "const int" on architectures that have PREL32 relocations,
    or "struct tracepoint * const" on architectures that does not have
    this feature.
    
    Also provide a new tracepoint_ptr_defer() static inline to
    encapsulate deferencing this type rather than duplicate code and
    ugly idefs within the for_each_tracepoint_range() implementation.
    
    This issue appears in 4.19-rc kernels, and should ideally be fixed
    before the end of the rc cycle.
    
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Link: http://lkml.kernel.org/r/20181013191050.22389-1-mathieu.desnoyers@efficios.com
    Link: http://lkml.kernel.org/r/20180704083651.24360-7-ard.biesheuvel@linaro.org
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 041f7e56a289..538ba1a58f5b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -99,6 +99,29 @@ extern void syscall_unregfunc(void);
 #define TRACE_DEFINE_ENUM(x)
 #define TRACE_DEFINE_SIZEOF(x)
 
+#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
+static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
+{
+	return offset_to_ptr(p);
+}
+
+#define __TRACEPOINT_ENTRY(name)					\
+	asm("	.section \"__tracepoints_ptrs\", \"a\"		\n"	\
+	    "	.balign 4					\n"	\
+	    "	.long 	__tracepoint_" #name " - .		\n"	\
+	    "	.previous					\n")
+#else
+static inline struct tracepoint *tracepoint_ptr_deref(tracepoint_ptr_t *p)
+{
+	return *p;
+}
+
+#define __TRACEPOINT_ENTRY(name)					 \
+	static tracepoint_ptr_t __tracepoint_ptr_##name __used		 \
+	__attribute__((section("__tracepoints_ptrs"))) =		 \
+		&__tracepoint_##name
+#endif
+
 #endif /* _LINUX_TRACEPOINT_H */
 
 /*
@@ -253,19 +276,6 @@ extern void syscall_unregfunc(void);
 		return static_key_false(&__tracepoint_##name.key);	\
 	}
 
-#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
-#define __TRACEPOINT_ENTRY(name)					\
-	asm("	.section \"__tracepoints_ptrs\", \"a\"		\n"	\
-	    "	.balign 4					\n"	\
-	    "	.long 	__tracepoint_" #name " - .		\n"	\
-	    "	.previous					\n")
-#else
-#define __TRACEPOINT_ENTRY(name)					 \
-	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
-	__attribute__((section("__tracepoints_ptrs"))) =		 \
-		&__tracepoint_##name
-#endif
-
 /*
  * We have no guarantee that gcc and the linker won't up-align the tracepoint
  * structures, so we create an array of pointers that will be used for iteration

commit 865e63b04e9b2a658d7f26bd13a71dcd964a9118
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Tue Sep 4 16:26:11 2018 -0400

    tracing: Add back in rcu_irq_enter/exit_irqson() for rcuidle tracepoints
    
    Borislav reported the following splat:
    
     =============================
     WARNING: suspicious RCU usage
     4.19.0-rc1+ #1 Not tainted
     -----------------------------
     ./include/linux/rcupdate.h:631 rcu_read_lock() used illegally while idle!
     other info that might help us debug this:
    
     RCU used illegally from idle CPU!
     rcu_scheduler_active = 2, debug_locks = 1
     RCU used illegally from extended quiescent state!
     1 lock held by swapper/0/0:
      #0: 000000004557ee0e (rcu_read_lock){....}, at: perf_event_output_forward+0x0/0x130
    
     stack backtrace:
     CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0-rc1+ #1
     Hardware name: LENOVO 2320CTO/2320CTO, BIOS G2ET86WW (2.06 ) 11/13/2012
     Call Trace:
      dump_stack+0x85/0xcb
      perf_event_output_forward+0xf6/0x130
      __perf_event_overflow+0x52/0xe0
      perf_swevent_overflow+0x91/0xb0
      perf_tp_event+0x11a/0x350
      ? find_held_lock+0x2d/0x90
      ? __lock_acquire+0x2ce/0x1350
      ? __lock_acquire+0x2ce/0x1350
      ? retint_kernel+0x2d/0x2d
      ? find_held_lock+0x2d/0x90
      ? tick_nohz_get_sleep_length+0x83/0xb0
      ? perf_trace_cpu+0xbb/0xd0
      ? perf_trace_buf_alloc+0x5a/0xa0
      perf_trace_cpu+0xbb/0xd0
      cpuidle_enter_state+0x185/0x340
      do_idle+0x1eb/0x260
      cpu_startup_entry+0x5f/0x70
      start_kernel+0x49b/0x4a6
      secondary_startup_64+0xa4/0xb0
    
    This is due to the tracepoints moving to SRCU usage which does not require
    RCU to be "watching". But perf uses these tracepoints with RCU and expects
    it to be. Hence, we still need to add in the rcu_irq_enter/exit_irqson()
    calls for "rcuidle" tracepoints. This is a temporary fix until we have SRCU
    working in NMI context, and then perf can be converted to use that instead
    of normal RCU.
    
    Link: http://lkml.kernel.org/r/20180904162611.6a120068@gandalf.local.home
    
    Cc: x86-ml <x86@kernel.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reported-by: Borislav Petkov <bp@alien8.de>
    Tested-by: Borislav Petkov <bp@alien8.de>
    Reviewed-by: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Fixes: e6753f23d961d ("tracepoint: Make rcuidle tracepoint callers use SRCU")
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 7f2e16e76ac4..041f7e56a289 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -158,8 +158,10 @@ extern void syscall_unregfunc(void);
 		 * For rcuidle callers, use srcu since sched-rcu	\
 		 * doesn't work from the idle path.			\
 		 */							\
-		if (rcuidle)						\
+		if (rcuidle) {						\
 			idx = srcu_read_lock_notrace(&tracepoint_srcu);	\
+			rcu_irq_enter_irqson();				\
+		}							\
 									\
 		it_func_ptr = rcu_dereference_raw((tp)->funcs);		\
 									\
@@ -171,8 +173,10 @@ extern void syscall_unregfunc(void);
 			} while ((++it_func_ptr)->func);		\
 		}							\
 									\
-		if (rcuidle)						\
+		if (rcuidle) {						\
+			rcu_irq_exit_irqson();				\
 			srcu_read_unlock_notrace(&tracepoint_srcu, idx);\
+		}							\
 									\
 		preempt_enable_notrace();				\
 	} while (0)

commit 46e0c9be206fa7b11aca75da2d6b8535d0139752
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:22 2018 -0700

    kernel: tracepoints: add support for relative references
    
    To avoid the need for relocating absolute references to tracepoint
    structures at boot time when running relocatable kernels (which may
    take a disproportionate amount of space), add the option to emit
    these tables as relative references instead.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-7-ard.biesheuvel@linaro.org
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index d9a084c72541..7f2e16e76ac4 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -249,6 +249,19 @@ extern void syscall_unregfunc(void);
 		return static_key_false(&__tracepoint_##name.key);	\
 	}
 
+#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
+#define __TRACEPOINT_ENTRY(name)					\
+	asm("	.section \"__tracepoints_ptrs\", \"a\"		\n"	\
+	    "	.balign 4					\n"	\
+	    "	.long 	__tracepoint_" #name " - .		\n"	\
+	    "	.previous					\n")
+#else
+#define __TRACEPOINT_ENTRY(name)					 \
+	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
+	__attribute__((section("__tracepoints_ptrs"))) =		 \
+		&__tracepoint_##name
+#endif
+
 /*
  * We have no guarantee that gcc and the linker won't up-align the tracepoint
  * structures, so we create an array of pointers that will be used for iteration
@@ -258,11 +271,9 @@ extern void syscall_unregfunc(void);
 	static const char __tpstrtab_##name[]				 \
 	__attribute__((section("__tracepoints_strings"))) = #name;	 \
 	struct tracepoint __tracepoint_##name				 \
-	__attribute__((section("__tracepoints"))) =			 \
+	__attribute__((section("__tracepoints"), used)) =		 \
 		{ __tpstrtab_##name, STATIC_KEY_INIT_FALSE, reg, unreg, NULL };\
-	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
-	__attribute__((section("__tracepoints_ptrs"))) =		 \
-		&__tracepoint_##name;
+	__TRACEPOINT_ENTRY(name);
 
 #define DEFINE_TRACE(name)						\
 	DEFINE_TRACE_FN(name, NULL, NULL);

commit e6753f23d961d601dbae50a2fc2a3975c9715b14
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Mon Jul 30 15:24:22 2018 -0700

    tracepoint: Make rcuidle tracepoint callers use SRCU
    
    In recent tests with IRQ on/off tracepoints, a large performance
    overhead ~10% is noticed when running hackbench. This is root caused to
    calls to rcu_irq_enter_irqson and rcu_irq_exit_irqson from the
    tracepoint code. Following a long discussion on the list [1] about this,
    we concluded that srcu is a better alternative for use during rcu idle.
    Although it does involve extra barriers, its lighter than the sched-rcu
    version which has to do additional RCU calls to notify RCU idle about
    entry into RCU sections.
    
    In this patch, we change the underlying implementation of the
    trace_*_rcuidle API to use SRCU. This has shown to improve performance
    alot for the high frequency irq enable/disable tracepoints.
    
    Test: Tested idle and preempt/irq tracepoints.
    
    Here are some performance numbers:
    
    With a run of the following 30 times on a single core x86 Qemu instance
    with 1GB memory:
    hackbench -g 4 -f 2 -l 3000
    
    Completion times in seconds. CONFIG_PROVE_LOCKING=y.
    
    No patches (without this series)
    Mean: 3.048
    Median: 3.025
    Std Dev: 0.064
    
    With Lockdep using irq tracepoints with RCU implementation:
    Mean: 3.451   (-11.66 %)
    Median: 3.447 (-12.22%)
    Std Dev: 0.049
    
    With Lockdep using irq tracepoints with SRCU implementation (this series):
    Mean: 3.020   (I would consider the improvement against the "without
                   this series" case as just noise).
    Median: 3.013
    Std Dev: 0.033
    
    [1] https://patchwork.kernel.org/patch/10344297/
    
    [remove rcu_read_lock_sched_notrace as its the equivalent of
    preempt_disable_notrace and is unnecessary to call in tracepoint code]
    Link: http://lkml.kernel.org/r/20180730222423.196630-3-joel@joelfernandes.org
    
    Cleaned-up-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    [ Simplified WARN_ON_ONCE() ]
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 19a690b559ca..d9a084c72541 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -15,6 +15,7 @@
  */
 
 #include <linux/smp.h>
+#include <linux/srcu.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/cpumask.h>
@@ -33,6 +34,8 @@ struct trace_eval_map {
 
 #define TRACEPOINT_DEFAULT_PRIO	10
 
+extern struct srcu_struct tracepoint_srcu;
+
 extern int
 tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);
 extern int
@@ -75,10 +78,16 @@ int unregister_tracepoint_module_notifier(struct notifier_block *nb)
  * probe unregistration and the end of module exit to make sure there is no
  * caller executing a probe when it is freed.
  */
+#ifdef CONFIG_TRACEPOINTS
 static inline void tracepoint_synchronize_unregister(void)
 {
+	synchronize_srcu(&tracepoint_srcu);
 	synchronize_sched();
 }
+#else
+static inline void tracepoint_synchronize_unregister(void)
+{ }
+#endif
 
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
 extern int syscall_regfunc(void);
@@ -129,18 +138,31 @@ extern void syscall_unregfunc(void);
  * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
  * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
  */
-#define __DO_TRACE(tp, proto, args, cond, rcucheck)			\
+#define __DO_TRACE(tp, proto, args, cond, rcuidle)			\
 	do {								\
 		struct tracepoint_func *it_func_ptr;			\
 		void *it_func;						\
 		void *__data;						\
+		int __maybe_unused idx = 0;				\
 									\
 		if (!(cond))						\
 			return;						\
-		if (rcucheck)						\
-			rcu_irq_enter_irqson();				\
-		rcu_read_lock_sched_notrace();				\
-		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
+									\
+		/* srcu can't be used from NMI */			\
+		WARN_ON_ONCE(rcuidle && in_nmi());			\
+									\
+		/* keep srcu and sched-rcu usage consistent */		\
+		preempt_disable_notrace();				\
+									\
+		/*							\
+		 * For rcuidle callers, use srcu since sched-rcu	\
+		 * doesn't work from the idle path.			\
+		 */							\
+		if (rcuidle)						\
+			idx = srcu_read_lock_notrace(&tracepoint_srcu);	\
+									\
+		it_func_ptr = rcu_dereference_raw((tp)->funcs);		\
+									\
 		if (it_func_ptr) {					\
 			do {						\
 				it_func = (it_func_ptr)->func;		\
@@ -148,9 +170,11 @@ extern void syscall_unregfunc(void);
 				((void(*)(proto))(it_func))(args);	\
 			} while ((++it_func_ptr)->func);		\
 		}							\
-		rcu_read_unlock_sched_notrace();			\
-		if (rcucheck)						\
-			rcu_irq_exit_irqson();				\
+									\
+		if (rcuidle)						\
+			srcu_read_unlock_notrace(&tracepoint_srcu, idx);\
+									\
+		preempt_enable_notrace();				\
 	} while (0)
 
 #ifndef MODULE

commit ec15872daa0ac3f5cbe7cb6f1734c493d74301ac
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue May 8 18:54:36 2018 -0300

    docs: fix broken references with multiple hints
    
    The script:
            ./scripts/documentation-file-ref-check --fix
    
    Gives multiple hints for broken references on some files.
    Manually use the one that applies for some files.
    
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: James Morris <james.morris@microsoft.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c94f466d57ef..19a690b559ca 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -4,7 +4,7 @@
 /*
  * Kernel Tracepoint API.
  *
- * See Documentation/trace/tracepoints.txt.
+ * See Documentation/trace/tracepoints.rst.
  *
  * Copyright (C) 2008-2014 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
  *

commit 844ccdd7dce2c1a6ea9b437fcf8c3265b136e4a5
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Tue Oct 3 16:51:47 2017 -0700

    rcu: Eliminate rcu_irq_enter_disabled()
    
    Now that the irq path uses the rcu_nmi_{enter,exit}() algorithm,
    rcu_irq_enter() and rcu_irq_exit() may be used from any context.  There is
    thus no need for rcu_irq_enter_disabled() and for the checks using it.
    This commit therefore eliminates rcu_irq_enter_disabled().
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index a26ffbe09e71..c94f466d57ef 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -137,11 +137,8 @@ extern void syscall_unregfunc(void);
 									\
 		if (!(cond))						\
 			return;						\
-		if (rcucheck) {						\
-			if (WARN_ON_ONCE(rcu_irq_enter_disabled()))	\
-				return;					\
+		if (rcucheck)						\
 			rcu_irq_enter_irqson();				\
-		}							\
 		rcu_read_lock_sched_notrace();				\
 		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
 		if (it_func_ptr) {					\

commit 4f0dfd76e9cc9296d74d6d5f579a5c7ca3bed869
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Wed May 31 16:56:50 2017 -0500

    tracing: define TRACE_DEFINE_SIZEOF() macro to map sizeof's to their values
    
    Perf has a problem that if sizeof() macros are used within TRACE_EVENT()
    macro's they end up in userspace as "sizeof(kernel structure)" which
    cannot properly be parsed. Add a macro which can forward this data
    through the eval_map for userspace utilization.
    
    Link: http://lkml.kernel.org/r/20170531215653.3240-10-jeremy.linton@arm.com
    
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index f7b0f5525e46..a26ffbe09e71 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -88,6 +88,7 @@ extern void syscall_unregfunc(void);
 #define PARAMS(args...) args
 
 #define TRACE_DEFINE_ENUM(x)
+#define TRACE_DEFINE_SIZEOF(x)
 
 #endif /* _LINUX_TRACEPOINT_H */
 

commit 00f4b652b6f1dbfd4e1d5419d7f1cc23b1374da8
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Wed May 31 16:56:43 2017 -0500

    trace: rename trace_enum_map to trace_eval_map
    
    Each enum is loaded into the trace_enum_map, as we
    are now using this for more than enums rename it.
    
    Link: http://lkml.kernel.org/r/20170531215653.3240-3-jeremy.linton@arm.com
    
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index cc48cb2ce209..f7b0f5525e46 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -25,10 +25,10 @@ struct module;
 struct tracepoint;
 struct notifier_block;
 
-struct trace_enum_map {
+struct trace_eval_map {
 	const char		*system;
-	const char		*enum_string;
-	unsigned long		enum_value;
+	const char		*eval_string;
+	unsigned long		eval_value;
 };
 
 #define TRACEPOINT_DEFAULT_PRIO	10

commit d54b6eeb553c89ed8d4c5a2ed73df374a45b9562
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Fri Apr 7 12:40:49 2017 -0400

    tracing: Make sure rcu_irq_enter() can work for trace_*_rcuidle() trace events
    
    Stack tracing discovered that there's a small location inside the RCU
    infrastructure where calling rcu_irq_enter() does not work. As trace events
    use rcu_irq_enter() it must make sure that it is functionable. A check
    against rcu_irq_enter_disabled() is added with a WARN_ON_ONCE() as no trace
    event should ever be used in that part of RCU. If the warning is triggered,
    then the trace event is ignored.
    
    Restructure the __DO_TRACE() a bit to get rid of the prercu and postrcu,
    and just have an rcucheck that does the work from within the _DO_TRACE()
    macro. gcc optimization will compile out the rcucheck=0 case.
    
    Link: http://lkml.kernel.org/r/20170405093207.404f8deb@gandalf.local.home
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index f72fcfe0e66a..cc48cb2ce209 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -128,7 +128,7 @@ extern void syscall_unregfunc(void);
  * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
  * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
  */
-#define __DO_TRACE(tp, proto, args, cond, prercu, postrcu)		\
+#define __DO_TRACE(tp, proto, args, cond, rcucheck)			\
 	do {								\
 		struct tracepoint_func *it_func_ptr;			\
 		void *it_func;						\
@@ -136,7 +136,11 @@ extern void syscall_unregfunc(void);
 									\
 		if (!(cond))						\
 			return;						\
-		prercu;							\
+		if (rcucheck) {						\
+			if (WARN_ON_ONCE(rcu_irq_enter_disabled()))	\
+				return;					\
+			rcu_irq_enter_irqson();				\
+		}							\
 		rcu_read_lock_sched_notrace();				\
 		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
 		if (it_func_ptr) {					\
@@ -147,20 +151,19 @@ extern void syscall_unregfunc(void);
 			} while ((++it_func_ptr)->func);		\
 		}							\
 		rcu_read_unlock_sched_notrace();			\
-		postrcu;						\
+		if (rcucheck)						\
+			rcu_irq_exit_irqson();				\
 	} while (0)
 
 #ifndef MODULE
-#define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)	\
+#define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args) \
 	static inline void trace_##name##_rcuidle(proto)		\
 	{								\
 		if (static_key_false(&__tracepoint_##name.key))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
-				TP_CONDITION(cond),			\
-				rcu_irq_enter_irqson(),			\
-				rcu_irq_exit_irqson());			\
+				TP_CONDITION(cond), 1);			\
 	}
 #else
 #define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)
@@ -186,7 +189,7 @@ extern void syscall_unregfunc(void);
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
-				TP_CONDITION(cond),,);			\
+				TP_CONDITION(cond), 0);			\
 		if (IS_ENABLED(CONFIG_LOCKDEP) && (cond)) {		\
 			rcu_read_lock_sched_notrace();			\
 			rcu_dereference_sched(__tracepoint_##name.funcs);\

commit 8cf868affdc459beee1a941df0cfaba1673740e3
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Mon Nov 28 13:03:21 2016 -0500

    tracing: Have the reg function allow to fail
    
    Some tracepoints have a registration function that gets enabled when the
    tracepoint is enabled. There may be cases that the registraction function
    must fail (for example, can't allocate enough memory). In this case, the
    tracepoint should also fail to register, otherwise the user would not know
    why the tracepoint is not working.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: Seiji Aguchi <seiji.aguchi@hds.com>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index be586c632a0c..f72fcfe0e66a 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -81,7 +81,7 @@ static inline void tracepoint_synchronize_unregister(void)
 }
 
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
-extern void syscall_regfunc(void);
+extern int syscall_regfunc(void);
 extern void syscall_unregfunc(void);
 #endif /* CONFIG_HAVE_SYSCALL_TRACEPOINTS */
 

commit dc17147de328a74bbdee67c1bf37d2f1992de756
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Wed Mar 9 11:58:41 2016 -0500

    tracing: Fix check for cpu online when event is disabled
    
    Commit f37755490fe9b ("tracepoints: Do not trace when cpu is offline") added
    a check to make sure that tracepoints only get called when the cpu is
    online, as it uses rcu_read_lock_sched() for protection.
    
    Commit 3a630178fd5f3 ("tracing: generate RCU warnings even when tracepoints
    are disabled") added lockdep checks (including rcu checks) for events that
    are not enabled to catch possible RCU issues that would only be triggered if
    a trace event was enabled. Commit f37755490fe9b only stopped the warnings
    when the trace event was enabled but did not prevent warnings if the trace
    event was called when disabled.
    
    To fix this, the cpu online check is moved to where the condition is added
    to the trace event. This will place the cpu online check in all places that
    it may be used now and in the future.
    
    Cc: stable@vger.kernel.org # v3.18+
    Fixes: f37755490fe9b ("tracepoints: Do not trace when cpu is offline")
    Fixes: 3a630178fd5f3 ("tracing: generate RCU warnings even when tracepoints are disabled")
    Reported-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index acfdbf353a0b..be586c632a0c 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -134,9 +134,6 @@ extern void syscall_unregfunc(void);
 		void *it_func;						\
 		void *__data;						\
 									\
-		if (!cpu_online(raw_smp_processor_id()))		\
-			return;						\
-									\
 		if (!(cond))						\
 			return;						\
 		prercu;							\
@@ -343,15 +340,19 @@ extern void syscall_unregfunc(void);
  * "void *__data, proto" as the callback prototype.
  */
 #define DECLARE_TRACE_NOARGS(name)					\
-		__DECLARE_TRACE(name, void, , 1, void *__data, __data)
+	__DECLARE_TRACE(name, void, ,					\
+			cpu_online(raw_smp_processor_id()),		\
+			void *__data, __data)
 
 #define DECLARE_TRACE(name, proto, args)				\
-		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), 1,	\
-				PARAMS(void *__data, proto),		\
-				PARAMS(__data, args))
+	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
+			cpu_online(raw_smp_processor_id()),		\
+			PARAMS(void *__data, proto),			\
+			PARAMS(__data, args))
 
 #define DECLARE_TRACE_CONDITION(name, proto, args, cond)		\
-	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), PARAMS(cond), \
+	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
+			cpu_online(raw_smp_processor_id()) && (PARAMS(cond)), \
 			PARAMS(void *__data, proto),			\
 			PARAMS(__data, args))
 

commit f37755490fe9bf76f6ba1d8c6591745d3574a6a6
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Mon Feb 15 12:36:14 2016 -0500

    tracepoints: Do not trace when cpu is offline
    
    The tracepoint infrastructure uses RCU sched protection to enable and
    disable tracepoints safely. There are some instances where tracepoints are
    used in infrastructure code (like kfree()) that get called after a CPU is
    going offline, and perhaps when it is coming back online but hasn't been
    registered yet.
    
    This can probuce the following warning:
    
     [ INFO: suspicious RCU usage. ]
     4.4.0-00006-g0fe53e8-dirty #34 Tainted: G S
     -------------------------------
     include/trace/events/kmem.h:141 suspicious rcu_dereference_check() usage!
    
     other info that might help us debug this:
    
     RCU used illegally from offline CPU!  rcu_scheduler_active = 1, debug_locks = 1
     no locks held by swapper/8/0.
    
     stack backtrace:
      CPU: 8 PID: 0 Comm: swapper/8 Tainted: G S              4.4.0-00006-g0fe53e8-dirty #34
      Call Trace:
      [c0000005b76c78d0] [c0000000008b9540] .dump_stack+0x98/0xd4 (unreliable)
      [c0000005b76c7950] [c00000000010c898] .lockdep_rcu_suspicious+0x108/0x170
      [c0000005b76c79e0] [c00000000029adc0] .kfree+0x390/0x440
      [c0000005b76c7a80] [c000000000055f74] .destroy_context+0x44/0x100
      [c0000005b76c7b00] [c0000000000934a0] .__mmdrop+0x60/0x150
      [c0000005b76c7b90] [c0000000000e3ff0] .idle_task_exit+0x130/0x140
      [c0000005b76c7c20] [c000000000075804] .pseries_mach_cpu_die+0x64/0x310
      [c0000005b76c7cd0] [c000000000043e7c] .cpu_die+0x3c/0x60
      [c0000005b76c7d40] [c0000000000188d8] .arch_cpu_idle_dead+0x28/0x40
      [c0000005b76c7db0] [c000000000101e6c] .cpu_startup_entry+0x50c/0x560
      [c0000005b76c7ed0] [c000000000043bd8] .start_secondary+0x328/0x360
      [c0000005b76c7f90] [c000000000008a6c] start_secondary_prolog+0x10/0x14
    
    This warning is not a false positive either. RCU is not protecting code that
    is being executed while the CPU is offline.
    
    Instead of playing "whack-a-mole(TM)" and adding conditional statements to
    the tracepoints we find that are used in this instance, simply add a
    cpu_online() test to the tracepoint code where the tracepoint will be
    ignored if the CPU is offline.
    
    Use of raw_smp_processor_id() is fine, as there should never be a case where
    the tracepoint code goes from running on a CPU that is online and suddenly
    gets migrated to a CPU that is offline.
    
    Link: http://lkml.kernel.org/r/1455387773-4245-1-git-send-email-kda@linux-powerpc.org
    
    Reported-by: Denis Kirjanov <kda@linux-powerpc.org>
    Fixes: 97e1c18e8d17b ("tracing: Kernel Tracepoints")
    Cc: stable@vger.kernel.org # v2.6.28+
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index acd522a91539..acfdbf353a0b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -14,8 +14,10 @@
  * See the file COPYING for more details.
  */
 
+#include <linux/smp.h>
 #include <linux/errno.h>
 #include <linux/types.h>
+#include <linux/cpumask.h>
 #include <linux/rcupdate.h>
 #include <linux/tracepoint-defs.h>
 
@@ -132,6 +134,9 @@ extern void syscall_unregfunc(void);
 		void *it_func;						\
 		void *__data;						\
 									\
+		if (!cpu_online(raw_smp_processor_id()))		\
+			return;						\
+									\
 		if (!(cond))						\
 			return;						\
 		prercu;							\

commit c17488d06666153a14dd3f21bd10eba58383f6c1
Merge: 34a9304a96d6 5156dca34a3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 20:04:15 2016 -0800

    Merge tag 'trace-v4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing updates from Steven Rostedt:
     "Not much new with tracing for this release.  Mostly just clean ups and
      minor fixes.
    
      Here's what else is new:
    
       - A new TRACE_EVENT_FN_COND macro, combining both _FN and _COND for
         those that want both.
    
       - New selftest to test the instance create and delete
    
       - Better debug output when ftrace fails"
    
    * tag 'trace-v4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace: (24 commits)
      ftrace: Fix the race between ftrace and insmod
      ftrace: Add infrastructure for delayed enabling of module functions
      x86: ftrace: Fix the comments for ftrace_modify_code_direct()
      tracing: Fix comment to use tracing_on over tracing_enable
      metag: ftrace: Fix the comments for ftrace_modify_code
      sh: ftrace: Fix the comments for ftrace_modify_code()
      ia64: ftrace: Fix the comments for ftrace_modify_code()
      ftrace: Clean up ftrace_module_init() code
      ftrace: Join functions ftrace_module_init() and ftrace_init_module()
      tracing: Introduce TRACE_EVENT_FN_COND macro
      tracing: Use seq_buf_used() in seq_buf_to_user() instead of len
      bpf: Constify bpf_verifier_ops structure
      ftrace: Have ftrace_ops_get_func() handle RCU and PER_CPU flags too
      ftrace: Remove use of control list and ops
      ftrace: Fix output of enabled_functions for showing tramp
      ftrace: Fix a typo in comment
      ftrace: Show all tramps registered to a record on ftrace_bug()
      ftrace: Add variable ftrace_expected for archs to show expected code
      ftrace: Add new type to distinguish what kind of ftrace_bug()
      tracing: Update cond flag when enabling or disabling a trigger
      ...

commit 5cb52b5e1654f3f1ed9c32e34456d98559c85aa0
Merge: 24af98c4cf5f 3eb9ede23bdd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 14:39:17 2016 -0800

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull perf updates from Ingo Molnar:
     "Kernel side changes:
    
       - Intel Knights Landing support.  (Harish Chegondi)
    
       - Intel Broadwell-EP uncore PMU support.  (Kan Liang)
    
       - Core code improvements.  (Peter Zijlstra.)
    
       - Event filter, LBR and PEBS fixes.  (Stephane Eranian)
    
       - Enable cycles:pp on Intel Atom.  (Stephane Eranian)
    
       - Add cycles:ppp support for Skylake.  (Andi Kleen)
    
       - Various x86 NMI overhead optimizations.  (Andi Kleen)
    
       - Intel PT enhancements.  (Takao Indoh)
    
       - AMD cache events fix.  (Vince Weaver)
    
      Tons of tooling changes:
    
       - Show random perf tool tips in the 'perf report' bottom line
         (Namhyung Kim)
    
       - perf report now defaults to --group if the perf.data file has
         grouped events, try it with:
    
          # perf record -e '{cycles,instructions}' -a sleep 1
          [ perf record: Woken up 1 times to write data ]
          [ perf record: Captured and wrote 1.093 MB perf.data (1247 samples) ]
          # perf report
          # Samples: 1K of event 'anon group { cycles, instructions }'
          # Event count (approx.): 1955219195
          #
          #       Overhead  Command     Shared Object      Symbol
    
             2.86%   0.22%  swapper     [kernel.kallsyms]  [k] intel_idle
             1.05%   0.33%  firefox     libxul.so          [.] js::SetObjectElement
             1.05%   0.00%  kworker/0:3 [kernel.kallsyms]  [k] gen6_ring_get_seqno
             0.88%   0.17%  chrome      chrome             [.] 0x0000000000ee27ab
             0.65%   0.86%  firefox     libxul.so          [.] js::ValueToId<(js::AllowGC)1>
             0.64%   0.23%  JS Helper   libxul.so          [.] js::SplayTree<js::jit::LiveRange*, js::jit::LiveRange>::splay
             0.62%   1.27%  firefox     libxul.so          [.] js::GetIterator
             0.61%   1.74%  firefox     libxul.so          [.] js::NativeSetProperty
             0.61%   0.31%  firefox     libxul.so          [.] js::SetPropertyByDefining
    
       - Introduce the 'perf stat record/report' workflow:
    
         Generate perf.data files from 'perf stat', to tap into the
         scripting capabilities perf has instead of defining a 'perf stat'
         specific scripting support to calculate event ratios, etc.
    
         Simple example:
    
            $ perf stat record -e cycles usleep 1
    
             Performance counter stats for 'usleep 1':
    
                   1,134,996      cycles
    
                 0.000670644 seconds time elapsed
    
            $ perf stat report
    
             Performance counter stats for '/home/acme/bin/perf stat record -e cycles usleep 1':
    
                   1,134,996      cycles
    
                 0.000670644 seconds time elapsed
    
            $
    
         It generates PERF_RECORD_ userspace records to store the details:
    
            $ perf report -D | grep PERF_RECORD
            0xf0 [0x28]: PERF_RECORD_THREAD_MAP nr: 1 thread: 27637
            0x118 [0x12]: PERF_RECORD_CPU_MAP nr: 1 cpu: 65535
            0x12a [0x40]: PERF_RECORD_STAT_CONFIG
            0x16a [0x30]: PERF_RECORD_STAT
            -1 -1 0x19a [0x40]: PERF_RECORD_MMAP -1/0: [0xffffffff81000000(0x1f000000) @ 0xffffffff81000000]: x [kernel.kallsyms]_text
            0x1da [0x18]: PERF_RECORD_STAT_ROUND
            [acme@ssdandy linux]$
    
         An effort was made to make perf.data files generated like this to
         not generate cryptic messages when processed by older tools.
    
         The 'perf script' bits need rebasing, will go up later.
    
       - Make command line options always available, even when they depend
         on some feature being enabled, warning the user about use of such
         options (Wang Nan)
    
       - Support hw breakpoint events (mem:0xAddress) in the default output
         mode in 'perf script' (Wang Nan)
    
       - Fixes and improvements for supporting annotating ARM binaries,
         support ARM call and jump instructions, more work needed to have
         arch specific stuff separated into tools/perf/arch/*/annotate/
         (Russell King)
    
       - Add initial 'perf config' command, for now just with a --list
         command to the contents of the configuration file in use and a
         basic man page describing its format, commands for doing edits and
         detailed documentation are being reviewed and proof-read.  (Taeung
         Song)
    
       - Allows BPF scriptlets specify arguments to be fetched using DWARF
         info, using a prologue generated at compile/build time (He Kuang,
         Wang Nan)
    
       - Allow attaching BPF scriptlets to module symbols (Wang Nan)
    
       - Allow attaching BPF scriptlets to userspace code using uprobe (Wang
         Nan)
    
       - BPF programs now can specify 'perf probe' tunables via its section
         name, separating key=val values using semicolons (Wang Nan)
    
         Testing some of these new BPF features:
    
            Use case: get callchains when receiving SSL packets, filter then in the
                      kernel, at arbitrary place.
    
            # cat ssl.bpf.c
            #define SEC(NAME) __attribute__((section(NAME), used))
    
            struct pt_regs;
    
            SEC("func=__inet_lookup_established hnum")
            int func(struct pt_regs *ctx, int err, unsigned short port)
            {
                    return err == 0 && port == 443;
            }
    
            char _license[] SEC("license") = "GPL";
            int  _version   SEC("version") = LINUX_VERSION_CODE;
            #
            # perf record -a -g -e ssl.bpf.c
            ^C[ perf record: Woken up 1 times to write data ]
            [ perf record: Captured and wrote 0.787 MB perf.data (3 samples) ]
            # perf script | head -30
            swapper     0 [000] 58783.268118: perf_bpf_probe:func: (ffffffff816a0f60) hnum=0x1bb
               8a0f61 __inet_lookup_established (/lib/modules/4.3.0+/build/vmlinux)
               896def ip_rcv_finish (/lib/modules/4.3.0+/build/vmlinux)
               8976c2 ip_rcv (/lib/modules/4.3.0+/build/vmlinux)
               855eba __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
               8572a8 process_backlog (/lib/modules/4.3.0+/build/vmlinux)
               856b11 net_rx_action (/lib/modules/4.3.0+/build/vmlinux)
               2a284b __do_softirq (/lib/modules/4.3.0+/build/vmlinux)
               2a2ba3 irq_exit (/lib/modules/4.3.0+/build/vmlinux)
               96b7a4 do_IRQ (/lib/modules/4.3.0+/build/vmlinux)
               969807 ret_from_intr (/lib/modules/4.3.0+/build/vmlinux)
               2dede5 cpu_startup_entry (/lib/modules/4.3.0+/build/vmlinux)
               95d5bc rest_init (/lib/modules/4.3.0+/build/vmlinux)
              1163ffa start_kernel ([kernel.vmlinux].init.text)
              11634d7 x86_64_start_reservations ([kernel.vmlinux].init.text)
              1163623 x86_64_start_kernel ([kernel.vmlinux].init.text)
    
            qemu-system-x86  9178 [003] 58785.792417: perf_bpf_probe:func: (ffffffff816a0f60) hnum=0x1bb
               8a0f61 __inet_lookup_established (/lib/modules/4.3.0+/build/vmlinux)
               896def ip_rcv_finish (/lib/modules/4.3.0+/build/vmlinux)
               8976c2 ip_rcv (/lib/modules/4.3.0+/build/vmlinux)
               855eba __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
               856660 netif_receive_skb_internal (/lib/modules/4.3.0+/build/vmlinux)
               8566ec netif_receive_skb_sk (/lib/modules/4.3.0+/build/vmlinux)
                 430a br_handle_frame_finish ([bridge])
                 48bc br_handle_frame ([bridge])
               855f44 __netif_receive_skb_core (/lib/modules/4.3.0+/build/vmlinux)
               8565d8 __netif_receive_skb (/lib/modules/4.3.0+/build/vmlinux)
            #
    
       - Use 'perf probe' various options to list functions, see what
         variables can be collected at any given point, experiment first
         collecting without a filter, then filter, use it together with
         'perf trace', 'perf top', with or without callchains, if it
         explodes, please tell us!
    
       - Introduce a new callchain mode: "folded", that will list per line
         representations of all callchains for a give histogram entry,
         facilitating 'perf report' output processing by other tools, such
         as Brendan Gregg's flamegraph tools (Namhyung Kim)
    
         E.g:
    
            # perf report | grep -v ^# | head
               18.37%     0.00%  swapper  [kernel.kallsyms]   [k] cpu_startup_entry
                               |
                               ---cpu_startup_entry
                                  |
                                  |--12.07%--start_secondary
                                  |
                                   --6.30%--rest_init
                                             start_kernel
                                             x86_64_start_reservations
                                             x86_64_start_kernel
             #
    
         Becomes, in "folded" mode:
    
            # perf report -g folded | grep -v ^# | head -5
                18.37%     0.00%  swapper [kernel.kallsyms]   [k] cpu_startup_entry
              12.07% cpu_startup_entry;start_secondary
               6.30% cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                16.90%     0.00%  swapper [kernel.kallsyms]   [k] call_cpuidle
              11.23% call_cpuidle;cpu_startup_entry;start_secondary
               5.67% call_cpuidle;cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                16.90%     0.00%  swapper [kernel.kallsyms]   [k] cpuidle_enter
              11.23% cpuidle_enter;call_cpuidle;cpu_startup_entry;start_secondary
               5.67% cpuidle_enter;call_cpuidle;cpu_startup_entry;rest_init;start_kernel;x86_64_start_reservations;x86_64_start_kernel
                15.12%     0.00%  swapper [kernel.kallsyms]   [k] cpuidle_enter_state
             #
    
         The user can also select one of "count", "period" or "percent" as
         the first column.
    
      ... and lots of infrastructure enhancements, plus fixes and other
      changes, features I failed to list - see the shortlog and the git log
      for details"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (271 commits)
      perf evlist: Add --trace-fields option to show trace fields
      perf record: Store data mmaps for dwarf unwind
      perf libdw: Check for mmaps also in MAP__VARIABLE tree
      perf unwind: Check for mmaps also in MAP__VARIABLE tree
      perf unwind: Use find_map function in access_dso_mem
      perf evlist: Remove perf_evlist__(enable|disable)_event functions
      perf evlist: Make perf_evlist__open() open evsels with their cpus and threads (like perf record does)
      perf report: Show random usage tip on the help line
      perf hists: Export a couple of hist functions
      perf diff: Use perf_hpp__register_sort_field interface
      perf tools: Add overhead/overhead_children keys defaults via string
      perf tools: Remove list entry from struct sort_entry
      perf tools: Include all tools/lib directory for tags/cscope/TAGS targets
      perf script: Align event name properly
      perf tools: Add missing headers in perf's MANIFEST
      perf tools: Do not show trace command if it's not compiled in
      perf report: Change default to use event group view
      perf top: Decay periods in callchains
      tools lib: Move bitmap.[ch] from tools/perf/ to tools/{lib,include}/
      tools lib: Sync tools/lib/find_bit.c with the kernel
      ...

commit 2701121b8f4db4d69c327c0d8f8694ff2ce30ef7
Author: Denis Kirjanov <kda@linux-powerpc.org>
Date:   Mon Dec 14 23:18:05 2015 +0300

    tracing: Introduce TRACE_EVENT_FN_COND macro
    
    TRACE_EVENT_FN can't be used in some circumstances
    like invoking trace functions from offlined CPU due
    to RCU usage.
    
    This patch adds the TRACE_EVENT_FN_COND macro
    to make such trace points conditional.
    
    Link: http://lkml.kernel.org/r/1450124286-4822-1-git-send-email-kda@linux-powerpc.org
    
    Signed-off-by: Denis Kirjanov <kda@linux-powerpc.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 696a339c592c..45b3fcf7dd3c 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -493,6 +493,10 @@ extern void syscall_unregfunc(void);
 #define TRACE_EVENT_FN(name, proto, args, struct,		\
 		assign, print, reg, unreg)			\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define TRACE_EVENT_FN_COND(name, proto, args, cond, struct,		\
+		assign, print, reg, unreg)			\
+	DECLARE_TRACE_CONDITION(name, PARAMS(proto),	\
+			PARAMS(args), PARAMS(cond))
 #define TRACE_EVENT_CONDITION(name, proto, args, cond,		\
 			      struct, assign, print)		\
 	DECLARE_TRACE_CONDITION(name, PARAMS(proto),		\

commit 7c9906ca5e582a773fff696975e312cef58a7386
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Sat Oct 31 00:59:01 2015 -0700

    rcu: Don't redundantly disable irqs in rcu_irq_{enter,exit}()
    
    This commit replaces a local_irq_save()/local_irq_restore() pair with
    a lockdep assertion that interrupts are already disabled.  This should
    remove the corresponding overhead from the interrupt entry/exit fastpaths.
    
    This change was inspired by the fact that Iftekhar Ahmed's mutation
    testing showed that removing rcu_irq_enter()'s call to local_ird_restore()
    had no effect, which might indicate that interrupts were always enabled
    anyway.
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 696a339c592c..7834a8a8bf1e 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -171,8 +171,8 @@ extern void syscall_unregfunc(void);
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
 				TP_CONDITION(cond),			\
-				rcu_irq_enter(),			\
-				rcu_irq_exit());			\
+				rcu_irq_enter_irqson(),			\
+				rcu_irq_exit_irqson());			\
 	}
 #else
 #define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)

commit bd2a634d9e852b9b6100f9ae9c3c790b0ff91ce0
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Dec 1 17:00:58 2015 -0800

    tracepoints: Move struct tracepoint to new tracepoint-defs.h header
    
    Steven recommended open coding access to tracepoint->key to add
    trace points to headers. Unfortunately this is difficult for some
    headers (such as x86 asm/msr.h) because including tracepoint.h
    includes so many other headers that it causes include loops.
    The main problem is the include of linux/rcupdate.h, which
    pulls in a lot of other headers. The rcu header is only needed
    when actually defining trace points.
    
    Move the struct tracepoint into a separate tracepoint-defs.h
    header that can be included without pulling in all of RCU.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Link: http://lkml.kernel.org/r/1449018060-1742-2-git-send-email-andi@firstfloor.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 696a339c592c..f7c732bd5cbd 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -17,26 +17,12 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
-#include <linux/static_key.h>
+#include <linux/tracepoint-defs.h>
 
 struct module;
 struct tracepoint;
 struct notifier_block;
 
-struct tracepoint_func {
-	void *func;
-	void *data;
-	int prio;
-};
-
-struct tracepoint {
-	const char *name;		/* Tracepoint name */
-	struct static_key key;
-	void (*regfunc)(void);
-	void (*unregfunc)(void);
-	struct tracepoint_func __rcu *funcs;
-};
-
 struct trace_enum_map {
 	const char		*system;
 	const char		*enum_string;

commit a15920bea0428cd22291637f6c72542b1843e65f
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Mon Nov 2 17:42:42 2015 -0500

    tracepoints: Fix documentation of RCU lockdep checks
    
    The documentation on top of __DECLARE_TRACE() does not match its
    implementation since the condition check has been added to the
    RCU lockdep checks. Update the documentation to match its
    implementation.
    
    Link: http://lkml.kernel.org/r/1446504164-21563-1-git-send-email-mathieu.desnoyers@efficios.com
    
    CC: Dave Hansen <dave@sr71.net>
    Fixes: a05d59a56733 "tracing: Add condition check to RCU lockdep checks"
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 6b79537a42b1..696a339c592c 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -184,10 +184,11 @@ extern void syscall_unregfunc(void);
  * structure. Force alignment to the same alignment as the section start.
  *
  * When lockdep is enabled, we make sure to always do the RCU portions of
- * the tracepoint code, regardless of whether tracing is on or we match the
- * condition.  This lets us find RCU issues triggered with tracepoints even
- * when this tracepoint is off.  This code has no purpose other than poking
- * RCU a bit.
+ * the tracepoint code, regardless of whether tracing is on. However,
+ * don't check if the condition is false, due to interaction with idle
+ * instrumentation. This lets us find RCU issues triggered with tracepoints
+ * even when this tracepoint is off. This code has no purpose other than
+ * poking RCU a bit.
  */
 #define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	extern struct tracepoint __tracepoint_##name;			\

commit 7904b5c4988e18b50056b5e71a3ffca752a8a451
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Tue Sep 22 17:13:19 2015 -0400

    tracepoint: Give priority to probes of tracepoints
    
    In order to guarantee that a probe will be called before other probes that
    are attached to a tracepoint, there needs to be a mechanism to provide
    priority of one probe over the others.
    
    Adding a prio field to the struct tracepoint_func, which lets the probes be
    sorted by the priority set in the structure. If no priority is specified,
    then a priority of 10 is given (this is a macro, and perhaps may be changed
    in the future).
    
    Now probes may be added to affect other probes that are attached to a
    tracepoint with a guaranteed order.
    
    One use case would be to allow tracing of tracepoints be able to filter by
    pid. A special (higher priority probe) may be added to the sched_switch
    tracepoint and set the necessary flags of the other tracepoints to notify
    them if they should be traced or not. In case a tracepoint is enabled at the
    sched_switch tracepoint too, the order of the two are not random.
    
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index afada369c5b7..6b79537a42b1 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -26,6 +26,7 @@ struct notifier_block;
 struct tracepoint_func {
 	void *func;
 	void *data;
+	int prio;
 };
 
 struct tracepoint {
@@ -42,9 +43,14 @@ struct trace_enum_map {
 	unsigned long		enum_value;
 };
 
+#define TRACEPOINT_DEFAULT_PRIO	10
+
 extern int
 tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);
 extern int
+tracepoint_probe_register_prio(struct tracepoint *tp, void *probe, void *data,
+			       int prio);
+extern int
 tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data);
 extern void
 for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),
@@ -207,6 +213,13 @@ extern void syscall_unregfunc(void);
 						(void *)probe, data);	\
 	}								\
 	static inline int						\
+	register_trace_prio_##name(void (*probe)(data_proto), void *data,\
+				   int prio)				\
+	{								\
+		return tracepoint_probe_register_prio(&__tracepoint_##name, \
+					      (void *)probe, data, prio); \
+	}								\
+	static inline int						\
 	unregister_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\
 		return tracepoint_probe_unregister(&__tracepoint_##name,\

commit c63b7682b6d90530d3a071ff75b81bfddcce8598
Author: Tal Shorer <tal.shorer@gmail.com>
Date:   Sat Aug 1 15:27:57 2015 +0300

    tracing: Allow disabling compilation of specific trace systems
    
    Allow a trace events header file to disable compilation of its
    trace events by defining the preprocessor macro NOTRACE.
    
    This could be done, for example, according to a Kconfig option.
    
    Link: http://lkml.kernel.org/r/1438432079-11704-3-git-send-email-tal.shorer@gmail.com
    
    Signed-off-by: Tal Shorer <tal.shorer@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index a5f7f3ecafa3..afada369c5b7 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -111,7 +111,18 @@ extern void syscall_unregfunc(void);
 #define TP_ARGS(args...)	args
 #define TP_CONDITION(args...)	args
 
-#ifdef CONFIG_TRACEPOINTS
+/*
+ * Individual subsystem my have a separate configuration to
+ * enable their tracepoints. By default, this file will create
+ * the tracepoints if CONFIG_TRACEPOINT is defined. If a subsystem
+ * wants to be able to disable its tracepoints from being created
+ * it can define NOTRACE before including the tracepoint headers.
+ */
+#if defined(CONFIG_TRACEPOINTS) && !defined(NOTRACE)
+#define TRACEPOINTS_ENABLED
+#endif
+
+#ifdef TRACEPOINTS_ENABLED
 
 /*
  * it_func[0] is never NULL because there is at least one element in the array
@@ -234,7 +245,7 @@ extern void syscall_unregfunc(void);
 #define EXPORT_TRACEPOINT_SYMBOL(name)					\
 	EXPORT_SYMBOL(__tracepoint_##name)
 
-#else /* !CONFIG_TRACEPOINTS */
+#else /* !TRACEPOINTS_ENABLED */
 #define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	static inline void trace_##name(proto)				\
 	{ }								\
@@ -266,7 +277,7 @@ extern void syscall_unregfunc(void);
 #define EXPORT_TRACEPOINT_SYMBOL_GPL(name)
 #define EXPORT_TRACEPOINT_SYMBOL(name)
 
-#endif /* CONFIG_TRACEPOINTS */
+#endif /* TRACEPOINTS_ENABLED */
 
 #ifdef CONFIG_TRACING
 /**

commit 0c564a538aa934ad15b2145aaf8b64f3feb0be63
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Tue Mar 24 17:58:09 2015 -0400

    tracing: Add TRACE_DEFINE_ENUM() macro to map enums to their values
    
    Several tracepoints use the helper functions __print_symbolic() or
    __print_flags() and pass in enums that do the mapping between the
    binary data stored and the value to print. This works well for reading
    the ASCII trace files, but when the data is read via userspace tools
    such as perf and trace-cmd, the conversion of the binary value to a
    human string format is lost if an enum is used, as userspace does not
    have access to what the ENUM is.
    
    For example, the tracepoint trace_tlb_flush() has:
    
     __print_symbolic(REC->reason,
        { TLB_FLUSH_ON_TASK_SWITCH, "flush on task switch" },
        { TLB_REMOTE_SHOOTDOWN, "remote shootdown" },
        { TLB_LOCAL_SHOOTDOWN, "local shootdown" },
        { TLB_LOCAL_MM_SHOOTDOWN, "local mm shootdown" })
    
    Which maps the enum values to the strings they represent. But perf and
    trace-cmd do no know what value TLB_LOCAL_MM_SHOOTDOWN is, and would
    not be able to map it.
    
    With TRACE_DEFINE_ENUM(), developers can place these in the event header
    files and ftrace will convert the enums to their values:
    
    By adding:
    
     TRACE_DEFINE_ENUM(TLB_FLUSH_ON_TASK_SWITCH);
     TRACE_DEFINE_ENUM(TLB_REMOTE_SHOOTDOWN);
     TRACE_DEFINE_ENUM(TLB_LOCAL_SHOOTDOWN);
     TRACE_DEFINE_ENUM(TLB_LOCAL_MM_SHOOTDOWN);
    
     $ cat /sys/kernel/debug/tracing/events/tlb/tlb_flush/format
    [...]
     __print_symbolic(REC->reason,
        { 0, "flush on task switch" },
        { 1, "remote shootdown" },
        { 2, "local shootdown" },
        { 3, "local mm shootdown" })
    
    The above is what userspace expects to see, and tools do not need to
    be modified to parse them.
    
    Link: http://lkml.kernel.org/r/20150403013802.220157513@goodmis.org
    
    Cc: Guilherme Cox <cox@computer.org>
    Cc: Tony Luck <tony.luck@gmail.com>
    Cc: Xie XiuQi <xiexiuqi@huawei.com>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Tested-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c72851328ca9..a5f7f3ecafa3 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -36,6 +36,12 @@ struct tracepoint {
 	struct tracepoint_func __rcu *funcs;
 };
 
+struct trace_enum_map {
+	const char		*system;
+	const char		*enum_string;
+	unsigned long		enum_value;
+};
+
 extern int
 tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);
 extern int
@@ -87,6 +93,8 @@ extern void syscall_unregfunc(void);
 
 #define PARAMS(args...) args
 
+#define TRACE_DEFINE_ENUM(x)
+
 #endif /* _LINUX_TRACEPOINT_H */
 
 /*

commit a05d59a5673339ef6936d6940cdf68172ce75b9f
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Fri Feb 6 14:30:50 2015 -0500

    tracing: Add condition check to RCU lockdep checks
    
    The trace_tlb_flush() tracepoint can be called when a CPU is going offline.
    When a CPU is offline, RCU is no longer watching that CPU and since the
    tracepoint is protected by RCU, it must not be called. To prevent the
    tlb_flush tracepoint from being called when the CPU is offline, it was
    converted to a TRACE_EVENT_CONDITION where the condition checks if the
    CPU is online before calling the tracepoint.
    
    Unfortunately, this was not enough to stop lockdep from complaining about
    it. Even though the RCU protected code of the tracepoint will never be
    called, the condition is hidden within the tracepoint, and even though the
    condition prevents RCU code from being called, the lockdep checks are
    outside the tracepoint (this is to test tracepoints even when they are not
    enabled).
    
    Even though tracepoints should be checked to be RCU safe when they are not
    enabled, the condition should still be considered when checking RCU.
    
    Link: http://lkml.kernel.org/r/CA+icZUUGiGDoL5NU8RuxKzFjoLjEKRtUWx=JB8B9a0EQv-eGzQ@mail.gmail.com
    
    Fixes: 3a630178fd5f "tracing: generate RCU warnings even when tracepoints are disabled"
    Cc: stable@vger.kernel.org # 3.18+
    Acked-by: Dave Hansen <dave@sr71.net>
    Reported-by: Sedat Dilek <sedat.dilek@gmail.com>
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index e08e21e5f601..c72851328ca9 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -173,7 +173,7 @@ extern void syscall_unregfunc(void);
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
 				TP_CONDITION(cond),,);			\
-		if (IS_ENABLED(CONFIG_LOCKDEP)) {			\
+		if (IS_ENABLED(CONFIG_LOCKDEP) && (cond)) {		\
 			rcu_read_lock_sched_notrace();			\
 			rcu_dereference_sched(__tracepoint_##name.funcs);\
 			rcu_read_unlock_sched_notrace();		\

commit 3a630178fd5f30c285fd7016c5340a176b625913
Author: Dave Hansen <dave.hansen@linux.intel.com>
Date:   Thu Aug 7 10:52:04 2014 -0700

    tracing: generate RCU warnings even when tracepoints are disabled
    
    Dave Jones reported seeing a bug from one of my TLB tracepoints:
    
            http://lkml.kernel.org/r/20140806181801.GA4605@redhat.com
    
    I've been running these patches for months and never saw this.
    But, a big chunk of my testing, especially with all the debugging
    enabled, was in a vm where intel_idle doesn't work.  On the
    systems where I was using intel_idle, I never had lockdep enabled
    and this tracepoint on at the same time.
    
    This patch ensures that whenever we have lockdep available, we do
    _some_ RCU activity at the site of the tracepoint, despite
    whether the tracepoint's condition matches or even if the
    tracepoint itself is completely disabled.  This is a bit of a
    hack, but it is pretty self-contained.
    
    I confirmed that with this patch plus lockdep I get the same
    splat as Dave Jones did, but without enabling the tracepoint
    explicitly.
    
    Link: http://lkml.kernel.org/p/20140807175204.C257CAC5@viggo.jf.intel.com
    
    Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Dave Hansen <dave@sr71.net>
    Cc: Dave Jones <davej@redhat.com>,
    Cc: paulmck@linux.vnet.ibm.com
    Cc: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index b1293f15f592..e08e21e5f601 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -157,6 +157,12 @@ extern void syscall_unregfunc(void);
  * Make sure the alignment of the structure in the __tracepoints section will
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
+ *
+ * When lockdep is enabled, we make sure to always do the RCU portions of
+ * the tracepoint code, regardless of whether tracing is on or we match the
+ * condition.  This lets us find RCU issues triggered with tracepoints even
+ * when this tracepoint is off.  This code has no purpose other than poking
+ * RCU a bit.
  */
 #define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	extern struct tracepoint __tracepoint_##name;			\
@@ -167,6 +173,11 @@ extern void syscall_unregfunc(void);
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
 				TP_CONDITION(cond),,);			\
+		if (IS_ENABLED(CONFIG_LOCKDEP)) {			\
+			rcu_read_lock_sched_notrace();			\
+			rcu_dereference_sched(__tracepoint_##name.funcs);\
+			rcu_read_unlock_sched_notrace();		\
+		}							\
 	}								\
 	__DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),		\
 		PARAMS(cond), PARAMS(data_proto), PARAMS(data_args))	\

commit 3c49b52b155d0f723792377e1a4480a0e7ca0ba2
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Fri Jul 25 16:05:29 2014 -0400

    tracing: Do not do anything special with tracepoint_string when tracing is disabled
    
    When CONFIG_TRACING is not enabled, there's no reason to save the trace
    strings either by the linker or as a static variable that can be
    referenced later. Simply pass back the string that is given to
    tracepoint_string().
    
    Had to move the define to include/linux/tracepoint.h so that it is still
    visible when CONFIG_TRACING is not set.
    
    Link: http://lkml.kernel.org/p/1406318733-26754-2-git-send-email-nicolas.pitre@linaro.org
    
    Suggested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 2e2a5f7717e5..b1293f15f592 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -249,6 +249,50 @@ extern void syscall_unregfunc(void);
 
 #endif /* CONFIG_TRACEPOINTS */
 
+#ifdef CONFIG_TRACING
+/**
+ * tracepoint_string - register constant persistent string to trace system
+ * @str - a constant persistent string that will be referenced in tracepoints
+ *
+ * If constant strings are being used in tracepoints, it is faster and
+ * more efficient to just save the pointer to the string and reference
+ * that with a printf "%s" instead of saving the string in the ring buffer
+ * and wasting space and time.
+ *
+ * The problem with the above approach is that userspace tools that read
+ * the binary output of the trace buffers do not have access to the string.
+ * Instead they just show the address of the string which is not very
+ * useful to users.
+ *
+ * With tracepoint_string(), the string will be registered to the tracing
+ * system and exported to userspace via the debugfs/tracing/printk_formats
+ * file that maps the string address to the string text. This way userspace
+ * tools that read the binary buffers have a way to map the pointers to
+ * the ASCII strings they represent.
+ *
+ * The @str used must be a constant string and persistent as it would not
+ * make sense to show a string that no longer exists. But it is still fine
+ * to be used with modules, because when modules are unloaded, if they
+ * had tracepoints, the ring buffers are cleared too. As long as the string
+ * does not change during the life of the module, it is fine to use
+ * tracepoint_string() within a module.
+ */
+#define tracepoint_string(str)						\
+	({								\
+		static const char *___tp_str __tracepoint_string = str; \
+		___tp_str;						\
+	})
+#define __tracepoint_string	__attribute__((section("__tracepoint_str")))
+#else
+/*
+ * tracepoint_string() is used to save the string address for userspace
+ * tracing tools. When tracing isn't configured, there's no need to save
+ * anything.
+ */
+# define tracepoint_string(str) str
+# define __tracepoint_string
+#endif
+
 /*
  * The need for the DECLARE_TRACE_NOARGS() is to handle the prototype
  * (void). "void" is a special value in a function prototype and can

commit 7c65bbc7dcface00b295bbd18bce82fe1db3d633
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Tue May 6 09:26:30 2014 -0400

    tracing: Add trace_<tracepoint>_enabled() function
    
    There are some code paths in the kernel that need to do some preparations
    before it calls a tracepoint. As that code is worthless overhead when
    the tracepoint is not enabled, it would be prudent to have that code
    only run when the tracepoint is active. To accomplish this, all tracepoints
    now get a static inline function called "trace_<tracepoint-name>_enabled()"
    which returns true when the tracepoint is enabled and false otherwise.
    
    As an added bonus, that function uses the static_key of the tracepoint
    such that no branch is needed.
    
      if (trace_mytracepoint_enabled()) {
            arg = process_tp_arg();
            trace_mytracepoint(arg);
      }
    
    Will keep the "process_tp_arg()" (which may be expensive to run) from
    being executed when the tracepoint isn't enabled.
    
    It's best to encapsulate the tracepoint itself in the if statement
    just to keep races. For example, if you had:
    
      if (trace_mytracepoint_enabled())
            arg = process_tp_arg();
      trace_mytracepoint(arg);
    
    There's a chance that the tracepoint could be enabled just after the
    if statement, and arg will be undefined when calling the tracepoint.
    
    Link: http://lkml.kernel.org/r/20140506094407.507b6435@gandalf.local.home
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 9d30ee469c2a..2e2a5f7717e5 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -185,6 +185,11 @@ extern void syscall_unregfunc(void);
 	static inline void						\
 	check_trace_callback_type_##name(void (*cb)(data_proto))	\
 	{								\
+	}								\
+	static inline bool						\
+	trace_##name##_enabled(void)					\
+	{								\
+		return static_key_false(&__tracepoint_##name.key);	\
 	}
 
 /*
@@ -230,6 +235,11 @@ extern void syscall_unregfunc(void);
 	}								\
 	static inline void check_trace_callback_type_##name(void (*cb)(data_proto)) \
 	{								\
+	}								\
+	static inline bool						\
+	trace_##name##_enabled(void)					\
+	{								\
+		return false;						\
 	}
 
 #define DEFINE_TRACE_FN(name, reg, unreg)

commit b725dfea24b89de672c055b34b22398283a3f4bc
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Wed Apr 9 09:24:43 2014 -0400

    tracepoint: Fix sparse warnings in tracepoint.c
    
    Fix the following sparse warnings:
    
      CHECK   kernel/tracepoint.c
    kernel/tracepoint.c:184:18: warning: incorrect type in assignment (different address spaces)
    kernel/tracepoint.c:184:18:    expected struct tracepoint_func *tp_funcs
    kernel/tracepoint.c:184:18:    got struct tracepoint_func [noderef] <asn:4>*funcs
    kernel/tracepoint.c:216:18: warning: incorrect type in assignment (different address spaces)
    kernel/tracepoint.c:216:18:    expected struct tracepoint_func *tp_funcs
    kernel/tracepoint.c:216:18:    got struct tracepoint_func [noderef] <asn:4>*funcs
    kernel/tracepoint.c:392:24: error: return expression in void function
      CC      kernel/tracepoint.o
    kernel/tracepoint.c: In function tracepoint_module_going:
    kernel/tracepoint.c:491:6: warning: symbol 'syscall_regfunc' was not declared. Should it be static?
    kernel/tracepoint.c:508:6: warning: symbol 'syscall_unregfunc' was not declared. Should it be static?
    
    Link: http://lkml.kernel.org/r/1397049883-28692-1-git-send-email-mathieu.desnoyers@efficios.com
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 69a298b07357..9d30ee469c2a 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -80,6 +80,11 @@ static inline void tracepoint_synchronize_unregister(void)
 	synchronize_sched();
 }
 
+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
+extern void syscall_regfunc(void);
+extern void syscall_unregfunc(void);
+#endif /* CONFIG_HAVE_SYSCALL_TRACEPOINTS */
+
 #define PARAMS(args...) args
 
 #endif /* _LINUX_TRACEPOINT_H */

commit eb7d035c59431bb12e1aa6e69ddd3940352faddb
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Tue Apr 8 20:09:40 2014 -0400

    tracepoint: Simplify tracepoint module search
    
    Instead of copying the num_tracepoints and tracepoints_ptrs from
    the module structure to the tp_mod structure, which only uses it to
    find the module associated to tracepoints of modules that are coming
    and going, simply copy the pointer to the module struct to the tracepoint
    tp_module structure.
    
    Also removed un-needed brackets around an if statement.
    
    Link: http://lkml.kernel.org/r/20140408201705.4dad2c4a@gandalf.local.home
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 08150e265761..69a298b07357 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -47,8 +47,7 @@ for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),
 #ifdef CONFIG_MODULES
 struct tp_module {
 	struct list_head list;
-	unsigned int num_tracepoints;
-	struct tracepoint * const *tracepoints_ptrs;
+	struct module *mod;
 };
 
 bool trace_module_has_bad_taint(struct module *mod);

commit de7b2973903c6cc50b31ee5682a69b2219b9919d
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Tue Apr 8 17:26:21 2014 -0400

    tracepoint: Use struct pointer instead of name hash for reg/unreg tracepoints
    
    Register/unregister tracepoint probes with struct tracepoint pointer
    rather than tracepoint name.
    
    This change, which vastly simplifies tracepoint.c, has been proposed by
    Steven Rostedt. It also removes 8.8kB (mostly of text) to the vmlinux
    size.
    
    From this point on, the tracers need to pass a struct tracepoint pointer
    to probe register/unregister. A probe can now only be connected to a
    tracepoint that exists. Moreover, tracers are responsible for
    unregistering the probe before the module containing its associated
    tracepoint is unloaded.
    
       text    data     bss     dec     hex filename
    10443444        4282528 10391552        25117524        17f4354 vmlinux.orig
    10434930        4282848 10391552        25109330        17f2352 vmlinux
    
    Link: http://lkml.kernel.org/r/1396992381-23785-2-git-send-email-mathieu.desnoyers@efficios.com
    
    CC: Ingo Molnar <mingo@kernel.org>
    CC: Frederic Weisbecker <fweisbec@gmail.com>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Frank Ch. Eigler <fche@redhat.com>
    CC: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    [ SDR - fixed return val in void func in tracepoint_module_going() ]
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 812b2553dfd8..08150e265761 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -6,7 +6,7 @@
  *
  * See Documentation/trace/tracepoints.txt.
  *
- * (C) Copyright 2008 Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ * Copyright (C) 2008-2014 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
  *
  * Heavily inspired from the Linux Kernel Markers.
  *
@@ -21,6 +21,7 @@
 
 struct module;
 struct tracepoint;
+struct notifier_block;
 
 struct tracepoint_func {
 	void *func;
@@ -35,18 +36,13 @@ struct tracepoint {
 	struct tracepoint_func __rcu *funcs;
 };
 
-/*
- * Connect a probe to a tracepoint.
- * Internal API, should not be used directly.
- */
-extern int tracepoint_probe_register(const char *name, void *probe, void *data);
-
-/*
- * Disconnect a probe from a tracepoint.
- * Internal API, should not be used directly.
- */
 extern int
-tracepoint_probe_unregister(const char *name, void *probe, void *data);
+tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data);
+extern int
+tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data);
+extern void
+for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),
+		void *priv);
 
 #ifdef CONFIG_MODULES
 struct tp_module {
@@ -54,12 +50,25 @@ struct tp_module {
 	unsigned int num_tracepoints;
 	struct tracepoint * const *tracepoints_ptrs;
 };
+
 bool trace_module_has_bad_taint(struct module *mod);
+extern int register_tracepoint_module_notifier(struct notifier_block *nb);
+extern int unregister_tracepoint_module_notifier(struct notifier_block *nb);
 #else
 static inline bool trace_module_has_bad_taint(struct module *mod)
 {
 	return false;
 }
+static inline
+int register_tracepoint_module_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline
+int unregister_tracepoint_module_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
 #endif /* CONFIG_MODULES */
 
 /*
@@ -160,14 +169,14 @@ static inline void tracepoint_synchronize_unregister(void)
 	static inline int						\
 	register_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\
-		return tracepoint_probe_register(#name, (void *)probe,	\
-						 data);			\
+		return tracepoint_probe_register(&__tracepoint_##name,	\
+						(void *)probe, data);	\
 	}								\
 	static inline int						\
 	unregister_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\
-		return tracepoint_probe_unregister(#name, (void *)probe, \
-						   data);		\
+		return tracepoint_probe_unregister(&__tracepoint_##name,\
+						(void *)probe, data);	\
 	}								\
 	static inline void						\
 	check_trace_callback_type_##name(void (*cb)(data_proto))	\

commit 68114e5eb862ad0a7a261b91497281b026102715
Merge: 59ecc26004e7 3862807880ac
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 3 10:26:31 2014 -0700

    Merge tag 'trace-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace
    
    Pull tracing updates from Steven Rostedt:
     "Most of the changes were largely clean ups, and some documentation.
      But there were a few features that were added:
    
      Uprobes now work with event triggers and multi buffers and have
      support under ftrace and perf.
    
      The big feature is that the function tracer can now be used within the
      multi buffer instances.  That is, you can now trace some functions in
      one buffer, others in another buffer, all functions in a third buffer
      and so on.  They are basically agnostic from each other.  This only
      works for the function tracer and not for the function graph trace,
      although you can have the function graph tracer running in the top
      level buffer (or any tracer for that matter) and have different
      function tracing going on in the sub buffers"
    
    * tag 'trace-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace: (45 commits)
      tracing: Add BUG_ON when stack end location is over written
      tracepoint: Remove unused API functions
      Revert "tracing: Move event storage for array from macro to standalone function"
      ftrace: Constify ftrace_text_reserved
      tracepoints: API doc update to tracepoint_probe_register() return value
      tracepoints: API doc update to data argument
      ftrace: Fix compilation warning about control_ops_free
      ftrace/x86: BUG when ftrace recovery fails
      ftrace: Warn on error when modifying ftrace function
      ftrace: Remove freelist from struct dyn_ftrace
      ftrace: Do not pass data to ftrace_dyn_arch_init
      ftrace: Pass retval through return in ftrace_dyn_arch_init()
      ftrace: Inline the code from ftrace_dyn_table_alloc()
      ftrace: Cleanup of global variables ftrace_new_pgs and ftrace_update_cnt
      tracing: Evaluate len expression only once in __dynamic_array macro
      tracing: Correctly expand len expressions from __dynamic_array macro
      tracing/module: Replace include of tracepoint.h with jump_label.h in module.h
      tracing: Fix event header migrate.h to include tracepoint.h
      tracing: Fix event header writeback.h to include tracepoint.h
      tracing: Warn if a tracepoint is not set via debugfs
      ...

commit 0dea6d52638b2693b18cd2ed8938b236e0789ddb
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Fri Mar 21 01:19:01 2014 -0400

    tracepoint: Remove unused API functions
    
    After the following commit:
    
    commit b75ef8b44b1cb95f5a26484b0e2fe37a63b12b44
    Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Date:   Wed Aug 10 15:18:39 2011 -0400
    
        Tracepoint: Dissociate from module mutex
    
    The following functions became unnecessary:
    
    - tracepoint_probe_register_noupdate,
    - tracepoint_probe_unregister_noupdate,
    - tracepoint_probe_update_all.
    
    In fact, none of the in-kernel tracers, nor LTTng, nor SystemTAP use
    them. Remove those.
    
    Moreover, the functions:
    
    - tracepoint_iter_start,
    - tracepoint_iter_next,
    - tracepoint_iter_stop,
    - tracepoint_iter_reset.
    
    are unused by in-kernel tracers, LTTng and SystemTAP. Remove those too.
    
    Link: http://lkml.kernel.org/r/1395379142-2118-2-git-send-email-mathieu.desnoyers@efficios.com
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index accc497f8d72..a3b2837d8dd1 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -48,12 +48,6 @@ extern int tracepoint_probe_register(const char *name, void *probe, void *data);
 extern int
 tracepoint_probe_unregister(const char *name, void *probe, void *data);
 
-extern int tracepoint_probe_register_noupdate(const char *name, void *probe,
-					      void *data);
-extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe,
-						void *data);
-extern void tracepoint_probe_update_all(void);
-
 #ifdef CONFIG_MODULES
 struct tp_module {
 	struct list_head list;
@@ -62,18 +56,6 @@ struct tp_module {
 };
 #endif /* CONFIG_MODULES */
 
-struct tracepoint_iter {
-#ifdef CONFIG_MODULES
-	struct tp_module *module;
-#endif /* CONFIG_MODULES */
-	struct tracepoint * const *tracepoint;
-};
-
-extern void tracepoint_iter_start(struct tracepoint_iter *iter);
-extern void tracepoint_iter_next(struct tracepoint_iter *iter);
-extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
-extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
-
 /*
  * tracepoint_synchronize_unregister must be called between the last tracepoint
  * probe unregistration and the end of module exit to make sure there is no

commit 45ab2813d40d88fc575e753c38478de242d03f88
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Wed Feb 26 13:37:38 2014 -0500

    tracing: Do not add event files for modules that fail tracepoints
    
    If a module fails to add its tracepoints due to module tainting, do not
    create the module event infrastructure in the debugfs directory. As the events
    will not work and worse yet, they will silently fail, making the user wonder
    why the events they enable do not display anything.
    
    Having a warning on module load and the events not visible to the users
    will make the cause of the problem much clearer.
    
    Link: http://lkml.kernel.org/r/20140227154923.265882695@goodmis.org
    
    Fixes: 6d723736e472 "tracing/events: add support for modules to TRACE_EVENT"
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: stable@vger.kernel.org # 2.6.31+
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index accc497f8d72..7159a0a933df 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -60,6 +60,12 @@ struct tp_module {
 	unsigned int num_tracepoints;
 	struct tracepoint * const *tracepoints_ptrs;
 };
+bool trace_module_has_bad_taint(struct module *mod);
+#else
+static inline bool trace_module_has_bad_taint(struct module *mod)
+{
+	return false;
+}
 #endif /* CONFIG_MODULES */
 
 struct tracepoint_iter {

commit e23c34bb41da65f354fb7eee04300c56ee48f60c
Merge: b481c2cb3534 319e2e3f63c3
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Dec 19 15:08:03 2013 +0100

    Merge branch 'master' into for-next
    
    Sync with Linus' tree to be able to apply fixes on top of newer things
    in tree (efi-stub).
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

commit 2621bca83a4774854234c1c1c6d8c1ca2fd5e08a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Dec 2 15:15:37 2013 +0530

    tracepoint: comment fix "binay" -> "binary"
    
    Binary was written as binay, probably by mistake. Fix it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index ebeab360d851..f0c3e4cb45a8 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -274,7 +274,7 @@ static inline void tracepoint_synchronize_unregister(void)
  * For use with the TRACE_EVENT macro:
  *
  * We define a tracepoint, its arguments, its printk format
- * and its 'fast binay record' layout.
+ * and its 'fast binary record' layout.
  *
  * Firstly, name your tracepoint via TRACE_EVENT(name : the
  * 'subsystem_event' notation is fine.

commit d5b5f391d434c5cc8bcb1ab2d759738797b85f52
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Nov 14 16:23:04 2013 +0100

    ftrace, perf: Avoid infinite event generation loop
    
    Vince's perf-trinity fuzzer found yet another 'interesting' problem.
    
    When we sample the irq_work_exit tracepoint with period==1 (or
    PERF_SAMPLE_PERIOD) and we add an fasync SIGNAL handler we create an
    infinite event generation loop:
    
      ,-> <IPI>
      |     irq_work_exit() ->
      |       trace_irq_work_exit() ->
      |         ...
      |           __perf_event_overflow() -> (due to fasync)
      |             irq_work_queue() -> (irq_work_list must be empty)
      '---------      arch_irq_work_raise()
    
    Similar things can happen due to regular poll() wakeups if we exceed
    the ring-buffer wakeup watermark, or have an event_limit.
    
    To avoid this, dis-allow sampling this particular tracepoint.
    
    In order to achieve this, create a special perf_perm function pointer
    for each event and call this (when set) on trying to create a
    tracepoint perf event.
    
    [ roasted: use expr... to allow for ',' in your expression ]
    
    Reported-by: Vince Weaver <vincent.weaver@maine.edu>
    Tested-by: Vince Weaver <vincent.weaver@maine.edu>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Link: http://lkml.kernel.org/r/20131114152304.GC5364@laptop.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index ebeab360d851..f16dc0a40049 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -267,6 +267,8 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define TRACE_EVENT_FLAGS(event, flag)
 
+#define TRACE_EVENT_PERF_PERM(event, expr...)
+
 #endif /* DECLARE_TRACE */
 
 #ifndef TRACE_EVENT
@@ -399,4 +401,6 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define TRACE_EVENT_FLAGS(event, flag)
 
+#define TRACE_EVENT_PERF_PERM(event, expr...)
+
 #endif /* ifdef TRACE_EVENT (see note above) */

commit f5abaa1bfc3dbf26d19d3513f39279ca369f8d65
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Thu Jun 20 11:44:44 2013 -0400

    tracing: Add DEFINE_EVENT_FN() macro
    
    Each TRACE_EVENT() adds several helper functions. If two or more trace events
    share the same structure and print format, they can also share most of these
    helper functions and save a lot of space from duplicate code. This is why the
    DECLARE_EVENT_CLASS() and DEFINE_EVENT() were created.
    
    Some events require a trigger to be called at registering and unregistering of
    the event and to do so they use TRACE_EVENT_FN().
    
    If multiple events require a trigger, they currently have no choice but to use
    TRACE_EVENT_FN() as there's no DEFINE_EVENT_FN() available. This unfortunately
    causes a lot of wasted duplicate code created.
    
    By adding a DEFINE_EVENT_FN(), these events can still use a
    DECLARE_EVENT_CLASS() and then define their own triggers.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/51C3236C.8030508@hds.com
    Signed-off-by: Seiji Aguchi <seiji.aguchi@hds.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index f8e084d0fc77..ebeab360d851 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -378,6 +378,8 @@ static inline void tracepoint_synchronize_unregister(void)
 #define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)
 #define DEFINE_EVENT(template, name, proto, args)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define DEFINE_EVENT_FN(template, name, proto, args, reg, unreg)\
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define DEFINE_EVENT_CONDITION(template, name, proto,		\

commit d62840995a99c9766803d54e9d7923f247a1c1db
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Wed May 22 02:41:36 2013 -0700

    trace: Allow idle-safe tracepoints to be called from irq
    
    __DECLARE_TRACE_RCU() currently creates an _rcuidle() tracepoint which
    may safely be invoked from what RCU considers to be an idle CPU.
    However, these _rcuidle() tracepoints may -not- be invoked from the
    handler of an irq taken from idle, because rcu_idle_enter() zeroes
    RCU's nesting-level counter, so that the rcu_irq_exit() returning to
    idle will trigger a WARN_ON_ONCE().
    
    This commit therefore substitutes rcu_irq_enter() for rcu_idle_exit()
    and rcu_irq_exit() for rcu_idle_enter() in order to make the _rcuidle()
    tracepoints usable from irq handlers as well as from process context.
    
    Reported-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 2f322c38bd4d..f8e084d0fc77 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -145,8 +145,8 @@ static inline void tracepoint_synchronize_unregister(void)
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
 				TP_CONDITION(cond),			\
-				rcu_idle_exit(),			\
-				rcu_idle_enter());			\
+				rcu_irq_enter(),			\
+				rcu_irq_exit());			\
 	}
 #else
 #define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)

commit 7ece55a4a3a04abe37118b1d4fb0b702eeb1de4c
Author: Josh Triplett <josh@joshtriplett.org>
Date:   Tue Sep 4 23:23:06 2012 -0700

    trace: Don't declare trace_*_rcuidle functions in modules
    
    Tracepoints declare a static inline trace_*_rcuidle variant of the trace
    function, to support safely generating trace events from the idle loop.
    Module code never actually uses that variant of trace functions, because
    modules don't run code that needs tracing with RCU idled.  However, the
    declaration of those otherwise unused functions causes the module to
    reference rcu_idle_exit and rcu_idle_enter, which RCU does not export to
    modules.
    
    To avoid this, don't generate trace_*_rcuidle functions for tracepoints
    declared in module code.
    
    Link: http://lkml.kernel.org/r/20120905062306.GA14756@leaf
    
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 802de56c41e8..2f322c38bd4d 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -136,6 +136,22 @@ static inline void tracepoint_synchronize_unregister(void)
 		postrcu;						\
 	} while (0)
 
+#ifndef MODULE
+#define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)	\
+	static inline void trace_##name##_rcuidle(proto)		\
+	{								\
+		if (static_key_false(&__tracepoint_##name.key))		\
+			__DO_TRACE(&__tracepoint_##name,		\
+				TP_PROTO(data_proto),			\
+				TP_ARGS(data_args),			\
+				TP_CONDITION(cond),			\
+				rcu_idle_exit(),			\
+				rcu_idle_enter());			\
+	}
+#else
+#define __DECLARE_TRACE_RCU(name, proto, args, cond, data_proto, data_args)
+#endif
+
 /*
  * Make sure the alignment of the structure in the __tracepoints section will
  * not add unwanted padding between the beginning of the section and the
@@ -151,16 +167,8 @@ static inline void tracepoint_synchronize_unregister(void)
 				TP_ARGS(data_args),			\
 				TP_CONDITION(cond),,);			\
 	}								\
-	static inline void trace_##name##_rcuidle(proto)		\
-	{								\
-		if (static_key_false(&__tracepoint_##name.key))		\
-			__DO_TRACE(&__tracepoint_##name,		\
-				TP_PROTO(data_proto),			\
-				TP_ARGS(data_args),			\
-				TP_CONDITION(cond),			\
-				rcu_idle_exit(),			\
-				rcu_idle_enter());			\
-	}								\
+	__DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),		\
+		PARAMS(cond), PARAMS(data_proto), PARAMS(data_args))	\
 	static inline int						\
 	register_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\

commit 326f418b4c74ab4a6066f38b6144bc6461f9447b
Author: Jason Baron <jbaron@redhat.com>
Date:   Thu Jun 28 15:04:57 2012 -0400

    tracepoint: Use static_key_false(), since static_branch() is deprecated
    
    Convert the last user of static_branch() -> static_key_false().
    
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Cc: rostedt@goodmis.org
    Cc: mathieu.desnoyers@efficios.com
    Cc: a.p.zijlstra@chello.nl
    Link: http://lkml.kernel.org/r/5fffcd40a6c063769badcdd74a7d90980500dbcb.1340909155.git.jbaron@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index bd96ecd0e05c..802de56c41e8 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -153,7 +153,7 @@ static inline void tracepoint_synchronize_unregister(void)
 	}								\
 	static inline void trace_##name##_rcuidle(proto)		\
 	{								\
-		if (static_branch(&__tracepoint_##name.key))		\
+		if (static_key_false(&__tracepoint_##name.key))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\

commit c5905afb0ee6550b42c49213da1c22d67316c194
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Feb 24 08:31:31 2012 +0100

    static keys: Introduce 'struct static_key', static_key_true()/false() and static_key_slow_[inc|dec]()
    
    So here's a boot tested patch on top of Jason's series that does
    all the cleanups I talked about and turns jump labels into a
    more intuitive to use facility. It should also address the
    various misconceptions and confusions that surround jump labels.
    
    Typical usage scenarios:
    
            #include <linux/static_key.h>
    
            struct static_key key = STATIC_KEY_INIT_TRUE;
    
            if (static_key_false(&key))
                    do unlikely code
            else
                    do likely code
    
    Or:
    
            if (static_key_true(&key))
                    do likely code
            else
                    do unlikely code
    
    The static key is modified via:
    
            static_key_slow_inc(&key);
            ...
            static_key_slow_dec(&key);
    
    The 'slow' prefix makes it abundantly clear that this is an
    expensive operation.
    
    I've updated all in-kernel code to use this everywhere. Note
    that I (intentionally) have not pushed through the rename
    blindly through to the lowest levels: the actual jump-label
    patching arch facility should be named like that, so we want to
    decouple jump labels from the static-key facility a bit.
    
    On non-jump-label enabled architectures static keys default to
    likely()/unlikely() branches.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jason Baron <jbaron@redhat.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: a.p.zijlstra@chello.nl
    Cc: mathieu.desnoyers@efficios.com
    Cc: davem@davemloft.net
    Cc: ddaney.cavm@gmail.com
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20120222085809.GA26397@elte.hu
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index fc36da97ff7e..bd96ecd0e05c 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -17,7 +17,7 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
-#include <linux/jump_label.h>
+#include <linux/static_key.h>
 
 struct module;
 struct tracepoint;
@@ -29,7 +29,7 @@ struct tracepoint_func {
 
 struct tracepoint {
 	const char *name;		/* Tracepoint name */
-	struct jump_label_key key;
+	struct static_key key;
 	void (*regfunc)(void);
 	void (*unregfunc)(void);
 	struct tracepoint_func __rcu *funcs;
@@ -145,7 +145,7 @@ static inline void tracepoint_synchronize_unregister(void)
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
-		if (static_branch(&__tracepoint_##name.key))		\
+		if (static_key_false(&__tracepoint_##name.key))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
@@ -188,7 +188,7 @@ static inline void tracepoint_synchronize_unregister(void)
 	__attribute__((section("__tracepoints_strings"))) = #name;	 \
 	struct tracepoint __tracepoint_##name				 \
 	__attribute__((section("__tracepoints"))) =			 \
-		{ __tpstrtab_##name, JUMP_LABEL_INIT, reg, unreg, NULL };\
+		{ __tpstrtab_##name, STATIC_KEY_INIT_FALSE, reg, unreg, NULL };\
 	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
 	__attribute__((section("__tracepoints_ptrs"))) =		 \
 		&__tracepoint_##name;

commit 2fbb90db1b8fcc78f43830f1a009f3af243c5f42
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Feb 7 09:32:43 2012 -0500

    tracing/rcu: Add trace_##name##__rcuidle() static tracepoint for inside rcu_idle_exit() sections
    
    Added is a new static inline function that lets *any* tracepoint be used
    inside a rcu_idle_exit() section. And this also solves the problem where
    the same tracepoint may be used inside a rcu_idle_exit() section as well
    as outside of one.
    
    I added a new tracepoint function with a "_rcuidle" extension. All
    tracepoints can be used with either the normal "trace_foobar()"
    function, or the "trace_foobar_rcuidle()" function when inside a
    rcu_idle_exit() section.
    
    All tracepoints defined by TRACE_EVENT() or any of the derivatives
    will have a "_rcuidle()" function also defined. When a tracepoint is
    used within an rcu_idle_exit() section, the "_rcuidle()" version must
    be used. This denotes that the tracepoint is within rcu_idle_exit()
    and it allows the rcu read locks within the tracepoint to still
    be valid, as this version takes us out of rcu_idle_exit().
    
    Another nice aspect about this patch is that "static inline"s are not
    compiled into text when not used. So only the tracepoints that actually
    use the _rcuidle() version will have them defined in the actual text
    that is booted.
    
    Link: http://lkml.kernel.org/r/1328563113.2200.39.camel@gandalf.stny.rr.com>
    
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index df0a779c1bbd..fc36da97ff7e 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -114,7 +114,7 @@ static inline void tracepoint_synchronize_unregister(void)
  * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
  * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
  */
-#define __DO_TRACE(tp, proto, args, cond)				\
+#define __DO_TRACE(tp, proto, args, cond, prercu, postrcu)		\
 	do {								\
 		struct tracepoint_func *it_func_ptr;			\
 		void *it_func;						\
@@ -122,6 +122,7 @@ static inline void tracepoint_synchronize_unregister(void)
 									\
 		if (!(cond))						\
 			return;						\
+		prercu;							\
 		rcu_read_lock_sched_notrace();				\
 		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
 		if (it_func_ptr) {					\
@@ -132,6 +133,7 @@ static inline void tracepoint_synchronize_unregister(void)
 			} while ((++it_func_ptr)->func);		\
 		}							\
 		rcu_read_unlock_sched_notrace();			\
+		postrcu;						\
 	} while (0)
 
 /*
@@ -139,7 +141,7 @@ static inline void tracepoint_synchronize_unregister(void)
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
  */
-#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args)	\
+#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
@@ -147,7 +149,17 @@ static inline void tracepoint_synchronize_unregister(void)
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
-				TP_CONDITION(cond));			\
+				TP_CONDITION(cond),,);			\
+	}								\
+	static inline void trace_##name##_rcuidle(proto)		\
+	{								\
+		if (static_branch(&__tracepoint_##name.key))		\
+			__DO_TRACE(&__tracepoint_##name,		\
+				TP_PROTO(data_proto),			\
+				TP_ARGS(data_args),			\
+				TP_CONDITION(cond),			\
+				rcu_idle_exit(),			\
+				rcu_idle_enter());			\
 	}								\
 	static inline int						\
 	register_trace_##name(void (*probe)(data_proto), void *data)	\
@@ -190,9 +202,11 @@ static inline void tracepoint_synchronize_unregister(void)
 	EXPORT_SYMBOL(__tracepoint_##name)
 
 #else /* !CONFIG_TRACEPOINTS */
-#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args)	\
+#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	static inline void trace_##name(proto)				\
 	{ }								\
+	static inline void trace_##name##_rcuidle(proto)		\
+	{ }								\
 	static inline int						\
 	register_trace_##name(void (*probe)(data_proto),		\
 			      void *data)				\

commit b75ef8b44b1cb95f5a26484b0e2fe37a63b12b44
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Wed Aug 10 15:18:39 2011 -0400

    Tracepoint: Dissociate from module mutex
    
    Copy the information needed from struct module into a local module list
    held within tracepoint.c from within the module coming/going notifier.
    
    This vastly simplifies locking of tracepoint registration /
    unregistration, because we don't have to take the module mutex to
    register and unregister tracepoints anymore. Steven Rostedt ran into
    dependency problems related to modules mutex vs kprobes mutex vs ftrace
    mutex vs tracepoint mutex that seems to be hard to fix without removing
    this dependency between tracepoint and module mutex. (note: it should be
    investigated whether kprobes could benefit of being dissociated from the
    modules mutex too.)
    
    This also fixes module handling of tracepoint list iterators, because it
    was expecting the list to be sorted by pointer address. Given we have
    control on our own list now, it's OK to sort this list which has
    tracepoints as its only purpose. The reason why this sorting is required
    is to handle the fact that seq files (and any read() operation from
    user-space) cannot hold the tracepoint mutex across multiple calls, so
    list entries may vanish between calls. With sorting, the tracepoint
    iterator becomes usable even if the list don't contain the exact item
    pointed to by the iterator anymore.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Jason Baron <jbaron@redhat.com>
    CC: Ingo Molnar <mingo@elte.hu>
    CC: Lai Jiangshan <laijs@cn.fujitsu.com>
    CC: Peter Zijlstra <a.p.zijlstra@chello.nl>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Link: http://lkml.kernel.org/r/20110810191839.GC8525@Krystal
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index d530a4460a0b..df0a779c1bbd 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -54,8 +54,18 @@ extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe,
 						void *data);
 extern void tracepoint_probe_update_all(void);
 
+#ifdef CONFIG_MODULES
+struct tp_module {
+	struct list_head list;
+	unsigned int num_tracepoints;
+	struct tracepoint * const *tracepoints_ptrs;
+};
+#endif /* CONFIG_MODULES */
+
 struct tracepoint_iter {
-	struct module *module;
+#ifdef CONFIG_MODULES
+	struct tp_module *module;
+#endif /* CONFIG_MODULES */
 	struct tracepoint * const *tracepoint;
 };
 
@@ -63,8 +73,6 @@ extern void tracepoint_iter_start(struct tracepoint_iter *iter);
 extern void tracepoint_iter_next(struct tracepoint_iter *iter);
 extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
 extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
-extern int tracepoint_get_iter_range(struct tracepoint * const **tracepoint,
-	struct tracepoint * const *begin, struct tracepoint * const *end);
 
 /*
  * tracepoint_synchronize_unregister must be called between the last tracepoint
@@ -78,17 +86,6 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define PARAMS(args...) args
 
-#ifdef CONFIG_TRACEPOINTS
-extern
-void tracepoint_update_probe_range(struct tracepoint * const *begin,
-	struct tracepoint * const *end);
-#else
-static inline
-void tracepoint_update_probe_range(struct tracepoint * const *begin,
-	struct tracepoint * const *end)
-{ }
-#endif /* CONFIG_TRACEPOINTS */
-
 #endif /* _LINUX_TRACEPOINT_H */
 
 /*

commit d430d3d7e646eb1eac2bb4aa244a644312e67c76
Author: Jason Baron <jbaron@redhat.com>
Date:   Wed Mar 16 17:29:47 2011 -0400

    jump label: Introduce static_branch() interface
    
    Introduce:
    
    static __always_inline bool static_branch(struct jump_label_key *key);
    
    instead of the old JUMP_LABEL(key, label) macro.
    
    In this way, jump labels become really easy to use:
    
    Define:
    
            struct jump_label_key jump_key;
    
    Can be used as:
    
            if (static_branch(&jump_key))
                    do unlikely code
    
    enable/disale via:
    
            jump_label_inc(&jump_key);
            jump_label_dec(&jump_key);
    
    that's it!
    
    For the jump labels disabled case, the static_branch() becomes an
    atomic_read(), and jump_label_inc()/dec() are simply atomic_inc(),
    atomic_dec() operations. We show testing results for this change below.
    
    Thanks to H. Peter Anvin for suggesting the 'static_branch()' construct.
    
    Since we now require a 'struct jump_label_key *key', we can store a pointer into
    the jump table addresses. In this way, we can enable/disable jump labels, in
    basically constant time. This change allows us to completely remove the previous
    hashtable scheme. Thanks to Peter Zijlstra for this re-write.
    
    Testing:
    
    I ran a series of 'tbench 20' runs 5 times (with reboots) for 3
    configurations, where tracepoints were disabled.
    
    jump label configured in
    avg: 815.6
    
    jump label *not* configured in (using atomic reads)
    avg: 800.1
    
    jump label *not* configured in (regular reads)
    avg: 803.4
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <20110316212947.GA8792@redhat.com>
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Suggested-by: H. Peter Anvin <hpa@linux.intel.com>
    Tested-by: David Daney <ddaney@caviumnetworks.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 97c84a58efb8..d530a4460a0b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -29,7 +29,7 @@ struct tracepoint_func {
 
 struct tracepoint {
 	const char *name;		/* Tracepoint name */
-	int state;			/* State. */
+	struct jump_label_key key;
 	void (*regfunc)(void);
 	void (*unregfunc)(void);
 	struct tracepoint_func __rcu *funcs;
@@ -146,9 +146,7 @@ void tracepoint_update_probe_range(struct tracepoint * const *begin,
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
-		JUMP_LABEL(&__tracepoint_##name.state, do_trace);	\
-		return;							\
-do_trace:								\
+		if (static_branch(&__tracepoint_##name.key))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args),			\
@@ -176,14 +174,14 @@ do_trace:								\
  * structures, so we create an array of pointers that will be used for iteration
  * on the tracepoints.
  */
-#define DEFINE_TRACE_FN(name, reg, unreg)				\
-	static const char __tpstrtab_##name[]				\
-	__attribute__((section("__tracepoints_strings"))) = #name;	\
-	struct tracepoint __tracepoint_##name				\
-	__attribute__((section("__tracepoints"))) =			\
-		{ __tpstrtab_##name, 0, reg, unreg, NULL };		\
-	static struct tracepoint * const __tracepoint_ptr_##name __used	\
-	__attribute__((section("__tracepoints_ptrs"))) =		\
+#define DEFINE_TRACE_FN(name, reg, unreg)				 \
+	static const char __tpstrtab_##name[]				 \
+	__attribute__((section("__tracepoints_strings"))) = #name;	 \
+	struct tracepoint __tracepoint_##name				 \
+	__attribute__((section("__tracepoints"))) =			 \
+		{ __tpstrtab_##name, JUMP_LABEL_INIT, reg, unreg, NULL };\
+	static struct tracepoint * const __tracepoint_ptr_##name __used	 \
+	__attribute__((section("__tracepoints_ptrs"))) =		 \
 		&__tracepoint_##name;
 
 #define DEFINE_TRACE(name)						\

commit 654986462939cd7ec18f276c6379a334dac106a7
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Wed Jan 26 17:26:22 2011 -0500

    tracepoints: Fix section alignment using pointer array
    
    Make the tracepoints more robust, making them solid enough to handle compiler
    changes by not relying on anything based on compiler-specific behavior with
    respect to structure alignment. Implement an approach proposed by David Miller:
    use an array of const pointers to refer to the individual structures, and export
    this pointer array through the linker script rather than the structures per se.
    It will consume 32 extra bytes per tracepoint (24 for structure padding and 8
    for the pointers), but are less likely to break due to compiler changes.
    
    History:
    
    commit 7e066fb8 tracepoints: add DECLARE_TRACE() and DEFINE_TRACE()
    added the aligned(32) type and variable attribute to the tracepoint structures
    to deal with gcc happily aligning statically defined structures on 32-byte
    multiples.
    
    One attempt was to use a 8-byte alignment for tracepoint structures by applying
    both the variable and type attribute to tracepoint structures definitions and
    declarations. It worked fine with gcc 4.5.1, but broke with gcc 4.4.4 and 4.4.5.
    
    The reason is that the "aligned" attribute only specify the _minimum_ alignment
    for a structure, leaving both the compiler and the linker free to align on
    larger multiples. Because tracepoint.c expects the structures to be placed as an
    array within each section, up-alignment cause NULL-pointer exceptions due to the
    extra unexpected padding.
    
    (this patch applies on top of -tip)
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    LKML-Reference: <20110126222622.GA10794@Krystal>
    CC: Frederic Weisbecker <fweisbec@gmail.com>
    CC: Ingo Molnar <mingo@elte.hu>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Peter Zijlstra <peterz@infradead.org>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c6814616653b..97c84a58efb8 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -33,12 +33,7 @@ struct tracepoint {
 	void (*regfunc)(void);
 	void (*unregfunc)(void);
 	struct tracepoint_func __rcu *funcs;
-} __attribute__((aligned(32)));		/*
-					 * Aligned on 32 bytes because it is
-					 * globally visible and gcc happily
-					 * align these on the structure size.
-					 * Keep in sync with vmlinux.lds.h.
-					 */
+};
 
 /*
  * Connect a probe to a tracepoint.
@@ -61,15 +56,15 @@ extern void tracepoint_probe_update_all(void);
 
 struct tracepoint_iter {
 	struct module *module;
-	struct tracepoint *tracepoint;
+	struct tracepoint * const *tracepoint;
 };
 
 extern void tracepoint_iter_start(struct tracepoint_iter *iter);
 extern void tracepoint_iter_next(struct tracepoint_iter *iter);
 extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
 extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
-extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
-	struct tracepoint *begin, struct tracepoint *end);
+extern int tracepoint_get_iter_range(struct tracepoint * const **tracepoint,
+	struct tracepoint * const *begin, struct tracepoint * const *end);
 
 /*
  * tracepoint_synchronize_unregister must be called between the last tracepoint
@@ -84,11 +79,13 @@ static inline void tracepoint_synchronize_unregister(void)
 #define PARAMS(args...) args
 
 #ifdef CONFIG_TRACEPOINTS
-extern void tracepoint_update_probe_range(struct tracepoint *begin,
-	struct tracepoint *end);
+extern
+void tracepoint_update_probe_range(struct tracepoint * const *begin,
+	struct tracepoint * const *end);
 #else
-static inline void tracepoint_update_probe_range(struct tracepoint *begin,
-	struct tracepoint *end)
+static inline
+void tracepoint_update_probe_range(struct tracepoint * const *begin,
+	struct tracepoint * const *end)
 { }
 #endif /* CONFIG_TRACEPOINTS */
 
@@ -174,12 +171,20 @@ do_trace:								\
 	{								\
 	}
 
+/*
+ * We have no guarantee that gcc and the linker won't up-align the tracepoint
+ * structures, so we create an array of pointers that will be used for iteration
+ * on the tracepoints.
+ */
 #define DEFINE_TRACE_FN(name, reg, unreg)				\
 	static const char __tpstrtab_##name[]				\
 	__attribute__((section("__tracepoints_strings"))) = #name;	\
 	struct tracepoint __tracepoint_##name				\
-	__attribute__((section("__tracepoints"), aligned(32))) =	\
-		{ __tpstrtab_##name, 0, reg, unreg, NULL }
+	__attribute__((section("__tracepoints"))) =			\
+		{ __tpstrtab_##name, 0, reg, unreg, NULL };		\
+	static struct tracepoint * const __tracepoint_ptr_##name __used	\
+	__attribute__((section("__tracepoints_ptrs"))) =		\
+		&__tracepoint_##name;
 
 #define DEFINE_TRACE(name)						\
 	DEFINE_TRACE_FN(name, NULL, NULL);

commit bd1c8b22b7b81c6f6c4f5c19cb2387da3d02fb0f
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Tue Jan 4 16:06:09 2011 +0800

    tracepoint: Add __rcu annotation
    
    Add __rcu annotation to :
            (struct tracepoint)->funcs
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    LKML-Reference: <4D22D4F1.50505@cn.fujitsu.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 899103c8f6f2..c6814616653b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -32,7 +32,7 @@ struct tracepoint {
 	int state;			/* State. */
 	void (*regfunc)(void);
 	void (*unregfunc)(void);
-	struct tracepoint_func *funcs;
+	struct tracepoint_func __rcu *funcs;
 } __attribute__((aligned(32)));		/*
 					 * Aligned on 32 bytes because it is
 					 * globally visible and gcc happily

commit ec6e7c3ae39cb1dc279b5274aaaadd09ff8e224b
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Thu Jan 6 13:45:32 2011 -0500

    tracing/trivial: Add missing comma in TRACE_EVENT comment
    
    Add missing comma within the TRACE_EVENT() example in tracepoint.h.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    LKML-Reference: <20110106184532.GA2526@Krystal>
    CC: Frederic Weisbecker <fweisbec@gmail.com>
    CC: Ingo Molnar <mingo@elte.hu>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index d3e4f87e95c0..899103c8f6f2 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -326,7 +326,7 @@ do_trace:								\
  *		memcpy(__entry->prev_comm, prev->comm, TASK_COMM_LEN);
  *		__entry->next_pid	= next->pid;
  *		__entry->next_prio	= next->prio;
- *	)
+ *	),
  *
  *	*
  *	* Formatted output of a trace record via TP_printk().

commit 287050d390264402e11bea8b811859e42e8faa29
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Thu Dec 2 16:46:18 2010 -0500

    tracing: Add TRACE_EVENT_CONDITIONAL()
    
    There are instances in the kernel that we only want to trace
    a tracepoint when a certain condition is set. But we do not
    want to test for that condition in the core kernel.
    If we test for that condition before calling the tracepoin, then
    we will be performing that test even when tracing is not enabled.
    This is 99.99% of the time.
    
    We currently can just filter out on that condition, but that happens
    after we write to the trace buffer. We just wasted time writing to
    the ring buffer for an event we never cared about.
    
    This patch adds:
    
       TRACE_EVENT_CONDITION() and DEFINE_EVENT_CONDITION()
    
    These have a new TP_CONDITION() argument that comes right after
    the TP_ARGS().  This condition can use the parameters of TP_ARGS()
    in the TRACE_EVENT() to determine if the tracepoint should be traced
    or not. The TP_CONDITION() will be placed in a if (cond) trace;
    
    For example, for the tracepoint sched_wakeup, it is useless to
    trace a wakeup event where the caller never actually wakes
    anything up (where success == 0). So adding:
    
            TP_CONDITION(success),
    
    which uses the "success" parameter of the wakeup tracepoint
    will have it only trace when we have successfully woken up a
    task.
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 5a6074fcd81d..d3e4f87e95c0 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -106,6 +106,7 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 
 #define TP_PROTO(args...)	args
 #define TP_ARGS(args...)	args
+#define TP_CONDITION(args...)	args
 
 #ifdef CONFIG_TRACEPOINTS
 
@@ -119,12 +120,14 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
  * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
  * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
  */
-#define __DO_TRACE(tp, proto, args)					\
+#define __DO_TRACE(tp, proto, args, cond)				\
 	do {								\
 		struct tracepoint_func *it_func_ptr;			\
 		void *it_func;						\
 		void *__data;						\
 									\
+		if (!(cond))						\
+			return;						\
 		rcu_read_lock_sched_notrace();				\
 		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
 		if (it_func_ptr) {					\
@@ -142,7 +145,7 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
  */
-#define __DECLARE_TRACE(name, proto, args, data_proto, data_args)	\
+#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args)	\
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
@@ -151,7 +154,8 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 do_trace:								\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
-				TP_ARGS(data_args));			\
+				TP_ARGS(data_args),			\
+				TP_CONDITION(cond));			\
 	}								\
 	static inline int						\
 	register_trace_##name(void (*probe)(data_proto), void *data)	\
@@ -186,7 +190,7 @@ do_trace:								\
 	EXPORT_SYMBOL(__tracepoint_##name)
 
 #else /* !CONFIG_TRACEPOINTS */
-#define __DECLARE_TRACE(name, proto, args, data_proto, data_args)	\
+#define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args)	\
 	static inline void trace_##name(proto)				\
 	{ }								\
 	static inline int						\
@@ -227,13 +231,18 @@ do_trace:								\
  * "void *__data, proto" as the callback prototype.
  */
 #define DECLARE_TRACE_NOARGS(name)					\
-		__DECLARE_TRACE(name, void, , void *__data, __data)
+		__DECLARE_TRACE(name, void, , 1, void *__data, __data)
 
 #define DECLARE_TRACE(name, proto, args)				\
-		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),	\
+		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), 1,	\
 				PARAMS(void *__data, proto),		\
 				PARAMS(__data, args))
 
+#define DECLARE_TRACE_CONDITION(name, proto, args, cond)		\
+	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), PARAMS(cond), \
+			PARAMS(void *__data, proto),			\
+			PARAMS(__data, args))
+
 #define TRACE_EVENT_FLAGS(event, flag)
 
 #endif /* DECLARE_TRACE */
@@ -349,12 +358,20 @@ do_trace:								\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define DEFINE_EVENT_CONDITION(template, name, proto,		\
+			       args, cond)			\
+	DECLARE_TRACE_CONDITION(name, PARAMS(proto),		\
+				PARAMS(args), PARAMS(cond))
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define TRACE_EVENT_FN(name, proto, args, struct,		\
 		assign, print, reg, unreg)			\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define TRACE_EVENT_CONDITION(name, proto, args, cond,		\
+			      struct, assign, print)		\
+	DECLARE_TRACE_CONDITION(name, PARAMS(proto),		\
+				PARAMS(args), PARAMS(cond))
 
 #define TRACE_EVENT_FLAGS(event, flag)
 

commit 1ed0c5971159974185653170543a764cc061c857
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Nov 18 01:46:57 2010 +0100

    tracing: New macro to set up initial event flags value
    
    This introduces the new TRACE_EVENT_FLAGS() macro in order
    to set up initial event flags value.
    
    This macro must simply follow the definition of a trace event
    and take the event name and the flag value as parameters:
    
    TRACE_EVENT(my_event, .....
    ....
    );
    
    TRACE_EVENT_FLAGS(my_event, 1)
    
    This will set up 1 as the initial my_event->flags value.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Jason Baron <jbaron@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index a4a90b6726ce..5a6074fcd81d 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -234,6 +234,8 @@ do_trace:								\
 				PARAMS(void *__data, proto),		\
 				PARAMS(__data, args))
 
+#define TRACE_EVENT_FLAGS(event, flag)
+
 #endif /* DECLARE_TRACE */
 
 #ifndef TRACE_EVENT
@@ -354,4 +356,6 @@ do_trace:								\
 		assign, print, reg, unreg)			\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
+#define TRACE_EVENT_FLAGS(event, flag)
+
 #endif /* ifdef TRACE_EVENT (see note above) */

commit 8f7b50c514206211cc282a4247f7b12f18dee674
Author: Jason Baron <jbaron@redhat.com>
Date:   Fri Sep 17 11:09:13 2010 -0400

    jump label: Tracepoint support for jump labels
    
    Make use of the jump label infrastructure for tracepoints.
    
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    LKML-Reference: <a9ba2056e2c9cf332c3c300b577463ce66ff23a8.1284733808.git.jbaron@redhat.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 103d1b61aacb..a4a90b6726ce 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -17,6 +17,7 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
+#include <linux/jump_label.h>
 
 struct module;
 struct tracepoint;
@@ -145,7 +146,9 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
-		if (unlikely(__tracepoint_##name.state))		\
+		JUMP_LABEL(&__tracepoint_##name.state, do_trace);	\
+		return;							\
+do_trace:								\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
 				TP_ARGS(data_args));			\

commit b70e4f0529c089b00d0a6da13106db4de1ada4c7
Author: Wu Zhangjin <wuzhangjin@gmail.com>
Date:   Mon Jun 21 19:09:09 2010 +0800

    tracing: Fix undeclared ENOSYS in include/linux/tracepoint.h
    
    The header file include/linux/tracepoint.h may be included without
    include/linux/errno.h and then the compiler will fail on building for
    undelcared ENOSYS. This patch fixes this problem via including <linux/errno.h>
    to include/linux/tracepoint.h.
    
    Signed-off-by: Wu Zhangjin <wuzhangjin@gmail.com>
    LKML-Reference: <1277118549-622-1-git-send-email-wuzhangjin@gmail.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 9a59d1f98cd4..103d1b61aacb 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -14,6 +14,7 @@
  * See the file COPYING for more details.
  */
 
+#include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/rcupdate.h>
 

commit 38516ab59fbc5b3bb278cf5e1fe2867c70cff32e
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Apr 20 17:04:50 2010 -0400

    tracing: Let tracepoints have data passed to tracepoint callbacks
    
    This patch adds data to be passed to tracepoint callbacks.
    
    The created functions from DECLARE_TRACE() now need a mandatory data
    parameter. For example:
    
    DECLARE_TRACE(mytracepoint, int value, value)
    
    Will create the register function:
    
    int register_trace_mytracepoint((void(*)(void *data, int value))probe,
                                    void *data);
    
    As the first argument, all callbacks (probes) must take a (void *data)
    parameter. So a callback for the above tracepoint will look like:
    
    void myprobe(void *data, int value)
    {
    }
    
    The callback may choose to ignore the data parameter.
    
    This change allows callbacks to register a private data pointer along
    with the function probe.
    
            void mycallback(void *data, int value);
    
            register_trace_mytracepoint(mycallback, mydata);
    
    Then the mycallback() will receive the "mydata" as the first parameter
    before the args.
    
    A more detailed example:
    
      DECLARE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));
    
      /* In the C file */
    
      DEFINE_TRACE(mytracepoint, TP_PROTO(int status), TP_ARGS(status));
    
      [...]
    
           trace_mytracepoint(status);
    
      /* In a file registering this tracepoint */
    
      int my_callback(void *data, int status)
      {
            struct my_struct my_data = data;
            [...]
      }
    
      [...]
            my_data = kmalloc(sizeof(*my_data), GFP_KERNEL);
            init_my_data(my_data);
            register_trace_mytracepoint(my_callback, my_data);
    
    The same callback can also be registered to the same tracepoint as long
    as the data registered is different. Note, the data must also be used
    to unregister the callback:
    
            unregister_trace_mytracepoint(my_callback, my_data);
    
    Because of the data parameter, tracepoints declared this way can not have
    no args. That is:
    
      DECLARE_TRACE(mytracepoint, TP_PROTO(void), TP_ARGS());
    
    will cause an error.
    
    If no arguments are needed, a new macro can be used instead:
    
      DECLARE_TRACE_NOARGS(mytracepoint);
    
    Since there are no arguments, the proto and args fields are left out.
    
    This is part of a series to make the tracepoint footprint smaller:
    
       text    data     bss     dec     hex filename
    4913961 1088356  861512 6863829  68bbd5 vmlinux.orig
    4914025 1088868  861512 6864405  68be15 vmlinux.class
    4918492 1084612  861512 6864616  68bee8 vmlinux.tracepoint
    
    Again, this patch also increases the size of the kernel, but
    lays the ground work for decreasing it.
    
     v5: Fixed net/core/drop_monitor.c to handle these updates.
    
     v4: Moved the DECLARE_TRACE() DECLARE_TRACE_NOARGS out of the
         #ifdef CONFIG_TRACE_POINTS, since the two are the same in both
         cases. The __DECLARE_TRACE() is what changes.
         Thanks to Frederic Weisbecker for pointing this out.
    
     v3: Made all register_* functions require data to be passed and
         all callbacks to take a void * parameter as its first argument.
         This makes the calling functions comply with C standards.
    
         Also added more comments to the modifications of DECLARE_TRACE().
    
     v2: Made the DECLARE_TRACE() have the ability to pass arguments
         and added a new DECLARE_TRACE_NOARGS() for tracepoints that
         do not need any arguments.
    
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Acked-by: Masami Hiramatsu <mhiramat@redhat.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 8d5e4f6d96d0..9a59d1f98cd4 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -20,12 +20,17 @@
 struct module;
 struct tracepoint;
 
+struct tracepoint_func {
+	void *func;
+	void *data;
+};
+
 struct tracepoint {
 	const char *name;		/* Tracepoint name */
 	int state;			/* State. */
 	void (*regfunc)(void);
 	void (*unregfunc)(void);
-	void **funcs;
+	struct tracepoint_func *funcs;
 } __attribute__((aligned(32)));		/*
 					 * Aligned on 32 bytes because it is
 					 * globally visible and gcc happily
@@ -37,16 +42,19 @@ struct tracepoint {
  * Connect a probe to a tracepoint.
  * Internal API, should not be used directly.
  */
-extern int tracepoint_probe_register(const char *name, void *probe);
+extern int tracepoint_probe_register(const char *name, void *probe, void *data);
 
 /*
  * Disconnect a probe from a tracepoint.
  * Internal API, should not be used directly.
  */
-extern int tracepoint_probe_unregister(const char *name, void *probe);
+extern int
+tracepoint_probe_unregister(const char *name, void *probe, void *data);
 
-extern int tracepoint_probe_register_noupdate(const char *name, void *probe);
-extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe);
+extern int tracepoint_probe_register_noupdate(const char *name, void *probe,
+					      void *data);
+extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe,
+						void *data);
 extern void tracepoint_probe_update_all(void);
 
 struct tracepoint_iter {
@@ -102,17 +110,27 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 /*
  * it_func[0] is never NULL because there is at least one element in the array
  * when the array itself is non NULL.
+ *
+ * Note, the proto and args passed in includes "__data" as the first parameter.
+ * The reason for this is to handle the "void" prototype. If a tracepoint
+ * has a "void" prototype, then it is invalid to declare a function
+ * as "(void *, void)". The DECLARE_TRACE_NOARGS() will pass in just
+ * "void *data", where as the DECLARE_TRACE() will pass in "void *data, proto".
  */
 #define __DO_TRACE(tp, proto, args)					\
 	do {								\
-		void **it_func;						\
+		struct tracepoint_func *it_func_ptr;			\
+		void *it_func;						\
+		void *__data;						\
 									\
 		rcu_read_lock_sched_notrace();				\
-		it_func = rcu_dereference_sched((tp)->funcs);		\
-		if (it_func) {						\
+		it_func_ptr = rcu_dereference_sched((tp)->funcs);	\
+		if (it_func_ptr) {					\
 			do {						\
-				((void(*)(proto))(*it_func))(args);	\
-			} while (*(++it_func));				\
+				it_func = (it_func_ptr)->func;		\
+				__data = (it_func_ptr)->data;		\
+				((void(*)(proto))(it_func))(args);	\
+			} while ((++it_func_ptr)->func);		\
 		}							\
 		rcu_read_unlock_sched_notrace();			\
 	} while (0)
@@ -122,23 +140,29 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
  */
-#define DECLARE_TRACE(name, proto, args)				\
+#define __DECLARE_TRACE(name, proto, args, data_proto, data_args)	\
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
 		if (unlikely(__tracepoint_##name.state))		\
 			__DO_TRACE(&__tracepoint_##name,		\
-				TP_PROTO(proto), TP_ARGS(args));	\
+				TP_PROTO(data_proto),			\
+				TP_ARGS(data_args));			\
 	}								\
-	static inline int register_trace_##name(void (*probe)(proto))	\
+	static inline int						\
+	register_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\
-		return tracepoint_probe_register(#name, (void *)probe);	\
+		return tracepoint_probe_register(#name, (void *)probe,	\
+						 data);			\
 	}								\
-	static inline int unregister_trace_##name(void (*probe)(proto))	\
+	static inline int						\
+	unregister_trace_##name(void (*probe)(data_proto), void *data)	\
 	{								\
-		return tracepoint_probe_unregister(#name, (void *)probe);\
+		return tracepoint_probe_unregister(#name, (void *)probe, \
+						   data);		\
 	}								\
-	static inline void check_trace_callback_type_##name(void (*cb)(proto)) \
+	static inline void						\
+	check_trace_callback_type_##name(void (*cb)(data_proto))	\
 	{								\
 	}
 
@@ -158,20 +182,22 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	EXPORT_SYMBOL(__tracepoint_##name)
 
 #else /* !CONFIG_TRACEPOINTS */
-#define DECLARE_TRACE(name, proto, args)				\
-	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
-	{ }								\
+#define __DECLARE_TRACE(name, proto, args, data_proto, data_args)	\
 	static inline void trace_##name(proto)				\
 	{ }								\
-	static inline int register_trace_##name(void (*probe)(proto))	\
+	static inline int						\
+	register_trace_##name(void (*probe)(data_proto),		\
+			      void *data)				\
 	{								\
 		return -ENOSYS;						\
 	}								\
-	static inline int unregister_trace_##name(void (*probe)(proto))	\
+	static inline int						\
+	unregister_trace_##name(void (*probe)(data_proto),		\
+				void *data)				\
 	{								\
 		return -ENOSYS;						\
 	}								\
-	static inline void check_trace_callback_type_##name(void (*cb)(proto)) \
+	static inline void check_trace_callback_type_##name(void (*cb)(data_proto)) \
 	{								\
 	}
 
@@ -181,6 +207,29 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 #define EXPORT_TRACEPOINT_SYMBOL(name)
 
 #endif /* CONFIG_TRACEPOINTS */
+
+/*
+ * The need for the DECLARE_TRACE_NOARGS() is to handle the prototype
+ * (void). "void" is a special value in a function prototype and can
+ * not be combined with other arguments. Since the DECLARE_TRACE()
+ * macro adds a data element at the beginning of the prototype,
+ * we need a way to differentiate "(void *data, proto)" from
+ * "(void *data, void)". The second prototype is invalid.
+ *
+ * DECLARE_TRACE_NOARGS() passes "void" as the tracepoint prototype
+ * and "void *__data" as the callback prototype.
+ *
+ * DECLARE_TRACE() passes "proto" as the tracepoint protoype and
+ * "void *__data, proto" as the callback prototype.
+ */
+#define DECLARE_TRACE_NOARGS(name)					\
+		__DECLARE_TRACE(name, void, , void *__data, __data)
+
+#define DECLARE_TRACE(name, proto, args)				\
+		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),	\
+				PARAMS(void *__data, proto),		\
+				PARAMS(__data, args))
+
 #endif /* DECLARE_TRACE */
 
 #ifndef TRACE_EVENT

commit 53da59aa6dd881fd0bbdd058a8a299d90ce9dd1d
Author: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date:   Fri Apr 30 12:59:59 2010 -0400

    tracepoints: Add check trace callback type
    
    This check is meant to be used by tracepoint users which do a direct cast of
    callbacks to (void *) for direct registration, thus bypassing the
    register_trace_##name and unregister_trace_##name checks.
    
    This permits to ensure that the callback type matches the function type at the
    call site, but without generating any code.
    
    Acked-by: Masami Hiramatsu <mhiramat@redhat.com>
    Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    LKML-Reference: <20100430165959.GA25605@Krystal>
    CC: Ingo Molnar <mingo@elte.hu>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Peter Zijlstra <peterz@infradead.org>
    CC: Arnaldo Carvalho de Melo <acme@redhat.com>
    CC: Lai Jiangshan <laijs@cn.fujitsu.com>
    CC: Li Zefan <lizf@cn.fujitsu.com>
    CC: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 1d85f9a6a199..8d5e4f6d96d0 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -137,9 +137,11 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
 		return tracepoint_probe_unregister(#name, (void *)probe);\
+	}								\
+	static inline void check_trace_callback_type_##name(void (*cb)(proto)) \
+	{								\
 	}
 
-
 #define DEFINE_TRACE_FN(name, reg, unreg)				\
 	static const char __tpstrtab_##name[]				\
 	__attribute__((section("__tracepoints_strings"))) = #name;	\
@@ -168,6 +170,9 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
 		return -ENOSYS;						\
+	}								\
+	static inline void check_trace_callback_type_##name(void (*cb)(proto)) \
+	{								\
 	}
 
 #define DEFINE_TRACE_FN(name, reg, unreg)

commit 2e26ca7150a4f2ab3e69471dfc65f131e7dd7a05
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed May 5 10:52:31 2010 -0400

    tracing: Fix tracepoint.h DECLARE_TRACE() to allow more than one header
    
    When more than one header is included under CREATE_TRACE_POINTS
    the DECLARE_TRACE() macro is not defined back to its original meaning
    and the second include will fail to initialize the TRACE_EVENT()
    and DECLARE_TRACE() correctly.
    
    To fix this the tracepoint.h file moves the define of DECLARE_TRACE()
    out of the #ifdef _LINUX_TRACEPOINT_H protection (just like the
    define of the TRACE_EVENT()). This way the define_trace.h will undef
    the DECLARE_TRACE() at the end and allow new headers to start
    from scratch.
    
    This patch also requires fixing the include/events/napi.h
    
    It currently uses DECLARE_TRACE() and should be converted to a TRACE_EVENT()
    format. But I'll leave that change to the authors of that file.
    But since the napi.h file depends on using the CREATE_TRACE_POINTS
    and does not define its own DEFINE_TRACE() it must use the define_trace.h
    method instead.
    
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 78b4bd3be496..1d85f9a6a199 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -33,6 +33,65 @@ struct tracepoint {
 					 * Keep in sync with vmlinux.lds.h.
 					 */
 
+/*
+ * Connect a probe to a tracepoint.
+ * Internal API, should not be used directly.
+ */
+extern int tracepoint_probe_register(const char *name, void *probe);
+
+/*
+ * Disconnect a probe from a tracepoint.
+ * Internal API, should not be used directly.
+ */
+extern int tracepoint_probe_unregister(const char *name, void *probe);
+
+extern int tracepoint_probe_register_noupdate(const char *name, void *probe);
+extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe);
+extern void tracepoint_probe_update_all(void);
+
+struct tracepoint_iter {
+	struct module *module;
+	struct tracepoint *tracepoint;
+};
+
+extern void tracepoint_iter_start(struct tracepoint_iter *iter);
+extern void tracepoint_iter_next(struct tracepoint_iter *iter);
+extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
+extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
+extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
+	struct tracepoint *begin, struct tracepoint *end);
+
+/*
+ * tracepoint_synchronize_unregister must be called between the last tracepoint
+ * probe unregistration and the end of module exit to make sure there is no
+ * caller executing a probe when it is freed.
+ */
+static inline void tracepoint_synchronize_unregister(void)
+{
+	synchronize_sched();
+}
+
+#define PARAMS(args...) args
+
+#ifdef CONFIG_TRACEPOINTS
+extern void tracepoint_update_probe_range(struct tracepoint *begin,
+	struct tracepoint *end);
+#else
+static inline void tracepoint_update_probe_range(struct tracepoint *begin,
+	struct tracepoint *end)
+{ }
+#endif /* CONFIG_TRACEPOINTS */
+
+#endif /* _LINUX_TRACEPOINT_H */
+
+/*
+ * Note: we keep the TRACE_EVENT and DECLARE_TRACE outside the include
+ *  file ifdef protection.
+ *  This is due to the way trace events work. If a file includes two
+ *  trace event headers under one "CREATE_TRACE_POINTS" the first include
+ *  will override the TRACE_EVENT and break the second include.
+ */
+
 #ifndef DECLARE_TRACE
 
 #define TP_PROTO(args...)	args
@@ -96,9 +155,6 @@ struct tracepoint {
 #define EXPORT_TRACEPOINT_SYMBOL(name)					\
 	EXPORT_SYMBOL(__tracepoint_##name)
 
-extern void tracepoint_update_probe_range(struct tracepoint *begin,
-	struct tracepoint *end);
-
 #else /* !CONFIG_TRACEPOINTS */
 #define DECLARE_TRACE(name, proto, args)				\
 	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
@@ -119,61 +175,9 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 #define EXPORT_TRACEPOINT_SYMBOL_GPL(name)
 #define EXPORT_TRACEPOINT_SYMBOL(name)
 
-static inline void tracepoint_update_probe_range(struct tracepoint *begin,
-	struct tracepoint *end)
-{ }
 #endif /* CONFIG_TRACEPOINTS */
 #endif /* DECLARE_TRACE */
 
-/*
- * Connect a probe to a tracepoint.
- * Internal API, should not be used directly.
- */
-extern int tracepoint_probe_register(const char *name, void *probe);
-
-/*
- * Disconnect a probe from a tracepoint.
- * Internal API, should not be used directly.
- */
-extern int tracepoint_probe_unregister(const char *name, void *probe);
-
-extern int tracepoint_probe_register_noupdate(const char *name, void *probe);
-extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe);
-extern void tracepoint_probe_update_all(void);
-
-struct tracepoint_iter {
-	struct module *module;
-	struct tracepoint *tracepoint;
-};
-
-extern void tracepoint_iter_start(struct tracepoint_iter *iter);
-extern void tracepoint_iter_next(struct tracepoint_iter *iter);
-extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
-extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
-extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
-	struct tracepoint *begin, struct tracepoint *end);
-
-/*
- * tracepoint_synchronize_unregister must be called between the last tracepoint
- * probe unregistration and the end of module exit to make sure there is no
- * caller executing a probe when it is freed.
- */
-static inline void tracepoint_synchronize_unregister(void)
-{
-	synchronize_sched();
-}
-
-#define PARAMS(args...) args
-
-#endif /* _LINUX_TRACEPOINT_H */
-
-/*
- * Note: we keep the TRACE_EVENT outside the include file ifdef protection.
- *  This is due to the way trace events work. If a file includes two
- *  trace event headers under one "CREATE_TRACE_POINTS" the first include
- *  will override the TRACE_EVENT and break the second include.
- */
-
 #ifndef TRACE_EVENT
 /*
  * For use with the TRACE_EVENT macro:

commit 7f5b774275df8c76a959eae7488128b637fcbfc8
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Tue Mar 16 17:00:29 2010 +0800

    rcu: Fix tracepoints & lockdep false positive
    
    tracepoint.h uses rcu_dereference(), which triggers this warning:
    
    [    0.701161] ===================================================
    [    0.702211] [ INFO: suspicious rcu_dereference_check() usage. ]
    [    0.702716] ---------------------------------------------------
    [    0.703203] include/trace/events/workqueue.h:68 invoked rcu_dereference_check() without protection!
    [    0.703971] [ 0.703990] other info that might help us debug this:
    [    0.703993]
    [    0.705590]
    [    0.705604] rcu_scheduler_active = 1, debug_locks = 0
    [    0.706712] 1 lock held by swapper/1:
    [    0.707229]  #0:  (cpu_add_remove_lock){+.+.+.}, at: [<c0142f54>] cpu_maps_update_begin+0x14/0x20
    [    0.710097]
    [    0.710106] stack backtrace:
    [    0.712602] Pid: 1, comm: swapper Not tainted 2.6.34-rc1-tip-01613-g72662bb #168
    [    0.713231] Call Trace:
    [    0.713997]  [<c017174d>] lockdep_rcu_dereference+0x9d/0xb0
    [    0.714746]  [<c015a117>] create_workqueue_thread+0x107/0x110
    [    0.715353]  [<c015aee0>] ? worker_thread+0x0/0x340
    [    0.715845]  [<c015a8e8>] __create_workqueue_key+0x138/0x240
    [    0.716427]  [<c0142f92>] ? cpu_maps_update_done+0x12/0x20
    [    0.717012]  [<c086b12f>] init_workqueues+0x6f/0x80
    [    0.717530]  [<c08576d2>] kernel_init+0x102/0x1f0
    [    0.717570]  [<c08575d0>] ? kernel_init+0x0/0x1f0
    [    0.718944]  [<c01030fa>] kernel_thread_helper+0x6/0x10
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <4B9F48AD.4000404@cn.fujitsu.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index f59604ed0ec6..78b4bd3be496 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -49,7 +49,7 @@ struct tracepoint {
 		void **it_func;						\
 									\
 		rcu_read_lock_sched_notrace();				\
-		it_func = rcu_dereference((tp)->funcs);			\
+		it_func = rcu_dereference_sched((tp)->funcs);		\
 		if (it_func) {						\
 			do {						\
 				((void(*)(proto))(*it_func))(args);	\

commit 091ad3658e3c76c5fb05f65bfb64a0246f8f31b5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Nov 26 09:04:55 2009 +0100

    events: Rename TRACE_EVENT_TEMPLATE() to DECLARE_EVENT_CLASS()
    
    It is not quite obvious at first sight what TRACE_EVENT_TEMPLATE
    does: does it define an event as well beyond defining a template?
    
    To clarify this, rename it to DECLARE_EVENT_CLASS, which follows
    the various 'DECLARE_*()' idioms we already have in the kernel:
    
      DECLARE_EVENT_CLASS(class)
    
        DEFINE_EVENT(class, event1)
        DEFINE_EVENT(class, event2)
        DEFINE_EVENT(class, event3)
    
    To complete this logic we should also rename TRACE_EVENT() to:
    
      DEFINE_SINGLE_EVENT(single_event)
    
    ... but in a more quiet moment of the kernel cycle.
    
    Cc: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    LKML-Reference: <4B0E286A.2000405@cn.fujitsu.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 7063383cca13..f59604ed0ec6 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -280,7 +280,7 @@ static inline void tracepoint_synchronize_unregister(void)
  * TRACE_EVENT_FN to perform any (un)registration work.
  */
 
-#define TRACE_EVENT_TEMPLATE(name, proto, args, tstruct, assign, print)
+#define DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)
 #define DEFINE_EVENT(template, name, proto, args)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\

commit e5bc9721684e9412f3e0465222f317c362a8ab47
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Nov 18 20:36:26 2009 -0500

    tracing: Create new DEFINE_EVENT_PRINT
    
    After creating the TRACE_EVENT_TEMPLATE I started to look at other
    trace points to see what duplication was made. I noticed that there
    are several trace points where they are almost identical except for
    the name and the output format. Since TRACE_EVENT_TEMPLATE was successful
    in bringing down the size of trace events, I added a DEFINE_EVENT_PRINT.
    
    DEFINE_EVENT_PRINT is used just like DEFINE_EVENT is. That is, the
    DEFINE_EVENT_PRINT also uses a TRACE_EVENT_TEMPLATE, but it allows the
    developer to overwrite the print format. If there are two or more
    TRACE_EVENTS that are identical except for the name and print, then
    they can be converted to use a TRACE_EVENT_TEMPLATE. Since the
    TRACE_EVENT_TEMPLATE already does the print output, the first trace event
    would have its print format held in the TRACE_EVENT_TEMPLATE and
    be defined with a DEFINE_EVENT. The rest will use the DEFINE_EVENT_PRINT
    and override the print format.
    
    Converting the sched trace points to both DEFINE_EVENT and
    DEFINE_EVENT_PRINT. Five were converted to DEFINE_EVENT and two were
    converted to DEFINE_EVENT_PRINT.
    
    I was able to get the following:
    
    $ size kernel/sched.o-*
       text    data     bss     dec     hex filename
      79299    6776    2520   88595   15a13 kernel/sched.o-notrace
     101941   11896    2584  116421   1c6c5 kernel/sched.o-templ
     104779   11896    2584  119259   1d1db kernel/sched.o-trace
    
    sched.o-notrace is the scheduler compiled with no trace points.
    sched.o-templ is with the use of DEFINE_EVENT and DEFINE_EVENT_PRINT
    sched.o-trace is the current trace events.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 88a5b5a809ec..7063383cca13 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -283,6 +283,8 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_EVENT_TEMPLATE(name, proto, args, tstruct, assign, print)
 #define DEFINE_EVENT(template, name, proto, args)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define DEFINE_EVENT_PRINT(template, name, proto, args, print)	\
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))

commit ff038f5c37c2070829004a0678372766c2b32180
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Nov 18 20:27:27 2009 -0500

    tracing: Create new TRACE_EVENT_TEMPLATE
    
    There are some places in the kernel that define several tracepoints and
    they are all identical besides the name. The code to enable, disable and
    record is created for every trace point even if most of the code is
    identical.
    
    This patch adds TRACE_EVENT_TEMPLATE that lets the developer create
    a template TRACE_EVENT and create trace points with DEFINE_EVENT, which
    is based off of a given template. Each trace point used by this
    will share most of the code, and bring down the size of the kernel
    when there are several duplicate events.
    
    Usage is:
    
    TRACE_EVENT_TEMPLATE(name, proto, args, tstruct, assign, print);
    
    Which would be the same as defining a normal TRACE_EVENT.
    
    To create the trace events that the trace points will use:
    
    DEFINE_EVENT(template, name, proto, args) is done. The template
    is the name of the TRACE_EVENT_TEMPLATE to use. The name is the
    name of the trace point. The parameters proto and args must be the same
    as the proto and args of the template. If they are not the same,
    then a compile error will result. I tried hard removing this duplication
    but the C preprocessor is not powerful enough (or my CPP magic
    experience points is not at a high enough level) to not need them.
    
    A lot of trace events are coming in with new XFS development. Most of
    the trace points are identical except for the name. The following shows
    the advantage of having TRACE_EVENT_TEMPLATE:
    
    $ size fs/xfs/xfs.o.*
        text          data     bss     dec     hex filename
      452114          2788    3520  458422   6feb6 fs/xfs/xfs.o.old
      638482         38116    3744  680342   a6196 fs/xfs/xfs.o.template
      996954         38116    4480 1039550   fdcbe fs/xfs/xfs.o.trace
    
    xfs.o.old is without any tracepoints.
    xfs.o.template uses the new TRACE_EVENT_TEMPLATE.
    xfs.o.trace uses the current TRACE_EVENT macros.
    
    Requested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 2aac8a83e89b..88a5b5a809ec 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -280,6 +280,10 @@ static inline void tracepoint_synchronize_unregister(void)
  * TRACE_EVENT_FN to perform any (un)registration work.
  */
 
+#define TRACE_EVENT_TEMPLATE(name, proto, args, tstruct, assign, print)
+#define DEFINE_EVENT(template, name, proto, args)		\
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #define TRACE_EVENT_FN(name, proto, args, struct,		\

commit 8cd09a5984c08dafade74c9c1ab4311af2bf2d24
Author: Li Hong <lihong.hi@gmail.com>
Date:   Tue Sep 22 18:00:44 2009 +0800

    tracing: Fix a comment and a trivial format issue in tracepoint.h
    
    Fix the tracepoint documentation path in tracepoints headers and
    a misaligned tabulation.
    
    Signed-off-by: Li Hong <lihong.hi@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    LKML-Reference: <3a3680030909220300h7cf18849q4d4702b9d4feaa67@mail.gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 63a3f7a80580..2aac8a83e89b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -4,7 +4,7 @@
 /*
  * Kernel Tracepoint API.
  *
- * See Documentation/tracepoint.txt.
+ * See Documentation/trace/tracepoints.txt.
  *
  * (C) Copyright 2008 Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
  *
@@ -36,7 +36,7 @@ struct tracepoint {
 #ifndef DECLARE_TRACE
 
 #define TP_PROTO(args...)	args
-#define TP_ARGS(args...)		args
+#define TP_ARGS(args...)	args
 
 #ifdef CONFIG_TRACEPOINTS
 

commit 35dce1a99d010f3d738af4ce1b9b77302fdfe69c
Merge: 7cb2e3ee2aee 1c569f0264ea
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Aug 26 08:29:02 2009 +0200

    Merge branch 'tracing/core' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing into tracing/core
    
    Conflicts:
            include/linux/tracepoint.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 7cb2e3ee2aeec5b83ecadba929a2dc575dd4008f
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Aug 26 00:32:37 2009 -0400

    tracing: add comments to explain TRACE_EVENT out of protection
    
    The commit:
      commit 5ac35daa9343936038a3c9c4f4d6d3fe6a2a7bd8
      Author: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
      tracing/events: fix the include file dependencies
    
    Moved the TRACE_EVENT out of the ifdef protection of tracepoints.h
    but uses the define of TRACE_EVENT itself as protection. This patch
    adds comments to explain why.
    
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 81709854f7ab..0341f2e2698a 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -180,7 +180,15 @@ static inline void tracepoint_synchronize_unregister(void)
 }
 
 #define PARAMS(args...) args
-#endif
+
+#endif /* _LINUX_TRACEPOINT_H */
+
+/*
+ * Note: we keep the TRACE_EVENT outside the include file ifdef protection.
+ *  This is due to the way trace events work. If a file includes two
+ *  trace event headers under one "CREATE_TRACE_POINTS" the first include
+ *  will override the TRACE_EVENT and break the second include.
+ */
 
 #ifndef TRACE_EVENT
 /*
@@ -287,4 +295,5 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
-#endif
+
+#endif /* ifdef TRACE_EVENT (see note above) */

commit 5ac35daa9343936038a3c9c4f4d6d3fe6a2a7bd8
Author: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
Date:   Tue Aug 25 14:06:22 2009 +0800

    tracing/events: fix the include file dependencies
    
    The TRACE_EVENT depends on the include/linux/tracepoint.h first
    and include/trace/ftrace.h later, if we include the ftrace.h early,
    a building error will occur.
    
    Both define TRACE_EVENT in trace_a.h and trace_b.h, if we include
    those in .c file, like this:
    
    #define CREATE_TRACE_POINTS
    include <trace/events/trace_a.h>
    include <trace/events/trace_b.h>
    
    The above will not work, because the TRACE_EVENT was re-defined by
    the previous .h file.
    
    Reported-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
    LKML-Reference: <4A937F5E.3020802@cn.fujitsu.com>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 5984ed04c03b..81709854f7ab 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -180,6 +180,7 @@ static inline void tracepoint_synchronize_unregister(void)
 }
 
 #define PARAMS(args...) args
+#endif
 
 #ifndef TRACE_EVENT
 /*
@@ -287,5 +288,3 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #endif
-
-#endif

commit 97419875865859fd2403e66266c02ce028e2f5ab
Author: Josh Stone <jistone@redhat.com>
Date:   Mon Aug 24 14:43:13 2009 -0700

    tracing: Move tracepoint callbacks from declaration to definition
    
    It's not strictly correct for the tracepoint reg/unreg callbacks to
    occur when a client is hooking up, because the actual tracepoint may not
    be present yet.  This happens to be fine for syscall, since that's in
    the core kernel, but it would cause problems for tracepoints defined in
    a module that hasn't been loaded yet.  It also means the reg/unreg has
    to be EXPORTed for any modules to use the tracepoint (as in SystemTap).
    
    This patch removes DECLARE_TRACE_WITH_CALLBACK, and instead introduces
    DEFINE_TRACE_FN which stores the callbacks in struct tracepoint.  The
    callbacks are used now when the active state of the tracepoint changes
    in set_tracepoint & disable_tracepoint.
    
    This also introduces TRACE_EVENT_FN, so ftrace events can also provide
    registration callbacks if needed.
    
    Signed-off-by: Josh Stone <jistone@redhat.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Jiaying Zhang <jiayingz@google.com>
    Cc: Martin Bligh <mbligh@google.com>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    LKML-Reference: <1251150194-1713-4-git-send-email-jistone@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 5984ed04c03b..846a4ae501eb 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -23,6 +23,8 @@ struct tracepoint;
 struct tracepoint {
 	const char *name;		/* Tracepoint name */
 	int state;			/* State. */
+	void (*regfunc)(void);
+	void (*unregfunc)(void);
 	void **funcs;
 } __attribute__((aligned(32)));		/*
 					 * Aligned on 32 bytes because it is
@@ -60,10 +62,8 @@ struct tracepoint {
  * Make sure the alignment of the structure in the __tracepoints section will
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
- * An optional set of (un)registration functions can be passed to perform any
- * additional (un)registration work.
  */
-#define DECLARE_TRACE_WITH_CALLBACK(name, proto, args, reg, unreg)	\
+#define DECLARE_TRACE(name, proto, args)				\
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
@@ -73,36 +73,23 @@ struct tracepoint {
 	}								\
 	static inline int register_trace_##name(void (*probe)(proto))	\
 	{								\
-		int ret;						\
-		void (*func)(void) = reg;				\
-									\
-		ret = tracepoint_probe_register(#name, (void *)probe);	\
-		if (func && !ret)					\
-			func();						\
-		return ret;						\
+		return tracepoint_probe_register(#name, (void *)probe);	\
 	}								\
 	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
-		int ret;						\
-		void (*func)(void) = unreg;				\
-									\
-		ret = tracepoint_probe_unregister(#name, (void *)probe);\
-		if (func && !ret)					\
-			func();						\
-		return ret;						\
+		return tracepoint_probe_unregister(#name, (void *)probe);\
 	}
 
 
-#define DECLARE_TRACE(name, proto, args)				 \
-	DECLARE_TRACE_WITH_CALLBACK(name, TP_PROTO(proto), TP_ARGS(args),\
-					NULL, NULL);
-
-#define DEFINE_TRACE(name)						\
+#define DEFINE_TRACE_FN(name, reg, unreg)				\
 	static const char __tpstrtab_##name[]				\
 	__attribute__((section("__tracepoints_strings"))) = #name;	\
 	struct tracepoint __tracepoint_##name				\
 	__attribute__((section("__tracepoints"), aligned(32))) =	\
-		{ __tpstrtab_##name, 0, NULL }
+		{ __tpstrtab_##name, 0, reg, unreg, NULL }
+
+#define DEFINE_TRACE(name)						\
+	DEFINE_TRACE_FN(name, NULL, NULL);
 
 #define EXPORT_TRACEPOINT_SYMBOL_GPL(name)				\
 	EXPORT_SYMBOL_GPL(__tracepoint_##name)
@@ -113,7 +100,7 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end);
 
 #else /* !CONFIG_TRACEPOINTS */
-#define DECLARE_TRACE_WITH_CALLBACK(name, proto, args, reg, unreg)	\
+#define DECLARE_TRACE(name, proto, args)				\
 	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
 	{ }								\
 	static inline void trace_##name(proto)				\
@@ -127,10 +114,7 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 		return -ENOSYS;						\
 	}
 
-#define DECLARE_TRACE(name, proto, args)				 \
-	DECLARE_TRACE_WITH_CALLBACK(name, TP_PROTO(proto), TP_ARGS(args),\
-					NULL, NULL);
-
+#define DEFINE_TRACE_FN(name, reg, unreg)
 #define DEFINE_TRACE(name)
 #define EXPORT_TRACEPOINT_SYMBOL_GPL(name)
 #define EXPORT_TRACEPOINT_SYMBOL(name)
@@ -282,10 +266,16 @@ static inline void tracepoint_synchronize_unregister(void)
  * can also by used by generic instrumentation like SystemTap), and
  * it is also used to expose a structured trace record in
  * /sys/kernel/debug/tracing/events/.
+ *
+ * A set of (un)registration functions can be passed to the variant
+ * TRACE_EVENT_FN to perform any (un)registration work.
  */
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#define TRACE_EVENT_FN(name, proto, args, struct,		\
+		assign, print, reg, unreg)			\
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 #endif
 
 #endif

commit 63fbdab3157b72467013fe4dcf88c85e45280ef7
Author: Jason Baron <jbaron@redhat.com>
Date:   Mon Aug 10 16:52:27 2009 -0400

    tracing: Add DECLARE_TRACE_WITH_CALLBACK() macro
    
    Introduce a new 'DECLARE_TRACE_WITH_CALLBACK()' macro, so that
    tracepoints can associate an external register/unregister function.
    
    This prepares for the syscalls tracer conversion to trace events. We
    will need to perform arch level operations once a syscall event is
    turned on/off, such as TIF flags setting, hence the need of such
    specific callbacks.
    
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Jiaying Zhang <jiayingz@google.com>
    Cc: Martin Bligh <mbligh@google.com>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Masami Hiramatsu <mhiramat@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index b9dc4ca0246f..5984ed04c03b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -60,8 +60,10 @@ struct tracepoint {
  * Make sure the alignment of the structure in the __tracepoints section will
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
+ * An optional set of (un)registration functions can be passed to perform any
+ * additional (un)registration work.
  */
-#define DECLARE_TRACE(name, proto, args)				\
+#define DECLARE_TRACE_WITH_CALLBACK(name, proto, args, reg, unreg)	\
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
@@ -71,13 +73,30 @@ struct tracepoint {
 	}								\
 	static inline int register_trace_##name(void (*probe)(proto))	\
 	{								\
-		return tracepoint_probe_register(#name, (void *)probe);	\
+		int ret;						\
+		void (*func)(void) = reg;				\
+									\
+		ret = tracepoint_probe_register(#name, (void *)probe);	\
+		if (func && !ret)					\
+			func();						\
+		return ret;						\
 	}								\
 	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
-		return tracepoint_probe_unregister(#name, (void *)probe);\
+		int ret;						\
+		void (*func)(void) = unreg;				\
+									\
+		ret = tracepoint_probe_unregister(#name, (void *)probe);\
+		if (func && !ret)					\
+			func();						\
+		return ret;						\
 	}
 
+
+#define DECLARE_TRACE(name, proto, args)				 \
+	DECLARE_TRACE_WITH_CALLBACK(name, TP_PROTO(proto), TP_ARGS(args),\
+					NULL, NULL);
+
 #define DEFINE_TRACE(name)						\
 	static const char __tpstrtab_##name[]				\
 	__attribute__((section("__tracepoints_strings"))) = #name;	\
@@ -94,7 +113,7 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end);
 
 #else /* !CONFIG_TRACEPOINTS */
-#define DECLARE_TRACE(name, proto, args)				\
+#define DECLARE_TRACE_WITH_CALLBACK(name, proto, args, reg, unreg)	\
 	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
 	{ }								\
 	static inline void trace_##name(proto)				\
@@ -108,6 +127,10 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 		return -ENOSYS;						\
 	}
 
+#define DECLARE_TRACE(name, proto, args)				 \
+	DECLARE_TRACE_WITH_CALLBACK(name, TP_PROTO(proto), TP_ARGS(args),\
+					NULL, NULL);
+
 #define DEFINE_TRACE(name)
 #define EXPORT_TRACEPOINT_SYMBOL_GPL(name)
 #define EXPORT_TRACEPOINT_SYMBOL(name)

commit 156f5a7801195fa2ce44aeeb62d6cf8468f3332a
Author: GeunSik Lim <leemgs1@gmail.com>
Date:   Tue Jun 2 15:01:37 2009 +0900

    debugfs: Fix terminology inconsistency of dir name to mount debugfs filesystem.
    
    Many developers use "/debug/" or "/debugfs/" or "/sys/kernel/debug/"
    directory name to mount debugfs filesystem for ftrace according to
    ./Documentation/tracers/ftrace.txt file.
    
    And, three directory names(ex:/debug/, /debugfs/, /sys/kernel/debug/) is
    existed in kernel source like ftrace, DRM, Wireless, Documentation,
    Network[sky2]files to mount debugfs filesystem.
    
    debugfs means debug filesystem for debugging easy to use by greg kroah
    hartman. "/sys/kernel/debug/" name is suitable as directory name
    of debugfs filesystem.
    - debugfs related reference: http://lwn.net/Articles/334546/
    
    Fix inconsistency of directory name to mount debugfs filesystem.
    
    * From Steven Rostedt
      - find_debugfs() and tracing_files() in this patch.
    
    Signed-off-by: GeunSik Lim <geunsik.lim@samsung.com>
    Acked-by     : Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Reviewed-by  : Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by  : James Smart <james.smart@emulex.com>
    CC: Jiri Kosina <trivial@kernel.org>
    CC: David Airlie <airlied@linux.ie>
    CC: Peter Osterlund <petero2@telia.com>
    CC: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    CC: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    CC: Masami Hiramatsu <mhiramat@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 14df7e635d43..b9dc4ca0246f 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -198,7 +198,7 @@ static inline void tracepoint_synchronize_unregister(void)
  *	* This is how the trace record is structured and will
  *	* be saved into the ring buffer. These are the fields
  *	* that will be exposed to user-space in
- *	* /debug/tracing/events/<*>/format.
+ *	* /sys/kernel/debug/tracing/events/<*>/format.
  *	*
  *	* The declared 'local variable' is called '__entry'
  *	*
@@ -258,7 +258,7 @@ static inline void tracepoint_synchronize_unregister(void)
  * tracepoint callback (this is used by programmatic plugins and
  * can also by used by generic instrumentation like SystemTap), and
  * it is also used to expose a structured trace record in
- * /debug/tracing/events/.
+ * /sys/kernel/debug/tracing/events/.
  */
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\

commit b8e65554d80b4c560d201362d0e8fa02109d89fd
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Fri Apr 24 11:50:39 2009 -0400

    tracing: remove deprecated TRACE_FORMAT
    
    The TRACE_FORMAT macro has been deprecated by the TRACE_EVENT macro.
    There are no more users. All new users must use the TRACE_EVENT macro.
    
    [ Impact: remove old functionality ]
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 4353f3f7e624..14df7e635d43 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -158,11 +158,6 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define PARAMS(args...) args
 
-#ifndef TRACE_FORMAT
-#define TRACE_FORMAT(name, proto, args, fmt)		\
-	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
-#endif
-
 #ifndef TRACE_EVENT
 /*
  * For use with the TRACE_EVENT macro:

commit ea20d9293ce423a39717ed4375393129a2e701f9
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Fri Apr 10 08:54:16 2009 -0400

    tracing: consolidate trace and trace_event headers
    
    Impact: clean up
    
    Neil Horman (et. al.) criticized the way the trace events were broken up
    into two files. The reason for that was that ftrace needed to separate out
    the declarations from where the #include <linux/tracepoint.h> was used.
    It then dawned on me that the tracepoint.h header only needs to define the
    TRACE_EVENT macro if it is not already defined.
    
    The solution is simply to test if TRACE_EVENT is defined, and if it is not
    then the linux/tracepoint.h header can define it. This change consolidates
    all the <traces>.h and <traces>_event_types.h into the <traces>.h file.
    
    Reported-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: Theodore Tso <tytso@mit.edu>
    Reported-by: Jiaying Zhang <jiayingz@google.com>
    Cc: Zhaolei <zhaolei@cn.fujitsu.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index d35a7ee7611f..4353f3f7e624 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -31,6 +31,8 @@ struct tracepoint {
 					 * Keep in sync with vmlinux.lds.h.
 					 */
 
+#ifndef DECLARE_TRACE
+
 #define TP_PROTO(args...)	args
 #define TP_ARGS(args...)		args
 
@@ -114,6 +116,7 @@ static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end)
 { }
 #endif /* CONFIG_TRACEPOINTS */
+#endif /* DECLARE_TRACE */
 
 /*
  * Connect a probe to a tracepoint.
@@ -154,10 +157,13 @@ static inline void tracepoint_synchronize_unregister(void)
 }
 
 #define PARAMS(args...) args
+
+#ifndef TRACE_FORMAT
 #define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#endif
 
-
+#ifndef TRACE_EVENT
 /*
  * For use with the TRACE_EVENT macro:
  *
@@ -262,5 +268,6 @@ static inline void tracepoint_synchronize_unregister(void)
 
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+#endif
 
 #endif

commit ef18012b248b47ec9a12c3a83ca5e99782d39c5d
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Mar 10 14:10:56 2009 -0400

    tracing: remove funky whitespace in the trace code
    
    Impact: clean up
    
    There existed a lot of <space><tab>'s in the tracing code. This
    patch removes them.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 119ece224c21..d35a7ee7611f 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -178,8 +178,8 @@ static inline void tracepoint_synchronize_unregister(void)
  *	* prototype, declare it via TP_PROTO():
  *	*
  *
- * 	TP_PROTO(struct rq *rq, struct task_struct *prev,
- * 		 struct task_struct *next),
+ *	TP_PROTO(struct rq *rq, struct task_struct *prev,
+ *		 struct task_struct *next),
  *
  *	*
  *	* Define the call signature of the 'function'.
@@ -187,7 +187,7 @@ static inline void tracepoint_synchronize_unregister(void)
  *	*  TP_PROTO1/TP_PROTO2/TP_PROTO3 ugliness.)
  *	*
  *
- * 	TP_ARGS(rq, prev, next),
+ *	TP_ARGS(rq, prev, next),
  *
  *	*
  *	* Fast binary tracing: define the trace record via
@@ -229,13 +229,13 @@ static inline void tracepoint_synchronize_unregister(void)
  *	* happens, on an active tracepoint.
  *	*
  *
- * 	TP_fast_assign(
- * 		memcpy(__entry->next_comm, next->comm, TASK_COMM_LEN);
- * 		__entry->prev_pid	= prev->pid;
- * 		__entry->prev_prio	= prev->prio;
+ *	TP_fast_assign(
+ *		memcpy(__entry->next_comm, next->comm, TASK_COMM_LEN);
+ *		__entry->prev_pid	= prev->pid;
+ *		__entry->prev_prio	= prev->prio;
  *		memcpy(__entry->prev_comm, prev->comm, TASK_COMM_LEN);
  *		__entry->next_pid	= next->pid;
- * 		__entry->next_prio	= next->prio;
+ *		__entry->next_prio	= next->prio;
  *	)
  *
  *	*

commit 823f9124fb2e33eeb624d139978a52089f8a02ae
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Mar 10 12:58:51 2009 -0400

    tracing: document TRACE_EVENT macro in tracepoint.h
    
    Impact: clean up / comments
    
    Kosaki Motohiro asked about an explanation to the TRACE_EVENT macro.
    Ingo Molnar replied with a nice description.
    
    This patch takes the description that Ingo wrote (with some slight
    modifications) and adds it to the tracepoint.h file.
    
    Reported-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c7b09452514b..119ece224c21 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -157,6 +157,109 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
+
+/*
+ * For use with the TRACE_EVENT macro:
+ *
+ * We define a tracepoint, its arguments, its printk format
+ * and its 'fast binay record' layout.
+ *
+ * Firstly, name your tracepoint via TRACE_EVENT(name : the
+ * 'subsystem_event' notation is fine.
+ *
+ * Think about this whole construct as the
+ * 'trace_sched_switch() function' from now on.
+ *
+ *
+ *  TRACE_EVENT(sched_switch,
+ *
+ *	*
+ *	* A function has a regular function arguments
+ *	* prototype, declare it via TP_PROTO():
+ *	*
+ *
+ * 	TP_PROTO(struct rq *rq, struct task_struct *prev,
+ * 		 struct task_struct *next),
+ *
+ *	*
+ *	* Define the call signature of the 'function'.
+ *	* (Design sidenote: we use this instead of a
+ *	*  TP_PROTO1/TP_PROTO2/TP_PROTO3 ugliness.)
+ *	*
+ *
+ * 	TP_ARGS(rq, prev, next),
+ *
+ *	*
+ *	* Fast binary tracing: define the trace record via
+ *	* TP_STRUCT__entry(). You can think about it like a
+ *	* regular C structure local variable definition.
+ *	*
+ *	* This is how the trace record is structured and will
+ *	* be saved into the ring buffer. These are the fields
+ *	* that will be exposed to user-space in
+ *	* /debug/tracing/events/<*>/format.
+ *	*
+ *	* The declared 'local variable' is called '__entry'
+ *	*
+ *	* __field(pid_t, prev_prid) is equivalent to a standard declariton:
+ *	*
+ *	*	pid_t	prev_pid;
+ *	*
+ *	* __array(char, prev_comm, TASK_COMM_LEN) is equivalent to:
+ *	*
+ *	*	char	prev_comm[TASK_COMM_LEN];
+ *	*
+ *
+ *	TP_STRUCT__entry(
+ *		__array(	char,	prev_comm,	TASK_COMM_LEN	)
+ *		__field(	pid_t,	prev_pid			)
+ *		__field(	int,	prev_prio			)
+ *		__array(	char,	next_comm,	TASK_COMM_LEN	)
+ *		__field(	pid_t,	next_pid			)
+ *		__field(	int,	next_prio			)
+ *	),
+ *
+ *	*
+ *	* Assign the entry into the trace record, by embedding
+ *	* a full C statement block into TP_fast_assign(). You
+ *	* can refer to the trace record as '__entry' -
+ *	* otherwise you can put arbitrary C code in here.
+ *	*
+ *	* Note: this C code will execute every time a trace event
+ *	* happens, on an active tracepoint.
+ *	*
+ *
+ * 	TP_fast_assign(
+ * 		memcpy(__entry->next_comm, next->comm, TASK_COMM_LEN);
+ * 		__entry->prev_pid	= prev->pid;
+ * 		__entry->prev_prio	= prev->prio;
+ *		memcpy(__entry->prev_comm, prev->comm, TASK_COMM_LEN);
+ *		__entry->next_pid	= next->pid;
+ * 		__entry->next_prio	= next->prio;
+ *	)
+ *
+ *	*
+ *	* Formatted output of a trace record via TP_printk().
+ *	* This is how the tracepoint will appear under ftrace
+ *	* plugins that make use of this tracepoint.
+ *	*
+ *	* (raw-binary tracing wont actually perform this step.)
+ *	*
+ *
+ *	TP_printk("task %s:%d [%d] ==> %s:%d [%d]",
+ *		__entry->prev_comm, __entry->prev_pid, __entry->prev_prio,
+ *		__entry->next_comm, __entry->next_pid, __entry->next_prio),
+ *
+ * );
+ *
+ * This macro construct is thus used for the regular printk format
+ * tracing setup, it is used to construct a function pointer based
+ * tracepoint callback (this is used by programmatic plugins and
+ * can also by used by generic instrumentation like SystemTap), and
+ * it is also used to expose a structured trace record in
+ * /debug/tracing/events/.
+ */
+
 #define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 

commit 30a8fecc2d34f086df34fe2f2b926f080e002600
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Mar 10 12:41:38 2009 -0400

    tracing: flip the TP_printk and TP_fast_assign in the TRACE_EVENT macro
    
    Impact: clean up
    
    In trying to stay consistant with the C style format in the TRACE_EVENT
    macro, it makes more sense to do the printk after the assigning of
    the variables.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 69b56988813d..c7b09452514b 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -157,7 +157,7 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
-#define TRACE_EVENT(name, proto, args, struct, print, assign)	\
+#define TRACE_EVENT(name, proto, args, struct, assign, print)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
 #endif

commit 157587d7ac555458da9f682e3250135e468470a6
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Mar 10 00:15:34 2009 -0400

    tracing: remove obsolete TRACE_EVENT_FORMAT macro
    
    Impact: clean up
    
    The TRACE_EVENT_FORMAT macro is no longer used by trace points
    and only the DECLARE_TRACE, TRACE_FORMAT or TRACE_EVENT macros should
    be used by them. Although the TRACE_EVENT_FORMAT macro is still used
    by the internal tracing utility, it should not be used in core
    kernel code.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 6b4f1bb3701e..69b56988813d 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -157,9 +157,6 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
-#define TRACE_EVENT_FORMAT(name, proto, args, fmt, struct, tpfmt)	\
-	TRACE_FORMAT(name, PARAMS(proto), PARAMS(args), PARAMS(fmt))
-
 #define TRACE_EVENT(name, proto, args, struct, print, assign)	\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 

commit da4d03020c2af32f73e8bfbab0a66620d85bb9bb
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Mon Mar 9 17:14:30 2009 -0400

    tracing: new format for specialized trace points
    
    Impact: clean up and enhancement
    
    The TRACE_EVENT_FORMAT macro looks quite ugly and is limited in its
    ability to save data as well as to print the record out. Working with
    Ingo Molnar, we came up with a new format that is much more pleasing to
    the eye of C developers. This new macro is more C style than the old
    macro, and is more obvious to what it does.
    
    Here's the example. The only updated macro in this patch is the
    sched_switch trace point.
    
    The old method looked like this:
    
     TRACE_EVENT_FORMAT(sched_switch,
            TP_PROTO(struct rq *rq, struct task_struct *prev,
                    struct task_struct *next),
            TP_ARGS(rq, prev, next),
            TP_FMT("task %s:%d ==> %s:%d",
                  prev->comm, prev->pid, next->comm, next->pid),
            TRACE_STRUCT(
                    TRACE_FIELD(pid_t, prev_pid, prev->pid)
                    TRACE_FIELD(int, prev_prio, prev->prio)
                    TRACE_FIELD_SPECIAL(char next_comm[TASK_COMM_LEN],
                                        next_comm,
                                        TP_CMD(memcpy(TRACE_ENTRY->next_comm,
                                                     next->comm,
                                                     TASK_COMM_LEN)))
                    TRACE_FIELD(pid_t, next_pid, next->pid)
                    TRACE_FIELD(int, next_prio, next->prio)
            ),
            TP_RAW_FMT("prev %d:%d ==> next %s:%d:%d")
            );
    
    The above method is hard to read and requires two format fields.
    
    The new method:
    
     /*
      * Tracepoint for task switches, performed by the scheduler:
      *
      * (NOTE: the 'rq' argument is not used by generic trace events,
      *        but used by the latency tracer plugin. )
      */
     TRACE_EVENT(sched_switch,
    
            TP_PROTO(struct rq *rq, struct task_struct *prev,
                     struct task_struct *next),
    
            TP_ARGS(rq, prev, next),
    
            TP_STRUCT__entry(
                    __array(        char,   prev_comm,      TASK_COMM_LEN   )
                    __field(        pid_t,  prev_pid                        )
                    __field(        int,    prev_prio                       )
                    __array(        char,   next_comm,      TASK_COMM_LEN   )
                    __field(        pid_t,  next_pid                        )
                    __field(        int,    next_prio                       )
            ),
    
            TP_printk("task %s:%d [%d] ==> %s:%d [%d]",
                    __entry->prev_comm, __entry->prev_pid, __entry->prev_prio,
                    __entry->next_comm, __entry->next_pid, __entry->next_prio),
    
            TP_fast_assign(
                    memcpy(__entry->next_comm, next->comm, TASK_COMM_LEN);
                    __entry->prev_pid       = prev->pid;
                    __entry->prev_prio      = prev->prio;
                    memcpy(__entry->prev_comm, prev->comm, TASK_COMM_LEN);
                    __entry->next_pid       = next->pid;
                    __entry->next_prio      = next->prio;
            )
     );
    
    This macro is called TRACE_EVENT, it is broken up into 5 parts:
    
     TP_PROTO:        the proto type of the trace point
     TP_ARGS:         the arguments of the trace point
     TP_STRUCT_entry: the structure layout of the entry in the ring buffer
     TP_printk:       the printk format
     TP_fast_assign:  the method used to write the entry into the ring buffer
    
    The structure is the definition of how the event will be saved in the
    ring buffer. The printk is used by the internal tracing in case of
    an oops, and the kernel needs to print out the format of the record
    to the console. This the TP_printk gives a means to show the records
    in a human readable format. It is also used to print out the data
    from the trace file.
    
    The TP_fast_assign is executed directly. It is basically like a C function,
    where the __entry is the handle to the record.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 3bcc3e171443..6b4f1bb3701e 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -160,4 +160,7 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_EVENT_FORMAT(name, proto, args, fmt, struct, tpfmt)	\
 	TRACE_FORMAT(name, PARAMS(proto), PARAMS(args), PARAMS(fmt))
 
+#define TRACE_EVENT(name, proto, args, struct, print, assign)	\
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
+
 #endif

commit 2939b0469d04ba9ac791aca9a81625d7eb50662b
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Mon Mar 9 15:47:18 2009 -0400

    tracing: replace TP<var> with TP_<var>
    
    Impact: clean up
    
    The macros TPPROTO, TPARGS, TPFMT, TPRAWFMT, and TPCMD all look a bit
    ugly. This patch adds an underscore to their names.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 152b2f03fb86..3bcc3e171443 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -31,8 +31,8 @@ struct tracepoint {
 					 * Keep in sync with vmlinux.lds.h.
 					 */
 
-#define TPPROTO(args...)	args
-#define TPARGS(args...)		args
+#define TP_PROTO(args...)	args
+#define TP_ARGS(args...)		args
 
 #ifdef CONFIG_TRACEPOINTS
 
@@ -65,7 +65,7 @@ struct tracepoint {
 	{								\
 		if (unlikely(__tracepoint_##name.state))		\
 			__DO_TRACE(&__tracepoint_##name,		\
-				TPPROTO(proto), TPARGS(args));		\
+				TP_PROTO(proto), TP_ARGS(args));	\
 	}								\
 	static inline int register_trace_##name(void (*probe)(proto))	\
 	{								\

commit 629928041c53771f9902753d50fef6b35f36d33d
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Sat Feb 28 02:47:59 2009 -0500

    tracing: create the C style tracing for the sched subsystem
    
    This patch utilizes the TRACE_EVENT_FORMAT macro to enable the C style
    faster tracing for the sched subsystem trace points.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 62d13391a240..152b2f03fb86 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -157,4 +157,7 @@ static inline void tracepoint_synchronize_unregister(void)
 #define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
+#define TRACE_EVENT_FORMAT(name, proto, args, fmt, struct, tpfmt)	\
+	TRACE_FORMAT(name, PARAMS(proto), PARAMS(args), PARAMS(fmt))
+
 #endif

commit 3cdfdf91fcc77cfc82592e2b5c2ab35abe819c41
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Feb 25 15:54:30 2009 -0500

    tracing: wrap arguments with PARAMS
    
    Peter Zijlstra warned that TPPROTO and TPARGS might become something
    other than a simple copy of itself. To prevent this from having
    side effects in the TRACE_FORMAT macro in tracepoint.h, we add a
    PARAMS() macro to be defined as just a wrapper.
    
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 3de09fa8e01d..62d13391a240 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -153,7 +153,8 @@ static inline void tracepoint_synchronize_unregister(void)
 	synchronize_sched();
 }
 
+#define PARAMS(args...) args
 #define TRACE_FORMAT(name, proto, args, fmt)		\
-	DECLARE_TRACE(name, TPPROTO(proto), TPARGS(args))
+	DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))
 
 #endif

commit eef62a6826b8ab530cefff5aa55c1661a209c803
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Wed Feb 25 15:49:52 2009 -0500

    tracing: rename DEFINE_TRACE_FMT to just TRACE_FORMAT
    
    There's been a bit confusion to whether DEFINE/DECLARE_TRACE_FMT should
    be a DEFINE or a DECLARE. Ingo Molnar suggested simply calling it
    TRACE_FORMAT.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 34ae464effff..3de09fa8e01d 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -153,7 +153,7 @@ static inline void tracepoint_synchronize_unregister(void)
 	synchronize_sched();
 }
 
-#define DEFINE_TRACE_FMT(name, proto, args, fmt)		\
+#define TRACE_FORMAT(name, proto, args, fmt)		\
 	DECLARE_TRACE(name, TPPROTO(proto), TPARGS(args))
 
 #endif

commit 7c37730cd31ddb2d3a1da142af9b18c29b8c433b
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Tue Feb 24 12:07:53 2009 -0500

    tracing: add DEFINE_TRACE_FMT to tracepoint.h
    
    This patch creates a DEFINE_TRACE_FMT to map to DECLARE_TRACE.
    This allows for the developers to place format strings and
    args in with their tracepoint declaration. A tracer may now
    override the DEFINE_TRACE_FMT macro and use it to record
    a default format.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 757005458366..34ae464effff 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -153,4 +153,7 @@ static inline void tracepoint_synchronize_unregister(void)
 	synchronize_sched();
 }
 
+#define DEFINE_TRACE_FMT(name, proto, args, fmt)		\
+	DECLARE_TRACE(name, TPPROTO(proto), TPARGS(args))
+
 #endif

commit 7e066fb870fcd1025ec3ba7bbde5d541094f4ce1
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Nov 14 17:47:47 2008 -0500

    tracepoints: add DECLARE_TRACE() and DEFINE_TRACE()
    
    Impact: API *CHANGE*. Must update all tracepoint users.
    
    Add DEFINE_TRACE() to tracepoints to let them declare the tracepoint
    structure in a single spot for all the kernel. It helps reducing memory
    consumption, especially when declaring a lot of tracepoints, e.g. for
    kmalloc tracing.
    
    *API CHANGE WARNING*: now, DECLARE_TRACE() must be used in headers for
    tracepoint declarations rather than DEFINE_TRACE(). This is the sane way
    to do it. The name previously used was misleading.
    
    Updates scheduler instrumentation to follow this API change.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 7e9b42aeae0e..757005458366 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -24,8 +24,12 @@ struct tracepoint {
 	const char *name;		/* Tracepoint name */
 	int state;			/* State. */
 	void **funcs;
-} __attribute__((aligned(8)));
-
+} __attribute__((aligned(32)));		/*
+					 * Aligned on 32 bytes because it is
+					 * globally visible and gcc happily
+					 * align these on the structure size.
+					 * Keep in sync with vmlinux.lds.h.
+					 */
 
 #define TPPROTO(args...)	args
 #define TPARGS(args...)		args
@@ -55,15 +59,10 @@ struct tracepoint {
  * not add unwanted padding between the beginning of the section and the
  * structure. Force alignment to the same alignment as the section start.
  */
-#define DEFINE_TRACE(name, proto, args)					\
+#define DECLARE_TRACE(name, proto, args)				\
+	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
-		static const char __tpstrtab_##name[]			\
-		__attribute__((section("__tracepoints_strings")))	\
-		= #name;						\
-		static struct tracepoint __tracepoint_##name		\
-		__attribute__((section("__tracepoints"), aligned(8))) =	\
-		{ __tpstrtab_##name, 0, NULL };				\
 		if (unlikely(__tracepoint_##name.state))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TPPROTO(proto), TPARGS(args));		\
@@ -77,11 +76,23 @@ struct tracepoint {
 		return tracepoint_probe_unregister(#name, (void *)probe);\
 	}
 
+#define DEFINE_TRACE(name)						\
+	static const char __tpstrtab_##name[]				\
+	__attribute__((section("__tracepoints_strings"))) = #name;	\
+	struct tracepoint __tracepoint_##name				\
+	__attribute__((section("__tracepoints"), aligned(32))) =	\
+		{ __tpstrtab_##name, 0, NULL }
+
+#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)				\
+	EXPORT_SYMBOL_GPL(__tracepoint_##name)
+#define EXPORT_TRACEPOINT_SYMBOL(name)					\
+	EXPORT_SYMBOL(__tracepoint_##name)
+
 extern void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end);
 
 #else /* !CONFIG_TRACEPOINTS */
-#define DEFINE_TRACE(name, proto, args)			\
+#define DECLARE_TRACE(name, proto, args)				\
 	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
 	{ }								\
 	static inline void trace_##name(proto)				\
@@ -95,6 +106,10 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 		return -ENOSYS;						\
 	}
 
+#define DEFINE_TRACE(name)
+#define EXPORT_TRACEPOINT_SYMBOL_GPL(name)
+#define EXPORT_TRACEPOINT_SYMBOL(name)
+
 static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end)
 { }

commit 5f382671def7cb9c0f4b75d586dc5f60dca5e1c3
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Nov 14 17:47:45 2008 -0500

    tracepoints: do not put arguments in name
    
    Impact: cleanup
    
    That's overkill, takes space. We have a global tracepoint registery in
    header files anyway.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c60a791f8874..7e9b42aeae0e 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -60,7 +60,7 @@ struct tracepoint {
 	{								\
 		static const char __tpstrtab_##name[]			\
 		__attribute__((section("__tracepoints_strings")))	\
-		= #name ":" #proto;					\
+		= #name;						\
 		static struct tracepoint __tracepoint_##name		\
 		__attribute__((section("__tracepoints"), aligned(8))) =	\
 		{ __tpstrtab_##name, 0, NULL };				\
@@ -70,13 +70,11 @@ struct tracepoint {
 	}								\
 	static inline int register_trace_##name(void (*probe)(proto))	\
 	{								\
-		return tracepoint_probe_register(#name ":" #proto,	\
-			(void *)probe);					\
+		return tracepoint_probe_register(#name, (void *)probe);	\
 	}								\
 	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
-		return tracepoint_probe_unregister(#name ":" #proto,	\
-			(void *)probe);					\
+		return tracepoint_probe_unregister(#name, (void *)probe);\
 	}
 
 extern void tracepoint_update_probe_range(struct tracepoint *begin,

commit c420970ef476d7d68df119711700666224001f43
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Nov 14 17:47:44 2008 -0500

    tracepoints: use unregister return value
    
    Impact: bugfix.
    
    Unregistering a tracepoint can fail. Return the error value.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 69648c54a326..c60a791f8874 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -73,9 +73,9 @@ struct tracepoint {
 		return tracepoint_probe_register(#name ":" #proto,	\
 			(void *)probe);					\
 	}								\
-	static inline void unregister_trace_##name(void (*probe)(proto))\
+	static inline int unregister_trace_##name(void (*probe)(proto))	\
 	{								\
-		tracepoint_probe_unregister(#name ":" #proto,		\
+		return tracepoint_probe_unregister(#name ":" #proto,	\
 			(void *)probe);					\
 	}
 
@@ -92,8 +92,10 @@ extern void tracepoint_update_probe_range(struct tracepoint *begin,
 	{								\
 		return -ENOSYS;						\
 	}								\
-	static inline void unregister_trace_##name(void (*probe)(proto))\
-	{ }
+	static inline int unregister_trace_##name(void (*probe)(proto))	\
+	{								\
+		return -ENOSYS;						\
+	}
 
 static inline void tracepoint_update_probe_range(struct tracepoint *begin,
 	struct tracepoint *end)

commit da7b3eab167091693ad215ad7692f7d0d24d1356
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Nov 14 17:47:43 2008 -0500

    tracepoints: use rcu_*_sched_notrace
    
    Make sure tracepoints can be called within ftrace callbacks.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 63064e9403f2..69648c54a326 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -40,14 +40,14 @@ struct tracepoint {
 	do {								\
 		void **it_func;						\
 									\
-		rcu_read_lock_sched();					\
+		rcu_read_lock_sched_notrace();				\
 		it_func = rcu_dereference((tp)->funcs);			\
 		if (it_func) {						\
 			do {						\
 				((void(*)(proto))(*it_func))(args);	\
 			} while (*(++it_func));				\
 		}							\
-		rcu_read_unlock_sched();				\
+		rcu_read_unlock_sched_notrace();			\
 	} while (0)
 
 /*

commit 127cafbb276266b1b8da967bfe25a062ab1d42ab
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Tue Oct 28 10:51:53 2008 +0800

    tracepoint: introduce *_noupdate APIs.
    
    Impact: add new tracepoint APIs to allow the batched registration of probes
    
    new APIs separate tracepoint_probe_register(),
    tracepoint_probe_unregister() into 2 steps. The first step of them
    is just update tracepoint_entry, not connect or disconnect.
    
    this patch introduces tracepoint_probe_update_all() for update all.
    
    these APIs are very useful for registering lots of probes
    but just updating once. Another very important thing is that
    *_noupdate APIs do not require module_mutex.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Acked-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index c5bb39c7a770..63064e9403f2 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -112,6 +112,10 @@ extern int tracepoint_probe_register(const char *name, void *probe);
  */
 extern int tracepoint_probe_unregister(const char *name, void *probe);
 
+extern int tracepoint_probe_register_noupdate(const char *name, void *probe);
+extern int tracepoint_probe_unregister_noupdate(const char *name, void *probe);
+extern void tracepoint_probe_update_all(void);
+
 struct tracepoint_iter {
 	struct module *module;
 	struct tracepoint *tracepoint;

commit 231375cc5cc3549bb413f94a164bdcbd5f9ce943
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Oct 3 15:01:33 2008 -0400

    tracepoints: synchronize unregister static inline
    
    Turn tracepoint synchronize unregister into a static inline. There is no
    reason to keep it as a macro over a static inline.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index 199f4c207c1e..c5bb39c7a770 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -129,6 +129,9 @@ extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
  * probe unregistration and the end of module exit to make sure there is no
  * caller executing a probe when it is freed.
  */
-#define tracepoint_synchronize_unregister() synchronize_sched()
+static inline void tracepoint_synchronize_unregister(void)
+{
+	synchronize_sched();
+}
 
 #endif

commit f2461fc82a083dd60062e05e704c5fcc1c658ba1
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Mon Oct 6 10:33:00 2008 -0400

    tracepoints: tracepoint_synchronize_unregister()
    
    Create tracepoint_synchronize_unregister() which must be called before the end
    of exit() to make sure every probe callers have exited the non preemptible
    section and thus are not executing the probe code anymore.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index e623a6fca5c3..199f4c207c1e 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -124,4 +124,11 @@ extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
 extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
 	struct tracepoint *begin, struct tracepoint *end);
 
+/*
+ * tracepoint_synchronize_unregister must be called between the last tracepoint
+ * probe unregistration and the end of module exit to make sure there is no
+ * caller executing a probe when it is freed.
+ */
+#define tracepoint_synchronize_unregister() synchronize_sched()
+
 #endif

commit 97e1c18e8d17bd87e1e383b2e9d9fc740332c8e2
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Fri Jul 18 12:16:16 2008 -0400

    tracing: Kernel Tracepoints
    
    Implementation of kernel tracepoints. Inspired from the Linux Kernel
    Markers. Allows complete typing verification by declaring both tracing
    statement inline functions and probe registration/unregistration static
    inline functions within the same macro "DEFINE_TRACE". No format string
    is required. See the tracepoint Documentation and Samples patches for
    usage examples.
    
    Taken from the documentation patch :
    
    "A tracepoint placed in code provides a hook to call a function (probe)
    that you can provide at runtime. A tracepoint can be "on" (a probe is
    connected to it) or "off" (no probe is attached). When a tracepoint is
    "off" it has no effect, except for adding a tiny time penalty (checking
    a condition for a branch) and space penalty (adding a few bytes for the
    function call at the end of the instrumented function and adds a data
    structure in a separate section).  When a tracepoint is "on", the
    function you provide is called each time the tracepoint is executed, in
    the execution context of the caller. When the function provided ends its
    execution, it returns to the caller (continuing from the tracepoint
    site).
    
    You can put tracepoints at important locations in the code. They are
    lightweight hooks that can pass an arbitrary number of parameters, which
    prototypes are described in a tracepoint declaration placed in a header
    file."
    
    Addition and removal of tracepoints is synchronized by RCU using the
    scheduler (and preempt_disable) as guarantees to find a quiescent state
    (this is really RCU "classic"). The update side uses rcu_barrier_sched()
    with call_rcu_sched() and the read/execute side uses
    "preempt_disable()/preempt_enable()".
    
    We make sure the previous array containing probes, which has been
    scheduled for deletion by the rcu callback, is indeed freed before we
    proceed to the next update. It therefore limits the rate of modification
    of a single tracepoint to one update per RCU period. The objective here
    is to permit fast batch add/removal of probes on _different_
    tracepoints.
    
    Changelog :
    - Use #name ":" #proto as string to identify the tracepoint in the
      tracepoint table. This will make sure not type mismatch happens due to
      connexion of a probe with the wrong type to a tracepoint declared with
      the same name in a different header.
    - Add tracepoint_entry_free_old.
    - Change __TO_TRACE to get rid of the 'i' iterator.
    
    Masami Hiramatsu <mhiramat@redhat.com> :
    Tested on x86-64.
    
    Performance impact of a tracepoint : same as markers, except that it
    adds about 70 bytes of instructions in an unlikely branch of each
    instrumented function (the for loop, the stack setup and the function
    call). It currently adds a memory read, a test and a conditional branch
    at the instrumentation site (in the hot path). Immediate values will
    eventually change this into a load immediate, test and branch, which
    removes the memory read which will make the i-cache impact smaller
    (changing the memory read for a load immediate removes 3-4 bytes per
    site on x86_32 (depending on mov prefixes), or 7-8 bytes on x86_64, it
    also saves the d-cache hit).
    
    About the performance impact of tracepoints (which is comparable to
    markers), even without immediate values optimizations, tests done by
    Hideo Aoki on ia64 show no regression. His test case was using hackbench
    on a kernel where scheduler instrumentation (about 5 events in code
    scheduler code) was added.
    
    Quoting Hideo Aoki about Markers :
    
    I evaluated overhead of kernel marker using linux-2.6-sched-fixes git
    tree, which includes several markers for LTTng, using an ia64 server.
    
    While the immediate trace mark feature isn't implemented on ia64, there
    is no major performance regression. So, I think that we don't have any
    issues to propose merging marker point patches into Linus's tree from
    the viewpoint of performance impact.
    
    I prepared two kernels to evaluate. The first one was compiled without
    CONFIG_MARKERS. The second one was enabled CONFIG_MARKERS.
    
    I downloaded the original hackbench from the following URL:
    http://devresources.linux-foundation.org/craiger/hackbench/src/hackbench.c
    
    I ran hackbench 5 times in each condition and calculated the average and
    difference between the kernels.
    
        The parameter of hackbench: every 50 from 50 to 800
        The number of CPUs of the server: 2, 4, and 8
    
    Below is the results. As you can see, major performance regression
    wasn't found in any case. Even if number of processes increases,
    differences between marker-enabled kernel and marker- disabled kernel
    doesn't increase. Moreover, if number of CPUs increases, the differences
    doesn't increase either.
    
    Curiously, marker-enabled kernel is better than marker-disabled kernel
    in more than half cases, although I guess it comes from the difference
    of memory access pattern.
    
    * 2 CPUs
    
    Number of | without      | with         | diff     | diff    |
    processes | Marker [Sec] | Marker [Sec] |   [Sec]  |   [%]   |
    --------------------------------------------------------------
           50 |      4.811   |       4.872  |  +0.061  |  +1.27  |
          100 |      9.854   |      10.309  |  +0.454  |  +4.61  |
          150 |     15.602   |      15.040  |  -0.562  |  -3.6   |
          200 |     20.489   |      20.380  |  -0.109  |  -0.53  |
          250 |     25.798   |      25.652  |  -0.146  |  -0.56  |
          300 |     31.260   |      30.797  |  -0.463  |  -1.48  |
          350 |     36.121   |      35.770  |  -0.351  |  -0.97  |
          400 |     42.288   |      42.102  |  -0.186  |  -0.44  |
          450 |     47.778   |      47.253  |  -0.526  |  -1.1   |
          500 |     51.953   |      52.278  |  +0.325  |  +0.63  |
          550 |     58.401   |      57.700  |  -0.701  |  -1.2   |
          600 |     63.334   |      63.222  |  -0.112  |  -0.18  |
          650 |     68.816   |      68.511  |  -0.306  |  -0.44  |
          700 |     74.667   |      74.088  |  -0.579  |  -0.78  |
          750 |     78.612   |      79.582  |  +0.970  |  +1.23  |
          800 |     85.431   |      85.263  |  -0.168  |  -0.2   |
    --------------------------------------------------------------
    
    * 4 CPUs
    
    Number of | without      | with         | diff     | diff    |
    processes | Marker [Sec] | Marker [Sec] |   [Sec]  |   [%]   |
    --------------------------------------------------------------
           50 |      2.586   |       2.584  |  -0.003  |  -0.1   |
          100 |      5.254   |       5.283  |  +0.030  |  +0.56  |
          150 |      8.012   |       8.074  |  +0.061  |  +0.76  |
          200 |     11.172   |      11.000  |  -0.172  |  -1.54  |
          250 |     13.917   |      14.036  |  +0.119  |  +0.86  |
          300 |     16.905   |      16.543  |  -0.362  |  -2.14  |
          350 |     19.901   |      20.036  |  +0.135  |  +0.68  |
          400 |     22.908   |      23.094  |  +0.186  |  +0.81  |
          450 |     26.273   |      26.101  |  -0.172  |  -0.66  |
          500 |     29.554   |      29.092  |  -0.461  |  -1.56  |
          550 |     32.377   |      32.274  |  -0.103  |  -0.32  |
          600 |     35.855   |      35.322  |  -0.533  |  -1.49  |
          650 |     39.192   |      38.388  |  -0.804  |  -2.05  |
          700 |     41.744   |      41.719  |  -0.025  |  -0.06  |
          750 |     45.016   |      44.496  |  -0.520  |  -1.16  |
          800 |     48.212   |      47.603  |  -0.609  |  -1.26  |
    --------------------------------------------------------------
    
    * 8 CPUs
    
    Number of | without      | with         | diff     | diff    |
    processes | Marker [Sec] | Marker [Sec] |   [Sec]  |   [%]   |
    --------------------------------------------------------------
           50 |      2.094   |       2.072  |  -0.022  |  -1.07  |
          100 |      4.162   |       4.273  |  +0.111  |  +2.66  |
          150 |      6.485   |       6.540  |  +0.055  |  +0.84  |
          200 |      8.556   |       8.478  |  -0.078  |  -0.91  |
          250 |     10.458   |      10.258  |  -0.200  |  -1.91  |
          300 |     12.425   |      12.750  |  +0.325  |  +2.62  |
          350 |     14.807   |      14.839  |  +0.032  |  +0.22  |
          400 |     16.801   |      16.959  |  +0.158  |  +0.94  |
          450 |     19.478   |      19.009  |  -0.470  |  -2.41  |
          500 |     21.296   |      21.504  |  +0.208  |  +0.98  |
          550 |     23.842   |      23.979  |  +0.137  |  +0.57  |
          600 |     26.309   |      26.111  |  -0.198  |  -0.75  |
          650 |     28.705   |      28.446  |  -0.259  |  -0.9   |
          700 |     31.233   |      31.394  |  +0.161  |  +0.52  |
          750 |     34.064   |      33.720  |  -0.344  |  -1.01  |
          800 |     36.320   |      36.114  |  -0.206  |  -0.57  |
    --------------------------------------------------------------
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Acked-by: Masami Hiramatsu <mhiramat@redhat.com>
    Acked-by: 'Peter Zijlstra' <peterz@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
new file mode 100644
index 000000000000..e623a6fca5c3
--- /dev/null
+++ b/include/linux/tracepoint.h
@@ -0,0 +1,127 @@
+#ifndef _LINUX_TRACEPOINT_H
+#define _LINUX_TRACEPOINT_H
+
+/*
+ * Kernel Tracepoint API.
+ *
+ * See Documentation/tracepoint.txt.
+ *
+ * (C) Copyright 2008 Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
+ *
+ * Heavily inspired from the Linux Kernel Markers.
+ *
+ * This file is released under the GPLv2.
+ * See the file COPYING for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/rcupdate.h>
+
+struct module;
+struct tracepoint;
+
+struct tracepoint {
+	const char *name;		/* Tracepoint name */
+	int state;			/* State. */
+	void **funcs;
+} __attribute__((aligned(8)));
+
+
+#define TPPROTO(args...)	args
+#define TPARGS(args...)		args
+
+#ifdef CONFIG_TRACEPOINTS
+
+/*
+ * it_func[0] is never NULL because there is at least one element in the array
+ * when the array itself is non NULL.
+ */
+#define __DO_TRACE(tp, proto, args)					\
+	do {								\
+		void **it_func;						\
+									\
+		rcu_read_lock_sched();					\
+		it_func = rcu_dereference((tp)->funcs);			\
+		if (it_func) {						\
+			do {						\
+				((void(*)(proto))(*it_func))(args);	\
+			} while (*(++it_func));				\
+		}							\
+		rcu_read_unlock_sched();				\
+	} while (0)
+
+/*
+ * Make sure the alignment of the structure in the __tracepoints section will
+ * not add unwanted padding between the beginning of the section and the
+ * structure. Force alignment to the same alignment as the section start.
+ */
+#define DEFINE_TRACE(name, proto, args)					\
+	static inline void trace_##name(proto)				\
+	{								\
+		static const char __tpstrtab_##name[]			\
+		__attribute__((section("__tracepoints_strings")))	\
+		= #name ":" #proto;					\
+		static struct tracepoint __tracepoint_##name		\
+		__attribute__((section("__tracepoints"), aligned(8))) =	\
+		{ __tpstrtab_##name, 0, NULL };				\
+		if (unlikely(__tracepoint_##name.state))		\
+			__DO_TRACE(&__tracepoint_##name,		\
+				TPPROTO(proto), TPARGS(args));		\
+	}								\
+	static inline int register_trace_##name(void (*probe)(proto))	\
+	{								\
+		return tracepoint_probe_register(#name ":" #proto,	\
+			(void *)probe);					\
+	}								\
+	static inline void unregister_trace_##name(void (*probe)(proto))\
+	{								\
+		tracepoint_probe_unregister(#name ":" #proto,		\
+			(void *)probe);					\
+	}
+
+extern void tracepoint_update_probe_range(struct tracepoint *begin,
+	struct tracepoint *end);
+
+#else /* !CONFIG_TRACEPOINTS */
+#define DEFINE_TRACE(name, proto, args)			\
+	static inline void _do_trace_##name(struct tracepoint *tp, proto) \
+	{ }								\
+	static inline void trace_##name(proto)				\
+	{ }								\
+	static inline int register_trace_##name(void (*probe)(proto))	\
+	{								\
+		return -ENOSYS;						\
+	}								\
+	static inline void unregister_trace_##name(void (*probe)(proto))\
+	{ }
+
+static inline void tracepoint_update_probe_range(struct tracepoint *begin,
+	struct tracepoint *end)
+{ }
+#endif /* CONFIG_TRACEPOINTS */
+
+/*
+ * Connect a probe to a tracepoint.
+ * Internal API, should not be used directly.
+ */
+extern int tracepoint_probe_register(const char *name, void *probe);
+
+/*
+ * Disconnect a probe from a tracepoint.
+ * Internal API, should not be used directly.
+ */
+extern int tracepoint_probe_unregister(const char *name, void *probe);
+
+struct tracepoint_iter {
+	struct module *module;
+	struct tracepoint *tracepoint;
+};
+
+extern void tracepoint_iter_start(struct tracepoint_iter *iter);
+extern void tracepoint_iter_next(struct tracepoint_iter *iter);
+extern void tracepoint_iter_stop(struct tracepoint_iter *iter);
+extern void tracepoint_iter_reset(struct tracepoint_iter *iter);
+extern int tracepoint_get_iter_range(struct tracepoint **tracepoint,
+	struct tracepoint *begin, struct tracepoint *end);
+
+#endif
