commit 9a7875461fd0427dc86e3a87e93bd5723679b8b1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 28 16:45:14 2020 +0200

    PM: runtime: Replace pm_runtime_callbacks_present()
    
    The name of pm_runtime_callbacks_present() is confusing, because
    it suggests that the device has PM-runtime callbacks if 'true' is
    returned by that function, but in fact that may not be the case,
    so replace it with pm_runtime_has_no_callbacks() which is not
    ambiguous.
    
    No functional impact.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 3bdcbce8141a..3dbc207bff53 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -102,9 +102,9 @@ static inline bool pm_runtime_enabled(struct device *dev)
 	return !dev->power.disable_depth;
 }
 
-static inline bool pm_runtime_callbacks_present(struct device *dev)
+static inline bool pm_runtime_has_no_callbacks(struct device *dev)
 {
-	return !dev->power.no_callbacks;
+	return dev->power.no_callbacks;
 }
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)

commit c111566bea7ccd8a05e2c56f1fb3cbb6f4b7b441
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Feb 25 11:31:02 2020 +0200

    PM: runtime: Add pm_runtime_get_if_active()
    
    pm_runtime_get_if_in_use() bumps up the PM-runtime usage count if it
    is not equal to zero and the device's PM-runtime status is 'active'.
    This works for drivers that do not use autoidle, but for those that
    do, the function returns zero even when the device is active.
    
    In order to maintain sane device state while the device is powered on
    in the hope that it'll be needed, pm_runtime_get_if_active(dev, true)
    returns a positive value if the device's PM-runtime status is 'active'
    when it is called, in which case it also increments the device's usage
    count.
    
    If the second argument of pm_runtime_get_if_active() is 'false', the
    function behaves just like pm_runtime_get_if_in_use(), so redefine
    the latter as a wrapper around the former.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 22af69d237a6..3bdcbce8141a 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -38,7 +38,7 @@ extern int pm_runtime_force_resume(struct device *dev);
 extern int __pm_runtime_idle(struct device *dev, int rpmflags);
 extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
 extern int __pm_runtime_resume(struct device *dev, int rpmflags);
-extern int pm_runtime_get_if_in_use(struct device *dev);
+extern int pm_runtime_get_if_active(struct device *dev, bool ign_usage_count);
 extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
 extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
@@ -60,6 +60,11 @@ extern void pm_runtime_put_suppliers(struct device *dev);
 extern void pm_runtime_new_link(struct device *dev);
 extern void pm_runtime_drop_link(struct device *dev);
 
+static inline int pm_runtime_get_if_in_use(struct device *dev)
+{
+	return pm_runtime_get_if_active(dev, false);
+}
+
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
 {
 	dev->power.ignore_children = enable;
@@ -143,6 +148,11 @@ static inline int pm_runtime_get_if_in_use(struct device *dev)
 {
 	return -EINVAL;
 }
+static inline int pm_runtime_get_if_active(struct device *dev,
+					   bool ign_usage_count)
+{
+	return -EINVAL;
+}
 static inline int __pm_runtime_set_status(struct device *dev,
 					    unsigned int status) { return 0; }
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 9dc6eebf62d2..22af69d237a6 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -1,9 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * pm_runtime.h - Device run-time power management helper functions.
  *
  * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>
- *
- * This file is released under the GPLv2.
  */
 
 #ifndef _LINUX_PM_RUNTIME_H

commit 1cc9c59569e0ec69e9beadfe6ba8b2b7b22d57f0
Merge: 15efb47dc560 a08c2a5a3194
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 1 11:53:35 2019 +0100

    Merge back earlier PM core material for v5.1.

commit 15efb47dc560849d0c07db96fdad5121f2cf736e
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Wed Jan 30 18:26:02 2019 +0100

    PM-runtime: Fix deadlock with ktime_get()
    
    A deadlock has been seen when swicthing clocksources which use
    PM-runtime.  The call path is:
    
    change_clocksource
        ...
        write_seqcount_begin
        ...
        timekeeping_update
            ...
            sh_cmt_clocksource_enable
                ...
                rpm_resume
                    pm_runtime_mark_last_busy
                        ktime_get
                            do
                                read_seqcount_begin
                            while read_seqcount_retry
        ....
        write_seqcount_end
    
    Although we should be safe because we haven't yet changed the
    clocksource at that time, we can't do that because of seqcount
    protection.
    
    Use ktime_get_mono_fast_ns() instead which is lock safe for such
    cases.
    
    With ktime_get_mono_fast_ns, the timestamp is not guaranteed to be
    monotonic across an update and as a result can goes backward.
    According to update_fast_timekeeper() description: "In the worst
    case, this can result is a slightly wrong timestamp (a few
    nanoseconds)". For PM-runtime autosuspend, this means only that
    the suspend decision may be slightly suboptimal.
    
    Fixes: 8234f6734c5d ("PM-runtime: Switch autosuspend over to using hrtimers")
    Reported-by: Biju Das <biju.das@bp.renesas.com>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 54af4eef169f..fed5be706bc9 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -105,7 +105,7 @@ static inline bool pm_runtime_callbacks_present(struct device *dev)
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
-	WRITE_ONCE(dev->power.last_busy, ktime_to_ns(ktime_get()));
+	WRITE_ONCE(dev->power.last_busy, ktime_get_mono_fast_ns());
 }
 
 static inline bool pm_runtime_is_irq_safe(struct device *dev)

commit 8a62ffe2753a845272f4f2100b5fca0b6053ff6f
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Fri Dec 21 11:33:54 2018 +0100

    PM-runtime: Add new interface to get accounted time
    
    Some drivers (like i915/drm) needs to get the accounted suspended time.
    pm_runtime_suspended_time() will return the suspended accounted time
    in ns unit.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 54af4eef169f..a370006921c0 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -113,6 +113,8 @@ static inline bool pm_runtime_is_irq_safe(struct device *dev)
 	return dev->power.irq_safe;
 }
 
+extern u64 pm_runtime_suspended_time(struct device *dev);
+
 #else /* !CONFIG_PM */
 
 static inline bool queue_pm_work(struct work_struct *work) { return false; }

commit 8234f6734c5d74ac794e5517437f51c57d65f865
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Fri Dec 14 15:22:25 2018 +0100

    PM-runtime: Switch autosuspend over to using hrtimers
    
    PM-runtime uses the timer infrastructure for autosuspend. This implies
    that the minimum time before autosuspending a device is in the range
    of 1 tick included to 2 ticks excluded
     -On arm64 this means between 4ms and 8ms with default jiffies
      configuration
     -And on arm, it is between 10ms and 20ms
    
    These values are quite high for embedded systems which sometimes want
    the duration to be in the range of 1 ms.
    
    It is possible to switch autosuspend over to using hrtimers to get
    finer granularity for short durations and take advantage of slack to
    retain some margins and get long timeouts with minimum wakeups.
    
    On an arm64 platform that uses 1ms for autosuspending timeout of its
    GPU, idle power is reduced by 10% with hrtimer.
    
    The latency impact on arm64 hikey octo cores is:
     - mark_last_busy: from 1.11 us to 1.25 us
     - rpm_suspend: from 15.54 us to 15.38 us
    [Only the code path of rpm_suspend() that starts hrtimer has been
    measured.]
    
    arm64 image (arm64 default defconfig) decreases by around 3KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    12034646        6869268  386840 19290754        1265a82 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    12030550        6870164  387032 19287746        1264ec2 vmlinux
    
    The latency impact on arm 32bits snowball dual cores is :
     - mark_last_busy: from 0.31 us usec to 0.77 us
     - rpm_suspend: from 6.83 us to 6.67 usec
    
    The increase of the image for snowball platform that I used for
    testing performance impact, is neglictable (244B).
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    7157961 2119580  264120 9541661  91981d build-ux500/vmlinux
    
    size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    7157773 2119884  264248 9541905  919911 vmlinux-hrtimer
    
    And arm 32bits image (multi_v7_defconfig) increases by around 1.7KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    13304443        6803420  402768 20510631        138f7a7 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    13304299        6805276  402768 20512343        138fe57 vmlinux
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index f0fc4700b6ff..54af4eef169f 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -51,7 +51,7 @@ extern void pm_runtime_no_callbacks(struct device *dev);
 extern void pm_runtime_irq_safe(struct device *dev);
 extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
 extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
-extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
+extern u64 pm_runtime_autosuspend_expiration(struct device *dev);
 extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
 extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
@@ -105,7 +105,7 @@ static inline bool pm_runtime_callbacks_present(struct device *dev)
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
-	WRITE_ONCE(dev->power.last_busy, jiffies);
+	WRITE_ONCE(dev->power.last_busy, ktime_to_ns(ktime_get()));
 }
 
 static inline bool pm_runtime_is_irq_safe(struct device *dev)
@@ -168,7 +168,7 @@ static inline void __pm_runtime_use_autosuspend(struct device *dev,
 						bool use) {}
 static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 						int delay) {}
-static inline unsigned long pm_runtime_autosuspend_expiration(
+static inline u64 pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 						bool enable){}

commit b06c0b2f087ab498d51d50f5ae353133b602f614
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 12 10:24:13 2018 +0200

    Revert "PM / runtime: Fixup reference counting of device link suppliers at probe"
    
    Revert commit 1e8378619841 (PM / runtime: Fixup reference counting of
    device link suppliers at probe), as it has introduced a regression
    and the condition it was designed to address should be covered by the
    existing code.
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index db5dbbf7a48d..f0fc4700b6ff 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -56,7 +56,8 @@ extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
 extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
 extern void pm_runtime_clean_up_links(struct device *dev);
-extern void pm_runtime_resume_suppliers(struct device *dev);
+extern void pm_runtime_get_suppliers(struct device *dev);
+extern void pm_runtime_put_suppliers(struct device *dev);
 extern void pm_runtime_new_link(struct device *dev);
 extern void pm_runtime_drop_link(struct device *dev);
 
@@ -172,7 +173,8 @@ static inline unsigned long pm_runtime_autosuspend_expiration(
 static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 						bool enable){}
 static inline void pm_runtime_clean_up_links(struct device *dev) {}
-static inline void pm_runtime_resume_suppliers(struct device *dev) {}
+static inline void pm_runtime_get_suppliers(struct device *dev) {}
+static inline void pm_runtime_put_suppliers(struct device *dev) {}
 static inline void pm_runtime_new_link(struct device *dev) {}
 static inline void pm_runtime_drop_link(struct device *dev) {}
 

commit 1e8378619841ef1d621b130bbd3fc3b7e6739b50
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 18 10:48:49 2018 +0200

    PM / runtime: Fixup reference counting of device link suppliers at probe
    
    In the driver core, before it invokes really_probe() it runtime resumes the
    suppliers for the device via calling pm_runtime_get_suppliers(), which also
    increases the runtime PM usage count for each of the available supplier.
    
    This makes sense, as to be able to allow the consumer device to be probed
    by its driver. However, if the driver decides to add a new supplier link
    during ->probe(), hence updating the list of suppliers, the following call
    to pm_runtime_put_suppliers(), invoked after really_probe() in the driver
    core, we get into trouble.
    
    More precisely, pm_runtime_put() gets called also for the new supplier(s),
    which is wrong as the driver core, didn't trigger pm_runtime_get_sync() to
    be called for it in the first place. In other words, the new supplier may
    be runtime suspended even in cases when it shouldn't.
    
    Fix this behaviour, by runtime resume suppliers according to the same
    conditions as managed by the runtime PM core, when runtime resume callbacks
    are being invoked.
    
    Additionally, don't try to runtime suspend any of the suppliers after
    really_probe(), but instead rely on that to happen via the consumer device,
    when it becomes runtime suspended.
    
    Fixes: 21d5c57b3726 (PM / runtime: Use device links)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index f0fc4700b6ff..db5dbbf7a48d 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -56,8 +56,7 @@ extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
 extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
 extern void pm_runtime_clean_up_links(struct device *dev);
-extern void pm_runtime_get_suppliers(struct device *dev);
-extern void pm_runtime_put_suppliers(struct device *dev);
+extern void pm_runtime_resume_suppliers(struct device *dev);
 extern void pm_runtime_new_link(struct device *dev);
 extern void pm_runtime_drop_link(struct device *dev);
 
@@ -173,8 +172,7 @@ static inline unsigned long pm_runtime_autosuspend_expiration(
 static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 						bool enable){}
 static inline void pm_runtime_clean_up_links(struct device *dev) {}
-static inline void pm_runtime_get_suppliers(struct device *dev) {}
-static inline void pm_runtime_put_suppliers(struct device *dev) {}
+static inline void pm_runtime_resume_suppliers(struct device *dev) {}
 static inline void pm_runtime_new_link(struct device *dev) {}
 static inline void pm_runtime_drop_link(struct device *dev) {}
 

commit 6aa7de059173a986114ac43b8f50b297a86f09a8
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Oct 23 14:07:29 2017 -0700

    locking/atomics: COCCINELLE/treewide: Convert trivial ACCESS_ONCE() patterns to READ_ONCE()/WRITE_ONCE()
    
    Please do not apply this to mainline directly, instead please re-run the
    coccinelle script shown below and apply its output.
    
    For several reasons, it is desirable to use {READ,WRITE}_ONCE() in
    preference to ACCESS_ONCE(), and new code is expected to use one of the
    former. So far, there's been no reason to change most existing uses of
    ACCESS_ONCE(), as these aren't harmful, and changing them results in
    churn.
    
    However, for some features, the read/write distinction is critical to
    correct operation. To distinguish these cases, separate read/write
    accessors must be used. This patch migrates (most) remaining
    ACCESS_ONCE() instances to {READ,WRITE}_ONCE(), using the following
    coccinelle script:
    
    ----
    // Convert trivial ACCESS_ONCE() uses to equivalent READ_ONCE() and
    // WRITE_ONCE()
    
    // $ make coccicheck COCCI=/home/mark/once.cocci SPFLAGS="--include-headers" MODE=patch
    
    virtual patch
    
    @ depends on patch @
    expression E1, E2;
    @@
    
    - ACCESS_ONCE(E1) = E2
    + WRITE_ONCE(E1, E2)
    
    @ depends on patch @
    expression E;
    @@
    
    - ACCESS_ONCE(E)
    + READ_ONCE(E)
    ----
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: davem@davemloft.net
    Cc: linux-arch@vger.kernel.org
    Cc: mpe@ellerman.id.au
    Cc: shuah@kernel.org
    Cc: snitzer@redhat.com
    Cc: thor.thayer@linux.intel.com
    Cc: tj@kernel.org
    Cc: viro@zeniv.linux.org.uk
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1508792849-3115-19-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 2efb08a60e63..f0fc4700b6ff 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -105,7 +105,7 @@ static inline bool pm_runtime_callbacks_present(struct device *dev)
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
-	ACCESS_ONCE(dev->power.last_busy) = jiffies;
+	WRITE_ONCE(dev->power.last_busy, jiffies);
 }
 
 static inline bool pm_runtime_is_irq_safe(struct device *dev)

commit de3ef1eb1cd0cc3a75f7a3661e10ed827f370ab8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:58:53 2017 +0200

    PM / core: Drop run_wake flag from struct dev_pm_info
    
    The run_wake flag in struct dev_pm_info is used to indicate whether
    or not the device is capable of generating remote wakeup signals at
    run time (or in the system working state), but the distinction
    between runtime remote wakeup and system wakeup signaling has always
    been rather artificial.  The only practical reason for it to exist
    at the core level was that ACPI and PCI treated those two cases
    differently, but that's not the case any more after recent changes.
    
    For this reason, get rid of the run_wake flag and, when applicable,
    use device_set_wakeup_capable() and device_can_wakeup() instead of
    device_set_run_wake() and device_run_wake(), respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index ca4823e675e2..2efb08a60e63 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -76,16 +76,6 @@ static inline void pm_runtime_put_noidle(struct device *dev)
 	atomic_add_unless(&dev->power.usage_count, -1, 0);
 }
 
-static inline bool device_run_wake(struct device *dev)
-{
-	return dev->power.run_wake;
-}
-
-static inline void device_set_run_wake(struct device *dev, bool enable)
-{
-	dev->power.run_wake = enable;
-}
-
 static inline bool pm_runtime_suspended(struct device *dev)
 {
 	return dev->power.runtime_status == RPM_SUSPENDED
@@ -163,8 +153,6 @@ static inline void pm_runtime_forbid(struct device *dev) {}
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable) {}
 static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}
-static inline bool device_run_wake(struct device *dev) { return false; }
-static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }

commit 098c30557a9a19827240aaadc137e4668157dc6b
Merge: 72cca7baf4fb 5d47ec02c37e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:42:18 2016 -0800

    Merge tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the new driver core patches for 4.10-rc1.
    
      Big thing here is the nice addition of "functional dependencies" to
      the driver core. The idea has been talked about for a very long time,
      great job to Rafael for stepping up and implementing it. It's been
      tested for longer than the 4.9-rc1 date, we held off on merging it
      earlier in order to feel more comfortable about it.
    
      Other than that, it's just a handful of small other patches, some good
      cleanups to the mess that is the firmware class code, and we have a
      test driver for the deferred probe logic.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (30 commits)
      firmware: Correct handling of fw_state_wait() return value
      driver core: Silence device links sphinx warning
      firmware: remove warning at documentation generation time
      drivers: base: dma-mapping: Fix typo in dmam_alloc_non_coherent comments
      driver core: test_async: fix up typo found by 0-day
      firmware: move fw_state_is_done() into UHM section
      firmware: do not use fw_lock for fw_state protection
      firmware: drop bit ops in favor of simple state machine
      firmware: refactor loading status
      firmware: fix usermode helper fallback loading
      driver core: firmware_class: convert to use class_groups
      driver core: devcoredump: convert to use class_groups
      driver core: class: add class_groups support
      kernfs: Declare two local data structures static
      driver-core: fix platform_no_drv_owner.cocci warnings
      drivers/base/memory.c: Remove unused 'first_page' variable
      driver core: add CLASS_ATTR_WO()
      drivers: base: cacheinfo: support DT overrides for cache properties
      drivers: base: cacheinfo: add pr_fmt logging
      drivers: base: cacheinfo: fix boot error message when acpi is enabled
      ...

commit baa8809f60971d10220dfe79248f54b2b265f003
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:43 2016 +0100

    PM / runtime: Optimize the use of device links
    
    If the device has no links to suppliers that should be used for
    runtime PM (links with DEVICE_LINK_PM_RUNTIME set), there is no
    reason to walk the list of suppliers for that device during
    runtime suspend and resume.
    
    Add a simple mechanism to detect that case and possibly avoid the
    extra unnecessary overhead.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index c2ee87138e4a..73814877537d 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -58,6 +58,8 @@ extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
 extern void pm_runtime_clean_up_links(struct device *dev);
 extern void pm_runtime_get_suppliers(struct device *dev);
 extern void pm_runtime_put_suppliers(struct device *dev);
+extern void pm_runtime_new_link(struct device *dev);
+extern void pm_runtime_drop_link(struct device *dev);
 
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
 {
@@ -192,6 +194,8 @@ static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 static inline void pm_runtime_clean_up_links(struct device *dev) {}
 static inline void pm_runtime_get_suppliers(struct device *dev) {}
 static inline void pm_runtime_put_suppliers(struct device *dev) {}
+static inline void pm_runtime_new_link(struct device *dev) {}
+static inline void pm_runtime_drop_link(struct device *dev) {}
 
 #endif /* !CONFIG_PM */
 

commit 21d5c57b3726166421251e94dabab047baaf8ce4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:31 2016 +0100

    PM / runtime: Use device links
    
    Modify the runtime PM framework to use device links to ensure that
    supplier devices will not be suspended if any of their consumer
    devices are active.
    
    The idea is to reference count suppliers on the consumer's resume
    and drop references to them on its suspend.  The information on
    whether or not the supplier has been reference counted by the
    consumer's (runtime) resume is stored in a new field (rpm_active)
    in the link object for each link.
    
    It may be necessary to clean up those references when the
    supplier is unbinding and that's why the links whose status is
    DEVICE_LINK_SUPPLIER_UNBIND are skipped by the runtime suspend
    and resume code.
    
    The above means that if the consumer device is probed in the
    runtime-active state, the supplier has to be resumed and reference
    counted by device_link_add() so the code works as expected on its
    (runtime) suspend.  There is a new flag, DEVICE_LINK_RPM_ACTIVE,
    to tell device_link_add() about that (in which case the caller
    is responsible for making sure that the consumer really will
    be runtime-active when runtime PM is enabled for it).
    
    The other new link flag, DEVICE_LINK_PM_RUNTIME, tells the core
    whether or not the link should be used for runtime PM at all.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 2e14d2667b6c..c2ee87138e4a 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -55,6 +55,9 @@ extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
 extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
 extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
+extern void pm_runtime_clean_up_links(struct device *dev);
+extern void pm_runtime_get_suppliers(struct device *dev);
+extern void pm_runtime_put_suppliers(struct device *dev);
 
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
 {
@@ -186,6 +189,9 @@ static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 						bool enable){}
+static inline void pm_runtime_clean_up_links(struct device *dev) {}
+static inline void pm_runtime_get_suppliers(struct device *dev) {}
+static inline void pm_runtime_put_suppliers(struct device *dev) {}
 
 #endif /* !CONFIG_PM */
 

commit b1a60995a684f2b6052cda640b0704361ab40089
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 17 20:17:00 2016 +0200

    PM / Runtime: Convert pm_runtime_set_suspended() to return an int
    
    Because pm_runtime_set_suspended() invokes __pm_runtime_set_status(), which
    can fail, pm_runtime_set_suspended() can also fail.
    
    Instead of hiding a potential error, let's propagate it by converting
    pm_runtime_set_suspended() from a void to return an int. In this way users
    are able to check the error code and act accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 61ea5666c94c..4957fc185ea9 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -258,9 +258,9 @@ static inline int pm_runtime_set_active(struct device *dev)
 	return __pm_runtime_set_status(dev, RPM_ACTIVE);
 }
 
-static inline void pm_runtime_set_suspended(struct device *dev)
+static inline int pm_runtime_set_suspended(struct device *dev)
 {
-	__pm_runtime_set_status(dev, RPM_SUSPENDED);
+	return __pm_runtime_set_status(dev, RPM_SUSPENDED);
 }
 
 static inline void pm_runtime_disable(struct device *dev)

commit 62006c1702b3b1be0c0726949e0ee0ea2326be9c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 17 20:16:58 2016 +0200

    PM / Runtime: Remove the exported function pm_children_suspended()
    
    The exported function pm_children_suspended() has only one caller, which is
    the runtime PM internal function, rpm_check_suspend_allowed().
    
    Let's clean-up this code, by removing pm_children_suspended() altogether
    and instead do the one-liner check directly in rpm_check_suspend_allowed().
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 2e14d2667b6c..61ea5666c94c 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -61,12 +61,6 @@ static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
 	dev->power.ignore_children = enable;
 }
 
-static inline bool pm_children_suspended(struct device *dev)
-{
-	return dev->power.ignore_children
-		|| !atomic_read(&dev->power.child_count);
-}
-
 static inline void pm_runtime_get_noresume(struct device *dev)
 {
 	atomic_inc(&dev->power.usage_count);
@@ -162,7 +156,6 @@ static inline void pm_runtime_allow(struct device *dev) {}
 static inline void pm_runtime_forbid(struct device *dev) {}
 
 static inline void pm_suspend_ignore_children(struct device *dev, bool enable) {}
-static inline bool pm_children_suspended(struct device *dev) { return false; }
 static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }

commit 372a12ed9d99c02f105278a9b75f0cb176d15cc1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Apr 8 13:40:53 2016 +0200

    PM / Runtime: Move ignore_children flag under CONFIG_PM
    
    The ignore_children flag is used only when CONFIG_PM is set, so let's move
    it into that section within the struct dev_pm_info.
    
    Move also the corresponding pm_suspend_ignore_children() API out of
    device.h into pm_runtime.h, to be consistent with similar APIs.
    
    Unfortunate this causes the Toshiba PCI SD mmc host driver to fail to
    compile as it needs pm_runtime.h, so let's fix this here as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 7af093d6a4dd..2e14d2667b6c 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -56,6 +56,11 @@ extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
 extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
 
+static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
+{
+	dev->power.ignore_children = enable;
+}
+
 static inline bool pm_children_suspended(struct device *dev)
 {
 	return dev->power.ignore_children
@@ -156,6 +161,7 @@ static inline void __pm_runtime_disable(struct device *dev, bool c) {}
 static inline void pm_runtime_allow(struct device *dev) {}
 static inline void pm_runtime_forbid(struct device *dev) {}
 
+static inline void pm_suspend_ignore_children(struct device *dev, bool enable) {}
 static inline bool pm_children_suspended(struct device *dev) { return false; }
 static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}

commit a436b6a19f57656a6557439523923d89eb4a880d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 17 02:54:26 2015 +0100

    PM / runtime: Add new helper for conditional usage count incrementation
    
    Introduce a new runtime PM function, pm_runtime_get_if_in_use(),
    that will increment the device's runtime PM usage counter and
    return 1 if its status is RPM_ACTIVE and its usage counter
    is greater than 0 at the same time (0 will be returned otherwise).
    
    This is useful for things that should only be done if the device
    is active (from the runtime PM perspective) and used by somebody
    (as indicated by the usage counter) already and they are not worth
    bothering otherwise.
    
    Requested-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 3bdbb4189780..7af093d6a4dd 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -39,6 +39,7 @@ extern int pm_runtime_force_resume(struct device *dev);
 extern int __pm_runtime_idle(struct device *dev, int rpmflags);
 extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
 extern int __pm_runtime_resume(struct device *dev, int rpmflags);
+extern int pm_runtime_get_if_in_use(struct device *dev);
 extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
 extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
@@ -143,6 +144,10 @@ static inline int pm_schedule_suspend(struct device *dev, unsigned int delay)
 {
 	return -ENOSYS;
 }
+static inline int pm_runtime_get_if_in_use(struct device *dev)
+{
+	return -EINVAL;
+}
 static inline int __pm_runtime_set_status(struct device *dev,
 					    unsigned int status) { return 0; }
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }

commit 019d8817b1b064c2bacfbcf40fc68184438ad05a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 15 14:40:06 2015 +0200

    PM / sleep: Allow devices without runtime PM to do direct-complete
    
    Don't unset the direct_complete flag on devices that have runtime PM
    disabled, if they are runtime suspended.
    
    This is needed because otherwise ancestor devices wouldn't be able to
    do direct_complete without adding runtime PM support to all its
    descendants.
    
    Also removes pm_runtime_suspended_if_enabled() because it's now unused.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 30e84d48bfea..3bdbb4189780 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -98,11 +98,6 @@ static inline bool pm_runtime_status_suspended(struct device *dev)
 	return dev->power.runtime_status == RPM_SUSPENDED;
 }
 
-static inline bool pm_runtime_suspended_if_enabled(struct device *dev)
-{
-	return pm_runtime_status_suspended(dev) && dev->power.disable_depth == 1;
-}
-
 static inline bool pm_runtime_enabled(struct device *dev)
 {
 	return !dev->power.disable_depth;
@@ -164,7 +159,6 @@ static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
-static inline bool pm_runtime_suspended_if_enabled(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline void pm_runtime_no_callbacks(struct device *dev) {}

commit 26ceb127f7bcf473db926c6a026b18ddd6f274e8
Merge: 8d1406675559 e9f2d6d66037
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 12 15:26:48 2014 -0800

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "The major updates included in this update are:
    
       - Clang compatible stack pointer accesses by Behan Webster.
       - SA11x0 updates from Dmitry Eremin-Solenikov.
       - kgdb handling of breakpoints with read-only text/modules
       - Support for Privileged-no-execute feature on ARMv7 to prevent
         userspace code execution by the kernel.
       - AMBA primecell bus handling of irq-safe runtime PM
       - Unwinding support for memset/memzero/memmove/memcpy functions
       - VFP fixes for Krait CPUs and improvements in detecting the VFP
         architecture
       - A number of code cleanups (using pr_*, removing or reducing the
         severity of a couple of kernel messages, splitting ftrace asm code
         out to a separate file, etc.)
       - Add machine name to stack dump output"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (62 commits)
      ARM: 8247/2: pcmcia: sa1100: make use of device clock
      ARM: 8246/2: pcmcia: sa1111: provide device clock
      ARM: 8245/1: pcmcia: soc-common: enable/disable socket clocks
      ARM: 8244/1: fbdev: sa1100fb: make use of device clock
      ARM: 8243/1: sa1100: add a clock alias for sa1111 pcmcia device
      ARM: 8242/1: sa1100: add cpu clock
      ARM: 8221/1: PJ4: allow building in Thumb-2 mode
      ARM: 8234/1: sa1100: reorder IRQ handling code
      ARM: 8233/1: sa1100: switch to hwirq usage
      ARM: 8232/1: sa1100: merge GPIO multiplexer IRQ to "normal" irq domain
      ARM: 8231/1: sa1100: introduce irqdomains support
      ARM: 8230/1: sa1100: shift IRQs by one
      ARM: 8229/1: sa1100: replace irq numbers with names in irq driver
      ARM: 8228/1: sa1100: drop entry-macro.S
      ARM: 8227/1: sa1100: switch to MULTI_IRQ_HANDLER
      ARM: 8241/1: Update processor_modes for hyp and monitor mode
      ARM: 8240/1: MCPM: document mcpm_sync_init()
      ARM: 8239/1: Introduce {set,clear}_pte_bit
      ARM: 8238/1: mm: Refine set_memory_* functions
      ARM: 8237/1: fix flush_pfn_alias
      ...

commit d30d819dc83107812d9b2876e5e7194e511ed6af
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:05 2014 +0100

    PM: Drop CONFIG_PM_RUNTIME from the driver core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM or even may be dropped entirely in some cases.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the PM core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 367f49b9a1c9..eda4feede048 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -35,16 +35,6 @@ extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern int pm_runtime_force_suspend(struct device *dev);
 extern int pm_runtime_force_resume(struct device *dev);
-#else
-static inline bool queue_pm_work(struct work_struct *work) { return false; }
-
-static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
-static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
-static inline int pm_runtime_force_suspend(struct device *dev) { return 0; }
-static inline int pm_runtime_force_resume(struct device *dev) { return 0; }
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
 
 extern int __pm_runtime_idle(struct device *dev, int rpmflags);
 extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
@@ -128,7 +118,14 @@ static inline void pm_runtime_mark_last_busy(struct device *dev)
 	ACCESS_ONCE(dev->power.last_busy) = jiffies;
 }
 
-#else /* !CONFIG_PM_RUNTIME */
+#else /* !CONFIG_PM */
+
+static inline bool queue_pm_work(struct work_struct *work) { return false; }
+
+static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
+static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
+static inline int pm_runtime_force_suspend(struct device *dev) { return 0; }
+static inline int pm_runtime_force_resume(struct device *dev) { return 0; }
 
 static inline int __pm_runtime_idle(struct device *dev, int rpmflags)
 {
@@ -179,7 +176,7 @@ static inline unsigned long pm_runtime_autosuspend_expiration(
 static inline void pm_runtime_set_memalloc_noio(struct device *dev,
 						bool enable){}
 
-#endif /* !CONFIG_PM_RUNTIME */
+#endif /* !CONFIG_PM */
 
 static inline int pm_runtime_idle(struct device *dev)
 {

commit 3fb1581ea1ab0aec6ac5430dc0e257a8c9b71680
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Nov 14 09:47:25 2014 +0100

    ARM: 8199/1: PM / Runtime: Add getter for querying the IRQ safe option v12
    
    Add a simple getter pm_runtime_is_irq_safe() for querying whether runtime
    PM IRQ safe was set or not.
    
    Various bus drivers implementing runtime PM may use choose to suspend
    differently based on IRQ safeness status of child driver (e.g. do not
    unprepare the clock if IRQ safe is not set).
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 367f49b9a1c9..44d74f0f182e 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -128,6 +128,11 @@ static inline void pm_runtime_mark_last_busy(struct device *dev)
 	ACCESS_ONCE(dev->power.last_busy) = jiffies;
 }
 
+static inline bool pm_runtime_is_irq_safe(struct device *dev)
+{
+	return dev->power.irq_safe;
+}
+
 #else /* !CONFIG_PM_RUNTIME */
 
 static inline int __pm_runtime_idle(struct device *dev, int rpmflags)
@@ -167,6 +172,7 @@ static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
 static inline void pm_runtime_irq_safe(struct device *dev) {}
+static inline bool pm_runtime_is_irq_safe(struct device *dev) { return false; }
 
 static inline bool pm_runtime_callbacks_present(struct device *dev) { return false; }
 static inline void pm_runtime_mark_last_busy(struct device *dev) {}

commit 28cb5ef16e578bbca0a562b09f12c8c98ca92720
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:00:36 2014 +0200

    PM: Create PM workqueue if runtime PM is not configured too
    
    The PM workqueue is going to be used by ACPI PM notify handlers
    regardless of whether or not runtime PM is configured, so move
    it out of #ifdef CONFIG_PM_RUNTIME.
    
    Do that in three places in the ACPI device PM code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 43fd6716f662..367f49b9a1c9 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -24,11 +24,20 @@
 #define RPM_AUTO		0x08	/* Use autosuspend_delay */
 
 #ifdef CONFIG_PM
+extern struct workqueue_struct *pm_wq;
+
+static inline bool queue_pm_work(struct work_struct *work)
+{
+	return queue_work(pm_wq, work);
+}
+
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern int pm_runtime_force_suspend(struct device *dev);
 extern int pm_runtime_force_resume(struct device *dev);
 #else
+static inline bool queue_pm_work(struct work_struct *work) { return false; }
+
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline int pm_runtime_force_suspend(struct device *dev) { return 0; }
@@ -37,8 +46,6 @@ static inline int pm_runtime_force_resume(struct device *dev) { return 0; }
 
 #ifdef CONFIG_PM_RUNTIME
 
-extern struct workqueue_struct *pm_wq;
-
 extern int __pm_runtime_idle(struct device *dev, int rpmflags);
 extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
 extern int __pm_runtime_resume(struct device *dev, int rpmflags);

commit aae4518b3124b29f8dc81c829c704fd2df72e98b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 16 02:46:50 2014 +0200

    PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily
    
    Currently, some subsystems (e.g. PCI and the ACPI PM domain) have to
    resume all runtime-suspended devices during system suspend, mostly
    because those devices may need to be reprogrammed due to different
    wakeup settings for system sleep and for runtime PM.
    
    For some devices, though, it's OK to remain in runtime suspend
    throughout a complete system suspend/resume cycle (if the device was in
    runtime suspend at the start of the cycle).  We would like to do this
    whenever possible, to avoid the overhead of extra power-up and power-down
    events.
    
    However, problems may arise because the device's descendants may require
    it to be at full power at various points during the cycle.  Therefore the
    most straightforward way to do this safely is if the device and all its
    descendants can remain runtime suspended until the complete stage of
    system resume.
    
    To this end, introduce a new device PM flag, power.direct_complete
    and modify the PM core to use that flag as follows.
    
    If the ->prepare() callback of a device returns a positive number,
    the PM core will regard that as an indication that it may leave the
    device runtime-suspended.  It will then check if the system power
    transition in progress is a suspend (and not hibernation in particular)
    and if the device is, indeed, runtime-suspended.  In that case, the PM
    core will set the device's power.direct_complete flag.  Otherwise it
    will clear power.direct_complete for the device and it also will later
    clear it for the device's parent (if there's one).
    
    Next, the PM core will not invoke the ->suspend() ->suspend_late(),
    ->suspend_irq(), ->resume_irq(), ->resume_early(), or ->resume()
    callbacks for all devices having power.direct_complete set.  It
    will invoke their ->complete() callbacks, however, and those
    callbacks are then responsible for resuming the devices as
    appropriate, if necessary.  For example, in some cases they may
    need to queue up runtime resume requests for the devices using
    pm_request_resume().
    
    Changelog partly based on an Alan Stern's description of the idea
    (http://marc.info/?l=linux-pm&m=139940466625569&w=2).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 2a5897a4afbc..43fd6716f662 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -101,6 +101,11 @@ static inline bool pm_runtime_status_suspended(struct device *dev)
 	return dev->power.runtime_status == RPM_SUSPENDED;
 }
 
+static inline bool pm_runtime_suspended_if_enabled(struct device *dev)
+{
+	return pm_runtime_status_suspended(dev) && dev->power.disable_depth == 1;
+}
+
 static inline bool pm_runtime_enabled(struct device *dev)
 {
 	return !dev->power.disable_depth;
@@ -150,6 +155,7 @@ static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
+static inline bool pm_runtime_suspended_if_enabled(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline void pm_runtime_no_callbacks(struct device *dev) {}

commit 37f204164dfb0186a0caf20bc3e3120080bcd788
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sat Mar 1 11:56:05 2014 +0100

    PM: Add pm_runtime_suspend|resume_force functions
    
    This patch provides two new runtime PM helper functions which intend to
    be used from system suspend/resume callbacks, to make sure devices are
    put into low power state during system suspend and brought back to full
    power at system resume.
    
    The prerequisite is to have all levels of a device's runtime PM
    callbacks to be defined through the SET_PM_RUNTIME_PM_OPS macro, which
    means these are available for CONFIG_PM.
    
    By using the new runtime PM helper functions especially the two
    scenarios below will be addressed.
    
    1) The PM core prevents .runtime_suspend callbacks from being invoked
    during system suspend. That means even for a runtime PM centric
    subsystem and driver, the device needs to be put into low power state
    from a system suspend callback. Otherwise it may very well be left in
    full power state (runtime resumed) while the system is suspended. By
    using the new helper functions, we make sure to walk the hierarchy of
    a device's power domain, subsystem and driver.
    
    2) Subsystems and drivers need to cope with all the combinations of
    CONFIG_PM_SLEEP and CONFIG_PM_RUNTIME. The two new helper functions
    smothly addresses this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 16c9a62fa1c0..2a5897a4afbc 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -26,9 +26,13 @@
 #ifdef CONFIG_PM
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
+extern int pm_runtime_force_suspend(struct device *dev);
+extern int pm_runtime_force_resume(struct device *dev);
 #else
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
+static inline int pm_runtime_force_suspend(struct device *dev) { return 0; }
+static inline int pm_runtime_force_resume(struct device *dev) { return 0; }
 #endif
 
 #ifdef CONFIG_PM_RUNTIME

commit 717e5d458e3bfca495a38dca61c64f274c049e46
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Dec 10 14:37:41 2013 +0100

    PM / Runtime: Implement the pm_generic_runtime functions for CONFIG_PM
    
    The pm_generic_runtime_suspend|resume functions were implemented within
    CONFIG_PM_RUNTIME.
    
    As we also may use runtime PM callbacks during system suspend, to put
    devices into low power state, we need to move the implementation of
    pm_generic_runtime_suspend|resume to CONFIG_PM.
    
    This change gives a power domain provision to invoke a platform
    driver's runtime PM callback from a power domain's system PM callback.
    This were earlier prevented by the platform bus, since it uses the
    pm_generic_runtime_suspend|resume functions as runtime PM callbacks.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 6fa7cea25da9..16c9a62fa1c0 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -23,6 +23,14 @@
 					    usage_count */
 #define RPM_AUTO		0x08	/* Use autosuspend_delay */
 
+#ifdef CONFIG_PM
+extern int pm_generic_runtime_suspend(struct device *dev);
+extern int pm_generic_runtime_resume(struct device *dev);
+#else
+static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
+static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
+#endif
+
 #ifdef CONFIG_PM_RUNTIME
 
 extern struct workqueue_struct *pm_wq;
@@ -37,8 +45,6 @@ extern void pm_runtime_enable(struct device *dev);
 extern void __pm_runtime_disable(struct device *dev, bool check_resume);
 extern void pm_runtime_allow(struct device *dev);
 extern void pm_runtime_forbid(struct device *dev);
-extern int pm_generic_runtime_suspend(struct device *dev);
-extern int pm_generic_runtime_resume(struct device *dev);
 extern void pm_runtime_no_callbacks(struct device *dev);
 extern void pm_runtime_irq_safe(struct device *dev);
 extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
@@ -142,8 +148,6 @@ static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
-static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
-static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
 static inline void pm_runtime_irq_safe(struct device *dev) {}
 

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 7d7e09efff9b..6fa7cea25da9 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -37,7 +37,6 @@ extern void pm_runtime_enable(struct device *dev);
 extern void __pm_runtime_disable(struct device *dev, bool check_resume);
 extern void pm_runtime_allow(struct device *dev);
 extern void pm_runtime_forbid(struct device *dev);
-extern int pm_generic_runtime_idle(struct device *dev);
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern void pm_runtime_no_callbacks(struct device *dev);
@@ -143,7 +142,6 @@ static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
-static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}

commit e823407f7b11fa06ba8e7a2801eb9ed11268a7ec
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Feb 22 16:34:11 2013 -0800

    pm / runtime: introduce pm_runtime_set_memalloc_noio()
    
    Introduce the flag memalloc_noio in 'struct dev_pm_info' to help PM core
    to teach mm not allocating memory with GFP_KERNEL flag for avoiding
    probable deadlock.
    
    As explained in the comment, any GFP_KERNEL allocation inside
    runtime_resume() or runtime_suspend() on any one of device in the path
    from one block or network device to the root device in the device tree
    may cause deadlock, the introduced pm_runtime_set_memalloc_noio() sets
    or clears the flag on device in the path recursively.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Oliver Neukum <oneukum@suse.de>
    Cc: Jiri Kosina <jiri.kosina@suse.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: David Decotigny <david.decotigny@google.com>
    Cc: Tom Herbert <therbert@google.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index c785c215abfc..7d7e09efff9b 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -47,6 +47,7 @@ extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
 extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
 extern void pm_runtime_update_max_time_suspended(struct device *dev,
 						 s64 delta_ns);
+extern void pm_runtime_set_memalloc_noio(struct device *dev, bool enable);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -156,6 +157,8 @@ static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 						int delay) {}
 static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
+static inline void pm_runtime_set_memalloc_noio(struct device *dev,
+						bool enable){}
 
 #endif /* !CONFIG_PM_RUNTIME */
 

commit fbadc58dd3a52c330c8f3926aa93011bf9d91fa0
Author: ShuoX Liu <shuox.liu@intel.com>
Date:   Wed Jan 23 21:49:37 2013 +0100

    PM / Runtime: Add new helper function: pm_runtime_active()
    
    This boolean function simply returns whether or not the runtime
    status of the device is 'active'. The typical scenario is driver
    calls pm_runtime_get firstly, then check pm_runtime_active in
    atomic environment.
    
    Also add entry to Documentation/power/runtime.txt
    
    Signed-off-by: Yanmin Zhang <yanmin.zhang@intel.com>
    Signed-off-by: ShuoX Liu <shuox.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index f271860c78d5..c785c215abfc 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -80,6 +80,12 @@ static inline bool pm_runtime_suspended(struct device *dev)
 		&& !dev->power.disable_depth;
 }
 
+static inline bool pm_runtime_active(struct device *dev)
+{
+	return dev->power.runtime_status == RPM_ACTIVE
+		|| dev->power.disable_depth;
+}
+
 static inline bool pm_runtime_status_suspended(struct device *dev)
 {
 	return dev->power.runtime_status == RPM_SUSPENDED;
@@ -132,6 +138,7 @@ static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }
 static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
+static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 

commit 76e267d822f2913893ad210ba431607aa8e2af94
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:54:36 2012 +0200

    PM / Runtime: Remove device fields related to suspend time, v2
    
    After the previous changes in default_stop_ok() and
    default_power_down_ok() for PM domains, there are two fields in
    struct dev_pm_info that aren't necessary any more,  suspend_time
    and max_time_suspended_ns.
    
    Remove those fields along with all of the code that accesses them,
    which simplifies the runtime PM framework quite a bit.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 609daae7a014..f271860c78d5 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -150,9 +150,6 @@ static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 
-static inline void pm_runtime_update_max_time_suspended(struct device *dev,
-							s64 delta_ns) {}
-
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev)

commit 00dc9ad18d707f36b2fb4af98fd2cf0548d2b258
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 1 00:01:31 2011 +0100

    PM / Runtime: Use device PM QoS constraints (v2)
    
    Make the runtime PM core use device PM QoS constraints to check if
    it is allowed to suspend a given device, so that an error code is
    returned if the device's own PM QoS constraint is negative or one of
    its children has already been suspended for too long.  If this is
    not the case, the maximum estimated time the device is allowed to be
    suspended, computed as the minimum of the device's PM QoS constraint
    and the PM QoS constraints of its children (reduced by the difference
    between the current time and their suspend times) is stored in a new
    device's PM field power.max_time_suspended_ns that can be used by
    the device's subsystem or PM domain to decide whether or not to put
    the device into lower-power (and presumably higher-latency) states
    later (if the constraint is 0, which means "no constraint", the
    power.max_time_suspended_ns is set to -1).
    
    Additionally, the time of execution of the subsystem-level
    .runtime_suspend() callback for the device is recorded in the new
    power.suspend_time field for later use by the device's subsystem or
    PM domain along with power.max_time_suspended_ns (it also is used
    by the core code when the device's parent is suspended).
    
    Introduce a new helper function,
    pm_runtime_update_max_time_suspended(), allowing subsystems and PM
    domains (or device drivers) to update the power.max_time_suspended_ns
    field, for example after changing the power state of a suspended
    device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d3085e72a0ee..609daae7a014 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -45,6 +45,8 @@ extern void pm_runtime_irq_safe(struct device *dev);
 extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
 extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
 extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
+extern void pm_runtime_update_max_time_suspended(struct device *dev,
+						 s64 delta_ns);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -148,6 +150,9 @@ static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 
+static inline void pm_runtime_update_max_time_suspended(struct device *dev,
+							s64 delta_ns) {}
+
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev)

commit 8b258cc8ac229aa7d5dcb7cc34cb35d9124498ac
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 17 21:39:33 2011 +0100

    PM Sleep: Do not extend wakeup paths to devices with ignore_children set
    
    Commit 4ca46ff3e0d8c234cb40ebb6457653b59584426c (PM / Sleep: Mark
    devices involved in wakeup signaling during suspend) introduced
    the power.wakeup_path field in struct dev_pm_info to mark devices
    whose children are enabled to wake up the system from sleep states,
    so that power domains containing the parents that provide their
    children with wakeup power and/or relay their wakeup signals are not
    turned off.  Unfortunately, that introduced a PM regression on SH7372
    whose power consumption in the system "memory sleep" state increased
    as a result of it, because it prevented the power domain containing
    the I2C controller from being turned off when some children of that
    controller were enabled to wake up the system, although the
    controller was not necessary for them to signal wakeup.
    
    To fix this issue use the observation that devices whose
    power.ignore_children flag is set for runtime PM should be treated
    analogously during system suspend.  Namely, they shouldn't be
    included in wakeup paths going through their children.  Since the
    SH7372 I2C controller's power.ignore_children flag is set, doing so
    will restore the previous behavior of that SOC.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d8d903619642..d3085e72a0ee 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -52,11 +52,6 @@ static inline bool pm_children_suspended(struct device *dev)
 		|| !atomic_read(&dev->power.child_count);
 }
 
-static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
-{
-	dev->power.ignore_children = enable;
-}
-
 static inline void pm_runtime_get_noresume(struct device *dev)
 {
 	atomic_inc(&dev->power.usage_count);
@@ -130,7 +125,6 @@ static inline void pm_runtime_allow(struct device *dev) {}
 static inline void pm_runtime_forbid(struct device *dev) {}
 
 static inline bool pm_children_suspended(struct device *dev) { return false; }
-static inline void pm_suspend_ignore_children(struct device *dev, bool en) {}
 static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }

commit 246359d37985000b8403487e46867c4eb610af72
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 07:08:41 2011 -0400

    pm_runtime.h: explicitly requires notifier.h
    
    This file was getting notifier.h via device.h --> module.h but
    the module.h inclusion is going away, so add notifier.h directly.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 70b284024d9e..d8d903619642 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -10,6 +10,7 @@
 #define _LINUX_PM_RUNTIME_H
 
 #include <linux/device.h>
+#include <linux/notifier.h>
 #include <linux/pm.h>
 
 #include <linux/jiffies.h>

commit b5e8d269d814763d597ccc0108d1fa6639ad35a1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:19 2011 +0200

    PM: Move clock-related definitions and headers to separate file
    
    Since the PM clock management code in drivers/base/power/clock_ops.c
    is used for both runtime PM and system suspend/hibernation, the
    definitions of data structures and headers related to it should not
    be located in include/linux/pm_rumtime.h.  Move them to a separate
    header file.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index a5a41a850efb..70b284024d9e 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -251,60 +251,4 @@ static inline void pm_runtime_dont_use_autosuspend(struct device *dev)
 	__pm_runtime_use_autosuspend(dev, false);
 }
 
-struct pm_clk_notifier_block {
-	struct notifier_block nb;
-	struct dev_pm_domain *pm_domain;
-	char *con_ids[];
-};
-
-#ifdef CONFIG_PM_CLK
-static inline bool pm_clk_no_clocks(struct device *dev)
-{
-	return dev && dev->power.subsys_data
-		&& list_empty(&dev->power.subsys_data->clock_list);
-}
-
-extern void pm_clk_init(struct device *dev);
-extern int pm_clk_create(struct device *dev);
-extern void pm_clk_destroy(struct device *dev);
-extern int pm_clk_add(struct device *dev, const char *con_id);
-extern void pm_clk_remove(struct device *dev, const char *con_id);
-extern int pm_clk_suspend(struct device *dev);
-extern int pm_clk_resume(struct device *dev);
-#else
-static inline bool pm_clk_no_clocks(struct device *dev)
-{
-	return true;
-}
-static inline void pm_clk_init(struct device *dev)
-{
-}
-static inline int pm_clk_create(struct device *dev)
-{
-	return -EINVAL;
-}
-static inline void pm_clk_destroy(struct device *dev)
-{
-}
-static inline int pm_clk_add(struct device *dev, const char *con_id)
-{
-	return -EINVAL;
-}
-static inline void pm_clk_remove(struct device *dev, const char *con_id)
-{
-}
-#define pm_clk_suspend	NULL
-#define pm_clk_resume	NULL
-#endif
-
-#ifdef CONFIG_HAVE_CLK
-extern void pm_clk_add_notifier(struct bus_type *bus,
-					struct pm_clk_notifier_block *clknb);
-#else
-static inline void pm_clk_add_notifier(struct bus_type *bus,
-					struct pm_clk_notifier_block *clknb)
-{
-}
-#endif
-
 #endif

commit 4605ab653c1f9d7cc2dda8033de215c9cee325f4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:12 2011 +0200

    PM / Domains: Use power.sybsys_data to reduce overhead
    
    Currently pm_genpd_runtime_resume() has to walk the list of devices
    from the device's PM domain to find the corresponding device list
    object containing the need_restore field to check if the driver's
    .runtime_resume() callback should be executed for the device.
    This is suboptimal and can be simplified by using power.sybsys_data
    to store device information used by the generic PM domains code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 6b90630e3c98..a5a41a850efb 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -258,6 +258,12 @@ struct pm_clk_notifier_block {
 };
 
 #ifdef CONFIG_PM_CLK
+static inline bool pm_clk_no_clocks(struct device *dev)
+{
+	return dev && dev->power.subsys_data
+		&& list_empty(&dev->power.subsys_data->clock_list);
+}
+
 extern void pm_clk_init(struct device *dev);
 extern int pm_clk_create(struct device *dev);
 extern void pm_clk_destroy(struct device *dev);
@@ -266,6 +272,10 @@ extern void pm_clk_remove(struct device *dev, const char *con_id);
 extern int pm_clk_suspend(struct device *dev);
 extern int pm_clk_resume(struct device *dev);
 #else
+static inline bool pm_clk_no_clocks(struct device *dev)
+{
+	return true;
+}
 static inline void pm_clk_init(struct device *dev)
 {
 }

commit 5c095a0e0d600d5a5a4207eaadabd18db46395ce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:33:50 2011 +0200

    PM: Introduce struct pm_subsys_data
    
    Introduce struct pm_subsys_data that may be subclassed by subsystems
    to store subsystem-specific information related to the device.  Move
    the clock management fields accessed through the power.subsys_data
    pointer in struct device to the new strucutre.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index daac05d751b2..6b90630e3c98 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -258,14 +258,18 @@ struct pm_clk_notifier_block {
 };
 
 #ifdef CONFIG_PM_CLK
-extern int pm_clk_init(struct device *dev);
+extern void pm_clk_init(struct device *dev);
+extern int pm_clk_create(struct device *dev);
 extern void pm_clk_destroy(struct device *dev);
 extern int pm_clk_add(struct device *dev, const char *con_id);
 extern void pm_clk_remove(struct device *dev, const char *con_id);
 extern int pm_clk_suspend(struct device *dev);
 extern int pm_clk_resume(struct device *dev);
 #else
-static inline int pm_clk_init(struct device *dev)
+static inline void pm_clk_init(struct device *dev)
+{
+}
+static inline int pm_clk_create(struct device *dev)
 {
 	return -EINVAL;
 }

commit f3393b62f157cc87f8d78247e97b87778dc077b8
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Jul 12 11:17:09 2011 +0200

    PM / Runtime: Add new helper function: pm_runtime_status_suspended()
    
    This boolean function simply returns whether or not the runtime status
    of the device is 'suspended'.  Unlike pm_runtime_suspended(), this
    function returns the runtime status whether or not runtime PM for the
    device has been disabled or not.
    
    Also add entry to Documentation/power/runtime.txt
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index dfb8539ed686..daac05d751b2 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -82,6 +82,11 @@ static inline bool pm_runtime_suspended(struct device *dev)
 		&& !dev->power.disable_depth;
 }
 
+static inline bool pm_runtime_status_suspended(struct device *dev)
+{
+	return dev->power.runtime_status == RPM_SUSPENDED;
+}
+
 static inline bool pm_runtime_enabled(struct device *dev)
 {
 	return !dev->power.disable_depth;
@@ -130,6 +135,7 @@ static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }
 static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
+static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }

commit 3d5c30367cbc0c55c93bb158e824e00badc7ddc4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 1 22:13:44 2011 +0200

    PM: Rename clock management functions
    
    The common PM clock management functions may be used for system
    suspend/resume as well as for runtime PM, so rename them
    accordingly.  Modify kerneldoc comments describing these functions
    and kernel messages printed by them, so that they refer to power
    management in general rather that to runtime PM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 1bd5063a2cc8..dfb8539ed686 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -252,36 +252,36 @@ struct pm_clk_notifier_block {
 };
 
 #ifdef CONFIG_PM_CLK
-extern int pm_runtime_clk_init(struct device *dev);
-extern void pm_runtime_clk_destroy(struct device *dev);
-extern int pm_runtime_clk_add(struct device *dev, const char *con_id);
-extern void pm_runtime_clk_remove(struct device *dev, const char *con_id);
-extern int pm_runtime_clk_suspend(struct device *dev);
-extern int pm_runtime_clk_resume(struct device *dev);
+extern int pm_clk_init(struct device *dev);
+extern void pm_clk_destroy(struct device *dev);
+extern int pm_clk_add(struct device *dev, const char *con_id);
+extern void pm_clk_remove(struct device *dev, const char *con_id);
+extern int pm_clk_suspend(struct device *dev);
+extern int pm_clk_resume(struct device *dev);
 #else
-static inline int pm_runtime_clk_init(struct device *dev)
+static inline int pm_clk_init(struct device *dev)
 {
 	return -EINVAL;
 }
-static inline void pm_runtime_clk_destroy(struct device *dev)
+static inline void pm_clk_destroy(struct device *dev)
 {
 }
-static inline int pm_runtime_clk_add(struct device *dev, const char *con_id)
+static inline int pm_clk_add(struct device *dev, const char *con_id)
 {
 	return -EINVAL;
 }
-static inline void pm_runtime_clk_remove(struct device *dev, const char *con_id)
+static inline void pm_clk_remove(struct device *dev, const char *con_id)
 {
 }
-#define pm_runtime_clock_suspend	NULL
-#define pm_runtime_clock_resume		NULL
+#define pm_clk_suspend	NULL
+#define pm_clk_resume	NULL
 #endif
 
 #ifdef CONFIG_HAVE_CLK
-extern void pm_runtime_clk_add_notifier(struct bus_type *bus,
+extern void pm_clk_add_notifier(struct bus_type *bus,
 					struct pm_clk_notifier_block *clknb);
 #else
-static inline void pm_runtime_clk_add_notifier(struct bus_type *bus,
+static inline void pm_clk_add_notifier(struct bus_type *bus,
 					struct pm_clk_notifier_block *clknb)
 {
 }

commit b7b95920aa2e89e655afe9913ee0e55855ceda90
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 1 22:13:37 2011 +0200

    PM: Allow the clocks management code to be used during system suspend
    
    The common clocks management code in drivers/base/power/clock_ops.c
    is going to be used during system-wide power transitions as well as
    for runtime PM, so it shouldn't depend on CONFIG_PM_RUNTIME.
    However, the suspend/resume functions provided by it for
    CONFIG_PM_RUNTIME unset, to be used during system-wide power
    transitions, should not behave in the same way as their counterparts
    defined for CONFIG_PM_RUNTIME set, because in that case the clocks
    are managed differently at run time.
    
    The names of the functions still contain the word "runtime" after
    this change, but that is going to be modified by a separate patch
    later.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index ef91904c7110..1bd5063a2cc8 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -251,7 +251,7 @@ struct pm_clk_notifier_block {
 	char *con_ids[];
 };
 
-#ifdef CONFIG_PM_RUNTIME_CLK
+#ifdef CONFIG_PM_CLK
 extern int pm_runtime_clk_init(struct device *dev);
 extern void pm_runtime_clk_destroy(struct device *dev);
 extern int pm_runtime_clk_add(struct device *dev, const char *con_id);

commit 564b905ab10d17fb42f86aa8b7b9b796276d1336
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 23 01:52:55 2011 +0200

    PM / Domains: Rename struct dev_power_domain to struct dev_pm_domain
    
    The naming convention used by commit 7538e3db6e015e890825fbd9f86599b
    (PM: Add support for device power domains), which introduced the
    struct dev_power_domain type for representing device power domains,
    evidently confuses some developers who tend to think that objects
    of this type must correspond to "power domains" as defined by
    hardware, which is not the case.  Namely, at the kernel level, a
    struct dev_power_domain object can represent arbitrary set of devices
    that are mutually dependent power management-wise and need not belong
    to one hardware power domain.  To avoid that confusion, rename struct
    dev_power_domain to struct dev_pm_domain and rename the related
    pointers in struct device and struct pm_clk_notifier_block from
    pwr_domain to pm_domain.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 878cf84baeb1..ef91904c7110 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -247,7 +247,7 @@ static inline void pm_runtime_dont_use_autosuspend(struct device *dev)
 
 struct pm_clk_notifier_block {
 	struct notifier_block nb;
-	struct dev_power_domain *pwr_domain;
+	struct dev_pm_domain *pm_domain;
 	char *con_ids[];
 };
 

commit 85eb8c8d0b0900c073b0e6f89979ac9c439ade1a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Apr 30 00:25:44 2011 +0200

    PM / Runtime: Generic clock manipulation rountines for runtime PM (v6)
    
    Many different platforms and subsystems may want to disable device
    clocks during suspend and enable them during resume which is going to
    be done in a very similar way in all those cases.  For this reason,
    provide generic routines for the manipulation of device clocks during
    suspend and resume.
    
    Convert the ARM shmobile platform to using the new routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 8de9aa6e7def..878cf84baeb1 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -245,4 +245,46 @@ static inline void pm_runtime_dont_use_autosuspend(struct device *dev)
 	__pm_runtime_use_autosuspend(dev, false);
 }
 
+struct pm_clk_notifier_block {
+	struct notifier_block nb;
+	struct dev_power_domain *pwr_domain;
+	char *con_ids[];
+};
+
+#ifdef CONFIG_PM_RUNTIME_CLK
+extern int pm_runtime_clk_init(struct device *dev);
+extern void pm_runtime_clk_destroy(struct device *dev);
+extern int pm_runtime_clk_add(struct device *dev, const char *con_id);
+extern void pm_runtime_clk_remove(struct device *dev, const char *con_id);
+extern int pm_runtime_clk_suspend(struct device *dev);
+extern int pm_runtime_clk_resume(struct device *dev);
+#else
+static inline int pm_runtime_clk_init(struct device *dev)
+{
+	return -EINVAL;
+}
+static inline void pm_runtime_clk_destroy(struct device *dev)
+{
+}
+static inline int pm_runtime_clk_add(struct device *dev, const char *con_id)
+{
+	return -EINVAL;
+}
+static inline void pm_runtime_clk_remove(struct device *dev, const char *con_id)
+{
+}
+#define pm_runtime_clock_suspend	NULL
+#define pm_runtime_clock_resume		NULL
+#endif
+
+#ifdef CONFIG_HAVE_CLK
+extern void pm_runtime_clk_add_notifier(struct bus_type *bus,
+					struct pm_clk_notifier_block *clknb);
+#else
+static inline void pm_runtime_clk_add_notifier(struct bus_type *bus,
+					struct pm_clk_notifier_block *clknb)
+{
+}
+#endif
+
 #endif

commit cb8f51bdadb7969139c2e39c2defd4cde98c1ea8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:26:02 2011 +0100

    PM: Do not create wakeup sysfs files for devices that cannot wake up
    
    Currently, wakeup sysfs attributes are created for all devices,
    regardless of whether or not they are wakeup-capable.  This is
    excessive and complicates wakeup device identification from user
    space (i.e. to identify wakeup-capable devices user space has to read
    /sys/devices/.../power/wakeup for all devices and see if they are not
    empty).
    
    Fix this issue by avoiding to create wakeup sysfs files for devices
    that cannot wake up the system from sleep states (i.e. whose
    power.can_wakeup flags are unset during registration) and modify
    device_set_wakeup_capable() so that it adds (or removes) the relevant
    sysfs attributes if a device's wakeup capability status is changed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d34f067e2a7f..8de9aa6e7def 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -87,6 +87,11 @@ static inline bool pm_runtime_enabled(struct device *dev)
 	return !dev->power.disable_depth;
 }
 
+static inline bool pm_runtime_callbacks_present(struct device *dev)
+{
+	return !dev->power.no_callbacks;
+}
+
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
 	ACCESS_ONCE(dev->power.last_busy) = jiffies;
@@ -133,6 +138,7 @@ static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
 static inline void pm_runtime_irq_safe(struct device *dev) {}
 
+static inline bool pm_runtime_callbacks_present(struct device *dev) { return false; }
 static inline void pm_runtime_mark_last_busy(struct device *dev) {}
 static inline void __pm_runtime_use_autosuspend(struct device *dev,
 						bool use) {}

commit 4b31db8a16fa0d4d6a0fa42d044e7a4f4dad3641
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 24 15:04:06 2010 +0100

    PM / Runtime: Generic resume shouldn't set RPM_ACTIVE unconditionally
    
    The __pm_generic_resume() function changes the given device's runtime
    PM status to RPM_ACTIVE if its driver's callback returns 0, but it
    only should do that if the rumtime PM is enabled for the device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index e9cc049ccb62..d34f067e2a7f 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -82,6 +82,11 @@ static inline bool pm_runtime_suspended(struct device *dev)
 		&& !dev->power.disable_depth;
 }
 
+static inline bool pm_runtime_enabled(struct device *dev)
+{
+	return !dev->power.disable_depth;
+}
+
 static inline void pm_runtime_mark_last_busy(struct device *dev)
 {
 	ACCESS_ONCE(dev->power.last_busy) = jiffies;
@@ -120,6 +125,7 @@ static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }
 static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
+static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }

commit c7b61de5b7b17f0df34dc7d2f8b9576f8bd36fce
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 1 00:14:42 2010 +0100

    PM / Runtime: Add synchronous runtime interface for interrupt handlers (v3)
    
    This patch (as1431c) makes the synchronous runtime-PM interface
    suitable for use in interrupt handlers.  Subsystems can call the new
    pm_runtime_irq_safe() function to tell the PM core that a device's
    runtime_suspend and runtime_resume callbacks should be invoked with
    interrupts disabled and the spinlock held.  This permits the
    pm_runtime_get_sync() and the new pm_runtime_put_sync_suspend()
    routines to be called from within interrupt handlers.
    
    When a device is declared irq-safe in this way, the PM core increments
    the parent's usage count, so the parent will never be runtime
    suspended.  This prevents difficult situations in which an irq-safe
    device can't resume because it is forced to wait for its non-irq-safe
    parent.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d19f1cca7f74..e9cc049ccb62 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -40,6 +40,7 @@ extern int pm_generic_runtime_idle(struct device *dev);
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern void pm_runtime_no_callbacks(struct device *dev);
+extern void pm_runtime_irq_safe(struct device *dev);
 extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
 extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
 extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
@@ -124,6 +125,7 @@ static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
+static inline void pm_runtime_irq_safe(struct device *dev) {}
 
 static inline void pm_runtime_mark_last_busy(struct device *dev) {}
 static inline void __pm_runtime_use_autosuspend(struct device *dev,
@@ -196,6 +198,11 @@ static inline int pm_runtime_put_sync(struct device *dev)
 	return __pm_runtime_idle(dev, RPM_GET_PUT);
 }
 
+static inline int pm_runtime_put_sync_suspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, RPM_GET_PUT);
+}
+
 static inline int pm_runtime_put_sync_autosuspend(struct device *dev)
 {
 	return __pm_runtime_suspend(dev, RPM_GET_PUT | RPM_AUTO);

commit f08f5a0add20834d3f3d876dfe08005a5df656db
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 16 17:11:58 2010 +0100

    PM / Runtime: Fix pm_runtime_suspended()
    
    There are some situations (e.g. in __pm_generic_call()), where
    pm_runtime_suspended() is used to decide whether or not to execute
    a device's (system) ->suspend() callback.  The callback is not
    executed if pm_runtime_suspended() returns true, but it does so
    for devices that don't even support runtime PM, because the
    power.disable_depth device field is ignored by it.  This leads to
    problems (i.e. devices are not suspened when they should), so rework
    pm_runtime_suspended() so that it returns false if the device's
    power.disable_depth field is different from zero.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 3ec2358f8692..d19f1cca7f74 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -77,7 +77,8 @@ static inline void device_set_run_wake(struct device *dev, bool enable)
 
 static inline bool pm_runtime_suspended(struct device *dev)
 {
-	return dev->power.runtime_status == RPM_SUSPENDED;
+	return dev->power.runtime_status == RPM_SUSPENDED
+		&& !dev->power.disable_depth;
 }
 
 static inline void pm_runtime_mark_last_busy(struct device *dev)

commit 5fc62aad4e7779c2f04691e48b351d08c050c1f1
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Sep 29 00:12:22 2010 +0200

    PM: runtime: add missed pm_request_autosuspend
    
    The patch "PM / Runtime: Implement autosuspend support" introduces
    "autosuspend" facility for runtime PM, but misses helper function
    of pm_request_autosuspend, so add it.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 99ed1aa8f933..3ec2358f8692 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -164,6 +164,11 @@ static inline int pm_request_resume(struct device *dev)
 	return __pm_runtime_resume(dev, RPM_ASYNC);
 }
 
+static inline int pm_request_autosuspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, RPM_ASYNC | RPM_AUTO);
+}
+
 static inline int pm_runtime_get(struct device *dev)
 {
 	return __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);

commit 15bcb91d7e607d8a2e060f01f7784a7454668da4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:21 2010 +0200

    PM / Runtime: Implement autosuspend support
    
    This patch (as1427) implements the "autosuspend" facility for runtime
    PM.  A few new fields are added to the dev_pm_info structure and
    several new PM helper functions are defined, for telling the PM core
    whether or not a device uses autosuspend, for setting the autosuspend
    delay, and for marking periods of device activity.
    
    Drivers that do not want to use autosuspend can continue using the
    same helper functions as before; their behavior will not change.  In
    addition, drivers supporting autosuspend can also call the old helper
    functions to get the old behavior.
    
    The details are all explained in Documentation/power/runtime_pm.txt
    and Documentation/ABI/testing/sysfs-devices-power.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 8ca52f7c357e..99ed1aa8f933 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -12,12 +12,15 @@
 #include <linux/device.h>
 #include <linux/pm.h>
 
+#include <linux/jiffies.h>
+
 /* Runtime PM flag argument bits */
 #define RPM_ASYNC		0x01	/* Request is asynchronous */
 #define RPM_NOWAIT		0x02	/* Don't wait for concurrent
 					    state change */
 #define RPM_GET_PUT		0x04	/* Increment/decrement the
 					    usage_count */
+#define RPM_AUTO		0x08	/* Use autosuspend_delay */
 
 #ifdef CONFIG_PM_RUNTIME
 
@@ -37,6 +40,9 @@ extern int pm_generic_runtime_idle(struct device *dev);
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern void pm_runtime_no_callbacks(struct device *dev);
+extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
+extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
+extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -74,6 +80,11 @@ static inline bool pm_runtime_suspended(struct device *dev)
 	return dev->power.runtime_status == RPM_SUSPENDED;
 }
 
+static inline void pm_runtime_mark_last_busy(struct device *dev)
+{
+	ACCESS_ONCE(dev->power.last_busy) = jiffies;
+}
+
 #else /* !CONFIG_PM_RUNTIME */
 
 static inline int __pm_runtime_idle(struct device *dev, int rpmflags)
@@ -113,6 +124,14 @@ static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
 
+static inline void pm_runtime_mark_last_busy(struct device *dev) {}
+static inline void __pm_runtime_use_autosuspend(struct device *dev,
+						bool use) {}
+static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
+						int delay) {}
+static inline unsigned long pm_runtime_autosuspend_expiration(
+				struct device *dev) { return 0; }
+
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev)
@@ -125,6 +144,11 @@ static inline int pm_runtime_suspend(struct device *dev)
 	return __pm_runtime_suspend(dev, 0);
 }
 
+static inline int pm_runtime_autosuspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, RPM_AUTO);
+}
+
 static inline int pm_runtime_resume(struct device *dev)
 {
 	return __pm_runtime_resume(dev, 0);
@@ -155,11 +179,22 @@ static inline int pm_runtime_put(struct device *dev)
 	return __pm_runtime_idle(dev, RPM_GET_PUT | RPM_ASYNC);
 }
 
+static inline int pm_runtime_put_autosuspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev,
+	    RPM_GET_PUT | RPM_ASYNC | RPM_AUTO);
+}
+
 static inline int pm_runtime_put_sync(struct device *dev)
 {
 	return __pm_runtime_idle(dev, RPM_GET_PUT);
 }
 
+static inline int pm_runtime_put_sync_autosuspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, RPM_GET_PUT | RPM_AUTO);
+}
+
 static inline int pm_runtime_set_active(struct device *dev)
 {
 	return __pm_runtime_set_status(dev, RPM_ACTIVE);
@@ -175,4 +210,14 @@ static inline void pm_runtime_disable(struct device *dev)
 	__pm_runtime_disable(dev, true);
 }
 
+static inline void pm_runtime_use_autosuspend(struct device *dev)
+{
+	__pm_runtime_use_autosuspend(dev, true);
+}
+
+static inline void pm_runtime_dont_use_autosuspend(struct device *dev)
+{
+	__pm_runtime_use_autosuspend(dev, false);
+}
+
 #endif

commit 7490e44239e60293bca0c2663229050c36c660c2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:15 2010 +0200

    PM / Runtime: Add no_callbacks flag
    
    Some devices, such as USB interfaces, cannot be power-managed
    independently of their parents, i.e., they cannot be put in low power
    while the parent remains at full power.  This patch (as1425) creates a
    new "no_callbacks" flag, which tells the PM core not to invoke the
    runtime-PM callback routines for the such devices but instead to
    assume that the callbacks always succeed.  In addition, the
    non-debugging runtime-PM sysfs attributes for the devices are removed,
    since they are pretty much meaningless.
    
    The advantage of this scheme comes not so much from avoiding the
    callbacks themselves, but rather from the fact that without the need
    for a process context in which to run the callbacks, more work can be
    done in interrupt context.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 5869d87fffac..8ca52f7c357e 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -36,6 +36,7 @@ extern void pm_runtime_forbid(struct device *dev);
 extern int pm_generic_runtime_idle(struct device *dev);
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
+extern void pm_runtime_no_callbacks(struct device *dev);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -110,6 +111,7 @@ static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
+static inline void pm_runtime_no_callbacks(struct device *dev) {}
 
 #endif /* !CONFIG_PM_RUNTIME */
 

commit 140a6c945211ee911dec776fafa52e03a7d7bb9a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:07 2010 +0200

    PM / Runtime: Combine runtime PM entry points
    
    This patch (as1424) combines the various public entry points for the
    runtime PM routines into three simple functions: one for idle, one for
    suspend, and one for resume.  A new bitflag specifies whether or not
    to increment or decrement the usage_count field.
    
    The new entry points are named __pm_runtime_idle,
    __pm_runtime_suspend, and __pm_runtime_resume, to reflect that they
    are trampolines.  Simultaneously, the corresponding internal routines
    are renamed to rpm_idle, rpm_suspend, and rpm_resume.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index c030cac59aac..5869d87fffac 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -16,19 +16,17 @@
 #define RPM_ASYNC		0x01	/* Request is asynchronous */
 #define RPM_NOWAIT		0x02	/* Don't wait for concurrent
 					    state change */
+#define RPM_GET_PUT		0x04	/* Increment/decrement the
+					    usage_count */
 
 #ifdef CONFIG_PM_RUNTIME
 
 extern struct workqueue_struct *pm_wq;
 
-extern int pm_runtime_idle(struct device *dev);
-extern int pm_runtime_suspend(struct device *dev);
-extern int pm_runtime_resume(struct device *dev);
-extern int pm_request_idle(struct device *dev);
+extern int __pm_runtime_idle(struct device *dev, int rpmflags);
+extern int __pm_runtime_suspend(struct device *dev, int rpmflags);
+extern int __pm_runtime_resume(struct device *dev, int rpmflags);
 extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
-extern int pm_request_resume(struct device *dev);
-extern int __pm_runtime_get(struct device *dev, int rpmflags);
-extern int __pm_runtime_put(struct device *dev, int rpmflags);
 extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
 extern void pm_runtime_enable(struct device *dev);
@@ -77,19 +75,22 @@ static inline bool pm_runtime_suspended(struct device *dev)
 
 #else /* !CONFIG_PM_RUNTIME */
 
-static inline int pm_runtime_idle(struct device *dev) { return -ENOSYS; }
-static inline int pm_runtime_suspend(struct device *dev) { return -ENOSYS; }
-static inline int pm_runtime_resume(struct device *dev) { return 0; }
-static inline int pm_request_idle(struct device *dev) { return -ENOSYS; }
+static inline int __pm_runtime_idle(struct device *dev, int rpmflags)
+{
+	return -ENOSYS;
+}
+static inline int __pm_runtime_suspend(struct device *dev, int rpmflags)
+{
+	return -ENOSYS;
+}
+static inline int __pm_runtime_resume(struct device *dev, int rpmflags)
+{
+	return 1;
+}
 static inline int pm_schedule_suspend(struct device *dev, unsigned int delay)
 {
 	return -ENOSYS;
 }
-static inline int pm_request_resume(struct device *dev) { return 0; }
-static inline int __pm_runtime_get(struct device *dev, int rpmflags)
-					{ return 1; }
-static inline int __pm_runtime_put(struct device *dev, int rpmflags)
-					{ return 0; }
 static inline int __pm_runtime_set_status(struct device *dev,
 					    unsigned int status) { return 0; }
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }
@@ -112,24 +113,49 @@ static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 
 #endif /* !CONFIG_PM_RUNTIME */
 
+static inline int pm_runtime_idle(struct device *dev)
+{
+	return __pm_runtime_idle(dev, 0);
+}
+
+static inline int pm_runtime_suspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, 0);
+}
+
+static inline int pm_runtime_resume(struct device *dev)
+{
+	return __pm_runtime_resume(dev, 0);
+}
+
+static inline int pm_request_idle(struct device *dev)
+{
+	return __pm_runtime_idle(dev, RPM_ASYNC);
+}
+
+static inline int pm_request_resume(struct device *dev)
+{
+	return __pm_runtime_resume(dev, RPM_ASYNC);
+}
+
 static inline int pm_runtime_get(struct device *dev)
 {
-	return __pm_runtime_get(dev, RPM_ASYNC);
+	return __pm_runtime_resume(dev, RPM_GET_PUT | RPM_ASYNC);
 }
 
 static inline int pm_runtime_get_sync(struct device *dev)
 {
-	return __pm_runtime_get(dev, 0);
+	return __pm_runtime_resume(dev, RPM_GET_PUT);
 }
 
 static inline int pm_runtime_put(struct device *dev)
 {
-	return __pm_runtime_put(dev, RPM_ASYNC);
+	return __pm_runtime_idle(dev, RPM_GET_PUT | RPM_ASYNC);
 }
 
 static inline int pm_runtime_put_sync(struct device *dev)
 {
-	return __pm_runtime_put(dev, 0);
+	return __pm_runtime_idle(dev, RPM_GET_PUT);
 }
 
 static inline int pm_runtime_set_active(struct device *dev)

commit 3f9af0513ae5b1f185302c2d0ba656640926d970
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:34:54 2010 +0200

    PM / Runtime: Replace boolean arguments with bitflags
    
    The "from_wq" argument in __pm_runtime_suspend() and
    __pm_runtime_resume() supposedly indicates whether or not the function
    was called by the PM workqueue thread, but in fact it isn't always
    used this way.  It really indicates whether or not the function should
    return early if the requested operation is already in progress.
    
    Along with this badly-named boolean argument, later patches in this
    series will add several other boolean arguments to these functions and
    others.  Therefore this patch (as1422) begins the conversion process
    by replacing from_wq with a bitflag argument.  The same bitflags are
    also used in __pm_runtime_get() and __pm_runtime_put(), where they
    indicate whether or not the operation should be asynchronous.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 6e81888c6222..c030cac59aac 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -12,6 +12,11 @@
 #include <linux/device.h>
 #include <linux/pm.h>
 
+/* Runtime PM flag argument bits */
+#define RPM_ASYNC		0x01	/* Request is asynchronous */
+#define RPM_NOWAIT		0x02	/* Don't wait for concurrent
+					    state change */
+
 #ifdef CONFIG_PM_RUNTIME
 
 extern struct workqueue_struct *pm_wq;
@@ -22,8 +27,8 @@ extern int pm_runtime_resume(struct device *dev);
 extern int pm_request_idle(struct device *dev);
 extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
 extern int pm_request_resume(struct device *dev);
-extern int __pm_runtime_get(struct device *dev, bool sync);
-extern int __pm_runtime_put(struct device *dev, bool sync);
+extern int __pm_runtime_get(struct device *dev, int rpmflags);
+extern int __pm_runtime_put(struct device *dev, int rpmflags);
 extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
 extern void pm_runtime_enable(struct device *dev);
@@ -81,8 +86,10 @@ static inline int pm_schedule_suspend(struct device *dev, unsigned int delay)
 	return -ENOSYS;
 }
 static inline int pm_request_resume(struct device *dev) { return 0; }
-static inline int __pm_runtime_get(struct device *dev, bool sync) { return 1; }
-static inline int __pm_runtime_put(struct device *dev, bool sync) { return 0; }
+static inline int __pm_runtime_get(struct device *dev, int rpmflags)
+					{ return 1; }
+static inline int __pm_runtime_put(struct device *dev, int rpmflags)
+					{ return 0; }
 static inline int __pm_runtime_set_status(struct device *dev,
 					    unsigned int status) { return 0; }
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }
@@ -107,22 +114,22 @@ static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 
 static inline int pm_runtime_get(struct device *dev)
 {
-	return __pm_runtime_get(dev, false);
+	return __pm_runtime_get(dev, RPM_ASYNC);
 }
 
 static inline int pm_runtime_get_sync(struct device *dev)
 {
-	return __pm_runtime_get(dev, true);
+	return __pm_runtime_get(dev, 0);
 }
 
 static inline int pm_runtime_put(struct device *dev)
 {
-	return __pm_runtime_put(dev, false);
+	return __pm_runtime_put(dev, RPM_ASYNC);
 }
 
 static inline int pm_runtime_put_sync(struct device *dev)
 {
-	return __pm_runtime_put(dev, true);
+	return __pm_runtime_put(dev, 0);
 }
 
 static inline int pm_runtime_set_active(struct device *dev)

commit 2f60ba706bd9af84c4eab704243b262e69556f2e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon May 10 23:09:30 2010 +0200

    i2c: Fix bus-level power management callbacks
    
    There are three issues with the i2c bus type's power management
    callbacks at the moment.  First, they don't include any hibernate
    callbacks, although they should at least include the .restore()
    callback (there's no guarantee that the driver will be present in
    memory before loading the image kernel and we must restore the
    pre-hibernation state of the device).  Second, the "legacy"
    callbacks are not going to be invoked by the PM core since the bus
    type's pm object is not NULL.  Finally, the system sleep PM
    (ie. suspend/resume) callbacks don't check if the device has been
    already suspended at run time, in which case they should skip
    suspending it.  Also, it looks like the i2c bus type can use the
    generic subsystem-level runtime PM callbacks.
    
    For these reasons, rework the system sleep PM callbacks provided by
    the i2c bus type to handle hibernation correctly and to invoke the
    "legacy" callbacks for drivers that provide them.  In addition to
    that make the i2c bus type use the generic subsystem-level runtime
    PM callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index b776db737244..6e81888c6222 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -30,6 +30,9 @@ extern void pm_runtime_enable(struct device *dev);
 extern void __pm_runtime_disable(struct device *dev, bool check_resume);
 extern void pm_runtime_allow(struct device *dev);
 extern void pm_runtime_forbid(struct device *dev);
+extern int pm_generic_runtime_idle(struct device *dev);
+extern int pm_generic_runtime_suspend(struct device *dev);
+extern int pm_generic_runtime_resume(struct device *dev);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -96,6 +99,10 @@ static inline bool device_run_wake(struct device *dev) { return false; }
 static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 
+static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
+static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
+static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
+
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_get(struct device *dev)

commit d690b2cd222afc75320b9b8e9da7df02e9e630ca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Mar 6 21:28:37 2010 +0100

    PM: Provide generic subsystem-level callbacks
    
    There are subsystems whose power management callbacks only need to
    invoke the callbacks provided by device drivers.  Still, their system
    sleep PM callbacks should play well with the runtime PM callbacks,
    so that devices suspended at run time can be left in that state for
    a system sleep transition.
    
    Provide a set of generic PM callbacks for such subsystems and
    define convenience macros for populating dev_pm_ops structures.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 7d773aac5314..b776db737244 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -62,6 +62,11 @@ static inline void device_set_run_wake(struct device *dev, bool enable)
 	dev->power.run_wake = enable;
 }
 
+static inline bool pm_runtime_suspended(struct device *dev)
+{
+	return dev->power.runtime_status == RPM_SUSPENDED;
+}
+
 #else /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev) { return -ENOSYS; }
@@ -89,6 +94,7 @@ static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}
 static inline bool device_run_wake(struct device *dev) { return false; }
 static inline void device_set_run_wake(struct device *dev, bool enable) {}
+static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 
 #endif /* !CONFIG_PM_RUNTIME */
 

commit 53823639173cc9e9a261f68f4abefe62364b86c6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 23 22:02:51 2010 +0100

    PM / Runtime: Add sysfs switch for disabling device run-time PM
    
    Add new device sysfs attribute, power/control, allowing the user
    space to block the run-time power management of the devices.  If this
    attribute is set to "on", the driver of the device won't be able to power
    manage it at run time (without breaking the rules) and the device will
    always be in the full power state (except when the entire system goes
    into a sleep state).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 370ce0a6fe4a..7d773aac5314 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -28,6 +28,8 @@ extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
 extern int pm_runtime_barrier(struct device *dev);
 extern void pm_runtime_enable(struct device *dev);
 extern void __pm_runtime_disable(struct device *dev, bool check_resume);
+extern void pm_runtime_allow(struct device *dev);
+extern void pm_runtime_forbid(struct device *dev);
 
 static inline bool pm_children_suspended(struct device *dev)
 {
@@ -78,6 +80,8 @@ static inline int __pm_runtime_set_status(struct device *dev,
 static inline int pm_runtime_barrier(struct device *dev) { return 0; }
 static inline void pm_runtime_enable(struct device *dev) {}
 static inline void __pm_runtime_disable(struct device *dev, bool c) {}
+static inline void pm_runtime_allow(struct device *dev) {}
+static inline void pm_runtime_forbid(struct device *dev) {}
 
 static inline bool pm_children_suspended(struct device *dev) { return false; }
 static inline void pm_suspend_ignore_children(struct device *dev, bool en) {}

commit 7a1a8eb58a2c6cd819d17332c5a2c369203635d5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 3 21:19:18 2009 +0100

    PM: Add flag for devices capable of generating run-time wake-up events
    
    Apparently, there are devices that can wake up the system from sleep
    states and yet are incapable of generating wake-up events at run
    time.  Thus, introduce a flag indicating if given device is capable
    of generating run-time wake-up events.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 44087044910f..370ce0a6fe4a 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -50,6 +50,16 @@ static inline void pm_runtime_put_noidle(struct device *dev)
 	atomic_add_unless(&dev->power.usage_count, -1, 0);
 }
 
+static inline bool device_run_wake(struct device *dev)
+{
+	return dev->power.run_wake;
+}
+
+static inline void device_set_run_wake(struct device *dev, bool enable)
+{
+	dev->power.run_wake = enable;
+}
+
 #else /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev) { return -ENOSYS; }
@@ -73,6 +83,8 @@ static inline bool pm_children_suspended(struct device *dev) { return false; }
 static inline void pm_suspend_ignore_children(struct device *dev, bool en) {}
 static inline void pm_runtime_get_noresume(struct device *dev) {}
 static inline void pm_runtime_put_noidle(struct device *dev) {}
+static inline bool device_run_wake(struct device *dev) { return false; }
+static inline void device_set_run_wake(struct device *dev, bool enable) {}
 
 #endif /* !CONFIG_PM_RUNTIME */
 

commit 5e928f77a09a07f9dd595bb8a489965d69a83458
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 18 23:38:32 2009 +0200

    PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
    
    Introduce a core framework for run-time power management of I/O
    devices.  Add device run-time PM fields to 'struct dev_pm_info'
    and device run-time PM callbacks to 'struct dev_pm_ops'.  Introduce
    a run-time PM workqueue and define some device run-time PM helper
    functions at the core level.  Document all these things.
    
    Special thanks to Alan Stern for his help with the design and
    multiple detailed reviews of the pereceding versions of this patch
    and to Magnus Damm for testing feedback.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@igel.co.jp>

diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
new file mode 100644
index 000000000000..44087044910f
--- /dev/null
+++ b/include/linux/pm_runtime.h
@@ -0,0 +1,114 @@
+/*
+ * pm_runtime.h - Device run-time power management helper functions.
+ *
+ * Copyright (C) 2009 Rafael J. Wysocki <rjw@sisk.pl>
+ *
+ * This file is released under the GPLv2.
+ */
+
+#ifndef _LINUX_PM_RUNTIME_H
+#define _LINUX_PM_RUNTIME_H
+
+#include <linux/device.h>
+#include <linux/pm.h>
+
+#ifdef CONFIG_PM_RUNTIME
+
+extern struct workqueue_struct *pm_wq;
+
+extern int pm_runtime_idle(struct device *dev);
+extern int pm_runtime_suspend(struct device *dev);
+extern int pm_runtime_resume(struct device *dev);
+extern int pm_request_idle(struct device *dev);
+extern int pm_schedule_suspend(struct device *dev, unsigned int delay);
+extern int pm_request_resume(struct device *dev);
+extern int __pm_runtime_get(struct device *dev, bool sync);
+extern int __pm_runtime_put(struct device *dev, bool sync);
+extern int __pm_runtime_set_status(struct device *dev, unsigned int status);
+extern int pm_runtime_barrier(struct device *dev);
+extern void pm_runtime_enable(struct device *dev);
+extern void __pm_runtime_disable(struct device *dev, bool check_resume);
+
+static inline bool pm_children_suspended(struct device *dev)
+{
+	return dev->power.ignore_children
+		|| !atomic_read(&dev->power.child_count);
+}
+
+static inline void pm_suspend_ignore_children(struct device *dev, bool enable)
+{
+	dev->power.ignore_children = enable;
+}
+
+static inline void pm_runtime_get_noresume(struct device *dev)
+{
+	atomic_inc(&dev->power.usage_count);
+}
+
+static inline void pm_runtime_put_noidle(struct device *dev)
+{
+	atomic_add_unless(&dev->power.usage_count, -1, 0);
+}
+
+#else /* !CONFIG_PM_RUNTIME */
+
+static inline int pm_runtime_idle(struct device *dev) { return -ENOSYS; }
+static inline int pm_runtime_suspend(struct device *dev) { return -ENOSYS; }
+static inline int pm_runtime_resume(struct device *dev) { return 0; }
+static inline int pm_request_idle(struct device *dev) { return -ENOSYS; }
+static inline int pm_schedule_suspend(struct device *dev, unsigned int delay)
+{
+	return -ENOSYS;
+}
+static inline int pm_request_resume(struct device *dev) { return 0; }
+static inline int __pm_runtime_get(struct device *dev, bool sync) { return 1; }
+static inline int __pm_runtime_put(struct device *dev, bool sync) { return 0; }
+static inline int __pm_runtime_set_status(struct device *dev,
+					    unsigned int status) { return 0; }
+static inline int pm_runtime_barrier(struct device *dev) { return 0; }
+static inline void pm_runtime_enable(struct device *dev) {}
+static inline void __pm_runtime_disable(struct device *dev, bool c) {}
+
+static inline bool pm_children_suspended(struct device *dev) { return false; }
+static inline void pm_suspend_ignore_children(struct device *dev, bool en) {}
+static inline void pm_runtime_get_noresume(struct device *dev) {}
+static inline void pm_runtime_put_noidle(struct device *dev) {}
+
+#endif /* !CONFIG_PM_RUNTIME */
+
+static inline int pm_runtime_get(struct device *dev)
+{
+	return __pm_runtime_get(dev, false);
+}
+
+static inline int pm_runtime_get_sync(struct device *dev)
+{
+	return __pm_runtime_get(dev, true);
+}
+
+static inline int pm_runtime_put(struct device *dev)
+{
+	return __pm_runtime_put(dev, false);
+}
+
+static inline int pm_runtime_put_sync(struct device *dev)
+{
+	return __pm_runtime_put(dev, true);
+}
+
+static inline int pm_runtime_set_active(struct device *dev)
+{
+	return __pm_runtime_set_status(dev, RPM_ACTIVE);
+}
+
+static inline void pm_runtime_set_suspended(struct device *dev)
+{
+	__pm_runtime_set_status(dev, RPM_SUSPENDED);
+}
+
+static inline void pm_runtime_disable(struct device *dev)
+{
+	__pm_runtime_disable(dev, true);
+}
+
+#endif
