commit 0c67f6b29715ff888cb967cc98336221a8a23916
Merge: 49f13b0921aa 50dd154ed7b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 14:04:39 2020 -0700

    Merge tag 'pm-5.8-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "These are operating performance points (OPP) framework updates mostly,
      including support for interconnect bandwidth in the OPP core, plus a
      few cpufreq changes, including boost support in the CPPC cpufreq
      driver, an ACPI device power management fix and a hibernation code
      cleanup.
    
      Specifics:
    
       - Add support for interconnect bandwidth to the OPP core (Georgi
         Djakov, Saravana Kannan, Sibi Sankar, Viresh Kumar).
    
       - Add support for regulator enable/disable to the OPP core (Kamil
         Konieczny).
    
       - Add boost support to the CPPC cpufreq driver (Xiongfeng Wang).
    
       - Make the tegra186 cpufreq driver set the
         CPUFREQ_NEED_INITIAL_FREQ_CHECK flag (Mian Yousaf Kaukab).
    
       - Prevent the ACPI power management from using power resources with
         devices where the list of power resources for power state D0 (full
         power) is missing (Rafael Wysocki).
    
       - Annotate a hibernation-related function with __init (Christophe
         JAILLET)"
    
    * tag 'pm-5.8-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: PM: Avoid using power resources if there are none for D0
      cpufreq: CPPC: add SW BOOST support
      cpufreq: change '.set_boost' to act on one policy
      PM: hibernate: Add __init annotation to swsusp_header_init()
      opp: Don't parse icc paths unnecessarily
      opp: Remove bandwidth votes when target_freq is zero
      opp: core: add regulators enable and disable
      opp: Reorder the code for !target_freq case
      opp: Expose bandwidth information via debugfs
      cpufreq: dt: Add support for interconnect bandwidth scaling
      opp: Update the bandwidth on OPP frequency changes
      opp: Add sanity checks in _read_opp_key()
      opp: Add support for parsing interconnect bandwidth
      cpufreq: tegra186: add CPUFREQ_NEED_INITIAL_FREQ_CHECK flag
      OPP: Add helpers for reading the binding properties
      dt-bindings: opp: Introduce opp-peak-kBps and opp-avg-kBps bindings

commit 0430b1d5704b0f0f1d237236dde9c143f8669e49
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 18 14:25:32 2020 +0300

    opp: Expose bandwidth information via debugfs
    
    Expose the bandwidth information as well via debugfs.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index 34e97231a6ab..1ad09efd296e 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -32,6 +32,7 @@ struct icc_path *of_icc_get_by_index(struct device *dev, int idx);
 void icc_put(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
 void icc_set_tag(struct icc_path *path, u32 tag);
+const char *icc_get_name(struct icc_path *path);
 
 #else
 
@@ -65,6 +66,11 @@ static inline void icc_set_tag(struct icc_path *path, u32 tag)
 {
 }
 
+static inline const char *icc_get_name(struct icc_path *path)
+{
+	return NULL;
+}
+
 #endif /* CONFIG_INTERCONNECT */
 
 #endif /* __LINUX_INTERCONNECT_H */

commit b35da2e86f256a3a4be7c3b31507016100b00847
Merge: 7d374b209083 8fd3574b54a5
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Fri May 15 10:46:18 2020 +0300

    Merge branch 'icc-get-by-index' into icc-next
    
    This is an immutable branch shared with the OPP tree. It contains also
    the patches to convert the interconnect framework from tristate to bool
    after Greg agreed with that. This will make the integration between
    the OPP layer and interconnect much easier.
    
    * icc-get-by-index:
      interconnect: Add of_icc_get_by_index() helper function
      interconnect: Disallow interconnect core to be built as a module
      interconnect: Remove unused module exit code from core
    
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

commit 1597d453289b385237628cd96d57d147632ab105
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Tue May 12 15:53:20 2020 +0300

    interconnect: Add of_icc_get_by_index() helper function
    
    This is the same as the traditional of_icc_get() function, but the
    difference is that it takes index as an argument, instead of name.
    
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Sibi Sankar <sibis@codeaurora.org>
    Link: https://lore.kernel.org/r/20200512125327.1868-4-georgi.djakov@linaro.org
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index d70a914cba11..34e97231a6ab 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -28,6 +28,7 @@ struct device;
 struct icc_path *icc_get(struct device *dev, const int src_id,
 			 const int dst_id);
 struct icc_path *of_icc_get(struct device *dev, const char *name);
+struct icc_path *of_icc_get_by_index(struct device *dev, int idx);
 void icc_put(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
 void icc_set_tag(struct icc_path *path, u32 tag);
@@ -46,6 +47,11 @@ static inline struct icc_path *of_icc_get(struct device *dev,
 	return NULL;
 }
 
+static inline struct icc_path *of_icc_get_by_index(struct device *dev, int idx)
+{
+	return NULL;
+}
+
 static inline void icc_put(struct icc_path *path)
 {
 }

commit 7d374b20908338c9fbb03ea8022a11f3b3e0e55f
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Sun May 10 18:30:37 2020 +0300

    interconnect: Add helpers for enabling/disabling a path
    
    There is a repeated pattern in multiple drivers where they want to switch
    the bandwidth between zero and some other value. This is happening often
    in the suspend/resume callbacks. Let's add helper functions to enable and
    disable the path, so that callers don't have to take care of remembering
    the bandwidth values and handle this in the framework instead.
    
    With this patch the users can call icc_disable() and icc_enable() to lower
    their bandwidth request to zero and then restore it back to it's previous
    value.
    
    Suggested-by: Evan Green <evgreen@chromium.org>
    Suggested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Link: https://lore.kernel.org/r/20200507120846.8354-1-georgi.djakov@linaro.org
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index 770692421f4c..e56a95e3cf25 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -30,6 +30,8 @@ struct icc_path *icc_get(struct device *dev, const int src_id,
 struct icc_path *of_icc_get(struct device *dev, const char *name);
 struct icc_path *devm_of_icc_get(struct device *dev, const char *name);
 void icc_put(struct icc_path *path);
+int icc_enable(struct icc_path *path);
+int icc_disable(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
 void icc_set_tag(struct icc_path *path, u32 tag);
 
@@ -57,6 +59,16 @@ static inline void icc_put(struct icc_path *path)
 {
 }
 
+static inline int icc_enable(struct icc_path *path)
+{
+	return 0;
+}
+
+static inline int icc_disable(struct icc_path *path)
+{
+	return 0;
+}
+
 static inline int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw)
 {
 	return 0;

commit e145d9a184f23639edc864e2fa08fcc1853361a4
Author: Akash Asthana <akashast@codeaurora.org>
Date:   Wed Apr 15 15:53:10 2020 +0530

    interconnect: Add devm_of_icc_get() as exported API for users
    
    Users can use devm version of of_icc_get() to benefit from automatic
    resource release.
    
    Signed-off-by: Akash Asthana <akashast@codeaurora.org>
    Reviewed by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Link: https://lore.kernel.org/r/1586946198-13912-2-git-send-email-akashast@codeaurora.org
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index d70a914cba11..770692421f4c 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -28,6 +28,7 @@ struct device;
 struct icc_path *icc_get(struct device *dev, const int src_id,
 			 const int dst_id);
 struct icc_path *of_icc_get(struct device *dev, const char *name);
+struct icc_path *devm_of_icc_get(struct device *dev, const char *name);
 void icc_put(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
 void icc_set_tag(struct icc_path *path, u32 tag);
@@ -46,6 +47,12 @@ static inline struct icc_path *of_icc_get(struct device *dev,
 	return NULL;
 }
 
+static inline struct icc_path *devm_of_icc_get(struct device *dev,
+						const char *name)
+{
+	return NULL;
+}
+
 static inline void icc_put(struct icc_path *path)
 {
 }

commit 127ab2cc5f19692efe422935267b9db0845b2b04
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Fri Aug 9 15:13:23 2019 +0300

    interconnect: Add support for path tags
    
    Consumers may have use cases with different bandwidth requirements based
    on the system or driver state. The consumer driver can append a specific
    tag to the path and pass this information to the interconnect platform
    driver to do the aggregation based on this state.
    
    Introduce icc_set_tag() function that will allow the consumers to append
    an optional tag to each path. The aggregation of these tagged paths is
    platform specific.
    
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index dc25864755ba..d70a914cba11 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -30,6 +30,7 @@ struct icc_path *icc_get(struct device *dev, const int src_id,
 struct icc_path *of_icc_get(struct device *dev, const char *name);
 void icc_put(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
+void icc_set_tag(struct icc_path *path, u32 tag);
 
 #else
 
@@ -54,6 +55,10 @@ static inline int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw)
 	return 0;
 }
 
+static inline void icc_set_tag(struct icc_path *path, u32 tag)
+{
+}
+
 #endif /* CONFIG_INTERCONNECT */
 
 #endif /* __LINUX_INTERCONNECT_H */

commit 87e3031b6fbd83ea83adf1bf9602bcce313ee787
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Wed Jan 16 18:10:58 2019 +0200

    interconnect: Allow endpoints translation via DT
    
    Currently we support only platform data for specifying the interconnect
    endpoints. As now the endpoints are hard-coded into the consumer driver
    this may lead to complications when a single driver is used by multiple
    SoCs, which may have different interconnect topology.
    To avoid cluttering the consumer drivers, introduce a translation function
    to help us get the board specific interconnect data from device-tree.
    
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
index c331afb3a2c8..dc25864755ba 100644
--- a/include/linux/interconnect.h
+++ b/include/linux/interconnect.h
@@ -27,6 +27,7 @@ struct device;
 
 struct icc_path *icc_get(struct device *dev, const int src_id,
 			 const int dst_id);
+struct icc_path *of_icc_get(struct device *dev, const char *name);
 void icc_put(struct icc_path *path);
 int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
 
@@ -38,6 +39,12 @@ static inline struct icc_path *icc_get(struct device *dev, const int src_id,
 	return NULL;
 }
 
+static inline struct icc_path *of_icc_get(struct device *dev,
+					  const char *name)
+{
+	return NULL;
+}
+
 static inline void icc_put(struct icc_path *path)
 {
 }

commit 11f1ceca7031deefc1a34236ab7b94360016b71d
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Wed Jan 16 18:10:56 2019 +0200

    interconnect: Add generic on-chip interconnect API
    
    This patch introduces a new API to get requirements and configure the
    interconnect buses across the entire chipset to fit with the current
    demand.
    
    The API is using a consumer/provider-based model, where the providers are
    the interconnect buses and the consumers could be various drivers.
    The consumers request interconnect resources (path) between endpoints and
    set the desired constraints on this data flow path. The providers receive
    requests from consumers and aggregate these requests for all master-slave
    pairs on that path. Then the providers configure each node along the path
    to support a bandwidth that satisfies all bandwidth requests that cross
    through that node. The topology could be complicated and multi-tiered and
    is SoC specific.
    
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/interconnect.h b/include/linux/interconnect.h
new file mode 100644
index 000000000000..c331afb3a2c8
--- /dev/null
+++ b/include/linux/interconnect.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2019, Linaro Ltd.
+ * Author: Georgi Djakov <georgi.djakov@linaro.org>
+ */
+
+#ifndef __LINUX_INTERCONNECT_H
+#define __LINUX_INTERCONNECT_H
+
+#include <linux/mutex.h>
+#include <linux/types.h>
+
+/* macros for converting to icc units */
+#define Bps_to_icc(x)	((x) / 1000)
+#define kBps_to_icc(x)	(x)
+#define MBps_to_icc(x)	((x) * 1000)
+#define GBps_to_icc(x)	((x) * 1000 * 1000)
+#define bps_to_icc(x)	(1)
+#define kbps_to_icc(x)	((x) / 8 + ((x) % 8 ? 1 : 0))
+#define Mbps_to_icc(x)	((x) * 1000 / 8)
+#define Gbps_to_icc(x)	((x) * 1000 * 1000 / 8)
+
+struct icc_path;
+struct device;
+
+#if IS_ENABLED(CONFIG_INTERCONNECT)
+
+struct icc_path *icc_get(struct device *dev, const int src_id,
+			 const int dst_id);
+void icc_put(struct icc_path *path);
+int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw);
+
+#else
+
+static inline struct icc_path *icc_get(struct device *dev, const int src_id,
+				       const int dst_id)
+{
+	return NULL;
+}
+
+static inline void icc_put(struct icc_path *path)
+{
+}
+
+static inline int icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw)
+{
+	return 0;
+}
+
+#endif /* CONFIG_INTERCONNECT */
+
+#endif /* __LINUX_INTERCONNECT_H */
