commit cfa6705d89b6562f79c40c249f8d94073c4276e4
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed May 27 22:11:14 2020 +0200

    radix-tree: Use local_lock for protection
    
    The radix-tree and idr preload mechanisms use preempt_disable() to protect
    the complete operation between xxx_preload() and xxx_preload_end().
    
    As the code inside the preempt disabled section acquires regular spinlocks,
    which are converted to 'sleeping' spinlocks on a PREEMPT_RT kernel and
    eventually calls into a memory allocator, this conflicts with the RT
    semantics.
    
    Convert it to a local_lock which allows RT kernels to substitute them with
    a real per CPU lock. On non RT kernels this maps to preempt_disable() as
    before, but provides also lockdep coverage of the critical region.
    No functional change.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Link: https://lore.kernel.org/r/20200527201119.1692513-3-bigeasy@linutronix.de

diff --git a/include/linux/idr.h b/include/linux/idr.h
index ac6e946b6767..3ade03e5c7af 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -171,7 +171,7 @@ static inline bool idr_is_empty(const struct idr *idr)
  */
 static inline void idr_preload_end(void)
 {
-	preempt_enable();
+	local_unlock(&radix_tree_preloads.lock);
 }
 
 /**

commit 410ef736a77b584e1c54a3784ee56ca63114ce11
Merge: 4d8b3262af02 b7e9728f3d7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 8 08:46:49 2019 -0800

    Merge tag 'xarray-5.4' of git://git.infradead.org/users/willy/linux-dax
    
    Pull XArray fixes from Matthew Wilcox:
     "These all fix various bugs, some of which people have tripped over and
      some of which have been caught by automatic tools"
    
    * tag 'xarray-5.4' of git://git.infradead.org/users/willy/linux-dax:
      idr: Fix idr_alloc_u32 on 32-bit systems
      idr: Fix integer overflow in idr_for_each_entry
      radix tree: Remove radix_tree_iter_find
      idr: Fix idr_get_next_ul race with idr_remove
      XArray: Fix xas_next() with a single entry at 0

commit f6341c5af4e6e15041be39976d16deca789555fa
Author: Matthew Wilcox (Oracle) <willy@infradead.org>
Date:   Sun Nov 3 06:36:43 2019 -0500

    idr: Fix integer overflow in idr_for_each_entry
    
    If there is an entry at INT_MAX then idr_for_each_entry() will increment
    id after handling it.  This is undefined behaviour, and is caught by
    UBSAN.  Adding 1U to id forces the operation to be carried out as an
    unsigned addition which (when assigned to id) will result in INT_MIN.
    Since there is never an entry stored at INT_MIN, idr_get_next() will
    return NULL, ending the loop as expected.
    
    Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index ee7abae143d3..dc09bd646bcb 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -185,7 +185,7 @@ static inline void idr_preload_end(void)
  * is convenient for a "not found" value.
  */
 #define idr_for_each_entry(idr, entry, id)			\
-	for (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; ++id)
+	for (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; id += 1U)
 
 /**
  * idr_for_each_entry_ul() - Iterate over an IDR's elements of a given type.

commit d39d714969cda5cbda291402c8c6b1fb1047f42e
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Fri Jun 28 11:03:42 2019 -0700

    idr: introduce idr_for_each_entry_continue_ul()
    
    Similarly, other callers of idr_get_next_ul() suffer the same
    overflow bug as they don't handle it properly either.
    
    Introduce idr_for_each_entry_continue_ul() to help these callers
    iterate from a given ID.
    
    cls_flower needs more care here because it still has overflow when
    does arg->cookie++, we have to fold its nested loops into one
    and remove the arg->cookie++.
    
    Fixes: 01683a146999 ("net: sched: refactor flower walk to iterate over idr")
    Fixes: 12d6066c3b29 ("net/mlx5: Add flow counters idr")
    Reported-by: Li Shuang <shuali@redhat.com>
    Cc: Davide Caratti <dcaratti@redhat.com>
    Cc: Vlad Buslov <vladbu@mellanox.com>
    Cc: Chris Mi <chrism@mellanox.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Tested-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 68528a72d10d..4ec8986e5dfb 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -216,6 +216,20 @@ static inline void idr_preload_end(void)
 	     entry;							\
 	     ++id, (entry) = idr_get_next((idr), &(id)))
 
+/**
+ * idr_for_each_entry_continue_ul() - Continue iteration over an IDR's elements of a given type
+ * @idr: IDR handle.
+ * @entry: The type * to use as a cursor.
+ * @tmp: A temporary placeholder for ID.
+ * @id: Entry ID.
+ *
+ * Continue to iterate over entries, continuing after the current position.
+ */
+#define idr_for_each_entry_continue_ul(idr, entry, tmp, id)		\
+	for (tmp = id;							\
+	     tmp <= id && ((entry) = idr_get_next_ul(idr, &(id))) != NULL; \
+	     tmp = id, ++id)
+
 /*
  * IDA - ID Allocator, use when translation from id to pointer isn't necessary.
  */

commit e33d2b74d805af0e4c8060f41040595ba105a520
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Fri Jun 28 11:03:41 2019 -0700

    idr: fix overflow case for idr_for_each_entry_ul()
    
    idr_for_each_entry_ul() is buggy as it can't handle overflow
    case correctly. When we have an ID == UINT_MAX, it becomes an
    infinite loop. This happens when running on 32-bit CPU where
    unsigned long has the same size with unsigned int.
    
    There is no better way to fix this than casting it to a larger
    integer, but we can't just 64 bit integer on 32 bit CPU. Instead
    we could just use an additional integer to help us to detect this
    overflow case, that is, adding a new parameter to this macro.
    Fortunately tc action is its only user right now.
    
    Fixes: 65a206c01e8e ("net/sched: Change act_api and act_xxx modules to use IDR")
    Reported-by: Li Shuang <shuali@redhat.com>
    Tested-by: Davide Caratti <dcaratti@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Chris Mi <chrism@mellanox.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index ee7abae143d3..68528a72d10d 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -191,14 +191,17 @@ static inline void idr_preload_end(void)
  * idr_for_each_entry_ul() - Iterate over an IDR's elements of a given type.
  * @idr: IDR handle.
  * @entry: The type * to use as cursor.
+ * @tmp: A temporary placeholder for ID.
  * @id: Entry ID.
  *
  * @entry and @id do not need to be initialized before the loop, and
  * after normal termination @entry is left with the value NULL.  This
  * is convenient for a "not found" value.
  */
-#define idr_for_each_entry_ul(idr, entry, id)			\
-	for (id = 0; ((entry) = idr_get_next_ul(idr, &(id))) != NULL; ++id)
+#define idr_for_each_entry_ul(idr, entry, tmp, id)			\
+	for (tmp = 0, id = 0;						\
+	     tmp <= id && ((entry) = idr_get_next_ul(idr, &(id))) != NULL; \
+	     tmp = id, ++id)
 
 /**
  * idr_for_each_entry_continue() - Continue iteration over an IDR's elements of a given type

commit 68cf618c62946085d64f0cc237e01cd6d238dbb5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:22 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 220
    
    Based on 1 normalized pattern(s):
    
      distributed under the gnu gpl license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171439.854676954@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 60daf34b625d..ee7abae143d3 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -1,9 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * include/linux/idr.h
  * 
  * 2002-10-18  written by Jim Houston jim.houston@ccur.com
  *	Copyright (C) 2002 by Concurrent Computer Corporation
- *	Distributed under the GNU GPL license version 2.
  *
  * Small id to pointer translation service avoiding fixed sized
  * tables.

commit f32f004cddf86d63a9c42994bbce9f4e2f07c9fa
Author: Matthew Wilcox <willy@infradead.org>
Date:   Wed Jul 4 15:42:46 2018 -0400

    ida: Convert to XArray
    
    Use the XA_TRACK_FREE ability to track which entries have a free bit,
    similarly to how it uses the radix tree's IDR_FREE tag.  This eliminates
    the per-cpu ida_bitmap preload, and fixes the memory consumption
    regression I introduced when making the IDR able to store any pointer.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 3ec8628ce17f..60daf34b625d 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -214,8 +214,7 @@ static inline void idr_preload_end(void)
 	     ++id, (entry) = idr_get_next((idr), &(id)))
 
 /*
- * IDA - IDR based id allocator, use when translation from id to
- * pointer isn't necessary.
+ * IDA - ID Allocator, use when translation from id to pointer isn't necessary.
  */
 #define IDA_CHUNK_SIZE		128	/* 128 bytes per chunk */
 #define IDA_BITMAP_LONGS	(IDA_CHUNK_SIZE / sizeof(long))
@@ -225,14 +224,14 @@ struct ida_bitmap {
 	unsigned long		bitmap[IDA_BITMAP_LONGS];
 };
 
-DECLARE_PER_CPU(struct ida_bitmap *, ida_bitmap);
-
 struct ida {
-	struct radix_tree_root	ida_rt;
+	struct xarray xa;
 };
 
+#define IDA_INIT_FLAGS	(XA_FLAGS_LOCK_IRQ | XA_FLAGS_ALLOC)
+
 #define IDA_INIT(name)	{						\
-	.ida_rt = RADIX_TREE_INIT(name, IDR_RT_MARKER | GFP_NOWAIT),	\
+	.xa = XARRAY_INIT(name, IDA_INIT_FLAGS)				\
 }
 #define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
 
@@ -292,7 +291,7 @@ static inline int ida_alloc_max(struct ida *ida, unsigned int max, gfp_t gfp)
 
 static inline void ida_init(struct ida *ida)
 {
-	INIT_RADIX_TREE(&ida->ida_rt, IDR_RT_MARKER | GFP_NOWAIT);
+	xa_init_flags(&ida->xa, IDA_INIT_FLAGS);
 }
 
 #define ida_simple_get(ida, start, end, gfp)	\
@@ -301,9 +300,6 @@ static inline void ida_init(struct ida *ida)
 
 static inline bool ida_is_empty(const struct ida *ida)
 {
-	return radix_tree_empty(&ida->ida_rt);
+	return xa_empty(&ida->xa);
 }
-
-/* in lib/radix-tree.c */
-int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
 #endif /* __IDR_H__ */

commit aba16dc5cf9318b4e0fe92f8261779cd9f1d2d77
Merge: c4726e774ed2 1df895190233
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 26 11:48:42 2018 -0700

    Merge branch 'ida-4.19' of git://git.infradead.org/users/willy/linux-dax
    
    Pull IDA updates from Matthew Wilcox:
     "A better IDA API:
    
          id = ida_alloc(ida, GFP_xxx);
          ida_free(ida, id);
    
      rather than the cumbersome ida_simple_get(), ida_simple_remove().
    
      The new IDA API is similar to ida_simple_get() but better named.  The
      internal restructuring of the IDA code removes the bitmap
      preallocation nonsense.
    
      I hope the net -200 lines of code is convincing"
    
    * 'ida-4.19' of git://git.infradead.org/users/willy/linux-dax: (29 commits)
      ida: Change ida_get_new_above to return the id
      ida: Remove old API
      test_ida: check_ida_destroy and check_ida_alloc
      test_ida: Convert check_ida_conv to new API
      test_ida: Move ida_check_max
      test_ida: Move ida_check_leaf
      idr-test: Convert ida_check_nomem to new API
      ida: Start new test_ida module
      target/iscsi: Allocate session IDs from an IDA
      iscsi target: fix session creation failure handling
      drm/vmwgfx: Convert to new IDA API
      dmaengine: Convert to new IDA API
      ppc: Convert vas ID allocation to new IDA API
      media: Convert entity ID allocation to new IDA API
      ppc: Convert mmu context allocation to new IDA API
      Convert net_namespace to new IDA API
      cb710: Convert to new IDA API
      rsxx: Convert to new IDA API
      osd: Convert to new IDA API
      sd: Convert to new IDA API
      ...

commit b03f8e43c9261878bf29d8cc1c3ba458cc98287e
Author: Matthew Wilcox <willy@infradead.org>
Date:   Mon Jun 18 19:02:48 2018 -0400

    ida: Remove old API
    
    Delete ida_pre_get(), ida_get_new(), ida_get_new_above() and ida_remove()
    from the public API.  Some of these functions still exist as internal
    helpers, but they should not be called by consumers.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index cd339da0b1aa..2e1db0e36486 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -225,13 +225,9 @@ struct ida {
 }
 #define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
 
-int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
-int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
-void ida_remove(struct ida *ida, int id);
-void ida_destroy(struct ida *ida);
-
 int ida_alloc_range(struct ida *, unsigned int min, unsigned int max, gfp_t);
 void ida_free(struct ida *, unsigned int id);
+void ida_destroy(struct ida *ida);
 
 /**
  * ida_alloc() - Allocate an unused ID.
@@ -292,20 +288,11 @@ static inline void ida_init(struct ida *ida)
 			ida_alloc_range(ida, start, (end) - 1, gfp)
 #define ida_simple_remove(ida, id)	ida_free(ida, id)
 
-/**
- * ida_get_new - allocate new ID
- * @ida:	idr handle
- * @p_id:	pointer to the allocated handle
- *
- * Simple wrapper around ida_get_new_above() w/ @starting_id of zero.
- */
-static inline int ida_get_new(struct ida *ida, int *p_id)
-{
-	return ida_get_new_above(ida, 0, p_id);
-}
-
 static inline bool ida_is_empty(const struct ida *ida)
 {
 	return radix_tree_empty(&ida->ida_rt);
 }
+
+/* in lib/radix-tree.c */
+int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
 #endif /* __IDR_H__ */

commit 5ade60dda43c8906d4554374226c2eb11cc2ffba
Author: Matthew Wilcox <willy@infradead.org>
Date:   Tue Mar 20 17:07:11 2018 -0400

    ida: Add new API
    
    Add ida_alloc(), ida_alloc_min(), ida_alloc_max(), ida_alloc_range()
    and ida_free().  The ida_alloc_max() and ida_alloc_range() functions
    differ from ida_simple_get() in that they take an inclusive 'max'
    parameter instead of an exclusive 'end' parameter.  Callers are about
    evenly split whether they'd like inclusive or exclusive parameters and
    'max' is easier to document than 'end'.
    
    Change the IDA allocation to first attempt to allocate a bit using
    existing memory, and only allocate memory afterwards.  Also change the
    behaviour of 'min' > INT_MAX from being a BUG() to returning -ENOSPC.
    
    Leave compatibility wrappers in place for ida_simple_get() and
    ida_simple_remove() to avoid changing all callers.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index e856f4e0ab35..cd339da0b1aa 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -230,15 +230,68 @@ int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
 void ida_remove(struct ida *ida, int id);
 void ida_destroy(struct ida *ida);
 
-int ida_simple_get(struct ida *ida, unsigned int start, unsigned int end,
-		   gfp_t gfp_mask);
-void ida_simple_remove(struct ida *ida, unsigned int id);
+int ida_alloc_range(struct ida *, unsigned int min, unsigned int max, gfp_t);
+void ida_free(struct ida *, unsigned int id);
+
+/**
+ * ida_alloc() - Allocate an unused ID.
+ * @ida: IDA handle.
+ * @gfp: Memory allocation flags.
+ *
+ * Allocate an ID between 0 and %INT_MAX, inclusive.
+ *
+ * Context: Any context.
+ * Return: The allocated ID, or %-ENOMEM if memory could not be allocated,
+ * or %-ENOSPC if there are no free IDs.
+ */
+static inline int ida_alloc(struct ida *ida, gfp_t gfp)
+{
+	return ida_alloc_range(ida, 0, ~0, gfp);
+}
+
+/**
+ * ida_alloc_min() - Allocate an unused ID.
+ * @ida: IDA handle.
+ * @min: Lowest ID to allocate.
+ * @gfp: Memory allocation flags.
+ *
+ * Allocate an ID between @min and %INT_MAX, inclusive.
+ *
+ * Context: Any context.
+ * Return: The allocated ID, or %-ENOMEM if memory could not be allocated,
+ * or %-ENOSPC if there are no free IDs.
+ */
+static inline int ida_alloc_min(struct ida *ida, unsigned int min, gfp_t gfp)
+{
+	return ida_alloc_range(ida, min, ~0, gfp);
+}
+
+/**
+ * ida_alloc_max() - Allocate an unused ID.
+ * @ida: IDA handle.
+ * @max: Highest ID to allocate.
+ * @gfp: Memory allocation flags.
+ *
+ * Allocate an ID between 0 and @max, inclusive.
+ *
+ * Context: Any context.
+ * Return: The allocated ID, or %-ENOMEM if memory could not be allocated,
+ * or %-ENOSPC if there are no free IDs.
+ */
+static inline int ida_alloc_max(struct ida *ida, unsigned int max, gfp_t gfp)
+{
+	return ida_alloc_range(ida, 0, max, gfp);
+}
 
 static inline void ida_init(struct ida *ida)
 {
 	INIT_RADIX_TREE(&ida->ida_rt, IDR_RT_MARKER | GFP_NOWAIT);
 }
 
+#define ida_simple_get(ida, start, end, gfp)	\
+			ida_alloc_range(ida, start, (end) - 1, gfp)
+#define ida_simple_remove(ida, id)	ida_free(ida, id)
+
 /**
  * ida_get_new - allocate new ID
  * @ida:	idr handle

commit 3c60e868c31e4ff144776bf53ff0dfe9e9e4ec15
Author: willy@infradead.org <willy@infradead.org>
Date:   Wed Jun 13 11:45:55 2018 -0700

    IDR: Expose the XArray lock
    
    Allow users of the IDR to use the XArray lock for their own
    synchronisation purposes.  The IDR continues to rely on the caller to
    handle locking, but this lets the caller use the lock embedded in the
    IDR data structure instead of allocating their own lock.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index e856f4e0ab35..3e8215b2c371 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -98,6 +98,17 @@ static inline void idr_set_cursor(struct idr *idr, unsigned int val)
  * period).
  */
 
+#define idr_lock(idr)		xa_lock(&(idr)->idr_rt)
+#define idr_unlock(idr)		xa_unlock(&(idr)->idr_rt)
+#define idr_lock_bh(idr)	xa_lock_bh(&(idr)->idr_rt)
+#define idr_unlock_bh(idr)	xa_unlock_bh(&(idr)->idr_rt)
+#define idr_lock_irq(idr)	xa_lock_irq(&(idr)->idr_rt)
+#define idr_unlock_irq(idr)	xa_unlock_irq(&(idr)->idr_rt)
+#define idr_lock_irqsave(idr, flags) \
+				xa_lock_irqsave(&(idr)->idr_rt, flags)
+#define idr_unlock_irqrestore(idr, flags) \
+				xa_unlock_irqrestore(&(idr)->idr_rt, flags)
+
 void idr_preload(gfp_t gfp_mask);
 
 int idr_alloc(struct idr *, void *ptr, int start, int end, gfp_t);

commit f6bb2a2c0b81c47282ddb7883f92e65a063c27dd
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Apr 10 16:36:52 2018 -0700

    xarray: add the xa_lock to the radix_tree_root
    
    This results in no change in structure size on 64-bit machines as it
    fits in the padding between the gfp_t and the void *.  32-bit machines
    will grow the structure from 8 to 12 bytes.  Almost all radix trees are
    protected with (at least) a spinlock, so as they are converted from
    radix trees to xarrays, the data structures will shrink again.
    
    Initialising the spinlock requires a name for the benefit of lockdep, so
    RADIX_TREE_INIT() now needs to know the name of the radix tree it's
    initialising, and so do IDR_INIT() and IDA_INIT().
    
    Also add the xa_lock() and xa_unlock() family of wrappers to make it
    easier to use the lock.  If we could rely on -fplan9-extensions in the
    compiler, we could avoid all of this syntactic sugar, but that wasn't
    added until gcc 4.6.
    
    Link: http://lkml.kernel.org/r/20180313132639.17387-8-willy@infradead.org
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: Jeff Layton <jlayton@kernel.org>
    Cc: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 913c335054f0..e856f4e0ab35 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -32,27 +32,28 @@ struct idr {
 #define IDR_RT_MARKER	(ROOT_IS_IDR | (__force gfp_t)			\
 					(1 << (ROOT_TAG_SHIFT + IDR_FREE)))
 
-#define IDR_INIT_BASE(base) {						\
-	.idr_rt = RADIX_TREE_INIT(IDR_RT_MARKER),			\
+#define IDR_INIT_BASE(name, base) {					\
+	.idr_rt = RADIX_TREE_INIT(name, IDR_RT_MARKER),			\
 	.idr_base = (base),						\
 	.idr_next = 0,							\
 }
 
 /**
  * IDR_INIT() - Initialise an IDR.
+ * @name: Name of IDR.
  *
  * A freshly-initialised IDR contains no IDs.
  */
-#define IDR_INIT	IDR_INIT_BASE(0)
+#define IDR_INIT(name)	IDR_INIT_BASE(name, 0)
 
 /**
- * DEFINE_IDR() - Define a statically-allocated IDR
- * @name: Name of IDR
+ * DEFINE_IDR() - Define a statically-allocated IDR.
+ * @name: Name of IDR.
  *
  * An IDR defined using this macro is ready for use with no additional
  * initialisation required.  It contains no IDs.
  */
-#define DEFINE_IDR(name)	struct idr name = IDR_INIT
+#define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 
 /**
  * idr_get_cursor - Return the current position of the cyclic allocator
@@ -219,10 +220,10 @@ struct ida {
 	struct radix_tree_root	ida_rt;
 };
 
-#define IDA_INIT	{						\
-	.ida_rt = RADIX_TREE_INIT(IDR_RT_MARKER | GFP_NOWAIT),		\
+#define IDA_INIT(name)	{						\
+	.ida_rt = RADIX_TREE_INIT(name, IDR_RT_MARKER | GFP_NOWAIT),	\
 }
-#define DEFINE_IDA(name)	struct ida name = IDA_INIT
+#define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
 
 int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
 int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);

commit fa290cda102c096f5ca394277d65d3dbd689930b
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Apr 10 16:36:28 2018 -0700

    radix tree: use GFP_ZONEMASK bits of gfp_t for flags
    
    Patch series "XArray", v9.  (First part thereof).
    
    This patchset is, I believe, appropriate for merging for 4.17.  It
    contains the XArray implementation, to eventually replace the radix
    tree, and converts the page cache to use it.
    
    This conversion keeps the radix tree and XArray data structures in sync
    at all times.  That allows us to convert the page cache one function at
    a time and should allow for easier bisection.  Other than renaming some
    elements of the structures, the data structures are fundamentally
    unchanged; a radix tree walk and an XArray walk will touch the same
    number of cachelines.  I have changes planned to the XArray data
    structure, but those will happen in future patches.
    
    Improvements the XArray has over the radix tree:
    
     - The radix tree provides operations like other trees do; 'insert' and
       'delete'. But what most users really want is an automatically
       resizing array, and so it makes more sense to give users an API that
       is like an array -- 'load' and 'store'. We still have an 'insert'
       operation for users that really want that semantic.
    
     - The XArray considers locking as part of its API. This simplifies a
       lot of users who formerly had to manage their own locking just for
       the radix tree. It also improves code generation as we can now tell
       RCU that we're holding a lock and it doesn't need to generate as much
       fencing code. The other advantage is that tree nodes can be moved
       (not yet implemented).
    
     - GFP flags are now parameters to calls which may need to allocate
       memory. The radix tree forced users to decide what the allocation
       flags would be at creation time. It's much clearer to specify them at
       allocation time.
    
     - Memory is not preloaded; we don't tie up dozens of pages on the off
       chance that the slab allocator fails. Instead, we drop the lock,
       allocate a new node and retry the operation. We have to convert all
       the radix tree, IDA and IDR preload users before we can realise this
       benefit, but I have not yet found a user which cannot be converted.
    
     - The XArray provides a cmpxchg operation. The radix tree forces users
       to roll their own (and at least four have).
    
     - Iterators take a 'max' parameter. That simplifies many users and will
       reduce the amount of iteration done.
    
     - Iteration can proceed backwards. We only have one user for this, but
       since it's called as part of the pagefault readahead algorithm, that
       seemed worth mentioning.
    
     - RCU-protected pointers are not exposed as part of the API. There are
       some fun bugs where the page cache forgets to use rcu_dereference()
       in the current codebase.
    
     - Value entries gain an extra bit compared to radix tree exceptional
       entries. That gives us the extra bit we need to put huge page swap
       entries in the page cache.
    
     - Some iterators now take a 'filter' argument instead of having
       separate iterators for tagged/untagged iterations.
    
    The page cache is improved by this:
    
     - Shorter, easier to read code
    
     - More efficient iterations
    
     - Reduction in size of struct address_space
    
     - Fewer walks from the top of the data structure; the XArray API
       encourages staying at the leaf node and conducting operations there.
    
    This patch (of 8):
    
    None of these bits may be used for slab allocations, so we can use them
    as radix tree flags as long as we mask them off before passing them to
    the slab allocator. Move the IDR flag from the high bits to the
    GFP_ZONEMASK bits.
    
    Link: http://lkml.kernel.org/r/20180313132639.17387-3-willy@infradead.org
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>
    Cc: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 7d6a6313f0ab..913c335054f0 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -29,7 +29,8 @@ struct idr {
 #define IDR_FREE	0
 
 /* Set the IDR flag and the IDR_FREE tag */
-#define IDR_RT_MARKER		((__force gfp_t)(3 << __GFP_BITS_SHIFT))
+#define IDR_RT_MARKER	(ROOT_IS_IDR | (__force gfp_t)			\
+					(1 << (ROOT_TAG_SHIFT + IDR_FREE)))
 
 #define IDR_INIT_BASE(base) {						\
 	.idr_rt = RADIX_TREE_INIT(IDR_RT_MARKER),			\

commit ac665d9423474e64e64b34b0e2cea43601b50d7d
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Feb 6 15:05:49 2018 -0500

    idr: Add documentation
    
    Move the idr kernel-doc to its own idr.rst file and add a few
    paragraphs about how to use it.  Also add some more kernel-doc.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 86b38df6e121..7d6a6313f0ab 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -36,7 +36,6 @@ struct idr {
 	.idr_base = (base),						\
 	.idr_next = 0,							\
 }
-#define DEFINE_IDR(name)	struct idr name = IDR_INIT
 
 /**
  * IDR_INIT() - Initialise an IDR.
@@ -45,6 +44,15 @@ struct idr {
  */
 #define IDR_INIT	IDR_INIT_BASE(0)
 
+/**
+ * DEFINE_IDR() - Define a statically-allocated IDR
+ * @name: Name of IDR
+ *
+ * An IDR defined using this macro is ready for use with no additional
+ * initialisation required.  It contains no IDs.
+ */
+#define DEFINE_IDR(name)	struct idr name = IDR_INIT
+
 /**
  * idr_get_cursor - Return the current position of the cyclic allocator
  * @idr: idr handle
@@ -130,6 +138,12 @@ static inline void idr_init(struct idr *idr)
 	idr_init_base(idr, 0);
 }
 
+/**
+ * idr_is_empty() - Are there any IDs allocated?
+ * @idr: IDR handle.
+ *
+ * Return: %true if any IDs have been allocated from this IDR.
+ */
 static inline bool idr_is_empty(const struct idr *idr)
 {
 	return radix_tree_empty(&idr->idr_rt) &&

commit 6ce711f2750031d12cec91384ac5cfa0a485b60a
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Thu Nov 30 13:45:11 2017 -0500

    idr: Make 1-based IDRs more efficient
    
    About 20% of the IDR users in the kernel want the allocated IDs to start
    at 1.  The implementation currently searches all the way down the left
    hand side of the tree, finds no free ID other than ID 0, walks all the
    way back up, and then all the way down again.  This patch 'rebases' the
    ID so we fill the entire radix tree, rather than leave a gap at 0.
    
    Chris Wilson says: "I did the quick hack of allocating index 0 of the
    idr and that eradicated idr_get_free() from being at the top of the
    profiles for the many-object stress tests. This improvement will be
    much appreciated."
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 95a82cf2ed02..86b38df6e121 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -18,6 +18,7 @@
 
 struct idr {
 	struct radix_tree_root	idr_rt;
+	unsigned int		idr_base;
 	unsigned int		idr_next;
 };
 
@@ -30,12 +31,20 @@ struct idr {
 /* Set the IDR flag and the IDR_FREE tag */
 #define IDR_RT_MARKER		((__force gfp_t)(3 << __GFP_BITS_SHIFT))
 
-#define IDR_INIT							\
-{									\
-	.idr_rt = RADIX_TREE_INIT(IDR_RT_MARKER)			\
+#define IDR_INIT_BASE(base) {						\
+	.idr_rt = RADIX_TREE_INIT(IDR_RT_MARKER),			\
+	.idr_base = (base),						\
+	.idr_next = 0,							\
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT
 
+/**
+ * IDR_INIT() - Initialise an IDR.
+ *
+ * A freshly-initialised IDR contains no IDs.
+ */
+#define IDR_INIT	IDR_INIT_BASE(0)
+
 /**
  * idr_get_cursor - Return the current position of the cyclic allocator
  * @idr: idr handle
@@ -81,10 +90,12 @@ static inline void idr_set_cursor(struct idr *idr, unsigned int val)
 
 void idr_preload(gfp_t gfp_mask);
 
-int idr_alloc(struct idr *, void *, int start, int end, gfp_t);
-int __must_check idr_alloc_u32(struct idr *, void *ptr, u32 *nextid,
+int idr_alloc(struct idr *, void *ptr, int start, int end, gfp_t);
+int __must_check idr_alloc_u32(struct idr *, void *ptr, u32 *id,
 				unsigned long max, gfp_t);
-int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);
+int idr_alloc_cyclic(struct idr *, void *ptr, int start, int end, gfp_t);
+void *idr_remove(struct idr *, unsigned long id);
+void *idr_find(const struct idr *, unsigned long id);
 int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *, int *nextid);
@@ -92,15 +103,31 @@ void *idr_get_next_ul(struct idr *, unsigned long *nextid);
 void *idr_replace(struct idr *, void *, unsigned long id);
 void idr_destroy(struct idr *);
 
-static inline void *idr_remove(struct idr *idr, unsigned long id)
+/**
+ * idr_init_base() - Initialise an IDR.
+ * @idr: IDR handle.
+ * @base: The base value for the IDR.
+ *
+ * This variation of idr_init() creates an IDR which will allocate IDs
+ * starting at %base.
+ */
+static inline void idr_init_base(struct idr *idr, int base)
 {
-	return radix_tree_delete_item(&idr->idr_rt, id, NULL);
+	INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);
+	idr->idr_base = base;
+	idr->idr_next = 0;
 }
 
+/**
+ * idr_init() - Initialise an IDR.
+ * @idr: IDR handle.
+ *
+ * Initialise a dynamically allocated IDR.  To initialise a
+ * statically allocated IDR, use DEFINE_IDR().
+ */
 static inline void idr_init(struct idr *idr)
 {
-	INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);
-	idr->idr_next = 0;
+	idr_init_base(idr, 0);
 }
 
 static inline bool idr_is_empty(const struct idr *idr)
@@ -120,25 +147,6 @@ static inline void idr_preload_end(void)
 	preempt_enable();
 }
 
-/**
- * idr_find() - Return pointer for given ID.
- * @idr: IDR handle.
- * @id: Pointer ID.
- *
- * Looks up the pointer associated with this ID.  A %NULL pointer may
- * indicate that @id is not allocated or that the %NULL pointer was
- * associated with this ID.
- *
- * This function can be called under rcu_read_lock(), given that the leaf
- * pointers lifetimes are correctly managed.
- *
- * Return: The pointer associated with this ID.
- */
-static inline void *idr_find(const struct idr *idr, unsigned long id)
-{
-	return radix_tree_lookup(&idr->idr_rt, id);
-}
-
 /**
  * idr_for_each_entry() - Iterate over an IDR's elements of a given type.
  * @idr: IDR handle.

commit 7a4575778f4db109b8b78e6dba03271096793f88
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 15:39:51 2017 -0500

    idr: Rename idr_for_each_entry_ext
    
    Most places in the kernel that we need to distinguish functions by the
    type of their arguments, we use '_ul' as a suffix for the unsigned long
    variant, not '_ext'.  Also add kernel-doc.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index fa2a04b984df..95a82cf2ed02 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -88,7 +88,7 @@ int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);
 int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *, int *nextid);
-void *idr_get_next_ext(struct idr *idr, unsigned long *nextid);
+void *idr_get_next_ul(struct idr *, unsigned long *nextid);
 void *idr_replace(struct idr *, void *, unsigned long id);
 void idr_destroy(struct idr *);
 
@@ -121,16 +121,18 @@ static inline void idr_preload_end(void)
 }
 
 /**
- * idr_find - return pointer for given id
- * @idr: idr handle
- * @id: lookup key
+ * idr_find() - Return pointer for given ID.
+ * @idr: IDR handle.
+ * @id: Pointer ID.
  *
- * Return the pointer given the id it has been registered with.  A %NULL
- * return indicates that @id is not valid or you passed %NULL in
- * idr_get_new().
+ * Looks up the pointer associated with this ID.  A %NULL pointer may
+ * indicate that @id is not allocated or that the %NULL pointer was
+ * associated with this ID.
  *
  * This function can be called under rcu_read_lock(), given that the leaf
  * pointers lifetimes are correctly managed.
+ *
+ * Return: The pointer associated with this ID.
  */
 static inline void *idr_find(const struct idr *idr, unsigned long id)
 {
@@ -138,28 +140,38 @@ static inline void *idr_find(const struct idr *idr, unsigned long id)
 }
 
 /**
- * idr_for_each_entry - iterate over an idr's elements of a given type
- * @idr:     idr handle
- * @entry:   the type * to use as cursor
- * @id:      id entry's key
+ * idr_for_each_entry() - Iterate over an IDR's elements of a given type.
+ * @idr: IDR handle.
+ * @entry: The type * to use as cursor
+ * @id: Entry ID.
  *
  * @entry and @id do not need to be initialized before the loop, and
- * after normal terminatinon @entry is left with the value NULL.  This
+ * after normal termination @entry is left with the value NULL.  This
  * is convenient for a "not found" value.
  */
 #define idr_for_each_entry(idr, entry, id)			\
 	for (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; ++id)
-#define idr_for_each_entry_ext(idr, entry, id)			\
-	for (id = 0; ((entry) = idr_get_next_ext(idr, &(id))) != NULL; ++id)
 
 /**
- * idr_for_each_entry_continue - continue iteration over an idr's elements of a given type
- * @idr:     idr handle
- * @entry:   the type * to use as cursor
- * @id:      id entry's key
+ * idr_for_each_entry_ul() - Iterate over an IDR's elements of a given type.
+ * @idr: IDR handle.
+ * @entry: The type * to use as cursor.
+ * @id: Entry ID.
+ *
+ * @entry and @id do not need to be initialized before the loop, and
+ * after normal termination @entry is left with the value NULL.  This
+ * is convenient for a "not found" value.
+ */
+#define idr_for_each_entry_ul(idr, entry, id)			\
+	for (id = 0; ((entry) = idr_get_next_ul(idr, &(id))) != NULL; ++id)
+
+/**
+ * idr_for_each_entry_continue() - Continue iteration over an IDR's elements of a given type
+ * @idr: IDR handle.
+ * @entry: The type * to use as a cursor.
+ * @id: Entry ID.
  *
- * Continue to iterate over list of given type, continuing after
- * the current position.
+ * Continue to iterate over entries, continuing after the current position.
  */
 #define idr_for_each_entry_continue(idr, entry, id)			\
 	for ((entry) = idr_get_next((idr), &(id));			\

commit 460488c58ca8b9167463ac22ec9a2e33db351962
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 15:16:24 2017 -0500

    idr: Remove idr_alloc_ext
    
    It has no more users, so remove it.  Move idr_alloc() back into idr.c,
    move the guts of idr_alloc_cmn() into idr_alloc_u32(), remove the
    wrappers around idr_get_free_cmn() and rename it to idr_get_free().
    While there is now no interface to allocate IDs larger than a u32,
    the IDR internals remain ready to handle a larger ID should a need arise.
    
    These changes make it possible to provide the guarantee that, if the
    nextid pointer points into the object, the object's ID will be initialised
    before a concurrent lookup can find the object.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 561a4cbabca6..fa2a04b984df 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -15,7 +15,6 @@
 #include <linux/radix-tree.h>
 #include <linux/gfp.h>
 #include <linux/percpu.h>
-#include <linux/bug.h>
 
 struct idr {
 	struct radix_tree_root	idr_rt;
@@ -82,55 +81,7 @@ static inline void idr_set_cursor(struct idr *idr, unsigned int val)
 
 void idr_preload(gfp_t gfp_mask);
 
-int idr_alloc_cmn(struct idr *idr, void *ptr, unsigned long *index,
-		  unsigned long start, unsigned long end, gfp_t gfp,
-		  bool ext);
-
-/**
- * idr_alloc - allocate an id
- * @idr: idr handle
- * @ptr: pointer to be associated with the new id
- * @start: the minimum id (inclusive)
- * @end: the maximum id (exclusive)
- * @gfp: memory allocation flags
- *
- * Allocates an unused ID in the range [start, end).  Returns -ENOSPC
- * if there are no unused IDs in that range.
- *
- * Note that @end is treated as max when <= 0.  This is to always allow
- * using @start + N as @end as long as N is inside integer range.
- *
- * Simultaneous modifications to the @idr are not allowed and should be
- * prevented by the user, usually with a lock.  idr_alloc() may be called
- * concurrently with read-only accesses to the @idr, such as idr_find() and
- * idr_for_each_entry().
- */
-static inline int idr_alloc(struct idr *idr, void *ptr,
-			    int start, int end, gfp_t gfp)
-{
-	unsigned long id;
-	int ret;
-
-	if (WARN_ON_ONCE(start < 0))
-		return -EINVAL;
-
-	ret = idr_alloc_cmn(idr, ptr, &id, start, end, gfp, false);
-
-	if (ret)
-		return ret;
-
-	return id;
-}
-
-static inline int idr_alloc_ext(struct idr *idr, void *ptr,
-				unsigned long *index,
-				unsigned long start,
-				unsigned long end,
-				gfp_t gfp)
-{
-	return idr_alloc_cmn(idr, ptr, index, start, end, gfp, true);
-}
-
+int idr_alloc(struct idr *, void *, int start, int end, gfp_t);
 int __must_check idr_alloc_u32(struct idr *, void *ptr, u32 *nextid,
 				unsigned long max, gfp_t);
 int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);

commit e096f6a762bc54d0e5d44ba8b196e70b58e04367
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 10:14:27 2017 -0500

    idr: Add idr_alloc_u32 helper
    
    All current users of idr_alloc_ext() actually want to allocate a u32
    and idr_alloc_u32() fits their needs better.
    
    Like idr_get_next(), it uses a 'nextid' argument which serves as both
    a pointer to the start ID and the assigned ID (instead of a separate
    minimum and pointer-to-assigned-ID argument).  It uses a 'max' argument
    rather than 'end' because the semantics that idr_alloc has for 'end'
    don't work well for unsigned types.
    
    Since idr_alloc_u32() returns an errno instead of the allocated ID, mark
    it as __must_check to help callers use it correctly.  Include copious
    kernel-doc.  Chris Mi <chrism@mellanox.com> has promised to contribute
    test-cases for idr_alloc_u32.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 7867d6117535..561a4cbabca6 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -131,6 +131,8 @@ static inline int idr_alloc_ext(struct idr *idr, void *ptr,
 	return idr_alloc_cmn(idr, ptr, index, start, end, gfp, true);
 }
 
+int __must_check idr_alloc_u32(struct idr *, void *ptr, u32 *nextid,
+				unsigned long max, gfp_t);
 int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);
 int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);

commit 322d884ba731e05ca79ae58e9dee1ef7dc4de504
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 10:01:24 2017 -0500

    idr: Delete idr_find_ext function
    
    Simply changing idr_remove's 'id' argument to 'unsigned long' works
    for all callers.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index f1299c4dc45f..7867d6117535 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -179,16 +179,11 @@ static inline void idr_preload_end(void)
  * This function can be called under rcu_read_lock(), given that the leaf
  * pointers lifetimes are correctly managed.
  */
-static inline void *idr_find_ext(const struct idr *idr, unsigned long id)
+static inline void *idr_find(const struct idr *idr, unsigned long id)
 {
 	return radix_tree_lookup(&idr->idr_rt, id);
 }
 
-static inline void *idr_find(const struct idr *idr, int id)
-{
-	return idr_find_ext(idr, id);
-}
-
 /**
  * idr_for_each_entry - iterate over an idr's elements of a given type
  * @idr:     idr handle

commit 234a4624efe5629a777b4c00dbdf41dd8b7332db
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 09:56:36 2017 -0500

    idr: Delete idr_replace_ext function
    
    Changing idr_replace's 'id' argument to 'unsigned long' works for all
    callers.  Callers which passed a negative ID now get -ENOENT instead of
    -EINVAL.  No callers relied on this error value.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 118987a17ada..f1299c4dc45f 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -136,8 +136,7 @@ int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *, int *nextid);
 void *idr_get_next_ext(struct idr *idr, unsigned long *nextid);
-void *idr_replace(struct idr *, void *, int id);
-void *idr_replace_ext(struct idr *idr, void *ptr, unsigned long id);
+void *idr_replace(struct idr *, void *, unsigned long id);
 void idr_destroy(struct idr *);
 
 static inline void *idr_remove(struct idr *idr, unsigned long id)

commit 9c160941403ba833c8e67981806ccae73ff7aca7
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Nov 28 09:48:43 2017 -0500

    idr: Delete idr_remove_ext function
    
    Simply changing idr_remove's 'id' argument to 'unsigned long' suffices
    for all callers.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index fa14f834e4ed..118987a17ada 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -140,16 +140,11 @@ void *idr_replace(struct idr *, void *, int id);
 void *idr_replace_ext(struct idr *idr, void *ptr, unsigned long id);
 void idr_destroy(struct idr *);
 
-static inline void *idr_remove_ext(struct idr *idr, unsigned long id)
+static inline void *idr_remove(struct idr *idr, unsigned long id)
 {
 	return radix_tree_delete_item(&idr->idr_rt, id, NULL);
 }
 
-static inline void *idr_remove(struct idr *idr, int id)
-{
-	return idr_remove_ext(idr, id);
-}
-
 static inline void idr_init(struct idr *idr)
 {
 	INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);

commit c47d7f56e914900410f65835933f9fc4374d0a2b
Author: Wei Wang <wei.w.wang@intel.com>
Date:   Thu Dec 14 15:32:24 2017 -0800

    include/linux/idr.h: add #include <linux/bug.h>
    
    The <linux/bug.h> was removed from radix-tree.h by commit f5bba9d11a25
    ("include/linux/radix-tree.h: remove unneeded #include <linux/bug.h>").
    
    Since that commit, tools/testing/radix-tree/ couldn't pass compilation
    due to tools/testing/radix-tree/idr.c:17: undefined reference to
    WARN_ON_ONCE.  This patch adds the bug.h header to idr.h to solve the
    issue.
    
    Link: http://lkml.kernel.org/r/1511963726-34070-2-git-send-email-wei.w.wang@intel.com
    Fixes: f5bba9d11a2 ("include/linux/radix-tree.h: remove unneeded #include <linux/bug.h>")
    Signed-off-by: Wei Wang <wei.w.wang@intel.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Eric Biggers <ebiggers@google.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 7c3a365f7e12..fa14f834e4ed 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -15,6 +15,7 @@
 #include <linux/radix-tree.h>
 #include <linux/gfp.h>
 #include <linux/percpu.h>
+#include <linux/bug.h>
 
 struct idr {
 	struct radix_tree_root	idr_rt;

commit 388f79fda74fd3d8700ed5d899573ec58c2e0253
Author: Chris Mi <chrism@mellanox.com>
Date:   Wed Aug 30 02:31:57 2017 -0400

    idr: Add new APIs to support unsigned long
    
    The following new APIs are added:
    
    int idr_alloc_ext(struct idr *idr, void *ptr, unsigned long *index,
                      unsigned long start, unsigned long end, gfp_t gfp);
    void *idr_remove_ext(struct idr *idr, unsigned long id);
    void *idr_find_ext(const struct idr *idr, unsigned long id);
    void *idr_replace_ext(struct idr *idr, void *ptr, unsigned long id);
    void *idr_get_next_ext(struct idr *idr, unsigned long *nextid);
    
    Signed-off-by: Chris Mi <chrism@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index bf70b3ef0a07..7c3a365f7e12 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -80,19 +80,75 @@ static inline void idr_set_cursor(struct idr *idr, unsigned int val)
  */
 
 void idr_preload(gfp_t gfp_mask);
-int idr_alloc(struct idr *, void *entry, int start, int end, gfp_t);
+
+int idr_alloc_cmn(struct idr *idr, void *ptr, unsigned long *index,
+		  unsigned long start, unsigned long end, gfp_t gfp,
+		  bool ext);
+
+/**
+ * idr_alloc - allocate an id
+ * @idr: idr handle
+ * @ptr: pointer to be associated with the new id
+ * @start: the minimum id (inclusive)
+ * @end: the maximum id (exclusive)
+ * @gfp: memory allocation flags
+ *
+ * Allocates an unused ID in the range [start, end).  Returns -ENOSPC
+ * if there are no unused IDs in that range.
+ *
+ * Note that @end is treated as max when <= 0.  This is to always allow
+ * using @start + N as @end as long as N is inside integer range.
+ *
+ * Simultaneous modifications to the @idr are not allowed and should be
+ * prevented by the user, usually with a lock.  idr_alloc() may be called
+ * concurrently with read-only accesses to the @idr, such as idr_find() and
+ * idr_for_each_entry().
+ */
+static inline int idr_alloc(struct idr *idr, void *ptr,
+			    int start, int end, gfp_t gfp)
+{
+	unsigned long id;
+	int ret;
+
+	if (WARN_ON_ONCE(start < 0))
+		return -EINVAL;
+
+	ret = idr_alloc_cmn(idr, ptr, &id, start, end, gfp, false);
+
+	if (ret)
+		return ret;
+
+	return id;
+}
+
+static inline int idr_alloc_ext(struct idr *idr, void *ptr,
+				unsigned long *index,
+				unsigned long start,
+				unsigned long end,
+				gfp_t gfp)
+{
+	return idr_alloc_cmn(idr, ptr, index, start, end, gfp, true);
+}
+
 int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);
 int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *, int *nextid);
+void *idr_get_next_ext(struct idr *idr, unsigned long *nextid);
 void *idr_replace(struct idr *, void *, int id);
+void *idr_replace_ext(struct idr *idr, void *ptr, unsigned long id);
 void idr_destroy(struct idr *);
 
-static inline void *idr_remove(struct idr *idr, int id)
+static inline void *idr_remove_ext(struct idr *idr, unsigned long id)
 {
 	return radix_tree_delete_item(&idr->idr_rt, id, NULL);
 }
 
+static inline void *idr_remove(struct idr *idr, int id)
+{
+	return idr_remove_ext(idr, id);
+}
+
 static inline void idr_init(struct idr *idr)
 {
 	INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);
@@ -128,11 +184,16 @@ static inline void idr_preload_end(void)
  * This function can be called under rcu_read_lock(), given that the leaf
  * pointers lifetimes are correctly managed.
  */
-static inline void *idr_find(const struct idr *idr, int id)
+static inline void *idr_find_ext(const struct idr *idr, unsigned long id)
 {
 	return radix_tree_lookup(&idr->idr_rt, id);
 }
 
+static inline void *idr_find(const struct idr *idr, int id)
+{
+	return idr_find_ext(idr, id);
+}
+
 /**
  * idr_for_each_entry - iterate over an idr's elements of a given type
  * @idr:     idr handle
@@ -145,6 +206,8 @@ static inline void *idr_find(const struct idr *idr, int id)
  */
 #define idr_for_each_entry(idr, entry, id)			\
 	for (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; ++id)
+#define idr_for_each_entry_ext(idr, entry, id)			\
+	for (id = 0; ((entry) = idr_get_next_ext(idr, &(id))) != NULL; ++id)
 
 /**
  * idr_for_each_entry_continue - continue iteration over an idr's elements of a given type

commit d3e709e63e97e5f3f129b639991cfe266da60bae
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Thu Dec 22 13:30:22 2016 -0500

    idr: Return the deleted entry from idr_remove
    
    It is a relatively common idiom (8 instances) to first look up an IDR
    entry, and then remove it from the tree if it is found, possibly doing
    further operations upon the entry afterwards.  If we change idr_remove()
    to return the removed object, all of these users can save themselves a
    walk of the IDR tree.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 2027c7aba50d..bf70b3ef0a07 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -88,9 +88,9 @@ void *idr_get_next(struct idr *, int *nextid);
 void *idr_replace(struct idr *, void *, int id);
 void idr_destroy(struct idr *);
 
-static inline void idr_remove(struct idr *idr, int id)
+static inline void *idr_remove(struct idr *idr, int id)
 {
-	radix_tree_delete(&idr->idr_rt, id);
+	return radix_tree_delete_item(&idr->idr_rt, id, NULL);
 }
 
 static inline void idr_init(struct idr *idr)

commit 7ad3d4d85c7af9632055a6ac0aa15b6b6a321c6b
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Fri Dec 16 11:55:56 2016 -0500

    ida: Move ida_bitmap to a percpu variable
    
    When we preload the IDA, we allocate an IDA bitmap.  Instead of storing
    that preallocated bitmap in the IDA, we store it in a percpu variable.
    Generally there are more IDAs in the system than CPUs, so this cuts down
    on the number of preallocated bitmaps that are unused, and about half
    of the IDA users did not call ida_destroy() so they were leaking IDA
    bitmaps.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index f58c0a3addc3..2027c7aba50d 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -14,6 +14,7 @@
 
 #include <linux/radix-tree.h>
 #include <linux/gfp.h>
+#include <linux/percpu.h>
 
 struct idr {
 	struct radix_tree_root	idr_rt;
@@ -171,9 +172,10 @@ struct ida_bitmap {
 	unsigned long		bitmap[IDA_BITMAP_LONGS];
 };
 
+DECLARE_PER_CPU(struct ida_bitmap *, ida_bitmap);
+
 struct ida {
 	struct radix_tree_root	ida_rt;
-	struct ida_bitmap	*free_bitmap;
 };
 
 #define IDA_INIT	{						\
@@ -193,7 +195,6 @@ void ida_simple_remove(struct ida *ida, unsigned int id);
 static inline void ida_init(struct ida *ida)
 {
 	INIT_RADIX_TREE(&ida->ida_rt, IDR_RT_MARKER | GFP_NOWAIT);
-	ida->free_bitmap = NULL;
 }
 
 /**

commit 0a835c4f090af2c76fc2932c539c3b32fd21fbbb
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Dec 20 10:27:56 2016 -0500

    Reimplement IDR and IDA using the radix tree
    
    The IDR is very similar to the radix tree.  It has some functionality that
    the radix tree did not have (alloc next free, cyclic allocation, a
    callback-based for_each, destroy tree), which is readily implementable on
    top of the radix tree.  A few small changes were needed in order to use a
    tag to represent nodes with free space below them.  More extensive
    changes were needed to support storing NULL as a valid entry in an IDR.
    Plain radix trees still interpret NULL as a not-present entry.
    
    The IDA is reimplemented as a client of the newly enhanced radix tree.  As
    in the current implementation, it uses a bitmap at the last level of the
    tree.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 3c01b89aed67..f58c0a3addc3 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -12,47 +12,28 @@
 #ifndef __IDR_H__
 #define __IDR_H__
 
-#include <linux/types.h>
-#include <linux/bitops.h>
-#include <linux/init.h>
-#include <linux/rcupdate.h>
+#include <linux/radix-tree.h>
+#include <linux/gfp.h>
+
+struct idr {
+	struct radix_tree_root	idr_rt;
+	unsigned int		idr_next;
+};
 
 /*
- * Using 6 bits at each layer allows us to allocate 7 layers out of each page.
- * 8 bits only gave us 3 layers out of every pair of pages, which is less
- * efficient except for trees with a largest element between 192-255 inclusive.
+ * The IDR API does not expose the tagging functionality of the radix tree
+ * to users.  Use tag 0 to track whether a node has free space below it.
  */
-#define IDR_BITS 6
-#define IDR_SIZE (1 << IDR_BITS)
-#define IDR_MASK ((1 << IDR_BITS)-1)
-
-struct idr_layer {
-	int			prefix;	/* the ID prefix of this idr_layer */
-	int			layer;	/* distance from leaf */
-	struct idr_layer __rcu	*ary[1<<IDR_BITS];
-	int			count;	/* When zero, we can release it */
-	union {
-		/* A zero bit means "space here" */
-		DECLARE_BITMAP(bitmap, IDR_SIZE);
-		struct rcu_head		rcu_head;
-	};
-};
+#define IDR_FREE	0
 
-struct idr {
-	struct idr_layer __rcu	*hint;	/* the last layer allocated from */
-	struct idr_layer __rcu	*top;
-	int			layers;	/* only valid w/o concurrent changes */
-	int			cur;	/* current pos for cyclic allocation */
-	spinlock_t		lock;
-	int			id_free_cnt;
-	struct idr_layer	*id_free;
-};
+/* Set the IDR flag and the IDR_FREE tag */
+#define IDR_RT_MARKER		((__force gfp_t)(3 << __GFP_BITS_SHIFT))
 
-#define IDR_INIT(name)							\
+#define IDR_INIT							\
 {									\
-	.lock			= __SPIN_LOCK_UNLOCKED(name.lock),	\
+	.idr_rt = RADIX_TREE_INIT(IDR_RT_MARKER)			\
 }
-#define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
+#define DEFINE_IDR(name)	struct idr name = IDR_INIT
 
 /**
  * idr_get_cursor - Return the current position of the cyclic allocator
@@ -62,9 +43,9 @@ struct idr {
  * idr_alloc_cyclic() if it is free (otherwise the search will start from
  * this position).
  */
-static inline unsigned int idr_get_cursor(struct idr *idr)
+static inline unsigned int idr_get_cursor(const struct idr *idr)
 {
-	return READ_ONCE(idr->cur);
+	return READ_ONCE(idr->idr_next);
 }
 
 /**
@@ -77,7 +58,7 @@ static inline unsigned int idr_get_cursor(struct idr *idr)
  */
 static inline void idr_set_cursor(struct idr *idr, unsigned int val)
 {
-	WRITE_ONCE(idr->cur, val);
+	WRITE_ONCE(idr->idr_next, val);
 }
 
 /**
@@ -97,22 +78,31 @@ static inline void idr_set_cursor(struct idr *idr, unsigned int val)
  * period).
  */
 
-/*
- * This is what we export.
- */
-
-void *idr_find_slowpath(struct idr *idp, int id);
 void idr_preload(gfp_t gfp_mask);
-int idr_alloc(struct idr *idp, void *ptr, int start, int end, gfp_t gfp_mask);
-int idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask);
-int idr_for_each(struct idr *idp,
+int idr_alloc(struct idr *, void *entry, int start, int end, gfp_t);
+int idr_alloc_cyclic(struct idr *, void *entry, int start, int end, gfp_t);
+int idr_for_each(const struct idr *,
 		 int (*fn)(int id, void *p, void *data), void *data);
-void *idr_get_next(struct idr *idp, int *nextid);
-void *idr_replace(struct idr *idp, void *ptr, int id);
-void idr_remove(struct idr *idp, int id);
-void idr_destroy(struct idr *idp);
-void idr_init(struct idr *idp);
-bool idr_is_empty(struct idr *idp);
+void *idr_get_next(struct idr *, int *nextid);
+void *idr_replace(struct idr *, void *, int id);
+void idr_destroy(struct idr *);
+
+static inline void idr_remove(struct idr *idr, int id)
+{
+	radix_tree_delete(&idr->idr_rt, id);
+}
+
+static inline void idr_init(struct idr *idr)
+{
+	INIT_RADIX_TREE(&idr->idr_rt, IDR_RT_MARKER);
+	idr->idr_next = 0;
+}
+
+static inline bool idr_is_empty(const struct idr *idr)
+{
+	return radix_tree_empty(&idr->idr_rt) &&
+		radix_tree_tagged(&idr->idr_rt, IDR_FREE);
+}
 
 /**
  * idr_preload_end - end preload section started with idr_preload()
@@ -137,19 +127,14 @@ static inline void idr_preload_end(void)
  * This function can be called under rcu_read_lock(), given that the leaf
  * pointers lifetimes are correctly managed.
  */
-static inline void *idr_find(struct idr *idr, int id)
+static inline void *idr_find(const struct idr *idr, int id)
 {
-	struct idr_layer *hint = rcu_dereference_raw(idr->hint);
-
-	if (hint && (id & ~IDR_MASK) == hint->prefix)
-		return rcu_dereference_raw(hint->ary[id & IDR_MASK]);
-
-	return idr_find_slowpath(idr, id);
+	return radix_tree_lookup(&idr->idr_rt, id);
 }
 
 /**
  * idr_for_each_entry - iterate over an idr's elements of a given type
- * @idp:     idr handle
+ * @idr:     idr handle
  * @entry:   the type * to use as cursor
  * @id:      id entry's key
  *
@@ -157,57 +142,60 @@ static inline void *idr_find(struct idr *idr, int id)
  * after normal terminatinon @entry is left with the value NULL.  This
  * is convenient for a "not found" value.
  */
-#define idr_for_each_entry(idp, entry, id)			\
-	for (id = 0; ((entry) = idr_get_next(idp, &(id))) != NULL; ++id)
+#define idr_for_each_entry(idr, entry, id)			\
+	for (id = 0; ((entry) = idr_get_next(idr, &(id))) != NULL; ++id)
 
 /**
- * idr_for_each_entry - continue iteration over an idr's elements of a given type
- * @idp:     idr handle
+ * idr_for_each_entry_continue - continue iteration over an idr's elements of a given type
+ * @idr:     idr handle
  * @entry:   the type * to use as cursor
  * @id:      id entry's key
  *
  * Continue to iterate over list of given type, continuing after
  * the current position.
  */
-#define idr_for_each_entry_continue(idp, entry, id)			\
-	for ((entry) = idr_get_next((idp), &(id));			\
+#define idr_for_each_entry_continue(idr, entry, id)			\
+	for ((entry) = idr_get_next((idr), &(id));			\
 	     entry;							\
-	     ++id, (entry) = idr_get_next((idp), &(id)))
+	     ++id, (entry) = idr_get_next((idr), &(id)))
 
 /*
  * IDA - IDR based id allocator, use when translation from id to
  * pointer isn't necessary.
- *
- * IDA_BITMAP_LONGS is calculated to be one less to accommodate
- * ida_bitmap->nr_busy so that the whole struct fits in 128 bytes.
  */
 #define IDA_CHUNK_SIZE		128	/* 128 bytes per chunk */
-#define IDA_BITMAP_LONGS	(IDA_CHUNK_SIZE / sizeof(long) - 1)
+#define IDA_BITMAP_LONGS	(IDA_CHUNK_SIZE / sizeof(long))
 #define IDA_BITMAP_BITS 	(IDA_BITMAP_LONGS * sizeof(long) * 8)
 
 struct ida_bitmap {
-	long			nr_busy;
 	unsigned long		bitmap[IDA_BITMAP_LONGS];
 };
 
 struct ida {
-	struct idr		idr;
+	struct radix_tree_root	ida_rt;
 	struct ida_bitmap	*free_bitmap;
 };
 
-#define IDA_INIT(name)		{ .idr = IDR_INIT((name).idr), .free_bitmap = NULL, }
-#define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
+#define IDA_INIT	{						\
+	.ida_rt = RADIX_TREE_INIT(IDR_RT_MARKER | GFP_NOWAIT),		\
+}
+#define DEFINE_IDA(name)	struct ida name = IDA_INIT
 
 int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
 int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
 void ida_remove(struct ida *ida, int id);
 void ida_destroy(struct ida *ida);
-void ida_init(struct ida *ida);
 
 int ida_simple_get(struct ida *ida, unsigned int start, unsigned int end,
 		   gfp_t gfp_mask);
 void ida_simple_remove(struct ida *ida, unsigned int id);
 
+static inline void ida_init(struct ida *ida)
+{
+	INIT_RADIX_TREE(&ida->ida_rt, IDR_RT_MARKER | GFP_NOWAIT);
+	ida->free_bitmap = NULL;
+}
+
 /**
  * ida_get_new - allocate new ID
  * @ida:	idr handle
@@ -220,11 +208,8 @@ static inline int ida_get_new(struct ida *ida, int *p_id)
 	return ida_get_new_above(ida, 0, p_id);
 }
 
-static inline bool ida_is_empty(struct ida *ida)
+static inline bool ida_is_empty(const struct ida *ida)
 {
-	return idr_is_empty(&ida->idr);
+	return radix_tree_empty(&ida->ida_rt);
 }
-
-void __init idr_init_cache(void);
-
 #endif /* __IDR_H__ */

commit 424251a4a929a1b6dff2056d49135e3805132e32
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Wed Dec 14 15:09:22 2016 -0800

    idr: reduce the number of bits per level from 8 to 6
    
    In preparation for merging the IDR and radix tree, reduce the fanout at
    each level from 256 to 64.  If this causes a performance problem then a
    bisect will point to this commit, and we'll have a better idea about
    what we might do to fix it.
    
    Link: http://lkml.kernel.org/r/1480369871-5271-66-git-send-email-mawilcox@linuxonhyperv.com
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 1eb755f77f2f..3c01b89aed67 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -18,12 +18,11 @@
 #include <linux/rcupdate.h>
 
 /*
- * We want shallower trees and thus more bits covered at each layer.  8
- * bits gives us large enough first layer for most use cases and maximum
- * tree depth of 4.  Each idr_layer is slightly larger than 2k on 64bit and
- * 1k on 32bit.
+ * Using 6 bits at each layer allows us to allocate 7 layers out of each page.
+ * 8 bits only gave us 3 layers out of every pair of pages, which is less
+ * efficient except for trees with a largest element between 192-255 inclusive.
  */
-#define IDR_BITS 8
+#define IDR_BITS 6
 #define IDR_SIZE (1 << IDR_BITS)
 #define IDR_MASK ((1 << IDR_BITS)-1)
 

commit 444306129a920015a2cc876d13fcbf52382f39bd
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Wed Dec 14 15:09:19 2016 -0800

    rxrpc: abstract away knowledge of IDR internals
    
    Add idr_get_cursor() / idr_set_cursor() APIs, and remove the reference
    to IDR_SIZE.
    
    Link: http://lkml.kernel.org/r/1480369871-5271-65-git-send-email-mawilcox@linuxonhyperv.com
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: David Howells <dhowells@redhat.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 3639a28188c9..1eb755f77f2f 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -55,6 +55,32 @@ struct idr {
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 
+/**
+ * idr_get_cursor - Return the current position of the cyclic allocator
+ * @idr: idr handle
+ *
+ * The value returned is the value that will be next returned from
+ * idr_alloc_cyclic() if it is free (otherwise the search will start from
+ * this position).
+ */
+static inline unsigned int idr_get_cursor(struct idr *idr)
+{
+	return READ_ONCE(idr->cur);
+}
+
+/**
+ * idr_set_cursor - Set the current position of the cyclic allocator
+ * @idr: idr handle
+ * @val: new position
+ *
+ * The next call to idr_alloc_cyclic() will return @val if it is free
+ * (otherwise the search will start from this position).
+ */
+static inline void idr_set_cursor(struct idr *idr, unsigned int val)
+{
+	WRITE_ONCE(idr->cur, val);
+}
+
 /**
  * DOC: idr sync
  * idr synchronization (stolen from radix-tree.h)

commit 99c494077e2d4282a17120a772eecc00ec3004cc
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Wed Dec 14 15:09:13 2016 -0800

    idr: add ida_is_empty
    
    Two of the USB Gadgets were poking around in the internals of struct ida
    in order to determine if it is empty.  Add the appropriate abstraction.
    
    Link: http://lkml.kernel.org/r/1480369871-5271-63-git-send-email-mawilcox@linuxonhyperv.com
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: Konstantin Khlebnikov <koct9i@gmail.com>
    Tested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 083d61e92706..3639a28188c9 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -195,6 +195,11 @@ static inline int ida_get_new(struct ida *ida, int *p_id)
 	return ida_get_new_above(ida, 0, p_id);
 }
 
+static inline bool ida_is_empty(struct ida *ida)
+{
+	return idr_is_empty(&ida->idr);
+}
+
 void __init idr_init_cache(void);
 
 #endif /* __IDR_H__ */

commit a55bbd375d1802141f0f043e2cd08f85c23d6209
Author: Andreas Gruenbacher <agruen@linbit.com>
Date:   Thu Aug 28 13:31:14 2014 +0200

    drbd: Backport the "status" command
    
    The status command originates the drbd9 code base. While for now we
    keep the status information in /proc/drbd available, this commit
    allows the user base to gracefully migrate their monitoring
    infrastructure to the new status reporting interface.
    
    In drbd9 no status information is exposed through /proc/drbd.
    
    Signed-off-by: Philipp Reisner <philipp.reisner@linbit.com>
    Signed-off-by: Lars Ellenberg <lars.ellenberg@linbit.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 013fd9bc4cb6..083d61e92706 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -135,6 +135,20 @@ static inline void *idr_find(struct idr *idr, int id)
 #define idr_for_each_entry(idp, entry, id)			\
 	for (id = 0; ((entry) = idr_get_next(idp, &(id))) != NULL; ++id)
 
+/**
+ * idr_for_each_entry - continue iteration over an idr's elements of a given type
+ * @idp:     idr handle
+ * @entry:   the type * to use as cursor
+ * @id:      id entry's key
+ *
+ * Continue to iterate over list of given type, continuing after
+ * the current position.
+ */
+#define idr_for_each_entry_continue(idp, entry, id)			\
+	for ((entry) = idr_get_next((idp), &(id));			\
+	     entry;							\
+	     ++id, (entry) = idr_get_next((idp), &(id)))
+
 /*
  * IDA - IDR based id allocator, use when translation from id to
  * pointer isn't necessary.

commit dcbff5d1effbbd52be1ed9f2efb6c8d0445ad188
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Fri Jun 6 14:37:15 2014 -0700

    idr: reorder the fields
    
    idr_layer->layer is always accessed in read path, move it in the front.
    
    idr_layer->bitmap is moved on the bottom.  And rcu_head shares with
    bitmap due to they do not be accessed at the same time.
    
    idr->id_free/id_free_cnt/lock are free list fields, and moved to the
    bottom.  They will be removed in near future.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 6af3400b9b2f..013fd9bc4cb6 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -29,21 +29,24 @@
 
 struct idr_layer {
 	int			prefix;	/* the ID prefix of this idr_layer */
-	DECLARE_BITMAP(bitmap, IDR_SIZE); /* A zero bit means "space here" */
+	int			layer;	/* distance from leaf */
 	struct idr_layer __rcu	*ary[1<<IDR_BITS];
 	int			count;	/* When zero, we can release it */
-	int			layer;	/* distance from leaf */
-	struct rcu_head		rcu_head;
+	union {
+		/* A zero bit means "space here" */
+		DECLARE_BITMAP(bitmap, IDR_SIZE);
+		struct rcu_head		rcu_head;
+	};
 };
 
 struct idr {
 	struct idr_layer __rcu	*hint;	/* the last layer allocated from */
 	struct idr_layer __rcu	*top;
-	struct idr_layer	*id_free;
 	int			layers;	/* only valid w/o concurrent changes */
-	int			id_free_cnt;
 	int			cur;	/* current pos for cyclic allocation */
 	spinlock_t		lock;
+	int			id_free_cnt;
+	struct idr_layer	*id_free;
 };
 
 #define IDR_INIT(name)							\

commit 90ae3ae539246984d36e43b0e23554bca941476f
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Mon Apr 7 15:38:52 2014 -0700

    idr: remove dead code
    
    Remove no longer used deprecated code, and make local functions
    static.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Acked-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Philipp Reisner <philipp.reisner@linbit.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: George Spelvin <linux@horizon.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index f669585c4fc5..6af3400b9b2f 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -132,69 +132,6 @@ static inline void *idr_find(struct idr *idr, int id)
 #define idr_for_each_entry(idp, entry, id)			\
 	for (id = 0; ((entry) = idr_get_next(idp, &(id))) != NULL; ++id)
 
-/*
- * Don't use the following functions.  These exist only to suppress
- * deprecated warnings on EXPORT_SYMBOL()s.
- */
-int __idr_pre_get(struct idr *idp, gfp_t gfp_mask);
-int __idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
-void __idr_remove_all(struct idr *idp);
-
-/**
- * idr_pre_get - reserve resources for idr allocation
- * @idp:	idr handle
- * @gfp_mask:	memory allocation flags
- *
- * Part of old alloc interface.  This is going away.  Use
- * idr_preload[_end]() and idr_alloc() instead.
- */
-static inline int __deprecated idr_pre_get(struct idr *idp, gfp_t gfp_mask)
-{
-	return __idr_pre_get(idp, gfp_mask);
-}
-
-/**
- * idr_get_new_above - allocate new idr entry above or equal to a start id
- * @idp: idr handle
- * @ptr: pointer you want associated with the id
- * @starting_id: id to start search at
- * @id: pointer to the allocated handle
- *
- * Part of old alloc interface.  This is going away.  Use
- * idr_preload[_end]() and idr_alloc() instead.
- */
-static inline int __deprecated idr_get_new_above(struct idr *idp, void *ptr,
-						 int starting_id, int *id)
-{
-	return __idr_get_new_above(idp, ptr, starting_id, id);
-}
-
-/**
- * idr_get_new - allocate new idr entry
- * @idp: idr handle
- * @ptr: pointer you want associated with the id
- * @id: pointer to the allocated handle
- *
- * Part of old alloc interface.  This is going away.  Use
- * idr_preload[_end]() and idr_alloc() instead.
- */
-static inline int __deprecated idr_get_new(struct idr *idp, void *ptr, int *id)
-{
-	return __idr_get_new_above(idp, ptr, 0, id);
-}
-
-/**
- * idr_remove_all - remove all ids from the given idr tree
- * @idp: idr handle
- *
- * If you're trying to destroy @idp, calling idr_destroy() is enough.
- * This is going away.  Don't use.
- */
-static inline void __deprecated idr_remove_all(struct idr *idp)
-{
-	__idr_remove_all(idp);
-}
-
 /*
  * IDA - IDR based id allocator, use when translation from id to
  * pointer isn't necessary.

commit 159d8133d0b54a501a41a66fe3a0e7d16405e36d
Merge: 05bf58ca4b8f c800bcd5f53f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 2 16:23:38 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina:
     "Usual rocket science -- mostly documentation and comment updates"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      sparse: fix comment
      doc: fix double words
      isdn: capi: fix "CAPI_VERSION" comment
      doc: DocBook: Fix typos in xml and template file
      Bluetooth: add module name for btwilink
      driver core: unexport static function create_syslog_header
      mmc: core: typo fix in printk specifier
      ARM: spear: clean up editing mistake
      net-sysfs: fix comment typo 'CONFIG_SYFS'
      doc: Insert MODULE_ in module-signing macros
      Documentation: update URL to hfsplus Technote 1150
      gpio: update path to documentation
      ixgbe: Fix format string in ixgbe_fcoe.
      Kconfig: Remove useless "default N" lines
      user_namespace.c: Remove duplicated word in comment
      CREDITS: fix formatting
      treewide: Fix typo in Documentation/DocBook
      mm: Fix warning on make htmldocs caused by slab.c
      ata: ata-samsung_cf: cleanup in header file
      idr: remove unused prototype of idr_free()

commit 05f7a7d6a7d23a877063857cf2df1dffec5a96dc
Author: Andreas Gruenbacher <agruen@linbit.com>
Date:   Mon Aug 8 23:36:56 2011 +0200

    idr: Add new function idr_is_empty()
    
    Signed-off-by: Andreas Gruenbacher <agruen@linbit.com>
    Signed-off-by: Philipp Reisner <philipp.reisner@linbit.com>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 871a213a8477..9c95d210458b 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -85,6 +85,7 @@ void idr_remove(struct idr *idp, int id);
 void idr_free(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
+bool idr_is_empty(struct idr *idp);
 
 /**
  * idr_preload_end - end preload section started with idr_preload()

commit 8cc7212a036118fcb5cfbbdb013c5032677bbd23
Author: Vladimir Davydov <vdavydov@parallels.com>
Date:   Thu Jan 30 19:57:54 2014 +0400

    idr: remove unused prototype of idr_free()
    
    There is no such function. Remove the redundant prototype.
    
    Signed-off-by: Vladimir Davydov <vdavydov@parallels.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 871a213a8477..ff94a4875e1c 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -82,7 +82,6 @@ int idr_for_each(struct idr *idp,
 void *idr_get_next(struct idr *idp, int *nextid);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
-void idr_free(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 

commit ebb37277796269da36a8bc5d72ed1e8e1fb7d34b
Merge: 4de13d7aa8f4 f50efd2fdbd9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 8 11:51:05 2013 -0700

    Merge branch 'for-3.10/drivers' of git://git.kernel.dk/linux-block
    
    Pull block driver updates from Jens Axboe:
     "It might look big in volume, but when categorized, not a lot of
      drivers are touched.  The pull request contains:
    
       - mtip32xx fixes from Micron.
    
       - A slew of drbd updates, this time in a nicer series.
    
       - bcache, a flash/ssd caching framework from Kent.
    
       - Fixes for cciss"
    
    * 'for-3.10/drivers' of git://git.kernel.dk/linux-block: (66 commits)
      bcache: Use bd_link_disk_holder()
      bcache: Allocator cleanup/fixes
      cciss: bug fix to prevent cciss from loading in kdump crash kernel
      cciss: add cciss_allow_hpsa module parameter
      drivers/block/mg_disk.c: add CONFIG_PM_SLEEP to suspend/resume functions
      mtip32xx: Workaround for unaligned writes
      bcache: Make sure blocksize isn't smaller than device blocksize
      bcache: Fix merge_bvec_fn usage for when it modifies the bvm
      bcache: Correctly check against BIO_MAX_PAGES
      bcache: Hack around stuff that clones up to bi_max_vecs
      bcache: Set ra_pages based on backing device's ra_pages
      bcache: Take data offset from the bdev superblock.
      mtip32xx: mtip32xx: Disable TRIM support
      mtip32xx: fix a smatch warning
      bcache: Disable broken btree fuzz tester
      bcache: Fix a format string overflow
      bcache: Fix a minor memory leak on device teardown
      bcache: Documentation updates
      bcache: Use WARN_ONCE() instead of __WARN()
      bcache: Add missing #include <linux/prefetch.h>
      ...

commit 3e6628c4b347a558965041290c5a92791dd4c741
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Apr 29 16:21:16 2013 -0700

    idr: introduce idr_alloc_cyclic()
    
    As Tejun points out, there are several users of the IDR facility that
    attempt to use it in a cyclic fashion.  These users are likely to see
    -ENOSPC errors after the counter wraps one or more times however.
    
    This patchset adds a new idr_alloc_cyclic routine and converts several
    of these users to it.  Many of these users are in obscure parts of the
    kernel, and I don't have a good way to test some of them.  The change is
    pretty straightforward though, so hopefully it won't be an issue.
    
    There is one other cyclic user of idr_alloc that I didn't touch in
    ipc/util.c.  That one is doing some strange stuff that I didn't quite
    understand, but it looks like it should probably be converted later
    somehow.
    
    This patch:
    
    Thus spake Tejun Heo:
    
        Ooh, BTW, the cyclic allocation is broken.  It's prone to -ENOSPC
        after the first wraparound.  There are several cyclic users in the
        kernel and I think it probably would be best to implement cyclic
        support in idr.
    
    This patch does that by adding new idr_alloc_cyclic function that such
    users in the kernel can use.  With this, there's no need for a caller to
    keep track of the last value used as that's now tracked internally.  This
    should prevent the ENOSPC problems that can hit when the "last allocated"
    counter exceeds INT_MAX.
    
    Later patches will convert existing cyclic users to the new interface.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Cc: John McCutchan <john@johnmccutchan.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Cc: Robert Love <rlove@rlove.org>
    Cc: Roland Dreier <roland@purestorage.com>
    Cc: Sridhar Samudrala <sri@us.ibm.com>
    Cc: Steve Wise <swise@opengridcomputing.com>
    Cc: Tom Tucker <tom@opengridcomputing.com>
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 2640c7e99e51..a470ac3ef49d 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -42,6 +42,7 @@ struct idr {
 	struct idr_layer	*id_free;
 	int			layers;	/* only valid w/o concurrent changes */
 	int			id_free_cnt;
+	int			cur;	/* current pos for cyclic allocation */
 	spinlock_t		lock;
 };
 
@@ -75,6 +76,7 @@ struct idr {
 void *idr_find_slowpath(struct idr *idp, int id);
 void idr_preload(gfp_t gfp_mask);
 int idr_alloc(struct idr *idp, void *ptr, int start, int end, gfp_t gfp_mask);
+int idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask);
 int idr_for_each(struct idr *idp,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *idp, int *nextid);

commit b949be5857a4033e00fed67b707774f52619ce60
Author: George Spelvin <linux@horizon.com>
Date:   Wed Mar 27 14:08:33 2013 +0100

    idr: document exit conditions on idr_for_each_entry better
    
    And some manual common subexpression elimination which may help the
    compiler produce smaller code.
    
    Signed-off-by: George Spelvin <linux@horizon.com>
    Signed-off-by: Philipp Reisner <philipp.reisner@linbit.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 2640c7e99e51..6ece0583362a 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -122,11 +122,13 @@ static inline void *idr_find(struct idr *idr, int id)
  * @idp:     idr handle
  * @entry:   the type * to use as cursor
  * @id:      id entry's key
+ *
+ * @entry and @id do not need to be initialized before the loop, and
+ * after normal terminatinon @entry is left with the value NULL.  This
+ * is convenient for a "not found" value.
  */
-#define idr_for_each_entry(idp, entry, id)				\
-	for (id = 0, entry = (typeof(entry))idr_get_next((idp), &(id)); \
-	     entry != NULL;                                             \
-	     ++id, entry = (typeof(entry))idr_get_next((idp), &(id)))
+#define idr_for_each_entry(idp, entry, id)			\
+	for (id = 0; ((entry) = idr_get_next(idp, &(id))) != NULL; ++id)
 
 /*
  * Don't use the following functions.  These exist only to suppress

commit c8615d3716fe327c2540cf514a34b227dc9b39e8
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 13 14:59:42 2013 -0700

    idr: deprecate idr_pre_get() and idr_get_new[_above]()
    
    Now that all in-kernel users are converted to ues the new alloc
    interface, mark the old interface deprecated.  We should be able to
    remove these in a few releases.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 8c1f81f823c8..2640c7e99e51 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -73,8 +73,6 @@ struct idr {
  */
 
 void *idr_find_slowpath(struct idr *idp, int id);
-int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
-int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 void idr_preload(gfp_t gfp_mask);
 int idr_alloc(struct idr *idp, void *ptr, int start, int end, gfp_t gfp_mask);
 int idr_for_each(struct idr *idp,
@@ -119,19 +117,6 @@ static inline void *idr_find(struct idr *idr, int id)
 	return idr_find_slowpath(idr, id);
 }
 
-/**
- * idr_get_new - allocate new idr entry
- * @idp: idr handle
- * @ptr: pointer you want associated with the id
- * @id: pointer to the allocated handle
- *
- * Simple wrapper around idr_get_new_above() w/ @starting_id of zero.
- */
-static inline int idr_get_new(struct idr *idp, void *ptr, int *id)
-{
-	return idr_get_new_above(idp, ptr, 0, id);
-}
-
 /**
  * idr_for_each_entry - iterate over an idr's elements of a given type
  * @idp:     idr handle
@@ -143,7 +128,56 @@ static inline int idr_get_new(struct idr *idp, void *ptr, int *id)
 	     entry != NULL;                                             \
 	     ++id, entry = (typeof(entry))idr_get_next((idp), &(id)))
 
-void __idr_remove_all(struct idr *idp);	/* don't use */
+/*
+ * Don't use the following functions.  These exist only to suppress
+ * deprecated warnings on EXPORT_SYMBOL()s.
+ */
+int __idr_pre_get(struct idr *idp, gfp_t gfp_mask);
+int __idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
+void __idr_remove_all(struct idr *idp);
+
+/**
+ * idr_pre_get - reserve resources for idr allocation
+ * @idp:	idr handle
+ * @gfp_mask:	memory allocation flags
+ *
+ * Part of old alloc interface.  This is going away.  Use
+ * idr_preload[_end]() and idr_alloc() instead.
+ */
+static inline int __deprecated idr_pre_get(struct idr *idp, gfp_t gfp_mask)
+{
+	return __idr_pre_get(idp, gfp_mask);
+}
+
+/**
+ * idr_get_new_above - allocate new idr entry above or equal to a start id
+ * @idp: idr handle
+ * @ptr: pointer you want associated with the id
+ * @starting_id: id to start search at
+ * @id: pointer to the allocated handle
+ *
+ * Part of old alloc interface.  This is going away.  Use
+ * idr_preload[_end]() and idr_alloc() instead.
+ */
+static inline int __deprecated idr_get_new_above(struct idr *idp, void *ptr,
+						 int starting_id, int *id)
+{
+	return __idr_get_new_above(idp, ptr, starting_id, id);
+}
+
+/**
+ * idr_get_new - allocate new idr entry
+ * @idp: idr handle
+ * @ptr: pointer you want associated with the id
+ * @id: pointer to the allocated handle
+ *
+ * Part of old alloc interface.  This is going away.  Use
+ * idr_preload[_end]() and idr_alloc() instead.
+ */
+static inline int __deprecated idr_get_new(struct idr *idp, void *ptr, int *id)
+{
+	return __idr_get_new_above(idp, ptr, 0, id);
+}
 
 /**
  * idr_remove_all - remove all ids from the given idr tree

commit 5857f70c8a62377c2304d8ad27e579881728fc5a
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Mar 4 14:32:54 2013 -0800

    idr: fix new kernel-doc warnings
    
    Fix new kernel-doc warnings in idr:
    
      Warning(include/linux/idr.h:113): No description found for parameter 'idr'
      Warning(include/linux/idr.h:113): Excess function parameter 'idp' description in 'idr_find'
      Warning(lib/idr.c:232): Excess function parameter 'id' description in 'sub_alloc'
      Warning(lib/idr.c:232): Excess function parameter 'id' description in 'sub_alloc'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index a6f38b5c34e4..8c1f81f823c8 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -99,7 +99,7 @@ static inline void idr_preload_end(void)
 
 /**
  * idr_find - return pointer for given id
- * @idp: idr handle
+ * @idr: idr handle
  * @id: lookup key
  *
  * Return the pointer given the id it has been registered with.  A %NULL

commit 0ffc2a9c8072969253a20821c2c733a2cbb4c7c7
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:05:08 2013 -0800

    idr: implement lookup hint
    
    While idr lookup isn't a particularly heavy operation, it still is too
    substantial to use in hot paths without worrying about the performance
    implications.  With recent changes, each idr_layer covers 256 slots
    which should be enough to cover most use cases with single idr_layer
    making lookup hint very attractive.
    
    This patch adds idr->hint which points to the idr_layer which
    allocated an ID most recently and the fast path lookup becomes
    
            if (look up target's prefix matches that of the hinted layer)
                    return hint->ary[ID's offset in the leaf layer];
    
    which can be inlined.
    
    idr->hint is set to the leaf node on idr_fill_slot() and cleared from
    free_layer().
    
    [andriy.shevchenko@linux.intel.com: always do slow path when hint is uninitialized]
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 7b1c5c6f9a06..a6f38b5c34e4 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -37,6 +37,7 @@ struct idr_layer {
 };
 
 struct idr {
+	struct idr_layer __rcu	*hint;	/* the last layer allocated from */
 	struct idr_layer __rcu	*top;
 	struct idr_layer	*id_free;
 	int			layers;	/* only valid w/o concurrent changes */
@@ -71,7 +72,7 @@ struct idr {
  * This is what we export.
  */
 
-void *idr_find(struct idr *idp, int id);
+void *idr_find_slowpath(struct idr *idp, int id);
 int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 void idr_preload(gfp_t gfp_mask);
@@ -96,6 +97,28 @@ static inline void idr_preload_end(void)
 	preempt_enable();
 }
 
+/**
+ * idr_find - return pointer for given id
+ * @idp: idr handle
+ * @id: lookup key
+ *
+ * Return the pointer given the id it has been registered with.  A %NULL
+ * return indicates that @id is not valid or you passed %NULL in
+ * idr_get_new().
+ *
+ * This function can be called under rcu_read_lock(), given that the leaf
+ * pointers lifetimes are correctly managed.
+ */
+static inline void *idr_find(struct idr *idr, int id)
+{
+	struct idr_layer *hint = rcu_dereference_raw(idr->hint);
+
+	if (hint && (id & ~IDR_MASK) == hint->prefix)
+		return rcu_dereference_raw(hint->ary[id & IDR_MASK]);
+
+	return idr_find_slowpath(idr, id);
+}
+
 /**
  * idr_get_new - allocate new idr entry
  * @idp: idr handle

commit 54616283c2948812a44240858ced610e7cacbde1
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:05:07 2013 -0800

    idr: add idr_layer->prefix
    
    Add a field which carries the prefix of ID the idr_layer covers.  This
    will be used to implement lookup hint.
    
    This patch doesn't make use of the new field and doesn't introduce any
    behavior difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 43b87b1c77a3..7b1c5c6f9a06 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -28,6 +28,7 @@
 #define IDR_MASK ((1 << IDR_BITS)-1)
 
 struct idr_layer {
+	int			prefix;	/* the ID prefix of this idr_layer */
 	DECLARE_BITMAP(bitmap, IDR_SIZE); /* A zero bit means "space here" */
 	struct idr_layer __rcu	*ary[1<<IDR_BITS];
 	int			count;	/* When zero, we can release it */

commit 050a6b47d98e2bcea909c1129111e721668aaa2c
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:05:06 2013 -0800

    idr: make idr_layer larger
    
    With recent preloading changes, idr no longer keeps full layer cache per
    each idr instance (used to be ~6.5k per idr on 64bit) and the previous
    patch removed restriction on the bitmap size.  Both now allow us to have
    larger layers.
    
    Increase IDR_BITS to 8 regardless of BITS_PER_LONG.  Each layer is
    slightly larger than 2k on 64bit and 1k on 32bit and carries 256 entries.
    The size isn't too large, especially compared to what we used to waste on
    per-idr caches, and 256 entries should be able to serve most use cases
    with single layer.  The max tree depth is 4 which is much better than the
    previous 6 on 64bit and 7 on 32bit.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 63aa542da49b..43b87b1c77a3 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -17,14 +17,13 @@
 #include <linux/init.h>
 #include <linux/rcupdate.h>
 
-#if BITS_PER_LONG == 32
-# define IDR_BITS 5
-#elif BITS_PER_LONG == 64
-# define IDR_BITS 6
-#else
-# error "BITS_PER_LONG is not 32 or 64"
-#endif
-
+/*
+ * We want shallower trees and thus more bits covered at each layer.  8
+ * bits gives us large enough first layer for most use cases and maximum
+ * tree depth of 4.  Each idr_layer is slightly larger than 2k on 64bit and
+ * 1k on 32bit.
+ */
+#define IDR_BITS 8
 #define IDR_SIZE (1 << IDR_BITS)
 #define IDR_MASK ((1 << IDR_BITS)-1)
 

commit 1d9b2e1e663719d406e3a770979a19ba4233bba0
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:05:05 2013 -0800

    idr: remove length restriction from idr_layer->bitmap
    
    Currently, idr->bitmap is declared as an unsigned long which restricts
    the number of bits an idr_layer can contain.  All bitops can handle
    arbitrary positive integer bit number and there's no reason for this
    restriction.
    
    Declare idr_layer->bitmap using DECLARE_BITMAP() instead of a single
    unsigned long.
    
    * idr_layer->bitmap is now an array.  '&' dropped from params to
      bitops.
    
    * Replaced "== IDR_FULL" tests with bitmap_full() and removed
      IDR_FULL.
    
    * Replaced find_next_bit() on ~bitmap with find_next_zero_bit().
    
    * Replaced "bitmap = 0" with bitmap_clear().
    
    This patch doesn't (or at least shouldn't) introduce any behavior
    changes.
    
    [akpm@linux-foundation.org: checkpatch fixes]
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 99b0ce533f0e..63aa542da49b 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -19,18 +19,8 @@
 
 #if BITS_PER_LONG == 32
 # define IDR_BITS 5
-# define IDR_FULL 0xfffffffful
-/* We can only use two of the bits in the top level because there is
-   only one possible bit in the top level (5 bits * 7 levels = 35
-   bits, but you only use 31 bits in the id). */
-# define TOP_LEVEL_FULL (IDR_FULL >> 30)
 #elif BITS_PER_LONG == 64
 # define IDR_BITS 6
-# define IDR_FULL 0xfffffffffffffffful
-/* We can only use two of the bits in the top level because there is
-   only one possible bit in the top level (6 bits * 6 levels = 36
-   bits, but you only use 31 bits in the id). */
-# define TOP_LEVEL_FULL (IDR_FULL >> 62)
 #else
 # error "BITS_PER_LONG is not 32 or 64"
 #endif
@@ -39,7 +29,7 @@
 #define IDR_MASK ((1 << IDR_BITS)-1)
 
 struct idr_layer {
-	unsigned long		bitmap;	/* A zero bit means "space here" */
+	DECLARE_BITMAP(bitmap, IDR_SIZE); /* A zero bit means "space here" */
 	struct idr_layer __rcu	*ary[1<<IDR_BITS];
 	int			count;	/* When zero, we can release it */
 	int			layer;	/* distance from leaf */

commit e8c8d1bc063bc88cfa1356266027b5075d3a82d7
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:05:04 2013 -0800

    idr: remove MAX_IDR_MASK and move left MAX_IDR_* into idr.c
    
    MAX_IDR_MASK is another weirdness in the idr interface.  As idr covers
    whole positive integer range, it's defined as 0x7fffffff or INT_MAX.
    
    Its usage in idr_find(), idr_replace() and idr_remove() is bizarre.
    They basically mask off the sign bit and operate on the rest, so if
    the caller, by accident, passes in a negative number, the sign bit
    will be masked off and the remaining part will be used as if that was
    the input, which is worse than crashing.
    
    The constant is visible in idr.h and there are several users in the
    kernel.
    
    * drivers/i2c/i2c-core.c:i2c_add_numbered_adapter()
    
      Basically used to test if adap->nr is a negative number which isn't
      -1 and returns -EINVAL if so.  idr_alloc() already has negative
      @start checking (w/ WARN_ON_ONCE), so this can go away.
    
    * drivers/infiniband/core/cm.c:cm_alloc_id()
      drivers/infiniband/hw/mlx4/cm.c:id_map_alloc()
    
      Used to wrap cyclic @start.  Can be replaced with max(next, 0).
      Note that this type of cyclic allocation using idr is buggy.  These
      are prone to spurious -ENOSPC failure after the first wraparound.
    
    * fs/super.c:get_anon_bdev()
    
      The ID allocated from ida is masked off before being tested whether
      it's inside valid range.  ida allocated ID can never be a negative
      number and the masking is unnecessary.
    
    Update idr_*() functions to fail with -EINVAL when negative @id is
    specified and update other MAX_IDR_MASK users as described above.
    
    This leaves MAX_IDR_MASK without any user, remove it and relocate
    other MAX_IDR_* constants to lib/idr.c.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Roland Dreier <roland@kernel.org>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: "Marciniszyn, Mike" <mike.marciniszyn@intel.com>
    Cc: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Cc: Or Gerlitz <ogerlitz@mellanox.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Wolfram Sang <wolfram@the-dreams.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 6dcf133f208a..99b0ce533f0e 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -38,16 +38,6 @@
 #define IDR_SIZE (1 << IDR_BITS)
 #define IDR_MASK ((1 << IDR_BITS)-1)
 
-#define MAX_IDR_SHIFT (sizeof(int)*8 - 1)
-#define MAX_IDR_BIT (1U << MAX_IDR_SHIFT)
-#define MAX_IDR_MASK (MAX_IDR_BIT - 1)
-
-/* Leave the possibility of an incomplete final layer */
-#define MAX_IDR_LEVEL ((MAX_IDR_SHIFT + IDR_BITS - 1) / IDR_BITS)
-
-/* Number of id_layer structs to leave in free list */
-#define MAX_IDR_FREE (MAX_IDR_LEVEL * 2)
-
 struct idr_layer {
 	unsigned long		bitmap;	/* A zero bit means "space here" */
 	struct idr_layer __rcu	*ary[1<<IDR_BITS];

commit d5c7409f79e14db49d00785692334657592c07ff
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:55 2013 -0800

    idr: implement idr_preload[_end]() and idr_alloc()
    
    The current idr interface is very cumbersome.
    
    * For all allocations, two function calls - idr_pre_get() and
      idr_get_new*() - should be made.
    
    * idr_pre_get() doesn't guarantee that the following idr_get_new*()
      will not fail from memory shortage.  If idr_get_new*() returns
      -EAGAIN, the caller is expected to retry pre_get and allocation.
    
    * idr_get_new*() can't enforce upper limit.  Upper limit can only be
      enforced by allocating and then freeing if above limit.
    
    * idr_layer buffer is unnecessarily per-idr.  Each idr ends up keeping
      around MAX_IDR_FREE idr_layers.  The memory consumed per idr is
      under two pages but it makes it difficult to make idr_layer larger.
    
    This patch implements the following new set of allocation functions.
    
    * idr_preload[_end]() - Similar to radix preload but doesn't fail.
      The first idr_alloc() inside preload section can be treated as if it
      were called with @gfp_mask used for idr_preload().
    
    * idr_alloc() - Allocate an ID w/ lower and upper limits.  Takes
      @gfp_flags and can be used w/o preloading.  When used inside
      preloaded section, the allocation mask of preloading can be assumed.
    
    If idr_alloc() can be called from a context which allows sufficiently
    relaxed @gfp_mask, it can be used by itself.  If, for example,
    idr_alloc() is called inside spinlock protected region, preloading can
    be used like the following.
    
            idr_preload(GFP_KERNEL);
            spin_lock(lock);
    
            id = idr_alloc(idr, ptr, start, end, GFP_NOWAIT);
    
            spin_unlock(lock);
            idr_preload_end();
            if (id < 0)
                    error;
    
    which is much simpler and less error-prone than idr_pre_get and
    idr_get_new*() loop.
    
    The new interface uses per-pcu idr_layer buffer and thus the number of
    idr's in the system doesn't affect the amount of memory used for
    preloading.
    
    idr_layer_alloc() is introduced to handle idr_layer allocations for
    both old and new ID allocation paths.  This is a bit hairy now but the
    new interface is expected to replace the old and the internal
    implementation eventually will become simpler.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 837f152b1383..6dcf133f208a 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -94,14 +94,28 @@ struct idr {
 void *idr_find(struct idr *idp, int id);
 int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
+void idr_preload(gfp_t gfp_mask);
+int idr_alloc(struct idr *idp, void *ptr, int start, int end, gfp_t gfp_mask);
 int idr_for_each(struct idr *idp,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_get_next(struct idr *idp, int *nextid);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
+void idr_free(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 
+/**
+ * idr_preload_end - end preload section started with idr_preload()
+ *
+ * Each idr_preload() should be matched with an invocation of this
+ * function.  See idr_preload() for details.
+ */
+static inline void idr_preload_end(void)
+{
+	preempt_enable();
+}
+
 /**
  * idr_get_new - allocate new idr entry
  * @idp: idr handle

commit 12d1b4393e0d8df36b2646a5e512f0513fb532d2
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:53 2013 -0800

    idr: remove _idr_rc_to_errno() hack
    
    idr uses -1, IDR_NEED_TO_GROW and IDR_NOMORE_SPACE to communicate
    exception conditions internally.  The return value is later translated
    to errno values using _idr_rc_to_errno().
    
    This is confusing.  Drop the custom ones and consistently use -EAGAIN
    for "tree needs to grow", -ENOMEM for "need more memory" and -ENOSPC for
    "ran out of ID space".
    
    Due to the weird memory preloading mechanism, [ra]_get_new*() return
    -EAGAIN on memory shortage, so we need to substitute -ENOMEM w/
    -EAGAIN on those interface functions.  They'll eventually be cleaned
    up and the translations will go away.
    
    This patch doesn't introduce any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index ff44bc83f3cb..837f152b1383 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -70,12 +70,6 @@ struct idr {
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 
-/* Actions to be taken after a call to _idr_sub_alloc */
-#define IDR_NEED_TO_GROW -2
-#define IDR_NOMORE_SPACE -3
-
-#define _idr_rc_to_errno(rc) ((rc) == -1 ? -EAGAIN : -ENOSPC)
-
 /**
  * DOC: idr sync
  * idr synchronization (stolen from radix-tree.h)

commit 49038ef4fbe2842bd4d8338f89ec5c9ba71b0ae1
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:52 2013 -0800

    idr: relocate idr_for_each_entry() and reorganize id[r|a]_get_new()
    
    * Move idr_for_each_entry() definition next to other idr related
      definitions.
    
    * Make id[r|a]_get_new() inline wrappers of id[r|a]_get_new_above().
    
    This changes the implementation of idr_get_new() but the new
    implementation is trivial.  This patch doesn't introduce any
    functional change.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 8f4980db3524..ff44bc83f3cb 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -99,7 +99,6 @@ struct idr {
 
 void *idr_find(struct idr *idp, int id);
 int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
-int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 int idr_for_each(struct idr *idp,
 		 int (*fn)(int id, void *p, void *data), void *data);
@@ -109,6 +108,30 @@ void idr_remove(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 
+/**
+ * idr_get_new - allocate new idr entry
+ * @idp: idr handle
+ * @ptr: pointer you want associated with the id
+ * @id: pointer to the allocated handle
+ *
+ * Simple wrapper around idr_get_new_above() w/ @starting_id of zero.
+ */
+static inline int idr_get_new(struct idr *idp, void *ptr, int *id)
+{
+	return idr_get_new_above(idp, ptr, 0, id);
+}
+
+/**
+ * idr_for_each_entry - iterate over an idr's elements of a given type
+ * @idp:     idr handle
+ * @entry:   the type * to use as cursor
+ * @id:      id entry's key
+ */
+#define idr_for_each_entry(idp, entry, id)				\
+	for (id = 0, entry = (typeof(entry))idr_get_next((idp), &(id)); \
+	     entry != NULL;                                             \
+	     ++id, entry = (typeof(entry))idr_get_next((idp), &(id)))
+
 void __idr_remove_all(struct idr *idp);	/* don't use */
 
 /**
@@ -149,7 +172,6 @@ struct ida {
 
 int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
 int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
-int ida_get_new(struct ida *ida, int *p_id);
 void ida_remove(struct ida *ida, int id);
 void ida_destroy(struct ida *ida);
 void ida_init(struct ida *ida);
@@ -158,17 +180,18 @@ int ida_simple_get(struct ida *ida, unsigned int start, unsigned int end,
 		   gfp_t gfp_mask);
 void ida_simple_remove(struct ida *ida, unsigned int id);
 
-void __init idr_init_cache(void);
-
 /**
- * idr_for_each_entry - iterate over an idr's elements of a given type
- * @idp:     idr handle
- * @entry:   the type * to use as cursor
- * @id:      id entry's key
+ * ida_get_new - allocate new ID
+ * @ida:	idr handle
+ * @p_id:	pointer to the allocated handle
+ *
+ * Simple wrapper around ida_get_new_above() w/ @starting_id of zero.
  */
-#define idr_for_each_entry(idp, entry, id)				\
-	for (id = 0, entry = (typeof(entry))idr_get_next((idp), &(id)); \
-	     entry != NULL;                                             \
-	     ++id, entry = (typeof(entry))idr_get_next((idp), &(id)))
+static inline int ida_get_new(struct ida *ida, int *p_id)
+{
+	return ida_get_new_above(ida, 0, p_id);
+}
+
+void __init idr_init_cache(void);
 
 #endif /* __IDR_H__ */

commit 4106ecaf59b79efff3f9b466baf9e8c67e19ac5a
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:51 2013 -0800

    idr: cosmetic updates to struct / initializer definitions
    
    * Tab align fields like a normal person.
    
    * Drop the unnecessary 0 inits from IDR_INIT().
    
    This patch is purely cosmetic.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 4cf042da3892..8f4980db3524 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -49,28 +49,24 @@
 #define MAX_IDR_FREE (MAX_IDR_LEVEL * 2)
 
 struct idr_layer {
-	unsigned long		 bitmap; /* A zero bit means "space here" */
+	unsigned long		bitmap;	/* A zero bit means "space here" */
 	struct idr_layer __rcu	*ary[1<<IDR_BITS];
-	int			 count;	 /* When zero, we can release it */
-	int			 layer;	 /* distance from leaf */
-	struct rcu_head		 rcu_head;
+	int			count;	/* When zero, we can release it */
+	int			layer;	/* distance from leaf */
+	struct rcu_head		rcu_head;
 };
 
 struct idr {
-	struct idr_layer __rcu *top;
-	struct idr_layer *id_free;
-	int		  layers; /* only valid without concurrent changes */
-	int		  id_free_cnt;
-	spinlock_t	  lock;
+	struct idr_layer __rcu	*top;
+	struct idr_layer	*id_free;
+	int			layers;	/* only valid w/o concurrent changes */
+	int			id_free_cnt;
+	spinlock_t		lock;
 };
 
-#define IDR_INIT(name)						\
-{								\
-	.top		= NULL,					\
-	.id_free	= NULL,					\
-	.layers 	= 0,					\
-	.id_free_cnt	= 0,					\
-	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),	\
+#define IDR_INIT(name)							\
+{									\
+	.lock			= __SPIN_LOCK_UNLOCKED(name.lock),	\
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 

commit fe6e24ec90b753392c3f9ec1fbca196c4e88e511
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:50 2013 -0800

    idr: deprecate idr_remove_all()
    
    There was only one legitimate use of idr_remove_all() and a lot more of
    incorrect uses (or lack of it).  Now that idr_destroy() implies
    idr_remove_all() and all the in-kernel users updated not to use it,
    there's no reason to keep it around.  Mark it deprecated so that we can
    later unexport it.
    
    idr_remove_all() is made an inline function calling __idr_remove_all()
    to avoid triggering deprecated warning on EXPORT_SYMBOL().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index e5eb125effe6..4cf042da3892 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -110,10 +110,22 @@ int idr_for_each(struct idr *idp,
 void *idr_get_next(struct idr *idp, int *nextid);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
-void idr_remove_all(struct idr *idp);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 
+void __idr_remove_all(struct idr *idp);	/* don't use */
+
+/**
+ * idr_remove_all - remove all ids from the given idr tree
+ * @idp: idr handle
+ *
+ * If you're trying to destroy @idp, calling idr_destroy() is enough.
+ * This is going away.  Don't use.
+ */
+static inline void __deprecated idr_remove_all(struct idr *idp)
+{
+	__idr_remove_all(idp);
+}
 
 /*
  * IDA - IDR based id allocator, use when translation from id to

commit eece09ec213e93333010bf4c6bb9175b32229c54
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 17 21:25:03 2011 +0200

    locking: Various static lock initializer fixes
    
    The static lock initializers want to be fed the proper name of the
    lock and not some random string. In mainline random strings are
    obfuscating the readability of debug output, but for RT they prevent
    the spinlock substitution. Fix it up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index de7e190f1af4..e5eb125effe6 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -136,7 +136,7 @@ struct ida {
 	struct ida_bitmap	*free_bitmap;
 };
 
-#define IDA_INIT(name)		{ .idr = IDR_INIT(name), .free_bitmap = NULL, }
+#define IDA_INIT(name)		{ .idr = IDR_INIT((name).idr), .free_bitmap = NULL, }
 #define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
 
 int ida_pre_get(struct ida *ida, gfp_t gfp_mask);

commit 986836503e49ccf7e84b813715d344964ec93566
Merge: ccae7868b0c5 328e0f125bf4
Author: Philipp Reisner <philipp.reisner@linbit.com>
Date:   Fri Nov 9 14:18:43 2012 +0100

    Merge branch 'drbd-8.4_ed6' into for-3.8-drivers-drbd-8.4_ed6

commit 125c4c706b680c7831f0966ff873c1ad0354ec25
Author: Fengguang Wu <fengguang.wu@intel.com>
Date:   Thu Oct 4 17:13:15 2012 -0700

    idr: rename MAX_LEVEL to MAX_IDR_LEVEL
    
    To avoid name conflicts:
    
      drivers/video/riva/fbdev.c:281:9: sparse: preprocessor token MAX_LEVEL redefined
    
    While at it, also make the other names more consistent and add
    parentheses.
    
    [akpm@linux-foundation.org: repair fallout]
    [sfr@canb.auug.org.au: IB/mlx4: fix for MAX_ID_MASK to MAX_IDR_MASK name change]
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Bernd Petrovitsch <bernd@petrovitsch.priv.at>
    Cc: walter harms <wharms@bfs.de>
    Cc: Glauber Costa <glommer@parallels.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Roland Dreier <roland@purestorage.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 255491cf522e..87259a44c251 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -38,15 +38,15 @@
 #define IDR_SIZE (1 << IDR_BITS)
 #define IDR_MASK ((1 << IDR_BITS)-1)
 
-#define MAX_ID_SHIFT (sizeof(int)*8 - 1)
-#define MAX_ID_BIT (1U << MAX_ID_SHIFT)
-#define MAX_ID_MASK (MAX_ID_BIT - 1)
+#define MAX_IDR_SHIFT (sizeof(int)*8 - 1)
+#define MAX_IDR_BIT (1U << MAX_IDR_SHIFT)
+#define MAX_IDR_MASK (MAX_IDR_BIT - 1)
 
 /* Leave the possibility of an incomplete final layer */
-#define MAX_LEVEL (MAX_ID_SHIFT + IDR_BITS - 1) / IDR_BITS
+#define MAX_IDR_LEVEL ((MAX_IDR_SHIFT + IDR_BITS - 1) / IDR_BITS)
 
 /* Number of id_layer structs to leave in free list */
-#define IDR_FREE_MAX MAX_LEVEL + MAX_LEVEL
+#define MAX_IDR_FREE (MAX_IDR_LEVEL * 2)
 
 struct idr_layer {
 	unsigned long		 bitmap; /* A zero bit means "space here" */

commit 9749f30f1a387070e6e8351f35aeb829eacc3ab6
Author: Philipp Reisner <philipp.reisner@linbit.com>
Date:   Wed Jul 20 14:59:37 2011 +0200

    idr: idr_for_each_entry() macro
    
    Inspired by the list_for_each_entry() macro

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 255491cf522e..52a9da295296 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -152,4 +152,15 @@ void ida_simple_remove(struct ida *ida, unsigned int id);
 
 void __init idr_init_cache(void);
 
+/**
+ * idr_for_each_entry - iterate over an idr's elements of a given type
+ * @idp:     idr handle
+ * @entry:   the type * to use as cursor
+ * @id:      id entry's key
+ */
+#define idr_for_each_entry(idp, entry, id)				\
+	for (id = 0, entry = (typeof(entry))idr_get_next((idp), &(id)); \
+	     entry != NULL;                                             \
+	     ++id, entry = (typeof(entry))idr_get_next((idp), &(id)))
+
 #endif /* __IDR_H__ */

commit 88eca0207cf1574328c3ce8c3be537a9317261bb
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Aug 3 16:21:06 2011 -0700

    ida: simplified functions for id allocation
    
    The current hyper-optimized functions are overkill if you simply want to
    allocate an id for a device.  Create versions which use an internal
    lock.
    
    In followup patches, numerous drivers are converted to use this
    interface.
    
    Thanks to Tejun for feedback.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 13a801f3d028..255491cf522e 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -146,6 +146,10 @@ void ida_remove(struct ida *ida, int id);
 void ida_destroy(struct ida *ida);
 void ida_init(struct ida *ida);
 
+int ida_simple_get(struct ida *ida, unsigned int start, unsigned int end,
+		   gfp_t gfp_mask);
+void ida_simple_remove(struct ida *ida, unsigned int id);
+
 void __init idr_init_cache(void);
 
 #endif /* __IDR_H__ */

commit 56083ab17e0075e538270823c374b59cc97e73b9
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Oct 26 14:19:08 2010 -0700

    docbook: add idr/ida to kernel-api docbook
    
    Add idr/ida to kernel-api docbook.
    Fix typos and kernel-doc notation.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Cc: Naohiro Aota <naota@elisp.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 928ae712709f..13a801f3d028 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -81,6 +81,7 @@ struct idr {
 #define _idr_rc_to_errno(rc) ((rc) == -1 ? -EAGAIN : -ENOSPC)
 
 /**
+ * DOC: idr sync
  * idr synchronization (stolen from radix-tree.h)
  *
  * idr_find() is able to be called locklessly, using RCU. The caller must

commit 229aebb873e29726b91e076161649cf45154b0bf
Merge: 8de547e18244 50a23e6eec6f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 24 13:41:39 2010 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      Update broken web addresses in arch directory.
      Update broken web addresses in the kernel.
      Revert "drivers/usb: Remove unnecessary return's from void functions" for musb gadget
      Revert "Fix typo: configuation => configuration" partially
      ida: document IDA_BITMAP_LONGS calculation
      ext2: fix a typo on comment in ext2/inode.c
      drivers/scsi: Remove unnecessary casts of private_data
      drivers/s390: Remove unnecessary casts of private_data
      net/sunrpc/rpc_pipe.c: Remove unnecessary casts of private_data
      drivers/infiniband: Remove unnecessary casts of private_data
      drivers/gpu/drm: Remove unnecessary casts of private_data
      kernel/pm_qos_params.c: Remove unnecessary casts of private_data
      fs/ecryptfs: Remove unnecessary casts of private_data
      fs/seq_file.c: Remove unnecessary casts of private_data
      arm: uengine.c: remove C99 comments
      arm: scoop.c: remove C99 comments
      Fix typo configue => configure in comments
      Fix typo: configuation => configuration
      Fix typo interrest[ing|ed] => interest[ing|ed]
      Fix various typos of valid in comments
      ...
    
    Fix up trivial conflicts in:
            drivers/char/ipmi/ipmi_si_intf.c
            drivers/usb/gadget/rndis.c
            net/irda/irnet/irnet_ppp.c

commit ed9f524ac79457f0c547c85746b19b92526be612
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Thu Sep 16 01:30:19 2010 +0900

    ida: document IDA_BITMAP_LONGS calculation
    
    IDA_BITMAP_LONGS value is calculated take into account struct ida_bitmap
    not to waste memory space. Comment it.
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index e968db71e33a..88607523e2df 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -117,10 +117,13 @@ void idr_init(struct idr *idp);
 /*
  * IDA - IDR based id allocator, use when translation from id to
  * pointer isn't necessary.
+ *
+ * IDA_BITMAP_LONGS is calculated to be one less to accommodate
+ * ida_bitmap->nr_busy so that the whole struct fits in 128 bytes.
  */
 #define IDA_CHUNK_SIZE		128	/* 128 bytes per chunk */
-#define IDA_BITMAP_LONGS	(128 / sizeof(long) - 1)
-#define IDA_BITMAP_BITS		(IDA_BITMAP_LONGS * sizeof(long) * 8)
+#define IDA_BITMAP_LONGS	(IDA_CHUNK_SIZE / sizeof(long) - 1)
+#define IDA_BITMAP_BITS 	(IDA_BITMAP_LONGS * sizeof(long) * 8)
 
 struct ida_bitmap {
 	long			nr_busy;

commit d2c2486bc8e185548490e8edbc84d185de9eaff1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 26 14:53:26 2010 +0100

    idr: __rcu annotations
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index e968db71e33a..cdb715e58e3e 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -50,14 +50,14 @@
 
 struct idr_layer {
 	unsigned long		 bitmap; /* A zero bit means "space here" */
-	struct idr_layer	*ary[1<<IDR_BITS];
+	struct idr_layer __rcu	*ary[1<<IDR_BITS];
 	int			 count;	 /* When zero, we can release it */
 	int			 layer;	 /* distance from leaf */
 	struct rcu_head		 rcu_head;
 };
 
 struct idr {
-	struct idr_layer *top;
+	struct idr_layer __rcu *top;
 	struct idr_layer *id_free;
 	int		  layers; /* only valid without concurrent changes */
 	int		  id_free_cnt;

commit 38460b48d06440de46b34cb778bd6c4855030754
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Thu Apr 2 16:57:25 2009 -0700

    cgroup: CSS ID support
    
    Patch for Per-CSS(Cgroup Subsys State) ID and private hierarchy code.
    
    This patch attaches unique ID to each css and provides following.
    
     - css_lookup(subsys, id)
       returns pointer to struct cgroup_subysys_state of id.
     - css_get_next(subsys, id, rootid, depth, foundid)
       returns the next css under "root" by scanning
    
    When cgroup_subsys->use_id is set, an id for css is maintained.
    
    The cgroup framework only parepares
            - css_id of root css for subsys
            - id is automatically attached at creation of css.
            - id is *not* freed automatically. Because the cgroup framework
              don't know lifetime of cgroup_subsys_state.
              free_css_id() function is provided. This must be called by subsys.
    
    There are several reasons to develop this.
            - Saving space .... For example, memcg's swap_cgroup is array of
              pointers to cgroup. But it is not necessary to be very fast.
              By replacing pointers(8bytes per ent) to ID (2byes per ent), we can
              reduce much amount of memory usage.
    
            - Scanning without lock.
              CSS_ID provides "scan id under this ROOT" function. By this, scanning
              css under root can be written without locks.
              ex)
              do {
                    rcu_read_lock();
                    next = cgroup_get_next(subsys, id, root, &found);
                    /* check sanity of next here */
                    css_tryget();
                    rcu_read_unlock();
                    id = found + 1
             } while(...)
    
    Characteristics:
            - Each css has unique ID under subsys.
            - Lifetime of ID is controlled by subsys.
            - css ID contains "ID" and "Depth in hierarchy" and stack of hierarchy
            - Allowed ID is 1-65535, ID 0 is UNUSED ID.
    
    Design Choices:
            - scan-by-ID v.s. scan-by-tree-walk.
              As /proc's pid scan does, scan-by-ID is robust when scanning is done
              by following kind of routine.
              scan -> rest a while(release a lock) -> conitunue from interrupted
              memcg's hierarchical reclaim does this.
    
            - When subsys->use_id is set, # of css in the system is limited to
              65535.
    
    [bharata@linux.vnet.ibm.com: remove rcu_read_lock() from css_get_next()]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Acked-by: Paul Menage <menage@google.com>
    Cc: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Balbir Singh <balbir@in.ibm.com>
    Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
    Signed-off-by: Bharata B Rao <bharata@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index dd846df8cd32..e968db71e33a 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -106,6 +106,7 @@ int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 int idr_for_each(struct idr *idp,
 		 int (*fn)(int id, void *p, void *data), void *data);
+void *idr_get_next(struct idr *idp, int *nextid);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
 void idr_remove_all(struct idr *idp);

commit 6ff2d39b91aec3dcae951afa982059e3dd9b49dc
Author: Manfred Spraul <manfred@colorfullife.com>
Date:   Mon Dec 1 13:14:02 2008 -0800

    lib/idr.c: fix rcu related race with idr_find
    
    2nd part of the fixes needed for
    http://bugzilla.kernel.org/show_bug.cgi?id=11796.
    
    When the idr tree is either grown or shrunk, then the update to the number
    of layers and the top pointer were not atomic.  This race caused crashes.
    
    The attached patch fixes that by replicating the layers counter in each
    layer, thus idr_find doesn't need idp->layers anymore.
    
    Signed-off-by: Manfred Spraul <manfred@colorfullife.com>
    Cc: Clement Calmels <cboulte@gmail.com>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: Pierre Peiffer <peifferp@gmail.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index fa035f96f2a3..dd846df8cd32 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -52,13 +52,14 @@ struct idr_layer {
 	unsigned long		 bitmap; /* A zero bit means "space here" */
 	struct idr_layer	*ary[1<<IDR_BITS];
 	int			 count;	 /* When zero, we can release it */
+	int			 layer;	 /* distance from leaf */
 	struct rcu_head		 rcu_head;
 };
 
 struct idr {
 	struct idr_layer *top;
 	struct idr_layer *id_free;
-	int		  layers;
+	int		  layers; /* only valid without concurrent changes */
 	int		  id_free_cnt;
 	spinlock_t	  lock;
 };

commit f9c46d6ea5ce138a886c3a0f10a46130afab75f5
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Fri Jul 25 01:48:01 2008 -0700

    idr: make idr_find rcu-safe
    
    Make idr_find rcu-safe: it can now be called inside an rcu_read critical
    section.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Reviewed-by: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Jim Houston <jim.houston@comcast.net>
    Cc: Pierre Peiffer <peifferp@gmail.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 762c3f2c631d..fa035f96f2a3 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -79,6 +79,22 @@ struct idr {
 
 #define _idr_rc_to_errno(rc) ((rc) == -1 ? -EAGAIN : -ENOSPC)
 
+/**
+ * idr synchronization (stolen from radix-tree.h)
+ *
+ * idr_find() is able to be called locklessly, using RCU. The caller must
+ * ensure calls to this function are made within rcu_read_lock() regions.
+ * Other readers (lock-free or otherwise) and modifications may be running
+ * concurrently.
+ *
+ * It is still required that the caller manage the synchronization and
+ * lifetimes of the items. So if RCU lock-free lookups are used, typically
+ * this would mean that the items have their own locks, or are amenable to
+ * lock-free access; and that the items are freed by RCU (or only freed after
+ * having been deleted from the idr tree *and* a synchronize_rcu() grace
+ * period).
+ */
+
 /*
  * This is what we export.
  */

commit 944ca05c7b4972f2ebf37262e0f4933d178ad6db
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Fri Jul 25 01:47:59 2008 -0700

    idr: error checking factorization
    
    Do some code factorization in the return code analysis.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Jim Houston <jim.houston@comcast.net>
    Cc: Pierre Peiffer <peifferp@gmail.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 1af61d23be36..762c3f2c631d 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -73,6 +73,12 @@ struct idr {
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 
+/* Actions to be taken after a call to _idr_sub_alloc */
+#define IDR_NEED_TO_GROW -2
+#define IDR_NOMORE_SPACE -3
+
+#define _idr_rc_to_errno(rc) ((rc) == -1 ? -EAGAIN : -ENOSPC)
+
 /*
  * This is what we export.
  */

commit 2027d1abc25ff770cc3bc936abd33570ce85d85a
Author: Nadia Derbey <Nadia.Derbey@bull.net>
Date:   Fri Jul 25 01:47:57 2008 -0700

    idr: change the idr structure
    
    After scalability problems have been detected when using the sysV ipcs, I have
    proposed to use an RCU based implementation of the IDR api instead (see
    threads http://lkml.org/lkml/2008/4/11/212 and
    http://lkml.org/lkml/2008/4/29/295).
    
    This resulted in many people asking to convert the idr API and make it rcu
    safe (because most of the code was duplicated and thus unmaintanable and
    unreviewable).
    
    So here is a first attempt.
    
    The important change wrt to the idr API itself is during idr removes: idr
    layers are freed after a grace period, instead of being moved to the free
    list.
    
    The important change wrt to ipcs, is that idr_find() can now be called
    locklessly inside a rcu read critical section.
    
    Here are the results I've got for the pmsg test sent by Manfred:
    
       2.6.25-rc3-mm1   2.6.25-rc3-mm1+   2.6.25-mm1   Patched 2.6.25-mm1
    1         1168441           1064021       876000               947488
    2         1094264            921059      1549592              1730685
    3         2082520           1738165      1694370              2324880
    4         2079929           1695521       404553              2400408
    5         2898758            406566       391283              3246580
    6         2921417            261275       263249              3752148
    7         3308761            126056       191742              4243142
    8         3329456            100129       141722              4275780
    
    1st column: stock 2.6.25-rc3-mm1
    2nd column: 2.6.25-rc3-mm1 + ipc patches (store ipcs into idrs)
    3nd column: stock 2.6.25-mm1
    4th column: 2.6.25-mm1 + this pacth series.
    
    This patch:
    
    Add an rcu_head to the idr_layer structure in order to free it after a grace
    period.
    
    Signed-off-by: Nadia Derbey <Nadia.Derbey@bull.net>
    Reviewed-by: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Jim Houston <jim.houston@comcast.net>
    Cc: Pierre Peiffer <peifferp@gmail.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 9a2d762124de..1af61d23be36 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -15,6 +15,7 @@
 #include <linux/types.h>
 #include <linux/bitops.h>
 #include <linux/init.h>
+#include <linux/rcupdate.h>
 
 #if BITS_PER_LONG == 32
 # define IDR_BITS 5
@@ -51,6 +52,7 @@ struct idr_layer {
 	unsigned long		 bitmap; /* A zero bit means "space here" */
 	struct idr_layer	*ary[1<<IDR_BITS];
 	int			 count;	 /* When zero, we can release it */
+	struct rcu_head		 rcu_head;
 };
 
 struct idr {

commit 199f0ca514f9c17668eec4f935c4ba24cd789f85
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue Apr 29 01:03:13 2008 -0700

    idr: create idr_layer_cache at boot time
    
    Avoid a possible kmem_cache_create() failure by creating idr_layer_cache
    unconditionary at boot time rather than creating it on-demand when idr_init()
    is called the first time.
    
    This change also enables us to eliminate the check every time idr_init() is
    called.
    
    [akpm@linux-foundation.org: rename init_id_cache() to idr_init_cache()]
    [akpm@linux-foundation.org: fix alpha build]
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 0edda411959c..9a2d762124de 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -14,6 +14,7 @@
 
 #include <linux/types.h>
 #include <linux/bitops.h>
+#include <linux/init.h>
 
 #if BITS_PER_LONG == 32
 # define IDR_BITS 5
@@ -115,4 +116,6 @@ void ida_remove(struct ida *ida, int id);
 void ida_destroy(struct ida *ida);
 void ida_init(struct ida *ida);
 
+void __init idr_init_cache(void);
+
 #endif /* __IDR_H__ */

commit 23936cc0b5d89619c34c2dab11d8cf3d6f7ca028
Author: Kristian Hoegsberg <krh@redhat.com>
Date:   Sun Jul 15 23:37:24 2007 -0700

    lib: add idr_remove_all
    
    Remove all ids from the given idr tree.  idr_destroy() only frees up
    unused, cached idp_layers, but this function will remove all id mappings
    and leave all idp_layers unused.
    
    A typical clean-up sequence for objects stored in an idr tree, will use
    idr_for_each() to free all objects, if necessay, then idr_remove_all() to
    remove all ids, and idr_destroy() to free up the cached idr_layers.
    
    Signed-off-by: Kristian Hoegsberg <krh@redhat.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 8442c0bffc06..0edda411959c 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -82,6 +82,7 @@ int idr_for_each(struct idr *idp,
 		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
+void idr_remove_all(struct idr *idp);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 

commit 96d7fa421e6424ad9ef6d1d039375dc2edb63fe8
Author: Kristian Hoegsberg <krh@redhat.com>
Date:   Sun Jul 15 23:37:24 2007 -0700

    lib: add idr_for_each()
    
    This patch adds an iterator function for the idr data structure.  Compared
    to just iterating through the idr with an integer and idr_find, this
    iterator is (almost, but not quite) linear in the number of elements, as
    opposed to the number of integers in the range covered by the idr.  This
    makes a difference for sparse idrs, but more importantly, it's a nicer way
    to iterate through the elements.
    
    The drm subsystem is moving to idr for tracking contexts and drawables, and
    with this change, we can use the idr exclusively for tracking these
    resources.
    
    [akpm@linux-foundation.org: fix comment]
    Signed-off-by: Kristian Hoegsberg <krh@redhat.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 915572fa030b..8442c0bffc06 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -78,6 +78,8 @@ void *idr_find(struct idr *idp, int id);
 int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
 int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
+int idr_for_each(struct idr *idp,
+		 int (*fn)(int id, void *p, void *data), void *data);
 void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);

commit 72dba584b695d8bc8c1a50ed54ad4cba7c62314d
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:13 2007 +0900

    ida: implement idr based id allocator
    
    Implement idr based id allocator.  ida is used the same way idr is
    used but lacks id -> ptr translation and thus consumes much less
    memory.  struct ida_bitmap is attached as leaf nodes to idr tree which
    is managed by the idr code.  Each ida_bitmap is 128bytes long and
    contains slightly less than a thousand slots.
    
    ida is more aggressive with releasing extra resources acquired using
    ida_pre_get().  After every successful id allocation, ida frees one
    reserved idr_layer if possible.  Reserved ida_bitmap is not freed
    automatically but only one ida_bitmap is reserved and it's almost
    always used right away.  Under most circumstances, ida won't hold on
    to memory for too long which isn't actively used.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 826803449db7..915572fa030b 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -83,4 +83,33 @@ void idr_remove(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
 
+
+/*
+ * IDA - IDR based id allocator, use when translation from id to
+ * pointer isn't necessary.
+ */
+#define IDA_CHUNK_SIZE		128	/* 128 bytes per chunk */
+#define IDA_BITMAP_LONGS	(128 / sizeof(long) - 1)
+#define IDA_BITMAP_BITS		(IDA_BITMAP_LONGS * sizeof(long) * 8)
+
+struct ida_bitmap {
+	long			nr_busy;
+	unsigned long		bitmap[IDA_BITMAP_LONGS];
+};
+
+struct ida {
+	struct idr		idr;
+	struct ida_bitmap	*free_bitmap;
+};
+
+#define IDA_INIT(name)		{ .idr = IDR_INIT(name), .free_bitmap = NULL, }
+#define DEFINE_IDA(name)	struct ida name = IDA_INIT(name)
+
+int ida_pre_get(struct ida *ida, gfp_t gfp_mask);
+int ida_get_new_above(struct ida *ida, int starting_id, int *p_id);
+int ida_get_new(struct ida *ida, int *p_id);
+void ida_remove(struct ida *ida, int id);
+void ida_destroy(struct ida *ida);
+void ida_init(struct ida *ida);
+
 #endif /* __IDR_H__ */

commit e4d919188554a77c798a267e098059bc9aa39726
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:24:34 2006 -0700

    [PATCH] lockdep: locking init debugging improvement
    
    Locking init improvement:
    
     - introduce and use __SPIN_LOCK_UNLOCKED for array initializations,
       to pass in the name string of locks, used by debugging
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index f559a719dbe8..826803449db7 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -66,7 +66,7 @@ struct idr {
 	.id_free	= NULL,					\
 	.layers 	= 0,					\
 	.id_free_cnt	= 0,					\
-	.lock		= SPIN_LOCK_UNLOCKED,			\
+	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),	\
 }
 #define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
 

commit 5806f07cd2c32920d5105e0f9ff3117338f34eec
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Mon Jun 26 00:27:19 2006 -0700

    [PATCH] lib: add idr_replace
    
    This patch adds idr_replace() to replace an existing pointer in a single
    operation.
    
    Device-mapper will use this to update the pointer it stored against a given
    id.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index d37c8d808b0f..f559a719dbe8 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -78,6 +78,7 @@ void *idr_find(struct idr *idp, int id);
 int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
 int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
+void *idr_replace(struct idr *idp, void *ptr, int id);
 void idr_remove(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);

commit f668ab1acc05fc3f525b97db613b2d1f99efd957
Author: Luben Tuikov <luben_tuikov@adaptec.com>
Date:   Tue Nov 8 17:14:08 2005 +0100

    include/linux: enclose idr.h in #ifndef
    
    This patch encloses the idr.h header file in
    #ifndef __IDR_H__ macro.
    
    Signed-off-by: Luben Tuikov <luben_tuikov@adaptec.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 7fb3ff9c7b0e..d37c8d808b0f 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -8,6 +8,10 @@
  * Small id to pointer translation service avoiding fixed sized
  * tables.
  */
+
+#ifndef __IDR_H__
+#define __IDR_H__
+
 #include <linux/types.h>
 #include <linux/bitops.h>
 
@@ -77,3 +81,5 @@ int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 void idr_remove(struct idr *idp, int id);
 void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);
+
+#endif /* __IDR_H__ */

commit fd4f2df24bc23e6b8fc069765b425c7dacf52347
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:18:50 2005 -0400

    [PATCH] gfp_t: lib/*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index 3d5de45f961b..7fb3ff9c7b0e 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -71,7 +71,7 @@ struct idr {
  */
 
 void *idr_find(struct idr *idp, int id);
-int idr_pre_get(struct idr *idp, unsigned gfp_mask);
+int idr_pre_get(struct idr *idp, gfp_t gfp_mask);
 int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 void idr_remove(struct idr *idp, int id);

commit 8d3b35914aa54232b27e6a2b57d84092aadc5e86
Author: Andrew Morton <akpm@osdl.org>
Date:   Sun Oct 23 12:57:18 2005 -0700

    [PATCH] inotify/idr leak fix
    
    Fix a bug which was reported and diagnosed by
    Stefan Jones <stefan.jones@churchillrandoms.co.uk>
    
    IDR trees include a cache of idr_layer objects.  There's no way to destroy
    this cache, so when we discard an overall idr tree we end up leaking some
    memory.
    
    Add and use idr_destroy() for this.  v9fs and infiniband also need to use
    idr_destroy() to avoid leaks.
    
    Or, we make the cache global, like radix_tree_preload().  Which is probably
    better.  Later.
    
    Cc: Eric Van Hensbergen <ericvh@ericvh.myip.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Robert Love <rml@novell.com>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/idr.h b/include/linux/idr.h
index ca3b7e462576..3d5de45f961b 100644
--- a/include/linux/idr.h
+++ b/include/linux/idr.h
@@ -75,4 +75,5 @@ int idr_pre_get(struct idr *idp, unsigned gfp_mask);
 int idr_get_new(struct idr *idp, void *ptr, int *id);
 int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
 void idr_remove(struct idr *idp, int id);
+void idr_destroy(struct idr *idp);
 void idr_init(struct idr *idp);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/idr.h b/include/linux/idr.h
new file mode 100644
index 000000000000..ca3b7e462576
--- /dev/null
+++ b/include/linux/idr.h
@@ -0,0 +1,78 @@
+/*
+ * include/linux/idr.h
+ * 
+ * 2002-10-18  written by Jim Houston jim.houston@ccur.com
+ *	Copyright (C) 2002 by Concurrent Computer Corporation
+ *	Distributed under the GNU GPL license version 2.
+ *
+ * Small id to pointer translation service avoiding fixed sized
+ * tables.
+ */
+#include <linux/types.h>
+#include <linux/bitops.h>
+
+#if BITS_PER_LONG == 32
+# define IDR_BITS 5
+# define IDR_FULL 0xfffffffful
+/* We can only use two of the bits in the top level because there is
+   only one possible bit in the top level (5 bits * 7 levels = 35
+   bits, but you only use 31 bits in the id). */
+# define TOP_LEVEL_FULL (IDR_FULL >> 30)
+#elif BITS_PER_LONG == 64
+# define IDR_BITS 6
+# define IDR_FULL 0xfffffffffffffffful
+/* We can only use two of the bits in the top level because there is
+   only one possible bit in the top level (6 bits * 6 levels = 36
+   bits, but you only use 31 bits in the id). */
+# define TOP_LEVEL_FULL (IDR_FULL >> 62)
+#else
+# error "BITS_PER_LONG is not 32 or 64"
+#endif
+
+#define IDR_SIZE (1 << IDR_BITS)
+#define IDR_MASK ((1 << IDR_BITS)-1)
+
+#define MAX_ID_SHIFT (sizeof(int)*8 - 1)
+#define MAX_ID_BIT (1U << MAX_ID_SHIFT)
+#define MAX_ID_MASK (MAX_ID_BIT - 1)
+
+/* Leave the possibility of an incomplete final layer */
+#define MAX_LEVEL (MAX_ID_SHIFT + IDR_BITS - 1) / IDR_BITS
+
+/* Number of id_layer structs to leave in free list */
+#define IDR_FREE_MAX MAX_LEVEL + MAX_LEVEL
+
+struct idr_layer {
+	unsigned long		 bitmap; /* A zero bit means "space here" */
+	struct idr_layer	*ary[1<<IDR_BITS];
+	int			 count;	 /* When zero, we can release it */
+};
+
+struct idr {
+	struct idr_layer *top;
+	struct idr_layer *id_free;
+	int		  layers;
+	int		  id_free_cnt;
+	spinlock_t	  lock;
+};
+
+#define IDR_INIT(name)						\
+{								\
+	.top		= NULL,					\
+	.id_free	= NULL,					\
+	.layers 	= 0,					\
+	.id_free_cnt	= 0,					\
+	.lock		= SPIN_LOCK_UNLOCKED,			\
+}
+#define DEFINE_IDR(name)	struct idr name = IDR_INIT(name)
+
+/*
+ * This is what we export.
+ */
+
+void *idr_find(struct idr *idp, int id);
+int idr_pre_get(struct idr *idp, unsigned gfp_mask);
+int idr_get_new(struct idr *idp, void *ptr, int *id);
+int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
+void idr_remove(struct idr *idp, int id);
+void idr_init(struct idr *idp);
