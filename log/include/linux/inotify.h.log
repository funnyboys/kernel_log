commit 4d97f7d53da7dc830dbf416a3d2a6778d267ae68
Author: Henry Wilson <henry.wilson@acentic.com>
Date:   Thu May 31 09:43:03 2018 +0000

    inotify: Add flag IN_MASK_CREATE for inotify_add_watch()
    
    The flag IN_MASK_CREATE is introduced as a flag for inotiy_add_watch()
    which prevents inotify from modifying any existing watches when invoked.
    If the pathname specified in the call has a watched inode associated
    with it and IN_MASK_CREATE is specified, fail with an errno of EEXIST.
    
    Use of IN_MASK_CREATE with IN_MASK_ADD is reserved for future use and
    will return EINVAL.
    
    RATIONALE
    
    In the current implementation, there is no way to prevent
    inotify_add_watch() from modifying existing watch descriptors. Even if
    the caller keeps a record of all watch descriptors collected, this is
    only sufficient to detect that an existing watch descriptor may have
    been modified.
    
    The assumption that a particular path will map to the same inode over
    multiple calls to inotify_add_watch() cannot be made as files can be
    renamed or deleted.  It is also not possible to assume that two distinct
    paths do no map to the same inode, due to hard-links or a dereferenced
    symbolic link. Further uses of inotify_add_watch() to revert the change
    may cause other watch descriptors to be modified or created, merely
    compunding the problem. There is currently no system call such as
    inotify_modify_watch() to explicity modify a watch descriptor, which
    would be able to revert unwanted changes. Thus the caller cannot
    guarantee to be able to revert any changes to existing watch decriptors.
    
    Additionally the caller cannot assume that the events that are
    associated with a watch descriptor are within the set requested, as any
    future calls to inotify_add_watch() may unintentionally modify a watch
    descriptor's mask. Thus it cannot currently be guaranteed that a watch
    descriptor will only generate events which have been requested. The
    program must filter events which come through its watch descriptor to
    within its expected range.
    
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Henry Wilson <henry.wilson@acentic.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 44f9ffe72c87..6a24905f6e1e 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -18,6 +18,6 @@ extern struct ctl_table inotify_table[]; /* for sysctl */
 			  IN_DELETE_SELF | IN_MOVE_SELF | IN_UNMOUNT | \
 			  IN_Q_OVERFLOW | IN_IGNORED | IN_ONLYDIR | \
 			  IN_DONT_FOLLOW | IN_EXCL_UNLINK | IN_MASK_ADD | \
-			  IN_ISDIR | IN_ONESHOT)
+			  IN_MASK_CREATE | IN_ISDIR | IN_ONESHOT)
 
 #endif	/* _LINUX_INOTIFY_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 23aede0b5843..44f9ffe72c87 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Inode based directory notification for Linux
  *

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index d33041e2a42a..23aede0b5843 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -3,75 +3,12 @@
  *
  * Copyright (C) 2005 John McCutchan
  */
-
 #ifndef _LINUX_INOTIFY_H
 #define _LINUX_INOTIFY_H
 
-/* For O_CLOEXEC and O_NONBLOCK */
-#include <linux/fcntl.h>
-#include <linux/types.h>
-
-/*
- * struct inotify_event - structure read from the inotify device for each event
- *
- * When you are watching a directory, you will receive the filename for events
- * such as IN_CREATE, IN_DELETE, IN_OPEN, IN_CLOSE, ..., relative to the wd.
- */
-struct inotify_event {
-	__s32		wd;		/* watch descriptor */
-	__u32		mask;		/* watch mask */
-	__u32		cookie;		/* cookie to synchronize two events */
-	__u32		len;		/* length (including nulls) of name */
-	char		name[0];	/* stub for possible name */
-};
-
-/* the following are legal, implemented events that user-space can watch for */
-#define IN_ACCESS		0x00000001	/* File was accessed */
-#define IN_MODIFY		0x00000002	/* File was modified */
-#define IN_ATTRIB		0x00000004	/* Metadata changed */
-#define IN_CLOSE_WRITE		0x00000008	/* Writtable file was closed */
-#define IN_CLOSE_NOWRITE	0x00000010	/* Unwrittable file closed */
-#define IN_OPEN			0x00000020	/* File was opened */
-#define IN_MOVED_FROM		0x00000040	/* File was moved from X */
-#define IN_MOVED_TO		0x00000080	/* File was moved to Y */
-#define IN_CREATE		0x00000100	/* Subfile was created */
-#define IN_DELETE		0x00000200	/* Subfile was deleted */
-#define IN_DELETE_SELF		0x00000400	/* Self was deleted */
-#define IN_MOVE_SELF		0x00000800	/* Self was moved */
-
-/* the following are legal events.  they are sent as needed to any watch */
-#define IN_UNMOUNT		0x00002000	/* Backing fs was unmounted */
-#define IN_Q_OVERFLOW		0x00004000	/* Event queued overflowed */
-#define IN_IGNORED		0x00008000	/* File was ignored */
-
-/* helper events */
-#define IN_CLOSE		(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* close */
-#define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
-
-/* special flags */
-#define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
-#define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
-#define IN_EXCL_UNLINK		0x04000000	/* exclude events on unlinked objects */
-#define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
-#define IN_ISDIR		0x40000000	/* event occurred against dir */
-#define IN_ONESHOT		0x80000000	/* only send event once */
-
-/*
- * All of the events - we build the list by hand so that we can add flags in
- * the future and not break backward compatibility.  Apps will get only the
- * events that they originally wanted.  Be sure to add new events here!
- */
-#define IN_ALL_EVENTS	(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
-			 IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
-			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
-			 IN_MOVE_SELF)
-
-/* Flags for sys_inotify_init1.  */
-#define IN_CLOEXEC O_CLOEXEC
-#define IN_NONBLOCK O_NONBLOCK
-
-#ifdef __KERNEL__
 #include <linux/sysctl.h>
+#include <uapi/linux/inotify.h>
+
 extern struct ctl_table inotify_table[]; /* for sysctl */
 
 #define ALL_INOTIFY_BITS (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
@@ -82,6 +19,4 @@ extern struct ctl_table inotify_table[]; /* for sysctl */
 			  IN_DONT_FOLLOW | IN_EXCL_UNLINK | IN_MASK_ADD | \
 			  IN_ISDIR | IN_ONESHOT)
 
-#endif
-
 #endif	/* _LINUX_INOTIFY_H */

commit f874e1ac21d7708464dc656a10312542c54719f1
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Jul 28 10:18:37 2010 -0400

    inotify: force inotify and fsnotify use same bits
    
    inotify uses bits called IN_* and fsnotify uses bits called FS_*.  These
    need to line up.  This patch adds build time checks to make sure noone can
    change these bits so they are not the same.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index b74f2ef2c368..d33041e2a42a 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -73,6 +73,15 @@ struct inotify_event {
 #ifdef __KERNEL__
 #include <linux/sysctl.h>
 extern struct ctl_table inotify_table[]; /* for sysctl */
+
+#define ALL_INOTIFY_BITS (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
+			  IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
+			  IN_MOVED_TO | IN_CREATE | IN_DELETE | \
+			  IN_DELETE_SELF | IN_MOVE_SELF | IN_UNMOUNT | \
+			  IN_Q_OVERFLOW | IN_IGNORED | IN_ONLYDIR | \
+			  IN_DONT_FOLLOW | IN_EXCL_UNLINK | IN_MASK_ADD | \
+			  IN_ISDIR | IN_ONESHOT)
+
 #endif
 
 #endif	/* _LINUX_INOTIFY_H */

commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
Author: Eric Paris <eparis@redhat.com>
Date:   Wed Jul 28 10:18:37 2010 -0400

    inotify: allow users to request not to recieve events on unlinked children
    
    An inotify watch on a directory will send events for children even if those
    children have been unlinked.  This patch add a new inotify flag IN_EXCL_UNLINK
    which allows a watch to specificy they don't care about unlinked children.
    This should fix performance problems seen by tasks which add a watch to
    /tmp and then are overrun with events when other processes are reading and
    writing to unlinked files they created in /tmp.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=16296
    
    Requested-by: Matthias Clasen <mclasen@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 94d209a1b689..b74f2ef2c368 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -51,6 +51,7 @@ struct inotify_event {
 /* special flags */
 #define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
 #define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
+#define IN_EXCL_UNLINK		0x04000000	/* exclude events on unlinked objects */
 #define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
 #define IN_ISDIR		0x40000000	/* event occurred against dir */
 #define IN_ONESHOT		0x80000000	/* only send event once */

commit d14f1729483fad3a8817fbbcbd017678b7d1ad26
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Thu Feb 25 20:28:57 2010 -0500

    sysctl extern cleanup: inotify
    
    Extern declarations in sysctl.c should be move to their own head file, and
    then include them in relavant .c files.
    
    Move inotify_table extern declaration to linux/inotify.h
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 959a38b8f75d..94d209a1b689 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -69,4 +69,9 @@ struct inotify_event {
 #define IN_CLOEXEC O_CLOEXEC
 #define IN_NONBLOCK O_NONBLOCK
 
+#ifdef __KERNEL__
+#include <linux/sysctl.h>
+extern struct ctl_table inotify_table[]; /* for sysctl */
+#endif
+
 #endif	/* _LINUX_INOTIFY_H */

commit 2dfc1cae4c42b93b831b2417540df2b895ab7108
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 20:30:52 2009 -0500

    inotify: remove inotify in kernel interface
    
    nothing uses inotify in the kernel, drop it!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 37ea2894b3c0..959a38b8f75d 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -69,178 +69,4 @@ struct inotify_event {
 #define IN_CLOEXEC O_CLOEXEC
 #define IN_NONBLOCK O_NONBLOCK
 
-#ifdef __KERNEL__
-
-#include <linux/dcache.h>
-#include <linux/fs.h>
-
-/*
- * struct inotify_watch - represents a watch request on a specific inode
- *
- * h_list is protected by ih->mutex of the associated inotify_handle.
- * i_list, mask are protected by inode->inotify_mutex of the associated inode.
- * ih, inode, and wd are never written to once the watch is created.
- *
- * Callers must use the established inotify interfaces to access inotify_watch
- * contents.  The content of this structure is private to the inotify
- * implementation.
- */
-struct inotify_watch {
-	struct list_head	h_list;	/* entry in inotify_handle's list */
-	struct list_head	i_list;	/* entry in inode's list */
-	atomic_t		count;	/* reference count */
-	struct inotify_handle	*ih;	/* associated inotify handle */
-	struct inode		*inode;	/* associated inode */
-	__s32			wd;	/* watch descriptor */
-	__u32			mask;	/* event mask for this watch */
-};
-
-struct inotify_operations {
-	void (*handle_event)(struct inotify_watch *, u32, u32, u32,
-			     const char *, struct inode *);
-	void (*destroy_watch)(struct inotify_watch *);
-};
-
-#ifdef CONFIG_INOTIFY
-
-/* Kernel API for producing events */
-
-extern void inotify_d_instantiate(struct dentry *, struct inode *);
-extern void inotify_d_move(struct dentry *);
-extern void inotify_inode_queue_event(struct inode *, __u32, __u32,
-				      const char *, struct inode *);
-extern void inotify_dentry_parent_queue_event(struct dentry *, __u32, __u32,
-					      const char *);
-extern void inotify_unmount_inodes(struct list_head *);
-extern void inotify_inode_is_dead(struct inode *);
-extern u32 inotify_get_cookie(void);
-
-/* Kernel Consumer API */
-
-extern struct inotify_handle *inotify_init(const struct inotify_operations *);
-extern void inotify_init_watch(struct inotify_watch *);
-extern void inotify_destroy(struct inotify_handle *);
-extern __s32 inotify_find_watch(struct inotify_handle *, struct inode *,
-				struct inotify_watch **);
-extern __s32 inotify_find_update_watch(struct inotify_handle *, struct inode *,
-				       u32);
-extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
-			       struct inode *, __u32);
-extern __s32 inotify_clone_watch(struct inotify_watch *, struct inotify_watch *);
-extern void inotify_evict_watch(struct inotify_watch *);
-extern int inotify_rm_watch(struct inotify_handle *, struct inotify_watch *);
-extern int inotify_rm_wd(struct inotify_handle *, __u32);
-extern void inotify_remove_watch_locked(struct inotify_handle *,
-					struct inotify_watch *);
-extern void get_inotify_watch(struct inotify_watch *);
-extern void put_inotify_watch(struct inotify_watch *);
-extern int pin_inotify_watch(struct inotify_watch *);
-extern void unpin_inotify_watch(struct inotify_watch *);
-
-#else
-
-static inline void inotify_d_instantiate(struct dentry *dentry,
-					struct inode *inode)
-{
-}
-
-static inline void inotify_d_move(struct dentry *dentry)
-{
-}
-
-static inline void inotify_inode_queue_event(struct inode *inode,
-					     __u32 mask, __u32 cookie,
-					     const char *filename,
-					     struct inode *n_inode)
-{
-}
-
-static inline void inotify_dentry_parent_queue_event(struct dentry *dentry,
-						     __u32 mask, __u32 cookie,
-						     const char *filename)
-{
-}
-
-static inline void inotify_unmount_inodes(struct list_head *list)
-{
-}
-
-static inline void inotify_inode_is_dead(struct inode *inode)
-{
-}
-
-static inline u32 inotify_get_cookie(void)
-{
-	return 0;
-}
-
-static inline struct inotify_handle *inotify_init(const struct inotify_operations *ops)
-{
-	return ERR_PTR(-EOPNOTSUPP);
-}
-
-static inline void inotify_init_watch(struct inotify_watch *watch)
-{
-}
-
-static inline void inotify_destroy(struct inotify_handle *ih)
-{
-}
-
-static inline __s32 inotify_find_watch(struct inotify_handle *ih, struct inode *inode,
-				       struct inotify_watch **watchp)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline __s32 inotify_find_update_watch(struct inotify_handle *ih,
-					      struct inode *inode, u32 mask)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline __s32 inotify_add_watch(struct inotify_handle *ih,
-				      struct inotify_watch *watch,
-				      struct inode *inode, __u32 mask)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline int inotify_rm_watch(struct inotify_handle *ih,
-				   struct inotify_watch *watch)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline int inotify_rm_wd(struct inotify_handle *ih, __u32 wd)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline void inotify_remove_watch_locked(struct inotify_handle *ih,
-					       struct inotify_watch *watch)
-{
-}
-
-static inline void get_inotify_watch(struct inotify_watch *watch)
-{
-}
-
-static inline void put_inotify_watch(struct inotify_watch *watch)
-{
-}
-
-extern inline int pin_inotify_watch(struct inotify_watch *watch)
-{
-	return 0;
-}
-
-extern inline void unpin_inotify_watch(struct inotify_watch *watch)
-{
-}
-
-#endif	/* CONFIG_INOTIFY */
-
-#endif	/* __KERNEL __ */
-
 #endif	/* _LINUX_INOTIFY_H */

commit 8f7b0ba1c853919b85b54774775f567f30006107
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sat Nov 15 01:15:43 2008 +0000

    Fix inotify watch removal/umount races
    
    Inotify watch removals suck violently.
    
    To kick the watch out we need (in this order) inode->inotify_mutex and
    ih->mutex.  That's fine if we have a hold on inode; however, for all
    other cases we need to make damn sure we don't race with umount.  We can
    *NOT* just grab a reference to a watch - inotify_unmount_inodes() will
    happily sail past it and we'll end with reference to inode potentially
    outliving its superblock.
    
    Ideally we just want to grab an active reference to superblock if we
    can; that will make sure we won't go into inotify_umount_inodes() until
    we are done.  Cleanup is just deactivate_super().
    
    However, that leaves a messy case - what if we *are* racing with
    umount() and active references to superblock can't be acquired anymore?
    We can bump ->s_count, grab ->s_umount, which will almost certainly wait
    until the superblock is shut down and the watch in question is pining
    for fjords.  That's fine, but there is a problem - we might have hit the
    window between ->s_active getting to 0 / ->s_count - below S_BIAS (i.e.
    the moment when superblock is past the point of no return and is heading
    for shutdown) and the moment when deactivate_super() acquires
    ->s_umount.
    
    We could just do drop_super() yield() and retry, but that's rather
    antisocial and this stuff is luser-triggerable.  OTOH, having grabbed
    ->s_umount and having found that we'd got there first (i.e.  that
    ->s_root is non-NULL) we know that we won't race with
    inotify_umount_inodes().
    
    So we could grab a reference to watch and do the rest as above, just
    with drop_super() instead of deactivate_super(), right? Wrong.  We had
    to drop ih->mutex before we could grab ->s_umount.  So the watch
    could've been gone already.
    
    That still can be dealt with - we need to save watch->wd, do idr_find()
    and compare its result with our pointer.  If they match, we either have
    the damn thing still alive or we'd lost not one but two races at once,
    the watch had been killed and a new one got created with the same ->wd
    at the same address.  That couldn't have happened in inotify_destroy(),
    but inotify_rm_wd() could run into that.  Still, "new one got created"
    is not a problem - we have every right to kill it or leave it alone,
    whatever's more convenient.
    
    So we can use idr_find(...) == watch && watch->inode->i_sb == sb as
    "grab it and kill it" check.  If it's been our original watch, we are
    fine, if it's a newcomer - nevermind, just pretend that we'd won the
    race and kill the fscker anyway; we are safe since we know that its
    superblock won't be going away.
    
    And yes, this is far beyond mere "not very pretty"; so's the entire
    concept of inotify to start with.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index bd578578a8b9..37ea2894b3c0 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -134,6 +134,8 @@ extern void inotify_remove_watch_locked(struct inotify_handle *,
 					struct inotify_watch *);
 extern void get_inotify_watch(struct inotify_watch *);
 extern void put_inotify_watch(struct inotify_watch *);
+extern int pin_inotify_watch(struct inotify_watch *);
+extern void unpin_inotify_watch(struct inotify_watch *);
 
 #else
 
@@ -228,6 +230,15 @@ static inline void put_inotify_watch(struct inotify_watch *watch)
 {
 }
 
+extern inline int pin_inotify_watch(struct inotify_watch *watch)
+{
+	return 0;
+}
+
+extern inline void unpin_inotify_watch(struct inotify_watch *watch)
+{
+}
+
 #endif	/* CONFIG_INOTIFY */
 
 #endif	/* __KERNEL __ */

commit 510df2dd482496083e1c3b1a8c9b6afd5fa4c7d7
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:41 2008 -0700

    flag parameters: NONBLOCK in inotify_init
    
    This patch adds non-blocking support for inotify_init1.  The
    additional changes needed are minimal.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_inotify_init1
    # ifdef __x86_64__
    #  define __NR_inotify_init1 294
    # elif defined __i386__
    #  define __NR_inotify_init1 332
    # else
    #  error "need __NR_inotify_init1"
    # endif
    #endif
    
    #define IN_NONBLOCK O_NONBLOCK
    
    int
    main (void)
    {
      int fd = syscall (__NR_inotify_init1, 0);
      if (fd == -1)
        {
          puts ("inotify_init1(0) failed");
          return 1;
        }
      int fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (fl & O_NONBLOCK)
        {
          puts ("inotify_init1(0) set non-blocking mode");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_inotify_init1, IN_NONBLOCK);
      if (fd == -1)
        {
          puts ("inotify_init1(IN_NONBLOCK) failed");
          return 1;
        }
      fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((fl & O_NONBLOCK) == 0)
        {
          puts ("inotify_init1(IN_NONBLOCK) set non-blocking mode");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 72ef82120512..bd578578a8b9 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -7,7 +7,7 @@
 #ifndef _LINUX_INOTIFY_H
 #define _LINUX_INOTIFY_H
 
-/* For O_CLOEXEC */
+/* For O_CLOEXEC and O_NONBLOCK */
 #include <linux/fcntl.h>
 #include <linux/types.h>
 
@@ -67,6 +67,7 @@ struct inotify_event {
 
 /* Flags for sys_inotify_init1.  */
 #define IN_CLOEXEC O_CLOEXEC
+#define IN_NONBLOCK O_NONBLOCK
 
 #ifdef __KERNEL__
 

commit 4006553b06306b34054529477b06b68a1c66249b
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:32 2008 -0700

    flag parameters: inotify_init
    
    This patch introduces the new syscall inotify_init1 (note: the 1 stands for
    the one parameter the syscall takes, as opposed to no parameter before).  The
    values accepted for this parameter are function-specific and defined in the
    inotify.h header.  Here the values must match the O_* flags, though.  In this
    patch CLOEXEC support is introduced.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_inotify_init1
    # ifdef __x86_64__
    #  define __NR_inotify_init1 294
    # elif defined __i386__
    #  define __NR_inotify_init1 332
    # else
    #  error "need __NR_inotify_init1"
    # endif
    #endif
    
    #define IN_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      int fd;
      fd = syscall (__NR_inotify_init1, 0);
      if (fd == -1)
        {
          puts ("inotify_init1(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("inotify_init1(0) set close-on-exit");
          return 1;
        }
      close (fd);
    
      fd = syscall (__NR_inotify_init1, IN_CLOEXEC);
      if (fd == -1)
        {
          puts ("inotify_init1(IN_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("inotify_init1(O_CLOEXEC) does not set close-on-exit");
          return 1;
        }
      close (fd);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 742b917e7d1b..72ef82120512 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -7,6 +7,8 @@
 #ifndef _LINUX_INOTIFY_H
 #define _LINUX_INOTIFY_H
 
+/* For O_CLOEXEC */
+#include <linux/fcntl.h>
 #include <linux/types.h>
 
 /*
@@ -63,6 +65,9 @@ struct inotify_event {
 			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
 			 IN_MOVE_SELF)
 
+/* Flags for sys_inotify_init1.  */
+#define IN_CLOEXEC O_CLOEXEC
+
 #ifdef __KERNEL__
 
 #include <linux/dcache.h>

commit 455434d450a358ac5bcf3fc58f8913d13c544622
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 12:22:59 2007 -0400

    [PATCH] new helper - inotify_evict_watch()
    
    Kicks the watch out without dropping it.  Called under ->inotify_mutex
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index e76e2272e2ab..742b917e7d1b 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -121,6 +121,7 @@ extern __s32 inotify_find_update_watch(struct inotify_handle *, struct inode *,
 extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
 			       struct inode *, __u32);
 extern __s32 inotify_clone_watch(struct inotify_watch *, struct inotify_watch *);
+extern void inotify_evict_watch(struct inotify_watch *);
 extern int inotify_rm_watch(struct inotify_handle *, struct inotify_watch *);
 extern int inotify_rm_wd(struct inotify_handle *, __u32);
 extern void inotify_remove_watch_locked(struct inotify_handle *,

commit b9efe8a234ad874a049460417c54680338f96360
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 12:21:44 2007 -0400

    [PATCH] new helper - inotify_clone_watch()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index d4f48c6402e6..e76e2272e2ab 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -120,6 +120,7 @@ extern __s32 inotify_find_update_watch(struct inotify_handle *, struct inode *,
 				       u32);
 extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
 			       struct inode *, __u32);
+extern __s32 inotify_clone_watch(struct inotify_watch *, struct inotify_watch *);
 extern int inotify_rm_watch(struct inotify_handle *, struct inotify_watch *);
 extern int inotify_rm_wd(struct inotify_handle *, __u32);
 extern void inotify_remove_watch_locked(struct inotify_handle *,

commit 3ca10067f7f4bfa62a1b0edc84f590261fa02d75
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jun 1 13:11:05 2006 -0700

    [PATCH] inotify (4/5): allow watch removal from event handler
    
    Allow callers to remove watches from their event handler via
    inotify_remove_watch_locked().  This functionality can be used to
    achieve IN_ONESHOT-like functionality for a subset of events in the
    mask.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Acked-by: Robert Love <rml@novell.com>
    Acked-by: John McCutchan <john@johnmccutchan.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index e7e7fb7fc778..d4f48c6402e6 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -122,6 +122,8 @@ extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
 			       struct inode *, __u32);
 extern int inotify_rm_watch(struct inotify_handle *, struct inotify_watch *);
 extern int inotify_rm_wd(struct inotify_handle *, __u32);
+extern void inotify_remove_watch_locked(struct inotify_handle *,
+					struct inotify_watch *);
 extern void get_inotify_watch(struct inotify_watch *);
 extern void put_inotify_watch(struct inotify_watch *);
 
@@ -205,6 +207,11 @@ static inline int inotify_rm_wd(struct inotify_handle *ih, __u32 wd)
 	return -EOPNOTSUPP;
 }
 
+static inline void inotify_remove_watch_locked(struct inotify_handle *ih,
+					       struct inotify_watch *watch)
+{
+}
+
 static inline void get_inotify_watch(struct inotify_watch *watch)
 {
 }

commit a9dc971d3fdb857a2bcd6d53238125a2cd31d5f4
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jun 1 13:11:03 2006 -0700

    [PATCH] inotify (3/5): add interfaces to kernel API
    
    Add inotify_init_watch() so caller can use inotify_watch refcounts
    before calling inotify_add_watch().
    
    Add inotify_find_watch() to find an existing watch for an (ih,inode)
    pair.  This is similar to inotify_find_update_watch(), but does not
    update the watch's mask if one is found.
    
    Add inotify_rm_watch() to remove a watch via the watch pointer instead
    of the watch descriptor.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Acked-by: Robert Love <rml@novell.com>
    Acked-by: John McCutchan <john@johnmccutchan.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index e7899e7d83ad..e7e7fb7fc778 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -112,11 +112,15 @@ extern u32 inotify_get_cookie(void);
 /* Kernel Consumer API */
 
 extern struct inotify_handle *inotify_init(const struct inotify_operations *);
+extern void inotify_init_watch(struct inotify_watch *);
 extern void inotify_destroy(struct inotify_handle *);
+extern __s32 inotify_find_watch(struct inotify_handle *, struct inode *,
+				struct inotify_watch **);
 extern __s32 inotify_find_update_watch(struct inotify_handle *, struct inode *,
 				       u32);
 extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
 			       struct inode *, __u32);
+extern int inotify_rm_watch(struct inotify_handle *, struct inotify_watch *);
 extern int inotify_rm_wd(struct inotify_handle *, __u32);
 extern void get_inotify_watch(struct inotify_watch *);
 extern void put_inotify_watch(struct inotify_watch *);
@@ -163,10 +167,20 @@ static inline struct inotify_handle *inotify_init(const struct inotify_operation
 	return ERR_PTR(-EOPNOTSUPP);
 }
 
+static inline void inotify_init_watch(struct inotify_watch *watch)
+{
+}
+
 static inline void inotify_destroy(struct inotify_handle *ih)
 {
 }
 
+static inline __s32 inotify_find_watch(struct inotify_handle *ih, struct inode *inode,
+				       struct inotify_watch **watchp)
+{
+	return -EOPNOTSUPP;
+}
+
 static inline __s32 inotify_find_update_watch(struct inotify_handle *ih,
 					      struct inode *inode, u32 mask)
 {
@@ -180,6 +194,12 @@ static inline __s32 inotify_add_watch(struct inotify_handle *ih,
 	return -EOPNOTSUPP;
 }
 
+static inline int inotify_rm_watch(struct inotify_handle *ih,
+				   struct inotify_watch *watch)
+{
+	return -EOPNOTSUPP;
+}
+
 static inline int inotify_rm_wd(struct inotify_handle *ih, __u32 wd)
 {
 	return -EOPNOTSUPP;

commit 7c29772288b7026504cfe75bfd90d40fbd1574bf
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jun 1 13:11:01 2006 -0700

    [PATCH] inotify (2/5): add name's inode to event handler
    
    When an inotify event includes a dentry name, also include the inode
    associated with that name.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Acked-by: Robert Love <rml@novell.com>
    Acked-by: John McCutchan <john@johnmccutchan.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 68b6e0127de4..e7899e7d83ad 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -91,7 +91,7 @@ struct inotify_watch {
 
 struct inotify_operations {
 	void (*handle_event)(struct inotify_watch *, u32, u32, u32,
-			     const char *);
+			     const char *, struct inode *);
 	void (*destroy_watch)(struct inotify_watch *);
 };
 
@@ -102,7 +102,7 @@ struct inotify_operations {
 extern void inotify_d_instantiate(struct dentry *, struct inode *);
 extern void inotify_d_move(struct dentry *);
 extern void inotify_inode_queue_event(struct inode *, __u32, __u32,
-				      const char *);
+				      const char *, struct inode *);
 extern void inotify_dentry_parent_queue_event(struct dentry *, __u32, __u32,
 					      const char *);
 extern void inotify_unmount_inodes(struct list_head *);
@@ -134,7 +134,8 @@ static inline void inotify_d_move(struct dentry *dentry)
 
 static inline void inotify_inode_queue_event(struct inode *inode,
 					     __u32 mask, __u32 cookie,
-					     const char *filename)
+					     const char *filename,
+					     struct inode *n_inode)
 {
 }
 

commit 2d9048e201bfb67ba21f05e647b1286b8a4a5667
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jun 1 13:10:59 2006 -0700

    [PATCH] inotify (1/5): split kernel API from userspace support
    
    The following series of patches introduces a kernel API for inotify,
    making it possible for kernel modules to benefit from inotify's
    mechanism for watching inodes.  With these patches, inotify will
    maintain for each caller a list of watches (via an embedded struct
    inotify_watch), where each inotify_watch is associated with a
    corresponding struct inode.  The caller registers an event handler and
    specifies for which filesystem events their event handler should be
    called per inotify_watch.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Acked-by: Robert Love <rml@novell.com>
    Acked-by: John McCutchan <john@johnmccutchan.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 71aa1553ef38..68b6e0127de4 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -68,8 +68,37 @@ struct inotify_event {
 #include <linux/dcache.h>
 #include <linux/fs.h>
 
+/*
+ * struct inotify_watch - represents a watch request on a specific inode
+ *
+ * h_list is protected by ih->mutex of the associated inotify_handle.
+ * i_list, mask are protected by inode->inotify_mutex of the associated inode.
+ * ih, inode, and wd are never written to once the watch is created.
+ *
+ * Callers must use the established inotify interfaces to access inotify_watch
+ * contents.  The content of this structure is private to the inotify
+ * implementation.
+ */
+struct inotify_watch {
+	struct list_head	h_list;	/* entry in inotify_handle's list */
+	struct list_head	i_list;	/* entry in inode's list */
+	atomic_t		count;	/* reference count */
+	struct inotify_handle	*ih;	/* associated inotify handle */
+	struct inode		*inode;	/* associated inode */
+	__s32			wd;	/* watch descriptor */
+	__u32			mask;	/* event mask for this watch */
+};
+
+struct inotify_operations {
+	void (*handle_event)(struct inotify_watch *, u32, u32, u32,
+			     const char *);
+	void (*destroy_watch)(struct inotify_watch *);
+};
+
 #ifdef CONFIG_INOTIFY
 
+/* Kernel API for producing events */
+
 extern void inotify_d_instantiate(struct dentry *, struct inode *);
 extern void inotify_d_move(struct dentry *);
 extern void inotify_inode_queue_event(struct inode *, __u32, __u32,
@@ -80,6 +109,18 @@ extern void inotify_unmount_inodes(struct list_head *);
 extern void inotify_inode_is_dead(struct inode *);
 extern u32 inotify_get_cookie(void);
 
+/* Kernel Consumer API */
+
+extern struct inotify_handle *inotify_init(const struct inotify_operations *);
+extern void inotify_destroy(struct inotify_handle *);
+extern __s32 inotify_find_update_watch(struct inotify_handle *, struct inode *,
+				       u32);
+extern __s32 inotify_add_watch(struct inotify_handle *, struct inotify_watch *,
+			       struct inode *, __u32);
+extern int inotify_rm_wd(struct inotify_handle *, __u32);
+extern void get_inotify_watch(struct inotify_watch *);
+extern void put_inotify_watch(struct inotify_watch *);
+
 #else
 
 static inline void inotify_d_instantiate(struct dentry *dentry,
@@ -116,6 +157,41 @@ static inline u32 inotify_get_cookie(void)
 	return 0;
 }
 
+static inline struct inotify_handle *inotify_init(const struct inotify_operations *ops)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
+static inline void inotify_destroy(struct inotify_handle *ih)
+{
+}
+
+static inline __s32 inotify_find_update_watch(struct inotify_handle *ih,
+					      struct inode *inode, u32 mask)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline __s32 inotify_add_watch(struct inotify_handle *ih,
+				      struct inotify_watch *watch,
+				      struct inode *inode, __u32 mask)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int inotify_rm_wd(struct inotify_handle *ih, __u32 wd)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void get_inotify_watch(struct inotify_watch *watch)
+{
+}
+
+static inline void put_inotify_watch(struct inotify_watch *watch)
+{
+}
+
 #endif	/* CONFIG_INOTIFY */
 
 #endif	/* __KERNEL __ */

commit 90204e0b7b51e9f2a6905adca12dc331128602c7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 1 21:39:38 2006 -0400

    [PATCH] remove config.h from inotify.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 09e00433c78e..71aa1553ef38 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -67,7 +67,6 @@ struct inotify_event {
 
 #include <linux/dcache.h>
 #include <linux/fs.h>
-#include <linux/config.h>
 
 #ifdef CONFIG_INOTIFY
 

commit c32ccd87bfd1414b0aabfcd8dbc7539ad23bcbaa
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Sat Mar 25 03:07:09 2006 -0800

    [PATCH] inotify: lock avoidance with parent watch status in dentry
    
    Previous inotify work avoidance is good when inotify is completely unused,
    but it breaks down if even a single watch is in place anywhere in the
    system.  Robin Holt notices that udev is one such culprit - it slows down a
    512-thread application on a 512 CPU system from 6 seconds to 22 minutes.
    
    Solve this by adding a flag in the dentry that tells inotify whether or not
    its parent inode has a watch on it.  Event queueing to parent will skip
    taking locks if this flag is cleared.  Setting and clearing of this flag on
    all child dentries versus event delivery: this is no in terms of race
    cases, and that was shown to be equivalent to always performing the check.
    
    The essential behaviour is that activity occuring _after_ a watch has been
    added and _before_ it has been removed, will generate events.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Robert Love <rml@novell.com>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 267c88b5f742..09e00433c78e 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -71,6 +71,8 @@ struct inotify_event {
 
 #ifdef CONFIG_INOTIFY
 
+extern void inotify_d_instantiate(struct dentry *, struct inode *);
+extern void inotify_d_move(struct dentry *);
 extern void inotify_inode_queue_event(struct inode *, __u32, __u32,
 				      const char *);
 extern void inotify_dentry_parent_queue_event(struct dentry *, __u32, __u32,
@@ -81,6 +83,15 @@ extern u32 inotify_get_cookie(void);
 
 #else
 
+static inline void inotify_d_instantiate(struct dentry *dentry,
+					struct inode *inode)
+{
+}
+
+static inline void inotify_d_move(struct dentry *dentry)
+{
+}
+
 static inline void inotify_inode_queue_event(struct inode *inode,
 					     __u32 mask, __u32 cookie,
 					     const char *filename)

commit 8140a5005bc6f1c9d0fa103460d50d472e6e3426
Author: John McCutchan <ttb@tentacle.dhs.org>
Date:   Mon Dec 12 00:37:14 2005 -0800

    [PATCH] inotify: add two inotify_add_watch flags
    
    The below patch lets userspace have more control over the inodes that
    inotify will watch.  It introduces two new flags.
    
            IN_ONLYDIR -- only watch the inode if it is a directory.
            This is needed to avoid the race that can occur when we want to be
            sure that we are watching a directory.
    
            IN_DONT_FOLLOW -- don't follow a symlink.  In combination
            with IN_ONLYDIR we can make sure that we don't watch the target of
            symlinks.
    
    The issues the flags fix came up when writing the gnome-vfs inotify
    backend.  Default behaviour is unchanged.
    
    Signed-off-by: John McCutchan <ttb@tentacle.dhs.org>
    Acked-by: Robert Love <rml@novell.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index ee5b239092ed..267c88b5f742 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -47,6 +47,8 @@ struct inotify_event {
 #define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
 
 /* special flags */
+#define IN_ONLYDIR		0x01000000	/* only watch the path if it is a directory */
+#define IN_DONT_FOLLOW		0x02000000	/* don't follow a sym link */
 #define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
 #define IN_ISDIR		0x40000000	/* event occurred against dir */
 #define IN_ONESHOT		0x80000000	/* only send event once */

commit 7ea6040b0eff07d3a9a4e2d248ac137c6ad02d42
Author: John McCutchan <ttb@tentacle.dhs.org>
Date:   Tue Sep 6 15:18:02 2005 -0700

    [PATCH] inotify: fix event loss on hardlinked files
    
    People have run into a problem when they do this:
    
    watch (file1, all_events);
    watch (file2, some_events);
    
    if file2 is a hard link to file1, some events will be missed because by
    default we replace the mask.  The patch below adds a flag IN_MASK_ADD which
    will cause inotify to add to the existing mask if present.
    
    Signed-off-by: John McCutchan <ttb@tentacle.dhs.org>
    Signed-off-by: Robert Love <rml@novell.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index 93bb3afe646b..ee5b239092ed 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -47,6 +47,7 @@ struct inotify_event {
 #define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
 
 /* special flags */
+#define IN_MASK_ADD		0x20000000	/* add to the mask of an already existing watch */
 #define IN_ISDIR		0x40000000	/* event occurred against dir */
 #define IN_ONESHOT		0x80000000	/* only send event once */
 

commit 89204c40a03346cd951e698d854105db4cfedc28
Author: John McCutchan <jmccutchan@novell.com>
Date:   Mon Aug 15 12:13:28 2005 -0400

    [PATCH] inotify: add MOVE_SELF event
    
    This adds a MOVE_SELF event to inotify.  It is sent whenever the inode
    you are watching is moved.  We need this event so that we can catch
    something like this:
    
     - app1:
            watch /etc/mtab
    
     - app2:
            cp /etc/mtab /tmp/mtab-work
            mv /etc/mtab /etc/mtab~
            mv /tmp/mtab-work /etc/mtab
    
    app1 still thinks it's watching /etc/mtab but it's actually watching
    /etc/mtab~.
    
    Signed-off-by: John McCutchan <ttb@tentacle.dhs.org>
    Signed-off-by: Robert Love <rml@novell.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index a40c2bf0408e..93bb3afe646b 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -35,6 +35,7 @@ struct inotify_event {
 #define IN_CREATE		0x00000100	/* Subfile was created */
 #define IN_DELETE		0x00000200	/* Subfile was deleted */
 #define IN_DELETE_SELF		0x00000400	/* Self was deleted */
+#define IN_MOVE_SELF		0x00000800	/* Self was moved */
 
 /* the following are legal events.  they are sent as needed to any watch */
 #define IN_UNMOUNT		0x00002000	/* Backing fs was unmounted */
@@ -56,7 +57,8 @@ struct inotify_event {
  */
 #define IN_ALL_EVENTS	(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
 			 IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
-			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)
+			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
+			 IN_MOVE_SELF)
 
 #ifdef __KERNEL__
 

commit 0eeca28300df110bd6ed54b31193c83b87921443
Author: Robert Love <rml@novell.com>
Date:   Tue Jul 12 17:06:03 2005 -0400

    [PATCH] inotify
    
    inotify is intended to correct the deficiencies of dnotify, particularly
    its inability to scale and its terrible user interface:
    
            * dnotify requires the opening of one fd per each directory
              that you intend to watch. This quickly results in too many
              open files and pins removable media, preventing unmount.
            * dnotify is directory-based. You only learn about changes to
              directories. Sure, a change to a file in a directory affects
              the directory, but you are then forced to keep a cache of
              stat structures.
            * dnotify's interface to user-space is awful.  Signals?
    
    inotify provides a more usable, simple, powerful solution to file change
    notification:
    
            * inotify's interface is a system call that returns a fd, not SIGIO.
              You get a single fd, which is select()-able.
            * inotify has an event that says "the filesystem that the item
              you were watching is on was unmounted."
            * inotify can watch directories or files.
    
    Inotify is currently used by Beagle (a desktop search infrastructure),
    Gamin (a FAM replacement), and other projects.
    
    See Documentation/filesystems/inotify.txt.
    
    Signed-off-by: Robert Love <rml@novell.com>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/inotify.h b/include/linux/inotify.h
new file mode 100644
index 000000000000..a40c2bf0408e
--- /dev/null
+++ b/include/linux/inotify.h
@@ -0,0 +1,108 @@
+/*
+ * Inode based directory notification for Linux
+ *
+ * Copyright (C) 2005 John McCutchan
+ */
+
+#ifndef _LINUX_INOTIFY_H
+#define _LINUX_INOTIFY_H
+
+#include <linux/types.h>
+
+/*
+ * struct inotify_event - structure read from the inotify device for each event
+ *
+ * When you are watching a directory, you will receive the filename for events
+ * such as IN_CREATE, IN_DELETE, IN_OPEN, IN_CLOSE, ..., relative to the wd.
+ */
+struct inotify_event {
+	__s32		wd;		/* watch descriptor */
+	__u32		mask;		/* watch mask */
+	__u32		cookie;		/* cookie to synchronize two events */
+	__u32		len;		/* length (including nulls) of name */
+	char		name[0];	/* stub for possible name */
+};
+
+/* the following are legal, implemented events that user-space can watch for */
+#define IN_ACCESS		0x00000001	/* File was accessed */
+#define IN_MODIFY		0x00000002	/* File was modified */
+#define IN_ATTRIB		0x00000004	/* Metadata changed */
+#define IN_CLOSE_WRITE		0x00000008	/* Writtable file was closed */
+#define IN_CLOSE_NOWRITE	0x00000010	/* Unwrittable file closed */
+#define IN_OPEN			0x00000020	/* File was opened */
+#define IN_MOVED_FROM		0x00000040	/* File was moved from X */
+#define IN_MOVED_TO		0x00000080	/* File was moved to Y */
+#define IN_CREATE		0x00000100	/* Subfile was created */
+#define IN_DELETE		0x00000200	/* Subfile was deleted */
+#define IN_DELETE_SELF		0x00000400	/* Self was deleted */
+
+/* the following are legal events.  they are sent as needed to any watch */
+#define IN_UNMOUNT		0x00002000	/* Backing fs was unmounted */
+#define IN_Q_OVERFLOW		0x00004000	/* Event queued overflowed */
+#define IN_IGNORED		0x00008000	/* File was ignored */
+
+/* helper events */
+#define IN_CLOSE		(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* close */
+#define IN_MOVE			(IN_MOVED_FROM | IN_MOVED_TO) /* moves */
+
+/* special flags */
+#define IN_ISDIR		0x40000000	/* event occurred against dir */
+#define IN_ONESHOT		0x80000000	/* only send event once */
+
+/*
+ * All of the events - we build the list by hand so that we can add flags in
+ * the future and not break backward compatibility.  Apps will get only the
+ * events that they originally wanted.  Be sure to add new events here!
+ */
+#define IN_ALL_EVENTS	(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
+			 IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
+			 IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)
+
+#ifdef __KERNEL__
+
+#include <linux/dcache.h>
+#include <linux/fs.h>
+#include <linux/config.h>
+
+#ifdef CONFIG_INOTIFY
+
+extern void inotify_inode_queue_event(struct inode *, __u32, __u32,
+				      const char *);
+extern void inotify_dentry_parent_queue_event(struct dentry *, __u32, __u32,
+					      const char *);
+extern void inotify_unmount_inodes(struct list_head *);
+extern void inotify_inode_is_dead(struct inode *);
+extern u32 inotify_get_cookie(void);
+
+#else
+
+static inline void inotify_inode_queue_event(struct inode *inode,
+					     __u32 mask, __u32 cookie,
+					     const char *filename)
+{
+}
+
+static inline void inotify_dentry_parent_queue_event(struct dentry *dentry,
+						     __u32 mask, __u32 cookie,
+						     const char *filename)
+{
+}
+
+static inline void inotify_unmount_inodes(struct list_head *list)
+{
+}
+
+static inline void inotify_inode_is_dead(struct inode *inode)
+{
+}
+
+static inline u32 inotify_get_cookie(void)
+{
+	return 0;
+}
+
+#endif	/* CONFIG_INOTIFY */
+
+#endif	/* __KERNEL __ */
+
+#endif	/* _LINUX_INOTIFY_H */
