commit cf6fada71543ceea0f6228ffdc0b85778f3f5a6e
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Sat May 30 10:08:30 2020 +0800

    cpufreq: change '.set_boost' to act on one policy
    
    Macro 'for_each_active_policy()' is defined internally. To avoid some
    cpufreq driver needing this macro to iterate over all the policies in
    '.set_boost' callback, we redefine '.set_boost' to act on only one
    policy and pass the policy as an argument.
    
    'cpufreq_boost_trigger_state()' iterates over all the policies to set
    boost for the system.
    
    This is preparation for adding SW BOOST support for CPPC.
    
    To protect Boost enable/disable by sysfs from CPU online/offline,
    add 'cpu_hotplug_lock' before calling '.set_boost' for each CPU.
    
    Also move the lock from 'set_boost()' to 'store_cpb()' in
    acpi_cpufreq.
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 67d5950bd878..3494f6763597 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -367,7 +367,7 @@ struct cpufreq_driver {
 
 	/* platform specific boost support code */
 	bool		boost_enabled;
-	int		(*set_boost)(int state);
+	int		(*set_boost)(struct cpufreq_policy *policy, int state);
 };
 
 /* flags */

commit 2909438d4d62681f392c57df4cd6b7183d19dde0
Author: Wang Wenhu <wenhu.wang@vivo.com>
Date:   Wed May 13 07:18:54 2020 -0700

    cpufreq: fix minor typo in struct cpufreq_driver doc comment
    
    Delete the duplicate "to", possibly double-typed.
    
    Signed-off-by: Wang Wenhu <wenhu.wang@vivo.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f7240251a949..67d5950bd878 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -330,7 +330,7 @@ struct cpufreq_driver {
 	 *
 	 * get_intermediate should return a stable intermediate frequency
 	 * platform wants to switch to and target_intermediate() should set CPU
-	 * to to that frequency, before jumping to the frequency corresponding
+	 * to that frequency, before jumping to the frequency corresponding
 	 * to 'index'. Core will take care of sending notifications and driver
 	 * doesn't have to handle them in target_intermediate() or
 	 * target_index().

commit bbce8eaa603236bf958b0d24e6377b3f3b623991
Author: Ionela Voinescu <ionela.voinescu@arm.com>
Date:   Thu Mar 5 09:06:25 2020 +0000

    cpufreq: add function to get the hardware max frequency
    
    Add weak function to return the hardware maximum frequency of a CPU,
    with the default implementation returning cpuinfo.max_freq, which is
    the best information we can generically get from the cpufreq framework.
    
    The default can be overwritten by a strong function in platforms
    that want to provide an alternative implementation, with more accurate
    information, obtained either from hardware or firmware.
    
    Signed-off-by: Ionela Voinescu <ionela.voinescu@arm.com>
    Reviewed-by: Valentin Schneider <valentin.schneider@arm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0fb561d1b524..f7240251a949 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -205,6 +205,7 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 unsigned int cpufreq_get(unsigned int cpu);
 unsigned int cpufreq_quick_get(unsigned int cpu);
 unsigned int cpufreq_quick_get_max(unsigned int cpu);
+unsigned int cpufreq_get_hw_max_freq(unsigned int cpu);
 void disable_cpufreq(void);
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
@@ -232,6 +233,10 @@ static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
 {
 	return 0;
 }
+static inline unsigned int cpufreq_get_hw_max_freq(unsigned int cpu)
+{
+	return 0;
+}
 static inline void disable_cpufreq(void) { }
 #endif
 

commit 183edb20e60a73925bf3b60e2f4796898167262f
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Mon Feb 3 15:45:17 2020 +0000

    cpufreq: Make cpufreq_global_kobject static
    
    The cpufreq_global_kobject is only used internally by cpufreq.c
    after commit 2361be236662 ("cpufreq: Don't create empty
    /sys/devices/system/cpu/cpufreq directory").
    
    Make it static.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    [ rjw: Add empty line after cpufreq_global_kobject definition ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 018dce868de6..0fb561d1b524 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -201,9 +201,6 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 	return cpumask_weight(policy->cpus) > 1;
 }
 
-/* /sys/devices/system/cpu/cpufreq: entry point for global variables */
-extern struct kobject *cpufreq_global_kobject;
-
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_get(unsigned int cpu);
 unsigned int cpufreq_quick_get(unsigned int cpu);

commit 1e4f63aecb53e48468661e922fc2fa3b83e55722
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 26 23:40:11 2020 +0100

    cpufreq: Avoid creating excessively large stack frames
    
    In the process of modifying a cpufreq policy, the cpufreq core makes
    a copy of it including all of the internals which is stored on the
    CPU stack.  Because struct cpufreq_policy is relatively large, this
    may cause the size of the stack frame to exceed the 2 KB limit and
    so the GCC complains when -Wframe-larger-than= is used.
    
    In fact, it is not necessary to copy the entire policy structure
    in order to modify it, however.
    
    First, because cpufreq_set_policy() obtains the min and max policy
    limits from frequency QoS now, it is not necessary to pass the limits
    to it from the callers.  The only things that need to be passed to it
    from there are the new governor pointer or (if there is a built-in
    governor in the driver) the "policy" value representing the governor
    choice.  They both can be passed as individual arguments, though, so
    make cpufreq_set_policy() take them this way and rework its callers
    accordingly.  This avoids making copies of cpufreq policies in the
    callers of cpufreq_set_policy().
    
    Second, cpufreq_set_policy() still needs to pass the new policy
    data to the ->verify() callback of the cpufreq driver whose task
    is to sanitize the min and max policy limits.  It still does not
    need to make a full copy of struct cpufreq_policy for this purpose,
    but it needs to pass a few items from it to the driver in case they
    are needed (different drivers have different needs in that respect
    and all of them have to be covered).  For this reason, introduce
    struct cpufreq_policy_data to hold copies of the members of
    struct cpufreq_policy used by the existing ->verify() driver
    callbacks and pass a pointer to a temporary structure of that
    type to ->verify() (instead of passing a pointer to full struct
    cpufreq_policy to it).
    
    While at it, notice that intel_pstate and longrun don't really need
    to verify the "policy" value in struct cpufreq_policy, so drop those
    check from them to avoid copying "policy" into struct
    cpufreq_policy_data (which allows it to be slightly smaller).
    
    Also while at it fix up white space in a couple of places and make
    cpufreq_set_policy() static (as it can be so).
    
    Fixes: 3000ce3c52f8 ("cpufreq: Use per-policy frequency QoS")
    Link: https://lore.kernel.org/linux-pm/CAMuHMdX6-jb1W8uC2_237m8ctCpsnGp=JCxqt8pCWVqNXHmkVg@mail.gmail.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 31b1b0e03df8..018dce868de6 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -148,6 +148,20 @@ struct cpufreq_policy {
 	struct notifier_block nb_max;
 };
 
+/*
+ * Used for passing new cpufreq policy data to the cpufreq driver's ->verify()
+ * callback for sanitization.  That callback is only expected to modify the min
+ * and max values, if necessary, and specifically it must not update the
+ * frequency table.
+ */
+struct cpufreq_policy_data {
+	struct cpufreq_cpuinfo		cpuinfo;
+	struct cpufreq_frequency_table	*freq_table;
+	unsigned int			cpu;
+	unsigned int			min;    /* in kHz */
+	unsigned int			max;    /* in kHz */
+};
+
 struct cpufreq_freqs {
 	struct cpufreq_policy *policy;
 	unsigned int old;
@@ -201,8 +215,6 @@ u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 struct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu);
 void cpufreq_cpu_release(struct cpufreq_policy *policy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
-int cpufreq_set_policy(struct cpufreq_policy *policy,
-		       struct cpufreq_policy *new_policy);
 void refresh_frequency_limits(struct cpufreq_policy *policy);
 void cpufreq_update_policy(unsigned int cpu);
 void cpufreq_update_limits(unsigned int cpu);
@@ -284,7 +296,7 @@ struct cpufreq_driver {
 
 	/* needed by all drivers */
 	int		(*init)(struct cpufreq_policy *policy);
-	int		(*verify)(struct cpufreq_policy *policy);
+	int		(*verify)(struct cpufreq_policy_data *policy);
 
 	/* define one out of two */
 	int		(*setpolicy)(struct cpufreq_policy *policy);
@@ -415,8 +427,9 @@ static inline int cpufreq_thermal_control_enabled(struct cpufreq_driver *drv)
 		(drv->flags & CPUFREQ_IS_COOLING_DEV);
 }
 
-static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
-		unsigned int min, unsigned int max)
+static inline void cpufreq_verify_within_limits(struct cpufreq_policy_data *policy,
+						unsigned int min,
+						unsigned int max)
 {
 	if (policy->min < min)
 		policy->min = min;
@@ -432,10 +445,10 @@ static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 }
 
 static inline void
-cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
+cpufreq_verify_within_cpu_limits(struct cpufreq_policy_data *policy)
 {
 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
-			policy->cpuinfo.max_freq);
+				     policy->cpuinfo.max_freq);
 }
 
 #ifdef CONFIG_CPU_FREQ
@@ -513,6 +526,7 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
  *                          CPUFREQ GOVERNORS                        *
  *********************************************************************/
 
+#define CPUFREQ_POLICY_UNKNOWN		(0)
 /*
  * If (cpufreq_driver->target) exists, the ->governor decides what frequency
  * within the limits is used. If (cpufreq_driver->setpolicy> exists, these
@@ -684,9 +698,9 @@ static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
 int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 				    struct cpufreq_frequency_table *table);
 
-int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
+int cpufreq_frequency_table_verify(struct cpufreq_policy_data *policy,
 				   struct cpufreq_frequency_table *table);
-int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy);
+int cpufreq_generic_frequency_table_verify(struct cpufreq_policy_data *policy);
 
 int cpufreq_table_index_unsorted(struct cpufreq_policy *policy,
 				 unsigned int target_freq,

commit 85572c2c4a45a541e880e087b5b17a48198b2416
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Dec 11 11:28:41 2019 +0100

    cpufreq: Avoid leaving stale IRQ work items during CPU offline
    
    The scheduler code calling cpufreq_update_util() may run during CPU
    offline on the target CPU after the IRQ work lists have been flushed
    for it, so the target CPU should be prevented from running code that
    may queue up an IRQ work item on it at that point.
    
    Unfortunately, that may not be the case if dvfs_possible_from_any_cpu
    is set for at least one cpufreq policy in the system, because that
    allows the CPU going offline to run the utilization update callback
    of the cpufreq governor on behalf of another (online) CPU in some
    cases.
    
    If that happens, the cpufreq governor callback may queue up an IRQ
    work on the CPU running it, which is going offline, and the IRQ work
    may not be flushed after that point.  Moreover, that IRQ work cannot
    be flushed until the "offlining" CPU goes back online, so if any
    other CPU calls irq_work_sync() to wait for the completion of that
    IRQ work, it will have to wait until the "offlining" CPU is back
    online and that may not happen forever.  In particular, a system-wide
    deadlock may occur during CPU online as a result of that.
    
    The failing scenario is as follows.  CPU0 is the boot CPU, so it
    creates a cpufreq policy and becomes the "leader" of it
    (policy->cpu).  It cannot go offline, because it is the boot CPU.
    Next, other CPUs join the cpufreq policy as they go online and they
    leave it when they go offline.  The last CPU to go offline, say CPU3,
    may queue up an IRQ work while running the governor callback on
    behalf of CPU0 after leaving the cpufreq policy because of the
    dvfs_possible_from_any_cpu effect described above.  Then, CPU0 is
    the only online CPU in the system and the stale IRQ work is still
    queued on CPU3.  When, say, CPU1 goes back online, it will run
    irq_work_sync() to wait for that IRQ work to complete and so it
    will wait for CPU3 to go back online (which may never happen even
    in principle), but (worse yet) CPU0 is waiting for CPU1 at that
    point too and a system-wide deadlock occurs.
    
    To address this problem notice that CPUs which cannot run cpufreq
    utilization update code for themselves (for example, because they
    have left the cpufreq policies that they belonged to), should also
    be prevented from running that code on behalf of the other CPUs that
    belong to a cpufreq policy with dvfs_possible_from_any_cpu set and so
    in that case the cpufreq_update_util_data pointer of the CPU running
    the code must not be NULL as well as for the CPU which is the target
    of the cpufreq utilization update in progress.
    
    Accordingly, change cpufreq_this_cpu_can_update() into a regular
    function in kernel/sched/cpufreq.c (instead of a static inline in a
    header file) and make it check the cpufreq_update_util_data pointer
    of the local CPU if dvfs_possible_from_any_cpu is set for the target
    cpufreq policy.
    
    Also update the schedutil governor to do the
    cpufreq_this_cpu_can_update() check in the non-fast-switch
    case too to avoid the stale IRQ work issues.
    
    Fixes: 99d14d0e16fa ("cpufreq: Process remote callbacks from any CPU if the platform permits")
    Link: https://lore.kernel.org/linux-pm/20191121093557.bycvdo4xyinbc5cb@vireshk-i7/
    Reported-by: Anson Huang <anson.huang@nxp.com>
    Tested-by: Anson Huang <anson.huang@nxp.com>
    Cc: 4.14+ <stable@vger.kernel.org> # 4.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Peng Fan <peng.fan@nxp.com> (i.MX8QXP-MEK)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 92d5fdc8154e..31b1b0e03df8 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -595,17 +595,6 @@ struct governor_attr {
 			 size_t count);
 };
 
-static inline bool cpufreq_this_cpu_can_update(struct cpufreq_policy *policy)
-{
-	/*
-	 * Allow remote callbacks if:
-	 * - dvfs_possible_from_any_cpu flag is set
-	 * - the local and remote CPUs share cpufreq policy
-	 */
-	return policy->dvfs_possible_from_any_cpu ||
-		cpumask_test_cpu(smp_processor_id(), policy->cpus);
-}
-
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/

commit 3000ce3c52f8b8db093e4dc649cd172390f71137
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 16 12:47:06 2019 +0200

    cpufreq: Use per-policy frequency QoS
    
    Replace the CPU device PM QoS used for the management of min and max
    frequency constraints in cpufreq (and its users) with per-policy
    frequency QoS to avoid problems with cpufreq policies covering
    more then one CPU.
    
    Namely, a cpufreq driver is registered with the subsys interface
    which calls cpufreq_add_dev() for each CPU, starting from CPU0, so
    currently the PM QoS notifiers are added to the first CPU in the
    policy (i.e. CPU0 in the majority of cases).
    
    In turn, when the cpufreq driver is unregistered, the subsys interface
    doing that calls cpufreq_remove_dev() for each CPU, starting from CPU0,
    and the PM QoS notifiers are only removed when cpufreq_remove_dev() is
    called for the last CPU in the policy, say CPUx, which as a rule is
    not CPU0 if the policy covers more than one CPU.  Then, the PM QoS
    notifiers cannot be removed, because CPUx does not have them, and
    they are still there in the device PM QoS notifiers list of CPU0,
    which prevents new PM QoS notifiers from being registered for CPU0
    on the next attempt to register the cpufreq driver.
    
    The same issue occurs when the first CPU in the policy goes offline
    before unregistering the driver.
    
    After this change it does not matter which CPU is the policy CPU at
    the driver registration time and whether or not it is online all the
    time, because the frequency QoS is per policy and not per CPU.
    
    Fixes: 67d874c3b2c6 ("cpufreq: Register notifiers with the PM QoS framework")
    Reported-by: Dmitry Osipenko <digetx@gmail.com>
    Tested-by: Dmitry Osipenko <digetx@gmail.com>
    Reported-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Diagnosed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Link: https://lore.kernel.org/linux-pm/5ad2624194baa2f53acc1f1e627eb7684c577a19.1562210705.git.viresh.kumar@linaro.org/T/#md2d89e95906b8c91c15f582146173dce2e86e99f
    Link: https://lore.kernel.org/linux-pm/20191017094612.6tbkwoq4harsjcqv@vireshk-i7/T/#m30d48cc23b9a80467fbaa16e30f90b3828a5a29b
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c57e88e85c41..92d5fdc8154e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -13,6 +13,7 @@
 #include <linux/completion.h>
 #include <linux/kobject.h>
 #include <linux/notifier.h>
+#include <linux/pm_qos.h>
 #include <linux/spinlock.h>
 #include <linux/sysfs.h>
 
@@ -76,8 +77,10 @@ struct cpufreq_policy {
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
 
-	struct dev_pm_qos_request *min_freq_req;
-	struct dev_pm_qos_request *max_freq_req;
+	struct freq_constraints	constraints;
+	struct freq_qos_request	*min_freq_req;
+	struct freq_qos_request	*max_freq_req;
+
 	struct cpufreq_frequency_table	*freq_table;
 	enum cpufreq_table_sorting freq_table_sorted;
 

commit df0eea4488081e0698b0b58ccd1e8c8823e22841
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 23 11:44:09 2019 +0530

    cpufreq: Remove CPUFREQ_ADJUST and CPUFREQ_NOTIFY policy notifier events
    
    No driver makes reference to these events now, remove them and the code
    related to them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index afc10384a681..c57e88e85c41 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -456,10 +456,8 @@ static inline void cpufreq_resume(void) {}
 #define CPUFREQ_POSTCHANGE		(1)
 
 /* Policy Notifiers  */
-#define CPUFREQ_ADJUST			(0)
-#define CPUFREQ_NOTIFY			(1)
-#define CPUFREQ_CREATE_POLICY		(2)
-#define CPUFREQ_REMOVE_POLICY		(3)
+#define CPUFREQ_CREATE_POLICY		(0)
+#define CPUFREQ_REMOVE_POLICY		(1)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit 6a1490367c44f94614e39e8b98ff7114ff8a6449
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 23 11:44:01 2019 +0530

    cpufreq: Add policy create/remove notifiers back
    
    This effectively reverts some changes made by commit f9f41e3ef99
    ("cpufreq: Remove policy create/remove notifiers").
    
    We have a new use case for policy create/remove notifiers (for
    allocating/freeing QoS requests per policy), so add them back.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 536a049d7ecc..afc10384a681 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -458,6 +458,8 @@ static inline void cpufreq_resume(void) {}
 /* Policy Notifiers  */
 #define CPUFREQ_ADJUST			(0)
 #define CPUFREQ_NOTIFY			(1)
+#define CPUFREQ_CREATE_POLICY		(2)
+#define CPUFREQ_REMOVE_POLICY		(3)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit 918e162e6a71e924a343b41f71789ad14e1e3229
Merge: 8da04e05cdfc c4dcc8a16278
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 18 09:49:30 2019 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq:
      cpufreq: Make cpufreq_generic_init() return void
      cpufreq: imx-cpufreq-dt: Add i.MX8MN support
      cpufreq: Add QoS requests for userspace constraints
      cpufreq: intel_pstate: Reuse refresh_frequency_limits()
      cpufreq: Register notifiers with the PM QoS framework
      PM / QoS: Add support for MIN/MAX frequency constraints
      PM / QOS: Pass request type to dev_pm_qos_read_value()
      PM / QOS: Rename __dev_pm_qos_read_value() and dev_pm_qos_raw_read_value()
      PM / QOS: Pass request type to dev_pm_qos_{add|remove}_notifier()

commit c4dcc8a162784c1f827c7f6d8409598f19708fe6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 16 09:36:08 2019 +0530

    cpufreq: Make cpufreq_generic_init() return void
    
    It always returns 0 (success) and its return type should really be void.
    
    Over that, many drivers have added error handling code based on its
    return value, which is not required at all.
    
    Change its return type to void and update all the callers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index afc683021ac5..441ff15b7768 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -995,7 +995,7 @@ extern struct freq_attr *cpufreq_generic_attr[];
 int cpufreq_table_validate_and_sort(struct cpufreq_policy *policy);
 
 unsigned int cpufreq_generic_get(unsigned int cpu);
-int cpufreq_generic_init(struct cpufreq_policy *policy,
+void cpufreq_generic_init(struct cpufreq_policy *policy,
 		struct cpufreq_frequency_table *table,
 		unsigned int transition_latency);
 #endif /* _LINUX_CPUFREQ_H */

commit 18c49926c4bf4915e5194d1de3299c0537229f9f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 5 16:21:24 2019 +0530

    cpufreq: Add QoS requests for userspace constraints
    
    This implements QoS requests to manage userspace configuration of min
    and max frequency.
    
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: syzbot <syzbot+de771ae9390dffed7266@syzkaller.appspotmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1fa37b675a80..afc683021ac5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -50,11 +50,6 @@ struct cpufreq_cpuinfo {
 	unsigned int		transition_latency;
 };
 
-struct cpufreq_user_policy {
-	unsigned int		min;    /* in kHz */
-	unsigned int		max;    /* in kHz */
-};
-
 struct cpufreq_policy {
 	/* CPUs sharing clock, require sw coordination */
 	cpumask_var_t		cpus;	/* Online CPUs only */
@@ -84,7 +79,8 @@ struct cpufreq_policy {
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
 
-	struct cpufreq_user_policy user_policy;
+	struct dev_pm_qos_request *min_freq_req;
+	struct dev_pm_qos_request *max_freq_req;
 	struct cpufreq_frequency_table	*freq_table;
 	enum cpufreq_table_sorting freq_table_sorted;
 

commit c57b25bdf7cd374af106992356536bf5df7c255b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 4 13:06:22 2019 +0530

    cpufreq: intel_pstate: Reuse refresh_frequency_limits()
    
    The implementation of intel_pstate_update_max_freq() is quite similar to
    refresh_frequency_limits(), lets reuse it.
    
    Finding minimum of policy->user_policy.max and policy->cpuinfo.max_freq
    in intel_pstate_update_max_freq() is redundant as cpufreq_set_policy()
    will call the ->verify() callback of intel-pstate driver, which will do
    this comparison anyway and so dropping it from
    intel_pstate_update_max_freq() doesn't harm.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 95425941f46d..1fa37b675a80 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -207,6 +207,7 @@ void cpufreq_cpu_release(struct cpufreq_policy *policy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_set_policy(struct cpufreq_policy *policy,
 		       struct cpufreq_policy *new_policy);
+void refresh_frequency_limits(struct cpufreq_policy *policy);
 void cpufreq_update_policy(unsigned int cpu);
 void cpufreq_update_limits(unsigned int cpu);
 bool have_governor_per_policy(void);

commit 67d874c3b2c69d65274fa5ce44ba939788d5729d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 8 16:27:52 2019 +0530

    cpufreq: Register notifiers with the PM QoS framework
    
    Register notifiers for min/max frequency constraints with the PM QoS
    framework. The constraints are also taken into consideration in
    cpufreq_set_policy().
    
    This also relocates cpufreq_policy_put_kobj() as it is required to be
    called from cpufreq_policy_alloc() now.
    
    refresh_frequency_limits() is updated to avoid calling
    cpufreq_set_policy() for inactive policies and handle_update() is
    updated to have proper locking in place.
    
    No constraints are added until now though.
    
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a1467aa7f58b..95425941f46d 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -147,6 +147,9 @@ struct cpufreq_policy {
 
 	/* Pointer to the cooling device if used for thermal mitigation */
 	struct thermal_cooling_device *cdev;
+
+	struct notifier_block nb_min;
+	struct notifier_block nb_max;
 };
 
 struct cpufreq_freqs {

commit 586a07dca8c51b966960d1f0d8be9c27d7e0a95c
Merge: 13b06b78c772 70a59fde6e69
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 11:00:02 2019 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq:
      cpufreq: Avoid calling cpufreq_verify_current_freq() from handle_update()
      cpufreq: Consolidate cpufreq_update_current_freq() and __cpufreq_get()
      cpufreq: Don't skip frequency validation for has_target() drivers
      cpufreq: Use has_target() instead of !setpolicy
      cpufreq: Remove redundant !setpolicy check
      cpufreq: Move the IS_ENABLED(CPU_THERMAL) macro into a stub
      cpufreq: s5pv210: Don't flood kernel log after cpufreq change
      cpufreq: pcc-cpufreq: Fail initialization if driver cannot be registered
      cpufreq: add driver for Raspberry Pi
      cpufreq: Switch imx7d to imx-cpufreq-dt for speed grading
      cpufreq: imx-cpufreq-dt: Remove global platform match list
      cpufreq: brcmstb-avs-cpufreq: Fix types for voltage/frequency
      cpufreq: brcmstb-avs-cpufreq: Fix initial command check
      cpufreq: armada-37xx: Remove set but not used variable 'freq'
      cpufreq: imx-cpufreq-dt: Fix no OPPs available on unfused parts
      dt-bindings: imx-cpufreq-dt: Document opp-supported-hw usage
      cpufreq: Add imx-cpufreq-dt driver

commit bcc61569997b2188ba89db43b5b991da01ea2d18
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Jun 25 13:32:41 2019 +0200

    cpufreq: Move the IS_ENABLED(CPU_THERMAL) macro into a stub
    
    cpufreq_online() and cpufreq_offline() [un]register the driver as
    a cooling device. This is done if the driver is flagged as a cooling
    device in addition with an IS_ENABLED() check to compile out the branching
    code.
    
    Group this test in a stub function added in the cpufreq header instead
    of having the IS_ENABLED() in the code.
    
    Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d01a74fbc4db..a1467aa7f58b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -409,6 +409,12 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 const char *cpufreq_get_current_driver(void);
 void *cpufreq_get_driver_data(void);
 
+static inline int cpufreq_thermal_control_enabled(struct cpufreq_driver *drv)
+{
+	return IS_ENABLED(CONFIG_CPU_THERMAL) &&
+		(drv->flags & CPUFREQ_IS_COOLING_DEV);
+}
+
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 		unsigned int min, unsigned int max)
 {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d01a74fbc4db..32a1733014f5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * linux/include/linux/cpufreq.h
  *
  * Copyright (C) 2001 Russell King
  *           (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef _LINUX_CPUFREQ_H
 #define _LINUX_CPUFREQ_H

commit df24014abe3694e7c34ce5e50248611b7a93fe83
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Apr 29 15:03:58 2019 +0530

    cpufreq: Call transition notifier only once for each policy
    
    Currently, the notifiers are called once for each CPU of the policy->cpus
    cpumask. It would be more optimal if the notifier can be called only
    once and all the relevant information be provided to it. Out of the 23
    drivers that register for the transition notifiers today, only 4 of them
    do per-cpu updates and the callback for the rest can be called only once
    for the policy without any impact.
    
    This would also avoid multiple function calls to the notifier callbacks
    and reduce multiple iterations of notifier core's code (which does
    locking as well).
    
    This patch adds pointer to the cpufreq policy to the struct
    cpufreq_freqs, so the notifier callback has all the information
    available to it with a single call. The five drivers which perform
    per-cpu updates are updated to use the cpufreq policy. The freqs->cpu
    field is redundant now and is removed.
    
    Acked-by: David S. Miller <davem@davemloft.net> (sparc)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 684caf067003..d01a74fbc4db 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -42,13 +42,6 @@ enum cpufreq_table_sorting {
 	CPUFREQ_TABLE_SORTED_DESCENDING
 };
 
-struct cpufreq_freqs {
-	unsigned int cpu;	/* cpu nr */
-	unsigned int old;
-	unsigned int new;
-	u8 flags;		/* flags of cpufreq_driver, see below. */
-};
-
 struct cpufreq_cpuinfo {
 	unsigned int		max_freq;
 	unsigned int		min_freq;
@@ -156,6 +149,13 @@ struct cpufreq_policy {
 	struct thermal_cooling_device *cdev;
 };
 
+struct cpufreq_freqs {
+	struct cpufreq_policy *policy;
+	unsigned int old;
+	unsigned int new;
+	u8 flags;		/* flags of cpufreq_driver, see below. */
+};
+
 /* Only for ACPI */
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */

commit 9083e4986124389e2a7c0ffca95630a4983887f0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 26 12:19:52 2019 +0100

    cpufreq: intel_pstate: Update max frequency on global turbo changes
    
    While the cpuinfo.max_freq value doesn't really matter for
    intel_pstate in the active mode, in the passive mode it is used by
    governors as the maximum physical frequency of the CPU and the
    results of governor computations generally depend on it.  Also it
    is made available to user space via sysfs and it should match the
    current HW configuration.
    
    For this reason, make intel_pstate update cpuinfo.max_freq for all
    CPUs if it detects a global change of turbo frequency settings from
    "disable" to "enable" or the other way associated with a _PPC change
    notification from the platform firmware.
    
    Note that policy_is_inactive(),  cpufreq_cpu_acquire(),
    cpufreq_cpu_release(), and cpufreq_set_policy() need to be made
    available to it for this purpose.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200759
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5005ea40364f..684caf067003 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -178,6 +178,11 @@ static inline struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
 static inline void cpufreq_cpu_put(struct cpufreq_policy *policy) { }
 #endif
 
+static inline bool policy_is_inactive(struct cpufreq_policy *policy)
+{
+	return cpumask_empty(policy->cpus);
+}
+
 static inline bool policy_is_shared(struct cpufreq_policy *policy)
 {
 	return cpumask_weight(policy->cpus) > 1;
@@ -193,7 +198,12 @@ unsigned int cpufreq_quick_get_max(unsigned int cpu);
 void disable_cpufreq(void);
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
+
+struct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu);
+void cpufreq_cpu_release(struct cpufreq_policy *policy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
+int cpufreq_set_policy(struct cpufreq_policy *policy,
+		       struct cpufreq_policy *new_policy);
 void cpufreq_update_policy(unsigned int cpu);
 void cpufreq_update_limits(unsigned int cpu);
 bool have_governor_per_policy(void);

commit 5a25e3f7cc538fb49e11267c1e41c54ccf83835e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 26 12:15:13 2019 +0100

    cpufreq: intel_pstate: Driver-specific handling of _PPC updates
    
    In some cases, the platform firmware disables or enables turbo
    frequencies for all CPUs globally before triggering a _PPC change
    notification for one of them.  Obviously, that global change affects
    all CPUs, not just the notified one, and it needs to be acted upon by
    cpufreq.
    
    The intel_pstate driver is able to detect such global changes of
    the settings, but it also needs to update policy limits for all
    CPUs if that happens, in particular if turbo frequencies are
    enabled globally - to allow them to be used.
    
    For this reason, introduce a new cpufreq driver callback to be
    invoked on _PPC notifications, if present, instead of simply
    calling cpufreq_update_policy() for the notified CPU and make
    intel_pstate use it to trigger policy updates for all CPUs
    in the system if global settings change.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200759
    Reported-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b160e98076e3..5005ea40364f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -195,6 +195,7 @@ void disable_cpufreq(void);
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 void cpufreq_update_policy(unsigned int cpu);
+void cpufreq_update_limits(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 void cpufreq_enable_fast_switch(struct cpufreq_policy *policy);
@@ -322,6 +323,9 @@ struct cpufreq_driver {
 	/* should be defined, if possible */
 	unsigned int	(*get)(unsigned int cpu);
 
+	/* Called to update policy limits on firmware notifications. */
+	void		(*update_limits)(unsigned int cpu);
+
 	/* optional */
 	int		(*bios_limit)(int cpu, unsigned int *limit);
 

commit 91a12e91dc39137906d929a4ff6f9c32c59697fa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 12 16:36:04 2019 +0530

    cpufreq: Allow light-weight tear down and bring up of CPUs
    
    The cpufreq core doesn't remove the cpufreq policy anymore on CPU
    offline operation, rather that happens when the CPU device gets
    unregistered from the kernel. This allows faster recovery when the CPU
    comes back online. This is also very useful during system wide
    suspend/resume where we offline all non-boot CPUs during suspend and
    then bring them back on resume.
    
    This commit takes the same idea a step ahead to allow drivers to do
    light weight tear-down and bring-up during CPU offline and online
    operations.
    
    A new set of callbacks is introduced, online/offline(). online() gets
    called when the first CPU of an inactive policy is brought up and
    offline() gets called when all the CPUs of a policy are offlined.
    
    The existing init/exit() callback get called on policy
    creation/destruction. They also get called instead of online/offline()
    callbacks if the online/offline() callbacks aren't provided.
    
    This also moves around some code to get executed only for the new-policy
    case going forward.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9db074ecbbd7..b160e98076e3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -325,6 +325,8 @@ struct cpufreq_driver {
 	/* optional */
 	int		(*bios_limit)(int cpu, unsigned int *limit);
 
+	int		(*online)(struct cpufreq_policy *policy);
+	int		(*offline)(struct cpufreq_policy *policy);
 	int		(*exit)(struct cpufreq_policy *policy);
 	void		(*stop_cpu)(struct cpufreq_policy *policy);
 	int		(*suspend)(struct cpufreq_policy *policy);

commit 5c238a8b599f1ae25eaeb08ad0e9e13e2b9eb023
Author: Amit Kucheria <amit.kucheria@linaro.org>
Date:   Wed Jan 30 10:52:01 2019 +0530

    cpufreq: Auto-register the driver as a thermal cooling device if asked
    
    All cpufreq drivers do similar things to register as a cooling device.
    Provide a cpufreq driver flag so drivers can just ask the cpufreq core
    to register the cooling device on their behalf. This allows us to get
    rid of duplicated code in the drivers.
    
    In order to allow this, we add a struct thermal_cooling_device pointer
    to struct cpufreq_policy so that drivers don't need to store it in a
    private data structure.
    
    Suggested-by: Stephen Boyd <swboyd@chromium.org>
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Amit Kucheria <amit.kucheria@linaro.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c19142911554..9db074ecbbd7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -151,6 +151,9 @@ struct cpufreq_policy {
 
 	/* For cpufreq driver's internal use */
 	void			*driver_data;
+
+	/* Pointer to the cooling device if used for thermal mitigation */
+	struct thermal_cooling_device *cdev;
 };
 
 /* Only for ACPI */
@@ -378,6 +381,12 @@ struct cpufreq_driver {
  */
 #define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING	BIT(6)
 
+/*
+ * Set by drivers that want the core to automatically register the cpufreq
+ * driver as a thermal cooling device.
+ */
+#define CPUFREQ_IS_COOLING_DEV			BIT(7)
+
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 

commit 625c85a62cb7d3c79f6e16de3cfa972033658250
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jan 25 12:53:07 2019 +0530

    cpufreq: Use struct kobj_attribute instead of struct global_attr
    
    The cpufreq_global_kobject is created using kobject_create_and_add()
    helper, which assigns the kobj_type as dynamic_kobj_ktype and show/store
    routines are set to kobj_attr_show() and kobj_attr_store().
    
    These routines pass struct kobj_attribute as an argument to the
    show/store callbacks. But all the cpufreq files created using the
    cpufreq_global_kobject expect the argument to be of type struct
    attribute. Things work fine currently as no one accesses the "attr"
    argument. We may not see issues even if the argument is used, as struct
    kobj_attribute has struct attribute as its first element and so they
    will both get same address.
    
    But this is logically incorrect and we should rather use struct
    kobj_attribute instead of struct global_attr in the cpufreq core and
    drivers and the show/store callbacks should take struct kobj_attribute
    as argument instead.
    
    This bug is caught using CFI CLANG builds in android kernel which
    catches mismatch in function prototypes for such callbacks.
    
    Reported-by: Donghee Han <dh.han@samsung.com>
    Reported-by: Sangkyu Kim <skwith.kim@samsung.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bd7fbd6a4478..c19142911554 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -254,20 +254,12 @@ __ATTR(_name, 0644, show_##_name, store_##_name)
 static struct freq_attr _name =			\
 __ATTR(_name, 0200, NULL, store_##_name)
 
-struct global_attr {
-	struct attribute attr;
-	ssize_t (*show)(struct kobject *kobj,
-			struct attribute *attr, char *buf);
-	ssize_t (*store)(struct kobject *a, struct attribute *b,
-			 const char *c, size_t count);
-};
-
 #define define_one_global_ro(_name)		\
-static struct global_attr _name =		\
+static struct kobj_attribute _name =		\
 __ATTR(_name, 0444, show_##_name, NULL)
 
 #define define_one_global_rw(_name)		\
-static struct global_attr _name =		\
+static struct kobj_attribute _name =		\
 __ATTR(_name, 0644, show_##_name, store_##_name)
 
 

commit 8321be6a9df5c5cfbf3fb5f716caf8698a5a7016
Author: Amit Kucheria <amit.kucheria@linaro.org>
Date:   Mon Jan 21 14:17:37 2019 +0530

    cpufreq: Replace open-coded << with BIT()
    
    Minor clean-up to use BIT() and keep checkpatch happy. Clean up the
    comment formatting while we're at it to make it easier to read.
    
    Signed-off-by: Amit Kucheria <amit.kucheria@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c86d6d8bdfed..bd7fbd6a4478 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -346,14 +346,15 @@ struct cpufreq_driver {
 };
 
 /* flags */
-#define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
-						   all ->init() calls failed */
-#define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
-						   kernel "constants" aren't
-						   affected by frequency
-						   transitions */
-#define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
-						   speed mismatches */
+
+/* driver isn't removed even if all ->init() calls failed */
+#define CPUFREQ_STICKY				BIT(0)
+
+/* loops_per_jiffy or other kernel "constants" aren't affected by frequency transitions */
+#define CPUFREQ_CONST_LOOPS			BIT(1)
+
+/* don't warn on suspend/resume speed mismatches */
+#define CPUFREQ_PM_NO_WARN			BIT(2)
 
 /*
  * This should be set by platforms having multiple clock-domains, i.e.
@@ -361,14 +362,14 @@ struct cpufreq_driver {
  * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
  * governor with different tunables for different clusters.
  */
-#define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+#define CPUFREQ_HAVE_GOVERNOR_PER_POLICY	BIT(3)
 
 /*
  * Driver will do POSTCHANGE notifications from outside of their ->target()
  * routine and so must set cpufreq_driver->flags with this flag, so that core
  * can handle them specially.
  */
-#define CPUFREQ_ASYNC_NOTIFICATION  (1 << 4)
+#define CPUFREQ_ASYNC_NOTIFICATION		BIT(4)
 
 /*
  * Set by drivers which want cpufreq core to check if CPU is running at a
@@ -377,13 +378,13 @@ struct cpufreq_driver {
  * from the table. And if that fails, we will stop further boot process by
  * issuing a BUG_ON().
  */
-#define CPUFREQ_NEED_INITIAL_FREQ_CHECK	(1 << 5)
+#define CPUFREQ_NEED_INITIAL_FREQ_CHECK	BIT(5)
 
 /*
  * Set by drivers to disallow use of governors with "dynamic_switching" flag
  * set.
  */
-#define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING (1 << 6)
+#define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING	BIT(6)
 
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);

commit 531b5c9f5cd05ead53324f419b32685a22eebe8b
Author: Quentin Perret <quentin.perret@arm.com>
Date:   Mon Dec 3 09:56:21 2018 +0000

    sched/topology: Make Energy Aware Scheduling depend on schedutil
    
    Energy Aware Scheduling (EAS) is designed with the assumption that
    frequencies of CPUs follow their utilization value. When using a CPUFreq
    governor other than schedutil, the chances of this assumption being true
    are small, if any. When schedutil is being used, EAS' predictions are at
    least consistent with the frequency requests. Although those requests
    have no guarantees to be honored by the hardware, they should at least
    guide DVFS in the right direction and provide some hope in regards to the
    EAS model being accurate.
    
    To make sure EAS is only used in a sane configuration, create a strong
    dependency on schedutil being used. Since having sugov compiled-in does
    not provide that guarantee, make CPUFreq call a scheduler function on
    governor changes hence letting it rebuild the scheduling domains, check
    the governors of the online CPUs, and enable/disable EAS accordingly.
    
    Signed-off-by: Quentin Perret <quentin.perret@arm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: adharmap@codeaurora.org
    Cc: chris.redpath@arm.com
    Cc: currojerez@riseup.net
    Cc: dietmar.eggemann@arm.com
    Cc: edubezval@gmail.com
    Cc: gregkh@linuxfoundation.org
    Cc: javi.merino@kernel.org
    Cc: joel@joelfernandes.org
    Cc: juri.lelli@redhat.com
    Cc: morten.rasmussen@arm.com
    Cc: patrick.bellasi@arm.com
    Cc: pkondeti@codeaurora.org
    Cc: skannan@codeaurora.org
    Cc: smuckle@google.com
    Cc: srinivas.pandruvada@linux.intel.com
    Cc: thara.gopinath@linaro.org
    Cc: tkjos@google.com
    Cc: valentin.schneider@arm.com
    Cc: vincent.guittot@linaro.org
    Cc: viresh.kumar@linaro.org
    Link: https://lkml.kernel.org/r/20181203095628.11858-9-quentin.perret@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 882a9b9e34bc..c86d6d8bdfed 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -950,6 +950,14 @@ static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
 }
 #endif
 
+#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)
+void sched_cpufreq_governor_change(struct cpufreq_policy *policy,
+			struct cpufreq_governor *old_gov);
+#else
+static inline void sched_cpufreq_governor_change(struct cpufreq_policy *policy,
+			struct cpufreq_governor *old_gov) { }
+#endif
+
 extern void arch_freq_prepare_all(void);
 extern unsigned int arch_freq_get_on_cpu(int cpu);
 

commit 036399782bf51dafb932b680b260936b2b5f8dd6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue May 22 15:31:30 2018 +0530

    cpufreq: Rename cpufreq_can_do_remote_dvfs()
    
    This routine checks if the CPU running this code belongs to the policy
    of the target CPU or if not, can it do remote DVFS for it remotely. But
    the current name of it implies as if it is only about doing remote
    updates.
    
    Rename it to make it more relevant.
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 87f48dd932eb..882a9b9e34bc 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -571,7 +571,7 @@ struct governor_attr {
 			 size_t count);
 };
 
-static inline bool cpufreq_can_do_remote_dvfs(struct cpufreq_policy *policy)
+static inline bool cpufreq_this_cpu_can_update(struct cpufreq_policy *policy)
 {
 	/*
 	 * Allow remote callbacks if:

commit 2dd0df8472ff9bb520673cb5862b08be9290c9fa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 3 15:37:39 2018 +0530

    cpufreq: Drop cpufreq_table_validate_and_show()
    
    This isn't used anymore. Remove the helper and update documentation
    accordingly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1fe49724da9e..87f48dd932eb 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -960,8 +960,6 @@ extern void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 extern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;
 extern struct freq_attr *cpufreq_generic_attr[];
-int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
-				      struct cpufreq_frequency_table *table);
 int cpufreq_table_validate_and_sort(struct cpufreq_policy *policy);
 
 unsigned int cpufreq_generic_get(unsigned int cpu);

commit d417e0691ac00d35c4e6b90fc3fc85631a7865ad
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Feb 22 11:29:44 2018 +0530

    cpufreq: Validate frequency table in the core
    
    By design, cpufreq drivers are responsible for calling
    cpufreq_frequency_table_cpuinfo() from their ->init()
    callbacks to validate the frequency table.
    
    However, if a cpufreq driver is buggy and fails to do so properly, it
    lead to unexpected behavior of the driver or the cpufreq core at a
    later point in time.  It would be better if the core could
    validate the frequency table during driver initialization.
    
    To that end, introduce cpufreq_table_validate_and_sort() and make
    the cpufreq core call it right after invoking the ->init() callback
    of the driver and destroy the cpufreq policy if the table is invalid.
    
    For the time being the validation of the table happens twice, once
    from the driver and then from the core.  The individual drivers will
    be updated separately to drop table validation if they don't need it
    for other reasons.
    
    The frequency table is marked "sorted" or "unsorted" by the new helper
    now instead of in cpufreq_table_validate_and_show(), as it should only
    be done after validating the table (which the drivers won't do going
    forward).
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject/changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 21e8d248d956..1fe49724da9e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -962,6 +962,7 @@ extern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;
 extern struct freq_attr *cpufreq_generic_attr[];
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);
+int cpufreq_table_validate_and_sort(struct cpufreq_policy *policy);
 
 unsigned int cpufreq_generic_get(unsigned int cpu);
 int cpufreq_generic_init(struct cpufreq_policy *policy,

commit ffd81dcfef85a33729f90e4acd2f61a68e56b993
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Jan 30 06:42:37 2018 +0100

    cpufreq: Add and use cpufreq_for_each_{valid_,}entry_idx()
    
    Pointer subtraction is slow and tedious. Therefore, replace all instances
    where cpufreq_for_each_{valid_,}entry loops contained such substractions
    with an iteration macro providing an index to the frequency_table entry.
    
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Link: http://lkml.kernel.org/r/20180120020237.GM13338@ZenIV.linux.org.uk
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 065f3a8eb486..21e8d248d956 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -628,6 +628,18 @@ static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
 #define cpufreq_for_each_entry(pos, table)	\
 	for (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)
 
+/*
+ * cpufreq_for_each_entry_idx -	iterate over a cpufreq_frequency_table
+ *	with index
+ * @pos:	the cpufreq_frequency_table * to use as a loop cursor.
+ * @table:	the cpufreq_frequency_table * to iterate over.
+ * @idx:	the table entry currently being processed
+ */
+
+#define cpufreq_for_each_entry_idx(pos, table, idx)	\
+	for (pos = table, idx = 0; pos->frequency != CPUFREQ_TABLE_END; \
+		pos++, idx++)
+
 /*
  * cpufreq_for_each_valid_entry -     iterate over a cpufreq_frequency_table
  *	excluding CPUFREQ_ENTRY_INVALID frequencies.
@@ -641,6 +653,21 @@ static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
 			continue;					\
 		else
 
+/*
+ * cpufreq_for_each_valid_entry_idx -     iterate with index over a cpufreq
+ *	frequency_table excluding CPUFREQ_ENTRY_INVALID frequencies.
+ * @pos:	the cpufreq_frequency_table * to use as a loop cursor.
+ * @table:	the cpufreq_frequency_table * to iterate over.
+ * @idx:	the table entry currently being processed
+ */
+
+#define cpufreq_for_each_valid_entry_idx(pos, table, idx)		\
+	cpufreq_for_each_entry_idx(pos, table, idx)			\
+		if (pos->frequency == CPUFREQ_ENTRY_INVALID)		\
+			continue;					\
+		else
+
+
 int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 				    struct cpufreq_frequency_table *table);
 
@@ -667,19 +694,20 @@ static inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq >= target_freq)
-			return pos - table;
+			return idx;
 
-		best = pos;
+		best = idx;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Find lowest freq at or above target in a table in descending order */
@@ -687,28 +715,29 @@ static inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return pos - table;
+			return idx;
 
 		if (freq > target_freq) {
-			best = pos;
+			best = idx;
 			continue;
 		}
 
 		/* No freq found above target_freq */
-		if (best == table - 1)
-			return pos - table;
+		if (best == -1)
+			return idx;
 
-		return best - table;
+		return best;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Works only on sorted freq-tables */
@@ -728,28 +757,29 @@ static inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return pos - table;
+			return idx;
 
 		if (freq < target_freq) {
-			best = pos;
+			best = idx;
 			continue;
 		}
 
 		/* No freq found below target_freq */
-		if (best == table - 1)
-			return pos - table;
+		if (best == -1)
+			return idx;
 
-		return best - table;
+		return best;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Find highest freq at or below target in a table in descending order */
@@ -757,19 +787,20 @@ static inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq <= target_freq)
-			return pos - table;
+			return idx;
 
-		best = pos;
+		best = idx;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Works only on sorted freq-tables */
@@ -789,32 +820,33 @@ static inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return pos - table;
+			return idx;
 
 		if (freq < target_freq) {
-			best = pos;
+			best = idx;
 			continue;
 		}
 
 		/* No freq found below target_freq */
-		if (best == table - 1)
-			return pos - table;
+		if (best == -1)
+			return idx;
 
 		/* Choose the closest freq */
-		if (target_freq - best->frequency > freq - target_freq)
-			return pos - table;
+		if (target_freq - table[best].frequency > freq - target_freq)
+			return idx;
 
-		return best - table;
+		return best;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Find closest freq to target in a table in descending order */
@@ -822,32 +854,33 @@ static inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
-	struct cpufreq_frequency_table *pos, *best = table - 1;
+	struct cpufreq_frequency_table *pos;
 	unsigned int freq;
+	int idx, best = -1;
 
-	cpufreq_for_each_valid_entry(pos, table) {
+	cpufreq_for_each_valid_entry_idx(pos, table, idx) {
 		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return pos - table;
+			return idx;
 
 		if (freq > target_freq) {
-			best = pos;
+			best = idx;
 			continue;
 		}
 
 		/* No freq found above target_freq */
-		if (best == table - 1)
-			return pos - table;
+		if (best == -1)
+			return idx;
 
 		/* Choose the closest freq */
-		if (best->frequency - target_freq > target_freq - freq)
-			return pos - table;
+		if (table[best].frequency - target_freq > target_freq - freq)
+			return idx;
 
-		return best - table;
+		return best;
 	}
 
-	return best - table;
+	return best;
 }
 
 /* Works only on sorted freq-tables */

commit 7d5905dc14a87805a59f3c5bf70173aac2bb18f8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Nov 15 02:13:40 2017 +0100

    x86 / CPU: Always show current CPU frequency in /proc/cpuinfo
    
    After commit 890da9cf0983 (Revert "x86: do not use cpufreq_quick_get()
    for /proc/cpuinfo "cpu MHz"") the "cpu MHz" number in /proc/cpuinfo
    on x86 can be either the nominal CPU frequency (which is constant)
    or the frequency most recently requested by a scaling governor in
    cpufreq, depending on the cpufreq configuration.  That is somewhat
    inconsistent and is different from what it was before 4.13, so in
    order to restore the previous behavior, make it report the current
    CPU frequency like the scaling_cur_freq sysfs file in cpufreq.
    
    To that end, modify the /proc/cpuinfo implementation on x86 to use
    aperfmperf_snapshot_khz() to snapshot the APERF and MPERF feedback
    registers, if available, and use their values to compute the CPU
    frequency to be reported as "cpu MHz".
    
    However, do that carefully enough to avoid accumulating delays that
    lead to unacceptable access times for /proc/cpuinfo on systems with
    many CPUs.  Run aperfmperf_snapshot_khz() once on all CPUs
    asynchronously at the /proc/cpuinfo open time, add a single delay
    upfront (if necessary) at that point and simply compute the current
    frequency while running show_cpuinfo() for each individual CPU.
    
    Also, to avoid slowing down /proc/cpuinfo accesses too much, reduce
    the default delay between consecutive APERF and MPERF reads to 10 ms,
    which should be sufficient to get large enough numbers for the
    frequency computation in all cases.
    
    Fixes: 890da9cf0983 (Revert "x86: do not use cpufreq_quick_get() for /proc/cpuinfo "cpu MHz"")
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 28734ee185a7..065f3a8eb486 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -917,6 +917,7 @@ static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
 }
 #endif
 
+extern void arch_freq_prepare_all(void);
 extern unsigned int arch_freq_get_on_cpu(int cpu);
 
 extern void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,

commit e7d5459dfaf613799915e901189d296bdc7534f9
Author: Dietmar Eggemann <dietmar.eggemann@arm.com>
Date:   Tue Sep 26 17:41:07 2017 +0100

    cpufreq: provide default frequency-invariance setter function
    
    Frequency-invariant accounting support based on the ratio of current
    frequency and maximum supported frequency is an optional feature an arch
    can implement.
    
    Since there are cpufreq drivers (e.g. cpufreq-dt) which can be build for
    different arch's a default implementation of the frequency-invariance
    setter function arch_set_freq_scale() is needed.
    
    This default implementation is an empty weak function which will be
    overwritten by a strong function in case the arch provides one.
    
    The setter function passes the cpumask of related (to the frequency
    change) cpus (online and offline cpus), the (new) current frequency and
    the maximum supported frequency.
    
    Signed-off-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 537ff842ff73..28734ee185a7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -919,6 +919,9 @@ static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
 
 extern unsigned int arch_freq_get_on_cpu(int cpu);
 
+extern void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,
+				unsigned long max_freq);
+
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 extern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;

commit 08a10002bed151f6df201715adb80c1c5e7fe7ca
Merge: bd87c8fb9d2e c49cbc19b31e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 4 00:05:22 2017 +0200

    Merge branch 'pm-cpufreq-sched'
    
    * pm-cpufreq-sched:
      cpufreq: schedutil: Always process remote callback with slow switching
      cpufreq: schedutil: Don't restrict kthread to related_cpus unnecessarily
      cpufreq: Return 0 from ->fast_switch() on errors
      cpufreq: Simplify cpufreq_can_do_remote_dvfs()
      cpufreq: Process remote callbacks from any CPU if the platform permits
      sched: cpufreq: Allow remote cpufreq callbacks
      cpufreq: schedutil: Use unsigned int for iowait boost
      cpufreq: schedutil: Make iowait boost more energy efficient

commit d6344d4b5628052ccda104466e5e05b9c43d7b61
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Aug 4 14:57:39 2017 +0200

    cpufreq: Simplify cpufreq_can_do_remote_dvfs()
    
    The if () in cpufreq_can_do_remote_dvfs() is superfluous, so drop
    it and simply return the value of the expression under it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1981a4a167ce..d69464139f67 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -578,11 +578,8 @@ static inline bool cpufreq_can_do_remote_dvfs(struct cpufreq_policy *policy)
 	 * - dvfs_possible_from_any_cpu flag is set
 	 * - the local and remote CPUs share cpufreq policy
 	 */
-	if (policy->dvfs_possible_from_any_cpu ||
-	    cpumask_test_cpu(smp_processor_id(), policy->cpus))
-		return true;
-
-	return false;
+	return policy->dvfs_possible_from_any_cpu ||
+		cpumask_test_cpu(smp_processor_id(), policy->cpus);
 }
 
 /*********************************************************************

commit 99d14d0e16fadb4de001bacc0ac0786a9ebecf2a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 28 12:16:39 2017 +0530

    cpufreq: Process remote callbacks from any CPU if the platform permits
    
    On many platforms, CPUs can do DVFS across cpufreq policies. i.e CPU
    from policy-A can change frequency of CPUs belonging to policy-B.
    
    This is quite common in case of ARM platforms where we don't
    configure any per-cpu register.
    
    Add a flag to identify such platforms and update
    cpufreq_can_do_remote_dvfs() to allow remote callbacks if this flag is
    set.
    
    Also enable the flag for cpufreq-dt driver which is used only on ARM
    platforms currently.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c4035964e6b3..1981a4a167ce 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -127,6 +127,15 @@ struct cpufreq_policy {
 	 */
 	unsigned int		transition_delay_us;
 
+	/*
+	 * Remote DVFS flag (Not added to the driver structure as we don't want
+	 * to access another structure from scheduler hotpath).
+	 *
+	 * Should be set if CPUs can do DVFS on behalf of other CPUs from
+	 * different cpufreq policies.
+	 */
+	bool			dvfs_possible_from_any_cpu;
+
 	 /* Cached frequency lookup from cpufreq_driver_resolve_freq. */
 	unsigned int cached_target_freq;
 	int cached_resolved_idx;
@@ -564,8 +573,13 @@ struct governor_attr {
 
 static inline bool cpufreq_can_do_remote_dvfs(struct cpufreq_policy *policy)
 {
-	/* Allow remote callbacks only on the CPUs sharing cpufreq policy */
-	if (cpumask_test_cpu(smp_processor_id(), policy->cpus))
+	/*
+	 * Allow remote callbacks if:
+	 * - dvfs_possible_from_any_cpu flag is set
+	 * - the local and remote CPUs share cpufreq policy
+	 */
+	if (policy->dvfs_possible_from_any_cpu ||
+	    cpumask_test_cpu(smp_processor_id(), policy->cpus))
 		return true;
 
 	return false;

commit 674e75411fc260b0d4532701228cfe12fc090da8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 28 12:16:38 2017 +0530

    sched: cpufreq: Allow remote cpufreq callbacks
    
    With Android UI and benchmarks the latency of cpufreq response to
    certain scheduling events can become very critical. Currently, callbacks
    into cpufreq governors are only made from the scheduler if the target
    CPU of the event is the same as the current CPU. This means there are
    certain situations where a target CPU may not run the cpufreq governor
    for some time.
    
    One testcase to show this behavior is where a task starts running on
    CPU0, then a new task is also spawned on CPU0 by a task on CPU1. If the
    system is configured such that the new tasks should receive maximum
    demand initially, this should result in CPU0 increasing frequency
    immediately. But because of the above mentioned limitation though, this
    does not occur.
    
    This patch updates the scheduler core to call the cpufreq callbacks for
    remote CPUs as well.
    
    The schedutil, ondemand and conservative governors are updated to
    process cpufreq utilization update hooks called for remote CPUs where
    the remote CPU is managed by the cpufreq policy of the local CPU.
    
    The intel_pstate driver is updated to always reject remote callbacks.
    
    This is tested with couple of usecases (Android: hackbench, recentfling,
    galleryfling, vellamo, Ubuntu: hackbench) on ARM hikey board (64 bit
    octa-core, single policy). Only galleryfling showed minor improvements,
    while others didn't had much deviation.
    
    The reason being that this patch only targets a corner case, where
    following are required to be true to improve performance and that
    doesn't happen too often with these tests:
    
    - Task is migrated to another CPU.
    - The task has high demand, and should take the target CPU to higher
      OPPs.
    - And the target CPU doesn't call into the cpufreq governor until the
      next tick.
    
    Based on initial work from Steve Muckle.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f10a9b3761cd..c4035964e6b3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -562,6 +562,15 @@ struct governor_attr {
 			 size_t count);
 };
 
+static inline bool cpufreq_can_do_remote_dvfs(struct cpufreq_policy *policy)
+{
+	/* Allow remote callbacks only on the CPUs sharing cpufreq policy */
+	if (cpumask_test_cpu(smp_processor_id(), policy->cpus))
+		return true;
+
+	return false;
+}
+
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/

commit fe829ed8ef1f3c7ac22843bd594ef2f6c4044288
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:48 2017 +0530

    cpufreq: Add CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING cpufreq driver flag
    
    The policy->transition_latency field is used for multiple purposes
    today and its not straight forward at all. This is how it is used:
    
    A. Set the correct transition_latency value.
    
    B. Set it to CPUFREQ_ETERNAL because:
       1. We don't want automatic dynamic switching (with
          ondemand/conservative) to happen at all.
       2. We don't know the transition latency.
    
    This patch handles the B.1. case in a more readable way. A new flag for
    the cpufreq drivers is added to disallow use of cpufreq governors which
    have dynamic_switching flag set.
    
    All the current cpufreq drivers which are setting transition_latency
    unconditionally to CPUFREQ_ETERNAL are updated to use it. They don't
    need to set transition_latency anymore.
    
    There shouldn't be any functional change after this patch.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index e141dbbb9d1c..5f40522ec98c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -370,6 +370,12 @@ struct cpufreq_driver {
  */
 #define CPUFREQ_NEED_INITIAL_FREQ_CHECK	(1 << 5)
 
+/*
+ * Set by drivers to disallow use of governors with "dynamic_switching" flag
+ * set.
+ */
+#define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING (1 << 6)
+
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 

commit ed4676e254630c1f00a4fc8f3821890fff7e3643
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:46 2017 +0530

    cpufreq: Replace "max_transition_latency" with "dynamic_switching"
    
    There is no limitation in the ondemand or conservative governors which
    disallow the transition_latency to be greater than 10 ms.
    
    The max_transition_latency field is rather used to disallow automatic
    dynamic frequency switching for platforms which didn't wanted these
    governors to run.
    
    Replace max_transition_latency with a boolean (dynamic_switching) and
    check for transition_latency == CPUFREQ_ETERNAL along with that. This
    makes it pretty straight forward to read/understand now.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index aaadfc543f63..e141dbbb9d1c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -487,12 +487,8 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
  * polling frequency is 1000 times the transition latency of the processor. The
  * ondemand governor will work on any processor with transition latency <= 10ms,
  * using appropriate sampling rate.
- *
- * For CPUs with transition latency > 10ms (mostly drivers with CPUFREQ_ETERNAL)
- * the ondemand governor will not work. All times here are in us (microseconds).
  */
 #define LATENCY_MULTIPLIER		(1000)
-#define TRANSITION_LATENCY_LIMIT	(10 * 1000 * 1000)
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
@@ -505,9 +501,8 @@ struct cpufreq_governor {
 					 char *buf);
 	int	(*store_setspeed)	(struct cpufreq_policy *policy,
 					 unsigned int freq);
-	unsigned int max_transition_latency; /* HW must be able to switch to
-			next freq faster than this value in nano secs or we
-			will fallback to performance governor */
+	/* For governors which change frequency dynamically by themselves */
+	bool			dynamic_switching;
 	struct list_head	governor_list;
 	struct module		*owner;
 };

commit aa7519af450d3c62a057aece24877c34562fa25a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:42 2017 +0530

    cpufreq: Use transition_delay_us for legacy governors as well
    
    The policy->transition_delay_us field is used only by the schedutil
    governor currently, and this field describes how fast the driver wants
    the cpufreq governor to change CPUs frequency. It should rather be a
    common thing across all governors, as it doesn't have any schedutil
    dependency here.
    
    Create a new helper cpufreq_policy_transition_delay_us() to get the
    transition delay across all governors.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 02aec384cab9..aaadfc543f63 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -523,6 +523,7 @@ int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int relation);
 unsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,
 					 unsigned int target_freq);
+unsigned int cpufreq_policy_transition_delay_us(struct cpufreq_policy *policy);
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 

commit 2d045036322c29b69c22f06530f1130338d06373
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:41 2017 +0530

    cpufreq: governor: Drop min_sampling_rate
    
    The cpufreq core and governors aren't supposed to set a limit on how
    fast we want to try changing the frequency. This is currently done for
    the legacy governors with help of min_sampling_rate.
    
    At worst, we may end up setting the sampling rate to a value lower than
    the rate at which frequency can be changed and then one of the CPUs in
    the policy will be only changing frequency for ever.
    
    But that is something for the user to decide and there is no need to
    have special handling for such cases in the core. Leave it for the user
    to figure out.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f10a9b3761cd..02aec384cab9 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -491,9 +491,7 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
  * For CPUs with transition latency > 10ms (mostly drivers with CPUFREQ_ETERNAL)
  * the ondemand governor will not work. All times here are in us (microseconds).
  */
-#define MIN_SAMPLING_RATE_RATIO		(2)
 #define LATENCY_MULTIPLIER		(1000)
-#define MIN_LATENCY_MULTIPLIER		(20)
 #define TRANSITION_LATENCY_LIMIT	(10 * 1000 * 1000)
 
 struct cpufreq_governor {

commit 4d25ec19669292a65a32498eabdabdd32b1a8747
Merge: 907afe5923b4 5d72ed35678a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 14 13:12:32 2017 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
    
     - Improve thermal cpu_cooling interaction with cpufreq core.
    
       The cpu_cooling driver is designed to use CPU frequency scaling to
       avoid high thermal states for a platform. But it wasn't glued really
       well with cpufreq core.
    
       For example clipped-cpus is copied from the policy structure and its
       much better to use the policy->cpus (or related_cpus) fields directly
       as they may have got updated. Not that things were broken before this
       series, but they can be optimized a bit more.
    
       This series tries to improve interactions between cpufreq core and
       cpu_cooling driver and does some fixes/cleanups to the cpu_cooling
       driver. (Viresh Kumar)
    
     - A couple of fixes and cleanups in thermal core and imx, hisilicon,
       bcm_2835, int340x thermal drivers. (Arvind Yadav, Dan Carpenter,
       Sumeet Pawnikar, Srinivas Pandruvada, Willy WOLFF)
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (24 commits)
      thermal: bcm2835: fix an error code in probe()
      thermal: hisilicon: Handle return value of clk_prepare_enable
      thermal: imx: Handle return value of clk_prepare_enable
      thermal: int340x: check for sensor when PTYP is missing
      Thermal/int340x: Fix few typos and kernel-doc style
      thermal: fix source code documentation for parameters
      thermal: cpu_cooling: Replace kmalloc with kmalloc_array
      thermal: cpu_cooling: Rearrange struct cpufreq_cooling_device
      thermal: cpu_cooling: 'freq' can't be zero in cpufreq_state2power()
      thermal: cpu_cooling: don't store cpu_dev in cpufreq_cdev
      thermal: cpu_cooling: get_level() can't fail
      thermal: cpu_cooling: create structure for idle time stats
      thermal: cpu_cooling: merge frequency and power tables
      thermal: cpu_cooling: get rid of 'allowed_cpus'
      thermal: cpu_cooling: OPPs are registered for all CPUs
      thermal: cpu_cooling: store cpufreq policy
      cpufreq: create cpufreq_table_count_valid_entries()
      thermal: cpu_cooling: use cpufreq_policy to register cooling device
      thermal: cpu_cooling: get rid of a variable in cpufreq_set_cur_state()
      thermal: cpu_cooling: remove cpufreq_cooling_get_level()
      ...

commit f8475cef90082bf0902ddab106112de130d90395
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jun 23 22:11:52 2017 -0700

    x86: use common aperfmperf_khz_on_cpu() to calculate KHz using APERF/MPERF
    
    The goal of this change is to give users a uniform and meaningful
    result when they read /sys/...cpufreq/scaling_cur_freq
    on modern x86 hardware, as compared to what they get today.
    
    Modern x86 processors include the hardware needed
    to accurately calculate frequency over an interval --
    APERF, MPERF, and the TSC.
    
    Here we provide an x86 routine to make this calculation
    on supported hardware, and use it in preference to any
    driver driver-specific cpufreq_driver.get() routine.
    
    MHz is computed like so:
    
    MHz = base_MHz * delta_APERF / delta_MPERF
    
    MHz is the average frequency of the busy processor
    over a measurement interval.  The interval is
    defined to be the time between successive invocations
    of aperfmperf_khz_on_cpu(), which are expected to to
    happen on-demand when users read sysfs attribute
    cpufreq/scaling_cur_freq.
    
    As with previous methods of calculating MHz,
    idle time is excluded.
    
    base_MHz above is from TSC calibration global "cpu_khz".
    
    This x86 native method to calculate MHz returns a meaningful result
    no matter if P-states are controlled by hardware or firmware
    and/or if the Linux cpufreq sub-system is or is-not installed.
    
    When this routine is invoked more frequently, the measurement
    interval becomes shorter.  However, the code limits re-computation
    to 10ms intervals so that average frequency remains meaningful.
    
    Discerning users are encouraged to take advantage of
    the turbostat(8) utility, which can gracefully handle
    concurrent measurement intervals of arbitrary length.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a5ce0bbeadb5..905117bd5012 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -883,6 +883,8 @@ static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
 }
 #endif
 
+extern unsigned int arch_freq_get_on_cpu(int cpu);
+
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 extern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;

commit 55d852931319d2e3ccde86cd426405231ce6c6ac
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 25 15:57:15 2017 +0530

    cpufreq: create cpufreq_table_count_valid_entries()
    
    We need such a routine at two places already, lets create one.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Lukasz Luba <lukasz.luba@arm.com>
    Tested-by: Lukasz Luba <lukasz.luba@arm.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a5ce0bbeadb5..eb9abfadaeac 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -862,6 +862,20 @@ static inline int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 		return -EINVAL;
 	}
 }
+
+static inline int cpufreq_table_count_valid_entries(const struct cpufreq_policy *policy)
+{
+	struct cpufreq_frequency_table *pos;
+	int count = 0;
+
+	if (unlikely(!policy->freq_table))
+		return 0;
+
+	cpufreq_for_each_valid_entry(pos, policy->freq_table)
+		count++;
+
+	return count;
+}
 #else
 static inline int cpufreq_boost_trigger_state(int state)
 {

commit 1b72e7fd304639f1cd49d1e11955c4974936d88c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 11 00:20:41 2017 +0200

    cpufreq: schedutil: Use policy-dependent transition delays
    
    Make the schedutil governor take the initial (default) value of the
    rate_limit_us sysfs attribute from the (new) transition_delay_us
    policy parameter (to be set by the scaling driver).
    
    That will allow scaling drivers to make schedutil use smaller default
    values of rate_limit_us and reduce the default average time interval
    between consecutive frequency changes.
    
    Make intel_pstate set transition_delay_us to 500.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 87165f06a307..a5ce0bbeadb5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -120,6 +120,13 @@ struct cpufreq_policy {
 	bool			fast_switch_possible;
 	bool			fast_switch_enabled;
 
+	/*
+	 * Preferred average time interval between consecutive invocations of
+	 * the driver to set the frequency for this policy.  To be set by the
+	 * scaling driver (0, which is the default, means no preference).
+	 */
+	unsigned int		transition_delay_us;
+
 	 /* Cached frequency lookup from cpufreq_driver_resolve_freq. */
 	unsigned int cached_target_freq;
 	int cached_resolved_idx;

commit 565ebe8073f84ced436a18e76a5ba8e6bb73dfb3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 3 15:26:25 2017 +0530

    cpufreq: Fix typos in comments
    
    - s/freqnency/frequency/
    - s/accomodating/accommodating/
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b07838b1fc60..87165f06a307 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -31,7 +31,7 @@
 
 #define CPUFREQ_ETERNAL			(-1)
 #define CPUFREQ_NAME_LEN		16
-/* Print length for names. Extra 1 space for accomodating '\n' in prints */
+/* Print length for names. Extra 1 space for accommodating '\n' in prints */
 #define CPUFREQ_NAME_PLEN		(CPUFREQ_NAME_LEN + 1)
 
 struct cpufreq_governor;
@@ -115,7 +115,7 @@ struct cpufreq_policy {
 	 *   guarantee that frequency can be changed on any CPU sharing the
 	 *   policy and that the change will affect all of the policy CPUs then.
 	 * - fast_switch_enabled is to be set by governors that support fast
-	 *   freqnency switching with the help of cpufreq_enable_fast_switch().
+	 *   frequency switching with the help of cpufreq_enable_fast_switch().
 	 */
 	bool			fast_switch_possible;
 	bool			fast_switch_enabled;

commit 052f573f5cca0ce0a16de409012660565bd792df
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 5 11:34:31 2017 +0530

    cpufreq: Remove CPUFREQ_START notifier event
    
    Its not used anymore, remove it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a597bb825ae1..b07838b1fc60 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -415,7 +415,6 @@ static inline void cpufreq_resume(void) {}
 /* Policy Notifiers  */
 #define CPUFREQ_ADJUST			(0)
 #define CPUFREQ_NOTIFY			(1)
-#define CPUFREQ_START			(2)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit f9f41e3ef99ac9d4e91b07634362e393fb929aad
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 5 10:17:27 2017 +0530

    cpufreq: Remove policy create/remove notifiers
    
    Those were added by:
    
    commit fcd7af917abb ("cpufreq: stats: handle cpufreq_unregister_driver()
    and suspend/resume properly")
    
    but aren't used anymore since:
    
    commit 1aefc75b2449 ("cpufreq: stats: Make the stats code non-modular").
    
    Remove them. Also remove the redundant parameter to the respective
    routines.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7e05c5e4e45c..a597bb825ae1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -416,8 +416,6 @@ static inline void cpufreq_resume(void) {}
 #define CPUFREQ_ADJUST			(0)
 #define CPUFREQ_NOTIFY			(1)
 #define CPUFREQ_START			(2)
-#define CPUFREQ_CREATE_POLICY		(3)
-#define CPUFREQ_REMOVE_POLICY		(4)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit 30248feff5e5c6a01ade5e6126009e296ed8bd35
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 18 13:59:21 2016 +0100

    cpufreq: Make cpufreq_update_policy() void
    
    The return value of cpufreq_update_policy() is never used, so make
    it void.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 40dc2e29f480..7e05c5e4e45c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -175,7 +175,7 @@ void disable_cpufreq(void);
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
-int cpufreq_update_policy(unsigned int cpu);
+void cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 void cpufreq_enable_fast_switch(struct cpufreq_policy *policy);

commit ee7930ee27fe5240398cc302fa8eb4454725f188
Author: Markus Mayer <mmayer@broadcom.com>
Date:   Mon Nov 7 10:02:23 2016 -0800

    cpufreq: stats: New sysfs attribute for clearing statistics
    
    Allow CPUfreq statistics to be cleared by writing anything to
    /sys/.../cpufreq/stats/reset.
    
    Signed-off-by: Markus Mayer <mmayer@broadcom.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 32dc0cbd51ca..40dc2e29f480 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -234,6 +234,10 @@ __ATTR(_name, _perm, show_##_name, NULL)
 static struct freq_attr _name =			\
 __ATTR(_name, 0644, show_##_name, store_##_name)
 
+#define cpufreq_freq_attr_wo(_name)		\
+static struct freq_attr _name =			\
+__ATTR(_name, 0200, NULL, store_##_name)
+
 struct global_attr {
 	struct attribute attr;
 	ssize_t (*show)(struct kobject *kobj,

commit c6fe46a79ecd79606bb96fada4515f6b23f87b62
Author: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Date:   Tue Oct 18 00:41:12 2016 +0900

    cpufreq: fix overflow in cpufreq_table_find_index_dl()
    
    'best' is always less or equals to 'pos', so `best - pos' returns
    a negative value which is then getting casted to `unsigned int'
    and passed to __cpufreq_driver_target()->acpi_cpufreq_target()
    for policy->freq_table selection. This results in
    
     BUG: unable to handle kernel paging request at ffff881019b469f8
     IP: [<ffffffffa00356c1>] acpi_cpufreq_target+0x4f/0x190 [acpi_cpufreq]
     PGD 267f067
     PUD 0
    
     Oops: 0000 [#1] PREEMPT SMP
     CPU: 6 PID: 70 Comm: kworker/6:1 Not tainted 4.9.0-rc1-next-20161017-dbg-dirty
     Workqueue: events dbs_work_handler
     task: ffff88041b808000 task.stack: ffff88041b810000
     RIP: 0010:[<ffffffffa00356c1>]  [<ffffffffa00356c1>] acpi_cpufreq_target+0x4f/0x190 [acpi_cpufreq]
     RSP: 0018:ffff88041b813c60  EFLAGS: 00010282
     RAX: ffff880419b46a00 RBX: ffff88041b848400 RCX: ffff880419b20f80
     RDX: 00000000001dff38 RSI: 00000000ffffffff RDI: ffff88041b848400
     RBP: ffff88041b813cb0 R08: 0000000000000006 R09: 0000000000000040
     R10: ffffffff8207f9e0 R11: ffffffff8173595b R12: 0000000000000000
     R13: ffff88041f1dff38 R14: 0000000000262900 R15: 0000000bfffffff4
     FS:  0000000000000000(0000) GS:ffff88041f000000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: ffff881019b469f8 CR3: 000000041a2d3000 CR4: 00000000001406e0
     Stack:
      ffff88041b813cb0 ffffffff813347f9 ffff88041b813ca0 ffffffff81334663
      ffff88041f1d4bc0 ffff88041b848400 0000000000000000 0000000000000000
      0000000000262900 0000000000000000 ffff88041b813d00 ffffffff813355dc
     Call Trace:
      [<ffffffff813347f9>] ? cpufreq_freq_transition_begin+0xf1/0xfc
      [<ffffffff81334663>] ? get_cpu_idle_time+0x97/0xa6
      [<ffffffff813355dc>] __cpufreq_driver_target+0x3b6/0x44e
      [<ffffffff81336ca3>] cs_dbs_timer+0x11a/0x135
      [<ffffffff81336fda>] dbs_work_handler+0x39/0x62
      [<ffffffff81057823>] process_one_work+0x280/0x4a5
      [<ffffffff81058719>] worker_thread+0x24f/0x397
      [<ffffffff810584ca>] ? rescuer_thread+0x30b/0x30b
      [<ffffffff81418380>] ? nl80211_get_key+0x29/0x36a
      [<ffffffff8105d2b7>] kthread+0xfc/0x104
      [<ffffffff8107ceea>] ? put_lock_stats.isra.9+0xe/0x20
      [<ffffffff8105d1bb>] ? kthread_create_on_node+0x3f/0x3f
      [<ffffffff814b2092>] ret_from_fork+0x22/0x30
     Code: 56 4d 6b ff 0c 41 55 41 54 53 48 83 ec 28 48 8b 15 ad 1e 00 00 44 8b 41
     08 48 8b 87 c8 00 00 00 49 89 d5 4e 03 2c c5 80 b2 78 81 <46> 8b 74 38 04 45
     3b 75 00 75 11 31 c0 83 39 00 0f 84 1c 01 00
     RIP  [<ffffffffa00356c1>] acpi_cpufreq_target+0x4f/0x190 [acpi_cpufreq]
      RSP <ffff88041b813c60>
     CR2: ffff881019b469f8
     ---[ end trace 16d9fc7a17897d37 ]---
    
    [ rjw: In some cases this bug may also cause incorrect frequencies to
      be selected by cpufreq governors. ]
    
    Fixes: 899bb6642f2a (cpufreq: skip invalid entries when searching the frequency)
    Link: http://marc.info/?l=linux-kernel&m=147672030714331&w=2
    Reported-and-tested-by: Sedat Dilek <sedat.dilek@gmail.com>
    Reported-and-tested-by: Jrg Otte <jrg.otte@gmail.com>
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 4.8+ <stable@vger.kernel.org> # 4.8+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5fa55fc56e18..32dc0cbd51ca 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -677,10 +677,10 @@ static inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,
 		if (best == table - 1)
 			return pos - table;
 
-		return best - pos;
+		return best - table;
 	}
 
-	return best - pos;
+	return best - table;
 }
 
 /* Works only on sorted freq-tables */

commit 899bb6642f2a2f2cd3f77abd6c5a14550e3b37e6
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Oct 12 08:45:05 2016 +0530

    cpufreq: skip invalid entries when searching the frequency
    
    Skip invalid entries when searching the frequency. This fixes cpufreq
    at least on loongson2 MIPS board.
    
    Fixes: da0c6dc00c69 (cpufreq: Handle sorted frequency tables more efficiently)
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 4.8+ <stable@vger.kernel.org> # 4.8+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 631ba33bbe9f..5fa55fc56e18 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -639,19 +639,19 @@ static inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq >= target_freq)
-			return i;
+			return pos - table;
 
-		best = i;
+		best = pos;
 	}
 
-	return best;
+	return best - table;
 }
 
 /* Find lowest freq at or above target in a table in descending order */
@@ -659,28 +659,28 @@ static inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return i;
+			return pos - table;
 
 		if (freq > target_freq) {
-			best = i;
+			best = pos;
 			continue;
 		}
 
 		/* No freq found above target_freq */
-		if (best == -1)
-			return i;
+		if (best == table - 1)
+			return pos - table;
 
-		return best;
+		return best - pos;
 	}
 
-	return best;
+	return best - pos;
 }
 
 /* Works only on sorted freq-tables */
@@ -700,28 +700,28 @@ static inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return i;
+			return pos - table;
 
 		if (freq < target_freq) {
-			best = i;
+			best = pos;
 			continue;
 		}
 
 		/* No freq found below target_freq */
-		if (best == -1)
-			return i;
+		if (best == table - 1)
+			return pos - table;
 
-		return best;
+		return best - table;
 	}
 
-	return best;
+	return best - table;
 }
 
 /* Find highest freq at or below target in a table in descending order */
@@ -729,19 +729,19 @@ static inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq <= target_freq)
-			return i;
+			return pos - table;
 
-		best = i;
+		best = pos;
 	}
 
-	return best;
+	return best - table;
 }
 
 /* Works only on sorted freq-tables */
@@ -761,32 +761,32 @@ static inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return i;
+			return pos - table;
 
 		if (freq < target_freq) {
-			best = i;
+			best = pos;
 			continue;
 		}
 
 		/* No freq found below target_freq */
-		if (best == -1)
-			return i;
+		if (best == table - 1)
+			return pos - table;
 
 		/* Choose the closest freq */
-		if (target_freq - table[best].frequency > freq - target_freq)
-			return i;
+		if (target_freq - best->frequency > freq - target_freq)
+			return pos - table;
 
-		return best;
+		return best - table;
 	}
 
-	return best;
+	return best - table;
 }
 
 /* Find closest freq to target in a table in descending order */
@@ -794,32 +794,32 @@ static inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy->freq_table;
+	struct cpufreq_frequency_table *pos, *best = table - 1;
 	unsigned int freq;
-	int i, best = -1;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		freq = table[i].frequency;
+	cpufreq_for_each_valid_entry(pos, table) {
+		freq = pos->frequency;
 
 		if (freq == target_freq)
-			return i;
+			return pos - table;
 
 		if (freq > target_freq) {
-			best = i;
+			best = pos;
 			continue;
 		}
 
 		/* No freq found above target_freq */
-		if (best == -1)
-			return i;
+		if (best == table - 1)
+			return pos - table;
 
 		/* Choose the closest freq */
-		if (table[best].frequency - target_freq > target_freq - freq)
-			return i;
+		if (best->frequency - target_freq > target_freq - freq)
+			return pos - table;
 
-		return best;
+		return best - table;
 	}
 
-	return best;
+	return best - table;
 }
 
 /* Works only on sorted freq-tables */

commit e3c06236087051d5c62d60d0668588c370fda887
Author: Steve Muckle <steve.muckle@linaro.org>
Date:   Wed Jul 13 13:25:25 2016 -0700

    cpufreq: add cpufreq_driver_resolve_freq()
    
    Cpufreq governors may need to know what a particular target frequency
    maps to in the driver without necessarily wanting to set the frequency.
    Support this operation via a new cpufreq API,
    cpufreq_driver_resolve_freq(). This API returns the lowest driver
    frequency equal or greater than the target frequency
    (CPUFREQ_RELATION_L), subject to any policy (min/max) or driver
    limitations. The mapping is also cached in the policy so that a
    subsequent fast_switch operation can avoid repeating the same lookup.
    
    The API will call a new cpufreq driver callback, resolve_freq(), if it
    has been registered by the driver. Otherwise the frequency is resolved
    via cpufreq_frequency_table_target(). Rather than require ->target()
    style drivers to provide a resolve_freq() callback it is left to the
    caller to ensure that the driver implements this callback if necessary
    to use cpufreq_driver_resolve_freq().
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Steve Muckle <smuckle@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c6410b1b2490..631ba33bbe9f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -120,6 +120,10 @@ struct cpufreq_policy {
 	bool			fast_switch_possible;
 	bool			fast_switch_enabled;
 
+	 /* Cached frequency lookup from cpufreq_driver_resolve_freq. */
+	unsigned int cached_target_freq;
+	int cached_resolved_idx;
+
 	/* Synchronization for frequency transitions */
 	bool			transition_ongoing; /* Tracks transition status */
 	spinlock_t		transition_lock;
@@ -270,6 +274,16 @@ struct cpufreq_driver {
 					unsigned int index);
 	unsigned int	(*fast_switch)(struct cpufreq_policy *policy,
 				       unsigned int target_freq);
+
+	/*
+	 * Caches and returns the lowest driver-supported frequency greater than
+	 * or equal to the target frequency, subject to any driver limitations.
+	 * Does not set the frequency. Only to be implemented for drivers with
+	 * target().
+	 */
+	unsigned int	(*resolve_freq)(struct cpufreq_policy *policy,
+					unsigned int target_freq);
+
 	/*
 	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION
 	 * unset.
@@ -501,6 +515,8 @@ int cpufreq_driver_target(struct cpufreq_policy *policy,
 int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
 				   unsigned int relation);
+unsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,
+					 unsigned int target_freq);
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 

commit da0c6dc00c69d0adaae99c3b3d2ea0c869a3fb35
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jun 27 16:04:07 2016 +0530

    cpufreq: Handle sorted frequency tables more efficiently
    
    cpufreq drivers aren't required to provide a sorted frequency table
    today, and even the ones which provide a sorted table aren't handled
    efficiently by cpufreq core.
    
    This patch adds infrastructure to verify if the freq-table provided by
    the drivers is sorted or not, and use efficient helpers if they are
    sorted.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c378776628b4..c6410b1b2490 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -36,6 +36,12 @@
 
 struct cpufreq_governor;
 
+enum cpufreq_table_sorting {
+	CPUFREQ_TABLE_UNSORTED,
+	CPUFREQ_TABLE_SORTED_ASCENDING,
+	CPUFREQ_TABLE_SORTED_DESCENDING
+};
+
 struct cpufreq_freqs {
 	unsigned int cpu;	/* cpu nr */
 	unsigned int old;
@@ -87,6 +93,7 @@ struct cpufreq_policy {
 
 	struct cpufreq_user_policy user_policy;
 	struct cpufreq_frequency_table	*freq_table;
+	enum cpufreq_table_sorting freq_table_sorted;
 
 	struct list_head        policy_list;
 	struct kobject		kobj;
@@ -597,9 +604,9 @@ int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
 				   struct cpufreq_frequency_table *table);
 int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy);
 
-int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
-				   unsigned int target_freq,
-				   unsigned int relation);
+int cpufreq_table_index_unsorted(struct cpufreq_policy *policy,
+				 unsigned int target_freq,
+				 unsigned int relation);
 int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
 		unsigned int freq);
 
@@ -610,6 +617,227 @@ int cpufreq_boost_trigger_state(int state);
 int cpufreq_boost_enabled(void);
 int cpufreq_enable_boost_support(void);
 bool policy_has_boost_freq(struct cpufreq_policy *policy);
+
+/* Find lowest freq at or above target in a table in ascending order */
+static inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq >= target_freq)
+			return i;
+
+		best = i;
+	}
+
+	return best;
+}
+
+/* Find lowest freq at or above target in a table in descending order */
+static inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq == target_freq)
+			return i;
+
+		if (freq > target_freq) {
+			best = i;
+			continue;
+		}
+
+		/* No freq found above target_freq */
+		if (best == -1)
+			return i;
+
+		return best;
+	}
+
+	return best;
+}
+
+/* Works only on sorted freq-tables */
+static inline int cpufreq_table_find_index_l(struct cpufreq_policy *policy,
+					     unsigned int target_freq)
+{
+	target_freq = clamp_val(target_freq, policy->min, policy->max);
+
+	if (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)
+		return cpufreq_table_find_index_al(policy, target_freq);
+	else
+		return cpufreq_table_find_index_dl(policy, target_freq);
+}
+
+/* Find highest freq at or below target in a table in ascending order */
+static inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq == target_freq)
+			return i;
+
+		if (freq < target_freq) {
+			best = i;
+			continue;
+		}
+
+		/* No freq found below target_freq */
+		if (best == -1)
+			return i;
+
+		return best;
+	}
+
+	return best;
+}
+
+/* Find highest freq at or below target in a table in descending order */
+static inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq <= target_freq)
+			return i;
+
+		best = i;
+	}
+
+	return best;
+}
+
+/* Works only on sorted freq-tables */
+static inline int cpufreq_table_find_index_h(struct cpufreq_policy *policy,
+					     unsigned int target_freq)
+{
+	target_freq = clamp_val(target_freq, policy->min, policy->max);
+
+	if (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)
+		return cpufreq_table_find_index_ah(policy, target_freq);
+	else
+		return cpufreq_table_find_index_dh(policy, target_freq);
+}
+
+/* Find closest freq to target in a table in ascending order */
+static inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq == target_freq)
+			return i;
+
+		if (freq < target_freq) {
+			best = i;
+			continue;
+		}
+
+		/* No freq found below target_freq */
+		if (best == -1)
+			return i;
+
+		/* Choose the closest freq */
+		if (target_freq - table[best].frequency > freq - target_freq)
+			return i;
+
+		return best;
+	}
+
+	return best;
+}
+
+/* Find closest freq to target in a table in descending order */
+static inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,
+					      unsigned int target_freq)
+{
+	struct cpufreq_frequency_table *table = policy->freq_table;
+	unsigned int freq;
+	int i, best = -1;
+
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		freq = table[i].frequency;
+
+		if (freq == target_freq)
+			return i;
+
+		if (freq > target_freq) {
+			best = i;
+			continue;
+		}
+
+		/* No freq found above target_freq */
+		if (best == -1)
+			return i;
+
+		/* Choose the closest freq */
+		if (table[best].frequency - target_freq > target_freq - freq)
+			return i;
+
+		return best;
+	}
+
+	return best;
+}
+
+/* Works only on sorted freq-tables */
+static inline int cpufreq_table_find_index_c(struct cpufreq_policy *policy,
+					     unsigned int target_freq)
+{
+	target_freq = clamp_val(target_freq, policy->min, policy->max);
+
+	if (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)
+		return cpufreq_table_find_index_ac(policy, target_freq);
+	else
+		return cpufreq_table_find_index_dc(policy, target_freq);
+}
+
+static inline int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
+						 unsigned int target_freq,
+						 unsigned int relation)
+{
+	if (unlikely(policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED))
+		return cpufreq_table_index_unsorted(policy, target_freq,
+						    relation);
+
+	switch (relation) {
+	case CPUFREQ_RELATION_L:
+		return cpufreq_table_find_index_l(policy, target_freq);
+	case CPUFREQ_RELATION_H:
+		return cpufreq_table_find_index_h(policy, target_freq);
+	case CPUFREQ_RELATION_C:
+		return cpufreq_table_find_index_c(policy, target_freq);
+	default:
+		pr_err("%s: Invalid relation: %d\n", __func__, relation);
+		return -EINVAL;
+	}
+}
 #else
 static inline int cpufreq_boost_trigger_state(int state)
 {

commit d218ed773915a2b762d132be6bb765637338c360
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 3 10:58:51 2016 +0530

    cpufreq: Return index from cpufreq_frequency_table_target()
    
    This routine can't fail unless the frequency table is invalid and
    doesn't contain any valid entries.
    
    Make it return the index and WARN() in case it is used for an invalid
    table.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bdd7f0c035ae..c378776628b4 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -599,8 +599,7 @@ int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy);
 
 int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
-				   unsigned int relation,
-				   unsigned int *index);
+				   unsigned int relation);
 int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
 		unsigned int freq);
 

commit 7ab4aabbaa98fbf9f8967fd93162d675439337e1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 3 10:58:49 2016 +0530

    cpufreq: Drop freq-table param to cpufreq_frequency_table_target()
    
    The policy already has this pointer set, use it instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1342cbc0f25e..bdd7f0c035ae 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -598,7 +598,6 @@ int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
 int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy);
 
 int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
-				   struct cpufreq_frequency_table *table,
 				   unsigned int target_freq,
 				   unsigned int relation,
 				   unsigned int *index);

commit f8bfc116cacbdf7e0e655d8a798a242087ed70a5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 3 10:58:47 2016 +0530

    cpufreq: Remove cpufreq_frequency_get_table()
    
    Most of the callers of cpufreq_frequency_get_table() already have the
    pointer to a valid 'policy' structure and they don't really need to go
    through the per-cpu variable first and then a check to validate the
    frequency, in order to find the freq-table for the policy.
    
    Directly use the policy->freq_table field instead for them.
    
    Only one user of that API is left after above changes, cpu_cooling.c and
    it accesses the freq_table in a racy way as the policy can get freed in
    between.
    
    Fix it by using cpufreq_cpu_get() properly.
    
    Since there are no more users of cpufreq_frequency_get_table() left, get
    rid of it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Javi Merino <javi.merino@arm.com> (cpu_cooling.c)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7ed93c310c08..1342cbc0f25e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -632,8 +632,6 @@ static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
 	return false;
 }
 #endif
-/* the following funtion is for cpufreq core use only */
-struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;

commit 1aefc75b2449eb68a6fc3ca932e2a4ee353b748d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue May 31 22:14:44 2016 +0200

    cpufreq: stats: Make the stats code non-modular
    
    The modularity of cpufreq_stats is quite problematic.
    
    First off, the usage of policy notifiers for the initialization
    and cleanup in the cpufreq_stats module is inherently racy with
    respect to CPU offline/online and the initialization and cleanup
    of the cpufreq driver.
    
    Second, fast frequency switching (used by the schedutil governor)
    cannot be enabled if any transition notifiers are registered, so
    if the cpufreq_stats module (that registers a transition notifier
    for updating transition statistics) is loaded, the schedutil governor
    cannot use fast frequency switching.
    
    On the other hand, allowing cpufreq_stats to be built as a module
    doesn't really add much value.  Arguably, there's not much reason
    for that code to be modular at all.
    
    For the above reasons, make the cpufreq stats code non-modular,
    modify the core to invoke functions provided by that code directly
    and drop the notifiers from it.
    
    Make the stats sysfs attributes appear empty if fast frequency
    switching is enabled as the statistics will not be updated in that
    case anyway (and returning -EBUSY from those attributes breaks
    powertop).
    
    While at it, clean up Kconfig help for the CPU_FREQ_STAT and
    CPU_FREQ_STAT_DETAILS options.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index fbd696edf5bd..7ed93c310c08 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -185,6 +185,18 @@ static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
 static inline void disable_cpufreq(void) { }
 #endif
 
+#ifdef CONFIG_CPU_FREQ_STAT
+void cpufreq_stats_create_table(struct cpufreq_policy *policy);
+void cpufreq_stats_free_table(struct cpufreq_policy *policy);
+void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
+				     unsigned int new_freq);
+#else
+static inline void cpufreq_stats_create_table(struct cpufreq_policy *policy) { }
+static inline void cpufreq_stats_free_table(struct cpufreq_policy *policy) { }
+static inline void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
+						   unsigned int new_freq) { }
+#endif /* CONFIG_CPU_FREQ_STAT */
+
 /*********************************************************************
  *                      CPUFREQ DRIVER INTERFACE                     *
  *********************************************************************/

commit 9a15fb2c797a15524e63eacb10bd6cd68a99e830
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 18 22:59:49 2016 +0200

    cpufreq: Drop the 'initialized' field from struct cpufreq_governor
    
    The 'initialized' field in struct cpufreq_governor is only used by
    the conservative governor (as a usage counter) and the way that
    happens is far from straightforward and arguably incorrect.
    
    Namely, the value of 'initialized' is checked by
    cpufreq_dbs_governor_init() and cpufreq_dbs_governor_exit() and
    the results of those checks are passed (as the second argument) to
    the ->init() and ->exit() callbacks in struct dbs_governor.  Those
    callbacks are only implemented by the ondemand and conservative
    governors and ondemand doesn't use their second argument at all.
    In turn, the conservative governor uses it to decide whether or not
    to either register or unregister a transition notifier.
    
    That whole mechanism is not only unnecessarily convoluted, but also
    racy, because the 'initialized' field of struct cpufreq_governor is
    updated in cpufreq_init_governor() and cpufreq_exit_governor() under
    policy->rwsem which doesn't help if one of these functions is run
    twice in parallel for different policies (which isn't impossible in
    principle), for example.
    
    Instead of it, add a proper usage counter to the conservative
    governor and update it from cs_init() and cs_exit() which is
    guaranteed to be non-racy, as those functions are only called
    under gov_dbs_data_mutex which is global.
    
    With that in place, drop the 'initialized' field from struct
    cpufreq_governor as it is not used any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 3be54a0b4373..fbd696edf5bd 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -457,7 +457,6 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
-	int	initialized;
 	int	(*init)(struct cpufreq_policy *policy);
 	void	(*exit)(struct cpufreq_policy *policy);
 	int	(*start)(struct cpufreq_policy *policy);

commit bf2be2de8493dd5f86d6e0f0d4eecb5810ad035b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 18 17:55:31 2016 +0530

    cpufreq: governor: Create cpufreq_policy_apply_limits()
    
    Create a new helper to avoid code duplication across governors.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5bcda3e6aa9e..3be54a0b4373 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -489,6 +489,14 @@ void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 struct cpufreq_governor *cpufreq_default_governor(void);
 struct cpufreq_governor *cpufreq_fallback_governor(void);
 
+static inline void cpufreq_policy_apply_limits(struct cpufreq_policy *policy)
+{
+	if (policy->max < policy->cur)
+		__cpufreq_driver_target(policy, policy->max, CPUFREQ_RELATION_H);
+	else if (policy->min > policy->cur)
+		__cpufreq_driver_target(policy, policy->min, CPUFREQ_RELATION_L);
+}
+
 /* Governor attribute set */
 struct gov_attr_set {
 	struct kobject kobj;

commit e788892ba3cc71d385b75895f7a375fbc659ce86
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 2 23:24:15 2016 +0200

    cpufreq: governor: Get rid of governor events
    
    The design of the cpufreq governor API is not very straightforward,
    as struct cpufreq_governor provides only one callback to be invoked
    from different code paths for different purposes.  The purpose it is
    invoked for is determined by its second "event" argument, causing it
    to act as a "callback multiplexer" of sorts.
    
    Unfortunately, that leads to extra complexity in governors, some of
    which implement the ->governor() callback as a switch statement
    that simply checks the event argument and invokes a separate function
    to handle that specific event.
    
    That extra complexity can be eliminated by replacing the all-purpose
    ->governor() callback with a family of callbacks to carry out specific
    governor operations: initialization and exit, start and stop and policy
    limits updates.  That also turns out to reduce the code size too, so
    do it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4e81e08db752..5bcda3e6aa9e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -455,18 +455,14 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
 #define MIN_LATENCY_MULTIPLIER		(20)
 #define TRANSITION_LATENCY_LIMIT	(10 * 1000 * 1000)
 
-/* Governor Events */
-#define CPUFREQ_GOV_START	1
-#define CPUFREQ_GOV_STOP	2
-#define CPUFREQ_GOV_LIMITS	3
-#define CPUFREQ_GOV_POLICY_INIT	4
-#define CPUFREQ_GOV_POLICY_EXIT	5
-
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
 	int	initialized;
-	int	(*governor)	(struct cpufreq_policy *policy,
-				 unsigned int event);
+	int	(*init)(struct cpufreq_policy *policy);
+	void	(*exit)(struct cpufreq_policy *policy);
+	int	(*start)(struct cpufreq_policy *policy);
+	void	(*stop)(struct cpufreq_policy *policy);
+	void	(*limits)(struct cpufreq_policy *policy);
 	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
 					 char *buf);
 	int	(*store_setspeed)	(struct cpufreq_policy *policy,

commit 6c9d9c81924b4b63c7a487e90fddb3b2d0f7d458
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Apr 7 23:38:46 2016 +0200

    cpufreq: Call cpufreq_disable_fast_switch() in sugov_exit()
    
    Due to differences in the cpufreq core's handling of runtime CPU
    offline and nonboot CPUs disabling during system suspend-to-RAM,
    fast frequency switching gets disabled after a suspend-to-RAM and
    resume cycle on all of the nonboot CPUs.
    
    To prevent that from happening, move the invocation of
    cpufreq_disable_fast_switch() from cpufreq_exit_governor() to
    sugov_exit(), as the schedutil governor is the only user of fast
    frequency switching today anyway.
    
    That simply prevents cpufreq_disable_fast_switch() from being called
    without invoking the ->governor callback for the CPUFREQ_GOV_POLICY_EXIT
    event (which happens during system suspend now).
    
    Fixes: b7898fda5bc7 (cpufreq: Support for fast frequency switching)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 55e69ebb035c..4e81e08db752 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -168,6 +168,7 @@ int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 void cpufreq_enable_fast_switch(struct cpufreq_policy *policy);
+void cpufreq_disable_fast_switch(struct cpufreq_policy *policy);
 #else
 static inline unsigned int cpufreq_get(unsigned int cpu)
 {

commit b7898fda5bc7e786e76ce24fbd2ec993b08ec518
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Mar 30 03:47:49 2016 +0200

    cpufreq: Support for fast frequency switching
    
    Modify the ACPI cpufreq driver to provide a method for switching
    CPU frequencies from interrupt context and update the cpufreq core
    to support that method if available.
    
    Introduce a new cpufreq driver callback, ->fast_switch, to be
    invoked for frequency switching from interrupt context by (future)
    governors supporting that feature via (new) helper function
    cpufreq_driver_fast_switch().
    
    Add two new policy flags, fast_switch_possible, to be set by the
    cpufreq driver if fast frequency switching can be used for the
    given policy and fast_switch_enabled, to be set by the governor
    if it is going to use fast frequency switching for the given
    policy.  Also add a helper for setting the latter.
    
    Since fast frequency switching is inherently incompatible with
    cpufreq transition notifiers, make it possible to set the
    fast_switch_enabled only if there are no transition notifiers
    already registered and make the registration of new transition
    notifiers fail if fast_switch_enabled is set for at least one
    policy.
    
    Implement the ->fast_switch callback in the ACPI cpufreq driver
    and make it set fast_switch_possible during policy initialization
    as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 2b4f248b8ef1..55e69ebb035c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -102,6 +102,17 @@ struct cpufreq_policy {
 	 */
 	struct rw_semaphore	rwsem;
 
+	/*
+	 * Fast switch flags:
+	 * - fast_switch_possible should be set by the driver if it can
+	 *   guarantee that frequency can be changed on any CPU sharing the
+	 *   policy and that the change will affect all of the policy CPUs then.
+	 * - fast_switch_enabled is to be set by governors that support fast
+	 *   freqnency switching with the help of cpufreq_enable_fast_switch().
+	 */
+	bool			fast_switch_possible;
+	bool			fast_switch_enabled;
+
 	/* Synchronization for frequency transitions */
 	bool			transition_ongoing; /* Tracks transition status */
 	spinlock_t		transition_lock;
@@ -156,6 +167,7 @@ int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
+void cpufreq_enable_fast_switch(struct cpufreq_policy *policy);
 #else
 static inline unsigned int cpufreq_get(unsigned int cpu)
 {
@@ -236,6 +248,8 @@ struct cpufreq_driver {
 				  unsigned int relation);	/* Deprecated */
 	int		(*target_index)(struct cpufreq_policy *policy,
 					unsigned int index);
+	unsigned int	(*fast_switch)(struct cpufreq_policy *policy,
+				       unsigned int target_freq);
 	/*
 	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION
 	 * unset.
@@ -464,6 +478,8 @@ struct cpufreq_governor {
 };
 
 /* Pass a target to the cpufreq driver */
+unsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,
+					unsigned int target_freq);
 int cpufreq_driver_target(struct cpufreq_policy *policy,
 				 unsigned int target_freq,
 				 unsigned int relation);

commit 379480d8258056bfdbaa65e4d3f024bb5b34b52b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:51:56 2016 +0100

    cpufreq: Move governor symbols to cpufreq.h
    
    Move definitions of symbols related to transition latency and
    sampling rate to include/linux/cpufreq.h so they can be used by
    (future) goverernors located outside of drivers/cpufreq/.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 74f5cfff2b52..2b4f248b8ef1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -426,6 +426,20 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
 #define CPUFREQ_POLICY_POWERSAVE	(1)
 #define CPUFREQ_POLICY_PERFORMANCE	(2)
 
+/*
+ * The polling frequency depends on the capability of the processor. Default
+ * polling frequency is 1000 times the transition latency of the processor. The
+ * ondemand governor will work on any processor with transition latency <= 10ms,
+ * using appropriate sampling rate.
+ *
+ * For CPUs with transition latency > 10ms (mostly drivers with CPUFREQ_ETERNAL)
+ * the ondemand governor will not work. All times here are in us (microseconds).
+ */
+#define MIN_SAMPLING_RATE_RATIO		(2)
+#define LATENCY_MULTIPLIER		(1000)
+#define MIN_LATENCY_MULTIPLIER		(20)
+#define TRANSITION_LATENCY_LIMIT	(10 * 1000 * 1000)
+
 /* Governor Events */
 #define CPUFREQ_GOV_START	1
 #define CPUFREQ_GOV_STOP	2

commit 66893b6ac9952ec9d9409e9d85eaacf37bba8d15
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:50:45 2016 +0100

    cpufreq: Move governor attribute set headers to cpufreq.h
    
    Move definitions and function headers related to struct gov_attr_set
    to include/linux/cpufreq.h so they can be used by (future) goverernors
    located outside of drivers/cpufreq/.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 718e8725de8a..74f5cfff2b52 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -462,6 +462,29 @@ void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 struct cpufreq_governor *cpufreq_default_governor(void);
 struct cpufreq_governor *cpufreq_fallback_governor(void);
 
+/* Governor attribute set */
+struct gov_attr_set {
+	struct kobject kobj;
+	struct list_head policy_list;
+	struct mutex update_lock;
+	int usage_count;
+};
+
+/* sysfs ops for cpufreq governors */
+extern const struct sysfs_ops governor_sysfs_ops;
+
+void gov_attr_set_init(struct gov_attr_set *attr_set, struct list_head *list_node);
+void gov_attr_set_get(struct gov_attr_set *attr_set, struct list_head *list_node);
+unsigned int gov_attr_set_put(struct gov_attr_set *attr_set, struct list_head *list_node);
+
+/* Governor sysfs attribute */
+struct governor_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct gov_attr_set *attr_set, char *buf);
+	ssize_t (*store)(struct gov_attr_set *attr_set, const char *buf,
+			 size_t count);
+};
+
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/

commit a5acbfbd70bc6a0cd4c8ca8f4f5e52ac3ee7dca4
Merge: edd4a893e097 adaf9fcd1369
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 10 20:46:03 2016 +0100

    Merge branch 'pm-cpufreq-governor' into pm-cpufreq

commit adaf9fcd136970e480d7ca834c0cf25ce922ea74
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 10 20:44:47 2016 +0100

    cpufreq: Move scheduler-related code to the sched directory
    
    Create cpufreq.c under kernel/sched/ and move the cpufreq code
    related to the scheduler to that file and to sched.h.
    
    Redefine cpufreq_update_util() as a static inline function to avoid
    function calls at its call sites in the scheduler code (as suggested
    by Peter Zijlstra).
    
    Also move the definition of struct update_util_data and declaration
    of cpufreq_set_update_util_data() from include/linux/cpufreq.h to
    include/linux/sched.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a50c5b2e3bf2..a5ea52f793f3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -146,36 +146,6 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 extern struct kobject *cpufreq_global_kobject;
 
 #ifdef CONFIG_CPU_FREQ
-void cpufreq_update_util(u64 time, unsigned long util, unsigned long max);
-
-/**
- * cpufreq_trigger_update - Trigger CPU performance state evaluation if needed.
- * @time: Current time.
- *
- * The way cpufreq is currently arranged requires it to evaluate the CPU
- * performance state (frequency/voltage) on a regular basis to prevent it from
- * being stuck in a completely inadequate performance level for too long.
- * That is not guaranteed to happen if the updates are only triggered from CFS,
- * though, because they may not be coming in if RT or deadline tasks are active
- * all the time (or there are RT and DL tasks only).
- *
- * As a workaround for that issue, this function is called by the RT and DL
- * sched classes to trigger extra cpufreq updates to prevent it from stalling,
- * but that really is a band-aid.  Going forward it should be replaced with
- * solutions targeted more specifically at RT and DL tasks.
- */
-static inline void cpufreq_trigger_update(u64 time)
-{
-	cpufreq_update_util(time, ULONG_MAX, 0);
-}
-
-struct update_util_data {
-	void (*func)(struct update_util_data *data,
-		     u64 time, unsigned long util, unsigned long max);
-};
-
-void cpufreq_set_update_util_data(int cpu, struct update_util_data *data);
-
 unsigned int cpufreq_get(unsigned int cpu);
 unsigned int cpufreq_quick_get(unsigned int cpu);
 unsigned int cpufreq_quick_get_max(unsigned int cpu);
@@ -187,10 +157,6 @@ int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 #else
-static inline void cpufreq_update_util(u64 time, unsigned long util,
-				       unsigned long max) {}
-static inline void cpufreq_trigger_update(u64 time) {}
-
 static inline unsigned int cpufreq_get(unsigned int cpu)
 {
 	return 0;

commit 242aa883a64d8c54cfeee47f3603b21bc705e081
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 22 16:36:44 2016 +0530

    cpufreq: Remove 'policy->governor_enabled'
    
    The entire sequence of events (like INIT/START or STOP/EXIT) for which
    cpufreq_governor() is called, is guaranteed to be protected by
    policy->rwsem now.
    
    The additional checks that were added earlier (as we were forced to drop
    policy->rwsem before calling cpufreq_governor() for EXIT event), aren't
    required anymore.
    
    Over that, they weren't sufficient really. They just take care of
    START/STOP events, but not INIT/EXIT and the state machine was never
    maintained properly by them.
    
    Kill the unnecessary checks and policy->governor_enabled field.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index cac3d1ba8200..a50c5b2e3bf2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -80,7 +80,6 @@ struct cpufreq_policy {
 	unsigned int		last_policy; /* policy before unplug */
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
-	bool			governor_enabled; /* governor start/stop flag */
 	char			last_governor[CPUFREQ_NAME_LEN]; /* last governor used */
 
 	struct work_struct	update; /* if update_policy() needs to be

commit 68e80dae09033d778b98dc88e5bfe8fdade188e5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:35 2016 +0530

    Revert "cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT"
    
    Earlier, when the struct freq-attr was used to represent governor
    attributes, the standard cpufreq show/store sysfs attribute callbacks
    were applied to the governor tunable attributes and they always acquire
    the policy->rwsem lock before carrying out the operation.  That could
    have resulted in an ABBA deadlock if governor tunable attributes are
    removed under policy->rwsem while one of them is being accessed
    concurrently (if sysfs attributes removal wins the race, it will wait
    for the access to complete with policy->rwsem held while the attribute
    callback will block on policy->rwsem indefinitely).
    
    We attempted to address this issue by dropping policy->rwsem around
    governor tunable attributes removal (that is, around invocations of the
    ->governor callback with the event arg equal to CPUFREQ_GOV_POLICY_EXIT)
    in cpufreq_set_policy(), but that opened up race conditions that had not
    been possible with policy->rwsem held all the time.
    
    The previous commit, "cpufreq: governor: New sysfs show/store callbacks
    for governor tunables", fixed the original ABBA deadlock by adding new
    governor specific show/store callbacks.
    
    We don't have to drop rwsem around invocations of governor event
    CPUFREQ_GOV_POLICY_EXIT anymore, and original fix can be reverted now.
    
    Fixes: 955ef4833574 (cpufreq: Drop rwsem lock around CPUFREQ_GOV_POLICY_EXIT)
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reported-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 704d85bf7242..cac3d1ba8200 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -100,10 +100,6 @@ struct cpufreq_policy {
 	 * - Any routine that will write to the policy structure and/or may take away
 	 *   the policy altogether (eg. CPU hotplug), will hold this lock in write
 	 *   mode before doing so.
-	 *
-	 * Additional rules:
-	 * - Lock should not be held across
-	 *     __cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
 	 */
 	struct rw_semaphore	rwsem;
 

commit 34e2c555f3e13c90e9284e23d00f03be8a6e06c5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 15 20:20:42 2016 +0100

    cpufreq: Add mechanism for registering utilization update callbacks
    
    Introduce a mechanism by which parts of the cpufreq subsystem
    ("setpolicy" drivers or the core) can register callbacks to be
    executed from cpufreq_update_util() which is invoked by the
    scheduler's update_load_avg() on CPU utilization changes.
    
    This allows the "setpolicy" drivers to dispense with their timers
    and do all of the computations they need and frequency/voltage
    adjustments in the update_load_avg() code path, among other things.
    
    The update_load_avg() changes were suggested by Peter Zijlstra.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d0bf555b6bbf..704d85bf7242 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -151,6 +151,36 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 extern struct kobject *cpufreq_global_kobject;
 
 #ifdef CONFIG_CPU_FREQ
+void cpufreq_update_util(u64 time, unsigned long util, unsigned long max);
+
+/**
+ * cpufreq_trigger_update - Trigger CPU performance state evaluation if needed.
+ * @time: Current time.
+ *
+ * The way cpufreq is currently arranged requires it to evaluate the CPU
+ * performance state (frequency/voltage) on a regular basis to prevent it from
+ * being stuck in a completely inadequate performance level for too long.
+ * That is not guaranteed to happen if the updates are only triggered from CFS,
+ * though, because they may not be coming in if RT or deadline tasks are active
+ * all the time (or there are RT and DL tasks only).
+ *
+ * As a workaround for that issue, this function is called by the RT and DL
+ * sched classes to trigger extra cpufreq updates to prevent it from stalling,
+ * but that really is a band-aid.  Going forward it should be replaced with
+ * solutions targeted more specifically at RT and DL tasks.
+ */
+static inline void cpufreq_trigger_update(u64 time)
+{
+	cpufreq_update_util(time, ULONG_MAX, 0);
+}
+
+struct update_util_data {
+	void (*func)(struct update_util_data *data,
+		     u64 time, unsigned long util, unsigned long max);
+};
+
+void cpufreq_set_update_util_data(int cpu, struct update_util_data *data);
+
 unsigned int cpufreq_get(unsigned int cpu);
 unsigned int cpufreq_quick_get(unsigned int cpu);
 unsigned int cpufreq_quick_get_max(unsigned int cpu);
@@ -162,6 +192,10 @@ int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 #else
+static inline void cpufreq_update_util(u64 time, unsigned long util,
+				       unsigned long max) {}
+static inline void cpufreq_trigger_update(u64 time) {}
+
 static inline unsigned int cpufreq_get(unsigned int cpu)
 {
 	return 0;

commit 34b0870515aaac6b7ea1ffdc370516b0a8024c82
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 26 00:22:57 2016 +0100

    cpufreq: Simplify the cpufreq_for_each_valid_entry()
    
    That macro uses an internal static inline function that is first
    totally unnecessary and second hard to read, so simplify it and
    get rid of that monster.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d0bf555b6bbf..4064cfcfbffd 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -504,16 +504,6 @@ static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
 }
 #endif
 
-static inline bool cpufreq_next_valid(struct cpufreq_frequency_table **pos)
-{
-	while ((*pos)->frequency != CPUFREQ_TABLE_END)
-		if ((*pos)->frequency != CPUFREQ_ENTRY_INVALID)
-			return true;
-		else
-			(*pos)++;
-	return false;
-}
-
 /*
  * cpufreq_for_each_entry -	iterate over a cpufreq_frequency_table
  * @pos:	the cpufreq_frequency_table * to use as a loop cursor.
@@ -530,8 +520,11 @@ static inline bool cpufreq_next_valid(struct cpufreq_frequency_table **pos)
  * @table:      the cpufreq_frequency_table * to iterate over.
  */
 
-#define cpufreq_for_each_valid_entry(pos, table)	\
-	for (pos = table; cpufreq_next_valid(&pos); pos++)
+#define cpufreq_for_each_valid_entry(pos, table)			\
+	for (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)	\
+		if (pos->frequency == CPUFREQ_ENTRY_INVALID)		\
+			continue;					\
+		else
 
 int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 				    struct cpufreq_frequency_table *table);

commit de1df26b7cef702a32ae876ed45c1112f523df48
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 5 02:37:42 2016 +0100

    cpufreq: Clean up default and fallback governor setup
    
    The preprocessor magic used for setting the default cpufreq governor
    (and for using the performance governor as a fallback one for that
    matter) is really nasty, so replace it with __weak functions and
    overrides.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 88a4215125bc..d0bf555b6bbf 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -464,29 +464,8 @@ int __cpufreq_driver_target(struct cpufreq_policy *policy,
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
-/* CPUFREQ DEFAULT GOVERNOR */
-/*
- * Performance governor is fallback governor if any other gov failed to auto
- * load due latency restrictions
- */
-#ifdef CONFIG_CPU_FREQ_GOV_PERFORMANCE
-extern struct cpufreq_governor cpufreq_gov_performance;
-#endif
-#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
-#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_performance)
-#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE)
-extern struct cpufreq_governor cpufreq_gov_powersave;
-#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_powersave)
-#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
-extern struct cpufreq_governor cpufreq_gov_userspace;
-#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)
-#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
-extern struct cpufreq_governor cpufreq_gov_ondemand;
-#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemand)
-#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
-extern struct cpufreq_governor cpufreq_gov_conservative;
-#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
-#endif
+struct cpufreq_governor *cpufreq_default_governor(void);
+struct cpufreq_governor *cpufreq_fallback_governor(void);
 
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *

commit 7a6c79f2fe53dac9b7b290f3a4c56b0958e19201
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 27 00:27:38 2015 +0100

    cpufreq: Simplify core code related to boost support
    
    Notice that the boost_supported field in struct cpufreq_driver is
    redundant, because the driver's ->set_boost callback may be left
    unset if "boost" is not supported.  Moreover, the only driver
    populating the ->set_boost callback is acpi_cpufreq, so make it
    avoid populating that callback if "boost" is not supported, rework
    the core to check ->set_boost instead of boost_supported to
    verify "boost" support and drop boost_supported which isn't
    used any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f859b728d98e..88a4215125bc 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -278,7 +278,6 @@ struct cpufreq_driver {
 	struct freq_attr **attr;
 
 	/* platform specific boost support code */
-	bool		boost_supported;
 	bool		boost_enabled;
 	int		(*set_boost)(int state);
 };

commit 41669da03060c5e55e9d3061ddede624f01d7262
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 27 00:23:48 2015 +0100

    cpufreq: Make cpufreq_boost_supported() static
    
    cpufreq_boost_supported() is not used outside of cpufreq.c, so make
    it static.
    
    While at it, refactor it as a one-liner (which it really is).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 177c7680c1a8..f859b728d98e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -574,7 +574,6 @@ ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_boost_trigger_state(int state);
-int cpufreq_boost_supported(void);
 int cpufreq_boost_enabled(void);
 int cpufreq_enable_boost_support(void);
 bool policy_has_boost_freq(struct cpufreq_policy *policy);
@@ -583,10 +582,6 @@ static inline int cpufreq_boost_trigger_state(int state)
 {
 	return 0;
 }
-static inline int cpufreq_boost_supported(void)
-{
-	return 0;
-}
 static inline int cpufreq_boost_enabled(void)
 {
 	return 0;

commit 69030dd1c3671625c6f766af0b64a4bb4409ac3b
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Dec 1 16:52:14 2015 -0800

    cpufreq: use last policy after online for drivers with ->setpolicy
    
    For cpufreq drivers which use setpolicy interface, after offline->online
    the policy is set to default. This can be reproduced by setting the
    default policy of intel_pstate or longrun to ondemand and then change to
    "performance". After offline and online, the setpolicy will be called with
    the policy=ondemand.
    
    For drivers using governors this condition is handled by storing
    last_governor, during offline and restoring during online. The same should
    be done for drivers using setpolicy interface. Storing last_policy during
    offline and restoring during online.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ef4c5b1a860f..177c7680c1a8 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -77,6 +77,7 @@ struct cpufreq_policy {
 	unsigned int		suspend_freq; /* freq to set during suspend */
 
 	unsigned int		policy; /* see above */
+	unsigned int		last_policy; /* policy before unplug */
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
 	bool			governor_enabled; /* governor start/stop flag */

commit 96bdda61f58b70431bbe8a3e49794c8210f7691b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Oct 15 21:35:24 2015 +0530

    cpufreq: create cpu/cpufreq/policyX directories
    
    The cpufreq sysfs interface had been a bit inconsistent as one of the
    CPUs for a policy had a real directory within its sysfs 'cpuX' directory
    and all other CPUs had links to it. That also made the code a bit
    complex as we need to take care of moving the sysfs directory if the CPU
    containing the real directory is getting physically hot-unplugged.
    
    Solve this by creating 'policyX' directories (per-policy) in
    /sys/devices/system/cpu/cpufreq/ directory, where X is the CPU for which
    the policy was first created.
    
    This also removes the need of keeping kobj_cpu and we can remove it now.
    
    Suggested-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: is more of a general agreement from the person that he is
    Reviewed-by: is a more strict tag and implies that the reviewer has
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9623218d996a..ef4c5b1a860f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -65,7 +65,6 @@ struct cpufreq_policy {
 	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu managing this policy, must be online */
-	unsigned int		kobj_cpu; /* cpu managing sysfs files, can be offline */
 
 	struct clk		*clk;
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */

commit c82bd44437f5d53d1654d9e36a9e4e55610f6624
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Oct 15 21:35:23 2015 +0530

    cpufreq: remove cpufreq_sysfs_{create|remove}_file()
    
    They don't do anything special now, remove the unnecessary wrapper.
    
    Reviewed-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 338bf0e59bb8..9623218d996a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -149,8 +149,6 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 
 /* /sys/devices/system/cpu/cpufreq: entry point for global variables */
 extern struct kobject *cpufreq_global_kobject;
-int cpufreq_sysfs_create_file(const struct attribute *attr);
-void cpufreq_sysfs_remove_file(const struct attribute *attr);
 
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_get(unsigned int cpu);

commit 8eec1020f0c0c03f7219ed50cf1b754be49dd448
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Oct 15 21:35:22 2015 +0530

    cpufreq: create cpu/cpufreq at boot time
    
    Later patches will need to create policy specific directories in
    /sys/devices/system/cpu/cpufreq/ directory and so the cpufreq directory
    wouldn't be ever empty.
    
    And so no fun creating/destroying it on need basis anymore. Create it
    once on system boot.
    
    Reviewed-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index dca22de98d94..338bf0e59bb8 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -149,8 +149,6 @@ static inline bool policy_is_shared(struct cpufreq_policy *policy)
 
 /* /sys/devices/system/cpu/cpufreq: entry point for global variables */
 extern struct kobject *cpufreq_global_kobject;
-int cpufreq_get_global_kobject(void);
-void cpufreq_put_global_kobject(void);
 int cpufreq_sysfs_create_file(const struct attribute *attr);
 void cpufreq_sysfs_remove_file(const struct attribute *attr);
 

commit 1f0bd44e937468446d080b98b5669844744c24a1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Sep 16 02:17:49 2015 +0200

    cpufreq: acpi-cpufreq: Use cpufreq_cpu_get_raw() in ->get()
    
    cpufreq_cpu_get() called by get_cur_freq_on_cpu() is overkill,
    because the ->get() callback is always invoked in a context in
    which all of the conditions checked by cpufreq_cpu_get() are
    guaranteed to be satisfied.
    
    Use cpufreq_cpu_get_raw() instead of it and drop the
    corresponding cpufreq_cpu_put() from get_cur_freq_on_cpu().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 430efcbea48e..dca22de98d94 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -127,9 +127,14 @@ struct cpufreq_policy {
 #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
 #ifdef CONFIG_CPU_FREQ
+struct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu);
 struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 void cpufreq_cpu_put(struct cpufreq_policy *policy);
 #else
+static inline struct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)
+{
+	return NULL;
+}
 static inline struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
 {
 	return NULL;

commit ac2a29c8a4a641574febccd10169b26138a5d656
Merge: 4ffe18c2556f 50a3cb04a5f9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 1 15:52:41 2015 +0200

    Merge branch 'pm-opp'
    
    * pm-opp:
      PM / OPP: Drop unlikely before IS_ERR(_OR_NULL)
      PM / OPP: Fix static checker warning (broken 64bit big endian systems)
      PM / OPP: Free resources and properly return error on failure
      cpufreq-dt: make scaling_boost_freqs sysfs attr available when boost is enabled
      cpufreq: dt: Add support for turbo/boost mode
      cpufreq: dt: Add support for operating-points-v2 bindings
      cpufreq: Allow drivers to enable boost support after registering driver
      cpufreq: Update boost flag while initializing freq table from OPPs
      PM / OPP: add dev_pm_opp_is_turbo() helper
      PM / OPP: Add helpers for initializing CPU OPPs
      PM / OPP: Add support for opp-suspend
      PM / OPP: Add OPP sharing information to OPP library
      PM / OPP: Add clock-latency-ns support
      PM / OPP: Add support to parse "operating-points-v2" bindings
      PM / OPP: Break _opp_add_dynamic() into smaller functions
      PM / OPP: Allocate dev_opp from _add_device_opp()
      PM / OPP: Create _remove_device_opp() for freeing dev_opp
      PM / OPP: Relocate few routines
      PM / OPP: Create a directory for opp bindings
      PM / OPP: Update bindings to make opp-hz a 64 bit value

commit c7a7b418dd1991079dd7ef03fec7d1863ef96154
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 3 08:36:19 2015 +0530

    cpufreq: rename cpufreq_real_policy as cpufreq_user_policy
    
    Its all about caching min/max freq requested by userspace, and
    the name 'cpufreq_real_policy' doesn't fit that well. Rename it to
    cpufreq_user_policy.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 54dbbff0a55e..6ff6a4d95eea 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -51,7 +51,7 @@ struct cpufreq_cpuinfo {
 	unsigned int		transition_latency;
 };
 
-struct cpufreq_real_policy {
+struct cpufreq_user_policy {
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
 };
@@ -86,7 +86,7 @@ struct cpufreq_policy {
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
 
-	struct cpufreq_real_policy	user_policy;
+	struct cpufreq_user_policy user_policy;
 	struct cpufreq_frequency_table	*freq_table;
 
 	struct list_head        policy_list;

commit 88dc4384958759510db248bf9158434ac783d407
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 3 08:36:18 2015 +0530

    cpufreq: remove redundant 'policy' field from user_policy
    
    Its always same as policy->policy, and there is no need to keep another
    copy of it. Remove it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 752bf8a5c314..54dbbff0a55e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -54,7 +54,6 @@ struct cpufreq_cpuinfo {
 struct cpufreq_real_policy {
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
-	unsigned int		policy; /* see above */
 };
 
 struct cpufreq_policy {

commit e27f8bd248756310a6df8b67f96d41d5a693642c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 3 08:36:17 2015 +0530

    cpufreq: remove redundant 'governor' field from user_policy
    
    Its always same as policy->governor, and there is no need to keep
    another copy of it. Remove it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bedcc90c0757..752bf8a5c314 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -55,7 +55,6 @@ struct cpufreq_real_policy {
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
 	unsigned int		policy; /* see above */
-	struct cpufreq_governor	*governor; /* see below */
 };
 
 struct cpufreq_policy {

commit 6bfb7c7434f75d29241413dc7e784295ba56de98
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 3 08:36:14 2015 +0530

    cpufreq: remove redundant CPUFREQ_INCOMPATIBLE notifier event
    
    What's being done from CPUFREQ_INCOMPATIBLE, can also be done with
    CPUFREQ_ADJUST. There is nothing special with CPUFREQ_INCOMPATIBLE
    notifier.
    
    Kill CPUFREQ_INCOMPATIBLE and fix its usage sites.
    
    This also updates the numbering of notifier events to remove holes.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bde1e567b3a9..bedcc90c0757 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -369,11 +369,10 @@ static inline void cpufreq_resume(void) {}
 
 /* Policy Notifiers  */
 #define CPUFREQ_ADJUST			(0)
-#define CPUFREQ_INCOMPATIBLE		(1)
-#define CPUFREQ_NOTIFY			(2)
-#define CPUFREQ_START			(3)
-#define CPUFREQ_CREATE_POLICY		(4)
-#define CPUFREQ_REMOVE_POLICY		(5)
+#define CPUFREQ_NOTIFY			(1)
+#define CPUFREQ_START			(2)
+#define CPUFREQ_CREATE_POLICY		(3)
+#define CPUFREQ_REMOVE_POLICY		(4)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit 21c36d35711d24a7689b7fb9606ce78f3b4c3d3b
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Aug 7 13:59:16 2015 +0200

    cpufreq-dt: make scaling_boost_freqs sysfs attr available when boost is enabled
    
    Make scaling_boost_freqs sysfs attribute is available when
    cpufreq-dt driver is used and boost support is enabled.
    
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 95f018649abf..657542d3e23b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -609,6 +609,7 @@ struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
+extern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;
 extern struct freq_attr *cpufreq_generic_attr[];
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);

commit 44139ed4943ee8ec186eea3e9072ca16d2b48133
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 29 16:23:09 2015 +0530

    cpufreq: Allow drivers to enable boost support after registering driver
    
    In some cases it wouldn't be known at time of driver registration, if
    the driver needs to support boost frequencies.
    
    For example, while getting boost information from DT with opp-v2
    bindings, we need to parse the bindings for all the CPUs to know if
    turbo/boost OPPs are supported or not.
    
    One way out to do that efficiently is to delay supporting boost mode
    (i.e. creating /sys/devices/system/cpu/cpufreq/boost file), until the
    time OPP bindings are parsed.
    
    At that point, the driver can enable boost support. This can be done at
    ->init(), where the frequency table is created.
    
    To do that, the driver requires few APIs from cpufreq core that let him
    do this. This patch provides these APIs.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bde1e567b3a9..95f018649abf 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -578,6 +578,8 @@ ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
 int cpufreq_boost_trigger_state(int state);
 int cpufreq_boost_supported(void);
 int cpufreq_boost_enabled(void);
+int cpufreq_enable_boost_support(void);
+bool policy_has_boost_freq(struct cpufreq_policy *policy);
 #else
 static inline int cpufreq_boost_trigger_state(int state)
 {
@@ -591,6 +593,16 @@ static inline int cpufreq_boost_enabled(void)
 {
 	return 0;
 }
+
+static inline int cpufreq_enable_boost_support(void)
+{
+	return -EINVAL;
+}
+
+static inline bool policy_has_boost_freq(struct cpufreq_policy *policy)
+{
+	return false;
+}
 #endif
 /* the following funtion is for cpufreq core use only */
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);

commit 559ed40752dc63e68f9b9ad301b20e6a3fe5cf21
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 26 02:07:47 2015 +0200

    cpufreq: Avoid attempts to create duplicate symbolic links
    
    After commit 87549141d516 (cpufreq: Stop migrating sysfs files on
    hotplug) there is a problem with CPUs that share cpufreq policy
    objects with other CPUs and are initially offline.
    
    Say CPU1 shares a policy with CPU0 which is online and is registered
    first.  As part of the registration process, cpufreq_add_dev() is
    called for it.  It creates the policy object and a symbolic link
    to it from the CPU1's sysfs directory.  If CPU1 is registered
    subsequently and it is offline at that time, cpufreq_add_dev() will
    attempt to create a symbolic link to the policy object for it, but
    that link is present already, so a warning about that will be
    triggered.
    
    To avoid that warning, make cpufreq use an additional CPU mask
    containing related CPUs that are actually present for each policy
    object.  That mask is initialized when the policy object is populated
    after its creation (for the first online CPU using it) and it includes
    CPUs from the "policy CPUs" mask returned by the cpufreq driver's
    ->init() callback that are physically present at that time.  Symbolic
    links to the policy are created only for the CPUs in that mask.
    
    If cpufreq_add_dev() is invoked for an offline CPU, it checks the
    new mask and only creates the symlink if the CPU was not in it (the
    CPU is added to the mask at the same time).
    
    In turn, cpufreq_remove_dev() drops the given CPU from the new mask,
    removes its symlink to the policy object and returns, unless it is
    the CPU owning the policy object.  In that case, the policy object
    is moved to a new CPU's sysfs directory or deleted if the CPU being
    removed was the last user of the policy.
    
    While at it, notice that cpufreq_remove_dev() can't fail, because
    its return value is ignored, so make it ignore return values from
    __cpufreq_remove_dev_prepare() and __cpufreq_remove_dev_finish()
    and prevent these functions from aborting on errors returned by
    __cpufreq_governor().  Also drop the now unused sif argument from
    them.
    
    Fixes: 87549141d516 (cpufreq: Stop migrating sysfs files on hotplug)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-and-tested-by: Russell King <linux@arm.linux.org.uk>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 29ad97c34fd5..bde1e567b3a9 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -62,6 +62,7 @@ struct cpufreq_policy {
 	/* CPUs sharing clock, require sw coordination */
 	cpumask_var_t		cpus;	/* Online CPUs only */
 	cpumask_var_t		related_cpus; /* Online + Offline CPUs */
+	cpumask_var_t		real_cpus; /* Related and present */
 
 	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
 						should set cpufreq */

commit 9d16f207112f77711600fb0770182a06e056e5de
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Mon May 18 10:43:31 2015 +0530

    cpufreq: Track cpu managing sysfs kobjects separately
    
    In order to prepare for the next few commits, that will stop migrating
    sysfs files on cpu hotplug, this patch starts managing sysfs-cpu
    separately.
    
    The behavior is still the same as we are still migrating sysfs files on
    hotplug, later commits would change that.
    
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 48e37c07eb84..29ad97c34fd5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -65,7 +65,9 @@ struct cpufreq_policy {
 
 	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
 						should set cpufreq */
-	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
+	unsigned int		cpu;    /* cpu managing this policy, must be online */
+	unsigned int		kobj_cpu; /* cpu managing sysfs files, can be offline */
+
 	struct clk		*clk;
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 

commit 4573237b01221881702fbe6655f3ae5135be1c18
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue May 12 12:22:34 2015 +0530

    cpufreq: Manage governor usage history with 'policy->last_governor'
    
    History of which governor was used last is common to all CPUs within a
    policy and maintaining it per-cpu isn't the best approach for sure.
    
    Apart from wasting memory, this also increases the complexity of
    managing this data structure as it has to be updated for all CPUs.
    
    To make that somewhat simpler, lets store this information in a new
    field 'last_governor' in struct cpufreq_policy and update it on removal
    of last cpu of a policy.
    
    As a side-effect it also solves an old problem, consider a system with
    two clusters 0 & 1. And there is one policy per cluster.
    
    Cluster 0: CPU0 and 1.
    Cluster 1: CPU2 and 3.
    
     - CPU2 is first brought online, and governor is set to performance
       (default as cpufreq_cpu_governor wasn't set).
     - Governor is changed to ondemand.
     - CPU2 is taken offline and cpufreq_cpu_governor is updated for CPU2.
     - CPU3 is brought online.
     - Because cpufreq_cpu_governor wasn't set for CPU3, the default governor
       performance is picked for CPU3.
    
    This patch fixes the bug as we now have a single variable to update for
    policy.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 2ee4888c1f47..48e37c07eb84 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -80,6 +80,7 @@ struct cpufreq_policy {
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
 	bool			governor_enabled; /* governor start/stop flag */
+	char			last_governor[CPUFREQ_NAME_LEN]; /* last governor used */
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */

commit d9f354460db8b58a8395936d323b4ca6e8428b9d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:10 2015 +0530

    cpufreq: remove CPUFREQ_UPDATE_POLICY_CPU notifications
    
    CPUFREQ_UPDATE_POLICY_CPU notifications were used only from cpufreq-stats which
    doesn't use it anymore. Remove them.
    
    This also decrements values of other notification macros defined after
    CPUFREQ_UPDATE_POLICY_CPU by 1 to remove gaps. Hopefully all users are using
    macro's instead of direct numbers and so they wouldn't break as macro values are
    changed now.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7e1a389b4e92..2ee4888c1f47 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -368,9 +368,8 @@ static inline void cpufreq_resume(void) {}
 #define CPUFREQ_INCOMPATIBLE		(1)
 #define CPUFREQ_NOTIFY			(2)
 #define CPUFREQ_START			(3)
-#define CPUFREQ_UPDATE_POLICY_CPU	(4)
-#define CPUFREQ_CREATE_POLICY		(5)
-#define CPUFREQ_REMOVE_POLICY		(6)
+#define CPUFREQ_CREATE_POLICY		(4)
+#define CPUFREQ_REMOVE_POLICY		(5)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit 7c418ff099110d987846c8c670479a3b90ed1dcb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:08 2015 +0530

    cpufreq: Remove (now) unused 'last_cpu' from struct cpufreq_policy
    
    'last_cpu' was used only from cpufreq-stats and isn't used anymore. Get rid of
    it.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 60b7b496565d..7e1a389b4e92 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -66,8 +66,6 @@ struct cpufreq_policy {
 	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
-	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
-					   * this policy */
 	struct clk		*clk;
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 

commit a9aaf2915ee265735c28b764551d084e61a694e0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 13 11:34:00 2015 +0530

    cpufreq: stats: get rid of per-cpu cpufreq_stats_table
    
    All CPUs sharing a cpufreq policy share stats too. For this reason,
    add a stats pointer to struct cpufreq_policy and drop per-CPU variable
    cpufreq_stats_table used for accessing cpufreq stats so as to reduce
    code complexity.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4d078cebafd2..60b7b496565d 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -113,6 +113,9 @@ struct cpufreq_policy {
 	wait_queue_head_t	transition_wait;
 	struct task_struct	*transition_task; /* Task which is doing the transition */
 
+	/* cpufreq-stats */
+	struct cpufreq_stats	*stats;
+
 	/* For cpufreq driver's internal use */
 	void			*driver_data;
 };

commit 7c45cf31b3ab9be270a7bf6af2926631dc566436
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 27 06:07:51 2014 +0530

    cpufreq: Introduce ->ready() callback for cpufreq drivers
    
    Currently there is no callback for cpufreq drivers which is called once the
    policy is ready to be used. There are some requirements where such a callback is
    required.
    
    One of them is registering a cooling device with the help of
    of_cpufreq_cooling_register(). This routine tries to get 'struct cpufreq_policy'
    for CPUs which isn't yet initialed at the time ->init() is called and so we face
    issues while registering the cooling device.
    
    Because we can't register cooling device from ->init(), we need a callback that
    is called after the policy is ready to be used and hence we introduce ->ready()
    callback.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Eduardo Valentin <edubezval@gmail.com>
    Tested-by: Eduardo Valentin <edubezval@gmail.com>
    Reviewed-by: Lukasz Majewski <l.majewski@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index db3c13085671..4d078cebafd2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -267,6 +267,10 @@ struct cpufreq_driver {
 	void		(*stop_cpu)(struct cpufreq_policy *policy);
 	int		(*suspend)(struct cpufreq_policy *policy);
 	int		(*resume)(struct cpufreq_policy *policy);
+
+	/* Will be called after the driver is fully initialized */
+	void		(*ready)(struct cpufreq_policy *policy);
+
 	struct freq_attr **attr;
 
 	/* platform specific boost support code */

commit 90452e61137a3e88aa705d3efcb3874f3ce8d390
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Nov 27 06:07:49 2014 +0530

    cpufreq: Fix formatting issues in 'struct cpufreq_driver'
    
    Adding any new callback to 'struct cpufreq_driver' gives following checkpatch
    warning:
    
    WARNING: Unnecessary space before function pointer arguments
    +       void    (*ready)        (struct cpufreq_policy *policy);
    
    This is because we have been using a tab spacing between function pointer name
    and its arguments and the new one tried to follow that.
    
    Though we normally don't try to fix every checkpatch warning, specially around
    formatting issues as that creates unnecessary noise over lists. But I thought we
    better fix this so that new additions don't generate these warnings plus it
    looks far better/symmetric now.
    
    So, remove these tab spacing issues in 'struct cpufreq_driver' only + fix
    alignment of all members.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Eduardo Valentin <edubezval@gmail.com>
    Tested-by: Eduardo Valentin <edubezval@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 503b085b7832..db3c13085671 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -217,26 +217,26 @@ __ATTR(_name, 0644, show_##_name, store_##_name)
 
 
 struct cpufreq_driver {
-	char			name[CPUFREQ_NAME_LEN];
-	u8			flags;
-	void			*driver_data;
+	char		name[CPUFREQ_NAME_LEN];
+	u8		flags;
+	void		*driver_data;
 
 	/* needed by all drivers */
-	int	(*init)		(struct cpufreq_policy *policy);
-	int	(*verify)	(struct cpufreq_policy *policy);
+	int		(*init)(struct cpufreq_policy *policy);
+	int		(*verify)(struct cpufreq_policy *policy);
 
 	/* define one out of two */
-	int	(*setpolicy)	(struct cpufreq_policy *policy);
+	int		(*setpolicy)(struct cpufreq_policy *policy);
 
 	/*
 	 * On failure, should always restore frequency to policy->restore_freq
 	 * (i.e. old freq).
 	 */
-	int	(*target)	(struct cpufreq_policy *policy,	/* Deprecated */
-				 unsigned int target_freq,
-				 unsigned int relation);
-	int	(*target_index)	(struct cpufreq_policy *policy,
-				 unsigned int index);
+	int		(*target)(struct cpufreq_policy *policy,
+				  unsigned int target_freq,
+				  unsigned int relation);	/* Deprecated */
+	int		(*target_index)(struct cpufreq_policy *policy,
+					unsigned int index);
 	/*
 	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION
 	 * unset.
@@ -252,27 +252,27 @@ struct cpufreq_driver {
 	 * wish to switch to intermediate frequency for some target frequency.
 	 * In that case core will directly call ->target_index().
 	 */
-	unsigned int (*get_intermediate)(struct cpufreq_policy *policy,
-					 unsigned int index);
-	int	(*target_intermediate)(struct cpufreq_policy *policy,
-				       unsigned int index);
+	unsigned int	(*get_intermediate)(struct cpufreq_policy *policy,
+					    unsigned int index);
+	int		(*target_intermediate)(struct cpufreq_policy *policy,
+					       unsigned int index);
 
 	/* should be defined, if possible */
-	unsigned int	(*get)	(unsigned int cpu);
+	unsigned int	(*get)(unsigned int cpu);
 
 	/* optional */
-	int	(*bios_limit)	(int cpu, unsigned int *limit);
+	int		(*bios_limit)(int cpu, unsigned int *limit);
 
-	int	(*exit)		(struct cpufreq_policy *policy);
-	void	(*stop_cpu)	(struct cpufreq_policy *policy);
-	int	(*suspend)	(struct cpufreq_policy *policy);
-	int	(*resume)	(struct cpufreq_policy *policy);
-	struct freq_attr	**attr;
+	int		(*exit)(struct cpufreq_policy *policy);
+	void		(*stop_cpu)(struct cpufreq_policy *policy);
+	int		(*suspend)(struct cpufreq_policy *policy);
+	int		(*resume)(struct cpufreq_policy *policy);
+	struct freq_attr **attr;
 
 	/* platform specific boost support code */
-	bool                    boost_supported;
-	bool                    boost_enabled;
-	int     (*set_boost)    (int state);
+	bool		boost_supported;
+	bool		boost_enabled;
+	int		(*set_boost)(int state);
 };
 
 /* flags */

commit 51315cdfa0521fff3059cec5fb8ffecc7f37cba7
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Sun Oct 19 11:30:27 2014 +0200

    cpufreq: allow driver-specific data
    
    This commit extends the cpufreq_driver structure with an additional
    'void *driver_data' field that can be filled by the ->probe() function
    of a cpufreq driver to pass additional custom information to the
    driver itself.
    
    A new function called cpufreq_get_driver_data() is added to allow a
    cpufreq driver to retrieve those driver data, since they are typically
    needed from a cpufreq_policy->init() callback, which does not have
    access to the cpufreq_driver structure. This function call is similar
    to the existing cpufreq_get_current_driver() function call.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 138336b6bb04..503b085b7832 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -219,6 +219,7 @@ __ATTR(_name, 0644, show_##_name, store_##_name)
 struct cpufreq_driver {
 	char			name[CPUFREQ_NAME_LEN];
 	u8			flags;
+	void			*driver_data;
 
 	/* needed by all drivers */
 	int	(*init)		(struct cpufreq_policy *policy);
@@ -312,6 +313,7 @@ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
 const char *cpufreq_get_current_driver(void);
+void *cpufreq_get_driver_data(void);
 
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 		unsigned int min, unsigned int max)

commit 413fffc3a1db7f270afdf1ecb35c1edc013acc68
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 28 11:22:23 2014 +0530

    cpufreq: Add support for per-policy driver data
    
    Drivers supporting multiple clusters or multiple 'struct cpufreq_policy'
    instances may need to keep per-policy data. If the core doesn't provide support
    for that, they might do it in the most unoptimized way: 'per-cpu' data.
    
    This patch adds another field in struct cpufreq_policy: 'driver_data'. It isn't
    accessed by core and is for driver's internal use only.
    
    Tested-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7d1955afa62c..138336b6bb04 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -112,6 +112,9 @@ struct cpufreq_policy {
 	spinlock_t		transition_lock;
 	wait_queue_head_t	transition_wait;
 	struct task_struct	*transition_task; /* Task which is doing the transition */
+
+	/* For cpufreq driver's internal use */
+	void			*driver_data;
 };
 
 /* Only for ACPI */

commit 5b0c0b16d48d20e26859907df4dd449e3b3c7f4c
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Mon Jun 30 19:59:33 2014 +0300

    cpufreq: Introduce new relation for freq selection
    
    Introduce CPUFREQ_RELATION_C for frequency selection.
    It selects the frequency with the minimum euclidean distance to target.
    In case of equal distance between 2 frequencies, it will select the
    greater frequency.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 8f8ae95c6e27..7d1955afa62c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -176,6 +176,7 @@ static inline void disable_cpufreq(void) { }
 
 #define CPUFREQ_RELATION_L 0  /* lowest frequency at or above target */
 #define CPUFREQ_RELATION_H 1  /* highest frequency below or at target */
+#define CPUFREQ_RELATION_C 2  /* closest frequency to target */
 
 struct freq_attr {
 	struct attribute attr;

commit 2b1987a9f1e6250c962ca13820d3c69817879266
Author: Brian W Hart <hartb@linux.vnet.ibm.com>
Date:   Fri Jun 27 16:09:39 2014 -0500

    cpufreq: make table sentinel macros unsigned to match use
    
    Commit 5eeaf1f18973 (cpufreq: Fix build error on some platforms that
    use cpufreq_for_each_*) moved function cpufreq_next_valid() to a public
    header.  Warnings are now generated when objects including that header
    are built with -Wsign-compare (as an out-of-tree module might be):
    
    .../include/linux/cpufreq.h: In function cpufreq_next_valid:
    .../include/linux/cpufreq.h:519:27: warning: comparison between signed
    and unsigned integer expressions [-Wsign-compare]
      while ((*pos)->frequency != CPUFREQ_TABLE_END)
                               ^
    .../include/linux/cpufreq.h:520:25: warning: comparison between signed
    and unsigned integer expressions [-Wsign-compare]
       if ((*pos)->frequency != CPUFREQ_ENTRY_INVALID)
                             ^
    
    Constants CPUFREQ_ENTRY_INVALID and CPUFREQ_TABLE_END are signed, but
    are used with unsigned member 'frequency' of cpufreq_frequency_table.
    Update the macro definitions to be explicitly unsigned to match their
    use.
    
    This also corrects potentially wrong behavior of clk_rate_table_iter()
    if unsigned long is wider than usigned int.
    
    Fixes: 5eeaf1f18973 (cpufreq: Fix build error on some platforms that use cpufreq_for_each_*)
    Signed-off-by: Brian W Hart <hartb@linux.vnet.ibm.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ec4112d257bc..8f8ae95c6e27 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -482,8 +482,8 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
  *********************************************************************/
 
 /* Special Values of .frequency field */
-#define CPUFREQ_ENTRY_INVALID	~0
-#define CPUFREQ_TABLE_END	~1
+#define CPUFREQ_ENTRY_INVALID	~0u
+#define CPUFREQ_TABLE_END	~1u
 /* Special Values of .flags field */
 #define CPUFREQ_BOOST_FREQ	(1 << 0)
 

commit 1c03a2d04d7ab6d27c1fef8614f08187d974bd21
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jun 2 22:49:28 2014 +0530

    cpufreq: add support for intermediate (stable) frequencies
    
    Douglas Anderson, recently pointed out an interesting problem due to which
    udelay() was expiring earlier than it should.
    
    While transitioning between frequencies few platforms may temporarily switch to
    a stable frequency, waiting for the main PLL to stabilize.
    
    For example: When we transition between very low frequencies on exynos, like
    between 200MHz and 300MHz, we may temporarily switch to a PLL running at 800MHz.
    No CPUFREQ notification is sent for that. That means there's a period of time
    when we're running at 800MHz but loops_per_jiffy is calibrated at between 200MHz
    and 300MHz. And so udelay behaves badly.
    
    To get this fixed in a generic way, introduce another set of callbacks
    get_intermediate() and target_intermediate(), only for drivers with
    target_index() and CPUFREQ_ASYNC_NOTIFICATION unset.
    
    get_intermediate() should return a stable intermediate frequency platform wants
    to switch to, and target_intermediate() should set CPU to that frequency,
    before jumping to the frequency corresponding to 'index'. Core will take care of
    sending notifications and driver doesn't have to handle them in
    target_intermediate() or target_index().
    
    NOTE: ->target_index() should restore to policy->restore_freq in case of
    failures as core would send notifications for that.
    
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 3f458896d45c..ec4112d257bc 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -75,6 +75,7 @@ struct cpufreq_policy {
 	unsigned int		max;    /* in kHz */
 	unsigned int		cur;    /* in kHz, only needed if cpufreq
 					 * governors are used */
+	unsigned int		restore_freq; /* = policy->cur before transition */
 	unsigned int		suspend_freq; /* freq to set during suspend */
 
 	unsigned int		policy; /* see above */
@@ -221,11 +222,35 @@ struct cpufreq_driver {
 
 	/* define one out of two */
 	int	(*setpolicy)	(struct cpufreq_policy *policy);
+
+	/*
+	 * On failure, should always restore frequency to policy->restore_freq
+	 * (i.e. old freq).
+	 */
 	int	(*target)	(struct cpufreq_policy *policy,	/* Deprecated */
 				 unsigned int target_freq,
 				 unsigned int relation);
 	int	(*target_index)	(struct cpufreq_policy *policy,
 				 unsigned int index);
+	/*
+	 * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION
+	 * unset.
+	 *
+	 * get_intermediate should return a stable intermediate frequency
+	 * platform wants to switch to and target_intermediate() should set CPU
+	 * to to that frequency, before jumping to the frequency corresponding
+	 * to 'index'. Core will take care of sending notifications and driver
+	 * doesn't have to handle them in target_intermediate() or
+	 * target_index().
+	 *
+	 * Drivers can return '0' from get_intermediate() in case they don't
+	 * wish to switch to intermediate frequency for some target frequency.
+	 * In that case core will directly call ->target_index().
+	 */
+	unsigned int (*get_intermediate)(struct cpufreq_policy *policy,
+					 unsigned int index);
+	int	(*target_intermediate)(struct cpufreq_policy *policy,
+				       unsigned int index);
 
 	/* should be defined, if possible */
 	unsigned int	(*get)	(unsigned int cpu);

commit 5eeaf1f1897372590105f155c6a7110b3fa36aef
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Wed May 7 19:33:33 2014 +0300

    cpufreq: Fix build error on some platforms that use cpufreq_for_each_*
    
    On platforms that use cpufreq_for_each_* macros, build fails if
    CONFIG_CPU_FREQ=n, e.g. ARM/shmobile/koelsch/non-multiplatform:
    
    drivers/built-in.o: In function `clk_round_parent':
    clkdev.c:(.text+0xcf168): undefined reference to `cpufreq_next_valid'
    drivers/built-in.o: In function `clk_rate_table_find':
    clkdev.c:(.text+0xcf820): undefined reference to `cpufreq_next_valid'
    make[3]: *** [vmlinux] Error 1
    
    Fix this making cpufreq_next_valid function inline and move it to
    cpufreq.h.
    
    Fixes: 27e289dce297 (cpufreq: Introduce macros for cpufreq_frequency_table iteration)
    Reported-and-tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9d803b529ac2..3f458896d45c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -489,8 +489,15 @@ static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
 }
 #endif
 
-
-bool cpufreq_next_valid(struct cpufreq_frequency_table **pos);
+static inline bool cpufreq_next_valid(struct cpufreq_frequency_table **pos)
+{
+	while ((*pos)->frequency != CPUFREQ_TABLE_END)
+		if ((*pos)->frequency != CPUFREQ_ENTRY_INVALID)
+			return true;
+		else
+			(*pos)++;
+	return false;
+}
 
 /*
  * cpufreq_for_each_entry -	iterate over a cpufreq_frequency_table

commit a0dd7b79657bd6644b914d16ce7f23468c44a7b4
Author: Nishanth Menon <nm@ti.com>
Date:   Mon May 5 08:33:50 2014 -0500

    PM / OPP: Move cpufreq specific OPP functions out of generic OPP library
    
    CPUFreq specific helper functions for OPP (Operating Performance Points)
    now use generic OPP functions that allow CPUFreq to be be moved back
    into CPUFreq framework. This allows for independent modifications
    or future enhancements as needed isolated to just CPUFreq framework
    alone.
    
    Here, we just move relevant code and documentation to make this part of
    CPUFreq infrastructure.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f3822f836e14..9d803b529ac2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -469,6 +469,27 @@ struct cpufreq_frequency_table {
 				    * order */
 };
 
+#if defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM_OPP)
+int dev_pm_opp_init_cpufreq_table(struct device *dev,
+				  struct cpufreq_frequency_table **table);
+void dev_pm_opp_free_cpufreq_table(struct device *dev,
+				   struct cpufreq_frequency_table **table);
+#else
+static inline int dev_pm_opp_init_cpufreq_table(struct device *dev,
+						struct cpufreq_frequency_table
+						**table)
+{
+	return -EINVAL;
+}
+
+static inline void dev_pm_opp_free_cpufreq_table(struct device *dev,
+						 struct cpufreq_frequency_table
+						 **table)
+{
+}
+#endif
+
+
 bool cpufreq_next_valid(struct cpufreq_frequency_table **pos);
 
 /*

commit ca654dc3a93d3b47dddc0c24a98043060bbb256b
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Mon May 5 12:52:39 2014 +0530

    cpufreq: Catch double invocations of cpufreq_freq_transition_begin/end
    
    Some cpufreq drivers were redundantly invoking the _begin() and _end()
    APIs around frequency transitions, and this double invocation (one from
    the cpufreq core and the other from the cpufreq driver) used to result
    in a self-deadlock, leading to system hangs during boot. (The _begin()
    API makes contending callers wait until the previous invocation is
    complete. Hence, the cpufreq driver would end up waiting on itself!).
    
    Now all such drivers have been fixed, but debugging this issue was not
    very straight-forward (even lockdep didn't catch this). So let us add a
    debug infrastructure to the cpufreq core to catch such issues more easily
    in the future.
    
    We add a new field called 'transition_task' to the policy structure, to keep
    track of the task which is performing the frequency transition. Using this
    field, we make note of this task during _begin() and print a warning if we
    find a case where the same task is calling _begin() again, before completing
    the previous frequency transition using the corresponding _end().
    
    We have left out ASYNC_NOTIFICATION drivers from this debug infrastructure
    for 2 reasons:
    
    1. At the moment, we have no way to avoid a particular scenario where this
       debug infrastructure can emit false-positive warnings for such drivers.
       The scenario is depicted below:
    
             Task A                                         Task B
    
        /* 1st freq transition */
        Invoke _begin() {
                ...
                ...
        }
    
        Change the frequency
    
        /* 2nd freq transition */
        Invoke _begin() {
                ... //waiting for B to
                ... //finish _end() for
                ... //the 1st transition
                ...       |                         Got interrupt for successful
                ...       |                         change of frequency (1st one).
                ...       |
                ...       |                         /* 1st freq transition */
                ...       |                         Invoke _end() {
                ...       |                                 ...
                ...       V                         }
                ...
                ...
        }
    
       This scenario is actually deadlock-free because, once Task A changes the
       frequency, it is Task B's responsibility to invoke the corresponding
       _end() for the 1st frequency transition. Hence it is perfectly legal for
       Task A to go ahead and attempt another frequency transition in the meantime.
       (Of course it won't be able to proceed until Task B finishes the 1st _end(),
       but this doesn't cause a deadlock or a hang).
    
       The debug infrastructure cannot handle this scenario and will treat it as
       a deadlock and print a warning. To avoid this, we exclude such drivers
       from the purview of this code.
    
    2. Luckily, we don't _need_ this infrastructure for ASYNC_NOTIFICATION drivers
       at all! The cpufreq core does not automatically invoke the _begin() and
       _end() APIs during frequency transitions in such drivers. Thus, the driver
       alone is responsible for invoking _begin()/_end() and hence there shouldn't
       be any conflicts which lead to double invocations. So, we can skip these
       drivers, since the probability that such drivers will hit this problem is
       extremely low, as outlined above.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 77a5fa191502..f3822f836e14 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -110,6 +110,7 @@ struct cpufreq_policy {
 	bool			transition_ongoing; /* Tracks transition status */
 	spinlock_t		transition_lock;
 	wait_queue_head_t	transition_wait;
+	struct task_struct	*transition_task; /* Task which is doing the transition */
 };
 
 /* Only for ACPI */

commit 27e289dce29764e488c1e13e9aa6950cad1f4aab
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Fri Apr 25 23:15:23 2014 +0300

    cpufreq: Introduce macros for cpufreq_frequency_table iteration
    
    Many cpufreq drivers need to iterate over the cpufreq_frequency_table
    for various tasks.
    
    This patch introduces two macros which can be used for iteration over
    cpufreq_frequency_table keeping a common coding style across drivers:
    
    - cpufreq_for_each_entry: iterate over each entry of the table
    - cpufreq_for_each_valid_entry: iterate over each entry that contains
    a valid frequency.
    
    It should have no functional changes.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5ae5100c1f24..77a5fa191502 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -468,6 +468,27 @@ struct cpufreq_frequency_table {
 				    * order */
 };
 
+bool cpufreq_next_valid(struct cpufreq_frequency_table **pos);
+
+/*
+ * cpufreq_for_each_entry -	iterate over a cpufreq_frequency_table
+ * @pos:	the cpufreq_frequency_table * to use as a loop cursor.
+ * @table:	the cpufreq_frequency_table * to iterate over.
+ */
+
+#define cpufreq_for_each_entry(pos, table)	\
+	for (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)
+
+/*
+ * cpufreq_for_each_valid_entry -     iterate over a cpufreq_frequency_table
+ *	excluding CPUFREQ_ENTRY_INVALID frequencies.
+ * @pos:        the cpufreq_frequency_table * to use as a loop cursor.
+ * @table:      the cpufreq_frequency_table * to iterate over.
+ */
+
+#define cpufreq_for_each_valid_entry(pos, table)	\
+	for (pos = table; cpufreq_next_valid(&pos); pos++)
+
 int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 				    struct cpufreq_frequency_table *table);
 

commit 7f4b04614a273089ad65654f53771c033fadc65e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Mar 28 19:11:47 2014 +0530

    cpufreq: create another field .flags in cpufreq_frequency_table
    
    Currently cpufreq frequency table has two fields: frequency and driver_data.
    driver_data is only for drivers' internal use and cpufreq core shouldn't use
    it at all. But with the introduction of BOOST frequencies, this assumption
    was broken and we started using it as a flag instead.
    
    There are two problems due to this:
    - It is against the description of this field, as driver's data is used by
      the core now.
    - if drivers fill it with -3 for any frequency, then those frequencies are
      never considered by cpufreq core as it is exactly same as value of
      CPUFREQ_BOOST_FREQ, i.e. ~2.
    
    The best way to get this fixed is by creating another field flags which
    will be used for such flags. This patch does that. Along with that various
    drivers need modifications due to the change of struct cpufreq_frequency_table.
    
    Reviewed-by: Gautham R Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c48e595f623e..5ae5100c1f24 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -455,11 +455,14 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/
 
-#define CPUFREQ_ENTRY_INVALID ~0
-#define CPUFREQ_TABLE_END     ~1
-#define CPUFREQ_BOOST_FREQ    ~2
+/* Special Values of .frequency field */
+#define CPUFREQ_ENTRY_INVALID	~0
+#define CPUFREQ_TABLE_END	~1
+/* Special Values of .flags field */
+#define CPUFREQ_BOOST_FREQ	(1 << 0)
 
 struct cpufreq_frequency_table {
+	unsigned int	flags;
 	unsigned int	driver_data; /* driver specific data, not used by core */
 	unsigned int	frequency; /* kHz - doesn't need to be in ascending
 				    * order */

commit 236a98005274d8011136aee4aef52241588a9712
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Mar 24 13:35:46 2014 +0530

    cpufreq: Make cpufreq_notify_transition & cpufreq_notify_post_transition static
    
    cpufreq_notify_transition() and cpufreq_notify_post_transition() shouldn't be
    called directly by cpufreq drivers anymore and so these should be marked static.
    
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index e33760268a86..c48e595f623e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -339,10 +339,6 @@ static inline void cpufreq_resume(void) {}
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 
-void cpufreq_notify_transition(struct cpufreq_policy *policy,
-		struct cpufreq_freqs *freqs, unsigned int state);
-void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
-		struct cpufreq_freqs *freqs, int transition_failed);
 void cpufreq_freq_transition_begin(struct cpufreq_policy *policy,
 		struct cpufreq_freqs *freqs);
 void cpufreq_freq_transition_end(struct cpufreq_policy *policy,

commit 12478cf0c55e5969f740bb38a24b1a0104ae18d8
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Mon Mar 24 13:35:44 2014 +0530

    cpufreq: Make sure frequency transitions are serialized
    
    Whenever we change the frequency of a CPU, we call the PRECHANGE and POSTCHANGE
    notifiers. They must be serialized, i.e. PRECHANGE and POSTCHANGE notifiers
    should strictly alternate, thereby preventing two different sets of PRECHANGE or
    POSTCHANGE notifiers from interleaving arbitrarily.
    
    The following examples illustrate why this is important:
    
    Scenario 1:
    -----------
    A thread reading the value of cpuinfo_cur_freq, will call
    __cpufreq_cpu_get()->cpufreq_out_of_sync()->cpufreq_notify_transition()
    
    The ondemand governor can decide to change the frequency of the CPU at the same
    time and hence it can end up sending the notifications via ->target().
    
    If the notifiers are not serialized, the following sequence can occur:
    - PRECHANGE Notification for freq A (from cpuinfo_cur_freq)
    - PRECHANGE Notification for freq B (from target())
    - Freq changed by target() to B
    - POSTCHANGE Notification for freq B
    - POSTCHANGE Notification for freq A
    
    We can see from the above that the last POSTCHANGE Notification happens for freq
    A but the hardware is set to run at freq B.
    
    Where would we break then?: adjust_jiffies() in cpufreq.c & cpufreq_callback()
    in arch/arm/kernel/smp.c (which also adjusts the jiffies). All the
    loops_per_jiffy calculations will get messed up.
    
    Scenario 2:
    -----------
    The governor calls __cpufreq_driver_target() to change the frequency. At the
    same time, if we change scaling_{min|max}_freq from sysfs, it will end up
    calling the governor's CPUFREQ_GOV_LIMITS notification, which will also call
    __cpufreq_driver_target(). And hence we end up issuing concurrent calls to
    ->target().
    
    Typically, platforms have the following logic in their ->target() routines:
    (Eg: cpufreq-cpu0, omap, exynos, etc)
    
    A. If new freq is more than old: Increase voltage
    B. Change freq
    C. If new freq is less than old: decrease voltage
    
    Now, if the two concurrent calls to ->target() are X and Y, where X is trying to
    increase the freq and Y is trying to decrease it, we get the following race
    condition:
    
    X.A: voltage gets increased for larger freq
    Y.A: nothing happens
    Y.B: freq gets decreased
    Y.C: voltage gets decreased
    X.B: freq gets increased
    X.C: nothing happens
    
    Thus we can end up setting a freq which is not supported by the voltage we have
    set. That will probably make the clock to the CPU unstable and the system might
    not work properly anymore.
    
    This patch introduces a set of synchronization primitives to serialize frequency
    transitions, which are to be used as shown below:
    
    cpufreq_freq_transition_begin();
    
    //Perform the frequency change
    
    cpufreq_freq_transition_end();
    
    The _begin() call sends the PRECHANGE notification whereas the _end() call sends
    the POSTCHANGE notification. Also, all the necessary synchronization is handled
    within these calls. In particular, even drivers which set the ASYNC_NOTIFICATION
    flag can also use these APIs for performing frequency transitions (ie., you can
    call _begin() from one task, and call the corresponding _end() from a different
    task).
    
    The actual synchronization underneath is not that complicated:
    
    The key challenge is to allow drivers to begin the transition from one thread
    and end it in a completely different thread (this is to enable drivers that do
    asynchronous POSTCHANGE notification from bottom-halves, to also use the same
    interface).
    
    To achieve this, a 'transition_ongoing' flag, a 'transition_lock' spinlock and a
    wait-queue are added per-policy. The flag and the wait-queue are used in
    conjunction to create an "uninterrupted flow" from _begin() to _end(). The
    spinlock is used to ensure that only one such "flow" is in flight at any given
    time. Put together, this provides us all the necessary synchronization.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 2d2e62c8666a..e33760268a86 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -16,6 +16,7 @@
 #include <linux/completion.h>
 #include <linux/kobject.h>
 #include <linux/notifier.h>
+#include <linux/spinlock.h>
 #include <linux/sysfs.h>
 
 /*********************************************************************
@@ -104,6 +105,11 @@ struct cpufreq_policy {
 	 *     __cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
 	 */
 	struct rw_semaphore	rwsem;
+
+	/* Synchronization for frequency transitions */
+	bool			transition_ongoing; /* Tracks transition status */
+	spinlock_t		transition_lock;
+	wait_queue_head_t	transition_wait;
 };
 
 /* Only for ACPI */
@@ -337,6 +343,10 @@ void cpufreq_notify_transition(struct cpufreq_policy *policy,
 		struct cpufreq_freqs *freqs, unsigned int state);
 void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
 		struct cpufreq_freqs *freqs, int transition_failed);
+void cpufreq_freq_transition_begin(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs);
+void cpufreq_freq_transition_end(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs, int transition_failed);
 
 #else /* CONFIG_CPU_FREQ */
 static inline int cpufreq_register_notifier(struct notifier_block *nb,

commit 367dc4aa932bfb33a3189064d33f7890a8ec1ca8
Author: Dirk Brandewie <dirk.j.brandewie@intel.com>
Date:   Wed Mar 19 08:45:53 2014 -0700

    cpufreq: Add stop CPU callback to cpufreq_driver interface
    
    This callback allows the driver to do clean up before the CPU is
    completely down and its state cannot be modified.  This is used
    by the intel_pstate driver to reduce the requested P state prior to
    the core going away.  This is required because the requested P state
    of the offline core is used to select the package P state. This
    effectively sets the floor package P state to the requested P state on
    the offline core.
    
    Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    [rjw: Minor modifications]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 70929bcf1a9d..2d2e62c8666a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -227,6 +227,7 @@ struct cpufreq_driver {
 	int	(*bios_limit)	(int cpu, unsigned int *limit);
 
 	int	(*exit)		(struct cpufreq_policy *policy);
+	void	(*stop_cpu)	(struct cpufreq_policy *policy);
 	int	(*suspend)	(struct cpufreq_policy *policy);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;

commit 0b443ead714f0cba797a7f2476dd756f22b5421e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Mar 19 11:24:58 2014 +0530

    cpufreq: remove unused notifier: CPUFREQ_{SUSPENDCHANGE|RESUMECHANGE}
    
    Two cpufreq notifiers CPUFREQ_RESUMECHANGE and CPUFREQ_SUSPENDCHANGE have
    not been used for some time, so remove them to clean up code a bit.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 31c431e150a7..70929bcf1a9d 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -318,8 +318,6 @@ static inline void cpufreq_resume(void) {}
 /* Transition notifiers */
 #define CPUFREQ_PRECHANGE		(0)
 #define CPUFREQ_POSTCHANGE		(1)
-#define CPUFREQ_RESUMECHANGE		(8)
-#define CPUFREQ_SUSPENDCHANGE		(9)
 
 /* Policy Notifiers  */
 #define CPUFREQ_ADJUST			(0)

commit 979d86fac5e6dbf5c939e9a2a9fe294c9e05e42f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Mar 10 14:53:34 2014 +0530

    cpufreq: Remove cpufreq_generic_exit()
    
    cpufreq_generic_exit() is empty now and can be deleted.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 79341350f498..31c431e150a7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -508,9 +508,4 @@ unsigned int cpufreq_generic_get(unsigned int cpu);
 int cpufreq_generic_init(struct cpufreq_policy *policy,
 		struct cpufreq_frequency_table *table,
 		unsigned int transition_latency);
-static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
-{
-	return 0;
-}
-
 #endif /* _LINUX_CPUFREQ_H */

commit e0b3165ba521c6824b3e9f563f38a701dfa2d8e6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Mar 10 14:53:33 2014 +0530

    cpufreq: add 'freq_table' in struct cpufreq_policy
    
    freq table is not per CPU but per policy, so it makes more sense to
    keep it within struct cpufreq_policy instead of a per-cpu variable.
    
    This patch does it. Over that, there is no need to set policy->freq_table
    to NULL in ->exit(), as policy structure is going to be freed soon.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 325bab04271b..79341350f498 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -85,6 +85,7 @@ struct cpufreq_policy {
 					 * called, but you're in IRQ context */
 
 	struct cpufreq_real_policy	user_policy;
+	struct cpufreq_frequency_table	*freq_table;
 
 	struct list_head        policy_list;
 	struct kobject		kobj;
@@ -474,7 +475,6 @@ int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
 		unsigned int freq);
 
-void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
 
 #ifdef CONFIG_CPU_FREQ
@@ -501,9 +501,6 @@ struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 extern struct freq_attr *cpufreq_generic_attr[];
-void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
-				      unsigned int cpu);
-void cpufreq_frequency_table_put_attr(unsigned int cpu);
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);
 
@@ -513,7 +510,6 @@ int cpufreq_generic_init(struct cpufreq_policy *policy,
 		unsigned int transition_latency);
 static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
 {
-	cpufreq_frequency_table_put_attr(policy->cpu);
 	return 0;
 }
 

commit e28867eab7c0a60cddf0cb59f9f6cbbd9561425d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Mar 4 11:00:27 2014 +0800

    cpufreq: Implement cpufreq_generic_suspend()
    
    Multiple platforms need to set CPUs to a particular frequency before
    suspending the system, so provide a common infrastructure for them.
    
    Those platforms only need to point their ->suspend callback pointers
    to the generic routine.
    
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 94ed907c6999..325bab04271b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -74,6 +74,8 @@ struct cpufreq_policy {
 	unsigned int		max;    /* in kHz */
 	unsigned int		cur;    /* in kHz, only needed if cpufreq
 					 * governors are used */
+	unsigned int		suspend_freq; /* freq to set during suspend */
+
 	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
@@ -299,6 +301,7 @@ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 #ifdef CONFIG_CPU_FREQ
 void cpufreq_suspend(void);
 void cpufreq_resume(void);
+int cpufreq_generic_suspend(struct cpufreq_policy *policy);
 #else
 static inline void cpufreq_suspend(void) {}
 static inline void cpufreq_resume(void) {}

commit 2f0aea9363609433b38ab13f0f86f38372668c68
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Mar 4 11:00:26 2014 +0800

    cpufreq: suspend governors on system suspend/hibernate
    
    This patch adds cpufreq suspend/resume calls to dpm_{suspend|resume}()
    for handling suspend/resume of cpufreq governors.
    
    Lan Tianyu (Intel) & Jinhyuk Choi (Broadcom) found an issue where the
    tunables configuration for clusters/sockets with non-boot CPUs was
    lost after system suspend/resume, as we were notifying governors with
    CPUFREQ_GOV_POLICY_EXIT on removal of the last CPU for that policy
    which caused the tunables memory to be freed.
    
    This is fixed by preventing any governor operations from being
    carried out between the device suspend and device resume stages of
    system suspend and resume, respectively.
    
    We could have added these callbacks at dpm_{suspend|resume}_noirq()
    level, but there is an additional problem that the majority of I/O
    devices is already suspended at that point and if cpufreq drivers
    want to change the frequency before suspending, then that not be
    possible on some platforms (which depend on peripherals like i2c,
    regulators, etc).
    
    Reported-and-tested-by: Lan Tianyu <tianyu.lan@intel.com>
    Reported-by: Jinhyuk Choi <jinchoi@broadcom.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [rjw: Changelog]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4d89e0e6f9cc..94ed907c6999 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -296,6 +296,14 @@ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 			policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_FREQ
+void cpufreq_suspend(void);
+void cpufreq_resume(void);
+#else
+static inline void cpufreq_suspend(void) {}
+static inline void cpufreq_resume(void) {}
+#endif
+
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/

commit 6f19efc0a1ca08bc61841b971d8b85ab505d95c8
Author: Lukasz Majewski <l.majewski@samsung.com>
Date:   Fri Dec 20 15:24:49 2013 +0100

    cpufreq: Add boost frequency support in core
    
    This commit adds boost frequency support in cpufreq core (Hardware &
    Software). Some SoCs (like Exynos4 - e.g. 4x12) allow setting frequency
    above its normal operation limits. Such mode shall be only used for a
    short time.
    
    Overclocking (boost) support is essentially provided by platform
    dependent cpufreq driver.
    
    This commit unifies support for SW and HW (Intel) overclocking solutions
    in the core cpufreq driver. Previously the "boost" sysfs attribute was
    defined in the ACPI processor driver code. By default boost is disabled.
    One global attribute is available at: /sys/devices/system/cpu/cpufreq/boost.
    
    It only shows up when cpufreq driver supports overclocking.
    Under the hood frequencies dedicated for boosting are marked with a
    special flag (CPUFREQ_BOOST_FREQ) at driver's frequency table.
    It is the user's concern to enable/disable overclocking with a proper call
    to sysfs.
    
    The cpufreq_boost_trigger_state() function is defined non static on purpose.
    It is used later with thermal subsystem to provide automatic enable/disable
    of the BOOST feature.
    
    Signed-off-by: Lukasz Majewski <l.majewski@samsung.com>
    Signed-off-by: Myungjoo Ham <myungjoo.ham@samsung.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 422f10561e0b..4d89e0e6f9cc 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -227,6 +227,11 @@ struct cpufreq_driver {
 	int	(*suspend)	(struct cpufreq_policy *policy);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
+
+	/* platform specific boost support code */
+	bool                    boost_supported;
+	bool                    boost_enabled;
+	int     (*set_boost)    (int state);
 };
 
 /* flags */
@@ -435,6 +440,7 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 
 #define CPUFREQ_ENTRY_INVALID ~0
 #define CPUFREQ_TABLE_END     ~1
+#define CPUFREQ_BOOST_FREQ    ~2
 
 struct cpufreq_frequency_table {
 	unsigned int	driver_data; /* driver specific data, not used by core */
@@ -460,6 +466,24 @@ int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
 
+#ifdef CONFIG_CPU_FREQ
+int cpufreq_boost_trigger_state(int state);
+int cpufreq_boost_supported(void);
+int cpufreq_boost_enabled(void);
+#else
+static inline int cpufreq_boost_trigger_state(int state)
+{
+	return 0;
+}
+static inline int cpufreq_boost_supported(void)
+{
+	return 0;
+}
+static inline int cpufreq_boost_enabled(void)
+{
+	return 0;
+}
+#endif
 /* the following funtion is for cpufreq core use only */
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 

commit 652ed95d5fa6074b3c4ea245deb0691f1acb6656
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 9 20:38:43 2014 +0530

    cpufreq: introduce cpufreq_generic_get() routine
    
    CPUFreq drivers that use clock frameworks interface,i.e. clk_get_rate(),
    to get CPUs clk rate, have similar sort of code used in most of them.
    
    This patch adds a generic ->get() which will do the same thing for them.
    All those drivers are required to now is to set .get to cpufreq_generic_get()
    and set their clk pointer in policy->clk during ->init().
    
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index bb727eb98ed5..422f10561e0b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -11,6 +11,7 @@
 #ifndef _LINUX_CPUFREQ_H
 #define _LINUX_CPUFREQ_H
 
+#include <linux/clk.h>
 #include <linux/cpumask.h>
 #include <linux/completion.h>
 #include <linux/kobject.h>
@@ -66,6 +67,7 @@ struct cpufreq_policy {
 	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
 	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
 					   * this policy */
+	struct clk		*clk;
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 
 	unsigned int		min;    /* in kHz */
@@ -470,6 +472,7 @@ void cpufreq_frequency_table_put_attr(unsigned int cpu);
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);
 
+unsigned int cpufreq_generic_get(unsigned int cpu);
 int cpufreq_generic_init(struct cpufreq_policy *policy,
 		struct cpufreq_frequency_table *table,
 		unsigned int transition_latency);

commit fcd7af917abba798cd954419030142e95139359f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:10 2014 +0530

    cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
    
    There are several problems with cpufreq stats in the way it handles
    cpufreq_unregister_driver() and suspend/resume..
    
     - We must not lose data collected so far when suspend/resume happens
       and so stats directories must not be removed/allocated during these
       operations, which is done currently.
    
     - cpufreq_stat has registered notifiers with both cpufreq and hotplug.
       It adds sysfs stats directory with a cpufreq notifier: CPUFREQ_NOTIFY
       and removes this directory with a notifier from hotplug core.
    
       In case cpufreq_unregister_driver() is called (on rmmod cpufreq driver),
       stats directories per cpu aren't removed as CPUs are still online. The
       only call cpufreq_stats gets is cpufreq_stats_update_policy_cpu() for
       all CPUs except the last of each policy. And pointer to stat information
       is stored in the entry for last CPU in the per-cpu cpufreq_stats_table.
       But policy structure would be freed inside cpufreq core and so that will
       result in memory leak inside cpufreq stats (as we are never freeing
       memory for stats).
    
       Now if we again insert the module cpufreq_register_driver() will be
       called and we will again allocate stats data and put it on for first
       CPU of every policy.  In case we only have a single CPU per policy, we
       will return with a error from cpufreq_stats_create_table() due to this
       code:
    
            if (per_cpu(cpufreq_stats_table, cpu))
                    return -EBUSY;
    
       And so probably cpufreq stats directory would not show up anymore (as
       it was added inside last policies->kobj which doesn't exist anymore).
       I haven't tested it, though. Also the values in stats files wouldn't
       be refreshed as we are using the earlier stats structure.
    
     - CPUFREQ_NOTIFY is called from cpufreq_set_policy() which is called for
       scenarios where we don't really want cpufreq_stat_notifier_policy() to get
       called. For example whenever we are changing anything related to a policy:
       min/max/current freq, etc. cpufreq_set_policy() is called and so cpufreq
       stats is notified. Where we don't do any useful stuff other than simply
       returning with -EBUSY from cpufreq_stats_create_table(). And so this
       isn't the right notifier that cpufreq stats..
    
     Due to all above reasons this patch does following changes:
     - Add new notifiers CPUFREQ_CREATE_POLICY and CPUFREQ_REMOVE_POLICY,
       which are only called when policy is created/destroyed. They aren't
       called for suspend/resume paths..
     - Use these notifiers in cpufreq_stat_notifier_policy() to create/destory
       stats sysfs entries. And so cpufreq_unregister_driver() or suspend/resume
       shouldn't be a problem for cpufreq_stats.
     - Return early from cpufreq_stat_cpu_callback() for suspend/resume sequence,
       so that we don't free stats structure.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index aaf800eb9dd2..bb727eb98ed5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -308,6 +308,8 @@ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 #define CPUFREQ_NOTIFY			(2)
 #define CPUFREQ_START			(3)
 #define CPUFREQ_UPDATE_POLICY_CPU	(4)
+#define CPUFREQ_CREATE_POLICY		(5)
+#define CPUFREQ_REMOVE_POLICY		(6)
 
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);

commit d3916691c90dfc9f08328d5cef8181e9ea508c55
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Dec 3 11:20:46 2013 +0530

    cpufreq: Make sure CPU is running on a freq from freq-table
    
    Sometimes boot loaders set CPU frequency to a value outside of frequency table
    present with cpufreq core. In such cases CPU might be unstable if it has to run
    on that frequency for long duration of time and so its better to set it to a
    frequency which is specified in freq-table. This also makes cpufreq stats
    inconsistent as cpufreq-stats would fail to register because current frequency
    of CPU isn't found in freq-table.
    
    Because we don't want this change to affect boot process badly, we go for the
    next freq which is >= policy->cur ('cur' must be set by now, otherwise we will
    end up setting freq to lowest of the table as 'cur' is initialized to zero).
    
    In case current frequency doesn't match any frequency from freq-table, we throw
    warnings to user, so that user can get this fixed in their bootloaders or
    freq-tables.
    
    Reported-by: Carlos Hernandez <ceh@ti.com>
    Reported-and-tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 91b8c84e8cd0..aaf800eb9dd2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -450,6 +450,8 @@ int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
 				   unsigned int relation,
 				   unsigned int *index);
+int cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,
+		unsigned int freq);
 
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);

commit ae6b427132ba39d023e332e7d920e9931ff05313
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Dec 3 11:20:45 2013 +0530

    cpufreq: Mark ARM drivers with CPUFREQ_NEED_INITIAL_FREQ_CHECK flag
    
    Sometimes boot loaders set CPU frequency to a value outside of frequency table
    present with cpufreq core. In such cases CPU might be unstable if it has to run
    on that frequency for long duration of time and so its better to set it to a
    frequency which is specified in frequency table.
    
    On some systems we can't really say what frequency we're running at the moment
    and so for these we shouldn't check if we are running at a frequency present in
    frequency table. And so we really can't force this for all the cpufreq drivers.
    
    Hence we are created another flag here: CPUFREQ_NEED_INITIAL_FREQ_CHECK that
    will be marked by platforms which want to go for this check at boot time.
    
    Initially this is done for all ARM platforms but others may follow if required.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 88aa0f342e85..91b8c84e8cd0 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -252,6 +252,15 @@ struct cpufreq_driver {
  */
 #define CPUFREQ_ASYNC_NOTIFICATION  (1 << 4)
 
+/*
+ * Set by drivers which want cpufreq core to check if CPU is running at a
+ * frequency present in freq-table exposed by the driver. For these drivers if
+ * CPU is found running at an out of table freq, we will try to set it to a freq
+ * from the table. And if that fails, we will stop further boot process by
+ * issuing a BUG_ON().
+ */
+#define CPUFREQ_NEED_INITIAL_FREQ_CHECK	(1 << 5)
+
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 

commit f7ba3b41e27129575201f0f9656e83fb67e86c3b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Dec 2 11:04:12 2013 +0530

    cpufreq: Introduce cpufreq_notify_post_transition()
    
    This introduces a new routine cpufreq_notify_post_transition() which
    can be used to send POSTCHANGE notification for new freq with or
    without both {PRE|POST}CHANGE notifications for last freq. This is
    useful at multiple places, especially for sending transition failure
    notifications.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index dc196bbcf227..88aa0f342e85 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -306,6 +306,8 @@ int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 
 void cpufreq_notify_transition(struct cpufreq_policy *policy,
 		struct cpufreq_freqs *freqs, unsigned int state);
+void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs, int transition_failed);
 
 #else /* CONFIG_CPU_FREQ */
 static inline int cpufreq_register_notifier(struct notifier_block *nb,

commit 12205a4b79bef56ef618a4b7caa840c5c971cff2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 8 01:04:17 2013 +0100

    Revert "cpufreq: suspend governors on system suspend/hibernate"
    
    Commit 5a87182aa21d (cpufreq: suspend governors on system
    suspend/hibernate) causes hibernation problems to happen on
    Bjrn Mork's and Paul Bolle's systems, so revert it.
    
    Fixes: 5a87182aa21d (cpufreq: suspend governors on system suspend/hibernate)
    Reported-by: Bjrn Mork <bjorn@mork.no>
    Reported-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ee5fe9d77ae8..dc196bbcf227 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -280,14 +280,6 @@ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 			policy->cpuinfo.max_freq);
 }
 
-#ifdef CONFIG_CPU_FREQ
-void cpufreq_suspend(void);
-void cpufreq_resume(void);
-#else
-static inline void cpufreq_suspend(void) {}
-static inline void cpufreq_resume(void) {}
-#endif
-
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/

commit 7cdcec991c06cd6d792b304851cc245cfec507a7
Merge: dc1ccc48159d 813e8e3d6aaa 2167e2399dc5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Dec 6 02:17:59 2013 +0100

    Merge branches 'pm-cpuidle' and 'pm-cpufreq'
    
    * pm-cpuidle:
      cpuidle: Check for dev before deregistering it.
      intel_idle: Fixed C6 state on Avoton/Rangeley processors
    
    * pm-cpufreq:
      cpufreq: fix garbage kobjects on errors during suspend/resume
      cpufreq: suspend governors on system suspend/hibernate

commit 5a87182aa21d6d5d306840feab9321818dd3e2a3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Nov 27 09:09:42 2013 +0530

    cpufreq: suspend governors on system suspend/hibernate
    
    This patch adds cpufreq suspend/resume calls to dpm_{suspend|resume}_noirq()
    for handling suspend/resume of cpufreq governors.
    
    Lan Tianyu (Intel) & Jinhyuk Choi (Broadcom) found anr issue where
    tunables configuration for clusters/sockets with non-boot CPUs was
    getting lost after suspend/resume, as we were notifying governors
    with CPUFREQ_GOV_POLICY_EXIT on removal of the last cpu for that
    policy and so deallocating memory for tunables. This is fixed by
    this patch as we don't allow any operation on governors after
    device suspend and before device resume now.
    
    Reported-and-tested-by: Lan Tianyu <tianyu.lan@intel.com>
    Reported-by: Jinhyuk Choi <jinchoi@broadcom.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [rjw: Changelog, minor cleanups]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5bd6ab9b0c27..91716658e9a1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -272,6 +272,14 @@ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 			policy->cpuinfo.max_freq);
 }
 
+#ifdef CONFIG_CPU_FREQ
+void cpufreq_suspend(void);
+void cpufreq_resume(void);
+#else
+static inline void cpufreq_suspend(void) {}
+static inline void cpufreq_resume(void) {}
+#endif
+
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/

commit 049ffa8ab33a63b3bff672d1a0ee6a35ad253fe8
Merge: c681427e5ca2 0846c728e20a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 14:19:54 2013 +0900

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "This is a combo of -next and some -fixes that came in in the
      intervening time.
    
      Highlights:
    
      New drivers:
        ARM Armada driver for Marvell Armada 510 SOCs
    
      Intel:
        Broadwell initial support under a default off switch,
        Stereo/3D HDMI mode support
        Valleyview improvements
        Displayport improvements
        Haswell fixes
        initial mipi dsi panel support
        CRC support for debugging
        build with CONFIG_FB=n
    
      Radeon:
        enable DPM on a number of GPUs by default
        secondary GPU powerdown support
        enable HDMI audio by default
        Hawaii support
    
      Nouveau:
        dynamic pm code infrastructure reworked, does nothing major yet
        GK208 modesetting support
        MSI fixes, on by default again
        PMPEG improvements
        pageflipping fixes
    
      GMA500:
        minnowboard SDVO support
    
      VMware:
        misc fixes
    
      MSM:
        prime, plane and rendernodes support
    
      Tegra:
        rearchitected to put the drm driver into the drm subsystem.
        HDMI and gr2d support for tegra 114 SoC
    
      QXL:
        oops fix, and multi-head fixes
    
      DRM core:
        sysfs lifetime fixes
        client capability ioctl
        further cleanups to device midlayer
        more vblank timestamp fixes"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (789 commits)
      drm/nouveau: do not map evicted vram buffers in nouveau_bo_vma_add
      drm/nvc0-/gr: shift wrapping bug in nvc0_grctx_generate_r406800
      drm/nouveau/pwr: fix missing mutex unlock in a failure path
      drm/nv40/therm: fix slowing down fan when pstate undefined
      drm/nv11-: synchronise flips to vblank, unless async flip requested
      drm/nvc0-: remove nasty fifo swmthd hack for flip completion method
      drm/nv10-: we no longer need to create nvsw object on user channels
      drm/nouveau: always queue flips relative to kernel channel activity
      drm/nouveau: there is no need to reserve/fence the new fb when flipping
      drm/nouveau: when bailing out of a pushbuf ioctl, do not remove previous fence
      drm/nouveau: allow nouveau_fence_ref() to be a noop
      drm/nvc8/mc: msi rearm is via the nvc0 method
      drm/ttm: Fix vma page_prot bit manipulation
      drm/vmwgfx: Fix a couple of compile / sparse warnings and errors
      drm/vmwgfx: Resource evict fixes
      drm/edid: compare actual vrefresh for all modes for quirks
      drm: shmob_drm: Convert to clk_prepare/unprepare
      drm/nouveau: fix 32-bit build
      drm/i915/opregion: fix build error on CONFIG_ACPI=n
      Revert "drm/radeon/audio: don't set speaker allocation on DCE4+"
      ...

commit 7dbf694db6ac7c759599316d50d7050efcbd512a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Oct 29 18:56:06 2013 +0530

    cpufreq: distinguish drivers that do asynchronous notifications
    
    There are few special cases like exynos5440 which doesn't send POSTCHANGE
    notification from their ->target() routine and call some kind of bottom halves
    for doing this work, work/tasklet/etc.. From which they finally send POSTCHANGE
    notification.
    
    Its better if we distinguish them from other cpufreq drivers in some way so that
    core can handle them specially. So this patch introduces another flag:
    CPUFREQ_ASYNC_NOTIFICATION, which will be set by such drivers.
    
    This also changes exynos5440-cpufreq.c and powernow-k8 in order to set this
    flag.
    
    Acked-by: Amit Daniel Kachhap <amit.daniel@samsung.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 93a8c34d6c7f..5bd6ab9b0c27 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -237,6 +237,13 @@ struct cpufreq_driver {
  */
 #define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
 
+/*
+ * Driver will do POSTCHANGE notifications from outside of their ->target()
+ * routine and so must set cpufreq_driver->flags with this flag, so that core
+ * can handle them specially.
+ */
+#define CPUFREQ_ASYNC_NOTIFICATION  (1 << 4)
+
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 

commit ad7722dab7292dbc1c4586d701ac226b68122d39
Author: viresh kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 18 19:10:15 2013 +0530

    cpufreq: create per policy rwsem instead of per CPU cpu_policy_rwsem
    
    We have per-CPU cpu_policy_rwsem for cpufreq core, but we never use
    all of them. We always use rwsem of policy->cpu and so we can
    actually make this rwsem per policy instead.
    
    This patch does this change. With this change other tricky situations
    are also avoided now, like which lock to take while we are changing
    policy->cpu, etc.
    
    Suggested-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index e8c77d330479..93a8c34d6c7f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -85,6 +85,20 @@ struct cpufreq_policy {
 	struct list_head        policy_list;
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
+
+	/*
+	 * The rules for this semaphore:
+	 * - Any routine that wants to read from the policy structure will
+	 *   do a down_read on this semaphore.
+	 * - Any routine that will write to the policy structure and/or may take away
+	 *   the policy altogether (eg. CPU hotplug), will hold this lock in write
+	 *   mode before doing so.
+	 *
+	 * Additional rules:
+	 * - Lock should not be held across
+	 *     __cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
+	 */
+	struct rw_semaphore	rwsem;
 };
 
 /* Only for ACPI */

commit 9c0ebcf78fde0ffa348a95a544c6d3f2dac5af65
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 25 19:45:48 2013 +0530

    cpufreq: Implement light weight ->target_index() routine
    
    Currently, the prototype of cpufreq_drivers target routines is:
    
    int target(struct cpufreq_policy *policy, unsigned int target_freq,
                    unsigned int relation);
    
    And most of the drivers call cpufreq_frequency_table_target() to get a valid
    index of their frequency table which is closest to the target_freq. And they
    don't use target_freq and relation after that.
    
    So, it makes sense to just do this work in cpufreq core before calling
    cpufreq_frequency_table_target() and simply pass index instead. But this can be
    done only with drivers which expose their frequency table with cpufreq core. For
    others we need to stick with the old prototype of target() until those drivers
    are converted to expose frequency tables.
    
    This patch implements the new light weight prototype for target_index() routine.
    It looks like this:
    
    int target_index(struct cpufreq_policy *policy, unsigned int index);
    
    CPUFreq core will call cpufreq_frequency_table_target() before calling this
    routine and pass index to it. Because CPUFreq core now requires to call routines
    present in freq_table.c CONFIG_CPU_FREQ_TABLE must be enabled all the time.
    
    This also marks target() interface as deprecated. So, that new drivers avoid
    using it. And Documentation is updated accordingly.
    
    It also converts existing .target() to newly defined light weight
    .target_index() routine for many driver.
    
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Russell King <linux@arm.linux.org.uk>
    Acked-by: David S. Miller <davem@davemloft.net>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rjw@rjwysocki.net>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0aba2a6cadaf..e8c77d330479 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -187,9 +187,11 @@ struct cpufreq_driver {
 
 	/* define one out of two */
 	int	(*setpolicy)	(struct cpufreq_policy *policy);
-	int	(*target)	(struct cpufreq_policy *policy,
+	int	(*target)	(struct cpufreq_policy *policy,	/* Deprecated */
 				 unsigned int target_freq,
 				 unsigned int relation);
+	int	(*target_index)	(struct cpufreq_policy *policy,
+				 unsigned int index);
 
 	/* should be defined, if possible */
 	unsigned int	(*get)	(unsigned int cpu);

commit c75b505ddaa08098940441226bb3a87c5b3179c0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 8 10:56:11 2013 +0200

    cpufreq: Add dummy cpufreq_cpu_get/put for CONFIG_CPU_FREQ=n
    
    The drm/i915 driver wants to adjust it's own power policies using the
    cpu policies as a guideline (we can implicitly boost the cpus through
    the gpus on some platforms). To avoid a dreaded select (since a
    depends will leave users wondering where where their driver has gone
    too) add dummy functions.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: cpufreq@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index fcabc42d66ab..5ad9a4e2bc59 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -93,8 +93,16 @@ struct cpufreq_policy {
 #define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */
 #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
+#ifdef CONFIG_CPU_FREQ
 struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 void cpufreq_cpu_put(struct cpufreq_policy *policy);
+#else
+static inline struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
+{
+	return NULL;
+}
+static inline void cpufreq_cpu_put(struct cpufreq_policy *policy) { }
+#endif
 
 static inline bool policy_is_shared(struct cpufreq_policy *policy)
 {

commit 70e9e778337973d5bf57004092b360bd3f3c412f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Oct 3 20:29:07 2013 +0530

    cpufreq: create cpufreq_generic_init() routine
    
    Many CPUFreq drivers for SMP system (where all cores share same clock lines), do
    similar stuff in their ->init() part.
    
    This patch creates a generic routine in cpufreq core which can be used by these
    so that we can remove some redundant code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 36ccd0bf1304..0aba2a6cadaf 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -424,6 +424,9 @@ void cpufreq_frequency_table_put_attr(unsigned int cpu);
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);
 
+int cpufreq_generic_init(struct cpufreq_policy *policy,
+		struct cpufreq_frequency_table *table,
+		unsigned int transition_latency);
 static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
 {
 	cpufreq_frequency_table_put_attr(policy->cpu);

commit 184345129c53e76069c209f9912ed7c457eceb31
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Oct 3 20:27:55 2013 +0530

    cpufreq: define generic .attr, .exit() and .verify() routines
    
    Most of the CPUFreq drivers do similar things in .exit() and .verify() routines
    and .attr. So its better if we have generic routines for them which can be used
    by cpufreq drivers then.
    
    This patch introduces generic .attr, .exit() and .verify() cpufreq drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c7495915932d..36ccd0bf1304 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -401,6 +401,7 @@ int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
 
 int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
 				   struct cpufreq_frequency_table *table);
+int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy);
 
 int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 				   struct cpufreq_frequency_table *table,
@@ -416,10 +417,17 @@ struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
+extern struct freq_attr *cpufreq_generic_attr[];
 void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
 				      struct cpufreq_frequency_table *table);
 
+static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
+{
+	cpufreq_frequency_table_put_attr(policy->cpu);
+	return 0;
+}
+
 #endif /* _LINUX_CPUFREQ_H */

commit be49e3465f222b4b796be8a21d14afbfd8f5d20f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 2 14:13:19 2013 +0530

    cpufreq: add new routine cpufreq_verify_within_cpu_limits()
    
    Most of the users of cpufreq_verify_within_limits() calls it for
    limiting with min/max from policy->cpuinfo. We can make that code
    simple by introducing another routine which will do this for them
    automatically.
    
    This patch adds another routine cpufreq_verify_within_cpu_limits()
    and updates others to use it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 24b84f7e7f8d..c7495915932d 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -242,6 +242,13 @@ static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 	return;
 }
 
+static inline void
+cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
+{
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+			policy->cpuinfo.max_freq);
+}
+
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/

commit 0b981e70748861a3e10ea2e2a689bdcee3e15085
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 2 14:13:18 2013 +0530

    cpufreq: use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY
    
    Use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY instead
    of a separate field within cpufreq_driver. This will save some bytes of
    memory.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 00c80a5372db..24b84f7e7f8d 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -180,13 +180,6 @@ __ATTR(_name, 0644, show_##_name, store_##_name)
 struct cpufreq_driver {
 	char			name[CPUFREQ_NAME_LEN];
 	u8			flags;
-	/*
-	 * This should be set by platforms having multiple clock-domains, i.e.
-	 * supporting multiple policies. With this sysfs directories of governor
-	 * would be created in cpu/cpu<num>/cpufreq/ directory and so they can
-	 * use the same governor with different tunables for different clusters.
-	 */
-	bool			have_governor_per_policy;
 
 	/* needed by all drivers */
 	int	(*init)		(struct cpufreq_policy *policy);
@@ -220,6 +213,14 @@ struct cpufreq_driver {
 #define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
 						   speed mismatches */
 
+/*
+ * This should be set by platforms having multiple clock-domains, i.e.
+ * supporting multiple policies. With this sysfs directories of governor would
+ * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
+ * governor with different tunables for different clusters.
+ */
+#define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 

commit 6461f018e7ad08863b55c386bf694683e4e2e86e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 2 14:13:17 2013 +0530

    cpufreq: rewrite cpufreq_driver->flags using shift operator
    
    Currently cpufreq_driver's flags are defined directly using 0x1, 0x2, 0x4, 0x8,
    etc.. As the list grows it becomes less readable..
    
    Use bitwise shift operator << to generate these numbers for respective
    positions.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6b199ed7aa58..00c80a5372db 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -211,13 +211,14 @@ struct cpufreq_driver {
 };
 
 /* flags */
-#define CPUFREQ_STICKY		0x01	/* the driver isn't removed even if
-					 * all ->init() calls failed */
-#define CPUFREQ_CONST_LOOPS	0x02	/* loops_per_jiffy or other kernel
-					 * "constants" aren't affected by
-					 * frequency transitions */
-#define CPUFREQ_PM_NO_WARN	0x04	/* don't warn on suspend/resume speed
-					 * mismatches */
+#define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
+						   all ->init() calls failed */
+#define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
+						   kernel "constants" aren't
+						   affected by frequency
+						   transitions */
+#define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
+						   speed mismatches */
 
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);

commit 27047a603645d0885bcd72d7a0b6cce6e3c94ca7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Sep 16 18:56:03 2013 +0530

    cpufreq: Add new helper cpufreq_table_validate_and_show()
    
    Almost every cpufreq driver is required to validate its frequency table with:
    cpufreq_frequency_table_cpuinfo() and then expose it to cpufreq core with:
    cpufreq_frequency_table_get_attr().
    
    This patch creates another helper routine cpufreq_table_validate_and_show() that
    will do both these steps in a single call and will return 0 for success, error
    otherwise.
    
    This also fixes potential bugs in cpufreq drivers where people have called
    cpufreq_frequency_table_get_attr() before calling
    cpufreq_frequency_table_cpuinfo(), as the later may fail.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index fcabc42d66ab..6b199ed7aa58 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -410,5 +410,7 @@ extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
+int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
+				      struct cpufreq_frequency_table *table);
 
 #endif /* _LINUX_CPUFREQ_H */

commit 798282a8718347b04a2f0a4bae7d775c48c6bcb9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 10 02:54:50 2013 +0200

    Revert "cpufreq: make sure frequency transitions are serialized"
    
    Commit 7c30ed5 (cpufreq: make sure frequency transitions are
    serialized) attempted to serialize frequency transitions by
    adding checks to the CPUFREQ_PRECHANGE and CPUFREQ_POSTCHANGE
    notifications.  However, it assumed that the notifications will
    always originate from the driver's .target() callback, but they
    also can be triggered by cpufreq_out_of_sync() and that leads to
    warnings like this on some systems:
    
     WARNING: CPU: 0 PID: 14543 at drivers/cpufreq/cpufreq.c:317
     __cpufreq_notify_transition+0x238/0x260()
     In middle of another frequency transition
    
    accompanied by a call trace similar to this one:
    
     [<ffffffff81720daa>] dump_stack+0x46/0x58
     [<ffffffff8106534c>] warn_slowpath_common+0x8c/0xc0
     [<ffffffff815b8560>] ? acpi_cpufreq_target+0x320/0x320
     [<ffffffff81065436>] warn_slowpath_fmt+0x46/0x50
     [<ffffffff815b1ec8>] __cpufreq_notify_transition+0x238/0x260
     [<ffffffff815b33be>] cpufreq_notify_transition+0x3e/0x70
     [<ffffffff815b345d>] cpufreq_out_of_sync+0x6d/0xb0
     [<ffffffff815b370c>] cpufreq_update_policy+0x10c/0x160
     [<ffffffff815b3760>] ? cpufreq_update_policy+0x160/0x160
     [<ffffffff81413813>] cpufreq_set_cur_state+0x8c/0xb5
     [<ffffffff814138df>] processor_set_cur_state+0xa3/0xcf
     [<ffffffff8158e13c>] thermal_cdev_update+0x9c/0xb0
     [<ffffffff8159046a>] step_wise_throttle+0x5a/0x90
     [<ffffffff8158e21f>] handle_thermal_trip+0x4f/0x140
     [<ffffffff8158e377>] thermal_zone_device_update+0x57/0xa0
     [<ffffffff81415b36>] acpi_thermal_check+0x2e/0x30
     [<ffffffff81415ca0>] acpi_thermal_notify+0x40/0xdc
     [<ffffffff813e7dbd>] acpi_device_notify+0x19/0x1b
     [<ffffffff813f8241>] acpi_ev_notify_dispatch+0x41/0x5c
     [<ffffffff813e3fbe>] acpi_os_execute_deferred+0x25/0x32
     [<ffffffff81081060>] process_one_work+0x170/0x4a0
     [<ffffffff81082121>] worker_thread+0x121/0x390
     [<ffffffff81082000>] ? manage_workers.isra.20+0x170/0x170
     [<ffffffff81088fe0>] kthread+0xc0/0xd0
     [<ffffffff81088f20>] ? flush_kthread_worker+0xb0/0xb0
     [<ffffffff8173582c>] ret_from_fork+0x7c/0xb0
     [<ffffffff81088f20>] ? flush_kthread_worker+0xb0/0xb0
    
    For this reason, revert commit 7c30ed5 along with the fix 266c13d
    (cpufreq: Fix serialization of frequency transitions) on top of it
    and we will revisit the serialization problem later.
    
    Reported-by: Alessandro Bono <alessandro.bono@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d568f3975eeb..fcabc42d66ab 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -85,7 +85,6 @@ struct cpufreq_policy {
 	struct list_head        policy_list;
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
-	int			transition_ongoing; /* Tracks transition status */
 };
 
 /* Only for ACPI */

commit 56d07db274b7b15ca38b60ea4a762d40de093000
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Sat Sep 7 01:23:55 2013 +0530

    cpufreq: Remove temporary fix for race between CPU hotplug and sysfs-writes
    
    Commit "cpufreq: serialize calls to __cpufreq_governor()" had been a temporary
    and partial solution to the race condition between writing to a cpufreq sysfs
    file and taking a CPU offline. Now that we have a proper and complete solution
    to that problem, remove the temporary fix.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index cca885dac1d3..d568f3975eeb 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -76,7 +76,6 @@ struct cpufreq_policy {
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
 	bool			governor_enabled; /* governor start/stop flag */
-	bool			governor_busy;
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */

commit 19c763031acb831a5ab9c1a701b7fedda073eb3f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 31 17:48:23 2013 +0530

    cpufreq: serialize calls to __cpufreq_governor()
    
    We can't take a big lock around __cpufreq_governor() as this causes
    recursive locking for some cases. But calls to this routine must be
    serialized for every policy. Otherwise we can see some unpredictable
    events.
    
    For example, consider following scenario:
    
    __cpufreq_remove_dev()
     __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
       policy->governor->governor(policy, CPUFREQ_GOV_STOP);
        cpufreq_governor_dbs()
         case CPUFREQ_GOV_STOP:
          mutex_destroy(&cpu_cdbs->timer_mutex)
          cpu_cdbs->cur_policy = NULL;
      <PREEMPT>
    store()
     __cpufreq_set_policy()
      __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
        policy->governor->governor(policy, CPUFREQ_GOV_LIMITS);
         case CPUFREQ_GOV_LIMITS:
          mutex_lock(&cpu_cdbs->timer_mutex); <-- Warning (destroyed mutex)
           if (policy->max < cpu_cdbs->cur_policy->cur) <- cur_policy == NULL
    
    And so store() will eventually result in a crash if cur_policy is
    NULL at this point.
    
    Introduce an additional variable which would guarantee serialization
    here.
    
    Reported-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d568f3975eeb..cca885dac1d3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -76,6 +76,7 @@ struct cpufreq_policy {
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
 	bool			governor_enabled; /* governor start/stop flag */
+	bool			governor_busy;
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */

commit adc97d6a735dbb1e94cb4f1bf0b55f258b349941
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:12 2013 +0530

    cpufreq: Drop the owner field from struct cpufreq_driver
    
    We don't need to set .owner = THIS_MODULE any more in cpufreq drivers
    as this field isn't used any more by the cpufreq core.
    
    This patch removes it and updates all dependent drivers accordingly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 431a05d4b4c9..d568f3975eeb 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -179,7 +179,6 @@ __ATTR(_name, 0644, show_##_name, store_##_name)
 
 
 struct cpufreq_driver {
-	struct module		*owner;
 	char			name[CPUFREQ_NAME_LEN];
 	u8			flags;
 	/*

commit c88a1f8b96e7384627b918dfabbfc0c615a4a914
Author: Lukasz Majewski <l.majewski@samsung.com>
Date:   Tue Aug 6 22:53:08 2013 +0530

    cpufreq: Store cpufreq policies in a list
    
    Policies available in the cpufreq framework are now linked together.
    They are accessible via cpufreq_policy_list defined in the cpufreq
    core.
    
    [rjw: Fix from Yinghai Lu folded in]
    Signed-off-by: Lukasz Majewski <l.majewski@samsung.com>
    Signed-off-by: Myungjoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 29208923c9d3..431a05d4b4c9 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -82,6 +82,7 @@ struct cpufreq_policy {
 
 	struct cpufreq_real_policy	user_policy;
 
+	struct list_head        policy_list;
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
 	int			transition_ongoing; /* Tracks transition status */

commit 3a3e9e06d0c11b8efa95933a88c9e67209fa4330
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:05 2013 +0530

    cpufreq: Give consistent names to cpufreq_policy objects
    
    They are called policy, cur_policy, new_policy, data, etc.  Just call
    them policy wherever possible.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0d3b0266bc98..29208923c9d3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -94,7 +94,7 @@ struct cpufreq_policy {
 #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
 struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
-void cpufreq_cpu_put(struct cpufreq_policy *data);
+void cpufreq_cpu_put(struct cpufreq_policy *policy);
 
 static inline bool policy_is_shared(struct cpufreq_policy *policy)
 {

commit 74aca95da74836a6807118f6590d8df8232c74a9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:04 2013 +0530

    cpufreq: Re-arrange declarations in cpufreq.h
    
    They are pretty much mixed up.  Although generic headers are present,
    definitions/declarations are present outside of them too ...
    
    This patch just moves stuff up and down to make it look better and
    consistent.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 97627bbbca82..0d3b0266bc98 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -17,60 +17,30 @@
 #include <linux/notifier.h>
 #include <linux/sysfs.h>
 
-#define CPUFREQ_NAME_LEN 16
-/* Print length for names. Extra 1 space for accomodating '\n' in prints */
-#define CPUFREQ_NAME_PLEN (CPUFREQ_NAME_LEN + 1)
-
 /*********************************************************************
- *                     CPUFREQ NOTIFIER INTERFACE                    *
+ *                        CPUFREQ INTERFACE                          *
  *********************************************************************/
-
-#define CPUFREQ_TRANSITION_NOTIFIER	(0)
-#define CPUFREQ_POLICY_NOTIFIER		(1)
-
-#ifdef CONFIG_CPU_FREQ
-int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
-int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
-extern void disable_cpufreq(void);
-#else		/* CONFIG_CPU_FREQ */
-static inline int cpufreq_register_notifier(struct notifier_block *nb,
-						unsigned int list)
-{
-	return 0;
-}
-static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
-						unsigned int list)
-{
-	return 0;
-}
-static inline void disable_cpufreq(void) { }
-#endif		/* CONFIG_CPU_FREQ */
-
-/* if (cpufreq_driver->target) exists, the ->governor decides what frequency
- * within the limits is used. If (cpufreq_driver->setpolicy> exists, these
- * two generic policies are available:
- */
-
-#define CPUFREQ_POLICY_POWERSAVE	(1)
-#define CPUFREQ_POLICY_PERFORMANCE	(2)
-
-/* Frequency values here are CPU kHz so that hardware which doesn't run
- * with some frequencies can complain without having to guess what per
- * cent / per mille means.
+/*
+ * Frequency values here are CPU kHz
+ *
  * Maximum transition latency is in nanoseconds - if it's unknown,
  * CPUFREQ_ETERNAL shall be used.
  */
 
+#define CPUFREQ_ETERNAL			(-1)
+#define CPUFREQ_NAME_LEN		16
+/* Print length for names. Extra 1 space for accomodating '\n' in prints */
+#define CPUFREQ_NAME_PLEN		(CPUFREQ_NAME_LEN + 1)
+
 struct cpufreq_governor;
 
-/* /sys/devices/system/cpu/cpufreq: entry point for global variables */
-extern struct kobject *cpufreq_global_kobject;
-int cpufreq_get_global_kobject(void);
-void cpufreq_put_global_kobject(void);
-int cpufreq_sysfs_create_file(const struct attribute *attr);
-void cpufreq_sysfs_remove_file(const struct attribute *attr);
+struct cpufreq_freqs {
+	unsigned int cpu;	/* cpu nr */
+	unsigned int old;
+	unsigned int new;
+	u8 flags;		/* flags of cpufreq_driver, see below. */
+};
 
-#define CPUFREQ_ETERNAL			(-1)
 struct cpufreq_cpuinfo {
 	unsigned int		max_freq;
 	unsigned int		min_freq;
@@ -117,111 +87,95 @@ struct cpufreq_policy {
 	int			transition_ongoing; /* Tracks transition status */
 };
 
-#define CPUFREQ_ADJUST			(0)
-#define CPUFREQ_INCOMPATIBLE		(1)
-#define CPUFREQ_NOTIFY			(2)
-#define CPUFREQ_START			(3)
-#define CPUFREQ_UPDATE_POLICY_CPU	(4)
-
 /* Only for ACPI */
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */
 #define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */
 #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
+struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
+void cpufreq_cpu_put(struct cpufreq_policy *data);
+
 static inline bool policy_is_shared(struct cpufreq_policy *policy)
 {
 	return cpumask_weight(policy->cpus) > 1;
 }
 
-/******************** cpufreq transition notifiers *******************/
-
-#define CPUFREQ_PRECHANGE	(0)
-#define CPUFREQ_POSTCHANGE	(1)
-#define CPUFREQ_RESUMECHANGE	(8)
-#define CPUFREQ_SUSPENDCHANGE	(9)
+/* /sys/devices/system/cpu/cpufreq: entry point for global variables */
+extern struct kobject *cpufreq_global_kobject;
+int cpufreq_get_global_kobject(void);
+void cpufreq_put_global_kobject(void);
+int cpufreq_sysfs_create_file(const struct attribute *attr);
+void cpufreq_sysfs_remove_file(const struct attribute *attr);
 
-struct cpufreq_freqs {
-	unsigned int cpu;	/* cpu nr */
-	unsigned int old;
-	unsigned int new;
-	u8 flags;		/* flags of cpufreq_driver, see below. */
-};
+#ifdef CONFIG_CPU_FREQ
+unsigned int cpufreq_get(unsigned int cpu);
+unsigned int cpufreq_quick_get(unsigned int cpu);
+unsigned int cpufreq_quick_get_max(unsigned int cpu);
+void disable_cpufreq(void);
 
-/**
- * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch
- * safe)
- * @old:   old value
- * @div:   divisor
- * @mult:  multiplier
- *
- *
- * new = old * mult / div
- */
-static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
-		u_int mult)
+u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
+int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
+int cpufreq_update_policy(unsigned int cpu);
+bool have_governor_per_policy(void);
+struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
+#else
+static inline unsigned int cpufreq_get(unsigned int cpu)
 {
-#if BITS_PER_LONG == 32
-
-	u64 result = ((u64) old) * ((u64) mult);
-	do_div(result, div);
-	return (unsigned long) result;
-
-#elif BITS_PER_LONG == 64
-
-	unsigned long result = old * ((u64) mult);
-	result /= div;
-	return result;
-
+	return 0;
+}
+static inline unsigned int cpufreq_quick_get(unsigned int cpu)
+{
+	return 0;
+}
+static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
+{
+	return 0;
+}
+static inline void disable_cpufreq(void) { }
 #endif
-};
 
 /*********************************************************************
- *                          CPUFREQ GOVERNORS                        *
+ *                      CPUFREQ DRIVER INTERFACE                     *
  *********************************************************************/
 
-#define CPUFREQ_GOV_START	1
-#define CPUFREQ_GOV_STOP	2
-#define CPUFREQ_GOV_LIMITS	3
-#define CPUFREQ_GOV_POLICY_INIT	4
-#define CPUFREQ_GOV_POLICY_EXIT	5
+#define CPUFREQ_RELATION_L 0  /* lowest frequency at or above target */
+#define CPUFREQ_RELATION_H 1  /* highest frequency below or at target */
 
-struct cpufreq_governor {
-	char	name[CPUFREQ_NAME_LEN];
-	int	initialized;
-	int	(*governor)	(struct cpufreq_policy *policy,
-				 unsigned int event);
-	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
-					 char *buf);
-	int	(*store_setspeed)	(struct cpufreq_policy *policy,
-					 unsigned int freq);
-	unsigned int max_transition_latency; /* HW must be able to switch to
-			next freq faster than this value in nano secs or we
-			will fallback to performance governor */
-	struct list_head	governor_list;
-	struct module		*owner;
+struct freq_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct cpufreq_policy *, char *);
+	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 };
 
-/*
- * Pass a target to the cpufreq driver.
- */
-extern int cpufreq_driver_target(struct cpufreq_policy *policy,
-				 unsigned int target_freq,
-				 unsigned int relation);
-extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
-				   unsigned int target_freq,
-				   unsigned int relation);
-int cpufreq_register_governor(struct cpufreq_governor *governor);
-void cpufreq_unregister_governor(struct cpufreq_governor *governor);
+#define cpufreq_freq_attr_ro(_name)		\
+static struct freq_attr _name =			\
+__ATTR(_name, 0444, show_##_name, NULL)
 
-/*********************************************************************
- *                      CPUFREQ DRIVER INTERFACE                     *
- *********************************************************************/
+#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
+static struct freq_attr _name =			\
+__ATTR(_name, _perm, show_##_name, NULL)
 
-#define CPUFREQ_RELATION_L 0  /* lowest frequency at or above target */
-#define CPUFREQ_RELATION_H 1  /* highest frequency below or at target */
+#define cpufreq_freq_attr_rw(_name)		\
+static struct freq_attr _name =			\
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+struct global_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct kobject *kobj,
+			struct attribute *attr, char *buf);
+	ssize_t (*store)(struct kobject *a, struct attribute *b,
+			 const char *c, size_t count);
+};
+
+#define define_one_global_ro(_name)		\
+static struct global_attr _name =		\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+#define define_one_global_rw(_name)		\
+static struct global_attr _name =		\
+__ATTR(_name, 0644, show_##_name, store_##_name)
 
-struct freq_attr;
 
 struct cpufreq_driver {
 	struct module		*owner;
@@ -258,7 +212,6 @@ struct cpufreq_driver {
 };
 
 /* flags */
-
 #define CPUFREQ_STICKY		0x01	/* the driver isn't removed even if
 					 * all ->init() calls failed */
 #define CPUFREQ_CONST_LOOPS	0x02	/* loops_per_jiffy or other kernel
@@ -270,8 +223,7 @@ struct cpufreq_driver {
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
-void cpufreq_notify_transition(struct cpufreq_policy *policy,
-		struct cpufreq_freqs *freqs, unsigned int state);
+const char *cpufreq_get_current_driver(void);
 
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 		unsigned int min, unsigned int max)
@@ -289,86 +241,117 @@ static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 	return;
 }
 
-struct freq_attr {
-	struct attribute attr;
-	ssize_t (*show)(struct cpufreq_policy *, char *);
-	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
-};
-
-#define cpufreq_freq_attr_ro(_name)		\
-static struct freq_attr _name =			\
-__ATTR(_name, 0444, show_##_name, NULL)
-
-#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
-static struct freq_attr _name =			\
-__ATTR(_name, _perm, show_##_name, NULL)
-
-#define cpufreq_freq_attr_rw(_name)		\
-static struct freq_attr _name =			\
-__ATTR(_name, 0644, show_##_name, store_##_name)
+/*********************************************************************
+ *                     CPUFREQ NOTIFIER INTERFACE                    *
+ *********************************************************************/
 
-struct global_attr {
-	struct attribute attr;
-	ssize_t (*show)(struct kobject *kobj,
-			struct attribute *attr, char *buf);
-	ssize_t (*store)(struct kobject *a, struct attribute *b,
-			 const char *c, size_t count);
-};
+#define CPUFREQ_TRANSITION_NOTIFIER	(0)
+#define CPUFREQ_POLICY_NOTIFIER		(1)
 
-#define define_one_global_ro(_name)		\
-static struct global_attr _name =		\
-__ATTR(_name, 0444, show_##_name, NULL)
+/* Transition notifiers */
+#define CPUFREQ_PRECHANGE		(0)
+#define CPUFREQ_POSTCHANGE		(1)
+#define CPUFREQ_RESUMECHANGE		(8)
+#define CPUFREQ_SUSPENDCHANGE		(9)
 
-#define define_one_global_rw(_name)		\
-static struct global_attr _name =		\
-__ATTR(_name, 0644, show_##_name, store_##_name)
+/* Policy Notifiers  */
+#define CPUFREQ_ADJUST			(0)
+#define CPUFREQ_INCOMPATIBLE		(1)
+#define CPUFREQ_NOTIFY			(2)
+#define CPUFREQ_START			(3)
+#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 
-struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
-void cpufreq_cpu_put(struct cpufreq_policy *data);
-const char *cpufreq_get_current_driver(void);
+#ifdef CONFIG_CPU_FREQ
+int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 
-/*********************************************************************
- *                        CPUFREQ 2.6. INTERFACE                     *
- *********************************************************************/
-u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
-int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
-int cpufreq_update_policy(unsigned int cpu);
-bool have_governor_per_policy(void);
-struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
+void cpufreq_notify_transition(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs, unsigned int state);
 
-#ifdef CONFIG_CPU_FREQ
-/*
- * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
- */
-unsigned int cpufreq_get(unsigned int cpu);
-#else
-static inline unsigned int cpufreq_get(unsigned int cpu)
+#else /* CONFIG_CPU_FREQ */
+static inline int cpufreq_register_notifier(struct notifier_block *nb,
+						unsigned int list)
 {
 	return 0;
 }
-#endif
-
-/*
- * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
- */
-#ifdef CONFIG_CPU_FREQ
-unsigned int cpufreq_quick_get(unsigned int cpu);
-unsigned int cpufreq_quick_get_max(unsigned int cpu);
-#else
-static inline unsigned int cpufreq_quick_get(unsigned int cpu)
+static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
+						unsigned int list)
 {
 	return 0;
 }
-static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
+#endif /* !CONFIG_CPU_FREQ */
+
+/**
+ * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch
+ * safe)
+ * @old:   old value
+ * @div:   divisor
+ * @mult:  multiplier
+ *
+ *
+ * new = old * mult / div
+ */
+static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
+		u_int mult)
 {
-	return 0;
-}
+#if BITS_PER_LONG == 32
+	u64 result = ((u64) old) * ((u64) mult);
+	do_div(result, div);
+	return (unsigned long) result;
+
+#elif BITS_PER_LONG == 64
+	unsigned long result = old * ((u64) mult);
+	result /= div;
+	return result;
 #endif
+}
 
 /*********************************************************************
- *                       CPUFREQ DEFAULT GOVERNOR                    *
+ *                          CPUFREQ GOVERNORS                        *
  *********************************************************************/
 
+/*
+ * If (cpufreq_driver->target) exists, the ->governor decides what frequency
+ * within the limits is used. If (cpufreq_driver->setpolicy> exists, these
+ * two generic policies are available:
+ */
+#define CPUFREQ_POLICY_POWERSAVE	(1)
+#define CPUFREQ_POLICY_PERFORMANCE	(2)
+
+/* Governor Events */
+#define CPUFREQ_GOV_START	1
+#define CPUFREQ_GOV_STOP	2
+#define CPUFREQ_GOV_LIMITS	3
+#define CPUFREQ_GOV_POLICY_INIT	4
+#define CPUFREQ_GOV_POLICY_EXIT	5
+
+struct cpufreq_governor {
+	char	name[CPUFREQ_NAME_LEN];
+	int	initialized;
+	int	(*governor)	(struct cpufreq_policy *policy,
+				 unsigned int event);
+	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
+					 char *buf);
+	int	(*store_setspeed)	(struct cpufreq_policy *policy,
+					 unsigned int freq);
+	unsigned int max_transition_latency; /* HW must be able to switch to
+			next freq faster than this value in nano secs or we
+			will fallback to performance governor */
+	struct list_head	governor_list;
+	struct module		*owner;
+};
+
+/* Pass a target to the cpufreq driver */
+int cpufreq_driver_target(struct cpufreq_policy *policy,
+				 unsigned int target_freq,
+				 unsigned int relation);
+int __cpufreq_driver_target(struct cpufreq_policy *policy,
+				   unsigned int target_freq,
+				   unsigned int relation);
+int cpufreq_register_governor(struct cpufreq_governor *governor);
+void cpufreq_unregister_governor(struct cpufreq_governor *governor);
+
+/* CPUFREQ DEFAULT GOVERNOR */
 /*
  * Performance governor is fallback governor if any other gov failed to auto
  * load due latency restrictions
@@ -417,18 +400,16 @@ int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 				   unsigned int relation,
 				   unsigned int *index);
 
-/* the following 3 funtions are for cpufreq core use only */
+void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
+ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
+
+/* the following funtion is for cpufreq core use only */
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
-
 void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
-void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
-
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 
-ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
-
 #endif /* _LINUX_CPUFREQ_H */

commit 5ff0a268037d344f86df690ccb994d8bc015d2d9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:03 2013 +0530

    cpufreq: Clean up header files included in the core
    
    This patch addresses the following issues in the header files in the
    cpufreq core:
     - Include headers in ascending order, so that we don't add same
       many times by mistake.
     - <asm/> must be included after <linux/>, so that they override
       whatever they need to.
     - Remove unnecessary includes.
     - Don't include files already included by cpufreq.h or
       cpufreq_governor.h.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index e1fd215e16c9..97627bbbca82 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -11,16 +11,11 @@
 #ifndef _LINUX_CPUFREQ_H
 #define _LINUX_CPUFREQ_H
 
-#include <asm/cputime.h>
-#include <linux/mutex.h>
-#include <linux/notifier.h>
-#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <linux/completion.h>
 #include <linux/kobject.h>
+#include <linux/notifier.h>
 #include <linux/sysfs.h>
-#include <linux/completion.h>
-#include <linux/workqueue.h>
-#include <linux/cpumask.h>
-#include <asm/div64.h>
 
 #define CPUFREQ_NAME_LEN 16
 /* Print length for names. Extra 1 space for accomodating '\n' in prints */

commit cffe4e0e7413eb29fb8bd035c8b12b33a4b8522a
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Wed Jun 5 19:01:50 2013 +0300

    cpufreq: Remove unused function __cpufreq_driver_getavg()
    
    The target frequency calculation method in the ondemand governor has
    changed and it is now independent of the measured average frequency.
    Consequently, the __cpufreq_driver_getavg() function and getavg
    member of struct cpufreq_driver are not used any more, so drop them.
    
    [rjw: Changelog]
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 90d5a15120d5..e1fd215e16c9 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -216,10 +216,6 @@ extern int cpufreq_driver_target(struct cpufreq_policy *policy,
 extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
 				   unsigned int relation);
-
-extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy,
-				   unsigned int cpu);
-
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
@@ -258,8 +254,6 @@ struct cpufreq_driver {
 	unsigned int	(*get)	(unsigned int cpu);
 
 	/* optional */
-	unsigned int (*getavg)	(struct cpufreq_policy *policy,
-				 unsigned int cpu);
 	int	(*bios_limit)	(int cpu, unsigned int *limit);
 
 	int	(*exit)		(struct cpufreq_policy *policy);

commit 266c13d767be61a17d8e6f2310b9b7c46278273b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 2 16:36:28 2013 +0530

    cpufreq: Fix serialization of frequency transitions
    
    Commit 7c30ed ("cpufreq: make sure frequency transitions are serialized")
    interacts poorly with systems that have a single core freqency for all
    cores.  On such systems we have a single policy for all cores with
    several CPUs.  When we do a frequency transition the governor calls the
    pre and post change notifiers which causes cpufreq_notify_transition()
    per CPU.  Since the policy is the same for all of them all CPUs after
    the first and the warnings added are generated by checking a per-policy
    flag the warnings will be triggered for all cores after the first.
    
    Fix this by allowing notifier to be called for n times. Where n is the number of
    cpus in policy->cpus.
    
    Reported-and-tested-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4d7390bc1727..90d5a15120d5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -119,7 +119,7 @@ struct cpufreq_policy {
 
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
-	bool			transition_ongoing; /* Tracks transition status */
+	int			transition_ongoing; /* Tracks transition status */
 };
 
 #define CPUFREQ_ADJUST			(0)

commit f4fd3797848aa04e72e942c855fd279840a47fe4
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Thu Jun 27 15:08:54 2013 +0800

    acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
    
    Commits fcf8058 (cpufreq: Simplify cpufreq_add_dev()) and aa77a52
    (cpufreq: acpi-cpufreq: Don't set policy->related_cpus from .init())
    changed the contents of the "related_cpus" sysfs attribute on systems
    where acpi-cpufreq is used and user space can't get the list of CPUs
    which are in the same hardware coordination CPU domain (provided by
    the ACPI AML method _PSD) via "related_cpus" any more.
    
    To make up for that loss add a new sysfs attribute "freqdomian_cpus"
    for the acpi-cpufreq driver which exposes the list of CPUs in the
    same domain regardless of whether it is coordinated by hardware or
    software.
    
    [rjw: Changelog, documentation]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=58761
    Reported-by: Jean-Philippe Halimi <jean-philippe.halimi@exascale-computing.eu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c0bc7374445e..4d7390bc1727 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -439,4 +439,7 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
+
+ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
+
 #endif /* _LINUX_CPUFREQ_H */

commit 7c30ed532cf798a8d924562f2f44d03d7652f7a7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 19 10:16:55 2013 +0530

    cpufreq: make sure frequency transitions are serialized
    
    Whenever we are changing frequency of a cpu, we are calling PRECHANGE and
    POSTCHANGE notifiers. They must be serialized. i.e. PRECHANGE or POSTCHANGE
    shouldn't be called twice contiguously.
    
    This can happen due to bugs in users of __cpufreq_driver_target() or actual
    cpufreq drivers who are sending these notifiers.
    
    This patch adds some protection against this. Now, we keep track of the last
    transaction and see if something went wrong.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 3c7ee2f90370..c0bc7374445e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -119,6 +119,7 @@ struct cpufreq_policy {
 
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
+	bool			transition_ongoing; /* Tracks transition status */
 };
 
 #define CPUFREQ_ADJUST			(0)

commit bb176f7d038fee4d46b3293e64e173bfb05ab7b5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 19 14:19:33 2013 +0530

    cpufreq: Fix minor formatting issues
    
    There were a few noticeable formatting issues in core cpufreq code.
    This cleans them up to make code look better.  The changes include:
     - Whitespace cleanup.
     - Rearrangements of code.
     - Multiline comments fixes.
     - Formatting changes to fit 80 columns.
    
    Copyright information in cpufreq.c is also updated to include my name
    for 2013.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 125719d41285..3c7ee2f90370 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -1,8 +1,8 @@
 /*
- *  linux/include/linux/cpufreq.h
+ * linux/include/linux/cpufreq.h
  *
- *  Copyright (C) 2001 Russell King
- *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
+ * Copyright (C) 2001 Russell King
+ *           (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -26,7 +26,6 @@
 /* Print length for names. Extra 1 space for accomodating '\n' in prints */
 #define CPUFREQ_NAME_PLEN (CPUFREQ_NAME_LEN + 1)
 
-
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/
@@ -153,17 +152,18 @@ struct cpufreq_freqs {
 	u8 flags;		/* flags of cpufreq_driver, see below. */
 };
 
-
 /**
- * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch safe)
+ * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch
+ * safe)
  * @old:   old value
  * @div:   divisor
  * @mult:  multiplier
  *
  *
- *    new = old * mult / div
+ * new = old * mult / div
  */
-static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mult)
+static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
+		u_int mult)
 {
 #if BITS_PER_LONG == 32
 
@@ -216,14 +216,12 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int target_freq,
 				   unsigned int relation);
 
-
 extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy,
 				   unsigned int cpu);
 
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
-
 /*********************************************************************
  *                      CPUFREQ DRIVER INTERFACE                     *
  *********************************************************************/
@@ -234,7 +232,7 @@ void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 struct freq_attr;
 
 struct cpufreq_driver {
-	struct module           *owner;
+	struct module		*owner;
 	char			name[CPUFREQ_NAME_LEN];
 	u8			flags;
 	/*
@@ -282,11 +280,11 @@ struct cpufreq_driver {
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
-
 void cpufreq_notify_transition(struct cpufreq_policy *policy,
 		struct cpufreq_freqs *freqs, unsigned int state);
 
-static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
+static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
+		unsigned int min, unsigned int max)
 {
 	if (policy->min < min)
 		policy->min = min;
@@ -349,7 +347,9 @@ bool have_governor_per_policy(void);
 struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 
 #ifdef CONFIG_CPU_FREQ
-/* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
+/*
+ * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
+ */
 unsigned int cpufreq_get(unsigned int cpu);
 #else
 static inline unsigned int cpufreq_get(unsigned int cpu)
@@ -358,7 +358,9 @@ static inline unsigned int cpufreq_get(unsigned int cpu)
 }
 #endif
 
-/* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
+/*
+ * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
+ */
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_quick_get(unsigned int cpu);
 unsigned int cpufreq_quick_get_max(unsigned int cpu);
@@ -373,16 +375,14 @@ static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
 }
 #endif
 
-
 /*********************************************************************
  *                       CPUFREQ DEFAULT GOVERNOR                    *
  *********************************************************************/
 
-
 /*
-  Performance governor is fallback governor if any other gov failed to
-  auto load due latency restrictions
-*/
+ * Performance governor is fallback governor if any other gov failed to auto
+ * load due latency restrictions
+ */
 #ifdef CONFIG_CPU_FREQ_GOV_PERFORMANCE
 extern struct cpufreq_governor cpufreq_gov_performance;
 #endif
@@ -402,7 +402,6 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
 #endif
 
-
 /*********************************************************************
  *                     FREQUENCY TABLE HELPERS                       *
  *********************************************************************/

commit 95731ebb114c5f0c028459388560fc2a72fe5049
Author: Xiaoguang Chen <chenxg@marvell.com>
Date:   Wed Jun 19 15:00:07 2013 +0800

    cpufreq: Fix governor start/stop race condition
    
    Cpufreq governors' stop and start operations should be carried out
    in sequence.  Otherwise, there will be unexpected behavior, like in
    the example below.
    
    Suppose there are 4 CPUs and policy->cpu=CPU0, CPU1/2/3 are linked
    to CPU0.  The normal sequence is:
    
     1) Current governor is userspace.  An application tries to set the
        governor to ondemand.  It will call __cpufreq_set_policy() in
        which it will stop the userspace governor and then start the
        ondemand governor.
    
     2) Current governor is userspace.  The online of CPU3 runs on CPU0.
        It will call cpufreq_add_policy_cpu() in which it will first
        stop the userspace governor, and then start it again.
    
    If the sequence of the above two cases interleaves, it becomes:
    
     1) Application stops userspace governor
     2)                                  Hotplug stops userspace governor
    
    which is a problem, because the governor shouldn't be stopped twice
    in a row.  What happens next is:
    
     3) Application starts ondemand governor
     4)                                  Hotplug starts a governor
    
    In step 4, the hotplug is supposed to start the userspace governor,
    but now the governor has been changed by the application to ondemand,
    so the ondemand governor is started once again, which is incorrect.
    
    The solution is to prevent policy governors from being stopped
    multiple times in a row.  A governor should only be stopped once for
    one policy.  After it has been stopped, no more governor stop
    operations should be executed.
    
    Also add a mutex to serialize governor operations.
    
    [rjw: Changelog.  And you owe me a beverage of my choice.]
    Signed-off-by: Xiaoguang Chen <chenxg@marvell.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d93905633dc7..125719d41285 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -111,6 +111,7 @@ struct cpufreq_policy {
 	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 	void			*governor_data;
+	bool			governor_enabled; /* governor start/stop flag */
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */

commit 5070158804b5339c71809f5e673cea1cfacd804d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Mar 30 16:25:15 2013 +0530

    cpufreq: rename index as driver_data in cpufreq_frequency_table
    
    The "index" field of struct cpufreq_frequency_table was never an
    index and isn't used at all by the cpufreq core.  It only is useful
    for cpufreq drivers for their internal purposes.
    
    Many people nowadays blindly set it in ascending order with the
    assumption that the core will use it, which is a mistake.
    
    Rename it to "driver_data" as that's what its purpose is. All of its
    users are updated accordingly.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1b5b5efa3e3a..d93905633dc7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -410,7 +410,7 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_TABLE_END     ~1
 
 struct cpufreq_frequency_table {
-	unsigned int	index;     /* any */
+	unsigned int	driver_data; /* driver specific data, not used by core */
 	unsigned int	frequency; /* kHz - doesn't need to be in ascending
 				    * order */
 };

commit 2361be23666232dbb4851a527f466c4cbf5340fc
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri May 17 16:09:09 2013 +0530

    cpufreq: Don't create empty /sys/devices/system/cpu/cpufreq directory
    
    When we don't have any file in cpu/cpufreq directory we shouldn't
    create it. Specially with the introduction of per-policy governor
    instance patchset, even governors are moved to
    cpu/cpu*/cpufreq/governor-name directory and so this directory is
    just not required.
    
    Lets have it only when required.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index fbf392aaa02e..1b5b5efa3e3a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -71,6 +71,10 @@ struct cpufreq_governor;
 
 /* /sys/devices/system/cpu/cpufreq: entry point for global variables */
 extern struct kobject *cpufreq_global_kobject;
+int cpufreq_get_global_kobject(void);
+void cpufreq_put_global_kobject(void);
+int cpufreq_sysfs_create_file(const struct attribute *attr);
+void cpufreq_sysfs_remove_file(const struct attribute *attr);
 
 #define CPUFREQ_ETERNAL			(-1)
 struct cpufreq_cpuinfo {

commit 72a4ce340a7ebf39e1c6fdc8f5feb4f974d6c635
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri May 17 11:26:32 2013 +0000

    cpufreq: Move get_cpu_idle_time() to cpufreq.c
    
    Governors other than ondemand and conservative can also use
    get_cpu_idle_time() and they aren't required to compile
    cpufreq_governor.c. So, move these independent routines to
    cpufreq.c instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index dd1a5d41357b..fbf392aaa02e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -337,6 +337,7 @@ const char *cpufreq_get_current_driver(void);
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *
  *********************************************************************/
+u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);

commit 944e9a0316e60bc5bc122e46c1fde36e5f6e9f56
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 16 05:09:57 2013 +0000

    cpufreq: governors: Move get_governor_parent_kobj() to cpufreq.c
    
    get_governor_parent_kobj() can be used by any governor, generic
    cpufreq governors or platform specific ones and so must be present in
    cpufreq.c instead of cpufreq_governor.c.
    
    This patch moves it to cpufreq.c. This also adds
    EXPORT_SYMBOL_GPL(get_governor_parent_kobj) so that modules can use
    this function too.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 037d36ae63e5..dd1a5d41357b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -340,6 +340,7 @@ const char *cpufreq_get_current_driver(void);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 bool have_governor_per_policy(void);
+struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
 
 #ifdef CONFIG_CPU_FREQ
 /* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */

commit b43a7ffbf33be7e4d3b10b7714ee663ea2c52fe2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sun Mar 24 11:56:43 2013 +0530

    cpufreq: Notify all policy->cpus in cpufreq_notify_transition()
    
    policy->cpus contains all online cpus that have single shared clock line. And
    their frequencies are always updated together.
    
    Many SMP system's cpufreq drivers take care of this in individual drivers but
    the best place for this code is in cpufreq core.
    
    This patch modifies cpufreq_notify_transition() to notify frequency change for
    all cpus in policy->cpus and hence updates all users of this API.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4bbc572dd521..037d36ae63e5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -278,8 +278,8 @@ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
 
-void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
-
+void cpufreq_notify_transition(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs, unsigned int state);
 
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
 {

commit 4d5dcc4211f9def4281eafb54b8ed483862e8135
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Mar 27 15:58:58 2013 +0000

    cpufreq: governor: Implement per policy instances of governors
    
    Currently, there can't be multiple instances of single governor_type.
    If we have a multi-package system, where we have multiple instances
    of struct policy (per package), we can't have multiple instances of
    same governor. i.e. We can't have multiple instances of ondemand
    governor for multiple packages.
    
    Governors directory in sysfs is created at /sys/devices/system/cpu/cpufreq/
    governor-name/. Which again reflects that there can be only one
    instance of a governor_type in the system.
    
    This is a bottleneck for multicluster system, where we want different
    packages to use same governor type, but with different tunables.
    
    This patch uses the infrastructure provided by earlier patch and
    implements init/exit routines for ondemand and conservative
    governors.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b7393b56f552..4bbc572dd521 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -232,6 +232,13 @@ struct cpufreq_driver {
 	struct module           *owner;
 	char			name[CPUFREQ_NAME_LEN];
 	u8			flags;
+	/*
+	 * This should be set by platforms having multiple clock-domains, i.e.
+	 * supporting multiple policies. With this sysfs directories of governor
+	 * would be created in cpu/cpu<num>/cpufreq/ directory and so they can
+	 * use the same governor with different tunables for different clusters.
+	 */
+	bool			have_governor_per_policy;
 
 	/* needed by all drivers */
 	int	(*init)		(struct cpufreq_policy *policy);
@@ -332,6 +339,7 @@ const char *cpufreq_get_current_driver(void);
  *********************************************************************/
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
+bool have_governor_per_policy(void);
 
 #ifdef CONFIG_CPU_FREQ
 /* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */

commit 7bd353a995d9049262661d85811d6109140582a3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Mar 27 15:58:57 2013 +0000

    cpufreq: Add per policy governor-init/exit infrastructure
    
    Currently, there can't be multiple instances of single governor_type.
    If we have a multi-package system, where we have multiple instances
    of struct policy (per package), we can't have multiple instances of
    same governor. i.e. We can't have multiple instances of ondemand
    governor for multiple packages.
    
    Governors directory in sysfs is created at /sys/devices/system/cpu/cpufreq/
    governor-name/. Which again reflects that there can be only one
    instance of a governor_type in the system.
    
    This is a bottleneck for multicluster system, where we want different
    packages to use same governor type, but with different tunables.
    
    This patch is inclined towards providing this infrastructure. Because
    we are required to allocate governor's resources dynamically now, we
    must do it at policy creation and end. And so got
    CPUFREQ_GOV_POLICY_INIT/EXIT.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a22944ca0526..b7393b56f552 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -106,6 +106,7 @@ struct cpufreq_policy {
 					 * governors are used */
 	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
+	void			*governor_data;
 
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
@@ -178,9 +179,11 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mu
  *                          CPUFREQ GOVERNORS                        *
  *********************************************************************/
 
-#define CPUFREQ_GOV_START  1
-#define CPUFREQ_GOV_STOP   2
-#define CPUFREQ_GOV_LIMITS 3
+#define CPUFREQ_GOV_START	1
+#define CPUFREQ_GOV_STOP	2
+#define CPUFREQ_GOV_LIMITS	3
+#define CPUFREQ_GOV_POLICY_INIT	4
+#define CPUFREQ_GOV_POLICY_EXIT	5
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];

commit 62b36cc1c83aca1cd252772e82cbc5d9ef8ff25b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 1 06:40:02 2013 +0000

    cpufreq: Remove unnecessary use of policy->shared_type
    
    policy->shared_type field was added only for SoCs with ACPI support:
    
    commit 3b2d99429e3386b6e2ac949fc72486509c8bbe36
    Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Date:   Wed Dec 14 15:05:00 2005 -0500
    
        P-state software coordination for ACPI core
    
        http://bugzilla.kernel.org/show_bug.cgi?id=5737
    
    Many non-ACPI systems are filling this field by mistake, which makes its usage
    confusing. Lets clean it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6bf3f2d12c90..a22944ca0526 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -93,7 +93,7 @@ struct cpufreq_policy {
 	cpumask_var_t		cpus;	/* Online CPUs only */
 	cpumask_var_t		related_cpus; /* Online + Offline CPUs */
 
-	unsigned int		shared_type; /* ANY or ALL affected CPUs
+	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
 	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
@@ -122,6 +122,7 @@ struct cpufreq_policy {
 #define CPUFREQ_START			(3)
 #define CPUFREQ_UPDATE_POLICY_CPU	(4)
 
+/* Only for ACPI */
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */
 #define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */

commit b394058f064848deac7a7cd6942b6521d7b3fe1d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 1 05:42:58 2013 +0000

    cpufreq: governors: Reset tunables only for cpufreq_unregister_governor()
    
    Currently, whenever governor->governor() is called for CPUFRREQ_GOV_START event
    we reset few tunables of governor. Which isn't correct, as this routine is
    called for every cpu hot-[un]plugging event. We should actually be resetting
    these only when the governor module is removed and re-installed.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index feb360c8aa88..6bf3f2d12c90 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -183,6 +183,7 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mu
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
+	int	initialized;
 	int	(*governor)	(struct cpufreq_policy *policy,
 				 unsigned int event);
 	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,

commit 2624f90c16413990ecb0414400174a066319a9f5
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Thu Jan 31 09:44:40 2013 +0000

    cpufreq: governors: implement generic policy_is_shared
    
    Implement a generic helper function policy_is_shared() to replace the
    current dbs_sw_coordinated_cpus() at cpufreq level, so that it can be
    used by code other than cpufreq governors.
    
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 753b198750cf..feb360c8aa88 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -127,6 +127,11 @@ struct cpufreq_policy {
 #define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */
 #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
+static inline bool policy_is_shared(struct cpufreq_policy *policy)
+{
+	return cpumask_weight(policy->cpus) > 1;
+}
+
 /******************** cpufreq transition notifiers *******************/
 
 #define CPUFREQ_PRECHANGE	(0)

commit 951fc5f45836988c7df1d05c7f4658f331e7a920
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 31 02:03:53 2013 +0000

    cpufreq: Update Documentation for cpus and related_cpus
    
    Documentation related to cpus and related_cpus is confusing and not very clear.
    Over that CPUFreq core has seen much changes recently. Lets update documentation
    and comments for cpus and related_cpus.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 5fdc6c6e3f8a..753b198750cf 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -89,8 +89,10 @@ struct cpufreq_real_policy {
 };
 
 struct cpufreq_policy {
-	cpumask_var_t		cpus;	/* CPUs requiring sw coordination */
-	cpumask_var_t		related_cpus; /* CPUs with any coordination */
+	/* CPUs sharing clock, require sw coordination */
+	cpumask_var_t		cpus;	/* Online CPUs only */
+	cpumask_var_t		related_cpus; /* Online + Offline CPUs */
+
 	unsigned int		shared_type; /* ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of CPU managing this policy */

commit ab45bd9bed36ad6c471b090bb8846ab7228fdf11
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Jan 28 14:50:39 2013 +0100

    cpufreq: Sort function prototypes properly
    
    Move function prototypes to a place where they logically fit better.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1f3a726640e8..5fdc6c6e3f8a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -311,6 +311,9 @@ __ATTR(_name, 0444, show_##_name, NULL)
 static struct global_attr _name =		\
 __ATTR(_name, 0644, show_##_name, store_##_name)
 
+struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
+void cpufreq_cpu_put(struct cpufreq_policy *data);
+const char *cpufreq_get_current_driver(void);
 
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *
@@ -400,8 +403,6 @@ int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 
 /* the following 3 funtions are for cpufreq core use only */
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
-struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
-void   cpufreq_cpu_put(struct cpufreq_policy *data);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
@@ -411,5 +412,4 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
-const char *cpufreq_get_current_driver(void);
 #endif /* _LINUX_CPUFREQ_H */

commit 9d95046e5d6afd6d7ae86fb71ab59c6faf0db8de
Author: Borislav Petkov <bp@suse.de>
Date:   Sun Jan 20 10:24:28 2013 +0000

    cpufreq: Add a get_current_driver helper
    
    Add a helper function to return cpufreq_driver->name.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 52be2d0c994a..1f3a726640e8 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -411,4 +411,5 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
+const char *cpufreq_get_current_driver(void);
 #endif /* _LINUX_CPUFREQ_H */

commit b8eed8af94f9203e0cc39245ea335f4b8dc1ed31
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 14 13:23:03 2013 +0000

    cpufreq: Simplify __cpufreq_remove_dev()
    
    __cpufreq_remove_dev() is called on multiple occasions: cpufreq_driver
    unregister and cpu removals.
    
    Current implementation of this routine is overly complex without much need. If
    the cpu to be removed is the policy->cpu, we remove the policy first and add all
    other cpus again from policy->cpus and then finally call __cpufreq_remove_dev()
    again to remove the cpu to be deleted. Haahhhh..
    
    There exist a simple solution to removal of a cpu:
    - Simply use the old policy structure
    - update its fields like: policy->cpu, etc.
    - notify any users of cpufreq, which depend on changing policy->cpu
    
    Hence this patch, which tries to implement the above theory. It is tested well
    by myself on ARM big.LITTLE TC2 SoC, which has 5 cores (2 A15 and 3 A7). Both
    A15's share same struct policy and all A7's share same policy structure.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a55b88eaf96a..52be2d0c994a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -93,7 +93,9 @@ struct cpufreq_policy {
 	cpumask_var_t		related_cpus; /* CPUs with any coordination */
 	unsigned int		shared_type; /* ANY or ALL affected CPUs
 						should set cpufreq */
-	unsigned int		cpu;    /* cpu nr of registered CPU */
+	unsigned int		cpu;    /* cpu nr of CPU managing this policy */
+	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
+					   * this policy */
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 
 	unsigned int		min;    /* in kHz */
@@ -112,10 +114,11 @@ struct cpufreq_policy {
 	struct completion	kobj_unregister;
 };
 
-#define CPUFREQ_ADJUST		(0)
-#define CPUFREQ_INCOMPATIBLE	(1)
-#define CPUFREQ_NOTIFY		(2)
-#define CPUFREQ_START		(3)
+#define CPUFREQ_ADJUST			(0)
+#define CPUFREQ_INCOMPATIBLE		(1)
+#define CPUFREQ_NOTIFY			(2)
+#define CPUFREQ_START			(3)
+#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */
@@ -405,6 +408,7 @@ extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 
 void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
+void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 #endif /* _LINUX_CPUFREQ_H */

commit 4471a34f9a1f2da220272e823bdb8e8fa83a7661
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 26 00:47:42 2012 +0200

    cpufreq: governors: remove redundant code
    
    Initially ondemand governor was written and then using its code conservative
    governor is written. It used a lot of code from ondemand governor, but copy of
    code was created instead of using the same routines from both governors. Which
    increased code redundancy, which is difficult to manage.
    
    This patch is an attempt to move common part of both the governors to
    cpufreq_governor.c file to come over above mentioned issues.
    
    This shouldn't change anything from functionality point of view.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d03c21993052..a55b88eaf96a 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -407,10 +407,4 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
-
-/*********************************************************************
- *                     Governor Helpers				     *
- *********************************************************************/
-cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall);
-
 #endif /* _LINUX_CPUFREQ_H */

commit 2aacdfff9c6958723aa5076003247933cefc32ea
Author: viresh kumar <viresh.kumar@linaro.org>
Date:   Tue Oct 23 01:28:05 2012 +0200

    cpufreq: Move common part from governors to separate file, v2
    
    Multiple cpufreq governers have defined similar get_cpu_idle_time_***()
    routines. These routines must be moved to some common place, so that all
    governors can use them.
    
    So moving them to cpufreq_governor.c, which seems to be a better place for
    keeping these routines.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index fc4b78510151..d03c21993052 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -11,6 +11,7 @@
 #ifndef _LINUX_CPUFREQ_H
 #define _LINUX_CPUFREQ_H
 
+#include <asm/cputime.h>
 #include <linux/mutex.h>
 #include <linux/notifier.h>
 #include <linux/threads.h>
@@ -407,5 +408,9 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 
+/*********************************************************************
+ *                     Governor Helpers				     *
+ *********************************************************************/
+cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall);
 
 #endif /* _LINUX_CPUFREQ_H */

commit 4b972f0b04eaae645b22d99479b9aea43c3d64e7
Author: viresh kumar <viresh.kumar@linaro.org>
Date:   Tue Oct 23 01:23:43 2012 +0200

    cpufreq / core: Fix printing of governor and driver name
    
    Arrays for governer and driver name are of size CPUFREQ_NAME_LEN or 16.
    i.e. 15 bytes for name and 1 for trailing '\0'.
    
    When cpufreq driver print these names (for sysfs), it includes '\n' or ' ' in
    the fmt string and still passes length as CPUFREQ_NAME_LEN. If the driver or
    governor names are using all 15 fields allocated to them, then the trailing '\n'
    or ' ' will never be printed. And so commands like:
    
    root@linaro-developer# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver
    
    will print something like:
    
    cpufreq_foodrvroot@linaro-developer#
    
    Fix this by increasing print length by one character.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b60f6ba01d0c..fc4b78510151 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -22,6 +22,8 @@
 #include <asm/div64.h>
 
 #define CPUFREQ_NAME_LEN 16
+/* Print length for names. Extra 1 space for accomodating '\n' in prints */
+#define CPUFREQ_NAME_PLEN (CPUFREQ_NAME_LEN + 1)
 
 
 /*********************************************************************

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6216115c7789..fad1382f8615 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -14,7 +14,6 @@
 #include <linux/mutex.h>
 #include <linux/notifier.h>
 #include <linux/threads.h>
-#include <linux/device.h>
 #include <linux/kobject.h>
 #include <linux/sysfs.h>
 #include <linux/completion.h>

commit a7b422cda5084db7265c3b23310a959b43b47529
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Mar 13 19:18:39 2012 -0400

    provide disable_cpufreq() function to disable the API.
    
    useful for disabling cpufreq altogether. The cpu frequency
    scaling drivers and cpu frequency governors will fail to register.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6216115c7789..8ff442753c75 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -35,6 +35,7 @@
 #ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
+extern void disable_cpufreq(void);
 #else		/* CONFIG_CPU_FREQ */
 static inline int cpufreq_register_notifier(struct notifier_block *nb,
 						unsigned int list)
@@ -46,6 +47,7 @@ static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
 {
 	return 0;
 }
+static inline void disable_cpufreq(void) { }
 #endif		/* CONFIG_CPU_FREQ */
 
 /* if (cpufreq_driver->target) exists, the ->governor decides what frequency

commit 3d73710880afa3d61cf57b5d4eb192e812eb7e4f
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Jun 28 10:59:12 2011 -0700

    cpufreq: expose a cpufreq_quick_get_max routine
    
    This allows drivers and other code to get the max reported CPU frequency.
    Initial use is for scaling ring frequency with GPU frequency in the i915
    driver.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Keith Packard <keithp@keithp.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 11be48e0d168..6216115c7789 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -324,11 +324,16 @@ static inline unsigned int cpufreq_get(unsigned int cpu)
 /* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_quick_get(unsigned int cpu);
+unsigned int cpufreq_quick_get_max(unsigned int cpu);
 #else
 static inline unsigned int cpufreq_quick_get(unsigned int cpu)
 {
 	return 0;
 }
+static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
+{
+	return 0;
+}
 #endif
 
 

commit 335dc3335ff692173bc766b248f7a97f3a23b30a
Author: Thiago Farina <tfransosi@gmail.com>
Date:   Thu Apr 28 20:42:53 2011 -0300

    [CPUFREQ] cpufreq.h: Fix some checkpatch.pl coding style issues.
    
    Before:
    $ scripts/checkpatch.pl --file --terse include/linux/cpufreq.h
    total: 14 errors, 11 warnings, 419 lines checked
    
    After:
    $ scripts/checkpatch.pl --file --terse include/linux/cpufreq.h
    total: 2 errors, 4 warnings, 422 lines checked
    
    Signed-off-by: Thiago Farina <tfransosi@gmail.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 2845f6e67221..11be48e0d168 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2001 Russell King
  *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
- *            
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -56,9 +56,9 @@ static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
 #define CPUFREQ_POLICY_POWERSAVE	(1)
 #define CPUFREQ_POLICY_PERFORMANCE	(2)
 
-/* Frequency values here are CPU kHz so that hardware which doesn't run 
- * with some frequencies can complain without having to guess what per 
- * cent / per mille means. 
+/* Frequency values here are CPU kHz so that hardware which doesn't run
+ * with some frequencies can complain without having to guess what per
+ * cent / per mille means.
  * Maximum transition latency is in nanoseconds - if it's unknown,
  * CPUFREQ_ETERNAL shall be used.
  */
@@ -72,13 +72,15 @@ extern struct kobject *cpufreq_global_kobject;
 struct cpufreq_cpuinfo {
 	unsigned int		max_freq;
 	unsigned int		min_freq;
-	unsigned int		transition_latency; /* in 10^(-9) s = nanoseconds */
+
+	/* in 10^(-9) s = nanoseconds */
+	unsigned int		transition_latency;
 };
 
 struct cpufreq_real_policy {
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
-        unsigned int		policy; /* see above */
+	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 };
 
@@ -94,7 +96,7 @@ struct cpufreq_policy {
 	unsigned int		max;    /* in kHz */
 	unsigned int		cur;    /* in kHz, only needed if cpufreq
 					 * governors are used */
-        unsigned int		policy; /* see above */
+	unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 
 	struct work_struct	update; /* if update_policy() needs to be
@@ -167,11 +169,11 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mu
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
-	int 	(*governor)	(struct cpufreq_policy *policy,
+	int	(*governor)	(struct cpufreq_policy *policy,
 				 unsigned int event);
 	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
 					 char *buf);
-	int 	(*store_setspeed)	(struct cpufreq_policy *policy,
+	int	(*store_setspeed)	(struct cpufreq_policy *policy,
 					 unsigned int freq);
 	unsigned int max_transition_latency; /* HW must be able to switch to
 			next freq faster than this value in nano secs or we
@@ -180,7 +182,8 @@ struct cpufreq_governor {
 	struct module		*owner;
 };
 
-/* pass a target to the cpufreq driver 
+/*
+ * Pass a target to the cpufreq driver.
  */
 extern int cpufreq_driver_target(struct cpufreq_policy *policy,
 				 unsigned int target_freq,
@@ -237,9 +240,9 @@ struct cpufreq_driver {
 
 /* flags */
 
-#define CPUFREQ_STICKY		0x01	/* the driver isn't removed even if 
+#define CPUFREQ_STICKY		0x01	/* the driver isn't removed even if
 					 * all ->init() calls failed */
-#define CPUFREQ_CONST_LOOPS 	0x02	/* loops_per_jiffy or other kernel
+#define CPUFREQ_CONST_LOOPS	0x02	/* loops_per_jiffy or other kernel
 					 * "constants" aren't affected by
 					 * frequency transitions */
 #define CPUFREQ_PM_NO_WARN	0x04	/* don't warn on suspend/resume speed
@@ -252,7 +255,7 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
 
 
-static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max) 
+static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
 {
 	if (policy->min < min)
 		policy->min = min;
@@ -386,12 +389,12 @@ int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 /* the following 3 funtions are for cpufreq core use only */
 struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
 struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
-void   cpufreq_cpu_put (struct cpufreq_policy *data);
+void   cpufreq_cpu_put(struct cpufreq_policy *data);
 
 /* the following are really really optional */
 extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
 
-void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table, 
+void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 				      unsigned int cpu);
 
 void cpufreq_frequency_table_put_attr(unsigned int cpu);

commit 2d06d8c49afdcc9bb35a85039fa50f0fe35bd40e
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 27 15:04:46 2011 +0200

    [CPUFREQ] use dynamic debug instead of custom infrastructure
    
    With dynamic debug having gained the capability to report debug messages
    also during the boot process, it offers a far superior interface for
    debug messages than the custom cpufreq infrastructure. As a first step,
    remove the old cpufreq_debug_printk() function and replace it with a call
    to the generic pr_debug() function.
    
    How can dynamic debug be used on cpufreq? You need a kernel which has
    CONFIG_DYNAMIC_DEBUG enabled.
    
    To enabled debugging during runtime, mount debugfs and
    
    $ echo -n 'module cpufreq +p' > /sys/kernel/debug/dynamic_debug/control
    
    for debugging the complete "cpufreq" module. To achieve the same goal during
    boot, append
    
            ddebug_query="module cpufreq +p"
    
    as a boot parameter to the kernel of your choice.
    
    For more detailled instructions, please see
    Documentation/dynamic-debug-howto.txt
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9343dd3de858..2845f6e67221 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -397,23 +397,4 @@ void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
 void cpufreq_frequency_table_put_attr(unsigned int cpu);
 
 
-/*********************************************************************
- *                     UNIFIED DEBUG HELPERS                         *
- *********************************************************************/
-
-#define CPUFREQ_DEBUG_CORE	1
-#define CPUFREQ_DEBUG_DRIVER	2
-#define CPUFREQ_DEBUG_GOVERNOR	4
-
-#ifdef CONFIG_CPU_FREQ_DEBUG
-
-extern void cpufreq_debug_printk(unsigned int type, const char *prefix, 
-				 const char *fmt, ...);
-
-#else
-
-#define cpufreq_debug_printk(msg...) do { } while(0)
-
-#endif /* CONFIG_CPU_FREQ_DEBUG */
-
 #endif /* _LINUX_CPUFREQ_H */

commit 7ca64e2d2859e96a325c28678b5fdb5e17a5764b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 10 21:13:05 2011 +0100

    [CPUFREQ] Remove the pm_message_t argument from driver suspend
    
    None of the existing cpufreq drivers uses the second argument of
    its .suspend() callback (which isn't useful anyway), so remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f2fe598feb4e..9343dd3de858 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -230,7 +230,7 @@ struct cpufreq_driver {
 	int	(*bios_limit)	(int cpu, unsigned int *limit);
 
 	int	(*exit)		(struct cpufreq_policy *policy);
-	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
+	int	(*suspend)	(struct cpufreq_policy *policy);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
 };

commit e8951251b89440644a39f2512b4f265973926b41
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Mar 3 21:31:26 2011 +0100

    [CPUFREQ] Remove old, deprecated per cpu ondemand/conservative sysfs files
    
    Marked deprecated for quite a whilte now...
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>
    CC: cpufreq@vger.kernel.org

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c3e9de8321c6..f2fe598feb4e 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -281,19 +281,10 @@ __ATTR(_name, 0444, show_##_name, NULL)
 static struct freq_attr _name =			\
 __ATTR(_name, _perm, show_##_name, NULL)
 
-#define cpufreq_freq_attr_ro_old(_name)		\
-static struct freq_attr _name##_old =		\
-__ATTR(_name, 0444, show_##_name##_old, NULL)
-
 #define cpufreq_freq_attr_rw(_name)		\
 static struct freq_attr _name =			\
 __ATTR(_name, 0644, show_##_name, store_##_name)
 
-#define cpufreq_freq_attr_rw_old(_name)		\
-static struct freq_attr _name##_old =		\
-__ATTR(_name, 0644, show_##_name##_old, store_##_name##_old)
-
-
 struct global_attr {
 	struct attribute attr;
 	ssize_t (*show)(struct kobject *kobj,

commit 226528c6100e4191842e61997110c8ace40605f7
Author: Amerigo Wang <amwang@redhat.com>
Date:   Thu Mar 4 03:23:36 2010 -0500

    [CPUFREQ] unexport (un)lock_policy_rwsem* functions
    
    lock_policy_rwsem_* and unlock_policy_rwsem_* functions are scheduled
    to be unexported when 2.6.33. Now there are no other callers of them
    out of cpufreq.c, unexport them and make them static.
    
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9f15150ce8d6..c3e9de8321c6 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -196,11 +196,6 @@ extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy,
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
-int lock_policy_rwsem_read(int cpu);
-int lock_policy_rwsem_write(int cpu);
-void unlock_policy_rwsem_read(int cpu);
-void unlock_policy_rwsem_write(int cpu);
-
 
 /*********************************************************************
  *                      CPUFREQ DRIVER INTERFACE                     *

commit 6dad2a29646ce3792c40cfc52d77e9b65a7bb143
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Wed Mar 31 21:56:46 2010 +0200

    cpufreq: Unify sysfs attribute definition macros
    
    Multiple modules used to define those which are with identical
    functionality and were needlessly replicated among the different cpufreq
    drivers. Push them into the header and remove duplication.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>
    LKML-Reference: <1270065406-1814-7-git-send-email-bp@amd64.org>
    Reviewed-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4de02b10007f..9f15150ce8d6 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -278,6 +278,27 @@ struct freq_attr {
 	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 };
 
+#define cpufreq_freq_attr_ro(_name)		\
+static struct freq_attr _name =			\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
+static struct freq_attr _name =			\
+__ATTR(_name, _perm, show_##_name, NULL)
+
+#define cpufreq_freq_attr_ro_old(_name)		\
+static struct freq_attr _name##_old =		\
+__ATTR(_name, 0444, show_##_name##_old, NULL)
+
+#define cpufreq_freq_attr_rw(_name)		\
+static struct freq_attr _name =			\
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+#define cpufreq_freq_attr_rw_old(_name)		\
+static struct freq_attr _name##_old =		\
+__ATTR(_name, 0644, show_##_name##_old, store_##_name##_old)
+
+
 struct global_attr {
 	struct attribute attr;
 	ssize_t (*show)(struct kobject *kobj,
@@ -286,6 +307,15 @@ struct global_attr {
 			 const char *c, size_t count);
 };
 
+#define define_one_global_ro(_name)		\
+static struct global_attr _name =		\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+#define define_one_global_rw(_name)		\
+static struct global_attr _name =		\
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *
  *********************************************************************/

commit e2f74f355e9e2914483db10c05d70e69e0b7ae04
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Nov 19 12:31:01 2009 +0100

    [ACPI/CPUFREQ] Introduce bios_limit per cpu cpufreq sysfs interface
    
    This interface is mainly intended (and implemented) for ACPI _PPC BIOS
    frequency limitations, but other cpufreq drivers can also use it for
    similar use-cases.
    
    Why is this needed:
    
    Currently it's not obvious why cpufreq got limited.
    People see cpufreq/scaling_max_freq reduced, but this could have
    happened by:
      - any userspace prog writing to scaling_max_freq
      - thermal limitations
      - hardware (_PPC in ACPI case) limitiations
    
    Therefore export bios_limit (in kHz) to:
      - Point the user that it's the BIOS (broken or intended) which limits
        frequency
      - Export it as a sysfs interface for userspace progs.
        While this was a rarely used feature on laptops, there will appear
        more and more server implemenations providing "Green IT" features like
        allowing the service processor to limit the frequency. People want
        to know about HW/BIOS frequency limitations.
    
    All ACPI P-state driven cpufreq drivers are covered with this patch:
      - powernow-k8
      - powernow-k7
      - acpi-cpufreq
    
    Tested with a patched DSDT which limits the first two cores (_PPC returns 1)
    via _PPC, exposed by bios_limit:
    # echo 2200000 >cpu2/cpufreq/scaling_max_freq
    # cat cpu*/cpufreq/scaling_max_freq
    2600000
    2600000
    2200000
    2200000
    # #scaling_max_freq shows general user/thermal/BIOS limitations
    
    # cat cpu*/cpufreq/bios_limit
    2600000
    2600000
    2800000
    2800000
    # #bios_limit only shows the HW/BIOS limitation
    
    CC: Pallipadi Venkatesh <venkatesh.pallipadi@intel.com>
    CC: Len Brown <lenb@kernel.org>
    CC: davej@codemonkey.org.uk
    CC: linux@dominikbrodowski.net
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 79a2340d83cd..4de02b10007f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -232,6 +232,7 @@ struct cpufreq_driver {
 	/* optional */
 	unsigned int (*getavg)	(struct cpufreq_policy *policy,
 				 unsigned int cpu);
+	int	(*bios_limit)	(int cpu, unsigned int *limit);
 
 	int	(*exit)		(struct cpufreq_policy *policy);
 	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);

commit 2eca40a8ccd4160dbfaa5cbd61038d921d0e5f13
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Oct 26 16:49:29 2009 -0700

    cpufreq: add cpufreq_get() stub for CONFIG_CPU_FREQ=n
    
    When CONFIG_CPU_FREQ is disabled, cpufreq_get() needs a stub.  Used by kvm
    (although it looks like a bit of the kvm code could be omitted when
    CONFIG_CPU_FREQ is disabled).
    
    arch/x86/built-in.o: In function `kvm_arch_init':
    (.text+0x10de7): undefined reference to `cpufreq_get'
    
    (Needed in linux-next's KVM tree, but it's correct in 2.6.32).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Tested-by: Eric Paris <eparis@redhat.com>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 44717eb47639..79a2340d83cd 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -291,8 +291,15 @@ struct global_attr {
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 
+#ifdef CONFIG_CPU_FREQ
 /* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
 unsigned int cpufreq_get(unsigned int cpu);
+#else
+static inline unsigned int cpufreq_get(unsigned int cpu)
+{
+	return 0;
+}
+#endif
 
 /* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
 #ifdef CONFIG_CPU_FREQ

commit 8aa84ad8d6c740a04386f599694609ee4998e82e
Author: Thomas Renninger <trenn@suse.de>
Date:   Fri Jul 24 15:25:05 2009 +0200

    [CPUFREQ] Introduce global, not per core: /sys/devices/system/cpu/cpufreq
    
    Currently everything in the cpufreq layer is per core based.
    This does not reflect reality, for example ondemand on conservative
    governors have global sysfs variables.
    
    Introduce a global cpufreq directory and add the kobject to the governor
    struct, so that governors can easily access it.
    The directory is initialized in the cpufreq_core_init initcall and thus will
    always be created if cpufreq is compiled in, even if no cpufreq driver is
    active later.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 161042746afc..44717eb47639 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -65,6 +65,9 @@ static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
 
 struct cpufreq_governor;
 
+/* /sys/devices/system/cpu/cpufreq: entry point for global variables */
+extern struct kobject *cpufreq_global_kobject;
+
 #define CPUFREQ_ETERNAL			(-1)
 struct cpufreq_cpuinfo {
 	unsigned int		max_freq;
@@ -274,6 +277,13 @@ struct freq_attr {
 	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 };
 
+struct global_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct kobject *kobj,
+			struct attribute *attr, char *buf);
+	ssize_t (*store)(struct kobject *a, struct attribute *b,
+			 const char *c, size_t count);
+};
 
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *

commit 129f8ae9b1b5be94517da76009ea956e89104ce8
Author: Dave Jones <davej@redhat.com>
Date:   Mon Mar 9 15:07:33 2009 -0400

    Revert "[CPUFREQ] Disable sysfs ui for p4-clockmod."
    
    This reverts commit e088e4c9cdb618675874becb91b2fd581ee707e6.
    
    Removing the sysfs interface for p4-clockmod was flagged as a
    regression in bug 12826.
    
    Course of action:
     - Find out the remaining causes of overheating, and fix them
       if possible. ACPI should be doing the right thing automatically.
       If it isn't, we need to fix that.
     - mark p4-clockmod ui as deprecated
     - try again with the removal in six months.
    
    It's not really feasible to printk about the deprecation, because
    it needs to happen at all the sysfs entry points, which means adding
    a lot of strcmp("p4-clockmod".. calls to the core, which.. bleuch.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 384b38d3e8e2..161042746afc 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -234,7 +234,6 @@ struct cpufreq_driver {
 	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
-	bool			hide_interface;
 };
 
 /* flags */

commit 835481d9bcd65720b473db6b38746a74a3964218
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sun Jan 4 05:18:06 2009 -0800

    cpumask: convert struct cpufreq_policy to cpumask_var_t
    
    Impact: use new cpumask API to reduce memory usage
    
    This is part of an effort to reduce structure sizes for machines
    configured with large NR_CPUS.  cpumask_t gets replaced by
    cpumask_var_t, which is either struct cpumask[1] (small NR_CPUS) or
    struct cpumask * (large NR_CPUS).
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 484b3abf61bb..384b38d3e8e2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -80,8 +80,8 @@ struct cpufreq_real_policy {
 };
 
 struct cpufreq_policy {
-	cpumask_t		cpus;	/* CPUs requiring sw coordination */
-	cpumask_t		related_cpus; /* CPUs with any coordination */
+	cpumask_var_t		cpus;	/* CPUs requiring sw coordination */
+	cpumask_var_t		related_cpus; /* CPUs with any coordination */
 	unsigned int		shared_type; /* ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of registered CPU */

commit e088e4c9cdb618675874becb91b2fd581ee707e6
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Nov 25 13:29:47 2008 -0500

    [CPUFREQ] Disable sysfs ui for p4-clockmod.
    
    p4-clockmod has a long history of abuse.   It pretends to be a CPU
    frequency scaling driver, even though it doesn't actually change
    the CPU frequency, but instead just modulates the frequency with
    wait-states.
    The biggest misconception is that when running at the lower 'frequency'
    p4-clockmod is saving power.  This isn't the case, as workloads running
    slower take longer to complete, preventing the CPU from entering deep C states.
    
    However p4-clockmod does have a purpose.  It can prevent overheating.
    Having it hooked up to the cpufreq interfaces is the wrong way to achieve
    cooling however. It should instead be hooked up to ACPI.
    
    This diff introduces a means for a cpufreq driver to register with the
    cpufreq core, but not present a sysfs interface.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 1ee608fd7b77..484b3abf61bb 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -234,6 +234,7 @@ struct cpufreq_driver {
 	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
+	bool			hide_interface;
 };
 
 /* flags */

commit bf0b90e357c883e8efd72954432efe652de74c76
Author: venkatesh.pallipadi@intel.com <venkatesh.pallipadi@intel.com>
Date:   Mon Aug 4 11:59:07 2008 -0700

    [CPUFREQ][1/6] cpufreq: Add cpu number parameter to __cpufreq_driver_getavg()
    
    Add a cpu parameter to __cpufreq_driver_getavg(). This is needed for software
    cpufreq coordination where policy->cpu may not be same as the CPU on which we
    want to getavg frequency.
    
    A follow-on patch will use this parameter to getavg freq from all cpus
    in policy->cpus.
    
    Change since last patch. Fix the offline/online and suspend/resume
    oops reported by Youquan Song <youquan.song@intel.com>
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 6fd5668aa572..1ee608fd7b77 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -187,7 +187,8 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int relation);
 
 
-extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy);
+extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy,
+				   unsigned int cpu);
 
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
@@ -226,7 +227,9 @@ struct cpufreq_driver {
 	unsigned int	(*get)	(unsigned int cpu);
 
 	/* optional */
-	unsigned int (*getavg)	(unsigned int cpu);
+	unsigned int (*getavg)	(struct cpufreq_policy *policy,
+				 unsigned int cpu);
+
 	int	(*exit)		(struct cpufreq_policy *policy);
 	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
 	int	(*resume)	(struct cpufreq_policy *policy);

commit a1531acd43310a7e4571d52e8846640667f4c74b
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Jul 29 22:32:58 2008 -0700

    cpufreq acpi: only call _PPC after cpufreq ACPI init funcs got called already
    
    Ingo Molnar provided a fix to not call _PPC at processor driver
    initialization time in "[PATCH] ACPI: fix cpufreq regression" (git
    commit e4233dec749a3519069d9390561b5636a75c7579)
    
    But it can still happen that _PPC is called at processor driver
    initialization time.
    
    This patch should make sure that this is not possible anymore.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 2270ca5ec631..6fd5668aa572 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -106,6 +106,7 @@ struct cpufreq_policy {
 #define CPUFREQ_ADJUST		(0)
 #define CPUFREQ_INCOMPATIBLE	(1)
 #define CPUFREQ_NOTIFY		(2)
+#define CPUFREQ_START		(3)
 
 #define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
 #define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */

commit 48adcf148c83faa41999fb0b3524299c4e160fd9
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:16 2008 +0300

    [CPUFREQ] cpufreq: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index e7e91dbfde0f..2270ca5ec631 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -4,9 +4,6 @@
  *  Copyright (C) 2001 Russell King
  *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
  *            
- *
- * $Id: cpufreq.h,v 1.36 2003/01/20 17:31:48 db Exp $
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.

commit 30d221db4439973076953e2ed44344fa92d1d09f
Author: Alessandro Guido <alessandro.guido@gmail.com>
Date:   Fri Apr 18 13:31:13 2008 -0700

    [CPUFREQ] allow use of the powersave governor as the default one
    
    Allow use of the powersave cpufreq governor as the default one for EMBEDDED
    configs.
    
    Signed-off-by: Alessandro Guido <alessandro.guido@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index a881fd62c447..e7e91dbfde0f 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -308,6 +308,9 @@ extern struct cpufreq_governor cpufreq_gov_performance;
 #endif
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_performance)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE)
+extern struct cpufreq_governor cpufreq_gov_powersave;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_powersave)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)

commit e8628dd06d66f2e3965ec9742029b401d63434f1
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Apr 18 13:31:12 2008 -0700

    [CPUFREQ] expose cpufreq coordination requirements regardless of coordination mechanism
    
    Currently, affected_cpus shows which CPUs need to have their frequency
    coordinated in software.  When hardware coordination is in use, the contents
    of this file appear the same as when no coordination is required.  This can
    lead to some confusion among user-space programs, for example, that do not
    know that extra coordination is required to force a CPU core to a particular
    speed to control power consumption.
    
    To fix this, create a "related_cpus" attribute that always displays the
    coordination map regardless of whatever coordination strategy the cpufreq
    driver uses (sw or hw).  If the cpufreq driver does not provide a value, fall
    back to policy->cpus.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ddd8652fc3f3..a881fd62c447 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -83,7 +83,8 @@ struct cpufreq_real_policy {
 };
 
 struct cpufreq_policy {
-	cpumask_t		cpus;	/* affected CPUs */
+	cpumask_t		cpus;	/* CPUs requiring sw coordination */
+	cpumask_t		related_cpus; /* CPUs with any coordination */
 	unsigned int		shared_type; /* ANY or ALL affected CPUs
 						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of registered CPU */

commit 9e76988e9390a4ff4d171f690586d0c58186b47e
Author: Venki Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Fri Oct 26 10:18:21 2007 -0700

    [CPUFREQ] Eliminate cpufreq_userspace scaling_setspeed deadlock
    
    Eliminate cpufreq_userspace scaling_setspeed deadlock.
    
    Luming Yu recently uncovered yet another cpufreq related deadlock.
    One thread that continuously switches the governors and the other thread that
    repeatedly cats the contents of cpufreq directory causes both these threads to
    go into a deadlock.
    
    Detailed examination of the deadlock showed the exact flow before the deadlock
    as:
    
    Thread 1                        Thread 2
    ________                        ________
                                    cats files under /sys/devices/.../cpufreq/
    Set governor to userspace
      Adds a new sysfs entry for
      scaling_setspeed
                                    cats files under /sys/devices/.../cpufreq/
    
    Set governor to performance
      Holds cpufreq_rw_sem in write
      mode
      Sends a STOP notify to
      userspace governor
                                    cat /sys/devices/.../cpufreq/scaling_setspeed
                                      Gets a handle on the above sysfs entry with
                                      sysfs_get_active
                                      Blocks while trying to get cpufreq_rw_sem
                                      in read mode
      Remove a sysfs entry for
      scaling_setspeed
        Blocks on sysfs_deactivate
        while waiting for earlier
        get_active (on other thread)
        to drain
    
    At this point both threads go into deadlock and any other thread that tries to
    do anything with sysfs cpufreq will also block.
    
    There seems to be no easy way to avoid this deadlock as long as
    cpufreq_userspace adds/removes the sysfs entry under same kobject as cpufreq.
    Below patch moves scaling_setspeed to cpufreq.c, keeping it always and calling
    back the governor on read/write. This is the cleanest fix I could think of,
    even though adding two callbacks in governor structure just for this seems
    unnecessary.
    
    Note that the change makes scaling_setspeed under /sys/.../cpufreq permanent
    and returns <unsupported> when governor is not userspace.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 23932d7741a9..ddd8652fc3f3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -167,6 +167,10 @@ struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
 	int 	(*governor)	(struct cpufreq_policy *policy,
 				 unsigned int event);
+	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
+					 char *buf);
+	int 	(*store_setspeed)	(struct cpufreq_policy *policy,
+					 unsigned int freq);
 	unsigned int max_transition_latency; /* HW must be able to switch to
 			next freq faster than this value in nano secs or we
 			will fallback to performance governor */

commit 6070b5de50ab5e3f810628a9cbb04deecf30a85f
Author: Satyam Sharma <satyam@infradead.org>
Date:   Tue Oct 2 13:28:15 2007 -0700

    [CPUFREQ] implement !CONFIG_CPU_FREQ stub for  cpufreq_unregister_notifier()
    
    Callsites such as arch/powerpc/oprofile/op_model_cell.c are having to
    open-code #ifdef CONFIG_CPU_FREQ only to be able to get at the full definition
    of cpufreq_unregister_notifier(), because no empty stub is available for the
    !CONFIG_CPU_FREQ case.  Let's provide one, to be able to remove such #ifdef's
    from the rest of the kernel tree -- those will come in a subsequent patch.
    
    Signed-off-by: Satyam Sharma <satyam@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 450a841b5892..23932d7741a9 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -32,12 +32,24 @@
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/
 
-int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
-int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
-
 #define CPUFREQ_TRANSITION_NOTIFIER	(0)
 #define CPUFREQ_POLICY_NOTIFIER		(1)
 
+#ifdef CONFIG_CPU_FREQ
+int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
+#else		/* CONFIG_CPU_FREQ */
+static inline int cpufreq_register_notifier(struct notifier_block *nb,
+						unsigned int list)
+{
+	return 0;
+}
+static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
+						unsigned int list)
+{
+	return 0;
+}
+#endif		/* CONFIG_CPU_FREQ */
 
 /* if (cpufreq_driver->target) exists, the ->governor decides what frequency
  * within the limits is used. If (cpufreq_driver->setpolicy> exists, these

commit 6afde10c3f58cc3ac593f5b4505b8b1cf719f5d6
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Oct 2 13:28:13 2007 -0700

    [CPUFREQ] Only check for transition latency on problematic governors (kconfig fix)
    
    Cc: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 9e5f5d0c87f3..450a841b5892 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -286,8 +286,9 @@ static inline unsigned int cpufreq_quick_get(unsigned int cpu)
   Performance governor is fallback governor if any other gov failed to
   auto load due latency restrictions
 */
+#ifdef CONFIG_CPU_FREQ_GOV_PERFORMANCE
 extern struct cpufreq_governor cpufreq_gov_performance;
-#define CPUFREQ_PERFORMANCE_GOVERNOR	(&cpufreq_gov_performance)
+#endif
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_performance)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)

commit 1c2562459faedc35927546cfa5273ec6c2884cce
Author: Thomas Renninger <trenn@suse.de>
Date:   Tue Oct 2 13:28:12 2007 -0700

    [CPUFREQ] allow ondemand and conservative cpufreq governors to be used as default
    
    Depending on the transition latency of the HW for cpufreq switches, the
    ondemand or conservative governor cannot be used with certain cpufreq
    drivers.  Still the ondemand should be the default governor on a wide range
    of systems.  This patch allows this and lets the governor fallback to the
    performance governor at cpufreq driver load time, if the driver does not
    support fast enough frequency switching.
    
    Main benefit is that on e.g.  installation or other systems without
    userspace support a working dynamic cpufreq support can be achieved on most
    systems by simply loading the cpufreq driver.  This is especially essential
    for recent x86(_64) laptop hardware which may rely on working dynamic
    cpufreq OS support.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 3ec6e7ff5fbd..9e5f5d0c87f3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -155,6 +155,9 @@ struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
 	int 	(*governor)	(struct cpufreq_policy *policy,
 				 unsigned int event);
+	unsigned int max_transition_latency; /* HW must be able to switch to
+			next freq faster than this value in nano secs or we
+			will fallback to performance governor */
 	struct list_head	governor_list;
 	struct module		*owner;
 };
@@ -279,12 +282,23 @@ static inline unsigned int cpufreq_quick_get(unsigned int cpu)
  *********************************************************************/
 
 
-#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
+/*
+  Performance governor is fallback governor if any other gov failed to
+  auto load due latency restrictions
+*/
 extern struct cpufreq_governor cpufreq_gov_performance;
-#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_performance
+#define CPUFREQ_PERFORMANCE_GOVERNOR	(&cpufreq_gov_performance)
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_performance)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
-#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_userspace
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_userspace)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND)
+extern struct cpufreq_governor cpufreq_gov_ondemand;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_ondemand)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
+extern struct cpufreq_governor cpufreq_gov_conservative;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
 #endif
 
 

commit ff0ce6845bc18292e80ea40d11c3d3a539a3fc5e
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Sep 26 15:52:17 2007 -0700

    Revert "[PATCH] x86-64: fix x86_64-mm-sched-clock-share"
    
    This reverts commit 184c44d2049c4db7ef6ec65794546954da2c6a0e.
    
    As noted by Dave Jones:
       "Linus, please revert the above cset.  It doesn't seem to be
        necessary (it was added to fix a miscompile in 'make allnoconfig'
        which doesn't seem to be repeatable with it reverted) and actively
       breaks the ARM SA1100 framebuffer driver."
    
    Requested-by: Dave Jones <davej@redhat.com>
    Cc: Russell King <rmk+lkml@arm.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 963051a967d6..3ec6e7ff5fbd 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -32,15 +32,7 @@
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/
 
-#ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
-#else
-static inline int cpufreq_register_notifier(struct notifier_block *nb,
-						unsigned int list)
-{
-	return 0;
-}
-#endif
 int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 
 #define CPUFREQ_TRANSITION_NOTIFIER	(0)
@@ -268,22 +260,17 @@ struct freq_attr {
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 
+/* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
+unsigned int cpufreq_get(unsigned int cpu);
 
-/*
- * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
- */
+/* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_quick_get(unsigned int cpu);
-unsigned int cpufreq_get(unsigned int cpu);
 #else
 static inline unsigned int cpufreq_quick_get(unsigned int cpu)
 {
 	return 0;
 }
-static inline unsigned int cpufreq_get(unsigned int cpu)
-{
-	return 0;
-}
 #endif
 
 

commit ea62ccd00fd0b6720b033adfc9984f31130ce195
Merge: 886a0768affe 35060b6a9a4e
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sat May 5 14:55:20 2007 -0700

    Merge branch 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6
    
    * 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6: (231 commits)
      [PATCH] i386: Don't delete cpu_devs data to identify different x86 types in late_initcall
      [PATCH] i386: type may be unused
      [PATCH] i386: Some additional chipset register values validation.
      [PATCH] i386: Add missing !X86_PAE dependincy to the 2G/2G split.
      [PATCH] x86-64: Don't exclude asm-offsets.c in Documentation/dontdiff
      [PATCH] i386: avoid redundant preempt_disable in __unlazy_fpu
      [PATCH] i386: white space fixes in i387.h
      [PATCH] i386: Drop noisy e820 debugging printks
      [PATCH] x86-64: Fix allnoconfig error in genapic_flat.c
      [PATCH] x86-64: Shut up warnings for vfat compat ioctls on other file systems
      [PATCH] x86-64: Share identical video.S between i386 and x86-64
      [PATCH] x86-64: Remove CONFIG_REORDER
      [PATCH] x86-64: Print type and size correctly for unknown compat ioctls
      [PATCH] i386: Remove copy_*_user BUG_ONs for (size < 0)
      [PATCH] i386: Little cleanups in smpboot.c
      [PATCH] x86-64: Don't enable NUMA for a single node in K8 NUMA scanning
      [PATCH] x86: Use RDTSCP for synchronous get_cycles if possible
      [PATCH] i386: Add X86_FEATURE_RDTSCP
      [PATCH] i386: Implement X86_FEATURE_SYNC_RDTSC on i386
      [PATCH] i386: Implement alternative_io for i386
      ...
    
    Fix up trivial conflict in include/linux/highmem.h manually.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

commit 184c44d2049c4db7ef6ec65794546954da2c6a0e
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed May 2 19:27:08 2007 +0200

    [PATCH] x86-64: fix x86_64-mm-sched-clock-share
    
    Fix for the following patch. Provide dummy cpufreq functions when
    CPUFREQ is not compiled in.
    
    Cc: Andi Kleen <ak@suse.de>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0899e2cdcdd1..cb9b2ec8849c 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -32,7 +32,15 @@
  *                     CPUFREQ NOTIFIER INTERFACE                    *
  *********************************************************************/
 
+#ifdef CONFIG_CPU_FREQ
 int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+#else
+static inline int cpufreq_register_notifier(struct notifier_block *nb,
+						unsigned int list)
+{
+	return 0;
+}
+#endif
 int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 
 #define CPUFREQ_TRANSITION_NOTIFIER	(0)
@@ -261,17 +269,22 @@ int cpufreq_set_policy(struct cpufreq_policy *policy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 
-/* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
-unsigned int cpufreq_get(unsigned int cpu);
 
-/* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
+/*
+ * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
+ */
 #ifdef CONFIG_CPU_FREQ
 unsigned int cpufreq_quick_get(unsigned int cpu);
+unsigned int cpufreq_get(unsigned int cpu);
 #else
 static inline unsigned int cpufreq_quick_get(unsigned int cpu)
 {
 	return 0;
 }
+static inline unsigned int cpufreq_get(unsigned int cpu)
+{
+	return 0;
+}
 #endif
 
 

commit 632786ce9ff6206951ee4c84fe5c0d5c1d12f4cc
Author: Thomas Renninger <trenn@suse.de>
Date:   Thu Apr 19 15:49:09 2007 +0200

    [CPUFREQ] Remove deprecated /proc/acpi/processor/performance write support
    
    Remove deprecated /proc/acpi/processor/performance write support
    
    Writing to /proc/acpi/processor/xy/performance interferes with sysfs
    cpufreq interface. Also removes buggy cpufreq_set_policy exported symbol.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0899e2cdcdd1..3ec6e7ff5fbd 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -257,7 +257,6 @@ struct freq_attr {
 /*********************************************************************
  *                        CPUFREQ 2.6. INTERFACE                     *
  *********************************************************************/
-int cpufreq_set_policy(struct cpufreq_policy *policy);
 int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 int cpufreq_update_policy(unsigned int cpu);
 

commit 221dee285ee38099b82437531bcae9fa9cb64cc4
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 26 14:55:48 2007 -0800

    Revert "[CPUFREQ] constify cpufreq_driver where possible."
    
    This reverts commit aeeddc1435c37fa3fc844f31d39c185b08de4158, which was
    half-baked and broken.  It just resulted in compile errors, since
    cpufreq_register_driver() still changes the 'driver_data' by setting
    bits in the flags field.  So claiming it is 'const' _really_ doesn't
    work.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 3a25235d79da..0899e2cdcdd1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -225,8 +225,8 @@ struct cpufreq_driver {
 #define CPUFREQ_PM_NO_WARN	0x04	/* don't warn on suspend/resume speed
 					 * mismatches */
 
-int cpufreq_register_driver(const struct cpufreq_driver *driver_data);
-int cpufreq_unregister_driver(const struct cpufreq_driver *driver_data);
+int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
 
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);

commit aeeddc1435c37fa3fc844f31d39c185b08de4158
Author: Dave Jones <davej@redhat.com>
Date:   Thu Feb 22 19:08:27 2007 -0500

    [CPUFREQ] constify cpufreq_driver where possible.
    
    Not all cases are possible due to ->flags being set at runtime
    on some drivers.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 0899e2cdcdd1..3a25235d79da 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -225,8 +225,8 @@ struct cpufreq_driver {
 #define CPUFREQ_PM_NO_WARN	0x04	/* don't warn on suspend/resume speed
 					 * mismatches */
 
-int cpufreq_register_driver(struct cpufreq_driver *driver_data);
-int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+int cpufreq_register_driver(const struct cpufreq_driver *driver_data);
+int cpufreq_unregister_driver(const struct cpufreq_driver *driver_data);
 
 
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);

commit 5a01f2e8f3ac134e24144d74bb48a60236f7024d
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Mon Feb 5 16:12:44 2007 -0800

    [CPUFREQ] Rewrite lock in cpufreq to eliminate cpufreq/hotplug related issues
    
    Yet another attempt to resolve cpufreq and hotplug locking issues.
    
    Patchset has 3 patches:
    * Rewrite the lock infrastructure of cpufreq using a per cpu rwsem.
    * Minor restructuring of work callback in ondemand driver.
    * Use the new cpufreq rwsem infrastructure in ondemand work.
    
    This patch:
    
    Convert policy->lock to rwsem and move it to per_cpu area.
    This rwsem will protect against both changing/accessing policy
    related parameters and CPU hot plug/unplug.
    
    [malattia@linux.it: fix oops in kref_put()]
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Mattia Dongili <malattia@linux.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 7f008f6bfdc3..0899e2cdcdd1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -84,9 +84,6 @@ struct cpufreq_policy {
         unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 
- 	struct mutex		lock;   /* CPU ->setpolicy or ->target may
-					   only be called once a time */
-
 	struct work_struct	update; /* if update_policy() needs to be
 					 * called, but you're in IRQ context */
 
@@ -172,11 +169,16 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int relation);
 
 
-extern int cpufreq_driver_getavg(struct cpufreq_policy *policy);
+extern int __cpufreq_driver_getavg(struct cpufreq_policy *policy);
 
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
+int lock_policy_rwsem_read(int cpu);
+int lock_policy_rwsem_write(int cpu);
+void unlock_policy_rwsem_read(int cpu);
+void unlock_policy_rwsem_write(int cpu);
+
 
 /*********************************************************************
  *                      CPUFREQ DRIVER INTERFACE                     *

commit dfde5d62ed9b28b0bda676c16e8cb635df244ef2
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Tue Oct 3 12:38:45 2006 -0700

    [CPUFREQ][8/8] acpi-cpufreq: Add support for freq feedback from hardware
    
    Enable ondemand governor and acpi-cpufreq to use IA32_APERF and IA32_MPERF MSR
    to get active frequency feedback for the last sampling interval. This will
    make ondemand take right frequency decisions when hardware coordination of
    frequency is going on.
    
    Without APERF/MPERF, ondemand can take wrong decision at times due
    to underlying hardware coordination or TM2.
    Example:
    * CPU 0 and CPU 1 are hardware cooridnated.
    * CPU 1 running at highest frequency.
    * CPU 0 was running at highest freq. Now ondemand reduces it to
      some intermediate frequency based on utilization.
    * Due to underlying hardware coordination with other CPU 1, CPU 0 continues to
      run at highest frequency (as long as other CPU is at highest).
    * When ondemand samples CPU 0 again next time, without actual frequency
      feedback from APERF/MPERF, it will think that previous frequency change
      was successful and can go to wrong target frequency. This is because it
      thinks that utilization it has got this sampling interval is when running at
      intermediate frequency, rather than actual highest frequency.
    
    More information about IA32_APERF IA32_MPERF MSR:
    Refer to IA-32 Intel Architecture Software Developer's Manual at
    http://developer.intel.com
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 4ea39fee99c7..7f008f6bfdc3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -172,6 +172,8 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int relation);
 
 
+extern int cpufreq_driver_getavg(struct cpufreq_policy *policy);
+
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 
@@ -204,6 +206,7 @@ struct cpufreq_driver {
 	unsigned int	(*get)	(unsigned int cpu);
 
 	/* optional */
+	unsigned int (*getavg)	(unsigned int cpu);
 	int	(*exit)		(struct cpufreq_policy *policy);
 	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
 	int	(*resume)	(struct cpufreq_policy *policy);

commit 153d7f3fcae7ed4e19328549aa9467acdfbced10
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Jul 26 15:40:07 2006 +0200

    [PATCH] Reorganize the cpufreq cpu hotplug locking to not be totally bizare
    
    The patch below moves the cpu hotplugging higher up in the cpufreq
    layering; this is needed to avoid recursive taking of the cpu hotplug
    lock and to otherwise detangle the mess.
    
    The new rules are:
    1. you must do lock_cpu_hotplug() around the following functions:
       __cpufreq_driver_target
       __cpufreq_governor (for CPUFREQ_GOV_LIMITS operation only)
       __cpufreq_set_policy
    2. governer methods (.governer) must NOT take the lock_cpu_hotplug()
       lock in any way; they are called with the lock taken already
    3. if your governer spawns a thread that does things, like calling
       __cpufreq_driver_target, your thread must honor rule #1.
    4. the policy lock and other cpufreq internal locks nest within
       the lock_cpu_hotplug() lock.
    
    I'm not entirely happy about how the __cpufreq_governor rule ended up
    (conditional locking rule depending on the argument) but basically all
    callers pass this as a constant so it's not too horrible.
    
    The patch also removes the cpufreq_governor() function since during the
    locking audit it turned out to be entirely unused (so no need to fix it)
    
    The patch works on my testbox, but it could use more testing
    (otoh... it can't be much worse than the current code)
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 35e137636b0b..4ea39fee99c7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -172,9 +172,6 @@ extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
 				   unsigned int relation);
 
 
-/* pass an event to the cpufreq governor */
-int cpufreq_governor(unsigned int cpu, unsigned int event);
-
 int cpufreq_register_governor(struct cpufreq_governor *governor);
 void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 

commit 46f18e3a28295a9e11a6ffa4478241c19bc93735
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Mon Jun 26 00:34:43 2006 -0400

    ACPI: HW P-state coordination support
    
    Treat HW coordination as independent CPUs.
    This enables per-cpu monintoring of P-states
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5737
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 466fbe9e4899..35e137636b0b 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -100,8 +100,10 @@ struct cpufreq_policy {
 #define CPUFREQ_INCOMPATIBLE	(1)
 #define CPUFREQ_NOTIFY		(2)
 
-#define CPUFREQ_SHARED_TYPE_ALL	(0) /* All dependent CPUs should set freq */
-#define CPUFREQ_SHARED_TYPE_ANY	(1) /* Freq can be set from any dependent CPU */
+#define CPUFREQ_SHARED_TYPE_NONE (0) /* None */
+#define CPUFREQ_SHARED_TYPE_HW	 (1) /* HW does needed coordination */
+#define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */
+#define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
 
 /******************** cpufreq transition notifiers *******************/
 

commit 37224470c8c6d90a4062e76a08d4dc1fcf91fc89
Merge: e83319510b04 ae6c859b7dcd
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jun 23 07:52:36 2006 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (65 commits)
      ACPI: suppress power button event on S3 resume
      ACPI: resolve merge conflict between sem2mutex and processor_perflib.c
      ACPI: use for_each_possible_cpu() instead of for_each_cpu()
      ACPI: delete newly added debugging macros in processor_perflib.c
      ACPI: UP build fix for bugzilla-5737
      Enable P-state software coordination via _PDC
      P-state software coordination for speedstep-centrino
      P-state software coordination for acpi-cpufreq
      P-state software coordination for ACPI core
      ACPI: create acpi_thermal_resume()
      ACPI: create acpi_fan_suspend()/acpi_fan_resume()
      ACPI: pass pm_message_t from acpi_device_suspend() to root_suspend()
      ACPI: create acpi_device_suspend()/acpi_device_resume()
      ACPI: replace spin_lock_irq with mutex for ec poll mode
      ACPI: Allow a WAN module enable/disable on a Thinkpad X60.
      sem2mutex: acpi, acpi_link_lock
      ACPI: delete unused acpi_bus_drivers_lock
      sem2mutex: drivers/acpi/processor_perflib.c
      ACPI add ia64 exports to build acpi_memhotplug as a module
      ACPI: asus_acpi_init(): propagate correct return value
      ...
    
    Manual resolve of conflicts in:
    
            arch/i386/kernel/cpu/cpufreq/acpi-cpufreq.c
            arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
            include/acpi/processor.h

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 17866d7e2b71..5aa95011f7e6 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -15,7 +15,6 @@
 #define _LINUX_CPUFREQ_H
 
 #include <linux/mutex.h>
-#include <linux/config.h>
 #include <linux/notifier.h>
 #include <linux/threads.h>
 #include <linux/device.h>

commit 3b2d99429e3386b6e2ac949fc72486509c8bbe36
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed Dec 14 15:05:00 2005 -0500

    P-state software coordination for ACPI core
    
    http://bugzilla.kernel.org/show_bug.cgi?id=5737
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 17866d7e2b71..f7d988366941 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -73,6 +73,8 @@ struct cpufreq_real_policy {
 
 struct cpufreq_policy {
 	cpumask_t		cpus;	/* affected CPUs */
+	unsigned int		shared_type; /* ANY or ALL affected CPUs
+						should set cpufreq */
 	unsigned int		cpu;    /* cpu nr of registered CPU */
 	struct cpufreq_cpuinfo	cpuinfo;/* see above */
 
@@ -99,6 +101,8 @@ struct cpufreq_policy {
 #define CPUFREQ_INCOMPATIBLE	(1)
 #define CPUFREQ_NOTIFY		(2)
 
+#define CPUFREQ_SHARED_TYPE_ALL	(0) /* All dependent CPUs should set freq */
+#define CPUFREQ_SHARED_TYPE_ANY	(1) /* Freq can be set from any dependent CPU */
 
 /******************** cpufreq transition notifiers *******************/
 

commit 83933af4720b282f6f6a0b6c05a2a47b4cf08819
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Jan 14 16:01:49 2006 +0100

    [CPUFREQ] convert remaining cpufreq semaphore to a mutex
    
    This one fell through the automation at first because it initializes the
    semaphore to locked, but that's easily remedied
    
    Signed-off-by:  Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Dave Jones <davej@redhat.com>
    
     drivers/cpufreq/cpufreq.c |   37 +++++++++++++++++++------------------
     include/linux/cpufreq.h   |    3 ++-
     2 files changed, 21 insertions(+), 19 deletions(-)

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index c31650df9241..17866d7e2b71 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -14,6 +14,7 @@
 #ifndef _LINUX_CPUFREQ_H
 #define _LINUX_CPUFREQ_H
 
+#include <linux/mutex.h>
 #include <linux/config.h>
 #include <linux/notifier.h>
 #include <linux/threads.h>
@@ -82,7 +83,7 @@ struct cpufreq_policy {
         unsigned int		policy; /* see above */
 	struct cpufreq_governor	*governor; /* see below */
 
- 	struct semaphore	lock;   /* CPU ->setpolicy or ->target may
+ 	struct mutex		lock;   /* CPU ->setpolicy or ->target may
 					   only be called once a time */
 
 	struct work_struct	update; /* if update_policy() needs to be

commit 95235ca2c20ac0b31a8eb39e2d599bcc3e9c9a10
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Fri Dec 2 10:43:20 2005 -0800

    [CPUFREQ] CPU frequency display in /proc/cpuinfo
    
    What is the value shown in "cpu MHz" of /proc/cpuinfo when CPUs are capable of
    changing frequency?
    
    Today the answer is: It depends.
    On i386:
    SMP kernel - It is always the boot frequency
    UP kernel - Scales with the frequency change and shows that was last set.
    
    On x86_64:
    There is one single variable cpu_khz that gets written by all the CPUs. So,
    the frequency set by last CPU will be seen on /proc/cpuinfo of all the
    CPUs in the system. What you see also depends on whether you have constant_tsc
    capable CPU or not.
    
    On ia64:
    It is always boot time frequency of a particular CPU that gets displayed.
    
    The patch below changes this to:
    Show the last known frequency of the particular CPU, when cpufreq is present. If
    cpu doesnot support changing of frequency through cpufreq, then boot frequency
    will be shown. The patch affects i386, x86_64 and ia64 architectures.
    
    Signed-off-by: Venkatesh Pallipadi<venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index d068176b7ad7..c31650df9241 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -256,6 +256,16 @@ int cpufreq_update_policy(unsigned int cpu);
 /* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
 unsigned int cpufreq_get(unsigned int cpu);
 
+/* query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it */
+#ifdef CONFIG_CPU_FREQ
+unsigned int cpufreq_quick_get(unsigned int cpu);
+#else
+static inline unsigned int cpufreq_quick_get(unsigned int cpu)
+{
+	return 0;
+}
+#endif
+
 
 /*********************************************************************
  *                       CPUFREQ DEFAULT GOVERNOR                    *

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index ff7f80f48df1..d068176b7ad7 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -23,6 +23,7 @@
 #include <linux/completion.h>
 #include <linux/workqueue.h>
 #include <linux/cpumask.h>
+#include <asm/div64.h>
 
 #define CPUFREQ_NAME_LEN 16
 

commit e00d9967e3addea86dded46deefc5daec5d52e5a
Author: Bernard Blackham <bernard@blackham.com.au>
Date:   Thu Jul 7 17:56:42 2005 -0700

    [PATCH] pm: fix u32 vs. pm_message_t confusion in cpufreq
    
    Fix u32 vs pm_message_t confusion in cpufreq.
    
    Signed-off-by: Bernard Blackham <bernard@blackham.com.au>
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 927daa86c9b3..ff7f80f48df1 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -201,7 +201,7 @@ struct cpufreq_driver {
 
 	/* optional */
 	int	(*exit)		(struct cpufreq_policy *policy);
-	int	(*suspend)	(struct cpufreq_policy *policy, u32 state);
+	int	(*suspend)	(struct cpufreq_policy *policy, pm_message_t pmsg);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
 };

commit b53cc6ead046093477ec7a3354d620337101ea5b
Author: Dave Jones <davej@redhat.com>
Date:   Tue May 31 19:03:47 2005 -0700

    [CPUFREQ] fix up comment in cpufreq.h
    
    Fix up comment in cpufreq.h stating transition latency should be passed
    in microseconds -- it was decided long ago to switch to nanoseconds.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index f21af067d015..927daa86c9b3 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -49,7 +49,7 @@ int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 /* Frequency values here are CPU kHz so that hardware which doesn't run 
  * with some frequencies can complain without having to guess what per 
  * cent / per mille means. 
- * Maximum transition latency is in microseconds - if it's unknown,
+ * Maximum transition latency is in nanoseconds - if it's unknown,
  * CPUFREQ_ETERNAL shall be used.
  */
 

commit 42d4dc3f4e1ec1396371aac89d0dccfdd977191b
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Apr 29 07:40:12 2005 -0700

    [PATCH] Add suspend method to cpufreq core
    
    In order to properly fix some issues with cpufreq vs. sleep on
    PowerBooks, I had to add a suspend callback to the pmac_cpufreq driver.
    I must force a switch to full speed before sleep and I switch back to
    previous speed on resume.
    
    I also added a driver flag to disable the warnings in suspend/resume
    since it is expected in this case to have different speed (and I want it
    to fixup the jiffies properly).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 910eca35583d..f21af067d015 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -103,6 +103,7 @@ struct cpufreq_policy {
 #define CPUFREQ_PRECHANGE	(0)
 #define CPUFREQ_POSTCHANGE	(1)
 #define CPUFREQ_RESUMECHANGE	(8)
+#define CPUFREQ_SUSPENDCHANGE	(9)
 
 struct cpufreq_freqs {
 	unsigned int cpu;	/* cpu nr */
@@ -200,6 +201,7 @@ struct cpufreq_driver {
 
 	/* optional */
 	int	(*exit)		(struct cpufreq_policy *policy);
+	int	(*suspend)	(struct cpufreq_policy *policy, u32 state);
 	int	(*resume)	(struct cpufreq_policy *policy);
 	struct freq_attr	**attr;
 };
@@ -211,7 +213,8 @@ struct cpufreq_driver {
 #define CPUFREQ_CONST_LOOPS 	0x02	/* loops_per_jiffy or other kernel
 					 * "constants" aren't affected by
 					 * frequency transitions */
-
+#define CPUFREQ_PM_NO_WARN	0x04	/* don't warn on suspend/resume speed
+					 * mismatches */
 
 int cpufreq_register_driver(struct cpufreq_driver *driver_data);
 int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
new file mode 100644
index 000000000000..910eca35583d
--- /dev/null
+++ b/include/linux/cpufreq.h
@@ -0,0 +1,328 @@
+/*
+ *  linux/include/linux/cpufreq.h
+ *
+ *  Copyright (C) 2001 Russell King
+ *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
+ *            
+ *
+ * $Id: cpufreq.h,v 1.36 2003/01/20 17:31:48 db Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _LINUX_CPUFREQ_H
+#define _LINUX_CPUFREQ_H
+
+#include <linux/config.h>
+#include <linux/notifier.h>
+#include <linux/threads.h>
+#include <linux/device.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/cpumask.h>
+
+#define CPUFREQ_NAME_LEN 16
+
+
+/*********************************************************************
+ *                     CPUFREQ NOTIFIER INTERFACE                    *
+ *********************************************************************/
+
+int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
+
+#define CPUFREQ_TRANSITION_NOTIFIER	(0)
+#define CPUFREQ_POLICY_NOTIFIER		(1)
+
+
+/* if (cpufreq_driver->target) exists, the ->governor decides what frequency
+ * within the limits is used. If (cpufreq_driver->setpolicy> exists, these
+ * two generic policies are available:
+ */
+
+#define CPUFREQ_POLICY_POWERSAVE	(1)
+#define CPUFREQ_POLICY_PERFORMANCE	(2)
+
+/* Frequency values here are CPU kHz so that hardware which doesn't run 
+ * with some frequencies can complain without having to guess what per 
+ * cent / per mille means. 
+ * Maximum transition latency is in microseconds - if it's unknown,
+ * CPUFREQ_ETERNAL shall be used.
+ */
+
+struct cpufreq_governor;
+
+#define CPUFREQ_ETERNAL			(-1)
+struct cpufreq_cpuinfo {
+	unsigned int		max_freq;
+	unsigned int		min_freq;
+	unsigned int		transition_latency; /* in 10^(-9) s = nanoseconds */
+};
+
+struct cpufreq_real_policy {
+	unsigned int		min;    /* in kHz */
+	unsigned int		max;    /* in kHz */
+        unsigned int		policy; /* see above */
+	struct cpufreq_governor	*governor; /* see below */
+};
+
+struct cpufreq_policy {
+	cpumask_t		cpus;	/* affected CPUs */
+	unsigned int		cpu;    /* cpu nr of registered CPU */
+	struct cpufreq_cpuinfo	cpuinfo;/* see above */
+
+	unsigned int		min;    /* in kHz */
+	unsigned int		max;    /* in kHz */
+	unsigned int		cur;    /* in kHz, only needed if cpufreq
+					 * governors are used */
+        unsigned int		policy; /* see above */
+	struct cpufreq_governor	*governor; /* see below */
+
+ 	struct semaphore	lock;   /* CPU ->setpolicy or ->target may
+					   only be called once a time */
+
+	struct work_struct	update; /* if update_policy() needs to be
+					 * called, but you're in IRQ context */
+
+	struct cpufreq_real_policy	user_policy;
+
+	struct kobject		kobj;
+	struct completion	kobj_unregister;
+};
+
+#define CPUFREQ_ADJUST		(0)
+#define CPUFREQ_INCOMPATIBLE	(1)
+#define CPUFREQ_NOTIFY		(2)
+
+
+/******************** cpufreq transition notifiers *******************/
+
+#define CPUFREQ_PRECHANGE	(0)
+#define CPUFREQ_POSTCHANGE	(1)
+#define CPUFREQ_RESUMECHANGE	(8)
+
+struct cpufreq_freqs {
+	unsigned int cpu;	/* cpu nr */
+	unsigned int old;
+	unsigned int new;
+	u8 flags;		/* flags of cpufreq_driver, see below. */
+};
+
+
+/**
+ * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch safe)
+ * @old:   old value
+ * @div:   divisor
+ * @mult:  multiplier
+ *
+ *
+ *    new = old * mult / div
+ */
+static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mult)
+{
+#if BITS_PER_LONG == 32
+
+	u64 result = ((u64) old) * ((u64) mult);
+	do_div(result, div);
+	return (unsigned long) result;
+
+#elif BITS_PER_LONG == 64
+
+	unsigned long result = old * ((u64) mult);
+	result /= div;
+	return result;
+
+#endif
+};
+
+/*********************************************************************
+ *                          CPUFREQ GOVERNORS                        *
+ *********************************************************************/
+
+#define CPUFREQ_GOV_START  1
+#define CPUFREQ_GOV_STOP   2
+#define CPUFREQ_GOV_LIMITS 3
+
+struct cpufreq_governor {
+	char	name[CPUFREQ_NAME_LEN];
+	int 	(*governor)	(struct cpufreq_policy *policy,
+				 unsigned int event);
+	struct list_head	governor_list;
+	struct module		*owner;
+};
+
+/* pass a target to the cpufreq driver 
+ */
+extern int cpufreq_driver_target(struct cpufreq_policy *policy,
+				 unsigned int target_freq,
+				 unsigned int relation);
+extern int __cpufreq_driver_target(struct cpufreq_policy *policy,
+				   unsigned int target_freq,
+				   unsigned int relation);
+
+
+/* pass an event to the cpufreq governor */
+int cpufreq_governor(unsigned int cpu, unsigned int event);
+
+int cpufreq_register_governor(struct cpufreq_governor *governor);
+void cpufreq_unregister_governor(struct cpufreq_governor *governor);
+
+
+/*********************************************************************
+ *                      CPUFREQ DRIVER INTERFACE                     *
+ *********************************************************************/
+
+#define CPUFREQ_RELATION_L 0  /* lowest frequency at or above target */
+#define CPUFREQ_RELATION_H 1  /* highest frequency below or at target */
+
+struct freq_attr;
+
+struct cpufreq_driver {
+	struct module           *owner;
+	char			name[CPUFREQ_NAME_LEN];
+	u8			flags;
+
+	/* needed by all drivers */
+	int	(*init)		(struct cpufreq_policy *policy);
+	int	(*verify)	(struct cpufreq_policy *policy);
+
+	/* define one out of two */
+	int	(*setpolicy)	(struct cpufreq_policy *policy);
+	int	(*target)	(struct cpufreq_policy *policy,
+				 unsigned int target_freq,
+				 unsigned int relation);
+
+	/* should be defined, if possible */
+	unsigned int	(*get)	(unsigned int cpu);
+
+	/* optional */
+	int	(*exit)		(struct cpufreq_policy *policy);
+	int	(*resume)	(struct cpufreq_policy *policy);
+	struct freq_attr	**attr;
+};
+
+/* flags */
+
+#define CPUFREQ_STICKY		0x01	/* the driver isn't removed even if 
+					 * all ->init() calls failed */
+#define CPUFREQ_CONST_LOOPS 	0x02	/* loops_per_jiffy or other kernel
+					 * "constants" aren't affected by
+					 * frequency transitions */
+
+
+int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+
+
+void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
+
+
+static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max) 
+{
+	if (policy->min < min)
+		policy->min = min;
+	if (policy->max < min)
+		policy->max = min;
+	if (policy->min > max)
+		policy->min = max;
+	if (policy->max > max)
+		policy->max = max;
+	if (policy->min > policy->max)
+		policy->min = policy->max;
+	return;
+}
+
+struct freq_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct cpufreq_policy *, char *);
+	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
+};
+
+
+/*********************************************************************
+ *                        CPUFREQ 2.6. INTERFACE                     *
+ *********************************************************************/
+int cpufreq_set_policy(struct cpufreq_policy *policy);
+int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
+int cpufreq_update_policy(unsigned int cpu);
+
+/* query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it */
+unsigned int cpufreq_get(unsigned int cpu);
+
+
+/*********************************************************************
+ *                       CPUFREQ DEFAULT GOVERNOR                    *
+ *********************************************************************/
+
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
+extern struct cpufreq_governor cpufreq_gov_performance;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_performance
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
+extern struct cpufreq_governor cpufreq_gov_userspace;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_userspace
+#endif
+
+
+/*********************************************************************
+ *                     FREQUENCY TABLE HELPERS                       *
+ *********************************************************************/
+
+#define CPUFREQ_ENTRY_INVALID ~0
+#define CPUFREQ_TABLE_END     ~1
+
+struct cpufreq_frequency_table {
+	unsigned int	index;     /* any */
+	unsigned int	frequency; /* kHz - doesn't need to be in ascending
+				    * order */
+};
+
+int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
+				    struct cpufreq_frequency_table *table);
+
+int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
+				   struct cpufreq_frequency_table *table);
+
+int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
+				   struct cpufreq_frequency_table *table,
+				   unsigned int target_freq,
+				   unsigned int relation,
+				   unsigned int *index);
+
+/* the following 3 funtions are for cpufreq core use only */
+struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu);
+struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
+void   cpufreq_cpu_put (struct cpufreq_policy *data);
+
+/* the following are really really optional */
+extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
+
+void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table, 
+				      unsigned int cpu);
+
+void cpufreq_frequency_table_put_attr(unsigned int cpu);
+
+
+/*********************************************************************
+ *                     UNIFIED DEBUG HELPERS                         *
+ *********************************************************************/
+
+#define CPUFREQ_DEBUG_CORE	1
+#define CPUFREQ_DEBUG_DRIVER	2
+#define CPUFREQ_DEBUG_GOVERNOR	4
+
+#ifdef CONFIG_CPU_FREQ_DEBUG
+
+extern void cpufreq_debug_printk(unsigned int type, const char *prefix, 
+				 const char *fmt, ...);
+
+#else
+
+#define cpufreq_debug_printk(msg...) do { } while(0)
+
+#endif /* CONFIG_CPU_FREQ_DEBUG */
+
+#endif /* _LINUX_CPUFREQ_H */
