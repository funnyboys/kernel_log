commit 84eeb5d460e399795e9a92a0cd44999254886150
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:34 2020 +0300

    net: dsa: tag_sja1105: implement sub-VLAN decoding
    
    Create a subvlan_map as part of each port's tagger private structure.
    This keeps reverse mappings of bridge-to-dsa_8021q VLAN retagging rules.
    
    Note that as of this patch, this piece of code is never engaged, due to
    the fact that the driver hasn't installed any retagging rule, so we'll
    always see packets with a subvlan code of 0 (untagged).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index f821d08b1b5f..dd93735ae228 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -9,6 +9,7 @@
 
 #include <linux/skbuff.h>
 #include <linux/etherdevice.h>
+#include <linux/dsa/8021q.h>
 #include <net/dsa.h>
 
 #define ETH_P_SJA1105				ETH_P_DSA_8021Q
@@ -53,6 +54,7 @@ struct sja1105_skb_cb {
 	((struct sja1105_skb_cb *)DSA_SKB_CB_PRIV(skb))
 
 struct sja1105_port {
+	u16 subvlan_map[DSA_8021Q_N_SUBVLAN];
 	struct kthread_worker *xmit_worker;
 	struct kthread_work xmit_work;
 	struct sk_buff_head xmit_queue;

commit 38b5beeae7a4cde87edabb0196fac1f55ae668ee
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:32 2020 +0300

    net: dsa: sja1105: prepare tagger for handling DSA tags and VLAN simultaneously
    
    In VLAN-unaware mode, sja1105 uses VLAN tags with a custom TPID of
    0xdadb. While in the yet-to-be introduced best_effort_vlan_filtering
    mode, it needs to work with normal VLAN TPID values.
    
    A complication arises when we must transmit a VLAN-tagged packet to the
    switch when it's in VLAN-aware mode. We need to construct a packet with
    2 VLAN tags, and the switch will use the outer header for routing and
    pop it on egress. But sadly, here the 2 hardware generations don't
    behave the same:
    
    - E/T switches won't pop an ETH_P_8021AD tag on egress, it seems
      (packets will remain double-tagged).
    - P/Q/R/S switches will drop a packet with 2 ETH_P_8021Q tags (it looks
      like it tries to prevent VLAN hopping).
    
    But looks like the reverse is also true:
    
    - E/T switches have no problem popping the outer tag from packets with
      2 ETH_P_8021Q tags.
    - P/Q/R/S will have no problem popping a single tag even if that is
      ETH_P_8021AD.
    
    So it is clear that if we want the hardware to work with dsa_8021q
    tagging in VLAN-aware mode, we need to send different TPIDs depending on
    revision. Keep that information in priv->info->qinq_tpid.
    
    The per-port tagger structure will hold an xmit_tpid value that depends
    not only upon the qinq_tpid, but also upon the VLAN awareness state
    itself (in case we must transmit using 0xdadb).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index fa5735c353cd..f821d08b1b5f 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -59,6 +59,7 @@ struct sja1105_port {
 	struct sja1105_tagger_data *data;
 	struct dsa_port *dp;
 	bool hwts_tx_en;
+	u16 xmit_tpid;
 };
 
 #endif /* _NET_DSA_SJA1105_H */

commit a68578c20a9667463ee3000402b21644ea62d753
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jan 4 02:37:10 2020 +0200

    net: dsa: Make deferred_xmit private to sja1105
    
    There are 3 things that are wrong with the DSA deferred xmit mechanism:
    
    1. Its introduction has made the DSA hotpath ever so slightly more
       inefficient for everybody, since DSA_SKB_CB(skb)->deferred_xmit needs
       to be initialized to false for every transmitted frame, in order to
       figure out whether the driver requested deferral or not (a very rare
       occasion, rare even for the only driver that does use this mechanism:
       sja1105). That was necessary to avoid kfree_skb from freeing the skb.
    
    2. Because L2 PTP is a link-local protocol like STP, it requires
       management routes and deferred xmit with this switch. But as opposed
       to STP, the deferred work mechanism needs to schedule the packet
       rather quickly for the TX timstamp to be collected in time and sent
       to user space. But there is no provision for controlling the
       scheduling priority of this deferred xmit workqueue. Too bad this is
       a rather specific requirement for a feature that nobody else uses
       (more below).
    
    3. Perhaps most importantly, it makes the DSA core adhere a bit too
       much to the NXP company-wide policy "Innovate Where It Doesn't
       Matter". The sja1105 is probably the only DSA switch that requires
       some frames sent from the CPU to be routed to the slave port via an
       out-of-band configuration (register write) rather than in-band (DSA
       tag). And there are indeed very good reasons to not want to do that:
       if that out-of-band register is at the other end of a slow bus such
       as SPI, then you limit that Ethernet flow's throughput to effectively
       the throughput of the SPI bus. So hardware vendors should definitely
       not be encouraged to design this way. We do _not_ want more
       widespread use of this mechanism.
    
    Luckily we have a solution for each of the 3 issues:
    
    For 1, we can just remove that variable in the skb->cb and counteract
    the effect of kfree_skb with skb_get, much to the same effect. The
    advantage, of course, being that anybody who doesn't use deferred xmit
    doesn't need to do any extra operation in the hotpath.
    
    For 2, we can create a kernel thread for each port's deferred xmit work.
    If the user switch ports are named swp0, swp1, swp2, the kernel threads
    will be named swp0_xmit, swp1_xmit, swp2_xmit (there appears to be a 15
    character length limit on kernel thread names). With this, the user can
    change the scheduling priority with chrt $(pidof swp2_xmit).
    
    For 3, we can actually move the entire implementation to the sja1105
    driver.
    
    So this patch deletes the generic implementation from the DSA core and
    adds a new one, more adequate to the requirements of PTP TX
    timestamping, in sja1105_main.c.
    
    Suggested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 317e05b2584b..fa5735c353cd 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -53,6 +53,9 @@ struct sja1105_skb_cb {
 	((struct sja1105_skb_cb *)DSA_SKB_CB_PRIV(skb))
 
 struct sja1105_port {
+	struct kthread_worker *xmit_worker;
+	struct kthread_work xmit_work;
+	struct sk_buff_head xmit_queue;
 	struct sja1105_tagger_data *data;
 	struct dsa_port *dp;
 	bool hwts_tx_en;

commit 0a51826c6e05c5b6cc423b376b81c311e9e485b0
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jan 4 02:37:09 2020 +0200

    net: dsa: sja1105: Always send through management routes in slot 0
    
    I finally found out how the 4 management route slots are supposed to
    be used, but.. it's not worth it.
    
    The description from the comment I've just deleted in this commit is
    still true: when more than 1 management slot is active at the same time,
    the switch will match frames incoming [from the CPU port] on the lowest
    numbered management slot that matches the frame's DMAC.
    
    My issue was that one was not supposed to statically assign each port a
    slot. Yes, there are 4 slots and also 4 non-CPU ports, but that is a
    mere coincidence.
    
    Instead, the switch can be used like this: every management frame gets a
    slot at the right of the most recently assigned slot:
    
    Send mgmt frame 1 through S0:    S0 x  x  x
    Send mgmt frame 2 through S1:    S0 S1 x  x
    Send mgmt frame 3 through S2:    S0 S1 S2 x
    Send mgmt frame 4 through S3:    S0 S1 S2 S3
    
    The difference compared to the old usage is that the transmission of
    frames 1-4 doesn't need to wait until the completion of the management
    route. It is safe to use a slot to the right of the most recently used
    one, because by protocol nobody will program a slot to your left and
    "steal" your route towards the correct egress port.
    
    So there is a potential throughput benefit here.
    
    But mgmt frame 5 has no more free slot to use, so it has to wait until
    _all_ of S0, S1, S2, S3 are full, in order to use S0 again.
    
    And that's actually exactly the problem: I was looking for something
    that would bring more predictable transmission latency, but this is
    exactly the opposite: 3 out of 4 frames would be transmitted quicker,
    but the 4th would draw the short straw and have a worse worst-case
    latency than before.
    
    Useless.
    
    Things are made even worse by PTP TX timestamping, which is something I
    won't go deeply into here. Suffice to say that the fact there is a
    driver-level lock on the SPI bus offsets any potential throughput gains
    that parallelism might bring.
    
    So there's no going back to the multi-slot scheme, remove the
    "mgmt_slot" variable from sja1105_port and the dummy static assignment
    made at probe time.
    
    While passing by, also remove the assignment to casc_port altogether.
    Don't pretend that we support cascaded setups.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index c0b6a603ea8c..317e05b2584b 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -56,7 +56,6 @@ struct sja1105_port {
 	struct sja1105_tagger_data *data;
 	struct dsa_port *dp;
 	bool hwts_tx_en;
-	int mgmt_slot;
 };
 
 #endif /* _NET_DSA_SJA1105_H */

commit 1e762bd278d2a70bc74b9cbee7f1e93bd4704fe2
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Fri Dec 27 15:02:29 2019 +0200

    net: dsa: sja1105: Use PTP core's dedicated kernel thread for RX timestamping
    
    And move the queue of skb's waiting for RX timestamps into the ptp_data
    structure, since it isn't needed if PTP is not compiled.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 897e799dbcb9..c0b6a603ea8c 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -37,8 +37,6 @@
  * the structure defined in struct sja1105_private.
  */
 struct sja1105_tagger_data {
-	struct sk_buff_head skb_rxtstamp_queue;
-	struct work_struct rxtstamp_work;
 	struct sk_buff *stampable_skb;
 	/* Protects concurrent access to the meta state machine
 	 * from taggers running on multiple ports on SMP systems

commit 3e8db7e56082156a37b71d7334860c10fcea8025
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Oct 1 21:58:19 2019 +0300

    net: dsa: sja1105: Fix sleeping while atomic in .port_hwtstamp_set
    
    Currently this stack trace can be seen with CONFIG_DEBUG_ATOMIC_SLEEP=y:
    
    [   41.568348] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:909
    [   41.576757] in_atomic(): 1, irqs_disabled(): 0, pid: 208, name: ptp4l
    [   41.583212] INFO: lockdep is turned off.
    [   41.587123] CPU: 1 PID: 208 Comm: ptp4l Not tainted 5.3.0-rc6-01445-ge950f2d4bc7f-dirty #1827
    [   41.599873] [<c0313d7c>] (unwind_backtrace) from [<c030e13c>] (show_stack+0x10/0x14)
    [   41.607584] [<c030e13c>] (show_stack) from [<c1212d50>] (dump_stack+0xd4/0x100)
    [   41.614863] [<c1212d50>] (dump_stack) from [<c037dfc8>] (___might_sleep+0x1c8/0x2b4)
    [   41.622574] [<c037dfc8>] (___might_sleep) from [<c122ea90>] (__mutex_lock+0x48/0xab8)
    [   41.630368] [<c122ea90>] (__mutex_lock) from [<c122f51c>] (mutex_lock_nested+0x1c/0x24)
    [   41.638340] [<c122f51c>] (mutex_lock_nested) from [<c0c6fe08>] (sja1105_static_config_reload+0x30/0x27c)
    [   41.647779] [<c0c6fe08>] (sja1105_static_config_reload) from [<c0c7015c>] (sja1105_hwtstamp_set+0x108/0x1cc)
    [   41.657562] [<c0c7015c>] (sja1105_hwtstamp_set) from [<c0feb650>] (dev_ifsioc+0x18c/0x330)
    [   41.665788] [<c0feb650>] (dev_ifsioc) from [<c0febbd8>] (dev_ioctl+0x320/0x6e8)
    [   41.673064] [<c0febbd8>] (dev_ioctl) from [<c0f8b1f4>] (sock_ioctl+0x334/0x5e8)
    [   41.680340] [<c0f8b1f4>] (sock_ioctl) from [<c05404a8>] (do_vfs_ioctl+0xb0/0xa10)
    [   41.687789] [<c05404a8>] (do_vfs_ioctl) from [<c0540e3c>] (ksys_ioctl+0x34/0x58)
    [   41.695151] [<c0540e3c>] (ksys_ioctl) from [<c0301000>] (ret_fast_syscall+0x0/0x28)
    [   41.702768] Exception stack(0xe8495fa8 to 0xe8495ff0)
    [   41.707796] 5fa0:                   beff4a8c 00000001 00000011 000089b0 beff4a8c beff4a80
    [   41.715933] 5fc0: beff4a8c 00000001 0000000c 00000036 b6fa98c8 004e19c1 00000001 00000000
    [   41.724069] 5fe0: 004dcedc beff4a6c 004c0738 b6e7af4c
    [   41.729860] BUG: scheduling while atomic: ptp4l/208/0x00000002
    [   41.735682] INFO: lockdep is turned off.
    
    Enabling RX timestamping will logically disturb the fastpath (processing
    of meta frames). Replace bool hwts_rx_en with a bit that is checked
    atomically from the fastpath and temporarily unset from the sleepable
    context during a change of the RX timestamping process (a destructive
    operation anyways, requires switch reset).
    If found unset, the fastpath (net/dsa/tag_sja1105.c) will just drop any
    received meta frame and not take the meta_lock at all.
    
    Fixes: a602afd200f5 ("net: dsa: sja1105: Expose PTP timestamping ioctls to userspace")
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 79435cfc20eb..897e799dbcb9 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -31,6 +31,8 @@
 #define SJA1105_META_SMAC			0x222222222222ull
 #define SJA1105_META_DMAC			0x0180C200000Eull
 
+#define SJA1105_HWTS_RX_EN			0
+
 /* Global tagger data: each struct sja1105_port has a reference to
  * the structure defined in struct sja1105_private.
  */
@@ -42,7 +44,7 @@ struct sja1105_tagger_data {
 	 * from taggers running on multiple ports on SMP systems
 	 */
 	spinlock_t meta_lock;
-	bool hwts_rx_en;
+	unsigned long state;
 };
 
 struct sja1105_skb_cb {

commit f3097be21bf17ae8785eea009cbc424f16611d9a
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:42 2019 +0300

    net: dsa: sja1105: Add a state machine for RX timestamping
    
    Meta frame reception relies on the hardware keeping its promise that it
    will send no other traffic towards the CPU port between a link-local
    frame and a meta frame.  Otherwise there is no other way to associate
    the meta frame with the link-local frame it's holding a timestamp of.
    The receive function is made stateful, and buffers a timestampable frame
    until its meta frame arrives, then merges the two, drops the meta and
    releases the link-local frame up the stack.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 2c4fce4eaf0d..79435cfc20eb 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -45,6 +45,13 @@ struct sja1105_tagger_data {
 	bool hwts_rx_en;
 };
 
+struct sja1105_skb_cb {
+	u32 meta_tstamp;
+};
+
+#define SJA1105_SKB_CB(skb) \
+	((struct sja1105_skb_cb *)DSA_SKB_CB_PRIV(skb))
+
 struct sja1105_port {
 	struct sja1105_tagger_data *data;
 	struct dsa_port *dp;

commit 844d7edc6a34ae3a8236f1306e4f2615c8db1eac
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:40 2019 +0300

    net: dsa: sja1105: Add a global sja1105_tagger_data structure
    
    This will be used to keep state for RX timestamping. It is global
    because the switch serializes timestampable and meta frames when
    trapping them towards the CPU port (lower port indices have higher
    priority) and therefore having one state machine per port would create
    unnecessary complications.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index cc4a909d1007..2c4fce4eaf0d 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -31,7 +31,22 @@
 #define SJA1105_META_SMAC			0x222222222222ull
 #define SJA1105_META_DMAC			0x0180C200000Eull
 
+/* Global tagger data: each struct sja1105_port has a reference to
+ * the structure defined in struct sja1105_private.
+ */
+struct sja1105_tagger_data {
+	struct sk_buff_head skb_rxtstamp_queue;
+	struct work_struct rxtstamp_work;
+	struct sk_buff *stampable_skb;
+	/* Protects concurrent access to the meta state machine
+	 * from taggers running on multiple ports on SMP systems
+	 */
+	spinlock_t meta_lock;
+	bool hwts_rx_en;
+};
+
 struct sja1105_port {
+	struct sja1105_tagger_data *data;
 	struct dsa_port *dp;
 	bool hwts_tx_en;
 	int mgmt_slot;

commit d3f9b90bf19fad05889e4bead7dc1b336da56118
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:36 2019 +0300

    net: dsa: sja1105: Build a minimal understanding of meta frames
    
    Meta frames are sent on the CPU port by the switch if RX timestamping is
    enabled. They contain a partial timestamp of the previous frame.
    
    They are Ethernet frames with the Ethernet header constructed out of:
    
    - SJA1105_META_DMAC
    - SJA1105_META_SMAC
    - ETH_P_SJA1105_META
    
    The Ethernet payload will be decoded in a follow-up patch.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 5a956f335022..cc4a909d1007 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -12,6 +12,7 @@
 #include <net/dsa.h>
 
 #define ETH_P_SJA1105				ETH_P_DSA_8021Q
+#define ETH_P_SJA1105_META			0x0008
 
 /* IEEE 802.3 Annex 57A: Slow Protocols PDUs (01:80:C2:xx:xx:xx) */
 #define SJA1105_LINKLOCAL_FILTER_A		0x0180C2000000ull
@@ -20,6 +21,16 @@
 #define SJA1105_LINKLOCAL_FILTER_B		0x011B19000000ull
 #define SJA1105_LINKLOCAL_FILTER_B_MASK		0xFFFFFF000000ull
 
+/* Source and Destination MAC of follow-up meta frames.
+ * Whereas the choice of SMAC only affects the unique identification of the
+ * switch as sender of meta frames, the DMAC must be an address that is present
+ * in the DSA master port's multicast MAC filter.
+ * 01-80-C2-00-00-0E is a good choice for this, as all profiles of IEEE 1588
+ * over L2 use this address for some purpose already.
+ */
+#define SJA1105_META_SMAC			0x222222222222ull
+#define SJA1105_META_DMAC			0x0180C200000Eull
+
 struct sja1105_port {
 	struct dsa_port *dp;
 	bool hwts_tx_en;

commit 47ed985e97f513b7746270e8c5d1f3a3f959b2da
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:35 2019 +0300

    net: dsa: sja1105: Add logic for TX timestamping
    
    On TX, timestamping is performed synchronously from the
    port_deferred_xmit worker thread.
    In management routes, the switch is requested to take egress timestamps
    (again partial), which are reconstructed and appended to a clone of the
    skb that was just sent.  The cloning is done by DSA and we retrieve the
    pointer from the structure that DSA keeps in skb->cb.
    Then these clones are enqueued to the socket's error queue for
    application-level processing.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index e46e18c47d41..5a956f335022 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -22,6 +22,7 @@
 
 struct sja1105_port {
 	struct dsa_port *dp;
+	bool hwts_tx_en;
 	int mgmt_slot;
 };
 

commit e8d67fa5696e2fcaf956dae36d11e6eff5246101
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 30 00:51:26 2019 +0300

    net: dsa: sja1105: Don't store frame type in skb->cb
    
    Due to a confusion I thought that eth_type_trans() was called by the
    network stack whereas it can actually be called by network drivers to
    figure out the skb protocol and next packet_type handlers.
    
    In light of the above, it is not safe to store the frame type from the
    DSA tagger's .filter callback (first entry point on RX path), since GRO
    is yet to be invoked on the received traffic.  Hence it is very likely
    that the skb->cb will actually get overwritten between eth_type_trans()
    and the actual DSA packet_type handler.
    
    Of course, what this patch fixes is the actual overwriting of the
    SJA1105_SKB_CB(skb)->type field from the GRO layer, which made all
    frames be seen as SJA1105_FRAME_TYPE_NORMAL (0).
    
    Fixes: 227d07a07ef1 ("net: dsa: sja1105: Add support for traffic through standalone ports")
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 603a02e5a8cb..e46e18c47d41 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -20,18 +20,6 @@
 #define SJA1105_LINKLOCAL_FILTER_B		0x011B19000000ull
 #define SJA1105_LINKLOCAL_FILTER_B_MASK		0xFFFFFF000000ull
 
-enum sja1105_frame_type {
-	SJA1105_FRAME_TYPE_NORMAL = 0,
-	SJA1105_FRAME_TYPE_LINK_LOCAL,
-};
-
-struct sja1105_skb_cb {
-	enum sja1105_frame_type type;
-};
-
-#define SJA1105_SKB_CB(skb) \
-	((struct sja1105_skb_cb *)DSA_SKB_CB_PRIV(skb))
-
 struct sja1105_port {
 	struct dsa_port *dp;
 	int mgmt_slot;

commit 227d07a07ef126272ea2eed97fd136cd7a803d81
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun May 5 13:19:27 2019 +0300

    net: dsa: sja1105: Add support for traffic through standalone ports
    
    In order to support this, we are creating a make-shift switch tag out of
    a VLAN trunk configured on the CPU port. Termination of normal traffic
    on switch ports only works when not under a vlan_filtering bridge.
    Termination of management (PTP, BPDU) traffic works under all
    circumstances because it uses a different tagging mechanism
    (incl_srcpt). We are making use of the generic CONFIG_NET_DSA_TAG_8021Q
    code and leveraging it from our own CONFIG_NET_DSA_TAG_SJA1105.
    
    There are two types of traffic: regular and link-local.
    
    The link-local traffic received on the CPU port is trapped from the
    switch's regular forwarding decisions because it matched one of the two
    DMAC filters for management traffic.
    
    On transmission, the switch requires special massaging for these
    link-local frames. Due to a weird implementation of the switching IP, by
    default it drops link-local frames that originate on the CPU port.
    It needs to be told where to forward them to, through an SPI command
    ("management route") that is valid for only a single frame.
    So when we're sending link-local traffic, we are using the
    dsa_defer_xmit mechanism.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index abf3977e34fd..603a02e5a8cb 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -2,22 +2,39 @@
  * Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
  */
 
-/* Included by drivers/net/dsa/sja1105/sja1105.h */
+/* Included by drivers/net/dsa/sja1105/sja1105.h and net/dsa/tag_sja1105.c */
 
 #ifndef _NET_DSA_SJA1105_H
 #define _NET_DSA_SJA1105_H
 
+#include <linux/skbuff.h>
 #include <linux/etherdevice.h>
+#include <net/dsa.h>
 
 #define ETH_P_SJA1105				ETH_P_DSA_8021Q
 
-/* The switch can only be convinced to stay in unmanaged mode and not trap any
- * link-local traffic by actually telling it to filter frames sent at the
- * 00:00:00:00:00:00 destination MAC.
- */
-#define SJA1105_LINKLOCAL_FILTER_A		0x000000000000ull
-#define SJA1105_LINKLOCAL_FILTER_A_MASK		0xFFFFFFFFFFFFull
-#define SJA1105_LINKLOCAL_FILTER_B		0x000000000000ull
-#define SJA1105_LINKLOCAL_FILTER_B_MASK		0xFFFFFFFFFFFFull
+/* IEEE 802.3 Annex 57A: Slow Protocols PDUs (01:80:C2:xx:xx:xx) */
+#define SJA1105_LINKLOCAL_FILTER_A		0x0180C2000000ull
+#define SJA1105_LINKLOCAL_FILTER_A_MASK		0xFFFFFF000000ull
+/* IEEE 1588 Annex F: Transport of PTP over Ethernet (01:1B:19:xx:xx:xx) */
+#define SJA1105_LINKLOCAL_FILTER_B		0x011B19000000ull
+#define SJA1105_LINKLOCAL_FILTER_B_MASK		0xFFFFFF000000ull
+
+enum sja1105_frame_type {
+	SJA1105_FRAME_TYPE_NORMAL = 0,
+	SJA1105_FRAME_TYPE_LINK_LOCAL,
+};
+
+struct sja1105_skb_cb {
+	enum sja1105_frame_type type;
+};
+
+#define SJA1105_SKB_CB(skb) \
+	((struct sja1105_skb_cb *)DSA_SKB_CB_PRIV(skb))
+
+struct sja1105_port {
+	struct dsa_port *dp;
+	int mgmt_slot;
+};
 
 #endif /* _NET_DSA_SJA1105_H */

commit 6666cebc5e306f49a25bd20aa8c1cb8ef8950df5
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:34 2019 +0300

    net: dsa: sja1105: Add support for VLAN operations
    
    VLAN filtering cannot be properly disabled in SJA1105. So in order to
    emulate the "no VLAN awareness" behavior (not dropping traffic that is
    tagged with a VID that isn't configured on the port), we need to hack
    another switch feature: programmable TPID (which is 0x8100 for 802.1Q).
    We are reprogramming the TPID to a bogus value which leaves the switch
    thinking that all traffic is untagged, and therefore accepts it.
    
    Under a vlan_filtering bridge, the proper TPID of ETH_P_8021Q is
    installed again, and the switch starts identifying 802.1Q-tagged
    traffic.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index 30559d1d0e1b..abf3977e34fd 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -7,6 +7,10 @@
 #ifndef _NET_DSA_SJA1105_H
 #define _NET_DSA_SJA1105_H
 
+#include <linux/etherdevice.h>
+
+#define ETH_P_SJA1105				ETH_P_DSA_8021Q
+
 /* The switch can only be convinced to stay in unmanaged mode and not trap any
  * link-local traffic by actually telling it to filter frames sent at the
  * 00:00:00:00:00:00 destination MAC.

commit 8aa9ebccae87621d997707e4f25e53fddd7e30e4
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:30 2019 +0300

    net: dsa: Introduce driver for NXP SJA1105 5-port L2 switch
    
    At this moment the following is supported:
    * Link state management through phylib
    * Autonomous L2 forwarding managed through iproute2 bridge commands.
    
    IP termination must be done currently through the master netdevice,
    since the switch is unmanaged at this point and using
    DSA_TAG_PROTO_NONE.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: Georg Waibel <georg.waibel@sensor-technik.de>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
new file mode 100644
index 000000000000..30559d1d0e1b
--- /dev/null
+++ b/include/linux/dsa/sja1105.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
+ */
+
+/* Included by drivers/net/dsa/sja1105/sja1105.h */
+
+#ifndef _NET_DSA_SJA1105_H
+#define _NET_DSA_SJA1105_H
+
+/* The switch can only be convinced to stay in unmanaged mode and not trap any
+ * link-local traffic by actually telling it to filter frames sent at the
+ * 00:00:00:00:00:00 destination MAC.
+ */
+#define SJA1105_LINKLOCAL_FILTER_A		0x000000000000ull
+#define SJA1105_LINKLOCAL_FILTER_A_MASK		0xFFFFFFFFFFFFull
+#define SJA1105_LINKLOCAL_FILTER_B		0x000000000000ull
+#define SJA1105_LINKLOCAL_FILTER_B_MASK		0xFFFFFFFFFFFFull
+
+#endif /* _NET_DSA_SJA1105_H */
