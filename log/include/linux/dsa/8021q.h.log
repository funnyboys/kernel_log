commit 3eaae1d05f2b5be1be834bfad64f8fc2ad39a56d
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:33 2020 +0300

    net: dsa: tag_8021q: support up to 8 VLANs per port using sub-VLANs
    
    For switches that support VLAN retagging, such as sja1105, we extend
    dsa_8021q by encoding a "sub-VLAN" into the remaining 3 free bits in the
    dsa_8021q tag.
    
    A sub-VLAN is nothing more than a number in the range 0-7, which serves
    as an index into a per-port driver lookup table. The sub-VLAN value of
    zero means that traffic is untagged (this is also backwards-compatible
    with dsa_8021q without retagging).
    
    The switch should be configured to retag VLAN-tagged traffic that gets
    transmitted towards the CPU port (and towards the CPU only). Example:
    
    bridge vlan add dev sw1p0 vid 100
    
    The switch retags frames received on port 0, going to the CPU, and
    having VID 100, to the VID of 1104 (0x0450). In dsa_8021q language:
    
     | 11  | 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
     +-----------+-----+-----------------+-----------+-----------------------+
     |    DIR    | SVL |    SWITCH_ID    |  SUBVLAN  |          PORT         |
     +-----------+-----+-----------------+-----------+-----------------------+
    
    0x0450 means:
     - DIR = 0b01: this is an RX VLAN
     - SUBVLAN = 0b001: this is subvlan #1
     - SWITCH_ID = 0b001: this is switch 1 (see the name "sw1p0")
     - PORT = 0b0000: this is port 0 (see the name "sw1p0")
    
    The driver also remembers the "1 -> 100" mapping. In the hotpath, if the
    sub-VLAN from the tag encodes a non-untagged frame, this mapping is used
    to create a VLAN hwaccel tag, with the value of 100.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index 404bd2cce642..311aa04e7520 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -20,6 +20,8 @@ struct dsa_8021q_crosschip_link {
 	refcount_t refcount;
 };
 
+#define DSA_8021Q_N_SUBVLAN			8
+
 #if IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q)
 
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
@@ -42,10 +44,14 @@ u16 dsa_8021q_tx_vid(struct dsa_switch *ds, int port);
 
 u16 dsa_8021q_rx_vid(struct dsa_switch *ds, int port);
 
+u16 dsa_8021q_rx_vid_subvlan(struct dsa_switch *ds, int port, u16 subvlan);
+
 int dsa_8021q_rx_switch_id(u16 vid);
 
 int dsa_8021q_rx_source_port(u16 vid);
 
+u16 dsa_8021q_rx_subvlan(u16 vid);
+
 bool vid_is_dsa_8021q(u16 vid);
 
 #else
@@ -88,6 +94,11 @@ u16 dsa_8021q_rx_vid(struct dsa_switch *ds, int port)
 	return 0;
 }
 
+u16 dsa_8021q_rx_vid_subvlan(struct dsa_switch *ds, int port, u16 subvlan)
+{
+	return 0;
+}
+
 int dsa_8021q_rx_switch_id(u16 vid)
 {
 	return 0;
@@ -98,6 +109,11 @@ int dsa_8021q_rx_source_port(u16 vid)
 	return 0;
 }
 
+u16 dsa_8021q_rx_subvlan(u16 vid)
+{
+	return 0;
+}
+
 bool vid_is_dsa_8021q(u16 vid)
 {
 	return false;

commit ec5ae61076d07be986df19773662506220757c9f
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:29 2020 +0300

    net: dsa: sja1105: save/restore VLANs using a delta commit method
    
    Managing the VLAN table that is present in hardware will become very
    difficult once we add a third operating state
    (best_effort_vlan_filtering). That is because correct cleanup (not too
    little, not too much) becomes virtually impossible, when VLANs can be
    added from the bridge layer, from dsa_8021q for basic tagging, for
    cross-chip bridging, as well as retagging rules for sub-VLANs and
    cross-chip sub-VLANs. So we need to rethink VLAN interaction with the
    switch in a more scalable way.
    
    In preparation for that, use the priv->expect_dsa_8021q boolean to
    classify any VLAN request received through .port_vlan_add or
    .port_vlan_del towards either one of 2 internal lists: bridge VLANs and
    dsa_8021q VLANs.
    
    Then, implement a central sja1105_build_vlan_table method that creates a
    VLAN configuration from scratch based on the 2 lists of VLANs kept by
    the driver, and based on the VLAN awareness state. Currently, if we are
    VLAN-unaware, install the dsa_8021q VLANs, otherwise the bridge VLANs.
    
    Then, implement a delta commit procedure that identifies which VLANs
    from this new configuration are actually different from the config
    previously committed to hardware. We apply the delta through the dynamic
    configuration interface (we don't reset the switch). The result is that
    the hardware should see the exact sequence of operations as before this
    patch.
    
    This also helps remove the "br" argument passed to
    dsa_8021q_crosschip_bridge_join, which it was only using to figure out
    whether it should commit the configuration back to us or not, based on
    the VLAN awareness state of the bridge. We can simplify that, by always
    allowing those VLANs inside of our dsa_8021q_vlans list, and committing
    those to hardware when necessary.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index ebc245ff838a..404bd2cce642 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -25,18 +25,14 @@ struct dsa_8021q_crosschip_link {
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
 				 bool enabled);
 
-int dsa_8021q_crosschip_link_apply(struct dsa_switch *ds, int port,
-				   struct dsa_switch *other_ds,
-				   int other_port, bool enabled);
-
 int dsa_8021q_crosschip_bridge_join(struct dsa_switch *ds, int port,
 				    struct dsa_switch *other_ds,
-				    int other_port, struct net_device *br,
+				    int other_port,
 				    struct list_head *crosschip_links);
 
 int dsa_8021q_crosschip_bridge_leave(struct dsa_switch *ds, int port,
 				     struct dsa_switch *other_ds,
-				     int other_port, struct net_device *br,
+				     int other_port,
 				     struct list_head *crosschip_links);
 
 struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
@@ -60,16 +56,9 @@ int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
 	return 0;
 }
 
-int dsa_8021q_crosschip_link_apply(struct dsa_switch *ds, int port,
-				   struct dsa_switch *other_ds,
-				   int other_port, bool enabled)
-{
-	return 0;
-}
-
 int dsa_8021q_crosschip_bridge_join(struct dsa_switch *ds, int port,
 				    struct dsa_switch *other_ds,
-				    int other_port, struct net_device *br,
+				    int other_port,
 				    struct list_head *crosschip_links)
 {
 	return 0;
@@ -77,7 +66,7 @@ int dsa_8021q_crosschip_bridge_join(struct dsa_switch *ds, int port,
 
 int dsa_8021q_crosschip_bridge_leave(struct dsa_switch *ds, int port,
 				     struct dsa_switch *other_ds,
-				     int other_port, struct net_device *br,
+				     int other_port,
 				     struct list_head *crosschip_links)
 {
 	return 0;

commit 1f66b0f0aec671f8fbc86d75b2efdf7c7e0f7880
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:26 2020 +0300

    net: dsa: tag_8021q: introduce a vid_is_dsa_8021q helper
    
    This function returns a boolean denoting whether the VLAN passed as
    argument is part of the 1024-3071 range that the dsa_8021q tagging
    scheme uses.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index b8daaec0896e..ebc245ff838a 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -50,6 +50,8 @@ int dsa_8021q_rx_switch_id(u16 vid);
 
 int dsa_8021q_rx_source_port(u16 vid);
 
+bool vid_is_dsa_8021q(u16 vid);
+
 #else
 
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
@@ -107,6 +109,11 @@ int dsa_8021q_rx_source_port(u16 vid)
 	return 0;
 }
 
+bool vid_is_dsa_8021q(u16 vid)
+{
+	return false;
+}
+
 #endif /* IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q) */
 
 #endif /* _NET_DSA_8021Q_H */

commit ac02a451a6148bb9c395b39783ce7299eddf4f31
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun May 10 19:37:43 2020 +0300

    net: dsa: sja1105: implement cross-chip bridging operations
    
    sja1105 uses dsa_8021q for DSA tagging, a format which is VLAN at heart
    and which is compatible with cascading. A complete description of this
    tagging format is in net/dsa/tag_8021q.c, but a quick summary is that
    each external-facing port tags incoming frames with a unique pvid, and
    this special VLAN is transmitted as tagged towards the inside of the
    system, and as untagged towards the exterior. The tag encodes the switch
    id and the source port index.
    
    This means that cross-chip bridging for dsa_8021q only entails adding
    the dsa_8021q pvids of one switch to the RX filter of the other
    switches. Everything else falls naturally into place, as long as the
    bottom-end of ports (the leaves in the tree) is comprised exclusively of
    dsa_8021q-compatible (i.e. sja1105 switches). Otherwise, there would be
    a chance that a front-panel switch transmits a packet tagged with a
    dsa_8021q header, header which it wouldn't be able to remove, and which
    would hence "leak" out.
    
    The only use case I tested (due to lack of board availability) was when
    the sja1105 switches are part of disjoint trees (however, this doesn't
    change the fact that multiple sja1105 switches still need unique switch
    identifiers in such a system). But in principle, even "true" single-tree
    setups (with DSA links) should work just as fine, except for a small
    change which I can't test: dsa_towards_port should be used instead of
    dsa_upstream_port (I made the assumption that the routing port that any
    sja1105 should use towards its neighbours is the CPU port. That might
    not hold true in other setups).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index c620d9139c28..b8daaec0896e 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -12,11 +12,33 @@ struct sk_buff;
 struct net_device;
 struct packet_type;
 
+struct dsa_8021q_crosschip_link {
+	struct list_head list;
+	int port;
+	struct dsa_switch *other_ds;
+	int other_port;
+	refcount_t refcount;
+};
+
 #if IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q)
 
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
 				 bool enabled);
 
+int dsa_8021q_crosschip_link_apply(struct dsa_switch *ds, int port,
+				   struct dsa_switch *other_ds,
+				   int other_port, bool enabled);
+
+int dsa_8021q_crosschip_bridge_join(struct dsa_switch *ds, int port,
+				    struct dsa_switch *other_ds,
+				    int other_port, struct net_device *br,
+				    struct list_head *crosschip_links);
+
+int dsa_8021q_crosschip_bridge_leave(struct dsa_switch *ds, int port,
+				     struct dsa_switch *other_ds,
+				     int other_port, struct net_device *br,
+				     struct list_head *crosschip_links);
+
 struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
 			       u16 tpid, u16 tci);
 
@@ -36,6 +58,29 @@ int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
 	return 0;
 }
 
+int dsa_8021q_crosschip_link_apply(struct dsa_switch *ds, int port,
+				   struct dsa_switch *other_ds,
+				   int other_port, bool enabled)
+{
+	return 0;
+}
+
+int dsa_8021q_crosschip_bridge_join(struct dsa_switch *ds, int port,
+				    struct dsa_switch *other_ds,
+				    int other_port, struct net_device *br,
+				    struct list_head *crosschip_links)
+{
+	return 0;
+}
+
+int dsa_8021q_crosschip_bridge_leave(struct dsa_switch *ds, int port,
+				     struct dsa_switch *other_ds,
+				     int other_port, struct net_device *br,
+				     struct list_head *crosschip_links)
+{
+	return 0;
+}
+
 struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
 			       u16 tpid, u16 tci)
 {

commit e80f40cbe4dd51371818e967d40da8fe305db5e4
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue Mar 24 11:45:34 2020 +0200

    net: dsa: tag_8021q: replace dsa_8021q_remove_header with __skb_vlan_pop
    
    Not only did this wheel did not need reinventing, but there is also
    an issue with it: It doesn't remove the VLAN header in a way that
    preserves the L2 payload checksum when that is being provided by the DSA
    master hw.  It should recalculate checksum both for the push, before
    removing the header, and for the pull afterwards. But the current
    implementation is quite dizzying, with pulls followed immediately
    afterwards by pushes, the memmove is done before the push, etc.  This
    makes a DSA master with RX checksumming offload to print stack traces
    with the infamous 'hw csum failure' message.
    
    So remove the dsa_8021q_remove_header function and replace it with
    something that actually works with inet checksumming.
    
    Fixes: d461933638ae ("net: dsa: tag_8021q: Create helper function for removing VLAN header")
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index 0aa803c451a3..c620d9139c28 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -28,8 +28,6 @@ int dsa_8021q_rx_switch_id(u16 vid);
 
 int dsa_8021q_rx_source_port(u16 vid);
 
-struct sk_buff *dsa_8021q_remove_header(struct sk_buff *skb);
-
 #else
 
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
@@ -64,11 +62,6 @@ int dsa_8021q_rx_source_port(u16 vid)
 	return 0;
 }
 
-struct sk_buff *dsa_8021q_remove_header(struct sk_buff *skb)
-{
-	return NULL;
-}
-
 #endif /* IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q) */
 
 #endif /* _NET_DSA_8021Q_H */

commit d461933638ae9fa49ad22f60a40de5b3ed414912
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:29 2019 +0300

    net: dsa: tag_8021q: Create helper function for removing VLAN header
    
    This removes the existing implementation from tag_sja1105, which was
    partially incorrect (it was not changing the MAC header offset, thereby
    leaving it to point 4 bytes earlier than it should have).
    
    This overwrites the VLAN tag by moving the Ethernet source and
    destination MACs 4 bytes to the right. Then skb->data (assumed to be
    pointing immediately after the EtherType) is temporarily pushed to the
    beginning of the new Ethernet header, the new Ethernet header offset and
    length are recorded, then skb->data is moved back to where it was.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
index 3911e0586478..0aa803c451a3 100644
--- a/include/linux/dsa/8021q.h
+++ b/include/linux/dsa/8021q.h
@@ -20,9 +20,6 @@ int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
 struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
 			       u16 tpid, u16 tci);
 
-struct sk_buff *dsa_8021q_rcv(struct sk_buff *skb, struct net_device *netdev,
-			      struct packet_type *pt, u16 *tpid, u16 *tci);
-
 u16 dsa_8021q_tx_vid(struct dsa_switch *ds, int port);
 
 u16 dsa_8021q_rx_vid(struct dsa_switch *ds, int port);
@@ -31,6 +28,8 @@ int dsa_8021q_rx_switch_id(u16 vid);
 
 int dsa_8021q_rx_source_port(u16 vid);
 
+struct sk_buff *dsa_8021q_remove_header(struct sk_buff *skb);
+
 #else
 
 int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
@@ -45,12 +44,6 @@ struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
 	return NULL;
 }
 
-struct sk_buff *dsa_8021q_rcv(struct sk_buff *skb, struct net_device *netdev,
-			      struct packet_type *pt, u16 *tpid, u16 *tci)
-{
-	return NULL;
-}
-
 u16 dsa_8021q_tx_vid(struct dsa_switch *ds, int port)
 {
 	return 0;
@@ -71,6 +64,11 @@ int dsa_8021q_rx_source_port(u16 vid)
 	return 0;
 }
 
+struct sk_buff *dsa_8021q_remove_header(struct sk_buff *skb)
+{
+	return NULL;
+}
+
 #endif /* IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q) */
 
 #endif /* _NET_DSA_8021Q_H */

commit f9bbe4477c30ece44296437ee26142b42ef8070b
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun May 5 13:19:22 2019 +0300

    net: dsa: Optional VLAN-based port separation for switches without tagging
    
    This patch provides generic DSA code for using VLAN (802.1Q) tags for
    the same purpose as a dedicated switch tag for injection/extraction.
    It is based on the discussions and interest that has been so far
    expressed in https://www.spinics.net/lists/netdev/msg556125.html.
    
    Unlike all other DSA-supported tagging protocols, CONFIG_NET_DSA_TAG_8021Q
    does not offer a complete solution for drivers (nor can it). Instead, it
    provides generic code that driver can opt into calling:
    - dsa_8021q_xmit: Inserts a VLAN header with the specified contents.
      Can be called from another tagging protocol's xmit function.
      Currently the LAN9303 driver is inserting headers that are simply
      802.1Q with custom fields, so this is an opportunity for code reuse.
    - dsa_8021q_rcv: Retrieves the TPID and TCI from a VLAN-tagged skb.
      Removing the VLAN header is left as a decision for the caller to make.
    - dsa_port_setup_8021q_tagging: For each user port, installs an Rx VID
      and a Tx VID, for proper untagged traffic identification on ingress
      and steering on egress. Also sets up the VLAN trunk on the upstream
      (CPU or DSA) port. Drivers are intentionally left to call this
      function explicitly, depending on the context and hardware support.
      The expected switch behavior and VLAN semantics should not be violated
      under any conditions. That is, after calling
      dsa_port_setup_8021q_tagging, the hardware should still pass all
      ingress traffic, be it tagged or untagged.
    
    For uniformity with the other tagging protocols, a module for the
    dsa_8021q_netdev_ops structure is registered, but the typical usage is
    to set up another tagging protocol which selects CONFIG_NET_DSA_TAG_8021Q,
    and calls the API from tag_8021q.h. Null function definitions are also
    provided so that a "depends on" is not forced in the Kconfig.
    
    This tagging protocol only works when switch ports are standalone, or
    when they are added to a VLAN-unaware bridge. It will probably remain
    this way for the reasons below.
    
    When added to a bridge that has vlan_filtering 1, the bridge core will
    install its own VLANs and reset the pvids through switchdev. For the
    bridge core, switchdev is a write-only pipe. All VLAN-related state is
    kept in the bridge core and nothing is read from DSA/switchdev or from
    the driver. So the bridge core will break this port separation because
    it will install the vlan_default_pvid into all switchdev ports.
    
    Even if we could teach the bridge driver about switchdev preference of a
    certain vlan_default_pvid (task difficult in itself since the current
    setting is per-bridge but we would need it per-port), there would still
    exist many other challenges.
    
    Firstly, in the DSA rcv callback, a driver would have to perform an
    iterative reverse lookup to find the correct switch port. That is
    because the port is a bridge slave, so its Rx VID (port PVID) is subject
    to user configuration. How would we ensure that the user doesn't reset
    the pvid to a different value (which would make an O(1) translation
    impossible), or to a non-unique value within this DSA switch tree (which
    would make any translation impossible)?
    
    Finally, not all switch ports are equal in DSA, and that makes it
    difficult for the bridge to be completely aware of this anyway.
    The CPU port needs to transmit tagged packets (VLAN trunk) in order for
    the DSA rcv code to be able to decode source information.
    But the bridge code has absolutely no idea which switch port is the CPU
    port, if nothing else then just because there is no netdevice registered
    by DSA for the CPU port.
    Also DSA does not currently allow the user to specify that they want the
    CPU port to do VLAN trunking anyway. VLANs are added to the CPU port
    using the same flags as they were added on the user port.
    
    So the VLANs installed by dsa_port_setup_8021q_tagging per driver
    request should remain private from the bridge's and user's perspective,
    and should not alter the VLAN semantics observed by the user.
    
    In the current implementation a VLAN range ending at 4095 (VLAN_N_VID)
    is reserved for this purpose. Each port receives a unique Rx VLAN and a
    unique Tx VLAN. Separate VLANs are needed for Rx and Tx because they
    serve different purposes: on Rx the switch must process traffic as
    untagged and process it with a port-based VLAN, but with care not to
    hinder bridging. On the other hand, the Tx VLAN is where the
    reachability restrictions are imposed, since by tagging frames in the
    xmit callback we are telling the switch onto which port to steer the
    frame.
    
    Some general guidance on how this support might be employed for
    real-life hardware (some comments made by Florian Fainelli):
    
    - If the hardware supports VLAN tag stacking, it should somehow back
      up its private VLAN settings when the bridge tries to override them.
      Then the driver could re-apply them as outer tags. Dedicating an outer
      tag per bridge device would allow identical inner tag VID numbers to
      co-exist, yet preserve broadcast domain isolation.
    
    - If the switch cannot handle VLAN tag stacking, it should disable this
      port separation when added as slave to a vlan_filtering bridge, in
      that case having reduced functionality.
    
    - Drivers for old switches that don't support the entire VLAN_N_VID
      range will need to rework the current range selection mechanism.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dsa/8021q.h b/include/linux/dsa/8021q.h
new file mode 100644
index 000000000000..3911e0586478
--- /dev/null
+++ b/include/linux/dsa/8021q.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Copyright (c) 2019, Vladimir Oltean <olteanv@gmail.com>
+ */
+
+#ifndef _NET_DSA_8021Q_H
+#define _NET_DSA_8021Q_H
+
+#include <linux/types.h>
+
+struct dsa_switch;
+struct sk_buff;
+struct net_device;
+struct packet_type;
+
+#if IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q)
+
+int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
+				 bool enabled);
+
+struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
+			       u16 tpid, u16 tci);
+
+struct sk_buff *dsa_8021q_rcv(struct sk_buff *skb, struct net_device *netdev,
+			      struct packet_type *pt, u16 *tpid, u16 *tci);
+
+u16 dsa_8021q_tx_vid(struct dsa_switch *ds, int port);
+
+u16 dsa_8021q_rx_vid(struct dsa_switch *ds, int port);
+
+int dsa_8021q_rx_switch_id(u16 vid);
+
+int dsa_8021q_rx_source_port(u16 vid);
+
+#else
+
+int dsa_port_setup_8021q_tagging(struct dsa_switch *ds, int index,
+				 bool enabled)
+{
+	return 0;
+}
+
+struct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,
+			       u16 tpid, u16 tci)
+{
+	return NULL;
+}
+
+struct sk_buff *dsa_8021q_rcv(struct sk_buff *skb, struct net_device *netdev,
+			      struct packet_type *pt, u16 *tpid, u16 *tci)
+{
+	return NULL;
+}
+
+u16 dsa_8021q_tx_vid(struct dsa_switch *ds, int port)
+{
+	return 0;
+}
+
+u16 dsa_8021q_rx_vid(struct dsa_switch *ds, int port)
+{
+	return 0;
+}
+
+int dsa_8021q_rx_switch_id(u16 vid)
+{
+	return 0;
+}
+
+int dsa_8021q_rx_source_port(u16 vid)
+{
+	return 0;
+}
+
+#endif /* IS_ENABLED(CONFIG_NET_DSA_TAG_8021Q) */
+
+#endif /* _NET_DSA_8021Q_H */
