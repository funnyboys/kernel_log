commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index d4b7683c722d..aec8f30ab200 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_FIREWIRE_H
 #define _LINUX_FIREWIRE_H
 

commit 9b1ee0b2cb8bffdbb3003b1d5205f3ae0592c15a
Author: Takashi Sakamoto <o-takashi@sakamocchi.jp>
Date:   Fri Apr 25 22:45:30 2014 +0900

    ALSA: firewire/bebob: Add a workaround for M-Audio special Firewire series
    
    In post commit, a quirk of this firmware about transactions is reported.
    This commit apply a workaround for this quirk.
    
    They often fail transactions due to gap_count mismatch. This state is changed
    by generating bus reset.
    
    The fw_schedule_bus_reset() is an exported symbol in firewire-core. But there
    are no header for public. This commit moves its prototype from
    drivers/firewire/core.h to include/linux/firewire.h.
    
    This mismatch still affects bus management before generating this bus reset.
    It still takes a time to call driver's probe() because transactions are still
    often failed.
    
    Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index c3683bdf28fe..d4b7683c722d 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -367,6 +367,9 @@ static inline int fw_stream_packet_destination_id(int tag, int channel, int sy)
 	return tag << 14 | channel << 8 | sy;
 }
 
+void fw_schedule_bus_reset(struct fw_card *card, bool delayed,
+			   bool short_reset);
+
 struct fw_descriptor {
 	struct list_head link;
 	size_t length;

commit 70044d71d31d6973665ced5be04ef39ac1c09a48
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Mar 7 10:19:57 2014 -0500

    firewire: don't use PREPARE_DELAYED_WORK
    
    PREPARE_[DELAYED_]WORK() are being phased out.  They have few users
    and a nasty surprise in terms of reentrancy guarantee as workqueue
    considers work items to be different if they don't have the same work
    function.
    
    firewire core-device and sbp2 have been been multiplexing work items
    with multiple work functions.  Introduce fw_device_workfn() and
    sbp2_lu_workfn() which invoke fw_device->workfn and
    sbp2_logical_unit->workfn respectively and always use the two
    functions as the work functions and update the users to set the
    ->workfn fields instead of overriding work functions using
    PREPARE_DELAYED_WORK().
    
    This fixes a variety of possible regressions since a2c1c57be8d9
    "workqueue: consider work function when searching for busy work items"
    due to which fw_workqueue lost its required non-reentrancy property.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: stable@vger.kernel.org # v3.9+
    Cc: stable@vger.kernel.org # v3.8.2+
    Cc: stable@vger.kernel.org # v3.4.60+
    Cc: stable@vger.kernel.org # v3.2.40+

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5d7782e42b8f..c3683bdf28fe 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -200,6 +200,7 @@ struct fw_device {
 	unsigned irmc:1;
 	unsigned bc_implemented:2;
 
+	work_func_t workfn;
 	struct delayed_work work;
 	struct fw_attribute_group attribute_group;
 };

commit 0699a73af3811b66b1ab5650575acee5eea841ab
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Jul 22 21:32:09 2013 +0200

    firewire: fix libdc1394/FlyCap2 iso event regression
    
    Commit 18d627113b83 (firewire: prevent dropping of completed iso packet
    header data) was intended to be an obvious bug fix, but libdc1394 and
    FlyCap2 depend on the old behaviour by ignoring all returned information
    and thus not noticing that not all packets have been received yet.  The
    result was that the video frame buffers would be saved before they
    contained the correct data.
    
    Reintroduce the old behaviour for old clients.
    
    Tested-by: Stepan Salenikovich <stepan.salenikovich@gmail.com>
    Tested-by: Josep Bosch <jep250@gmail.com>
    Cc: <stable@vger.kernel.org> # 3.4+
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 3b0e820375ab..5d7782e42b8f 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -436,6 +436,7 @@ struct fw_iso_context {
 	int type;
 	int channel;
 	int speed;
+	bool drop_overflow_headers;
 	size_t header_size;
 	union {
 		fw_iso_callback_t sc;

commit 94a87157cde95d38b9cdf1116e4f0fd93f6d25df
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 9 18:15:00 2013 +0200

    firewire: introduce fw_driver.probe and .remove methods
    
    FireWire upper layer drivers are converted from generic
        struct driver.probe() and .remove()
    to bus-specific
        struct fw_driver.probe() and .remove().
    
    The new .probe() adds a const struct ieee1394_device_id *id argument,
    indicating the entry in the driver's device identifiers table which
    matched the fw_unit to be probed.  This new argument is used by the
    snd-firewire-speakers driver to look up device-specific parameters and
    methods.  There is at least one other FireWire audio driver currently in
    development in which this will be useful too.
    
    The new .remove() drops the unused error return code.
    
    Although all in-tree drivers are being converted to the new methods,
    support for the old methods is left in place in this commit.  This
    allows public developer trees to merge this commit and then move to the
    new fw_driver methods.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de> (for sound/firewire/)
    Cc: Peter Hurley <peter@hurleysoftware.com> (for drivers/staging/fwserial/)

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 191501afd7fb..3b0e820375ab 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -251,8 +251,10 @@ struct ieee1394_device_id;
 
 struct fw_driver {
 	struct device_driver driver;
+	int (*probe)(struct fw_unit *unit, const struct ieee1394_device_id *id);
 	/* Called when the parent device sits through a bus reset. */
 	void (*update)(struct fw_unit *unit);
+	void (*remove)(struct fw_unit *unit);
 	const struct ieee1394_device_id *id_table;
 };
 

commit 4d50c44381c981c9caa74e82ab894d4938dac9ca
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Sep 27 21:46:09 2012 +0200

    firewire: addendum to address handler RCU conversion
    
    Follow up on commit c285f6ff6787 "firewire: remove global lock around
    address handlers, convert to RCU":
    
      - address_handler_lock no longer serializes the address handler, only
        its function to serialize updates to the list of handlers remains.
        Rename the lock to address_handler_list_lock.
    
      - Callers of fw_core_remove_address_handler() must be able to sleep.
        Comment on this in the API documentation.
    
      - The counterpart fw_core_add_address_handler() is by nature something
        which is used in process context.  Replace spin_lock_bh() by
        spin_lock() in fw_core_add_address_handler() and in
        fw_core_remove_address_handler(), and document that process context
        is now required for fw_core_add_address_handler().
    
      - Extend the documentation of fw_address_callback_t.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index db04ec5121cb..191501afd7fb 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -265,8 +265,16 @@ typedef void (*fw_transaction_callback_t)(struct fw_card *card, int rcode,
 					  void *data, size_t length,
 					  void *callback_data);
 /*
- * Important note:  Except for the FCP registers, the callback must guarantee
- * that either fw_send_response() or kfree() is called on the @request.
+ * This callback handles an inbound request subaction.  It is called in
+ * RCU read-side context, therefore must not sleep.
+ *
+ * The callback should not initiate outbound request subactions directly.
+ * Otherwise there is a danger of recursion of inbound and outbound
+ * transactions from and to the local node.
+ *
+ * The callback is responsible that either fw_send_response() or kfree()
+ * is called on the @request, except for FCP registers for which the core
+ * takes care of that.
  */
 typedef void (*fw_address_callback_t)(struct fw_card *card,
 				      struct fw_request *request,

commit 148b729b9f51a78c1a024369bdcdc592f01103d4
Merge: 9ec97169e7d6 e3cbd92002a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 30 09:32:39 2012 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull firewire updates from Stefan Richter:
    
     - Small fixes and optimizations.
    
     - A new sysfs attribute to tell local and remote nodes apart.
       Useful to set special permissions/ ownership of local nodes'
       /dev/fw*, to start daemons on them (for diagnostics, management,
       AV targets, VersaPHY initiator or targets...), to pick up their
       GUID to use it as GUID of an SBP2 target instance, and of course
       for informational purposes.
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394:
      firewire: core: document is_local sysfs attribute
      firewire: core: add is_local sysfs device attribute
      firewire: ohci: initialize multiChanMode bits after reset
      firewire: core: fix multichannel IR with buffers larger than 2 GB
      firewire: ohci: sanity-check MMIO resource
      firewire: ohci: lazy bus time initialization
      firewire: core: allocate the low memory region
      firewire: core: make address handler length 64 bits

commit baedee177e6c553af455865718971d9a9c75e537
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Jun 17 16:40:36 2012 +0200

    firewire: core: add is_local sysfs device attribute
    
    Making this information available in sysfs allows to differentiate
    between controllers in the local and remote Linux PCs, and thus is
    useful for servers that are started with udev rules.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index d77f60c6d1ed..cb2445e2e10e 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -138,7 +138,7 @@ struct fw_card {
 struct fw_attribute_group {
 	struct attribute_group *groups[2];
 	struct attribute_group group;
-	struct attribute *attrs[12];
+	struct attribute *attrs[13];
 };
 
 enum fw_device_state {

commit 188726ecb66f022e92ec110ca85c62a937184636
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu May 24 19:28:17 2012 +0200

    firewire: core: make address handler length 64 bits
    
    The type of the length field of the fw_address_handler structure was
    size_t, which restricted it to 32 bits on 32-bit architectures.
    
    While making it u32 would match the userspace API, all calculations on
    this field use 64 bits anyway, and the ability to use 4 GB or larger
    address ranges is useful in the kernel.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 584826ba2eb7..d77f60c6d1ed 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -307,7 +307,7 @@ struct fw_transaction {
 
 struct fw_address_handler {
 	u64 offset;
-	size_t length;
+	u64 length;
 	fw_address_callback_t address_callback;
 	void *callback_data;
 	struct list_head link;

commit 2f78d8e249973f1eeb88315e6444e616c60177ae
Merge: f2fde3a65e88 26c72e22c94f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 24 12:57:47 2012 -0700

    Merge tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394
    
    Pull IEEE 1394 (FireWire) subsystem updates from Stefan Richter:
    
     - Fix mismatch between DMA mapping direction (was wrong) and DMA
       synchronization direction (was correct) of isochronous reception
       buffers of userspace drivers if vma-mapped for R/W access.  For
       example, libdc1394 was affected.
    
     - more consistent retry stategy in device discovery/ rediscovery, and
       improved failure diagnostics
    
     - various small cleanups, e.g. use SCSI layer's DMA mapping API in
       firewire-sbp2
    
    * tag 'firewire-updates' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394:
      firewire: sbp2: document the absence of alignment requirements
      firewire: sbp2: remove superfluous blk_queue_max_segment_size() call
      firewire: sbp2: use scsi_dma_(un)map
      firewire: sbp2: give correct DMA device to scsi framework
      firewire: core: fw_device_refresh(): clean up error handling
      firewire: core: log config rom reading errors
      firewire: core: log error in case of failed bus manager lock
      firewire: move rcode_string() to core
      firewire: core: improve reread_config_rom() interface
      firewire: core: wait for inaccessible devices after bus reset
      firewire: ohci: omit spinlock IRQ flags where possible
      firewire: ohci: correct signedness of a local variable
      firewire: core: fix DMA mapping direction
      firewire: use module_pci_driver

commit fc5f80b152896c1ffded2a91d11dcb08ffcffebb
Author: Chris Boot <bootc@bootc.net>
Date:   Wed Feb 1 22:36:02 2012 +0000

    firewire: Move fw_card kref functions into linux/firewire.h
    
    When writing a firewire driver that doesn't deal with struct fw_device
    objects (e.g. it only publishes FireWire units and doesn't subscribe to
    them), you likely need to keep referenced to struct fw_card objects so
    that you can send messages to other nodes. This patch moves
    fw_card_put(), fw_card_get() and fw_card_release() into the public
    include/linux/firewire.h header instead of drivers/firewire/core.h, and
    adds EXPORT_SYMBOL_GPL(fw_card_release).
    
    The firewire-sbp-target module requires these so it can keep a reference
    to the fw_card object in order that it can fetch ORBs to execute and
    read/write related data and status information.
    
    Signed-off-by: Chris Boot <bootc@bootc.net>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 46831303b0b9..e83c24af358a 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -135,6 +135,20 @@ struct fw_card {
 	__be32 maint_utility_register;
 };
 
+static inline struct fw_card *fw_card_get(struct fw_card *card)
+{
+	kref_get(&card->kref);
+
+	return card;
+}
+
+void fw_card_release(struct kref *kref);
+
+static inline void fw_card_put(struct fw_card *card)
+{
+	kref_put(&card->kref, fw_card_release);
+}
+
 struct fw_attribute_group {
 	struct attribute_group *groups[2];
 	struct attribute_group group;

commit 253d92371ca29a470b2bbf91fb9824a9fef05657
Author: Chris Boot <bootc@bootc.net>
Date:   Thu Feb 16 09:16:35 2012 +0000

    firewire: Add function to get speed from opaque struct fw_request
    
    Sometimes it's useful to know the FireWire speed of the request that has
    just come in to a fw_address_handler callback. As struct fw_request is
    opaque we can't peek inside to get the speed out of the struct fw_packet
    that's just inside. For example, the SBP-2 spec says:
    
    "The speed at which the block write request to the MANAGEMENT_AGENT
    register is received shall determine the speed used by the target for
    all subsequent requests to read the initiator’s configuration ROM, fetch
    ORB’s from initiator memory or store status at the initiator’s
    status_FIFO. Command block ORB’s separately specify the speed for
    requests addressed to the data buffer or page table."
    
    [ ANSI T10/1155D Revision 4 page 53/54 ]
    
    Signed-off-by: Chris Boot <bootc@bootc.net>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index cdc9b719e9c7..46831303b0b9 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -325,6 +325,7 @@ int fw_core_add_address_handler(struct fw_address_handler *handler,
 void fw_core_remove_address_handler(struct fw_address_handler *handler);
 void fw_send_response(struct fw_card *card,
 		      struct fw_request *request, int rcode);
+int fw_get_request_speed(struct fw_request *request);
 void fw_send_request(struct fw_card *card, struct fw_transaction *t,
 		     int tcode, int destination_id, int generation, int speed,
 		     unsigned long long offset, void *payload, size_t length,

commit 7bdbff6762a573b911e4ee5715779d8ee6a62631
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Wed Apr 11 17:38:10 2012 +0200

    firewire: move rcode_string() to core
    
    There is nothing audio-specific about the rcode_string() helper, so move
    it from snd-firewire-lib into firewire-core to allow other code to use it.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (fixed sound/firewire/cmp.c)

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 0a1905719f6f..584826ba2eb7 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -334,6 +334,7 @@ int fw_cancel_transaction(struct fw_card *card,
 int fw_run_transaction(struct fw_card *card, int tcode, int destination_id,
 		       int generation, int speed, unsigned long long offset,
 		       void *payload, size_t length);
+const char *fw_rcode_string(int rcode);
 
 static inline int fw_stream_packet_destination_id(int tag, int channel, int sy)
 {

commit 0b6c4857f7684f6d3f59e0506f62953575346978
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Apr 9 20:51:18 2012 +0200

    firewire: core: fix DMA mapping direction
    
    Seen with recent libdc1394:  If a client mmap()s the buffer of an
    isochronous reception buffer with PROT_READ|PROT_WRITE instead of just
    PROT_READ, firewire-core sets the wrong DMA mapping direction during
    buffer initialization.
    
    The fix is to split fw_iso_buffer_init() into allocation and DMA mapping
    and to perform the latter after both buffer and DMA context were
    allocated.  Buffer allocation and context allocation may happen in any
    order, but we need the context type (reception or transmission) in order
    to set the DMA direction of the buffer.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index cdc9b719e9c7..0a1905719f6f 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -391,6 +391,7 @@ struct fw_iso_buffer {
 	enum dma_data_direction direction;
 	struct page **pages;
 	int page_count;
+	int page_count_mapped;
 };
 
 int fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,

commit f68c56b7d2351036d1ec58c7a0ac4f258cbc1fa2
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Apr 1 16:38:45 2012 -0400

    firewire: restore the device.h include in linux/firewire.h
    
    Commit 313162d0b838 ("device.h: audit and cleanup users in main include
    dir") exchanged an include <linux/device.h> for a struct *device but in
    actuality I misread this file when creating 313162d and it should have
    remained an include.
    
    There were no build regressions since all consumers were already getting
    device.h anyway, but make it right regardless.
    
    Reported-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 4db7b68f0582..cdc9b719e9c7 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -2,6 +2,7 @@
 #define _LINUX_FIREWIRE_H
 
 #include <linux/completion.h>
+#include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/kernel.h>
 #include <linux/kref.h>
@@ -64,8 +65,6 @@
 #define CSR_MODEL		0x17
 #define CSR_DIRECTORY_ID	0x20
 
-struct device;
-
 struct fw_csr_iterator {
 	const u32 *p;
 	const u32 *end;

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit d1bbd20972936b9b178fda3eb1ec417cb27fdc01
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Mar 18 19:06:39 2012 +0100

    firewire: allow explicit flushing of iso packet completions
    
    Extend the kernel and userspace APIs to allow reporting all currently
    completed isochronous packets, even if the next interrupt packet has not
    yet been reached.  This is required to determine the status of the
    packets at the end of a paused or stopped stream, and useful for more
    precise synchronization of audio streams.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index ab5b7a18decf..cdc9b719e9c7 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -426,6 +426,7 @@ int fw_iso_context_queue(struct fw_iso_context *ctx,
 			 struct fw_iso_buffer *buffer,
 			 unsigned long payload);
 void fw_iso_context_queue_flush(struct fw_iso_context *ctx);
+int fw_iso_context_flush_completions(struct fw_iso_context *ctx);
 int fw_iso_context_start(struct fw_iso_context *ctx,
 			 int cycle, int sync, int tags);
 int fw_iso_context_stop(struct fw_iso_context *ctx);

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 84ccf8e04fa6..fba45b89689e 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -2,7 +2,6 @@
 #define _LINUX_FIREWIRE_H
 
 #include <linux/completion.h>
-#include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/kernel.h>
 #include <linux/kref.h>
@@ -68,6 +67,8 @@
 #define CSR_MODEL		0x17
 #define CSR_DIRECTORY_ID	0x20
 
+struct device;
+
 struct fw_csr_iterator {
 	const u32 *p;
 	const u32 *end;

commit 26b4950de174bc96c27b77546370dec84fb75ae7
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Feb 18 22:03:14 2012 +0100

    firewire: core: prefix log messages with card name
    
    Associate all log messages from firewire-core with the respective card
    because some people have more than one card.  E.g.
        firewire_ohci 0000:04:00.0: added OHCI v1.10 device as card 0, 8 IR + 8 IT contexts, quirks 0x0
        firewire_ohci 0000:05:00.0: added OHCI v1.10 device as card 1, 8 IR + 8 IT contexts, quirks 0x0
        firewire_core: created device fw0: GUID 0814438400000389, S800
        firewire_core: phy config: new root=ffc1, gap_count=5
        firewire_core: created device fw1: GUID 0814438400000388, S800
        firewire_core: created device fw2: GUID 0001d202e06800d1, S800
    turns into
        firewire_ohci 0000:04:00.0: added OHCI v1.10 device as card 0, 8 IR + 8 IT contexts, quirks 0x0
        firewire_ohci 0000:05:00.0: added OHCI v1.10 device as card 1, 8 IR + 8 IT contexts, quirks 0x0
        firewire_core 0000:04:00.0: created device fw0: GUID 0814438400000389, S800
        firewire_core 0000:04:00.0: phy config: new root=ffc1, gap_count=5
        firewire_core 0000:05:00.0: created device fw1: GUID 0814438400000388, S800
        firewire_core 0000:04:00.0: created device fw2: GUID 0001d202e06800d1, S800
    
    This increases the module size slightly; to keep this in check, turn the
    former printk wrapper macros into functions.  Their implementation is
    largely copied from driver core's dev_printk counterparts.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 6f1d7385e051..ab5b7a18decf 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -17,9 +17,6 @@
 #include <linux/atomic.h>
 #include <asm/byteorder.h>
 
-#define fw_notify(s, args...) printk(KERN_NOTICE KBUILD_MODNAME ": " s, ## args)
-#define fw_error(s, args...) printk(KERN_ERR KBUILD_MODNAME ": " s, ## args)
-
 #define CSR_REGISTER_BASE		0xfffff0000000ULL
 
 /* register offsets are relative to CSR_REGISTER_BASE */

commit 210762268466634ddbfaddb48fdf5181ce4b5f2d
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Aug 27 18:53:03 2011 +0200

    firewire: move fw_device reference counting from drivers to core
    
    fw_unit device drivers invariably need to talk to the fw_unit's parent
    (an fw_device) and grandparent (an fw_card).  firewire-core already
    maintains an fw_card reference for the entire lifetime of an fw_device.
    Likewise, let firewire-core maintain an fw_device reference for the
    entire lifetime of an fw_unit so that fw_unit drivers don't have to.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 84ccf8e04fa6..6f1d7385e051 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -203,18 +203,6 @@ static inline int fw_device_is_shutdown(struct fw_device *device)
 	return atomic_read(&device->state) == FW_DEVICE_SHUTDOWN;
 }
 
-static inline struct fw_device *fw_device_get(struct fw_device *device)
-{
-	get_device(&device->device);
-
-	return device;
-}
-
-static inline void fw_device_put(struct fw_device *device)
-{
-	put_device(&device->device);
-}
-
 int fw_device_enable_phys_dma(struct fw_device *device);
 
 /*

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5e6f42789afe..84ccf8e04fa6 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -14,7 +14,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/byteorder.h>
 
 #define fw_notify(s, args...) printk(KERN_NOTICE KBUILD_MODNAME ": " s, ## args)

commit 105e53f863c04e1d9e5bb34bf753c9fdbce6a60c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun May 1 20:50:31 2011 +0200

    firewire: sbp2: parallelize login, reconnect, logout
    
    The struct sbp2_logical_unit.work items can all be executed in parallel
    but are not reentrant.  Furthermore, reconnect or re-login work must be
    executed in a WQ_MEM_RECLAIM workqueue.
    
    Hence replace the old single-threaded firewire-sbp2 workqueue by a
    concurrency-managed but non-reentrant workqueue with rescuer.
    firewire-core already maintains one, hence use this one.
    
    In earlier versions of this change, I observed occasional failures of
    parallel INQUIRY to an Initio INIC-2430 FireWire 800 to dual IDE bridge.
    More testing indicates that parallel INQUIRY is not actually a problem,
    but too quick successions of logout and login + INQUIRY, e.g. a quick
    sequence of cable plugout and plugin, can result in failed INQUIRY.
    This does not seem to be something that should or could be addressed by
    serialization.
    
    Another dual-LU device to which I currently have access to, an
    OXUF924DSB FireWire 800 to dual SATA bridge with firmware from MacPower,
    has been successfully tested with this too.
    
    This change is beneficial to environments with two or more FireWire
    storage devices, especially if they are located on the same bus.
    Management tasks that should be performed as soon and as quickly as
    possible, especially reconnect, are no longer held up by tasks on other
    devices that may take a long time, especially login with INQUIRY and sd
    or sr driver probe.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index c0fb405bb435..5e6f42789afe 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -449,4 +449,6 @@ void fw_iso_resource_manage(struct fw_card *card, int generation,
 			    u64 channels_mask, int *channel, int *bandwidth,
 			    bool allocate);
 
+extern struct workqueue_struct *fw_workqueue;
+
 #endif /* _LINUX_FIREWIRE_H */

commit 13882a82ee1646336c3996c93b4a560a55d2a419
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon May 2 09:33:56 2011 +0200

    firewire: optimize iso queueing by setting wake only after the last packet
    
    When queueing iso packets, the run time is dominated by the two
    MMIO accesses that set the DMA context's wake bit.  Because most
    drivers submit packets in batches, we can save much time by
    removing all but the last wakeup.
    
    The internal kernel API is changed to require a call to
    fw_iso_context_queue_flush() after a batch of queued packets.
    The user space API does not change, so one call to
    FW_CDEV_IOC_QUEUE_ISO must specify multiple packets to take
    advantage of this optimization.
    
    In my measurements, this patch reduces the time needed to queue
    fifty skip packets from userspace to one sixth on a 2.5 GHz CPU,
    or to one third at 800 MHz.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index de90e1ff8488..c0fb405bb435 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -440,6 +440,7 @@ int fw_iso_context_queue(struct fw_iso_context *ctx,
 			 struct fw_iso_packet *packet,
 			 struct fw_iso_buffer *buffer,
 			 unsigned long payload);
+void fw_iso_context_queue_flush(struct fw_iso_context *ctx);
 int fw_iso_context_start(struct fw_iso_context *ctx,
 			 int cycle, int sync, int tags);
 int fw_iso_context_stop(struct fw_iso_context *ctx);

commit f30e6d3e419bfb5540fa82ba7eca01d578556e6b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Apr 22 15:13:54 2011 +0200

    firewire: octlet AT payloads can be stack-allocated
    
    We do not need slab allocations anymore in order to satisfy
    streaming DMA mapping constraints, thanks to commit da28947e7e36
    "firewire: ohci: avoid separate DMA mapping for small AT payloads".
    
    (Besides, the slab-allocated buffers that firewire-core, firewire-sbp2,
    and firedtv used to provide for 8-byte write and lock requests were
    still not fully portable since they crossed cacheline boundaries or
    shared a cacheline with unrelated CPU-accessed data.  snd-firewire-lib
    got this aspect right by using an extra kmalloc/ kfree just for the
    8-byte transaction buffer.)
    
    This change replaces kmalloc'ed lock transaction scratch buffers in
    firewire-core, firedtv, and snd-firewire-lib by local stack allocations.
    Perhaps the most notable result of the change is simpler locking because
    there is no need to serialize usages of preallocated per-device buffers
    anymore.  Also, allocations and deallocations are simpler.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index c64f3680d4f1..de90e1ff8488 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -125,7 +125,6 @@ struct fw_card {
 	struct delayed_work bm_work; /* bus manager job */
 	int bm_retries;
 	int bm_generation;
-	__be32 bm_transaction_data[2];
 	int bm_node_id;
 	bool bm_abdicate;
 
@@ -447,6 +446,6 @@ int fw_iso_context_stop(struct fw_iso_context *ctx);
 void fw_iso_context_destroy(struct fw_iso_context *ctx);
 void fw_iso_resource_manage(struct fw_card *card, int generation,
 			    u64 channels_mask, int *channel, int *bandwidth,
-			    bool allocate, __be32 buffer[2]);
+			    bool allocate);
 
 #endif /* _LINUX_FIREWIRE_H */

commit c3ca48f062a37c2f79560a9b0b9f1b08039aa248
Merge: 4e76ae440644 115881d39595
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 10:05:22 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ieee1394/linux1394-2.6:
      firewire: core: ignore link-active bit of new nodes, fix device recognition
      firewire: sbp2: revert obsolete 'fix stall with "Unsolicited response"'
      firewire: core: increase default SPLIT_TIMEOUT value
      firewire: ohci: Misleading kfree in ohci.c::pci_probe/remove
      firewire: ohci: omit IntEvent.busReset check rom AT queueing
      firewire: ohci: prevent starting of iso contexts with empty queue
      firewire: ohci: prevent iso completion callbacks after context stop
      firewire: core: rename some variables
      firewire: nosy: should work on Power Mac G4 PCI too
      firewire: core: fix card->reset_jiffies overflow
      firewire: cdev: remove unneeded reference
      firewire: cdev: always wait for outbound transactions to complete
      firewire: cdev: remove unneeded idr_find() from complete_transaction()
      firewire: ohci: log dead DMA contexts

commit 31ef9134eb52636d383a7d0626cbbd345cb94f2f
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Mar 15 07:53:21 2011 +0100

    ALSA: add LaCie FireWire Speakers/Griffin FireWave Surround driver
    
    Add a driver for two playback-only FireWire devices based on the OXFW970
    chip.
    
    v2: better AMDTP API abstraction; fix fw_unit leak; small fixes
    v3: cache the iPCR value
    v4: FireWave constraints; fix fw_device reference counting;
        fix PCR caching; small changes and fixes
    v5: volume/mute support; fix crashing due to pcm stop races
    v6: fix build; one-channel volume for LaCie
    v7: use signed values to make volume (range checks) work; fix function
        block IDs for volume/mute; always use channel 0 for LaCie volume
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Tested-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 9a3f5f9383f6..fc023d67676f 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -42,6 +42,10 @@
 #define CSR_BROADCAST_CHANNEL		0x234
 #define CSR_CONFIG_ROM			0x400
 #define CSR_CONFIG_ROM_END		0x800
+#define CSR_OMPR			0x900
+#define CSR_OPCR(i)			(0x904 + (i) * 4)
+#define CSR_IMPR			0x980
+#define CSR_IPCR(i)			(0x984 + (i) * 4)
 #define CSR_FCP_COMMAND			0xB00
 #define CSR_FCP_RESPONSE		0xD00
 #define CSR_FCP_END			0xF00
@@ -441,5 +445,8 @@ int fw_iso_context_start(struct fw_iso_context *ctx,
 			 int cycle, int sync, int tags);
 int fw_iso_context_stop(struct fw_iso_context *ctx);
 void fw_iso_context_destroy(struct fw_iso_context *ctx);
+void fw_iso_resource_manage(struct fw_card *card, int generation,
+			    u64 channels_mask, int *channel, int *bandwidth,
+			    bool allocate, __be32 buffer[2]);
 
 #endif /* _LINUX_FIREWIRE_H */

commit e71084af58cf15e6043338500eeaf6281d0a62af
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Jan 22 15:05:03 2011 +0100

    firewire: core: fix card->reset_jiffies overflow
    
    On a 32-bit machine with, e.g., HZ=1000, jiffies will overflow after
    about 50 days, so if there are between 25 and 50 days between bus
    resets, the card->reset_jiffies comparisons can get wrong results.
    
    To fix this, ensure that this timestamp always uses 64 bits.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: "Stefan Richter" <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 9a3f5f9383f6..b6d21d5a11a2 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -89,7 +89,7 @@ struct fw_card {
 	int current_tlabel;
 	u64 tlabel_mask;
 	struct list_head transaction_list;
-	unsigned long reset_jiffies;
+	u64 reset_jiffies;
 
 	u32 split_timeout_hi;
 	u32 split_timeout_lo;

commit 410cf2bd3dc6ec1ed9e1b36b25b9d7aa927ed14e
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Mon Dec 13 14:56:02 2010 +0100

    firewire: use split transaction timeout only for split transactions
    
    Instead of starting the split transaction timeout timer when any request
    is submitted, start it only when the destination's ACK_PENDING has been
    received.  This prevents us from using a timeout that is too short, and,
    if the controller's AT queue is emptying very slowly, from cancelling
    a packet that has not yet been sent.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 1cd637ef62d2..9a3f5f9383f6 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -302,9 +302,9 @@ struct fw_packet {
 struct fw_transaction {
 	int node_id; /* The generation is implied; it is always the current. */
 	int tlabel;
-	int timestamp;
 	struct list_head link;
 	struct fw_card *card;
+	bool is_split_transaction;
 	struct timer_list split_timeout_timer;
 
 	struct fw_packet packet;

commit 872e330e38806d835bd6c311c93ab998e2fb9058
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 29 18:19:22 2010 +0200

    firewire: add isochronous multichannel reception
    
    This adds the DMA context programming and userspace ABI for multichannel
    reception, i.e. for listening on multiple channel numbers by means of a
    single DMA context.
    
    The use case is reception of more streams than there are IR DMA units
    offered by the link layer.  This is already implemented by the older
    ohci1394 + ieee1394 + raw1394 stack.  And as discussed recently on
    linux1394-devel, this feature is occasionally used in practice.
    
    The big drawbacks of this mode are that buffer layout and interrupt
    generation necessarily differ from single-channel reception:  Headers
    and trailers are not stripped from packets, packets are not aligned with
    buffer chunks, interrupts are per buffer chunk, not per packet.
    
    These drawbacks also cause a rather hefty code footprint to support this
    rarely used OHCI-1394 feature.  (367 lines added, among them 94 lines of
    added userspace ABI documentation.)
    
    This implementation enforces that a multichannel reception context may
    only listen to channels to which no single-channel context on the same
    link layer is presently listening to.  OHCI-1394 would allow to overlay
    single-channel contexts by the multi-channel context, but this would be
    a departure from the present first-come-first-served policy of IR
    context creation.
    
    The implementation is heavily based on an earlier one by Jay Fenlason.
    Thanks Jay.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index d974aa4a24c9..1cd637ef62d2 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -372,17 +372,19 @@ void fw_core_remove_descriptor(struct fw_descriptor *desc);
  * scatter-gather streaming (e.g. assembling video frame automatically).
  */
 struct fw_iso_packet {
-	u16 payload_length;	/* Length of indirect payload. */
-	u32 interrupt:1;	/* Generate interrupt on this packet */
-	u32 skip:1;		/* Set to not send packet at all. */
-	u32 tag:2;
-	u32 sy:4;
-	u32 header_length:8;	/* Length of immediate header. */
-	u32 header[0];
+	u16 payload_length;	/* Length of indirect payload		*/
+	u32 interrupt:1;	/* Generate interrupt on this packet	*/
+	u32 skip:1;		/* tx: Set to not send packet at all	*/
+				/* rx: Sync bit, wait for matching sy	*/
+	u32 tag:2;		/* tx: Tag in packet header		*/
+	u32 sy:4;		/* tx: Sy in packet header		*/
+	u32 header_length:8;	/* Length of immediate header		*/
+	u32 header[0];		/* tx: Top of 1394 isoch. data_block	*/
 };
 
-#define FW_ISO_CONTEXT_TRANSMIT	0
-#define FW_ISO_CONTEXT_RECEIVE	1
+#define FW_ISO_CONTEXT_TRANSMIT			0
+#define FW_ISO_CONTEXT_RECEIVE			1
+#define FW_ISO_CONTEXT_RECEIVE_MULTICHANNEL	2
 
 #define FW_ISO_CONTEXT_MATCH_TAG0	 1
 #define FW_ISO_CONTEXT_MATCH_TAG1	 2
@@ -406,24 +408,31 @@ struct fw_iso_buffer {
 int fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,
 		       int page_count, enum dma_data_direction direction);
 void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer, struct fw_card *card);
+size_t fw_iso_buffer_lookup(struct fw_iso_buffer *buffer, dma_addr_t completed);
 
 struct fw_iso_context;
 typedef void (*fw_iso_callback_t)(struct fw_iso_context *context,
 				  u32 cycle, size_t header_length,
 				  void *header, void *data);
+typedef void (*fw_iso_mc_callback_t)(struct fw_iso_context *context,
+				     dma_addr_t completed, void *data);
 struct fw_iso_context {
 	struct fw_card *card;
 	int type;
 	int channel;
 	int speed;
 	size_t header_size;
-	fw_iso_callback_t callback;
+	union {
+		fw_iso_callback_t sc;
+		fw_iso_mc_callback_t mc;
+	} callback;
 	void *callback_data;
 };
 
 struct fw_iso_context *fw_iso_context_create(struct fw_card *card,
 		int type, int channel, int speed, size_t header_size,
 		fw_iso_callback_t callback, void *callback_data);
+int fw_iso_context_set_channels(struct fw_iso_context *ctx, u64 *channels);
 int fw_iso_context_queue(struct fw_iso_context *ctx,
 			 struct fw_iso_packet *packet,
 			 struct fw_iso_buffer *buffer,

commit bf54e1462b9192fdef7ea9e2bc44fdc16a4b87bc
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Jul 16 22:25:51 2010 +0200

    firewire: cdev: add PHY packet reception
    
    Add an FW_CDEV_IOC_RECEIVE_PHY_PACKETS ioctl() and
    FW_CDEV_EVENT_PHY_PACKET_RECEIVED poll()/read() event for /dev/fw*.
    This can be used to get information from remote PHYs by remote access
    PHY packets.
    
    This is also the 2nd half of the functionality (the receive part) to
    support a userspace implementation of a VersaPHY transaction layer.
    
    Safety considerations:
    
      - PHY packets are generally broadcasts, hence some kind of elevated
        privileges should be required of a process to be able to listen in
        on PHY packets.  This implementation assumes that a process that is
        allowed to open the /dev/fw* of a local node does have this
        privilege.
    
        There was an inconclusive discussion about introducing POSIX
        capabilities as a means to check for user privileges for these
        kinds of operations.
    
    Other limitations:
    
      - PHY packet reception may be switched on by ioctl() but cannot be
        switched off again.  It would be trivial to provide an off switch,
        but this is not worth the code.  The client should simply close()
        the fd then, or just ignore further events.
    
      - For sake of simplicity of API and kernel-side implementation, no
        filter per packet content is provided.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 0c38b8e97722..d974aa4a24c9 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -111,9 +111,10 @@ struct fw_card {
 	bool beta_repeaters_present;
 
 	int index;
-
 	struct list_head link;
 
+	struct list_head phy_receiver_list;
+
 	struct delayed_work br_work; /* bus reset job */
 	bool br_short;
 

commit 18d0cdfd1a4cc9028c0ef80f94538b31541f8fe5
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 18 12:44:01 2010 +0200

    firewire: normalize status values in packet callbacks
    
    core-transaction.c transmit_complete_callback() and close_transaction()
    expect packet callback status to be an ACK or RCODE, and ACKs get
    translated to RCODEs for transaction callbacks.
    
    An old comment on the packet callback API (been there from the initial
    submission of the stack) and the dummy_driver implementation of
    send_request/send_response deviated from this as they also included
    -ERRNO in the range of status values.
    
    Let's narrow status values down to ACK and RCODE to prevent surprises.
    RCODE_CANCELLED is chosen as the dummy_driver's RCODE as its meaning of
    "transaction timed out" comes closest to what happens when a transaction
    coincides with card removal.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index adc5b55e6e5f..0c38b8e97722 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -285,10 +285,10 @@ struct fw_packet {
 	u32 timestamp;
 
 	/*
-	 * This callback is called when the packet transmission has
-	 * completed; for successful transmission, the status code is
-	 * the ack received from the destination, otherwise it's a
-	 * negative errno: ENOMEM, ESTALE, ETIMEDOUT, ENODEV, EIO.
+	 * This callback is called when the packet transmission has completed.
+	 * For successful transmission, the status code is the ack received
+	 * from the destination.  Otherwise it is one of the juju-specific
+	 * rcodes:  RCODE_SEND_ERROR, _CANCELLED, _BUSY, _GENERATION, _NO_ACK.
 	 * The callback can be called from tasklet context and thus
 	 * must never block.
 	 */

commit 02d37bed188c500ee7afb0a2dc6b65a80704c58e
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Jul 8 16:09:06 2010 +0200

    firewire: core: integrate software-forced bus resets with bus management
    
    Bus resets which are triggered
      - by the kernel drivers after updates of the local nodes' config ROM,
      - by userspace software via ioctl
    shall be deferred until after >=2 seconds after the last bus reset.
    
    If multiple modifications of the local nodes' config ROM happen in a row,
    only a single bus reset should happen after them.
    
    When the local node's link goes from inactive to active or vice versa,
    and at the two occasions of bus resets mentioned above --- and if the
    current gap count differs from 63 --- the bus reset should be preceded
    by a PHY configuration packet that reaffirms the gap count.  Otherwise a
    bus manager would have to reset the bus again right after that.
    
    This is necessary to promote bus stability, e.g. leave grace periods for
    allocations and reallocations of isochronous channels and bandwidth,
    SBP-2 reconnections etc.; see IEEE 1394 clause 8.2.1.
    
    This change implements all of the above by moving bus reset initiation
    into a delayed work (except for bus resets which are triggered by the
    bus manager workqueue job and are performed there immediately).  It
    comes with a necessary addition to the card driver methods that allows
    to get the current gap count from PHY registers.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index db30a752a87a..adc5b55e6e5f 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -114,8 +114,10 @@ struct fw_card {
 
 	struct list_head link;
 
-	/* Work struct for BM duties. */
-	struct delayed_work work;
+	struct delayed_work br_work; /* bus reset job */
+	bool br_short;
+
+	struct delayed_work bm_work; /* bus manager job */
 	int bm_retries;
 	int bm_generation;
 	__be32 bm_transaction_data[2];

commit 250b2b6dd421c9f8844a867d2ac06e0661e0ad93
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Mon Jun 21 23:24:35 2010 +0200

    firewire: cdev: fix fw_cdev_event_bus_reset.bm_node_id
    
    Fix an obscure ABI feature that is a bit of a hassle to implement.
    However, somebody put it into the ABI, so let's fill in a sensible
    value there.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index e44b502c8341..db30a752a87a 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -119,6 +119,7 @@ struct fw_card {
 	int bm_retries;
 	int bm_generation;
 	__be32 bm_transaction_data[2];
+	int bm_node_id;
 	bool bm_abdicate;
 
 	bool priority_budget_implemented;	/* controller feature */

commit 33e553fe2b4a983ef34a57ab1440d8d33397bb12
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 20 22:50:35 2010 +0200

    firewire: remove an unused function argument
    
    void (*fw_address_callback_t)(..., int speed, ...) is the speed that a
    remote node chose to transmit a request to us.  In case of split
    transactions, firewire-core will transmit the response at that speed.
    
    Upper layer drivers on the other hand (firewire-net, -sbp2, firedtv, and
    userspace drivers) cannot do anything useful with that speed datum,
    except log it for debug purposes.  But data that is merely potentially
    (not even actually) used for debug purposes does not belong into the API.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5553018d45d6..e44b502c8341 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -265,7 +265,7 @@ typedef void (*fw_transaction_callback_t)(struct fw_card *card, int rcode,
 typedef void (*fw_address_callback_t)(struct fw_card *card,
 				      struct fw_request *request,
 				      int tcode, int destination, int source,
-				      int generation, int speed,
+				      int generation,
 				      unsigned long long offset,
 				      void *data, size_t length,
 				      void *callback_data);

commit c8a94ded57e9cc2498d401b2f5c856213a3e19fb
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 12 20:34:50 2010 +0200

    firewire: normalize STATE_CLEAR/SET CSR access interface
    
    Push the maintenance of STATE_CLEAR/SET.abdicate down into the card
    driver.  This way, the read/write_csr_reg driver method works uniformly
    across all CSR offsets.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5acb5fc19180..5553018d45d6 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -119,8 +119,7 @@ struct fw_card {
 	int bm_retries;
 	int bm_generation;
 	__be32 bm_transaction_data[2];
-	bool bm_abdicate; /* value of csr_abdicate before last bus reset */
-	bool csr_abdicate; /* visible in CSR STATE_CLEAR/SET registers */
+	bool bm_abdicate;
 
 	bool priority_budget_implemented;	/* controller feature */
 	bool broadcast_channel_auto_allocated;	/* controller feature */

commit db3c9cc105ee844f6cd7a1beb9926fb8e9a093ae
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 12 20:30:21 2010 +0200

    firewire: replace get_features card driver hook
    
    by feature variables in the fw_card struct.  The hook appeared to be an
    unnecessary abstraction in the card driver interface.
    
    Cleaner would be to pass those feature flags as arguments to
    fw_card_initialize() or fw_card_add(), but the FairnessControl register
    is in the SCLK domain and may therefore not be accessible while Link
    Power Status is off, i.e. before the card->driver->enable call from
    fw_card_add().
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 4d22643215ef..5acb5fc19180 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -122,6 +122,9 @@ struct fw_card {
 	bool bm_abdicate; /* value of csr_abdicate before last bus reset */
 	bool csr_abdicate; /* visible in CSR STATE_CLEAR/SET registers */
 
+	bool priority_budget_implemented;	/* controller feature */
+	bool broadcast_channel_auto_allocated;	/* controller feature */
+
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
 	__be32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];

commit 7e0e314f198d5048b74c8f0ef9f4c1c02e5ecfc9
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:37:15 2010 +0200

    firewire: core: add CSR abdicate support
    
    Implement the abdicate bit, which is required for bus manager
    capable nodes and tested by the Base 1394 Test Suite.
    
    Finally, something to do at a command reset!  :-)
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index f1160e831dad..4d22643215ef 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -119,6 +119,8 @@ struct fw_card {
 	int bm_retries;
 	int bm_generation;
 	__be32 bm_transaction_data[2];
+	bool bm_abdicate; /* value of csr_abdicate before last bus reset */
+	bool csr_abdicate; /* visible in CSR STATE_CLEAR/SET registers */
 
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;

commit 3d1f46eb60b155c705e389ecdf313f11b4b91976
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:35:37 2010 +0200

    firewire: core: add CSR MAINT_UTILITY support
    
    Implement the MAIN_UTILITY register, which is utterly optional
    but useful as a safe target for diagnostic read/write/broadcast
    transactions.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index a50377d91254..f1160e831dad 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -38,6 +38,7 @@
 #define CSR_CHANNELS_AVAILABLE		0x224
 #define CSR_CHANNELS_AVAILABLE_HI	0x224
 #define CSR_CHANNELS_AVAILABLE_LO	0x228
+#define CSR_MAINT_UTILITY		0x230
 #define CSR_BROADCAST_CHANNEL		0x234
 #define CSR_CONFIG_ROM			0x400
 #define CSR_CONFIG_ROM_END		0x800
@@ -122,6 +123,8 @@ struct fw_card {
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
 	__be32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
+
+	__be32 maint_utility_register;
 };
 
 struct fw_attribute_group {

commit a1a1132bd83d0aea51d4f19be4b4a58a064a0131
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:35:06 2010 +0200

    firewire: add CSR PRIORITY_BUDGET support
    
    If supported by the OHCI controller, implement the PRIORITY_BUDGET
    register, which is required for nodes that can use asynchronous
    priority arbitration.
    
    To allow the core to determine what features the lowlevel device
    supports, add a new card driver callback.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index cdf8213c68ca..a50377d91254 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -32,6 +32,7 @@
 #define CSR_CYCLE_TIME			0x200
 #define CSR_BUS_TIME			0x204
 #define CSR_BUSY_TIMEOUT		0x210
+#define CSR_PRIORITY_BUDGET		0x218
 #define CSR_BUS_MANAGER_ID		0x21c
 #define CSR_BANDWIDTH_AVAILABLE		0x220
 #define CSR_CHANNELS_AVAILABLE		0x224

commit 8e4b50f94e8c1435a3e0ece42b7f97bc857d0145
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Jun 10 08:26:28 2010 +0200

    firewire: core: add CSR SPLIT_TIMEOUT support
    
    Implement the SPLIT_TIMEOUT registers.  Besides being required by the
    spec, this is desirable for some IIDC devices and necessary for many
    audio devices to be able to increase the timeout from userspace.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 72e2b8ac2a5a..cdf8213c68ca 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -89,6 +89,11 @@ struct fw_card {
 	struct list_head transaction_list;
 	unsigned long reset_jiffies;
 
+	u32 split_timeout_hi;
+	u32 split_timeout_lo;
+	unsigned int split_timeout_cycles;
+	unsigned int split_timeout_jiffies;
+
 	unsigned long long guid;
 	unsigned max_receive;
 	int link_speed;

commit 5c40cbfefa828208c671e2f58789e4dd04f79563
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Tue Apr 27 09:07:00 2010 +0200

    firewire: core: use separate timeout for each transaction
    
    Using a single timeout for all transaction that need to be flushed does
    not work if the submission of new transactions can defer the timeout
    indefinitely into the future.  We need to have timeouts that do not
    change due to other transactions; the simplest way to do this is with a
    separate timer for each transaction.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (+ one lockdep annotation)

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index a527d73f9966..72e2b8ac2a5a 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -87,7 +87,6 @@ struct fw_card {
 	int current_tlabel;
 	u64 tlabel_mask;
 	struct list_head transaction_list;
-	struct timer_list flush_timer;
 	unsigned long reset_jiffies;
 
 	unsigned long long guid;
@@ -288,6 +287,8 @@ struct fw_transaction {
 	int tlabel;
 	int timestamp;
 	struct list_head link;
+	struct fw_card *card;
+	struct timer_list split_timeout_timer;
 
 	struct fw_packet packet;
 

commit edd5bdaf128e04066caac84fcb21377197ea0d64
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Apr 14 22:30:18 2010 +0200

    firewire: core: clean up config ROM related defined constants
    
    Clemens Ladisch pointed out that
      - BIB_IMC is not named like the field is called in the standard,
      - readers of the code may get worried about the magic 0x0c0083c0,
      - a CSR_NODE_CAPABILITIES key is there in the header but not put to
        good use.
    
    So let's rename BIB_IMC, add a defined constant for Node_Capabilities
    and a comment which reassures people that somebody thought about it and
    they don't have to (or if they still do, tell them where they have to
    look for confirmation), and prune our incomplete and arbitrary set of
    defined constants of CSR key IDs.  And there is a nother magic number,
    that of Bus_Information_Block.Bus_Name, to be defined and commented.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 4bd94bf5e739..a527d73f9966 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -55,13 +55,11 @@
 #define CSR_DESCRIPTOR		0x01
 #define CSR_VENDOR		0x03
 #define CSR_HARDWARE_VERSION	0x04
-#define CSR_NODE_CAPABILITIES	0x0c
 #define CSR_UNIT		0x11
 #define CSR_SPECIFIER_ID	0x12
 #define CSR_VERSION		0x13
 #define CSR_DEPENDENT_INFO	0x14
 #define CSR_MODEL		0x17
-#define CSR_INSTANCE		0x18
 #define CSR_DIRECTORY_ID	0x20
 
 struct fw_csr_iterator {

commit 13b302d0a217580c0129b0641b0ca8b592e437b0
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Dec 26 01:44:10 2009 +0100

    firewire: qualify config ROM cache pointers as const pointers
    
    Several config ROM related functions only peek at the ROM cache; mark
    their arguments as const pointers.  Ditto fw_device.config_rom and
    fw_unit.directory, as the memory behind them is meant to be write-once.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index df680216e7b6..4bd94bf5e739 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -65,13 +65,13 @@
 #define CSR_DIRECTORY_ID	0x20
 
 struct fw_csr_iterator {
-	u32 *p;
-	u32 *end;
+	const u32 *p;
+	const u32 *end;
 };
 
-void fw_csr_iterator_init(struct fw_csr_iterator *ci, u32 *p);
+void fw_csr_iterator_init(struct fw_csr_iterator *ci, const u32 *p);
 int fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value);
-int fw_csr_string(u32 *directory, int key, char *buf, size_t size);
+int fw_csr_string(const u32 *directory, int key, char *buf, size_t size);
 
 extern struct bus_type fw_bus_type;
 
@@ -163,7 +163,7 @@ struct fw_device {
 	struct mutex client_list_mutex;
 	struct list_head client_list;
 
-	u32 *config_rom;
+	const u32 *config_rom;
 	size_t config_rom_length;
 	int config_rom_retries;
 	unsigned is_local:1;
@@ -205,7 +205,7 @@ int fw_device_enable_phys_dma(struct fw_device *device);
  */
 struct fw_unit {
 	struct device device;
-	u32 *directory;
+	const u32 *directory;
 	struct fw_attribute_group attribute_group;
 };
 

commit 3c2c58cb33b3b15a2c4871babeec8fe1456e1db6
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Dec 26 01:43:21 2009 +0100

    firewire: core: fw_csr_string addendum
    
    Witespace and comment changes, and a different way to say i + 1 < end.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5246869d8083..df680216e7b6 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -71,7 +71,6 @@ struct fw_csr_iterator {
 
 void fw_csr_iterator_init(struct fw_csr_iterator *ci, u32 *p);
 int fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value);
-
 int fw_csr_string(u32 *directory, int key, char *buf, size_t size);
 
 extern struct bus_type fw_bus_type;

commit 1f8fef7b3388b5a976e80839679b5bae581a1091
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Thu Dec 24 11:59:57 2009 +0100

    firewire: add fw_csr_string() helper function
    
    The core (sysfs attributes), the firedtv driver, and possible future
    drivers all read strings from some configuration ROM directory.  Factor
    out the generic code from show_text_leaf() into a new helper function,
    modified slightly to handle arbitrary buffer sizes.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index a0e67150a729..5246869d8083 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -72,6 +72,8 @@ struct fw_csr_iterator {
 void fw_csr_iterator_init(struct fw_csr_iterator *ci, u32 *p);
 int fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value);
 
+int fw_csr_string(u32 *directory, int key, char *buf, size_t size);
+
 extern struct bus_type fw_bus_type;
 
 struct fw_card_driver;

commit db5d247ae811f49185a71e703b65acad845e4b18
Author: Clemens Ladisch <cladisch@fastmail.net>
Date:   Thu Dec 24 12:05:58 2009 +0100

    firewire: fix use of multiple AV/C devices, allow multiple FCP listeners
    
    Control of more than one AV/C device at once --- e.g. camcorders, tape
    decks, audio devices, TV tuners --- failed or worked only unreliably,
    depending on driver implementation.  This affected kernelspace and
    userspace drivers alike and was caused by firewire-core's inability to
    accept multiple registrations of FCP listeners.
    
    The fix allows multiple address handlers to be registered for the FCP
    command and response registers.  When a request for these registers is
    received, all handlers are invoked, and the Firewire response is
    generated by the core and not by any handler.
    
    The cdev API does not change, i.e., userspace is still expected to send
    a response for FCP requests; this response is silently ignored.
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (changelog, rebased, whitespace)

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 9416a461b696..a0e67150a729 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -248,8 +248,8 @@ typedef void (*fw_transaction_callback_t)(struct fw_card *card, int rcode,
 					  void *data, size_t length,
 					  void *callback_data);
 /*
- * Important note:  The callback must guarantee that either fw_send_response()
- * or kfree() is called on the @request.
+ * Important note:  Except for the FCP registers, the callback must guarantee
+ * that either fw_send_response() or kfree() is called on the @request.
  */
 typedef void (*fw_address_callback_t)(struct fw_card *card,
 				      struct fw_request *request,

commit 19593ffdb6daa6ba691d247a2400cece12687c52
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Wed Oct 14 20:40:10 2009 +0200

    firewire: ohci: 0 may be a valid DMA address
    
    I was told that there are obscure architectures with non-coherent DMA
    which may DMA-map to bus address 0.  We shall not use 0 as a magic
    number of uninitialized bus address variables.
    
    The packet->payload_length > 0 test cannot be used either (except in
    at_context_queue_packet) because local requests are not DMA-mapped
    regardless of payload_length.  Hence add a state flag to struct
    fw_packet.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 211a5d7d87b3..9416a461b696 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -267,6 +267,7 @@ struct fw_packet {
 	void *payload;
 	size_t payload_length;
 	dma_addr_t payload_bus;
+	bool payload_mapped;
 	u32 timestamp;
 
 	/*

commit cb7c96da3651111efbe088fa12f9bed61836ea93
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Oct 8 00:42:53 2009 +0200

    firewire: core: optimize Topology Map creation
    
    The Topology Map of the local node was created in CPU byte order,
    then a temporary big endian copy was created to compute the CRC,
    and when a read request to the Topology Map arrived it had to be
    converted to big endian byte order again.
    
    We now generate it in big endian byte order in the first place.
    This also rids us of 1000 bytes stack usage in tasklet context.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 53b9217de86c..211a5d7d87b3 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -117,7 +117,7 @@ struct fw_card {
 
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
-	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
+	__be32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
 };
 
 struct fw_attribute_group {

commit 8e85973efc87dfae8508f1a3440fd44612897458
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Thu Oct 8 00:41:59 2009 +0200

    firewire: optimize config ROM creation
    
    The config ROM image of the local node was created in CPU byte order,
    then a temporary big endian copy was created to compute the CRC, and
    finally the card driver created its own big endian copy.
    
    We now generate it in big endian byte order in the first place to avoid
    one byte order conversion and the temporary on-stack copy of the ROM
    image (1000 bytes stack usage in process context).  Furthermore, two
    1000 bytes memset()s are replaced by one 1000 bytes - ROM length sized
    memset.
    
    The trivial fw_memcpy_{from,to}_be32() helpers are now superfluous and
    removed.  The newly added __compute_block_crc() function will be folded
    into fw_compute_block_crc() in a subsequent change.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 7e1d4dec83e7..53b9217de86c 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -20,20 +20,6 @@
 #define fw_notify(s, args...) printk(KERN_NOTICE KBUILD_MODNAME ": " s, ## args)
 #define fw_error(s, args...) printk(KERN_ERR KBUILD_MODNAME ": " s, ## args)
 
-static inline void fw_memcpy_from_be32(void *_dst, void *_src, size_t size)
-{
-	u32    *dst = _dst;
-	__be32 *src = _src;
-	int i;
-
-	for (i = 0; i < size / 4; i++)
-		dst[i] = be32_to_cpu(src[i]);
-}
-
-static inline void fw_memcpy_to_be32(void *_dst, void *_src, size_t size)
-{
-	fw_memcpy_from_be32(_dst, _src, size);
-}
 #define CSR_REGISTER_BASE		0xfffff0000000ULL
 
 /* register offsets are relative to CSR_REGISTER_BASE */

commit 18668ff9a3232d5f942a2f7abc1ad67d2760dcdf
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Sep 6 18:49:48 2009 +0200

    firewire: core: header file cleanup
    
    fw_card_get, fw_card_put, fw_card_release are currently not exported for
    use outside the firewire-core.  Move their definitions/ declarations
    from the subsystem header file to the core header file.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 192d1e43c43c..7e1d4dec83e7 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -134,20 +134,6 @@ struct fw_card {
 	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
 };
 
-static inline struct fw_card *fw_card_get(struct fw_card *card)
-{
-	kref_get(&card->kref);
-
-	return card;
-}
-
-void fw_card_release(struct kref *kref);
-
-static inline void fw_card_put(struct fw_card *card)
-{
-	kref_put(&card->kref, fw_card_release);
-}
-
 struct fw_attribute_group {
 	struct attribute_group *groups[2];
 	struct attribute_group group;

commit 6fdc03709433ccc2005f0f593ae9d9dd04f7b485
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 20 13:23:59 2009 +0200

    firewire: core: do not DMA-map stack addresses
    
    The DMA mapping API cannot map on-stack addresses, as explained in
    Documentation/DMA-mapping.txt.  Convert the two cases of on-stack packet
    payload buffers in firewire-core (payload of lock requests in the bus
    manager work and in iso resource management) to slab-allocated memory.
    
    There are a number on-stack buffers for quadlet write or quadlet read
    requests in firewire-core and firewire-sbp2.  These are harmless; they
    are copied to/ from card driver internal DMA buffers since quadlet
    payloads are inlined with packet headers.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 9823946adbc5..192d1e43c43c 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -127,6 +127,7 @@ struct fw_card {
 	struct delayed_work work;
 	int bm_retries;
 	int bm_generation;
+	__be32 bm_transaction_data[2];
 
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;

commit 5a124d382ea5c97be43c779e4f481455e0287654
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 14 11:45:27 2009 +0200

    firewire: net: allow for unordered unit discovery
    
    Decouple the creation and destruction of the net_device from the order
    of discovery and removal of nodes with RFC 2734 unit directories since
    there is no reliable order.  The net_device is now created when the
    first RFC 2734 unit on a card is discovered, and destroyed when the last
    RFC 2734 unit on a card went away.  This includes all remote units as
    well as the local unit, which is therefore tracked as a peer now too.
    
    Also, locking around the list of peers is slightly extended to guard
    against peer removal.  As a side effect, fwnet_peer.pdg_lock has become
    superfluous and is deleted.
    
    Peer data (max_rec, speed, node ID, generation) are updated more
    carefully.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 5cb0c1549ff1..9823946adbc5 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -131,10 +131,6 @@ struct fw_card {
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
 	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
-
-	/* firewire-net driver data */
-	void *netdev;
-	struct list_head peer_list;
 };
 
 static inline struct fw_card *fw_card_get(struct fw_card *card)

commit f91e3bd842ec6f5cea245993926ee8ff26250467
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 7 22:57:53 2009 +0200

    firewire: net: style changes
    
    Change names of types, variables, functions.
    Omit debug code.
    Use get_unaligned*, put_unaligned*.
    Annotate big endian data.
    Handle errors in __init.
    Change whitespace.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index d44f47d3b2d9..5cb0c1549ff1 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -131,13 +131,10 @@ struct fw_card {
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
 	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
-	/* Only non-NULL if firewire-ipv4 is active on this card. */
+
+	/* firewire-net driver data */
 	void *netdev;
-	/*
-	 * The nodes get probed before the card, so we need a place to store
-	 * them independent of card->netdev
-	 */
-	struct list_head ipv4_nodes;
+	struct list_head peer_list;
 };
 
 static inline struct fw_card *fw_card_get(struct fw_card *card)

commit c76acec6d55107b652a37c90b36c00bc8b04dabb
Author: Jay Fenlason <fenlason@redhat.com>
Date:   Mon May 18 13:08:06 2009 -0400

    firewire: add IPv4 support
    
    Implement IPv4 over IEEE 1394 as per RFC 2734 for the newer firewire
    stack.  This feature has only been present in the older ieee1394 stack
    via the eth1394 driver.
    
    Still to do:
      - fix ipv4_priv and ipv4_node lifetime logic
      - fix determination of speeds and max payloads
      - fix bus reset handling
      - fix unaligned memory accesses
      - fix coding style
      - further testing/ improvement of fragment reassembly
      - perhaps multicast support
    
    Signed-off-by: Jay Fenlason <fenlason@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de> (rebased, copyright note, changelog)

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index e584b7215e8b..d44f47d3b2d9 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -3,6 +3,7 @@
 
 #include <linux/completion.h>
 #include <linux/device.h>
+#include <linux/dma-mapping.h>
 #include <linux/kernel.h>
 #include <linux/kref.h>
 #include <linux/list.h>
@@ -130,6 +131,13 @@ struct fw_card {
 	bool broadcast_channel_allocated;
 	u32 broadcast_channel;
 	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
+	/* Only non-NULL if firewire-ipv4 is active on this card. */
+	void *netdev;
+	/*
+	 * The nodes get probed before the card, so we need a place to store
+	 * them independent of card->netdev
+	 */
+	struct list_head ipv4_nodes;
 };
 
 static inline struct fw_card *fw_card_get(struct fw_card *card)
@@ -355,4 +363,90 @@ int fw_run_transaction(struct fw_card *card, int tcode, int destination_id,
 		       int generation, int speed, unsigned long long offset,
 		       void *payload, size_t length);
 
+static inline int fw_stream_packet_destination_id(int tag, int channel, int sy)
+{
+	return tag << 14 | channel << 8 | sy;
+}
+
+struct fw_descriptor {
+	struct list_head link;
+	size_t length;
+	u32 immediate;
+	u32 key;
+	const u32 *data;
+};
+
+int fw_core_add_descriptor(struct fw_descriptor *desc);
+void fw_core_remove_descriptor(struct fw_descriptor *desc);
+
+/*
+ * The iso packet format allows for an immediate header/payload part
+ * stored in 'header' immediately after the packet info plus an
+ * indirect payload part that is pointer to by the 'payload' field.
+ * Applications can use one or the other or both to implement simple
+ * low-bandwidth streaming (e.g. audio) or more advanced
+ * scatter-gather streaming (e.g. assembling video frame automatically).
+ */
+struct fw_iso_packet {
+	u16 payload_length;	/* Length of indirect payload. */
+	u32 interrupt:1;	/* Generate interrupt on this packet */
+	u32 skip:1;		/* Set to not send packet at all. */
+	u32 tag:2;
+	u32 sy:4;
+	u32 header_length:8;	/* Length of immediate header. */
+	u32 header[0];
+};
+
+#define FW_ISO_CONTEXT_TRANSMIT	0
+#define FW_ISO_CONTEXT_RECEIVE	1
+
+#define FW_ISO_CONTEXT_MATCH_TAG0	 1
+#define FW_ISO_CONTEXT_MATCH_TAG1	 2
+#define FW_ISO_CONTEXT_MATCH_TAG2	 4
+#define FW_ISO_CONTEXT_MATCH_TAG3	 8
+#define FW_ISO_CONTEXT_MATCH_ALL_TAGS	15
+
+/*
+ * An iso buffer is just a set of pages mapped for DMA in the
+ * specified direction.  Since the pages are to be used for DMA, they
+ * are not mapped into the kernel virtual address space.  We store the
+ * DMA address in the page private. The helper function
+ * fw_iso_buffer_map() will map the pages into a given vma.
+ */
+struct fw_iso_buffer {
+	enum dma_data_direction direction;
+	struct page **pages;
+	int page_count;
+};
+
+int fw_iso_buffer_init(struct fw_iso_buffer *buffer, struct fw_card *card,
+		       int page_count, enum dma_data_direction direction);
+void fw_iso_buffer_destroy(struct fw_iso_buffer *buffer, struct fw_card *card);
+
+struct fw_iso_context;
+typedef void (*fw_iso_callback_t)(struct fw_iso_context *context,
+				  u32 cycle, size_t header_length,
+				  void *header, void *data);
+struct fw_iso_context {
+	struct fw_card *card;
+	int type;
+	int channel;
+	int speed;
+	size_t header_size;
+	fw_iso_callback_t callback;
+	void *callback_data;
+};
+
+struct fw_iso_context *fw_iso_context_create(struct fw_card *card,
+		int type, int channel, int speed, size_t header_size,
+		fw_iso_callback_t callback, void *callback_data);
+int fw_iso_context_queue(struct fw_iso_context *ctx,
+			 struct fw_iso_packet *packet,
+			 struct fw_iso_buffer *buffer,
+			 unsigned long payload);
+int fw_iso_context_start(struct fw_iso_context *ctx,
+			 int cycle, int sync, int tags);
+int fw_iso_context_stop(struct fw_iso_context *ctx);
+void fw_iso_context_destroy(struct fw_iso_context *ctx);
+
 #endif /* _LINUX_FIREWIRE_H */

commit 1e626fdcef61460dc75fe7377f38bb019722b848
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jun 14 13:23:58 2009 +0200

    firewire: core: use more outbound tlabels
    
    Tlabel is a 6 bits wide datum.  Wrap it after 63 rather than 31 for more
    safety against transaction label exhaustion and potential responders'
    transaction layer bugs.  (As noted by Guus Sliepen, this change requires
    an expansion of tlabel_mask to 64 bits.)
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index 610eade8abb4..e584b7215e8b 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -98,7 +98,8 @@ struct fw_card {
 
 	int node_id;
 	int generation;
-	int current_tlabel, tlabel_mask;
+	int current_tlabel;
+	u64 tlabel_mask;
 	struct list_head transaction_list;
 	struct timer_list flush_timer;
 	unsigned long reset_jiffies;

commit 837ec787d85fda8d73193a399ebcea0288e4765b
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Tue Jun 9 23:56:55 2009 +0200

    firewire: core: don't update Broadcast_Channel if RFC 2734 conditions aren't met
    
    This extra check will avoid Broadcast_Channel register related traffic
    to many IIDC, SBP-2, and AV/C devices which aren't IRMC or have a
    max_rec < 8 (i.e. support < 512 bytes async payload).  This avoids a
    little bit of traffic after bus reset and is even more careful with
    devices which don't implement this CSR.
    
    The assumption is that no other protocol than IP over 1394 uses the
    broadcast channel for streams.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index a69aea0394e3..610eade8abb4 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -191,7 +191,9 @@ struct fw_device {
 	size_t config_rom_length;
 	int config_rom_retries;
 	unsigned is_local:1;
+	unsigned max_rec:4;
 	unsigned cmc:1;
+	unsigned irmc:1;
 	unsigned bc_implemented:2;
 
 	struct delayed_work work;

commit e5110d011e03030926872457f05e49e3d5031737
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sat Jun 6 18:35:27 2009 +0200

    firewire: add parent-of-unit accessor
    
    Retrieval of an fw_unit's parent is a common pattern in high-level code.
    Wrap it up as device = fw_parent_device(unit).
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
index e979f9b22cb6..a69aea0394e3 100644
--- a/include/linux/firewire.h
+++ b/include/linux/firewire.h
@@ -248,6 +248,11 @@ static inline void fw_unit_put(struct fw_unit *unit)
 	put_device(&unit->device);
 }
 
+static inline struct fw_device *fw_parent_device(struct fw_unit *unit)
+{
+	return fw_device(unit->device.parent);
+}
+
 struct ieee1394_device_id;
 
 struct fw_driver {

commit 77c9a5daa9c4d9b37812c9c69c7bcbb3f9399c3c
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Fri Jun 5 16:26:18 2009 +0200

    firewire: reorganize header files
    
    The three header files of firewire-core, i.e.
     "drivers/firewire/fw-device.h",
     "drivers/firewire/fw-topology.h",
     "drivers/firewire/fw-transaction.h",
    are replaced by
     "drivers/firewire/core.h",
     "include/linux/firewire.h".
    
    The latter includes everything which a firewire high-level driver (like
    firewire-sbp2) needs besides linux/firewire-constants.h, while core.h
    contains the rest which is needed by firewire-core itself and by low-
    level drivers (card drivers) like firewire-ohci.
    
    High-level drivers can now also reside outside of drivers/firewire
    without having to add drivers/firewire to the header file search path in
    makefiles.  At least the firedtv driver will be such a driver.
    
    I also considered to spread the contents of core.h over several files,
    one for each .c file where the respective implementation resides.  But
    it turned out that most core .c files will end up including most of the
    core .h files.  Also, the combined core.h isn't unreasonably big, and it
    will lose more of its contents to linux/firewire.h anyway soon when more
    firewire drivers are added.  (IP-over-1394, firedtv, and there are plans
    for one or two more.)
    
    Furthermore, fw-ohci.h is renamed to ohci.h.  The name of core.h and
    ohci.h is chosen with regard to name changes of the .c files in a
    follow-up change.
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/include/linux/firewire.h b/include/linux/firewire.h
new file mode 100644
index 000000000000..e979f9b22cb6
--- /dev/null
+++ b/include/linux/firewire.h
@@ -0,0 +1,350 @@
+#ifndef _LINUX_FIREWIRE_H
+#define _LINUX_FIREWIRE_H
+
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+#include <asm/atomic.h>
+#include <asm/byteorder.h>
+
+#define fw_notify(s, args...) printk(KERN_NOTICE KBUILD_MODNAME ": " s, ## args)
+#define fw_error(s, args...) printk(KERN_ERR KBUILD_MODNAME ": " s, ## args)
+
+static inline void fw_memcpy_from_be32(void *_dst, void *_src, size_t size)
+{
+	u32    *dst = _dst;
+	__be32 *src = _src;
+	int i;
+
+	for (i = 0; i < size / 4; i++)
+		dst[i] = be32_to_cpu(src[i]);
+}
+
+static inline void fw_memcpy_to_be32(void *_dst, void *_src, size_t size)
+{
+	fw_memcpy_from_be32(_dst, _src, size);
+}
+#define CSR_REGISTER_BASE		0xfffff0000000ULL
+
+/* register offsets are relative to CSR_REGISTER_BASE */
+#define CSR_STATE_CLEAR			0x0
+#define CSR_STATE_SET			0x4
+#define CSR_NODE_IDS			0x8
+#define CSR_RESET_START			0xc
+#define CSR_SPLIT_TIMEOUT_HI		0x18
+#define CSR_SPLIT_TIMEOUT_LO		0x1c
+#define CSR_CYCLE_TIME			0x200
+#define CSR_BUS_TIME			0x204
+#define CSR_BUSY_TIMEOUT		0x210
+#define CSR_BUS_MANAGER_ID		0x21c
+#define CSR_BANDWIDTH_AVAILABLE		0x220
+#define CSR_CHANNELS_AVAILABLE		0x224
+#define CSR_CHANNELS_AVAILABLE_HI	0x224
+#define CSR_CHANNELS_AVAILABLE_LO	0x228
+#define CSR_BROADCAST_CHANNEL		0x234
+#define CSR_CONFIG_ROM			0x400
+#define CSR_CONFIG_ROM_END		0x800
+#define CSR_FCP_COMMAND			0xB00
+#define CSR_FCP_RESPONSE		0xD00
+#define CSR_FCP_END			0xF00
+#define CSR_TOPOLOGY_MAP		0x1000
+#define CSR_TOPOLOGY_MAP_END		0x1400
+#define CSR_SPEED_MAP			0x2000
+#define CSR_SPEED_MAP_END		0x3000
+
+#define CSR_OFFSET		0x40
+#define CSR_LEAF		0x80
+#define CSR_DIRECTORY		0xc0
+
+#define CSR_DESCRIPTOR		0x01
+#define CSR_VENDOR		0x03
+#define CSR_HARDWARE_VERSION	0x04
+#define CSR_NODE_CAPABILITIES	0x0c
+#define CSR_UNIT		0x11
+#define CSR_SPECIFIER_ID	0x12
+#define CSR_VERSION		0x13
+#define CSR_DEPENDENT_INFO	0x14
+#define CSR_MODEL		0x17
+#define CSR_INSTANCE		0x18
+#define CSR_DIRECTORY_ID	0x20
+
+struct fw_csr_iterator {
+	u32 *p;
+	u32 *end;
+};
+
+void fw_csr_iterator_init(struct fw_csr_iterator *ci, u32 *p);
+int fw_csr_iterator_next(struct fw_csr_iterator *ci, int *key, int *value);
+
+extern struct bus_type fw_bus_type;
+
+struct fw_card_driver;
+struct fw_node;
+
+struct fw_card {
+	const struct fw_card_driver *driver;
+	struct device *device;
+	struct kref kref;
+	struct completion done;
+
+	int node_id;
+	int generation;
+	int current_tlabel, tlabel_mask;
+	struct list_head transaction_list;
+	struct timer_list flush_timer;
+	unsigned long reset_jiffies;
+
+	unsigned long long guid;
+	unsigned max_receive;
+	int link_speed;
+	int config_rom_generation;
+
+	spinlock_t lock; /* Take this lock when handling the lists in
+			  * this struct. */
+	struct fw_node *local_node;
+	struct fw_node *root_node;
+	struct fw_node *irm_node;
+	u8 color; /* must be u8 to match the definition in struct fw_node */
+	int gap_count;
+	bool beta_repeaters_present;
+
+	int index;
+
+	struct list_head link;
+
+	/* Work struct for BM duties. */
+	struct delayed_work work;
+	int bm_retries;
+	int bm_generation;
+
+	bool broadcast_channel_allocated;
+	u32 broadcast_channel;
+	u32 topology_map[(CSR_TOPOLOGY_MAP_END - CSR_TOPOLOGY_MAP) / 4];
+};
+
+static inline struct fw_card *fw_card_get(struct fw_card *card)
+{
+	kref_get(&card->kref);
+
+	return card;
+}
+
+void fw_card_release(struct kref *kref);
+
+static inline void fw_card_put(struct fw_card *card)
+{
+	kref_put(&card->kref, fw_card_release);
+}
+
+struct fw_attribute_group {
+	struct attribute_group *groups[2];
+	struct attribute_group group;
+	struct attribute *attrs[12];
+};
+
+enum fw_device_state {
+	FW_DEVICE_INITIALIZING,
+	FW_DEVICE_RUNNING,
+	FW_DEVICE_GONE,
+	FW_DEVICE_SHUTDOWN,
+};
+
+/*
+ * Note, fw_device.generation always has to be read before fw_device.node_id.
+ * Use SMP memory barriers to ensure this.  Otherwise requests will be sent
+ * to an outdated node_id if the generation was updated in the meantime due
+ * to a bus reset.
+ *
+ * Likewise, fw-core will take care to update .node_id before .generation so
+ * that whenever fw_device.generation is current WRT the actual bus generation,
+ * fw_device.node_id is guaranteed to be current too.
+ *
+ * The same applies to fw_device.card->node_id vs. fw_device.generation.
+ *
+ * fw_device.config_rom and fw_device.config_rom_length may be accessed during
+ * the lifetime of any fw_unit belonging to the fw_device, before device_del()
+ * was called on the last fw_unit.  Alternatively, they may be accessed while
+ * holding fw_device_rwsem.
+ */
+struct fw_device {
+	atomic_t state;
+	struct fw_node *node;
+	int node_id;
+	int generation;
+	unsigned max_speed;
+	struct fw_card *card;
+	struct device device;
+
+	struct mutex client_list_mutex;
+	struct list_head client_list;
+
+	u32 *config_rom;
+	size_t config_rom_length;
+	int config_rom_retries;
+	unsigned is_local:1;
+	unsigned cmc:1;
+	unsigned bc_implemented:2;
+
+	struct delayed_work work;
+	struct fw_attribute_group attribute_group;
+};
+
+static inline struct fw_device *fw_device(struct device *dev)
+{
+	return container_of(dev, struct fw_device, device);
+}
+
+static inline int fw_device_is_shutdown(struct fw_device *device)
+{
+	return atomic_read(&device->state) == FW_DEVICE_SHUTDOWN;
+}
+
+static inline struct fw_device *fw_device_get(struct fw_device *device)
+{
+	get_device(&device->device);
+
+	return device;
+}
+
+static inline void fw_device_put(struct fw_device *device)
+{
+	put_device(&device->device);
+}
+
+int fw_device_enable_phys_dma(struct fw_device *device);
+
+/*
+ * fw_unit.directory must not be accessed after device_del(&fw_unit.device).
+ */
+struct fw_unit {
+	struct device device;
+	u32 *directory;
+	struct fw_attribute_group attribute_group;
+};
+
+static inline struct fw_unit *fw_unit(struct device *dev)
+{
+	return container_of(dev, struct fw_unit, device);
+}
+
+static inline struct fw_unit *fw_unit_get(struct fw_unit *unit)
+{
+	get_device(&unit->device);
+
+	return unit;
+}
+
+static inline void fw_unit_put(struct fw_unit *unit)
+{
+	put_device(&unit->device);
+}
+
+struct ieee1394_device_id;
+
+struct fw_driver {
+	struct device_driver driver;
+	/* Called when the parent device sits through a bus reset. */
+	void (*update)(struct fw_unit *unit);
+	const struct ieee1394_device_id *id_table;
+};
+
+struct fw_packet;
+struct fw_request;
+
+typedef void (*fw_packet_callback_t)(struct fw_packet *packet,
+				     struct fw_card *card, int status);
+typedef void (*fw_transaction_callback_t)(struct fw_card *card, int rcode,
+					  void *data, size_t length,
+					  void *callback_data);
+/*
+ * Important note:  The callback must guarantee that either fw_send_response()
+ * or kfree() is called on the @request.
+ */
+typedef void (*fw_address_callback_t)(struct fw_card *card,
+				      struct fw_request *request,
+				      int tcode, int destination, int source,
+				      int generation, int speed,
+				      unsigned long long offset,
+				      void *data, size_t length,
+				      void *callback_data);
+
+struct fw_packet {
+	int speed;
+	int generation;
+	u32 header[4];
+	size_t header_length;
+	void *payload;
+	size_t payload_length;
+	dma_addr_t payload_bus;
+	u32 timestamp;
+
+	/*
+	 * This callback is called when the packet transmission has
+	 * completed; for successful transmission, the status code is
+	 * the ack received from the destination, otherwise it's a
+	 * negative errno: ENOMEM, ESTALE, ETIMEDOUT, ENODEV, EIO.
+	 * The callback can be called from tasklet context and thus
+	 * must never block.
+	 */
+	fw_packet_callback_t callback;
+	int ack;
+	struct list_head link;
+	void *driver_data;
+};
+
+struct fw_transaction {
+	int node_id; /* The generation is implied; it is always the current. */
+	int tlabel;
+	int timestamp;
+	struct list_head link;
+
+	struct fw_packet packet;
+
+	/*
+	 * The data passed to the callback is valid only during the
+	 * callback.
+	 */
+	fw_transaction_callback_t callback;
+	void *callback_data;
+};
+
+struct fw_address_handler {
+	u64 offset;
+	size_t length;
+	fw_address_callback_t address_callback;
+	void *callback_data;
+	struct list_head link;
+};
+
+struct fw_address_region {
+	u64 start;
+	u64 end;
+};
+
+extern const struct fw_address_region fw_high_memory_region;
+
+int fw_core_add_address_handler(struct fw_address_handler *handler,
+				const struct fw_address_region *region);
+void fw_core_remove_address_handler(struct fw_address_handler *handler);
+void fw_send_response(struct fw_card *card,
+		      struct fw_request *request, int rcode);
+void fw_send_request(struct fw_card *card, struct fw_transaction *t,
+		     int tcode, int destination_id, int generation, int speed,
+		     unsigned long long offset, void *payload, size_t length,
+		     fw_transaction_callback_t callback, void *callback_data);
+int fw_cancel_transaction(struct fw_card *card,
+			  struct fw_transaction *transaction);
+int fw_run_transaction(struct fw_card *card, int tcode, int destination_id,
+		       int generation, int speed, unsigned long long offset,
+		       void *payload, size_t length);
+
+#endif /* _LINUX_FIREWIRE_H */
