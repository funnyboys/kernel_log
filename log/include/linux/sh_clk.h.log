commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 645896b81244..7bed5be886c6 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __SH_CLOCK_H
 #define __SH_CLOCK_H
 

commit 90069ad1b602d05740ed0fc5f72f09a616ceddd0
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Nov 19 19:32:07 2015 +0100

    drivers: sh: clk: Remove obsolete and unused clk_round_parent()
    
    clk_round_parent() was only ever used by AP4EVB, until commit
    b24bd7e97b3784af ("ARM: shmobile: Remove AP4EVB board support").
    
    The Common Clock Framework does not provide clk_round_parent(), hence
    remove it.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 1f208b2a1ed6..645896b81244 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -113,10 +113,6 @@ long clk_rate_div_range_round(struct clk *clk, unsigned int div_min,
 long clk_rate_mult_range_round(struct clk *clk, unsigned int mult_min,
 			       unsigned int mult_max, unsigned long rate);
 
-long clk_round_parent(struct clk *clk, unsigned long target,
-		      unsigned long *best_freq, unsigned long *parent_freq,
-		      unsigned int div_min, unsigned int div_max);
-
 #define SH_CLK_MSTP(_parent, _enable_reg, _enable_bit, _status_reg, _flags) \
 {									\
 	.parent		= _parent,					\

commit a028c6da34d434e35ba8322568c756ea97ff3c18
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Sat Dec 14 16:23:51 2013 +0100

    ARM: shmobile: wait for MSTP clock status to toggle, when enabling it
    
    On r-/sh-mobile SoCs MSTP clocks are used by the runtime PM to dynamically
    enable and disable peripheral clocks. To make sure the clock has really
    started we have to read back its status register until it confirms success.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski+renesas@gmail.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 60c72395ec6b..1f208b2a1ed6 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -52,6 +52,7 @@ struct clk {
 	unsigned long		flags;
 
 	void __iomem		*enable_reg;
+	void __iomem		*status_reg;
 	unsigned int		enable_bit;
 	void __iomem		*mapped_reg;
 
@@ -116,22 +117,26 @@ long clk_round_parent(struct clk *clk, unsigned long target,
 		      unsigned long *best_freq, unsigned long *parent_freq,
 		      unsigned int div_min, unsigned int div_max);
 
-#define SH_CLK_MSTP(_parent, _enable_reg, _enable_bit, _flags)		\
+#define SH_CLK_MSTP(_parent, _enable_reg, _enable_bit, _status_reg, _flags) \
 {									\
 	.parent		= _parent,					\
 	.enable_reg	= (void __iomem *)_enable_reg,			\
 	.enable_bit	= _enable_bit,					\
+	.status_reg	= _status_reg,					\
 	.flags		= _flags,					\
 }
 
-#define SH_CLK_MSTP32(_p, _r, _b, _f)					\
-	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_32BIT)
+#define SH_CLK_MSTP32(_p, _r, _b, _f)				\
+	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_32BIT)
 
-#define SH_CLK_MSTP16(_p, _r, _b, _f)					\
-	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_16BIT)
+#define SH_CLK_MSTP32_STS(_p, _r, _b, _s, _f)			\
+	SH_CLK_MSTP(_p, _r, _b, _s, _f | CLK_ENABLE_REG_32BIT)
 
-#define SH_CLK_MSTP8(_p, _r, _b, _f)					\
-	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_8BIT)
+#define SH_CLK_MSTP16(_p, _r, _b, _f)				\
+	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_16BIT)
+
+#define SH_CLK_MSTP8(_p, _r, _b, _f)				\
+	SH_CLK_MSTP(_p, _r, _b, 0, _f | CLK_ENABLE_REG_8BIT)
 
 int sh_clk_mstp_register(struct clk *clks, int nr);
 

commit 9d626eccb1de90a310f3fb9bc5e8803706be1a95
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 30 20:06:55 2012 -0700

    sh: clkfwk: add sh_clk_fsidiv_register()
    
    This patch adds sh_clk_fsidiv_register() to share FSI-DIV clock code
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Simon Horman <horms@verge.net.au>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 50910913b268..60c72395ec6b 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -199,4 +199,13 @@ int sh_clk_div6_reparent_register(struct clk *clks, int nr);
 #define CLKDEV_DEV_ID(_id, _clk) { .dev_id = _id, .clk = _clk }
 #define CLKDEV_ICK_ID(_cid, _did, _clk) { .con_id = _cid, .dev_id = _did, .clk = _clk }
 
+/* .enable_reg will be updated to .mapping on sh_clk_fsidiv_register() */
+#define SH_CLK_FSIDIV(_reg, _parent)		\
+{						\
+	.enable_reg = (void __iomem *)_reg,	\
+	.parent		= _parent,		\
+}
+
+int sh_clk_fsidiv_register(struct clk *clks, int nr);
+
 #endif /* __SH_CLOCK_H */

commit 764f4e4e33d18cde4dcaf8a0d860b749c6d6d08b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 25 16:34:48 2012 +0900

    sh: clkfwk: Use shared sh_clk_div_enable/disable().
    
    This introduces a new flag for clocks that need to have their divisor
    ratio set back to their initial mask at disable time to prevent
    interactivity problems with the clock stop bit (presently div6 only).
    With this in place it's possible to handle the corner case on top of the
    div4 op without any particular need for leaving things split out.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 35a04f19fb53..50910913b268 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -69,6 +69,8 @@ struct clk {
 #define CLK_ENABLE_REG_16BIT	BIT(2)
 #define CLK_ENABLE_REG_8BIT	BIT(3)
 
+#define CLK_MASK_DIV_ON_DISABLE	BIT(4)
+
 #define CLK_ENABLE_REG_MASK	(CLK_ENABLE_REG_32BIT | \
 				 CLK_ENABLE_REG_16BIT | \
 				 CLK_ENABLE_REG_8BIT)
@@ -173,7 +175,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 {								\
 	.enable_reg = (void __iomem *)_reg,			\
 	.enable_bit = 0, /* unused */				\
-	.flags = _flags,					\
+	.flags = _flags | CLK_MASK_DIV_ON_DISABLE,		\
 	.div_mask = SH_CLK_DIV6_MSK,				\
 	.parent_table = _parents,				\
 	.parent_num = _num_parents,				\
@@ -187,7 +189,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 	.enable_reg	= (void __iomem *)_reg,			\
 	.enable_bit	= 0,	/* unused */			\
 	.div_mask	= SH_CLK_DIV6_MSK,			\
-	.flags		= _flags,				\
+	.flags		= _flags | CLK_MASK_DIV_ON_DISABLE,	\
 }
 
 int sh_clk_div6_register(struct clk *clks, int nr);

commit 75f5f8a56e0fdf6d32b3ae9c44c10bc0acd3857c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 25 15:26:01 2012 +0900

    sh: clkfwk: Use shared sh_clk_div_recalc().
    
    This generalizes the div4 recalc routine for use by div6 and others, then
    makes it the default.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index d540b8153178..35a04f19fb53 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -172,6 +172,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 			_num_parents, _src_shift, _src_width)	\
 {								\
 	.enable_reg = (void __iomem *)_reg,			\
+	.enable_bit = 0, /* unused */				\
 	.flags = _flags,					\
 	.div_mask = SH_CLK_DIV6_MSK,				\
 	.parent_table = _parents,				\
@@ -184,6 +185,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 {								\
 	.parent		= _parent,				\
 	.enable_reg	= (void __iomem *)_reg,			\
+	.enable_bit	= 0,	/* unused */			\
 	.div_mask	= SH_CLK_DIV6_MSK,			\
 	.flags		= _flags,				\
 }

commit 1111cc1e8080b5ff46f5b945acb2f99d6176b2d1
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 25 15:21:43 2012 +0900

    sh: clkfwk: Introduce a div_mask for variable div types.
    
    This plugs in a div_mask for the clock and sets it up for the existing
    div6/4 cases. This will make it possible to support other div types, as
    well as share more div6/4 infrastructure.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 706b803df7b7..d540b8153178 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -30,6 +30,10 @@ struct sh_clk_ops {
 	long (*round_rate)(struct clk *clk, unsigned long rate);
 };
 
+#define SH_CLK_DIV_MSK(div)	((1 << (div)) - 1)
+#define SH_CLK_DIV4_MSK		SH_CLK_DIV_MSK(4)
+#define SH_CLK_DIV6_MSK		SH_CLK_DIV_MSK(6)
+
 struct clk {
 	struct list_head	node;
 	struct clk		*parent;
@@ -51,6 +55,7 @@ struct clk {
 	unsigned int		enable_bit;
 	void __iomem		*mapped_reg;
 
+	unsigned int		div_mask;
 	unsigned long		arch_flags;
 	void			*priv;
 	struct clk_mapping	*mapping;
@@ -145,6 +150,7 @@ static inline int __deprecated sh_clk_mstp32_register(struct clk *clks, int nr)
 	.enable_reg = (void __iomem *)_reg,			\
 	.enable_bit = _shift,					\
 	.arch_flags = _div_bitmap,				\
+	.div_mask = SH_CLK_DIV4_MSK,				\
 	.flags = _flags,					\
 }
 
@@ -167,6 +173,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 {								\
 	.enable_reg = (void __iomem *)_reg,			\
 	.flags = _flags,					\
+	.div_mask = SH_CLK_DIV6_MSK,				\
 	.parent_table = _parents,				\
 	.parent_num = _num_parents,				\
 	.src_shift = _src_shift,				\
@@ -177,6 +184,7 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 {								\
 	.parent		= _parent,				\
 	.enable_reg	= (void __iomem *)_reg,			\
+	.div_mask	= SH_CLK_DIV6_MSK,			\
 	.flags		= _flags,				\
 }
 

commit a60977a51333a8108f0574aa26094d66b7fedf34
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 25 14:59:26 2012 +0900

    sh: clkfwk: Move to common clk_div_table accessors for div4/div6.
    
    This plugs in a generic clk_div_table, based on the div4 version. div6 is
    then adopted to use it for encapsulating its div table, which permits us
    to start div6/4 unification, as well as preparation for other div types.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index c513b73cd7cb..706b803df7b7 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -18,7 +18,6 @@ struct clk_mapping {
 	struct kref		ref;
 };
 
-
 struct sh_clk_ops {
 #ifdef CONFIG_SH_CLK_CPG_LEGACY
 	void (*init)(struct clk *clk);
@@ -149,11 +148,13 @@ static inline int __deprecated sh_clk_mstp32_register(struct clk *clks, int nr)
 	.flags = _flags,					\
 }
 
-struct clk_div4_table {
+struct clk_div_table {
 	struct clk_div_mult_table *div_mult_table;
 	void (*kick)(struct clk *clk);
 };
 
+#define clk_div4_table clk_div_table
+
 int sh_clk_div4_register(struct clk *clks, int nr,
 			 struct clk_div4_table *table);
 int sh_clk_div4_enable_register(struct clk *clks, int nr,

commit 4d6ddb08acc48368c5b7ac431f9d00db7227d2ed
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 11 12:05:50 2012 +0900

    sh: clkfwk: Support variable size accesses for MSTP clocks.
    
    The bulk of the MSTP users require 32-bit access, but this isn't the case
    for some of the SH-2A parts, so add in some basic infrastructure to let
    the CPU define its required access size in preparation.
    
    Requested-by: Phil Edworthy <phil.edworthy@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 0a9d8f2ac519..c513b73cd7cb 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -59,7 +59,15 @@ struct clk {
 	unsigned int		nr_freqs;
 };
 
-#define CLK_ENABLE_ON_INIT	(1 << 0)
+#define CLK_ENABLE_ON_INIT	BIT(0)
+
+#define CLK_ENABLE_REG_32BIT	BIT(1)	/* default access size */
+#define CLK_ENABLE_REG_16BIT	BIT(2)
+#define CLK_ENABLE_REG_8BIT	BIT(3)
+
+#define CLK_ENABLE_REG_MASK	(CLK_ENABLE_REG_32BIT | \
+				 CLK_ENABLE_REG_16BIT | \
+				 CLK_ENABLE_REG_8BIT)
 
 /* drivers/sh/clk.c */
 unsigned long followparent_recalc(struct clk *);
@@ -102,7 +110,7 @@ long clk_round_parent(struct clk *clk, unsigned long target,
 		      unsigned long *best_freq, unsigned long *parent_freq,
 		      unsigned int div_min, unsigned int div_max);
 
-#define SH_CLK_MSTP32(_parent, _enable_reg, _enable_bit, _flags)	\
+#define SH_CLK_MSTP(_parent, _enable_reg, _enable_bit, _flags)		\
 {									\
 	.parent		= _parent,					\
 	.enable_reg	= (void __iomem *)_enable_reg,			\
@@ -110,7 +118,27 @@ long clk_round_parent(struct clk *clk, unsigned long target,
 	.flags		= _flags,					\
 }
 
-int sh_clk_mstp32_register(struct clk *clks, int nr);
+#define SH_CLK_MSTP32(_p, _r, _b, _f)					\
+	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_32BIT)
+
+#define SH_CLK_MSTP16(_p, _r, _b, _f)					\
+	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_16BIT)
+
+#define SH_CLK_MSTP8(_p, _r, _b, _f)					\
+	SH_CLK_MSTP(_p, _r, _b, _f | CLK_ENABLE_REG_8BIT)
+
+int sh_clk_mstp_register(struct clk *clks, int nr);
+
+/*
+ * MSTP registration never really cared about access size, despite the
+ * original enable/disable pairs assuming a 32-bit access. Clocks are
+ * responsible for defining their access sizes either directly or via the
+ * clock definition wrappers.
+ */
+static inline int __deprecated sh_clk_mstp32_register(struct clk *clks, int nr)
+{
+	return sh_clk_mstp_register(clks, nr);
+}
 
 #define SH_CLK_DIV4(_parent, _reg, _shift, _div_bitmap, _flags)	\
 {								\

commit 84c36ffd7c580e1a63d7284e318670b082260118
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 29 22:18:19 2012 +0900

    sh: remove clk_ops
    
    Now when all clk_ops have been renamed it is
    safe to rename clk_ops to sh_clk_ops.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 706c005cd4ba..0a9d8f2ac519 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -18,9 +18,8 @@ struct clk_mapping {
 	struct kref		ref;
 };
 
-#define sh_clk_ops clk_ops
 
-struct clk_ops {
+struct sh_clk_ops {
 #ifdef CONFIG_SH_CLK_CPG_LEGACY
 	void (*init)(struct clk *clk);
 #endif
@@ -39,7 +38,7 @@ struct clk {
 	unsigned short		parent_num;	/* choose between */
 	unsigned char		src_shift;	/* source clock field in the */
 	unsigned char		src_width;	/* configuration register */
-	struct clk_ops		*ops;
+	struct sh_clk_ops	*ops;
 
 	struct list_head	children;
 	struct list_head	sibling;	/* node for children */

commit e34828298ec542294f4b798606ee73e462d322f5
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 29 22:16:13 2012 +0900

    sh: introduce sh_clk_ops in parallel with clk_ops
    
    Introduce sh_clk_ops in parallel with clk_ops.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 54341d811685..706c005cd4ba 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -18,6 +18,8 @@ struct clk_mapping {
 	struct kref		ref;
 };
 
+#define sh_clk_ops clk_ops
+
 struct clk_ops {
 #ifdef CONFIG_SH_CLK_CPG_LEGACY
 	void (*init)(struct clk *clk);

commit eda2030a5b60bb818f062adacbcfb6fd2d366fb9
Author: Magnus Damm <damm@opensource.se>
Date:   Thu Dec 8 22:58:54 2011 +0900

    sh: extend clock struct with mapped_reg member
    
    Add a "mapped_reg" member to struct clk and use that
    to keep the ioremapped register based on enable_reg.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index e834304c0b6a..54341d811685 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -49,6 +49,7 @@ struct clk {
 
 	void __iomem		*enable_reg;
 	unsigned int		enable_bit;
+	void __iomem		*mapped_reg;
 
 	unsigned long		arch_flags;
 	void			*priv;

commit 56242a1fc595d158eddefbb4d6d76e82c2535f55
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 21 21:33:18 2011 -0800

    sh: clkfwk: setup clock parent from current register value
    
    Some clocks can select its parent clock by CPG register.
    But it might have been modified by boot-loader or something.
    This patch removed fixed initial parent clock,
    and setup it from their current register settings.
    It works on div6 reparent clocks for now.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index a20831cf336a..e834304c0b6a 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -131,10 +131,9 @@ int sh_clk_div4_enable_register(struct clk *clks, int nr,
 int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 			 struct clk_div4_table *table);
 
-#define SH_CLK_DIV6_EXT(_parent, _reg, _flags, _parents,	\
+#define SH_CLK_DIV6_EXT(_reg, _flags, _parents,			\
 			_num_parents, _src_shift, _src_width)	\
 {								\
-	.parent = _parent,					\
 	.enable_reg = (void __iomem *)_reg,			\
 	.flags = _flags,					\
 	.parent_table = _parents,				\
@@ -144,7 +143,11 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 }
 
 #define SH_CLK_DIV6(_parent, _reg, _flags)			\
-	SH_CLK_DIV6_EXT(_parent, _reg, _flags, NULL, 0, 0, 0)
+{								\
+	.parent		= _parent,				\
+	.enable_reg	= (void __iomem *)_reg,			\
+	.flags		= _flags,				\
+}
 
 int sh_clk_div6_register(struct clk *clks, int nr);
 int sh_clk_div6_reparent_register(struct clk *clks, int nr);

commit 79e7066415a8b12adbeacc41b3dc44423534b8be
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Nov 11 16:11:41 2011 +0900

    sh: clkfwk: Kill off remaining debugfs cruft.
    
    Now that all of the named string association with clocks has been
    migrated to clkdev lookups there's no meaningful named topology that can
    be constructed for a debugfs tree view. Get rid of the left over bits,
    and shrink struct clk a bit in the process.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 9237c299641c..a20831cf336a 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -52,7 +52,6 @@ struct clk {
 
 	unsigned long		arch_flags;
 	void			*priv;
-	struct dentry		*dentry;
 	struct clk_mapping	*mapping;
 	struct cpufreq_frequency_table *freq_table;
 	unsigned int		nr_freqs;

commit dd2c0ca1b153b555c09fd8e08f6842e12cf8e87b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 19 18:51:13 2011 -0700

    sh: clkfwk: add clk_rate_mult_range_round()
    
    This provides a clk_rate_mult_range_round() helper for use by some of the
    CPG PLL ranged multipliers, following the same approach as used by the
    div ranges.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 3ccf18648d0a..9237c299641c 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -94,6 +94,9 @@ int clk_rate_table_find(struct clk *clk,
 long clk_rate_div_range_round(struct clk *clk, unsigned int div_min,
 			      unsigned int div_max, unsigned long rate);
 
+long clk_rate_mult_range_round(struct clk *clk, unsigned int mult_min,
+			       unsigned int mult_max, unsigned long rate);
+
 long clk_round_parent(struct clk *clk, unsigned long target,
 		      unsigned long *best_freq, unsigned long *parent_freq,
 		      unsigned int div_min, unsigned int div_max);

commit 1522043bf73ef0e9e61dc512a0f3cdbec1cbf89f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 6 02:54:11 2011 +0000

    sh: move CLKDEV_xxx_ID macro to sh_clk.h
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 9a52f72527dc..3ccf18648d0a 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -147,4 +147,8 @@ int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 int sh_clk_div6_register(struct clk *clks, int nr);
 int sh_clk_div6_reparent_register(struct clk *clks, int nr);
 
+#define CLKDEV_CON_ID(_id, _clk) { .con_id = _id, .clk = _clk }
+#define CLKDEV_DEV_ID(_id, _clk) { .dev_id = _id, .clk = _clk }
+#define CLKDEV_ICK_ID(_cid, _did, _clk) { .con_id = _cid, .dev_id = _did, .clk = _clk }
+
 #endif /* __SH_CLOCK_H */

commit 549015c36baadc6e67861bba6e927259e34c4d59
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 15 18:48:25 2010 +0900

    sh: clkfwk: Disable init clk op for non-legacy clocks.
    
    Presently it's only legacy users that are using this clock op, guard it
    with an ifdef to ensure that no new users start using it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 038475a2092f..9a52f72527dc 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -19,7 +19,9 @@ struct clk_mapping {
 };
 
 struct clk_ops {
+#ifdef CONFIG_SH_CLK_CPG_LEGACY
 	void (*init)(struct clk *clk);
+#endif
 	int (*enable)(struct clk *clk);
 	void (*disable)(struct clk *clk);
 	unsigned long (*recalc)(struct clk *clk);

commit 35a96c739fd7624b8edff990a74b86b5a85342da
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 15 18:18:32 2010 +0900

    sh: clkfwk: Kill off now unused algo_id in set_rate op.
    
    Now that clk_set_rate_ex() is gone, there is also no way to get at rate
    setting algo id, which is now also completely unused. Kill it off before
    new clock ops start using it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 30885d928801..038475a2092f 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -23,7 +23,7 @@ struct clk_ops {
 	int (*enable)(struct clk *clk);
 	void (*disable)(struct clk *clk);
 	unsigned long (*recalc)(struct clk *clk);
-	int (*set_rate)(struct clk *clk, unsigned long rate, int algo_id);
+	int (*set_rate)(struct clk *clk, unsigned long rate);
 	int (*set_parent)(struct clk *clk, struct clk *parent);
 	long (*round_rate)(struct clk *clk, unsigned long rate);
 };

commit 9a1683d1dd14d6ed35d2884c6b79ff12fc6bef39
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 15 18:14:43 2010 +0900

    sh: clkfwk: Kill off unused clk_set_rate_ex().
    
    With the refactoring of the SH7722 clock framework some time ago this
    abstraction has become unecessary. Kill it off before anyone else gets
    the bright idea to start using it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index cea0c38e7a63..30885d928801 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -67,36 +67,6 @@ int clk_register(struct clk *);
 void clk_unregister(struct clk *);
 void clk_enable_init_clocks(void);
 
-/**
- * clk_set_rate_ex - set the clock rate for a clock source, with additional parameter
- * @clk: clock source
- * @rate: desired clock rate in Hz
- * @algo_id: algorithm id to be passed down to ops->set_rate
- *
- * Returns success (0) or negative errno.
- */
-int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id);
-
-enum clk_sh_algo_id {
-	NO_CHANGE = 0,
-
-	IUS_N1_N1,
-	IUS_322,
-	IUS_522,
-	IUS_N11,
-
-	SB_N1,
-
-	SB3_N1,
-	SB3_32,
-	SB3_43,
-	SB3_54,
-
-	BP_N1,
-
-	IP_N1,
-};
-
 struct clk_div_mult_table {
 	unsigned int *divisors;
 	unsigned int nr_divisors;

commit 6af26c6c99f01e810f9944543df810e320284aa3
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Nov 2 11:27:24 2010 +0000

    sh: add clk_round_parent() to optimize parent clock rate
    
    Sometimes it is possible and reasonable to adjust the parent clock rate to
    improve precision of the child clock, e.g., if the child clock has no siblings.
    clk_round_parent() is a new addition to the SH clock-framework API, that
    implements such an optimization for child clocks with divisors, taking all
    integer values in a range.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 4dca992f3093..cea0c38e7a63 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -122,6 +122,10 @@ int clk_rate_table_find(struct clk *clk,
 long clk_rate_div_range_round(struct clk *clk, unsigned int div_min,
 			      unsigned int div_max, unsigned long rate);
 
+long clk_round_parent(struct clk *clk, unsigned long target,
+		      unsigned long *best_freq, unsigned long *parent_freq,
+		      unsigned int div_min, unsigned int div_max);
+
 #define SH_CLK_MSTP32(_parent, _enable_reg, _enable_bit, _flags)	\
 {									\
 	.parent		= _parent,					\

commit 8e122db61c98debbc35e26dd29504958cbcf2cbb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 15 18:33:24 2010 +0900

    sh: clkfwk: Add a helper for rate rounding by divisor ranges.
    
    This adds a new clk_rate_div_range_round() for implementing rate rounding
    by divisor ranges. This can be used trivially by clocks that support
    arbitrary ranged divisors without the need for rate table construction.
    
    This should only be used by clocks that both have large divisor ranges in
    addition to clocks that will never be arbitrarily scaled, as the lack of
    a backing frequency table will prevent cpufreq from being able to do much
    of anything with them.
    
    Primarily intended for use as a ->recalc helper.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 49f6e9b6eda2..4dca992f3093 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -119,6 +119,9 @@ int clk_rate_table_find(struct clk *clk,
 			struct cpufreq_frequency_table *freq_table,
 			unsigned long rate);
 
+long clk_rate_div_range_round(struct clk *clk, unsigned int div_min,
+			      unsigned int div_max, unsigned long rate);
+
 #define SH_CLK_MSTP32(_parent, _enable_reg, _enable_bit, _flags)	\
 {									\
 	.parent		= _parent,					\

commit f586903d27e2503a3e7d427b3d665bbaf1b7f4d4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 15 18:17:35 2010 +0900

    sh: clkfwk: Abstract rate rounding helper.
    
    Presently the only assisted rate rounding is frequency table backed, but
    there are cases where it's impractical to use a frequency table for
    certain clocks (such as the FSIDIV case, which supports 65535 divisors),
    and we wish to reuse the same rate rounding algorithm.
    
    This breaks out the core of the rate rounding logic in to its own helper
    routine and shuffles the frequency table logic around, switching to using
    an iterator for the generic helper routine.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 8ae37707a4a4..49f6e9b6eda2 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -53,6 +53,7 @@ struct clk {
 	struct dentry		*dentry;
 	struct clk_mapping	*mapping;
 	struct cpufreq_frequency_table *freq_table;
+	unsigned int		nr_freqs;
 };
 
 #define CLK_ENABLE_ON_INIT	(1 << 0)

commit 28085bc5de19cad365bcff98e9c8785c397c7c36
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 15 16:46:37 2010 +0900

    sh: clkfwk: support clock remapping.
    
    This implements support for ioremapping of register windows that
    encapsulate clock control registers used by a struct clk, with
    transparent sibling inheritance.
    
    Root clocks at the top of a given topology often encapsulate the entire
    register space of all of their sibling clocks, so this mapping can be
    done once and handed down. A given clock enable/disable case maps out to
    a single bit in a shared register, so this prevents creating multiple
    overlapping mappings.
    
    The mapping case breaks down in to a couple of different situations:
    
            - Sibling clocks without a specific mapping.
            - Root clocks without a specific mapping.
            - Any of sibling/root clocks with a specific mapping.
    
    Sibling clocks with no specified mapping will grovel up the clock chain
    and install the root clock mapping unconditionally at registration time.
    
    Root clocks without their own mappings have a dummy BSS-initialized
    mapping inserted that is handed down the chain just like any other
    mapping. This permits all of the sibling clock ops to read/write using
    the mapping offsets without any special configuration, enabling them to
    not care whether access ultimately goes through translatable or
    untranslatable memory.
    
    Any clock with its own mapping will have the window initialized at
    registration time and be ready for use by its clock ops. Failure to
    establish the mapping will prevent registration, so no additional sanity
    checks are needed. Sibling clocks that double as parents for the moment
    will not propagate their mapping down, but this is easily tunable if the
    need arises.
    
    All clock mappings are kref refcounted, with each instance of mapping
    inheritance incrementing the refcount.
    
    Tested-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index ecdfea54a49e..8ae37707a4a4 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -4,11 +4,20 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include <linux/cpufreq.h>
+#include <linux/types.h>
+#include <linux/kref.h>
 #include <linux/clk.h>
 #include <linux/err.h>
 
 struct clk;
 
+struct clk_mapping {
+	phys_addr_t		phys;
+	void __iomem		*base;
+	unsigned long		len;
+	struct kref		ref;
+};
+
 struct clk_ops {
 	void (*init)(struct clk *clk);
 	int (*enable)(struct clk *clk);
@@ -42,6 +51,7 @@ struct clk {
 	unsigned long		arch_flags;
 	void			*priv;
 	struct dentry		*dentry;
+	struct clk_mapping	*mapping;
 	struct cpufreq_frequency_table *freq_table;
 };
 

commit 69395396a0a8866f30d59c66b7be1912ccb5d160
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Oct 13 07:44:36 2010 +0000

    sh: remove name and id from struct clk
    
    Remove "name" and "id" from drivers/sh/ struct clk.
    
    The struct clk members "name" and "id" are not used
    now when matching is done through clkdev.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 875ce50719a9..ecdfea54a49e 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -21,9 +21,6 @@ struct clk_ops {
 
 struct clk {
 	struct list_head	node;
-	const char		*name;
-	int			id;
-
 	struct clk		*parent;
 	struct clk		**parent_table;	/* list of parents to */
 	unsigned short		parent_num;	/* choose between */

commit b3dd51a8a6ce2e618e8a1be8fa0e7d3d4733c300
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jul 21 10:13:10 2010 +0000

    sh: add a reparent function to DIV6 clocks
    
    Add support for reparenting of div6 clocks on SuperH and SH-Mobile SoCs.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 08a07b9a894f..875ce50719a9 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -142,13 +142,22 @@ int sh_clk_div4_enable_register(struct clk *clks, int nr,
 int sh_clk_div4_reparent_register(struct clk *clks, int nr,
 			 struct clk_div4_table *table);
 
-#define SH_CLK_DIV6(_parent, _reg, _flags)	\
-{						\
-	.parent = _parent,			\
-	.enable_reg = (void __iomem *)_reg,	\
-	.flags = _flags,			\
+#define SH_CLK_DIV6_EXT(_parent, _reg, _flags, _parents,	\
+			_num_parents, _src_shift, _src_width)	\
+{								\
+	.parent = _parent,					\
+	.enable_reg = (void __iomem *)_reg,			\
+	.flags = _flags,					\
+	.parent_table = _parents,				\
+	.parent_num = _num_parents,				\
+	.src_shift = _src_shift,				\
+	.src_width = _src_width,				\
 }
 
+#define SH_CLK_DIV6(_parent, _reg, _flags)			\
+	SH_CLK_DIV6_EXT(_parent, _reg, _flags, NULL, 0, 0, 0)
+
 int sh_clk_div6_register(struct clk *clks, int nr);
+int sh_clk_div6_reparent_register(struct clk *clks, int nr);
 
 #endif /* __SH_CLOCK_H */

commit b5272b509a8570bb559156001e74ee162c5cb96a
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jul 21 10:13:06 2010 +0000

    sh: add a list of parent configurations to struct clk
    
    Many system clocks can select a parent by writing a value to a specific field
    in the configuration register. Add a list of parents and location and width of
    the source selection field in the clock configuration register to struct clk to
    assist in clk_set_parent() implementation.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 1636d1e2a5f1..08a07b9a894f 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -25,6 +25,10 @@ struct clk {
 	int			id;
 
 	struct clk		*parent;
+	struct clk		**parent_table;	/* list of parents to */
+	unsigned short		parent_num;	/* choose between */
+	unsigned char		src_shift;	/* source clock field in the */
+	unsigned char		src_width;	/* configuration register */
 	struct clk_ops		*ops;
 
 	struct list_head	children;

commit a71ba09655d197f22938fffa6f5d210ff5134f98
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 13 18:42:25 2010 +0900

    sh: fixup the docbook paths for clock framework shuffling.
    
    Now that the definitions have been consolidated in an alternate header,
    update the template accordingly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index 6d7de242be1d..1636d1e2a5f1 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -46,7 +46,7 @@ struct clk {
 
 #define CLK_ENABLE_ON_INIT	(1 << 0)
 
-/* arch/sh/kernel/cpu/clock.c */
+/* drivers/sh/clk.c */
 unsigned long followparent_recalc(struct clk *);
 void recalculate_root_clocks(void);
 void propagate_rate(struct clk *);
@@ -55,7 +55,6 @@ int clk_register(struct clk *);
 void clk_unregister(struct clk *);
 void clk_enable_init_clocks(void);
 
-/* the exported API, in addition to clk_set_rate */
 /**
  * clk_set_rate_ex - set the clock rate for a clock source, with additional parameter
  * @clk: clock source

commit 8b5ee113e1b97097e992a0301d0cac2530b31fc2
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 11 13:29:25 2010 +0000

    sh: move sh clock.c contents to drivers/sh/clk.
    
    This patch is V2 of the SH clock framework move from
    arch/sh/kernel/cpu/clock.c to drivers/sh/clk.c. All
    code except the following functions are moved:
    clk_init(), clk_get() and clk_put().
    
    The init function is still kept in clock.c since it
    depends on the SH-specific machvec implementation.
    
    The symbols clk_get() and clk_put() already exist in
    the common ARM clkdev code, those symbols are left in
    the SH tree to avoid duplicating them for SH-Mobile ARM.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
index de911451c216..6d7de242be1d 100644
--- a/include/linux/sh_clk.h
+++ b/include/linux/sh_clk.h
@@ -47,13 +47,13 @@ struct clk {
 #define CLK_ENABLE_ON_INIT	(1 << 0)
 
 /* arch/sh/kernel/cpu/clock.c */
-int clk_init(void);
 unsigned long followparent_recalc(struct clk *);
 void recalculate_root_clocks(void);
 void propagate_rate(struct clk *);
 int clk_reparent(struct clk *child, struct clk *parent);
 int clk_register(struct clk *);
 void clk_unregister(struct clk *);
+void clk_enable_init_clocks(void);
 
 /* the exported API, in addition to clk_set_rate */
 /**

commit d28bdf05f72238d626c8d06b61049f6df8d78e70
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 11 13:29:17 2010 +0000

    sh: move sh asm/clock.h contents to linux/sh_clk.h V2
    
    This patch is V2 of the clock framework move from
    arch/sh/include/asm/clock.h to include/linux/sh_clk.h
    and updates the include paths for files that will be
    shared between SH and SH-Mobile ARM.
    
    The file asm/clock.h is still kept in this version,
    this to depend on as few files as possible at this
    point. We keep SH specific stuff in there.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/sh_clk.h b/include/linux/sh_clk.h
new file mode 100644
index 000000000000..de911451c216
--- /dev/null
+++ b/include/linux/sh_clk.h
@@ -0,0 +1,151 @@
+#ifndef __SH_CLOCK_H
+#define __SH_CLOCK_H
+
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+struct clk;
+
+struct clk_ops {
+	void (*init)(struct clk *clk);
+	int (*enable)(struct clk *clk);
+	void (*disable)(struct clk *clk);
+	unsigned long (*recalc)(struct clk *clk);
+	int (*set_rate)(struct clk *clk, unsigned long rate, int algo_id);
+	int (*set_parent)(struct clk *clk, struct clk *parent);
+	long (*round_rate)(struct clk *clk, unsigned long rate);
+};
+
+struct clk {
+	struct list_head	node;
+	const char		*name;
+	int			id;
+
+	struct clk		*parent;
+	struct clk_ops		*ops;
+
+	struct list_head	children;
+	struct list_head	sibling;	/* node for children */
+
+	int			usecount;
+
+	unsigned long		rate;
+	unsigned long		flags;
+
+	void __iomem		*enable_reg;
+	unsigned int		enable_bit;
+
+	unsigned long		arch_flags;
+	void			*priv;
+	struct dentry		*dentry;
+	struct cpufreq_frequency_table *freq_table;
+};
+
+#define CLK_ENABLE_ON_INIT	(1 << 0)
+
+/* arch/sh/kernel/cpu/clock.c */
+int clk_init(void);
+unsigned long followparent_recalc(struct clk *);
+void recalculate_root_clocks(void);
+void propagate_rate(struct clk *);
+int clk_reparent(struct clk *child, struct clk *parent);
+int clk_register(struct clk *);
+void clk_unregister(struct clk *);
+
+/* the exported API, in addition to clk_set_rate */
+/**
+ * clk_set_rate_ex - set the clock rate for a clock source, with additional parameter
+ * @clk: clock source
+ * @rate: desired clock rate in Hz
+ * @algo_id: algorithm id to be passed down to ops->set_rate
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id);
+
+enum clk_sh_algo_id {
+	NO_CHANGE = 0,
+
+	IUS_N1_N1,
+	IUS_322,
+	IUS_522,
+	IUS_N11,
+
+	SB_N1,
+
+	SB3_N1,
+	SB3_32,
+	SB3_43,
+	SB3_54,
+
+	BP_N1,
+
+	IP_N1,
+};
+
+struct clk_div_mult_table {
+	unsigned int *divisors;
+	unsigned int nr_divisors;
+	unsigned int *multipliers;
+	unsigned int nr_multipliers;
+};
+
+struct cpufreq_frequency_table;
+void clk_rate_table_build(struct clk *clk,
+			  struct cpufreq_frequency_table *freq_table,
+			  int nr_freqs,
+			  struct clk_div_mult_table *src_table,
+			  unsigned long *bitmap);
+
+long clk_rate_table_round(struct clk *clk,
+			  struct cpufreq_frequency_table *freq_table,
+			  unsigned long rate);
+
+int clk_rate_table_find(struct clk *clk,
+			struct cpufreq_frequency_table *freq_table,
+			unsigned long rate);
+
+#define SH_CLK_MSTP32(_parent, _enable_reg, _enable_bit, _flags)	\
+{									\
+	.parent		= _parent,					\
+	.enable_reg	= (void __iomem *)_enable_reg,			\
+	.enable_bit	= _enable_bit,					\
+	.flags		= _flags,					\
+}
+
+int sh_clk_mstp32_register(struct clk *clks, int nr);
+
+#define SH_CLK_DIV4(_parent, _reg, _shift, _div_bitmap, _flags)	\
+{								\
+	.parent = _parent,					\
+	.enable_reg = (void __iomem *)_reg,			\
+	.enable_bit = _shift,					\
+	.arch_flags = _div_bitmap,				\
+	.flags = _flags,					\
+}
+
+struct clk_div4_table {
+	struct clk_div_mult_table *div_mult_table;
+	void (*kick)(struct clk *clk);
+};
+
+int sh_clk_div4_register(struct clk *clks, int nr,
+			 struct clk_div4_table *table);
+int sh_clk_div4_enable_register(struct clk *clks, int nr,
+			 struct clk_div4_table *table);
+int sh_clk_div4_reparent_register(struct clk *clks, int nr,
+			 struct clk_div4_table *table);
+
+#define SH_CLK_DIV6(_parent, _reg, _flags)	\
+{						\
+	.parent = _parent,			\
+	.enable_reg = (void __iomem *)_reg,	\
+	.flags = _flags,			\
+}
+
+int sh_clk_div6_register(struct clk *clks, int nr);
+
+#endif /* __SH_CLOCK_H */
