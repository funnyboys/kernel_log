commit 5c8f77a278737a6af44a892f0700d9aadb2b0de0
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu May 14 10:39:00 2020 +0200

    irqdomain: Make irq_domain_reset_irq_data() available to  non-hierarchical users
    
    irq_domain_reset_irq_data() doesn't modify the parent data, so it can be
    made available even if irq domain hierarchy is not being built. We'll
    subsequently use it in irq_sim code.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200514083901.23445-2-brgl@bgdev.pl

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 8d062e86d954..b37350c4fe37 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -450,6 +450,7 @@ extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
 				irq_hw_number_t hwirq, struct irq_chip *chip,
 				void *chip_data, irq_flow_handler_t handler,
 				void *handler_data, const char *handler_name);
+extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,
 			unsigned int flags, unsigned int size,
@@ -491,7 +492,6 @@ extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
 					 irq_hw_number_t hwirq,
 					 struct irq_chip *chip,
 					 void *chip_data);
-extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
 extern void irq_domain_free_irqs_common(struct irq_domain *domain,
 					unsigned int virq,
 					unsigned int nr_irqs);

commit 2546287c5fb363a0165933ae2181c92f03e701d0
Author: Zenghui Yu <yuzenghui@huawei.com>
Date:   Fri Feb 21 10:07:25 2020 +0800

    genirq/irqdomain: Make sure all irq domain flags are distinct
    
    This was noticed when printing debugfs for MSIs on my ARM64 server.  The
    new dstate IRQD_MSI_NOMASK_QUIRK came out surprisingly while it should only
    be the x86 stuff for the time being...
    
    The new MSI quirk flag uses the same bit as IRQ_DOMAIN_NAME_ALLOCATED which
    is oddly defined as bit 6 for no good reason.
    
    Switch it to the non used bit 1.
    
    Fixes: 6f1a4891a592 ("x86/apic/msi: Plug non-maskable MSI affinity race")
    Signed-off-by: Zenghui Yu <yuzenghui@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20200221020725.2038-1-yuzenghui@huawei.com

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index b2d47571ab67..8d062e86d954 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -192,7 +192,7 @@ enum {
 	IRQ_DOMAIN_FLAG_HIERARCHY	= (1 << 0),
 
 	/* Irq domain name was allocated in __irq_domain_add() */
-	IRQ_DOMAIN_NAME_ALLOCATED	= (1 << 6),
+	IRQ_DOMAIN_NAME_ALLOCATED	= (1 << 1),
 
 	/* Irq domain is an IPI domain with virq per cpu */
 	IRQ_DOMAIN_FLAG_IPI_PER_CPU	= (1 << 2),

commit 1a2a76c2685a29e46d7b37e752ccea7b15aa8e24
Merge: f41377609a72 0f378d73d429
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 9 12:11:12 2020 -0800

    Merge tag 'x86-urgent-2020-02-09' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 fixes from Thomas Gleixner:
     "A set of fixes for X86:
    
       - Ensure that the PIT is set up when the local APIC is disable or
         configured in legacy mode. This is caused by an ordering issue
         introduced in the recent changes which skip PIT initialization when
         the TSC and APIC frequencies are already known.
    
       - Handle malformed SRAT tables during early ACPI parsing which caused
         an infinite loop anda boot hang.
    
       - Fix a long standing race in the affinity setting code which affects
         PCI devices with non-maskable MSI interrupts. The problem is caused
         by the non-atomic writes of the MSI address (destination APIC id)
         and data (vector) fields which the device uses to construct the MSI
         message. The non-atomic writes are mandated by PCI.
    
         If both fields change and the device raises an interrupt after
         writing address and before writing data, then the MSI block
         constructs a inconsistent message which causes interrupts to be
         lost and subsequent malfunction of the device.
    
         The fix is to redirect the interrupt to the new vector on the
         current CPU first and then switch it over to the new target CPU.
         This allows to observe an eventually raised interrupt in the
         transitional stage (old CPU, new vector) to be observed in the APIC
         IRR and retriggered on the new target CPU and the new vector.
    
         The potential spurious interrupts caused by this are harmless and
         can in the worst case expose a buggy driver (all handlers have to
         be able to deal with spurious interrupts as they can and do happen
         for various reasons).
    
       - Add the missing suspend/resume mechanism for the HYPERV hypercall
         page which prevents resume hibernation on HYPERV guests. This
         change got lost before the merge window.
    
       - Mask the IOAPIC before disabling the local APIC to prevent
         potentially stale IOAPIC remote IRR bits which cause stale
         interrupt lines after resume"
    
    * tag 'x86-urgent-2020-02-09' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/apic: Mask IOAPIC entries when disabling the local APIC
      x86/hyperv: Suspend/resume the hypercall page for hibernation
      x86/apic/msi: Plug non-maskable MSI affinity race
      x86/boot: Handle malformed SRAT tables during early ACPI parsing
      x86/timer: Don't skip PIT setup when APIC is disabled or in legacy mode

commit 6f1a4891a5928a5969c87fa5a584844c983ec823
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 31 15:26:52 2020 +0100

    x86/apic/msi: Plug non-maskable MSI affinity race
    
    Evan tracked down a subtle race between the update of the MSI message and
    the device raising an interrupt internally on PCI devices which do not
    support MSI masking. The update of the MSI message is non-atomic and
    consists of either 2 or 3 sequential 32bit wide writes to the PCI config
    space.
    
       - Write address low 32bits
       - Write address high 32bits (If supported by device)
       - Write data
    
    When an interrupt is migrated then both address and data might change, so
    the kernel attempts to mask the MSI interrupt first. But for MSI masking is
    optional, so there exist devices which do not provide it. That means that
    if the device raises an interrupt internally between the writes then a MSI
    message is sent built from half updated state.
    
    On x86 this can lead to spurious interrupts on the wrong interrupt
    vector when the affinity setting changes both address and data. As a
    consequence the device interrupt can be lost causing the device to
    become stuck or malfunctioning.
    
    Evan tried to handle that by disabling MSI accross an MSI message
    update. That's not feasible because disabling MSI has issues on its own:
    
     If MSI is disabled the PCI device is routing an interrupt to the legacy
     INTx mechanism. The INTx delivery can be disabled, but the disablement is
     not working on all devices.
    
     Some devices lose interrupts when both MSI and INTx delivery are disabled.
    
    Another way to solve this would be to enforce the allocation of the same
    vector on all CPUs in the system for this kind of screwed devices. That
    could be done, but it would bring back the vector space exhaustion problems
    which got solved a few years ago.
    
    Fortunately the high address (if supported by the device) is only relevant
    when X2APIC is enabled which implies interrupt remapping. In the interrupt
    remapping case the affinity setting is happening at the interrupt remapping
    unit and the PCI MSI message is programmed only once when the PCI device is
    initialized.
    
    That makes it possible to solve it with a two step update:
    
      1) Target the MSI msg to the new vector on the current target CPU
    
      2) Target the MSI msg to the new vector on the new target CPU
    
    In both cases writing the MSI message is only changing a single 32bit word
    which prevents the issue of inconsistency.
    
    After writing the final destination it is necessary to check whether the
    device issued an interrupt while the intermediate state #1 (new vector,
    current CPU) was in effect.
    
    This is possible because the affinity change is always happening on the
    current target CPU. The code runs with interrupts disabled, so the
    interrupt can be detected by checking the IRR of the local APIC. If the
    vector is pending in the IRR then the interrupt is retriggered on the new
    target CPU by sending an IPI for the associated vector on the target CPU.
    
    This can cause spurious interrupts on both the local and the new target
    CPU.
    
     1) If the new vector is not in use on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then interrupt entry code will
        ignore that spurious interrupt. The vector is marked so that the
        'No irq handler for vector' warning is supressed once.
    
     2) If the new vector is in use already on the local CPU then the IRR check
        might see an pending interrupt from the device which is using this
        vector. The IPI to the new target CPU will then invoke the handler of
        the device, which got the affinity change, even if that device did not
        issue an interrupt
    
     3) If the new vector is in use already on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then the handler of the device which
        uses that vector on the local CPU will be invoked.
    
    expose issues in device driver interrupt handlers which are not prepared to
    handle a spurious interrupt correctly. This not a regression, it's just
    exposing something which was already broken as spurious interrupts can
    happen for a lot of reasons and all driver handlers need to be able to deal
    with them.
    
    Reported-by: Evan Green <evgreen@chromium.org>
    Debugged-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/87imkr4s7n.fsf@nanos.tec.linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 3c340dbc5a1f..4da8df57618a 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -206,6 +206,13 @@ enum {
 	/* Irq domain implements MSI remapping */
 	IRQ_DOMAIN_FLAG_MSI_REMAP	= (1 << 5),
 
+	/*
+	 * Quirk to handle MSI implementations which do not provide
+	 * masking. Currently known to affect x86, but partially
+	 * handled in core code.
+	 */
+	IRQ_DOMAIN_MSI_NOMASK_QUIRK	= (1 << 6),
+
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the

commit b01ecceaf2c0c4b3f2d24aa0adcf096ab1648253
Author: Yash Shah <yash.shah@sifive.com>
Date:   Tue Dec 10 16:41:09 2019 +0530

    genirq: Introduce irq_domain_translate_onecell
    
    Add a new function irq_domain_translate_onecell() that is to be used as
    the translate function in struct irq_domain_ops.
    
    Signed-off-by: Yash Shah <yash.shah@sifive.com>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Link: https://lore.kernel.org/r/1575976274-13487-2-git-send-email-yash.shah@sifive.com

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 3c340dbc5a1f..698749f42ced 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -427,6 +427,11 @@ int irq_domain_translate_twocell(struct irq_domain *d,
 				 unsigned long *out_hwirq,
 				 unsigned int *out_type);
 
+int irq_domain_translate_onecell(struct irq_domain *d,
+				 struct irq_fwspec *fwspec,
+				 unsigned long *out_hwirq,
+				 unsigned int *out_type);
+
 /* IPI functions */
 int irq_reserve_ipi(struct irq_domain *domain, const struct cpumask *dest);
 int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);

commit d46bca2b5d06cbb5f3e66945080f275bcfab7181
Author: Lina Iyer <ilina@codeaurora.org>
Date:   Fri Nov 15 15:11:44 2019 -0700

    irqdomain: Add bus token DOMAIN_BUS_WAKEUP
    
    A single controller can handle normal interrupts and wake-up interrupts
    independently, with a different numbering space. It is thus crucial to
    allow the driver for such a controller discriminate between the two.
    
    A simple way to do so is to tag the wake-up irqdomain with a "bus token"
    that indicates the wake-up domain. This slightly abuses the notion of
    bus, but also radically simplifies the design of such a driver. Between
    two evils, we choose the least damaging.
    
    Suggested-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1573855915-9841-2-git-send-email-ilina@codeaurora.org

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 583e7abd07f9..3c340dbc5a1f 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -83,6 +83,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_IPI,
 	DOMAIN_BUS_FSL_MC_MSI,
 	DOMAIN_BUS_TI_SCI_INTA_MSI,
+	DOMAIN_BUS_WAKEUP,
 };
 
 /**

commit b977fcf477c176e5f41775f0ea139f935b0f25b7
Author: Marc Zyngier <maz@kernel.org>
Date:   Wed Jul 31 15:13:19 2019 +0100

    irqdomain/debugfs: Use PAs to generate fwnode names
    
    Booting a large arm64 server (HiSi D05) leads to the following
    shouting at boot time:
    
    [   20.722132] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.730851] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.739560] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.748267] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.756975] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.765683] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    [   20.774391] debugfs: File 'irqchip@(____ptrval____)-3' in directory 'domains' already present!
    
    and many more... Evidently, we expect something a bit more informative
    than ____ptrval____, and certainly we want all of our domains, not just
    the first one.
    
    For that, turn the %p used to generate the fwnode name into something
    that won't be repainted (%pa). Given that we've now fixed all users to
    pass a pointer to a PA, it will actually do the right thing.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marc Zyngier <maz@kernel.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 07ec8b390161..583e7abd07f9 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -220,7 +220,7 @@ static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
 
 #ifdef CONFIG_IRQ_DOMAIN
 struct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,
-						const char *name, void *data);
+						const char *name, phys_addr_t *pa);
 
 enum {
 	IRQCHIP_FWNODE_REAL,
@@ -241,9 +241,9 @@ struct fwnode_handle *irq_domain_alloc_named_id_fwnode(const char *name, int id)
 					 NULL);
 }
 
-static inline struct fwnode_handle *irq_domain_alloc_fwnode(void *data)
+static inline struct fwnode_handle *irq_domain_alloc_fwnode(phys_addr_t *pa)
 {
-	return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_REAL, 0, NULL, data);
+	return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_REAL, 0, NULL, pa);
 }
 
 void irq_domain_free_fwnode(struct fwnode_handle *fwnode);

commit 49b323157bf1e70bfb3114a463d340399906c43a
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Tue Apr 30 15:42:28 2019 +0530

    soc: ti: Add MSI domain bus support for Interrupt Aggregator
    
    With the system coprocessor managing the range allocation of the
    inputs to Interrupt Aggregator, it is difficult to represent
    the device IRQs from DT.
    
    The suggestion is to use MSI in such cases where devices wants
    to allocate and group interrupts dynamically.
    
    Create a MSI domain bus layer that allocates and frees MSIs for
    a device.
    
    APIs that are implemented:
    - ti_sci_inta_msi_create_irq_domain() that creates a MSI domain
    - ti_sci_inta_msi_domain_alloc_irqs() that creates MSIs for the
      specified device and resource.
    - ti_sci_inta_msi_domain_free_irqs() frees the irqs attached to the device.
    - ti_sci_inta_msi_get_virq() for getting the virq attached to a specific event.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 61706b430907..07ec8b390161 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -82,6 +82,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_NEXUS,
 	DOMAIN_BUS_IPI,
 	DOMAIN_BUS_FSL_MC_MSI,
+	DOMAIN_BUS_TI_SCI_INTA_MSI,
 };
 
 /**

commit 3601fe43e8164f67a8de3de8e988bfcb3a94af46
Merge: cf2e8c544cd3 d01849f7deba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 10:09:53 2019 -0800

    Merge tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v5.1 cycle:
    
      Core changes:
    
       - The big change this time around is the irqchip handling in the
         qualcomm pin controllers, closely coupled with the gpiochip. This
         rework, in a classic fall-between-the-chairs fashion has been
         sidestepped for too long.
    
         The Qualcomm IRQchips using the SPMI and SSBI transport mechanisms
         have been rewritten to use hierarchical irqchip. This creates the
         base from which I intend to gradually pull support for hierarchical
         irqchips into the gpiolib irqchip helpers to cut down on duplicate
         code.
    
         We have too many hacks in the kernel because people have been
         working around the missing hierarchical irqchip for years, and once
         it was there, noone understood it for a while. We are now slowly
         adapting to using it.
    
         This is why this pull requests include changes to MFD, SPMI,
         IRQchip core and some ARM Device Trees pertaining to the Qualcomm
         chip family. Since Qualcomm have so many chips and such large
         deployments it is paramount that this platform gets this right, and
         now it (hopefully) does.
    
       - Core support for pull-up and pull-down configuration, also from the
         device tree. When a simple GPIO chip supports an "off or on" pull-up
         or pull-down resistor, we provide a way to set this up using
         machine descriptors or device tree.
    
         If more elaborate control of pull up/down (such as resistance shunt
         setting) is required, drivers should be phased over to use pin
         control. We do not yet provide a userspace ABI for this pull
         up-down setting but I suspect the makers are going to ask for it
         soon enough. PCA953x is the first user of this new API.
    
       - The GPIO mockup driver has been revamped after some discussion
         improving the IRQ simulator in the process.
    
         The idea is to make it possible to use the mockup for both testing
         and virtual prototyping, e.g. when you do not yet have a GPIO
         expander to play with but really want to get something to develop
         code around before hardware is available. It's neat. The blackbox
         testing usecase is currently making its way into kernelci.
    
       - ACPI GPIO core preserves non direction flags when updating flags.
    
       - A new device core helper for devm_platform_ioremap_resource() is
         funneled through the GPIO tree with Greg's ACK.
    
      New drivers:
    
       - TQ-Systems QTMX86 GPIO controllers (using port-mapped I/O)
    
       - Gateworks PLD GPIO driver (vaccumed up from OpenWrt)
    
       - AMD G-Series PCH (Platform Controller Hub) GPIO driver.
    
       - Fintek F81804 & F81966 subvariants.
    
       - PCA953x now supports NXP PCAL6416.
    
      Driver improvements:
    
       - IRQ support on the Nintendo Wii (Hollywood) GPIO.
    
       - get_direction() support for the MVEBU driver.
    
       - Set the right output level on SAMA5D2.
    
       - Drop the unused irq trigger setting on the Spreadtrum driver.
    
       - Wakeup support for PCA953x.
    
       - A slew of cleanups in the various Intel drivers"
    
    * tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (110 commits)
      gpio: gpio-omap: fix level interrupt idling
      gpio: amd-fch: Set proper output level for direction_output
      x86: apuv2: remove unused variable
      gpio: pca953x: Use PCA_LATCH_INT
      platform/x86: fix PCENGINES_APU2 Kconfig warning
      gpio: pca953x: Fix dereference of irq data in shutdown
      gpio: amd-fch: Fix type error found by sparse
      gpio: amd-fch: Drop const from resource
      gpio: mxc: add check to return defer probe if clock tree NOT ready
      gpio: ftgpio: Register per-instance irqchip
      gpio: ixp4xx: Add DT bindings
      x86: pcengines apuv2 gpio/leds/keys platform driver
      gpio: AMD G-Series PCH gpio driver
      drivers: depend on HAS_IOMEM for devm_platform_ioremap_resource()
      gpio: tqmx86: Set proper output level for direction_output
      gpio: sprd: Change to use SoC compatible string
      gpio: sprd: Use SoC compatible string instead of wildcard string
      gpio: of: Handle both enable-gpio{,s}
      gpio: of: Restrict enable-gpio quirk to regulator-gpio
      gpio: davinci: use devm_platform_ioremap_resource()
      ...

commit 9f199dd34ce06f603df365ab18bd84eefc5f7c2b
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Feb 20 08:59:23 2019 +0000

    irqdomain: Allow the default irq domain to be retrieved
    
    The default irq domain allows legacy code to create irqdomain
    mappings without having to track the domain it is allocating
    from. Setting the default domain is a one shot, fire and forget
    operation, and no effort was made to be able to retrieve this
    information at a later point in time.
    
    Newer irqdomain APIs (the hierarchical stuff) relies on both
    the irqchip code to track the irqdomain it is allocating from,
    as well as some form of firmware abstraction to easily identify
    which piece of HW maps to which irq domain (DT, ACPI).
    
    For systems without such firmware (or legacy platform that are
    getting dragged into the 21st century), things are a bit harder.
    For these cases (and these cases only!), let's provide a way
    to retrieve the default domain, allowing the use of the v2 API
    without having to resort to platform-specific hacks.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 35965f41d7be..d2130dc7c0e6 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -265,6 +265,7 @@ extern struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,
 						   enum irq_domain_bus_token bus_token);
 extern bool irq_domain_check_msi_remap(void);
 extern void irq_set_default_host(struct irq_domain *host);
+extern struct irq_domain *irq_get_default_host(void);
 extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
 				  irq_hw_number_t hwirq, int node,
 				  const struct irq_affinity_desc *affinity);

commit b5c231d8c8037f63d34199ea1667bbe1cd9f940f
Author: Brian Masney <masneyb@onstation.org>
Date:   Thu Feb 7 21:16:22 2019 -0500

    genirq: introduce irq_domain_translate_twocell
    
    Add a new function irq_domain_translate_twocell() that is to be used as
    the translate function in struct irq_domain_ops for the v2 IRQ API.
    
    This patch also changes irq_domain_xlate_twocell() from the v1 IRQ API
    to call irq_domain_translate_twocell() in the v2 IRQ API. This required
    changes to of_phandle_args_to_fwspec()'s arguments so that it can be
    called from multiple places.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 35965f41d7be..fcefe0c7263f 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -419,6 +419,11 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 			const u32 *intspec, unsigned int intsize,
 			irq_hw_number_t *out_hwirq, unsigned int *out_type);
 
+int irq_domain_translate_twocell(struct irq_domain *d,
+				 struct irq_fwspec *fwspec,
+				 unsigned long *out_hwirq,
+				 unsigned int *out_type);
+
 /* IPI functions */
 int irq_reserve_ipi(struct irq_domain *domain, const struct cpumask *dest);
 int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);

commit bec04037e4e484f41ee4d9409e40616874169d20
Author: Dou Liyang <douliyangs@gmail.com>
Date:   Tue Dec 4 23:51:20 2018 +0800

    genirq/core: Introduce struct irq_affinity_desc
    
    The interrupt affinity management uses straight cpumask pointers to convey
    the automatically assigned affinity masks for managed interrupts. The core
    interrupt descriptor allocation also decides based on the pointer being non
    NULL whether an interrupt is managed or not.
    
    Devices which use managed interrupts usually have two classes of
    interrupts:
    
      - Interrupts for multiple device queues
      - Interrupts for general device management
    
    Currently both classes are treated the same way, i.e. as managed
    interrupts. The general interrupts get the default affinity mask assigned
    while the device queue interrupts are spread out over the possible CPUs.
    
    Treating the general interrupts as managed is both a limitation and under
    certain circumstances a bug. Assume the following situation:
    
     default_irq_affinity = 4..7
    
    So if CPUs 4-7 are offlined, then the core code will shut down the device
    management interrupts because the last CPU in their affinity mask went
    offline.
    
    It's also a limitation because it's desired to allow manual placement of
    the general device interrupts for various reasons. If they are marked
    managed then the interrupt affinity setting from both user and kernel space
    is disabled.
    
    To remedy that situation it's required to convey more information than the
    cpumasks through various interfaces related to interrupt descriptor
    allocation.
    
    Instead of adding yet another argument, create a new data structure
    'irq_affinity_desc' which for now just contains the cpumask. This struct
    can be expanded to convey auxilliary information in the next step.
    
    No functional change, just preparatory work.
    
    [ tglx: Simplified logic and clarified changelog ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Dou Liyang <douliyangs@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: kashyap.desai@broadcom.com
    Cc: shivasharan.srikanteshwara@broadcom.com
    Cc: sumit.saxena@broadcom.com
    Cc: ming.lei@redhat.com
    Cc: hch@lst.de
    Cc: douliyang1@huawei.com
    Link: https://lkml.kernel.org/r/20181204155122.6327-2-douliyangs@gmail.com

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 068aa46f0d55..35965f41d7be 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -43,6 +43,7 @@ struct irq_chip;
 struct irq_data;
 struct cpumask;
 struct seq_file;
+struct irq_affinity_desc;
 
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
@@ -266,7 +267,7 @@ extern bool irq_domain_check_msi_remap(void);
 extern void irq_set_default_host(struct irq_domain *host);
 extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
 				  irq_hw_number_t hwirq, int node,
-				  const struct cpumask *affinity);
+				  const struct irq_affinity_desc *affinity);
 
 static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
 {
@@ -449,7 +450,8 @@ static inline struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *par
 
 extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
-				   bool realloc, const struct cpumask *affinity);
+				   bool realloc,
+				   const struct irq_affinity_desc *affinity);
 extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
 extern int irq_domain_activate_irq(struct irq_data *irq_data, bool early);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);

commit 61ce8d8d8a8168a714de80fc31b3d6ac160fc5b0
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Mon Oct 1 16:13:51 2018 +0200

    irqchip/irq-mvebu-sei: Add new driver for Marvell SEI
    
    This is a cascaded interrupt controller in the AP806 GIC that collapses
    SEIs (System Error Interrupt) coming from the AP and the CPs (through
    the ICU).
    
    The SEI handles up to 64 interrupts. The first 21 interrupts are wired
    from the AP. The next 43 interrupts are from the CPs and are triggered
    through MSI messages. To handle this complexity, the driver has to
    declare to the upper layer: one IRQ domain for the wired interrupts,
    one IRQ domain for the MSIs; and acts as a MSI controller ('parent')
    by declaring an MSI domain.
    
    Suggested-by: Haim Boot <hayim@marvell.com>
    Suggested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index dccfa65aee96..068aa46f0d55 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -75,6 +75,7 @@ struct irq_fwspec {
 enum irq_domain_bus_token {
 	DOMAIN_BUS_ANY		= 0,
 	DOMAIN_BUS_WIRED,
+	DOMAIN_BUS_GENERIC_MSI,
 	DOMAIN_BUS_PCI_MSI,
 	DOMAIN_BUS_PLATFORM_MSI,
 	DOMAIN_BUS_NEXUS,

commit 6461934371bfc1bfe6b424b197a546b4effd0a32
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue May 8 13:14:34 2018 +0100

    irqdomain: Let irq_find_host default to DOMAIN_BUS_WIRED
    
    At the beginning of times, irq_find_host() was simple. Each device node
    implemented at most one irq domain, and we were happy. Over time, things
    have become more complex, and we now have nodes implementing a plurality
    of domains, tagged by "bus_token".
    
    Crutially, users of irq_find_host() all expect the most basic domain
    to be returned, and not any other domain such as a bus-specific MSI
    domain.
    
    So let's change irq_find_host() to first look for a DOMAIN_BUS_WIRED
    domain, and only if this fails fallback to DOMAIN_BUS_ANY. Note that
    this is consistent with what irq_create_fwspec_mapping is already
    doing, see 530cbe100ef7 ("irqdomain: Allow domain lookup with
    DOMAIN_BUS_WIRED token").
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20180508121438.11301-6-marc.zyngier@arm.com

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 48c7e86bb556..dccfa65aee96 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -301,7 +301,13 @@ static inline struct irq_domain *irq_find_matching_host(struct device_node *node
 
 static inline struct irq_domain *irq_find_host(struct device_node *node)
 {
-	return irq_find_matching_host(node, DOMAIN_BUS_ANY);
+	struct irq_domain *d;
+
+	d = irq_find_matching_host(node, DOMAIN_BUS_WIRED);
+	if (!d)
+		d = irq_find_matching_host(node, DOMAIN_BUS_ANY);
+
+	return d;
 }
 
 /**

commit 702cb0a02813299d6911b775c637906ae21b737d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 29 16:59:06 2017 +0100

    genirq/irqdomain: Rename early argument of irq_domain_activate_irq()
    
    The 'early' argument of irq_domain_activate_irq() is actually used to
    denote reservation mode. To avoid confusion, rename it before abuse
    happens.
    
    No functional change.
    
    Fixes: 72491643469a ("genirq/irqdomain: Update irq_domain_ops.activate() signature")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alexandru Chirvasitu <achirvasub@gmail.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Mikael Pettersson <mikpelinux@gmail.com>
    Cc: Josh Poulson <jopoulso@microsoft.com>
    Cc: Mihai Costache <v-micos@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-pci@vger.kernel.org
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Dexuan Cui <decui@microsoft.com>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Saeed Mahameed <saeedm@mellanox.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: devel@linuxdriverproject.org
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Sakari Ailus <sakari.ailus@intel.com>,
    Cc: linux-media@vger.kernel.org

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index a34355d19546..48c7e86bb556 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -113,7 +113,7 @@ struct irq_domain_ops {
 		     unsigned int nr_irqs, void *arg);
 	void (*free)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs);
-	int (*activate)(struct irq_domain *d, struct irq_data *irqd, bool early);
+	int (*activate)(struct irq_domain *d, struct irq_data *irqd, bool reserve);
 	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
 	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
 			 unsigned long *out_hwirq, unsigned int *out_type);

commit 670310dfbae0eefe7318ff6a61e29e67a7a7bbce
Merge: 43ff2f4db9d0 ffc661c99f62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:33:11 2017 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq core updates from Thomas Gleixner:
     "A rather large update for the interrupt core code and the irq chip drivers:
    
       - Add a new bitmap matrix allocator and supporting changes, which is
         used to replace the x86 vector allocator which comes with separate
         pull request. This allows to replace the convoluted nested loop
         allocation function in x86 with a facility which supports the
         recently added property of managed interrupts proper and allows to
         switch to a best effort vector reservation scheme, which addresses
         problems with vector exhaustion.
    
       - A large update to the ARM GIC-V3-ITS driver adding support for
         range selectors.
    
       - New interrupt controllers:
           - Meson and Meson8 GPIO
           - BCM7271 L2
           - Socionext EXIU
    
         If you expected that this will stop at some point, I have to
         disappoint you. There are new ones posted already. Sigh!
    
       - STM32 interrupt controller support for new platforms.
    
       - A pile of fixes, cleanups and updates to the MIPS GIC driver
    
       - The usual small fixes, cleanups and updates all over the place.
         Most visible one is to move the irq chip drivers Kconfig switches
         into a separate Kconfig menu"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (70 commits)
      genirq: Fix type of shifting literal 1 in __setup_irq()
      irqdomain: Drop pointless NULL check in virq_debug_show_one
      genirq/proc: Return proper error code when irq_set_affinity() fails
      irq/work: Use llist_for_each_entry_safe
      irqchip: mips-gic: Print warning if inherited GIC base is used
      irqchip/mips-gic: Add pr_fmt and reword pr_* messages
      irqchip/stm32: Move the wakeup on interrupt mask
      irqchip/stm32: Fix initial values
      irqchip/stm32: Add stm32h7 support
      dt-bindings/interrupt-controllers: Add compatible string for stm32h7
      irqchip/stm32: Add multi-bank management
      irqchip/stm32: Select GENERIC_IRQ_CHIP
      irqchip/exiu: Add support for Socionext Synquacer EXIU controller
      dt-bindings: Add description of Socionext EXIU interrupt controller
      irqchip/gic-v3-its: Fix VPE activate callback return value
      irqchip: mips-gic: Make IPI bitmaps static
      irqchip: mips-gic: Share register writes in gic_set_type()
      irqchip: mips-gic: Remove gic_vpes variable
      irqchip: mips-gic: Use num_possible_cpus() to reserve IPIs
      irqchip: mips-gic: Configure EIC when CPUs come online
      ...

commit 4b82130077d93539c9fbb0f5eee21965cea9cfe9
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Mon Oct 30 10:15:00 2017 +0800

    irqdomain: Update the comments of fwnode field of irq_domain structure
    
    Commit:
    
    f110711a6053 ("irqdomain: Convert irqdomain-%3Eof_node to fwnode")
    
    converted of_node field to fwnode, but didn't update its comments.
    
    Update it.
    
    Fixes: f110711a6053 ("irqdomain: Convert irqdomain-%3Eof_node to fwnode")
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index df162f7a4aad..ce48a23d621f 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -138,8 +138,8 @@ struct irq_domain_chip_generic;
  * @mapcount: The number of mapped interrupts
  *
  * Optional elements
- * @of_node: Pointer to device tree nodes associated with the irq_domain. Used
- *           when decoding device tree interrupt specifiers.
+ * @fwnode: Pointer to firmware node associated with the irq_domain. Pretty easy
+ *          to swap it for the of_node via the irq_domain_get_of_node accessor
  * @gc: Pointer to a list of generic chips. There is a helper function for
  *      setting up one or more generic chips for interrupt controllers
  *      drivers using the generic chip library which uses this pointer.

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 81e4889ca6dd..b1037dfc47e4 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * irq_domain - IRQ translation domains
  *

commit f1d783585486c7c612f277c2a6f0c9bb5a67e463
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 5 10:44:54 2017 +0900

    irqdomain: Move revmap_trees_mutex to struct irq_domain
    
    The revmap_trees_mutex protects domain->revmap_tree.  There is no
    need to make it global because it is allowed to modify revmap_tree
    of two different domains concurrently.  Having said that, this would
    not be a actual bottleneck because the interrupt map/unmap does not
    occur quite often.  Rather, the motivation is to tidy up the code
    from a data structure point of view.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 7d0c6c144708..df162f7a4aad 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -32,6 +32,7 @@
 #include <linux/types.h>
 #include <linux/irqhandler.h>
 #include <linux/of.h>
+#include <linux/mutex.h>
 #include <linux/radix-tree.h>
 
 struct device_node;
@@ -176,6 +177,7 @@ struct irq_domain {
 	unsigned int revmap_direct_max_irq;
 	unsigned int revmap_size;
 	struct radix_tree_root revmap_tree;
+	struct mutex revmap_tree_mutex;
 	unsigned int linear_revmap[];
 };
 

commit 42e1cc2dc5b698181ab1ffb7972bd880230c506e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:12 2017 +0200

    genirq/irqdomain: Propagate early activation
    
    Propagate the early activation mode to the irqdomain activate()
    callbacks. This is required for the upcoming reservation, late vector
    assignment scheme, so that the early activation call can act accordingly.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.028353660@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 8fb877121984..7d0c6c144708 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -441,7 +441,7 @@ extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
 				   bool realloc, const struct cpumask *affinity);
 extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
-extern int irq_domain_activate_irq(struct irq_data *irq_data);
+extern int irq_domain_activate_irq(struct irq_data *irq_data, bool early);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
 
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,

commit bb9b428a5c832d7abb494fbabac37c515c01c6c4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:11 2017 +0200

    genirq/irqdomain: Allow irq_domain_activate_irq() to fail
    
    Allow irq_domain_activate_irq() to fail. This is required to support a
    reservation and late vector assignment scheme.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.933882227@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 9bc07f59b090..8fb877121984 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -441,7 +441,7 @@ extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
 				   bool realloc, const struct cpumask *affinity);
 extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
-extern void irq_domain_activate_irq(struct irq_data *irq_data);
+extern int irq_domain_activate_irq(struct irq_data *irq_data);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
 
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,

commit 72491643469aab736536ae71dcd199b19dabd891
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:10 2017 +0200

    genirq/irqdomain: Update irq_domain_ops.activate() signature
    
    The irq_domain_ops.activate() callback has no return value and no way to
    tell the function that the activation is early.
    
    The upcoming changes to support a reservation scheme which allows to assign
    interrupt vectors on x86 only when the interrupt is actually requested
    requires:
    
      - A return value, so activation can fail at request_irq() time
    
      - Information that the activate invocation is early, i.e. before
        request_irq().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.848490816@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index de06ce992a2d..9bc07f59b090 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -111,7 +111,7 @@ struct irq_domain_ops {
 		     unsigned int nr_irqs, void *arg);
 	void (*free)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs);
-	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
+	int (*activate)(struct irq_domain *d, struct irq_data *irqd, bool early);
 	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
 	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
 			 unsigned long *out_hwirq, unsigned int *out_type);

commit 457f6d35072f395508255ef09fd08f824382cf85
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:07 2017 +0200

    genirq: Make state consistent for !IRQ_DOMAIN_HIERARCHY
    
    In the !IRQ_DOMAIN_HIERARCHY cas the activation stubs are not
    setting/clearing the activation status bits. This is not a problem at the
    moment, but upcoming changes require a correct status.
    
    Add the set/clear incovations to the stub functions and move them to the
    core internal header to avoid duplication and visibility outside the core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.591985591@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 1fb50438a868..de06ce992a2d 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -511,8 +511,6 @@ static inline bool irq_domain_is_msi_remap(struct irq_domain *domain)
 extern bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain);
 
 #else	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
-static inline void irq_domain_activate_irq(struct irq_data *data) { }
-static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 			unsigned int nr_irqs, int node, void *arg)
 {
@@ -561,8 +559,6 @@ irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)
 
 #else /* CONFIG_IRQ_DOMAIN */
 static inline void irq_dispose_mapping(unsigned int virq) { }
-static inline void irq_domain_activate_irq(struct irq_data *data) { }
-static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
 static inline struct irq_domain *irq_find_matching_fwnode(
 	struct fwnode_handle *fwnode, enum irq_domain_bus_token bus_token)
 {

commit c3e7239a7f43ce1ff407df5f5944bf0d42dc21bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:06 2017 +0200

    irqdomain/debugfs: Provide domain specific debug callback
    
    Some interrupt domains like the X86 vector domain has special requirements
    for debugging, like showing the vector usage on the CPUs.
    
    Add a callback to the irqdomain ops which can be filled in by domains which
    require it and add conditional invocations to the irqdomain and the per irq
    debug files.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.512937505@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 81e4889ca6dd..1fb50438a868 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -40,6 +40,7 @@ struct of_device_id;
 struct irq_chip;
 struct irq_data;
 struct cpumask;
+struct seq_file;
 
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
@@ -104,7 +105,6 @@ struct irq_domain_ops {
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
 		     const u32 *intspec, unsigned int intsize,
 		     unsigned long *out_hwirq, unsigned int *out_type);
-
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	/* extended V2 interfaces to support hierarchy irq_domains */
 	int (*alloc)(struct irq_domain *d, unsigned int virq,
@@ -116,6 +116,10 @@ struct irq_domain_ops {
 	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
 			 unsigned long *out_hwirq, unsigned int *out_type);
 #endif
+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+	void (*debug_show)(struct seq_file *m, struct irq_domain *d,
+			   struct irq_data *irqd, int ind);
+#endif
 };
 
 extern struct irq_domain_ops irq_generic_chip_ops;

commit e7d0c41ecc2e372a81741a30894f556afec24315
Merge: 53ac64aac9af 3689d3d69072
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:50:00 2017 -0700

    Merge tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull device properties framework updates from Rafael Wysocki:
     "These introduce fwnode operations for all of the separate types of
      'firmware nodes' that can be handled by the device properties
      framework, make the framework use const fwnode arguments all over, add
      a helper for the consolidated handling of node references and switch
      over the framework to the new UUID API.
    
      Specifics:
    
       - Introduce fwnode operations for all of the separate types of
         'firmware nodes' that can be handled by the device properties
         framework and drop the type field from struct fwnode_handle (Sakari
         Ailus, Arnd Bergmann).
    
       - Make the device properties framework use const fwnode arguments
         where possible (Sakari Ailus).
    
       - Add a helper for the consolidated handling of node references to
         the device properties framework (Sakari Ailus).
    
       - Switch over the ACPI part of the device properties framework to the
         new UUID API (Andy Shevchenko)"
    
    * tag 'devprop-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: device property: Switch to use new generic UUID API
      device property: export irqchip_fwnode_ops
      device property: Introduce fwnode_property_get_reference_args
      device property: Constify fwnode property API
      device property: Constify argument to pset fwnode backend
      ACPI: Constify internal fwnode arguments
      ACPI: Constify acpi_bus helper functions, switch to macros
      ACPI: Prepare for constifying acpi_get_next_subnode() fwnode argument
      device property: Get rid of struct fwnode_handle type field
      ACPI: Use IS_ERR_OR_NULL() instead of non-NULL check in is_acpi_data_node()

commit 495c38d3001fd226cf91df1d031320f349bcaf35
Author: David Daney <david.daney@cavium.com>
Date:   Thu Aug 17 17:53:34 2017 -0700

    irqdomain: Add irq_domain_{push,pop}_irq() functions
    
    For an already existing irqdomain hierarchy, as might be obtained via
    a call to pci_enable_msix_range(), a PCI driver wishing to add an
    additional irqdomain to the hierarchy needs to be able to insert the
    irqdomain to that already initialized hierarchy.  Calling
    irq_domain_create_hierarchy() allows the new irqdomain to be created,
    but no existing code allows for initializing the associated irq_data.
    
    Add a couple of helper functions (irq_domain_push_irq() and
    irq_domain_pop_irq()) to initialize the irq_data for the new
    irqdomain added to an existing hierarchy.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-gpio@vger.kernel.org
    Link: http://lkml.kernel.org/r/1503017616-3252-6-git-send-email-david.daney@cavium.com

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index cac77a5c5555..2318f29054af 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -460,6 +460,9 @@ extern void irq_domain_free_irqs_common(struct irq_domain *domain,
 extern void irq_domain_free_irqs_top(struct irq_domain *domain,
 				     unsigned int virq, unsigned int nr_irqs);
 
+extern int irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg);
+extern int irq_domain_pop_irq(struct irq_domain *domain, int virq);
+
 extern int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
 					unsigned int irq_base,
 					unsigned int nr_irqs, void *arg);

commit db3e50f3234ba1a477413f56a9e5800a73dca786
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jul 21 14:39:31 2017 +0300

    device property: Get rid of struct fwnode_handle type field
    
    Instead of relying on the struct fwnode_handle type field, define
    fwnode_operations structs for all separate types of fwnodes. To find out
    the type, compare to the ops field to relevant ops structs.
    
    This change has two benefits:
    
    1. it avoids adding the type field to each and every instance of struct
    fwnode_handle, thus saving memory and
    
    2. makes the ops field the single factor that defines both the types of
    the fwnode as well as defines the implementation of its operations,
    decreasing the possibility of bugs when developing code dealing with
    fwnode internals.
    
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index cac77a5c5555..d24273840b79 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -265,9 +265,11 @@ static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
 	return node ? &node->fwnode : NULL;
 }
 
+extern const struct fwnode_operations irqchip_fwnode_ops;
+
 static inline bool is_fwnode_irqchip(struct fwnode_handle *fwnode)
 {
-	return fwnode && fwnode->type == FWNODE_IRQCHIP;
+	return fwnode && fwnode->ops == &irqchip_fwnode_ops;
 }
 
 extern void irq_domain_update_bus_token(struct irq_domain *domain,

commit 6a6544e520abecd484ab8b67fb50d1fc003f3275
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 20 22:17:44 2017 +0100

    genirq/irqdomain: Remove auto-recursive hierarchy support
    
    It did seem like a good idea at the time, but it never really
    caught on, and auto-recursive domains remain unused 3 years after
    having been introduced.
    
    Oh well, time for a late spring cleanup.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 222f47af12f4..cac77a5c5555 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -180,8 +180,8 @@ enum {
 	/* Irq domain is hierarchical */
 	IRQ_DOMAIN_FLAG_HIERARCHY	= (1 << 0),
 
-	/* Core calls alloc/free recursive through the domain hierarchy. */
-	IRQ_DOMAIN_FLAG_AUTO_RECURSIVE	= (1 << 1),
+	/* Irq domain name was allocated in __irq_domain_add() */
+	IRQ_DOMAIN_NAME_ALLOCATED	= (1 << 6),
 
 	/* Irq domain is an IPI domain with virq per cpu */
 	IRQ_DOMAIN_FLAG_IPI_PER_CPU	= (1 << 2),
@@ -195,9 +195,6 @@ enum {
 	/* Irq domain implements MSI remapping */
 	IRQ_DOMAIN_FLAG_MSI_REMAP	= (1 << 5),
 
-	/* Irq domain name was allocated in __irq_domain_add() */
-	IRQ_DOMAIN_NAME_ALLOCATED	= (1 << 6),
-
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the
@@ -448,7 +445,7 @@ static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 				       NULL);
 }
 
-extern int irq_domain_alloc_irqs_recursive(struct irq_domain *domain,
+extern int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
 					   unsigned int irq_base,
 					   unsigned int nr_irqs, void *arg);
 extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,

commit 61d0a000b7746665c7cfcff766532f6f2a922a61
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Jun 22 11:34:57 2017 +0100

    genirq/irqdomain: Add irq_domain_update_bus_token helper
    
    We can have irq domains that are identified by the same fwnode
    (because they are serviced by the same HW), and yet have different
    functionnality (because they serve different busses, for example).
    This is what we use the bus_token field.
    
    Since we don't use this field when generating the domain name,
    all the aliasing domains will get the same name, and the debugfs
    file creation fails. Also, bus_token is updated by individual drivers,
    and the core code is unaware of that update.
    
    In order to sort this mess, let's introduce a helper that takes care
    of updating bus_token, and regenerate the debugfs file.
    
    A separate patch will update all the individual users.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 914b0c31d233..222f47af12f4 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -273,6 +273,9 @@ static inline bool is_fwnode_irqchip(struct fwnode_handle *fwnode)
 	return fwnode && fwnode->type == FWNODE_IRQCHIP;
 }
 
+extern void irq_domain_update_bus_token(struct irq_domain *domain,
+					enum irq_domain_bus_token bus_token);
+
 static inline
 struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
 					    enum irq_domain_bus_token bus_token)

commit 087cdfb662ae50e3826e7cd2e54b6519d07b60f0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:17 2017 +0200

    genirq/debugfs: Add proper debugfs interface
    
    Debugging (hierarchical) interupt domains is tedious as there is no
    information about the hierarchy and no information about states of
    interrupts in the various domain levels.
    
    Add a debugfs directory 'irq' and subdirectories 'domains' and 'irqs'.
    
    The domains directory contains the domain files. The content is information
    about the domain. If the domain is part of a hierarchy then the parent
    domains are printed as well.
    
    # ls /sys/kernel/debug/irq/domains/
    default     INTEL-IR-2      INTEL-IR-MSI-2  IO-APIC-IR-2  PCI-MSI
    DMAR-MSI    INTEL-IR-3      INTEL-IR-MSI-3  IO-APIC-IR-3  unknown-1
    INTEL-IR-0  INTEL-IR-MSI-0  IO-APIC-IR-0    IO-APIC-IR-4  VECTOR
    INTEL-IR-1  INTEL-IR-MSI-1  IO-APIC-IR-1    PCI-HT
    
    # cat /sys/kernel/debug/irq/domains/VECTOR
    name:   VECTOR
     size:   0
     mapped: 216
     flags:  0x00000041
    
    # cat /sys/kernel/debug/irq/domains/IO-APIC-IR-0
    name:   IO-APIC-IR-0
     size:   24
     mapped: 19
     flags:  0x00000041
     parent: INTEL-IR-3
        name:   INTEL-IR-3
         size:   65536
         mapped: 167
         flags:  0x00000041
         parent: VECTOR
            name:   VECTOR
             size:   0
             mapped: 216
             flags:  0x00000041
    
    Unfortunately there is no per cpu information about the VECTOR domain (yet).
    
    The irqs directory contains detailed information about mapped interrupts.
    
    # cat /sys/kernel/debug/irq/irqs/3
    handler:  handle_edge_irq
    status:   0x00004000
    istate:   0x00000000
    ddepth:   1
    wdepth:   0
    dstate:   0x01018000
                IRQD_IRQ_DISABLED
                IRQD_SINGLE_TARGET
                IRQD_MOVE_PCNTXT
    node:     0
    affinity: 0-143
    effectiv: 0
    pending:
    domain:  IO-APIC-IR-0
     hwirq:   0x3
     chip:    IR-IO-APIC
      flags:   0x10
                 IRQCHIP_SKIP_SET_WAKE
     parent:
        domain:  INTEL-IR-3
         hwirq:   0x20000
         chip:    INTEL-IR
          flags:   0x0
         parent:
            domain:  VECTOR
             hwirq:   0x3
             chip:    APIC
              flags:   0x0
    
    This was developed to simplify the debugging of the managed affinity
    changes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.537566163@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 17ccd54d936d..914b0c31d233 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -139,6 +139,7 @@ struct irq_domain_chip_generic;
  *      setting up one or more generic chips for interrupt controllers
  *      drivers using the generic chip library which uses this pointer.
  * @parent: Pointer to parent irq_domain to support hierarchy irq_domains
+ * @debugfs_file: dentry for the domain debugfs file
  *
  * Revmap data, used internally by irq_domain
  * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that
@@ -162,6 +163,9 @@ struct irq_domain {
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	struct irq_domain *parent;
 #endif
+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+	struct dentry		*debugfs_file;
+#endif
 
 	/* reverse map data. The linear map gets appended to the irq_domain */
 	irq_hw_number_t hwirq_max;

commit 9dc6be3d419398eae9a19cd09b7969ceff8eaf10
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:16 2017 +0200

    genirq/irqdomain: Add map counter
    
    Add a map counter instead of counting radix tree entries for
    diagnosis. That also gives correct information for linear domains.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.459397746@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 9cf32a2fbe69..17ccd54d936d 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -130,6 +130,7 @@ struct irq_domain_chip_generic;
  * @host_data: private data pointer for use by owner.  Not touched by irq_domain
  *             core code.
  * @flags: host per irq_domain flags
+ * @mapcount: The number of mapped interrupts
  *
  * Optional elements
  * @of_node: Pointer to device tree nodes associated with the irq_domain. Used
@@ -152,6 +153,7 @@ struct irq_domain {
 	const struct irq_domain_ops *ops;
 	void *host_data;
 	unsigned int flags;
+	unsigned int mapcount;
 
 	/* Optional data */
 	struct fwnode_handle *fwnode;

commit d59f6617eef0f76e34f7a9993f5645c5ef467e42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:05 2017 +0200

    genirq: Allow fwnode to carry name information only
    
    In order to provide proper debug interface it's required to have domain
    names available when the domain is added. Non fwnode based architectures
    like x86 have no way to do so.
    
    It's not possible to use domain ops or host data for this as domain ops
    might be the same for several instances, but the names have to be unique.
    
    Extend the irqchip fwnode to allow transporting the domain name. If no node
    is supplied, create a 'unknown-N' placeholder.
    
    Warn if an invalid node is supplied and treat it like no node. This happens
    e.g. with i2 devices on x86 which hand in an ACPI type node which has no
    interface for retrieving the name.
    
    [ Folded a fix from Marc to make DT name parsing work ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235443.588784933@linutronix.de

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 9f3616085423..9cf32a2fbe69 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -189,6 +189,9 @@ enum {
 	/* Irq domain implements MSI remapping */
 	IRQ_DOMAIN_FLAG_MSI_REMAP	= (1 << 5),
 
+	/* Irq domain name was allocated in __irq_domain_add() */
+	IRQ_DOMAIN_NAME_ALLOCATED	= (1 << 6),
+
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the
@@ -203,7 +206,33 @@ static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
 }
 
 #ifdef CONFIG_IRQ_DOMAIN
-struct fwnode_handle *irq_domain_alloc_fwnode(void *data);
+struct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,
+						const char *name, void *data);
+
+enum {
+	IRQCHIP_FWNODE_REAL,
+	IRQCHIP_FWNODE_NAMED,
+	IRQCHIP_FWNODE_NAMED_ID,
+};
+
+static inline
+struct fwnode_handle *irq_domain_alloc_named_fwnode(const char *name)
+{
+	return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_NAMED, 0, name, NULL);
+}
+
+static inline
+struct fwnode_handle *irq_domain_alloc_named_id_fwnode(const char *name, int id)
+{
+	return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_NAMED_ID, id, name,
+					 NULL);
+}
+
+static inline struct fwnode_handle *irq_domain_alloc_fwnode(void *data)
+{
+	return __irq_domain_alloc_fwnode(IRQCHIP_FWNODE_REAL, 0, NULL, data);
+}
+
 void irq_domain_free_fwnode(struct fwnode_handle *fwnode);
 struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,

commit b3e228473e6cec7cf83b4025b4570c8066ab2dd8
Author: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
Date:   Thu Mar 2 16:11:47 2017 +0100

    irqdomain: Add empty irq_domain_check_msi_remap
    
    Fix following build error for s390:
    drivers/vfio/vfio_iommu_type1.c: In function 'vfio_iommu_type1_attach_group':
    drivers/vfio/vfio_iommu_type1.c:1290:25: error: implicit declaration of function 'irq_domain_check_msi_remap'
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 188eced6813e..9f3616085423 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -524,6 +524,10 @@ static inline struct irq_domain *irq_find_matching_fwnode(
 {
 	return NULL;
 }
+static inline bool irq_domain_check_msi_remap(void)
+{
+	return false;
+}
 #endif /* !CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit c7b41f0af38f53e46050b56a5b0e96710097b83c
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:59 2017 +0000

    irqdomain: irq_domain_check_msi_remap
    
    This new function checks whether all MSI irq domains
    implement IRQ remapping. This is useful to understand
    whether VFIO passthrough is safe with respect to interrupts.
    
    On ARM typically an MSI controller can sit downstream
    to the IOMMU without preventing VFIO passthrough.
    As such any assigned device can write into the MSI doorbell.
    In case the MSI controller implements IRQ remapping, assigned
    devices will not be able to trigger interrupts towards the
    host. On the contrary, the assignment must be emphasized as
    unsafe with respect to interrupts.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index bc2f5719dace..188eced6813e 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -222,6 +222,7 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 void *host_data);
 extern struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,
 						   enum irq_domain_bus_token bus_token);
+extern bool irq_domain_check_msi_remap(void);
 extern void irq_set_default_host(struct irq_domain *host);
 extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
 				  irq_hw_number_t hwirq, int node,

commit 631a9639ac413da6242cb15558ebd661cf633622
Author: Eric Auger <eric.auger@redhat.com>
Date:   Thu Jan 19 20:57:57 2017 +0000

    irqdomain: Add irq domain MSI and MSI_REMAP flags
    
    We introduce two new enum values for the irq domain flag:
    - IRQ_DOMAIN_FLAG_MSI indicates the irq domain corresponds to
      an MSI domain
    - IRQ_DOMAIN_FLAG_MSI_REMAP indicates the irq domain has MSI
      remapping capabilities.
    
    Those values will be useful to check all MSI irq domains have
    MSI remapping support when assessing the safety of IRQ assignment
    to a guest.
    
    irq_domain_hierarchical_is_msi_remap() allows to check if an
    irq domain or any parent implements MSI remapping.
    
    Signed-off-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Tomasz Nowicki <tomasz.nowicki@caviumnetworks.com>
    Tested-by: Bharat Bhushan <bharat.bhushan@nxp.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index ffb84604c1de..bc2f5719dace 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -183,6 +183,12 @@ enum {
 	/* Irq domain is an IPI domain with single virq */
 	IRQ_DOMAIN_FLAG_IPI_SINGLE	= (1 << 3),
 
+	/* Irq domain implements MSIs */
+	IRQ_DOMAIN_FLAG_MSI		= (1 << 4),
+
+	/* Irq domain implements MSI remapping */
+	IRQ_DOMAIN_FLAG_MSI_REMAP	= (1 << 5),
+
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the
@@ -446,6 +452,19 @@ static inline bool irq_domain_is_ipi_single(struct irq_domain *domain)
 {
 	return domain->flags & IRQ_DOMAIN_FLAG_IPI_SINGLE;
 }
+
+static inline bool irq_domain_is_msi(struct irq_domain *domain)
+{
+	return domain->flags & IRQ_DOMAIN_FLAG_MSI;
+}
+
+static inline bool irq_domain_is_msi_remap(struct irq_domain *domain)
+{
+	return domain->flags & IRQ_DOMAIN_FLAG_MSI_REMAP;
+}
+
+extern bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain);
+
 #else	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
 static inline void irq_domain_activate_irq(struct irq_data *data) { }
 static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
@@ -477,6 +496,22 @@ static inline bool irq_domain_is_ipi_single(struct irq_domain *domain)
 {
 	return false;
 }
+
+static inline bool irq_domain_is_msi(struct irq_domain *domain)
+{
+	return false;
+}
+
+static inline bool irq_domain_is_msi_remap(struct irq_domain *domain)
+{
+	return false;
+}
+
+static inline bool
+irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)
+{
+	return false;
+}
 #endif	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
 
 #else /* CONFIG_IRQ_DOMAIN */

commit 8658be133baa92c06b6d832a436d437deb2e2a22
Merge: 4030103b9b2e 5e385a6ef31f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 12:26:05 2016 +0200

    Merge branch 'irq/for-block' into irq/core
    
    Pull the irq affinity managing code which is in a seperate branch for block
    developers to pull.

commit 06ee6d571f0e350253a8fc3492316b2be007fae2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 17:39:24 2016 +0900

    genirq: Add affinity hint to irq allocation
    
    Add an extra argument to the irq(domain) allocation functions, so we can hand
    down affinity hints to the allocator. Thats necessary to implement proper
    support for multiqueue devices.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-nvme@lists.infradead.org
    Cc: axboe@fb.com
    Cc: agordeev@redhat.com
    Link: http://lkml.kernel.org/r/1467621574-8277-4-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f1f36e04d885..1aee0fbe900e 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -39,6 +39,7 @@ struct irq_domain;
 struct of_device_id;
 struct irq_chip;
 struct irq_data;
+struct cpumask;
 
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
@@ -217,7 +218,8 @@ extern struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,
 						   enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
 extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
-				  irq_hw_number_t hwirq, int node);
+				  irq_hw_number_t hwirq, int node,
+				  const struct cpumask *affinity);
 
 static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
 {
@@ -389,7 +391,7 @@ static inline struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *par
 
 extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
-				   bool realloc);
+				   bool realloc, const struct cpumask *affinity);
 extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
 extern void irq_domain_activate_irq(struct irq_data *irq_data);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
@@ -397,7 +399,8 @@ extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 			unsigned int nr_irqs, int node, void *arg)
 {
-	return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false);
+	return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false,
+				       NULL);
 }
 
 extern int irq_domain_alloc_irqs_recursive(struct irq_domain *domain,

commit 1e2a7d78499ec8859d2b469051b7b80bad3b08aa
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Jun 7 16:12:28 2016 +0100

    irqdomain: Don't set type when mapping an IRQ
    
    Some IRQ chips, such as GPIO controllers or secondary level interrupt
    controllers, may require require additional runtime power management
    control to ensure they are accessible. For such IRQ chips, it makes sense
    to enable the IRQ chip when interrupts are requested and disabled them
    again once all interrupts have been freed.
    
    When mapping an IRQ, the IRQ type settings are read and then programmed.
    The mapping of the IRQ happens before the IRQ is requested and so the
    programming of the type settings occurs before the IRQ is requested. This
    is a problem for IRQ chips that require additional power management
    control because they may not be accessible yet. Therefore, when mapping
    the IRQ, don't program the type settings, just save them and then program
    these saved settings when the IRQ is requested (so long as if they are not
    overridden via the call to request the IRQ).
    
    Add a stub function for irq_domain_free_irqs() to avoid any compilation
    errors when CONFIG_IRQ_DOMAIN_HIERARCHY is not selected.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f1f36e04d885..317503763314 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -452,6 +452,9 @@ static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 	return -1;
 }
 
+static inline void irq_domain_free_irqs(unsigned int virq,
+					unsigned int nr_irqs) { }
+
 static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 {
 	return false;

commit 651e8b54abdeeaa36f5f54ffa05c18707a3cc1d0
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Apr 11 09:57:51 2016 +0100

    irqdomain: Allow domain matching on irq_fwspec
    
    When iterating over the irq domain list, we try to match a domain
    either by calling a match() function or by comparing a number
    of fields passed as parameters.
    
    Both approaches are a bit restrictive:
    - match() is DT specific and only takes a device node
    - the fallback case only deals with the fwnode_handle
    
    It would be useful if we had a per-domain function that would
    actually perform the matching check on the whole of the
    irq_fwspec structure. This would allow for a domain to triage
    matching attempts that need to extend beyond the fwnode.
    
    Let's introduce irq_find_matching_fwspec(), which takes a full
    blown irq_fwspec structure, and call into a select() function
    implemented by the irqdomain. irq_find_matching_fwnode() is
    made a wrapper around irq_find_matching_fwspec in order to
    preserve compatibility.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: devicetree@vger.kernel.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Link: http://lkml.kernel.org/r/1460365075-7316-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 736abd74c135..f1f36e04d885 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -96,6 +96,8 @@ enum irq_domain_bus_token {
 struct irq_domain_ops {
 	int (*match)(struct irq_domain *d, struct device_node *node,
 		     enum irq_domain_bus_token bus_token);
+	int (*select)(struct irq_domain *d, struct irq_fwspec *fwspec,
+		      enum irq_domain_bus_token bus_token);
 	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
 	void (*unmap)(struct irq_domain *d, unsigned int virq);
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
@@ -211,7 +213,7 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 irq_hw_number_t first_hwirq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
-extern struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
+extern struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,
 						   enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
 extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
@@ -227,6 +229,17 @@ static inline bool is_fwnode_irqchip(struct fwnode_handle *fwnode)
 	return fwnode && fwnode->type == FWNODE_IRQCHIP;
 }
 
+static inline
+struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
+					    enum irq_domain_bus_token bus_token)
+{
+	struct irq_fwspec fwspec = {
+		.fwnode = fwnode,
+	};
+
+	return irq_find_matching_fwspec(&fwspec, bus_token);
+}
+
 static inline struct irq_domain *irq_find_matching_host(struct device_node *node,
 							enum irq_domain_bus_token bus_token)
 {

commit 7cec18a3906b52e855c9386650c0226bbe594a4c
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Mon Apr 25 08:14:24 2016 +0100

    genirq: Add error code reporting to irq_{reserve,destroy}_ipi
    
    Make these functions return appropriate error codes when something goes
    wrong.
    
    Previously irq_destroy_ipi returned void making it impossible to notify
    the caller if the request could not be fulfilled. Patch 1 in the series
    added another condition in which this could fail in addition to the
    existing ones. irq_reserve_ipi returned an unsigned int meaning it could
    only return 0 on failure and give the caller no indication as to why the
    request failed.
    
    As time goes on there are likely to be further conditions added in which
    these functions can fail. These APIs and the IPI IRQ domain are new in
    4.6 and the number of existing call sites are low, changing the API now
    has little impact on the code, while making it easier for these
    functions to grow over time.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Cc: ralf@linux-mips.org
    Cc: Qais Yousef <qsyousef@gmail.com>
    Cc: lisa.parratt@imgtec.com
    Cc: jiang.liu@linux.intel.com
    Link: http://lkml.kernel.org/r/1461568464-31701-2-git-send-email-matt.redfearn@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index e1b81d35e7a3..736abd74c135 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -346,9 +346,8 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 			irq_hw_number_t *out_hwirq, unsigned int *out_type);
 
 /* IPI functions */
-unsigned int irq_reserve_ipi(struct irq_domain *domain,
-			     const struct cpumask *dest);
-void irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);
+int irq_reserve_ipi(struct irq_domain *domain, const struct cpumask *dest);
+int irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);
 
 /* V2 interfaces to support hierarchy IRQ domains. */
 extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,

commit 01292cea0df86ed4a1eb6450d6eda375ef925716
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Mon Apr 25 08:14:23 2016 +0100

    genirq: Make irq_destroy_ipi take a cpumask of IPIs to destroy
    
    Previously irq_destroy_ipi() would destroy IPIs to all CPUs that were
    configured by irq_reserve_ipi(). This change makes it possible to
    destroy just a subset of the IPIs. This may be useful to remove IPIs to
    CPUs that have been hot removed so that the IRQ numbers allocated within
    the IPI domain can be re-used.
    
    The original behaviour is restored by passing the complete mask that the
    IPI was created with.
    
    There are currently no users of this function that would break from the
    API change.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Cc: ralf@linux-mips.org
    Cc: Qais Yousef <qsyousef@gmail.com>
    Cc: lisa.parratt@imgtec.com
    Cc: jiang.liu@linux.intel.com
    Link: http://lkml.kernel.org/r/1461568464-31701-1-git-send-email-matt.redfearn@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 2aed04396210..e1b81d35e7a3 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -348,7 +348,7 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 /* IPI functions */
 unsigned int irq_reserve_ipi(struct irq_domain *domain,
 			     const struct cpumask *dest);
-void irq_destroy_ipi(unsigned int irq);
+void irq_destroy_ipi(unsigned int irq, const struct cpumask *dest);
 
 /* V2 interfaces to support hierarchy IRQ domains. */
 extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,

commit 9dffdb38d864ae89e16ff7b3a09451270736e35b
Merge: 10fdfee7f7fd 2df122bdebab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 22:13:41 2016 -0700

    Merge tag 'staging-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging driver updates from Greg KH:
     "Here is the big staging driver pull request for 4.6-rc1.
    
      Lots of little things here, over 1600 patches or so.  Notable is all
      of the good Lustre work happening, those developers have finally woken
      up and are cleaning up their code greatly.  The Outreachy intern
      application process is also happening, which brought in another 400 or
      so patches.  Full details are in the very long shortlog.
    
      All of these have been in linux-next with no reported issues"
    
    * tag 'staging-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1673 commits)
      staging: lustre: fix aligments in lnet selftest
      staging: lustre: report minimum of two buffers for LNet selftest load test
      staging: lustre: test for proper errno code in lstcon_rpc_trans_abort
      staging: lustre: filter remaining extra spacing for lnet selftest
      staging: lustre: remove extra spacing when setting variable for lnet selftest
      staging: lustre: remove extra spacing of variable declartions for lnet selftest
      staging: lustre: fix spacing issues checkpatch reported in lnet selftest
      staging: lustre: remove returns in void function for lnet selftest
      staging: lustre: fix bogus lst errors for lnet selftest
      staging: netlogic: Replacing pr_err with dev_err after the call to devm_kzalloc
      staging: mt29f_spinand: Replacing pr_info with dev_info after the call to devm_kzalloc
      staging: android: ion: fix up file mode
      staging: ion: debugfs invalid gfp mask
      staging: rts5208: Replace pci_enable_device with pcim_enable_device
      Staging: ieee80211: Place constant on right side of the test.
      staging: speakup: Replace del_timer with del_timer_sync
      staging: lowmemorykiller: fix 2 checks that checkpatch complained
      staging: mt29f_spinand: Drop void pointer cast
      staging: rdma: hfi1: file_ops: Replace ALIGN with PAGE_ALIGN
      staging: rdma: hfi1: driver: Replace IS_ALIGNED with PAGE_ALIGNED
      ...

commit d17bf24e695290d3fe7943aca52ab48098a10653
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:19 2015 +0000

    genirq: Add a new generic IPI reservation code to irq core
    
    Add a generic mechanism to dynamically allocate an IPI. Depending on the
    underlying implementation this creates either a single Linux irq or a
    consective range of Linux irqs. The Linux irq is used later to send IPIs to
    other CPUs.
    
    [ tglx: Massaged the code and removed the 'consecutive mask' restriction for
            the single IRQ case ]
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-9-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index c466cc17b8e9..ed48594e96d2 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -344,6 +344,11 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 			const u32 *intspec, unsigned int intsize,
 			irq_hw_number_t *out_hwirq, unsigned int *out_type);
 
+/* IPI functions */
+unsigned int irq_reserve_ipi(struct irq_domain *domain,
+			     const struct cpumask *dest);
+void irq_destroy_ipi(unsigned int irq);
+
 /* V2 interfaces to support hierarchy IRQ domains. */
 extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 						unsigned int virq);

commit ac0a0cd266d1f21236d5975ca6bced9b377a2a6a
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:18 2015 +0000

    genirq: Make irq_domain_alloc_descs() non static
    
    We will need to use this function to implement irq_reserve_ipi() later. So
    make it non static and move the prototype to irqdomain.h to allow using it
    outside irqdomain.c
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-8-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 130e1c3117c3..c466cc17b8e9 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -213,6 +213,8 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 extern struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
 						   enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
+extern int irq_domain_alloc_descs(int virq, unsigned int nr_irqs,
+				  irq_hw_number_t hwirq, int node);
 
 static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
 {

commit 29d5c8db26ad54592436508819ac617119306f96
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:13 2015 +0000

    genirq: Add DOMAIN_BUS_IPI
    
    We need a way to search and match IPI domains.
    
    Using the new enum we can use irq_find_matching_host() to do that.
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-3-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 9bb0a9cfc1c4..130e1c3117c3 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -74,6 +74,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_PCI_MSI,
 	DOMAIN_BUS_PLATFORM_MSI,
 	DOMAIN_BUS_NEXUS,
+	DOMAIN_BUS_IPI,
 };
 
 /**

commit 0abefbaab4edbcec637e00fefcdeccb52797fe4f
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:12 2015 +0000

    genirq: Add new IPI irqdomain flags
    
    These flags will be used to identify an IPI domain. We have two flavours of
    IPI implementations:
    
    IRQ_DOMAIN_FLAG_IPI_PER_CPU: Each CPU has its own virq and hwirq
    IRQ_DOMAIN_FLAG_IPI_SINGLE : A single virq and hwirq for all CPUs
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-2-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 04579d9fbce4..9bb0a9cfc1c4 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -172,6 +172,12 @@ enum {
 	/* Core calls alloc/free recursive through the domain hierarchy. */
 	IRQ_DOMAIN_FLAG_AUTO_RECURSIVE	= (1 << 1),
 
+	/* Irq domain is an IPI domain with virq per cpu */
+	IRQ_DOMAIN_FLAG_IPI_PER_CPU	= (1 << 2),
+
+	/* Irq domain is an IPI domain with single virq */
+	IRQ_DOMAIN_FLAG_IPI_SINGLE	= (1 << 3),
+
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the
@@ -400,6 +406,22 @@ static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 {
 	return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
 }
+
+static inline bool irq_domain_is_ipi(struct irq_domain *domain)
+{
+	return domain->flags &
+		(IRQ_DOMAIN_FLAG_IPI_PER_CPU | IRQ_DOMAIN_FLAG_IPI_SINGLE);
+}
+
+static inline bool irq_domain_is_ipi_per_cpu(struct irq_domain *domain)
+{
+	return domain->flags & IRQ_DOMAIN_FLAG_IPI_PER_CPU;
+}
+
+static inline bool irq_domain_is_ipi_single(struct irq_domain *domain)
+{
+	return domain->flags & IRQ_DOMAIN_FLAG_IPI_SINGLE;
+}
 #else	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
 static inline void irq_domain_activate_irq(struct irq_data *data) { }
 static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
@@ -413,6 +435,21 @@ static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 {
 	return false;
 }
+
+static inline bool irq_domain_is_ipi(struct irq_domain *domain)
+{
+	return false;
+}
+
+static inline bool irq_domain_is_ipi_per_cpu(struct irq_domain *domain)
+{
+	return false;
+}
+
+static inline bool irq_domain_is_ipi_single(struct irq_domain *domain)
+{
+	return false;
+}
 #endif	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
 
 #else /* CONFIG_IRQ_DOMAIN */

commit 9b1b282ccd8195e3264dbb3cd15b9d60b6345230
Author: J. German Rivera <German.Rivera@freescale.com>
Date:   Wed Jan 6 16:03:19 2016 -0600

    irqdomain: Added domain bus token DOMAIN_BUS_FSL_MC_MSI
    
    Since an FSL-MC bus is a new bus type that is neither PCI nor
    PLATFORM, we need a new domain bus token to disambiguate the
    IRQ domain for FSL-MC MSIs.
    
    Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 04579d9fbce4..0934d06c8b00 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -74,6 +74,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_PCI_MSI,
 	DOMAIN_BUS_PLATFORM_MSI,
 	DOMAIN_BUS_NEXUS,
+	DOMAIN_BUS_FSL_MC_MSI,
 };
 
 /**

commit 530cbe100ef7587aa5b5ac3a4b670cda4d50e598
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jan 26 13:52:25 2016 +0000

    irqdomain: Allow domain lookup with DOMAIN_BUS_WIRED token
    
    Let's take the (outlandish) example of an interrupt controller
    capable of handling both wired interrupts and PCI MSIs.
    
    With the current code, the PCI MSI domain is going to be tagged
    with DOMAIN_BUS_PCI_MSI, and the wired domain with DOMAIN_BUS_ANY.
    
    Things get hairy when we start looking up the domain for a wired
    interrupt (typically when creating it based on some firmware
    information - DT or ACPI).
    
    In irq_create_fwspec_mapping(), we perform the lookup using
    DOMAIN_BUS_ANY, which is actually used as a wildcard. This gives
    us one chance out of two to end up with the wrong domain, and
    we try to configure a wired interrupt with the MSI domain.
    Everything grinds to a halt pretty quickly.
    
    What we really need to do is to start looking for a domain that
    would uniquely identify a wired interrupt domain, and only use
    DOMAIN_BUS_ANY as a fallback.
    
    In order to solve this, let's introduce a new DOMAIN_BUS_WIRED
    token, which is going to be used exactly as described above.
    Of course, this depends on the irqchip to setup the domain
    bus_token, and nobody had to implement this so far.
    
    Only so far.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Link: http://lkml.kernel.org/r/1453816347-32720-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f64622ad02c1..04579d9fbce4 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -70,6 +70,7 @@ struct irq_fwspec {
  */
 enum irq_domain_bus_token {
 	DOMAIN_BUS_ANY		= 0,
+	DOMAIN_BUS_WIRED,
 	DOMAIN_BUS_PCI_MSI,
 	DOMAIN_BUS_PLATFORM_MSI,
 	DOMAIN_BUS_NEXUS,

commit 92b86f92ed0307efbaea3c0e95520551848d3995
Merge: a4289dc2ec3a 0644b3daca28
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 29 10:08:45 2015 +0100

    Merge branch 'irq/gic-v2m-acpi' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/core
    
    Pull another round of GIC changes from Marc:
    
     ACPI support for GIV-v2m

commit 75aba7b0e9ac416ca53c0c97680b8e9aedf09284
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Thu Dec 10 08:55:28 2015 -0800

    irqdomain: Introduce is_fwnode_irqchip helper
    
    Since there will be several places checking if fwnode.type
    is equal FWNODE_IRQCHIP, this patch adds a convenient function
    for this purpose.
    
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index a06fedacd955..d72fabc04437 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -211,6 +211,11 @@ static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
 	return node ? &node->fwnode : NULL;
 }
 
+static inline bool is_fwnode_irqchip(struct fwnode_handle *fwnode)
+{
+	return fwnode && fwnode->type == FWNODE_IRQCHIP;
+}
+
 static inline struct irq_domain *irq_find_matching_host(struct device_node *node,
 							enum irq_domain_bus_token bus_token)
 {

commit 471036b2b895789c2305428fd879006468e4a758
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Thu Dec 10 08:55:27 2015 -0800

    acpi: pci: Setup MSI domain for ACPI based pci devices
    
    This patch introduces pci_msi_register_fwnode_provider() for irqchip
    to register a callback, to provide a way to determine appropriate MSI
    domain for a pci device.
    
    It also introduces pci_host_bridge_acpi_msi_domain(), which returns
    the MSI domain of the specified PCI host bridge with DOMAIN_BUS_PCI_MSI
    bus token. Then, it is assigned to pci device.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index d5e5c5bef28c..a06fedacd955 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -410,6 +410,11 @@ static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 static inline void irq_dispose_mapping(unsigned int virq) { }
 static inline void irq_domain_activate_irq(struct irq_data *data) { }
 static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
+static inline struct irq_domain *irq_find_matching_fwnode(
+	struct fwnode_handle *fwnode, enum irq_domain_bus_token bus_token)
+{
+	return NULL;
+}
 #endif /* !CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit c466595c416c04036e1ba36ecdc5fe9072c76228
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Nov 23 08:26:04 2015 +0000

    irqdomain: Make irq_domain_alloc_irqs_recursive available
    
    We are soon going to need the MSI layer to call into the domain
    allocators. Instead of open coding this, make the standard
    irq_domain_alloc_irqs_recursive function available to the MSI
    layer.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index d5e5c5bef28c..cf96c6a326f7 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -367,6 +367,9 @@ static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 	return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false);
 }
 
+extern int irq_domain_alloc_irqs_recursive(struct irq_domain *domain,
+					   unsigned int irq_base,
+					   unsigned int nr_irqs, void *arg);
 extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
 					 unsigned int virq,
 					 irq_hw_number_t hwirq,

commit e7a46c818564329f977f8fa157b5e9e1d0d83012
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:45 2015 +0100

    irqdomain: Documentation updates
    
    Update the IRQ domain documentation to reflect the changes made
    while divorcing the domain infrastructure from Device Tree.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-18-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 2b3340ae915d..d5e5c5bef28c 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -5,9 +5,10 @@
  * helpful for interrupt controllers to implement mapping between hardware
  * irq numbers and the Linux irq number space.
  *
- * irq_domains also have a hook for translating device tree interrupt
- * representation into a hardware irq number that can be mapped back to a
- * Linux irq number without any extra platform support code.
+ * irq_domains also have hooks for translating device tree or other
+ * firmware interrupt representations into a hardware irq number that
+ * can be mapped back to a Linux irq number without any extra platform
+ * support code.
  *
  * Interrupt controller "domain" data structure. This could be defined as a
  * irq domain controller. That is, it handles the mapping between hardware
@@ -17,16 +18,12 @@
  * model). It's the domain callbacks that are responsible for setting the
  * irq_chip on a given irq_desc after it's been mapped.
  *
- * The host code and data structures are agnostic to whether or not
- * we use an open firmware device-tree. We do have references to struct
- * device_node in two places: in irq_find_host() to find the host matching
- * a given interrupt controller node, and of course as an argument to its
- * counterpart domain->ops->match() callback. However, those are treated as
- * generic pointers by the core and the fact that it's actually a device-node
- * pointer is purely a convention between callers and implementation. This
- * code could thus be used on other architectures by replacing those two
- * by some sort of arch-specific void * "token" used to identify interrupt
- * controllers.
+ * The host code and data structures use a fwnode_handle pointer to
+ * identify the domain. In some cases, and in order to preserve source
+ * code compatibility, this fwnode pointer is "upgraded" to a DT
+ * device_node. For those firmware infrastructures that do not provide
+ * a unique identifier for an interrupt controller, the irq_domain
+ * code offers a fwnode allocator.
  */
 
 #ifndef _LINUX_IRQDOMAIN_H

commit 2a5e9a072da6469a37d1f0b1577416f51223c280
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:43 2015 +0100

    irqdomain: Introduce irq_domain_create_hierarchy
    
    As we're about to start converting the various MSI layers to
    use fwnode_handle instead of device_node, add irq_domain_create_hierarchy
    as a directly equivalent of irq_domain_add_hierarchy (which still
    exists as a compatibility interface).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-16-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 949caa728758..2b3340ae915d 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -340,10 +340,23 @@ extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
 				void *chip_data, irq_flow_handler_t handler,
 				void *handler_data, const char *handler_name);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
-extern struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,
+extern struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,
 			unsigned int flags, unsigned int size,
-			struct device_node *node,
+			struct fwnode_handle *fwnode,
 			const struct irq_domain_ops *ops, void *host_data);
+
+static inline struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,
+					    unsigned int flags,
+					    unsigned int size,
+					    struct device_node *node,
+					    const struct irq_domain_ops *ops,
+					    void *host_data)
+{
+	return irq_domain_create_hierarchy(parent, flags, size,
+					   of_node_to_fwnode(node),
+					   ops, host_data);
+}
+
 extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
 				   bool realloc);

commit b145dcc45a6af0abfcf9b4de8006d40559c50fc6
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:36 2015 +0100

    irqdomain: Add a fwnode_handle allocator
    
    In order to be able to reference an irqdomain from ACPI, we need
    to be able to create an identifier, which is usually a struct
    device_node.
    
    This device node does't really fit the ACPI infrastructure, so
    we cunningly allocate a new structure containing a fwnode_handle,
    and return that.
    
    This structure doesn't really point to a device (interrupt
    controllers are not "real" devices in Linux), but as we cannot
    really deny that they exist, we create them with a new fwnode_type
    (FWNODE_IRQCHIP).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-9-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 995d4c5100d3..949caa728758 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -188,6 +188,8 @@ static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
 }
 
 #ifdef CONFIG_IRQ_DOMAIN
+struct fwnode_handle *irq_domain_alloc_fwnode(void *data);
+void irq_domain_free_fwnode(struct fwnode_handle *fwnode);
 struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,
 				    const struct irq_domain_ops *ops,

commit 1bf4ddc46c5d6123897a54cea4ffe3e90f30600b
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:35 2015 +0100

    irqdomain: Introduce irq_domain_create_{linear, tree}
    
    Just like we have irq_domain_add_{linear,tree} to create a irq domain
    identified by an of_node, introduce irq_domain_create_{linear,tree}
    that do the same thing, except that they take a struct fwnode_handle.
    
    Existing functions get rewritten in terms of the new ones so that
    everything keeps working as before (and __irq_domain_add is now
    fwnode_handle based as well).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-8-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 7e7842e90d40..995d4c5100d3 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -188,7 +188,7 @@ static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
 }
 
 #ifdef CONFIG_IRQ_DOMAIN
-struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
+struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,
 				    const struct irq_domain_ops *ops,
 				    void *host_data);
@@ -207,11 +207,15 @@ extern struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
 						   enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
 
+static inline struct fwnode_handle *of_node_to_fwnode(struct device_node *node)
+{
+	return node ? &node->fwnode : NULL;
+}
+
 static inline struct irq_domain *irq_find_matching_host(struct device_node *node,
 							enum irq_domain_bus_token bus_token)
 {
-	return irq_find_matching_fwnode(node ? &node->fwnode : NULL,
-					bus_token);
+	return irq_find_matching_fwnode(of_node_to_fwnode(node), bus_token);
 }
 
 static inline struct irq_domain *irq_find_host(struct device_node *node)
@@ -231,14 +235,14 @@ static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_no
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return __irq_domain_add(of_node, size, size, 0, ops, host_data);
+	return __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
 }
 static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
 					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data);
+	return __irq_domain_add(of_node_to_fwnode(of_node), 0, max_irq, max_irq, ops, host_data);
 }
 static inline struct irq_domain *irq_domain_add_legacy_isa(
 				struct device_node *of_node,
@@ -252,7 +256,22 @@ static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data);
+	return __irq_domain_add(of_node_to_fwnode(of_node), 0, ~0, 0, ops, host_data);
+}
+
+static inline struct irq_domain *irq_domain_create_linear(struct fwnode_handle *fwnode,
+					 unsigned int size,
+					 const struct irq_domain_ops *ops,
+					 void *host_data)
+{
+	return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
+}
+
+static inline struct irq_domain *irq_domain_create_tree(struct fwnode_handle *fwnode,
+					 const struct irq_domain_ops *ops,
+					 void *host_data)
+{
+	return __irq_domain_add(fwnode, 0, ~0, 0, ops, host_data);
 }
 
 extern void irq_domain_remove(struct irq_domain *host);

commit c0131f09de8c2d301814cac86d78f643b8ee0574
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:34 2015 +0100

    irqdomain: Introduce irq_create_fwspec_mapping
    
    Just like we have irq_create_of_mapping, irq_create_fwspec_mapping
    creates a IRQ domain mapping for an interrupt described in a
    struct irq_fwspec.
    
    irq_create_of_mapping gets rewritten in terms of the new function,
    and the hack we introduced before gets removed (now that no stacked
    irqchip uses of_phandle_args anymore).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-7-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 533c974b9d94..7e7842e90d40 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -267,6 +267,7 @@ extern void irq_domain_disassociate(struct irq_domain *domain,
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
+extern unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec);
 extern void irq_dispose_mapping(unsigned int virq);
 
 /**

commit 11e4438ee330fab0f216ee7cc1b651cb2ddceb5d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:32 2015 +0100

    irqdomain: Introduce a firmware-specific IRQ specifier structure
    
    So far the closest thing to a generic IRQ specifier structure is
    of_phandle_args, which happens to be pretty OF specific (the of_node
    pointer in there is quite annoying).
    
    Let's introduce 'struct irq_fwspec' that can be used in place of
    of_phandle_args for OF, but also for other firmware implementations
    (that'd be ACPI). This is used together with a new 'translate' method
    that is the pendent of 'xlate'.
    
    We convert irq_create_of_mapping to use this new structure (with a
    small hack that will be removed later).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-5-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 607c1856cc01..533c974b9d94 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -46,6 +46,24 @@ struct irq_data;
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
 
+#define IRQ_DOMAIN_IRQ_SPEC_PARAMS 16
+
+/**
+ * struct irq_fwspec - generic IRQ specifier structure
+ *
+ * @fwnode:		Pointer to a firmware-specific descriptor
+ * @param_count:	Number of device-specific parameters
+ * @param:		Device-specific parameters
+ *
+ * This structure, directly modeled after of_phandle_args, is used to
+ * pass a device-specific description of an interrupt.
+ */
+struct irq_fwspec {
+	struct fwnode_handle *fwnode;
+	int param_count;
+	u32 param[IRQ_DOMAIN_IRQ_SPEC_PARAMS];
+};
+
 /*
  * Should several domains have the same device node, but serve
  * different purposes (for example one domain is for PCI/MSI, and the
@@ -92,6 +110,8 @@ struct irq_domain_ops {
 		     unsigned int nr_irqs);
 	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
 	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
+	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
+			 unsigned long *out_hwirq, unsigned int *out_type);
 #endif
 };
 

commit 130b8c6c8d86075304952241bf2365cea6489df1
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:31 2015 +0100

    irqdomain: Allow irq domain lookup by fwnode
    
    So far, our irq domains are still looked up by device node.
    Let's change this and allow a domain to be looked up using
    a fwnode_handle pointer.
    
    The existing interfaces are preserved with a couple of helpers.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-4-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 2f508f4ac2ea..607c1856cc01 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -183,10 +183,17 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 irq_hw_number_t first_hwirq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
-extern struct irq_domain *irq_find_matching_host(struct device_node *node,
-						 enum irq_domain_bus_token bus_token);
+extern struct irq_domain *irq_find_matching_fwnode(struct fwnode_handle *fwnode,
+						   enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
 
+static inline struct irq_domain *irq_find_matching_host(struct device_node *node,
+							enum irq_domain_bus_token bus_token)
+{
+	return irq_find_matching_fwnode(node ? &node->fwnode : NULL,
+					bus_token);
+}
+
 static inline struct irq_domain *irq_find_host(struct device_node *node)
 {
 	return irq_find_matching_host(node, DOMAIN_BUS_ANY);

commit f110711a6053f08731858aa91420104094188973
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:30 2015 +0100

    irqdomain: Convert irqdomain-%3Eof_node to fwnode
    
    Now that we have everyone accessing the of_node field via the
    irq_domain_get_of_node accessor, it is pretty easy to swap it
    for a pointer to a fwnode_handle.
    
    This translates into a few limited changes in __irq_domain_add,
    and an updated irq_domain_get_of_node.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f644fdb06dd6..2f508f4ac2ea 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -34,6 +34,7 @@
 
 #include <linux/types.h>
 #include <linux/irqhandler.h>
+#include <linux/of.h>
 #include <linux/radix-tree.h>
 
 struct device_node;
@@ -130,7 +131,7 @@ struct irq_domain {
 	unsigned int flags;
 
 	/* Optional data */
-	struct device_node *of_node;
+	struct fwnode_handle *fwnode;
 	enum irq_domain_bus_token bus_token;
 	struct irq_domain_chip_generic *gc;
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
@@ -163,7 +164,7 @@ enum {
 
 static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
 {
-	return d->of_node;
+	return to_of_node(d->fwnode);
 }
 
 #ifdef CONFIG_IRQ_DOMAIN

commit 10abc7df9277a81971924a6c03f74e86d799daf1
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 9 15:50:11 2015 +0100

    irqdomain: Add an accessor for the of_node field
    
    As we're about to remove the of_node field from the irqdomain
    structure, introduce an accessor for it. Subsequent patches
    will take care of the actual repainting.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1444402211-1141-1-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index d3ca79236fb0..f644fdb06dd6 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -161,6 +161,11 @@ enum {
 	IRQ_DOMAIN_FLAG_NONCORE		= (1 << 16),
 };
 
+static inline struct device_node *irq_domain_get_of_node(struct irq_domain *d)
+{
+	return d->of_node;
+}
+
 #ifdef CONFIG_IRQ_DOMAIN
 struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,

commit a5716070d88cba1a0a8a18fea809ea6e3374e276
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:17 2015 +0100

    genirq: Add DOMAIN_BUS_NEXUS irqdomain property
    
    Some IRQ domains are not designed to directly provide interrupts
    to devices, but strictly to be used by other domains. An example
    of this is the GICv3 ITS, which is completely bus agnostic, and
    on which it is possible to implement a PCI/MSI domain.
    
    Just introduce the irq_domain_bus_token property for now.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-11-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index b4a74f73a0c3..d3ca79236fb0 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -56,6 +56,7 @@ enum irq_domain_bus_token {
 	DOMAIN_BUS_ANY		= 0,
 	DOMAIN_BUS_PCI_MSI,
 	DOMAIN_BUS_PLATFORM_MSI,
+	DOMAIN_BUS_NEXUS,
 };
 
 /**

commit c706c239af5bc297b5fbf1adc715632e1c222f7a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:15 2015 +0100

    of/platform: Assign MSI domain to platform device
    
    As for PCI, we're able to populate the msi_domain field at probe time,
    provided that the device tree has an "msi-parent" property.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-9-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 25e9e6696a65..b4a74f73a0c3 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -55,6 +55,7 @@ struct irq_data;
 enum irq_domain_bus_token {
 	DOMAIN_BUS_ANY		= 0,
 	DOMAIN_BUS_PCI_MSI,
+	DOMAIN_BUS_PLATFORM_MSI,
 };
 
 /**

commit 0380839dc90c53e24ddfa0f17ad909c2ddc345c2
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:09 2015 +0100

    PCI/MSI: Register irq domain with specific token
    
    When creating a PCI/MSI domain, tag it with DOMAIN_BUS_PCI_MSI so
    that it can be looked-up using irq_find_matching_host().
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 91a83adf5e45..25e9e6696a65 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -54,6 +54,7 @@ struct irq_data;
  */
 enum irq_domain_bus_token {
 	DOMAIN_BUS_ANY		= 0,
+	DOMAIN_BUS_PCI_MSI,
 };
 
 /**

commit ad3aedfbb04b3a2af54473cfe31f13953cfe9d84
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:08 2015 +0100

    genirq/irqdomain: Allow irq domain aliasing
    
    It is not uncommon (at least with the ARM stuff) to have a piece
    of hardware that implements different flavours of "interrupts".
    A typical example of this is the GICv3 ITS, which implements
    standard PCI/MSI support, but also some form of "generic MSI".
    
    So far, the PCI/MSI domain is registered using the ITS device_node,
    so that irq_find_host can return it. On the contrary, the raw MSI
    domain is not registered with an device_node, making it impossible
    to be looked up by another subsystem (obviously, using the same
    device_node twice would only result in confusion, as it is not
    defined which one irq_find_host would return).
    
    A solution to this is to "type" domains that may be aliasing, and
    to be able to lookup an device_node that matches a given type.
    For this, we introduce irq_find_matching_host() as a superset
    of irq_find_host:
    
    struct irq_domain *irq_find_matching_host(struct device_node *node,
                                    enum irq_domain_bus_token bus_token);
    
    where bus_token is the "type" we want to match the domain against
    (so far, only DOMAIN_BUS_ANY is defined). This result in some
    moderately invasive changes on the PPC side (which is the only
    user of the .match method).
    
    This has otherwise no functionnal change.
    
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 744ac0ec98eb..91a83adf5e45 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -45,6 +45,17 @@ struct irq_data;
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
 
+/*
+ * Should several domains have the same device node, but serve
+ * different purposes (for example one domain is for PCI/MSI, and the
+ * other for wired IRQs), they can be distinguished using a
+ * bus-specific token. Most domains are expected to only carry
+ * DOMAIN_BUS_ANY.
+ */
+enum irq_domain_bus_token {
+	DOMAIN_BUS_ANY		= 0,
+};
+
 /**
  * struct irq_domain_ops - Methods for irq_domain objects
  * @match: Match an interrupt controller device node to a host, returns
@@ -61,7 +72,8 @@ struct irq_data;
  * to setup the irq_desc when returning from map().
  */
 struct irq_domain_ops {
-	int (*match)(struct irq_domain *d, struct device_node *node);
+	int (*match)(struct irq_domain *d, struct device_node *node,
+		     enum irq_domain_bus_token bus_token);
 	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
 	void (*unmap)(struct irq_domain *d, unsigned int virq);
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
@@ -116,6 +128,7 @@ struct irq_domain {
 
 	/* Optional data */
 	struct device_node *of_node;
+	enum irq_domain_bus_token bus_token;
 	struct irq_domain_chip_generic *gc;
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	struct irq_domain *parent;
@@ -161,9 +174,15 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 irq_hw_number_t first_hwirq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
-extern struct irq_domain *irq_find_host(struct device_node *node);
+extern struct irq_domain *irq_find_matching_host(struct device_node *node,
+						 enum irq_domain_bus_token bus_token);
 extern void irq_set_default_host(struct irq_domain *host);
 
+static inline struct irq_domain *irq_find_host(struct device_node *node)
+{
+	return irq_find_matching_host(node, DOMAIN_BUS_ANY);
+}
+
 /**
  * irq_domain_add_linear() - Allocate and register a linear revmap irq_domain.
  * @of_node: pointer to interrupt controller's device tree node.

commit 5f22f5c668204f3af7557018b2ad6cf2074defac
Author: Stefan Agner <stefan@agner.ch>
Date:   Sat May 16 11:44:13 2015 +0200

    irqdomain: Add non-hierarchy helper irq_domain_set_info
    
    This adds the helper irq_domain_set_info() in a non-domain hierarchy
    variant. This allows to use the helper for generic chip since not
    all chips using generic chip support domain hierarchy.
    
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Cc: marc.zyngier@arm.com
    Cc: linux@arm.linux.org.uk
    Cc: u.kleine-koenig@pengutronix.de
    Cc: olof@lixom.net
    Cc: arnd@arndb.de
    Cc: daniel.lezcano@linaro.org
    Cc: mark.rutland@arm.com
    Cc: pawel.moll@arm.com
    Cc: robh+dt@kernel.org
    Cc: ijc+devicetree@hellion.org.uk
    Cc: galak@codeaurora.org
    Cc: mcoquelin.stm32@gmail.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: shawn.guo@linaro.org
    Cc: kernel@pengutronix.de
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/1431769465-26867-2-git-send-email-stefan@agner.ch
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 676d7306a360..744ac0ec98eb 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -258,6 +258,10 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 /* V2 interfaces to support hierarchy IRQ domains. */
 extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 						unsigned int virq);
+extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
+				irq_hw_number_t hwirq, struct irq_chip *chip,
+				void *chip_data, irq_flow_handler_t handler,
+				void *handler_data, const char *handler_name);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,
 			unsigned int flags, unsigned int size,
@@ -281,10 +285,6 @@ extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
 					 irq_hw_number_t hwirq,
 					 struct irq_chip *chip,
 					 void *chip_data);
-extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
-				irq_hw_number_t hwirq, struct irq_chip *chip,
-				void *chip_data, irq_flow_handler_t handler,
-				void *handler_data, const char *handler_name);
 extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
 extern void irq_domain_free_irqs_common(struct irq_domain *domain,
 					unsigned int virq,

commit afb7da83b9f476728623130703acb553d7c7c4d9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sat Nov 15 22:24:02 2014 +0800

    irqdomain: Introduce helper function irq_domain_add_hierarchy()
    
    Introduce helper function irq_domain_add_hierarchy(), which creates
    a linear irqdomain if parameter 'size' is not zero, otherwise creates
    a tree irqdomain.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Link: http://lkml.kernel.org/r/1416061447-9472-5-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index dd2709bdad56..676d7306a360 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -259,6 +259,10 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 						unsigned int virq);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+extern struct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,
+			unsigned int flags, unsigned int size,
+			struct device_node *node,
+			const struct irq_domain_ops *ops, void *host_data);
 extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 				   unsigned int nr_irqs, int node, void *arg,
 				   bool realloc);

commit 36d727310cb9f85efb5ac089ffb1797e7c3538e1
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sat Nov 15 22:24:01 2014 +0800

    irqdomain: Implement a method to automatically call parent domains alloc/free
    
    Add a flags to irq_domain.flags to control whether the irqdomain core
    should automatically call parent irqdomain's alloc/free callbacks. It
    help to reduce hierarchy irqdomains users' code size.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Link: http://lkml.kernel.org/r/1416061447-9472-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 7aca1adb68a1..dd2709bdad56 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -134,6 +134,9 @@ enum {
 	/* Irq domain is hierarchical */
 	IRQ_DOMAIN_FLAG_HIERARCHY	= (1 << 0),
 
+	/* Core calls alloc/free recursive through the domain hierarchy. */
+	IRQ_DOMAIN_FLAG_AUTO_RECURSIVE	= (1 << 1),
+
 	/*
 	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
 	 * for implementation specific purposes and ignored by the
@@ -285,22 +288,13 @@ extern void irq_domain_free_irqs_common(struct irq_domain *domain,
 extern void irq_domain_free_irqs_top(struct irq_domain *domain,
 				     unsigned int virq, unsigned int nr_irqs);
 
-static inline int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
-					       unsigned int irq_base,
-					       unsigned int nr_irqs, void *arg)
-{
-	if (domain->parent && domain->parent->ops->alloc)
-		return domain->parent->ops->alloc(domain->parent, irq_base,
-						  nr_irqs, arg);
-	return -ENOSYS;
-}
+extern int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
+					unsigned int irq_base,
+					unsigned int nr_irqs, void *arg);
 
-static inline void irq_domain_free_irqs_parent(struct irq_domain *domain,
-				unsigned int irq_base, unsigned int nr_irqs)
-{
-	if (domain->parent && domain->parent->ops->free)
-		domain->parent->ops->free(domain->parent, irq_base, nr_irqs);
-}
+extern void irq_domain_free_irqs_parent(struct irq_domain *domain,
+					unsigned int irq_base,
+					unsigned int nr_irqs);
 
 static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 {

commit 1b5377087cb4e68d719a875120894fddfbcbf0f9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sun Nov 9 23:10:24 2014 +0800

    genirq: Introduce helper irq_domain_set_info() to reduce duplicated code
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f8563dcfd254..7aca1adb68a1 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -33,6 +33,7 @@
 #define _LINUX_IRQDOMAIN_H
 
 #include <linux/types.h>
+#include <linux/irqhandler.h>
 #include <linux/radix-tree.h>
 
 struct device_node;
@@ -273,6 +274,10 @@ extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
 					 irq_hw_number_t hwirq,
 					 struct irq_chip *chip,
 					 void *chip_data);
+extern void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,
+				irq_hw_number_t hwirq, struct irq_chip *chip,
+				void *chip_data, irq_flow_handler_t handler,
+				void *handler_data, const char *handler_name);
 extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
 extern void irq_domain_free_irqs_common(struct irq_domain *domain,
 					unsigned int virq,

commit f8264e34965aaf43203912ed8f7b543c00c8d70f
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Nov 6 22:20:14 2014 +0800

    irqdomain: Introduce new interfaces to support hierarchy irqdomains
    
    We plan to use hierarchy irqdomain to suppport CPU vector assignment,
    interrupt remapping controller, IO-APIC controller, MSI interrupt
    and hypertransport interrupt etc on x86 platforms. So extend irqdomain
    interfaces to support hierarchy irqdomain.
    
    There are already many clients of current irqdomain interfaces.
    To minimize the changes, we choose to introduce new version 2 interfaces
    to support hierarchy instead of extending existing irqdomain interfaces.
    
    According to Thomas's suggestion, the most important design decision is
    to build hierarchy struct irq_data to support hierarchy irqdomain, so
    hierarchy irqdomain related data could be saved in struct irq_data.
    With support of hierarchy irq_data, we could also support stacked
    irq_chips. This is most useful in case of set_affinity().
    
    The new hierarchy irqdomain introduces following interfaces:
    1) irq_domain_alloc_irqs()/irq_domain_free_irqs(): allocate/release IRQ
       and related resources.
    2) __irq_domain_alloc_irqs(): a special version to support legacy IRQs.
    3) irq_domain_activate_irq()/irq_domain_deactivate_irq(): program
       interrupt controllers to activate/deactivate interrupt.
    
    There are also several help functions to ease irqdomain implemenations:
    1) irq_domain_get_irq_data(): get irq_data associated with a specific
       irqdomain.
    2) irq_domain_set_hwirq_and_chip(): save irqdomain specific data into
       irq_data.
    3) irq_domain_alloc_irqs_parent()/irq_domain_free_irqs_parent(): invoke
       parent irqdomain's alloc/free callbacks.
    
    We also changed irq_startup()/irq_shutdown() to invoke
    irq_domain_activate_irq()/irq_domain_deactivate_irq() to program
    interrupt controller when start/stop interrupts.
    
    [ tglx: Folded parts of the later patch series in ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index b0f9d16e48f6..f8563dcfd254 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -38,6 +38,8 @@
 struct device_node;
 struct irq_domain;
 struct of_device_id;
+struct irq_chip;
+struct irq_data;
 
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
@@ -64,6 +66,16 @@ struct irq_domain_ops {
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
 		     const u32 *intspec, unsigned int intsize,
 		     unsigned long *out_hwirq, unsigned int *out_type);
+
+#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+	/* extended V2 interfaces to support hierarchy irq_domains */
+	int (*alloc)(struct irq_domain *d, unsigned int virq,
+		     unsigned int nr_irqs, void *arg);
+	void (*free)(struct irq_domain *d, unsigned int virq,
+		     unsigned int nr_irqs);
+	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
+	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
+#endif
 };
 
 extern struct irq_domain_ops irq_generic_chip_ops;
@@ -77,6 +89,7 @@ struct irq_domain_chip_generic;
  * @ops: pointer to irq_domain methods
  * @host_data: private data pointer for use by owner.  Not touched by irq_domain
  *             core code.
+ * @flags: host per irq_domain flags
  *
  * Optional elements
  * @of_node: Pointer to device tree nodes associated with the irq_domain. Used
@@ -84,6 +97,7 @@ struct irq_domain_chip_generic;
  * @gc: Pointer to a list of generic chips. There is a helper function for
  *      setting up one or more generic chips for interrupt controllers
  *      drivers using the generic chip library which uses this pointer.
+ * @parent: Pointer to parent irq_domain to support hierarchy irq_domains
  *
  * Revmap data, used internally by irq_domain
  * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that
@@ -97,10 +111,14 @@ struct irq_domain {
 	const char *name;
 	const struct irq_domain_ops *ops;
 	void *host_data;
+	unsigned int flags;
 
 	/* Optional data */
 	struct device_node *of_node;
 	struct irq_domain_chip_generic *gc;
+#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+	struct irq_domain *parent;
+#endif
 
 	/* reverse map data. The linear map gets appended to the irq_domain */
 	irq_hw_number_t hwirq_max;
@@ -110,6 +128,19 @@ struct irq_domain {
 	unsigned int linear_revmap[];
 };
 
+/* Irq domain flags */
+enum {
+	/* Irq domain is hierarchical */
+	IRQ_DOMAIN_FLAG_HIERARCHY	= (1 << 0),
+
+	/*
+	 * Flags starting from IRQ_DOMAIN_FLAG_NONCORE are reserved
+	 * for implementation specific purposes and ignored by the
+	 * core code.
+	 */
+	IRQ_DOMAIN_FLAG_NONCORE		= (1 << 16),
+};
+
 #ifdef CONFIG_IRQ_DOMAIN
 struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,
@@ -220,8 +251,75 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 			const u32 *intspec, unsigned int intsize,
 			irq_hw_number_t *out_hwirq, unsigned int *out_type);
 
+/* V2 interfaces to support hierarchy IRQ domains. */
+extern struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
+						unsigned int virq);
+#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+extern int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
+				   unsigned int nr_irqs, int node, void *arg,
+				   bool realloc);
+extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
+extern void irq_domain_activate_irq(struct irq_data *irq_data);
+extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
+
+static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
+			unsigned int nr_irqs, int node, void *arg)
+{
+	return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false);
+}
+
+extern int irq_domain_set_hwirq_and_chip(struct irq_domain *domain,
+					 unsigned int virq,
+					 irq_hw_number_t hwirq,
+					 struct irq_chip *chip,
+					 void *chip_data);
+extern void irq_domain_reset_irq_data(struct irq_data *irq_data);
+extern void irq_domain_free_irqs_common(struct irq_domain *domain,
+					unsigned int virq,
+					unsigned int nr_irqs);
+extern void irq_domain_free_irqs_top(struct irq_domain *domain,
+				     unsigned int virq, unsigned int nr_irqs);
+
+static inline int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
+					       unsigned int irq_base,
+					       unsigned int nr_irqs, void *arg)
+{
+	if (domain->parent && domain->parent->ops->alloc)
+		return domain->parent->ops->alloc(domain->parent, irq_base,
+						  nr_irqs, arg);
+	return -ENOSYS;
+}
+
+static inline void irq_domain_free_irqs_parent(struct irq_domain *domain,
+				unsigned int irq_base, unsigned int nr_irqs)
+{
+	if (domain->parent && domain->parent->ops->free)
+		domain->parent->ops->free(domain->parent, irq_base, nr_irqs);
+}
+
+static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
+{
+	return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
+}
+#else	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
+static inline void irq_domain_activate_irq(struct irq_data *data) { }
+static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
+static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
+			unsigned int nr_irqs, int node, void *arg)
+{
+	return -1;
+}
+
+static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
+{
+	return false;
+}
+#endif	/* CONFIG_IRQ_DOMAIN_HIERARCHY */
+
 #else /* CONFIG_IRQ_DOMAIN */
 static inline void irq_dispose_mapping(unsigned int virq) { }
+static inline void irq_domain_activate_irq(struct irq_data *data) { }
+static inline void irq_domain_deactivate_irq(struct irq_data *data) { }
 #endif /* !CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit 43a775916d63d1c822107b39987192ca5ced445c
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 9 16:20:05 2014 +0800

    genirq: Export irq_domain_disassociate() to architecture interrupt drivers
    
    Export irq_domain_disassociate() to architecture interrupt drivers,
    so it could be used to handle legacy IRQ descriptors on x86.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Link: http://lkml.kernel.org/r/1402302011-23642-37-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index c983ed18c332..b0f9d16e48f6 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -172,6 +172,8 @@ extern int irq_domain_associate(struct irq_domain *domain, unsigned int irq,
 extern void irq_domain_associate_many(struct irq_domain *domain,
 				      unsigned int irq_base,
 				      irq_hw_number_t hwirq_base, int count);
+extern void irq_domain_disassociate(struct irq_domain *domain,
+				    unsigned int irq);
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);

commit d3dcb436f61593843af178d4a520c8c43c04d3fc
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Jun 10 12:19:17 2013 +0100

    irqdomain: make irq_linear_revmap() a fast path again
    
    Over the years, irq_linear_revmap() gained tests and checks to make sure
    callers were using it safely, which while important, also make it less
    of a fast path. After the irqdomain refactoring done recently, it is now
    possible to make irq_linear_revmap() a fast path again. This patch moves
    irq_linear_revmap() to the header file and makes it a static inline so
    that interrupt controller drivers using a linear mapping can decode the
    virq from a hwirq in just a couple of instructions.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 6efbeccac56c..c983ed18c332 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -176,6 +176,22 @@ extern void irq_domain_associate_many(struct irq_domain *domain,
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
 extern void irq_dispose_mapping(unsigned int virq);
+
+/**
+ * irq_linear_revmap() - Find a linux irq from a hw irq number.
+ * @domain: domain owning this hardware interrupt
+ * @hwirq: hardware irq number in that domain space
+ *
+ * This is a fast path alternative to irq_find_mapping() that can be
+ * called directly by irq controller code to save a handful of
+ * instructions. It is always safe to call, but won't find irqs mapped
+ * using the radix tree.
+ */
+static inline unsigned int irq_linear_revmap(struct irq_domain *domain,
+					     irq_hw_number_t hwirq)
+{
+	return hwirq < domain->revmap_size ? domain->linear_revmap[hwirq] : 0;
+}
 extern unsigned int irq_find_mapping(struct irq_domain *host,
 				     irq_hw_number_t hwirq);
 extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
@@ -189,9 +205,6 @@ static inline int irq_create_identity_mapping(struct irq_domain *host,
 	return irq_create_strict_mappings(host, hwirq, hwirq, 1);
 }
 
-extern unsigned int irq_linear_revmap(struct irq_domain *host,
-				      irq_hw_number_t hwirq);
-
 extern const struct irq_domain_ops irq_domain_simple_ops;
 
 /* stock xlate functions */

commit 56a3d5ac774d054ece9373277a861338a468a294
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Jun 10 01:09:33 2013 +0100

    irqdomain: remove irq_domain_generate_simple()
    
    Nobody calls it; remove the function
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 208d1352c40a..6efbeccac56c 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -205,14 +205,6 @@ int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
 			const u32 *intspec, unsigned int intsize,
 			irq_hw_number_t *out_hwirq, unsigned int *out_type);
 
-#if defined(CONFIG_OF_IRQ)
-extern void irq_domain_generate_simple(const struct of_device_id *match,
-					u64 phys_base, unsigned int irq_start);
-#else /* CONFIG_OF_IRQ */
-static inline void irq_domain_generate_simple(const struct of_device_id *match,
-					u64 phys_base, unsigned int irq_start) { }
-#endif /* !CONFIG_OF_IRQ */
-
 #else /* CONFIG_IRQ_DOMAIN */
 static inline void irq_dispose_mapping(unsigned int virq) { }
 #endif /* !CONFIG_IRQ_DOMAIN */

commit ddaf144c61da45ae5c49ae38556c3ac4524f9318
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Jun 10 01:06:02 2013 +0100

    irqdomain: Refactor irq_domain_associate_many()
    
    Originally, irq_domain_associate_many() was designed to unwind the
    mapped irqs on a failure of any individual association. However, that
    proved to be a problem with certain IRQ controllers. Some of them only
    support a subset of irqs, and will fail when attempting to map a
    reserved IRQ. In those cases we want to map as many IRQs as possible, so
    instead it is better for irq_domain_associate_many() to make a
    best-effort attempt to map irqs, but not fail if any or all of them
    don't succeed. If a caller really cares about how many irqs got
    associated, then it should instead go back and check that all of the
    irqs is cares about were mapped.
    
    The original design open-coded the individual association code into the
    body of irq_domain_associate_many(), but with no longer needing to
    unwind associations, the code becomes simpler to split out
    irq_domain_associate() to contain the bulk of the logic, and
    irq_domain_associate_many() to be a simple loop wrapper.
    
    This patch also adds a new error check to the associate path to make
    sure it isn't called for an irq larger than the controller can handle,
    and adds locking so that the irq_domain_mutex is held while setting up a
    new association.
    
    v3: Fixup missing change to irq_domain_add_tree()
    v2: Fixup x86 warning. irq_domain_associate_many() no longer returns an
        error code, but reports errors to the printk log directly. In the
        majority of cases we don't actually want to fail if there is a
        problem, but rather log it and still try to boot the system.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    
    irqdomain: Fix flubbed irq_domain_associate_many refactoring
    
    commit d39046ec72, "irqdomain: Refactor irq_domain_associate_many()" was
    missing the following hunk which causes a boot failure on anything using
    irq_domain_add_tree() to allocate an irq domain.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Michael Neuling <mikey@neuling.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>,
    Cc: Thomas Gleixner <tglx@linutronix.de>,
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index fd4b26f8f44c..208d1352c40a 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -103,6 +103,7 @@ struct irq_domain {
 	struct irq_domain_chip_generic *gc;
 
 	/* reverse map data. The linear map gets appended to the irq_domain */
+	irq_hw_number_t hwirq_max;
 	unsigned int revmap_direct_max_irq;
 	unsigned int revmap_size;
 	struct radix_tree_root revmap_tree;
@@ -110,8 +111,8 @@ struct irq_domain {
 };
 
 #ifdef CONFIG_IRQ_DOMAIN
-struct irq_domain *__irq_domain_add(struct device_node *of_node,
-				    int size, int direct_max,
+struct irq_domain *__irq_domain_add(struct device_node *of_node, int size,
+				    irq_hw_number_t hwirq_max, int direct_max,
 				    const struct irq_domain_ops *ops,
 				    void *host_data);
 struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
@@ -140,14 +141,14 @@ static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_no
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return __irq_domain_add(of_node, size, 0, ops, host_data);
+	return __irq_domain_add(of_node, size, size, 0, ops, host_data);
 }
 static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
 					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return __irq_domain_add(of_node, 0, max_irq, ops, host_data);
+	return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data);
 }
 static inline struct irq_domain *irq_domain_add_legacy_isa(
 				struct device_node *of_node,
@@ -161,19 +162,16 @@ static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
-	return irq_domain_add_linear(of_node, 0, ops, host_data);
+	return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data);
 }
 
 extern void irq_domain_remove(struct irq_domain *host);
 
-extern int irq_domain_associate_many(struct irq_domain *domain,
-				     unsigned int irq_base,
-				     irq_hw_number_t hwirq_base, int count);
-static inline int irq_domain_associate(struct irq_domain *domain, unsigned int irq,
-					irq_hw_number_t hwirq)
-{
-	return irq_domain_associate_many(domain, irq, hwirq, 1);
-}
+extern int irq_domain_associate(struct irq_domain *domain, unsigned int irq,
+					irq_hw_number_t hwirq);
+extern void irq_domain_associate_many(struct irq_domain *domain,
+				      unsigned int irq_base,
+				      irq_hw_number_t hwirq_base, int count);
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);

commit fa40f377577752b83252b9d2b3165d4acee0eb7c
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sat Jun 8 12:57:40 2013 +0100

    irqdomain: Clean up aftermath of irq_domain refactoring
    
    After refactoring the irqdomain code, there are a number of API
    functions that are merely empty wrappers around core code. Drop those
    wrappers out of the C file and replace them with static inlines in the
    header.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 51ef84a3c990..fd4b26f8f44c 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -110,6 +110,10 @@ struct irq_domain {
 };
 
 #ifdef CONFIG_IRQ_DOMAIN
+struct irq_domain *__irq_domain_add(struct device_node *of_node,
+				    int size, int direct_max,
+				    const struct irq_domain_ops *ops,
+				    void *host_data);
 struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
 					 unsigned int size,
 					 unsigned int first_irq,
@@ -121,17 +125,30 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 irq_hw_number_t first_hwirq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
-struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
+extern struct irq_domain *irq_find_host(struct device_node *node);
+extern void irq_set_default_host(struct irq_domain *host);
+
+/**
+ * irq_domain_add_linear() - Allocate and register a linear revmap irq_domain.
+ * @of_node: pointer to interrupt controller's device tree node.
+ * @size: Number of interrupts in the domain.
+ * @ops: map/unmap domain callbacks
+ * @host_data: Controller private data pointer
+ */
+static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
 					 unsigned int size,
 					 const struct irq_domain_ops *ops,
-					 void *host_data);
-struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
+					 void *host_data)
+{
+	return __irq_domain_add(of_node, size, 0, ops, host_data);
+}
+static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
 					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
-					 void *host_data);
-extern struct irq_domain *irq_find_host(struct device_node *node);
-extern void irq_set_default_host(struct irq_domain *host);
-
+					 void *host_data)
+{
+	return __irq_domain_add(of_node, 0, max_irq, ops, host_data);
+}
 static inline struct irq_domain *irq_domain_add_legacy_isa(
 				struct device_node *of_node,
 				const struct irq_domain_ops *ops,

commit 1aa0dd94ca07df818cf14588c9031ab1d7fd84d3
Author: Grant Likely <grant.likely@linaro.org>
Date:   Sat Jun 8 12:03:59 2013 +0100

    irqdomain: Eliminate revmap type
    
    The NOMAP irq_domain type is only used by a handful of interrupt
    controllers and it unnecessarily complicates the code by adding special
    cases on how to look up mappings and different revmap functions are used
    for each type which need to validate the correct type is passed to it
    before performing the reverse map. Eliminating the revmap_type and
    making a single reverse mapping function simplifies the code. It also
    shouldn't be any slower than having separate revmap functions because
    the type of the revmap needed to be checked anyway.
    
    The linear and tree revmap types were already merged in a previous
    patch. This patch rolls the NOMAP or direct mapping behaviour into the
    same domain code making is possible for an irq domain to do any mapping
    type; linear, tree or direct; and that the mapping will be transparent
    to the interrupt controller driver.
    
    With this change, direct mappings will get stored in the linear or tree
    mapping for consistency. Reverse mapping from the hwirq to virq will go
    through the normal lookup process. However, any controller using a
    direct mapping can take advantage of knowing that hwirq==virq for any
    mapped interrupts skip doing a revmap lookup when handling IRQs.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 1cbb7413c121..51ef84a3c990 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -73,50 +73,42 @@ struct irq_domain_chip_generic;
 /**
  * struct irq_domain - Hardware interrupt number translation object
  * @link: Element in global irq_domain list.
- * @revmap_type: Method used for reverse mapping hwirq numbers to linux irq. This
- *               will be one of the IRQ_DOMAIN_MAP_* values.
+ * @name: Name of interrupt domain
  * @ops: pointer to irq_domain methods
  * @host_data: private data pointer for use by owner.  Not touched by irq_domain
  *             core code.
- * @irq_base: Start of irq_desc range assigned to the irq_domain.  The creator
- *            of the irq_domain is responsible for allocating the array of
- *            irq_desc structures.
- * @nr_irq: Number of irqs managed by the irq domain
- * @hwirq_base: Starting number for hwirqs managed by the irq domain
- * @of_node: (optional) Pointer to device tree nodes associated with the
- *           irq_domain.  Used when decoding device tree interrupt specifiers.
+ *
+ * Optional elements
+ * @of_node: Pointer to device tree nodes associated with the irq_domain. Used
+ *           when decoding device tree interrupt specifiers.
+ * @gc: Pointer to a list of generic chips. There is a helper function for
+ *      setting up one or more generic chips for interrupt controllers
+ *      drivers using the generic chip library which uses this pointer.
+ *
+ * Revmap data, used internally by irq_domain
+ * @revmap_direct_max_irq: The largest hwirq that can be set for controllers that
+ *                         support direct mapping
+ * @revmap_size: Size of the linear map table @linear_revmap[]
+ * @revmap_tree: Radix map tree for hwirqs that don't fit in the linear map
+ * @linear_revmap: Linear table of hwirq->virq reverse mappings
  */
 struct irq_domain {
 	struct list_head link;
 	const char *name;
-
-	/* type of reverse mapping_technique */
-	unsigned int revmap_type;
-	struct {
-		struct {
-			unsigned int size;
-		} linear;
-		struct {
-			unsigned int max_irq;
-		} nomap;
-		struct radix_tree_root tree;
-	} revmap_data;
 	const struct irq_domain_ops *ops;
 	void *host_data;
-	irq_hw_number_t inval_irq;
 
-	/* Optional device node pointer */
+	/* Optional data */
 	struct device_node *of_node;
-	/* Optional pointer to generic interrupt chips */
 	struct irq_domain_chip_generic *gc;
 
-	/* Linear reverse map */
+	/* reverse map data. The linear map gets appended to the irq_domain */
+	unsigned int revmap_direct_max_irq;
+	unsigned int revmap_size;
+	struct radix_tree_root revmap_tree;
 	unsigned int linear_revmap[];
 };
 
-#define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
-#define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
-
 #ifdef CONFIG_IRQ_DOMAIN
 struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
 					 unsigned int size,

commit cef5075c8c238ffd04c86a77a5a9bdbd18031137
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Jul 11 17:24:31 2012 +0100

    irqdomain: merge linear and tree reverse mappings.
    
    Keeping them separate makes irq_domain more complex and adds a lot of
    code (as proven by the diffstat).  Merging them simplifies the whole
    scheme.  This change makes it so both the tree and linear methods can be
    used by the same irq_domain instance.  If the hwirq is less than the
    ->linear_size, then the linear map is used to reverse map the hwirq.
    Otherwise the radix tree is used.  The test for which map to use is no
    more expensive that the existing code, so the performance of fast path
    is preserved.
    
    It also means that complex interrupt controllers can use both the
    linear map and a tree in the same domain.  This may be useful for an
    interrupt controller with a base set of core irqs and a large number
    of GPIOs which might be used as irqs.  The linear map could cover the
    core irqs, and the tree used for thas irqs.  The linear map could
    cover the core irqs, and the tree used for the gpios.
    
    v2: Drop reorganization of revmap data
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index e5e513c2d104..1cbb7413c121 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -75,7 +75,6 @@ struct irq_domain_chip_generic;
  * @link: Element in global irq_domain list.
  * @revmap_type: Method used for reverse mapping hwirq numbers to linux irq. This
  *               will be one of the IRQ_DOMAIN_MAP_* values.
- * @revmap_data: Revmap method specific data.
  * @ops: pointer to irq_domain methods
  * @host_data: private data pointer for use by owner.  Not touched by irq_domain
  *             core code.
@@ -93,10 +92,9 @@ struct irq_domain {
 
 	/* type of reverse mapping_technique */
 	unsigned int revmap_type;
-	union {
+	struct {
 		struct {
 			unsigned int size;
-			unsigned int *revmap;
 		} linear;
 		struct {
 			unsigned int max_irq;
@@ -111,11 +109,13 @@ struct irq_domain {
 	struct device_node *of_node;
 	/* Optional pointer to generic interrupt chips */
 	struct irq_domain_chip_generic *gc;
+
+	/* Linear reverse map */
+	unsigned int linear_revmap[];
 };
 
 #define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
 #define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
-#define IRQ_DOMAIN_MAP_TREE 3 /* radix tree */
 
 #ifdef CONFIG_IRQ_DOMAIN
 struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
@@ -137,10 +137,6 @@ struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
 					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
-struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
-					 const struct irq_domain_ops *ops,
-					 void *host_data);
-
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
 
@@ -152,6 +148,12 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
 				     host_data);
 }
+static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
+					 const struct irq_domain_ops *ops,
+					 void *host_data)
+{
+	return irq_domain_add_linear(of_node, 0, ops, host_data);
+}
 
 extern void irq_domain_remove(struct irq_domain *host);
 

commit 0bb4afb45dd1add73ca643a865daa38716aeff0c
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Jun 6 14:23:30 2013 +0100

    irqdomain: Add a name field
    
    This patch adds a name field to the irq_domain structure to help mere
    mortals understand the mappings between irq domains and virqs. It also
    converts a number of places that have open-coded some kind of fudging
    an irqdomain name to use the new field. This means a more consistent
    display of names in irq domain log messages and debugfs output.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 6f062416e5bf..e5e513c2d104 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -89,6 +89,7 @@ struct irq_domain_chip_generic;
  */
 struct irq_domain {
 	struct list_head link;
+	const char *name;
 
 	/* type of reverse mapping_technique */
 	unsigned int revmap_type;

commit 9bbf877d3b6b8c5991000296f40a3f0fe66fa89b
Author: Grant Likely <grant.likely@linaro.org>
Date:   Thu Jun 6 12:10:24 2013 +0100

    irqdomain: Replace LEGACY mapping with LINEAR
    
    The LEGACY mapping unnecessarily complicates the irqdomain code and
    can easily be implemented with a linear mapping.  By ripping it out
    and replacing it with the LINEAR mapping the object size of
    irqdomain.c shrinks by about 330 bytes (ARMv7) which offsets the
    additional allocation required by the linear map.  It also makes it
    possible for current LEGACY map users to pre-allocate irq_descs for a
    subset of the hwirqs and dynamically allocate the rest as needed.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index ba2c708adcff..6f062416e5bf 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -93,11 +93,6 @@ struct irq_domain {
 	/* type of reverse mapping_technique */
 	unsigned int revmap_type;
 	union {
-		struct {
-			unsigned int size;
-			unsigned int first_irq;
-			irq_hw_number_t first_hwirq;
-		} legacy;
 		struct {
 			unsigned int size;
 			unsigned int *revmap;
@@ -117,8 +112,6 @@ struct irq_domain {
 	struct irq_domain_chip_generic *gc;
 };
 
-#define IRQ_DOMAIN_MAP_LEGACY 0 /* driver allocated fixed range of irqs.
-				 * ie. legacy 8259, gets irqs 1..15 */
 #define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
 #define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
 #define IRQ_DOMAIN_MAP_TREE 3 /* radix tree */

commit 088f40b7b027dad6519712ff224a5798dd62a204
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 6 14:30:27 2013 +0000

    genirq: Generic chip: Add linear irq domain support
    
    Provide infrastructure for irq chip implementations which work on
    linear irq domains.
    
    - Interface to allocate multiple generic chips which are associated to
      the irq domain.
    
    - Interface to get the generic chip pointer for a particular hardware
      interrupt in the domain.
    
    - irq domain mapping function to install the chip for a particular
      interrupt.
    
    Note: This lacks a removal function for now.
    
    [ Sebastian Hesselbarth: Mask cache and pointer math fixups ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Rob Landley <rob@landley.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: http://lkml.kernel.org/r/20130506142539.450634298@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 0d5b17bf5e51..ba2c708adcff 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -66,6 +66,10 @@ struct irq_domain_ops {
 		     unsigned long *out_hwirq, unsigned int *out_type);
 };
 
+extern struct irq_domain_ops irq_generic_chip_ops;
+
+struct irq_domain_chip_generic;
+
 /**
  * struct irq_domain - Hardware interrupt number translation object
  * @link: Element in global irq_domain list.
@@ -109,8 +113,16 @@ struct irq_domain {
 
 	/* Optional device node pointer */
 	struct device_node *of_node;
+	/* Optional pointer to generic interrupt chips */
+	struct irq_domain_chip_generic *gc;
 };
 
+#define IRQ_DOMAIN_MAP_LEGACY 0 /* driver allocated fixed range of irqs.
+				 * ie. legacy 8259, gets irqs 1..15 */
+#define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
+#define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
+#define IRQ_DOMAIN_MAP_TREE 3 /* radix tree */
+
 #ifdef CONFIG_IRQ_DOMAIN
 struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
 					 unsigned int size,

commit d6b0d1f7058f7cf818138cd7fd116dca3f3576d9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sun Jun 3 22:04:37 2012 -0700

    irqdomain: Eliminate dedicated radix lookup functions
    
    In preparation to remove the slow revmap path, eliminate the public
    radix revmap lookup functions.  This simplifies the code and makes the
    slowpath removal patch a lot simpler.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index eab8a0e60b8e..0d5b17bf5e51 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -174,10 +174,6 @@ static inline int irq_create_identity_mapping(struct irq_domain *host,
 	return irq_create_strict_mappings(host, hwirq, hwirq, 1);
 }
 
-extern void irq_radix_revmap_insert(struct irq_domain *host, unsigned int virq,
-				    irq_hw_number_t hwirq);
-extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
-					    irq_hw_number_t hwirq);
 extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 

commit 98aa468e045a0091a7c34d9f5205a629634fabf4
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sun Jun 17 16:17:04 2012 -0600

    irqdomain: Support for static IRQ mapping and association.
    
    This adds a new strict mapping API for supporting creation of linux IRQs
    at existing positions within the domain. The new routines are as follows:
    
    For dynamic allocation and insertion to specified ranges:
    
            - irq_create_identity_mapping()
            - irq_create_strict_mappings()
    
    These will allocate and associate a range of linux IRQs at the specified
    location. This can be used by controllers that have their own static linux IRQ
    definitions to map a hwirq range to, as well as for platforms that wish to
    establish 1:1 identity mapping between linux and hwirq space.
    
    For insertion to specified ranges by platforms that do their own irq_desc
    management:
    
            - irq_domain_associate()
            - irq_domain_associate_many()
    
    These in turn call back in to the domain's ->map() routine, for further
    processing by the platform. Disassociation of IRQs get handled through
    irq_dispose_mapping() as normal.
    
    With these in place it should be possible to begin migration of legacy IRQ
    domains to linear ones, without requiring special handling for static vs
    dynamic IRQ definitions in DT vs non-DT paths. This also makes it possible
    for domains with static mappings to adopt whichever tree model best fits
    their needs, rather than simply restricting them to linear revmaps.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    [grant.likely: Reorganized irq_domain_associate{,_many} to have all logic in one place]
    [grant.likely: Add error checking for unallocated irq_descs at associate time]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 17b60be30fff..eab8a0e60b8e 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -149,12 +149,31 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 
 extern void irq_domain_remove(struct irq_domain *host);
 
+extern int irq_domain_associate_many(struct irq_domain *domain,
+				     unsigned int irq_base,
+				     irq_hw_number_t hwirq_base, int count);
+static inline int irq_domain_associate(struct irq_domain *domain, unsigned int irq,
+					irq_hw_number_t hwirq)
+{
+	return irq_domain_associate_many(domain, irq, hwirq, 1);
+}
+
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
 extern void irq_dispose_mapping(unsigned int virq);
 extern unsigned int irq_find_mapping(struct irq_domain *host,
 				     irq_hw_number_t hwirq);
 extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
+extern int irq_create_strict_mappings(struct irq_domain *domain,
+				      unsigned int irq_base,
+				      irq_hw_number_t hwirq_base, int count);
+
+static inline int irq_create_identity_mapping(struct irq_domain *host,
+					      irq_hw_number_t hwirq)
+{
+	return irq_create_strict_mappings(host, hwirq, hwirq, 1);
+}
+
 extern void irq_radix_revmap_insert(struct irq_domain *host, unsigned int virq,
 				    irq_hw_number_t hwirq);
 extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,

commit 781d0f46d81e2c26c70649903b503bcfe817efc8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 5 12:19:19 2012 +0100

    irq_domain: Standardise legacy/linear domain selection
    
    A large proportion of interrupt controllers that support legacy mappings
    do so because non-DT systems need to use fixed IRQ numbers when registering
    devices via buses but can otherwise use a linear mapping. The interrupt
    controller itself typically is not affected by the mapping used and best
    practice is to use a linear mapping where possible so drivers frequently
    select at runtime depending on if a legacy range has been allocated to
    them.
    
    Standardise this behaviour by providing irq_domain_register_simple() which
    will allocate a linear mapping unless a positive first_irq is provided in
    which case it will fall back to a legacy mapping. This helps make best
    practice for irq_domain adoption clearer.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 5abb533eb8eb..17b60be30fff 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -112,6 +112,11 @@ struct irq_domain {
 };
 
 #ifdef CONFIG_IRQ_DOMAIN
+struct irq_domain *irq_domain_add_simple(struct device_node *of_node,
+					 unsigned int size,
+					 unsigned int first_irq,
+					 const struct irq_domain_ops *ops,
+					 void *host_data);
 struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 unsigned int size,
 					 unsigned int first_irq,

commit cb5557bec9f14d05204a9014ae1b23aca8b04f1d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat May 19 15:11:45 2012 +0900

    irqdomain: Kill off duplicate definitions.
    
    Presently irqdomain.h has duplicate definitions for irq_find_host() and
    irq_set_default_host(), presumably from merge damage. Kill off the
    duplicates.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index a796dbf80b67..5abb533eb8eb 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -144,9 +144,6 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 
 extern void irq_domain_remove(struct irq_domain *host);
 
-extern struct irq_domain *irq_find_host(struct device_node *node);
-extern void irq_set_default_host(struct irq_domain *host);
-
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
 extern void irq_dispose_mapping(unsigned int virq);

commit 58ee99ada293b5ed971a023304fcfbc1a0ccdb1c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat May 19 15:11:41 2012 +0900

    irqdomain: Support removal of IRQ domains.
    
    Now that IRQ domains are being used by modules it's necessary to support
    removing them, too. This adds a new irq_domain_remove() routine for doing
    the bulk of the heavy lifting. It's left as an exercise to the caller to
    ensure all mappings have been appropriatey disposed of before attempting
    to remove the domain.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index c65740d76e66..a796dbf80b67 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -141,10 +141,12 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
 				     host_data);
 }
+
+extern void irq_domain_remove(struct irq_domain *host);
+
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
 
-
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
 extern void irq_dispose_mapping(unsigned int virq);

commit 6fa6c8e25e95bdc73e92e4c96b8e3299169b616e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Feb 15 15:06:08 2012 -0700

    irq_domain: Move irq_virq_count into NOMAP revmap
    
    This patch replaces the old global setting of irq_virq_count that is only
    used by the NOMAP mapping and instead uses a revmap_data property so that
    the maximum NOMAP allocation can be set per NOMAP irq_domain.
    
    There is exactly one user of irq_virq_count in-tree right now: PS3.
    Also, irq_virq_count is only useful for the NOMAP mapping.  So,
    instead of having a single global irq_virq_count values, this change
    drops it entirely and added a max_irq argument to irq_domain_add_nomap().
    That makes it a property of an individual nomap irq domain instead of
    a global system settting.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index ac17b9b2e7be..c65740d76e66 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -98,6 +98,9 @@ struct irq_domain {
 			unsigned int size;
 			unsigned int *revmap;
 		} linear;
+		struct {
+			unsigned int max_irq;
+		} nomap;
 		struct radix_tree_root tree;
 	} revmap_data;
 	const struct irq_domain_ops *ops;
@@ -120,6 +123,7 @@ struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
+					 unsigned int max_irq,
 					 const struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
@@ -128,7 +132,6 @@ struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
 
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
-extern void irq_set_virq_count(unsigned int count);
 
 static inline struct irq_domain *irq_domain_add_legacy_isa(
 				struct device_node *of_node,
@@ -140,7 +143,6 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 }
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
-extern void irq_set_virq_count(unsigned int count);
 
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,

commit a699e4e49ec3fb62c4a44394357d14081df10bef
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 3 07:11:04 2012 -0600

    irq: Kill pointless irqd_to_hw export
    
    It makes no sense to export this trivial function.  Make it a static inline
    instead.
    
    This patch also drops virq_to_hw from arch/c6x since it is unused by that
    architecture.
    
    v2: Move irq_hw_number_t into types.h to fix ARM build failure
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index ead4a4215797..ac17b9b2e7be 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -42,12 +42,6 @@ struct of_device_id;
 /* Number of irqs reserved for a legacy isa controller */
 #define NUM_ISA_INTERRUPTS	16
 
-/* This type is the placeholder for a hardware interrupt number. It has to
- * be big enough to enclose whatever representation is used by a given
- * platform.
- */
-typedef unsigned long irq_hw_number_t;
-
 /**
  * struct irq_domain_ops - Methods for irq_domain objects
  * @match: Match an interrupt controller device node to a host, returns

commit d593f25ff263b1a7752b7380f8b7d57809206c40
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Feb 24 08:24:17 2012 -0700

    irq_domain: Centralize definition of irq_dispose_mapping()
    
    Several architectures define their own empty irq_dispose_mapping().  Since
    the irq_domain code is centralized now, there is little need to do so.  This
    patch removes them and creates a new empty copy when !CONFIG_IRQ_DOMAIN is
    selected.
    
    The patch also means that IRQ_DOMAIN becomes selectable on all architectures.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: sparclinux@vger.kernel.org
    Cc: linux@lists.openrisc.net

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 52454881938a..ead4a4215797 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -182,6 +182,9 @@ extern void irq_domain_generate_simple(const struct of_device_id *match,
 static inline void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start) { }
 #endif /* !CONFIG_OF_IRQ */
-#endif /* CONFIG_IRQ_DOMAIN */
+
+#else /* CONFIG_IRQ_DOMAIN */
+static inline void irq_dispose_mapping(unsigned int virq) { }
+#endif /* !CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit a18dc81bf58258ac0920bec26b91656cb0140d2a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 26 12:12:14 2012 -0700

    irq_domain: constify irq_domain_ops
    
    Make irq_domain_ops pointer a constant to make it safer for multiple
    instances to share the same ops pointer and change the irq_domain code
    so that it does not modify the ops.
    
    v4: Fix mismatched type reference in powerpc code
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index ea58f36688a0..52454881938a 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -106,7 +106,7 @@ struct irq_domain {
 		} linear;
 		struct radix_tree_root tree;
 	} revmap_data;
-	struct irq_domain_ops *ops;
+	const struct irq_domain_ops *ops;
 	void *host_data;
 	irq_hw_number_t inval_irq;
 
@@ -119,17 +119,17 @@ struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 unsigned int size,
 					 unsigned int first_irq,
 					 irq_hw_number_t first_hwirq,
-					 struct irq_domain_ops *ops,
+					 const struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
 					 unsigned int size,
-					 struct irq_domain_ops *ops,
+					 const struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
-					 struct irq_domain_ops *ops,
+					 const struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
-					 struct irq_domain_ops *ops,
+					 const struct irq_domain_ops *ops,
 					 void *host_data);
 
 extern struct irq_domain *irq_find_host(struct device_node *node);
@@ -138,7 +138,7 @@ extern void irq_set_virq_count(unsigned int count);
 
 static inline struct irq_domain *irq_domain_add_legacy_isa(
 				struct device_node *of_node,
-				struct irq_domain_ops *ops,
+				const struct irq_domain_ops *ops,
 				void *host_data)
 {
 	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
@@ -162,7 +162,7 @@ extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
 extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 
-extern struct irq_domain_ops irq_domain_simple_ops;
+extern const struct irq_domain_ops irq_domain_simple_ops;
 
 /* stock xlate functions */
 int irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,

commit 16b2e6e2f31dda41f114aa0acade04f7e10f67c9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 26 11:26:52 2012 -0700

    irq_domain: Create common xlate functions that device drivers can use
    
    Rather than having each interrupt controller driver creating its own barely
    unique .xlate function for irq_domain, create a library of translators which
    any driver can use directly.
    
    v5: - Remove irq_domain_xlate_pci().  It was incorrect.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index e7379a3c4d7d..ea58f36688a0 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -163,6 +163,18 @@ extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 
 extern struct irq_domain_ops irq_domain_simple_ops;
+
+/* stock xlate functions */
+int irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,
+			const u32 *intspec, unsigned int intsize,
+			irq_hw_number_t *out_hwirq, unsigned int *out_type);
+int irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,
+			const u32 *intspec, unsigned int intsize,
+			irq_hw_number_t *out_hwirq, unsigned int *out_type);
+int irq_domain_xlate_onetwocell(struct irq_domain *d, struct device_node *ctrlr,
+			const u32 *intspec, unsigned int intsize,
+			irq_hw_number_t *out_hwirq, unsigned int *out_type);
+
 #if defined(CONFIG_OF_IRQ)
 extern void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start);

commit 6b783f7c5dde2648fa0bbe7fc8ac80d78699e67f
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jan 10 17:09:30 2012 -0700

    irq_domain: Remove irq_domain_add_simple()
    
    irq_domain_add_simple() was a stop-gap measure until complete irq_domain
    support was complete.  This patch removes the irq_domain_add_simple()
    interface.
    
    This patch also drops the explicit irq_domain initialization performed
    by the mach-versatile code because the versatile interrupt controller
    already has irq_domain support built into it.  This was a bug that was
    hanging around quietly for a while, but with the full irq_domain which
    actually verifies that irq_domain ranges are available it would cause
    the registration to fail and the system wouldn't boot.
    
    v4: Fixed number of irqs in mx5 gpio code
    v2: Updated to pass in host_data pointer on irq_domain allocation.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 624e9ac89e79..e7379a3c4d7d 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -164,7 +164,6 @@ extern unsigned int irq_linear_revmap(struct irq_domain *host,
 
 extern struct irq_domain_ops irq_domain_simple_ops;
 #if defined(CONFIG_OF_IRQ)
-extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
 extern void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start);
 #else /* CONFIG_OF_IRQ */

commit 75294957be1dee7d22dd7d90bd31334ba410e836
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:57 2012 -0700

    irq_domain: Remove 'new' irq_domain in favour of the ppc one
    
    This patch removes the simplistic implementation of irq_domains and enables
    the powerpc infrastructure for all irq_domain users.  The powerpc
    infrastructure includes support for complex mappings between Linux and
    hardware irq numbers, and can manage allocation of irq_descs.
    
    This patch also converts the few users of irq_domain_add()/irq_domain_del()
    to call irq_domain_add_legacy() instead.
    
    v3: Fix bug that set up too many irqs in translation range.
    v2: Fix removal of irq_alloc_descs() call in gic driver
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 7fef39ed5523..624e9ac89e79 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -55,9 +55,6 @@ typedef unsigned long irq_hw_number_t;
  * @map: Create or update a mapping between a virtual irq number and a hw
  *       irq number. This is called only once for a given mapping.
  * @unmap: Dispose of such a mapping
- * @to_irq: (optional) given a local hardware irq number, return the linux
- *          irq number.  If to_irq is not implemented, then the irq_domain
- *          will use this translation: irq = (domain->irq_base + hwirq)
  * @xlate: Given a device tree node and interrupt specifier, decode
  *         the hardware irq number and linux irq type value.
  *
@@ -70,7 +67,6 @@ struct irq_domain_ops {
 	int (*match)(struct irq_domain *d, struct device_node *node);
 	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
 	void (*unmap)(struct irq_domain *d, unsigned int virq);
-	unsigned int (*to_irq)(struct irq_domain *d, unsigned long hwirq);
 	int (*xlate)(struct irq_domain *d, struct device_node *node,
 		     const u32 *intspec, unsigned int intsize,
 		     unsigned long *out_hwirq, unsigned int *out_type);
@@ -114,16 +110,11 @@ struct irq_domain {
 	void *host_data;
 	irq_hw_number_t inval_irq;
 
-	unsigned int irq_base;
-	unsigned int nr_irq;
-	unsigned int hwirq_base;
-
 	/* Optional device node pointer */
 	struct device_node *of_node;
 };
 
 #ifdef CONFIG_IRQ_DOMAIN
-#ifdef CONFIG_PPC
 struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
 					 unsigned int size,
 					 unsigned int first_irq,
@@ -153,6 +144,10 @@ static inline struct irq_domain *irq_domain_add_legacy_isa(
 	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
 				     host_data);
 }
+extern struct irq_domain *irq_find_host(struct device_node *node);
+extern void irq_set_default_host(struct irq_domain *host);
+extern void irq_set_virq_count(unsigned int count);
+
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
@@ -167,38 +162,7 @@ extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
 extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 
-#else /* CONFIG_PPC */
-
-/**
- * irq_domain_to_irq() - Translate from a hardware irq to a linux irq number
- *
- * Returns the linux irq number associated with a hardware irq.  By default,
- * the mapping is irq == domain->irq_base + hwirq, but this mapping can
- * be overridden if the irq_domain implements a .to_irq() hook.
- */
-static inline unsigned int irq_domain_to_irq(struct irq_domain *d,
-					     unsigned long hwirq)
-{
-	if (d->ops->to_irq)
-		return d->ops->to_irq(d, hwirq);
-	if (WARN_ON(hwirq < d->hwirq_base))
-		return 0;
-	return d->irq_base + hwirq - d->hwirq_base;
-}
-
-#define irq_domain_for_each_hwirq(d, hw) \
-	for (hw = d->hwirq_base; hw < d->hwirq_base + d->nr_irq; hw++)
-
-#define irq_domain_for_each_irq(d, hw, irq) \
-	for (hw = d->hwirq_base, irq = irq_domain_to_irq(d, hw); \
-	     hw < d->hwirq_base + d->nr_irq; \
-	     hw++, irq = irq_domain_to_irq(d, hw))
-
-extern void irq_domain_add(struct irq_domain *domain);
-extern void irq_domain_del(struct irq_domain *domain);
-
 extern struct irq_domain_ops irq_domain_simple_ops;
-
 #if defined(CONFIG_OF_IRQ)
 extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
 extern void irq_domain_generate_simple(const struct of_device_id *match,
@@ -207,7 +171,6 @@ extern void irq_domain_generate_simple(const struct of_device_id *match,
 static inline void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start) { }
 #endif /* !CONFIG_OF_IRQ */
-#endif /* !CONFIG_PPC */
 #endif /* CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit 1bc04f2cf8c2a1feadbd994f50c40bb145bf2989
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:55 2012 -0700

    irq_domain: Add support for base irq and hwirq in legacy mappings
    
    Add support for a legacy mapping where irq = (hwirq - first_hwirq + first_irq)
    so that a controller driver can allocate a fixed range of irq_descs and use
    a simple calculation to translate back and forth between linux and hw irq
    numbers.  This is needed to use an irq_domain with many of the ARM interrupt
    controller drivers that manage their own irq_desc allocations.  Ultimately
    the goal is to migrate those drivers to use the linear revmap, but doing it
    this way allows each driver to be converted separately which makes the
    migration path easier.
    
    This patch generalizes the IRQ_DOMAIN_MAP_LEGACY method to use
    (first_irq-first_hwirq) as the offset between hwirq and linux irq number,
    and adds checks to make sure that the hwirq number does not exceed range
    assigned to the controller.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index f95553fa6872..7fef39ed5523 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -39,6 +39,9 @@ struct device_node;
 struct irq_domain;
 struct of_device_id;
 
+/* Number of irqs reserved for a legacy isa controller */
+#define NUM_ISA_INTERRUPTS	16
+
 /* This type is the placeholder for a hardware interrupt number. It has to
  * be big enough to enclose whatever representation is used by a given
  * platform.
@@ -96,6 +99,11 @@ struct irq_domain {
 	/* type of reverse mapping_technique */
 	unsigned int revmap_type;
 	union {
+		struct {
+			unsigned int size;
+			unsigned int first_irq;
+			irq_hw_number_t first_hwirq;
+		} legacy;
 		struct {
 			unsigned int size;
 			unsigned int *revmap;
@@ -117,6 +125,9 @@ struct irq_domain {
 #ifdef CONFIG_IRQ_DOMAIN
 #ifdef CONFIG_PPC
 struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
+					 unsigned int size,
+					 unsigned int first_irq,
+					 irq_hw_number_t first_hwirq,
 					 struct irq_domain_ops *ops,
 					 void *host_data);
 struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
@@ -130,11 +141,18 @@ struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
 					 struct irq_domain_ops *ops,
 					 void *host_data);
 
-
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
 extern void irq_set_virq_count(unsigned int count);
 
+static inline struct irq_domain *irq_domain_add_legacy_isa(
+				struct device_node *of_node,
+				struct irq_domain_ops *ops,
+				void *host_data)
+{
+	return irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, 0, 0, ops,
+				     host_data);
+}
 
 extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);

commit a8db8cf0d894df5f1dcfd4bce9894e0dbcc01c96
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:54 2012 -0700

    irq_domain: Replace irq_alloc_host() with revmap-specific initializers
    
    Each revmap type has different arguments for setting up the revmap.
    This patch splits up the generator functions so that each revmap type
    can do its own setup and the user doesn't need to keep track of how
    each revmap type handles the arguments.
    
    This patch also adds a host_data argument to the generators.  There are
    cases where the host_data pointer will be needed before the function returns.
    ie. the legacy map calls the .map callback for each irq before returning.
    
    v2: - Add void *host_data argument to irq_domain_add_*() functions
        - fixed failure to compile
        - Moved IRQ_DOMAIN_MAP_* defines into irqdomain.c
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 18f4ab002d2e..f95553fa6872 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -95,10 +95,6 @@ struct irq_domain {
 
 	/* type of reverse mapping_technique */
 	unsigned int revmap_type;
-#define IRQ_DOMAIN_MAP_LEGACY 0 /* legacy 8259, gets irqs 1..15 */
-#define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
-#define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
-#define IRQ_DOMAIN_MAP_TREE 3 /* radix tree */
 	union {
 		struct {
 			unsigned int size;
@@ -120,11 +116,21 @@ struct irq_domain {
 
 #ifdef CONFIG_IRQ_DOMAIN
 #ifdef CONFIG_PPC
-extern struct irq_domain *irq_alloc_host(struct device_node *of_node,
-				       unsigned int revmap_type,
-				       unsigned int revmap_arg,
-				       struct irq_domain_ops *ops,
-				       irq_hw_number_t inval_irq);
+struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,
+					 struct irq_domain_ops *ops,
+					 void *host_data);
+struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
+					 unsigned int size,
+					 struct irq_domain_ops *ops,
+					 void *host_data);
+struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
+					 struct irq_domain_ops *ops,
+					 void *host_data);
+struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
+					 struct irq_domain_ops *ops,
+					 void *host_data);
+
+
 extern struct irq_domain *irq_find_host(struct device_node *node);
 extern void irq_set_default_host(struct irq_domain *host);
 extern void irq_set_virq_count(unsigned int count);

commit cc79ca691c292e9fd44f589c7940b9654e22f2f6
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Feb 16 01:37:49 2012 -0700

    irq_domain: Move irq_domain code from powerpc to kernel/irq
    
    This patch only moves the code.  It doesn't make any changes, and the
    code is still only compiled for powerpc.  Follow-on patches will generalize
    the code for other architectures.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 35b9ff382e45..18f4ab002d2e 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -16,6 +16,17 @@
  * (though a domain can cover more than one PIC if they have a flat number
  * model). It's the domain callbacks that are responsible for setting the
  * irq_chip on a given irq_desc after it's been mapped.
+ *
+ * The host code and data structures are agnostic to whether or not
+ * we use an open firmware device-tree. We do have references to struct
+ * device_node in two places: in irq_find_host() to find the host matching
+ * a given interrupt controller node, and of course as an argument to its
+ * counterpart domain->ops->match() callback. However, those are treated as
+ * generic pointers by the core and the fact that it's actually a device-node
+ * pointer is purely a convention between callers and implementation. This
+ * code could thus be used on other architectures by replacing those two
+ * by some sort of arch-specific void * "token" used to identify interrupt
+ * controllers.
  */
 
 #ifndef _LINUX_IRQDOMAIN_H
@@ -108,6 +119,32 @@ struct irq_domain {
 };
 
 #ifdef CONFIG_IRQ_DOMAIN
+#ifdef CONFIG_PPC
+extern struct irq_domain *irq_alloc_host(struct device_node *of_node,
+				       unsigned int revmap_type,
+				       unsigned int revmap_arg,
+				       struct irq_domain_ops *ops,
+				       irq_hw_number_t inval_irq);
+extern struct irq_domain *irq_find_host(struct device_node *node);
+extern void irq_set_default_host(struct irq_domain *host);
+extern void irq_set_virq_count(unsigned int count);
+
+
+extern unsigned int irq_create_mapping(struct irq_domain *host,
+				       irq_hw_number_t hwirq);
+extern void irq_dispose_mapping(unsigned int virq);
+extern unsigned int irq_find_mapping(struct irq_domain *host,
+				     irq_hw_number_t hwirq);
+extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
+extern void irq_radix_revmap_insert(struct irq_domain *host, unsigned int virq,
+				    irq_hw_number_t hwirq);
+extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
+					    irq_hw_number_t hwirq);
+extern unsigned int irq_linear_revmap(struct irq_domain *host,
+				      irq_hw_number_t hwirq);
+
+#else /* CONFIG_PPC */
+
 /**
  * irq_domain_to_irq() - Translate from a hardware irq to a linux irq number
  *
@@ -137,15 +174,16 @@ extern void irq_domain_add(struct irq_domain *domain);
 extern void irq_domain_del(struct irq_domain *domain);
 
 extern struct irq_domain_ops irq_domain_simple_ops;
-#endif /* CONFIG_IRQ_DOMAIN */
 
-#if defined(CONFIG_IRQ_DOMAIN) && defined(CONFIG_OF_IRQ)
+#if defined(CONFIG_OF_IRQ)
 extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
 extern void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start);
-#else /* CONFIG_IRQ_DOMAIN && CONFIG_OF_IRQ */
+#else /* CONFIG_OF_IRQ */
 static inline void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start) { }
-#endif /* CONFIG_IRQ_DOMAIN && CONFIG_OF_IRQ */
+#endif /* !CONFIG_OF_IRQ */
+#endif /* !CONFIG_PPC */
+#endif /* CONFIG_IRQ_DOMAIN */
 
 #endif /* _LINUX_IRQDOMAIN_H */

commit 7bb69bade0d41715bdf1b24f5ef0b8f798769fe9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:48 2012 -0700

    irq_domain: Make irq_domain structure match powerpc's irq_host
    
    Part of the series to unify the irq remapping mechanisms in the
    kernel.  A follow up patch will copy the powerpc implementation into
    kernel/irq/irqdomain.c, which will be a lot easier if the structures
    are identical.
    
    Where they differ, I've chose to use the powerpc names since there is
    a lot more code using those names.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index bd4272b61a14..35b9ff382e45 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -9,61 +9,105 @@
  * representation into a hardware irq number that can be mapped back to a
  * Linux irq number without any extra platform support code.
  *
- * irq_domain is expected to be embedded in an interrupt controller's private
- * data structure.
+ * Interrupt controller "domain" data structure. This could be defined as a
+ * irq domain controller. That is, it handles the mapping between hardware
+ * and virtual interrupt numbers for a given interrupt domain. The domain
+ * structure is generally created by the PIC code for a given PIC instance
+ * (though a domain can cover more than one PIC if they have a flat number
+ * model). It's the domain callbacks that are responsible for setting the
+ * irq_chip on a given irq_desc after it's been mapped.
  */
+
 #ifndef _LINUX_IRQDOMAIN_H
 #define _LINUX_IRQDOMAIN_H
 
-#include <linux/irq.h>
-#include <linux/mod_devicetable.h>
+#include <linux/types.h>
+#include <linux/radix-tree.h>
 
-#ifdef CONFIG_IRQ_DOMAIN
 struct device_node;
 struct irq_domain;
+struct of_device_id;
+
+/* This type is the placeholder for a hardware interrupt number. It has to
+ * be big enough to enclose whatever representation is used by a given
+ * platform.
+ */
+typedef unsigned long irq_hw_number_t;
 
 /**
  * struct irq_domain_ops - Methods for irq_domain objects
+ * @match: Match an interrupt controller device node to a host, returns
+ *         1 on a match
+ * @map: Create or update a mapping between a virtual irq number and a hw
+ *       irq number. This is called only once for a given mapping.
+ * @unmap: Dispose of such a mapping
  * @to_irq: (optional) given a local hardware irq number, return the linux
  *          irq number.  If to_irq is not implemented, then the irq_domain
  *          will use this translation: irq = (domain->irq_base + hwirq)
- * @dt_translate: Given a device tree node and interrupt specifier, decode
- *                the hardware irq number and linux irq type value.
+ * @xlate: Given a device tree node and interrupt specifier, decode
+ *         the hardware irq number and linux irq type value.
+ *
+ * Functions below are provided by the driver and called whenever a new mapping
+ * is created or an old mapping is disposed. The driver can then proceed to
+ * whatever internal data structures management is required. It also needs
+ * to setup the irq_desc when returning from map().
  */
 struct irq_domain_ops {
+	int (*match)(struct irq_domain *d, struct device_node *node);
+	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
+	void (*unmap)(struct irq_domain *d, unsigned int virq);
 	unsigned int (*to_irq)(struct irq_domain *d, unsigned long hwirq);
-
-#ifdef CONFIG_OF
-	int (*dt_translate)(struct irq_domain *d, struct device_node *node,
-			    const u32 *intspec, unsigned int intsize,
-			    unsigned long *out_hwirq, unsigned int *out_type);
-#endif /* CONFIG_OF */
+	int (*xlate)(struct irq_domain *d, struct device_node *node,
+		     const u32 *intspec, unsigned int intsize,
+		     unsigned long *out_hwirq, unsigned int *out_type);
 };
 
 /**
  * struct irq_domain - Hardware interrupt number translation object
- * @list: Element in global irq_domain list.
+ * @link: Element in global irq_domain list.
+ * @revmap_type: Method used for reverse mapping hwirq numbers to linux irq. This
+ *               will be one of the IRQ_DOMAIN_MAP_* values.
+ * @revmap_data: Revmap method specific data.
+ * @ops: pointer to irq_domain methods
+ * @host_data: private data pointer for use by owner.  Not touched by irq_domain
+ *             core code.
  * @irq_base: Start of irq_desc range assigned to the irq_domain.  The creator
  *            of the irq_domain is responsible for allocating the array of
  *            irq_desc structures.
  * @nr_irq: Number of irqs managed by the irq domain
  * @hwirq_base: Starting number for hwirqs managed by the irq domain
- * @ops: pointer to irq_domain methods
- * @priv: private data pointer for use by owner.  Not touched by irq_domain
- *        core code.
  * @of_node: (optional) Pointer to device tree nodes associated with the
  *           irq_domain.  Used when decoding device tree interrupt specifiers.
  */
 struct irq_domain {
-	struct list_head list;
+	struct list_head link;
+
+	/* type of reverse mapping_technique */
+	unsigned int revmap_type;
+#define IRQ_DOMAIN_MAP_LEGACY 0 /* legacy 8259, gets irqs 1..15 */
+#define IRQ_DOMAIN_MAP_NOMAP 1 /* no fast reverse mapping */
+#define IRQ_DOMAIN_MAP_LINEAR 2 /* linear map of interrupts */
+#define IRQ_DOMAIN_MAP_TREE 3 /* radix tree */
+	union {
+		struct {
+			unsigned int size;
+			unsigned int *revmap;
+		} linear;
+		struct radix_tree_root tree;
+	} revmap_data;
+	struct irq_domain_ops *ops;
+	void *host_data;
+	irq_hw_number_t inval_irq;
+
 	unsigned int irq_base;
 	unsigned int nr_irq;
 	unsigned int hwirq_base;
-	const struct irq_domain_ops *ops;
-	void *priv;
+
+	/* Optional device node pointer */
 	struct device_node *of_node;
 };
 
+#ifdef CONFIG_IRQ_DOMAIN
 /**
  * irq_domain_to_irq() - Translate from a hardware irq to a linux irq number
  *

commit c87fb57346fc7653ace98769f148e0dcd88ac1ee
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Wed Dec 14 23:43:16 2011 +0100

    ARM: 7235/1: irqdomain: export irq_domain_simple_ops for !CONFIG_OF
    
    irqdomain support is used in interrupt controller drivers that may not
    have device tree support but only need the basic HW->Linux irq
    translation.  Rather than having each of these implement their own IRQ
    domain, allow them to use the simple ops.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rob Herring <robherring2@gmail.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 99834e581b9e..bd4272b61a14 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -91,10 +91,11 @@ static inline unsigned int irq_domain_to_irq(struct irq_domain *d,
 
 extern void irq_domain_add(struct irq_domain *domain);
 extern void irq_domain_del(struct irq_domain *domain);
+
+extern struct irq_domain_ops irq_domain_simple_ops;
 #endif /* CONFIG_IRQ_DOMAIN */
 
 #if defined(CONFIG_IRQ_DOMAIN) && defined(CONFIG_OF_IRQ)
-extern struct irq_domain_ops irq_domain_simple_ops;
 extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
 extern void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start);

commit 6d274309d0e64bdbdb6c50945ca2964596e8fa5a
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Sep 30 10:48:38 2011 -0500

    irq: support domains with non-zero hwirq base
    
    Interrupt controllers can have non-zero starting value for h/w irq numbers.
    Adding support in irq_domain allows the domain hwirq numbering to match
    the interrupt controllers' numbering.
    
    As this makes looping over irqs for a domain more complicated, add loop
    iterators to iterate over all hwirqs and irqs for a domain.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Thomas Abraham <thomas.abraham@linaro.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 3ad553e8eae2..99834e581b9e 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -47,6 +47,7 @@ struct irq_domain_ops {
  *            of the irq_domain is responsible for allocating the array of
  *            irq_desc structures.
  * @nr_irq: Number of irqs managed by the irq domain
+ * @hwirq_base: Starting number for hwirqs managed by the irq domain
  * @ops: pointer to irq_domain methods
  * @priv: private data pointer for use by owner.  Not touched by irq_domain
  *        core code.
@@ -57,6 +58,7 @@ struct irq_domain {
 	struct list_head list;
 	unsigned int irq_base;
 	unsigned int nr_irq;
+	unsigned int hwirq_base;
 	const struct irq_domain_ops *ops;
 	void *priv;
 	struct device_node *of_node;
@@ -72,9 +74,21 @@ struct irq_domain {
 static inline unsigned int irq_domain_to_irq(struct irq_domain *d,
 					     unsigned long hwirq)
 {
-	return d->ops->to_irq ? d->ops->to_irq(d, hwirq) : d->irq_base + hwirq;
+	if (d->ops->to_irq)
+		return d->ops->to_irq(d, hwirq);
+	if (WARN_ON(hwirq < d->hwirq_base))
+		return 0;
+	return d->irq_base + hwirq - d->hwirq_base;
 }
 
+#define irq_domain_for_each_hwirq(d, hw) \
+	for (hw = d->hwirq_base; hw < d->hwirq_base + d->nr_irq; hw++)
+
+#define irq_domain_for_each_irq(d, hw, irq) \
+	for (hw = d->hwirq_base, irq = irq_domain_to_irq(d, hw); \
+	     hw < d->hwirq_base + d->nr_irq; \
+	     hw++, irq = irq_domain_to_irq(d, hw))
+
 extern void irq_domain_add(struct irq_domain *domain);
 extern void irq_domain_del(struct irq_domain *domain);
 #endif /* CONFIG_IRQ_DOMAIN */

commit 5bd078dda4d4fbdb4bd138a6bd5b6e274c019ed2
Author: Rob Herring <robherring2@gmail.com>
Date:   Wed Sep 14 11:31:36 2011 -0500

    irq: Add declaration of irq_domain_simple_ops to irqdomain.h
    
    irq_domain_simple_ops is exported, but is not declared in irqdomain.h,
    so add it.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: marc.zyngier@arm.com
    Cc: thomas.abraham@linaro.org
    Cc: jamie@jamieiles.com
    Cc: b-cousson@ti.com
    Cc: shawn.guo@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: devicetree-discuss@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/1316017900-19918-2-git-send-email-robherring2@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index e807ad687a07..3ad553e8eae2 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -80,6 +80,7 @@ extern void irq_domain_del(struct irq_domain *domain);
 #endif /* CONFIG_IRQ_DOMAIN */
 
 #if defined(CONFIG_IRQ_DOMAIN) && defined(CONFIG_OF_IRQ)
+extern struct irq_domain_ops irq_domain_simple_ops;
 extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
 extern void irq_domain_generate_simple(const struct of_device_id *match,
 					u64 phys_base, unsigned int irq_start);

commit 7e71330169d8056536b299290544980bccc6b300
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jul 26 03:19:06 2011 -0600

    dt/irq: add irq_domain_generate_simple() helper
    
    irq_domain_generate_simple() is an easy way to generate an irq translation
    domain for simple irq controllers.  It assumes a flat 1:1 mapping from
    hardware irq number to an offset of the first linux irq number assigned
    to the controller
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index 8f2c10a784a4..e807ad687a07 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -16,6 +16,7 @@
 #define _LINUX_IRQDOMAIN_H
 
 #include <linux/irq.h>
+#include <linux/mod_devicetable.h>
 
 #ifdef CONFIG_IRQ_DOMAIN
 struct device_node;
@@ -78,4 +79,13 @@ extern void irq_domain_add(struct irq_domain *domain);
 extern void irq_domain_del(struct irq_domain *domain);
 #endif /* CONFIG_IRQ_DOMAIN */
 
+#if defined(CONFIG_IRQ_DOMAIN) && defined(CONFIG_OF_IRQ)
+extern void irq_domain_add_simple(struct device_node *controller, int irq_base);
+extern void irq_domain_generate_simple(const struct of_device_id *match,
+					u64 phys_base, unsigned int irq_start);
+#else /* CONFIG_IRQ_DOMAIN && CONFIG_OF_IRQ */
+static inline void irq_domain_generate_simple(const struct of_device_id *match,
+					u64 phys_base, unsigned int irq_start) { }
+#endif /* CONFIG_IRQ_DOMAIN && CONFIG_OF_IRQ */
+
 #endif /* _LINUX_IRQDOMAIN_H */

commit 08a543ad33fc188650801bd36eed4ffe272643e1
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jul 26 03:19:06 2011 -0600

    irq: add irq_domain translation infrastructure
    
    This patch adds irq_domain infrastructure for translating from
    hardware irq numbers to linux irqs.  This is particularly important
    for architectures adding device tree support because the current
    implementation (excluding PowerPC and SPARC) cannot handle
    translation for more than a single interrupt controller.  irq_domain
    supports device tree translation for any number of interrupt
    controllers.
    
    This patch converts x86, Microblaze, ARM and MIPS to use irq_domain
    for device tree irq translation.  x86 is untested beyond compiling it,
    irq_domain is enabled for MIPS and Microblaze, but the old behaviour is
    preserved until the core code is modified to actually register an
    irq_domain yet.  On ARM it works and is required for much of the new
    ARM device tree board support.
    
    PowerPC has /not/ been converted to use this new infrastructure.  It
    is still missing some features before it can replace the virq
    infrastructure already in powerpc (see documentation on
    irq_domain_map/unmap for details).  Followup patches will add the
    missing pieces and migrate PowerPC to use irq_domain.
    
    SPARC has its own method of managing interrupts from the device tree
    and is unaffected by this change.
    
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
new file mode 100644
index 000000000000..8f2c10a784a4
--- /dev/null
+++ b/include/linux/irqdomain.h
@@ -0,0 +1,81 @@
+/*
+ * irq_domain - IRQ translation domains
+ *
+ * Translation infrastructure between hw and linux irq numbers.  This is
+ * helpful for interrupt controllers to implement mapping between hardware
+ * irq numbers and the Linux irq number space.
+ *
+ * irq_domains also have a hook for translating device tree interrupt
+ * representation into a hardware irq number that can be mapped back to a
+ * Linux irq number without any extra platform support code.
+ *
+ * irq_domain is expected to be embedded in an interrupt controller's private
+ * data structure.
+ */
+#ifndef _LINUX_IRQDOMAIN_H
+#define _LINUX_IRQDOMAIN_H
+
+#include <linux/irq.h>
+
+#ifdef CONFIG_IRQ_DOMAIN
+struct device_node;
+struct irq_domain;
+
+/**
+ * struct irq_domain_ops - Methods for irq_domain objects
+ * @to_irq: (optional) given a local hardware irq number, return the linux
+ *          irq number.  If to_irq is not implemented, then the irq_domain
+ *          will use this translation: irq = (domain->irq_base + hwirq)
+ * @dt_translate: Given a device tree node and interrupt specifier, decode
+ *                the hardware irq number and linux irq type value.
+ */
+struct irq_domain_ops {
+	unsigned int (*to_irq)(struct irq_domain *d, unsigned long hwirq);
+
+#ifdef CONFIG_OF
+	int (*dt_translate)(struct irq_domain *d, struct device_node *node,
+			    const u32 *intspec, unsigned int intsize,
+			    unsigned long *out_hwirq, unsigned int *out_type);
+#endif /* CONFIG_OF */
+};
+
+/**
+ * struct irq_domain - Hardware interrupt number translation object
+ * @list: Element in global irq_domain list.
+ * @irq_base: Start of irq_desc range assigned to the irq_domain.  The creator
+ *            of the irq_domain is responsible for allocating the array of
+ *            irq_desc structures.
+ * @nr_irq: Number of irqs managed by the irq domain
+ * @ops: pointer to irq_domain methods
+ * @priv: private data pointer for use by owner.  Not touched by irq_domain
+ *        core code.
+ * @of_node: (optional) Pointer to device tree nodes associated with the
+ *           irq_domain.  Used when decoding device tree interrupt specifiers.
+ */
+struct irq_domain {
+	struct list_head list;
+	unsigned int irq_base;
+	unsigned int nr_irq;
+	const struct irq_domain_ops *ops;
+	void *priv;
+	struct device_node *of_node;
+};
+
+/**
+ * irq_domain_to_irq() - Translate from a hardware irq to a linux irq number
+ *
+ * Returns the linux irq number associated with a hardware irq.  By default,
+ * the mapping is irq == domain->irq_base + hwirq, but this mapping can
+ * be overridden if the irq_domain implements a .to_irq() hook.
+ */
+static inline unsigned int irq_domain_to_irq(struct irq_domain *d,
+					     unsigned long hwirq)
+{
+	return d->ops->to_irq ? d->ops->to_irq(d, hwirq) : d->irq_base + hwirq;
+}
+
+extern void irq_domain_add(struct irq_domain *domain);
+extern void irq_domain_del(struct irq_domain *domain);
+#endif /* CONFIG_IRQ_DOMAIN */
+
+#endif /* _LINUX_IRQDOMAIN_H */
