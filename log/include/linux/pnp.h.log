commit 01b2bafe57b19d9119413f138765ef57990921ce
Author: Jason Gunthorpe <jgg@mellanox.com>
Date:   Tue Apr 14 12:10:50 2020 -0300

    pnp: Use list_for_each_entry() instead of open coding
    
    Aside from good practice, this avoids a warning from gcc 10:
    
    ./include/linux/kernel.h:997:3: warning: array subscript -31 is outside array bounds of ‘struct list_head[1]’ [-Warray-bounds]
      997 |  ((type *)(__mptr - offsetof(type, member))); })
          |  ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ./include/linux/list.h:493:2: note: in expansion of macro ‘container_of’
      493 |  container_of(ptr, type, member)
          |  ^~~~~~~~~~~~
    ./include/linux/pnp.h:275:30: note: in expansion of macro ‘list_entry’
      275 | #define global_to_pnp_dev(n) list_entry(n, struct pnp_dev, global_list)
          |                              ^~~~~~~~~~
    ./include/linux/pnp.h:281:11: note: in expansion of macro ‘global_to_pnp_dev’
      281 |  (dev) != global_to_pnp_dev(&pnp_global); \
          |           ^~~~~~~~~~~~~~~~~
    arch/x86/kernel/rtc.c:189:2: note: in expansion of macro ‘pnp_for_each_dev’
      189 |  pnp_for_each_dev(dev) {
    
    Because the common code doesn't cast the starting list_head to the
    containing struct.
    
    Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
    [ rjw: Whitespace adjustments ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b18dca67253d..c2a7cfbca713 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -220,10 +220,8 @@ struct pnp_card {
 #define global_to_pnp_card(n) list_entry(n, struct pnp_card, global_list)
 #define protocol_to_pnp_card(n) list_entry(n, struct pnp_card, protocol_list)
 #define to_pnp_card(n) container_of(n, struct pnp_card, dev)
-#define pnp_for_each_card(card) \
-	for((card) = global_to_pnp_card(pnp_cards.next); \
-	(card) != global_to_pnp_card(&pnp_cards); \
-	(card) = global_to_pnp_card((card)->global_list.next))
+#define pnp_for_each_card(card)	\
+	list_for_each_entry(card, &pnp_cards, global_list)
 
 struct pnp_card_link {
 	struct pnp_card *card;
@@ -276,14 +274,9 @@ struct pnp_dev {
 #define card_to_pnp_dev(n) list_entry(n, struct pnp_dev, card_list)
 #define protocol_to_pnp_dev(n) list_entry(n, struct pnp_dev, protocol_list)
 #define	to_pnp_dev(n) container_of(n, struct pnp_dev, dev)
-#define pnp_for_each_dev(dev) \
-	for((dev) = global_to_pnp_dev(pnp_global.next); \
-	(dev) != global_to_pnp_dev(&pnp_global); \
-	(dev) = global_to_pnp_dev((dev)->global_list.next))
-#define card_for_each_dev(card,dev) \
-	for((dev) = card_to_pnp_dev((card)->devices.next); \
-	(dev) != card_to_pnp_dev(&(card)->devices); \
-	(dev) = card_to_pnp_dev((dev)->card_list.next))
+#define pnp_for_each_dev(dev) list_for_each_entry(dev, &pnp_global, global_list)
+#define card_for_each_dev(card, dev)	\
+	list_for_each_entry(dev, &(card)->devices, card_list)
 #define pnp_dev_name(dev) (dev)->name
 
 static inline void *pnp_get_drvdata(struct pnp_dev *pdev)
@@ -437,14 +430,10 @@ struct pnp_protocol {
 };
 
 #define to_pnp_protocol(n) list_entry(n, struct pnp_protocol, protocol_list)
-#define protocol_for_each_card(protocol,card) \
-	for((card) = protocol_to_pnp_card((protocol)->cards.next); \
-	(card) != protocol_to_pnp_card(&(protocol)->cards); \
-	(card) = protocol_to_pnp_card((card)->protocol_list.next))
-#define protocol_for_each_dev(protocol,dev) \
-	for((dev) = protocol_to_pnp_dev((protocol)->devices.next); \
-	(dev) != protocol_to_pnp_dev(&(protocol)->devices); \
-	(dev) = protocol_to_pnp_dev((dev)->protocol_list.next))
+#define protocol_for_each_card(protocol, card)	\
+	list_for_each_entry(card, &(protocol)->cards, protocol_list)
+#define protocol_for_each_dev(protocol, dev)	\
+	list_for_each_entry(dev, &(protocol)->devices, protocol_list)
 
 extern struct bus_type pnp_bus_type;
 

commit b927ddf2dd1807e62946129cfbc7754fdcde85c4
Author: Corentin Labbe <clabbe@baylibre.com>
Date:   Fri Mar 6 07:53:00 2020 +0000

    PNP: constify driver name
    
    struct pnp_driver has name set as char* instead of const char* like platform_driver, pci_driver, usb_driver, etc...
    Let's unify a bit by setting name as const char*.
    Furthermore, all users of this structures set name from already const
    data.
    
    Signed-off-by: Corentin Labbe <clabbe@baylibre.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 3b12fd28af78..b18dca67253d 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -379,7 +379,7 @@ struct pnp_id {
 };
 
 struct pnp_driver {
-	char *name;
+	const char *name;
 	const struct pnp_device_id *id_table;
 	unsigned int flags;
 	int (*probe) (struct pnp_dev *dev, const struct pnp_device_id *dev_id);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 2588ca6a9028..3b12fd28af78 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Linux Plug and Play Support
  * Copyright by Adam Belay <ambx1@neo.rr.com>

commit 80dfd83dfab6e49a31ab8fc484a801aef1c567bd
Author: Luis R. Rodriguez <mcgrof@kernel.org>
Date:   Wed Apr 13 17:04:41 2016 -0700

    x86, drivers/pnpbios: Replace paravirt_enabled() check with legacy device check
    
    Since we are removing paravirt_enabled() replace it with a
    logical equivalent. Even though PNPBIOS is x86 specific we
    add an arch-specific type call, which can be implemented by
    any architecture to show how other legacy attribute devices
    can later be also checked for with other ACPI legacy attribute
    flags.
    
    This implicates the first ACPI 5.2.9.3 IA-PC Boot Architecture
    ACPI_FADT_LEGACY_DEVICES flag device, and shows how to add more.
    
    The reason pnpbios gets a defined structure and as such uses
    a different approach than the RTC legacy quirk is that ACPI
    has a respective RTC flag, while pnpbios does not. We fold
    the pnpbios quirk under ACPI_FADT_LEGACY_DEVICES ACPI flag
    use case, and use a struct of possible devices to enable
    future extensions of this.
    
    As per 0-day, this bumps the vmlinux size using i386-tinyconfig as
    follows:
    
    TOTAL   TEXT   init.text   x86_early_init_platform_quirks()
    +32     +28    +28         +28
    
    That's 4 byte overhead total, the rest is cleared out on init
    as its all __init text.
    
    v2: split out subarch handlng on switch to make it easier
        later to add other subarchs. The 'fall-through' switch
        handling can be confusing and we'll remove it later
        when we add handling for X86_SUBARCH_CE4100.
    v3: document vmlinux size impact as per 0-day, and also
        explain why pnpbios is treated differently than the
        RTC legacy feature.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: andrew.cooper3@citrix.com
    Cc: andriy.shevchenko@linux.intel.com
    Cc: bigeasy@linutronix.de
    Cc: boris.ostrovsky@oracle.com
    Cc: david.vrabel@citrix.com
    Cc: ffainelli@freebox.fr
    Cc: george.dunlap@citrix.com
    Cc: glin@suse.com
    Cc: jgross@suse.com
    Cc: jlee@suse.com
    Cc: josh@joshtriplett.org
    Cc: julien.grall@linaro.org
    Cc: konrad.wilk@oracle.com
    Cc: kozerkov@parallels.com
    Cc: lenb@kernel.org
    Cc: lguest@lists.ozlabs.org
    Cc: linux-acpi@vger.kernel.org
    Cc: lv.zheng@intel.com
    Cc: matt@codeblueprint.co.uk
    Cc: mbizon@freebox.fr
    Cc: rjw@rjwysocki.net
    Cc: robert.moore@intel.com
    Cc: rusty@rustcorp.com.au
    Cc: tiwai@suse.de
    Cc: toshi.kani@hp.com
    Cc: xen-devel@lists.xensource.com
    Link: http://lkml.kernel.org/r/1460592286-300-12-git-send-email-mcgrof@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 5df733b8f704..2588ca6a9028 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -337,9 +337,11 @@ extern struct mutex pnp_res_mutex;
 
 #ifdef CONFIG_PNPBIOS
 extern struct pnp_protocol pnpbios_protocol;
+extern bool arch_pnpbios_disabled(void);
 #define pnp_device_is_pnpbios(dev) ((dev)->protocol == (&pnpbios_protocol))
 #else
 #define pnp_device_is_pnpbios(dev) 0
+#define arch_pnpbios_disabled()	false
 #endif
 
 #ifdef CONFIG_PNPACPI

commit 95c0fd457b03099b5ce385f3982e06d01ad42c5c
Author: Peter Huewe <PeterHuewe@gmx.de>
Date:   Mon Mar 16 21:46:30 2015 +0100

    PNP: Add helper macro for pnp_register_driver boilerplate
    
    This patch introduces the module_pnp_driver macro which is a
    convenience macro for PNP driver modules similar to module_pci_driver.
    It is intended to be used by drivers which init/exit section does nothing
    but register/unregister the PNP driver. By using this macro it is
    possible to eliminate a few lines of boilerplate code per PNP driver.
    
    Based on work done by Lars-Peter Clausen <lars@metafoo.de> for other
    busses (i2c and spi) and Greg KH for PCI.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 6512e9cbc6d5..5df733b8f704 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -510,4 +510,16 @@ static inline void pnp_unregister_driver(struct pnp_driver *drv) { }
 
 #endif /* CONFIG_PNP */
 
+/**
+ * module_pnp_driver() - Helper macro for registering a PnP driver
+ * @__pnp_driver: pnp_driver struct
+ *
+ * Helper macro for PnP drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_pnp_driver(__pnp_driver) \
+	module_driver(__pnp_driver, pnp_register_driver, \
+				    pnp_unregister_driver)
+
 #endif /* _LINUX_PNP_H */

commit 01395d798452435f19de3bfe5d04325db4e49677
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Jan 22 11:50:24 2015 -0500

    PNP: Allow console to override ACPI device sleep
    
    If the serial console is an ACPI PNP device, the PNP bus always powers
    down the device at system suspend, even though the no_console_suspend
    command line parameter is specified (eg., when debugging suspend/resume).
    
    Add PNP_CONSOLE capability, which when set, prevents calling both the
    ->disable() and ->suspend() PNP protocol methods if console suspend
    is disabled.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 195aafc6cd07..6512e9cbc6d5 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -12,6 +12,7 @@
 #include <linux/list.h>
 #include <linux/errno.h>
 #include <linux/mod_devicetable.h>
+#include <linux/console.h>
 
 #define PNP_NAME_LEN		50
 
@@ -309,15 +310,22 @@ struct pnp_fixup {
 #define PNP_DISABLE		0x0004
 #define PNP_CONFIGURABLE	0x0008
 #define PNP_REMOVABLE		0x0010
+#define PNP_CONSOLE		0x0020
 
 #define pnp_can_read(dev)	(((dev)->protocol->get) && \
 				 ((dev)->capabilities & PNP_READ))
 #define pnp_can_write(dev)	(((dev)->protocol->set) && \
 				 ((dev)->capabilities & PNP_WRITE))
-#define pnp_can_disable(dev)	(((dev)->protocol->disable) && \
-				 ((dev)->capabilities & PNP_DISABLE))
+#define pnp_can_disable(dev)	(((dev)->protocol->disable) &&		  \
+				 ((dev)->capabilities & PNP_DISABLE) &&	  \
+				 (!((dev)->capabilities & PNP_CONSOLE) || \
+				  console_suspend_enabled))
 #define pnp_can_configure(dev)	((!(dev)->active) && \
 				 ((dev)->capabilities & PNP_CONFIGURABLE))
+#define pnp_can_suspend(dev)	(((dev)->protocol->suspend) &&		  \
+				 (!((dev)->capabilities & PNP_CONSOLE) || \
+				  console_suspend_enabled))
+
 
 #ifdef CONFIG_ISAPNP
 extern struct pnp_protocol isapnp_protocol;

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 1bc1338b817b..195aafc6cd07 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -50,7 +50,7 @@ static inline resource_size_t pnp_resource_len(struct resource *res)
 {
 	if (res->start == 0 && res->end == 0)
 		return 0;
-	return res->end - res->start + 1;
+	return resource_size(res);
 }
 
 

commit b14e033e17d0ea0ba12668d0d2f371cd31586994
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 29 22:49:24 2010 +0200

    PNPACPI: Add support for remote wakeup
    
    This patch (as1354) adds remote-wakeup support to the pnpacpi driver.
    The new can_wakeup method also allows other PNP protocol drivers
    (pnpbios or iaspnp) to add wakeup support, but I don't know enough
    about how they work to actually do it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 7c4193eb0072..1bc1338b817b 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -414,6 +414,7 @@ struct pnp_protocol {
 	int (*disable) (struct pnp_dev *dev);
 
 	/* protocol specific suspend/resume */
+	bool (*can_wakeup) (struct pnp_dev *dev);
 	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
 	int (*resume) (struct pnp_dev * dev);
 

commit 9065ce4500085b9ca66b19d3c4d21a73cb410173
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Nov 17 17:05:19 2009 -0700

    PNP: add interface to retrieve ACPI device from a PNPACPI device
    
    Add pnp_acpi_device(pnp_dev), which takes a PNP device and returns the
    associated ACPI device (or NULL, if the device is not a PNPACPI device).
    
    This allows us to write a PNP driver that can manage both traditional
    PNPBIOS and ACPI devices, treating ACPI-only functionality as an optional
    extension.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index fddfafaed024..7c4193eb0072 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -334,6 +334,19 @@ extern struct pnp_protocol pnpbios_protocol;
 #define pnp_device_is_pnpbios(dev) 0
 #endif
 
+#ifdef CONFIG_PNPACPI
+extern struct pnp_protocol pnpacpi_protocol;
+
+static inline struct acpi_device *pnp_acpi_device(struct pnp_dev *dev)
+{
+	if (dev->protocol == &pnpacpi_protocol)
+		return dev->data;
+	return NULL;
+}
+#else
+#define pnp_acpi_device(dev) 0
+#endif
+
 /* status */
 #define PNP_READY		0x0000
 #define PNP_ATTACHED		0x0001

commit abd6633c67925f90775bb74755f9c547e30f1f20
Author: David Härdeman <david@hardeman.nu>
Date:   Mon Sep 21 17:04:52 2009 -0700

    pnp: add a shutdown method to pnp drivers
    
    The shutdown method is used by the winbond cir driver to setup the
    hardware for wake-from-S5.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b063c7328ba5..fddfafaed024 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -360,6 +360,7 @@ struct pnp_driver {
 	unsigned int flags;
 	int (*probe) (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
 	void (*remove) (struct pnp_dev *dev);
+	void (*shutdown) (struct pnp_dev *dev);
 	int (*suspend) (struct pnp_dev *dev, pm_message_t state);
 	int (*resume) (struct pnp_dev *dev);
 	struct device_driver driver;

commit 1b8e69662e1a086878bf930a6042daf7f8a076cc
Author: Bjorn Helgaas <bjorn.helgaas at hp.com>
Date:   Fri Jun 5 14:37:23 2009 +0000

    pnp: add PNP resource range checking function
    
    Add a PNP resource range check function, indicating whether a resource
    has been assigned to any device.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    [apw@canonical.com: fixed up exports et al]
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index ca3c88773028..b063c7328ba5 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -446,6 +446,7 @@ int pnp_start_dev(struct pnp_dev *dev);
 int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
 int pnp_disable_dev(struct pnp_dev *dev);
+int pnp_range_reserved(resource_size_t start, resource_size_t end);
 
 /* protocol helpers */
 int pnp_is_active(struct pnp_dev *dev);
@@ -476,6 +477,7 @@ static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_range_reserved(resource_size_t start, resource_size_t end) { return 0;}
 
 /* protocol helpers */
 static inline int pnp_is_active(struct pnp_dev *dev) { return 0; }

commit 057316cc6a5b521b332a1d7ccc871cd60c904c74
Merge: 3e2dab9a1c2d 2515ddc6db8e
Author: Len Brown <len.brown@intel.com>
Date:   Wed Oct 22 23:57:26 2008 -0400

    Merge branch 'linus' into test
    
    Conflicts:
            MAINTAINERS
            arch/x86/kernel/acpi/boot.c
            arch/x86/kernel/acpi/sleep.c
            drivers/acpi/Kconfig
            drivers/pnp/Makefile
            drivers/pnp/quirks.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit b563cf59c4d67da7d671788a9848416bfa4180ab
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Oct 15 22:03:58 2008 -0700

    pnp: make the resource type an unsigned long
    
    PnP encodes the resource type directly as its struct resource->flags value
    which is an unsigned long.  Make it so...
    
    Signed-off-by: Rene Herman <rene.herman@gmail.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index be764e514e35..53b70fd1d9a5 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -22,9 +22,11 @@ struct pnp_dev;
  * Resource Management
  */
 #ifdef CONFIG_PNP
-struct resource *pnp_get_resource(struct pnp_dev *, unsigned int, unsigned int);
+struct resource *pnp_get_resource(struct pnp_dev *dev, unsigned long type,
+				unsigned int num);
 #else
-static inline struct resource *pnp_get_resource(struct pnp_dev *dev, unsigned int type, unsigned int num)
+static inline struct resource *pnp_get_resource(struct pnp_dev *dev,
+			unsigned long type, unsigned int num)
 {
 	return NULL;
 }

commit c865d2f6eb160c15b74245b4891c8e945d67d96c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Aug 19 16:53:26 2008 -0600

    PNP: convert the last few pnp_info() uses to printk()
    
    There are only a few remaining uses of pnp_info(), so I just
    converted them to printk and removed the pnp_err(), pnp_info(),
    pnp_warn(), and pnp_dbg() wrappers.
    
    I also removed a couple debug messages that don't seem useful any
    more ("driver registered", "driver unregistered", "driver attached").
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index be764e514e35..05daecec16c5 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -483,14 +483,4 @@ static inline void pnp_unregister_driver(struct pnp_driver *drv) { }
 
 #endif /* CONFIG_PNP */
 
-#define pnp_err(format, arg...) printk(KERN_ERR "pnp: " format "\n" , ## arg)
-#define pnp_info(format, arg...) printk(KERN_INFO "pnp: " format "\n" , ## arg)
-#define pnp_warn(format, arg...) printk(KERN_WARNING "pnp: " format "\n" , ## arg)
-
-#ifdef CONFIG_PNP_DEBUG
-#define pnp_dbg(format, arg...) printk(KERN_DEBUG "pnp: " format "\n" , ## arg)
-#else
-#define pnp_dbg(format, arg...) do {} while (0)
-#endif
-
 #endif /* _LINUX_PNP_H */

commit ef3d7714f6b75b51825ad0384b5ce48358427e50
Author: David Miller <davem@davemloft.net>
Date:   Tue Sep 16 15:00:11 2008 -0700

    Fix PNP build failure, bugzilla #11276
    
    This fill fix the following regression list entry:
    
    Bug-Entry       : http://bugzilla.kernel.org/show_bug.cgi?id=11276
    Subject         : build error: CONFIG_OPTIMIZE_INLINING=y causes gcc 4.2 to do stupid things
    Submitter       : Randy Dunlap <randy.dunlap@oracle.com>
    Date            : 2008-08-06 17:18 (38 days old)
    References      : http://marc.info/?l=linux-kernel&m=121804329014332&w=4
                      http://lkml.org/lkml/2008/7/22/353
    Handled-By      : Bjorn Helgaas <bjorn.helgaas@hp.com>
    Patch           : http://lkml.org/lkml/2008/7/22/364
    
    with what I believe is a better fix than the one referenced
    in the regression entry above.
    
    These PNP header interfaces try to work in such a way that
    you can reference some of them even if PNP is not enabled,
    and the compiler was expected to optimize everything away.
    
    Which is mostly fine, except that there was one interface
    for which there was not provided an inline "NOP" implementation.
    
    Once we add that, all of these compile failures cannot handle
    any more.
    
    pnp: Provide NOP inline implementation of pnp_get_resource() when !PNP
    
    Fixes kernel bugzilla #11276.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 1ce54b63085d..be764e514e35 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -21,7 +21,14 @@ struct pnp_dev;
 /*
  * Resource Management
  */
+#ifdef CONFIG_PNP
 struct resource *pnp_get_resource(struct pnp_dev *, unsigned int, unsigned int);
+#else
+static inline struct resource *pnp_get_resource(struct pnp_dev *dev, unsigned int type, unsigned int num)
+{
+	return NULL;
+}
+#endif
 
 static inline int pnp_resource_valid(struct resource *res)
 {

commit 1f32ca31e7409d37c1b25e5f81840fb184380cdf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:17 2008 -0600

    PNP: convert resource options to single linked list
    
    ISAPNP, PNPBIOS, and ACPI describe the "possible resource settings" of
    a device, i.e., the possibilities an OS bus driver has when it assigns
    I/O port, MMIO, and other resources to the device.
    
    PNP used to maintain this "possible resource setting" information in
    one independent option structure and a list of dependent option
    structures for each device.  Each of these option structures had lists
    of I/O, memory, IRQ, and DMA resources, for example:
    
      dev
        independent options
          ind-io0  -> ind-io1  ...
          ind-mem0 -> ind-mem1 ...
          ...
        dependent option set 0
          dep0-io0  -> dep0-io1  ...
          dep0-mem0 -> dep0-mem1 ...
          ...
        dependent option set 1
          dep1-io0  -> dep1-io1  ...
          dep1-mem0 -> dep1-mem1 ...
          ...
        ...
    
    This data structure was designed for ISAPNP, where the OS configures
    device resource settings by writing directly to configuration
    registers.  The OS can write the registers in arbitrary order much
    like it writes PCI BARs.
    
    However, for PNPBIOS and ACPI devices, the OS uses firmware interfaces
    that perform device configuration, and it is important to pass the
    desired settings to those interfaces in the correct order.  The OS
    learns the correct order by using firmware interfaces that return the
    "current resource settings" and "possible resource settings," but the
    option structures above doesn't store the ordering information.
    
    This patch replaces the independent and dependent lists with a single
    list of options.  For example, a device might have possible resource
    settings like this:
    
      dev
        options
          ind-io0 -> dep0-io0 -> dep1->io0 -> ind-io1 ...
    
    All the possible settings are in the same list, in the order they
    come from the firmware "possible resource settings" list.  Each entry
    is tagged with an independent/dependent flag.  Dependent entries also
    have a "set number" and an optional priority value.  All dependent
    entries must be assigned from the same set.  For example, the OS can
    use all the entries from dependent set 0, or all the entries from
    dependent set 1, but it cannot mix entries from set 0 with entries
    from set 1.
    
    Prior to this patch PNP didn't keep track of the order of this list,
    and it assigned all independent options first, then all dependent
    ones.  Using the example above, that resulted in a "desired
    configuration" list like this:
    
      ind->io0 -> ind->io1 -> depN-io0 ...
    
    instead of the list the firmware expects, which looks like this:
    
      ind->io0 -> depN-io0 -> ind-io1 ...
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 785126ffcc11..1ce54b63085d 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -1,6 +1,8 @@
 /*
  * Linux Plug and Play Support
  * Copyright by Adam Belay <ambx1@neo.rr.com>
+ * Copyright (C) 2008 Hewlett-Packard Development Company, L.P.
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  */
 
 #ifndef _LINUX_PNP_H
@@ -249,9 +251,9 @@ struct pnp_dev {
 
 	int active;
 	int capabilities;
-	struct pnp_option *independent;
-	struct pnp_option *dependent;
+	unsigned int num_dependent_sets;
 	struct list_head resources;
+	struct list_head options;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
 	int flags;			/* used by protocols */

commit a1802c42950403657d07e64558eff612d550ce16
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:04 2008 -0600

    PNP: make resource option structures private to PNP subsystem
    
    Nothing outside the PNP subsystem should need access to a
    device's resource options, so this patch moves the option
    structure declarations to a private header file.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index e1454dabde10..785126ffcc11 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -182,54 +182,6 @@ static inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)
 }
 
 
-struct pnp_port {
-	unsigned short min;	/* min base number */
-	unsigned short max;	/* max base number */
-	unsigned char align;	/* align boundary */
-	unsigned char size;	/* size of range */
-	unsigned char flags;	/* port flags */
-	unsigned char pad;	/* pad */
-	struct pnp_port *next;	/* next port */
-};
-
-#define PNP_IRQ_NR 256
-struct pnp_irq {
-	DECLARE_BITMAP(map, PNP_IRQ_NR);	/* bitmask for IRQ lines */
-	unsigned char flags;	/* IRQ flags */
-	unsigned char pad;	/* pad */
-	struct pnp_irq *next;	/* next IRQ */
-};
-
-struct pnp_dma {
-	unsigned char map;	/* bitmask for DMA channels */
-	unsigned char flags;	/* DMA flags */
-	struct pnp_dma *next;	/* next port */
-};
-
-struct pnp_mem {
-	unsigned int min;	/* min base number */
-	unsigned int max;	/* max base number */
-	unsigned int align;	/* align boundary */
-	unsigned int size;	/* size of range */
-	unsigned char flags;	/* memory flags */
-	unsigned char pad;	/* pad */
-	struct pnp_mem *next;	/* next memory resource */
-};
-
-#define PNP_RES_PRIORITY_PREFERRED	0
-#define PNP_RES_PRIORITY_ACCEPTABLE	1
-#define PNP_RES_PRIORITY_FUNCTIONAL	2
-#define PNP_RES_PRIORITY_INVALID	65535
-
-struct pnp_option {
-	unsigned short priority;	/* priority */
-	struct pnp_port *port;		/* first port */
-	struct pnp_irq *irq;		/* first IRQ */
-	struct pnp_dma *dma;		/* first DMA */
-	struct pnp_mem *mem;		/* first memory resource */
-	struct pnp_option *next;	/* used to chain dependent resources */
-};
-
 /*
  * Device Management
  */

commit 08c9f262f268f7948be13bf3a5bda1d635c649b4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:03 2008 -0600

    PNP: define PNP-specific IORESOURCE_IO_* flags alongside IRQ, DMA, MEM
    
    PNP previously defined PNP_PORT_FLAG_16BITADDR and PNP_PORT_FLAG_FIXED
    in a private header file, but put those flags in struct resource.flags
    fields.  Better to make them IORESOURCE_IO_* flags like the existing
    IRQ, DMA, and MEM flags.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index e033e1b14c27..e1454dabde10 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -182,9 +182,6 @@ static inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)
 }
 
 
-#define PNP_PORT_FLAG_16BITADDR	(1<<0)
-#define PNP_PORT_FLAG_FIXED	(1<<1)
-
 struct pnp_port {
 	unsigned short min;	/* min base number */
 	unsigned short max;	/* max base number */

commit 57fd51a8be26921b56747ddd09d1d9e01c11c9e0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:57:01 2008 -0600

    PNP: add pnp_possible_config() -- can a device could be configured this way?
    
    As part of a heuristic to identify modem devices, 8250_pnp.c
    checks to see whether a device can be configured at any of the
    legacy COM port addresses.
    
    This patch moves the code that traverses the PNP "possible resource
    options" from 8250_pnp.c to the PNP subsystem.  This encapsulation
    is important because a future patch will change the implementation
    of those resource options.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index dfaa567e04a8..e033e1b14c27 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -479,6 +479,8 @@ void pnp_unregister_card_driver(struct pnp_card_driver *drv);
 extern struct list_head pnp_cards;
 
 /* resource management */
+int pnp_possible_config(struct pnp_dev *dev, int type, resource_size_t base,
+			resource_size_t size);
 int pnp_auto_config_dev(struct pnp_dev *dev);
 int pnp_start_dev(struct pnp_dev *dev);
 int pnp_stop_dev(struct pnp_dev *dev);
@@ -506,6 +508,9 @@ static inline int pnp_register_card_driver(struct pnp_card_driver *drv) { return
 static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv) { }
 
 /* resource management */
+static inline int pnp_possible_config(struct pnp_dev *dev, int type,
+				      resource_size_t base,
+				      resource_size_t size) { return 0; }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }

commit aee3ad815dd291a7193ab01da0f1a30c84d00061
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:57 2008 -0600

    PNP: replace pnp_resource_table with dynamically allocated resources
    
    PNP used to have a fixed-size pnp_resource_table for tracking the
    resources used by a device.  This table often overflowed, so we've
    had to increase the table size, which wastes memory because most
    devices have very few resources.
    
    This patch replaces the table with a linked list of resources where
    the entries are allocated on demand.
    
    This removes messages like these:
    
        pnpacpi: exceeded the max number of IO resources
        00:01: too many I/O port resources
    
    References:
    
        http://bugzilla.kernel.org/show_bug.cgi?id=9535
        http://bugzilla.kernel.org/show_bug.cgi?id=9740
        http://lkml.org/lkml/2007/11/30/110
    
    This patch also changes the way PNP uses the IORESOURCE_UNSET,
    IORESOURCE_AUTO, and IORESOURCE_DISABLED flags.
    
    Prior to this patch, the pnp_resource_table entries used the flags
    like this:
    
        IORESOURCE_UNSET
            This table entry is unused and available for use.  When this flag
            is set, we shouldn't look at anything else in the resource structure.
            This flag is set when a resource table entry is initialized.
    
        IORESOURCE_AUTO
            This resource was assigned automatically by pnp_assign_{io,mem,etc}().
    
            This flag is set when a resource table entry is initialized and
            cleared whenever we discover a resource setting by reading an ISAPNP
            config register, parsing a PNPBIOS resource data stream, parsing an
            ACPI _CRS list, or interpreting a sysfs "set" command.
    
            Resources marked IORESOURCE_AUTO are reinitialized and marked as
            IORESOURCE_UNSET by pnp_clean_resource_table() in these cases:
    
                - before we attempt to assign resources automatically,
                - if we fail to assign resources automatically,
                - after disabling a device
    
        IORESOURCE_DISABLED
            Set by pnp_assign_{io,mem,etc}() when automatic assignment fails.
            Also set by PNPBIOS and PNPACPI for:
    
                - invalid IRQs or GSI registration failures
                - invalid DMA channels
                - I/O ports above 0x10000
                - mem ranges with negative length
    
    After this patch, there is no pnp_resource_table, and the resource list
    entries use the flags like this:
    
        IORESOURCE_UNSET
            This flag is no longer used in PNP.  Instead of keeping
            IORESOURCE_UNSET entries in the resource list, we remove
            entries from the list and free them.
    
        IORESOURCE_AUTO
            No change in meaning: it still means the resource was assigned
            automatically by pnp_assign_{port,mem,etc}(), but these functions
            now set the bit explicitly.
    
            We still "clean" a device's resource list in the same places,
            but rather than reinitializing IORESOURCE_AUTO entries, we
            just remove them from the list.
    
            Note that IORESOURCE_AUTO entries are always at the end of the
            list, so removing them doesn't reorder other list entries.
            This is because non-IORESOURCE_AUTO entries are added by the
            ISAPNP, PNPBIOS, or PNPACPI "get resources" methods and by the
            sysfs "set" command.  In each of these cases, we completely free
            the resource list first.
    
        IORESOURCE_DISABLED
            In addition to the cases where we used to set this flag, ISAPNP now
            adds an IORESOURCE_DISABLED resource when it reads a configuration
            register with a "disabled" value.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 8b607aecd959..dfaa567e04a8 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -15,7 +15,6 @@
 
 struct pnp_protocol;
 struct pnp_dev;
-struct pnp_resource_table;
 
 /*
  * Resource Management
@@ -24,7 +23,14 @@ struct resource *pnp_get_resource(struct pnp_dev *, unsigned int, unsigned int);
 
 static inline int pnp_resource_valid(struct resource *res)
 {
-	if (res && !(res->flags & IORESOURCE_UNSET))
+	if (res)
+		return 1;
+	return 0;
+}
+
+static inline int pnp_resource_enabled(struct resource *res)
+{
+	if (res && !(res->flags & IORESOURCE_DISABLED))
 		return 1;
 	return 0;
 }
@@ -64,7 +70,7 @@ static inline unsigned long pnp_port_flags(struct pnp_dev *dev,
 
 	if (pnp_resource_valid(res))
 		return res->flags;
-	return IORESOURCE_IO | IORESOURCE_AUTO | IORESOURCE_UNSET;
+	return IORESOURCE_IO | IORESOURCE_AUTO;
 }
 
 static inline int pnp_port_valid(struct pnp_dev *dev, unsigned int bar)
@@ -109,7 +115,7 @@ static inline unsigned long pnp_mem_flags(struct pnp_dev *dev, unsigned int bar)
 
 	if (pnp_resource_valid(res))
 		return res->flags;
-	return IORESOURCE_MEM | IORESOURCE_AUTO | IORESOURCE_UNSET;
+	return IORESOURCE_MEM | IORESOURCE_AUTO;
 }
 
 static inline int pnp_mem_valid(struct pnp_dev *dev, unsigned int bar)
@@ -143,7 +149,7 @@ static inline unsigned long pnp_irq_flags(struct pnp_dev *dev, unsigned int bar)
 
 	if (pnp_resource_valid(res))
 		return res->flags;
-	return IORESOURCE_IRQ | IORESOURCE_AUTO | IORESOURCE_UNSET;
+	return IORESOURCE_IRQ | IORESOURCE_AUTO;
 }
 
 static inline int pnp_irq_valid(struct pnp_dev *dev, unsigned int bar)
@@ -167,7 +173,7 @@ static inline unsigned long pnp_dma_flags(struct pnp_dev *dev, unsigned int bar)
 
 	if (pnp_resource_valid(res))
 		return res->flags;
-	return IORESOURCE_DMA | IORESOURCE_AUTO | IORESOURCE_UNSET;
+	return IORESOURCE_DMA | IORESOURCE_AUTO;
 }
 
 static inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)
@@ -296,7 +302,7 @@ struct pnp_dev {
 	int capabilities;
 	struct pnp_option *independent;
 	struct pnp_option *dependent;
-	struct pnp_resource_table *res;
+	struct list_head resources;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
 	int flags;			/* used by protocols */

commit 20bfdbba7212d19613b93dcea93f26cb65af91fe
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 27 16:56:56 2008 -0600

    PNP: make pnp_{port,mem,etc}_start(), et al work for invalid resources
    
    Some callers use pnp_port_start() and similar functions without
    making sure the resource is valid.  This patch makes us fall
    back to returning the initial values if the resource is not
    valid or not even present.
    
    This mostly preserves the previous behavior, where we would just
    return the initial values set by pnp_init_resource_table().  The
    original 2.6.25 code didn't range-check the "bar", so it would
    return garbage if the bar exceeded the table size.  This code
    returns sensible values instead.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 63b128d512fb..8b607aecd959 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -40,19 +40,31 @@ static inline resource_size_t pnp_resource_len(struct resource *res)
 static inline resource_size_t pnp_port_start(struct pnp_dev *dev,
 					     unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_IO, bar)->start;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);
+
+	if (pnp_resource_valid(res))
+		return res->start;
+	return 0;
 }
 
 static inline resource_size_t pnp_port_end(struct pnp_dev *dev,
 					   unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_IO, bar)->end;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);
+
+	if (pnp_resource_valid(res))
+		return res->end;
+	return 0;
 }
 
 static inline unsigned long pnp_port_flags(struct pnp_dev *dev,
 					   unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_IO, bar)->flags;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);
+
+	if (pnp_resource_valid(res))
+		return res->flags;
+	return IORESOURCE_IO | IORESOURCE_AUTO | IORESOURCE_UNSET;
 }
 
 static inline int pnp_port_valid(struct pnp_dev *dev, unsigned int bar)
@@ -63,25 +75,41 @@ static inline int pnp_port_valid(struct pnp_dev *dev, unsigned int bar)
 static inline resource_size_t pnp_port_len(struct pnp_dev *dev,
 					   unsigned int bar)
 {
-	return pnp_resource_len(pnp_get_resource(dev, IORESOURCE_IO, bar));
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IO, bar);
+
+	if (pnp_resource_valid(res))
+		return pnp_resource_len(res);
+	return 0;
 }
 
 
 static inline resource_size_t pnp_mem_start(struct pnp_dev *dev,
 					    unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->start;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);
+
+	if (pnp_resource_valid(res))
+		return res->start;
+	return 0;
 }
 
 static inline resource_size_t pnp_mem_end(struct pnp_dev *dev,
 					  unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->end;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);
+
+	if (pnp_resource_valid(res))
+		return res->end;
+	return 0;
 }
 
 static inline unsigned long pnp_mem_flags(struct pnp_dev *dev, unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->flags;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);
+
+	if (pnp_resource_valid(res))
+		return res->flags;
+	return IORESOURCE_MEM | IORESOURCE_AUTO | IORESOURCE_UNSET;
 }
 
 static inline int pnp_mem_valid(struct pnp_dev *dev, unsigned int bar)
@@ -92,18 +120,30 @@ static inline int pnp_mem_valid(struct pnp_dev *dev, unsigned int bar)
 static inline resource_size_t pnp_mem_len(struct pnp_dev *dev,
 					  unsigned int bar)
 {
-	return pnp_resource_len(pnp_get_resource(dev, IORESOURCE_MEM, bar));
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_MEM, bar);
+
+	if (pnp_resource_valid(res))
+		return pnp_resource_len(res);
+	return 0;
 }
 
 
 static inline resource_size_t pnp_irq(struct pnp_dev *dev, unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_IRQ, bar)->start;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IRQ, bar);
+
+	if (pnp_resource_valid(res))
+		return res->start;
+	return -1;
 }
 
 static inline unsigned long pnp_irq_flags(struct pnp_dev *dev, unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_IRQ, bar)->flags;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_IRQ, bar);
+
+	if (pnp_resource_valid(res))
+		return res->flags;
+	return IORESOURCE_IRQ | IORESOURCE_AUTO | IORESOURCE_UNSET;
 }
 
 static inline int pnp_irq_valid(struct pnp_dev *dev, unsigned int bar)
@@ -114,12 +154,20 @@ static inline int pnp_irq_valid(struct pnp_dev *dev, unsigned int bar)
 
 static inline resource_size_t pnp_dma(struct pnp_dev *dev, unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_DMA, bar)->start;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_DMA, bar);
+
+	if (pnp_resource_valid(res))
+		return res->start;
+	return -1;
 }
 
 static inline unsigned long pnp_dma_flags(struct pnp_dev *dev, unsigned int bar)
 {
-	return pnp_get_resource(dev, IORESOURCE_DMA, bar)->flags;
+	struct resource *res = pnp_get_resource(dev, IORESOURCE_DMA, bar);
+
+	if (pnp_resource_valid(res))
+		return res->flags;
+	return IORESOURCE_DMA | IORESOURCE_AUTO | IORESOURCE_UNSET;
 }
 
 static inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)

commit 08acd4f8af42affd8cbed81cc1b69fa12ddb213f
Merge: ccf2779544ee 008238b54ac2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 30 11:52:52 2008 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (179 commits)
      ACPI: Fix acpi_processor_idle and idle= boot parameters interaction
      acpi: fix section mismatch warning in pnpacpi
      intel_menlo: fix build warning
      ACPI: Cleanup: Remove unneeded, multiple local dummy variables
      ACPI: video - fix permissions on some proc entries
      ACPI: video - properly handle errors when registering proc elements
      ACPI: video - do not store invalid entries in attached_array list
      ACPI: re-name acpi_pm_ops to acpi_suspend_ops
      ACER_WMI/ASUS_LAPTOP: fix build bug
      thinkpad_acpi: fix possible NULL pointer dereference if kstrdup failed
      ACPI: check a return value correctly in acpi_power_get_context()
      #if 0 acpi/bay.c:eject_removable_drive()
      eeepc-laptop: add hwmon fan control
      eeepc-laptop: add backlight
      eeepc-laptop: add base driver
      ACPI: thinkpad-acpi: bump up version to 0.20
      ACPI: thinkpad-acpi: fix selects in Kconfig
      ACPI: thinkpad-acpi: use a private workqueue
      ACPI: thinkpad-acpi: fluff really minor fix
      ACPI: thinkpad-acpi: use uppercase for "LED" on user documentation
      ...
    
    Fixed conflicts in drivers/acpi/video.c and drivers/misc/intel_menlow.c
    manually.

commit 735643ee6cc5249bfac07fcad0946a5e7aff4423
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Apr 30 00:55:12 2008 -0700

    Remove "#ifdef __KERNEL__" checks from unexported headers
    
    Remove the "#ifdef __KERNEL__" tests from unexported header files in
    linux/include whose entire contents are wrapped in that preprocessor
    test.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b2f05c230f4b..2f3bcf73052c 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -6,8 +6,6 @@
 #ifndef _LINUX_PNP_H
 #define _LINUX_PNP_H
 
-#ifdef __KERNEL__
-
 #include <linux/device.h>
 #include <linux/list.h>
 #include <linux/errno.h>
@@ -466,6 +464,4 @@ static inline void pnp_unregister_driver(struct pnp_driver *drv) { }
 #define pnp_dbg(format, arg...) do {} while (0)
 #endif
 
-#endif /* __KERNEL__ */
-
 #endif /* _LINUX_PNP_H */

commit 261b20da4bd349f1b26e206f440809f1351be34b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:41 2008 -0600

    ISAPNP: remove unused pnp_dev->regs field
    
    The "regs" field in struct pnp_dev is set but never read, so remove it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index f5b985e912ae..e3b2c0068de7 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -253,7 +253,6 @@ struct pnp_dev {
 	struct pnp_resource_table *res;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
-	unsigned short regs;		/* ISAPnP: supported registers */
 	int flags;			/* used by protocols */
 	struct proc_dir_entry *procent;	/* device entry in /proc/bus/isapnp */
 	void *data;

commit 62cfb298b95d713825deb8faf2044c45a1e17a0a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:40 2008 -0600

    PNP: make interfaces private to the PNP core
    
    The interfaces for registering protocols, devices, cards,
    and resource options should only be used inside the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index a5487b6a4e57..f5b985e912ae 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -414,19 +414,12 @@ extern struct bus_type pnp_bus_type;
 #if defined(CONFIG_PNP)
 
 /* device management */
-int pnp_register_protocol(struct pnp_protocol *protocol);
-void pnp_unregister_protocol(struct pnp_protocol *protocol);
-int pnp_add_device(struct pnp_dev *dev);
 int pnp_device_attach(struct pnp_dev *pnp_dev);
 void pnp_device_detach(struct pnp_dev *pnp_dev);
 extern struct list_head pnp_global;
 extern int pnp_platform_devices;
 
 /* multidevice card support */
-int pnp_add_card(struct pnp_card *card);
-void pnp_remove_card(struct pnp_card *card);
-int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev);
-void pnp_remove_card_device(struct pnp_dev *dev);
 struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,
 					const char *id, struct pnp_dev *from);
 void pnp_release_card_device(struct pnp_dev *dev);
@@ -435,20 +428,7 @@ void pnp_unregister_card_driver(struct pnp_card_driver *drv);
 extern struct list_head pnp_cards;
 
 /* resource management */
-struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev);
-struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
-						 int priority);
-int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_irq *data);
-int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_dma *data);
-int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
-			       struct pnp_port *data);
-int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
-			      struct pnp_mem *data);
-void pnp_init_resources(struct pnp_dev *dev);
 int pnp_auto_config_dev(struct pnp_dev *dev);
-int pnp_validate_config(struct pnp_dev *dev);
 int pnp_start_dev(struct pnp_dev *dev);
 int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
@@ -463,35 +443,19 @@ void pnp_unregister_driver(struct pnp_driver *drv);
 #else
 
 /* device management */
-static inline int pnp_register_protocol(struct pnp_protocol *protocol) { return -ENODEV; }
-static inline void pnp_unregister_protocol(struct pnp_protocol *protocol) { }
-static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
 static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { }
 
 #define pnp_platform_devices 0
 
 /* multidevice card support */
-static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }
-static inline void pnp_remove_card(struct pnp_card *card) { }
-static inline int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev) { return -ENODEV; }
-static inline void pnp_remove_card_device(struct pnp_dev *dev) { }
 static inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink, const char *id, struct pnp_dev *from) { return NULL; }
 static inline void pnp_release_card_device(struct pnp_dev *dev) { }
 static inline int pnp_register_card_driver(struct pnp_card_driver *drv) { return -ENODEV; }
 static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv) { }
 
 /* resource management */
-static inline struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev) { return NULL; }
-static inline struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev, int priority) { return NULL; }
-static inline int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
-static inline int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
-static inline int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
-static inline int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
-static inline void pnp_init_resources(struct pnp_dev *dev) { }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }

commit 02d83b5da3efa3c278ce87db2637f3dd6837166d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:28 2008 -0600

    PNP: make pnp_resource_table private to PNP core
    
    There are no remaining references to the PNP_MAX_* constants or
    the pnp_resource_table structure outside of the PNP core.  Make
    them private to the PNP core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 1640562f3ebc..a5487b6a4e57 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -13,14 +13,11 @@
 #include <linux/errno.h>
 #include <linux/mod_devicetable.h>
 
-#define PNP_MAX_PORT		40
-#define PNP_MAX_MEM		24
-#define PNP_MAX_IRQ		2
-#define PNP_MAX_DMA		2
 #define PNP_NAME_LEN		50
 
 struct pnp_protocol;
 struct pnp_dev;
+struct pnp_resource_table;
 
 /*
  * Resource Management
@@ -184,13 +181,6 @@ struct pnp_option {
 	struct pnp_option *next;	/* used to chain dependent resources */
 };
 
-struct pnp_resource_table {
-	struct resource port_resource[PNP_MAX_PORT];
-	struct resource mem_resource[PNP_MAX_MEM];
-	struct resource dma_resource[PNP_MAX_DMA];
-	struct resource irq_resource[PNP_MAX_IRQ];
-};
-
 /*
  * Device Management
  */
@@ -260,7 +250,7 @@ struct pnp_dev {
 	int capabilities;
 	struct pnp_option *independent;
 	struct pnp_option *dependent;
-	struct pnp_resource_table res;
+	struct pnp_resource_table *res;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
 	unsigned short regs;		/* ISAPnP: supported registers */

commit 13575e81bb38fc797a5513ad1bd8e6fda17439b8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:16 2008 -0600

    PNP: convert resource accessors to use pnp_get_resource(), not pnp_resource_table
    
    This removes more direct references to pnp_resource_table.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b5fd03854fa4..1640562f3ebc 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -27,46 +27,111 @@ struct pnp_dev;
  */
 struct resource *pnp_get_resource(struct pnp_dev *, unsigned int, unsigned int);
 
-/* Use these instead of directly reading pnp_dev to get resource information */
-#define pnp_port_start(dev,bar)   ((dev)->res.port_resource[(bar)].start)
-#define pnp_port_end(dev,bar)     ((dev)->res.port_resource[(bar)].end)
-#define pnp_port_flags(dev,bar)   ((dev)->res.port_resource[(bar)].flags)
-#define pnp_port_valid(dev,bar) \
-	((pnp_port_flags((dev),(bar)) & (IORESOURCE_IO | IORESOURCE_UNSET)) \
-		== IORESOURCE_IO)
-#define pnp_port_len(dev,bar) \
-	((pnp_port_start((dev),(bar)) == 0 &&	\
-	  pnp_port_end((dev),(bar)) ==		\
-	  pnp_port_start((dev),(bar))) ? 0 :	\
-	  					\
-	 (pnp_port_end((dev),(bar)) -		\
-	  pnp_port_start((dev),(bar)) + 1))
-
-#define pnp_mem_start(dev,bar)   ((dev)->res.mem_resource[(bar)].start)
-#define pnp_mem_end(dev,bar)     ((dev)->res.mem_resource[(bar)].end)
-#define pnp_mem_flags(dev,bar)   ((dev)->res.mem_resource[(bar)].flags)
-#define pnp_mem_valid(dev,bar) \
-	((pnp_mem_flags((dev),(bar)) & (IORESOURCE_MEM | IORESOURCE_UNSET)) \
-		== IORESOURCE_MEM)
-#define pnp_mem_len(dev,bar) \
-	((pnp_mem_start((dev),(bar)) == 0 &&	\
-	  pnp_mem_end((dev),(bar)) ==		\
-	  pnp_mem_start((dev),(bar))) ? 0 :	\
-	  					\
-	 (pnp_mem_end((dev),(bar)) -		\
-	  pnp_mem_start((dev),(bar)) + 1))
-
-#define pnp_irq(dev,bar)	 ((dev)->res.irq_resource[(bar)].start)
-#define pnp_irq_flags(dev,bar)	 ((dev)->res.irq_resource[(bar)].flags)
-#define pnp_irq_valid(dev,bar) \
-	((pnp_irq_flags((dev),(bar)) & (IORESOURCE_IRQ | IORESOURCE_UNSET)) \
-		== IORESOURCE_IRQ)
-
-#define pnp_dma(dev,bar)	 ((dev)->res.dma_resource[(bar)].start)
-#define pnp_dma_flags(dev,bar)	 ((dev)->res.dma_resource[(bar)].flags)
-#define pnp_dma_valid(dev,bar) \
-	((pnp_dma_flags((dev),(bar)) & (IORESOURCE_DMA | IORESOURCE_UNSET)) \
-		== IORESOURCE_DMA)
+static inline int pnp_resource_valid(struct resource *res)
+{
+	if (res && !(res->flags & IORESOURCE_UNSET))
+		return 1;
+	return 0;
+}
+
+static inline resource_size_t pnp_resource_len(struct resource *res)
+{
+	if (res->start == 0 && res->end == 0)
+		return 0;
+	return res->end - res->start + 1;
+}
+
+
+static inline resource_size_t pnp_port_start(struct pnp_dev *dev,
+					     unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_IO, bar)->start;
+}
+
+static inline resource_size_t pnp_port_end(struct pnp_dev *dev,
+					   unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_IO, bar)->end;
+}
+
+static inline unsigned long pnp_port_flags(struct pnp_dev *dev,
+					   unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_IO, bar)->flags;
+}
+
+static inline int pnp_port_valid(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_IO, bar));
+}
+
+static inline resource_size_t pnp_port_len(struct pnp_dev *dev,
+					   unsigned int bar)
+{
+	return pnp_resource_len(pnp_get_resource(dev, IORESOURCE_IO, bar));
+}
+
+
+static inline resource_size_t pnp_mem_start(struct pnp_dev *dev,
+					    unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->start;
+}
+
+static inline resource_size_t pnp_mem_end(struct pnp_dev *dev,
+					  unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->end;
+}
+
+static inline unsigned long pnp_mem_flags(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_MEM, bar)->flags;
+}
+
+static inline int pnp_mem_valid(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_MEM, bar));
+}
+
+static inline resource_size_t pnp_mem_len(struct pnp_dev *dev,
+					  unsigned int bar)
+{
+	return pnp_resource_len(pnp_get_resource(dev, IORESOURCE_MEM, bar));
+}
+
+
+static inline resource_size_t pnp_irq(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_IRQ, bar)->start;
+}
+
+static inline unsigned long pnp_irq_flags(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_IRQ, bar)->flags;
+}
+
+static inline int pnp_irq_valid(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_IRQ, bar));
+}
+
+
+static inline resource_size_t pnp_dma(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_DMA, bar)->start;
+}
+
+static inline unsigned long pnp_dma_flags(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_get_resource(dev, IORESOURCE_DMA, bar)->flags;
+}
+
+static inline int pnp_dma_valid(struct pnp_dev *dev, unsigned int bar)
+{
+	return pnp_resource_valid(pnp_get_resource(dev, IORESOURCE_DMA, bar));
+}
+
 
 #define PNP_PORT_FLAG_16BITADDR	(1<<0)
 #define PNP_PORT_FLAG_FIXED	(1<<1)

commit b90eca0a61ebd010036242e29610bc6a909e3f19
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:14 2008 -0600

    PNP: add pnp_get_resource() interface
    
    This adds a pnp_get_resource() that works the same way as
    platform_get_resource().  This will enable us to consolidate
    many pnp_resource_table references in one place, which will
    make it easier to make the table dynamic.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index e8187d9faf01..b5fd03854fa4 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -25,6 +25,7 @@ struct pnp_dev;
 /*
  * Resource Management
  */
+struct resource *pnp_get_resource(struct pnp_dev *, unsigned int, unsigned int);
 
 /* Use these instead of directly reading pnp_dev to get resource information */
 #define pnp_port_start(dev,bar)   ((dev)->res.port_resource[(bar)].start)

commit 2cd1393098073426256cb4543c897f8c340d0b93
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:11 2008 -0600

    PNP: remove unused interfaces using pnp_resource_table
    
    Rene Herman <rene.herman@gmail.com> recently removed the only in-tree
    driver uses of:
    
        pnp_init_resource_table()
        pnp_manual_config_dev()
        pnp_resource_change()
    
    in this change:
    
        http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=109c53f840e551d6e99ecfd8b0131a968332c89f
    
    These are no longer used in the PNP core either, so we can just remove
    them completely.
    
    It's possible that there are out-of-tree drivers that use these
    interfaces.  They should be changed to either (1) use PNP quirks
    to work around broken hardware or firmware, or (2) use the sysfs
    interfaces to control resource usage from userspace.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 1737f071787a..e8187d9faf01 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -390,18 +390,13 @@ int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 			       struct pnp_port *data);
 int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
 			      struct pnp_mem *data);
-void pnp_init_resource_table(struct pnp_resource_table *table);
 void pnp_init_resources(struct pnp_dev *dev);
-int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res,
-			  int mode);
 int pnp_auto_config_dev(struct pnp_dev *dev);
 int pnp_validate_config(struct pnp_dev *dev);
 int pnp_start_dev(struct pnp_dev *dev);
 int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
 int pnp_disable_dev(struct pnp_dev *dev);
-void pnp_resource_change(struct resource *resource, resource_size_t start,
-			 resource_size_t size);
 
 /* protocol helpers */
 int pnp_is_active(struct pnp_dev *dev);
@@ -438,16 +433,13 @@ static inline int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_opti
 static inline int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
 static inline int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
 static inline int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
-static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
 static inline void pnp_init_resources(struct pnp_dev *dev) { }
-static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline void pnp_resource_change(struct resource *resource, resource_size_t start, resource_size_t size) { }
 
 /* protocol helpers */
 static inline int pnp_is_active(struct pnp_dev *dev) { return 0; }

commit f44900020926b2cb06b87f0f52643d6285514fc3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:09 2008 -0600

    PNP: add pnp_init_resources(struct pnp_dev *) interface
    
    Add pnp_init_resources(struct pnp_dev *) to replace
    pnp_init_resource_table(), which takes a pointer to the
    pnp_resource_table itself.  Passing only the pnp_dev * reduces
    the possibility for error in the caller and removes the
    pnp_resource_table implementation detail from the interface.
    
    Even though pnp_init_resource_table() is exported, I did not
    export pnp_init_resources() because it is used only by the PNP
    core.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 8d7c9bc2fdbb..1737f071787a 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -391,6 +391,7 @@ int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
 			      struct pnp_mem *data);
 void pnp_init_resource_table(struct pnp_resource_table *table);
+void pnp_init_resources(struct pnp_dev *dev);
 int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res,
 			  int mode);
 int pnp_auto_config_dev(struct pnp_dev *dev);
@@ -438,6 +439,7 @@ static inline int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_opti
 static inline int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
 static inline int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
 static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
+static inline void pnp_init_resources(struct pnp_dev *dev) { }
 static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }

commit 59284cb4099411bc6f4915a5a4cb76414440c447
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:05 2008 -0600

    PNP: remove pnp_resource_table from internal get/set interfaces
    
    When we call protocol->get() and protocol->set() methods, we currently
    supply pointers to both the pnp_dev and the pnp_resource_table even
    though the pnp_resource_table should always be the one associated with
    the pnp_dev.
    
    This removes the pnp_resource_table arguments to make it clear that
    these methods only operate on the specified pnp_dev.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index a4c2bf361596..8d7c9bc2fdbb 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -328,8 +328,8 @@ struct pnp_protocol {
 	char *name;
 
 	/* resource control functions */
-	int (*get) (struct pnp_dev *dev, struct pnp_resource_table *res);
-	int (*set) (struct pnp_dev *dev, struct pnp_resource_table *res);
+	int (*get) (struct pnp_dev *dev);
+	int (*set) (struct pnp_dev *dev);
 	int (*disable) (struct pnp_dev *dev);
 
 	/* protocol specific suspend/resume */

commit c1caf06ccfd3a4efd4b489f89bcdabd2362f31d0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:34:04 2008 -0600

    PNP: add debug output to option registration
    
    Add debug output to resource option registration functions (enabled
    by CONFIG_PNP_DEBUG).  This uses dev_printk, so I had to add pnp_dev
    arguments at the same time.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 7639db83ce3f..a4c2bf361596 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -382,11 +382,14 @@ extern struct list_head pnp_cards;
 struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev);
 struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
 						 int priority);
-int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data);
-int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data);
-int pnp_register_port_resource(struct pnp_option *option,
+int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_irq *data);
+int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_dma *data);
+int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option,
 			       struct pnp_port *data);
-int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data);
+int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option,
+			      struct pnp_mem *data);
 void pnp_init_resource_table(struct pnp_resource_table *table);
 int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res,
 			  int mode);
@@ -430,10 +433,10 @@ static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv) { }
 /* resource management */
 static inline struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev) { return NULL; }
 static inline struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev, int priority) { return NULL; }
-static inline int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
-static inline int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
-static inline int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
-static inline int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
+static inline int pnp_register_irq_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
+static inline int pnp_register_dma_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
+static inline int pnp_register_port_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
+static inline int pnp_register_mem_resource(struct pnp_dev *dev, struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
 static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
 static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }

commit 048825deea5f261335b5202cd1114c53a3a21ae7
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:55 2008 -0600

    PNP: make pnp_add_card_id() internal to PNP core
    
    pnp_add_card_id() doesn't need to be exposed outside the PNP core, so
    move the declaration to an internal header file.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 9a05ab5515b6..7639db83ce3f 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -371,7 +371,6 @@ int pnp_add_card(struct pnp_card *card);
 void pnp_remove_card(struct pnp_card *card);
 int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev);
 void pnp_remove_card_device(struct pnp_dev *dev);
-int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card);
 struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,
 					const char *id, struct pnp_dev *from);
 void pnp_release_card_device(struct pnp_dev *dev);
@@ -423,7 +422,6 @@ static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }
 static inline void pnp_remove_card(struct pnp_card *card) { }
 static inline int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev) { return -ENODEV; }
 static inline void pnp_remove_card_device(struct pnp_dev *dev) { }
-static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card) { return -ENODEV; }
 static inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink, const char *id, struct pnp_dev *from) { return NULL; }
 static inline void pnp_release_card_device(struct pnp_dev *dev) { }
 static inline int pnp_register_card_driver(struct pnp_card_driver *drv) { return -ENODEV; }

commit 1692b27bf37826f85f9c12f8468848885643532a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Apr 28 16:33:51 2008 -0600

    PNP: make pnp_add_id() internal to PNP core
    
    pnp_add_id() doesn't need to be exposed outside the PNP core, so
    move the declaration to an internal header file.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Acked-By: Rene Herman <rene.herman@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b2f05c230f4b..9a05ab5515b6 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -403,7 +403,6 @@ void pnp_resource_change(struct resource *resource, resource_size_t start,
 /* protocol helpers */
 int pnp_is_active(struct pnp_dev *dev);
 int compare_pnp_id(struct pnp_id *pos, const char *id);
-int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev);
 int pnp_register_driver(struct pnp_driver *drv);
 void pnp_unregister_driver(struct pnp_driver *drv);
 
@@ -450,7 +449,6 @@ static inline void pnp_resource_change(struct resource *resource, resource_size_
 /* protocol helpers */
 static inline int pnp_is_active(struct pnp_dev *dev) { return 0; }
 static inline int compare_pnp_id(struct pnp_id *pos, const char *id) { return -ENODEV; }
-static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_register_driver(struct pnp_driver *drv) { return -ENODEV; }
 static inline void pnp_unregister_driver(struct pnp_driver *drv) { }
 

commit 544451a1a36b06f43fc67112ede3b92e6203eb9d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 10 21:29:28 2008 -0700

    pnp: increase number of devices supported per protocol
    
    Increase the PNP "number of devices" limit.  We currently use an unsigned
    char, which limits us to 256 devices per protocol.  This patch changes that to
    an unsigned int.
    
    Not all backends can take advantage of this: we limit ISAPNP to 10 devices in
    isapnp_cfg_begin(), and PNPBIOS is limited to 256 devices because the BIOS
    interfaces use a one-byte device node number.
    
    But there is no limit on the number of PNPACPI devices we may have.  Large HP
    Integrity machines have more than 256, which causes the current "unsigned char
    number" to wrap around.  This causes errors like this:
    
        pnp: PnP ACPI init
        kobject_add failed for 00:00 with -EEXIST, don't try to register things with the same name in the same directory.
    
        Call Trace:
         [<a000000100010720>] show_stack+0x40/0xa0
         [<a0000001000107b0>] dump_stack+0x30/0x60
         [<a0000001001dbdf0>] kobject_add+0x290/0x2c0
         [<a0000001002bfd40>] device_add+0x160/0x860
         [<a0000001002c0470>] device_register+0x30/0x60
         [<a00000010026ba70>] __pnp_add_device+0x130/0x180
         [<a00000010026bb70>] pnp_add_device+0xb0/0xe0
         [<a0000001007f2730>] pnpacpi_add_device+0x510/0x5a0
         [<a0000001007f2810>] pnpacpi_add_device_handler+0x50/0x80
    
    This patch increases the limit to fix this PNPACPI problem.  It should not
    have any adverse effect on ISAPNP or PNPBIOS because their limits are still
    enforced in the backends.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 29dd55838e84..b2f05c230f4b 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -175,7 +175,7 @@ static inline void pnp_set_card_drvdata(struct pnp_card_link *pcard, void *data)
 struct pnp_dev {
 	struct device dev;		/* Driver Model device interface */
 	u64 dma_mask;
-	unsigned char number;		/* used as an index, must be unique */
+	unsigned int number;		/* used as an index, must be unique */
 	int status;
 
 	struct list_head global_list;	/* node in global list of devices */

commit 03c086a747d0b242878eb881971ec61c1555869d
Author: Darren Salt <linux@youmustbejoking.demon.co.uk>
Date:   Thu Mar 13 15:35:49 2008 +0000

    PNP: increase the number of PnP memory resources from 12 to 24
    
    Increase the number of PnP memory resources from 12 to 24.
    
    This removes an "exceeded the max num of mem resources" warning on boot. I
    also noticed the reservation of two more iomem ranges on the computer on
    which this was tested.
    
    Signed-off-by: Darren Salt <linux@youmustbejoking.demon.co.uk>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index cd6332b88829..29dd55838e84 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -14,7 +14,7 @@
 #include <linux/mod_devicetable.h>
 
 #define PNP_MAX_PORT		40
-#define PNP_MAX_MEM		12
+#define PNP_MAX_MEM		24
 #define PNP_MAX_IRQ		2
 #define PNP_MAX_DMA		2
 #define PNP_NAME_LEN		50

commit b3bd86e2fdce01d6b49271a553d2a18b3e0510f3
Author: Daniel Walker <dwalker@mvista.com>
Date:   Wed Feb 6 01:40:04 2008 -0800

    isapnp driver semaphore to mutex
    
    Changed the isapnp semaphore to a mutex.
    
    [akpm@linux-foundation.org: no externs-in-c]
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index b9339d8b95bc..cd6332b88829 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -258,6 +258,7 @@ extern struct pnp_protocol isapnp_protocol;
 #else
 #define pnp_device_is_isapnp(dev) 0
 #endif
+extern struct mutex pnp_res_mutex;
 
 #ifdef CONFIG_PNPBIOS
 extern struct pnp_protocol pnpbios_protocol;

commit fd3f8984f6fa1ad1a6c2283eef48ba6e5242bcc5
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:45:46 2008 +0200

    include/linux/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 2a6d62c7d2d1..b9339d8b95bc 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -126,7 +126,7 @@ struct pnp_resource_table {
 };
 
 /*
- * Device Managemnt
+ * Device Management
  */
 
 struct pnp_card {

commit 2c838197751db19d08a00e633e33dce23a69fb0c
Author: Len Brown <len.brown@intel.com>
Date:   Thu Dec 27 23:55:13 2007 -0500

    increase PNP_MAX_PORT to 40 from 24
    
    a7839e960675b549f06209d18283d5cee2ce9261
    (PNP: increase the maximum number of resources)
    increased PNP_MAX_PORT to 24 from 8.
    It also added a test and a complaint when a
    machine exceeded the limit, causing:
    
    pnpacpi: exceeded the max number of IO resources: 24
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9535
    
    We should have been squawking about this all along,
    as this is a potentially serious issue.
    
    For now, simply burn some dynamic bytes and
    increase the limit by another 16 to 40.
    There is no guarantee that this will satisfy
    every system on Earth.  It probably will not,
    but it should be an improvement.
    
    In the future, PNPACPI should allocate resource
    structures as needed, rather than max-sized arrays.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 0a0426c2867d..2a6d62c7d2d1 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -13,7 +13,7 @@
 #include <linux/errno.h>
 #include <linux/mod_devicetable.h>
 
-#define PNP_MAX_PORT		24
+#define PNP_MAX_PORT		40
 #define PNP_MAX_MEM		12
 #define PNP_MAX_IRQ		2
 #define PNP_MAX_DMA		2

commit a7839e960675b549f06209d18283d5cee2ce9261
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Wed Nov 28 16:21:21 2007 -0800

    PNP: increase the maximum number of resources
    
    On some systems the number of resources(IO,MEM) returnedy by PNP device is
    greater than the PNP constant, for example motherboard devices.  It brings
    that some resources can't be reserved and resource confilicts.  This will
    cause PCI resources are assigned wrongly in some systems, and cause hang.
    This is a regression since we deleted ACPI motherboard driver and use PNP
    system driver.
    
    [akpm@linux-foundation.org: fix text and coding-style a bit]
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 664d68cb1fbd..0a0426c2867d 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -13,8 +13,8 @@
 #include <linux/errno.h>
 #include <linux/mod_devicetable.h>
 
-#define PNP_MAX_PORT		8
-#define PNP_MAX_MEM		4
+#define PNP_MAX_PORT		24
+#define PNP_MAX_MEM		12
 #define PNP_MAX_IRQ		2
 #define PNP_MAX_DMA		2
 #define PNP_NAME_LEN		50

commit 402b310cb6e523779149139b20f46899a890e963
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 16 23:31:09 2007 -0700

    PNP: remove null pointer checks
    
    Remove some null pointer checks.  Null pointers in these areas indicate
    programming errors, and I think it's better to oops immediately rather than
    return an error that is easily ignored.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 16b46aace349..664d68cb1fbd 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -243,11 +243,11 @@ struct pnp_fixup {
 #define PNP_CONFIGURABLE	0x0008
 #define PNP_REMOVABLE		0x0010
 
-#define pnp_can_read(dev)	(((dev)->protocol) && ((dev)->protocol->get) && \
+#define pnp_can_read(dev)	(((dev)->protocol->get) && \
 				 ((dev)->capabilities & PNP_READ))
-#define pnp_can_write(dev)	(((dev)->protocol) && ((dev)->protocol->set) && \
+#define pnp_can_write(dev)	(((dev)->protocol->set) && \
 				 ((dev)->capabilities & PNP_WRITE))
-#define pnp_can_disable(dev)	(((dev)->protocol) && ((dev)->protocol->disable) && \
+#define pnp_can_disable(dev)	(((dev)->protocol->disable) && \
 				 ((dev)->capabilities & PNP_DISABLE))
 #define pnp_can_configure(dev)	((!(dev)->active) && \
 				 ((dev)->capabilities & PNP_CONFIGURABLE))

commit 07d4e9af109221ab731c5aaf832e89776c64b013
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:21 2007 -0700

    PNP: fix up after Lindent
    
    These are manual fixups after running Lindent.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 6f9cf2fcffd0..16b46aace349 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -1,7 +1,6 @@
 /*
  * Linux Plug and Play Support
  * Copyright by Adam Belay <ambx1@neo.rr.com>
- *
  */
 
 #ifndef _LINUX_PNP_H
@@ -83,7 +82,7 @@ struct pnp_port {
 
 #define PNP_IRQ_NR 256
 struct pnp_irq {
-	DECLARE_BITMAP(map, PNP_IRQ_NR);	/* bitmaks for IRQ lines */
+	DECLARE_BITMAP(map, PNP_IRQ_NR);	/* bitmask for IRQ lines */
 	unsigned char flags;	/* IRQ flags */
 	unsigned char pad;	/* pad */
 	struct pnp_irq *next;	/* next IRQ */
@@ -112,10 +111,10 @@ struct pnp_mem {
 
 struct pnp_option {
 	unsigned short priority;	/* priority */
-	struct pnp_port *port;	/* first port */
-	struct pnp_irq *irq;	/* first IRQ */
-	struct pnp_dma *dma;	/* first DMA */
-	struct pnp_mem *mem;	/* first memory resource */
+	struct pnp_port *port;		/* first port */
+	struct pnp_irq *irq;		/* first IRQ */
+	struct pnp_dma *dma;		/* first DMA */
+	struct pnp_mem *mem;		/* first memory resource */
 	struct pnp_option *next;	/* used to chain dependent resources */
 };
 
@@ -131,20 +130,20 @@ struct pnp_resource_table {
  */
 
 struct pnp_card {
-	struct device dev;	/* Driver Model device interface */
-	unsigned char number;	/* used as an index, must be unique */
+	struct device dev;		/* Driver Model device interface */
+	unsigned char number;		/* used as an index, must be unique */
 	struct list_head global_list;	/* node in global list of cards */
 	struct list_head protocol_list;	/* node in protocol's list of cards */
 	struct list_head devices;	/* devices attached to the card */
 
 	struct pnp_protocol *protocol;
-	struct pnp_id *id;	/* contains supported EISA IDs */
+	struct pnp_id *id;		/* contains supported EISA IDs */
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
-	unsigned char pnpver;	/* Plug & Play version */
+	unsigned char pnpver;		/* Plug & Play version */
 	unsigned char productver;	/* product version */
-	unsigned int serial;	/* serial number */
-	unsigned char checksum;	/* if zero - checksum passed */
+	unsigned int serial;		/* serial number */
+	unsigned char checksum;		/* if zero - checksum passed */
 	struct proc_dir_entry *procdir;	/* directory entry in /proc/bus/isapnp */
 };
 
@@ -174,9 +173,9 @@ static inline void pnp_set_card_drvdata(struct pnp_card_link *pcard, void *data)
 }
 
 struct pnp_dev {
-	struct device dev;	/* Driver Model device interface */
+	struct device dev;		/* Driver Model device interface */
 	u64 dma_mask;
-	unsigned char number;	/* used as an index, must be unique */
+	unsigned char number;		/* used as an index, must be unique */
 	int status;
 
 	struct list_head global_list;	/* node in global list of devices */
@@ -189,7 +188,7 @@ struct pnp_dev {
 	struct pnp_driver *driver;
 	struct pnp_card_link *card_link;
 
-	struct pnp_id *id;	/* supported EISA IDs */
+	struct pnp_id *id;		/* supported EISA IDs */
 
 	int active;
 	int capabilities;
@@ -198,8 +197,8 @@ struct pnp_dev {
 	struct pnp_resource_table res;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
-	unsigned short regs;	/* ISAPnP: supported registers */
-	int flags;		/* used by protocols */
+	unsigned short regs;		/* ISAPnP: supported registers */
+	int flags;			/* used by protocols */
 	struct proc_dir_entry *procent;	/* device entry in /proc/bus/isapnp */
 	void *data;
 };
@@ -291,11 +290,10 @@ struct pnp_driver {
 	char *name;
 	const struct pnp_device_id *id_table;
 	unsigned int flags;
-	int (*probe) (struct pnp_dev * dev,
-		      const struct pnp_device_id * dev_id);
-	void (*remove) (struct pnp_dev * dev);
-	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
-	int (*resume) (struct pnp_dev * dev);
+	int (*probe) (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
+	void (*remove) (struct pnp_dev *dev);
+	int (*suspend) (struct pnp_dev *dev, pm_message_t state);
+	int (*resume) (struct pnp_dev *dev);
 	struct device_driver driver;
 };
 
@@ -306,11 +304,11 @@ struct pnp_card_driver {
 	char *name;
 	const struct pnp_card_device_id *id_table;
 	unsigned int flags;
-	int (*probe) (struct pnp_card_link * card,
-		      const struct pnp_card_device_id * card_id);
-	void (*remove) (struct pnp_card_link * card);
-	int (*suspend) (struct pnp_card_link * card, pm_message_t state);
-	int (*resume) (struct pnp_card_link * card);
+	int (*probe) (struct pnp_card_link *card,
+		      const struct pnp_card_device_id *card_id);
+	void (*remove) (struct pnp_card_link *card);
+	int (*suspend) (struct pnp_card_link *card, pm_message_t state);
+	int (*resume) (struct pnp_card_link *card);
 	struct pnp_driver link;
 };
 
@@ -329,9 +327,9 @@ struct pnp_protocol {
 	char *name;
 
 	/* resource control functions */
-	int (*get) (struct pnp_dev * dev, struct pnp_resource_table * res);
-	int (*set) (struct pnp_dev * dev, struct pnp_resource_table * res);
-	int (*disable) (struct pnp_dev * dev);
+	int (*get) (struct pnp_dev *dev, struct pnp_resource_table *res);
+	int (*set) (struct pnp_dev *dev, struct pnp_resource_table *res);
+	int (*disable) (struct pnp_dev *dev);
 
 	/* protocol specific suspend/resume */
 	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
@@ -411,159 +409,49 @@ void pnp_unregister_driver(struct pnp_driver *drv);
 #else
 
 /* device management */
-static inline int pnp_register_protocol(struct pnp_protocol *protocol)
-{
-	return -ENODEV;
-}
-static inline void pnp_unregister_protocol(struct pnp_protocol *protocol)
-{
-}
-static inline int pnp_init_device(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_add_device(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_device_attach(struct pnp_dev *pnp_dev)
-{
-	return -ENODEV;
-}
-static inline void pnp_device_detach(struct pnp_dev *pnp_dev)
-{;
-}
+static inline int pnp_register_protocol(struct pnp_protocol *protocol) { return -ENODEV; }
+static inline void pnp_unregister_protocol(struct pnp_protocol *protocol) { }
+static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
+static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { }
 
 #define pnp_platform_devices 0
 
 /* multidevice card support */
-static inline int pnp_add_card(struct pnp_card *card)
-{
-	return -ENODEV;
-}
-static inline void pnp_remove_card(struct pnp_card *card)
-{;
-}
-static inline int pnp_add_card_device(struct pnp_card *card,
-				      struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline void pnp_remove_card_device(struct pnp_dev *dev)
-{;
-}
-static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card)
-{
-	return -ENODEV;
-}
-static inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link
-						      *clink, const char *id,
-						      struct pnp_dev *from)
-{
-	return NULL;
-}
-static inline void pnp_release_card_device(struct pnp_dev *dev)
-{;
-}
-static inline int pnp_register_card_driver(struct pnp_card_driver *drv)
-{
-	return -ENODEV;
-}
-static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv)
-{;
-}
+static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }
+static inline void pnp_remove_card(struct pnp_card *card) { }
+static inline int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev) { return -ENODEV; }
+static inline void pnp_remove_card_device(struct pnp_dev *dev) { }
+static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card) { return -ENODEV; }
+static inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink, const char *id, struct pnp_dev *from) { return NULL; }
+static inline void pnp_release_card_device(struct pnp_dev *dev) { }
+static inline int pnp_register_card_driver(struct pnp_card_driver *drv) { return -ENODEV; }
+static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv) { }
 
 /* resource management */
-static inline struct pnp_option *pnp_register_independent_option(struct pnp_dev
-								 *dev)
-{
-	return NULL;
-}
-static inline struct pnp_option *pnp_register_dependent_option(struct pnp_dev
-							       *dev,
-							       int priority)
-{
-	return NULL;
-}
-static inline int pnp_register_irq_resource(struct pnp_option *option,
-					    struct pnp_irq *data)
-{
-	return -ENODEV;
-}
-static inline int pnp_register_dma_resource(struct pnp_option *option,
-					    struct pnp_dma *data)
-{
-	return -ENODEV;
-}
-static inline int pnp_register_port_resource(struct pnp_option *option,
-					     struct pnp_port *data)
-{
-	return -ENODEV;
-}
-static inline int pnp_register_mem_resource(struct pnp_option *option,
-					    struct pnp_mem *data)
-{
-	return -ENODEV;
-}
-static inline void pnp_init_resource_table(struct pnp_resource_table *table)
-{
-}
-static inline int pnp_manual_config_dev(struct pnp_dev *dev,
-					struct pnp_resource_table *res,
-					int mode)
-{
-	return -ENODEV;
-}
-static inline int pnp_auto_config_dev(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_validate_config(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_start_dev(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_stop_dev(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_activate_dev(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_disable_dev(struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline void pnp_resource_change(struct resource *resource,
-				       resource_size_t start,
-				       resource_size_t size)
-{
-}
+static inline struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev) { return NULL; }
+static inline struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev, int priority) { return NULL; }
+static inline int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
+static inline int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
+static inline int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
+static inline int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
+static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
+static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
+static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline void pnp_resource_change(struct resource *resource, resource_size_t start, resource_size_t size) { }
 
 /* protocol helpers */
-static inline int pnp_is_active(struct pnp_dev *dev)
-{
-	return 0;
-}
-static inline int compare_pnp_id(struct pnp_id *pos, const char *id)
-{
-	return -ENODEV;
-}
-static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
-{
-	return -ENODEV;
-}
-static inline int pnp_register_driver(struct pnp_driver *drv)
-{
-	return -ENODEV;
-}
-static inline void pnp_unregister_driver(struct pnp_driver *drv)
-{;
-}
+static inline int pnp_is_active(struct pnp_dev *dev) { return 0; }
+static inline int compare_pnp_id(struct pnp_id *pos, const char *id) { return -ENODEV; }
+static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_register_driver(struct pnp_driver *drv) { return -ENODEV; }
+static inline void pnp_unregister_driver(struct pnp_driver *drv) { }
 
 #endif /* CONFIG_PNP */
 

commit 9dd78466c956ac4b4f38e12032dc4249ccf57ad1
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Jul 26 10:41:20 2007 -0700

    PNP: Lindent all source files
    
    Run Lindent on all PNP source files.
    
    Produced by:
    
        $ quilt new pnp-lindent
        $ find drivers/pnp -name \*.[ch] | xargs quilt add
        $ quilt add include/linux/{pnp.h,pnpbios.h}
        $ scripts/Lindent drivers/pnp/*.c drivers/pnp/*/*.c include/linux/pnp*.h
        $ quilt refresh --sort
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 66edb2293184..6f9cf2fcffd0 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -23,7 +23,6 @@
 struct pnp_protocol;
 struct pnp_dev;
 
-
 /*
  * Resource Management
  */
@@ -73,37 +72,37 @@ struct pnp_dev;
 #define PNP_PORT_FLAG_FIXED	(1<<1)
 
 struct pnp_port {
-	unsigned short min;		/* min base number */
-	unsigned short max;		/* max base number */
-	unsigned char align;		/* align boundary */
-	unsigned char size;		/* size of range */
-	unsigned char flags;		/* port flags */
-	unsigned char pad;		/* pad */
-	struct pnp_port *next;		/* next port */
+	unsigned short min;	/* min base number */
+	unsigned short max;	/* max base number */
+	unsigned char align;	/* align boundary */
+	unsigned char size;	/* size of range */
+	unsigned char flags;	/* port flags */
+	unsigned char pad;	/* pad */
+	struct pnp_port *next;	/* next port */
 };
 
 #define PNP_IRQ_NR 256
 struct pnp_irq {
-	DECLARE_BITMAP(map, PNP_IRQ_NR); /* bitmaks for IRQ lines */
-	unsigned char flags;		/* IRQ flags */
-	unsigned char pad;		/* pad */
-	struct pnp_irq *next;		/* next IRQ */
+	DECLARE_BITMAP(map, PNP_IRQ_NR);	/* bitmaks for IRQ lines */
+	unsigned char flags;	/* IRQ flags */
+	unsigned char pad;	/* pad */
+	struct pnp_irq *next;	/* next IRQ */
 };
 
 struct pnp_dma {
-	unsigned char map;		/* bitmask for DMA channels */
-	unsigned char flags;		/* DMA flags */
-	struct pnp_dma *next;		/* next port */
+	unsigned char map;	/* bitmask for DMA channels */
+	unsigned char flags;	/* DMA flags */
+	struct pnp_dma *next;	/* next port */
 };
 
 struct pnp_mem {
-	unsigned int min;		/* min base number */
-	unsigned int max;		/* max base number */
-	unsigned int align;		/* align boundary */
-	unsigned int size;		/* size of range */
-	unsigned char flags;		/* memory flags */
-	unsigned char pad;		/* pad */
-	struct pnp_mem *next;		/* next memory resource */
+	unsigned int min;	/* min base number */
+	unsigned int max;	/* max base number */
+	unsigned int align;	/* align boundary */
+	unsigned int size;	/* size of range */
+	unsigned char flags;	/* memory flags */
+	unsigned char pad;	/* pad */
+	struct pnp_mem *next;	/* next memory resource */
 };
 
 #define PNP_RES_PRIORITY_PREFERRED	0
@@ -113,10 +112,10 @@ struct pnp_mem {
 
 struct pnp_option {
 	unsigned short priority;	/* priority */
-	struct pnp_port *port;		/* first port */
-	struct pnp_irq *irq;		/* first IRQ */
-	struct pnp_dma *dma;		/* first DMA */
-	struct pnp_mem *mem;		/* first memory resource */
+	struct pnp_port *port;	/* first port */
+	struct pnp_irq *irq;	/* first IRQ */
+	struct pnp_dma *dma;	/* first DMA */
+	struct pnp_mem *mem;	/* first memory resource */
 	struct pnp_option *next;	/* used to chain dependent resources */
 };
 
@@ -127,26 +126,25 @@ struct pnp_resource_table {
 	struct resource irq_resource[PNP_MAX_IRQ];
 };
 
-
 /*
  * Device Managemnt
  */
 
 struct pnp_card {
-	struct device dev;		/* Driver Model device interface */
-	unsigned char number;		/* used as an index, must be unique */
+	struct device dev;	/* Driver Model device interface */
+	unsigned char number;	/* used as an index, must be unique */
 	struct list_head global_list;	/* node in global list of cards */
 	struct list_head protocol_list;	/* node in protocol's list of cards */
 	struct list_head devices;	/* devices attached to the card */
 
-	struct pnp_protocol * protocol;
-	struct pnp_id * id;		/* contains supported EISA IDs*/
+	struct pnp_protocol *protocol;
+	struct pnp_id *id;	/* contains supported EISA IDs */
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
-	unsigned char	pnpver;		/* Plug & Play version */
-	unsigned char	productver;	/* product version */
-	unsigned int	serial;		/* serial number */
-	unsigned char	checksum;	/* if zero - checksum passed */
+	unsigned char pnpver;	/* Plug & Play version */
+	unsigned char productver;	/* product version */
+	unsigned int serial;	/* serial number */
+	unsigned char checksum;	/* if zero - checksum passed */
 	struct proc_dir_entry *procdir;	/* directory entry in /proc/bus/isapnp */
 };
 
@@ -159,26 +157,26 @@ struct pnp_card {
 	(card) = global_to_pnp_card((card)->global_list.next))
 
 struct pnp_card_link {
-	struct pnp_card * card;
-	struct pnp_card_driver * driver;
-	void * driver_data;
+	struct pnp_card *card;
+	struct pnp_card_driver *driver;
+	void *driver_data;
 	pm_message_t pm_state;
 };
 
-static inline void *pnp_get_card_drvdata (struct pnp_card_link *pcard)
+static inline void *pnp_get_card_drvdata(struct pnp_card_link *pcard)
 {
 	return pcard->driver_data;
 }
 
-static inline void pnp_set_card_drvdata (struct pnp_card_link *pcard, void *data)
+static inline void pnp_set_card_drvdata(struct pnp_card_link *pcard, void *data)
 {
 	pcard->driver_data = data;
 }
 
 struct pnp_dev {
-	struct device dev;		/* Driver Model device interface */
+	struct device dev;	/* Driver Model device interface */
 	u64 dma_mask;
-	unsigned char number;		/* used as an index, must be unique */
+	unsigned char number;	/* used as an index, must be unique */
 	int status;
 
 	struct list_head global_list;	/* node in global list of devices */
@@ -186,22 +184,22 @@ struct pnp_dev {
 	struct list_head card_list;	/* node in card's list of devices */
 	struct list_head rdev_list;	/* node in cards list of requested devices */
 
-	struct pnp_protocol * protocol;
-	struct pnp_card * card;		/* card the device is attached to, none if NULL */
-	struct pnp_driver * driver;
-	struct pnp_card_link * card_link;
+	struct pnp_protocol *protocol;
+	struct pnp_card *card;	/* card the device is attached to, none if NULL */
+	struct pnp_driver *driver;
+	struct pnp_card_link *card_link;
 
-	struct pnp_id	* id;	/* supported EISA IDs*/
+	struct pnp_id *id;	/* supported EISA IDs */
 
 	int active;
 	int capabilities;
-	struct pnp_option * independent;
-	struct pnp_option * dependent;
+	struct pnp_option *independent;
+	struct pnp_option *dependent;
 	struct pnp_resource_table res;
 
 	char name[PNP_NAME_LEN];	/* contains a human-readable name */
-	unsigned short	regs;		/* ISAPnP: supported registers */
-	int 		flags;		/* used by protocols */
+	unsigned short regs;	/* ISAPnP: supported registers */
+	int flags;		/* used by protocols */
 	struct proc_dir_entry *procent;	/* device entry in /proc/bus/isapnp */
 	void *data;
 };
@@ -220,19 +218,19 @@ struct pnp_dev {
 	(dev) = card_to_pnp_dev((dev)->card_list.next))
 #define pnp_dev_name(dev) (dev)->name
 
-static inline void *pnp_get_drvdata (struct pnp_dev *pdev)
+static inline void *pnp_get_drvdata(struct pnp_dev *pdev)
 {
 	return dev_get_drvdata(&pdev->dev);
 }
 
-static inline void pnp_set_drvdata (struct pnp_dev *pdev, void *data)
+static inline void pnp_set_drvdata(struct pnp_dev *pdev, void *data)
 {
 	dev_set_drvdata(&pdev->dev, data);
 }
 
 struct pnp_fixup {
 	char id[7];
-	void (*quirk_function)(struct pnp_dev *dev);	/* fixup function */
+	void (*quirk_function) (struct pnp_dev * dev);	/* fixup function */
 };
 
 /* config parameters */
@@ -269,7 +267,6 @@ extern struct pnp_protocol pnpbios_protocol;
 #define pnp_device_is_pnpbios(dev) 0
 #endif
 
-
 /* status */
 #define PNP_READY		0x0000
 #define PNP_ATTACHED		0x0001
@@ -287,17 +284,18 @@ extern struct pnp_protocol pnpbios_protocol;
 
 struct pnp_id {
 	char id[PNP_ID_LEN];
-	struct pnp_id * next;
+	struct pnp_id *next;
 };
 
 struct pnp_driver {
-	char * name;
+	char *name;
 	const struct pnp_device_id *id_table;
 	unsigned int flags;
-	int  (*probe)  (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
-	void (*remove) (struct pnp_dev *dev);
-	int  (*suspend) (struct pnp_dev *dev, pm_message_t state);
-	int  (*resume) (struct pnp_dev *dev);
+	int (*probe) (struct pnp_dev * dev,
+		      const struct pnp_device_id * dev_id);
+	void (*remove) (struct pnp_dev * dev);
+	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
+	int (*resume) (struct pnp_dev * dev);
 	struct device_driver driver;
 };
 
@@ -305,13 +303,14 @@ struct pnp_driver {
 
 struct pnp_card_driver {
 	struct list_head global_list;
-	char * name;
+	char *name;
 	const struct pnp_card_device_id *id_table;
 	unsigned int flags;
-	int  (*probe)  (struct pnp_card_link *card, const struct pnp_card_device_id *card_id);
-	void (*remove) (struct pnp_card_link *card);
-	int  (*suspend) (struct pnp_card_link *card, pm_message_t state);
-	int  (*resume) (struct pnp_card_link *card);
+	int (*probe) (struct pnp_card_link * card,
+		      const struct pnp_card_device_id * card_id);
+	void (*remove) (struct pnp_card_link * card);
+	int (*suspend) (struct pnp_card_link * card, pm_message_t state);
+	int (*resume) (struct pnp_card_link * card);
 	struct pnp_driver link;
 };
 
@@ -321,29 +320,28 @@ struct pnp_card_driver {
 #define PNP_DRIVER_RES_DO_NOT_CHANGE	0x0001	/* do not change the state of the device */
 #define PNP_DRIVER_RES_DISABLE		0x0003	/* ensure the device is disabled */
 
-
 /*
  * Protocol Management
  */
 
 struct pnp_protocol {
-	struct list_head	protocol_list;
-	char		      * name;
+	struct list_head protocol_list;
+	char *name;
 
 	/* resource control functions */
-	int (*get)(struct pnp_dev *dev, struct pnp_resource_table *res);
-	int (*set)(struct pnp_dev *dev, struct pnp_resource_table *res);
-	int (*disable)(struct pnp_dev *dev);
+	int (*get) (struct pnp_dev * dev, struct pnp_resource_table * res);
+	int (*set) (struct pnp_dev * dev, struct pnp_resource_table * res);
+	int (*disable) (struct pnp_dev * dev);
 
 	/* protocol specific suspend/resume */
-	int (*suspend)(struct pnp_dev *dev, pm_message_t state);
-	int (*resume)(struct pnp_dev *dev);
+	int (*suspend) (struct pnp_dev * dev, pm_message_t state);
+	int (*resume) (struct pnp_dev * dev);
 
 	/* used by pnp layer only (look but don't touch) */
-	unsigned char		number;		/* protocol number*/
-	struct device		dev;		/* link to driver model */
-	struct list_head	cards;
-	struct list_head	devices;
+	unsigned char number;	/* protocol number */
+	struct device dev;	/* link to driver model */
+	struct list_head cards;
+	struct list_head devices;
 };
 
 #define to_pnp_protocol(n) list_entry(n, struct pnp_protocol, protocol_list)
@@ -356,7 +354,6 @@ struct pnp_protocol {
 	(dev) != protocol_to_pnp_dev(&(protocol)->devices); \
 	(dev) = protocol_to_pnp_dev((dev)->protocol_list.next))
 
-
 extern struct bus_type pnp_bus_type;
 
 #if defined(CONFIG_PNP)
@@ -376,21 +373,25 @@ void pnp_remove_card(struct pnp_card *card);
 int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev);
 void pnp_remove_card_device(struct pnp_dev *dev);
 int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card);
-struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from);
-void pnp_release_card_device(struct pnp_dev * dev);
-int pnp_register_card_driver(struct pnp_card_driver * drv);
-void pnp_unregister_card_driver(struct pnp_card_driver * drv);
+struct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,
+					const char *id, struct pnp_dev *from);
+void pnp_release_card_device(struct pnp_dev *dev);
+int pnp_register_card_driver(struct pnp_card_driver *drv);
+void pnp_unregister_card_driver(struct pnp_card_driver *drv);
 extern struct list_head pnp_cards;
 
 /* resource management */
-struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev);
-struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority);
+struct pnp_option *pnp_register_independent_option(struct pnp_dev *dev);
+struct pnp_option *pnp_register_dependent_option(struct pnp_dev *dev,
+						 int priority);
 int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data);
 int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data);
-int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data);
+int pnp_register_port_resource(struct pnp_option *option,
+			       struct pnp_port *data);
 int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data);
 void pnp_init_resource_table(struct pnp_resource_table *table);
-int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode);
+int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res,
+			  int mode);
 int pnp_auto_config_dev(struct pnp_dev *dev);
 int pnp_validate_config(struct pnp_dev *dev);
 int pnp_start_dev(struct pnp_dev *dev);
@@ -398,11 +399,11 @@ int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
 int pnp_disable_dev(struct pnp_dev *dev);
 void pnp_resource_change(struct resource *resource, resource_size_t start,
-				resource_size_t size);
+			 resource_size_t size);
 
 /* protocol helpers */
-int pnp_is_active(struct pnp_dev * dev);
-int compare_pnp_id(struct pnp_id * pos, const char * id);
+int pnp_is_active(struct pnp_dev *dev);
+int compare_pnp_id(struct pnp_id *pos, const char *id);
 int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev);
 int pnp_register_driver(struct pnp_driver *drv);
 void pnp_unregister_driver(struct pnp_driver *drv);
@@ -410,54 +411,162 @@ void pnp_unregister_driver(struct pnp_driver *drv);
 #else
 
 /* device management */
-static inline int pnp_register_protocol(struct pnp_protocol *protocol) { return -ENODEV; }
-static inline void pnp_unregister_protocol(struct pnp_protocol *protocol) { }
-static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
-static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { ; }
+static inline int pnp_register_protocol(struct pnp_protocol *protocol)
+{
+	return -ENODEV;
+}
+static inline void pnp_unregister_protocol(struct pnp_protocol *protocol)
+{
+}
+static inline int pnp_init_device(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_add_device(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_device_attach(struct pnp_dev *pnp_dev)
+{
+	return -ENODEV;
+}
+static inline void pnp_device_detach(struct pnp_dev *pnp_dev)
+{;
+}
+
 #define pnp_platform_devices 0
 
 /* multidevice card support */
-static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }
-static inline void pnp_remove_card(struct pnp_card *card) { ; }
-static inline int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev) { return -ENODEV; }
-static inline void pnp_remove_card_device(struct pnp_dev *dev) { ; }
-static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card) { return -ENODEV; }
-static inline struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from) { return NULL; }
-static inline void pnp_release_card_device(struct pnp_dev * dev) { ; }
-static inline int pnp_register_card_driver(struct pnp_card_driver * drv) { return -ENODEV; }
-static inline void pnp_unregister_card_driver(struct pnp_card_driver * drv) { ; }
+static inline int pnp_add_card(struct pnp_card *card)
+{
+	return -ENODEV;
+}
+static inline void pnp_remove_card(struct pnp_card *card)
+{;
+}
+static inline int pnp_add_card_device(struct pnp_card *card,
+				      struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline void pnp_remove_card_device(struct pnp_dev *dev)
+{;
+}
+static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card)
+{
+	return -ENODEV;
+}
+static inline struct pnp_dev *pnp_request_card_device(struct pnp_card_link
+						      *clink, const char *id,
+						      struct pnp_dev *from)
+{
+	return NULL;
+}
+static inline void pnp_release_card_device(struct pnp_dev *dev)
+{;
+}
+static inline int pnp_register_card_driver(struct pnp_card_driver *drv)
+{
+	return -ENODEV;
+}
+static inline void pnp_unregister_card_driver(struct pnp_card_driver *drv)
+{;
+}
 
 /* resource management */
-static inline struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev) { return NULL; }
-static inline struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority) { return NULL; }
-static inline int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
-static inline int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
-static inline int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
-static inline int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
-static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
-static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
-static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline struct pnp_option *pnp_register_independent_option(struct pnp_dev
+								 *dev)
+{
+	return NULL;
+}
+static inline struct pnp_option *pnp_register_dependent_option(struct pnp_dev
+							       *dev,
+							       int priority)
+{
+	return NULL;
+}
+static inline int pnp_register_irq_resource(struct pnp_option *option,
+					    struct pnp_irq *data)
+{
+	return -ENODEV;
+}
+static inline int pnp_register_dma_resource(struct pnp_option *option,
+					    struct pnp_dma *data)
+{
+	return -ENODEV;
+}
+static inline int pnp_register_port_resource(struct pnp_option *option,
+					     struct pnp_port *data)
+{
+	return -ENODEV;
+}
+static inline int pnp_register_mem_resource(struct pnp_option *option,
+					    struct pnp_mem *data)
+{
+	return -ENODEV;
+}
+static inline void pnp_init_resource_table(struct pnp_resource_table *table)
+{
+}
+static inline int pnp_manual_config_dev(struct pnp_dev *dev,
+					struct pnp_resource_table *res,
+					int mode)
+{
+	return -ENODEV;
+}
+static inline int pnp_auto_config_dev(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_validate_config(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_start_dev(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_stop_dev(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_activate_dev(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_disable_dev(struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
 static inline void pnp_resource_change(struct resource *resource,
-					resource_size_t start,
-					resource_size_t size) { }
+				       resource_size_t start,
+				       resource_size_t size)
+{
+}
 
 /* protocol helpers */
-static inline int pnp_is_active(struct pnp_dev * dev) { return 0; }
-static inline int compare_pnp_id(struct pnp_id * pos, const char * id) { return -ENODEV; }
-static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev) { return -ENODEV; }
-static inline int pnp_register_driver(struct pnp_driver *drv) { return -ENODEV; }
-static inline void pnp_unregister_driver(struct pnp_driver *drv) { ; }
+static inline int pnp_is_active(struct pnp_dev *dev)
+{
+	return 0;
+}
+static inline int compare_pnp_id(struct pnp_id *pos, const char *id)
+{
+	return -ENODEV;
+}
+static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev)
+{
+	return -ENODEV;
+}
+static inline int pnp_register_driver(struct pnp_driver *drv)
+{
+	return -ENODEV;
+}
+static inline void pnp_unregister_driver(struct pnp_driver *drv)
+{;
+}
 
 #endif /* CONFIG_PNP */
 
-
 #define pnp_err(format, arg...) printk(KERN_ERR "pnp: " format "\n" , ## arg)
 #define pnp_info(format, arg...) printk(KERN_INFO "pnp: " format "\n" , ## arg)
 #define pnp_warn(format, arg...) printk(KERN_WARNING "pnp: " format "\n" , ## arg)

commit fc30e68e88baf463683bde43347756889ba2ffae
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:20 2007 +0800

    ACPI, PNP: hook ACPI D-state to PNP suspend/resume
    
    applied after Rafel's 'PM: Update global suspend and hibernation operations framework' patch set
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 2a1897e6f937..66edb2293184 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -335,6 +335,10 @@ struct pnp_protocol {
 	int (*set)(struct pnp_dev *dev, struct pnp_resource_table *res);
 	int (*disable)(struct pnp_dev *dev);
 
+	/* protocol specific suspend/resume */
+	int (*suspend)(struct pnp_dev *dev, pm_message_t state);
+	int (*resume)(struct pnp_dev *dev);
+
 	/* used by pnp layer only (look but don't touch) */
 	unsigned char		number;		/* protocol number*/
 	struct device		dev;		/* link to driver model */

commit 8f81dd149806bc53c68c92f34d61f88427079039
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue May 8 00:35:54 2007 -0700

    PNP: notice whether we have PNP devices (PNPBIOS or PNPACPI)
    
    This series converts i386 and x86_64 legacy serial ports to be platform
    devices and prevents probing for them if we have PNP.
    
    This prevents double discovery, where a device was found both by the legacy
    probe and by 8250_pnp.
    
    This also prevents the serial driver from claiming IRDA devices (unless they
    have a UART PNP ID).  The serial legacy probe sometimes assumed the wrong IRQ,
    so the user had to use "setserial" to fix it.
    
    Removing the need for setserial to make IRDA devices work seems good, but it
    does break some things.  In particular, you may need to keep setserial from
    poking legacy UART stuff back in by doing something like "dpkg-reconfigure
    setserial" with the "kernel" option.  Otherwise, the setserial-discovered
    "UART" will claim resources and prevent the IRDA driver from loading.
    
    This patch:
    
    If we can discover devices using PNP, we can skip some legacy probes.  This
    flag ("pnp_platform_devices") indicates that PNPBIOS or PNPACPI is enabled and
    should tell us about builtin devices.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Keith Owens <kaos@ocs.com.au>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Matthieu CASTET <castet.matthieu@free.fr>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Ville Syrjala <syrjala@sci.fi>
    Cc: Russell King <rmk+serial@arm.linux.org.uk>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 00dae5ba128a..2a1897e6f937 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -364,6 +364,7 @@ int pnp_add_device(struct pnp_dev *dev);
 int pnp_device_attach(struct pnp_dev *pnp_dev);
 void pnp_device_detach(struct pnp_dev *pnp_dev);
 extern struct list_head pnp_global;
+extern int pnp_platform_devices;
 
 /* multidevice card support */
 int pnp_add_card(struct pnp_card *card);
@@ -411,6 +412,7 @@ static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
 static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { ; }
+#define pnp_platform_devices 0
 
 /* multidevice card support */
 static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }

commit 2e17c5508fa015f2c7690e29041f437e9308c64f
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:25:29 2007 -0700

    init dma masks in pnp_dev
    
    PNP now initializes device dma masks, which prevents oopses when generic
    dma calls are made using pnp device nodes.
    
    This assumes PNP only uses ISA DMA, with 24 bit addresses; and that it's
    safe to init those masks for all devices (rather than finding out which
    devices have been assigned DMA channels, and handling only those).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Adam Belay <abelay@novell.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 9a5226f0f169..00dae5ba128a 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -177,6 +177,7 @@ static inline void pnp_set_card_drvdata (struct pnp_card_link *pcard, void *data
 
 struct pnp_dev {
 	struct device dev;		/* Driver Model device interface */
+	u64 dma_mask;
 	unsigned char number;		/* used as an index, must be unique */
 	int status;
 

commit cbcdc1debd02e1a2cbc1367ee7e0213e1041f738
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Feb 10 01:45:13 2007 -0800

    [PATCH] PNP: export pnp_bus_type
    
    The PNP framework doesn't export "pnp_bus_type", which is an unfortunate
    exception to the policy followed by pretty much every other bus.  I noticed
    this when I had to find a device in order to provide its platform_data.
    
    Note that per advice from Arjan, the "export" scope has been been minimized to
    avoid the hundred-plus bytes needed to support access from modules.  In this
    case, the symbol is only needed by statically linked kernel code that lives
    outside the drivers/pnp directory.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index ab8a8dd8d64c..9a5226f0f169 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -352,6 +352,8 @@ struct pnp_protocol {
 	(dev) = protocol_to_pnp_dev((dev)->protocol_list.next))
 
 
+extern struct bus_type pnp_bus_type;
+
 #if defined(CONFIG_PNP)
 
 /* device management */

commit b60ba8343b78b182c03cf239d4342785376c1ad1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:07:07 2006 -0700

    [PATCH] 64bit resource: change pnp core to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 93b0959eb40f..ab8a8dd8d64c 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -389,7 +389,8 @@ int pnp_start_dev(struct pnp_dev *dev);
 int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
 int pnp_disable_dev(struct pnp_dev *dev);
-void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size);
+void pnp_resource_change(struct resource *resource, resource_size_t start,
+				resource_size_t size);
 
 /* protocol helpers */
 int pnp_is_active(struct pnp_dev * dev);
@@ -434,7 +435,9 @@ static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
-static inline void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size) { }
+static inline void pnp_resource_change(struct resource *resource,
+					resource_size_t start,
+					resource_size_t size) { }
 
 /* protocol helpers */
 static inline int pnp_is_active(struct pnp_dev * dev) { return 0; }

commit 68094e3251a664ee1389fcf179497237cbf78331
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Nov 29 09:09:32 2005 +0100

    [ALSA] [PATCH] alsa: Improved PnP suspend support
    
    Also use the PnP functions to start/stop the devices during the suspend so
    that drivers will not have to duplicate this code.
    
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 472319fcf631..93b0959eb40f 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -385,6 +385,8 @@ void pnp_init_resource_table(struct pnp_resource_table *table);
 int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode);
 int pnp_auto_config_dev(struct pnp_dev *dev);
 int pnp_validate_config(struct pnp_dev *dev);
+int pnp_start_dev(struct pnp_dev *dev);
+int pnp_stop_dev(struct pnp_dev *dev);
 int pnp_activate_dev(struct pnp_dev *dev);
 int pnp_disable_dev(struct pnp_dev *dev);
 void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size);
@@ -428,6 +430,8 @@ static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
 static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
 static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_start_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_stop_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
 static inline void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size) { }

commit 4c98cfef2efa6b6662ac28c4f0069964bbd9fdf9
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Nov 29 09:09:32 2005 +0100

    [ALSA] PATCH] Add PM support to PnP drivers
    
    Add suspend/resume callback to pnp_driver and pnp_card_driver.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 584d57cb393a..472319fcf631 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -162,6 +162,7 @@ struct pnp_card_link {
 	struct pnp_card * card;
 	struct pnp_card_driver * driver;
 	void * driver_data;
+	pm_message_t pm_state;
 };
 
 static inline void *pnp_get_card_drvdata (struct pnp_card_link *pcard)
@@ -294,6 +295,8 @@ struct pnp_driver {
 	unsigned int flags;
 	int  (*probe)  (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
 	void (*remove) (struct pnp_dev *dev);
+	int  (*suspend) (struct pnp_dev *dev, pm_message_t state);
+	int  (*resume) (struct pnp_dev *dev);
 	struct device_driver driver;
 };
 
@@ -306,6 +309,8 @@ struct pnp_card_driver {
 	unsigned int flags;
 	int  (*probe)  (struct pnp_card_link *card, const struct pnp_card_device_id *card_id);
 	void (*remove) (struct pnp_card_link *card);
+	int  (*suspend) (struct pnp_card_link *card, pm_message_t state);
+	int  (*resume) (struct pnp_card_link *card);
 	struct pnp_driver link;
 };
 

commit b449f63c8ce4a517cb91f237cc3d68d083ec2dd3
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Nov 7 01:01:48 2005 -0800

    [PATCH] drivers/pnp/: cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - core.c: pnp_remove_device
    - #if 0 the following unneeded EXPORT_SYMBOL's:
      - card.c: pnp_add_card
      - card.c: pnp_remove_card
      - card.c: pnp_add_card_device
      - card.c: pnp_remove_card_device
      - card.c: pnp_add_card_id
      - core.c: pnp_register_protocol
      - core.c: pnp_unregister_protocol
      - core.c: pnp_add_device
      - core.c: pnp_remove_device
      - pnpacpi/core.c: pnpacpi_protocol
      - driver.c: pnp_add_id
      - isapnp/core.c: isapnp_read_byte
      - manager.c: pnp_auto_config_dev
      - resource.c: pnp_register_dependent_option
      - resource.c: pnp_register_independent_option
      - resource.c: pnp_register_irq_resource
      - resource.c: pnp_register_dma_resource
      - resource.c: pnp_register_port_resource
      - resource.c: pnp_register_mem_resource
    
    Note that this patch #if 0's exactly one functions and removes no
    functions.  Most it does is the #if 0 of EXPORT_SYMBOL's, so if any modular
    code will use any of them, re-adding will be trivial.
    
    Modular ISAPnP might be interesting in some cases, but this is more legacy
    code.  If someone would work on it to sort all the issues out (starting
    with the point that most users of __ISAPNP__ will have to be fixed)
    re-enabling the required EXPORT_SYMBOL's won't be hard for him.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index aadbac29103c..584d57cb393a 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -353,7 +353,6 @@ struct pnp_protocol {
 int pnp_register_protocol(struct pnp_protocol *protocol);
 void pnp_unregister_protocol(struct pnp_protocol *protocol);
 int pnp_add_device(struct pnp_dev *dev);
-void pnp_remove_device(struct pnp_dev *dev);
 int pnp_device_attach(struct pnp_dev *pnp_dev);
 void pnp_device_detach(struct pnp_dev *pnp_dev);
 extern struct list_head pnp_global;
@@ -399,7 +398,6 @@ static inline int pnp_register_protocol(struct pnp_protocol *protocol) { return
 static inline void pnp_unregister_protocol(struct pnp_protocol *protocol) { }
 static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
 static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
-static inline void pnp_remove_device(struct pnp_dev *dev) { }
 static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
 static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { ; }
 

commit e139aa595c5d3bd01699530cbe017dec75fdb07f
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Sep 6 15:17:05 2005 -0700

    [PATCH] PNP: make pnp_dbg conditional directly on CONFIG_PNP_DEBUG
    
    Seems pointless to require .c files to test CONFIG_PNP_DEBUG and
    conditionally define DEBUG before including <linux/pnp.h>.  Just test
    CONFIG_PNP_DEBUG directly in pnp.h.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
index 5ec2bd0c2848..aadbac29103c 100644
--- a/include/linux/pnp.h
+++ b/include/linux/pnp.h
@@ -443,7 +443,7 @@ static inline void pnp_unregister_driver(struct pnp_driver *drv) { ; }
 #define pnp_info(format, arg...) printk(KERN_INFO "pnp: " format "\n" , ## arg)
 #define pnp_warn(format, arg...) printk(KERN_WARNING "pnp: " format "\n" , ## arg)
 
-#ifdef DEBUG
+#ifdef CONFIG_PNP_DEBUG
 #define pnp_dbg(format, arg...) printk(KERN_DEBUG "pnp: " format "\n" , ## arg)
 #else
 #define pnp_dbg(format, arg...) do {} while (0)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/pnp.h b/include/linux/pnp.h
new file mode 100644
index 000000000000..5ec2bd0c2848
--- /dev/null
+++ b/include/linux/pnp.h
@@ -0,0 +1,454 @@
+/*
+ * Linux Plug and Play Support
+ * Copyright by Adam Belay <ambx1@neo.rr.com>
+ *
+ */
+
+#ifndef _LINUX_PNP_H
+#define _LINUX_PNP_H
+
+#ifdef __KERNEL__
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mod_devicetable.h>
+
+#define PNP_MAX_PORT		8
+#define PNP_MAX_MEM		4
+#define PNP_MAX_IRQ		2
+#define PNP_MAX_DMA		2
+#define PNP_NAME_LEN		50
+
+struct pnp_protocol;
+struct pnp_dev;
+
+
+/*
+ * Resource Management
+ */
+
+/* Use these instead of directly reading pnp_dev to get resource information */
+#define pnp_port_start(dev,bar)   ((dev)->res.port_resource[(bar)].start)
+#define pnp_port_end(dev,bar)     ((dev)->res.port_resource[(bar)].end)
+#define pnp_port_flags(dev,bar)   ((dev)->res.port_resource[(bar)].flags)
+#define pnp_port_valid(dev,bar) \
+	((pnp_port_flags((dev),(bar)) & (IORESOURCE_IO | IORESOURCE_UNSET)) \
+		== IORESOURCE_IO)
+#define pnp_port_len(dev,bar) \
+	((pnp_port_start((dev),(bar)) == 0 &&	\
+	  pnp_port_end((dev),(bar)) ==		\
+	  pnp_port_start((dev),(bar))) ? 0 :	\
+	  					\
+	 (pnp_port_end((dev),(bar)) -		\
+	  pnp_port_start((dev),(bar)) + 1))
+
+#define pnp_mem_start(dev,bar)   ((dev)->res.mem_resource[(bar)].start)
+#define pnp_mem_end(dev,bar)     ((dev)->res.mem_resource[(bar)].end)
+#define pnp_mem_flags(dev,bar)   ((dev)->res.mem_resource[(bar)].flags)
+#define pnp_mem_valid(dev,bar) \
+	((pnp_mem_flags((dev),(bar)) & (IORESOURCE_MEM | IORESOURCE_UNSET)) \
+		== IORESOURCE_MEM)
+#define pnp_mem_len(dev,bar) \
+	((pnp_mem_start((dev),(bar)) == 0 &&	\
+	  pnp_mem_end((dev),(bar)) ==		\
+	  pnp_mem_start((dev),(bar))) ? 0 :	\
+	  					\
+	 (pnp_mem_end((dev),(bar)) -		\
+	  pnp_mem_start((dev),(bar)) + 1))
+
+#define pnp_irq(dev,bar)	 ((dev)->res.irq_resource[(bar)].start)
+#define pnp_irq_flags(dev,bar)	 ((dev)->res.irq_resource[(bar)].flags)
+#define pnp_irq_valid(dev,bar) \
+	((pnp_irq_flags((dev),(bar)) & (IORESOURCE_IRQ | IORESOURCE_UNSET)) \
+		== IORESOURCE_IRQ)
+
+#define pnp_dma(dev,bar)	 ((dev)->res.dma_resource[(bar)].start)
+#define pnp_dma_flags(dev,bar)	 ((dev)->res.dma_resource[(bar)].flags)
+#define pnp_dma_valid(dev,bar) \
+	((pnp_dma_flags((dev),(bar)) & (IORESOURCE_DMA | IORESOURCE_UNSET)) \
+		== IORESOURCE_DMA)
+
+#define PNP_PORT_FLAG_16BITADDR	(1<<0)
+#define PNP_PORT_FLAG_FIXED	(1<<1)
+
+struct pnp_port {
+	unsigned short min;		/* min base number */
+	unsigned short max;		/* max base number */
+	unsigned char align;		/* align boundary */
+	unsigned char size;		/* size of range */
+	unsigned char flags;		/* port flags */
+	unsigned char pad;		/* pad */
+	struct pnp_port *next;		/* next port */
+};
+
+#define PNP_IRQ_NR 256
+struct pnp_irq {
+	DECLARE_BITMAP(map, PNP_IRQ_NR); /* bitmaks for IRQ lines */
+	unsigned char flags;		/* IRQ flags */
+	unsigned char pad;		/* pad */
+	struct pnp_irq *next;		/* next IRQ */
+};
+
+struct pnp_dma {
+	unsigned char map;		/* bitmask for DMA channels */
+	unsigned char flags;		/* DMA flags */
+	struct pnp_dma *next;		/* next port */
+};
+
+struct pnp_mem {
+	unsigned int min;		/* min base number */
+	unsigned int max;		/* max base number */
+	unsigned int align;		/* align boundary */
+	unsigned int size;		/* size of range */
+	unsigned char flags;		/* memory flags */
+	unsigned char pad;		/* pad */
+	struct pnp_mem *next;		/* next memory resource */
+};
+
+#define PNP_RES_PRIORITY_PREFERRED	0
+#define PNP_RES_PRIORITY_ACCEPTABLE	1
+#define PNP_RES_PRIORITY_FUNCTIONAL	2
+#define PNP_RES_PRIORITY_INVALID	65535
+
+struct pnp_option {
+	unsigned short priority;	/* priority */
+	struct pnp_port *port;		/* first port */
+	struct pnp_irq *irq;		/* first IRQ */
+	struct pnp_dma *dma;		/* first DMA */
+	struct pnp_mem *mem;		/* first memory resource */
+	struct pnp_option *next;	/* used to chain dependent resources */
+};
+
+struct pnp_resource_table {
+	struct resource port_resource[PNP_MAX_PORT];
+	struct resource mem_resource[PNP_MAX_MEM];
+	struct resource dma_resource[PNP_MAX_DMA];
+	struct resource irq_resource[PNP_MAX_IRQ];
+};
+
+
+/*
+ * Device Managemnt
+ */
+
+struct pnp_card {
+	struct device dev;		/* Driver Model device interface */
+	unsigned char number;		/* used as an index, must be unique */
+	struct list_head global_list;	/* node in global list of cards */
+	struct list_head protocol_list;	/* node in protocol's list of cards */
+	struct list_head devices;	/* devices attached to the card */
+
+	struct pnp_protocol * protocol;
+	struct pnp_id * id;		/* contains supported EISA IDs*/
+
+	char name[PNP_NAME_LEN];	/* contains a human-readable name */
+	unsigned char	pnpver;		/* Plug & Play version */
+	unsigned char	productver;	/* product version */
+	unsigned int	serial;		/* serial number */
+	unsigned char	checksum;	/* if zero - checksum passed */
+	struct proc_dir_entry *procdir;	/* directory entry in /proc/bus/isapnp */
+};
+
+#define global_to_pnp_card(n) list_entry(n, struct pnp_card, global_list)
+#define protocol_to_pnp_card(n) list_entry(n, struct pnp_card, protocol_list)
+#define to_pnp_card(n) container_of(n, struct pnp_card, dev)
+#define pnp_for_each_card(card) \
+	for((card) = global_to_pnp_card(pnp_cards.next); \
+	(card) != global_to_pnp_card(&pnp_cards); \
+	(card) = global_to_pnp_card((card)->global_list.next))
+
+struct pnp_card_link {
+	struct pnp_card * card;
+	struct pnp_card_driver * driver;
+	void * driver_data;
+};
+
+static inline void *pnp_get_card_drvdata (struct pnp_card_link *pcard)
+{
+	return pcard->driver_data;
+}
+
+static inline void pnp_set_card_drvdata (struct pnp_card_link *pcard, void *data)
+{
+	pcard->driver_data = data;
+}
+
+struct pnp_dev {
+	struct device dev;		/* Driver Model device interface */
+	unsigned char number;		/* used as an index, must be unique */
+	int status;
+
+	struct list_head global_list;	/* node in global list of devices */
+	struct list_head protocol_list;	/* node in list of device's protocol */
+	struct list_head card_list;	/* node in card's list of devices */
+	struct list_head rdev_list;	/* node in cards list of requested devices */
+
+	struct pnp_protocol * protocol;
+	struct pnp_card * card;		/* card the device is attached to, none if NULL */
+	struct pnp_driver * driver;
+	struct pnp_card_link * card_link;
+
+	struct pnp_id	* id;	/* supported EISA IDs*/
+
+	int active;
+	int capabilities;
+	struct pnp_option * independent;
+	struct pnp_option * dependent;
+	struct pnp_resource_table res;
+
+	char name[PNP_NAME_LEN];	/* contains a human-readable name */
+	unsigned short	regs;		/* ISAPnP: supported registers */
+	int 		flags;		/* used by protocols */
+	struct proc_dir_entry *procent;	/* device entry in /proc/bus/isapnp */
+	void *data;
+};
+
+#define global_to_pnp_dev(n) list_entry(n, struct pnp_dev, global_list)
+#define card_to_pnp_dev(n) list_entry(n, struct pnp_dev, card_list)
+#define protocol_to_pnp_dev(n) list_entry(n, struct pnp_dev, protocol_list)
+#define	to_pnp_dev(n) container_of(n, struct pnp_dev, dev)
+#define pnp_for_each_dev(dev) \
+	for((dev) = global_to_pnp_dev(pnp_global.next); \
+	(dev) != global_to_pnp_dev(&pnp_global); \
+	(dev) = global_to_pnp_dev((dev)->global_list.next))
+#define card_for_each_dev(card,dev) \
+	for((dev) = card_to_pnp_dev((card)->devices.next); \
+	(dev) != card_to_pnp_dev(&(card)->devices); \
+	(dev) = card_to_pnp_dev((dev)->card_list.next))
+#define pnp_dev_name(dev) (dev)->name
+
+static inline void *pnp_get_drvdata (struct pnp_dev *pdev)
+{
+	return dev_get_drvdata(&pdev->dev);
+}
+
+static inline void pnp_set_drvdata (struct pnp_dev *pdev, void *data)
+{
+	dev_set_drvdata(&pdev->dev, data);
+}
+
+struct pnp_fixup {
+	char id[7];
+	void (*quirk_function)(struct pnp_dev *dev);	/* fixup function */
+};
+
+/* config parameters */
+#define PNP_CONFIG_NORMAL	0x0001
+#define PNP_CONFIG_FORCE	0x0002	/* disables validity checking */
+
+/* capabilities */
+#define PNP_READ		0x0001
+#define PNP_WRITE		0x0002
+#define PNP_DISABLE		0x0004
+#define PNP_CONFIGURABLE	0x0008
+#define PNP_REMOVABLE		0x0010
+
+#define pnp_can_read(dev)	(((dev)->protocol) && ((dev)->protocol->get) && \
+				 ((dev)->capabilities & PNP_READ))
+#define pnp_can_write(dev)	(((dev)->protocol) && ((dev)->protocol->set) && \
+				 ((dev)->capabilities & PNP_WRITE))
+#define pnp_can_disable(dev)	(((dev)->protocol) && ((dev)->protocol->disable) && \
+				 ((dev)->capabilities & PNP_DISABLE))
+#define pnp_can_configure(dev)	((!(dev)->active) && \
+				 ((dev)->capabilities & PNP_CONFIGURABLE))
+
+#ifdef CONFIG_ISAPNP
+extern struct pnp_protocol isapnp_protocol;
+#define pnp_device_is_isapnp(dev) ((dev)->protocol == (&isapnp_protocol))
+#else
+#define pnp_device_is_isapnp(dev) 0
+#endif
+
+#ifdef CONFIG_PNPBIOS
+extern struct pnp_protocol pnpbios_protocol;
+#define pnp_device_is_pnpbios(dev) ((dev)->protocol == (&pnpbios_protocol))
+#else
+#define pnp_device_is_pnpbios(dev) 0
+#endif
+
+
+/* status */
+#define PNP_READY		0x0000
+#define PNP_ATTACHED		0x0001
+#define PNP_BUSY		0x0002
+#define PNP_FAULTY		0x0004
+
+/* isapnp specific macros */
+
+#define isapnp_card_number(dev)	((dev)->card ? (dev)->card->number : -1)
+#define isapnp_csn_number(dev)  ((dev)->number)
+
+/*
+ * Driver Management
+ */
+
+struct pnp_id {
+	char id[PNP_ID_LEN];
+	struct pnp_id * next;
+};
+
+struct pnp_driver {
+	char * name;
+	const struct pnp_device_id *id_table;
+	unsigned int flags;
+	int  (*probe)  (struct pnp_dev *dev, const struct pnp_device_id *dev_id);
+	void (*remove) (struct pnp_dev *dev);
+	struct device_driver driver;
+};
+
+#define	to_pnp_driver(drv) container_of(drv, struct pnp_driver, driver)
+
+struct pnp_card_driver {
+	struct list_head global_list;
+	char * name;
+	const struct pnp_card_device_id *id_table;
+	unsigned int flags;
+	int  (*probe)  (struct pnp_card_link *card, const struct pnp_card_device_id *card_id);
+	void (*remove) (struct pnp_card_link *card);
+	struct pnp_driver link;
+};
+
+#define	to_pnp_card_driver(drv) container_of(drv, struct pnp_card_driver, link)
+
+/* pnp driver flags */
+#define PNP_DRIVER_RES_DO_NOT_CHANGE	0x0001	/* do not change the state of the device */
+#define PNP_DRIVER_RES_DISABLE		0x0003	/* ensure the device is disabled */
+
+
+/*
+ * Protocol Management
+ */
+
+struct pnp_protocol {
+	struct list_head	protocol_list;
+	char		      * name;
+
+	/* resource control functions */
+	int (*get)(struct pnp_dev *dev, struct pnp_resource_table *res);
+	int (*set)(struct pnp_dev *dev, struct pnp_resource_table *res);
+	int (*disable)(struct pnp_dev *dev);
+
+	/* used by pnp layer only (look but don't touch) */
+	unsigned char		number;		/* protocol number*/
+	struct device		dev;		/* link to driver model */
+	struct list_head	cards;
+	struct list_head	devices;
+};
+
+#define to_pnp_protocol(n) list_entry(n, struct pnp_protocol, protocol_list)
+#define protocol_for_each_card(protocol,card) \
+	for((card) = protocol_to_pnp_card((protocol)->cards.next); \
+	(card) != protocol_to_pnp_card(&(protocol)->cards); \
+	(card) = protocol_to_pnp_card((card)->protocol_list.next))
+#define protocol_for_each_dev(protocol,dev) \
+	for((dev) = protocol_to_pnp_dev((protocol)->devices.next); \
+	(dev) != protocol_to_pnp_dev(&(protocol)->devices); \
+	(dev) = protocol_to_pnp_dev((dev)->protocol_list.next))
+
+
+#if defined(CONFIG_PNP)
+
+/* device management */
+int pnp_register_protocol(struct pnp_protocol *protocol);
+void pnp_unregister_protocol(struct pnp_protocol *protocol);
+int pnp_add_device(struct pnp_dev *dev);
+void pnp_remove_device(struct pnp_dev *dev);
+int pnp_device_attach(struct pnp_dev *pnp_dev);
+void pnp_device_detach(struct pnp_dev *pnp_dev);
+extern struct list_head pnp_global;
+
+/* multidevice card support */
+int pnp_add_card(struct pnp_card *card);
+void pnp_remove_card(struct pnp_card *card);
+int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev);
+void pnp_remove_card_device(struct pnp_dev *dev);
+int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card);
+struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from);
+void pnp_release_card_device(struct pnp_dev * dev);
+int pnp_register_card_driver(struct pnp_card_driver * drv);
+void pnp_unregister_card_driver(struct pnp_card_driver * drv);
+extern struct list_head pnp_cards;
+
+/* resource management */
+struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev);
+struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority);
+int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data);
+int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data);
+int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data);
+int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data);
+void pnp_init_resource_table(struct pnp_resource_table *table);
+int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode);
+int pnp_auto_config_dev(struct pnp_dev *dev);
+int pnp_validate_config(struct pnp_dev *dev);
+int pnp_activate_dev(struct pnp_dev *dev);
+int pnp_disable_dev(struct pnp_dev *dev);
+void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size);
+
+/* protocol helpers */
+int pnp_is_active(struct pnp_dev * dev);
+int compare_pnp_id(struct pnp_id * pos, const char * id);
+int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev);
+int pnp_register_driver(struct pnp_driver *drv);
+void pnp_unregister_driver(struct pnp_driver *drv);
+
+#else
+
+/* device management */
+static inline int pnp_register_protocol(struct pnp_protocol *protocol) { return -ENODEV; }
+static inline void pnp_unregister_protocol(struct pnp_protocol *protocol) { }
+static inline int pnp_init_device(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_add_device(struct pnp_dev *dev) { return -ENODEV; }
+static inline void pnp_remove_device(struct pnp_dev *dev) { }
+static inline int pnp_device_attach(struct pnp_dev *pnp_dev) { return -ENODEV; }
+static inline void pnp_device_detach(struct pnp_dev *pnp_dev) { ; }
+
+/* multidevice card support */
+static inline int pnp_add_card(struct pnp_card *card) { return -ENODEV; }
+static inline void pnp_remove_card(struct pnp_card *card) { ; }
+static inline int pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev) { return -ENODEV; }
+static inline void pnp_remove_card_device(struct pnp_dev *dev) { ; }
+static inline int pnp_add_card_id(struct pnp_id *id, struct pnp_card *card) { return -ENODEV; }
+static inline struct pnp_dev * pnp_request_card_device(struct pnp_card_link *clink, const char * id, struct pnp_dev * from) { return NULL; }
+static inline void pnp_release_card_device(struct pnp_dev * dev) { ; }
+static inline int pnp_register_card_driver(struct pnp_card_driver * drv) { return -ENODEV; }
+static inline void pnp_unregister_card_driver(struct pnp_card_driver * drv) { ; }
+
+/* resource management */
+static inline struct pnp_option * pnp_register_independent_option(struct pnp_dev *dev) { return NULL; }
+static inline struct pnp_option * pnp_register_dependent_option(struct pnp_dev *dev, int priority) { return NULL; }
+static inline int pnp_register_irq_resource(struct pnp_option *option, struct pnp_irq *data) { return -ENODEV; }
+static inline int pnp_register_dma_resource(struct pnp_option *option, struct pnp_dma *data) { return -ENODEV; }
+static inline int pnp_register_port_resource(struct pnp_option *option, struct pnp_port *data) { return -ENODEV; }
+static inline int pnp_register_mem_resource(struct pnp_option *option, struct pnp_mem *data) { return -ENODEV; }
+static inline void pnp_init_resource_table(struct pnp_resource_table *table) { }
+static inline int pnp_manual_config_dev(struct pnp_dev *dev, struct pnp_resource_table *res, int mode) { return -ENODEV; }
+static inline int pnp_auto_config_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_validate_config(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_activate_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_disable_dev(struct pnp_dev *dev) { return -ENODEV; }
+static inline void pnp_resource_change(struct resource *resource, unsigned long start, unsigned long size) { }
+
+/* protocol helpers */
+static inline int pnp_is_active(struct pnp_dev * dev) { return 0; }
+static inline int compare_pnp_id(struct pnp_id * pos, const char * id) { return -ENODEV; }
+static inline int pnp_add_id(struct pnp_id *id, struct pnp_dev *dev) { return -ENODEV; }
+static inline int pnp_register_driver(struct pnp_driver *drv) { return -ENODEV; }
+static inline void pnp_unregister_driver(struct pnp_driver *drv) { ; }
+
+#endif /* CONFIG_PNP */
+
+
+#define pnp_err(format, arg...) printk(KERN_ERR "pnp: " format "\n" , ## arg)
+#define pnp_info(format, arg...) printk(KERN_INFO "pnp: " format "\n" , ## arg)
+#define pnp_warn(format, arg...) printk(KERN_WARNING "pnp: " format "\n" , ## arg)
+
+#ifdef DEBUG
+#define pnp_dbg(format, arg...) printk(KERN_DEBUG "pnp: " format "\n" , ## arg)
+#else
+#define pnp_dbg(format, arg...) do {} while (0)
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_PNP_H */
