commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/sysv_fs.h b/include/linux/sysv_fs.h
index e47d6d90023d..5cf77dbb8d86 100644
--- a/include/linux/sysv_fs.h
+++ b/include/linux/sysv_fs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_SYSV_FS_H
 #define _LINUX_SYSV_FS_H
 

commit 0bcaa65a56ab74003666cf741b0bfa1e9263a11c
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Tue Aug 10 18:03:33 2010 -0700

    fs/sysv: v7: adjust sanity checks for some volumes
    
    Newly mkfs-ed filesystems from Seventh Edition have last modification time
    set to zero, but are otherwise perfectly valid.
    
    Also, tighten up other sanity checks to filter out most filesystems with
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sysv_fs.h b/include/linux/sysv_fs.h
index 96411306eec6..e47d6d90023d 100644
--- a/include/linux/sysv_fs.h
+++ b/include/linux/sysv_fs.h
@@ -148,6 +148,17 @@ struct v7_super_block {
 	char    s_fname[6];     /* file system name */
 	char    s_fpack[6];     /* file system pack name */
 };
+/* Constants to aid sanity checking */
+/* This is not a hard limit, nor enforced by v7 kernel. It's actually just
+ * the limit used by Seventh Edition's ls, though is high enough to assume
+ * that no reasonable file system would have that much entries in root
+ * directory. Thus, if we see anything higher, we just probably got the
+ * endiannes wrong. */
+#define V7_NFILES	1024
+/* The disk addresses are three-byte (despite direct block addresses being
+ * aligned word-wise in inode). If the most significant byte is non-zero,
+ * something is most likely wrong (not a filesystem, bad bytesex). */
+#define V7_MAXSIZE	0x00ffffff
 
 /* Coherent super-block data on disk */
 #define COH_NICINOD	100	/* number of inode cache entries */

commit dddfbaf8f86894415abb8256b55da68dab966ebe
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Tue Apr 29 01:03:26 2008 -0700

    sysv fs: remove superfluous check for __GNUC__ compiler
    
    Since <linux/sysv_fs.h> isn't exported to userspace, there is little
    point checking that this is a GNU-compatible compiler.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sysv_fs.h b/include/linux/sysv_fs.h
index e0248631e461..96411306eec6 100644
--- a/include/linux/sysv_fs.h
+++ b/include/linux/sysv_fs.h
@@ -1,11 +1,7 @@
 #ifndef _LINUX_SYSV_FS_H
 #define _LINUX_SYSV_FS_H
 
-#if defined(__GNUC__)
-# define __packed2__	__attribute__((packed, aligned(2)))
-#else
->> I want to scream! <<
-#endif
+#define __packed2__	__attribute__((packed, aligned(2)))
 
 
 #ifndef __KERNEL__

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/sysv_fs.h b/include/linux/sysv_fs.h
new file mode 100644
index 000000000000..e0248631e461
--- /dev/null
+++ b/include/linux/sysv_fs.h
@@ -0,0 +1,206 @@
+#ifndef _LINUX_SYSV_FS_H
+#define _LINUX_SYSV_FS_H
+
+#if defined(__GNUC__)
+# define __packed2__	__attribute__((packed, aligned(2)))
+#else
+>> I want to scream! <<
+#endif
+
+
+#ifndef __KERNEL__
+typedef u16 __fs16;
+typedef u32 __fs16;
+#endif
+
+/* inode numbers are 16 bit */
+typedef __fs16 sysv_ino_t;
+
+/* Block numbers are 24 bit, sometimes stored in 32 bit.
+   On Coherent FS, they are always stored in PDP-11 manner: the least
+   significant 16 bits come last. */
+typedef __fs32 sysv_zone_t;
+
+/* 0 is non-existent */
+#define SYSV_BADBL_INO	1	/* inode of bad blocks file */
+#define SYSV_ROOT_INO	2	/* inode of root directory */
+
+
+/* Xenix super-block data on disk */
+#define XENIX_NICINOD	100	/* number of inode cache entries */
+#define XENIX_NICFREE	100	/* number of free block list chunk entries */
+struct xenix_super_block {
+	__fs16		s_isize; /* index of first data zone */
+	__fs32		s_fsize __packed2__; /* total number of zones of this fs */
+	/* the start of the free block list: */
+	__fs16		s_nfree;	/* number of free blocks in s_free, <= XENIX_NICFREE */
+	sysv_zone_t	s_free[XENIX_NICFREE]; /* first free block list chunk */
+	/* the cache of free inodes: */
+	__fs16		s_ninode; /* number of free inodes in s_inode, <= XENIX_NICINOD */
+	sysv_ino_t	s_inode[XENIX_NICINOD]; /* some free inodes */
+	/* locks, not used by Linux: */
+	char		s_flock;	/* lock during free block list manipulation */
+	char		s_ilock;	/* lock during inode cache manipulation */
+	char		s_fmod;		/* super-block modified flag */
+	char		s_ronly;	/* flag whether fs is mounted read-only */
+	__fs32		s_time __packed2__; /* time of last super block update */
+	__fs32		s_tfree __packed2__; /* total number of free zones */
+	__fs16		s_tinode;	/* total number of free inodes */
+	__fs16		s_dinfo[4];	/* device information ?? */
+	char		s_fname[6];	/* file system volume name */
+	char		s_fpack[6];	/* file system pack name */
+	char		s_clean;	/* set to 0x46 when filesystem is properly unmounted */
+	char		s_fill[371];
+	s32		s_magic;	/* version of file system */
+	__fs32		s_type;		/* type of file system: 1 for 512 byte blocks
+								2 for 1024 byte blocks
+								3 for 2048 byte blocks */
+								
+};
+
+/*
+ * SystemV FS comes in two variants:
+ * sysv2: System V Release 2 (e.g. Microport), structure elements aligned(2).
+ * sysv4: System V Release 4 (e.g. Consensys), structure elements aligned(4).
+ */
+#define SYSV_NICINOD	100	/* number of inode cache entries */
+#define SYSV_NICFREE	50	/* number of free block list chunk entries */
+
+/* SystemV4 super-block data on disk */
+struct sysv4_super_block {
+	__fs16	s_isize;	/* index of first data zone */
+	u16	s_pad0;
+	__fs32	s_fsize;	/* total number of zones of this fs */
+	/* the start of the free block list: */
+	__fs16	s_nfree;	/* number of free blocks in s_free, <= SYSV_NICFREE */
+	u16	s_pad1;
+	sysv_zone_t	s_free[SYSV_NICFREE]; /* first free block list chunk */
+	/* the cache of free inodes: */
+	__fs16	s_ninode;	/* number of free inodes in s_inode, <= SYSV_NICINOD */
+	u16	s_pad2;
+	sysv_ino_t     s_inode[SYSV_NICINOD]; /* some free inodes */
+	/* locks, not used by Linux: */
+	char	s_flock;	/* lock during free block list manipulation */
+	char	s_ilock;	/* lock during inode cache manipulation */
+	char	s_fmod;		/* super-block modified flag */
+	char	s_ronly;	/* flag whether fs is mounted read-only */
+	__fs32	s_time;		/* time of last super block update */
+	__fs16	s_dinfo[4];	/* device information ?? */
+	__fs32	s_tfree;	/* total number of free zones */
+	__fs16	s_tinode;	/* total number of free inodes */
+	u16	s_pad3;
+	char	s_fname[6];	/* file system volume name */
+	char	s_fpack[6];	/* file system pack name */
+	s32	s_fill[12];
+	__fs32	s_state;	/* file system state: 0x7c269d38-s_time means clean */
+	s32	s_magic;	/* version of file system */
+	__fs32	s_type;		/* type of file system: 1 for 512 byte blocks
+								2 for 1024 byte blocks */
+};
+
+/* SystemV2 super-block data on disk */
+struct sysv2_super_block {
+	__fs16	s_isize; 		/* index of first data zone */
+	__fs32	s_fsize __packed2__;	/* total number of zones of this fs */
+	/* the start of the free block list: */
+	__fs16	s_nfree;		/* number of free blocks in s_free, <= SYSV_NICFREE */
+	sysv_zone_t s_free[SYSV_NICFREE];	/* first free block list chunk */
+	/* the cache of free inodes: */
+	__fs16	s_ninode;		/* number of free inodes in s_inode, <= SYSV_NICINOD */
+	sysv_ino_t     s_inode[SYSV_NICINOD]; /* some free inodes */
+	/* locks, not used by Linux: */
+	char	s_flock;		/* lock during free block list manipulation */
+	char	s_ilock;		/* lock during inode cache manipulation */
+	char	s_fmod;			/* super-block modified flag */
+	char	s_ronly;		/* flag whether fs is mounted read-only */
+	__fs32	s_time __packed2__;	/* time of last super block update */
+	__fs16	s_dinfo[4];		/* device information ?? */
+	__fs32	s_tfree __packed2__;	/* total number of free zones */
+	__fs16	s_tinode;		/* total number of free inodes */
+	char	s_fname[6];		/* file system volume name */
+	char	s_fpack[6];		/* file system pack name */
+	s32	s_fill[14];
+	__fs32	s_state;		/* file system state: 0xcb096f43 means clean */
+	s32	s_magic;		/* version of file system */
+	__fs32	s_type;			/* type of file system: 1 for 512 byte blocks
+								2 for 1024 byte blocks */
+};
+
+/* V7 super-block data on disk */
+#define V7_NICINOD     100     /* number of inode cache entries */
+#define V7_NICFREE     50      /* number of free block list chunk entries */
+struct v7_super_block {
+	__fs16 s_isize;        /* index of first data zone */
+	__fs32 s_fsize __packed2__; /* total number of zones of this fs */
+	/* the start of the free block list: */
+	__fs16 s_nfree;        /* number of free blocks in s_free, <= V7_NICFREE */
+	sysv_zone_t s_free[V7_NICFREE]; /* first free block list chunk */
+	/* the cache of free inodes: */
+	__fs16 s_ninode;       /* number of free inodes in s_inode, <= V7_NICINOD */
+	sysv_ino_t      s_inode[V7_NICINOD]; /* some free inodes */
+	/* locks, not used by Linux or V7: */
+	char    s_flock;        /* lock during free block list manipulation */
+	char    s_ilock;        /* lock during inode cache manipulation */
+	char    s_fmod;         /* super-block modified flag */
+	char    s_ronly;        /* flag whether fs is mounted read-only */
+	__fs32  s_time __packed2__; /* time of last super block update */
+	/* the following fields are not maintained by V7: */
+	__fs32  s_tfree __packed2__; /* total number of free zones */
+	__fs16  s_tinode;       /* total number of free inodes */
+	__fs16  s_m;            /* interleave factor */
+	__fs16  s_n;            /* interleave factor */
+	char    s_fname[6];     /* file system name */
+	char    s_fpack[6];     /* file system pack name */
+};
+
+/* Coherent super-block data on disk */
+#define COH_NICINOD	100	/* number of inode cache entries */
+#define COH_NICFREE	64	/* number of free block list chunk entries */
+struct coh_super_block {
+	__fs16		s_isize;	/* index of first data zone */
+	__fs32		s_fsize __packed2__; /* total number of zones of this fs */
+	/* the start of the free block list: */
+	__fs16 s_nfree;	/* number of free blocks in s_free, <= COH_NICFREE */
+	sysv_zone_t	s_free[COH_NICFREE] __packed2__; /* first free block list chunk */
+	/* the cache of free inodes: */
+	__fs16		s_ninode;	/* number of free inodes in s_inode, <= COH_NICINOD */
+	sysv_ino_t	s_inode[COH_NICINOD]; /* some free inodes */
+	/* locks, not used by Linux: */
+	char		s_flock;	/* lock during free block list manipulation */
+	char		s_ilock;	/* lock during inode cache manipulation */
+	char		s_fmod;		/* super-block modified flag */
+	char		s_ronly;	/* flag whether fs is mounted read-only */
+	__fs32		s_time __packed2__; /* time of last super block update */
+	__fs32		s_tfree __packed2__; /* total number of free zones */
+	__fs16		s_tinode;	/* total number of free inodes */
+	__fs16		s_interleave_m;	/* interleave factor */
+	__fs16		s_interleave_n;
+	char		s_fname[6];	/* file system volume name */
+	char		s_fpack[6];	/* file system pack name */
+	__fs32		s_unique;	/* zero, not used */
+};
+
+/* SystemV/Coherent inode data on disk */
+struct sysv_inode {
+	__fs16 i_mode;
+	__fs16 i_nlink;
+	__fs16 i_uid;
+	__fs16 i_gid;
+	__fs32 i_size;
+	u8  i_data[3*(10+1+1+1)];
+	u8  i_gen;
+	__fs32 i_atime;	/* time of last access */
+	__fs32 i_mtime;	/* time of last modification */
+	__fs32 i_ctime;	/* time of creation */
+};
+
+/* SystemV/Coherent directory entry on disk */
+#define SYSV_NAMELEN	14	/* max size of name in struct sysv_dir_entry */
+struct sysv_dir_entry {
+	sysv_ino_t inode;
+	char name[SYSV_NAMELEN]; /* up to 14 characters, the rest are zeroes */
+};
+
+#define SYSV_DIRSIZE	sizeof(struct sysv_dir_entry)	/* size of every directory entry */
+
+#endif /* _LINUX_SYSV_FS_H */
