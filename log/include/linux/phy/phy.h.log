commit 42d068472ddf532f3ca2bcdd06d1ca6b53f57e5e
Author: Yuti Amonkar <yamonkar@cadence.com>
Date:   Mon Jan 6 13:22:40 2020 +0100

    phy: Add DisplayPort configuration options
    
    Allow DisplayPort PHYs to be configured through the generic
    functions through a custom structure added to the generic union.
    The configuration structure is used for reconfiguration of
    DisplayPort PHYs during link training operation.
    
    The parameters added here are the ones defined in the DisplayPort
    spec v1.4 which include link rate, number of lanes, voltage swing
    and pre-emphasis.
    
    Add the DisplayPort phy mode to the generic phy_mode enum.
    
    Signed-off-by: Yuti Amonkar <yamonkar@cadence.com>
    Reviewed-by: Maxime Ripard <mripard@kernel.org>
    Reviewed-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 19eddd64c8f6..bcee8eba62b3 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -16,6 +16,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
+#include <linux/phy/phy-dp.h>
 #include <linux/phy/phy-mipi-dphy.h>
 
 struct phy;
@@ -40,6 +41,7 @@ enum phy_mode {
 	PHY_MODE_MIPI_DPHY,
 	PHY_MODE_SATA,
 	PHY_MODE_LVDS,
+	PHY_MODE_DP
 };
 
 /**
@@ -47,9 +49,12 @@ enum phy_mode {
  *
  * @mipi_dphy:	Configuration set applicable for phys supporting
  *		the MIPI_DPHY phy mode.
+ * @dp:		Configuration set applicable for phys supporting
+ *		the DisplayPort protocol.
  */
 union phy_configure_opts {
 	struct phy_configure_opts_mipi_dphy	mipi_dphy;
+	struct phy_configure_opts_dp		dp;
 };
 
 /**

commit 987351e1ea7772cf2f0795e917fb33b2e282e1c1
Author: Alexandre Torgue <alexandre.torgue@st.com>
Date:   Mon Nov 4 15:37:13 2019 +0100

    phy: core: Add consumer device link support
    
    In order to enforce suspend/resume ordering, this commit creates link
    between phy consumers and phy devices. This link avoids to suspend phy
    before phy consumers.
    
    Signed-off-by: Alexandre Torgue <alexandre.torgue@st.com>
    [jonathanh@nvidia.com: Fix an abort when of_phy_get() returns error]
    Signed-off-by: Jonathan Hunter <jonathanh@nvidia.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 56d3a100006a..19eddd64c8f6 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -234,7 +234,8 @@ struct phy *devm_of_phy_get(struct device *dev, struct device_node *np,
 			    const char *con_id);
 struct phy *devm_of_phy_get_by_index(struct device *dev, struct device_node *np,
 				     int index);
-void phy_put(struct phy *phy);
+void of_phy_put(struct phy *phy);
+void phy_put(struct device *dev, struct phy *phy);
 void devm_phy_put(struct device *dev, struct phy *phy);
 struct phy *of_phy_get(struct device_node *np, const char *con_id);
 struct phy *of_phy_simple_xlate(struct device *dev,
@@ -419,7 +420,11 @@ static inline struct phy *devm_of_phy_get_by_index(struct device *dev,
 	return ERR_PTR(-ENOSYS);
 }
 
-static inline void phy_put(struct phy *phy)
+static inline void of_phy_put(struct phy *phy)
+{
+}
+
+static inline void phy_put(struct device *dev, struct phy *phy)
 {
 }
 

commit 711b2bfba748b5adf8ad837b490b393197279203
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Thu Oct 24 00:38:49 2019 +0200

    phy: add PHY_MODE_LVDS
    
    There are combo phys out there that can be switched between doing
    dsi and lvds. So add a mode definition for it.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 15032f145063..56d3a100006a 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -38,7 +38,8 @@ enum phy_mode {
 	PHY_MODE_PCIE,
 	PHY_MODE_ETHERNET,
 	PHY_MODE_MIPI_DPHY,
-	PHY_MODE_SATA
+	PHY_MODE_SATA,
+	PHY_MODE_LVDS,
 };
 
 /**

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index ef13aea1d370..15032f145063 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -1,14 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * phy.h -- generic phy header file
  *
  * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
  *
  * Author: Kishon Vijay Abraham I <kishon@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #ifndef __DRIVERS_PHY_H

commit fec06b2bc436d1cbc3482becd40f656d46cd22b7
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Apr 5 16:38:30 2019 +0530

    phy: core: Add *release* phy_ops invoked when the consumer relinquishes PHY
    
    Add a new phy_ops *release* invoked when the consumer relinquishes the
    PHY using phy_put/devm_phy_put. The initializations done by the PHY
    driver in of_xlate call back can be can be cleaned up here.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 3f350e2749fe..ef13aea1d370 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -64,6 +64,7 @@ union phy_configure_opts {
  * @set_mode: set the mode of the phy
  * @reset: resetting the phy
  * @calibrate: calibrate the phy
+ * @release: ops to be performed while the consumer relinquishes the PHY
  * @owner: the module owner containing the ops
  */
 struct phy_ops {
@@ -105,6 +106,7 @@ struct phy_ops {
 			    union phy_configure_opts *opts);
 	int	(*reset)(struct phy *phy);
 	int	(*calibrate)(struct phy *phy);
+	void	(*release)(struct phy *phy);
 	struct module *owner;
 };
 

commit e1706720408e72fb883f6b151c2b3b23d8e7e5b2
Author: John Hubbard <jhubbard@nvidia.com>
Date:   Sat Jan 12 17:29:09 2019 -0800

    phy: fix build breakage: add PHY_MODE_SATA
    
    Commit 49e54187ae0b ("ata: libahci_platform: comply to PHY framework") uses
    the PHY_MODE_SATA, but that enum had not yet been added. This caused a
    build failure for me, with today's linux.git.
    
    Also, there is a potentially conflicting (mis-named) PHY_MODE_SATA, hiding
    in the Marvell Berlin SATA PHY driver.
    
    Fix the build by:
    
        1) Renaming Marvell's defined value to a more scoped name,
           in order to avoid any potential conflicts: PHY_BERLIN_MODE_SATA.
    
        2) Adding the missing enum, which was going to be added anyway as part
           of [1].
    
    [1] https://lkml.kernel.org/r/20190108163124.6409-3-miquel.raynal@bootlin.com
    
    Fixes: 49e54187ae0b ("ata: libahci_platform: comply to PHY framework")
    
    Signed-off-by: John Hubbard <jhubbard@nvidia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Acked-by: Olof Johansson <olof@lixom.net>
    Cc: Grzegorz Jaszczyk <jaz@semihalf.com>
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e8e118d70fd7..3f350e2749fe 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -42,6 +42,7 @@ enum phy_mode {
 	PHY_MODE_PCIE,
 	PHY_MODE_ETHERNET,
 	PHY_MODE_MIPI_DPHY,
+	PHY_MODE_SATA
 };
 
 /**

commit 43d86ee8c639df750529b4d8f062b328b61c423e
Merge: 645ff1e8e704 c5ee066333eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 12:53:47 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull networking fixes from David Miller:
     "Several fixes here. Basically split down the line between newly
      introduced regressions and long existing problems:
    
       1) Double free in tipc_enable_bearer(), from Cong Wang.
    
       2) Many fixes to nf_conncount, from Florian Westphal.
    
       3) op->get_regs_len() can throw an error, check it, from Yunsheng
          Lin.
    
       4) Need to use GFP_ATOMIC in *_add_hash_mac_address() of fsl/fman
          driver, from Scott Wood.
    
       5) Inifnite loop in fib_empty_table(), from Yue Haibing.
    
       6) Use after free in ax25_fillin_cb(), from Cong Wang.
    
       7) Fix socket locking in nr_find_socket(), also from Cong Wang.
    
       8) Fix WoL wakeup enable in r8169, from Heiner Kallweit.
    
       9) On 32-bit sock->sk_stamp is not thread-safe, from Deepa Dinamani.
    
      10) Fix ptr_ring wrap during queue swap, from Cong Wang.
    
      11) Missing shutdown callback in hinic driver, from Xue Chaojing.
    
      12) Need to return NULL on error from ip6_neigh_lookup(), from Stefano
          Brivio.
    
      13) BPF out of bounds speculation fixes from Daniel Borkmann"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (57 commits)
      ipv6: Consider sk_bound_dev_if when binding a socket to an address
      ipv6: Fix dump of specific table with strict checking
      bpf: add various test cases to selftests
      bpf: prevent out of bounds speculation on pointer arithmetic
      bpf: fix check_map_access smin_value test when pointer contains offset
      bpf: restrict unknown scalars of mixed signed bounds for unprivileged
      bpf: restrict stack pointer arithmetic for unprivileged
      bpf: restrict map value pointer arithmetic for unprivileged
      bpf: enable access to ax register also from verifier rewrite
      bpf: move tmp variable into ax register in interpreter
      bpf: move {prev_,}insn_idx into verifier env
      isdn: fix kernel-infoleak in capi_unlocked_ioctl
      ipv6: route: Fix return value of ip6_neigh_lookup() on neigh_create() error
      net/hamradio/6pack: use mod_timer() to rearm timers
      net-next/hinic:add shutdown callback
      net: hns3: call hns3_nic_net_open() while doing HNAE3_UP_CLIENT
      ip: validate header length on virtual device xmit
      tap: call skb_probe_transport_header after setting skb->dev
      ptr_ring: wrap back ->producer in __ptr_ring_swap_queue()
      net: rds: remove unnecessary NULL check
      ...

commit a3c9311f62b4943228ae90f769775dd3bcbfa7c0
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu Dec 27 16:10:59 2018 -0500

    include/linux/phy/phy.h: fix minor kerneldoc errors
    
    Correct two minor kerneldoc errors:
    
     1) missing reference to @mode in struct phy_ops
     2) obsolete reference to @init_data in struct_phy_attrs,
        removed in dbc98635e0d42f0e62ea92813df1e0e4c90f8375
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 03b319f89a34..66d1560f1a26 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -69,6 +69,7 @@ struct phy_ops {
 /**
  * struct phy_attrs - represents phy attributes
  * @bus_width: Data path width implemented by PHY
+ * @mode: PHY mode
  */
 struct phy_attrs {
 	u32			bus_width;
@@ -80,7 +81,6 @@ struct phy_attrs {
  * @dev: phy device
  * @id: id of the phy device
  * @ops: function pointers for performing phy operations
- * @init_data: list of PHY consumers (non-dt only)
  * @mutex: mutex to protect phy_ops
  * @init_count: used to protect when the PHY is used by multiple consumers
  * @power_count: used to protect when the PHY is used by multiple consumers

commit 2ed869990e14bc5528aeb00c45e42793c5406637
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Dec 7 14:55:30 2018 +0100

    phy: Add MIPI D-PHY configuration options
    
    Now that we have some infrastructure for it, allow the MIPI D-PHY phy's to
    be configured through the generic functions through a custom structure
    added to the generic union.
    
    The parameters added here are the ones defined in the MIPI D-PHY spec, plus
    the number of lanes in use. The current set of parameters should cover all
    the potential users.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 04476c026b5a..1fdefadf150a 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -20,6 +20,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
+#include <linux/phy/phy-mipi-dphy.h>
+
 struct phy;
 
 enum phy_mode {
@@ -44,8 +46,12 @@ enum phy_mode {
 
 /**
  * union phy_configure_opts - Opaque generic phy configuration
+ *
+ * @mipi_dphy:	Configuration set applicable for phys supporting
+ *		the MIPI_DPHY phy mode.
  */
 union phy_configure_opts {
+	struct phy_configure_opts_mipi_dphy	mipi_dphy;
 };
 
 /**

commit aeaac93ddb28eeacc0dff9c12cb338eb1de7481d
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Dec 7 14:55:29 2018 +0100

    phy: Add configuration interface
    
    The phy framework is only allowing to configure the power state of the PHY
    using the init and power_on hooks, and their power_off and exit
    counterparts.
    
    While it works for most, simple, PHYs supported so far, some more advanced
    PHYs need some configuration depending on runtime parameters. These PHYs
    have been supported by a number of means already, often by using ad-hoc
    drivers in their consumer drivers.
    
    That doesn't work too well however, when a consumer device needs to deal
    with multiple PHYs, or when multiple consumers need to deal with the same
    PHY (a DSI driver and a CSI driver for example).
    
    So we'll add a new interface, through two funtions, phy_validate and
    phy_configure. The first one will allow to check that a current
    configuration, for a given mode, is applicable. It will also allow the PHY
    driver to tune the settings given as parameters as it sees fit.
    
    phy_configure will actually apply that configuration in the phy itself.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 453f21834685..04476c026b5a 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -42,6 +42,12 @@ enum phy_mode {
 	PHY_MODE_MIPI_DPHY,
 };
 
+/**
+ * union phy_configure_opts - Opaque generic phy configuration
+ */
+union phy_configure_opts {
+};
+
 /**
  * struct phy_ops - set of function pointers for performing phy operations
  * @init: operation to be performed for initializing phy
@@ -59,6 +65,37 @@ struct phy_ops {
 	int	(*power_on)(struct phy *phy);
 	int	(*power_off)(struct phy *phy);
 	int	(*set_mode)(struct phy *phy, enum phy_mode mode, int submode);
+
+	/**
+	 * @configure:
+	 *
+	 * Optional.
+	 *
+	 * Used to change the PHY parameters. phy_init() must have
+	 * been called on the phy.
+	 *
+	 * Returns: 0 if successful, an negative error code otherwise
+	 */
+	int	(*configure)(struct phy *phy, union phy_configure_opts *opts);
+
+	/**
+	 * @validate:
+	 *
+	 * Optional.
+	 *
+	 * Used to check that the current set of parameters can be
+	 * handled by the phy. Implementations are free to tune the
+	 * parameters passed as arguments if needed by some
+	 * implementation detail or constraints. It must not change
+	 * any actual configuration of the PHY, so calling it as many
+	 * times as deemed fit by the consumer must have no side
+	 * effect.
+	 *
+	 * Returns: 0 if the configuration can be applied, an negative
+	 * error code otherwise
+	 */
+	int	(*validate)(struct phy *phy, enum phy_mode mode, int submode,
+			    union phy_configure_opts *opts);
 	int	(*reset)(struct phy *phy);
 	int	(*calibrate)(struct phy *phy);
 	struct module *owner;
@@ -165,6 +202,9 @@ int phy_power_off(struct phy *phy);
 int phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode);
 #define phy_set_mode(phy, mode) \
 	phy_set_mode_ext(phy, mode, 0)
+int phy_configure(struct phy *phy, union phy_configure_opts *opts);
+int phy_validate(struct phy *phy, enum phy_mode mode, int submode,
+		 union phy_configure_opts *opts);
 
 static inline enum phy_mode phy_get_mode(struct phy *phy)
 {
@@ -309,6 +349,24 @@ static inline int phy_calibrate(struct phy *phy)
 	return -ENOSYS;
 }
 
+static inline int phy_configure(struct phy *phy,
+				union phy_configure_opts *opts)
+{
+	if (!phy)
+		return 0;
+
+	return -ENOSYS;
+}
+
+static inline int phy_validate(struct phy *phy, enum phy_mode mode, int submode,
+			       union phy_configure_opts *opts)
+{
+	if (!phy)
+		return 0;
+
+	return -ENOSYS;
+}
+
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return -ENOSYS;

commit c8457828ff481411dca4cdea944c1a0980c862e1
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Dec 7 14:55:28 2018 +0100

    phy: Add MIPI D-PHY mode
    
    MIPI D-PHY is a MIPI standard meant mostly for display and cameras in
    embedded systems. Add a mode for it.
    
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 79da05a3e28d..453f21834685 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -39,6 +39,7 @@ enum phy_mode {
 	PHY_MODE_UFS_HS_B,
 	PHY_MODE_PCIE,
 	PHY_MODE_ETHERNET,
+	PHY_MODE_MIPI_DPHY,
 };
 
 /**

commit b3af06451bf859a45a306678e02b12bb676a9687
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Nov 19 19:24:24 2018 -0600

    phy: core: clean up unused ethernet specific phy modes
    
    After recent changes PHY_MODE_SGMII, PHY_MODE_2500SGMII, PHY_MODE_QSGMII,
    PHY_MODE_10GKR are not used any more and can be removed. Hence - remove
    them.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 02c9ef0c8fff..79da05a3e28d 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -35,10 +35,6 @@ enum phy_mode {
 	PHY_MODE_USB_DEVICE_HS,
 	PHY_MODE_USB_DEVICE_SS,
 	PHY_MODE_USB_OTG,
-	PHY_MODE_SGMII,
-	PHY_MODE_2500SGMII,
-	PHY_MODE_QSGMII,
-	PHY_MODE_10GKR,
 	PHY_MODE_UFS_HS_A,
 	PHY_MODE_UFS_HS_B,
 	PHY_MODE_PCIE,

commit 2af8caeee47846a84bc96abc3a72f7c991153040
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Nov 19 19:24:21 2018 -0600

    phy: core: add PHY_MODE_ETHERNET
    
    Add new PHY's mode to be used by Ethernet PHY interface drivers or
    multipurpose PHYs like serdes. It will be reused in further changes.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index b17e7709c5dc..02c9ef0c8fff 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -42,6 +42,7 @@ enum phy_mode {
 	PHY_MODE_UFS_HS_A,
 	PHY_MODE_UFS_HS_B,
 	PHY_MODE_PCIE,
+	PHY_MODE_ETHERNET,
 };
 
 /**

commit 79a5a18aa9d1062205cdcfa183d4cd5241d1b8da
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Nov 19 19:24:20 2018 -0600

    phy: core: rework phy_set_mode to accept phy mode and submode
    
    Currently the attempt to add support for Ethernet interface mode PHY
    (MII/GMII/RGMII) will lead to the necessity of extending enum phy_mode and
    duplicate there values from phy_interface_t enum (or introduce more PHY
    callbacks) [1]. Both approaches are ineffective and would lead to fast
    bloating of enum phy_mode or struct phy_ops in the process of adding more
    PHYs for different subsystems which will make them unmaintainable.
    
    As discussed in [1] the solution could be to introduce dual level PHYs mode
    configuration - PHY mode and PHY submode. The PHY mode will define generic
    PHY type (subsystem - PCIE/ETHERNET/USB_) while the PHY submode - subsystem
    specific interface mode. The last is usually already defined in
    corresponding subsystem headers (phy_interface_t for Ethernet, enum
    usb_device_speed for USB).
    
    This patch is cumulative change which refactors PHY framework code to
    support dual level PHYs mode configuration - PHY mode and PHY submode. It
    extends .set_mode() callback to support additional parameter "int submode"
    and converts all corresponding PHY drivers to support new .set_mode()
    callback declaration.
    The new extended PHY API
     int phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode)
    is introduced to support dual level PHYs mode configuration and existing
    phy_set_mode() API is converted to macros, so PHY framework consumers do
    not need to be changed (~21 matches).
    
    [1] http://lkml.kernel.org/r/d63588f6-9ab0-848a-5ad4-8073143bd95d@ti.com
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 03b319f89a34..b17e7709c5dc 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -60,7 +60,7 @@ struct phy_ops {
 	int	(*exit)(struct phy *phy);
 	int	(*power_on)(struct phy *phy);
 	int	(*power_off)(struct phy *phy);
-	int	(*set_mode)(struct phy *phy, enum phy_mode mode);
+	int	(*set_mode)(struct phy *phy, enum phy_mode mode, int submode);
 	int	(*reset)(struct phy *phy);
 	int	(*calibrate)(struct phy *phy);
 	struct module *owner;
@@ -164,7 +164,10 @@ int phy_init(struct phy *phy);
 int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
-int phy_set_mode(struct phy *phy, enum phy_mode mode);
+int phy_set_mode_ext(struct phy *phy, enum phy_mode mode, int submode);
+#define phy_set_mode(phy, mode) \
+	phy_set_mode_ext(phy, mode, 0)
+
 static inline enum phy_mode phy_get_mode(struct phy *phy)
 {
 	return phy->attrs.mode;
@@ -278,13 +281,17 @@ static inline int phy_power_off(struct phy *phy)
 	return -ENOSYS;
 }
 
-static inline int phy_set_mode(struct phy *phy, enum phy_mode mode)
+static inline int phy_set_mode_ext(struct phy *phy, enum phy_mode mode,
+				   int submode)
 {
 	if (!phy)
 		return 0;
 	return -ENOSYS;
 }
 
+#define phy_set_mode(phy, mode) \
+	phy_set_mode_ext(phy, mode, 0)
+
 static inline enum phy_mode phy_get_mode(struct phy *phy)
 {
 	return PHY_MODE_INVALID;

commit c2a90025ad09d830c8d8ae69f485eac6aaaa2472
Author: Quentin Schulz <quentin.schulz@bootlin.com>
Date:   Thu Oct 4 14:22:03 2018 +0200

    phy: add QSGMII and PCIE modes
    
    Prepare for upcoming phys that'll handle QSGMII or PCIe.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Quentin Schulz <quentin.schulz@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 9713aebdd348..03b319f89a34 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -37,9 +37,11 @@ enum phy_mode {
 	PHY_MODE_USB_OTG,
 	PHY_MODE_SGMII,
 	PHY_MODE_2500SGMII,
+	PHY_MODE_QSGMII,
 	PHY_MODE_10GKR,
 	PHY_MODE_UFS_HS_A,
 	PHY_MODE_UFS_HS_B,
+	PHY_MODE_PCIE,
 };
 
 /**

commit 5490b8725d80cdfd5266a3732e23d61d0e9f7d2f
Author: Antoine Tenart <antoine.tenart@bootlin.com>
Date:   Thu May 17 10:29:32 2018 +0200

    phy: add 2.5G SGMII mode to the phy_mode enum
    
    This patch adds one more generic PHY mode to the phy_mode enum, to allow
    configuring generic PHYs to the 2.5G SGMII mode by using the set_mode
    callback.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index c9d14eeee7f5..9713aebdd348 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -36,6 +36,7 @@ enum phy_mode {
 	PHY_MODE_USB_DEVICE_SS,
 	PHY_MODE_USB_OTG,
 	PHY_MODE_SGMII,
+	PHY_MODE_2500SGMII,
 	PHY_MODE_10GKR,
 	PHY_MODE_UFS_HS_A,
 	PHY_MODE_UFS_HS_B,

commit becaf17a58473e358e056ada2642e895aae93b0e
Author: Dov Levenglick <levengeek@gmail.com>
Date:   Fri Feb 2 18:34:50 2018 +0200

    phy: fix structure documentation
    
    Add missing documentation of structure members and
    modify the order of documentation to match that of
    the structure declaration.
    
    Signed-off-by: Dov Levenglick <dov.levenglick@gmail.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 485469e6fa7f..c9d14eeee7f5 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -81,7 +81,8 @@ struct phy_attrs {
  * @mutex: mutex to protect phy_ops
  * @init_count: used to protect when the PHY is used by multiple consumers
  * @power_count: used to protect when the PHY is used by multiple consumers
- * @phy_attrs: used to specify PHY specific attributes
+ * @attrs: used to specify PHY specific attributes
+ * @pwr: power regulator associated with the phy
  */
 struct phy {
 	struct device		dev;
@@ -97,9 +98,10 @@ struct phy {
 /**
  * struct phy_provider - represents the phy provider
  * @dev: phy provider device
+ * @children: can be used to override the default (dev->of_node) child node
  * @owner: the module owner having of_xlate
- * @of_xlate: function pointer to obtain phy instance from phy pointer
  * @list: to maintain a linked list of PHY providers
+ * @of_xlate: function pointer to obtain phy instance from phy pointer
  */
 struct phy_provider {
 	struct device		*dev;
@@ -110,6 +112,13 @@ struct phy_provider {
 		struct of_phandle_args *args);
 };
 
+/**
+ * struct phy_lookup - PHY association in list of phys managed by the phy driver
+ * @node: list node
+ * @dev_id: the device of the association
+ * @con_id: connection ID string on device
+ * @phy: the phy of the association
+ */
 struct phy_lookup {
 	struct list_head node;
 	const char *dev_id;

commit 3b3cd24ae61b3bbe9d3cecaff33e7cb3250ce47a
Author: Manu Gautam <mgautam@codeaurora.org>
Date:   Tue Jan 16 16:27:09 2018 +0530

    phy: Add USB speed related PHY modes
    
    Add following USB speed related PHY modes:
    LS (Low Speed), FS (Full Speed), HS (High Speed), SS (Super Speed)
    
    Speed related information is required by some QCOM PHY drivers
    to program PHY monitor resume/remote-wakeup events in suspended
    state. Speed is needed in order to set correct polarity of wakeup
    events for detection. E.g. QUSB2 PHY monitors DP/DM line state
    depending on whether speed is LS or FS/HS to detect resume.
    Similarly QMP USB3 PHY in SS mode should monitor RX terminations
    attach/detach and LFPS events depending on SSPHY is active or not.
    
    Signed-off-by: Manu Gautam <mgautam@codeaurora.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 4f8423a948d5..485469e6fa7f 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -25,7 +25,15 @@ struct phy;
 enum phy_mode {
 	PHY_MODE_INVALID,
 	PHY_MODE_USB_HOST,
+	PHY_MODE_USB_HOST_LS,
+	PHY_MODE_USB_HOST_FS,
+	PHY_MODE_USB_HOST_HS,
+	PHY_MODE_USB_HOST_SS,
 	PHY_MODE_USB_DEVICE,
+	PHY_MODE_USB_DEVICE_LS,
+	PHY_MODE_USB_DEVICE_FS,
+	PHY_MODE_USB_DEVICE_HS,
+	PHY_MODE_USB_DEVICE_SS,
 	PHY_MODE_USB_OTG,
 	PHY_MODE_SGMII,
 	PHY_MODE_10GKR,
@@ -61,6 +69,7 @@ struct phy_ops {
  */
 struct phy_attrs {
 	u32			bus_width;
+	enum phy_mode		mode;
 };
 
 /**
@@ -144,6 +153,10 @@ int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
 int phy_set_mode(struct phy *phy, enum phy_mode mode);
+static inline enum phy_mode phy_get_mode(struct phy *phy)
+{
+	return phy->attrs.mode;
+}
 int phy_reset(struct phy *phy);
 int phy_calibrate(struct phy *phy);
 static inline int phy_get_bus_width(struct phy *phy)
@@ -260,6 +273,11 @@ static inline int phy_set_mode(struct phy *phy, enum phy_mode mode)
 	return -ENOSYS;
 }
 
+static inline enum phy_mode phy_get_mode(struct phy *phy)
+{
+	return PHY_MODE_INVALID;
+}
+
 static inline int phy_reset(struct phy *phy)
 {
 	if (!phy)

commit 36914111e6829be36b23d1109214250b5ee1ee9c
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Mon Oct 9 14:00:50 2017 +0200

    drivers: phy: add calibrate method
    
    Some quirky UDCs (like dwc3 on Exynos) need to have their phys calibrated e.g.
    for using super speed. This patch adds a new phy_calibrate() method.
    When the calibration should be used is dependent on actual chip.
    
    In case of dwc3 on Exynos the calibration must happen after usb_add_hcd()
    (while in host mode), because certain phy parameters like Tx LOS levels
    and boost levels need to be calibrated further post initialization of xHCI
    controller, to get SuperSpeed operations working. But an hcd must be
    prepared first in order to pass it to usb_add_hcd(), so, in particular, dwc3
    registers must be available first, and in order for the latter to happen
    the phys must be initialized. This poses a chicken and egg problem if
    the calibration were to be performed in phy_init(). To break the circular
    dependency a separate method is added which can be called at a desired
    moment after phy intialization.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 194d08174516..4f8423a948d5 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -41,6 +41,7 @@ enum phy_mode {
  * @power_off: powering off the phy
  * @set_mode: set the mode of the phy
  * @reset: resetting the phy
+ * @calibrate: calibrate the phy
  * @owner: the module owner containing the ops
  */
 struct phy_ops {
@@ -50,6 +51,7 @@ struct phy_ops {
 	int	(*power_off)(struct phy *phy);
 	int	(*set_mode)(struct phy *phy, enum phy_mode mode);
 	int	(*reset)(struct phy *phy);
+	int	(*calibrate)(struct phy *phy);
 	struct module *owner;
 };
 
@@ -143,6 +145,7 @@ int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
 int phy_set_mode(struct phy *phy, enum phy_mode mode);
 int phy_reset(struct phy *phy);
+int phy_calibrate(struct phy *phy);
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return phy->attrs.bus_width;
@@ -264,6 +267,13 @@ static inline int phy_reset(struct phy *phy)
 	return -ENOSYS;
 }
 
+static inline int phy_calibrate(struct phy *phy)
+{
+	if (!phy)
+		return 0;
+	return -ENOSYS;
+}
+
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return -ENOSYS;

commit fd3e4c98e6e7a12dc47ef98ee12c0c3c024b5ee9
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Thu Oct 12 11:49:33 2017 +0530

    phy: Add UFS PHY modes
    
    UFS phy has two modes for each High speed generation.
    These modes are identified by two rates of operations -
    Rate A, and Rate B.
    Add these UFS phy modes to phy framework.
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 10888a717860..194d08174516 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -29,6 +29,8 @@ enum phy_mode {
 	PHY_MODE_USB_OTG,
 	PHY_MODE_SGMII,
 	PHY_MODE_10GKR,
+	PHY_MODE_UFS_HS_A,
+	PHY_MODE_UFS_HS_B,
 };
 
 /**

commit 11a6e41c0ee503ffcb971d260bd07dc99b77f13a
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Mon Sep 4 14:53:13 2017 +0200

    phy: Return NULL if the phy is optional
    
    If we're trying to get a handle to an optional phy, then the phy framework
    being disabled shouldn't return an hard error.
    
    Instead, return NULL just like phy_optional_get does when there's no phy
    provided in the DT.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e694d4008c4a..10888a717860 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -291,7 +291,7 @@ static inline struct phy *devm_phy_get(struct device *dev, const char *string)
 static inline struct phy *devm_phy_optional_get(struct device *dev,
 						const char *string)
 {
-	return ERR_PTR(-ENOSYS);
+	return NULL;
 }
 
 static inline struct phy *devm_of_phy_get(struct device *dev,

commit 5c23f2dc8eeb5a6010cb66119d942361bc8ec833
Author: Antoine Tenart <antoine.tenart@free-electrons.com>
Date:   Wed Aug 30 10:29:12 2017 +0200

    phy: add sgmii and 10gkr modes to the phy_mode enum
    
    This patch adds more generic PHY modes to the phy_mode enum, to
    allow configuring generic PHYs to the SGMII and/or the 10GKR mode
    by using the set_mode callback.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 78bb0d7f6b11..e694d4008c4a 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -27,6 +27,8 @@ enum phy_mode {
 	PHY_MODE_USB_HOST,
 	PHY_MODE_USB_DEVICE,
 	PHY_MODE_USB_OTG,
+	PHY_MODE_SGMII,
+	PHY_MODE_10GKR,
 };
 
 /**

commit 98430c7aad6a3fdedcc78a0d6780dabb6580dc38
Author: Randy Li <ayaka@soulik.info>
Date:   Tue Oct 25 22:15:34 2016 +0800

    phy: Add reset callback for not generic phy
    
    Add a dummy function for phy_reset in case the CONFIG_GENERIC_PHY
    is disabled.
    
    Signed-off-by: Randy Li <ayaka@soulik.info>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index ee1bed7dbfc6..78bb0d7f6b11 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -253,6 +253,13 @@ static inline int phy_set_mode(struct phy *phy, enum phy_mode mode)
 	return -ENOSYS;
 }
 
+static inline int phy_reset(struct phy *phy)
+{
+	if (!phy)
+		return 0;
+	return -ENOSYS;
+}
+
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return -ENOSYS;

commit cac18ecb6f44b11bc303d7afbae3887b27938fa4
Author: Randy Li <ayaka@soulik.info>
Date:   Sat Sep 10 02:59:37 2016 +0800

    phy: Add reset callback
    
    The only use for this is for solving a hardware design problem in
    usb of Rockchip RK3288.
    
    Signed-off-by: Randy Li <ayaka@soulik.info>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index f08b67238b58..ee1bed7dbfc6 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -36,6 +36,7 @@ enum phy_mode {
  * @power_on: powering on the phy
  * @power_off: powering off the phy
  * @set_mode: set the mode of the phy
+ * @reset: resetting the phy
  * @owner: the module owner containing the ops
  */
 struct phy_ops {
@@ -44,6 +45,7 @@ struct phy_ops {
 	int	(*power_on)(struct phy *phy);
 	int	(*power_off)(struct phy *phy);
 	int	(*set_mode)(struct phy *phy, enum phy_mode mode);
+	int	(*reset)(struct phy *phy);
 	struct module *owner;
 };
 
@@ -136,6 +138,7 @@ int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
 int phy_set_mode(struct phy *phy, enum phy_mode mode);
+int phy_reset(struct phy *phy);
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return phy->attrs.bus_width;

commit 300eb0139cf27044c67f6005ff17b8434c7843f0
Author: David Lechner <david@lechnology.com>
Date:   Mon May 9 18:39:59 2016 -0500

    phy: Add set_mode callback
    
    The initial use for this is for PHYs that have a mode related to USB OTG.
    There are several SoCs (e.g. TI OMAP and DA8xx) that have a mode setting
    in the USB PHY to override OTG VBUS and ID signals.
    
    Of course, the enum can be expaned in the future to include modes for
    other types of PHYs as well.
    
    Suggested-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: David Lechner <david@lechnology.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index a810f2a18842..f08b67238b58 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -22,12 +22,20 @@
 
 struct phy;
 
+enum phy_mode {
+	PHY_MODE_INVALID,
+	PHY_MODE_USB_HOST,
+	PHY_MODE_USB_DEVICE,
+	PHY_MODE_USB_OTG,
+};
+
 /**
  * struct phy_ops - set of function pointers for performing phy operations
  * @init: operation to be performed for initializing phy
  * @exit: operation to be performed while exiting
  * @power_on: powering on the phy
  * @power_off: powering off the phy
+ * @set_mode: set the mode of the phy
  * @owner: the module owner containing the ops
  */
 struct phy_ops {
@@ -35,6 +43,7 @@ struct phy_ops {
 	int	(*exit)(struct phy *phy);
 	int	(*power_on)(struct phy *phy);
 	int	(*power_off)(struct phy *phy);
+	int	(*set_mode)(struct phy *phy, enum phy_mode mode);
 	struct module *owner;
 };
 
@@ -126,6 +135,7 @@ int phy_init(struct phy *phy);
 int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
+int phy_set_mode(struct phy *phy, enum phy_mode mode);
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return phy->attrs.bus_width;
@@ -233,6 +243,13 @@ static inline int phy_power_off(struct phy *phy)
 	return -ENOSYS;
 }
 
+static inline int phy_set_mode(struct phy *phy, enum phy_mode mode)
+{
+	if (!phy)
+		return 0;
+	return -ENOSYS;
+}
+
 static inline int phy_get_bus_width(struct phy *phy)
 {
 	return -ENOSYS;

commit 1140f7c8994a3a2a0d7c4972509d98b792617d39
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Apr 5 17:17:34 2016 +0200

    phy: core: Allow children node to be overridden
    
    In order to more flexibly support device tree bindings, allow drivers to
    override the container of the child nodes. By default the device node of
    the PHY provider is assumed to be the parent for children, but bindings
    may decide to add additional levels for better organization.
    
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 8cf05e341cff..a810f2a18842 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -77,6 +77,7 @@ struct phy {
  */
 struct phy_provider {
 	struct device		*dev;
+	struct device_node	*children;
 	struct module		*owner;
 	struct list_head	list;
 	struct phy * (*of_xlate)(struct device *dev,
@@ -93,10 +94,16 @@ struct phy_lookup {
 #define	to_phy(a)	(container_of((a), struct phy, dev))
 
 #define	of_phy_provider_register(dev, xlate)	\
-	__of_phy_provider_register((dev), THIS_MODULE, (xlate))
+	__of_phy_provider_register((dev), NULL, THIS_MODULE, (xlate))
 
 #define	devm_of_phy_provider_register(dev, xlate)	\
-	__devm_of_phy_provider_register((dev), THIS_MODULE, (xlate))
+	__devm_of_phy_provider_register((dev), NULL, THIS_MODULE, (xlate))
+
+#define of_phy_provider_register_full(dev, children, xlate) \
+	__of_phy_provider_register(dev, children, THIS_MODULE, xlate)
+
+#define devm_of_phy_provider_register_full(dev, children, xlate) \
+	__devm_of_phy_provider_register(dev, children, THIS_MODULE, xlate)
 
 static inline void phy_set_drvdata(struct phy *phy, void *data)
 {
@@ -147,11 +154,13 @@ struct phy *devm_phy_create(struct device *dev, struct device_node *node,
 void phy_destroy(struct phy *phy);
 void devm_phy_destroy(struct device *dev, struct phy *phy);
 struct phy_provider *__of_phy_provider_register(struct device *dev,
-	struct module *owner, struct phy * (*of_xlate)(struct device *dev,
-	struct of_phandle_args *args));
+	struct device_node *children, struct module *owner,
+	struct phy * (*of_xlate)(struct device *dev,
+				 struct of_phandle_args *args));
 struct phy_provider *__devm_of_phy_provider_register(struct device *dev,
-	struct module *owner, struct phy * (*of_xlate)(struct device *dev,
-	struct of_phandle_args *args));
+	struct device_node *children, struct module *owner,
+	struct phy * (*of_xlate)(struct device *dev,
+				 struct of_phandle_args *args));
 void of_phy_provider_unregister(struct phy_provider *phy_provider);
 void devm_of_phy_provider_unregister(struct device *dev,
 	struct phy_provider *phy_provider);
@@ -312,15 +321,17 @@ static inline void devm_phy_destroy(struct device *dev, struct phy *phy)
 }
 
 static inline struct phy_provider *__of_phy_provider_register(
-	struct device *dev, struct module *owner, struct phy * (*of_xlate)(
-	struct device *dev, struct of_phandle_args *args))
+	struct device *dev, struct device_node *children, struct module *owner,
+	struct phy * (*of_xlate)(struct device *dev,
+				 struct of_phandle_args *args))
 {
 	return ERR_PTR(-ENOSYS);
 }
 
 static inline struct phy_provider *__devm_of_phy_provider_register(struct device
-	*dev, struct module *owner, struct phy * (*of_xlate)(struct device *dev,
-	struct of_phandle_args *args))
+	*dev, struct device_node *children, struct module *owner,
+	struct phy * (*of_xlate)(struct device *dev,
+				 struct of_phandle_args *args))
 {
 	return ERR_PTR(-ENOSYS);
 }

commit 6be109b31ccdb9c98e7be12687171f6602527a5d
Author: Arun Ramamurthy <arun.ramamurthy@broadcom.com>
Date:   Wed Apr 22 16:04:11 2015 -0700

    phy: core: Add devm_of_phy_get_by_index to phy-core
    
    Some generic drivers, such as ehci, may use multiple phys and for such
    drivers referencing phy(s) by name(s) does not make sense. Instead of
    inventing new naming schemes and using custom code to iterate through them,
    such drivers are better of using nameless phy bindings and using this newly
    introduced API to iterate through them.
    
    Signed-off-by: Arun Ramamurthy <arun.ramamurthy@broadcom.com>
    Reviewed-by: Ray Jui <rjui@broadcom.com>
    Reviewed-by: Scott Branden <sbranden@broadcom.com>
    [kishon@ti.com: fix compilation errors]
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index a0197fa1b116..8cf05e341cff 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -133,6 +133,8 @@ struct phy *devm_phy_get(struct device *dev, const char *string);
 struct phy *devm_phy_optional_get(struct device *dev, const char *string);
 struct phy *devm_of_phy_get(struct device *dev, struct device_node *np,
 			    const char *con_id);
+struct phy *devm_of_phy_get_by_index(struct device *dev, struct device_node *np,
+				     int index);
 void phy_put(struct phy *phy);
 void devm_phy_put(struct device *dev, struct phy *phy);
 struct phy *of_phy_get(struct device_node *np, const char *con_id);
@@ -261,6 +263,13 @@ static inline struct phy *devm_of_phy_get(struct device *dev,
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct phy *devm_of_phy_get_by_index(struct device *dev,
+						   struct device_node *np,
+						   int index)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 static inline void phy_put(struct phy *phy)
 {
 }

commit dbc98635e0d42f0e62ea92813df1e0e4c90f8375
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Nov 19 17:28:21 2014 +0200

    phy: remove the old lookup method
    
    The users of the old method are now converted to the new one.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    [ kishon@ti.com : made phy-berlin-usb.c and phy-miphy28lp.c to use the updated
                      devm_phy_create API.]
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 849284e5873f..a0197fa1b116 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -61,7 +61,6 @@ struct phy {
 	struct device		dev;
 	int			id;
 	const struct phy_ops	*ops;
-	struct phy_init_data	*init_data;
 	struct mutex		mutex;
 	int			init_count;
 	int			power_count;
@@ -84,32 +83,6 @@ struct phy_provider {
 		struct of_phandle_args *args);
 };
 
-/**
- * struct phy_consumer - represents the phy consumer
- * @dev_name: the device name of the controller that will use this PHY device
- * @port: name given to the consumer port
- */
-struct phy_consumer {
-	const char *dev_name;
-	const char *port;
-};
-
-/**
- * struct phy_init_data - contains the list of PHY consumers
- * @num_consumers: number of consumers for this PHY device
- * @consumers: list of PHY consumers
- */
-struct phy_init_data {
-	unsigned int num_consumers;
-	struct phy_consumer *consumers;
-};
-
-#define PHY_CONSUMER(_dev_name, _port)				\
-{								\
-	.dev_name	= _dev_name,				\
-	.port		= _port,				\
-}
-
 struct phy_lookup {
 	struct list_head node;
 	const char *dev_id;
@@ -166,10 +139,9 @@ struct phy *of_phy_get(struct device_node *np, const char *con_id);
 struct phy *of_phy_simple_xlate(struct device *dev,
 	struct of_phandle_args *args);
 struct phy *phy_create(struct device *dev, struct device_node *node,
-		       const struct phy_ops *ops,
-		       struct phy_init_data *init_data);
+		       const struct phy_ops *ops);
 struct phy *devm_phy_create(struct device *dev, struct device_node *node,
-	const struct phy_ops *ops, struct phy_init_data *init_data);
+			    const struct phy_ops *ops);
 void phy_destroy(struct phy *phy);
 void devm_phy_destroy(struct device *dev, struct phy *phy);
 struct phy_provider *__of_phy_provider_register(struct device *dev,
@@ -310,16 +282,14 @@ static inline struct phy *of_phy_simple_xlate(struct device *dev,
 
 static inline struct phy *phy_create(struct device *dev,
 				     struct device_node *node,
-				     const struct phy_ops *ops,
-				     struct phy_init_data *init_data)
+				     const struct phy_ops *ops)
 {
 	return ERR_PTR(-ENOSYS);
 }
 
 static inline struct phy *devm_phy_create(struct device *dev,
 					  struct device_node *node,
-					  const struct phy_ops *ops,
-					  struct phy_init_data *init_data)
+					  const struct phy_ops *ops)
 {
 	return ERR_PTR(-ENOSYS);
 }

commit b7bc15b98e843926d01eb03b9c0e196d8ddbadeb
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Nov 19 17:28:18 2014 +0200

    phy: improved lookup method
    
    Separates registration of the phy and the lookup. The method
    is copied from clkdev.c,
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 9fda68324298..849284e5873f 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -110,6 +110,13 @@ struct phy_init_data {
 	.port		= _port,				\
 }
 
+struct phy_lookup {
+	struct list_head node;
+	const char *dev_id;
+	const char *con_id;
+	struct phy *phy;
+};
+
 #define	to_phy(a)	(container_of((a), struct phy, dev))
 
 #define	of_phy_provider_register(dev, xlate)	\
@@ -174,6 +181,8 @@ struct phy_provider *__devm_of_phy_provider_register(struct device *dev,
 void of_phy_provider_unregister(struct phy_provider *phy_provider);
 void devm_of_phy_provider_unregister(struct device *dev,
 	struct phy_provider *phy_provider);
+int phy_create_lookup(struct phy *phy, const char *con_id, const char *dev_id);
+void phy_remove_lookup(struct phy *phy, const char *con_id, const char *dev_id);
 #else
 static inline int phy_pm_runtime_get(struct phy *phy)
 {
@@ -345,6 +354,13 @@ static inline void devm_of_phy_provider_unregister(struct device *dev,
 	struct phy_provider *phy_provider)
 {
 }
+static inline int
+phy_create_lookup(struct phy *phy, const char *con_id, const char *dev_id)
+{
+	return 0;
+}
+static inline void phy_remove_lookup(struct phy *phy, const char *con_id,
+				     const char *dev_id) { }
 #endif
 
 #endif /* __DRIVERS_PHY_H */

commit d451057464a7ea2fe400e56c8a7e004c875f2a84
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Wed Nov 19 17:28:17 2014 +0200

    phy: safer to_phy() macro
    
    This makes to_phy() macro work with other variable names
    besides "dev".
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Tested-by: Vivek Gautam <gautam.vivek@samsung.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 8cb6f815475b..9fda68324298 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -110,7 +110,7 @@ struct phy_init_data {
 	.port		= _port,				\
 }
 
-#define	to_phy(dev)	(container_of((dev), struct phy, dev))
+#define	to_phy(a)	(container_of((a), struct phy, dev))
 
 #define	of_phy_provider_register(dev, xlate)	\
 	__of_phy_provider_register((dev), THIS_MODULE, (xlate))

commit f0ed817638b59aa927f1f7e9564dd8796b18dc4f
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Mon Jul 14 15:55:02 2014 +0530

    phy: core: Let node ptr of PHY point to PHY and not of PHY provider
    
    In case of multi-phy PHY providers, each PHY should be modeled as a sub
    node of the PHY provider. Then each PHY will have a different node pointer
    (node pointer of sub node) than that of PHY provider. Added this provision
    in the PHY core.
    Also fixed all drivers to use the updated API.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 9a8694524742..8cb6f815475b 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -158,9 +158,10 @@ void devm_phy_put(struct device *dev, struct phy *phy);
 struct phy *of_phy_get(struct device_node *np, const char *con_id);
 struct phy *of_phy_simple_xlate(struct device *dev,
 	struct of_phandle_args *args);
-struct phy *phy_create(struct device *dev, const struct phy_ops *ops,
-	struct phy_init_data *init_data);
-struct phy *devm_phy_create(struct device *dev,
+struct phy *phy_create(struct device *dev, struct device_node *node,
+		       const struct phy_ops *ops,
+		       struct phy_init_data *init_data);
+struct phy *devm_phy_create(struct device *dev, struct device_node *node,
 	const struct phy_ops *ops, struct phy_init_data *init_data);
 void phy_destroy(struct phy *phy);
 void devm_phy_destroy(struct device *dev, struct phy *phy);
@@ -299,13 +300,17 @@ static inline struct phy *of_phy_simple_xlate(struct device *dev,
 }
 
 static inline struct phy *phy_create(struct device *dev,
-	const struct phy_ops *ops, struct phy_init_data *init_data)
+				     struct device_node *node,
+				     const struct phy_ops *ops,
+				     struct phy_init_data *init_data)
 {
 	return ERR_PTR(-ENOSYS);
 }
 
 static inline struct phy *devm_phy_create(struct device *dev,
-	const struct phy_ops *ops, struct phy_init_data *init_data)
+					  struct device_node *node,
+					  const struct phy_ops *ops,
+					  struct phy_init_data *init_data)
 {
 	return ERR_PTR(-ENOSYS);
 }

commit 3be88125d85df587085b0be0a5c0e9953eb5ed6b
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Jul 4 12:55:45 2014 +0300

    phy: core: Support regulator supply for PHY power
    
    Some PHYs can be powered by an external power regulator.
    e.g. USB_HS PHY on DRA7 SoC. Make the PHY core support a
    power regulator.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 2760744cb2a7..9a8694524742 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -18,6 +18,7 @@
 #include <linux/of.h>
 #include <linux/device.h>
 #include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
 
 struct phy;
 
@@ -65,6 +66,7 @@ struct phy {
 	int			init_count;
 	int			power_count;
 	struct phy_attrs	attrs;
+	struct regulator	*pwr;
 };
 
 /**

commit 2b97789fa289d531e767d994a77e34ec58f328c4
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Sat Apr 19 08:51:44 2014 +0530

    phy: core: make NULL a valid phy reference if !CONFIG_GENERIC_PHY
    
    This fixes a regression on Keystone 2 platforms caused by patch
    57303488cd37da58263e842de134dc65f7c626d5
    "usb: dwc3: adapt dwc3 core to use Generic PHY Framework" which adds
    optional support of generic phy in DWC3 core.
    
    On Keystone 2 platforms the USB is not working now because
    CONFIG_GENERIC_PHY isn't set and, as result, Generic PHY APIs stubs
    return -ENOSYS always. The log shows:
     dwc3 2690000.dwc3: failed to initialize core
     dwc3: probe of 2690000.dwc3 failed with error -38
    
    Hence, fix it by making NULL a valid phy reference in Generic PHY
    APIs stubs in the same way as it was done by the patch
    04c2facad8fee66c981a51852806d8923336f362 "drivers: phy: Make NULL
    a valid phy reference".
    
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e2f5ca96cddc..2760744cb2a7 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -174,21 +174,29 @@ void devm_of_phy_provider_unregister(struct device *dev,
 #else
 static inline int phy_pm_runtime_get(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_pm_runtime_get_sync(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_pm_runtime_put(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_pm_runtime_put_sync(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
@@ -204,21 +212,29 @@ static inline void phy_pm_runtime_forbid(struct phy *phy)
 
 static inline int phy_init(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_exit(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_power_on(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 
 static inline int phy_power_off(struct phy *phy)
 {
+	if (!phy)
+		return 0;
 	return -ENOSYS;
 }
 

commit b5d682f4eb76c98f2ca5658926df43dd05cf2c37
Author: Kamil Debski <k.debski@samsung.com>
Date:   Thu Mar 6 12:16:47 2014 +0100

    phy: core: Add devm_of_phy_get to phy-core
    
    Adding devm_of_phy_get will allow to get phys by supplying a
    pointer to the struct device_node instead of struct device.
    
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 50c7629b5860..e2f5ca96cddc 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -149,6 +149,8 @@ struct phy *phy_get(struct device *dev, const char *string);
 struct phy *phy_optional_get(struct device *dev, const char *string);
 struct phy *devm_phy_get(struct device *dev, const char *string);
 struct phy *devm_phy_optional_get(struct device *dev, const char *string);
+struct phy *devm_of_phy_get(struct device *dev, struct device_node *np,
+			    const char *con_id);
 void phy_put(struct phy *phy);
 void devm_phy_put(struct device *dev, struct phy *phy);
 struct phy *of_phy_get(struct device_node *np, const char *con_id);
@@ -252,6 +254,13 @@ static inline struct phy *devm_phy_optional_get(struct device *dev,
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct phy *devm_of_phy_get(struct device *dev,
+					  struct device_node *np,
+					  const char *con_id)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 static inline void phy_put(struct phy *phy)
 {
 }

commit 0b3f3b2c777a2f7d20c9826a190ffd5bbd288f8f
Author: Kamil Debski <k.debski@samsung.com>
Date:   Thu Mar 6 12:16:46 2014 +0100

    phy: core: Add an exported of_phy_get function
    
    Previously the of_phy_get function took a struct device * and
    was declared static. It was impossible to call it from
    another driver and thus it was impossible to get phy defined
    for a given node. The old function was renamed to _of_phy_get
    and was left for internal use. of_phy_get function was added
    and it was exported. The function enables to get a phy for
    a given device tree node.
    
    Signed-off-by: Kamil Debski <k.debski@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 3f83459dbb20..50c7629b5860 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -151,6 +151,7 @@ struct phy *devm_phy_get(struct device *dev, const char *string);
 struct phy *devm_phy_optional_get(struct device *dev, const char *string);
 void phy_put(struct phy *phy);
 void devm_phy_put(struct device *dev, struct phy *phy);
+struct phy *of_phy_get(struct device_node *np, const char *con_id);
 struct phy *of_phy_simple_xlate(struct device *dev,
 	struct of_phandle_args *args);
 struct phy *phy_create(struct device *dev, const struct phy_ops *ops,
@@ -259,6 +260,11 @@ static inline void devm_phy_put(struct device *dev, struct phy *phy)
 {
 }
 
+static inline struct phy *of_phy_get(struct device_node *np, const char *con_id)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 static inline struct phy *of_phy_simple_xlate(struct device *dev,
 	struct of_phandle_args *args)
 {

commit 788a4d56ff378bff0b8e685d03a962b36903a149
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Feb 4 18:33:12 2014 +0100

    drivers: phy: Add support for optional phys
    
    Add devm_phy_optional_get and phy_optional_get, which should be used
    when the phy is optional. They does not return an error when the phy
    does not exist, rather they returns NULL, which is considered as a valid
    phy, but results in NOPs when used with the consumer API.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e273e5ac19c9..3f83459dbb20 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -146,7 +146,9 @@ static inline void phy_set_bus_width(struct phy *phy, int bus_width)
 	phy->attrs.bus_width = bus_width;
 }
 struct phy *phy_get(struct device *dev, const char *string);
+struct phy *phy_optional_get(struct device *dev, const char *string);
 struct phy *devm_phy_get(struct device *dev, const char *string);
+struct phy *devm_phy_optional_get(struct device *dev, const char *string);
 void phy_put(struct phy *phy);
 void devm_phy_put(struct device *dev, struct phy *phy);
 struct phy *of_phy_simple_xlate(struct device *dev,
@@ -232,11 +234,23 @@ static inline struct phy *phy_get(struct device *dev, const char *string)
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct phy *phy_optional_get(struct device *dev,
+					   const char *string)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 static inline struct phy *devm_phy_get(struct device *dev, const char *string)
 {
 	return ERR_PTR(-ENOSYS);
 }
 
+static inline struct phy *devm_phy_optional_get(struct device *dev,
+						const char *string)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
 static inline void phy_put(struct phy *phy)
 {
 }

commit 8feed347d33bb630d426b9f2ed88cbdf9795f624
Author: Matt Porter <mporter@linaro.org>
Date:   Thu Dec 19 09:23:02 2013 -0500

    phy: add phy_get_bus_width()/phy_set_bus_width() calls
    
    This adds a pair of APIs that allows the generic PHY subsystem to
    provide information on the PHY bus width. The PHY provider driver may
    use phy_set_bus_width() to set the bus width that the PHY supports.
    The controller driver may then use phy_get_bus_width() to fetch the
    PHY bus width in order to properly configure the controller.
    
    Signed-off-by: Matt Porter <mporter@linaro.org>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 6d722695e027..e273e5ac19c9 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -37,6 +37,14 @@ struct phy_ops {
 	struct module *owner;
 };
 
+/**
+ * struct phy_attrs - represents phy attributes
+ * @bus_width: Data path width implemented by PHY
+ */
+struct phy_attrs {
+	u32			bus_width;
+};
+
 /**
  * struct phy - represents the phy device
  * @dev: phy device
@@ -46,6 +54,7 @@ struct phy_ops {
  * @mutex: mutex to protect phy_ops
  * @init_count: used to protect when the PHY is used by multiple consumers
  * @power_count: used to protect when the PHY is used by multiple consumers
+ * @phy_attrs: used to specify PHY specific attributes
  */
 struct phy {
 	struct device		dev;
@@ -55,6 +64,7 @@ struct phy {
 	struct mutex		mutex;
 	int			init_count;
 	int			power_count;
+	struct phy_attrs	attrs;
 };
 
 /**
@@ -127,6 +137,14 @@ int phy_init(struct phy *phy);
 int phy_exit(struct phy *phy);
 int phy_power_on(struct phy *phy);
 int phy_power_off(struct phy *phy);
+static inline int phy_get_bus_width(struct phy *phy)
+{
+	return phy->attrs.bus_width;
+}
+static inline void phy_set_bus_width(struct phy *phy, int bus_width)
+{
+	phy->attrs.bus_width = bus_width;
+}
 struct phy *phy_get(struct device *dev, const char *string);
 struct phy *devm_phy_get(struct device *dev, const char *string);
 void phy_put(struct phy *phy);
@@ -199,6 +217,16 @@ static inline int phy_power_off(struct phy *phy)
 	return -ENOSYS;
 }
 
+static inline int phy_get_bus_width(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline void phy_set_bus_width(struct phy *phy, int bus_width)
+{
+	return;
+}
+
 static inline struct phy *phy_get(struct device *dev, const char *string)
 {
 	return ERR_PTR(-ENOSYS);

commit ff764963479a1b18721ab96e531404c50fefe8b1
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Sep 27 11:53:25 2013 +0530

    drivers: phy: add generic PHY framework
    
    The PHY framework provides a set of APIs for the PHY drivers to
    create/destroy a PHY and APIs for the PHY users to obtain a reference to the
    PHY with or without using phandle. For dt-boot, the PHY drivers should
    also register *PHY provider* with the framework.
    
    PHY drivers should create the PHY by passing id and ops like init, exit,
    power_on and power_off. This framework is also pm runtime enabled.
    
    The documentation for the generic PHY framework is added in
    Documentation/phy.txt and the documentation for dt binding can be found at
    Documentation/devicetree/bindings/phy/phy-bindings.txt
    
    Cc: Tomasz Figa <t.figa@samsung.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
new file mode 100644
index 000000000000..6d722695e027
--- /dev/null
+++ b/include/linux/phy/phy.h
@@ -0,0 +1,270 @@
+/*
+ * phy.h -- generic phy header file
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * Author: Kishon Vijay Abraham I <kishon@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __DRIVERS_PHY_H
+#define __DRIVERS_PHY_H
+
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+
+struct phy;
+
+/**
+ * struct phy_ops - set of function pointers for performing phy operations
+ * @init: operation to be performed for initializing phy
+ * @exit: operation to be performed while exiting
+ * @power_on: powering on the phy
+ * @power_off: powering off the phy
+ * @owner: the module owner containing the ops
+ */
+struct phy_ops {
+	int	(*init)(struct phy *phy);
+	int	(*exit)(struct phy *phy);
+	int	(*power_on)(struct phy *phy);
+	int	(*power_off)(struct phy *phy);
+	struct module *owner;
+};
+
+/**
+ * struct phy - represents the phy device
+ * @dev: phy device
+ * @id: id of the phy device
+ * @ops: function pointers for performing phy operations
+ * @init_data: list of PHY consumers (non-dt only)
+ * @mutex: mutex to protect phy_ops
+ * @init_count: used to protect when the PHY is used by multiple consumers
+ * @power_count: used to protect when the PHY is used by multiple consumers
+ */
+struct phy {
+	struct device		dev;
+	int			id;
+	const struct phy_ops	*ops;
+	struct phy_init_data	*init_data;
+	struct mutex		mutex;
+	int			init_count;
+	int			power_count;
+};
+
+/**
+ * struct phy_provider - represents the phy provider
+ * @dev: phy provider device
+ * @owner: the module owner having of_xlate
+ * @of_xlate: function pointer to obtain phy instance from phy pointer
+ * @list: to maintain a linked list of PHY providers
+ */
+struct phy_provider {
+	struct device		*dev;
+	struct module		*owner;
+	struct list_head	list;
+	struct phy * (*of_xlate)(struct device *dev,
+		struct of_phandle_args *args);
+};
+
+/**
+ * struct phy_consumer - represents the phy consumer
+ * @dev_name: the device name of the controller that will use this PHY device
+ * @port: name given to the consumer port
+ */
+struct phy_consumer {
+	const char *dev_name;
+	const char *port;
+};
+
+/**
+ * struct phy_init_data - contains the list of PHY consumers
+ * @num_consumers: number of consumers for this PHY device
+ * @consumers: list of PHY consumers
+ */
+struct phy_init_data {
+	unsigned int num_consumers;
+	struct phy_consumer *consumers;
+};
+
+#define PHY_CONSUMER(_dev_name, _port)				\
+{								\
+	.dev_name	= _dev_name,				\
+	.port		= _port,				\
+}
+
+#define	to_phy(dev)	(container_of((dev), struct phy, dev))
+
+#define	of_phy_provider_register(dev, xlate)	\
+	__of_phy_provider_register((dev), THIS_MODULE, (xlate))
+
+#define	devm_of_phy_provider_register(dev, xlate)	\
+	__devm_of_phy_provider_register((dev), THIS_MODULE, (xlate))
+
+static inline void phy_set_drvdata(struct phy *phy, void *data)
+{
+	dev_set_drvdata(&phy->dev, data);
+}
+
+static inline void *phy_get_drvdata(struct phy *phy)
+{
+	return dev_get_drvdata(&phy->dev);
+}
+
+#if IS_ENABLED(CONFIG_GENERIC_PHY)
+int phy_pm_runtime_get(struct phy *phy);
+int phy_pm_runtime_get_sync(struct phy *phy);
+int phy_pm_runtime_put(struct phy *phy);
+int phy_pm_runtime_put_sync(struct phy *phy);
+void phy_pm_runtime_allow(struct phy *phy);
+void phy_pm_runtime_forbid(struct phy *phy);
+int phy_init(struct phy *phy);
+int phy_exit(struct phy *phy);
+int phy_power_on(struct phy *phy);
+int phy_power_off(struct phy *phy);
+struct phy *phy_get(struct device *dev, const char *string);
+struct phy *devm_phy_get(struct device *dev, const char *string);
+void phy_put(struct phy *phy);
+void devm_phy_put(struct device *dev, struct phy *phy);
+struct phy *of_phy_simple_xlate(struct device *dev,
+	struct of_phandle_args *args);
+struct phy *phy_create(struct device *dev, const struct phy_ops *ops,
+	struct phy_init_data *init_data);
+struct phy *devm_phy_create(struct device *dev,
+	const struct phy_ops *ops, struct phy_init_data *init_data);
+void phy_destroy(struct phy *phy);
+void devm_phy_destroy(struct device *dev, struct phy *phy);
+struct phy_provider *__of_phy_provider_register(struct device *dev,
+	struct module *owner, struct phy * (*of_xlate)(struct device *dev,
+	struct of_phandle_args *args));
+struct phy_provider *__devm_of_phy_provider_register(struct device *dev,
+	struct module *owner, struct phy * (*of_xlate)(struct device *dev,
+	struct of_phandle_args *args));
+void of_phy_provider_unregister(struct phy_provider *phy_provider);
+void devm_of_phy_provider_unregister(struct device *dev,
+	struct phy_provider *phy_provider);
+#else
+static inline int phy_pm_runtime_get(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_pm_runtime_get_sync(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_pm_runtime_put(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_pm_runtime_put_sync(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline void phy_pm_runtime_allow(struct phy *phy)
+{
+	return;
+}
+
+static inline void phy_pm_runtime_forbid(struct phy *phy)
+{
+	return;
+}
+
+static inline int phy_init(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_exit(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_power_on(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline int phy_power_off(struct phy *phy)
+{
+	return -ENOSYS;
+}
+
+static inline struct phy *phy_get(struct device *dev, const char *string)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline struct phy *devm_phy_get(struct device *dev, const char *string)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline void phy_put(struct phy *phy)
+{
+}
+
+static inline void devm_phy_put(struct device *dev, struct phy *phy)
+{
+}
+
+static inline struct phy *of_phy_simple_xlate(struct device *dev,
+	struct of_phandle_args *args)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline struct phy *phy_create(struct device *dev,
+	const struct phy_ops *ops, struct phy_init_data *init_data)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline struct phy *devm_phy_create(struct device *dev,
+	const struct phy_ops *ops, struct phy_init_data *init_data)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline void phy_destroy(struct phy *phy)
+{
+}
+
+static inline void devm_phy_destroy(struct device *dev, struct phy *phy)
+{
+}
+
+static inline struct phy_provider *__of_phy_provider_register(
+	struct device *dev, struct module *owner, struct phy * (*of_xlate)(
+	struct device *dev, struct of_phandle_args *args))
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline struct phy_provider *__devm_of_phy_provider_register(struct device
+	*dev, struct module *owner, struct phy * (*of_xlate)(struct device *dev,
+	struct of_phandle_args *args))
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline void of_phy_provider_unregister(struct phy_provider *phy_provider)
+{
+}
+
+static inline void devm_of_phy_provider_unregister(struct device *dev,
+	struct phy_provider *phy_provider)
+{
+}
+#endif
+
+#endif /* __DRIVERS_PHY_H */
