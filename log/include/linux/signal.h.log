commit fa4751f454e6b51ef93babfd8b6c8b43a65c9db2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue May 5 12:12:54 2020 +0200

    binfmt_elf: remove the set_fs in fill_siginfo_note
    
    The code in binfmt_elf.c is differnt from the rest of the code that
    processes siginfo, as it sends siginfo from a kernel buffer to a file
    rather than from kernel memory to userspace buffers.  To remove it's
    use of set_fs the code needs some different siginfo helpers.
    
    Add the helper copy_siginfo_to_external to copy from the kernel's
    internal siginfo layout to a buffer in the siginfo layout that
    userspace expects.
    
    Modify fill_siginfo_note to use copy_siginfo_to_external instead of
    set_fs and copy_siginfo_to_user.
    
    Update compat_binfmt_elf.c to use the previously added
    copy_siginfo_to_external32 to handle the compat case.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 05bacd2ab135..6bb1a3f0258c 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -24,6 +24,14 @@ static inline void clear_siginfo(kernel_siginfo_t *info)
 
 #define SI_EXPANSION_SIZE (sizeof(struct siginfo) - sizeof(struct kernel_siginfo))
 
+static inline void copy_siginfo_to_external(siginfo_t *to,
+					    const kernel_siginfo_t *from)
+{
+	memcpy(to, from, sizeof(*from));
+	memset(((char *)to) + sizeof(struct kernel_siginfo), 0,
+		SI_EXPANSION_SIZE);
+}
+
 int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from);
 int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from);
 

commit 119cd59fcfbe70fb3fcab4e64cd232bcc3807585
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 15 19:54:56 2020 -0500

    x86: get rid of put_user_try in __setup_rt_frame() (both 32bit and 64bit)
    
    Straightforward, except for save_altstack_ex() stuck in those.
    Replace that thing with an analogue that would use unsafe_put_user()
    instead of put_user_ex() (called compat_save_altstack()) and be done
    with that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 1a5f88316b08..05bacd2ab135 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -444,12 +444,12 @@ void signals_init(void);
 int restore_altstack(const stack_t __user *);
 int __save_altstack(stack_t __user *, unsigned long);
 
-#define save_altstack_ex(uss, sp) do { \
+#define unsafe_save_altstack(uss, sp, label) do { \
 	stack_t __user *__uss = uss; \
 	struct task_struct *t = current; \
-	put_user_ex((void __user *)t->sas_ss_sp, &__uss->ss_sp); \
-	put_user_ex(t->sas_ss_flags, &__uss->ss_flags); \
-	put_user_ex(t->sas_ss_size, &__uss->ss_size); \
+	unsafe_put_user((void __user *)t->sas_ss_sp, &__uss->ss_sp, label); \
+	unsafe_put_user(t->sas_ss_flags, &__uss->ss_flags, label); \
+	unsafe_put_user(t->sas_ss_size, &__uss->ss_size, label); \
 	if (t->sas_ss_flags & SS_AUTODISARM) \
 		sas_ss_reset(t); \
 } while (0);

commit 33da8e7c814f77310250bb54a9db36a44c5de784
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Aug 16 12:33:54 2019 -0500

    signal: Allow cifs and drbd to receive their terminating signals
    
    My recent to change to only use force_sig for a synchronous events
    wound up breaking signal reception cifs and drbd.  I had overlooked
    the fact that by default kthreads start out with all signals set to
    SIG_IGN.  So a change I thought was safe turned out to have made it
    impossible for those kernel thread to catch their signals.
    
    Reverting the work on force_sig is a bad idea because what the code
    was doing was very much a misuse of force_sig.  As the way force_sig
    ultimately allowed the signal to happen was to change the signal
    handler to SIG_DFL.  Which after the first signal will allow userspace
    to send signals to these kernel threads.  At least for
    wake_ack_receiver in drbd that does not appear actively wrong.
    
    So correct this problem by adding allow_kernel_signal that will allow
    signals whose siginfo reports they were sent by the kernel through,
    but will not allow userspace generated signals, and update cifs and
    drbd to call allow_kernel_signal in an appropriate place so that their
    thread can receive this signal.
    
    Fixing things this way ensures that userspace won't be able to send
    signals and cause problems, that it is clear which signals the
    threads are expecting to receive, and it guarantees that nothing
    else in the system will be affected.
    
    This change was partly inspired by similar cifs and drbd patches that
    added allow_signal.
    
    Reported-by: ronnie sahlberg <ronniesahlberg@gmail.com>
    Reported-by: Christoph Böhmwalder <christoph.boehmwalder@linbit.com>
    Tested-by: Christoph Böhmwalder <christoph.boehmwalder@linbit.com>
    Cc: Steve French <smfrench@gmail.com>
    Cc: Philipp Reisner <philipp.reisner@linbit.com>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Fixes: 247bc9470b1e ("cifs: fix rmmod regression in cifs.ko caused by force_sig changes")
    Fixes: 72abe3bcf091 ("signal/cifs: Fix cifs_put_tcp_session to call send_sig instead of force_sig")
    Fixes: fee109901f39 ("signal/drbd: Use send_sig not force_sig")
    Fixes: 3cf5d076fb4d ("signal: Remove task parameter from force_sig")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index b5d99482d3fe..1a5f88316b08 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -282,6 +282,9 @@ extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 extern void kernel_sigaction(int, __sighandler_t);
 
+#define SIG_KTHREAD ((__force __sighandler_t)2)
+#define SIG_KTHREAD_KERNEL ((__force __sighandler_t)3)
+
 static inline void allow_signal(int sig)
 {
 	/*
@@ -289,7 +292,17 @@ static inline void allow_signal(int sig)
 	 * know it'll be handled, so that they don't get converted to
 	 * SIGKILL or just silently dropped.
 	 */
-	kernel_sigaction(sig, (__force __sighandler_t)2);
+	kernel_sigaction(sig, SIG_KTHREAD);
+}
+
+static inline void allow_kernel_signal(int sig)
+{
+	/*
+	 * Kernel threads handle their own signals. Let the signal code
+	 * know signals sent by the kernel will be handled, so that they
+	 * don't get silently dropped.
+	 */
+	kernel_sigaction(sig, SIG_KTHREAD_KERNEL);
 }
 
 static inline void disallow_signal(int sig)

commit b772434be0891ed1081a08ae7cfd4666728f8e82
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Jul 16 16:29:53 2019 -0700

    signal: simplify set_user_sigmask/restore_user_sigmask
    
    task->saved_sigmask and ->restore_sigmask are only used in the ret-from-
    syscall paths.  This means that set_user_sigmask() can save ->blocked in
    ->saved_sigmask and do set_restore_sigmask() to indicate that ->blocked
    was modified.
    
    This way the callers do not need 2 sigset_t's passed to set/restore and
    restore_user_sigmask() renamed to restore_saved_sigmask_unless() turns
    into the trivial helper which just calls restore_saved_sigmask().
    
    Link: http://lkml.kernel.org/r/20190606113206.GA9464@redhat.com
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Eric Wong <e@80x24.org>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: David Laight <David.Laight@aculab.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 78c2bb376954..b5d99482d3fe 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -273,10 +273,6 @@ extern int group_send_sig_info(int sig, struct kernel_siginfo *info,
 			       struct task_struct *p, enum pid_type type);
 extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
-extern int set_user_sigmask(const sigset_t __user *usigmask, sigset_t *set,
-	sigset_t *oldset, size_t sigsetsize);
-extern void restore_user_sigmask(const void __user *usigmask,
-				 sigset_t *sigsaved, bool interrupted);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;

commit 97abc889ee296faf95ca0e978340fb7b942a3e32
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Jun 28 12:06:50 2019 -0700

    signal: remove the wrong signal_pending() check in restore_user_sigmask()
    
    This is the minimal fix for stable, I'll send cleanups later.
    
    Commit 854a6ed56839 ("signal: Add restore_user_sigmask()") introduced
    the visible change which breaks user-space: a signal temporary unblocked
    by set_user_sigmask() can be delivered even if the caller returns
    success or timeout.
    
    Change restore_user_sigmask() to accept the additional "interrupted"
    argument which should be used instead of signal_pending() check, and
    update the callers.
    
    Eric said:
    
    : For clarity.  I don't think this is required by posix, or fundamentally to
    : remove the races in select.  It is what linux has always done and we have
    : applications who care so I agree this fix is needed.
    :
    : Further in any case where the semantic change that this patch rolls back
    : (aka where allowing a signal to be delivered and the select like call to
    : complete) would be advantage we can do as well if not better by using
    : signalfd.
    :
    : Michael is there any chance we can get this guarantee of the linux
    : implementation of pselect and friends clearly documented.  The guarantee
    : that if the system call completes successfully we are guaranteed that no
    : signal that is unblocked by using sigmask will be delivered?
    
    Link: http://lkml.kernel.org/r/20190604134117.GA29963@redhat.com
    Fixes: 854a6ed56839a40f6b5d02a2962f48841482eec4 ("signal: Add restore_user_sigmask()")
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reported-by: Eric Wong <e@80x24.org>
    Tested-by: Eric Wong <e@80x24.org>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Cc: <stable@vger.kernel.org>    [5.0+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 9702016734b1..78c2bb376954 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -276,7 +276,7 @@ extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern int set_user_sigmask(const sigset_t __user *usigmask, sigset_t *set,
 	sigset_t *oldset, size_t sigsetsize);
 extern void restore_user_sigmask(const void __user *usigmask,
-				 sigset_t *sigsaved);
+				 sigset_t *sigsaved, bool interrupted);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;

commit ee17e5d6201c66492a0e8053190fca2ed2b8457d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jan 12 11:48:20 2019 -0600

    signal: Make siginmask safe when passed a signal of 0
    
    Eric Biggers reported:
    > The following commit, which went into v4.20, introduced undefined behavior when
    > sys_rt_sigqueueinfo() is called with sig=0:
    >
    > commit 4ce5f9c9e7546915c559ffae594e6d73f918db00
    > Author: Eric W. Biederman <ebiederm@xmission.com>
    > Date:   Tue Sep 25 12:59:31 2018 +0200
    >
    >     signal: Use a smaller struct siginfo in the kernel
    >
    > In sig_specific_sicodes(), used from known_siginfo_layout(), the expression
    > '1ULL << ((sig)-1)' is undefined as it evaluates to 1ULL << 4294967295.
    >
    > Reproducer:
    >
    > #include <signal.h>
    > #include <sys/syscall.h>
    > #include <unistd.h>
    >
    > int main(void)
    > {
    >       siginfo_t si = { .si_code = 1 };
    >       syscall(__NR_rt_sigqueueinfo, 0, 0, &si);
    > }
    >
    > UBSAN report for v5.0-rc1:
    >
    > UBSAN: Undefined behaviour in kernel/signal.c:2946:7
    > shift exponent 4294967295 is too large for 64-bit type 'long unsigned int'
    > CPU: 2 PID: 346 Comm: syz_signal Not tainted 5.0.0-rc1 #25
    > Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
    > Call Trace:
    >  __dump_stack lib/dump_stack.c:77 [inline]
    >  dump_stack+0x70/0xa5 lib/dump_stack.c:113
    >  ubsan_epilogue+0xd/0x40 lib/ubsan.c:159
    >  __ubsan_handle_shift_out_of_bounds+0x12c/0x170 lib/ubsan.c:425
    >  known_siginfo_layout+0xae/0xe0 kernel/signal.c:2946
    >  post_copy_siginfo_from_user kernel/signal.c:3009 [inline]
    >  __copy_siginfo_from_user+0x35/0x60 kernel/signal.c:3035
    >  __do_sys_rt_sigqueueinfo kernel/signal.c:3553 [inline]
    >  __se_sys_rt_sigqueueinfo kernel/signal.c:3549 [inline]
    >  __x64_sys_rt_sigqueueinfo+0x31/0x70 kernel/signal.c:3549
    >  do_syscall_64+0x4c/0x1b0 arch/x86/entry/common.c:290
    >  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    > RIP: 0033:0x433639
    > Code: c4 18 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b 27 00 00 c3 66 2e 0f 1f 84 00 00 00 00
    > RSP: 002b:00007fffcb289fc8 EFLAGS: 00000246 ORIG_RAX: 0000000000000081
    > RAX: ffffffffffffffda RBX: 00000000004002e0 RCX: 0000000000433639
    > RDX: 00007fffcb289fd0 RSI: 0000000000000000 RDI: 0000000000000000
    > RBP: 00000000006b2018 R08: 000000000000004d R09: 0000000000000000
    > R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000401560
    > R13: 00000000004015f0 R14: 0000000000000000 R15: 0000000000000000
    
    I have looked at the other callers of siginmask and they all appear to
    in locations where sig can not be zero.
    
    I have looked at the code generation of adding an extra test against
    zero and gcc was able with a simple decrement instruction to combine
    the two tests together. So the at most adding this test cost a single
    cpu cycle.  In practice that decrement instruction was already present
    as part of the mask comparison, so the only change was when the
    instruction was executed.
    
    So given that it is cheap, and obviously correct to update siginmask
    to verify the signal is not zero.  Fix this issue there to avoid any
    future problems.
    
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Fixes: 4ce5f9c9e754 ("signal: Use a smaller struct siginfo in the kernel")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index cc7e2c1cd444..9702016734b1 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -392,7 +392,7 @@ extern bool unhandled_signal(struct task_struct *tsk, int sig);
 #endif
 
 #define siginmask(sig, mask) \
-	((sig) < SIGRTMIN && (rt_sigmask(sig) & (mask)))
+	((sig) > 0 && (sig) < SIGRTMIN && (rt_sigmask(sig) & (mask)))
 
 #define SIG_KERNEL_ONLY_MASK (\
 	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))

commit 854a6ed56839a40f6b5d02a2962f48841482eec4
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 19 21:41:05 2018 -0700

    signal: Add restore_user_sigmask()
    
    Refactor the logic to restore the sigmask before the syscall
    returns into an api.
    This is useful for versions of syscalls that pass in the
    sigmask and expect the current->sigmask to be changed during
    the execution and restored after the execution of the syscall.
    
    With the advent of new y2038 syscalls in the subsequent patches,
    we add two more new versions of the syscalls (for pselect, ppoll
    and io_pgetevents) in addition to the existing native and compat
    versions. Adding such an api reduces the logic that would need to
    be replicated otherwise.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ce14b951befb..cc7e2c1cd444 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -275,6 +275,8 @@ extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struc
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern int set_user_sigmask(const sigset_t __user *usigmask, sigset_t *set,
 	sigset_t *oldset, size_t sigsetsize);
+extern void restore_user_sigmask(const void __user *usigmask,
+				 sigset_t *sigsaved);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;

commit ded653ccbec0335a78fa7a7aff3ec9870349fafb
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 19 21:41:04 2018 -0700

    signal: Add set_user_sigmask()
    
    Refactor reading sigset from userspace and updating sigmask
    into an api.
    
    This is useful for versions of syscalls that pass in the
    sigmask and expect the current->sigmask to be changed during,
    and restored after, the execution of the syscall.
    
    With the advent of new y2038 syscalls in the subsequent patches,
    we add two more new versions of the syscalls (for pselect, ppoll,
    and io_pgetevents) in addition to the existing native and compat
    versions. Adding such an api reduces the logic that would need to
    be replicated otherwise.
    
    Note that the calls to sigprocmask() ignored the return value
    from the api as the function only returns an error on an invalid
    first argument that is hardcoded at these call sites.
    The updated logic uses set_current_blocked() instead.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index f428e86f4800..ce14b951befb 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -273,6 +273,8 @@ extern int group_send_sig_info(int sig, struct kernel_siginfo *info,
 			       struct task_struct *p, enum pid_type type);
 extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
+extern int set_user_sigmask(const sigset_t __user *usigmask, sigset_t *set,
+	sigset_t *oldset, size_t sigsetsize);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;

commit 3819ddec1f8c8a5daf215bec4067f8fd1dc40d6d
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Oct 30 15:07:10 2018 -0700

    include/linux/signal.h: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
    we are expecting to fall through.
    
    Link: http://lkml.kernel.org/r/20181013114847.GA3160@embeddedor.com
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 200ed96a05af..f428e86f4800 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -129,9 +129,11 @@ static inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) \
 		b3 = b->sig[3]; b2 = b->sig[2];				\
 		r->sig[3] = op(a3, b3);					\
 		r->sig[2] = op(a2, b2);					\
+		/* fall through */					\
 	case 2:								\
 		a1 = a->sig[1]; b1 = b->sig[1];				\
 		r->sig[1] = op(a1, b1);					\
+		/* fall through */					\
 	case 1:								\
 		a0 = a->sig[0]; b0 = b->sig[0];				\
 		r->sig[0] = op(a0, b0);					\
@@ -161,7 +163,9 @@ static inline void name(sigset_t *set)					\
 	switch (_NSIG_WORDS) {						\
 	case 4:	set->sig[3] = op(set->sig[3]);				\
 		set->sig[2] = op(set->sig[2]);				\
+		/* fall through */					\
 	case 2:	set->sig[1] = op(set->sig[1]);				\
+		/* fall through */					\
 	case 1:	set->sig[0] = op(set->sig[0]);				\
 		    break;						\
 	default:							\
@@ -182,6 +186,7 @@ static inline void sigemptyset(sigset_t *set)
 		memset(set, 0, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = 0;
+		/* fall through */
 	case 1:	set->sig[0] = 0;
 		break;
 	}
@@ -194,6 +199,7 @@ static inline void sigfillset(sigset_t *set)
 		memset(set, -1, sizeof(sigset_t));
 		break;
 	case 2: set->sig[1] = -1;
+		/* fall through */
 	case 1:	set->sig[0] = -1;
 		break;
 	}

commit a36700589b85443e28170be59fa11c8a104130a5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 10 20:29:44 2018 -0500

    signal: Guard against negative signal numbers in copy_siginfo_from_user32
    
    While fixing an out of bounds array access in known_siginfo_layout
    reported by the kernel test robot it became apparent that the same bug
    exists in siginfo_layout and affects copy_siginfo_from_user32.
    
    The straight forward fix that makes guards against making this mistake
    in the future and should keep the code size small is to just take an
    unsigned signal number instead of a signed signal number, as I did to
    fix known_siginfo_layout.
    
    Cc: stable@vger.kernel.org
    Fixes: cc731525f26a ("signal: Remove kernel interal si_code magic")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 706a499d1eb1..200ed96a05af 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -40,7 +40,7 @@ enum siginfo_layout {
 	SIL_SYS,
 };
 
-enum siginfo_layout siginfo_layout(int sig, int si_code);
+enum siginfo_layout siginfo_layout(unsigned sig, int si_code);
 
 /*
  * Define some primitives to manipulate sigset_t.

commit 4ce5f9c9e7546915c559ffae594e6d73f918db00
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 25 12:59:31 2018 +0200

    signal: Use a smaller struct siginfo in the kernel
    
    We reserve 128 bytes for struct siginfo but only use about 48 bytes on
    64bit and 32 bytes on 32bit.  Someday we might use more but it is unlikely
    to be anytime soon.
    
    Userspace seems content with just enough bytes of siginfo to implement
    sigqueue.  Or in the case of checkpoint/restart reinjecting signals
    the kernel has sent.
    
    Reducing the stack footprint and the work to copy siginfo around from
    2 cachelines to 1 cachelines seems worth doing even if I don't have
    benchmarks to show a performance difference.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 70031b10b918..706a499d1eb1 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -22,6 +22,8 @@ static inline void clear_siginfo(kernel_siginfo_t *info)
 	memset(info, 0, sizeof(*info));
 }
 
+#define SI_EXPANSION_SIZE (sizeof(struct siginfo) - sizeof(struct kernel_siginfo))
+
 int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from);
 int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from);
 

commit ae7795bc6187a15ec51cf258abae656a625f9980
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 25 11:27:20 2018 +0200

    signal: Distinguish between kernel_siginfo and siginfo
    
    Linus recently observed that if we did not worry about the padding
    member in struct siginfo it is only about 48 bytes, and 48 bytes is
    much nicer than 128 bytes for allocating on the stack and copying
    around in the kernel.
    
    The obvious thing of only adding the padding when userspace is
    including siginfo.h won't work as there are sigframe definitions in
    the kernel that embed struct siginfo.
    
    So split siginfo in two; kernel_siginfo and siginfo.  Keeping the
    traditional name for the userspace definition.  While the version that
    is used internally to the kernel and ultimately will not be padded to
    128 bytes is called kernel_siginfo.
    
    The definition of struct kernel_siginfo I have put in include/signal_types.h
    
    A set of buildtime checks has been added to verify the two structures have
    the same field offsets.
    
    To make it easy to verify the change kernel_siginfo retains the same
    size as siginfo.  The reduction in size comes in a following change.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index de94c159bfb0..70031b10b918 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -11,18 +11,19 @@ struct task_struct;
 /* for sysctl */
 extern int print_fatal_signals;
 
-static inline void copy_siginfo(struct siginfo *to, const struct siginfo *from)
+static inline void copy_siginfo(kernel_siginfo_t *to,
+				const kernel_siginfo_t *from)
 {
 	memcpy(to, from, sizeof(*to));
 }
 
-static inline void clear_siginfo(struct siginfo *info)
+static inline void clear_siginfo(kernel_siginfo_t *info)
 {
 	memset(info, 0, sizeof(*info));
 }
 
-int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
-int copy_siginfo_from_user(struct siginfo *to, const struct siginfo __user *from);
+int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from);
+int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from);
 
 enum siginfo_layout {
 	SIL_KILL,
@@ -258,11 +259,11 @@ struct pt_regs;
 enum pid_type;
 
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
-extern int do_send_sig_info(int sig, struct siginfo *info,
+extern int do_send_sig_info(int sig, struct kernel_siginfo *info,
 				struct task_struct *p, enum pid_type type);
-extern int group_send_sig_info(int sig, struct siginfo *info,
+extern int group_send_sig_info(int sig, struct kernel_siginfo *info,
 			       struct task_struct *p, enum pid_type type);
-extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+extern int __group_send_sig_info(int, struct kernel_siginfo *, struct task_struct *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);

commit 4cd2e0e70af6897ca2247fa1ffb1553ca16b4903
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Apr 18 17:30:19 2018 -0500

    signal: Introduce copy_siginfo_from_user and use it's return value
    
    In preparation for using a smaller version of siginfo in the kernel
    introduce copy_siginfo_from_user and use it when siginfo is copied from
    userspace.
    
    Make the pattern for using copy_siginfo_from_user and
    copy_siginfo_from_user32 to capture the return value and return that
    value on error.
    
    This is a necessary prerequisite for using a smaller siginfo
    in the kernel than the kernel exports to userspace.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3d4cd5db30a9..de94c159bfb0 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -22,6 +22,7 @@ static inline void clear_siginfo(struct siginfo *info)
 }
 
 int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
+int copy_siginfo_from_user(struct siginfo *to, const struct siginfo __user *from);
 
 enum siginfo_layout {
 	SIL_KILL,

commit cd9b44f90763c3367e8dd0601849ffb028e8ba52
Merge: df2def49c57b 2a9d64810042
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 22 12:34:08 2018 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge more updates from Andrew Morton:
    
     - the rest of MM
    
     - procfs updates
    
     - various misc things
    
     - more y2038 fixes
    
     - get_maintainer updates
    
     - lib/ updates
    
     - checkpatch updates
    
     - various epoll updates
    
     - autofs updates
    
     - hfsplus
    
     - some reiserfs work
    
     - fatfs updates
    
     - signal.c cleanups
    
     - ipc/ updates
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (166 commits)
      ipc/util.c: update return value of ipc_getref from int to bool
      ipc/util.c: further variable name cleanups
      ipc: simplify ipc initialization
      ipc: get rid of ids->tables_initialized hack
      lib/rhashtable: guarantee initial hashtable allocation
      lib/rhashtable: simplify bucket_table_alloc()
      ipc: drop ipc_lock()
      ipc/util.c: correct comment in ipc_obtain_object_check
      ipc: rename ipcctl_pre_down_nolock()
      ipc/util.c: use ipc_rcu_putref() for failues in ipc_addid()
      ipc: reorganize initialization of kern_ipc_perm.seq
      ipc: compute kern_ipc_perm.id under the ipc lock
      init/Kconfig: remove EXPERT from CHECKPOINT_RESTORE
      fs/sysv/inode.c: use ktime_get_real_seconds() for superblock stamp
      adfs: use timespec64 for time conversion
      kernel/sysctl.c: fix typos in comments
      drivers/rapidio/devices/rio_mport_cdev.c: remove redundant pointer md
      fork: don't copy inconsistent signal handler state to child
      signal: make get_signal() return bool
      signal: make sigkill_pending() return bool
      ...

commit 20ab7218d2507b2dbec9c053c2f1b96054e266b6
Author: Christian Brauner <christian@brauner.io>
Date:   Tue Aug 21 22:00:54 2018 -0700

    signal: make get_signal() return bool
    
    make get_signal() already behaves like a boolean function.  Let's actually
    declare it as such too.
    
    Link: http://lkml.kernel.org/r/20180602103653.18181-18-christian@brauner.io
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index fa23cae66758..e3d9e0640e6e 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -265,7 +265,7 @@ extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 
-extern int get_signal(struct ksignal *ksig);
+extern bool get_signal(struct ksignal *ksig);
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 extern void kernel_sigaction(int, __sighandler_t);

commit 67a48a24478841525ba73ec6d64caaf079cf3b7c
Author: Christian Brauner <christian@brauner.io>
Date:   Tue Aug 21 22:00:34 2018 -0700

    signal: make unhandled_signal() return bool
    
    unhandled_signal() already behaves like a boolean function.  Let's
    actually declare it as such too.  All callers treat it as such too.
    
    Link: http://lkml.kernel.org/r/20180602103653.18181-13-christian@brauner.io
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3c5200137b24..fa23cae66758 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -287,7 +287,7 @@ static inline void disallow_signal(int sig)
 
 extern struct kmem_cache *sighand_cachep;
 
-int unhandled_signal(struct task_struct *tsk, int sig);
+extern bool unhandled_signal(struct task_struct *tsk, int sig);
 
 /*
  * In POSIX a signal is sent either to a specific thread (Linux task)

commit 40b3b02535621027f56d248139e0e467573c3098
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jul 21 10:45:15 2018 -0500

    signal: Pass pid type into do_send_sig_info
    
    This passes the information we already have at the call sight into
    do_send_sig_info.  Ultimately allowing for better handling of signals
    sent to a group of processes during fork.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index d8f2bf3d41e6..fe125b0335f7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -258,7 +258,7 @@ enum pid_type;
 
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int do_send_sig_info(int sig, struct siginfo *info,
-				struct task_struct *p, bool group);
+				struct task_struct *p, enum pid_type type);
 extern int group_send_sig_info(int sig, struct siginfo *info,
 			       struct task_struct *p, enum pid_type type);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);

commit 0102498083d58d8b17759642c602b525215e1a54
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Jul 13 18:40:57 2018 -0500

    signal: Pass pid type into group_send_sig_info
    
    This passes the information we already have at the call sight
    into group_send_sig_info.  Ultimatelly allowing for to better handle
    signals sent to a group of processes.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3c5200137b24..d8f2bf3d41e6 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -254,11 +254,13 @@ static inline int valid_signal(unsigned long sig)
 
 struct timespec;
 struct pt_regs;
+enum pid_type;
 
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int do_send_sig_info(int sig, struct siginfo *info,
 				struct task_struct *p, bool group);
-extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
+extern int group_send_sig_info(int sig, struct siginfo *info,
+			       struct task_struct *p, enum pid_type type);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(sigset_t *);

commit 31931c93dfe05a76385a443ed28244a50e915a46
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Apr 24 20:59:47 2018 -0500

    signal: Extend siginfo_layout with SIL_FAULT_{MCEERR|BNDERR|PKUERR}
    
    Update the siginfo_layout function and enum siginfo_layout to represent
    all of the possible field layouts of struct siginfo.
    
    This allows the uses of siginfo_layout in um and arm64 where they are testing
    for SIL_FAULT to be more accurate as this rules out the other cases.
    
    Further this allows the switch statements on siginfo_layout to be simpler
    if perhaps a little more wordy.  Making it easier to understand what is
    actually going on.
    
    As SIL_FAULT_BNDERR and SIL_FAULT_PKUERR are never expected to appear
    in signalfd just treat them as SIL_FAULT.  To include them would take
    20 extra bytes an pretty much fill up what is left of
    signalfd_siginfo.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index a9bc7e1b077e..3c5200137b24 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -28,6 +28,9 @@ enum siginfo_layout {
 	SIL_TIMER,
 	SIL_POLL,
 	SIL_FAULT,
+	SIL_FAULT_MCEERR,
+	SIL_FAULT_BNDERR,
+	SIL_FAULT_PKUERR,
 	SIL_CHLD,
 	SIL_RT,
 	SIL_SYS,

commit 0326e7ef057d214ed43a77557078c24e98b84af9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 27 11:59:46 2017 -0500

    signal: Remove unnecessary ifdefs now that there is only one struct siginfo
    
    Remove HAVE_ARCH_SIGINFO_T
    Remove __ARCH_SIGSYS
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 87abf0c29ed7..a9bc7e1b077e 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -30,9 +30,7 @@ enum siginfo_layout {
 	SIL_FAULT,
 	SIL_CHLD,
 	SIL_RT,
-#ifdef __ARCH_SIGSYS
 	SIL_SYS,
-#endif
 };
 
 enum siginfo_layout siginfo_layout(int sig, int si_code);

commit 8c5dbf2ae00bb8667f61c5edc6521c1fa2bbe4d7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jul 24 15:28:56 2017 -0500

    signal: Introduce clear_siginfo
    
    Unfortunately struct siginfo has holes both in the common part of the
    structure, in the union members, and in the lack of padding of the
    union members.  The result of those wholes is that the C standard does
    not guarantee those bits will be initialized.  As struct siginfo is
    for communication between the kernel and userspace that is a problem.
    
    Add the helper function clear_siginfo that is guaranteed to clear all of
    the bits in struct siginfo so when the structure is copied there is no danger
    of copying old kernel data and causing a leak of information from kernel
    space to userspace.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 8037b503ce91..87abf0c29ed7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -16,6 +16,11 @@ static inline void copy_siginfo(struct siginfo *to, const struct siginfo *from)
 	memcpy(to, from, sizeof(*to));
 }
 
+static inline void clear_siginfo(struct siginfo *info)
+{
+	memset(info, 0, sizeof(*info));
+}
+
 int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
 
 enum siginfo_layout {

commit 8c36fdf5ed48cc17a257e71e168883307ce89b0e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jul 19 21:30:42 2017 -0500

    signal: Reduce copy_siginfo to just a memcpy
    
    The savings for copying just part of struct siginfo appears to be in the
    noise on modern machines.  So remove this ``optimization'' and simplify the code.
    
    At the same time mark the second parameter as constant so there is no confusion
    as to which direction the copy will go.
    
    This ensures that a fully initialized siginfo that is sent ends up as
    a fully initialized siginfo on the signal queue.  This full initialization
    ensures even confused code won't copy unitialized data to userspace, and
    it prepares for turning copy_siginfo_to_user into a simple copy_to_user.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 042968dd98f0..8037b503ce91 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -11,13 +11,9 @@ struct task_struct;
 /* for sysctl */
 extern int print_fatal_signals;
 
-static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
+static inline void copy_siginfo(struct siginfo *to, const struct siginfo *from)
 {
-	if (from->si_code < 0)
-		memcpy(to, from, sizeof(*to));
-	else
-		/* _sigchld is currently the largest know union member */
-		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from->_sifields._sigchld));
+	memcpy(to, from, sizeof(*to));
 }
 
 int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 38564e3e54c7..042968dd98f0 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_SIGNAL_H
 #define _LINUX_SIGNAL_H
 

commit cc731525f26af85a1c3537da41e0abd1d35e0bdb
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Jul 16 22:36:59 2017 -0500

    signal: Remove kernel interal si_code magic
    
    struct siginfo is a union and the kernel since 2.4 has been hiding a union
    tag in the high 16bits of si_code using the values:
    __SI_KILL
    __SI_TIMER
    __SI_POLL
    __SI_FAULT
    __SI_CHLD
    __SI_RT
    __SI_MESGQ
    __SI_SYS
    
    While this looks plausible on the surface, in practice this situation has
    not worked well.
    
    - Injected positive signals are not copied to user space properly
      unless they have these magic high bits set.
    
    - Injected positive signals are not reported properly by signalfd
      unless they have these magic high bits set.
    
    - These kernel internal values leaked to userspace via ptrace_peek_siginfo
    
    - It was possible to inject these kernel internal values and cause the
      the kernel to misbehave.
    
    - Kernel developers got confused and expected these kernel internal values
      in userspace in kernel self tests.
    
    - Kernel developers got confused and set si_code to __SI_FAULT which
      is SI_USER in userspace which causes userspace to think an ordinary user
      sent the signal and that it was not kernel generated.
    
    - The values make it impossible to reorganize the code to transform
      siginfo_copy_to_user into a plain copy_to_user.  As si_code must
      be massaged before being passed to userspace.
    
    So remove these kernel internal si codes and make the kernel code simpler
    and more maintainable.
    
    To replace these kernel internal magic si_codes introduce the helper
    function siginfo_layout, that takes a signal number and an si_code and
    computes which union member of siginfo is being used.  Have
    siginfo_layout return an enumeration so that gcc will have enough
    information to warn if a switch statement does not handle all of union
    members.
    
    A couple of architectures have a messed up ABI that defines signal
    specific duplications of SI_USER which causes more special cases in
    siginfo_layout than I would like.  The good news is only problem
    architectures pay the cost.
    
    Update all of the code that used the previous magic __SI_ values to
    use the new SIL_ values and to call siginfo_layout to get those
    values.  Escept where not all of the cases are handled remove the
    defaults in the switch statements so that if a new case is missed in
    the future the lack will show up at compile time.
    
    Modify the code that copies siginfo si_code to userspace to just copy
    the value and not cast si_code to a short first.  The high bits are no
    longer used to hold a magic union member.
    
    Fixup the siginfo header files to stop including the __SI_ values in
    their constants and for the headers that were missing it to properly
    update the number of si_codes for each signal type.
    
    The fixes to copy_siginfo_from_user32 implementations has the
    interesting property that several of them perviously should never have
    worked as the __SI_ values they depended up where kernel internal.
    With that dependency gone those implementations should work much
    better.
    
    The idea of not passing the __SI_ values out to userspace and then
    not reinserting them has been tested with criu and criu worked without
    changes.
    
    Ref: 2.4.0-test1
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index c97cc20369c0..38564e3e54c7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -21,6 +21,20 @@ static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
 
 int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
 
+enum siginfo_layout {
+	SIL_KILL,
+	SIL_TIMER,
+	SIL_POLL,
+	SIL_FAULT,
+	SIL_CHLD,
+	SIL_RT,
+#ifdef __ARCH_SIGSYS
+	SIL_SYS,
+#endif
+};
+
+enum siginfo_layout siginfo_layout(int sig, int si_code);
+
 /*
  * Define some primitives to manipulate sigset_t.
  */

commit d08477aa975e97f1dc64c0ae59cebf98520456ce
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 29 09:28:50 2017 -0500

    fcntl: Don't use ambiguous SIG_POLL si_codes
    
    We have a weird and problematic intersection of features that when
    they all come together result in ambiguous siginfo values, that
    we can not support properly.
    
    - Supporting fcntl(F_SETSIG,...) with arbitrary valid signals.
    
    - Using positive values for POLL_IN, POLL_OUT, POLL_MSG, ..., etc
      that imply they are signal specific si_codes and using the
      aforementioned arbitrary signal to deliver them.
    
    - Supporting injection of arbitrary siginfo values for debugging and
      checkpoint/restore.
    
    The result is that just looking at siginfo si_codes of 1 to 6 are
    ambigious.  It could either be a signal specific si_code or it could
    be a generic si_code.
    
    For most of the kernel this is a non-issue but for sending signals
    with siginfo it is impossible to play back the kernel signals and
    get the same result.
    
    Strictly speaking when the si_code was changed from SI_SIGIO to
    POLL_IN and friends between 2.2 and 2.4 this functionality was not
    ambiguous, as only real time signals were supported.  Before 2.4 was
    released the kernel began supporting siginfo with non realtime signals
    so they could give details of why the signal was sent.
    
    The result is that if F_SETSIG is set to one of the signals with signal
    specific si_codes then user space can not know why the signal was sent.
    
    I grepped through a bunch of userspace programs using debian code
    search to get a feel for how often people choose a signal that results
    in an ambiguous si_code.  I only found one program doing so and it was
    using SIGCHLD to test the F_SETSIG functionality, and did not appear
    to be a real world usage.
    
    Therefore the ambiguity does not appears to be a real world problem in
    practice.  Remove the ambiguity while introducing the smallest chance
    of breakage by changing the si_code to SI_SIGIO when signals with
    signal specific si_codes are targeted.
    
    Fixes: v2.3.40 -- Added support for queueing non-rt signals
    Fixes: v2.3.21 -- Changed the si_code from SI_SIGIO
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index e2678b5dbb21..c97cc20369c0 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -380,10 +380,18 @@ int unhandled_signal(struct task_struct *tsk, int sig);
         rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \
 	rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )
 
+#define SIG_SPECIFIC_SICODES_MASK (\
+	rt_sigmask(SIGILL)    |  rt_sigmask(SIGFPE)    | \
+	rt_sigmask(SIGSEGV)   |  rt_sigmask(SIGBUS)    | \
+	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGCHLD)   | \
+	rt_sigmask(SIGPOLL)   |  rt_sigmask(SIGSYS)    | \
+	SIGEMT_MASK                                    )
+
 #define sig_kernel_only(sig)		siginmask(sig, SIG_KERNEL_ONLY_MASK)
 #define sig_kernel_coredump(sig)	siginmask(sig, SIG_KERNEL_COREDUMP_MASK)
 #define sig_kernel_ignore(sig)		siginmask(sig, SIG_KERNEL_IGNORE_MASK)
 #define sig_kernel_stop(sig)		siginmask(sig, SIG_KERNEL_STOP_MASK)
+#define sig_specific_sicodes(sig)	siginmask(sig, SIG_SPECIFIC_SICODES_MASK)
 
 #define sig_fatal(t, signr) \
 	(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) && \

commit c856863988ebf612d159e55eeddbcd27de63b40d
Merge: 771d3feb4b79 0d0606060bae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 20:57:13 2017 -0700

    Merge branch 'misc.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc compat stuff updates from Al Viro:
     "This part is basically untangling various compat stuff. Compat
      syscalls moved to their native counterparts, getting rid of quite a
      bit of double-copying and/or set_fs() uses. A lot of field-by-field
      copyin/copyout killed off.
    
       - kernel/compat.c is much closer to containing just the
         copyin/copyout of compat structs. Not all compat syscalls are gone
         from it yet, but it's getting there.
    
       - ipc/compat_mq.c killed off completely.
    
       - block/compat_ioctl.c cleaned up; floppy compat ioctls moved to
         drivers/block/floppy.c where they belong. Yes, there are several
         drivers that implement some of the same ioctls. Some are m68k and
         one is 32bit-only pmac. drivers/block/floppy.c is the only one in
         that bunch that can be built on biarch"
    
    * 'misc.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      mqueue: move compat syscalls to native ones
      usbdevfs: get rid of field-by-field copyin
      compat_hdio_ioctl: get rid of set_fs()
      take floppy compat ioctls to sodding floppy.c
      ipmi: get rid of field-by-field __get_user()
      ipmi: get COMPAT_IPMICTL_RECEIVE_MSG in sync with the native one
      rt_sigtimedwait(): move compat to native
      select: switch compat_{get,put}_fd_set() to compat_{get,put}_bitmap()
      put_compat_rusage(): switch to copy_to_user()
      sigpending(): move compat to native
      getrlimit()/setrlimit(): move compat to native
      times(2): move compat to native
      compat_{get,put}_bitmap(): use unsafe_{get,put}_user()
      fb_get_fscreeninfo(): don't bother with do_fb_ioctl()
      do_sigaltstack(): lift copying to/from userland into callers
      take compat_sys_old_getrlimit() to native syscall
      trim __ARCH_WANT_SYS_OLD_GETRLIMIT

commit 1b3c872c8342803d0fcd8042e4e007d173191db6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 31 04:46:17 2017 -0400

    rt_sigtimedwait(): move compat to native
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 1f5a16620693..231603ac20a3 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -246,8 +246,6 @@ extern int do_send_sig_info(int sig, struct siginfo *info,
 				struct task_struct *p, bool group);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
-extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
-				const struct timespec *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);

commit b9253a43370e8f3c46c0ee24b04fa2ffec37b7c0
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 21:01:01 2017 +0200

    signal: Move copy_siginfo_to_user to <linux/signal.h>
    
    Having it in asm-generic/siginfo.h doesn't make any sense as it is in no way
    architecture specific.  Move it to signal.h instead where several related
    functions already reside.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arch@vger.kernel.org
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-ia64@vger.kernel.org
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: sparclinux@vger.kernel.org
    Cc: "David S. Miller" <davem@davemloft.net>
    Link: http://lkml.kernel.org/r/20170603190102.28866-5-hch@lst.de

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 80c7418be359..a39feddd71ba 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -19,6 +19,8 @@ static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
 		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from->_sifields._sigchld));
 }
 
+int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
+
 /*
  * Define some primitives to manipulate sigset_t.
  */

commit 7994200ce69a3873dfa2641254a13bb0a40056f3
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 21:00:59 2017 +0200

    ia64: Remove HAVE_ARCH_COPY_SIGINFO
    
    Since ia64 defines __ARCH_SI_PREAMBLE_SIZE it can just use the generic
    copy_siginfo implementation, which is identical to the architecture
    specific one.
    
    With that support for HAVE_ARCH_COPY_SIGINFO can go away entirely.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arch@vger.kernel.org
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-ia64@vger.kernel.org
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: sparclinux@vger.kernel.org
    Cc: "David S. Miller" <davem@davemloft.net>
    Link: http://lkml.kernel.org/r/20170603190102.28866-3-hch@lst.de

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 1f5a16620693..80c7418be359 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -3,16 +3,13 @@
 
 #include <linux/bug.h>
 #include <linux/signal_types.h>
+#include <linux/string.h>
 
 struct task_struct;
 
 /* for sysctl */
 extern int print_fatal_signals;
 
-#ifndef HAVE_ARCH_COPY_SIGINFO
-
-#include <linux/string.h>
-
 static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
 {
 	if (from->si_code < 0)
@@ -22,8 +19,6 @@ static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
 		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from->_sifields._sigchld));
 }
 
-#endif
-
 /*
  * Define some primitives to manipulate sigset_t.
  */

commit d27158c0cf080c85753f34e7a20a91c3ba20a0b9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 30 19:26:35 2017 -0500

    signal: Remove unused definition of sig_user_definied
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 94ad6eea9550..1f5a16620693 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -390,10 +390,6 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 #define sig_kernel_ignore(sig)		siginmask(sig, SIG_KERNEL_IGNORE_MASK)
 #define sig_kernel_stop(sig)		siginmask(sig, SIG_KERNEL_STOP_MASK)
 
-#define sig_user_defined(t, signr) \
-	(((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_DFL) &&	\
-	 ((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_IGN))
-
 #define sig_fatal(t, signr) \
 	(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) && \
 	 (t)->sighand->action[(signr)-1].sa.sa_handler == SIG_DFL)

commit 76960dbf9b235b957d9d730be2c6c2a70f709026
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Feb 3 23:43:50 2017 +0100

    signals: Move signal data types from <linux/signal.h> to <linux/signal_types.h>
    
    Separate out just the pure data types - sched.h will be able to use
    this reduced size header.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index d1c2b05a7a55..94ad6eea9550 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -8,24 +8,6 @@ struct task_struct;
 
 /* for sysctl */
 extern int print_fatal_signals;
-/*
- * Real Time signals may be queued.
- */
-
-struct sigqueue {
-	struct list_head list;
-	int flags;
-	siginfo_t info;
-	struct user_struct *user;
-};
-
-/* flags values. */
-#define SIGQUEUE_PREALLOC	1
-
-struct sigpending {
-	struct list_head list;
-	sigset_t signal;
-};
 
 #ifndef HAVE_ARCH_COPY_SIGINFO
 
@@ -271,42 +253,6 @@ extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 
-struct sigaction {
-#ifndef __ARCH_HAS_IRIX_SIGACTION
-	__sighandler_t	sa_handler;
-	unsigned long	sa_flags;
-#else
-	unsigned int	sa_flags;
-	__sighandler_t	sa_handler;
-#endif
-#ifdef __ARCH_HAS_SA_RESTORER
-	__sigrestore_t sa_restorer;
-#endif
-	sigset_t	sa_mask;	/* mask last for extensibility */
-};
-
-struct k_sigaction {
-	struct sigaction sa;
-#ifdef __ARCH_HAS_KA_RESTORER
-	__sigrestore_t ka_restorer;
-#endif
-};
- 
-#ifdef CONFIG_OLD_SIGACTION
-struct old_sigaction {
-	__sighandler_t sa_handler;
-	old_sigset_t sa_mask;
-	unsigned long sa_flags;
-	__sigrestore_t sa_restorer;
-};
-#endif
-
-struct ksignal {
-	struct k_sigaction ka;
-	siginfo_t info;
-	int sig;
-};
-
 extern int get_signal(struct ksignal *ksig);
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void exit_signals(struct task_struct *tsk);

commit e6d930b4e0115eb0732eec0efb11c3b09a8000fc
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Feb 3 23:43:50 2017 +0100

    signals: Prepare to split out <linux/signal_types.h> from <linux/signal.h>
    
    Introduce dummy header and add dependencies to places that will depend on it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 5308304993be..d1c2b05a7a55 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -1,9 +1,8 @@
 #ifndef _LINUX_SIGNAL_H
 #define _LINUX_SIGNAL_H
 
-#include <linux/list.h>
 #include <linux/bug.h>
-#include <uapi/linux/signal.h>
+#include <linux/signal_types.h>
 
 struct task_struct;
 

commit c7be96af89d4b53211862d8599b2430e8900ed92
Author: Waiman Long <Waiman.Long@hpe.com>
Date:   Wed Dec 14 15:04:10 2016 -0800

    signals: avoid unnecessary taking of sighand->siglock
    
    When running certain database workload on a high-end system with many
    CPUs, it was found that spinlock contention in the sigprocmask syscalls
    became a significant portion of the overall CPU cycles as shown below.
    
      9.30%  9.30%  905387  dataserver  /proc/kcore 0x7fff8163f4d2
      [k] _raw_spin_lock_irq
                |
                ---_raw_spin_lock_irq
                   |
                   |--99.34%-- __set_current_blocked
                   |          sigprocmask
                   |          sys_rt_sigprocmask
                   |          system_call_fastpath
                   |          |
                   |          |--50.63%-- __swapcontext
                   |          |          |
                   |          |          |--99.91%-- upsleepgeneric
                   |          |
                   |          |--49.36%-- __setcontext
                   |          |          ktskRun
    
    Looking further into the swapcontext function in glibc, it was found that
    the function always call sigprocmask() without checking if there are
    changes in the signal mask.
    
    A check was added to the __set_current_blocked() function to avoid taking
    the sighand->siglock spinlock if there is no change in the signal mask.
    This will prevent unneeded spinlock contention when many threads are
    trying to call sigprocmask().
    
    With this patch applied, the spinlock contention in sigprocmask() was
    gone.
    
    Link: http://lkml.kernel.org/r/1474979209-11867-1-git-send-email-Waiman.Long@hpe.com
    Signed-off-by: Waiman Long <Waiman.Long@hpe.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Stas Sergeev <stsp@list.ru>
    Cc: Scott J Norton <scott.norton@hpe.com>
    Cc: Douglas Hatch <doug.hatch@hpe.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index b63f63eaa39c..5308304993be 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -97,6 +97,23 @@ static inline int sigisemptyset(sigset_t *set)
 	}
 }
 
+static inline int sigequalsets(const sigset_t *set1, const sigset_t *set2)
+{
+	switch (_NSIG_WORDS) {
+	case 4:
+		return	(set1->sig[3] == set2->sig[3]) &&
+			(set1->sig[2] == set2->sig[2]) &&
+			(set1->sig[1] == set2->sig[1]) &&
+			(set1->sig[0] == set2->sig[0]);
+	case 2:
+		return	(set1->sig[1] == set2->sig[1]) &&
+			(set1->sig[0] == set2->sig[0]);
+	case 1:
+		return	set1->sig[0] == set2->sig[0];
+	}
+	return 0;
+}
+
 #define sigmask(sig)	(1UL << ((sig) - 1))
 
 #ifndef __HAVE_ARCH_SIG_SETOPS

commit 5c8ccefdf46c5f87d87b694c7fbc04941c2c99a5
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon May 23 16:24:02 2016 -0700

    signal: move the "sig < SIGRTMIN" check into siginmask(sig)
    
    All the users of siginmask() must ensure that sig < SIGRTMIN.  sig_fatal()
    doesn't and this is wrong:
    
            UBSAN: Undefined behaviour in kernel/signal.c:911:6
            shift exponent 32 is too large for 32-bit type 'long unsigned int'
    
    the patch doesn't add the neccesary check to sig_fatal(), it moves the
    check into siginmask() and updates other callers.
    
    Link: http://lkml.kernel.org/r/20160517195052.GA15187@redhat.com
    Reported-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 639be264f5f9..b63f63eaa39c 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -400,7 +400,9 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 #else
 #define rt_sigmask(sig)	sigmask(sig)
 #endif
-#define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
+
+#define siginmask(sig, mask) \
+	((sig) < SIGRTMIN && (rt_sigmask(sig) & (mask)))
 
 #define SIG_KERNEL_ONLY_MASK (\
 	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
@@ -421,14 +423,10 @@ int unhandled_signal(struct task_struct *tsk, int sig);
         rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \
 	rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )
 
-#define sig_kernel_only(sig) \
-	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_ONLY_MASK))
-#define sig_kernel_coredump(sig) \
-	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_COREDUMP_MASK))
-#define sig_kernel_ignore(sig) \
-	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_IGNORE_MASK))
-#define sig_kernel_stop(sig) \
-	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_STOP_MASK))
+#define sig_kernel_only(sig)		siginmask(sig, SIG_KERNEL_ONLY_MASK)
+#define sig_kernel_coredump(sig)	siginmask(sig, SIG_KERNEL_COREDUMP_MASK)
+#define sig_kernel_ignore(sig)		siginmask(sig, SIG_KERNEL_IGNORE_MASK)
+#define sig_kernel_stop(sig)		siginmask(sig, SIG_KERNEL_STOP_MASK)
 
 #define sig_user_defined(t, signr) \
 	(((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_DFL) &&	\

commit 07b75260ebc2c789724c594d7eaf0194fa47b3be
Merge: 0efacbbaee1e 6e4ad1b41360
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 10:02:26 2016 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for MIPS for 4.7.  Here's the summary of
      the changes:
    
       - ATH79: Support for DTB passuing using the UHI boot protocol
       - ATH79: Remove support for builtin DTB.
       - ATH79: Add zboot debug serial support.
       - ATH79: Add initial support for Dragino MS14 (Dragine 2), Onion Omega
                and DPT-Module.
       - ATH79: Update devicetree clock support for AR9132 and AR9331.
       - ATH79: Cleanup the DT code.
       - ATH79: Support newer SOCs in ath79_ddr_ctrl_init.
       - ATH79: Fix regression in PCI window initialization.
       - BCM47xx: Move SPROM driver to drivers/firmware/
       - BCM63xx: Enable partition parser in defconfig.
       - BMIPS: BMIPS5000 has I cache filing from D cache
       - BMIPS: BMIPS: Add cpu-feature-overrides.h
       - BMIPS: Add Whirlwind support
       - BMIPS: Adjust mips-hpt-frequency for BCM7435
       - BMIPS: Remove maxcpus from BCM97435SVMB DTS
       - BMIPS: Add missing 7038 L1 register cells to BCM7435
       - BMIPS: Various tweaks to initialization code.
       - BMIPS: Enable partition parser in defconfig.
       - BMIPS: Cache tweaks.
       - BMIPS: Add UART, I2C and SATA devices to DT.
       - BMIPS: Add BCM6358 and BCM63268support
       - BMIPS: Add device tree example for BCM6358.
       - BMIPS: Improve Improve BCM6328 and BCM6368 device trees
       - Lantiq: Add support for device tree file from boot loader
       - Lantiq: Allow build with no built-in DT.
       - Loongson 3: Reserve 32MB for RS780E integrated GPU.
       - Loongson 3: Fix build error after ld-version.sh modification
       - Loongson 3: Move chipset ACPI code from drivers to arch.
       - Loongson 3: Speedup irq processing.
       - Loongson 3: Add basic Loongson 3A support.
       - Loongson 3: Set cache flush handlers to nop.
       - Loongson 3: Invalidate special TLBs when needed.
       - Loongson 3: Fast TLB refill handler.
       - MT7620: Fallback strategy for invalid syscfg0.
       - Netlogic: Fix CP0_EBASE redefinition warnings
       - Octeon: Initialization fixes
       - Octeon: Add DTS files for the D-Link DSR-1000N and EdgeRouter Lite
       - Octeon: Enable add Octeon-drivers in cavium_octeon_defconfig
       - Octeon: Correctly handle endian-swapped initramfs images.
       - Octeon: Support CN73xx, CN75xx and CN78xx.
       - Octeon: Remove dead code from cvmx-sysinfo.
       - Octeon: Extend number of supported CPUs past 32.
       - Octeon: Remove some code limiting NR_IRQS to 255.
       - Octeon: Simplify octeon_irq_ciu_gpio_set_type.
       - Octeon: Mark some functions __init in smp.c
       - Octeon: Octeon: Add Octeon III CN7xxx interface detection
       - PIC32: Add serial driver and bindings for it.
       - PIC32: Add PIC32 deadman timer driver and bindings.
       - PIC32: Add PIC32 clock timer driver and bindings.
       - Pistachio: Determine SoC revision during boot
       - Sibyte: Fix Kconfig dependencies of SIBYTE_BUS_WATCHER.
       - Sibyte: Strip redundant comments from bcm1480_regs.h.
       - Panic immediately if panic_on_oops is set.
       - module: fix incorrect IS_ERR_VALUE macro usage.
       - module: Make consistent use of pr_*
       - Remove no longer needed work_on_cpu() call.
       - Remove CONFIG_IPV6_PRIVACY from defconfigs.
       - Fix registers of non-crashing CPUs in dumps.
       - Handle MIPSisms in new vmcore_elf32_check_arch.
       - Select CONFIG_HANDLE_DOMAIN_IRQ and make it work.
       - Allow RIXI to be used on non-R2 or R6 cores.
       - Reserve nosave data for hibernation
       - Fix siginfo.h to use strict POSIX types.
       - Don't unwind user mode with EVA.
       - Fix watchpoint restoration
       - Ptrace watchpoints for R6.
       - Sync icache when it fills from dcache
       - I6400 I-cache fills from dcache.
       - Various MSA fixes.
       - Cleanup MIPS_CPU_* definitions.
       - Signal: Move generic copy_siginfo to signal.h
       - Signal: Fix uapi include in exported asm/siginfo.h
       - Timer fixes for sake of KVM.
       - XPA TLB refill fixes.
       - Treat perf counter feature
       - Update John Crispin's email address
       - Add PIC32 watchdog and bindings.
       - Handle R10000 LL/SC bug in set_pte()
       - cpufreq: Various fixes for Longson1.
       - R6: Fix R2 emulation.
       - mathemu: Cosmetic fix to ADDIUPC emulation, plenty of other small fixes
       - ELF: ABI and FP fixes.
       - Allow for relocatable kernel and use that to support KASLR.
       - Fix CPC_BASE_ADDR mask
       - Plenty fo smp-cps, CM, R6 and M6250 fixes.
       - Make reset_control_ops const.
       - Fix kernel command line handling of leading whitespace.
       - Cleanups to cache handling.
       - Add brcm, bcm6345-l1-intc device tree bindings.
       - Use generic clkdev.h header
       - Remove CLK_IS_ROOT usage.
       - Misc small cleanups.
       - CM: Fix compilation error when !MIPS_CM
       - oprofile: Fix a preemption issue
       - Detect DSP ASE v3 support:1"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (275 commits)
      MIPS: pic32mzda: fix getting timer clock rate.
      MIPS: ath79: fix regression in PCI window initialization
      MIPS: ath79: make ath79_ddr_ctrl_init() compatible for newer SoCs
      MIPS: Fix VZ probe gas errors with binutils <2.24
      MIPS: perf: Fix I6400 event numbers
      MIPS: DEC: Export `ioasic_ssr_lock' to modules
      MIPS: MSA: Fix a link error on `_init_msa_upper' with older GCC
      MIPS: CM: Fix compilation error when !MIPS_CM
      MIPS: Fix genvdso error on rebuild
      USB: ohci-jz4740: Remove obsolete driver
      MIPS: JZ4740: Probe OHCI platform device via DT
      MIPS: JZ4740: Qi LB60: Remove support for AVT2 variant
      MIPS: pistachio: Determine SoC revision during boot
      MIPS: BMIPS: Adjust mips-hpt-frequency for BCM7435
      mips: mt7620: fallback to SDRAM when syscfg0 does not have a valid value for the memory type
      MIPS: Prevent "restoration" of MSA context in non-MSA kernels
      MIPS: cevt-r4k: Dynamically calculate min_delta_ns
      MIPS: malta-time: Take seconds into account
      MIPS: malta-time: Start GIC count before syncing to RTC
      MIPS: Force CPUs to lose FP context during mode switches
      ...

commit ca9eb49aa9562eaadf3cea071ec7018ad6800425
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 8 18:43:50 2016 +0000

    SIGNAL: Move generic copy_siginfo() to signal.h
    
    The generic copy_siginfo() is currently defined in
    asm-generic/siginfo.h, after including uapi/asm-generic/siginfo.h which
    defines the generic struct siginfo. However this makes it awkward for an
    architecture to use it if it has to define its own struct siginfo (e.g.
    MIPS and potentially IA64), since it means that asm-generic/siginfo.h
    can only be included after defining the arch-specific siginfo, which may
    be problematic if the arch-specific definition needs definitions from
    uapi/asm-generic/siginfo.h.
    
    It is possible to work around this by first including
    uapi/asm-generic/siginfo.h to get the constants before defining the
    arch-specific siginfo, and include asm-generic/siginfo.h after. However
    uapi headers can't be included by other uapi headers, so that first
    include has to be in an ifdef __kernel__, with the non __kernel__ case
    including the non-UAPI header instead.
    
    Instead of that mess, move the generic copy_siginfo() definition into
    linux/signal.h, which allows an arch-specific uapi/asm/siginfo.h to
    include asm-generic/siginfo.h and define the arch-specific siginfo, and
    for the generic copy_siginfo() to see that arch-specific definition.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Petr Malat <oss@malat.biz>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Christopher Ferris <cferris@google.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 4.0-
    Patchwork: https://patchwork.linux-mips.org/patch/12478/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 92557bbce7e7..d80259afb9e5 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -28,6 +28,21 @@ struct sigpending {
 	sigset_t signal;
 };
 
+#ifndef HAVE_ARCH_COPY_SIGINFO
+
+#include <linux/string.h>
+
+static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)
+{
+	if (from->si_code < 0)
+		memcpy(to, from, sizeof(*to));
+	else
+		/* _sigchld is currently the largest know union member */
+		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from->_sifields._sigchld));
+}
+
+#endif
+
 /*
  * Define some primitives to manipulate sigset_t.
  */

commit 2a74213838104a41588d86fd5e8d344972891ace
Author: Stas Sergeev <stsp@list.ru>
Date:   Thu Apr 14 23:20:04 2016 +0300

    signals/sigaltstack: Implement SS_AUTODISARM flag
    
    This patch implements the SS_AUTODISARM flag that can be OR-ed with
    SS_ONSTACK when forming ss_flags.
    
    When this flag is set, sigaltstack will be disabled when entering
    the signal handler; more precisely, after saving sas to uc_stack.
    When leaving the signal handler, the sigaltstack is restored by
    uc_stack.
    
    When this flag is used, it is safe to switch from sighandler with
    swapcontext(). Without this flag, the subsequent signal will corrupt
    the state of the switched-away sighandler.
    
    To detect the support of this functionality, one can do:
    
      err = sigaltstack(SS_DISABLE | SS_AUTODISARM);
      if (err && errno == EINVAL)
            unsupported();
    
    Signed-off-by: Stas Sergeev <stsp@list.ru>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Aleksa Sarai <cyphar@cyphar.com>
    Cc: Amanieu d'Antras <amanieu@gmail.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Jason Low <jason.low2@hp.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Palmer Dabbelt <palmer@dabbelt.com>
    Cc: Paul Moore <pmoore@redhat.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vladimir Davydov <vdavydov@parallels.com>
    Cc: linux-api@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/1460665206-13646-4-git-send-email-stsp@list.ru
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 92557bbce7e7..3fbe81444d31 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -432,8 +432,10 @@ int __save_altstack(stack_t __user *, unsigned long);
 	stack_t __user *__uss = uss; \
 	struct task_struct *t = current; \
 	put_user_ex((void __user *)t->sas_ss_sp, &__uss->ss_sp); \
-	put_user_ex(sas_ss_flags(sp), &__uss->ss_flags); \
+	put_user_ex(t->sas_ss_flags, &__uss->ss_flags); \
 	put_user_ex(t->sas_ss_size, &__uss->ss_size); \
+	if (t->sas_ss_flags & SS_AUTODISARM) \
+		sas_ss_reset(t); \
 } while (0);
 
 #ifdef CONFIG_PROC_FS

commit 9d8a765211335cfdad464b90fb19f546af5706ae
Author: Richard Weinberger <richard@nod.at>
Date:   Fri Nov 20 15:57:21 2015 -0800

    kernel/signal.c: unexport sigsuspend()
    
    sigsuspend() is nowhere used except in signal.c itself, so we can mark it
    static do not pollute the global namespace.
    
    But this patch is more than a boring cleanup patch, it fixes a real issue
    on UserModeLinux.  UML has a special console driver to display ttys using
    xterm, or other terminal emulators, on the host side.  Vegard reported
    that sometimes UML is unable to spawn a xterm and he's facing the
    following warning:
    
      WARNING: CPU: 0 PID: 908 at include/linux/thread_info.h:128 sigsuspend+0xab/0xc0()
    
    It turned out that this warning makes absolutely no sense as the UML
    xterm code calls sigsuspend() on the host side, at least it tries.  But
    as the kernel itself offers a sigsuspend() symbol the linker choose this
    one instead of the glibc wrapper.  Interestingly this code used to work
    since ever but always blocked signals on the wrong side.  Some recent
    kernel change made the WARN_ON() trigger and uncovered the bug.
    
    It is a wonderful example of how much works by chance on computers. :-)
    
    Fixes: 68f3f16d9ad0f1 ("new helper: sigsuspend()")
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Tested-by: Vegard Nossum <vegard.nossum@oracle.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: <stable@vger.kernel.org>    [3.5+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ab1e0392b5ac..92557bbce7e7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -239,7 +239,6 @@ extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
-extern int sigsuspend(sigset_t *);
 
 struct sigaction {
 #ifndef __ARCH_HAS_IRIX_SIGACTION

commit 1c3bea0e71892ef9100c01d3799cdae8cac273ef
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Oct 13 15:53:33 2014 -0700

    signal: use BUILD_BUG() instead of _NSIG_WORDS_is_unsupported_size()
    
    Kill _NSIG_WORDS_is_unsupported_size(), use BUILD_BUG() instead.  This
    simplifies the code, avoids the nested-externs warnings, and this way we
    do not defer the problem to linker.
    
    Also, fix the indentation in _SIG_SET_BINOP() and _SIG_SET_OP().
    
    Note: this patch assumes that the code like "if (0) BUILD_BUG();" is
    valid.  If not (say __compiletime_error() is not defined and thus
    __compiletime_error_fallback() uses a negative array) we should fix
    BUILD_BUG() and/or BUILD_BUG_ON_MSG().  This code should be fine by
    definition, this is the documented purpose of BUILD_BUG().
    
    [sfr@canb.auug.org.au: fix powerpc build failures]
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reported-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 750196fcc0a5..ab1e0392b5ac 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -2,6 +2,7 @@
 #define _LINUX_SIGNAL_H
 
 #include <linux/list.h>
+#include <linux/bug.h>
 #include <uapi/linux/signal.h>
 
 struct task_struct;
@@ -67,7 +68,6 @@ static inline int sigismember(sigset_t *set, int _sig)
 
 static inline int sigisemptyset(sigset_t *set)
 {
-	extern void _NSIG_WORDS_is_unsupported_size(void);
 	switch (_NSIG_WORDS) {
 	case 4:
 		return (set->sig[3] | set->sig[2] |
@@ -77,7 +77,7 @@ static inline int sigisemptyset(sigset_t *set)
 	case 1:
 		return set->sig[0] == 0;
 	default:
-		_NSIG_WORDS_is_unsupported_size();
+		BUILD_BUG();
 		return 0;
 	}
 }
@@ -90,24 +90,23 @@ static inline int sigisemptyset(sigset_t *set)
 #define _SIG_SET_BINOP(name, op)					\
 static inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) \
 {									\
-	extern void _NSIG_WORDS_is_unsupported_size(void);		\
 	unsigned long a0, a1, a2, a3, b0, b1, b2, b3;			\
 									\
 	switch (_NSIG_WORDS) {						\
-	    case 4:							\
+	case 4:								\
 		a3 = a->sig[3]; a2 = a->sig[2];				\
 		b3 = b->sig[3]; b2 = b->sig[2];				\
 		r->sig[3] = op(a3, b3);					\
 		r->sig[2] = op(a2, b2);					\
-	    case 2:							\
+	case 2:								\
 		a1 = a->sig[1]; b1 = b->sig[1];				\
 		r->sig[1] = op(a1, b1);					\
-	    case 1:							\
+	case 1:								\
 		a0 = a->sig[0]; b0 = b->sig[0];				\
 		r->sig[0] = op(a0, b0);					\
 		break;							\
-	    default:							\
-		_NSIG_WORDS_is_unsupported_size();			\
+	default:							\
+		BUILD_BUG();						\
 	}								\
 }
 
@@ -128,16 +127,14 @@ _SIG_SET_BINOP(sigandnsets, _sig_andn)
 #define _SIG_SET_OP(name, op)						\
 static inline void name(sigset_t *set)					\
 {									\
-	extern void _NSIG_WORDS_is_unsupported_size(void);		\
-									\
 	switch (_NSIG_WORDS) {						\
-	    case 4: set->sig[3] = op(set->sig[3]);			\
-		    set->sig[2] = op(set->sig[2]);			\
-	    case 2: set->sig[1] = op(set->sig[1]);			\
-	    case 1: set->sig[0] = op(set->sig[0]);			\
+	case 4:	set->sig[3] = op(set->sig[3]);				\
+		set->sig[2] = op(set->sig[2]);				\
+	case 2:	set->sig[1] = op(set->sig[1]);				\
+	case 1:	set->sig[0] = op(set->sig[0]);				\
 		    break;						\
-	    default:							\
-		_NSIG_WORDS_is_unsupported_size();			\
+	default:							\
+		BUILD_BUG();						\
 	}								\
 }
 

commit 828b1f65d23cf8a68795739f6dd08fc8abd9ee64
Author: Richard Weinberger <richard@nod.at>
Date:   Mon Oct 7 15:26:57 2013 +0200

    Rip out get_signal_to_deliver()
    
    Now we can turn get_signal() to the main function.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index b005cc3dc1dc..750196fcc0a5 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -280,7 +280,7 @@ struct ksignal {
 	int sig;
 };
 
-extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+extern int get_signal(struct ksignal *ksig);
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 extern void kernel_sigaction(int, __sighandler_t);
@@ -300,18 +300,6 @@ static inline void disallow_signal(int sig)
 	kernel_sigaction(sig, SIG_IGN);
 }
 
-/*
- * Eventually that'll replace get_signal_to_deliver(); macro for now,
- * to avoid nastiness with include order.
- */
-#define get_signal(ksig)					\
-({								\
-	struct ksignal *p = (ksig);				\
-	p->sig = get_signal_to_deliver(&p->info, &p->ka,	\
-					signal_pt_regs(), NULL);\
-	p->sig > 0;						\
-})
-
 extern struct kmem_cache *sighand_cachep;
 
 int unhandled_signal(struct task_struct *tsk, int sig);

commit 10b1c7ac8bfed429cf3dcb0225482c8dc1485d8e
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Jul 13 13:36:04 2014 +0200

    Clean up signal_delivered()
    
     - Pass a ksignal struct to it
     - Remove unused regs parameter
     - Make it private as it's nowhere outside of kernel/signal.c is used
    
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index c9e65360c49a..b005cc3dc1dc 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -282,7 +282,6 @@ struct ksignal {
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
-extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 extern void kernel_sigaction(int, __sighandler_t);
 

commit b4e74264eb0b03f42097fa70a0766312156244a0
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Jun 6 14:37:00 2014 -0700

    signals: introduce kernel_sigaction()
    
    Now that allow_signal() is really trivial we can unify it with
    disallow_signal().  Add the new helper, kernel_sigaction(), and
    reimplement allow_signal/disallow_signal as a trivial wrappers.
    
    This saves one EXPORT_SYMBOL() and the new helper can have more users.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ac83c593f4b9..c9e65360c49a 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -284,8 +284,22 @@ extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
-extern void allow_signal(int);
-extern void disallow_signal(int);
+extern void kernel_sigaction(int, __sighandler_t);
+
+static inline void allow_signal(int sig)
+{
+	/*
+	 * Kernel threads handle their own signals. Let the signal code
+	 * know it'll be handled, so that they don't get converted to
+	 * SIGKILL or just silently dropped.
+	 */
+	kernel_sigaction(sig, (__force __sighandler_t)2);
+}
+
+static inline void disallow_signal(int sig)
+{
+	kernel_sigaction(sig, SIG_IGN);
+}
 
 /*
  * Eventually that'll replace get_signal_to_deliver(); macro for now,

commit 0341729b4b832e753c5e745c6ba0e797f6198be0
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Jun 6 14:36:53 2014 -0700

    signals: mv {dis,}allow_signal() from sched.h/exit.c to signal.[ch]
    
    Move the declaration/definition of allow_signal/disallow_signal to
    signal.h/signal.c.  The new place is more logical and allows to use the
    static helpers in signal.c (see the next changes).
    
    While at it, make them return void and remove the valid_signal() check.
    Nobody checks the returned value, and in-kernel users must not pass the
    wrong signal number.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ae744c314630..ac83c593f4b9 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -284,6 +284,8 @@ extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,
 extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
+extern void allow_signal(int);
+extern void disallow_signal(int);
 
 /*
  * Eventually that'll replace get_signal_to_deliver(); macro for now,

commit 36fac0a214805bd7c8307cad1cde60a7b833266d
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Jun 6 14:36:45 2014 -0700

    signals: kill sigfindinword()
    
    It has no users and it doesn't look useful.  I do not know why/when it was
    introduced, I can't even find any user in the git history.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 2ac423bdb676..ae744c314630 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -63,11 +63,6 @@ static inline int sigismember(sigset_t *set, int _sig)
 		return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
 }
 
-static inline int sigfindinword(unsigned long word)
-{
-	return ffz(~word);
-}
-
 #endif /* __HAVE_ARCH_SIG_BITOPS */
 
 static inline int sigisemptyset(sigset_t *set)

commit bd1c149aa9915b9abb6d83d0f01dfd2ace0680b5
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Sep 1 20:35:01 2013 +0100

    Introduce [compat_]save_altstack_ex() to unbreak x86 SMAP
    
    For performance reasons, when SMAP is in use, SMAP is left open for an
    entire put_user_try { ... } put_user_catch(); block, however, calling
    __put_user() in the middle of that block will close SMAP as the
    STAC..CLAC constructs intentionally do not nest.
    
    Furthermore, using __put_user() rather than put_user_ex() here is bad
    for performance.
    
    Thus, introduce new [compat_]save_altstack_ex() helpers that replace
    __[compat_]save_altstack() for x86, being currently the only
    architecture which supports put_user_try { ... } put_user_catch().
    
    Reported-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: <stable@vger.kernel.org> # v3.8+
    Link: http://lkml.kernel.org/n/tip-es5p6y64if71k8p5u08agv9n@git.kernel.org

diff --git a/include/linux/signal.h b/include/linux/signal.h
index d897484730c0..2ac423bdb676 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -434,6 +434,14 @@ void signals_init(void);
 int restore_altstack(const stack_t __user *);
 int __save_altstack(stack_t __user *, unsigned long);
 
+#define save_altstack_ex(uss, sp) do { \
+	stack_t __user *__uss = uss; \
+	struct task_struct *t = current; \
+	put_user_ex((void __user *)t->sas_ss_sp, &__uss->ss_sp); \
+	put_user_ex(sas_ss_flags(sp), &__uss->ss_flags); \
+	put_user_ex(t->sas_ss_size, &__uss->ss_size); \
+} while (0);
+
 #ifdef CONFIG_PROC_FS
 struct seq_file;
 extern void render_sigset_t(struct seq_file *, const char *, sigset_t *);

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit 34db8aaf0f95ffac407d39da22972b38da631db4
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 02:29:19 2013 +0100

    proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
    
    Move some bits from linux/proc_fs.h to linux/of.h, signal.h and tty.h.
    
    Also move proc_tty_init() and proc_device_tree_init() to fs/proc/internal.h as
    they're internal to procfs.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    cc: devicetree-discuss@lists.ozlabs.org
    cc: linux-arch@vger.kernel.org
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Jri Slaby <jslaby@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index a2dcb94ea49d..1135e3696e81 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -434,4 +434,9 @@ void signals_init(void);
 int restore_altstack(const stack_t __user *);
 int __save_altstack(stack_t __user *, unsigned long);
 
+#ifdef CONFIG_PROC_FS
+struct seq_file;
+extern void render_sigset_t(struct seq_file *, const char *, sigset_t *);
+#endif
+
 #endif /* _LINUX_SIGNAL_H */

commit 2a1486981c1317dc4f4aad568f2cc6e49dfb8c82
Author: David Howells <dhowells@redhat.com>
Date:   Tue Mar 19 14:00:53 2013 +0000

    Fix breakage in MIPS siginfo handling
    
    MIPS's siginfo handling has been broken since this commit:
    
            commit 574c4866e33d648520a8bd5bf6f573ea6e554e88
            Author: Al Viro <viro@zeniv.linux.org.uk>
            Date:   Sun Nov 25 22:24:19 2012 -0500
            consolidate kernel-side struct sigaction declarations
    
    for 64-bit BE MIPS CPUs.
    
    The UAPI variant looks like this:
    
            struct sigaction {
                    unsigned int    sa_flags;
                    __sighandler_t  sa_handler;
                    sigset_t        sa_mask;
            };
    
    but the core kernel's variant looks like this:
    
            struct sigaction {
            #ifndef __ARCH_HAS_ODD_SIGACTION
                    __sighandler_t  sa_handler;
                    unsigned long   sa_flags;
            #else
                    unsigned long   sa_flags;
                    __sighandler_t  sa_handler;
            #endif
            #ifdef __ARCH_HAS_SA_RESTORER
                    __sigrestore_t sa_restorer;
            #endif
                    sigset_t        sa_mask;
            };
    
    The problem is that sa_flags has been changed from an unsigned int to an
    unsigned long.
    
    Fix this by making sa_flags unsigned int if __ARCH_HAS_ODD_SIGACTION is
    defined.
    
    Whilst we're at it, rename __ARCH_HAS_ODD_SIGACTION to
    __ARCH_HAS_IRIX_SIGACTION.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: stable@vger.kernel.org
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index a2dcb94ea49d..9475c5cb28bc 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -250,11 +250,11 @@ extern int show_unhandled_signals;
 extern int sigsuspend(sigset_t *);
 
 struct sigaction {
-#ifndef __ARCH_HAS_ODD_SIGACTION
+#ifndef __ARCH_HAS_IRIX_SIGACTION
 	__sighandler_t	sa_handler;
 	unsigned long	sa_flags;
 #else
-	unsigned long	sa_flags;
+	unsigned int	sa_flags;
 	__sighandler_t	sa_handler;
 #endif
 #ifdef __ARCH_HAS_SA_RESTORER

commit 2ce5da17570771330f44ac993b77749debf7954b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 7 15:11:25 2012 -0500

    new helper: signal_setup_done()
    
    usual "call force_sigsegv or signal_delivered" logics.  Takes
    ksignal instead of separate siginfo/k_sigaction.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7c2744198dba..a2dcb94ea49d 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -286,6 +286,7 @@ struct ksignal {
 };
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+extern void signal_setup_done(int failed, struct ksignal *ksig, int stepping);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 

commit ca86b5dce213f52c7538932740f83cafb2c34547
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 7 15:09:38 2012 -0500

    new helper: get_signal()
    
    On success get_signal_to_deliver() fills k_sigaction and siginfo.
    _All_ users pass it addresses of the local variables sitting in
    the same function.  Then they proceed to pass those addresses
    pretty much in tandem to a bunch of helper functions; again, all
    callers of those helpers are passing them such a pair, and one that
    had been through get_signal_to_deliver() at that.
    
    The obvious cleanup: introduce a new type that would contain a
    <k_sigaction,siginfo> pair (struct ksignal) and begin switching to
    using it.  Turns out that it's convenient to store the signal number
    in the same object.
    
    New helper, taking that sucker is a wrapper for get_signal_to_deliver();
    takes struct ksignal * and returns bool.  On success fills ksignal
    with the information for signal handler to be invoked.
    
    For now it's a macro (to avoid header ordering headache), but eventually
    it'll be a function in kernel/signal.c, with get_signal_to_deliver()
    folded into it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index e28e8d455d6e..7c2744198dba 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -279,10 +279,28 @@ struct old_sigaction {
 };
 #endif
 
+struct ksignal {
+	struct k_sigaction ka;
+	siginfo_t info;
+	int sig;
+};
+
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 
+/*
+ * Eventually that'll replace get_signal_to_deliver(); macro for now,
+ * to avoid nastiness with include order.
+ */
+#define get_signal(ksig)					\
+({								\
+	struct ksignal *p = (ksig);				\
+	p->sig = get_signal_to_deliver(&p->info, &p->ka,	\
+					signal_pt_regs(), NULL);\
+	p->sig > 0;						\
+})
+
 extern struct kmem_cache *sighand_cachep;
 
 int unhandled_signal(struct task_struct *tsk, int sig);

commit 495dfbf767553980dbd40a19a96a8ca5fa1be616
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 25 19:09:45 2012 -0500

    generic sys_sigaction() and compat_sys_sigaction()
    
    conditional on OLD_SIGACTION/COMPAT_OLD_SIGACTION
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 0b6878e882da..e28e8d455d6e 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -269,6 +269,15 @@ struct k_sigaction {
 	__sigrestore_t ka_restorer;
 #endif
 };
+ 
+#ifdef CONFIG_OLD_SIGACTION
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+};
+#endif
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);

commit 574c4866e33d648520a8bd5bf6f573ea6e554e88
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 25 22:24:19 2012 -0500

    consolidate kernel-side struct sigaction declarations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 01451a156ff7..0b6878e882da 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -249,6 +249,20 @@ extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 extern int sigsuspend(sigset_t *);
 
+struct sigaction {
+#ifndef __ARCH_HAS_ODD_SIGACTION
+	__sighandler_t	sa_handler;
+	unsigned long	sa_flags;
+#else
+	unsigned long	sa_flags;
+	__sighandler_t	sa_handler;
+#endif
+#ifdef __ARCH_HAS_SA_RESTORER
+	__sigrestore_t sa_restorer;
+#endif
+	sigset_t	sa_mask;	/* mask last for extensibility */
+};
+
 struct k_sigaction {
 	struct sigaction sa;
 #ifdef __ARCH_HAS_KA_RESTORER

commit 92a3ce4a1e0047215aa0a0b30cc333bd32b866a8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 25 21:20:05 2012 -0500

    consolidate declarations of k_sigaction
    
    Only alpha and sparc are unusual - they have ka_restorer in it.
    And nobody needs that exposed to userland.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ed1e71f1aac7..01451a156ff7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -249,6 +249,13 @@ extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 extern int sigsuspend(sigset_t *);
 
+struct k_sigaction {
+	struct sigaction sa;
+#ifdef __ARCH_HAS_KA_RESTORER
+	__sigrestore_t ka_restorer;
+#endif
+};
+
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);

commit 9aae8fc05d2d130797be436eb7cae29c32710193
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 24 23:12:04 2012 -0500

    switch rt_tgsigqueueinfo to COMPAT_SYSCALL_DEFINE
    
    C ABI violations on sparc, ppc and mips
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 786bd99fde65..ed1e71f1aac7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -241,8 +241,6 @@ extern int do_send_sig_info(int sig, struct siginfo *info,
 				struct task_struct *p, bool group);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
-extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
-				 siginfo_t *info);
 extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
 				const struct timespec *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);

commit fe9c1db2cfc363cd30ecfe6480481b280abf8c0a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 25 14:31:38 2012 -0500

    generic compat_sys_rt_sigpending()
    
    conditional on GENERIC_COMPAT_RT_SIGPENDING; by the end of that series
    it will become the same thing as COMPAT and conditional will die out.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 0a89ffc48466..786bd99fde65 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -243,7 +243,6 @@ extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
 				 siginfo_t *info);
-extern long do_sigpending(void __user *, unsigned long);
 extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
 				const struct timespec *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);

commit c40702c49faef05ae324f121d8b3e215244ee152
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 20 14:24:26 2012 -0500

    new helpers: __save_altstack/__compat_save_altstack, switch x86 and um to those
    
    note that they are relying on access_ok() already checked by caller.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 5969522136fe..0a89ffc48466 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -386,5 +386,6 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 void signals_init(void);
 
 int restore_altstack(const stack_t __user *);
+int __save_altstack(stack_t __user *, unsigned long);
 
 #endif /* _LINUX_SIGNAL_H */

commit 5c49574ffd7ac07eae8c3b065d19e6ebc7e4760f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 18 15:29:16 2012 -0500

    new helper: restore_altstack()
    
    to be used by rt_sigreturn instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index e19a011b43b7..5969522136fe 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -385,4 +385,6 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 
 void signals_init(void);
 
+int restore_altstack(const stack_t __user *);
+
 #endif /* _LINUX_SIGNAL_H */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 26b424adc842..e19a011b43b7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -1,11 +1,8 @@
 #ifndef _LINUX_SIGNAL_H
 #define _LINUX_SIGNAL_H
 
-#include <asm/signal.h>
-#include <asm/siginfo.h>
-
-#ifdef __KERNEL__
 #include <linux/list.h>
+#include <uapi/linux/signal.h>
 
 struct task_struct;
 
@@ -388,6 +385,4 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 
 void signals_init(void);
 
-#endif /* __KERNEL__ */
-
 #endif /* _LINUX_SIGNAL_H */

commit efee984c27b67e3ebef40410f35671997441b57c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 28 02:04:15 2012 -0400

    new helper: signal_delivered()
    
    Does block_sigmask() + tracehook_signal_handler();  called when
    sigframe has been successfully built.  All architectures converted
    to it; block_sigmask() itself is gone now (merged into this one).
    
    I'm still not too happy with the signature, but that's a separate
    story (IMO we need a structure that would contain signal number +
    siginfo + k_sigaction, so that get_signal_to_deliver() would fill one,
    signal_delivered(), handle_signal() and probably setup...frame() -
    take one).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 065e76330398..26b424adc842 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -256,7 +256,7 @@ extern int show_unhandled_signals;
 extern int sigsuspend(sigset_t *);
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
-extern void block_sigmask(struct k_sigaction *ka, int signr);
+extern void signal_delivered(int sig, siginfo_t *info, struct k_sigaction *ka, struct pt_regs *regs, int stepping);
 extern void exit_signals(struct task_struct *tsk);
 
 extern struct kmem_cache *sighand_cachep;

commit 77097ae503b170120ab66dd1d547f8577193f91f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 27 13:58:59 2012 -0400

    most of set_current_blocked() callers want SIGKILL/SIGSTOP removed from set
    
    Only 3 out of 63 do not.  Renamed the current variant to __set_current_blocked(),
    added set_current_blocked() that will exclude unblockable signals, switched
    open-coded instances to it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 17046cc484bc..065e76330398 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -250,7 +250,8 @@ extern long do_sigpending(void __user *, unsigned long);
 extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
 				const struct timespec *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
-extern void set_current_blocked(const sigset_t *);
+extern void set_current_blocked(sigset_t *);
+extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 extern int sigsuspend(sigset_t *);
 

commit 68f3f16d9ad0f1e28ab3fd0001ab5798c41f15a3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 21 21:42:32 2012 -0400

    new helper: sigsuspend()
    
    guts of saved_sigmask-based sigsuspend/rt_sigsuspend.  Takes
    kernel sigset_t *.
    
    Open-coded instances replaced with calling it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7987ce74874b..17046cc484bc 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -252,6 +252,7 @@ extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
+extern int sigsuspend(sigset_t *);
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void block_sigmask(struct k_sigaction *ka, int signr);

commit 5e6292c0f28f03dfdb8ea3d685f0b838a23bfba4
Author: Matt Fleming <matt.fleming@intel.com>
Date:   Tue Jan 10 15:11:17 2012 -0800

    signal: add block_sigmask() for adding sigmask to current->blocked
    
    Abstract the code sequence for adding a signal handler's sa_mask to
    current->blocked because the sequence is identical for all architectures.
    Furthermore, in the past some architectures actually got this code wrong,
    so introduce a wrapper that all architectures can use.
    
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index a822300a253b..7987ce74874b 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -254,6 +254,7 @@ extern void set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+extern void block_sigmask(struct k_sigaction *ka, int signr);
 extern void exit_signals(struct task_struct *tsk);
 
 extern struct kmem_cache *sighand_cachep;

commit 3ed4c0583daa34dedb568b26ff99e5a7b58db612
Merge: ad9471752eba bd715d9a4f13
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 13:33:21 2011 -0700

    Merge branch 'ptrace' of git://git.kernel.org/pub/scm/linux/kernel/git/oleg/misc
    
    * 'ptrace' of git://git.kernel.org/pub/scm/linux/kernel/git/oleg/misc: (41 commits)
      signal: trivial, fix the "timespec declared inside parameter list" warning
      job control: reorganize wait_task_stopped()
      ptrace: fix signal->wait_chldexit usage in task_clear_group_stop_trapping()
      signal: sys_sigprocmask() needs retarget_shared_pending()
      signal: cleanup sys_sigprocmask()
      signal: rename signandsets() to sigandnsets()
      signal: do_sigtimedwait() needs retarget_shared_pending()
      signal: introduce do_sigtimedwait() to factor out compat/native code
      signal: sys_rt_sigtimedwait: simplify the timeout logic
      signal: cleanup sys_rt_sigprocmask()
      x86: signal: sys_rt_sigreturn() should use set_current_blocked()
      x86: signal: handle_signal() should use set_current_blocked()
      signal: sigprocmask() should do retarget_shared_pending()
      signal: sigprocmask: narrow the scope of ->siglock
      signal: retarget_shared_pending: optimize while_each_thread() loop
      signal: retarget_shared_pending: consider shared/unblocked signals only
      signal: introduce retarget_shared_pending()
      ptrace: ptrace_check_attach() should not do s/STOPPED/TRACED/
      signal: Turn SIGNAL_STOP_DEQUEUED into GROUP_STOP_DEQUEUED
      signal: do_signal_stop: Remove the unneeded task_clear_group_stop_pending()
      ...

commit 1477fcc290b3d5c2614bde98bf3b1154c538860d
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri May 20 11:11:53 2011 +1000

    signal.h need a definition of struct task_struct
    
    This fixes these build errors on powerpc:
    
      In file included from arch/powerpc/mm/fault.c:18:
      include/linux/signal.h:239: error: 'struct task_struct' declared inside parameter list
      include/linux/signal.h:239: error: its scope is only this definition or declaration, which is probably not what you want
      include/linux/signal.h:240: error: 'struct task_struct' declared inside parameter list
      ..
    
    Exposed by commit e66eed651fd1 ("list: remove prefetching from regular
    list iterators"), which removed the include of <linux/prefetch.h> from
    <linux/list.h>.
    
    Without that, linux/signal.h no longer accidentally got the declaration
    of 'struct task_struct'.
    
    Fix by properly declaring the struct, rather than introducing any new
    header file dependency.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index fcd2b14b1932..29a68ac7af83 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -7,6 +7,8 @@
 #ifdef __KERNEL__
 #include <linux/list.h>
 
+struct task_struct;
+
 /* for sysctl */
 extern int print_fatal_signals;
 /*

commit b2b07e4fdbc51383cfc0ba5618c2ddf5c9d038f2
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed May 18 15:08:03 2011 +0200

    signal: trivial, fix the "timespec declared inside parameter list" warning
    
    Fix the compile warning, do_sigtimedwait(struct timespec *) in signal.h
    needs the forward declaration of timespec.
    
    Reported-and-acked-by: Mike Frysinger <vapier.adi@gmail.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7e2526374fd7..a44e7f062238 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -234,6 +234,9 @@ static inline int valid_signal(unsigned long sig)
 	return sig <= _NSIG ? 1 : 0;
 }
 
+struct timespec;
+struct pt_regs;
+
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int do_send_sig_info(int sig, struct siginfo *info,
 				struct task_struct *p, bool group);
@@ -248,7 +251,6 @@ extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 
-struct pt_regs;
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 extern void exit_signals(struct task_struct *tsk);
 

commit 702a5073fdb71eb29cd4912575289fb5044c1894
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Apr 27 22:01:27 2011 +0200

    signal: rename signandsets() to sigandnsets()
    
    As Tejun and Linus pointed out, "nand" is the wrong name for "x & ~y",
    it should be "andn". Rename signandsets() as suggested.
    
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 782546d661ba..7e2526374fd7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -123,13 +123,13 @@ _SIG_SET_BINOP(sigorsets, _sig_or)
 #define _sig_and(x,y)	((x) & (y))
 _SIG_SET_BINOP(sigandsets, _sig_and)
 
-#define _sig_nand(x,y)	((x) & ~(y))
-_SIG_SET_BINOP(signandsets, _sig_nand)
+#define _sig_andn(x,y)	((x) & ~(y))
+_SIG_SET_BINOP(sigandnsets, _sig_andn)
 
 #undef _SIG_SET_BINOP
 #undef _sig_or
 #undef _sig_and
-#undef _sig_nand
+#undef _sig_andn
 
 #define _SIG_SET_OP(name, op)						\
 static inline void name(sigset_t *set)					\

commit 943df1485a8ff0e600729e082e568ece04d4de9e
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Apr 27 21:44:14 2011 +0200

    signal: introduce do_sigtimedwait() to factor out compat/native code
    
    Factor out the common code in sys_rt_sigtimedwait/compat_sys_rt_sigtimedwait
    to the new helper, do_sigtimedwait().
    
    Add the comment to document the extra tick we add to timespec_to_jiffies(ts),
    thanks to Linus who explained this to me.
    
    Perhaps it would be better to move compat_sys_rt_sigtimedwait() into
    signal.c under CONFIG_COMPAT, then we can make do_sigtimedwait() static.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Matt Fleming <matt.fleming@linux.intel.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ba009c167275..782546d661ba 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -242,6 +242,8 @@ extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
 				 siginfo_t *info);
 extern long do_sigpending(void __user *, unsigned long);
+extern int do_sigtimedwait(const sigset_t *, siginfo_t *,
+				const struct timespec *);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;

commit e6fa16ab9c1e9b344428e6fea4d29e3cc4b28fb0
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Apr 27 20:59:41 2011 +0200

    signal: sigprocmask() should do retarget_shared_pending()
    
    In short, almost every changing of current->blocked is wrong, or at least
    can lead to the unexpected results.
    
    For example. Two threads T1 and T2, T1 sleeps in sigtimedwait/pause/etc.
    kill(tgid, SIG) can pick T2 for TIF_SIGPENDING. If T2 calls sigprocmask()
    and blocks SIG before it notices the pending signal, nobody else can handle
    this pending shared signal.
    
    I am not sure this is bug, but at least this looks strange imho. T1 should
    not sleep forever, there is a signal which should wake it up.
    
    This patch moves the code which actually changes ->blocked into the new
    helper, set_current_blocked() and changes this code to call
    retarget_shared_pending() as exit_signals() does. We should only care about
    the signals we just blocked, we use "newset & ~current->blocked" as a mask.
    
    We do not check !sigisemptyset(newblocked), retarget_shared_pending() is
    cheap unless mask & shared_pending.
    
    Note: for this particular case we could simply change sigprocmask() to
    return -EINTR if signal_pending(), but then we should change other callers
    and, more importantly, if we need this fix then set_current_blocked() will
    have more callers and some of them can't restart. See the next patch as a
    random example.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Matt Fleming <matt.fleming@linux.intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index fcd2b14b1932..ba009c167275 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -243,6 +243,7 @@ extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
 				 siginfo_t *info);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
+extern void set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
 
 struct pt_regs;

commit d33ed52d57e794eba55cea3f5eab3c8f80b6cb5a
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Wed Mar 10 15:23:59 2010 -0800

    sysctl extern cleanup: signal
    
    Extern declarations in sysctl.c should be moved to their own header file,
    and then include them in relavant .c files.
    
    Move print_fatal_signals extern declaration to linux/signal.h
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ab9272cc270c..fcd2b14b1932 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -7,6 +7,8 @@
 #ifdef __KERNEL__
 #include <linux/list.h>
 
+/* for sysctl */
+extern int print_fatal_signals;
 /*
  * Real Time signals may be queued.
  */

commit 4a30debfb778240a4b1767d4b0c5a5b25ab97160
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Sep 23 15:57:00 2009 -0700

    signals: introduce do_send_sig_info() helper
    
    Introduce do_send_sig_info() and convert group_send_sig_info(),
    send_sig_info(), do_send_specific() to use this helper.
    
    Hopefully it will have more users soon, it allows to specify
    specific/group behaviour via "bool group" argument.
    
    Shaves 80 bytes from .text.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: stephane eranian <eranian@googlemail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index c7552836bd95..ab9272cc270c 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -233,6 +233,8 @@ static inline int valid_signal(unsigned long sig)
 }
 
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
+extern int do_send_sig_info(int sig, struct siginfo *info,
+				struct task_struct *p, bool group);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,

commit 62ab4505e3efaf67784f84059e0fb9cedb1728ea
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 4 21:01:06 2009 +0000

    signals: implement sys_rt_tgsigqueueinfo
    
    sys_kill has the per thread counterpart sys_tgkill. sigqueueinfo is
    missing a thread directed counterpart. Such an interface is important
    for migrating applications from other OSes which have the per thread
    delivery implemented.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Roland McGrath <roland@redhat.com>
    Acked-by: Ulrich Drepper <drepper@redhat.com>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 84f997f8aa53..c7552836bd95 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -235,6 +235,8 @@ static inline int valid_signal(unsigned long sig)
 extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+extern long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig,
+				 siginfo_t *info);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern int show_unhandled_signals;

commit 6ca25b551309eb1b1b41f83414a92f7472e0b23d
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Wed Apr 30 00:52:45 2008 -0700

    kill_pid_info: don't take now unneeded tasklist_lock
    
    Previously handle_stop_signal(SIGCONT) could drop ->siglock.  That is why
    kill_pid_info(SIGCONT) takes tasklist_lock to make sure the target task can't
    go away after unlock.  Not needed now.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 42d2e0a948f4..84f997f8aa53 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -362,8 +362,6 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 #define sig_kernel_stop(sig) \
 	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_STOP_MASK))
 
-#define sig_needs_tasklist(sig)	((sig) == SIGCONT)
-
 #define sig_user_defined(t, signr) \
 	(((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_DFL) &&	\
 	 ((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_IGN))

commit d12619b5ff5664623524aef796514d1946ea3b4a
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Fri Feb 8 04:19:12 2008 -0800

    fix group stop with exit race
    
    do_signal_stop() counts all sub-thread and sets ->group_stop_count
    accordingly.  Every thread should decrement ->group_stop_count and stop,
    the last one should notify the parent.
    
    However a sub-thread can exit before it notices the signal_pending(), or it
    may be somewhere in do_exit() already.  In that case the group stop never
    finishes properly.
    
    Note: this is a minimal fix, we can add some optimizations later.  Say we
    can return quickly if thread_group_empty().  Also, we can move some signal
    related code from exit_notify() to exit_signals().
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7e095147656c..42d2e0a948f4 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -241,6 +241,7 @@ extern int show_unhandled_signals;
 
 struct pt_regs;
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+extern void exit_signals(struct task_struct *tsk);
 
 extern struct kmem_cache *sighand_cachep;
 

commit a1c9eea9e56a7196c6891f6426b799c4598b38e2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 6 01:36:44 2008 -0800

    proper prototype for signals_init()
    
    Add a proper prototype for signals_init() in include/linux/signal.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 0ae338866240..7e095147656c 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -371,6 +371,8 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 	(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) && \
 	 (t)->sighand->action[(signr)-1].sa.sa_handler == SIG_DFL)
 
+void signals_init(void);
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SIGNAL_H */

commit abd4f7505bafdd6c5319fe3cb5caf9af6104e17a
Author: Masoud Asgharifard Sharbiani <masouds@google.com>
Date:   Sun Jul 22 11:12:28 2007 +0200

    x86: i386-show-unhandled-signals-v3
    
    This patch makes the i386 behave the same way that x86_64 does when a
    segfault happens.  A line gets printed to the kernel log so that tools
    that need to check for failures can behave more uniformly between
    debug.show_unhandled_signals sysctl variable to 0 (or by doing echo 0 >
    /proc/sys/debug/exception-trace)
    
    Also, all of the lines being printed are now using printk_ratelimit() to
    deny the ability of DoS from a local user with a program like the
    following:
    
    main()
    {
           while (1)
                   if (!fork()) *(int *)0 = 0;
    }
    
    This new revision also includes the fix that Andrew did which got rid of
    new sysctl that was added to the system in earlier versions of this.
    Also, 'show-unhandled-signals' sysctl has been renamed back to the old
    'exception-trace' to avoid breakage of people's scripts.
    
    AK: Enabling by default for i386 will be likely controversal, but let's see what happens
    AK: Really folks, before complaining just fix your segfaults
    AK: I bet this will find a lot of silent issues
    
    Signed-off-by: Masoud Sharbiani <masouds@google.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    [ Personally, I've found the complaints useful on x86-64, so I'm all for
      this. That said, I wonder if we could do it more prettily..   -Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ea91abe740da..0ae338866240 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -237,12 +237,15 @@ extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
+extern int show_unhandled_signals;
 
 struct pt_regs;
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 
 extern struct kmem_cache *sighand_cachep;
 
+int unhandled_signal(struct task_struct *tsk, int sig);
+
 /*
  * In POSIX a signal is sent either to a specific thread (Linux task)
  * or to the process as a whole (Linux thread group).  How the signal

commit 0a3021f4e249fbdb5f30d614707b5e02022e4c9b
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sun Jul 15 23:39:57 2007 -0700

    Remove unnecessary includes of spinlock.h under include/linux
    
    Remove the obviously unnecessary includes of <linux/spinlock.h> under the
    include/linux/ directory, and fix the couple errors that are introduced as
    a result of that.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 9a5eac508e5e..ea91abe740da 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -6,7 +6,6 @@
 
 #ifdef __KERNEL__
 #include <linux/list.h>
-#include <linux/spinlock.h>
 
 /*
  * Real Time signals may be queued.

commit fba2afaaec790dc5ab4ae8827972f342211bbb86
Author: Davide Libenzi <davidel@xmailserver.org>
Date:   Thu May 10 22:23:13 2007 -0700

    signal/timer/event: signalfd core
    
    This patch series implements the new signalfd() system call.
    
    I took part of the original Linus code (and you know how badly it can be
    broken :), and I added even more breakage ;) Signals are fetched from the same
    signal queue used by the process, so signalfd will compete with standard
    kernel delivery in dequeue_signal().  If you want to reliably fetch signals on
    the signalfd file, you need to block them with sigprocmask(SIG_BLOCK).  This
    seems to be working fine on my Dual Opteron machine.  I made a quick test
    program for it:
    
    http://www.xmailserver.org/signafd-test.c
    
    The signalfd() system call implements signal delivery into a file descriptor
    receiver.  The signalfd file descriptor if created with the following API:
    
    int signalfd(int ufd, const sigset_t *mask, size_t masksize);
    
    The "ufd" parameter allows to change an existing signalfd sigmask, w/out going
    to close/create cycle (Linus idea).  Use "ufd" == -1 if you want a brand new
    signalfd file.
    
    The "mask" allows to specify the signal mask of signals that we are interested
    in.  The "masksize" parameter is the size of "mask".
    
    The signalfd fd supports the poll(2) and read(2) system calls.  The poll(2)
    will return POLLIN when signals are available to be dequeued.  As a direct
    consequence of supporting the Linux poll subsystem, the signalfd fd can use
    used together with epoll(2) too.
    
    The read(2) system call will return a "struct signalfd_siginfo" structure in
    the userspace supplied buffer.  The return value is the number of bytes copied
    in the supplied buffer, or -1 in case of error.  The read(2) call can also
    return 0, in case the sighand structure to which the signalfd was attached,
    has been orphaned.  The O_NONBLOCK flag is also supported, and read(2) will
    return -EAGAIN in case no signal is available.
    
    If the size of the buffer passed to read(2) is lower than sizeof(struct
    signalfd_siginfo), -EINVAL is returned.  A read from the signalfd can also
    return -ERESTARTSYS in case a signal hits the process.  The format of the
    struct signalfd_siginfo is, and the valid fields depends of the (->code &
    __SI_MASK) value, in the same way a struct siginfo would:
    
    struct signalfd_siginfo {
            __u32 signo;    /* si_signo */
            __s32 err;      /* si_errno */
            __s32 code;     /* si_code */
            __u32 pid;      /* si_pid */
            __u32 uid;      /* si_uid */
            __s32 fd;       /* si_fd */
            __u32 tid;      /* si_fd */
            __u32 band;     /* si_band */
            __u32 overrun;  /* si_overrun */
            __u32 trapno;   /* si_trapno */
            __s32 status;   /* si_status */
            __s32 svint;    /* si_int */
            __u64 svptr;    /* si_ptr */
            __u64 utime;    /* si_utime */
            __u64 stime;    /* si_stime */
            __u64 addr;     /* si_addr */
    };
    
    [akpm@linux-foundation.org: fix signalfd_copyinfo() on i386]
    Signed-off-by: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 3fa0fab4a04b..9a5eac508e5e 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -233,6 +233,7 @@ static inline int valid_signal(unsigned long sig)
 	return sig <= _NSIG ? 1 : 0;
 }
 
+extern int next_signal(struct sigpending *pending, sigset_t *mask);
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_sigpending(void __user *, unsigned long);

commit 55c0d1f83e481dd6c77f52f7dcfeb043b8b740fa
Author: Roland McGrath <roland@redhat.com>
Date:   Wed May 9 02:33:37 2007 -0700

    Move sig_kernel_* et al macros to linux/signal.h
    
    This patch moves the sig_kernel_* and related macros from kernel/signal.c
    to linux/signal.h, and cleans them up slightly.  I need the sig_kernel_*
    macros for default signal behavior in the utrace code, and want to avoid
    duplication or overhead to share the knowledge.
    
    Signed-off-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 14749056dd63..3fa0fab4a04b 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -243,6 +243,131 @@ extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,
 
 extern struct kmem_cache *sighand_cachep;
 
+/*
+ * In POSIX a signal is sent either to a specific thread (Linux task)
+ * or to the process as a whole (Linux thread group).  How the signal
+ * is sent determines whether it's to one thread or the whole group,
+ * which determines which signal mask(s) are involved in blocking it
+ * from being delivered until later.  When the signal is delivered,
+ * either it's caught or ignored by a user handler or it has a default
+ * effect that applies to the whole thread group (POSIX process).
+ *
+ * The possible effects an unblocked signal set to SIG_DFL can have are:
+ *   ignore	- Nothing Happens
+ *   terminate	- kill the process, i.e. all threads in the group,
+ * 		  similar to exit_group.  The group leader (only) reports
+ *		  WIFSIGNALED status to its parent.
+ *   coredump	- write a core dump file describing all threads using
+ *		  the same mm and then kill all those threads
+ *   stop 	- stop all the threads in the group, i.e. TASK_STOPPED state
+ *
+ * SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
+ * Other signals when not blocked and set to SIG_DFL behaves as follows.
+ * The job control signals also have other special effects.
+ *
+ *	+--------------------+------------------+
+ *	|  POSIX signal      |  default action  |
+ *	+--------------------+------------------+
+ *	|  SIGHUP            |  terminate	|
+ *	|  SIGINT            |	terminate	|
+ *	|  SIGQUIT           |	coredump 	|
+ *	|  SIGILL            |	coredump 	|
+ *	|  SIGTRAP           |	coredump 	|
+ *	|  SIGABRT/SIGIOT    |	coredump 	|
+ *	|  SIGBUS            |	coredump 	|
+ *	|  SIGFPE            |	coredump 	|
+ *	|  SIGKILL           |	terminate(+)	|
+ *	|  SIGUSR1           |	terminate	|
+ *	|  SIGSEGV           |	coredump 	|
+ *	|  SIGUSR2           |	terminate	|
+ *	|  SIGPIPE           |	terminate	|
+ *	|  SIGALRM           |	terminate	|
+ *	|  SIGTERM           |	terminate	|
+ *	|  SIGCHLD           |	ignore   	|
+ *	|  SIGCONT           |	ignore(*)	|
+ *	|  SIGSTOP           |	stop(*)(+)  	|
+ *	|  SIGTSTP           |	stop(*)  	|
+ *	|  SIGTTIN           |	stop(*)  	|
+ *	|  SIGTTOU           |	stop(*)  	|
+ *	|  SIGURG            |	ignore   	|
+ *	|  SIGXCPU           |	coredump 	|
+ *	|  SIGXFSZ           |	coredump 	|
+ *	|  SIGVTALRM         |	terminate	|
+ *	|  SIGPROF           |	terminate	|
+ *	|  SIGPOLL/SIGIO     |	terminate	|
+ *	|  SIGSYS/SIGUNUSED  |	coredump 	|
+ *	|  SIGSTKFLT         |	terminate	|
+ *	|  SIGWINCH          |	ignore   	|
+ *	|  SIGPWR            |	terminate	|
+ *	|  SIGRTMIN-SIGRTMAX |	terminate       |
+ *	+--------------------+------------------+
+ *	|  non-POSIX signal  |  default action  |
+ *	+--------------------+------------------+
+ *	|  SIGEMT            |  coredump	|
+ *	+--------------------+------------------+
+ *
+ * (+) For SIGKILL and SIGSTOP the action is "always", not just "default".
+ * (*) Special job control effects:
+ * When SIGCONT is sent, it resumes the process (all threads in the group)
+ * from TASK_STOPPED state and also clears any pending/queued stop signals
+ * (any of those marked with "stop(*)").  This happens regardless of blocking,
+ * catching, or ignoring SIGCONT.  When any stop signal is sent, it clears
+ * any pending/queued SIGCONT signals; this happens regardless of blocking,
+ * catching, or ignored the stop signal, though (except for SIGSTOP) the
+ * default action of stopping the process may happen later or never.
+ */
+
+#ifdef SIGEMT
+#define SIGEMT_MASK	rt_sigmask(SIGEMT)
+#else
+#define SIGEMT_MASK	0
+#endif
+
+#if SIGRTMIN > BITS_PER_LONG
+#define rt_sigmask(sig)	(1ULL << ((sig)-1))
+#else
+#define rt_sigmask(sig)	sigmask(sig)
+#endif
+#define siginmask(sig, mask) (rt_sigmask(sig) & (mask))
+
+#define SIG_KERNEL_ONLY_MASK (\
+	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
+
+#define SIG_KERNEL_STOP_MASK (\
+	rt_sigmask(SIGSTOP)   |  rt_sigmask(SIGTSTP)   | \
+	rt_sigmask(SIGTTIN)   |  rt_sigmask(SIGTTOU)   )
+
+#define SIG_KERNEL_COREDUMP_MASK (\
+        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
+	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
+        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
+	rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
+        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
+	SIGEMT_MASK				       )
+
+#define SIG_KERNEL_IGNORE_MASK (\
+        rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \
+	rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )
+
+#define sig_kernel_only(sig) \
+	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_ONLY_MASK))
+#define sig_kernel_coredump(sig) \
+	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_COREDUMP_MASK))
+#define sig_kernel_ignore(sig) \
+	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_IGNORE_MASK))
+#define sig_kernel_stop(sig) \
+	(((sig) < SIGRTMIN) && siginmask(sig, SIG_KERNEL_STOP_MASK))
+
+#define sig_needs_tasklist(sig)	((sig) == SIGCONT)
+
+#define sig_user_defined(t, signr) \
+	(((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_DFL) &&	\
+	 ((t)->sighand->action[(signr)-1].sa.sa_handler != SIG_IGN))
+
+#define sig_fatal(t, signr) \
+	(!siginmask(signr, SIG_KERNEL_IGNORE_MASK|SIG_KERNEL_STOP_MASK) && \
+	 (t)->sighand->action[(signr)-1].sa.sa_handler == SIG_DFL)
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SIGNAL_H */

commit 298ec1e2ac85cecce3eddd167286359358c44d5d
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:32:47 2006 -0800

    [PATCH] Move sighand_cachep to include/signal.h
    
    Move sighand_cachep definitioni to linux/signal.h
    
    The sighand cache is only used in fs/exec.c and kernel/fork.c.  It is defined
    in kernel/fork.c but only used in fs/exec.c.
    
    The sighand_cachep is related to signal processing.  So add the definition to
    signal.h.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 117135e33d67..14749056dd63 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -241,6 +241,8 @@ extern int sigprocmask(int, sigset_t *, sigset_t *);
 struct pt_regs;
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
 
+extern struct kmem_cache *sighand_cachep;
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SIGNAL_H */

commit 6e21361619328751e2637b004e14cf360aafbddc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:03 2006 -0700

    [PATCH] irq-flags: consolidate flags for request_irq
    
    The recent interrupt rework introduced bit value conflicts with sparc.
    Instead of introducing new architecture flags mess, move the interrupt SA_
    flags out of the signal namespace and replace them by interrupt related flags.
    
    This allows to remove the obsolete SA_INTERRUPT flag and clean up the bit
    field values.
    
    This patch:
    
    Move the interrupt related SA_ flags out of linux/signal.h and rename them to
    IRQF_ .  This moves the interrupt related flags out of the signal namespace
    and allows to remove the architecture dependencies.
    
    SA_INTERRUPT is not needed by userspace and glibc so it can be removed safely.
    
    The existing SA_ constants are kept for easy transition and will be
    removed after a 6 month grace period.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Jody McIntyre <scjody@modernduck.com>
    Cc: Ben Collins <bcollins@debian.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>                                 Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 1e4ce7225eee..117135e33d67 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -8,32 +8,6 @@
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
-/*
- * These values of sa_flags are used only by the kernel as part of the
- * irq handling routines.
- *
- * SA_INTERRUPT is also used by the irq handling routines.
- * SA_SHIRQ is for shared interrupt support on PCI and EISA.
- * SA_PROBEIRQ is set by callers when they expect sharing mismatches to occur
- */
-#define SA_SAMPLE_RANDOM	SA_RESTART
-#define SA_SHIRQ		0x04000000
-#define SA_PROBEIRQ		0x08000000
-
-/*
- * As above, these correspond to the IORESOURCE_IRQ_* defines in
- * linux/ioport.h to select the interrupt line behaviour.  When
- * requesting an interrupt without specifying a SA_TRIGGER, the
- * setting should be assumed to be "as already configured", which
- * may be as per machine or firmware initialisation.
- */
-#define SA_TRIGGER_LOW		0x00000008
-#define SA_TRIGGER_HIGH		0x00000004
-#define SA_TRIGGER_FALLING	0x00000002
-#define SA_TRIGGER_RISING	0x00000001
-#define SA_TRIGGER_MASK	(SA_TRIGGER_HIGH|SA_TRIGGER_LOW|\
-				 SA_TRIGGER_RISING|SA_TRIGGER_FALLING)
-
 /*
  * Real Time signals may be queued.
  */

commit d6754b401a15eaa16492ea5dbaa4826361d3f411
Merge: acc429a517bd 693f7d362055
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Sat Apr 29 01:42:26 2006 +0100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 13e87ec68641fd54f3fa04eef3419d034ed2115a
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Apr 27 18:39:18 2006 -0700

    [PATCH] request_irq(): remove warnings from irq probing
    
    - Add new SA_PROBEIRQ which suppresses the new sharing-mismatch warning.
      Some drivers like to use request_irq() to find an unused interrupt slot.
    
    - Use it in i82365.c
    
    - Kill unused SA_PROBE.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 162a8fd10b29..70739f51a09f 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -14,10 +14,12 @@
  *
  * SA_INTERRUPT is also used by the irq handling routines.
  * SA_SHIRQ is for shared interrupt support on PCI and EISA.
+ * SA_PROBEIRQ is set by callers when they expect sharing mismatches to occur
  */
-#define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+#define SA_PROBEIRQ		0x08000000
+
 /*
  * As above, these correspond to the IORESOURCE_IRQ_* defines in
  * linux/ioport.h to select the interrupt line behaviour.  When

commit 7ab2febd4d3c6f50545cee11a116536a09748d59
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Apr 25 14:55:46 2006 +0100

    Don't include private headers from user-visible part of linux/signal.h
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 162a8fd10b29..4b42df3860ed 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -1,12 +1,12 @@
 #ifndef _LINUX_SIGNAL_H
 #define _LINUX_SIGNAL_H
 
-#include <linux/list.h>
-#include <linux/spinlock.h>
 #include <asm/signal.h>
 #include <asm/siginfo.h>
 
 #ifdef __KERNEL__
+#include <linux/list.h>
+#include <linux/spinlock.h>
 
 /*
  * These values of sa_flags are used only by the kernel as part of the

commit 6a14c5c9da0b4c34b5be783403c54f0396fcfe77
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Tue Mar 28 16:11:18 2006 -0800

    [PATCH] move __exit_signal() to kernel/exit.c
    
    __exit_signal() is private to release_task() now.  I think it is better to
    make it static in kernel/exit.c and export flush_sigqueue() instead - this
    function is much more simple and straightforward.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index b7d093520bb6..162a8fd10b29 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -249,6 +249,8 @@ static inline void init_sigpending(struct sigpending *sig)
 	INIT_LIST_HEAD(&sig->list);
 }
 
+extern void flush_sigqueue(struct sigpending *queue);
+
 /* Test if 'sig' is valid signal. Use this instead of testing _NSIG directly */
 static inline int valid_signal(unsigned long sig)
 {

commit 71fabd5e4835309b4feca6209122ce56c595c461
Author: George Anzinger <george@mvista.com>
Date:   Sun Jan 8 01:02:48 2006 -0800

    [PATCH] sigaction should clear all signals on SIG_IGN, not just < 32
    
    While rooting aroung in the signal code trying to understand how to fix the
    SIG_IGN ploy (set sig handler to SIG_IGN and flood system with high speed
    repeating timers) I came across what, I think, is a problem in sigaction()
    in that when processing a SIG_IGN request it flushes signals from 1 to
    SIGRTMIN and leaves the rest.  Attempt to fix this.
    
    Signed-off-by: George Anzinger <george@mvista.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index ea9eff16c4b7..b7d093520bb6 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -94,6 +94,23 @@ static inline int sigfindinword(unsigned long word)
 
 #endif /* __HAVE_ARCH_SIG_BITOPS */
 
+static inline int sigisemptyset(sigset_t *set)
+{
+	extern void _NSIG_WORDS_is_unsupported_size(void);
+	switch (_NSIG_WORDS) {
+	case 4:
+		return (set->sig[3] | set->sig[2] |
+			set->sig[1] | set->sig[0]) == 0;
+	case 2:
+		return (set->sig[1] | set->sig[0]) == 0;
+	case 1:
+		return set->sig[0] == 0;
+	default:
+		_NSIG_WORDS_is_unsupported_size();
+		return 0;
+	}
+}
+
 #define sigmask(sig)	(1UL << ((sig) - 1))
 
 #ifndef __HAVE_ARCH_SIG_SETOPS

commit 9ded96f24c3a5fcbef954e88c443385a1af37eb9
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Sun Jan 8 01:02:07 2006 -0800

    [PATCH] IRQ type flags
    
    Some ARM platforms have the ability to program the interrupt controller to
    detect various interrupt edges and/or levels.  For some platforms, this is
    critical to setup correctly, particularly those which the setting is dependent
    on the device.
    
    Currently, ARM drivers do (eg) the following:
    
            err = request_irq(irq, ...);
    
            set_irq_type(irq, IRQT_RISING);
    
    However, if the interrupt has previously been programmed to be level sensitive
    (for whatever reason) then this will cause an interrupt storm.
    
    Hence, if we combine set_irq_type() with request_irq(), we can then safely set
    the type prior to unmasking the interrupt.  The unfortunate problem is that in
    order to support this, these flags need to be visible outside of the ARM
    architecture - drivers such as smc91x need these flags and they're
    cross-architecture.
    
    Finally, the SA_TRIGGER_* flag passed to request_irq() should reflect the
    property that the device would like.  The IRQ controller code should do its
    best to select the most appropriate supported mode.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 5dd5f02c5c5f..ea9eff16c4b7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -18,6 +18,19 @@
 #define SA_PROBE		SA_ONESHOT
 #define SA_SAMPLE_RANDOM	SA_RESTART
 #define SA_SHIRQ		0x04000000
+/*
+ * As above, these correspond to the IORESOURCE_IRQ_* defines in
+ * linux/ioport.h to select the interrupt line behaviour.  When
+ * requesting an interrupt without specifying a SA_TRIGGER, the
+ * setting should be assumed to be "as already configured", which
+ * may be as per machine or firmware initialisation.
+ */
+#define SA_TRIGGER_LOW		0x00000008
+#define SA_TRIGGER_HIGH		0x00000004
+#define SA_TRIGGER_FALLING	0x00000002
+#define SA_TRIGGER_RISING	0x00000001
+#define SA_TRIGGER_MASK	(SA_TRIGGER_HIGH|SA_TRIGGER_LOW|\
+				 SA_TRIGGER_RISING|SA_TRIGGER_FALLING)
 
 /*
  * Real Time signals may be queued.

commit 19a4fcb531659f2f7d18b5d04cee039176e9540d
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Sun Oct 30 15:02:17 2005 -0800

    [PATCH] kill sigqueue->lock
    
    This lock is used in sigqueue_free(), but it is always equal to
    current->sighand->siglock, so we don't need to keep it in the struct
    sigqueue.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 7be18b5e2fb4..5dd5f02c5c5f 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -25,7 +25,6 @@
 
 struct sigqueue {
 	struct list_head list;
-	spinlock_t *lock;
 	int flags;
 	siginfo_t info;
 	struct user_struct *user;

commit a58e76f25432dc5e3e84d04c27bec03347ca365b
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jun 12 10:56:26 2005 +0200

    [PATCH] Remove obsolete HAVE_ARCH_GET_SIGNAL_TO_DELIVER?
    
    Now m68k no longer sets HAVE_ARCH_GET_SIGNAL_TO_DELIVER, can it be removed
    completely? Or may ARM26 still need it? Note that its usage was removed from
    kernel/signal.c about 2 months ago.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 0a98f5ec5cae..7be18b5e2fb4 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -231,10 +231,8 @@ extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 
-#ifndef HAVE_ARCH_GET_SIGNAL_TO_DELIVER
 struct pt_regs;
 extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
-#endif
 
 #endif /* __KERNEL__ */
 

commit e5bdd883a189243541e7a132385580703b049102
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Sun May 1 08:59:13 2005 -0700

    [PATCH] new valid_signal() function
    
    This patch adds a new function valid_signal() that tests if its argument is
    a valid signal number.
    
    The reasons for adding this new function are:
    
    - some code currently testing _NSIG directly has off-by-one errors.
      Using this function instead avoids such errors.
    
    - some code currently tests unsigned signal numbers for <0 which is
      pointless and generates warnings when building with gcc -W.  Using this
      function instead avoids such warnings.
    
    I considered various places to add this function but eventually settled on
    include/linux/signal.h as the most logical place for it.  If there's some
    reason this is a bad choice then please let me know (hints as to a better
    location are then welcome of course).
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 78bfb266e4f7..0a98f5ec5cae 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -220,6 +220,12 @@ static inline void init_sigpending(struct sigpending *sig)
 	INIT_LIST_HEAD(&sig->list);
 }
 
+/* Test if 'sig' is valid signal. Use this instead of testing _NSIG directly */
+static inline int valid_signal(unsigned long sig)
+{
+	return sig <= _NSIG ? 1 : 0;
+}
+
 extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
 extern long do_sigpending(void __user *, unsigned long);

commit 7f261b5f0dccd53ed3a9a95b55c36e24a698a92a
Author: Stas Sergeev <stsp@aknet.ru>
Date:   Sun May 1 08:59:02 2005 -0700

    [PATCH] move SA_xxx defines to linux/signal.h
    
    The attached patch moves the IRQ-related SA_xxx flags (namely, SA_PROBE,
    SA_SAMPLE_RANDOM and SA_SHIRQ) from all the arch-specific headers to
    linux/signal.h.  This looks like a left-over after the irq-handling code
    was consolidated.  The code was moved to kernel/irq/*, but the flags are
    still left per-arch.
    
    Right now, adding a new IRQ flag to the arch-specific header, like this
    patch does:
    http://cvs.sourceforge.net/viewcvs.py/*checkout*/alsa/alsa-driver/utils/patches/pcsp-kernel-2.6.10-03.diff?rev=1.1
    no longer works, it breaks the compilation for all other arches, unless you
    add that flag to all the other arch-specific headers too.  So I think such
    a clean-up makes sense.
    
    Signed-off-by: Stas Sergeev <stsp@aknet.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/signal.h b/include/linux/signal.h
index 99c97ad026c8..78bfb266e4f7 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -8,6 +8,17 @@
 
 #ifdef __KERNEL__
 
+/*
+ * These values of sa_flags are used only by the kernel as part of the
+ * irq handling routines.
+ *
+ * SA_INTERRUPT is also used by the irq handling routines.
+ * SA_SHIRQ is for shared interrupt support on PCI and EISA.
+ */
+#define SA_PROBE		SA_ONESHOT
+#define SA_SAMPLE_RANDOM	SA_RESTART
+#define SA_SHIRQ		0x04000000
+
 /*
  * Real Time signals may be queued.
  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/signal.h b/include/linux/signal.h
new file mode 100644
index 000000000000..99c97ad026c8
--- /dev/null
+++ b/include/linux/signal.h
@@ -0,0 +1,224 @@
+#ifndef _LINUX_SIGNAL_H
+#define _LINUX_SIGNAL_H
+
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/signal.h>
+#include <asm/siginfo.h>
+
+#ifdef __KERNEL__
+
+/*
+ * Real Time signals may be queued.
+ */
+
+struct sigqueue {
+	struct list_head list;
+	spinlock_t *lock;
+	int flags;
+	siginfo_t info;
+	struct user_struct *user;
+};
+
+/* flags values. */
+#define SIGQUEUE_PREALLOC	1
+
+struct sigpending {
+	struct list_head list;
+	sigset_t signal;
+};
+
+/*
+ * Define some primitives to manipulate sigset_t.
+ */
+
+#ifndef __HAVE_ARCH_SIG_BITOPS
+#include <linux/bitops.h>
+
+/* We don't use <linux/bitops.h> for these because there is no need to
+   be atomic.  */
+static inline void sigaddset(sigset_t *set, int _sig)
+{
+	unsigned long sig = _sig - 1;
+	if (_NSIG_WORDS == 1)
+		set->sig[0] |= 1UL << sig;
+	else
+		set->sig[sig / _NSIG_BPW] |= 1UL << (sig % _NSIG_BPW);
+}
+
+static inline void sigdelset(sigset_t *set, int _sig)
+{
+	unsigned long sig = _sig - 1;
+	if (_NSIG_WORDS == 1)
+		set->sig[0] &= ~(1UL << sig);
+	else
+		set->sig[sig / _NSIG_BPW] &= ~(1UL << (sig % _NSIG_BPW));
+}
+
+static inline int sigismember(sigset_t *set, int _sig)
+{
+	unsigned long sig = _sig - 1;
+	if (_NSIG_WORDS == 1)
+		return 1 & (set->sig[0] >> sig);
+	else
+		return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
+}
+
+static inline int sigfindinword(unsigned long word)
+{
+	return ffz(~word);
+}
+
+#endif /* __HAVE_ARCH_SIG_BITOPS */
+
+#define sigmask(sig)	(1UL << ((sig) - 1))
+
+#ifndef __HAVE_ARCH_SIG_SETOPS
+#include <linux/string.h>
+
+#define _SIG_SET_BINOP(name, op)					\
+static inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) \
+{									\
+	extern void _NSIG_WORDS_is_unsupported_size(void);		\
+	unsigned long a0, a1, a2, a3, b0, b1, b2, b3;			\
+									\
+	switch (_NSIG_WORDS) {						\
+	    case 4:							\
+		a3 = a->sig[3]; a2 = a->sig[2];				\
+		b3 = b->sig[3]; b2 = b->sig[2];				\
+		r->sig[3] = op(a3, b3);					\
+		r->sig[2] = op(a2, b2);					\
+	    case 2:							\
+		a1 = a->sig[1]; b1 = b->sig[1];				\
+		r->sig[1] = op(a1, b1);					\
+	    case 1:							\
+		a0 = a->sig[0]; b0 = b->sig[0];				\
+		r->sig[0] = op(a0, b0);					\
+		break;							\
+	    default:							\
+		_NSIG_WORDS_is_unsupported_size();			\
+	}								\
+}
+
+#define _sig_or(x,y)	((x) | (y))
+_SIG_SET_BINOP(sigorsets, _sig_or)
+
+#define _sig_and(x,y)	((x) & (y))
+_SIG_SET_BINOP(sigandsets, _sig_and)
+
+#define _sig_nand(x,y)	((x) & ~(y))
+_SIG_SET_BINOP(signandsets, _sig_nand)
+
+#undef _SIG_SET_BINOP
+#undef _sig_or
+#undef _sig_and
+#undef _sig_nand
+
+#define _SIG_SET_OP(name, op)						\
+static inline void name(sigset_t *set)					\
+{									\
+	extern void _NSIG_WORDS_is_unsupported_size(void);		\
+									\
+	switch (_NSIG_WORDS) {						\
+	    case 4: set->sig[3] = op(set->sig[3]);			\
+		    set->sig[2] = op(set->sig[2]);			\
+	    case 2: set->sig[1] = op(set->sig[1]);			\
+	    case 1: set->sig[0] = op(set->sig[0]);			\
+		    break;						\
+	    default:							\
+		_NSIG_WORDS_is_unsupported_size();			\
+	}								\
+}
+
+#define _sig_not(x)	(~(x))
+_SIG_SET_OP(signotset, _sig_not)
+
+#undef _SIG_SET_OP
+#undef _sig_not
+
+static inline void sigemptyset(sigset_t *set)
+{
+	switch (_NSIG_WORDS) {
+	default:
+		memset(set, 0, sizeof(sigset_t));
+		break;
+	case 2: set->sig[1] = 0;
+	case 1:	set->sig[0] = 0;
+		break;
+	}
+}
+
+static inline void sigfillset(sigset_t *set)
+{
+	switch (_NSIG_WORDS) {
+	default:
+		memset(set, -1, sizeof(sigset_t));
+		break;
+	case 2: set->sig[1] = -1;
+	case 1:	set->sig[0] = -1;
+		break;
+	}
+}
+
+/* Some extensions for manipulating the low 32 signals in particular.  */
+
+static inline void sigaddsetmask(sigset_t *set, unsigned long mask)
+{
+	set->sig[0] |= mask;
+}
+
+static inline void sigdelsetmask(sigset_t *set, unsigned long mask)
+{
+	set->sig[0] &= ~mask;
+}
+
+static inline int sigtestsetmask(sigset_t *set, unsigned long mask)
+{
+	return (set->sig[0] & mask) != 0;
+}
+
+static inline void siginitset(sigset_t *set, unsigned long mask)
+{
+	set->sig[0] = mask;
+	switch (_NSIG_WORDS) {
+	default:
+		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
+		break;
+	case 2: set->sig[1] = 0;
+	case 1: ;
+	}
+}
+
+static inline void siginitsetinv(sigset_t *set, unsigned long mask)
+{
+	set->sig[0] = ~mask;
+	switch (_NSIG_WORDS) {
+	default:
+		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
+		break;
+	case 2: set->sig[1] = -1;
+	case 1: ;
+	}
+}
+
+#endif /* __HAVE_ARCH_SIG_SETOPS */
+
+static inline void init_sigpending(struct sigpending *sig)
+{
+	sigemptyset(&sig->signal);
+	INIT_LIST_HEAD(&sig->list);
+}
+
+extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
+extern int __group_send_sig_info(int, struct siginfo *, struct task_struct *);
+extern long do_sigpending(void __user *, unsigned long);
+extern int sigprocmask(int, sigset_t *, sigset_t *);
+
+#ifndef HAVE_ARCH_GET_SIGNAL_TO_DELIVER
+struct pt_regs;
+extern int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka, struct pt_regs *regs, void *cookie);
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_SIGNAL_H */
