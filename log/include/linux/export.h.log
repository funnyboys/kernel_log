commit ce2b617ce8cbb7ba7a956299061bbc784131333c
Author: Jessica Yu <jeyu@kernel.org>
Date:   Tue Nov 12 12:35:59 2019 +0100

    export.h: reduce __ksymtab_strings string duplication by using "MS" section flags
    
    Commit c3a6cf19e695 ("export: avoid code duplication in
    include/linux/export.h") refactors export.h quite nicely, but introduces
    a slight increase in memory usage due to using the empty string ""
    instead of NULL to indicate that an exported symbol has no namespace. As
    mentioned in that commit, this meant an increase of 1 byte per exported
    symbol without a namespace. For example, if a kernel configuration has
    about 10k exported symbols, this would mean that the size of
    __ksymtab_strings would increase by roughly 10kB.
    
    We can alleviate this situation by utilizing the SHF_MERGE and
    SHF_STRING section flags. SHF_MERGE|SHF_STRING indicate to the linker
    that the data in the section are null-terminated strings that can be
    merged to eliminate duplication. More specifically, from the binutils
    documentation - "for sections with both M and S, a string which is a
    suffix of a larger string is considered a duplicate. Thus "def" will be
    merged with "abcdef"; A reference to the first "def" will be changed to
    a reference to "abcdef"+3". Thus, all the empty strings would be merged
    as well as any strings that can be merged according to the cited method
    above. For example, "memset" and "__memset" would be merged to just
    "__memset" in __ksymtab_strings.
    
    As of v5.4-rc5, the following statistics were gathered with x86
    defconfig with approximately 10.7k exported symbols.
    
    Size of __ksymtab_strings in vmlinux:
    -------------------------------------
    v5.4-rc5: 213834 bytes
    v5.4-rc5 with commit c3a6cf19e695: 224455 bytes
    v5.4-rc5 with this patch: 205759 bytes
    
    So, we already see memory savings of ~8kB compared to vanilla -rc5 and
    savings of nearly 18.7kB compared to -rc5 with commit c3a6cf19e695 on top.
    
    Unfortunately, as of this writing, strings will not get deduplicated for
    kernel modules, as ld does not do the deduplication for
    SHF_MERGE|SHF_STRINGS sections for relocatable files (ld -r), which
    kernel modules are. A patch for ld is currently being worked on to
    hopefully allow for string deduplication in relocatable files in the
    future.
    
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Masahiro Yamada <masahiroy@kernel.org>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 627841448293..fceb5e855717 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -82,16 +82,29 @@ struct kernel_symbol {
 
 #else
 
-/* For every exported symbol, place a struct in the __ksymtab section */
-#define ___EXPORT_SYMBOL(sym, sec, ns)					\
-	extern typeof(sym) sym;						\
-	__CRC_SYMBOL(sym, sec);						\
-	static const char __kstrtab_##sym[]				\
-	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-	= #sym;								\
-	static const char __kstrtabns_##sym[]				\
-	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-	= ns;								\
+/*
+ * For every exported symbol, do the following:
+ *
+ * - If applicable, place a CRC entry in the __kcrctab section.
+ * - Put the name of the symbol and namespace (empty string "" for none) in
+ *   __ksymtab_strings.
+ * - Place a struct kernel_symbol entry in the __ksymtab section.
+ *
+ * note on .section use: we specify progbits since usage of the "M" (SHF_MERGE)
+ * section flag requires it. Use '%progbits' instead of '@progbits' since the
+ * former apparently works on all arches according to the binutils source.
+ */
+#define ___EXPORT_SYMBOL(sym, sec, ns)						\
+	extern typeof(sym) sym;							\
+	extern const char __kstrtab_##sym[];					\
+	extern const char __kstrtabns_##sym[];					\
+	__CRC_SYMBOL(sym, sec);							\
+	asm("	.section \"__ksymtab_strings\",\"aMS\",%progbits,1	\n"	\
+	    "__kstrtab_" #sym ":					\n"	\
+	    "	.asciz 	\"" #sym "\"					\n"	\
+	    "__kstrtabns_" #sym ":					\n"	\
+	    "	.asciz 	\"" ns "\"					\n"	\
+	    "	.previous						\n");	\
 	__KSYMTAB_ENTRY(sym, sec)
 
 #endif

commit 0f137416247fe92c0779a9ab49e912a7006869e8
Merge: 25cfb0c7de3f 5d603311615f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 5 12:27:16 2019 -0800

    Merge tag 'modules-for-v5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull modules updates from Jessica Yu:
     "Summary of modules changes for the 5.5 merge window:
    
       - Refactor include/linux/export.h and remove code duplication between
         EXPORT_SYMBOL and EXPORT_SYMBOL_NS to make it more readable.
    
         The most notable change is that no namespace is represented by an
         empty string "" rather than NULL.
    
       - Fix a module load/unload race where waiter(s) trying to load the
         same module weren't being woken up when a module finally goes away"
    
    * tag 'modules-for-v5.5' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      kernel/module.c: wakeup processes in module_wq on module unload
      moduleparam: fix parameter description mismatch
      export: avoid code duplication in include/linux/export.h

commit bf49d9dd6fef688733e2ddbd55f7bcb57df194e4
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 18 13:50:53 2019 +0900

    export,module: add SPDX GPL-2.0 license identifier to headers with no license
    
    Commit b24413180f56 ("License cleanup: add SPDX GPL-2.0 license
    identifier to files with no license") took care of a lot of files
    without any license information.
    
    These headers were not processed by the tool perhaps because they
    contain "GPL" in the code.
    
    I do not see any license boilerplate in them, so they fall back to
    GPL version 2 only, which is the project default.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Link: https://lore.kernel.org/r/20191018045053.8424-1-yamada.masahiro@socionext.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 941d075f03d6..aee5c86ae350 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 #ifndef _LINUX_EXPORT_H
 #define _LINUX_EXPORT_H
 

commit c3a6cf19e695c8b0a9bf8b5933f863e12d878b7c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 18 10:31:43 2019 +0100

    export: avoid code duplication in include/linux/export.h
    
    include/linux/export.h has lots of code duplication between
    EXPORT_SYMBOL and EXPORT_SYMBOL_NS.
    
    To improve the maintainability and readability, unify the
    implementation.
    
    When the symbol has no namespace, pass the empty string "" to
    the 'ns' parameter.
    
    The drawback of this change is, it grows the code size.
    When the symbol has no namespace, sym->namespace was previously
    NULL, but it is now an empty string "". So, it increases 1 byte
    for every no namespace EXPORT_SYMBOL.
    
    A typical kernel configuration has 10K exported symbols, so it
    increases 10KB in rough estimation.
    
    I did not come up with a good idea to refactor it without increasing
    the code size.
    
    I am not sure how big a deal it is, but at least include/linux/export.h
    looks nicer.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    [maennich: rebase on top of 3 fixes for the namespace feature]
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 941d075f03d6..201262793369 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -46,7 +46,7 @@ extern struct module __this_module;
  * absolute relocations that require runtime processing on relocatable
  * kernels.
  */
-#define __KSYMTAB_ENTRY_NS(sym, sec)					\
+#define __KSYMTAB_ENTRY(sym, sec)					\
 	__ADDRESSABLE(sym)						\
 	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
 	    "	.balign	4					\n"	\
@@ -56,33 +56,17 @@ extern struct module __this_module;
 	    "	.long	__kstrtabns_" #sym "- .			\n"	\
 	    "	.previous					\n")
 
-#define __KSYMTAB_ENTRY(sym, sec)					\
-	__ADDRESSABLE(sym)						\
-	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
-	    "	.balign 4					\n"	\
-	    "__ksymtab_" #sym ":				\n"	\
-	    "	.long	" #sym "- .				\n"	\
-	    "	.long	__kstrtab_" #sym "- .			\n"	\
-	    "	.long	0					\n"	\
-	    "	.previous					\n")
-
 struct kernel_symbol {
 	int value_offset;
 	int name_offset;
 	int namespace_offset;
 };
 #else
-#define __KSYMTAB_ENTRY_NS(sym, sec)					\
-	static const struct kernel_symbol __ksymtab_##sym		\
-	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
-	__aligned(sizeof(void *))					\
-	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtabns_##sym }
-
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	static const struct kernel_symbol __ksymtab_##sym		\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
-	= { (unsigned long)&sym, __kstrtab_##sym, NULL }
+	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtabns_##sym }
 
 struct kernel_symbol {
 	unsigned long value;
@@ -93,28 +77,20 @@ struct kernel_symbol {
 
 #ifdef __GENKSYMS__
 
-#define ___EXPORT_SYMBOL(sym,sec)	__GENKSYMS_EXPORT_SYMBOL(sym)
-#define ___EXPORT_SYMBOL_NS(sym,sec,ns)	__GENKSYMS_EXPORT_SYMBOL(sym)
+#define ___EXPORT_SYMBOL(sym, sec, ns)	__GENKSYMS_EXPORT_SYMBOL(sym)
 
 #else
 
-#define ___export_symbol_common(sym, sec)				\
+/* For every exported symbol, place a struct in the __ksymtab section */
+#define ___EXPORT_SYMBOL(sym, sec, ns)					\
 	extern typeof(sym) sym;						\
 	__CRC_SYMBOL(sym, sec);						\
 	static const char __kstrtab_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-	= #sym								\
-
-/* For every exported symbol, place a struct in the __ksymtab section */
-#define ___EXPORT_SYMBOL_NS(sym, sec, ns)				\
-	___export_symbol_common(sym, sec);				\
+	= #sym;								\
 	static const char __kstrtabns_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-	= #ns;								\
-	__KSYMTAB_ENTRY_NS(sym, sec)
-
-#define ___EXPORT_SYMBOL(sym, sec)					\
-	___export_symbol_common(sym, sec);				\
+	= ns;								\
 	__KSYMTAB_ENTRY(sym, sec)
 
 #endif
@@ -126,8 +102,7 @@ struct kernel_symbol {
  * be reused in other execution contexts such as the UEFI stub or the
  * decompressor.
  */
-#define __EXPORT_SYMBOL_NS(sym, sec, ns)
-#define __EXPORT_SYMBOL(sym, sec)
+#define __EXPORT_SYMBOL(sym, sec, ns)
 
 #elif defined(CONFIG_TRIM_UNUSED_KSYMS)
 
@@ -143,48 +118,38 @@ struct kernel_symbol {
 #define __ksym_marker(sym)	\
 	static int __ksym_marker_##sym[0] __section(".discard.ksym") __used
 
-#define __EXPORT_SYMBOL(sym, sec)				\
-	__ksym_marker(sym);					\
-	__cond_export_sym(sym, sec, __is_defined(__KSYM_##sym))
-#define __cond_export_sym(sym, sec, conf)			\
-	___cond_export_sym(sym, sec, conf)
-#define ___cond_export_sym(sym, sec, enabled)			\
-	__cond_export_sym_##enabled(sym, sec)
-#define __cond_export_sym_1(sym, sec) ___EXPORT_SYMBOL(sym, sec)
-#define __cond_export_sym_0(sym, sec) /* nothing */
-
-#define __EXPORT_SYMBOL_NS(sym, sec, ns)				\
+#define __EXPORT_SYMBOL(sym, sec, ns)					\
 	__ksym_marker(sym);						\
-	__cond_export_ns_sym(sym, sec, ns, __is_defined(__KSYM_##sym))
-#define __cond_export_ns_sym(sym, sec, ns, conf)			\
-	___cond_export_ns_sym(sym, sec, ns, conf)
-#define ___cond_export_ns_sym(sym, sec, ns, enabled)			\
-	__cond_export_ns_sym_##enabled(sym, sec, ns)
-#define __cond_export_ns_sym_1(sym, sec, ns) ___EXPORT_SYMBOL_NS(sym, sec, ns)
-#define __cond_export_ns_sym_0(sym, sec, ns) /* nothing */
+	__cond_export_sym(sym, sec, ns, __is_defined(__KSYM_##sym))
+#define __cond_export_sym(sym, sec, ns, conf)				\
+	___cond_export_sym(sym, sec, ns, conf)
+#define ___cond_export_sym(sym, sec, ns, enabled)			\
+	__cond_export_sym_##enabled(sym, sec, ns)
+#define __cond_export_sym_1(sym, sec, ns) ___EXPORT_SYMBOL(sym, sec, ns)
+#define __cond_export_sym_0(sym, sec, ns) /* nothing */
 
 #else
 
-#define __EXPORT_SYMBOL_NS(sym,sec,ns)	___EXPORT_SYMBOL_NS(sym,sec,ns)
-#define __EXPORT_SYMBOL(sym,sec)	___EXPORT_SYMBOL(sym,sec)
+#define __EXPORT_SYMBOL(sym, sec, ns)	___EXPORT_SYMBOL(sym, sec, ns)
 
 #endif /* CONFIG_MODULES */
 
 #ifdef DEFAULT_SYMBOL_NAMESPACE
-#undef __EXPORT_SYMBOL
-#define __EXPORT_SYMBOL(sym, sec)				\
-	__EXPORT_SYMBOL_NS(sym, sec, DEFAULT_SYMBOL_NAMESPACE)
+#include <linux/stringify.h>
+#define _EXPORT_SYMBOL(sym, sec)	__EXPORT_SYMBOL(sym, sec, __stringify(DEFAULT_SYMBOL_NAMESPACE))
+#else
+#define _EXPORT_SYMBOL(sym, sec)	__EXPORT_SYMBOL(sym, sec, "")
 #endif
 
-#define EXPORT_SYMBOL(sym)		__EXPORT_SYMBOL(sym, "")
-#define EXPORT_SYMBOL_GPL(sym)		__EXPORT_SYMBOL(sym, "_gpl")
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)	__EXPORT_SYMBOL(sym, "_gpl_future")
-#define EXPORT_SYMBOL_NS(sym, ns)	__EXPORT_SYMBOL_NS(sym, "", ns)
-#define EXPORT_SYMBOL_NS_GPL(sym, ns)	__EXPORT_SYMBOL_NS(sym, "_gpl", ns)
+#define EXPORT_SYMBOL(sym)		_EXPORT_SYMBOL(sym, "")
+#define EXPORT_SYMBOL_GPL(sym)		_EXPORT_SYMBOL(sym, "_gpl")
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)	_EXPORT_SYMBOL(sym, "_gpl_future")
+#define EXPORT_SYMBOL_NS(sym, ns)	__EXPORT_SYMBOL(sym, "", #ns)
+#define EXPORT_SYMBOL_NS_GPL(sym, ns)	__EXPORT_SYMBOL(sym, "_gpl", #ns)
 
 #ifdef CONFIG_UNUSED_SYMBOLS
-#define EXPORT_UNUSED_SYMBOL(sym)	__EXPORT_SYMBOL(sym, "_unused")
-#define EXPORT_UNUSED_SYMBOL_GPL(sym)	__EXPORT_SYMBOL(sym, "_unused_gpl")
+#define EXPORT_UNUSED_SYMBOL(sym)	_EXPORT_SYMBOL(sym, "_unused")
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)	_EXPORT_SYMBOL(sym, "_unused_gpl")
 #else
 #define EXPORT_UNUSED_SYMBOL(sym)
 #define EXPORT_UNUSED_SYMBOL_GPL(sym)

commit 69923208431e097ce3830647aee98e5bd3e889c8
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Oct 18 10:31:42 2019 +0100

    symbol namespaces: revert to previous __ksymtab name scheme
    
    The introduction of Symbol Namespaces changed the naming schema of the
    __ksymtab entries from __kysmtab__symbol to __ksymtab_NAMESPACE.symbol.
    
    That caused some breakages in tools that depend on the name layout in
    either the binaries(vmlinux,*.ko) or in System.map. E.g. kmod's depmod
    would not be able to read System.map without a patch to support symbol
    namespaces. A warning reported by depmod for namespaced symbols would
    look like
    
      depmod: WARNING: [...]/uas.ko needs unknown symbol usb_stor_adjust_quirks
    
    In order to address this issue, revert to the original naming scheme and
    rather read the __kstrtabns_<symbol> entries and their corresponding
    values from __ksymtab_strings to update the namespace values for
    symbols. After having read all symbols and handled them in
    handle_modversions(), the symbols are created. In a second pass, read
    the __kstrtabns_ entries and update the namespaces accordingly.
    
    Fixes: 8651ec01daed ("module: add support for symbol namespaces.")
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Will Deacon <will@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 621158ecd2e2..941d075f03d6 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -18,8 +18,6 @@ extern struct module __this_module;
 #define THIS_MODULE ((struct module *)0)
 #endif
 
-#define NS_SEPARATOR "."
-
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
@@ -48,11 +46,11 @@ extern struct module __this_module;
  * absolute relocations that require runtime processing on relocatable
  * kernels.
  */
-#define __KSYMTAB_ENTRY_NS(sym, sec, ns)				\
+#define __KSYMTAB_ENTRY_NS(sym, sec)					\
 	__ADDRESSABLE(sym)						\
 	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
 	    "	.balign	4					\n"	\
-	    "__ksymtab_" #ns NS_SEPARATOR #sym ":		\n"	\
+	    "__ksymtab_" #sym ":				\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
 	    "	.long	__kstrtabns_" #sym "- .			\n"	\
@@ -74,16 +72,14 @@ struct kernel_symbol {
 	int namespace_offset;
 };
 #else
-#define __KSYMTAB_ENTRY_NS(sym, sec, ns)				\
-	static const struct kernel_symbol __ksymtab_##sym##__##ns	\
-	asm("__ksymtab_" #ns NS_SEPARATOR #sym)				\
+#define __KSYMTAB_ENTRY_NS(sym, sec)					\
+	static const struct kernel_symbol __ksymtab_##sym		\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
 	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtabns_##sym }
 
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	static const struct kernel_symbol __ksymtab_##sym		\
-	asm("__ksymtab_" #sym)						\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
 	= { (unsigned long)&sym, __kstrtab_##sym, NULL }
@@ -115,7 +111,7 @@ struct kernel_symbol {
 	static const char __kstrtabns_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
 	= #ns;								\
-	__KSYMTAB_ENTRY_NS(sym, sec, ns)
+	__KSYMTAB_ENTRY_NS(sym, sec)
 
 #define ___EXPORT_SYMBOL(sym, sec)					\
 	___export_symbol_common(sym, sec);				\

commit fa6643cdc5cd726b10d30eec45ff8dca267de735
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 3 16:58:23 2019 +0900

    module: rename __kstrtab_ns_* to __kstrtabns_* to avoid symbol conflict
    
    The module namespace produces __strtab_ns_<sym> symbols to store
    namespace strings, but it does not guarantee the name uniqueness.
    This is a potential problem because we have exported symbols starting
    with "ns_".
    
    For example, kernel/capability.c exports the following symbols:
    
      EXPORT_SYMBOL(ns_capable);
      EXPORT_SYMBOL(capable);
    
    Assume a situation where those are converted as follows:
    
      EXPORT_SYMBOL_NS(ns_capable, some_namespace);
      EXPORT_SYMBOL_NS(capable, some_namespace);
    
    The former expands to "__kstrtab_ns_capable" and "__kstrtab_ns_ns_capable",
    and the latter to "__kstrtab_capable" and "__kstrtab_ns_capable".
    Then, we have the duplicated "__kstrtab_ns_capable".
    
    To ensure the uniqueness, rename "__kstrtab_ns_*" to "__kstrtabns_*".
    
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 0695d4e847d9..621158ecd2e2 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -55,7 +55,7 @@ extern struct module __this_module;
 	    "__ksymtab_" #ns NS_SEPARATOR #sym ":		\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
-	    "	.long	__kstrtab_ns_" #sym "- .		\n"	\
+	    "	.long	__kstrtabns_" #sym "- .			\n"	\
 	    "	.previous					\n")
 
 #define __KSYMTAB_ENTRY(sym, sec)					\
@@ -79,7 +79,7 @@ struct kernel_symbol {
 	asm("__ksymtab_" #ns NS_SEPARATOR #sym)				\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
-	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtab_ns_##sym }
+	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtabns_##sym }
 
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	static const struct kernel_symbol __ksymtab_##sym		\
@@ -112,7 +112,7 @@ struct kernel_symbol {
 /* For every exported symbol, place a struct in the __ksymtab section */
 #define ___EXPORT_SYMBOL_NS(sym, sec, ns)				\
 	___export_symbol_common(sym, sec);				\
-	static const char __kstrtab_ns_##sym[]				\
+	static const char __kstrtabns_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
 	= #ns;								\
 	__KSYMTAB_ENTRY_NS(sym, sec, ns)

commit bf70b0503abd19194dba25fe383d143d0229dc6a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 3 16:58:21 2019 +0900

    module: swap the order of symbol.namespace
    
    Currently, EXPORT_SYMBOL_NS(_GPL) constructs the kernel symbol as
    follows:
    
      __ksymtab_SYMBOL.NAMESPACE
    
    The sym_extract_namespace() in modpost allocates memory for the part
    SYMBOL.NAMESPACE when '.' is contained. One problem is that the pointer
    returned by strdup() is lost because the symbol name will be copied to
    malloc'ed memory by alloc_symbol(). No one will keep track of the
    pointer of strdup'ed memory.
    
    sym->namespace still points to the NAMESPACE part. So, you can free it
    with complicated code like this:
    
       free(sym->namespace - strlen(sym->name) - 1);
    
    It complicates memory free.
    
    To fix it elegantly, I swapped the order of the symbol and the
    namespace as follows:
    
      __ksymtab_NAMESPACE.SYMBOL
    
    then, simplified sym_extract_namespace() so that it allocates memory
    only for the NAMESPACE part.
    
    I prefer this order because it is intuitive and also matches to major
    languages. For example, NAMESPACE::NAME in C++, MODULE.NAME in Python.
    
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 95f55b7f83a0..0695d4e847d9 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -52,7 +52,7 @@ extern struct module __this_module;
 	__ADDRESSABLE(sym)						\
 	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
 	    "	.balign	4					\n"	\
-	    "__ksymtab_" #sym NS_SEPARATOR #ns ":		\n"	\
+	    "__ksymtab_" #ns NS_SEPARATOR #sym ":		\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
 	    "	.long	__kstrtab_ns_" #sym "- .		\n"	\
@@ -76,7 +76,7 @@ struct kernel_symbol {
 #else
 #define __KSYMTAB_ENTRY_NS(sym, sec, ns)				\
 	static const struct kernel_symbol __ksymtab_##sym##__##ns	\
-	asm("__ksymtab_" #sym NS_SEPARATOR #ns)				\
+	asm("__ksymtab_" #ns NS_SEPARATOR #sym)				\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
 	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtab_ns_##sym }

commit e0703556644a531e50b5dc61b9f6ea83af5f6604
Merge: 8808cf8cbc4d 2e6fcfeb9df6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Sep 22 10:34:46 2019 -0700

    Merge tag 'modules-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull modules updates from Jessica Yu:
     "The main bulk of this pull request introduces a new exported symbol
      namespaces feature. The number of exported symbols is increasingly
      growing with each release (we're at about 31k exports as of 5.3-rc7)
      and we currently have no way of visualizing how these symbols are
      "clustered" or making sense of this huge export surface.
    
      Namespacing exported symbols allows kernel developers to more
      explicitly partition and categorize exported symbols, as well as more
      easily limiting the availability of namespaced symbols to other parts
      of the kernel. For starters, we have introduced the USB_STORAGE
      namespace to demonstrate the API's usage. I have briefly summarized
      the feature and its main motivations in the tag below.
    
      Summary:
    
       - Introduce exported symbol namespaces.
    
         This new feature allows subsystem maintainers to partition and
         categorize their exported symbols into explicit namespaces. Module
         authors are now required to import the namespaces they need.
    
         Some of the main motivations of this feature include: allowing
         kernel developers to better manage the export surface, allow
         subsystem maintainers to explicitly state that usage of some
         exported symbols should only be limited to certain users (think:
         inter-module or inter-driver symbols, debugging symbols, etc), as
         well as more easily limiting the availability of namespaced symbols
         to other parts of the kernel.
    
         With the module import requirement, it is also easier to spot the
         misuse of exported symbols during patch review.
    
         Two new macros are introduced: EXPORT_SYMBOL_NS() and
         EXPORT_SYMBOL_NS_GPL(). The API is thoroughly documented in
         Documentation/kbuild/namespaces.rst.
    
       - Some small code and kbuild cleanups here and there"
    
    * tag 'modules-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      module: Remove leftover '#undef' from export header
      module: remove unneeded casts in cmp_name()
      module: move CONFIG_UNUSED_SYMBOLS to the sub-menu of MODULES
      module: remove redundant 'depends on MODULES'
      module: Fix link failure due to invalid relocation on namespace offset
      usb-storage: export symbols in USB_STORAGE namespace
      usb-storage: remove single-use define for debugging
      docs: Add documentation for Symbol Namespaces
      scripts: Coccinelle script for namespace dependencies.
      modpost: add support for generating namespace dependencies
      export: allow definition default namespaces in Makefiles or sources
      module: add config option MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS
      modpost: add support for symbol namespaces
      module: add support for symbol namespaces.
      export: explicitly align struct kernel_symbol
      module: support reading multiple values per modinfo tag

commit 69a94abb82eed2789d52b58665ddf4b454d9adb9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Sep 9 19:53:17 2019 +0900

    export.h, genksyms: do not make genksyms calculate CRC of trimmed symbols
    
    Arnd Bergmann reported false-positive modpost warnings detected by his
    randconfig testing of linux-next.
    
    Actually, this happens under the combination of CONFIG_MODVERSIONS
    and CONFIG_TRIM_UNUSED_KSYMS since commit 15bfc2348d54 ("modpost:
    check for static EXPORT_SYMBOL* functions").
    
    For example, arch/arm/config/multi_v7_defconfig + CONFIG_MODVERSIONS
    + CONFIG_TRIM_UNUSED_KSYMS produces the following false-positives:
    
    WARNING: "__lshrdi3" [vmlinux] is a static (unknown)
    WARNING: "__ashrdi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_lasr" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_llsr" [vmlinux] is a static (unknown)
    WARNING: "ftrace_set_clr_event" [vmlinux] is a static (unknown)
    WARNING: "__muldi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_ulcmp" [vmlinux] is a static (unknown)
    WARNING: "__ucmpdi2" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_lmul" [vmlinux] is a static (unknown)
    WARNING: "__bswapsi2" [vmlinux] is a static (unknown)
    WARNING: "__bswapdi2" [vmlinux] is a static (unknown)
    WARNING: "__ashldi3" [vmlinux] is a static (unknown)
    WARNING: "__aeabi_llsl" [vmlinux] is a static (unknown)
    
    The root cause of the problem is not in the modpost, but in the
    implementation of CONFIG_TRIM_UNUSED_KSYMS.
    
    If there is at least one untrimmed symbol in the file, genksyms is
    invoked to calculate CRC of *all* the exported symbols in that file
    even if some of them have been trimmed due to no caller existing.
    
    As a result, .tmp_*.ver files contain CRC of trimmed symbols, thus
    unneeded, orphan __crc* symbols are added to objects. It had been
    harmless until recently.
    
    With commit 15bfc2348d54 ("modpost: check for static EXPORT_SYMBOL*
    functions"), it is now harmful because the bogus __crc* symbols make
    modpost call sym_update_crc() to add the symbols to the hash table,
    but there is no one that clears the ->is_static member.
    
    I gave Fixes to the first commit that uncovered the issue, but the
    potential problem has long existed since commit f235541699bc
    ("export.h: allow for per-symbol configurable EXPORT_SYMBOL()").
    
    Fixes: 15bfc2348d54 ("modpost: check for static EXPORT_SYMBOL* functions")
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/export.h b/include/linux/export.h
index cdd98a0d918c..7d8c112a8b61 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -18,9 +18,6 @@ extern struct module __this_module;
 #define THIS_MODULE ((struct module *)0)
 #endif
 
-#ifdef CONFIG_MODULES
-
-#if !defined(__GENKSYMS__)
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
@@ -74,6 +71,12 @@ struct kernel_symbol {
 };
 #endif
 
+#ifdef __GENKSYMS__
+
+#define ___EXPORT_SYMBOL(sym, sec)	__GENKSYMS_EXPORT_SYMBOL(sym)
+
+#else
+
 /* For every exported symbol, place a struct in the __ksymtab section */
 #define ___EXPORT_SYMBOL(sym, sec)					\
 	extern typeof(sym) sym;						\
@@ -83,7 +86,9 @@ struct kernel_symbol {
 	= #sym;								\
 	__KSYMTAB_ENTRY(sym, sec)
 
-#if defined(__DISABLE_EXPORTS)
+#endif
+
+#if !defined(CONFIG_MODULES) || defined(__DISABLE_EXPORTS)
 
 /*
  * Allow symbol exports to be disabled completely so that C code may
@@ -117,37 +122,22 @@ struct kernel_symbol {
 #define __cond_export_sym_0(sym, sec) /* nothing */
 
 #else
-#define __EXPORT_SYMBOL ___EXPORT_SYMBOL
-#endif
 
-#define EXPORT_SYMBOL(sym)					\
-	__EXPORT_SYMBOL(sym, "")
+#define __EXPORT_SYMBOL(sym, sec)	___EXPORT_SYMBOL(sym, sec)
 
-#define EXPORT_SYMBOL_GPL(sym)					\
-	__EXPORT_SYMBOL(sym, "_gpl")
-
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
-	__EXPORT_SYMBOL(sym, "_gpl_future")
+#endif /* CONFIG_MODULES */
 
+#define EXPORT_SYMBOL(sym)		__EXPORT_SYMBOL(sym, "")
+#define EXPORT_SYMBOL_GPL(sym)		__EXPORT_SYMBOL(sym, "_gpl")
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)	__EXPORT_SYMBOL(sym, "_gpl_future")
 #ifdef CONFIG_UNUSED_SYMBOLS
-#define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
-#define EXPORT_UNUSED_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_unused_gpl")
+#define EXPORT_UNUSED_SYMBOL(sym)	__EXPORT_SYMBOL(sym, "_unused")
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)	__EXPORT_SYMBOL(sym, "_unused_gpl")
 #else
 #define EXPORT_UNUSED_SYMBOL(sym)
 #define EXPORT_UNUSED_SYMBOL_GPL(sym)
 #endif
 
-#endif	/* __GENKSYMS__ */
-
-#else /* !CONFIG_MODULES... */
-
-#define EXPORT_SYMBOL(sym)
-#define EXPORT_SYMBOL_GPL(sym)
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)
-#define EXPORT_UNUSED_SYMBOL(sym)
-#define EXPORT_UNUSED_SYMBOL_GPL(sym)
-
-#endif /* CONFIG_MODULES */
 #endif /* !__ASSEMBLY__ */
 
 #endif /* _LINUX_EXPORT_H */

commit 069e1c07c18ac2ccecdfb5ac287a37d6fb2d7a00
Author: Will Deacon <will@kernel.org>
Date:   Wed Sep 11 13:26:46 2019 +0100

    module: Fix link failure due to invalid relocation on namespace offset
    
    Commit 8651ec01daed ("module: add support for symbol namespaces.")
    broke linking for arm64 defconfig:
    
      | lib/crypto/arc4.o: In function `__ksymtab_arc4_setkey':
      | arc4.c:(___ksymtab+arc4_setkey+0x8): undefined reference to `no symbol'
      | lib/crypto/arc4.o: In function `__ksymtab_arc4_crypt':
      | arc4.c:(___ksymtab+arc4_crypt+0x8): undefined reference to `no symbol'
    
    This is because the dummy initialisation of the 'namespace_offset' field
    in 'struct kernel_symbol' when using EXPORT_SYMBOL on architectures with
    support for PREL32 locations uses an offset from an absolute address (0)
    in an effort to trick 'offset_to_pointer' into behaving as a NOP,
    allowing non-namespaced symbols to be treated in the same way as those
    belonging to a namespace.
    
    Unfortunately, place-relative relocations require a symbol reference
    rather than an absolute value and, although x86 appears to get away with
    this due to placing the kernel text at the top of the address space, it
    almost certainly results in a runtime failure if the kernel is relocated
    dynamically as a result of KASLR.
    
    Rework 'namespace_offset' so that a value of 0, which cannot occur for a
    valid namespaced symbol, indicates that the corresponding symbol does
    not belong to a namespace.
    
    Cc: Matthias Maennich <maennich@google.com>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Fixes: 8651ec01daed ("module: add support for symbol namespaces.")
    Reported-by: kbuild test robot <lkp@intel.com>
    Tested-by: Matthias Maennich <maennich@google.com>
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Will Deacon <will@kernel.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 2c5468d8ea9a..ef5d015d754a 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -68,7 +68,7 @@ extern struct module __this_module;
 	    "__ksymtab_" #sym ":				\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
-	    "	.long	0 - .					\n"	\
+	    "	.long	0					\n"	\
 	    "	.previous					\n")
 
 struct kernel_symbol {

commit a0469f989fe1d051820cda7ead496f1a7371f3d8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Sep 9 19:53:16 2019 +0900

    export.h: remove defined(__KERNEL__), which is no longer needed
    
    The conditional, define(__KERNEL__), was added by commit f235541699bc
    ("export.h: allow for per-symbol configurable EXPORT_SYMBOL()").
    
    It was needed at that time to avoid the build error of modpost
    with CONFIG_TRIM_UNUSED_KSYMS=y.
    
    Since commit b2c5cdcfd4bc ("modpost: remove symbol prefix support"),
    modpost no longer includes linux/export.h, thus the define(__KERNEL__)
    is unneeded.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/include/linux/export.h b/include/linux/export.h
index fd8711ed9ac4..cdd98a0d918c 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -20,7 +20,7 @@ extern struct module __this_module;
 
 #ifdef CONFIG_MODULES
 
-#if defined(__KERNEL__) && !defined(__GENKSYMS__)
+#if !defined(__GENKSYMS__)
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */

commit 8e2adc6a00cd96c07fcfa8adfbedbb4be681b8a7
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:30 2019 +0100

    export: allow definition default namespaces in Makefiles or sources
    
    To avoid excessive usage of EXPORT_SYMBOL_NS(sym, MY_NAMESPACE), where
    MY_NAMESPACE will always be the namespace we are exporting to, allow
    exporting all definitions of EXPORT_SYMBOL() and friends by defining
    DEFAULT_SYMBOL_NAMESPACE.
    
    For example, to export all symbols defined in usb-common into the
    namespace USB_COMMON, add a line like this to drivers/usb/common/Makefile:
    
      ccflags-y += -DDEFAULT_SYMBOL_NAMESPACE=USB_COMMON
    
    That is equivalent to changing all EXPORT_SYMBOL(sym) definitions to
    EXPORT_SYMBOL_NS(sym, USB_COMMON). Subsequently all symbol namespaces
    functionality will apply.
    
    Another way of making use of this feature is to define the namespace
    within source or header files similar to how TRACE_SYSTEM defines are
    used:
      #undef DEFAULT_SYMBOL_NAMESPACE
      #define DEFAULT_SYMBOL_NAMESPACE USB_COMMON
    
    Please note that, as opposed to TRACE_SYSTEM, DEFAULT_SYMBOL_NAMESPACE
    has to be defined before including include/linux/export.h.
    
    If DEFAULT_SYMBOL_NAMESPACE is defined, a symbol can still be exported
    to another namespace by using EXPORT_SYMBOL_NS() and friends with
    explicitly specifying the namespace.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index d59461e71478..2c5468d8ea9a 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -166,6 +166,12 @@ struct kernel_symbol {
 #define __EXPORT_SYMBOL ___EXPORT_SYMBOL
 #endif
 
+#ifdef DEFAULT_SYMBOL_NAMESPACE
+#undef __EXPORT_SYMBOL
+#define __EXPORT_SYMBOL(sym, sec)				\
+	__EXPORT_SYMBOL_NS(sym, sec, DEFAULT_SYMBOL_NAMESPACE)
+#endif
+
 #define EXPORT_SYMBOL(sym) __EXPORT_SYMBOL(sym, "")
 #define EXPORT_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_gpl")
 #define EXPORT_SYMBOL_GPL_FUTURE(sym) __EXPORT_SYMBOL(sym, "_gpl_future")

commit 8651ec01daedad26290f76beeb4736f9d2da4b87
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:27 2019 +0100

    module: add support for symbol namespaces.
    
    The EXPORT_SYMBOL_NS() and EXPORT_SYMBOL_NS_GPL() macros can be used to
    export a symbol to a specific namespace.  There are no _GPL_FUTURE and
    _UNUSED variants because these are currently unused, and I'm not sure
    they are necessary.
    
    I didn't add EXPORT_SYMBOL_NS() for ASM exports; this patch sets the
    namespace of ASM exports to NULL by default. In case of relative
    references, it will be relocatable to NULL. If there's a need, this
    should be pretty easy to add.
    
    A module that wants to use a symbol exported to a namespace must add a
    MODULE_IMPORT_NS() statement to their module code; otherwise, modpost
    will complain when building the module, and the kernel module loader
    will emit an error and fail when loading the module.
    
    MODULE_IMPORT_NS() adds a modinfo tag 'import_ns' to the module. That
    tag can be observed by the modinfo command, modpost and kernel/module.c
    at the time of loading the module.
    
    The ELF symbols are renamed to include the namespace with an asm label;
    for example, symbol 'usb_stor_suspend' in namespace USB_STORAGE becomes
    'usb_stor_suspend.USB_STORAGE'.  This allows modpost to do namespace
    checking, without having to go through all the effort of parsing ELF and
    relocation records just to get to the struct kernel_symbols.
    
    On x86_64 I saw no difference in binary size (compression), but at
    runtime this will require a word of memory per export to hold the
    namespace. An alternative could be to store namespaced symbols in their
    own section and use a separate 'struct namespaced_kernel_symbol' for
    that section, at the cost of making the module loader more complex.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 28a4d2150689..d59461e71478 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -20,6 +20,8 @@ extern struct module __this_module;
 
 #ifdef CONFIG_MODULES
 
+#define NS_SEPARATOR "."
+
 #if defined(__KERNEL__) && !defined(__GENKSYMS__)
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
@@ -29,13 +31,13 @@ extern struct module __this_module;
 	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
 	    "	.weak	__crc_" #sym "				\n"	\
 	    "	.long	__crc_" #sym " - .			\n"	\
-	    "	.previous					\n");
+	    "	.previous					\n")
 #else
 #define __CRC_SYMBOL(sym, sec)						\
 	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
 	    "	.weak	__crc_" #sym "				\n"	\
 	    "	.long	__crc_" #sym "				\n"	\
-	    "	.previous					\n");
+	    "	.previous					\n")
 #endif
 #else
 #define __CRC_SYMBOL(sym, sec)
@@ -49,6 +51,16 @@ extern struct module __this_module;
  * absolute relocations that require runtime processing on relocatable
  * kernels.
  */
+#define __KSYMTAB_ENTRY_NS(sym, sec, ns)				\
+	__ADDRESSABLE(sym)						\
+	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
+	    "	.balign	4					\n"	\
+	    "__ksymtab_" #sym NS_SEPARATOR #ns ":		\n"	\
+	    "	.long	" #sym "- .				\n"	\
+	    "	.long	__kstrtab_" #sym "- .			\n"	\
+	    "	.long	__kstrtab_ns_" #sym "- .		\n"	\
+	    "	.previous					\n")
+
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	__ADDRESSABLE(sym)						\
 	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
@@ -56,32 +68,53 @@ extern struct module __this_module;
 	    "__ksymtab_" #sym ":				\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
+	    "	.long	0 - .					\n"	\
 	    "	.previous					\n")
 
 struct kernel_symbol {
 	int value_offset;
 	int name_offset;
+	int namespace_offset;
 };
 #else
+#define __KSYMTAB_ENTRY_NS(sym, sec, ns)				\
+	static const struct kernel_symbol __ksymtab_##sym##__##ns	\
+	asm("__ksymtab_" #sym NS_SEPARATOR #ns)				\
+	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
+	__aligned(sizeof(void *))					\
+	= { (unsigned long)&sym, __kstrtab_##sym, __kstrtab_ns_##sym }
+
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	static const struct kernel_symbol __ksymtab_##sym		\
+	asm("__ksymtab_" #sym)						\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	__aligned(sizeof(void *))					\
-	= { (unsigned long)&sym, __kstrtab_##sym }
+	= { (unsigned long)&sym, __kstrtab_##sym, NULL }
 
 struct kernel_symbol {
 	unsigned long value;
 	const char *name;
+	const char *namespace;
 };
 #endif
 
-/* For every exported symbol, place a struct in the __ksymtab section */
-#define ___EXPORT_SYMBOL(sym, sec)					\
+#define ___export_symbol_common(sym, sec)				\
 	extern typeof(sym) sym;						\
-	__CRC_SYMBOL(sym, sec)						\
+	__CRC_SYMBOL(sym, sec);						\
 	static const char __kstrtab_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
-	= #sym;								\
+	= #sym								\
+
+/* For every exported symbol, place a struct in the __ksymtab section */
+#define ___EXPORT_SYMBOL_NS(sym, sec, ns)				\
+	___export_symbol_common(sym, sec);				\
+	static const char __kstrtab_ns_##sym[]				\
+	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
+	= #ns;								\
+	__KSYMTAB_ENTRY_NS(sym, sec, ns)
+
+#define ___EXPORT_SYMBOL(sym, sec)					\
+	___export_symbol_common(sym, sec);				\
 	__KSYMTAB_ENTRY(sym, sec)
 
 #if defined(__DISABLE_EXPORTS)
@@ -91,6 +124,7 @@ struct kernel_symbol {
  * be reused in other execution contexts such as the UEFI stub or the
  * decompressor.
  */
+#define __EXPORT_SYMBOL_NS(sym, sec, ns)
 #define __EXPORT_SYMBOL(sym, sec)
 
 #elif defined(CONFIG_TRIM_UNUSED_KSYMS)
@@ -117,18 +151,26 @@ struct kernel_symbol {
 #define __cond_export_sym_1(sym, sec) ___EXPORT_SYMBOL(sym, sec)
 #define __cond_export_sym_0(sym, sec) /* nothing */
 
+#define __EXPORT_SYMBOL_NS(sym, sec, ns)				\
+	__ksym_marker(sym);						\
+	__cond_export_ns_sym(sym, sec, ns, __is_defined(__KSYM_##sym))
+#define __cond_export_ns_sym(sym, sec, ns, conf)			\
+	___cond_export_ns_sym(sym, sec, ns, conf)
+#define ___cond_export_ns_sym(sym, sec, ns, enabled)			\
+	__cond_export_ns_sym_##enabled(sym, sec, ns)
+#define __cond_export_ns_sym_1(sym, sec, ns) ___EXPORT_SYMBOL_NS(sym, sec, ns)
+#define __cond_export_ns_sym_0(sym, sec, ns) /* nothing */
+
 #else
+#define __EXPORT_SYMBOL_NS ___EXPORT_SYMBOL_NS
 #define __EXPORT_SYMBOL ___EXPORT_SYMBOL
 #endif
 
-#define EXPORT_SYMBOL(sym)					\
-	__EXPORT_SYMBOL(sym, "")
-
-#define EXPORT_SYMBOL_GPL(sym)					\
-	__EXPORT_SYMBOL(sym, "_gpl")
-
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
-	__EXPORT_SYMBOL(sym, "_gpl_future")
+#define EXPORT_SYMBOL(sym) __EXPORT_SYMBOL(sym, "")
+#define EXPORT_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_gpl")
+#define EXPORT_SYMBOL_GPL_FUTURE(sym) __EXPORT_SYMBOL(sym, "_gpl_future")
+#define EXPORT_SYMBOL_NS(sym, ns) __EXPORT_SYMBOL_NS(sym, "", ns)
+#define EXPORT_SYMBOL_NS_GPL(sym, ns) __EXPORT_SYMBOL_NS(sym, "_gpl", ns)
 
 #ifdef CONFIG_UNUSED_SYMBOLS
 #define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
@@ -138,11 +180,28 @@ struct kernel_symbol {
 #define EXPORT_UNUSED_SYMBOL_GPL(sym)
 #endif
 
-#endif	/* __GENKSYMS__ */
+#endif	/* __KERNEL__ && !__GENKSYMS__ */
+
+#if defined(__GENKSYMS__)
+/*
+ * When we're running genksyms, ignore the namespace and make the _NS
+ * variants look like the normal ones. There are two reasons for this:
+ * 1) In the normal definition of EXPORT_SYMBOL_NS, the 'ns' macro
+ *    argument is itself not expanded because it's always tokenized or
+ *    concatenated; but when running genksyms, a blank definition of the
+ *    macro does allow the argument to be expanded; if a namespace
+ *    happens to collide with a #define, this can cause issues.
+ * 2) There's no need to modify genksyms to deal with the _NS variants
+ */
+#define EXPORT_SYMBOL_NS(sym, ns) EXPORT_SYMBOL(sym)
+#define EXPORT_SYMBOL_NS_GPL(sym, ns) EXPORT_SYMBOL_GPL(sym)
+#endif
 
 #else /* !CONFIG_MODULES... */
 
 #define EXPORT_SYMBOL(sym)
+#define EXPORT_SYMBOL_NS(sym, ns)
+#define EXPORT_SYMBOL_NS_GPL(sym, ns)
 #define EXPORT_SYMBOL_GPL(sym)
 #define EXPORT_SYMBOL_GPL_FUTURE(sym)
 #define EXPORT_UNUSED_SYMBOL(sym)

commit ed13fc33f763035a7c290f11c7111877c3a5daab
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:26 2019 +0100

    export: explicitly align struct kernel_symbol
    
    This change allows growing struct kernel_symbol without wasting bytes to
    alignment. It also concretized the alignment of ksymtab entries if
    relative references are used for ksymtab entries.
    
    struct kernel_symbol was already implicitly being aligned to the word
    size, except on x86_64 and m68k, where it is aligned to 16 and 2 bytes,
    respectively.
    
    As far as I can tell there is no requirement for aligning struct
    kernel_symbol to 16 bytes on x86_64, but gcc aligns structs to their
    size, and the linker aligns the custom __ksymtab sections to the largest
    data type contained within, so setting KSYM_ALIGN to 16 was necessary to
    stay consistent with the code generated for non-ASM EXPORT_SYMBOL(). Now
    that non-ASM EXPORT_SYMBOL() explicitly aligns to word size (8),
    KSYM_ALIGN is no longer necessary.
    
    In case of relative references, the alignment has been changed
    accordingly to not waste space when adding new struct members.
    
    As for m68k, struct kernel_symbol is aligned to 2 bytes even though the
    structure itself is 8 bytes; using a 4-byte alignment shouldn't hurt.
    
    I manually verified the output of the __ksymtab sections didn't change
    on x86, x86_64, arm, arm64 and m68k. As expected, the section contents
    didn't change, and the ELF section alignment only changed on x86_64 and
    m68k. Feedback from other archs more than welcome.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index fd8711ed9ac4..28a4d2150689 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -52,7 +52,7 @@ extern struct module __this_module;
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	__ADDRESSABLE(sym)						\
 	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
-	    "	.balign	8					\n"	\
+	    "	.balign 4					\n"	\
 	    "__ksymtab_" #sym ":				\n"	\
 	    "	.long	" #sym "- .				\n"	\
 	    "	.long	__kstrtab_" #sym "- .			\n"	\
@@ -66,6 +66,7 @@ struct kernel_symbol {
 #define __KSYMTAB_ENTRY(sym, sec)					\
 	static const struct kernel_symbol __ksymtab_##sym		\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
+	__aligned(sizeof(void *))					\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
 struct kernel_symbol {

commit bbda5ec671d3fe62faefa1cab7270aa586042a4b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 30 10:05:26 2018 +0900

    kbuild: simplify dependency generation for CONFIG_TRIM_UNUSED_KSYMS
    
    My main motivation of this commit is to clean up scripts/Kbuild.include
    and scripts/Makefile.build.
    
    Currently, CONFIG_TRIM_UNUSED_KSYMS works with a tricky gimmick;
    possibly exported symbols are detected by letting $(CPP) replace
    EXPORT_SYMBOL* with a special string '=== __KSYM_*===', which is
    post-processed by sed, and passed to fixdep. The extra preprocessing
    is costly, and hacking cmd_and_fixdep is ugly.
    
    I came up with a new way to find exported symbols; insert a dummy
    symbol __ksym_marker_* to each potentially exported symbol. Those
    dummy symbols are picked up by $(NM), post-processed by sed, then
    appended to .*.cmd files. I collected the post-process part to a
    new shell script scripts/gen_ksymdeps.sh for readability. The dummy
    symbols are put into the .discard.* section so that the linker
    script rips them off the final vmlinux or modules.
    
    A nice side-effect is building with CONFIG_TRIM_UNUSED_KSYMS will
    be much faster.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index ce764a5d2ee4..fd8711ed9ac4 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -92,22 +92,22 @@ struct kernel_symbol {
  */
 #define __EXPORT_SYMBOL(sym, sec)
 
-#elif defined(__KSYM_DEPS__)
+#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
+
+#include <generated/autoksyms.h>
 
 /*
  * For fine grained build dependencies, we want to tell the build system
  * about each possible exported symbol even if they're not actually exported.
- * We use a string pattern that is unlikely to be valid code that the build
- * system filters out from the preprocessor output (see ksym_dep_filter
- * in scripts/Kbuild.include).
+ * We use a symbol pattern __ksym_marker_<symbol> that the build system filters
+ * from the $(NM) output (see scripts/gen_ksymdeps.sh). These symbols are
+ * discarded in the final link stage.
  */
-#define __EXPORT_SYMBOL(sym, sec)	=== __KSYM_##sym ===
-
-#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
-
-#include <generated/autoksyms.h>
+#define __ksym_marker(sym)	\
+	static int __ksym_marker_##sym[0] __section(".discard.ksym") __used
 
 #define __EXPORT_SYMBOL(sym, sec)				\
+	__ksym_marker(sym);					\
 	__cond_export_sym(sym, sec, __is_defined(__KSYM_##sym))
 #define __cond_export_sym(sym, sec, conf)			\
 	___cond_export_sym(sym, sec, conf)

commit 1bc276775d93faf42a3bb1c684cdb838ded8be56
Merge: b8dcdab36f53 d503ac531a52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 25 13:40:38 2018 -0700

    Merge tag 'kbuild-v4.19-2' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull more Kbuild updates from Masahiro Yamada:
    
     - add build_{menu,n,g,x}config targets for compile-testing Kconfig
    
     - fix and improve recursive dependency detection in Kconfig
    
     - fix parallel building of menuconfig/nconfig
    
     - fix syntax error in clang-version.sh
    
     - suppress distracting log from syncconfig
    
     - remove obsolete "rpm" target
    
     - remove VMLINUX_SYMBOL(_STR) macro entirely
    
     - fix microblaze build with CONFIG_DYNAMIC_FTRACE
    
     - move compiler test for dead code/data elimination to Kconfig
    
     - rename well-known LDFLAGS variable to KBUILD_LDFLAGS
    
     - misc fixes and cleanups
    
    * tag 'kbuild-v4.19-2' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild:
      kbuild: rename LDFLAGS to KBUILD_LDFLAGS
      kbuild: pass LDFLAGS to recordmcount.pl
      kbuild: test dead code/data elimination support in Kconfig
      initramfs: move gen_initramfs_list.sh from scripts/ to usr/
      vmlinux.lds.h: remove stale <linux/export.h> include
      export.h: remove VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR()
      Coccinelle: remove pci_alloc_consistent semantic to detect in zalloc-simple.cocci
      kbuild: make sorting initramfs contents independent of locale
      kbuild: remove "rpm" target, which is alias of "rpm-pkg"
      kbuild: Fix LOADLIBES rename in Documentation/kbuild/makefiles.txt
      kconfig: suppress "configuration written to .config" for syncconfig
      kconfig: fix "Can't open ..." in parallel build
      kbuild: Add a space after `!` to prevent parsing as file pattern
      scripts: modpost: check memory allocation results
      kconfig: improve the recursive dependency report
      kconfig: report recursive dependency involving 'imply'
      kconfig: error out when seeing recursive dependency
      kconfig: add build-only configurator targets
      scripts/dtc: consolidate include path options in Makefile

commit 7290d58095712a89f845e1bca05334796dd49ed2
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:09 2018 -0700

    module: use relative references for __ksymtab entries
    
    An ordinary arm64 defconfig build has ~64 KB worth of __ksymtab entries,
    each consisting of two 64-bit fields containing absolute references, to
    the symbol itself and to a char array containing its name, respectively.
    
    When we build the same configuration with KASLR enabled, we end up with an
    additional ~192 KB of relocations in the .init section, i.e., one 24 byte
    entry for each absolute reference, which all need to be processed at boot
    time.
    
    Given how the struct kernel_symbol that describes each entry is completely
    local to module.c (except for the references emitted by EXPORT_SYMBOL()
    itself), we can easily modify it to contain two 32-bit relative references
    instead.  This reduces the size of the __ksymtab section by 50% for all
    64-bit architectures, and gets rid of the runtime relocations entirely for
    architectures implementing KASLR, either via standard PIE linking (arm64)
    or using custom host tools (x86).
    
    Note that the binary search involving __ksymtab contents relies on each
    section being sorted by symbol name.  This is implemented based on the
    input section names, not the names in the ksymtab entries, so this patch
    does not interfere with that.
    
    Given that the use of place-relative relocations requires support both in
    the toolchain and in the module loader, we cannot enable this feature for
    all architectures.  So make it dependent on whether
    CONFIG_HAVE_ARCH_PREL32_RELOCATIONS is defined.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-4-ard.biesheuvel@linaro.org
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index ea7df303d68d..ae072bc5aacf 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -18,12 +18,6 @@
 #define VMLINUX_SYMBOL_STR(x) __VMLINUX_SYMBOL_STR(x)
 
 #ifndef __ASSEMBLY__
-struct kernel_symbol
-{
-	unsigned long value;
-	const char *name;
-};
-
 #ifdef MODULE
 extern struct module __this_module;
 #define THIS_MODULE (&__this_module)
@@ -54,17 +48,47 @@ extern struct module __this_module;
 #define __CRC_SYMBOL(sym, sec)
 #endif
 
+#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS
+#include <linux/compiler.h>
+/*
+ * Emit the ksymtab entry as a pair of relative references: this reduces
+ * the size by half on 64-bit architectures, and eliminates the need for
+ * absolute relocations that require runtime processing on relocatable
+ * kernels.
+ */
+#define __KSYMTAB_ENTRY(sym, sec)					\
+	__ADDRESSABLE(sym)						\
+	asm("	.section \"___ksymtab" sec "+" #sym "\", \"a\"	\n"	\
+	    "	.balign	8					\n"	\
+	    "__ksymtab_" #sym ":				\n"	\
+	    "	.long	" #sym "- .				\n"	\
+	    "	.long	__kstrtab_" #sym "- .			\n"	\
+	    "	.previous					\n")
+
+struct kernel_symbol {
+	int value_offset;
+	int name_offset;
+};
+#else
+#define __KSYMTAB_ENTRY(sym, sec)					\
+	static const struct kernel_symbol __ksymtab_##sym		\
+	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
+	= { (unsigned long)&sym, __kstrtab_##sym }
+
+struct kernel_symbol {
+	unsigned long value;
+	const char *name;
+};
+#endif
+
 /* For every exported symbol, place a struct in the __ksymtab section */
 #define ___EXPORT_SYMBOL(sym, sec)					\
 	extern typeof(sym) sym;						\
 	__CRC_SYMBOL(sym, sec)						\
 	static const char __kstrtab_##sym[]				\
-	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
+	__attribute__((section("__ksymtab_strings"), used, aligned(1)))	\
 	= #sym;								\
-	static const struct kernel_symbol __ksymtab_##sym		\
-	__used								\
-	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
-	= { (unsigned long)&sym, __kstrtab_##sym }
+	__KSYMTAB_ENTRY(sym, sec)
 
 #if defined(__DISABLE_EXPORTS)
 

commit f922c4abdf7648523589abee9460c87f51630d2f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Aug 21 21:56:04 2018 -0700

    module: allow symbol exports to be disabled
    
    To allow existing C code to be incorporated into the decompressor or the
    UEFI stub, introduce a CPP macro that turns all EXPORT_SYMBOL_xxx
    declarations into nops, and #define it in places where such exports are
    undesirable.  Note that this gets rid of a rather dodgy redefine of
    linux/export.h's header guard.
    
    Link: http://lkml.kernel.org/r/20180704083651.24360-3-ard.biesheuvel@linaro.org
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: James Morris <james.morris@microsoft.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: "Serge E. Hallyn" <serge@hallyn.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Garnier <thgarnie@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index b768d6dd3c90..ea7df303d68d 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -66,7 +66,16 @@ extern struct module __this_module;
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
-#if defined(__KSYM_DEPS__)
+#if defined(__DISABLE_EXPORTS)
+
+/*
+ * Allow symbol exports to be disabled completely so that C code may
+ * be reused in other execution contexts such as the UEFI stub or the
+ * decompressor.
+ */
+#define __EXPORT_SYMBOL(sym, sec)
+
+#elif defined(__KSYM_DEPS__)
 
 /*
  * For fine grained build dependencies, we want to tell the build system

commit c4df32c80d04987023844c1fb13734a872c8f2e2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Aug 19 07:34:47 2018 +0900

    export.h: remove VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR()
    
    With the special case handling for Blackfin and Metag was removed by
    commit 94e58e0ac312 ("export.h: remove code for prefixing symbols with
    underscore"), VMLINUX_SYMBOL() is no-op.
    
    Replace the remaining usages, then remove the definition of
    VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/include/linux/export.h b/include/linux/export.h
index b768d6dd3c90..c363bde21bbe 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -10,13 +10,6 @@
  * hackers place grumpy comments in header files.
  */
 
-#define __VMLINUX_SYMBOL(x) x
-#define __VMLINUX_SYMBOL_STR(x) #x
-
-/* Indirect, so macros are expanded before pasting. */
-#define VMLINUX_SYMBOL(x) __VMLINUX_SYMBOL(x)
-#define VMLINUX_SYMBOL_STR(x) __VMLINUX_SYMBOL_STR(x)
-
 #ifndef __ASSEMBLY__
 struct kernel_symbol
 {

commit 94e58e0ac31284fa26597c0e00a9b1d87a691d02
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 16:23:49 2018 +0900

    export.h: remove code for prefixing symbols with underscore
    
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX was selected by BLACKFIN, METAG.
    They were removed by commit 4ba66a976072 ("arch: remove blackfin port"),
    commit bb6fb6dfcc17 ("metag: Remove arch/metag/"), respectively.
    
    No more architecture enables CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX.
    Clean up the export.h headers.  I am keeping VMLINUX_SYMBOL() and
    VMLINUX_SYMBOL_STR() because they are widely used.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 1a1dfdb2a5c6..b768d6dd3c90 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -10,14 +10,8 @@
  * hackers place grumpy comments in header files.
  */
 
-/* Some toolchains use a `_' prefix for all user symbols. */
-#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
-#define __VMLINUX_SYMBOL(x) _##x
-#define __VMLINUX_SYMBOL_STR(x) "_" #x
-#else
 #define __VMLINUX_SYMBOL(x) x
 #define __VMLINUX_SYMBOL_STR(x) #x
-#endif
 
 /* Indirect, so macros are expanded before pasting. */
 #define VMLINUX_SYMBOL(x) __VMLINUX_SYMBOL(x)
@@ -46,14 +40,14 @@ extern struct module __this_module;
 #if defined(CONFIG_MODULE_REL_CRCS)
 #define __CRC_SYMBOL(sym, sec)						\
 	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
-	    "	.weak	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
-	    "	.long	" VMLINUX_SYMBOL_STR(__crc_##sym) " - .	\n"	\
+	    "	.weak	__crc_" #sym "				\n"	\
+	    "	.long	__crc_" #sym " - .			\n"	\
 	    "	.previous					\n");
 #else
 #define __CRC_SYMBOL(sym, sec)						\
 	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
-	    "	.weak	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
-	    "	.long	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
+	    "	.weak	__crc_" #sym "				\n"	\
+	    "	.long	__crc_" #sym "				\n"	\
 	    "	.previous					\n");
 #endif
 #else
@@ -66,7 +60,7 @@ extern struct module __this_module;
 	__CRC_SYMBOL(sym, sec)						\
 	static const char __kstrtab_##sym[]				\
 	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
-	= VMLINUX_SYMBOL_STR(sym);					\
+	= #sym;								\
 	static const struct kernel_symbol __ksymtab_##sym		\
 	__used								\
 	__attribute__((section("___ksymtab" sec "+" #sym), used))	\

commit 4b9eee96fcb361a5e16a8d2619825e8a048f81f7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:07 2017 +0000

    module: unify absolute krctab definitions for 32-bit and 64-bit
    
    The previous patch introduced a separate inline asm version of the
    krcrctab declaration template for use with 64-bit architectures, which
    cannot refer to ELF symbols using 32-bit quantities.
    
    This declaration should be equivalent to the C one for 32-bit
    architectures, but just in case - unify them in a separate patch, which
    can simply be dropped if it turns out to break anything.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 7473fba6a60c..1a1dfdb2a5c6 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -49,13 +49,6 @@ extern struct module __this_module;
 	    "	.weak	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
 	    "	.long	" VMLINUX_SYMBOL_STR(__crc_##sym) " - .	\n"	\
 	    "	.previous					\n");
-#elif !defined(CONFIG_64BIT)
-#define __CRC_SYMBOL(sym, sec)						\
-	extern __visible void *__crc_##sym __attribute__((weak));	\
-	static const unsigned long __kcrctab_##sym			\
-	__used								\
-	__attribute__((section("___kcrctab" sec "+" #sym), used))	\
-	= (unsigned long) &__crc_##sym;
 #else
 #define __CRC_SYMBOL(sym, sec)						\
 	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\

commit 71810db27c1c853b335675bee335d893bc3d324b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:06 2017 +0000

    modversions: treat symbol CRCs as 32 bit quantities
    
    The modversion symbol CRCs are emitted as ELF symbols, which allows us
    to easily populate the kcrctab sections by relying on the linker to
    associate each kcrctab slot with the correct value.
    
    This has a couple of downsides:
    
     - Given that the CRCs are treated as memory addresses, we waste 4 bytes
       for each CRC on 64 bit architectures,
    
     - On architectures that support runtime relocation, a R_<arch>_RELATIVE
       relocation entry is emitted for each CRC value, which identifies it
       as a quantity that requires fixing up based on the actual runtime
       load offset of the kernel. This results in corrupted CRCs unless we
       explicitly undo the fixup (and this is currently being handled in the
       core module code)
    
     - Such runtime relocation entries take up 24 bytes of __init space
       each, resulting in a x8 overhead in [uncompressed] kernel size for
       CRCs.
    
    Switching to explicit 32 bit values on 64 bit architectures fixes most
    of these issues, given that 32 bit values are not treated as quantities
    that require fixing up based on the actual runtime load offset.  Note
    that on some ELF64 architectures [such as PPC64], these 32-bit values
    are still emitted as [absolute] runtime relocatable quantities, even if
    the value resolves to a build time constant.  Since relative relocations
    are always resolved at build time, this patch enables MODULE_REL_CRCS on
    powerpc when CONFIG_RELOCATABLE=y, which turns the absolute CRC
    references into relative references into .rodata where the actual CRC
    value is stored.
    
    So redefine all CRC fields and variables as u32, and redefine the
    __CRC_SYMBOL() macro for 64 bit builds to emit the CRC reference using
    inline assembler (which is necessary since 64-bit C code cannot use
    32-bit types to hold memory addresses, even if they are ultimately
    resolved using values that do not exceed 0xffffffff).  To avoid
    potential problems with legacy 32-bit architectures using legacy
    toolchains, the equivalent C definition of the kcrctab entry is retained
    for 32-bit architectures.
    
    Note that this mostly reverts commit d4703aefdbc8 ("module: handle ppc64
    relocating kcrctabs when CONFIG_RELOCATABLE=y")
    
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index 2a0f61fbc731..7473fba6a60c 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -43,6 +43,13 @@ extern struct module __this_module;
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
+#if defined(CONFIG_MODULE_REL_CRCS)
+#define __CRC_SYMBOL(sym, sec)						\
+	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
+	    "	.weak	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
+	    "	.long	" VMLINUX_SYMBOL_STR(__crc_##sym) " - .	\n"	\
+	    "	.previous					\n");
+#elif !defined(CONFIG_64BIT)
 #define __CRC_SYMBOL(sym, sec)						\
 	extern __visible void *__crc_##sym __attribute__((weak));	\
 	static const unsigned long __kcrctab_##sym			\
@@ -50,6 +57,13 @@ extern struct module __this_module;
 	__attribute__((section("___kcrctab" sec "+" #sym), used))	\
 	= (unsigned long) &__crc_##sym;
 #else
+#define __CRC_SYMBOL(sym, sec)						\
+	asm("	.section \"___kcrctab" sec "+" #sym "\", \"a\"	\n"	\
+	    "	.weak	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
+	    "	.long	" VMLINUX_SYMBOL_STR(__crc_##sym) "	\n"	\
+	    "	.previous					\n");
+#endif
+#else
 #define __CRC_SYMBOL(sym, sec)
 #endif
 

commit 84d69848c97faab0c25aa2667b273404d2e2a64a
Merge: d4d24d2d0a7e 590abbdd2733
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 14 14:26:58 2016 -0700

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild updates from Michal Marek:
    
     - EXPORT_SYMBOL for asm source by Al Viro.
    
       This does bring a regression, because genksyms no longer generates
       checksums for these symbols (CONFIG_MODVERSIONS). Nick Piggin is
       working on a patch to fix this.
    
       Plus, we are talking about functions like strcpy(), which rarely
       change prototypes.
    
     - Fixes for PPC fallout of the above by Stephen Rothwell and Nick
       Piggin
    
     - fixdep speedup by Alexey Dobriyan.
    
     - preparatory work by Nick Piggin to allow architectures to build with
       -ffunction-sections, -fdata-sections and --gc-sections
    
     - CONFIG_THIN_ARCHIVES support by Stephen Rothwell
    
     - fix for filenames with colons in the initramfs source by me.
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild: (22 commits)
      initramfs: Escape colons in depfile
      ppc: there is no clear_pages to export
      powerpc/64: whitelist unresolved modversions CRCs
      kbuild: -ffunction-sections fix for archs with conflicting sections
      kbuild: add arch specific post-link Makefile
      kbuild: allow archs to select link dead code/data elimination
      kbuild: allow architectures to use thin archives instead of ld -r
      kbuild: Regenerate genksyms lexer
      kbuild: genksyms fix for typeof handling
      fixdep: faster CONFIG_ search
      ia64: move exports to definitions
      sparc32: debride memcpy.S a bit
      [sparc] unify 32bit and 64bit string.h
      sparc: move exports to definitions
      ppc: move exports to definitions
      arm: move exports to definitions
      s390: move exports to definitions
      m68k: move exports to definitions
      alpha: move exports to actual definitions
      x86: move exports to actual definitions
      ...

commit 97139d4a6f26445de47b378cddd5192c0278f863
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 11 13:55:58 2016 -0700

    treewide: remove redundant #include <linux/kconfig.h>
    
    Kernel source files need not include <linux/kconfig.h> explicitly
    because the top Makefile forces to include it with:
    
      -include $(srctree)/include/linux/kconfig.h
    
    This commit removes explicit includes except the following:
    
      * arch/s390/include/asm/facilities_src.h
      * tools/testing/radix-tree/linux/kernel.h
    
    These two are used for host programs.
    
    Link: http://lkml.kernel.org/r/1473656164-11929-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/export.h b/include/linux/export.h
index c565f87f005e..d7df4922da1d 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -78,7 +78,6 @@ extern struct module __this_module;
 
 #elif defined(CONFIG_TRIM_UNUSED_KSYMS)
 
-#include <linux/kconfig.h>
 #include <generated/autoksyms.h>
 
 #define __EXPORT_SYMBOL(sym, sec)				\

commit b67067f1176df6ee727450546b58704e4b588563
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Aug 24 22:29:20 2016 +1000

    kbuild: allow archs to select link dead code/data elimination
    
    Introduce LD_DEAD_CODE_DATA_ELIMINATION option for architectures to
    select to build with -ffunction-sections, -fdata-sections, and link
    with --gc-sections. It requires some work (documented) to ensure all
    unreferenced entrypoints are live, and requires toolchain and build
    verification, so it is made a per-arch option for now.
    
    On a random powerpc64le build, this yelds a significant size saving,
    it boots and runs fine, but there is a lot I haven't tested as yet, so
    these savings may be reduced if there are bugs in the link.
    
        text      data        bss        dec   filename
    11169741   1180744    1923176   14273661   vmlinux
    10445269   1004127    1919707   13369103   vmlinux.dce
    
    ~700K text, ~170K data, 6% removed from kernel image size.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/include/linux/export.h b/include/linux/export.h
index c565f87f005e..337cb90f3668 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -1,5 +1,6 @@
 #ifndef _LINUX_EXPORT_H
 #define _LINUX_EXPORT_H
+
 /*
  * Export symbols from the kernel to modules.  Forked from module.h
  * to reduce the amount of pointless cruft we feed to gcc when only
@@ -42,27 +43,26 @@ extern struct module __this_module;
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
-#define __CRC_SYMBOL(sym, sec)					\
-	extern __visible void *__crc_##sym __attribute__((weak));		\
-	static const unsigned long __kcrctab_##sym		\
-	__used							\
-	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
+#define __CRC_SYMBOL(sym, sec)						\
+	extern __visible void *__crc_##sym __attribute__((weak));	\
+	static const unsigned long __kcrctab_##sym			\
+	__used								\
+	__attribute__((section("___kcrctab" sec "+" #sym), used))	\
 	= (unsigned long) &__crc_##sym;
 #else
 #define __CRC_SYMBOL(sym, sec)
 #endif
 
 /* For every exported symbol, place a struct in the __ksymtab section */
-#define ___EXPORT_SYMBOL(sym, sec)				\
-	extern typeof(sym) sym;					\
-	__CRC_SYMBOL(sym, sec)					\
-	static const char __kstrtab_##sym[]			\
-	__attribute__((section("__ksymtab_strings"), aligned(1))) \
-	= VMLINUX_SYMBOL_STR(sym);				\
-	extern const struct kernel_symbol __ksymtab_##sym;	\
-	__visible const struct kernel_symbol __ksymtab_##sym	\
-	__used							\
-	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
+#define ___EXPORT_SYMBOL(sym, sec)					\
+	extern typeof(sym) sym;						\
+	__CRC_SYMBOL(sym, sec)						\
+	static const char __kstrtab_##sym[]				\
+	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
+	= VMLINUX_SYMBOL_STR(sym);					\
+	static const struct kernel_symbol __ksymtab_##sym		\
+	__used								\
+	__attribute__((section("___ksymtab" sec "+" #sym), used))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
 #if defined(__KSYM_DEPS__)

commit 6023d2369ba7b82b0588fd6fcdd558a6fef200ae
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jun 14 14:58:55 2016 +0900

    export.h: use __is_defined() to check if __KSYM_* is defined
    
    Here the need is for a macro that checks whether the given symbol is
    defined or not, which has nothing to do with config.
    
    The new macro __is_defined() is a better fit for this case.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/include/linux/export.h b/include/linux/export.h
index 2f9ccbe6a639..c565f87f005e 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -82,7 +82,7 @@ extern struct module __this_module;
 #include <generated/autoksyms.h>
 
 #define __EXPORT_SYMBOL(sym, sec)				\
-	__cond_export_sym(sym, sec, config_enabled(__KSYM_##sym))
+	__cond_export_sym(sym, sec, __is_defined(__KSYM_##sym))
 #define __cond_export_sym(sym, sec, conf)			\
 	___cond_export_sym(sym, sec, conf)
 #define ___cond_export_sym(sym, sec, enabled)			\

commit c1a95fda2a40ae8c7aad3fa44fa7718a3710eb2d
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Jan 22 13:41:57 2016 -0500

    kbuild: add fine grained build dependencies for exported symbols
    
    Like with kconfig options, we now have the ability to compile in and
    out individual EXPORT_SYMBOL() declarations based on the content of
    include/generated/autoksyms.h.  However we don't want the entire
    world to be rebuilt whenever that file is touched.
    
    Let's apply the same build dependency trick used for CONFIG_* symbols
    where the time stamp of empty files whose paths matching those symbols
    is used to trigger fine grained rebuilds. In our case the key is the
    symbol name passed to EXPORT_SYMBOL().
    
    However, unlike config options, we cannot just use fixdep to parse
    the source code for EXPORT_SYMBOL(ksym) because several variants exist
    and parsing them all in a separate tool, and keeping it in synch, is
    not trivially maintainable.  Furthermore, there are variants such as
    
            EXPORT_SYMBOL_GPL(pci_user_read_config_##size);
    
    that are instanciated via a macro for which we can't easily determine
    the actual exported symbol name(s) short of actually running the
    preprocessor on them.
    
    Storing the symbol name string in a special ELF section doesn't work
    for targets that output assembly or preprocessed source.
    
    So the best way is really to leverage the preprocessor by having it
    output actual symbol names anchored by a special sequence that can be
    easily filtered out. Then the list of symbols is simply fed to fixdep
    to be merged with the other dependencies.
    
    That implies the preprocessor is executed twice for each source file.
    A previous attempt relied on a warning pragma for each EXPORT_SYMBOL()
    instance that was filtered apart from stderr by the build system with
    a sed script during the actual compilation pass. Unfortunately the
    preprocessor/compiler diagnostic output isn't stable between versions
    and this solution, although more efficient, was deemed too fragile.
    
    Because of the lowercasing performed by fixdep, there might be name
    collisions triggering spurious rebuilds for similar symbols. But this
    shouldn't be a big issue in practice. (This is the case for CONFIG_*
    symbols and I didn't want to be different here, whatever the original
    reason for doing so.)
    
    To avoid needless build overhead, the exported symbol name gathering is
    performed only when CONFIG_TRIM_UNUSED_KSYMS is selected.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/export.h b/include/linux/export.h
index 77afdb2a2506..2f9ccbe6a639 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -65,7 +65,18 @@ extern struct module __this_module;
 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
-#ifdef CONFIG_TRIM_UNUSED_KSYMS
+#if defined(__KSYM_DEPS__)
+
+/*
+ * For fine grained build dependencies, we want to tell the build system
+ * about each possible exported symbol even if they're not actually exported.
+ * We use a string pattern that is unlikely to be valid code that the build
+ * system filters out from the preprocessor output (see ksym_dep_filter
+ * in scripts/Kbuild.include).
+ */
+#define __EXPORT_SYMBOL(sym, sec)	=== __KSYM_##sym ===
+
+#elif defined(CONFIG_TRIM_UNUSED_KSYMS)
 
 #include <linux/kconfig.h>
 #include <generated/autoksyms.h>

commit f235541699bcf14fb8be797c6bc1d7106df0eb64
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Jan 22 01:32:26 2016 -0500

    export.h: allow for per-symbol configurable EXPORT_SYMBOL()
    
    Similar to include/generated/autoconf.h, include/generated/autoksyms.h
    will contain a list of defines for each EXPORT_SYMBOL() that we want
    active. The format is:
    
      #define __KSYM_<symbol_name> 1
    
    This list will be auto-generated with another patch.  For now we only
    include the preprocessor magic to automatically create or omit the
    corresponding struct kernel_symbol declaration.
    
    Given the content of include/generated/autoksyms.h may not be known in
    advance, an empty file is created early on to let the build proceed.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/export.h b/include/linux/export.h
index 96e45ea463e7..77afdb2a2506 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -38,7 +38,7 @@ extern struct module __this_module;
 
 #ifdef CONFIG_MODULES
 
-#ifndef __GENKSYMS__
+#if defined(__KERNEL__) && !defined(__GENKSYMS__)
 #ifdef CONFIG_MODVERSIONS
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
@@ -53,7 +53,7 @@ extern struct module __this_module;
 #endif
 
 /* For every exported symbol, place a struct in the __ksymtab section */
-#define __EXPORT_SYMBOL(sym, sec)				\
+#define ___EXPORT_SYMBOL(sym, sec)				\
 	extern typeof(sym) sym;					\
 	__CRC_SYMBOL(sym, sec)					\
 	static const char __kstrtab_##sym[]			\
@@ -65,6 +65,24 @@ extern struct module __this_module;
 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }
 
+#ifdef CONFIG_TRIM_UNUSED_KSYMS
+
+#include <linux/kconfig.h>
+#include <generated/autoksyms.h>
+
+#define __EXPORT_SYMBOL(sym, sec)				\
+	__cond_export_sym(sym, sec, config_enabled(__KSYM_##sym))
+#define __cond_export_sym(sym, sec, conf)			\
+	___cond_export_sym(sym, sec, conf)
+#define ___cond_export_sym(sym, sec, enabled)			\
+	__cond_export_sym_##enabled(sym, sec)
+#define __cond_export_sym_1(sym, sec) ___EXPORT_SYMBOL(sym, sec)
+#define __cond_export_sym_0(sym, sec) /* nothing */
+
+#else
+#define __EXPORT_SYMBOL ___EXPORT_SYMBOL
+#endif
+
 #define EXPORT_SYMBOL(sym)					\
 	__EXPORT_SYMBOL(sym, "")
 

commit 7b4ec8dd7d4ac467e9eee4d49f2c9574d773efbb
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jan 16 10:18:48 2014 +1030

    export: declare ksymtab symbols
    
    sparse complains about any __ksymtab symbols with the following:
    
     warning: symbol '__ksymtab_...' was not declared. Should it be static?
    
    due to Andi's patch making it non-static.
    
    Mollify sparse by declaring the symbol extern, otherwise we get
    drowned in sparse warnings for anything that uses EXPORT_SYMBOL
    in the sources, making it easy to miss real warnings.
    
    Fixes: e0f244c63fc9 ("asmlinkage, module: Make ksymtab [...] __visible")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/export.h b/include/linux/export.h
index 3f2793d51899..96e45ea463e7 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -59,6 +59,7 @@ extern struct module __this_module;
 	static const char __kstrtab_##sym[]			\
 	__attribute__((section("__ksymtab_strings"), aligned(1))) \
 	= VMLINUX_SYMBOL_STR(sym);				\
+	extern const struct kernel_symbol __ksymtab_##sym;	\
 	__visible const struct kernel_symbol __ksymtab_##sym	\
 	__used							\
 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\

commit e0f244c63fc9d192dfd399cc2677bbdca61994b1
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Oct 23 10:57:58 2013 +1030

    asmlinkage, module: Make ksymtab and kcrctab symbols and __this_module __visible
    
    Make the ksymtab symbols for EXPORT_SYMBOL visible.
    This prevents the LTO compiler from adding a .NUMBER prefix,
    which avoids various problems in later export processing.
    
    Cc: rusty@rustcorp.com.au
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/export.h b/include/linux/export.h
index 412cd509effe..3f2793d51899 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -43,7 +43,7 @@ extern struct module __this_module;
 /* Mark the CRC weak since genksyms apparently decides not to
  * generate a checksums for some symbols */
 #define __CRC_SYMBOL(sym, sec)					\
-	extern void *__crc_##sym __attribute__((weak));		\
+	extern __visible void *__crc_##sym __attribute__((weak));		\
 	static const unsigned long __kcrctab_##sym		\
 	__used							\
 	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
@@ -59,7 +59,7 @@ extern struct module __this_module;
 	static const char __kstrtab_##sym[]			\
 	__attribute__((section("__ksymtab_strings"), aligned(1))) \
 	= VMLINUX_SYMBOL_STR(sym);				\
-	static const struct kernel_symbol __ksymtab_##sym	\
+	__visible const struct kernel_symbol __ksymtab_##sym	\
 	__used							\
 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
 	= { (unsigned long)&sym, __kstrtab_##sym }

commit b92021b09df70c1609e3547f3d6128dd560be97f
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Mar 15 15:04:17 2013 +1030

    CONFIG_SYMBOL_PREFIX: cleanup.
    
    We have CONFIG_SYMBOL_PREFIX, which three archs define to the string
    "_".  But Al Viro broke this in "consolidate cond_syscall and
    SYSCALL_ALIAS declarations" (in linux-next), and he's not the first to
    do so.
    
    Using CONFIG_SYMBOL_PREFIX is awkward, since we usually just want to
    prefix it so something.  So various places define helpers which are
    defined to nothing if CONFIG_SYMBOL_PREFIX isn't set:
    
    1) include/asm-generic/unistd.h defines __SYMBOL_PREFIX.
    2) include/asm-generic/vmlinux.lds.h defines VMLINUX_SYMBOL(sym)
    3) include/linux/export.h defines MODULE_SYMBOL_PREFIX.
    4) include/linux/kernel.h defines SYMBOL_PREFIX (which differs from #7)
    5) kernel/modsign_certificate.S defines ASM_SYMBOL(sym)
    6) scripts/modpost.c defines MODULE_SYMBOL_PREFIX
    7) scripts/Makefile.lib defines SYMBOL_PREFIX on the commandline if
       CONFIG_SYMBOL_PREFIX is set, so that we have a non-string version
       for pasting.
    
    (arch/h8300/include/asm/linkage.h defines SYMBOL_NAME(), too).
    
    Let's solve this properly:
    1) No more generic prefix, just CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX.
    2) Make linux/export.h usable from asm.
    3) Define VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR().
    4) Make everyone use them.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Tested-by: James Hogan <james.hogan@imgtec.com> (metag)

diff --git a/include/linux/export.h b/include/linux/export.h
index 696c0f48afc7..412cd509effe 100644
--- a/include/linux/export.h
+++ b/include/linux/export.h
@@ -5,17 +5,24 @@
  * to reduce the amount of pointless cruft we feed to gcc when only
  * exporting a simple symbol or two.
  *
- * If you feel the need to add #include <linux/foo.h> to this file
- * then you are doing something wrong and should go away silently.
+ * Try not to add #includes here.  It slows compilation and makes kernel
+ * hackers place grumpy comments in header files.
  */
 
 /* Some toolchains use a `_' prefix for all user symbols. */
-#ifdef CONFIG_SYMBOL_PREFIX
-#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
+#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
+#define __VMLINUX_SYMBOL(x) _##x
+#define __VMLINUX_SYMBOL_STR(x) "_" #x
 #else
-#define MODULE_SYMBOL_PREFIX ""
+#define __VMLINUX_SYMBOL(x) x
+#define __VMLINUX_SYMBOL_STR(x) #x
 #endif
 
+/* Indirect, so macros are expanded before pasting. */
+#define VMLINUX_SYMBOL(x) __VMLINUX_SYMBOL(x)
+#define VMLINUX_SYMBOL_STR(x) __VMLINUX_SYMBOL_STR(x)
+
+#ifndef __ASSEMBLY__
 struct kernel_symbol
 {
 	unsigned long value;
@@ -51,7 +58,7 @@ extern struct module __this_module;
 	__CRC_SYMBOL(sym, sec)					\
 	static const char __kstrtab_##sym[]			\
 	__attribute__((section("__ksymtab_strings"), aligned(1))) \
-	= MODULE_SYMBOL_PREFIX #sym;				\
+	= VMLINUX_SYMBOL_STR(sym);				\
 	static const struct kernel_symbol __ksymtab_##sym	\
 	__used							\
 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
@@ -85,5 +92,6 @@ extern struct module __this_module;
 #define EXPORT_UNUSED_SYMBOL_GPL(sym)
 
 #endif /* CONFIG_MODULES */
+#endif /* !__ASSEMBLY__ */
 
 #endif /* _LINUX_EXPORT_H */

commit f50169324df4ad942e544386d136216c8617636a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon May 23 14:11:39 2011 -0400

    module.h: split out the EXPORT_SYMBOL into export.h
    
    A lot of files pull in module.h when all they are really
    looking for is the basic EXPORT_SYMBOL functionality. The
    recent data from Ingo[1] shows that this is one of several
    instances that has a significant impact on compile times,
    and it should be targeted for factoring out (as done here).
    
    Note that several commonly used header files in include/*
    directly include <linux/module.h> themselves (some 34 of them!)
    The most commonly used ones of these will have to be made
    independent of module.h before the full benefit of this change
    can be realized.
    
    We also transition THIS_MODULE from module.h to export.h,
    since there are lots of files with subsystem structs that
    in turn will have a struct module *owner and only be doing:
    
            .owner = THIS_MODULE;
    
    and absolutely nothing else modular. So, we also want to have
    the THIS_MODULE definition present in the lightweight header.
    
    [1] https://lkml.org/lkml/2011/5/23/76
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/export.h b/include/linux/export.h
new file mode 100644
index 000000000000..696c0f48afc7
--- /dev/null
+++ b/include/linux/export.h
@@ -0,0 +1,89 @@
+#ifndef _LINUX_EXPORT_H
+#define _LINUX_EXPORT_H
+/*
+ * Export symbols from the kernel to modules.  Forked from module.h
+ * to reduce the amount of pointless cruft we feed to gcc when only
+ * exporting a simple symbol or two.
+ *
+ * If you feel the need to add #include <linux/foo.h> to this file
+ * then you are doing something wrong and should go away silently.
+ */
+
+/* Some toolchains use a `_' prefix for all user symbols. */
+#ifdef CONFIG_SYMBOL_PREFIX
+#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
+#else
+#define MODULE_SYMBOL_PREFIX ""
+#endif
+
+struct kernel_symbol
+{
+	unsigned long value;
+	const char *name;
+};
+
+#ifdef MODULE
+extern struct module __this_module;
+#define THIS_MODULE (&__this_module)
+#else
+#define THIS_MODULE ((struct module *)0)
+#endif
+
+#ifdef CONFIG_MODULES
+
+#ifndef __GENKSYMS__
+#ifdef CONFIG_MODVERSIONS
+/* Mark the CRC weak since genksyms apparently decides not to
+ * generate a checksums for some symbols */
+#define __CRC_SYMBOL(sym, sec)					\
+	extern void *__crc_##sym __attribute__((weak));		\
+	static const unsigned long __kcrctab_##sym		\
+	__used							\
+	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
+	= (unsigned long) &__crc_##sym;
+#else
+#define __CRC_SYMBOL(sym, sec)
+#endif
+
+/* For every exported symbol, place a struct in the __ksymtab section */
+#define __EXPORT_SYMBOL(sym, sec)				\
+	extern typeof(sym) sym;					\
+	__CRC_SYMBOL(sym, sec)					\
+	static const char __kstrtab_##sym[]			\
+	__attribute__((section("__ksymtab_strings"), aligned(1))) \
+	= MODULE_SYMBOL_PREFIX #sym;				\
+	static const struct kernel_symbol __ksymtab_##sym	\
+	__used							\
+	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
+	= { (unsigned long)&sym, __kstrtab_##sym }
+
+#define EXPORT_SYMBOL(sym)					\
+	__EXPORT_SYMBOL(sym, "")
+
+#define EXPORT_SYMBOL_GPL(sym)					\
+	__EXPORT_SYMBOL(sym, "_gpl")
+
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
+	__EXPORT_SYMBOL(sym, "_gpl_future")
+
+#ifdef CONFIG_UNUSED_SYMBOLS
+#define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
+#define EXPORT_UNUSED_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_unused_gpl")
+#else
+#define EXPORT_UNUSED_SYMBOL(sym)
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)
+#endif
+
+#endif	/* __GENKSYMS__ */
+
+#else /* !CONFIG_MODULES... */
+
+#define EXPORT_SYMBOL(sym)
+#define EXPORT_SYMBOL_GPL(sym)
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)
+#define EXPORT_UNUSED_SYMBOL(sym)
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)
+
+#endif /* CONFIG_MODULES */
+
+#endif /* _LINUX_EXPORT_H */
