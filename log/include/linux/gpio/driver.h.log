commit 6a45b0e2589fafd7fc501a5fbd0ab56689a08124
Author: Michael Walle <michael@walle.cc>
Date:   Thu May 28 16:58:43 2020 +0200

    gpiolib: Introduce gpiochip_irqchip_add_domain()
    
    The function connects an IRQ domain to a gpiochip and reuses
    gpiochip_to_irq() which is provided by gpiolib.
    
    gpiochip_irqchip_* and regmap_irq partially provide the same
    functionality. This function will help to connect just the
    minimal functionality of the gpiochip_irqchip which is needed to
    work together with regmap-irq.
    
    Signed-off-by: Michael Walle <michael@walle.cc>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Link: https://lore.kernel.org/r/20200528145845.31436-2-michael@walle.cc
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c8bcaf315d03..c4f272af7af5 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -612,6 +612,9 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gc,
 bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gc,
 				unsigned int offset);
 
+int gpiochip_irqchip_add_domain(struct gpio_chip *gc,
+				struct irq_domain *domain);
+
 #ifdef CONFIG_LOCKDEP
 
 /*

commit a8173820f441ab3e2a45c4bb66b70da9a57a349e
Author: Maulik Shah <mkshah@codeaurora.org>
Date:   Sat May 23 22:41:10 2020 +0530

    gpio: gpiolib: Allow GPIO IRQs to lazy disable
    
    With 'commit 461c1a7d4733 ("gpiolib: override irq_enable/disable")' gpiolib
    overrides irqchip's irq_enable and irq_disable callbacks. If irq_disable
    callback is implemented then genirq takes unlazy path to disable irq.
    
    Underlying irqchip may not want to implement irq_disable callback to lazy
    disable irq when client drivers invokes disable_irq(). By overriding
    irq_disable callback, gpiolib ends up always unlazy disabling IRQ.
    
    Allow gpiolib to lazy disable IRQs by overriding irq_disable callback only
    if irqchip implemented irq_disable. In cases where irq_disable is not
    implemented irq_mask is overridden. Similarly override irq_enable callback
    only if irqchip implemented irq_enable otherwise irq_unmask is overridden.
    
    Fixes: 461c1a7d4733 ("gpiolib: override irq_enable/disable")
    Signed-off-by: Maulik Shah <mkshah@codeaurora.org>
    Tested-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Link: https://lore.kernel.org/r/1590253873-11556-2-git-send-email-mkshah@codeaurora.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 8c41ae41b6bb..c8bcaf315d03 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -253,6 +253,19 @@ struct gpio_irq_chip {
 	 * Store old irq_chip irq_disable callback
 	 */
 	void		(*irq_disable)(struct irq_data *data);
+	/**
+	 * @irq_unmask:
+	 *
+	 * Store old irq_chip irq_unmask callback
+	 */
+	void		(*irq_unmask)(struct irq_data *data);
+
+	/**
+	 * @irq_mask:
+	 *
+	 * Store old irq_chip irq_mask callback
+	 */
+	void		(*irq_mask)(struct irq_data *data);
 };
 
 /**

commit 8d0910121b070b4edf4239d91cf9a4523b33ca0c
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Apr 28 17:23:28 2020 -0700

    gpio: Make "offset" and "unsigned int", not just "unsigned"
    
    When I copied the function prototypes from the GPIO header file into
    my own driver, checkpatch yelled at me saying that I shouldn't use use
    "unsigned" but instead should say "unsigned int".  Let's make the
    header file use "unsigned int" so others who copy like I did won't get
    yelled at.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20200428172322.2.Iacb3c8152c3cf9015a91308678155a578b0cc050@changeid
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 7b5f5681b7e4..8c41ae41b6bb 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -349,30 +349,30 @@ struct gpio_chip {
 	struct module		*owner;
 
 	int			(*request)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 	void			(*free)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 	int			(*get_direction)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 	int			(*direction_input)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 	int			(*direction_output)(struct gpio_chip *gc,
-						unsigned offset, int value);
+						unsigned int offset, int value);
 	int			(*get)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 	int			(*get_multiple)(struct gpio_chip *gc,
 						unsigned long *mask,
 						unsigned long *bits);
 	void			(*set)(struct gpio_chip *gc,
-						unsigned offset, int value);
+						unsigned int offset, int value);
 	void			(*set_multiple)(struct gpio_chip *gc,
 						unsigned long *mask,
 						unsigned long *bits);
 	int			(*set_config)(struct gpio_chip *gc,
-					      unsigned offset,
+					      unsigned int offset,
 					      unsigned long config);
 	int			(*to_irq)(struct gpio_chip *gc,
-						unsigned offset);
+						unsigned int offset);
 
 	void			(*dbg_show)(struct seq_file *s,
 						struct gpio_chip *gc);
@@ -459,7 +459,7 @@ struct gpio_chip {
 };
 
 extern const char *gpiochip_is_requested(struct gpio_chip *gc,
-			unsigned offset);
+			unsigned int offset);
 
 /* add/remove chips */
 extern int gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,
@@ -657,9 +657,9 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gc,
 }
 #endif /* CONFIG_LOCKDEP */
 
-int gpiochip_generic_request(struct gpio_chip *gc, unsigned offset);
-void gpiochip_generic_free(struct gpio_chip *gc, unsigned offset);
-int gpiochip_generic_config(struct gpio_chip *gc, unsigned offset,
+int gpiochip_generic_request(struct gpio_chip *gc, unsigned int offset);
+void gpiochip_generic_free(struct gpio_chip *gc, unsigned int offset);
+int gpiochip_generic_config(struct gpio_chip *gc, unsigned int offset,
 			    unsigned long config);
 
 /**

commit 36b5215436ad115551e12478ceb3be4a2279e415
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Apr 28 17:23:27 2020 -0700

    gpio: Document proper return value for gpio drivers
    
    The legacy defines GPIOF_DIR_XXX are only for consumers. Document the
    proper ones.  Also: don't use "_XXX" since that's harder to find with
    "git grep".  Just list both of the values.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20200428172322.1.I396f351e364f3c09df7c7606e79abefb8682c092@changeid
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index b8fc92c177eb..7b5f5681b7e4 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -267,9 +267,9 @@ struct gpio_irq_chip {
  * @free: optional hook for chip-specific deactivation, such as
  *	disabling module power and clock; may sleep
  * @get_direction: returns direction for signal "offset", 0=out, 1=in,
- *	(same as GPIOF_DIR_XXX), or negative error.
- *	It is recommended to always implement this function, even on
- *	input-only or output-only gpio chips.
+ *	(same as GPIO_LINE_DIRECTION_OUT / GPIO_LINE_DIRECTION_IN),
+ *	or negative error. It is recommended to always implement this
+ *	function, even on input-only or output-only gpio chips.
  * @direction_input: configures signal "offset" as input, or returns error
  *	This can be omitted on input-only or output-only gpio chips.
  * @direction_output: configures signal "offset" as output, or returns error

commit a0b66a73785ccc8fedbff00383ffe814df9f63c7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Mar 29 16:04:05 2020 +0200

    gpio: Rename variable in core APIs
    
    There is struct gpio *gc, *chip and *gpiochip, and yes
    I am responsible for some of the inconsistencies. I want
    this to be just gc everywhere for minimizing cognitive
    resistance when reading the code: more compact function
    signatures and less clutter.
    
    Purely syntactic changes intended. No semantic effects.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200329140405.52276-1-linus.walleij@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ed65e00ee977..b8fc92c177eb 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -87,7 +87,7 @@ struct gpio_irq_chip {
 	 * @need_valid_mask to make these GPIO lines unavailable for
 	 * translation.
 	 */
-	int (*child_to_parent_hwirq)(struct gpio_chip *chip,
+	int (*child_to_parent_hwirq)(struct gpio_chip *gc,
 				     unsigned int child_hwirq,
 				     unsigned int child_type,
 				     unsigned int *parent_hwirq,
@@ -102,7 +102,7 @@ struct gpio_irq_chip {
 	 * variant named &gpiochip_populate_parent_fwspec_fourcell is also
 	 * available.
 	 */
-	void *(*populate_parent_alloc_arg)(struct gpio_chip *chip,
+	void *(*populate_parent_alloc_arg)(struct gpio_chip *gc,
 				       unsigned int parent_hwirq,
 				       unsigned int parent_type);
 
@@ -114,7 +114,7 @@ struct gpio_irq_chip {
 	 * callback. If this is not specified, then a default callback will be
 	 * provided that returns the line offset.
 	 */
-	unsigned int (*child_offset_to_irq)(struct gpio_chip *chip,
+	unsigned int (*child_offset_to_irq)(struct gpio_chip *gc,
 					    unsigned int pin);
 
 	/**
@@ -209,7 +209,7 @@ struct gpio_irq_chip {
 	 * a particular driver wants to clear IRQ related registers
 	 * in order to avoid undesired events.
 	 */
-	int (*init_hw)(struct gpio_chip *chip);
+	int (*init_hw)(struct gpio_chip *gc);
 
 	/**
 	 * @init_valid_mask: optional routine to initialize @valid_mask, to be
@@ -220,7 +220,7 @@ struct gpio_irq_chip {
 	 * then directly set some bits to "0" if they cannot be used for
 	 * interrupts.
 	 */
-	void (*init_valid_mask)(struct gpio_chip *chip,
+	void (*init_valid_mask)(struct gpio_chip *gc,
 				unsigned long *valid_mask,
 				unsigned int ngpios);
 
@@ -348,40 +348,40 @@ struct gpio_chip {
 	struct device		*parent;
 	struct module		*owner;
 
-	int			(*request)(struct gpio_chip *chip,
+	int			(*request)(struct gpio_chip *gc,
 						unsigned offset);
-	void			(*free)(struct gpio_chip *chip,
+	void			(*free)(struct gpio_chip *gc,
 						unsigned offset);
-	int			(*get_direction)(struct gpio_chip *chip,
+	int			(*get_direction)(struct gpio_chip *gc,
 						unsigned offset);
-	int			(*direction_input)(struct gpio_chip *chip,
+	int			(*direction_input)(struct gpio_chip *gc,
 						unsigned offset);
-	int			(*direction_output)(struct gpio_chip *chip,
+	int			(*direction_output)(struct gpio_chip *gc,
 						unsigned offset, int value);
-	int			(*get)(struct gpio_chip *chip,
+	int			(*get)(struct gpio_chip *gc,
 						unsigned offset);
-	int			(*get_multiple)(struct gpio_chip *chip,
+	int			(*get_multiple)(struct gpio_chip *gc,
 						unsigned long *mask,
 						unsigned long *bits);
-	void			(*set)(struct gpio_chip *chip,
+	void			(*set)(struct gpio_chip *gc,
 						unsigned offset, int value);
-	void			(*set_multiple)(struct gpio_chip *chip,
+	void			(*set_multiple)(struct gpio_chip *gc,
 						unsigned long *mask,
 						unsigned long *bits);
-	int			(*set_config)(struct gpio_chip *chip,
+	int			(*set_config)(struct gpio_chip *gc,
 					      unsigned offset,
 					      unsigned long config);
-	int			(*to_irq)(struct gpio_chip *chip,
+	int			(*to_irq)(struct gpio_chip *gc,
 						unsigned offset);
 
 	void			(*dbg_show)(struct seq_file *s,
-						struct gpio_chip *chip);
+						struct gpio_chip *gc);
 
-	int			(*init_valid_mask)(struct gpio_chip *chip,
+	int			(*init_valid_mask)(struct gpio_chip *gc,
 						   unsigned long *valid_mask,
 						   unsigned int ngpios);
 
-	int			(*add_pin_ranges)(struct gpio_chip *chip);
+	int			(*add_pin_ranges)(struct gpio_chip *gc);
 
 	int			base;
 	u16			ngpio;
@@ -458,11 +458,11 @@ struct gpio_chip {
 #endif /* CONFIG_OF_GPIO */
 };
 
-extern const char *gpiochip_is_requested(struct gpio_chip *chip,
+extern const char *gpiochip_is_requested(struct gpio_chip *gc,
 			unsigned offset);
 
 /* add/remove chips */
-extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
+extern int gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,
 				      struct lock_class_key *lock_key,
 				      struct lock_class_key *request_key);
 
@@ -490,43 +490,43 @@ extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
  * Otherwise it returns zero as a success code.
  */
 #ifdef CONFIG_LOCKDEP
-#define gpiochip_add_data(chip, data) ({		\
+#define gpiochip_add_data(gc, data) ({		\
 		static struct lock_class_key lock_key;	\
 		static struct lock_class_key request_key;	  \
-		gpiochip_add_data_with_key(chip, data, &lock_key, \
+		gpiochip_add_data_with_key(gc, data, &lock_key, \
 					   &request_key);	  \
 	})
 #else
-#define gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL, NULL)
+#define gpiochip_add_data(gc, data) gpiochip_add_data_with_key(gc, data, NULL, NULL)
 #endif /* CONFIG_LOCKDEP */
 
-static inline int gpiochip_add(struct gpio_chip *chip)
+static inline int gpiochip_add(struct gpio_chip *gc)
 {
-	return gpiochip_add_data(chip, NULL);
+	return gpiochip_add_data(gc, NULL);
 }
-extern void gpiochip_remove(struct gpio_chip *chip);
-extern int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *chip,
+extern void gpiochip_remove(struct gpio_chip *gc);
+extern int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *gc,
 				  void *data);
 
 extern struct gpio_chip *gpiochip_find(void *data,
-			      int (*match)(struct gpio_chip *chip, void *data));
+			      int (*match)(struct gpio_chip *gc, void *data));
 
-bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
-int gpiochip_reqres_irq(struct gpio_chip *chip, unsigned int offset);
-void gpiochip_relres_irq(struct gpio_chip *chip, unsigned int offset);
-void gpiochip_disable_irq(struct gpio_chip *chip, unsigned int offset);
-void gpiochip_enable_irq(struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_irq(struct gpio_chip *gc, unsigned int offset);
+int gpiochip_reqres_irq(struct gpio_chip *gc, unsigned int offset);
+void gpiochip_relres_irq(struct gpio_chip *gc, unsigned int offset);
+void gpiochip_disable_irq(struct gpio_chip *gc, unsigned int offset);
+void gpiochip_enable_irq(struct gpio_chip *gc, unsigned int offset);
 
 /* Line status inquiry for drivers */
-bool gpiochip_line_is_open_drain(struct gpio_chip *chip, unsigned int offset);
-bool gpiochip_line_is_open_source(struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_open_drain(struct gpio_chip *gc, unsigned int offset);
+bool gpiochip_line_is_open_source(struct gpio_chip *gc, unsigned int offset);
 
 /* Sleep persistence inquiry for drivers */
-bool gpiochip_line_is_persistent(struct gpio_chip *chip, unsigned int offset);
-bool gpiochip_line_is_valid(const struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_persistent(struct gpio_chip *gc, unsigned int offset);
+bool gpiochip_line_is_valid(const struct gpio_chip *gc, unsigned int offset);
 
 /* get driver data */
-void *gpiochip_get_data(struct gpio_chip *chip);
+void *gpiochip_get_data(struct gpio_chip *gc);
 
 struct bgpio_pdata {
 	const char *label;
@@ -536,23 +536,23 @@ struct bgpio_pdata {
 
 #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
 
-void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *gc,
 					     unsigned int parent_hwirq,
 					     unsigned int parent_type);
-void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *gc,
 					      unsigned int parent_hwirq,
 					      unsigned int parent_type);
 
 #else
 
-static inline void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+static inline void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *gc,
 						    unsigned int parent_hwirq,
 						    unsigned int parent_type)
 {
 	return NULL;
 }
 
-static inline void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+static inline void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *gc,
 						     unsigned int parent_hwirq,
 						     unsigned int parent_type)
 {
@@ -583,11 +583,11 @@ int gpiochip_irq_domain_activate(struct irq_domain *domain,
 void gpiochip_irq_domain_deactivate(struct irq_domain *domain,
 				    struct irq_data *data);
 
-void gpiochip_set_nested_irqchip(struct gpio_chip *gpiochip,
+void gpiochip_set_nested_irqchip(struct gpio_chip *gc,
 		struct irq_chip *irqchip,
 		unsigned int parent_irq);
 
-int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
+int gpiochip_irqchip_add_key(struct gpio_chip *gc,
 			     struct irq_chip *irqchip,
 			     unsigned int first_irq,
 			     irq_flow_handler_t handler,
@@ -596,7 +596,7 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
 			     struct lock_class_key *lock_key,
 			     struct lock_class_key *request_key);
 
-bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gpiochip,
+bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gc,
 				unsigned int offset);
 
 #ifdef CONFIG_LOCKDEP
@@ -607,7 +607,7 @@ bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gpiochip,
  * boilerplate static inlines provides such a key for each
  * unique instance.
  */
-static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+static inline int gpiochip_irqchip_add(struct gpio_chip *gc,
 				       struct irq_chip *irqchip,
 				       unsigned int first_irq,
 				       irq_flow_handler_t handler,
@@ -616,12 +616,12 @@ static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 	static struct lock_class_key lock_key;
 	static struct lock_class_key request_key;
 
-	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+	return gpiochip_irqchip_add_key(gc, irqchip, first_irq,
 					handler, type, false,
 					&lock_key, &request_key);
 }
 
-static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
+static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gc,
 			  struct irq_chip *irqchip,
 			  unsigned int first_irq,
 			  irq_flow_handler_t handler,
@@ -631,35 +631,35 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 	static struct lock_class_key lock_key;
 	static struct lock_class_key request_key;
 
-	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+	return gpiochip_irqchip_add_key(gc, irqchip, first_irq,
 					handler, type, true,
 					&lock_key, &request_key);
 }
 #else /* ! CONFIG_LOCKDEP */
-static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+static inline int gpiochip_irqchip_add(struct gpio_chip *gc,
 				       struct irq_chip *irqchip,
 				       unsigned int first_irq,
 				       irq_flow_handler_t handler,
 				       unsigned int type)
 {
-	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+	return gpiochip_irqchip_add_key(gc, irqchip, first_irq,
 					handler, type, false, NULL, NULL);
 }
 
-static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
+static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gc,
 			  struct irq_chip *irqchip,
 			  unsigned int first_irq,
 			  irq_flow_handler_t handler,
 			  unsigned int type)
 {
-	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+	return gpiochip_irqchip_add_key(gc, irqchip, first_irq,
 					handler, type, true, NULL, NULL);
 }
 #endif /* CONFIG_LOCKDEP */
 
-int gpiochip_generic_request(struct gpio_chip *chip, unsigned offset);
-void gpiochip_generic_free(struct gpio_chip *chip, unsigned offset);
-int gpiochip_generic_config(struct gpio_chip *chip, unsigned offset,
+int gpiochip_generic_request(struct gpio_chip *gc, unsigned offset);
+void gpiochip_generic_free(struct gpio_chip *gc, unsigned offset);
+int gpiochip_generic_config(struct gpio_chip *gc, unsigned offset,
 			    unsigned long config);
 
 /**
@@ -676,25 +676,25 @@ struct gpio_pin_range {
 
 #ifdef CONFIG_PINCTRL
 
-int gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
+int gpiochip_add_pin_range(struct gpio_chip *gc, const char *pinctl_name,
 			   unsigned int gpio_offset, unsigned int pin_offset,
 			   unsigned int npins);
-int gpiochip_add_pingroup_range(struct gpio_chip *chip,
+int gpiochip_add_pingroup_range(struct gpio_chip *gc,
 			struct pinctrl_dev *pctldev,
 			unsigned int gpio_offset, const char *pin_group);
-void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
+void gpiochip_remove_pin_ranges(struct gpio_chip *gc);
 
 #else /* ! CONFIG_PINCTRL */
 
 static inline int
-gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
+gpiochip_add_pin_range(struct gpio_chip *gc, const char *pinctl_name,
 		       unsigned int gpio_offset, unsigned int pin_offset,
 		       unsigned int npins)
 {
 	return 0;
 }
 static inline int
-gpiochip_add_pingroup_range(struct gpio_chip *chip,
+gpiochip_add_pingroup_range(struct gpio_chip *gc,
 			struct pinctrl_dev *pctldev,
 			unsigned int gpio_offset, const char *pin_group)
 {
@@ -702,27 +702,27 @@ gpiochip_add_pingroup_range(struct gpio_chip *chip,
 }
 
 static inline void
-gpiochip_remove_pin_ranges(struct gpio_chip *chip)
+gpiochip_remove_pin_ranges(struct gpio_chip *gc)
 {
 }
 
 #endif /* CONFIG_PINCTRL */
 
-struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip,
+struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *gc,
 					    unsigned int hwnum,
 					    const char *label,
 					    enum gpio_lookup_flags lflags,
 					    enum gpiod_flags dflags);
 void gpiochip_free_own_desc(struct gpio_desc *desc);
 
-void devprop_gpiochip_set_names(struct gpio_chip *chip,
+void devprop_gpiochip_set_names(struct gpio_chip *gc,
 				const struct fwnode_handle *fwnode);
 
 #ifdef CONFIG_GPIOLIB
 
 /* lock/unlock as IRQ */
-int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
-void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
+int gpiochip_lock_as_irq(struct gpio_chip *gc, unsigned int offset);
+void gpiochip_unlock_as_irq(struct gpio_chip *gc, unsigned int offset);
 
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
@@ -736,14 +736,14 @@ static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
 	return ERR_PTR(-ENODEV);
 }
 
-static inline int gpiochip_lock_as_irq(struct gpio_chip *chip,
+static inline int gpiochip_lock_as_irq(struct gpio_chip *gc,
 				       unsigned int offset)
 {
 	WARN_ON(1);
 	return -EINVAL;
 }
 
-static inline void gpiochip_unlock_as_irq(struct gpio_chip *chip,
+static inline void gpiochip_unlock_as_irq(struct gpio_chip *gc,
 					  unsigned int offset)
 {
 	WARN_ON(1);

commit d19d2de61fb131abcd29f7c61d3f168f687bfd6e
Author: Chuanhong Guo <gch981213@gmail.com>
Date:   Sun Mar 15 20:13:37 2020 +0800

    gpio: mmio: introduce BGPIOF_NO_SET_ON_INPUT
    
    Some gpio controllers ignores pin value writing when that pin is
    configured as input mode. As a result, bgpio_dir_out should set
    pin to output before configuring pin values or gpio pin values
    can't be set up properly.
    Introduce two variants of bgpio_dir_out: bgpio_dir_out_val_first
    and bgpio_dir_out_dir_first, and assign direction_output according
    to a new flag: BGPIOF_NO_SET_ON_INPUT.
    
    Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
    Tested-by: René van Dorst <opensource@vdorst.com>
    Reviewed-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 6ef05bccc0a6..ed65e00ee977 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -572,6 +572,7 @@ int bgpio_init(struct gpio_chip *gc, struct device *dev,
 #define BGPIOF_BIG_ENDIAN_BYTE_ORDER	BIT(3)
 #define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
 #define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
+#define BGPIOF_NO_SET_ON_INPUT		BIT(6)
 
 int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
 		     irq_hw_number_t hwirq);

commit 6ba3d7066c71d2103da255df19eb613d299bab15
Merge: fa889d85551e 122ce22cb37b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 09:51:36 2020 -0800

    Merge tag 'pinctrl-v5.6-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes, nothing too exciting about
      this.
    
      Some changes hit arch/sh and arch/arm but are well isolated and
      acknowledged by the respective arch maintainers.
    
      Core changes:
    
       - Dropped the chained IRQ setup callback into GPIOLIB as we got rid
         of the last users of that in this changeset.
    
      New drivers:
    
       - New driver for Ingenic X1830.
    
       - New driver for Freescale i.MX8MP.
    
      Driver enhancements:
    
       - Fix all remaining Intel drivers to pass their IRQ chips along with
         the GPIO chips.
    
       - Intel Baytrail allocates its irqchip dynamically.
    
       - Intel Lynxpoint is thoroughly rewritten and modernized.
    
       - Aspeed AST2600 pin muxing and configuration is much improved.
    
       - Qualcomm SC7180 functions are updated and wakeup interrupt map is
         provided.
    
       - A whole slew of Renesas SH-PFC cleanups and improvements.
    
       - Fix up the Intel DT bindings to use the generic YAML DT bindings
         schema (a first user of this)"
    
    * tag 'pinctrl-v5.6-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (99 commits)
      pinctrl: madera: Remove extra blank line
      pinctrl: qcom: Don't lock around irq_set_irq_wake()
      pinctrl: mvebu: armada-37xx: use use platform api
      gpio: Drop the chained IRQ handler assign function
      pinctrl: freescale: Add i.MX8MP pinctrl driver support
      dt-bindings: imx: Add pinctrl binding doc for i.MX8MP
      pinctrl: tigerlake: Tiger Lake uses _HID enumeration
      pinctrl: sunrisepoint: Add Coffee Lake-S ACPI ID
      pinctrl: iproc: Use platform_get_irq_optional() to avoid error message
      pinctrl: dt-bindings: Fix some errors in the lgm and pinmux schema
      pinctrl: intel: Pass irqchip when adding gpiochip
      pinctrl: intel: Add GPIO <-> pin mapping ranges via callback
      pinctrl: baytrail: Replace WARN with dev_info_once when setting direct-irq pin to output
      pinctrl: baytrail: Do not clear IRQ flags on direct-irq enabled pins
      pinctrl: sunrisepoint: Add missing Interrupt Status register offset
      pinctrl: sh-pfc: Split R-Car H3 support in two independent drivers
      pinctrl: artpec6: fix __iomem on reg in set
      pinctrl: ingenic: Use devm_platform_ioremap_resource()
      pinctrl: ingenic: Factorize irq_set_type function
      pinctrl: ingenic: Remove duplicated ingenic_chip_info structures
      ...

commit 72780ce5f1a4189f3c8dcfb1c596c65146452668
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 13 23:08:00 2020 +0100

    gpio: Drop the chained IRQ handler assign function
    
    gpiochip_set_chained_irqchip() would assign a chained handler
    to a GPIO chip. We now populate struct gpio_irq_chip for all
    chained GPIO irqchips so drop this function.
    
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20200113220800.77817-1-linus.walleij@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e2480ef94c55..7067bc70a473 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -585,11 +585,6 @@ int gpiochip_irq_domain_activate(struct irq_domain *domain,
 void gpiochip_irq_domain_deactivate(struct irq_domain *domain,
 				    struct irq_data *data);
 
-void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
-		struct irq_chip *irqchip,
-		unsigned int parent_irq,
-		irq_flow_handler_t parent_handler);
-
 void gpiochip_set_nested_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
 		unsigned int parent_irq);

commit 8b844d78a72a9975730f4a65d66f7388a4dd9c38
Merge: 6a77de2596a8 9c6722d85e92
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jan 17 09:00:35 2020 +0100

    Merge branch 'fixup-thunderx-hierarchy' into devel

commit 9c6722d85e92233082da2b3623685bba54d6093e
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Jan 16 17:50:03 2020 +0800

    gpio: Fix the no return statement warning
    
    In commit 242587616710 ("gpiolib: Add support for the irqdomain which
    doesn't use irq_fwspec as arg") we have changed the return type of
    gpiochip_populate_parent_fwspec_twocell/fourcell() from void to void *,
    but forgot to add a return statement for these two dummy functions.
    Add "return NULL" to fix the build warnings.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Link: https://lore.kernel.org/r/20200116095003.30324-1-haokexin@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 9bb43467ed11..00d9f5b464c7 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -549,12 +549,14 @@ static inline void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *ch
 						    unsigned int parent_hwirq,
 						    unsigned int parent_type)
 {
+	return NULL;
 }
 
 static inline void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
 						     unsigned int parent_hwirq,
 						     unsigned int parent_type)
 {
+	return NULL;
 }
 
 #endif /* CONFIG_IRQ_DOMAIN_HIERARCHY */

commit 242587616710576808dc8d7cdf18cfe0d7bf9831
Author: Kevin Hao <haokexin@gmail.com>
Date:   Tue Jan 14 16:28:19 2020 +0800

    gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg
    
    Some gpio's parent irqdomain may not use the struct irq_fwspec as
    argument, such as msi irqdomain. So rename the callback
    populate_parent_fwspec() to populate_parent_alloc_arg() and make it
    allocate and populate the specific struct which is needed by the
    parent irqdomain.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Link: https://lore.kernel.org/r/20200114082821.14015-3-haokexin@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e2480ef94c55..9bb43467ed11 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -94,16 +94,15 @@ struct gpio_irq_chip {
 				     unsigned int *parent_type);
 
 	/**
-	 * @populate_parent_fwspec:
+	 * @populate_parent_alloc_arg :
 	 *
-	 * This optional callback populates the &struct irq_fwspec for the
-	 * parent's IRQ domain. If this is not specified, then
+	 * This optional callback allocates and populates the specific struct
+	 * for the parent's IRQ domain. If this is not specified, then
 	 * &gpiochip_populate_parent_fwspec_twocell will be used. A four-cell
 	 * variant named &gpiochip_populate_parent_fwspec_fourcell is also
 	 * available.
 	 */
-	void (*populate_parent_fwspec)(struct gpio_chip *chip,
-				       struct irq_fwspec *fwspec,
+	void *(*populate_parent_alloc_arg)(struct gpio_chip *chip,
 				       unsigned int parent_hwirq,
 				       unsigned int parent_type);
 
@@ -537,26 +536,22 @@ struct bgpio_pdata {
 
 #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
 
-void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
-					     struct irq_fwspec *fwspec,
+void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
 					     unsigned int parent_hwirq,
 					     unsigned int parent_type);
-void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
-					      struct irq_fwspec *fwspec,
+void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
 					      unsigned int parent_hwirq,
 					      unsigned int parent_type);
 
 #else
 
-static inline void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
-						    struct irq_fwspec *fwspec,
+static inline void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
 						    unsigned int parent_hwirq,
 						    unsigned int parent_type)
 {
 }
 
-static inline void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
-						     struct irq_fwspec *fwspec,
+static inline void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
 						     unsigned int parent_hwirq,
 						     unsigned int parent_type)
 {

commit 06863620edfeadbe9e0ea5eb01dd94ce07f37549
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Tue Dec 24 13:06:59 2019 +0100

    gpiolib: convert the type of hwnum to unsigned int in gpiochip_get_desc()
    
    gpiochip_get_desc() takes a u16 hwnum, but it turns out most users don't
    respect that and usually pass an unsigned int. Since implicit casting to
    a smaller type is dangerous - let's change the type of hwnum to unsigned
    int in gpiochip_get_desc() and in gpiochip_request_own_desc() where the
    size of hwnum is not respected either and who's a user of the former.
    
    This is safe as we then check the hwnum against the number of lines
    before proceeding in gpiochip_get_desc().
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e2480ef94c55..4f032de10bae 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -715,7 +715,8 @@ gpiochip_remove_pin_ranges(struct gpio_chip *chip)
 
 #endif /* CONFIG_PINCTRL */
 
-struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
+struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip,
+					    unsigned int hwnum,
 					    const char *label,
 					    enum gpio_lookup_flags lflags,
 					    enum gpiod_flags dflags);

commit b056ca1c2f01b2d261c2dd6d167c17ac27977034
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Nov 4 18:09:39 2019 +0200

    gpiolib: Introduce ->add_pin_ranges() callback
    
    When IRQ chip is being added by GPIO library, the ACPI based platform expects
    GPIO <-> pin mapping ranges to be initialized in order to correctly initialize
    ACPI event mechanism on affected platforms. Unfortunately this step is missed.
    
    Introduce ->add_pin_ranges() callback to fill the above mentioned gap.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index cc9ade4552d9..e2480ef94c55 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -289,6 +289,9 @@ struct gpio_irq_chip {
  *	state (such as pullup/pulldown configuration).
  * @init_valid_mask: optional routine to initialize @valid_mask, to be used if
  *	not all GPIOs are valid.
+ * @add_pin_ranges: optional routine to initialize pin ranges, to be used when
+ *	requires special mapping of the pins that provides GPIO functionality.
+ *	It is called after adding GPIO chip and before adding IRQ chip.
  * @base: identifies the first GPIO number handled by this chip;
  *	or, if negative during registration, requests dynamic ID allocation.
  *	DEPRECATION: providing anything non-negative and nailing the base
@@ -379,6 +382,8 @@ struct gpio_chip {
 						   unsigned long *valid_mask,
 						   unsigned int ngpios);
 
+	int			(*add_pin_ranges)(struct gpio_chip *chip);
+
 	int			base;
 	u16			ngpio;
 	const char		*const *names;

commit 9208b1e77d6e8e9776f34f46ef4079ecac9c3c25
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Wed Nov 6 10:51:47 2019 +0200

    gpio: Add definition for GPIO direction
    
    At least for me it is difficult to remember the meaning of GPIO
    direction values. Define GPIO_LINE_DIRECTION_IN and
    GPIO_LINE_DIRECTION_OUT so that occasional GPIO contributors would
    not need to always check the meaning of hard coded values 1 and 0.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 5dd9c982e2cb..cc9ade4552d9 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -22,6 +22,9 @@ enum gpio_lookup_flags;
 
 struct gpio_chip;
 
+#define GPIO_LINE_DIRECTION_IN	1
+#define GPIO_LINE_DIRECTION_OUT	0
+
 /**
  * struct gpio_irq_chip - GPIO interrupt controller
  */

commit 9411e3aaa6342eb730daa55cf3377463a37d2aa7
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Oct 9 17:34:44 2019 +0300

    gpiolib: Initialize the hardware with a callback
    
    After changing the drivers to use GPIO core to add an IRQ chip
    it appears that some of them requires a hardware initialization
    before adding the IRQ chip.
    
    Add an optional callback ->init_hw() to allow that drivers
    to initialize hardware if needed.
    
    This change is a part of the fix NULL pointer dereference
    brought to the several drivers recently.
    
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index f8245d67f070..5dd9c982e2cb 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -201,6 +201,14 @@ struct gpio_irq_chip {
 	 */
 	bool threaded;
 
+	/**
+	 * @init_hw: optional routine to initialize hardware before
+	 * an IRQ chip will be added. This is quite useful when
+	 * a particular driver wants to clear IRQ related registers
+	 * in order to avoid undesired events.
+	 */
+	int (*init_hw)(struct gpio_chip *chip);
+
 	/**
 	 * @init_valid_mask: optional routine to initialize @valid_mask, to be
 	 * used if not all GPIO lines are valid interrupts. Sometimes some

commit 5fbe5b5883f847363ff1b7280e8b1d2980526b8e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 4 16:01:04 2019 +0200

    gpio: Initialize the irqchip valid_mask with a callback
    
    After changing the valid_mask for the struct gpio_chip
    to detect the need and presence of a valid mask with the
    presence of a .init_valid_mask() callback to fill it in,
    we augment the gpio_irq_chip to use the same logic.
    
    Switch all driver using the gpio_irq_chio valid_mask
    over to this new method.
    
    This makes sure the valid_mask for the gpio_irq_chip gets
    filled in when we add the gpio_chip, which makes it a
    little easier to switch over drivers using the old
    way of setting up gpio_irq_chip over to the new method
    of passing the gpio_irq_chip along with the gpio_chip.
    (See drivers/gpio/TODO for details.)
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andrew Jeffery <andrew@aj.id.au>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Patrice Chotard <patrice.chotard@st.com>
    Link: https://lore.kernel.org/r/20190904140104.32426-1-linus.walleij@linaro.org

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c667ad0c099d..f8245d67f070 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -202,11 +202,17 @@ struct gpio_irq_chip {
 	bool threaded;
 
 	/**
-	 * @need_valid_mask:
-	 *
-	 * If set core allocates @valid_mask with all bits set to one.
+	 * @init_valid_mask: optional routine to initialize @valid_mask, to be
+	 * used if not all GPIO lines are valid interrupts. Sometimes some
+	 * lines just cannot fire interrupts, and this routine, when defined,
+	 * is passed a bitmap in "valid_mask" and it will have ngpios
+	 * bits from 0..(ngpios-1) set to "1" as in valid. The callback can
+	 * then directly set some bits to "0" if they cannot be used for
+	 * interrupts.
 	 */
-	bool need_valid_mask;
+	void (*init_valid_mask)(struct gpio_chip *chip,
+				unsigned long *valid_mask,
+				unsigned int ngpios);
 
 	/**
 	 * @valid_mask:

commit ae0755b56da9db4190288155ea884331993ed51b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 5 11:20:25 2019 +0200

    gpio: Fix up merge collision in include file
    
    The merge of two different patch sets cleaning around in the
    main driver include file collided making the function
    declarations for gpiochip_[un]lock_as_irq() be defined twice
    when gpiolib was unselected. Fix it up.
    
    Cc: YueHaibing <yuehaibing@huawei.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index b74a3bee85e5..c667ad0c099d 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -702,11 +702,12 @@ void gpiochip_free_own_desc(struct gpio_desc *desc);
 void devprop_gpiochip_set_names(struct gpio_chip *chip,
 				const struct fwnode_handle *fwnode);
 
+#ifdef CONFIG_GPIOLIB
+
 /* lock/unlock as IRQ */
 int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 
-#ifdef CONFIG_GPIOLIB
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 

commit 8a6abcd04e4cdf6088f11212570c3e5ec36ee5c3
Merge: f6a7053ddcf1 f2ee73147a3f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 3 16:04:19 2019 +0200

    Merge tag 'gpio-v5.4-updates-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/brgl/linux into devel
    
    gpio: updates for v5.4
    
    - use a helper variable for &pdev->dev in gpio-em
    - tweak the ifdefs in GPIO headers
    - fix function links in HTML docs
    - remove an unneeded error message from ixp4xx
    - use the optional clk_get in gpio-mxc instead of checking the return value
    - a couple improvements in pca953x
    - allow to build gpio-lpc32xx on non-lpc32xx targets

commit c7663fa2a6631e5dddc1b7b2ba2e905ddffaff90
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Thu Aug 22 11:18:17 2019 +0800

    gpio: Move gpiochip_lock/unlock_as_irq to gpio/driver.h
    
    If CONFIG_GPIOLIB is not, gpiochip_lock/unlock_as_irq will
    conflict as this:
    
    In file included from sound/soc/codecs/wm5100.c:18:0:
    ./include/linux/gpio.h:224:19: error: static declaration of gpiochip_lock_as_irq follows non-static declaration
     static inline int gpiochip_lock_as_irq(struct gpio_chip *chip,
                       ^~~~~~~~~~~~~~~~~~~~
    In file included from sound/soc/codecs/wm5100.c:17:0:
    ./include/linux/gpio/driver.h:494:5: note: previous declaration of gpiochip_lock_as_irq was here
     int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
         ^~~~~~~~~~~~~~~~~~~~
    In file included from sound/soc/codecs/wm5100.c:18:0:
    ./include/linux/gpio.h:231:20: error: static declaration of gpiochip_unlock_as_irq follows non-static declaration
     static inline void gpiochip_unlock_as_irq(struct gpio_chip *chip,
                        ^~~~~~~~~~~~~~~~~~~~~~
    In file included from sound/soc/codecs/wm5100.c:17:0:
    ./include/linux/gpio/driver.h:495:6: note: previous declaration of gpiochip_unlock_as_irq was here
     void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
         ^~~~~~~~~~~~~~~~~~~~~~
    
    Move them to gpio/driver.h and use CONFIG_GPIOLIB guard this.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Fixes: d74be6dfea1b ("gpio: remove gpiod_lock/unlock_as_irq()")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Link: https://lore.kernel.org/r/20190822031817.32888-1-yuehaibing@huawei.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 340121c7d2fb..8d06a054abc8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -495,9 +495,6 @@ extern int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *chip,
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 
-/* lock/unlock as IRQ */
-int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
-void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 int gpiochip_reqres_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_relres_irq(struct gpio_chip *chip, unsigned int offset);
@@ -723,6 +720,10 @@ void gpiochip_free_own_desc(struct gpio_desc *desc);
 void devprop_gpiochip_set_names(struct gpio_chip *chip,
 				const struct fwnode_handle *fwnode);
 
+/* lock/unlock as IRQ */
+int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
+void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
+
 #else /* CONFIG_GPIOLIB */
 
 static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
@@ -732,6 +733,18 @@ static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
 	return ERR_PTR(-ENODEV);
 }
 
+static inline int gpiochip_lock_as_irq(struct gpio_chip *chip,
+				       unsigned int offset)
+{
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+static inline void gpiochip_unlock_as_irq(struct gpio_chip *chip,
+					  unsigned int offset)
+{
+	WARN_ON(1);
+}
 #endif /* CONFIG_GPIOLIB */
 
 #endif

commit eb1e8bd6e3900e3a3b9776cd1b09ecfc05573619
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 19 11:30:58 2019 +0200

    gpio: Use callback presence to determine need of valid_mask
    
    After we switched the two drivers that have .need_valid_mask
    set to use the callback for setting up the .valid_mask,
    we can just use the presence of the .init_valid_mask()
    callback (or the OF reserved ranges, nota bene) to determine
    whether to allocate the mask or not and we can drop the
    .need_valid_mask field altogether.
    
    Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
    Cc: Amelie Delaunay <amelie.delaunay@st.com>
    Cc: Stephen Boyd <swboyd@chromium.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190819093058.10863-1-linus.walleij@linaro.org

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index dc03323897ef..340121c7d2fb 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -403,15 +403,6 @@ struct gpio_chip {
 	struct gpio_irq_chip irq;
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 
-	/**
-	 * @need_valid_mask:
-	 *
-	 * If set core allocates @valid_mask with all its values initialized
-	 * with init_valid_mask() or set to one if init_valid_mask() is not
-	 * defined
-	 */
-	bool need_valid_mask;
-
 	/**
 	 * @valid_mask:
 	 *

commit c9fc5aff217267a9ef3a76450760534488870c69
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 19 10:49:04 2019 +0200

    gpio: Pass mask and size with the init_valid_mask()
    
    It is more helpful for drivers to have the affected fields
    directly available when we use the callback to set up the
    valid mask. Change this and switch over the only user
    (MSM) to use the passed parameters. If we do this we can
    also move the mask out of publicly visible struct fields.
    
    Cc: Stephen Boyd <swboyd@chromium.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190819084904.30027-1-linus.walleij@linaro.or
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 72d48a2bab65..dc03323897ef 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -363,7 +363,9 @@ struct gpio_chip {
 	void			(*dbg_show)(struct seq_file *s,
 						struct gpio_chip *chip);
 
-	int			(*init_valid_mask)(struct gpio_chip *chip);
+	int			(*init_valid_mask)(struct gpio_chip *chip,
+						   unsigned long *valid_mask,
+						   unsigned int ngpios);
 
 	int			base;
 	u16			ngpio;

commit f52a0c7b5eb907a12bc08a33cc998ed02dad3507
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Aug 16 21:38:12 2019 +1000

    gpio: stubs in headers should be inline
    
    Fixes: fdd61a013a24 ("gpio: Add support for hierarchical IRQ domains")
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Link: https://lore.kernel.org/r/20190816213812.40a130db@canb.auug.org.au
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 0e6d3b0c0211..72d48a2bab65 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -543,14 +543,14 @@ void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
 
 #else
 
-static void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+static inline void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
 						    struct irq_fwspec *fwspec,
 						    unsigned int parent_hwirq,
 						    unsigned int parent_type)
 {
 }
 
-static void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+static inline void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
 						     struct irq_fwspec *fwspec,
 						     unsigned int parent_hwirq,
 						     unsigned int parent_type)

commit fdd61a013a24f2699aec1a446f0168682b6f9ec4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Aug 8 14:32:37 2019 +0200

    gpio: Add support for hierarchical IRQ domains
    
    Hierarchical IRQ domains can be used to stack different IRQ
    controllers on top of each other.
    
    Bring hierarchical IRQ domains into the GPIOLIB core with the
    following basic idea:
    
    Drivers that need their interrupts handled hierarchically
    specify a callback to translate the child hardware IRQ and
    IRQ type for each GPIO offset to a parent hardware IRQ and
    parent hardware IRQ type.
    
    Users have to pass the callback, fwnode, and parent irqdomain
    before calling gpiochip_irqchip_add().
    
    We use the new method of just filling in the struct
    gpio_irq_chip before adding the gpiochip for all hierarchical
    irqchips of this type.
    
    The code path for device tree is pretty straight-forward,
    while the code path for old boardfiles or anything else will
    be more convoluted requireing upfront allocation of the
    interrupts when adding the chip.
    
    One specific use-case where this can be useful is if a power
    management controller has top-level controls for wakeup
    interrupts. In such cases, the power management controller can
    be a parent to other interrupt controllers and program
    additional registers when an IRQ has its wake capability
    enabled or disabled.
    
    The hierarchical irqchip helper code will only be available
    when IRQ_DOMAIN_HIERARCHY is selected to GPIO chips using
    this should select or depend on that symbol. When using
    hierarchical IRQs, the parent interrupt controller must
    also be hierarchical all the way up to the top interrupt
    controller wireing directly into the CPU, so on systems
    that do not have this we can get rid of all the extra
    code for supporting hierarchical irqs.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Lina Iyer <ilina@codeaurora.org>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: Sowjanya Komatineni <skomatineni@nvidia.com>
    Cc: Bitan Biswas <bbiswas@nvidia.com>
    Cc: linux-tegra@vger.kernel.org
    Cc: David Daney <david.daney@cavium.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Co-developed-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190808123242.5359-1-linus.walleij@linaro.org

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 6a0e420915a3..0e6d3b0c0211 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -23,6 +23,9 @@ enum gpio_lookup_flags;
 #ifdef CONFIG_GPIOLIB
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
+
+struct gpio_chip;
+
 /**
  * struct gpio_irq_chip - GPIO interrupt controller
  */
@@ -49,6 +52,84 @@ struct gpio_irq_chip {
 	 */
 	const struct irq_domain_ops *domain_ops;
 
+#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+	/**
+	 * @fwnode:
+	 *
+	 * Firmware node corresponding to this gpiochip/irqchip, necessary
+	 * for hierarchical irqdomain support.
+	 */
+	struct fwnode_handle *fwnode;
+
+	/**
+	 * @parent_domain:
+	 *
+	 * If non-NULL, will be set as the parent of this GPIO interrupt
+	 * controller's IRQ domain to establish a hierarchical interrupt
+	 * domain. The presence of this will activate the hierarchical
+	 * interrupt support.
+	 */
+	struct irq_domain *parent_domain;
+
+	/**
+	 * @child_to_parent_hwirq:
+	 *
+	 * This callback translates a child hardware IRQ offset to a parent
+	 * hardware IRQ offset on a hierarchical interrupt chip. The child
+	 * hardware IRQs correspond to the GPIO index 0..ngpio-1 (see the
+	 * ngpio field of struct gpio_chip) and the corresponding parent
+	 * hardware IRQ and type (such as IRQ_TYPE_*) shall be returned by
+	 * the driver. The driver can calculate this from an offset or using
+	 * a lookup table or whatever method is best for this chip. Return
+	 * 0 on successful translation in the driver.
+	 *
+	 * If some ranges of hardware IRQs do not have a corresponding parent
+	 * HWIRQ, return -EINVAL, but also make sure to fill in @valid_mask and
+	 * @need_valid_mask to make these GPIO lines unavailable for
+	 * translation.
+	 */
+	int (*child_to_parent_hwirq)(struct gpio_chip *chip,
+				     unsigned int child_hwirq,
+				     unsigned int child_type,
+				     unsigned int *parent_hwirq,
+				     unsigned int *parent_type);
+
+	/**
+	 * @populate_parent_fwspec:
+	 *
+	 * This optional callback populates the &struct irq_fwspec for the
+	 * parent's IRQ domain. If this is not specified, then
+	 * &gpiochip_populate_parent_fwspec_twocell will be used. A four-cell
+	 * variant named &gpiochip_populate_parent_fwspec_fourcell is also
+	 * available.
+	 */
+	void (*populate_parent_fwspec)(struct gpio_chip *chip,
+				       struct irq_fwspec *fwspec,
+				       unsigned int parent_hwirq,
+				       unsigned int parent_type);
+
+	/**
+	 * @child_offset_to_irq:
+	 *
+	 * This optional callback is used to translate the child's GPIO line
+	 * offset on the GPIO chip to an IRQ number for the GPIO to_irq()
+	 * callback. If this is not specified, then a default callback will be
+	 * provided that returns the line offset.
+	 */
+	unsigned int (*child_offset_to_irq)(struct gpio_chip *chip,
+					    unsigned int pin);
+
+	/**
+	 * @child_irq_domain_ops:
+	 *
+	 * The IRQ domain operations that will be used for this GPIO IRQ
+	 * chip. If no operations are provided, then default callbacks will
+	 * be populated to setup the IRQ hierarchy. Some drivers need to
+	 * supply their own translate function.
+	 */
+	struct irq_domain_ops child_irq_domain_ops;
+#endif
+
 	/**
 	 * @handler:
 	 *
@@ -449,6 +530,36 @@ struct bgpio_pdata {
 	int ngpio;
 };
 
+#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+
+void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+					     struct irq_fwspec *fwspec,
+					     unsigned int parent_hwirq,
+					     unsigned int parent_type);
+void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+					      struct irq_fwspec *fwspec,
+					      unsigned int parent_hwirq,
+					      unsigned int parent_type);
+
+#else
+
+static void gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+						    struct irq_fwspec *fwspec,
+						    unsigned int parent_hwirq,
+						    unsigned int parent_type)
+{
+}
+
+static void gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+						     struct irq_fwspec *fwspec,
+						     unsigned int parent_hwirq,
+						     unsigned int parent_type)
+{
+}
+
+#endif /* CONFIG_IRQ_DOMAIN_HIERARCHY */
+
+
 #if IS_ENABLED(CONFIG_GPIO_GENERIC)
 
 int bgpio_init(struct gpio_chip *gc, struct device *dev,

commit 9091373ab7ea27cad381ce71aa37de6b9e687e81
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jul 30 14:43:47 2019 +0900

    gpio: remove less important #ifdef around declarations
    
    The whole struct/function declarations in this header are surrounded
    by #ifdef.
    
    As far as I understood, the motivation of this is probably to break
    the build earlier if a driver misses to select or depend on correct
    CONFIG options in Kconfig.
    
    Since commit 94bed2a9c4ae ("Add -Werror-implicit-function-declaration")
    no one cannot call functions that have not been declared.
    
    So, I see some benefit in doing this in the cost of uglier headers.
    
    In reality, it would not be so easy to catch missed 'select' or
    'depends on' because GPIOLIB, GPIOLIB_IRQCHIP etc. are already selected
    by someone else eventually. So, this kind of error, if any, will be
    caught by randconfig bots.
    
    In summary, I am not a big fan of cluttered #ifdef nesting, and this
    does not matter for normal developers. The code readability wins.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 6a0e420915a3..f28f534f451a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -20,9 +20,6 @@ struct module;
 enum gpiod_flags;
 enum gpio_lookup_flags;
 
-#ifdef CONFIG_GPIOLIB
-
-#ifdef CONFIG_GPIOLIB_IRQCHIP
 /**
  * struct gpio_irq_chip - GPIO interrupt controller
  */
@@ -161,7 +158,6 @@ struct gpio_irq_chip {
 	 */
 	void		(*irq_disable)(struct irq_data *data);
 };
-#endif /* CONFIG_GPIOLIB_IRQCHIP */
 
 /**
  * struct gpio_chip - abstract a GPIO controller
@@ -441,16 +437,12 @@ bool gpiochip_line_is_valid(const struct gpio_chip *chip, unsigned int offset);
 /* get driver data */
 void *gpiochip_get_data(struct gpio_chip *chip);
 
-struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
-
 struct bgpio_pdata {
 	const char *label;
 	int base;
 	int ngpio;
 };
 
-#if IS_ENABLED(CONFIG_GPIO_GENERIC)
-
 int bgpio_init(struct gpio_chip *gc, struct device *dev,
 	       unsigned long sz, void __iomem *dat, void __iomem *set,
 	       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,
@@ -463,10 +455,6 @@ int bgpio_init(struct gpio_chip *gc, struct device *dev,
 #define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
 #define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
 
-#endif /* CONFIG_GPIO_GENERIC */
-
-#ifdef CONFIG_GPIOLIB_IRQCHIP
-
 int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
 		     irq_hw_number_t hwirq);
 void gpiochip_irq_unmap(struct irq_domain *d, unsigned int irq);
@@ -555,15 +543,11 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 }
 #endif /* CONFIG_LOCKDEP */
 
-#endif /* CONFIG_GPIOLIB_IRQCHIP */
-
 int gpiochip_generic_request(struct gpio_chip *chip, unsigned offset);
 void gpiochip_generic_free(struct gpio_chip *chip, unsigned offset);
 int gpiochip_generic_config(struct gpio_chip *chip, unsigned offset,
 			    unsigned long config);
 
-#ifdef CONFIG_PINCTRL
-
 /**
  * struct gpio_pin_range - pin range controlled by a gpio chip
  * @node: list for maintaining set of pin ranges, used internally
@@ -576,6 +560,8 @@ struct gpio_pin_range {
 	struct pinctrl_gpio_range range;
 };
 
+#ifdef CONFIG_PINCTRL
+
 int gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
 			   unsigned int gpio_offset, unsigned int pin_offset,
 			   unsigned int npins);
@@ -586,8 +572,6 @@ void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
 
 #else /* ! CONFIG_PINCTRL */
 
-struct pinctrl_dev;
-
 static inline int
 gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
 		       unsigned int gpio_offset, unsigned int pin_offset,
@@ -619,6 +603,11 @@ void gpiochip_free_own_desc(struct gpio_desc *desc);
 void devprop_gpiochip_set_names(struct gpio_chip *chip,
 				const struct fwnode_handle *fwnode);
 
+
+#ifdef CONFIG_GPIOLIB
+
+struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
+
 #else /* CONFIG_GPIOLIB */
 
 static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
@@ -630,4 +619,4 @@ static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
 
 #endif /* CONFIG_GPIOLIB */
 
-#endif
+#endif /* __LINUX_GPIO_DRIVER_H */

commit 43c95d3694cc448fdf50bd53b7ff3a5bb4655883
Merge: 073c916bc005 4c105769bf6d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 15:02:27 2019 -0700

    Merge tag 'pinctrl-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for the v5.3 kernel cycle:
    
      Core changes:
    
       - Device links can optionally be added between a pin control producer
         and its consumers. This will affect how the system power management
         is handled: a pin controller will not suspend before all of its
         consumers have been suspended.
    
         This was necessary for the ST Microelectronics STMFX expander and
         need to be tested on other systems as well: it makes sense to make
         this default in the long run.
    
         Right now it is opt-in per driver.
    
       - Drive strength can be specified in microamps. With decreases in
         silicon technology, milliamps isn't granular enough, let's make it
         possible to select drive strengths in microamps.
    
         Right now the Meson (AMlogic) driver needs this.
    
      New drivers:
    
       - New subdriver for the Tegra 194 SoC.
    
       - New subdriver for the Qualcomm SDM845.
    
       - New subdriver for the Qualcomm SM8150.
    
       - New subdriver for the Freescale i.MX8MN (Freescale is now a product
         line of NXP).
    
       - New subdriver for Marvell MV98DX1135.
    
      Driver improvements:
    
       - The Bitmain BM1880 driver now supports pin config in addition to
         muxing.
    
       - The Qualcomm drivers can now reserve some GPIOs as taken aside and
         not usable for users. This is used in ACPI systems to take out some
         GPIO lines used by the BIOS so that noone else (neither kernel nor
         userspace) will play with them by mistake and crash the machine.
    
       - A slew of refurbishing around the Aspeed drivers (board management
         controllers for servers) in preparation for the new Aspeed AST2600
         SoC.
    
       - A slew of improvements over the SH PFC drivers as usual.
    
       - Misc cleanups and fixes"
    
    * tag 'pinctrl-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (106 commits)
      pinctrl: aspeed: Strip moved macros and structs from private header
      pinctrl: aspeed: Fix missed include
      pinctrl: baytrail: Use GENMASK() consistently
      pinctrl: baytrail: Re-use data structures from pinctrl-intel.h
      pinctrl: baytrail: Use defined macro instead of magic in byt_get_gpio_mux()
      pinctrl: qcom: Add SM8150 pinctrl driver
      dt-bindings: pinctrl: qcom: Add SM8150 pinctrl binding
      dt-bindings: pinctrl: qcom: Document missing gpio nodes
      pinctrl: aspeed: Add implementation-related documentation
      pinctrl: aspeed: Split out pinmux from general pinctrl
      pinctrl: aspeed: Clarify comment about strapping W1C
      pinctrl: aspeed: Correct comment that is no longer true
      MAINTAINERS: Add entry for ASPEED pinctrl drivers
      dt-bindings: pinctrl: aspeed: Convert AST2500 bindings to json-schema
      dt-bindings: pinctrl: aspeed: Convert AST2400 bindings to json-schema
      dt-bindings: pinctrl: aspeed: Split bindings document in two
      pinctrl: qcom: Add irq_enable callback for msm gpio
      pinctrl: madera: Fixup SPDX headers
      pinctrl: qcom: sdm845: Fix CONFIG preprocessor guard
      pinctrl: tegra: Add bitmask support for parked bits
      ...

commit f99d479bcb78ecc0243f1fcc53d7081fa150d7eb
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jul 1 16:26:50 2019 +0200

    gpiolib: Document new gpio_chip.init_valid_mask field
    
    A new field init_valid_mask was added to struct gpio_chip, but it was
    not documented.
    
    Fixes: f8ec92a9f63b3b11 ("gpiolib: Add init_valid_mask exported function")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20190701142650.25122-1-geert+renesas@glider.be
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 5d325fd29d6b..8d58386aadd5 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -194,6 +194,8 @@ struct gpio_irq_chip {
  * @dbg_show: optional routine to show contents in debugfs; default code
  *	will be used when this is omitted, but custom code can show extra
  *	state (such as pullup/pulldown configuration).
+ * @init_valid_mask: optional routine to initialize @valid_mask, to be used if
+ *	not all GPIOs are valid.
  * @base: identifies the first GPIO number handled by this chip;
  *	or, if negative during registration, requests dynamic ID allocation.
  *	DEPRECATION: providing anything non-negative and nailing the base

commit f310f2eff794f96b4ea87be7f5938e57c34a64f1
Author: Enrico Weigelt <info@metux.net>
Date:   Mon Jun 17 18:45:05 2019 +0200

    gpio: Add comments on #if/#else/#endif
    
    Improve readability a bit by commenting #if/#else/#endif statements
    with the checked preprocessor symbols.
    
    Signed-off-by: Enrico Weigelt <info@metux.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 02698c0f34ea..5d325fd29d6b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -161,7 +161,7 @@ struct gpio_irq_chip {
 	 */
 	void		(*irq_disable)(struct irq_data *data);
 };
-#endif
+#endif /* CONFIG_GPIOLIB_IRQCHIP */
 
 /**
  * struct gpio_chip - abstract a GPIO controller
@@ -301,7 +301,7 @@ struct gpio_chip {
 	spinlock_t bgpio_lock;
 	unsigned long bgpio_data;
 	unsigned long bgpio_dir;
-#endif
+#endif /* CONFIG_GPIO_GENERIC */
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	/*
@@ -316,7 +316,7 @@ struct gpio_chip {
 	 * used to handle IRQs for most practical cases.
 	 */
 	struct gpio_irq_chip irq;
-#endif
+#endif /* CONFIG_GPIOLIB_IRQCHIP */
 
 	/**
 	 * @need_valid_mask:
@@ -363,7 +363,7 @@ struct gpio_chip {
 	 */
 	int (*of_xlate)(struct gpio_chip *gc,
 			const struct of_phandle_args *gpiospec, u32 *flags);
-#endif
+#endif /* CONFIG_OF_GPIO */
 };
 
 extern const char *gpiochip_is_requested(struct gpio_chip *chip,
@@ -406,7 +406,7 @@ extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
 	})
 #else
 #define gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL, NULL)
-#endif
+#endif /* CONFIG_LOCKDEP */
 
 static inline int gpiochip_add(struct gpio_chip *chip)
 {
@@ -461,7 +461,7 @@ int bgpio_init(struct gpio_chip *gc, struct device *dev,
 #define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
 #define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
 
-#endif
+#endif /* CONFIG_GPIO_GENERIC */
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 
@@ -531,7 +531,7 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 					handler, type, true,
 					&lock_key, &request_key);
 }
-#else
+#else /* ! CONFIG_LOCKDEP */
 static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 				       struct irq_chip *irqchip,
 				       unsigned int first_irq,
@@ -582,7 +582,7 @@ int gpiochip_add_pingroup_range(struct gpio_chip *chip,
 			unsigned int gpio_offset, const char *pin_group);
 void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
 
-#else
+#else /* ! CONFIG_PINCTRL */
 
 static inline int
 gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,

commit 4892d3a6a009f7eba2e806b9183e5d8790769f41
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jun 14 10:12:26 2019 +0200

    gpio: Drop the parent_irq from gpio_irq_chip
    
    We already have an array named "parents" so instead
    of letting one point to the other, simply allocate a
    dynamic array to hold the parents, just one if desired
    and drop the number of members in gpio_irq_chip by
    1. Rename gpiochip to gc in the process.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 937c40fb61f7..02698c0f34ea 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -102,13 +102,6 @@ struct gpio_irq_chip {
 	 */
 	unsigned int num_parents;
 
-	/**
-	 * @parent_irq:
-	 *
-	 * For use by gpiochip_set_cascaded_irqchip()
-	 */
-	unsigned int parent_irq;
-
 	/**
 	 * @parents:
 	 *

commit d664c43958e0d9e0b34e23b6f8a8f4cf8ec61a2e
Author: Enrico Weigelt <info@metux.net>
Date:   Wed Jun 12 23:59:36 2019 +0200

    gpio: Fix build warnings on undefined struct pinctrl_dev
    
    This fixes the warnings:
    
    * include/linux/gpio.h:254:11: warning: 'struct pinctrl_dev' declared
      inside parameter list will not be visible outside of this definition
      or declaration
    * include/linux/gpio/driver.h:602:11: warning: 'struct pinctrl_dev'
      declared inside parameter list will not be visible outside of this
      definition or declaration
    
    Fixes: 78b99577b393 ("pinctrl: remove unused pin_is_valid()")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Enrico Weigelt <info@metux.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a1d273c96016..b58b27c11355 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -590,6 +590,8 @@ void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
 
 #else
 
+struct pinctrl_dev;
+
 static inline int
 gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
 		       unsigned int gpio_offset, unsigned int pin_offset,

commit 5923ea6c2ce626f0aa8a547d5b7e5fce705dd3dc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 26 14:40:18 2019 +0200

    gpio: pass lookup and descriptor flags to request_own
    
    When a gpio_chip wants to request a descriptor from itself
    using gpiochip_request_own_desc() it needs to be able to specify
    fully how to use the descriptor, notably line inversion
    semantics. The workaround in the gpiolib.c can be removed
    and cases (such as SPI CS) where we need at times to request
    a GPIO with line inversion semantics directly on a chip for
    workarounds, can be fully supported with this call.
    
    Fix up some users of the API that weren't really using the
    last flag to set up the line as input or output properly
    but instead just calling direction setting explicitly
    after requesting the line.
    
    Cc: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a1d273c96016..937c40fb61f7 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -18,6 +18,7 @@ struct seq_file;
 struct gpio_device;
 struct module;
 enum gpiod_flags;
+enum gpio_lookup_flags;
 
 #ifdef CONFIG_GPIOLIB
 
@@ -614,7 +615,8 @@ gpiochip_remove_pin_ranges(struct gpio_chip *chip)
 
 struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
 					    const char *label,
-					    enum gpiod_flags flags);
+					    enum gpio_lookup_flags lflags,
+					    enum gpiod_flags dflags);
 void gpiochip_free_own_desc(struct gpio_desc *desc);
 
 void devprop_gpiochip_set_names(struct gpio_chip *chip,

commit 8148c17b179d8acad190551fe0fb90d8f5193990
Merge: 6fe567df04a2 0fbee1df2078
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 11 10:54:43 2019 -0400

    Merge tag 'gpio-v5.2-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull gpio updates from Linus Walleij:
     "This is the bulk of the GPIO changes for the v5.2 kernel cycle. A bit
      later than usual because I was ironing out my own mistakes. I'm
      holding some stuff back for the next kernel as a result, and this
      should be a healthy and well tested batch.
    
      Core changes:
    
       - The gpiolib MMIO driver has been enhanced to handle two direction
         registers, i.e. one register to set lines as input and one register
         to set lines as output. It turns out some silicon engineer thinks
         the ability to configure a line as input and output at the same
         time makes sense, this can be debated but includes a lot of analog
         electronics reasoning, and the registers are there and need to be
         handled consistently. Unsurprisingly, we enforce the lines to be
         either inputs or outputs in such schemes.
    
       - Send in the proper argument value to .set_config() dispatched to
         the pin control subsystem. Nobody used it before, now someone does,
         so fix it to work as expected.
    
       - The ACPI gpiolib portions can now handle pin bias setting (pull up
         or pull down). This has been in the ACPI spec for years and we
         finally have it properly integrated with Linux GPIOs. It was based
         on an observation from Andy Schevchenko that Thomas Petazzoni's
         changes to the core for biasing the PCA950x GPIO expander actually
         happen to fit hand-in-glove with what the ACPI core needed. Such
         nice synergies happen sometimes.
    
      New drivers:
    
       - A new driver for the Mellanox BlueField GPIO controller. This is
         using 64bit MMIO registers and can configure lines as inputs and
         outputs at the same time and after improving the MMIO library we
         handle it just fine. Interesting.
    
       - A new IXP4xx proper gpiochip driver with hierarchical interrupts
         should be coming in from the ARM SoC tree as well.
    
      Driver enhancements:
    
       - The PCA053x driver handles the CAT9554 GPIO expander.
    
       - The PCA053x driver handles the NXP PCAL6416 GPIO expander.
    
       - Wake-up support on PCA053x GPIO lines.
    
       - OMAP now does a nice asynchronous IRQ handling on wake-ups by
         letting everything wake up on edges, and this makes runtime PM work
         as expected too.
    
      Misc:
    
       - Several cleanups such as devres fixes.
    
       - Get rid of some languager comstructs that cause problems when
         compiling with LLVMs clang.
    
       - Documentation review and update"
    
    * tag 'gpio-v5.2-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (85 commits)
      gpio: Update documentation
      docs: gpio: convert docs to ReST and rename to *.rst
      gpio: sch: Remove write-only core_base
      gpio: pxa: Make two symbols static
      gpiolib: acpi: Respect pin bias setting
      gpiolib: acpi: Add acpi_gpio_update_gpiod_lookup_flags() helper
      gpiolib: acpi: Set pin value, based on bias, more accurately
      gpiolib: acpi: Change type of dflags
      gpiolib: Introduce GPIO_LOOKUP_FLAGS_DEFAULT
      gpiolib: Make use of enum gpio_lookup_flags consistent
      gpiolib: Indent entry values of enum gpio_lookup_flags
      gpio: pca953x: add support for pca6416
      dt-bindings: gpio: pca953x: document the nxp,pca6416
      gpio: pca953x: add pcal6416 to the of_device_id table
      gpio: gpio-omap: Remove conditional pm_runtime handling for GPIO interrupts
      gpio: gpio-omap: configure edge detection for level IRQs for idle wakeup
      tracing: stop making gpio tracing configurable
      gpio: pca953x: Configure wake-up path when wake-up is enabled
      gpio: of: Optimize quirk checks
      gpio: mmio: Drop bgpio_dir_inverted
      ...

commit 27157af66324d529b43231c12b5d1e1a3e9fa620
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Apr 4 23:55:14 2019 +0700

    gpio: mmio: Drop bgpio_dir_inverted
    
    The direction inversion semantics are now handled by simply
    using the registers for in/out available, no need to keep
    track of inversion semantics exmplicitly anymore.
    
    Reviewed-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Jan Kotas <jank@cadence.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 95a51794c24a..4d69d458cf9f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -229,9 +229,6 @@ struct gpio_irq_chip {
  * @reg_clr: output clear register (out=low) for generic GPIO
  * @reg_dir_out: direction out setting register for generic GPIO
  * @reg_dir_in: direction in setting register for generic GPIO
- * @bgpio_dir_inverted: indicates that the direction register is inverted
- *	(gpiolib private state variable) this means @reg_dir_in is
- *	available but not @reg_dir_out.
  * @bgpio_dir_unreadable: indicates that the direction register(s) cannot
  *	be read and we need to rely on out internal state tracking.
  * @bgpio_bits: number of register bits used for a generic GPIO i.e.
@@ -305,7 +302,6 @@ struct gpio_chip {
 	void __iomem *reg_clr;
 	void __iomem *reg_dir_out;
 	void __iomem *reg_dir_in;
-	bool bgpio_dir_inverted;
 	bool bgpio_dir_unreadable;
 	int bgpio_bits;
 	spinlock_t bgpio_lock;

commit f69e00bd21aa6a1961c521b6eb199137fcb8a76a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 22 11:14:44 2019 +0100

    gpio: mmio: Support two direction registers
    
    It turns out that one specific hardware has two direction
    registers: one to set a GPIO line as input and another one
    to set a GPIO line as output. So in theory a line can be
    configured as input and output at the same time.
    
    Make the MMIO GPIO helper deal with this: store both
    registers in the state container, use both in the generic
    code if present. Synchronize the input register to the
    output register when we register a GPIO chip, with the
    output settings taking precedence.
    
    Keep the helper variable to detect inverted direction
    semantics (only direction in register) but augment the
    code to be more straight-forward for the generic case
    when setting the registers.
    
    Fix some flunky with unreadable direction registers at
    the same time as we're touching this code.
    
    Cc: David Woods <dwoods@mellanox.com>
    Cc: Shravan Kumar Ramani <sramani@mellanox.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 01497910f023..95a51794c24a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -227,9 +227,13 @@ struct gpio_irq_chip {
  * @reg_dat: data (in) register for generic GPIO
  * @reg_set: output set register (out=high) for generic GPIO
  * @reg_clr: output clear register (out=low) for generic GPIO
- * @reg_dir: direction setting register for generic GPIO
+ * @reg_dir_out: direction out setting register for generic GPIO
+ * @reg_dir_in: direction in setting register for generic GPIO
  * @bgpio_dir_inverted: indicates that the direction register is inverted
- *	(gpiolib private state variable)
+ *	(gpiolib private state variable) this means @reg_dir_in is
+ *	available but not @reg_dir_out.
+ * @bgpio_dir_unreadable: indicates that the direction register(s) cannot
+ *	be read and we need to rely on out internal state tracking.
  * @bgpio_bits: number of register bits used for a generic GPIO i.e.
  *	<register width> * 8
  * @bgpio_lock: used to lock chip->bgpio_data. Also, this is needed to keep
@@ -237,7 +241,8 @@ struct gpio_irq_chip {
  * @bgpio_data:	shadowed data register for generic GPIO to clear/set bits
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
- *	direction safely.
+ *	direction safely. A "1" in this word means the line is set as
+ *	output.
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
  * they can all be accessed through a common programing interface.
@@ -298,8 +303,10 @@ struct gpio_chip {
 	void __iomem *reg_dat;
 	void __iomem *reg_set;
 	void __iomem *reg_clr;
-	void __iomem *reg_dir;
+	void __iomem *reg_dir_out;
+	void __iomem *reg_dir_in;
 	bool bgpio_dir_inverted;
+	bool bgpio_dir_unreadable;
 	int bgpio_bits;
 	spinlock_t bgpio_lock;
 	unsigned long bgpio_data;

commit 64ebde5b0fdb69fc4061bea0de661421af54f918
Author: Jan Kundrát <jan.kundrat@cesnet.cz>
Date:   Thu Mar 7 14:30:13 2019 +0100

    gpiolib: export devprop_gpiochip_set_names()
    
    This function is needed in mcp23s08. That driver is a special snowflake
    because it supports several hardware chips as a single "GPIO chip" under
    Linux.
    
    Signed-off-by: Jan Kundrát <jan.kundrat@cesnet.cz>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Phil Reid <preid@electromag.com.au>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 01497910f023..951be1715c12 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -614,6 +614,9 @@ struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
 					    enum gpiod_flags flags);
 void gpiochip_free_own_desc(struct gpio_desc *desc);
 
+void devprop_gpiochip_set_names(struct gpio_chip *chip,
+				const struct fwnode_handle *fwnode);
+
 #else /* CONFIG_GPIOLIB */
 
 static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)

commit ef74f70e5a10cc2a78cc5529e564170cabcda9af
Author: Brian Masney <masneyb@onstation.org>
Date:   Sat Jan 19 15:42:42 2019 -0500

    gpio: add irq domain activate/deactivate functions
    
    This adds the two new functions gpiochip_irq_domain_activate and
    gpiochip_irq_domain_deactivate that can be used as the activate and
    deactivate functions in the struct irq_domain_ops. This is for
    situations where only gpiochip_{lock,unlock}_as_irq needs to be called.
    SPMI and SSBI GPIO are two users that will initially use these
    functions.
    
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Suggested-by: Stephen Boyd <sboyd@kernel.org>
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 07cddbf45186..01497910f023 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -472,6 +472,11 @@ int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
 		     irq_hw_number_t hwirq);
 void gpiochip_irq_unmap(struct irq_domain *d, unsigned int irq);
 
+int gpiochip_irq_domain_activate(struct irq_domain *domain,
+				 struct irq_data *data, bool reserve);
+void gpiochip_irq_domain_deactivate(struct irq_domain *domain,
+				    struct irq_data *data);
+
 void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
 		unsigned int parent_irq,

commit 21abf103818a4735e80fb0ab03934bed8ae9a028
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 4 13:31:45 2018 +0200

    gpio: Pass a flag to gpiochip_request_own_desc()
    
    Before things go out of hand, make it possible to pass
    flags when requesting "own" descriptors from a gpio_chip.
    This is necessary if the chip wants to request a GPIO with
    active low semantics, for example.
    
    Cc: Janusz Krzysztofik <jmkrzyszt@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 9c8d5d491680..07cddbf45186 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -17,6 +17,7 @@ struct device_node;
 struct seq_file;
 struct gpio_device;
 struct module;
+enum gpiod_flags;
 
 #ifdef CONFIG_GPIOLIB
 
@@ -604,7 +605,8 @@ gpiochip_remove_pin_ranges(struct gpio_chip *chip)
 #endif /* CONFIG_PINCTRL */
 
 struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
-					    const char *label);
+					    const char *label,
+					    enum gpiod_flags flags);
 void gpiochip_free_own_desc(struct gpio_desc *desc);
 
 #else /* CONFIG_GPIOLIB */

commit eee3919c5f2949a8b7b1e9fa239d153be1538656
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Nov 12 15:10:28 2018 +0100

    gpio: drop broken to_gpio_irq_chip() helper
    
    Drop the broken to_gpio_irq_chip() container_of() helper, which would
    break the build for anyone who tries to use it.
    
    Specifically, struct gpio_irq_chip only holds a pointer to a struct
    irq_chip so using container_of() on an irq-chip pointer makes no sense.
    
    Fixes: da80ff81a8f5 ("gpio: Move irqchip into struct gpio_irq_chip")
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index f70d976e1395..9c8d5d491680 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -166,11 +166,6 @@ struct gpio_irq_chip {
 	 */
 	void		(*irq_disable)(struct irq_data *data);
 };
-
-static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
-{
-	return container_of(chip, struct gpio_irq_chip, chip);
-}
 #endif
 
 /**

commit 48207d7595d2be604e21228e5a93aaff17e4b808
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Oct 5 21:42:06 2018 +0200

    gpio: drop devm_gpiochip_remove()
    
    There is hardly any reason to call devm_gpiochip_remove() because the
    driver core handles calling gpiochip_remove() automatically.
    
    To make it harder to introduce new (and probably unneeded) callers, drop
    the function.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 2db62b550b95..f70d976e1395 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -422,7 +422,6 @@ static inline int gpiochip_add(struct gpio_chip *chip)
 extern void gpiochip_remove(struct gpio_chip *chip);
 extern int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *chip,
 				  void *data);
-extern void devm_gpiochip_remove(struct device *dev, struct gpio_chip *chip);
 
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));

commit 114b5f8f7efc036dd7dd16efb0f218a88e6c6c02
Merge: b0b6a28bc4b2 40f5ff4f9f23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 23 08:45:05 2018 +0100

    Merge tag 'gpio-v4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.20 series:
    
      Core changes:
    
       - A patch series from Hans Verkuil to make it possible to
         enable/disable IRQs on a GPIO line at runtime and drive GPIO lines
         as output without having to put/get them from scratch.
    
         The irqchip callbacks have been improved so that they can use only
         the fastpatch callbacks to enable/disable irqs like any normal
         irqchip, especially the gpiod_lock_as_irq() has been improved to be
         callable in fastpath context.
    
         A bunch of rework had to be done to achieve this but it is a big
         win since I never liked to restrict this to slowpath. The only call
         requireing slowpath was try_module_get() and this is kept at the
         .request_resources() slowpath callback. In the GPIO CEC driver this
         is a big win sine a single line is used for both outgoing and
         incoming traffic, and this needs to use IRQs for incoming traffic
         while actively driving the line for outgoing traffic.
    
       - Janusz Krzysztofik improved the GPIO array API to pass a "cookie"
         (struct gpio_array) and a bitmap for setting or getting multiple
         GPIO lines at once.
    
         This improvement orginated in a specific need to speed up an OMAP1
         driver and has led to a much better API and real performance gains
         when the state of the array can be used to bypass a lot of checks
         and code when we want things to go really fast.
    
         The previous code would minimize the number of calls down to the
         driver callbacks assuming the CPU speed was orders of magnitude
         faster than the I/O latency, but this assumption was wrong on
         several platforms: what we needed to do was to profile and improve
         the speed on the hot path of the array functions and this change is
         now completed.
    
       - Clean out the painful and hard to grasp BNF experiments from the
         device tree bindings. Future approaches are looking into using JSON
         schema for this purpose. (Rob Herring is floating a patch series.)
    
      New drivers:
    
       - The RCAR driver now supports r8a774a1 (RZ/G2M).
    
       - Synopsys GPIO via CREGs driver.
    
      Major improvements:
    
       - Modernization of the EP93xx driver to use irqdomain and other
         contemporary concepts.
    
       - The ingenic driver has been merged into the Ingenic pin control
         driver and removed from the GPIO subsystem.
    
       - Debounce support in the ftgpio010 driver"
    
    * tag 'gpio-v4.20-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (116 commits)
      gpio: Clarify kerneldoc on gpiochip_set_chained_irqchip()
      gpio: Remove unused 'irqchip' argument to gpiochip_set_cascaded_irqchip()
      gpio: Drop parent irq assignment during cascade setup
      mmc: pwrseq_simple: Fix incorrect handling of GPIO bitmap
      gpio: fix SNPS_CREG kconfig dependency warning
      gpiolib: Initialize gdev field before is used
      gpio: fix kernel-doc after devres.c file rename
      gpio: fix doc string for devm_gpiochip_add_data() to not talk about irq_chip
      gpio: syscon: Fix possible NULL ptr usage
      gpiolib: Show correct direction from the beginning
      pinctrl: msm: Use init_valid_mask exported function
      gpiolib: Add init_valid_mask exported function
      GPIO: add single-register GPIO via CREG driver
      dt-bindings: Document the Synopsys GPIO via CREG bindings
      gpio: mockup: use device properties instead of platform_data
      gpio: Slightly more helpful debugfs
      gpio: omap: Remove set but not used variable 'dev'
      gpio: omap: drop omap_gpio_list
      Accept partial 'gpio-line-names' property.
      gpio: omap: get rid of the conditional PM runtime calls
      ...

commit 3e779a2e7f909015f21428b66834127496110b6d
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Oct 8 09:32:13 2018 -0700

    gpio: Assign gpio_irq_chip::parents to non-stack pointer
    
    gpiochip_set_cascaded_irqchip() is passed 'parent_irq' as an argument
    and then the address of that argument is assigned to the gpio chips
    gpio_irq_chip 'parents' pointer shortly thereafter. This can't ever
    work, because we've just assigned some stack address to a pointer that
    we plan to dereference later in gpiochip_irq_map(). I ran into this
    issue with the KASAN report below when gpiochip_irq_map() tried to setup
    the parent irq with a total junk pointer for the 'parents' array.
    
    BUG: KASAN: stack-out-of-bounds in gpiochip_irq_map+0x228/0x248
    Read of size 4 at addr ffffffc0dde472e0 by task swapper/0/1
    
    CPU: 7 PID: 1 Comm: swapper/0 Not tainted 4.14.72 #34
    Call trace:
    [<ffffff9008093638>] dump_backtrace+0x0/0x718
    [<ffffff9008093da4>] show_stack+0x20/0x2c
    [<ffffff90096b9224>] __dump_stack+0x20/0x28
    [<ffffff90096b91c8>] dump_stack+0x80/0xbc
    [<ffffff900845a350>] print_address_description+0x70/0x238
    [<ffffff900845a8e4>] kasan_report+0x1cc/0x260
    [<ffffff900845aa14>] __asan_report_load4_noabort+0x2c/0x38
    [<ffffff900897e098>] gpiochip_irq_map+0x228/0x248
    [<ffffff900820cc08>] irq_domain_associate+0x114/0x2ec
    [<ffffff900820d13c>] irq_create_mapping+0x120/0x234
    [<ffffff900820da78>] irq_create_fwspec_mapping+0x4c8/0x88c
    [<ffffff900820e2d8>] irq_create_of_mapping+0x180/0x210
    [<ffffff900917114c>] of_irq_get+0x138/0x198
    [<ffffff9008dc70ac>] spi_drv_probe+0x94/0x178
    [<ffffff9008ca5168>] driver_probe_device+0x51c/0x824
    [<ffffff9008ca6538>] __device_attach_driver+0x148/0x20c
    [<ffffff9008ca14cc>] bus_for_each_drv+0x120/0x188
    [<ffffff9008ca570c>] __device_attach+0x19c/0x2dc
    [<ffffff9008ca586c>] device_initial_probe+0x20/0x2c
    [<ffffff9008ca18bc>] bus_probe_device+0x80/0x154
    [<ffffff9008c9b9b4>] device_add+0x9b8/0xbdc
    [<ffffff9008dc7640>] spi_add_device+0x1b8/0x380
    [<ffffff9008dcbaf0>] spi_register_controller+0x111c/0x1378
    [<ffffff9008dd6b10>] spi_geni_probe+0x4dc/0x6f8
    [<ffffff9008cab058>] platform_drv_probe+0xdc/0x130
    [<ffffff9008ca5168>] driver_probe_device+0x51c/0x824
    [<ffffff9008ca59cc>] __driver_attach+0x100/0x194
    [<ffffff9008ca0ea8>] bus_for_each_dev+0x104/0x16c
    [<ffffff9008ca58c0>] driver_attach+0x48/0x54
    [<ffffff9008ca1edc>] bus_add_driver+0x274/0x498
    [<ffffff9008ca8448>] driver_register+0x1ac/0x230
    [<ffffff9008caaf6c>] __platform_driver_register+0xcc/0xdc
    [<ffffff9009c4b33c>] spi_geni_driver_init+0x1c/0x24
    [<ffffff9008084cb8>] do_one_initcall+0x240/0x3dc
    [<ffffff9009c017d0>] kernel_init_freeable+0x378/0x468
    [<ffffff90096e8240>] kernel_init+0x14/0x110
    [<ffffff9008086fcc>] ret_from_fork+0x10/0x18
    
    The buggy address belongs to the page:
    page:ffffffbf037791c0 count:0 mapcount:0 mapping:          (null) index:0x0
    flags: 0x4000000000000000()
    raw: 4000000000000000 0000000000000000 0000000000000000 00000000ffffffff
    raw: ffffffbf037791e0 ffffffbf037791e0 0000000000000000 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffffffc0dde47180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     ffffffc0dde47200: f1 f1 f1 f1 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f2 f2
    >ffffffc0dde47280: f2 f2 00 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3
                                                           ^
     ffffffc0dde47300: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     ffffffc0dde47380: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    
    Let's leave around one unsigned int in the gpio_irq_chip struct for the
    single parent irq case and repoint the 'parents' array at it. This way
    code is left mostly intact to setup parents and we waste an extra few
    bytes per structure of which there should be only a handful in a system.
    
    Cc: Evan Green <evgreen@chromium.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Fixes: e0d897289813 ("gpio: Implement tighter IRQ chip integration")
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 0ea328e71ec9..a4d5eb37744a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -94,6 +94,13 @@ struct gpio_irq_chip {
 	 */
 	unsigned int num_parents;
 
+	/**
+	 * @parent_irq:
+	 *
+	 * For use by gpiochip_set_cascaded_irqchip()
+	 */
+	unsigned int parent_irq;
+
 	/**
 	 * @parents:
 	 *

commit f8ec92a9f63b3b11e399409141b7868bb405e6b5
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Fri Oct 5 08:52:58 2018 +0200

    gpiolib: Add init_valid_mask exported function
    
    Add a function that allows initializing the valid_mask from
    gpiochip_add_data.
    
    This prevents race conditions during gpiochip initialization.
    
    If the function is not exported, then the old behaviour is respected,
    this is, set all gpios as valid.
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Tested-by: Jeffrey Hugo <jhugo@codeaurora.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index f6b95734073f..c5a51af8f76e 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -280,6 +280,9 @@ struct gpio_chip {
 
 	void			(*dbg_show)(struct seq_file *s,
 						struct gpio_chip *chip);
+
+	int			(*init_valid_mask)(struct gpio_chip *chip);
+
 	int			base;
 	u16			ngpio;
 	const char		*const *names;
@@ -318,7 +321,9 @@ struct gpio_chip {
 	/**
 	 * @need_valid_mask:
 	 *
-	 * If set core allocates @valid_mask with all bits set to one.
+	 * If set core allocates @valid_mask with all its values initialized
+	 * with init_valid_mask() or set to one if init_valid_mask() is not
+	 * defined
 	 */
 	bool need_valid_mask;
 

commit e48d194d1204b19655c1a9d78a67f2f01d2fe432
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 25 09:54:14 2018 +0200

    gpio: Add comments on single direction chips
    
    A patch from Ricardo got me thinking about some gpio chip
    semantics so let's drop in some comments to make things
    more clear around that.
    
    Cc: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Cc: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index d8dcd0e44cab..f6b95734073f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -178,9 +178,13 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  * @free: optional hook for chip-specific deactivation, such as
  *	disabling module power and clock; may sleep
  * @get_direction: returns direction for signal "offset", 0=out, 1=in,
- *	(same as GPIOF_DIR_XXX), or negative error
+ *	(same as GPIOF_DIR_XXX), or negative error.
+ *	It is recommended to always implement this function, even on
+ *	input-only or output-only gpio chips.
  * @direction_input: configures signal "offset" as input, or returns error
+ *	This can be omitted on input-only or output-only gpio chips.
  * @direction_output: configures signal "offset" as output, or returns error
+ *	This can be omitted on input-only or output-only gpio chips.
  * @get: returns value for signal "offset", 0=low, 1=high, or negative error
  * @get_multiple: reads values for multiple signals defined by "mask" and
  *	stores them in "bits", returns 0 on success or negative error

commit 461c1a7d4733d1dfd5c47b040cf32a5e7eefbc6c
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Sep 8 11:23:17 2018 +0200

    gpiolib: override irq_enable/disable
    
    When using the gpiolib irqchip helpers install irq_enable/disable
    hooks for the irqchip to ensure that gpiolib knows when the irq
    is enabled or disabled, allowing drivers to disable the irq and then
    use it as an output pin, and later switch the direction to input and
    re-enable the irq.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 9052ccd399fd..d8dcd0e44cab 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -144,6 +144,20 @@ struct gpio_irq_chip {
 	 * will allocate and map all IRQs during initialization.
 	 */
 	unsigned int first;
+
+	/**
+	 * @irq_enable:
+	 *
+	 * Store old irq_chip irq_enable callback
+	 */
+	void		(*irq_enable)(struct irq_data *data);
+
+	/**
+	 * @irq_disable:
+	 *
+	 * Store old irq_chip irq_disable callback
+	 */
+	void		(*irq_disable)(struct irq_data *data);
 };
 
 static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)

commit 4e9439ddacea06f35acce4d374bf6bd0acf99bc8
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Sep 8 11:23:16 2018 +0200

    gpiolib: add flag to indicate if the irq is disabled
    
    GPIO drivers call gpiochip_(un)lock_as_irq whenever they want to use a gpio
    as an interrupt. This is done when the irq is requested and it marks the
    gpio as in use by an interrupt.
    
    This is problematic for cases where a gpio pin is used as an interrupt
    pin, then, after the irq is disabled, is used as a regular gpio pin.
    Currently it is not possible to do this other than by first freeing
    the interrupt so gpiochip_unlock_as_irq is called, since an attempt to
    switch the gpio direction for output will fail since gpiolib believes
    that the gpio is in use for an interrupt and it does not know that it
    the irq is actually disabled.
    
    There are currently two drivers that would like to be able to do this:
    the tda998x_drv.c driver where a regular gpio pin needs to be temporarily
    reconfigured as an interrupt pin during CEC calibration, and the cec-gpio
    driver where you want to configure the gpio pin as an interrupt while
    waiting for traffic over the CEC bus, or as a regular pin when receiving or
    transmitting a CEC message.
    
    The solution is to add a new flag that is set when the irq is enabled,
    and have gpiod_direction_output check for that flag.
    
    We also add functions that drivers that do not use GPIOLIB_IRQCHIP
    can call when they enable/disable the irq.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 479f1ccaaebd..9052ccd399fd 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -403,6 +403,8 @@ void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 int gpiochip_reqres_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_relres_irq(struct gpio_chip *chip, unsigned int offset);
+void gpiochip_disable_irq(struct gpio_chip *chip, unsigned int offset);
+void gpiochip_enable_irq(struct gpio_chip *chip, unsigned int offset);
 
 /* Line status inquiry for drivers */
 bool gpiochip_line_is_open_drain(struct gpio_chip *chip, unsigned int offset);

commit 4e6b823867e2b8afc2b33740ba930e50b1f92421
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sat Sep 8 11:23:14 2018 +0200

    gpiolib: export gpiochip_irq_reqres/relres()
    
    GPIO drivers that do not use GPIOLIB_IRQCHIP can hook these into
    the irq_request_resource and irq_release_resource callbacks of the
    irq_chip so they correctly 'get' the module and lock the gpio line
    for IRQ use.
    
    This will simplify driver code.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 4a4f410b5285..479f1ccaaebd 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -401,6 +401,8 @@ extern struct gpio_chip *gpiochip_find(void *data,
 int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
+int gpiochip_reqres_irq(struct gpio_chip *chip, unsigned int offset);
+void gpiochip_relres_irq(struct gpio_chip *chip, unsigned int offset);
 
 /* Line status inquiry for drivers */
 bool gpiochip_line_is_open_drain(struct gpio_chip *chip, unsigned int offset);

commit 02ad0437decf2e5dba975c23b1a89775f4b211e1
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Sep 3 12:55:30 2018 -0700

    gpio: fix kernel-doc notation warning for 'request_key'
    
    Fix kernel-doc warning for missing struct member 'request_key':
    
    ../include/linux/gpio/driver.h:142: warning: Function parameter or member 'request_key' not described in 'gpio_irq_chip'
    
    Fixes: 39c3fd58952d ("kernel/irq: Extend lockdep class for request mutex")
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-gpio@vger.kernel.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 0ea328e71ec9..4a4f410b5285 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -66,9 +66,15 @@ struct gpio_irq_chip {
 	/**
 	 * @lock_key:
 	 *
-	 * Per GPIO IRQ chip lockdep classes.
+	 * Per GPIO IRQ chip lockdep class for IRQ lock.
 	 */
 	struct lock_class_key *lock_key;
+
+	/**
+	 * @request_key:
+	 *
+	 * Per GPIO IRQ chip lockdep class for IRQ request.
+	 */
 	struct lock_class_key *request_key;
 
 	/**

commit d799a4de0a250f1bdd99765bb8e55a5e2f469a1f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Aug 3 00:52:18 2018 +0200

    gpio: mmio: Fix up inverted direction registers
    
    The bgpio_init() takes one of two arguments to specify a register
    to set the direction of the GPIO line: either dirout that
    indicates that a 1 in the bit in that register sets the
    corresponding line to output, or dirin which indicates that
    a 1 in the bit in that register sets the corresponding line to
    input. Conversely setting the bit to 0 on these will turn the
    line into input and output respectively. One of these can
    be defined but not both.
    
    This means that a platform that sets a bit to 1 for output
    only defines dirout and a platform that sets a bit to 0 for
    output only defines dirin. In short this defines the polarity
    of the direction register.
    
    Both can also be left as NULL meaning the GPIO chip is either
    input only or output only.
    
    Tomer Maimon discovered that for get/set chips (those where the
    get and set registers are defined but no separate clear register,
    and specifying BGPIOF_READ_OUTPUT_REG_SET so that we say we
    want to read the output value from the SET register)
    we are unconditionally reading the value from the SET register
    when the direction bit is 1 and from the DAT register when the
    direction bit is 0, not taking the direction bit polarity into
    account.
    
    It would be expected that when the direction bit is inverted
    (dirin is defined but not dirout) we read the current value from
    the DAT register when the bit is 1 and from the SET register
    when the bit is 0.
    
    Currently only some versions of ATH79, brcmstb, some versions of
    CLP711x, GE, IOP and Loongson use the dirin mode (a 1 in the
    register means input). They are unaffected because
    BGPIOF_READ_OUTPUT_REG_SET is not set on any of them. (They
    do not read back the SET register to figure out the output
    value.) So this is no regression with current drivers.
    
    However the behaviour is wrong and does not work with Tomer's
    new driver where he needs to use the BGIOF_READ_OUTPUT_REG_SET.
    This fixes the above issue by:
    
    - Instead of defining separate functions for the inverted case,
      set up a flag in the gpio_chip that indicates that the
      direction is inverted.
    - Remove the special inverted functions for setting
      input/output and getting the direction, rely on the flag
      instead.
    - Respect this flag in bgpio_get_set() and
      bgpio_get_set_multiple()
    
    Reported-by: Tomer Maimon <tmaimon77@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 5382b5183b7e..0ea328e71ec9 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -201,6 +201,8 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  * @reg_set: output set register (out=high) for generic GPIO
  * @reg_clr: output clear register (out=low) for generic GPIO
  * @reg_dir: direction setting register for generic GPIO
+ * @bgpio_dir_inverted: indicates that the direction register is inverted
+ *	(gpiolib private state variable)
  * @bgpio_bits: number of register bits used for a generic GPIO i.e.
  *	<register width> * 8
  * @bgpio_lock: used to lock chip->bgpio_data. Also, this is needed to keep
@@ -267,6 +269,7 @@ struct gpio_chip {
 	void __iomem *reg_set;
 	void __iomem *reg_clr;
 	void __iomem *reg_dir;
+	bool bgpio_dir_inverted;
 	int bgpio_bits;
 	spinlock_t bgpio_lock;
 	unsigned long bgpio_data;

commit 726cb3ba49692bdae6caff457755e7cdb432efa4
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Mar 23 09:34:52 2018 -0700

    gpiolib: Support 'gpio-reserved-ranges' property
    
    Some qcom platforms make some GPIOs or pins unavailable for use by
    non-secure operating systems, and thus reading or writing the registers
    for those pins will cause access control issues. Add support for a DT
    property to describe the set of GPIOs that are available for use so that
    higher level OSes are able to know what pins to avoid reading/writing.
    Non-DT platforms can add support by directly updating the
    chip->valid_mask.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1ba9a331ec51..5382b5183b7e 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -288,6 +288,21 @@ struct gpio_chip {
 	struct gpio_irq_chip irq;
 #endif
 
+	/**
+	 * @need_valid_mask:
+	 *
+	 * If set core allocates @valid_mask with all bits set to one.
+	 */
+	bool need_valid_mask;
+
+	/**
+	 * @valid_mask:
+	 *
+	 * If not %NULL holds bitmask of GPIOs which are valid to be used
+	 * from the chip.
+	 */
+	unsigned long *valid_mask;
+
 #if defined(CONFIG_OF_GPIO)
 	/*
 	 * If CONFIG_OF is enabled, then all GPIO controllers described in the
@@ -384,6 +399,7 @@ bool gpiochip_line_is_open_source(struct gpio_chip *chip, unsigned int offset);
 
 /* Sleep persistence inquiry for drivers */
 bool gpiochip_line_is_persistent(struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_valid(const struct gpio_chip *chip, unsigned int offset);
 
 /* get driver data */
 void *gpiochip_get_data(struct gpio_chip *chip);

commit 9798f5178f5791f964562eccedcf4dabe02fd825
Merge: 50081e437872 d58f2bf261fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 12:25:27 2018 -0800

    Merge tag 'gpio-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "The is the bulk of GPIO changes for the v4.16 kernel cycle. It is
      pretty calm this time around I think. I even got time to get to things
      like starting to clean up header includes.
    
      Core changes:
    
       - Disallow open drain and open source flags to be set simultaneously.
         This doesn't make electrical sense, and would the hardware actually
         respond to this setting, the result would be short circuit.
    
       - ACPI GPIO has a new core infrastructure for handling quirks. The
         quirks are there to deal with broken ACPI tables centrally instead
         of pushing the work to individual drivers. In the world of BIOS
         writers, the ACPI tables are perfect. Until they find a mistake in
         it. When such a mistake is found, we can patch it with a quirk. It
         should never happen, the problem is that it happens. So we
         accomodate for it.
    
       - Several documentation updates.
    
       - Revert the patch setting up initial direction state from reading
         the device. This was causing bad things for drivers that can't read
         status on all its pins. It is only affecting debugfs information
         quality.
    
       - Label descriptors with the device name if no explicit label is
         passed in.
    
       - Pave the ground for transitioning SPI and regulators to use GPIO
         descriptors by implementing some quirks in the device tree GPIO
         parsing code.
    
      New drivers:
    
       - New driver for the Access PCIe IDIO 24 family.
    
      Other:
    
       - Major refactorings and improvements to the GPIO mockup driver used
         for test and verification.
    
       - Moved the AXP209 driver over to pin control since it gained a pin
         control back-end. These patches will appear (with the same hashes)
         in the pin control pull request as well.
    
       - Convert the onewire GPIO driver w1-gpio to use descriptors. This is
         merged here since the W1 maintainers send very few pull requests
         and he ACKed it.
    
       - Start to clean up driver headers using <linux/gpio.h> to just use
         <linux/gpio/driver.h> as appropriate"
    
    * tag 'gpio-v4.16-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (103 commits)
      gpio: Timestamp events in hardirq handler
      gpio: Fix kernel stack leak to userspace
      gpio: Fix a documentation spelling mistake
      gpio: Documentation update
      gpiolib: remove redundant initialization of pointer desc
      gpio: of: Fix NPE from OF flags
      gpio: stmpe: Delete an unnecessary variable initialisation in stmpe_gpio_probe()
      gpio: stmpe: Move an assignment in stmpe_gpio_probe()
      gpio: stmpe: Improve a size determination in stmpe_gpio_probe()
      gpio: stmpe: Use seq_putc() in stmpe_dbg_show()
      gpio: No NULL owner
      gpio: stmpe: i2c transfer are forbiden in atomic context
      gpio: davinci: Include proper header
      gpio: da905x: Include proper header
      gpio: cs5535: Include proper header
      gpio: crystalcove: Include proper header
      gpio: bt8xx: Include proper header
      gpio: bcm-kona: Include proper header
      gpio: arizona: Include proper header
      gpio: amd8111: Include proper header
      ...

commit 64ff2c8e468ceff3cd678a4fa2edfc77dadc6bfe
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jan 9 17:58:46 2018 -0800

    gpiolib: Export gpiochip_irqchip_irq_valid() to drivers
    
    Some pinctrl drivers can use the gpiochip irq valid information
    to figure out if certain gpios are exposed to the kernel for
    usage or not. Expose this API so we can use it in the
    pinmux_ops::request ops.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 55e672592fa9..b6a05dd0d10a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -431,6 +431,9 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
 			     bool threaded,
 			     struct lock_class_key *lock_key);
 
+bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gpiochip,
+				unsigned int offset);
+
 #ifdef CONFIG_LOCKDEP
 
 /*

commit 39c3fd58952d7599d367c84c1330b785d91d6088
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Dec 2 18:11:04 2017 +0100

    kernel/irq: Extend lockdep class for request mutex
    
    The IRQ code already has support for lockdep class for the lock mutex
    in an interrupt descriptor. Extend this to add a second class for the
    request mutex in the descriptor. Not having a class is resulting in
    false positive splats in some code paths.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: linus.walleij@linaro.org
    Cc: grygorii.strashko@ti.com
    Cc: f.fainelli@gmail.com
    Link: https://lkml.kernel.org/r/1512234664-21555-1-git-send-email-andrew@lunn.ch

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 55e672592fa9..7258cd676df4 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -66,9 +66,10 @@ struct gpio_irq_chip {
 	/**
 	 * @lock_key:
 	 *
-	 * Per GPIO IRQ chip lockdep class.
+	 * Per GPIO IRQ chip lockdep classes.
 	 */
 	struct lock_class_key *lock_key;
+	struct lock_class_key *request_key;
 
 	/**
 	 * @parent_handler:
@@ -323,7 +324,8 @@ extern const char *gpiochip_is_requested(struct gpio_chip *chip,
 
 /* add/remove chips */
 extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
-				      struct lock_class_key *lock_key);
+				      struct lock_class_key *lock_key,
+				      struct lock_class_key *request_key);
 
 /**
  * gpiochip_add_data() - register a gpio_chip
@@ -350,11 +352,13 @@ extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
  */
 #ifdef CONFIG_LOCKDEP
 #define gpiochip_add_data(chip, data) ({		\
-		static struct lock_class_key key;	\
-		gpiochip_add_data_with_key(chip, data, &key);	\
+		static struct lock_class_key lock_key;	\
+		static struct lock_class_key request_key;	  \
+		gpiochip_add_data_with_key(chip, data, &lock_key, \
+					   &request_key);	  \
 	})
 #else
-#define gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL)
+#define gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL, NULL)
 #endif
 
 static inline int gpiochip_add(struct gpio_chip *chip)
@@ -429,7 +433,8 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
 			     irq_flow_handler_t handler,
 			     unsigned int type,
 			     bool threaded,
-			     struct lock_class_key *lock_key);
+			     struct lock_class_key *lock_key,
+			     struct lock_class_key *request_key);
 
 #ifdef CONFIG_LOCKDEP
 
@@ -445,10 +450,12 @@ static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 				       irq_flow_handler_t handler,
 				       unsigned int type)
 {
-	static struct lock_class_key key;
+	static struct lock_class_key lock_key;
+	static struct lock_class_key request_key;
 
 	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
-					handler, type, false, &key);
+					handler, type, false,
+					&lock_key, &request_key);
 }
 
 static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
@@ -458,10 +465,12 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 			  unsigned int type)
 {
 
-	static struct lock_class_key key;
+	static struct lock_class_key lock_key;
+	static struct lock_class_key request_key;
 
 	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
-					handler, type, true, &key);
+					handler, type, true,
+					&lock_key, &request_key);
 }
 #else
 static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
@@ -471,7 +480,7 @@ static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 				       unsigned int type)
 {
 	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
-					handler, type, false, NULL);
+					handler, type, false, NULL, NULL);
 }
 
 static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
@@ -481,7 +490,7 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 			  unsigned int type)
 {
 	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
-					handler, type, true, NULL);
+					handler, type, true, NULL, NULL);
 }
 #endif /* CONFIG_LOCKDEP */
 

commit 6aa2f9441f1ef21f10c41f45e6453b135e9cd736
Merge: e37e0ee01900 24f0966c3e3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 17:23:44 2017 -0800

    Merge tag 'gpio-v4.15-1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.15 kernel cycle:
    
      Core:
    
       - Fix the semantics of raw GPIO to actually be raw. No inversion
         semantics as before, but also no open draining, and allow the raw
         operations to affect lines used for interrupts as the caller
         supposedly knows what they are doing if they are getting the big
         hammer.
    
       - Rewrote the __inner_function() notation calls to names that make
         more sense. I just find this kind of code disturbing.
    
       - Drop the .irq_base() field from the gpiochip since now all IRQs are
         mapped dynamically. This is nice.
    
       - Support for .get_multiple() in the core driver API. This allows us
         to read several GPIO lines with a single register read. This has
         high value for some usecases: it can be used to create
         oscilloscopes and signal analyzers and other things that rely on
         reading several lines at exactly the same instant. Also a generally
         nice optimization. This uses the new assign_bit() macro from the
         bitops lib that was ACKed by Andrew Morton and is implemented for
         two drivers, one of them being the generic MMIO driver so everyone
         using that will be able to benefit from this.
    
       - Do not allow requests of Open Drain and Open Source setting of a
         GPIO line simultaneously. If the hardware actually supports
         enabling both at the same time the electrical result would be
         disastrous.
    
       - A new interrupt chip core helper. This will be helpful to deal with
         "banked" GPIOs, which means GPIO controllers with several logical
         blocks of GPIO inside them. This is several gpiochips per device in
         the device model, in contrast to the case when there is a 1-to-1
         relationship between a device and a gpiochip.
    
      New drivers:
    
       - Maxim MAX3191x industrial serializer, a very interesting piece of
         professional I/O hardware.
    
       - Uniphier GPIO driver. This is the GPIO block from the recent
         Socionext (ex Fujitsu and Panasonic) platform.
    
       - Tegra 186 driver. This is based on the new banked GPIO
         infrastructure.
    
      Other improvements:
    
       - Some documentation improvements.
    
       - Wakeup support for the DesignWare DWAPB GPIO controller.
    
       - Reset line support on the DesignWare DWAPB GPIO controller.
    
       - Several non-critical bug fixes and improvements for the Broadcom
         BRCMSTB driver.
    
       - Misc non-critical bug fixes like exotic errorpaths, removal of dead
         code etc.
    
       - Explicit comments on fall-through switch() statements"
    
    * tag 'gpio-v4.15-1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (65 commits)
      gpio: tegra186: Remove tegra186_gpio_lock_class
      gpio: rcar: Add r8a77995 (R-Car D3) support
      pinctrl: bcm2835: Fix some merge fallout
      gpio: Fix undefined lock_dep_class
      gpio: Automatically add lockdep keys
      gpio: Introduce struct gpio_irq_chip.first
      gpio: Disambiguate struct gpio_irq_chip.nested
      gpio: Add Tegra186 support
      gpio: Export gpiochip_irq_{map,unmap}()
      gpio: Implement tighter IRQ chip integration
      gpio: Move lock_key into struct gpio_irq_chip
      gpio: Move irq_valid_mask into struct gpio_irq_chip
      gpio: Move irq_nested into struct gpio_irq_chip
      gpio: Move irq_chained_parent to struct gpio_irq_chip
      gpio: Move irq_default_type to struct gpio_irq_chip
      gpio: Move irq_handler to struct gpio_irq_chip
      gpio: Move irqdomain into struct gpio_irq_chip
      gpio: Move irqchip into struct gpio_irq_chip
      gpio: Introduce struct gpio_irq_chip
      pinctrl: armada-37xx: remove unused variable
      ...

commit 959bc7b22bd25a3a907fbb9b26a1d0cbdf98ef40
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:59 2017 +0100

    gpio: Automatically add lockdep keys
    
    In order to avoid lockdep boilerplate in individual drivers, turn the
    gpiochip_add_data() function into a macro that creates a unique class
    key for each driver.
    
    Note that this has the slight disadvantage of adding a key for each
    driver registered with the system. However, these keys are 8 bytes in
    size, which is negligible and a small price to pay for generic
    infrastructure.
    
    Suggested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    [renane __gpiochip_add_data() to gpiochip_add_data_with_key]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a77d4ada060c..8dd282c5167a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -321,7 +321,41 @@ extern const char *gpiochip_is_requested(struct gpio_chip *chip,
 			unsigned offset);
 
 /* add/remove chips */
-extern int gpiochip_add_data(struct gpio_chip *chip, void *data);
+extern int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
+				      struct lock_class_key *lock_key);
+
+/**
+ * gpiochip_add_data() - register a gpio_chip
+ * @chip: the chip to register, with chip->base initialized
+ * @data: driver-private data associated with this chip
+ *
+ * Context: potentially before irqs will work
+ *
+ * When gpiochip_add_data() is called very early during boot, so that GPIOs
+ * can be freely used, the chip->parent device must be registered before
+ * the gpio framework's arch_initcall().  Otherwise sysfs initialization
+ * for GPIOs will fail rudely.
+ *
+ * gpiochip_add_data() must only be called after gpiolib initialization,
+ * ie after core_initcall().
+ *
+ * If chip->base is negative, this requests dynamic assignment of
+ * a range of valid GPIOs.
+ *
+ * Returns:
+ * A negative errno if the chip can't be registered, such as because the
+ * chip->base is invalid or already associated with a different chip.
+ * Otherwise it returns zero as a success code.
+ */
+#ifdef CONFIG_LOCKDEP
+#define gpiochip_add_data(chip, data) ({		\
+		static struct lock_class_key key;	\
+		gpiochip_add_data_with_key(chip, data, &key);	\
+	})
+#else
+#define gpiochip_add_data(chip, data) gpiochip_add_data_with_key(chip, data, NULL)
+#endif
+
 static inline int gpiochip_add(struct gpio_chip *chip)
 {
 	return gpiochip_add_data(chip, NULL);

commit 8302cf585288f75fd253f6b9a094d51ae371a3f3
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:58 2017 +0100

    gpio: Introduce struct gpio_irq_chip.first
    
    Some GPIO chips cannot support sparse IRQ numbering and therefore need
    to manually allocate their interrupt descriptors statically. For these
    cases, a driver can pass the first allocated IRQ via the struct
    gpio_irq_chip's "first" field and thereby cause the IRQ domain to map
    all IRQs during initialization.
    
    Suggested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 0a3fdd4d9d8d..a77d4ada060c 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -128,6 +128,14 @@ struct gpio_irq_chip {
 	 * in IRQ domain of the chip.
 	 */
 	unsigned long *valid_mask;
+
+	/**
+	 * @first:
+	 *
+	 * Required for static IRQ allocation. If set, irq_domain_add_simple()
+	 * will allocate and map all IRQs during initialization.
+	 */
+	unsigned int first;
 };
 
 static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)

commit 60ed54cae8dc0f2d41cafbd477bbed6deb716615
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:57 2017 +0100

    gpio: Disambiguate struct gpio_irq_chip.nested
    
    The nested field in struct gpio_irq_chip currently has two meanings. On
    one hand it marks an IRQ chip as being nested (as opposed to chained),
    while on the other hand it also means that an IRQ chip uses nested
    thread handlers.
    
    However, nested IRQ chips can already be identified by the fact that
    they don't pass a parent handler (the driver would instead already have
    installed a nested handler using request_irq()).
    
    Therefore, the only use for the nested attribute is to inform gpiolib
    that an IRQ chip uses nested thread handlers (as opposed to regular,
    non-threaded handlers). To clarify its purpose, rename the field to
    "threaded".
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index bbe5c647f29d..0a3fdd4d9d8d 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -108,11 +108,11 @@ struct gpio_irq_chip {
 	unsigned int *map;
 
 	/**
-	 * @nested:
+	 * @threaded:
 	 *
-	 * True if set the interrupt handling is nested.
+	 * True if set the interrupt handling uses nested threads.
 	 */
-	bool nested;
+	bool threaded;
 
 	/**
 	 * @need_valid_mask:
@@ -385,7 +385,7 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
 			     unsigned int first_irq,
 			     irq_flow_handler_t handler,
 			     unsigned int type,
-			     bool nested,
+			     bool threaded,
 			     struct lock_class_key *lock_key);
 
 #ifdef CONFIG_LOCKDEP

commit 1b95b4eb567aab1cafcdcb14c60a7dd9d56236a9
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:55 2017 +0100

    gpio: Export gpiochip_irq_{map,unmap}()
    
    Export these functions so that drivers can explicitly use these when
    setting up their IRQ domain.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 51fc7b023364..bbe5c647f29d 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -367,6 +367,10 @@ int bgpio_init(struct gpio_chip *gc, struct device *dev,
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 
+int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
+		     irq_hw_number_t hwirq);
+void gpiochip_irq_unmap(struct irq_domain *d, unsigned int irq);
+
 void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
 		unsigned int parent_irq,

commit e0d89728981393b7d694bd3419b7794b9882c92d
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:54 2017 +0100

    gpio: Implement tighter IRQ chip integration
    
    Currently GPIO drivers are required to add the GPIO chip and its
    corresponding IRQ chip separately, which can result in a lot of
    boilerplate. Use the newly introduced struct gpio_irq_chip, embedded in
    struct gpio_chip, that drivers can fill in if they want the GPIO core
    to automatically register the IRQ chip associated with a GPIO chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c363ee198ff9..51fc7b023364 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -100,6 +100,13 @@ struct gpio_irq_chip {
 	 */
 	unsigned int *parents;
 
+	/**
+	 * @map:
+	 *
+	 * A list of interrupt parents for each line of a GPIO chip.
+	 */
+	unsigned int *map;
+
 	/**
 	 * @nested:
 	 *

commit ca9df053fb2bb2fcc64f37a1668321c7e19edd04
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:53 2017 +0100

    gpio: Move lock_key into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 067efcd4f46d..c363ee198ff9 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -62,6 +62,13 @@ struct gpio_irq_chip {
 	 */
 	unsigned int default_type;
 
+	/**
+	 * @lock_key:
+	 *
+	 * Per GPIO IRQ chip lockdep class.
+	 */
+	struct lock_class_key *lock_key;
+
 	/**
 	 * @parent_handler:
 	 *
@@ -185,7 +192,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @lock_key: per GPIO IRQ chip lockdep class
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
  * they can all be accessed through a common programing interface.
@@ -255,7 +261,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	struct lock_class_key	*lock_key;
 
 	/**
 	 * @irq:

commit dc7b0387ee894c115ef5ddcaaf794125d6d9058c
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:52 2017 +0100

    gpio: Move irq_valid_mask into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1c3d06fe54b1..067efcd4f46d 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -99,6 +99,21 @@ struct gpio_irq_chip {
 	 * True if set the interrupt handling is nested.
 	 */
 	bool nested;
+
+	/**
+	 * @need_valid_mask:
+	 *
+	 * If set core allocates @valid_mask with all bits set to one.
+	 */
+	bool need_valid_mask;
+
+	/**
+	 * @valid_mask:
+	 *
+	 * If not %NULL holds bitmask of GPIOs which are valid to be included
+	 * in IRQ domain of the chip.
+	 */
+	unsigned long *valid_mask;
 };
 
 static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
@@ -170,10 +185,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irq_need_valid_mask: If set core allocates @irq_valid_mask with all
- *	bits set to one
- * @irq_valid_mask: If not %NULL holds bitmask of GPIOs which are valid to
- *	be included in IRQ domain of the chip
  * @lock_key: per GPIO IRQ chip lockdep class
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
@@ -244,8 +255,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	bool			irq_need_valid_mask;
-	unsigned long		*irq_valid_mask;
 	struct lock_class_key	*lock_key;
 
 	/**

commit dc6bafee86897419b0908e8d1e52ef46ca0ea487
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:51 2017 +0100

    gpio: Move irq_nested into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 86f00d908e90..1c3d06fe54b1 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -92,6 +92,13 @@ struct gpio_irq_chip {
 	 * driver, so the core will only reference this list, not modify it.
 	 */
 	unsigned int *parents;
+
+	/**
+	 * @nested:
+	 *
+	 * True if set the interrupt handling is nested.
+	 */
+	bool nested;
 };
 
 static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
@@ -163,7 +170,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irq_nested: True if set the interrupt handling is nested.
  * @irq_need_valid_mask: If set core allocates @irq_valid_mask with all
  *	bits set to one
  * @irq_valid_mask: If not %NULL holds bitmask of GPIOs which are valid to
@@ -238,7 +244,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	bool			irq_nested;
 	bool			irq_need_valid_mask;
 	unsigned long		*irq_valid_mask;
 	struct lock_class_key	*lock_key;

commit 39e5f0969514fbfd6c235ac52586c72ca77cee00
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:50 2017 +0100

    gpio: Move irq_chained_parent to struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1367fa94105f..86f00d908e90 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -77,6 +77,21 @@ struct gpio_irq_chip {
 	 * interrupt.
 	 */
 	void *parent_handler_data;
+
+	/**
+	 * @num_parents:
+	 *
+	 * The number of interrupt parents of a GPIO chip.
+	 */
+	unsigned int num_parents;
+
+	/**
+	 * @parents:
+	 *
+	 * A list of interrupt parents of a GPIO chip. This is owned by the
+	 * driver, so the core will only reference this list, not modify it.
+	 */
+	unsigned int *parents;
 };
 
 static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
@@ -148,9 +163,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irq_chained_parent: GPIO IRQ chip parent/bank linux irq number,
- *	provided by GPIO driver for chained interrupt (not for nested
- *	interrupts).
  * @irq_nested: True if set the interrupt handling is nested.
  * @irq_need_valid_mask: If set core allocates @irq_valid_mask with all
  *	bits set to one
@@ -226,7 +238,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	unsigned int		irq_chained_parent;
 	bool			irq_nested;
 	bool			irq_need_valid_mask;
 	unsigned long		*irq_valid_mask;

commit 3634eeb0fe9176e453c99834749dce21ea1305c1
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:49 2017 +0100

    gpio: Move irq_default_type to struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 864f507e859b..1367fa94105f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -54,6 +54,14 @@ struct gpio_irq_chip {
 	 */
 	irq_flow_handler_t handler;
 
+	/**
+	 * @default_type:
+	 *
+	 * Default IRQ triggering type applied during GPIO driver
+	 * initialization, provided by GPIO driver.
+	 */
+	unsigned int default_type;
+
 	/**
 	 * @parent_handler:
 	 *
@@ -140,8 +148,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irq_default_type: default IRQ triggering type applied during GPIO driver
- *	initialization, provided by GPIO driver
  * @irq_chained_parent: GPIO IRQ chip parent/bank linux irq number,
  *	provided by GPIO driver for chained interrupt (not for nested
  *	interrupts).
@@ -220,7 +226,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	unsigned int		irq_default_type;
 	unsigned int		irq_chained_parent;
 	bool			irq_nested;
 	bool			irq_need_valid_mask;

commit c7a0aa59524c5bb20bebaca360f7c5faaec6b806
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:48 2017 +0100

    gpio: Move irq_handler to struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c5dfa8c0b829..864f507e859b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -46,6 +46,14 @@ struct gpio_irq_chip {
 	 */
 	const struct irq_domain_ops *domain_ops;
 
+	/**
+	 * @handler:
+	 *
+	 * The IRQ handler to use (often a predefined IRQ core function) for
+	 * GPIO IRQs, provided by GPIO driver.
+	 */
+	irq_flow_handler_t handler;
+
 	/**
 	 * @parent_handler:
 	 *
@@ -132,8 +140,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irq_handler: the irq handler to use (often a predefined irq core function)
- *	for GPIO IRQs, provided by GPIO driver
  * @irq_default_type: default IRQ triggering type applied during GPIO driver
  *	initialization, provided by GPIO driver
  * @irq_chained_parent: GPIO IRQ chip parent/bank linux irq number,
@@ -214,7 +220,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 	unsigned int		irq_chained_parent;
 	bool			irq_nested;

commit f0fbe7bce733561b76a5b55c5f4625888acd3792
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:47 2017 +0100

    gpio: Move irqdomain into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a79b3b18fadd..c5dfa8c0b829 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -31,6 +31,14 @@ struct gpio_irq_chip {
 	 */
 	struct irq_chip *chip;
 
+	/**
+	 * @domain:
+	 *
+	 * Interrupt translation domain; responsible for mapping between GPIO
+	 * hwirq number and Linux IRQ number.
+	 */
+	struct irq_domain *domain;
+
 	/**
 	 * @domain_ops:
 	 *
@@ -124,8 +132,6 @@ static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irqdomain: Interrupt translation domain; responsible for mapping
- *	between GPIO hwirq number and linux irq number
  * @irq_handler: the irq handler to use (often a predefined irq core function)
  *	for GPIO IRQs, provided by GPIO driver
  * @irq_default_type: default IRQ triggering type applied during GPIO driver
@@ -208,7 +214,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	struct irq_domain	*irqdomain;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 	unsigned int		irq_chained_parent;

commit da80ff81a8f54611b834d73149f8ac0d59151c87
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:46 2017 +0100

    gpio: Move irqchip into struct gpio_irq_chip
    
    In order to consolidate the multiple ways to associate an IRQ chip with
    a GPIO chip, move more fields into the new struct gpio_irq_chip.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 36a065521fa0..a79b3b18fadd 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -24,6 +24,13 @@ struct module;
  * struct gpio_irq_chip - GPIO interrupt controller
  */
 struct gpio_irq_chip {
+	/**
+	 * @chip:
+	 *
+	 * GPIO IRQ chip implementation, provided by GPIO driver.
+	 */
+	struct irq_chip *chip;
+
 	/**
 	 * @domain_ops:
 	 *
@@ -47,6 +54,11 @@ struct gpio_irq_chip {
 	 */
 	void *parent_handler_data;
 };
+
+static inline struct gpio_irq_chip *to_gpio_irq_chip(struct irq_chip *chip)
+{
+	return container_of(chip, struct gpio_irq_chip, chip);
+}
 #endif
 
 /**
@@ -112,7 +124,6 @@ struct gpio_irq_chip {
  *	safely.
  * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
  *	direction safely.
- * @irqchip: GPIO IRQ chip impl, provided by GPIO driver
  * @irqdomain: Interrupt translation domain; responsible for mapping
  *	between GPIO hwirq number and linux irq number
  * @irq_handler: the irq handler to use (often a predefined irq core function)
@@ -197,7 +208,6 @@ struct gpio_chip {
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
-	struct irq_chip		*irqchip;
 	struct irq_domain	*irqdomain;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;

commit c44eafd79be666e7c81d22e215c945b27f2785f7
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 7 19:15:45 2017 +0100

    gpio: Introduce struct gpio_irq_chip
    
    This new structure will be used to group all fields related to interrupt
    handling in a GPIO chip. Doing so will properly namespace these fields
    and make it easier to distinguish which fields are used for IRQ support.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ed04fa2a00a8..36a065521fa0 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -19,6 +19,36 @@ struct module;
 
 #ifdef CONFIG_GPIOLIB
 
+#ifdef CONFIG_GPIOLIB_IRQCHIP
+/**
+ * struct gpio_irq_chip - GPIO interrupt controller
+ */
+struct gpio_irq_chip {
+	/**
+	 * @domain_ops:
+	 *
+	 * Table of interrupt domain operations for this IRQ chip.
+	 */
+	const struct irq_domain_ops *domain_ops;
+
+	/**
+	 * @parent_handler:
+	 *
+	 * The interrupt handler for the GPIO chip's parent interrupts, may be
+	 * NULL if the parent interrupts are nested rather than cascaded.
+	 */
+	irq_flow_handler_t parent_handler;
+
+	/**
+	 * @parent_handler_data:
+	 *
+	 * Data associated, and passed to, the handler for the parent
+	 * interrupt.
+	 */
+	void *parent_handler_data;
+};
+#endif
+
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: a functional name for the GPIO device, such as a part
@@ -176,6 +206,14 @@ struct gpio_chip {
 	bool			irq_need_valid_mask;
 	unsigned long		*irq_valid_mask;
 	struct lock_class_key	*lock_key;
+
+	/**
+	 * @irq:
+	 *
+	 * Integrates interrupt chip functionality with the GPIO chip. Can be
+	 * used to handle IRQs for most practical cases.
+	 */
+	struct gpio_irq_chip irq;
 #endif
 
 #if defined(CONFIG_OF_GPIO)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c97f8325e8bf..424e5139ff10 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_GPIO_DRIVER_H
 #define __LINUX_GPIO_DRIVER_H
 

commit 24efd94bc38290dc1d9775a1e767ed4685d8a79b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Oct 20 16:31:27 2017 +0200

    gpio: mmio: Make pin2mask() a private business
    
    The vtable call pin2mask() was introducing a vtable function call
    in every gpiochip callback for a generic MMIO GPIO chip. This was
    not exactly efficient. (Maybe link-time optimization could get rid of
    it, I don't know.)
    
    After removing all external calls into this API we can make it a
    boolean flag in the struct gpio_chip call and sink the function into
    the gpio-mmio driver yielding encapsulation and potential speedups.
    
    Cc: Anton Vorontsov <anton@enomsg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index bda95a9b7b8c..ed04fa2a00a8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -67,9 +67,9 @@ struct module;
  *	registers.
  * @read_reg: reader function for generic GPIO
  * @write_reg: writer function for generic GPIO
- * @pin2mask: some generic GPIO controllers work with the big-endian bits
- *	notation, e.g. in a 8-bits register, GPIO7 is the least significant
- *	bit. This callback assigns the right bit mask.
+ * @be_bits: if the generic GPIO has big endian bit order (bit 31 is representing
+ *	line 0, bit 30 is line 1 ... bit 0 is line 31) this is set to true by the
+ *	generic GPIO core. It is for internal housekeeping only.
  * @reg_dat: data (in) register for generic GPIO
  * @reg_set: output set register (out=high) for generic GPIO
  * @reg_clr: output clear register (out=low) for generic GPIO
@@ -151,7 +151,7 @@ struct gpio_chip {
 #if IS_ENABLED(CONFIG_GPIO_GENERIC)
 	unsigned long (*read_reg)(void __iomem *reg);
 	void (*write_reg)(void __iomem *reg, unsigned long data);
-	unsigned long (*pin2mask)(struct gpio_chip *gc, unsigned int pin);
+	bool be_bits;
 	void __iomem *reg_dat;
 	void __iomem *reg_set;
 	void __iomem *reg_clr;

commit eec1d566cdf94b57e8f5ba9fe60eea214929bcfc
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Oct 12 12:40:10 2017 +0200

    gpio: Introduce ->get_multiple callback
    
    SPI-attached GPIO controllers typically read out all inputs in one go.
    If callers desire the values of multipe inputs, ideally a single readout
    should take place to return the desired values.  However the current
    driver API only offers a ->get callback but no ->get_multiple (unlike
    ->set_multiple, which is present).  Thus, to read multiple inputs, a
    full readout needs to be performed for every single value (barring
    driver-internal caching), which is inefficient.
    
    In fact, the lack of a ->get_multiple callback has been bemoaned
    repeatedly by the gpio subsystem maintainer:
    http://www.spinics.net/lists/linux-gpio/msg10571.html
    http://www.spinics.net/lists/devicetree/msg121734.html
    
    Introduce the missing callback.  Add corresponding consumer functions
    such as gpiod_get_array_value().  Amend linehandle_ioctl() to take
    advantage of the newly added infrastructure.  Update the documentation.
    
    Cc: Rojhalat Ibrahim <imr@rtschenk.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 6bbda879fb8b..bda95a9b7b8c 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -35,6 +35,8 @@ struct module;
  * @direction_input: configures signal "offset" as input, or returns error
  * @direction_output: configures signal "offset" as output, or returns error
  * @get: returns value for signal "offset", 0=low, 1=high, or negative error
+ * @get_multiple: reads values for multiple signals defined by "mask" and
+ *	stores them in "bits", returns 0 on success or negative error
  * @set: assigns output value for signal "offset"
  * @set_multiple: assigns output values for multiple signals defined by "mask"
  * @set_config: optional hook for all kinds of settings. Uses the same
@@ -125,6 +127,9 @@ struct gpio_chip {
 						unsigned offset, int value);
 	int			(*get)(struct gpio_chip *chip,
 						unsigned offset);
+	int			(*get_multiple)(struct gpio_chip *chip,
+						unsigned long *mask,
+						unsigned long *bits);
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
 	void			(*set_multiple)(struct gpio_chip *chip,

commit f628ba9e22e0fa32ac6270a0d696fe1509889540
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Oct 9 17:16:05 2017 -0500

    gpiolib: drop irq_base field from gpio_chip struct
    
    Hence, the last user of irq_base field was removed by commit b4c495f03ae3
    ("gpio: mockup: use irq_sim") it can be removed safely.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c97f8325e8bf..6bbda879fb8b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -83,7 +83,6 @@ struct module;
  * @irqchip: GPIO IRQ chip impl, provided by GPIO driver
  * @irqdomain: Interrupt translation domain; responsible for mapping
  *	between GPIO hwirq number and linux irq number
- * @irq_base: first linux IRQ number assigned to GPIO IRQ chip (deprecated)
  * @irq_handler: the irq handler to use (often a predefined irq core function)
  *	for GPIO IRQs, provided by GPIO driver
  * @irq_default_type: default IRQ triggering type applied during GPIO driver
@@ -165,7 +164,6 @@ struct gpio_chip {
 	 */
 	struct irq_chip		*irqchip;
 	struct irq_domain	*irqdomain;
-	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 	unsigned int		irq_chained_parent;

commit e3b445d77819b8fb41e3ceae9dbd49c8c8427c5d
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 24 16:57:28 2017 +0200

    gpio: Use unsigned int for of_gpio_n_cells
    
    The cell count for GPIO specifiers can never be negative, so make the
    field unsigned.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index fe66c9306caf..c97f8325e8bf 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -193,7 +193,7 @@ struct gpio_chip {
 	 *
 	 * Number of cells used to form the GPIO specifier.
 	 */
-	int of_gpio_n_cells;
+	unsigned int of_gpio_n_cells;
 
 	/**
 	 * @of_xlate:

commit 67049c505017d7b380e16aa4f4b02344c2be0d55
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 24 16:57:23 2017 +0200

    gpio: of: Improve kerneldoc
    
    Add descriptions for missing fields and fix up some parameter references
    to match the code.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ad4150d075c3..fe66c9306caf 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -180,8 +180,27 @@ struct gpio_chip {
 	 * If CONFIG_OF is enabled, then all GPIO controllers described in the
 	 * device tree automatically may have an OF translation
 	 */
+
+	/**
+	 * @of_node:
+	 *
+	 * Pointer to a device tree node representing this GPIO controller.
+	 */
 	struct device_node *of_node;
+
+	/**
+	 * @of_gpio_n_cells:
+	 *
+	 * Number of cells used to form the GPIO specifier.
+	 */
 	int of_gpio_n_cells;
+
+	/**
+	 * @of_xlate:
+	 *
+	 * Callback to translate a device tree GPIO specifier into a chip-
+	 * relative GPIO number and flags.
+	 */
 	int (*of_xlate)(struct gpio_chip *gc,
 			const struct of_phandle_args *gpiospec, u32 *flags);
 #endif

commit 950d55f5bf7991222e34428b5f779bd030b6a42a
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 24 16:57:22 2017 +0200

    gpio: Cleanup kerneldoc
    
    Some kerneldoc has become stale or wasn't quite correct from the outset.
    Fix up the most serious issues to silence warnings when building the
    documentation.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index af20369ec8e7..ad4150d075c3 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -327,11 +327,10 @@ int gpiochip_generic_config(struct gpio_chip *chip, unsigned offset,
 
 /**
  * struct gpio_pin_range - pin range controlled by a gpio chip
- * @head: list for maintaining set of pin ranges, used internally
+ * @node: list for maintaining set of pin ranges, used internally
  * @pctldev: pinctrl device which handles corresponding pins
  * @range: actual range of pins controlled by a gpio controller
  */
-
 struct gpio_pin_range {
 	struct list_head node;
 	struct pinctrl_dev *pctldev;

commit 05f479bf7d239f01ff6546f2bdeb14ad0fe65601
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue May 23 15:47:29 2017 +0100

    gpio: Add new flags to control sleep status of GPIOs
    
    Add new flags to allow users to specify that they are not concerned with
    the status of GPIOs whilst in a sleep/low power state.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 393582867afd..af20369ec8e7 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -213,6 +213,9 @@ bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_open_drain(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_open_source(struct gpio_chip *chip, unsigned int offset);
 
+/* Sleep persistence inquiry for drivers */
+bool gpiochip_line_is_persistent(struct gpio_chip *chip, unsigned int offset);
+
 /* get driver data */
 void *gpiochip_get_data(struct gpio_chip *chip);
 

commit 6f79309acc32b025064a496dbfcd4c70c557294e
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Apr 3 18:05:21 2017 +0200

    gpio: Use unsigned int for interrupt numbers
    
    Interrupt numbers are never negative, zero serves as the special invalid
    value.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 846f3b989480..393582867afd 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -168,7 +168,7 @@ struct gpio_chip {
 	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
-	int			irq_chained_parent;
+	unsigned int		irq_chained_parent;
 	bool			irq_nested;
 	bool			irq_need_valid_mask;
 	unsigned long		*irq_valid_mask;
@@ -244,12 +244,12 @@ int bgpio_init(struct gpio_chip *gc, struct device *dev,
 
 void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
-		int parent_irq,
+		unsigned int parent_irq,
 		irq_flow_handler_t parent_handler);
 
 void gpiochip_set_nested_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
-		int parent_irq);
+		unsigned int parent_irq);
 
 int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
 			     struct irq_chip *irqchip,

commit 7f36f5d11cda050b118f76d774151427a18d15ef
Merge: 2b24efa8e5c5 566cf877a1fc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 30 14:39:20 2017 +0100

    Merge tag 'v4.10-rc6' into devel
    
    Linux 4.10-rc6
    
    Resolved conflicts in:
            drivers/pinctrl/pinctrl-amd.c
            drivers/pinctrl/samsung/pinctrl-exynos.c

commit 2956b5d94a76b596fa5057c2b3ca915cb27d7652
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jan 23 15:34:34 2017 +0300

    pinctrl / gpio: Introduce .set_config() callback for GPIO chips
    
    Currently we already have two pin configuration related callbacks
    available for GPIO chips .set_single_ended() and .set_debounce(). In
    future we expect to have even more, which does not scale well if we need
    to add yet another callback to the GPIO chip structure for each possible
    configuration parameter.
    
    Better solution is to reuse what we already have available in the
    generic pinconf.
    
    To support this, we introduce a new .set_config() callback for GPIO
    chips. The callback takes a single packed pin configuration value as
    parameter. This can then be extended easily beyond what is currently
    supported by just adding new types to the generic pinconf enum.
    
    If the GPIO driver is backed up by a pinctrl driver the GPIO driver can
    just assign gpiochip_generic_config() (introduced in this patch) to
    .set_config and that will take care configuration requests are directed
    to the pinctrl driver.
    
    We then convert the existing drivers over .set_config() and finally
    remove the .set_single_ended() and .set_debounce() callbacks.
    
    Suggested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c2748accea71..db2022910caf 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -8,6 +8,7 @@
 #include <linux/irqdomain.h>
 #include <linux/lockdep.h>
 #include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf-generic.h>
 
 struct gpio_desc;
 struct of_phandle_args;
@@ -18,18 +19,6 @@ struct module;
 
 #ifdef CONFIG_GPIOLIB
 
-/**
- * enum single_ended_mode - mode for single ended operation
- * @LINE_MODE_PUSH_PULL: normal mode for a GPIO line, drive actively high/low
- * @LINE_MODE_OPEN_DRAIN: set line to be open drain
- * @LINE_MODE_OPEN_SOURCE: set line to be open source
- */
-enum single_ended_mode {
-	LINE_MODE_PUSH_PULL,
-	LINE_MODE_OPEN_DRAIN,
-	LINE_MODE_OPEN_SOURCE,
-};
-
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: a functional name for the GPIO device, such as a part
@@ -48,16 +37,8 @@ enum single_ended_mode {
  * @get: returns value for signal "offset", 0=low, 1=high, or negative error
  * @set: assigns output value for signal "offset"
  * @set_multiple: assigns output values for multiple signals defined by "mask"
- * @set_debounce: optional hook for setting debounce time for specified gpio in
- *	interrupt triggered gpio chips
- * @set_single_ended: optional hook for setting a line as open drain, open
- *	source, or non-single ended (restore from open drain/source to normal
- *	push-pull mode) this should be implemented if the hardware supports
- *	open drain or open source settings. The GPIOlib will otherwise try
- *	to emulate open drain/source by not actively driving lines high/low
- *	if a consumer request this. The driver may return -ENOTSUPP if e.g.
- *	it supports just open drain but not open source and is called
- *	with LINE_MODE_OPEN_SOURCE as mode argument.
+ * @set_config: optional hook for all kinds of settings. Uses the same
+ *	packed config format as generic pinconf.
  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
  *	implementation may not sleep
  * @dbg_show: optional routine to show contents in debugfs; default code
@@ -150,13 +131,9 @@ struct gpio_chip {
 	void			(*set_multiple)(struct gpio_chip *chip,
 						unsigned long *mask,
 						unsigned long *bits);
-	int			(*set_debounce)(struct gpio_chip *chip,
-						unsigned offset,
-						unsigned debounce);
-	int			(*set_single_ended)(struct gpio_chip *chip,
-						unsigned offset,
-						enum single_ended_mode mode);
-
+	int			(*set_config)(struct gpio_chip *chip,
+					      unsigned offset,
+					      unsigned long config);
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);
 
@@ -310,6 +287,8 @@ static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 
 int gpiochip_generic_request(struct gpio_chip *chip, unsigned offset);
 void gpiochip_generic_free(struct gpio_chip *chip, unsigned offset);
+int gpiochip_generic_config(struct gpio_chip *chip, unsigned offset,
+			    unsigned long config);
 
 #ifdef CONFIG_PINCTRL
 

commit 739e6f5945d88dcee01590913f6886132a10c215
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jan 11 13:37:07 2017 +0100

    gpio: provide lockdep keys for nested/unnested irqchips
    
    The helper function for adding a GPIO chip compiles in a lockdep
    key for debugging, the same key is needed for nested chips as
    well.
    
    The macro construction is unreadable, replace this with two
    static inlines instead.
    
    The _gpiochip_irqchip_add prefixed function is not helpful,
    rename it with gpiochip_irqchip_add_key() that tell us what the
    function is actually doing.
    
    Fixes: d245b3f9bd36 ("gpio: simplify adding threaded interrupts")
    Cc: Roger Quadros <rogerq@ti.com>
    Reported-by: Clemens Gruber <clemens.gruber@pqgruber.com>
    Reported-by: Roger Quadros <rogerq@ti.com>
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Clemens Gruber <clemens.gruber@pqgruber.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c2748accea71..e973faba69dc 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -274,37 +274,67 @@ void gpiochip_set_nested_irqchip(struct gpio_chip *gpiochip,
 		struct irq_chip *irqchip,
 		int parent_irq);
 
-int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+int gpiochip_irqchip_add_key(struct gpio_chip *gpiochip,
+			     struct irq_chip *irqchip,
+			     unsigned int first_irq,
+			     irq_flow_handler_t handler,
+			     unsigned int type,
+			     bool nested,
+			     struct lock_class_key *lock_key);
+
+#ifdef CONFIG_LOCKDEP
+
+/*
+ * Lockdep requires that each irqchip instance be created with a
+ * unique key so as to avoid unnecessary warnings. This upfront
+ * boilerplate static inlines provides such a key for each
+ * unique instance.
+ */
+static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+				       struct irq_chip *irqchip,
+				       unsigned int first_irq,
+				       irq_flow_handler_t handler,
+				       unsigned int type)
+{
+	static struct lock_class_key key;
+
+	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+					handler, type, false, &key);
+}
+
+static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 			  struct irq_chip *irqchip,
 			  unsigned int first_irq,
 			  irq_flow_handler_t handler,
-			  unsigned int type,
-			  bool nested,
-			  struct lock_class_key *lock_key);
+			  unsigned int type)
+{
+
+	static struct lock_class_key key;
+
+	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+					handler, type, true, &key);
+}
+#else
+static inline int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+				       struct irq_chip *irqchip,
+				       unsigned int first_irq,
+				       irq_flow_handler_t handler,
+				       unsigned int type)
+{
+	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+					handler, type, false, NULL);
+}
 
-/* FIXME: I assume threaded IRQchips do not have the lockdep problem */
 static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
 			  struct irq_chip *irqchip,
 			  unsigned int first_irq,
 			  irq_flow_handler_t handler,
 			  unsigned int type)
 {
-	return _gpiochip_irqchip_add(gpiochip, irqchip, first_irq,
-				     handler, type, true, NULL);
+	return gpiochip_irqchip_add_key(gpiochip, irqchip, first_irq,
+					handler, type, true, NULL);
 }
-
-#ifdef CONFIG_LOCKDEP
-#define gpiochip_irqchip_add(...)				\
-(								\
-	({							\
-		static struct lock_class_key _key;		\
-		_gpiochip_irqchip_add(__VA_ARGS__, false, &_key); \
-	})							\
-)
-#else
-#define gpiochip_irqchip_add(...)				\
-	_gpiochip_irqchip_add(__VA_ARGS__, false, NULL)
-#endif
+#endif /* CONFIG_LOCKDEP */
 
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 

commit acf1fcf77247efa01d7213f53082451f6c9c8f3b
Merge: eb485c7d9e6d 35ca3f61617d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Dec 7 15:24:12 2016 +0100

    Merge branch 'thread-irq-simpler' into devel

commit d245b3f9bd36f02fd641cba9931d8b4c77126e74
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Nov 24 10:57:25 2016 +0100

    gpio: simplify adding threaded interrupts
    
    This tries to simplify the use of CONFIG_GPIOLIB_IRQCHIP when
    using threaded interrupts: add a new call
    gpiochip_irqchip_add_nested() to indicate that we're dealing
    with a nested rather than a chained irqchip, then create a
    separate gpiochip_set_nested_irqchip() to mirror
    the gpiochip_set_chained_irqchip() call to connect the
    parent and child interrupts.
    
    In the nested case gpiochip_set_nested_irqchip() does nothing
    more than call irq_set_parent() on each valid child interrupt,
    which has little semantic effect in the kernel, but this is
    probably still formally correct.
    
    Update all drivers using nested interrupts to use
    gpiochip_irqchip_add_nested() so we can now see clearly
    which these users are.
    
    The DLN2 driver can drop its specific hack with
    .irq_not_threaded as we now recognize whether a chip is
    threaded or not from its use of gpiochip_irqchip_add_nested()
    signature rather than from inspecting .can_sleep.
    
    We rename the .irq_parent to .irq_chained_parent since this
    parent IRQ is only really kept around for the chained
    interrupt handlers.
    
    Cc: Lars Poeschel <poeschel@lemonage.de>
    Cc: Octavian Purdila <octavian.purdila@intel.com>
    Cc: Daniel Baluta <daniel.baluta@intel.com>
    Cc: Bin Gao <bin.gao@linux.intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Ajay Thomas <ajay.thomas.david.rajamanickam@intel.com>
    Cc: Semen Protsenko <semen.protsenko@globallogic.com>
    Cc: Alexander Stein <alexander.stein@systec-electronic.com>
    Cc: Phil Reid <preid@electromag.com.au>
    Cc: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 24e2cc56beb1..4b20238e7570 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -82,8 +82,6 @@ enum single_ended_mode {
  *	implies that if the chip supports IRQs, these IRQs need to be threaded
  *	as the chip access may sleep when e.g. reading out the IRQ status
  *	registers.
- * @irq_not_threaded: flag must be set if @can_sleep is set but the
- *	IRQs don't need to be threaded
  * @read_reg: reader function for generic GPIO
  * @write_reg: writer function for generic GPIO
  * @pin2mask: some generic GPIO controllers work with the big-endian bits
@@ -109,8 +107,10 @@ enum single_ended_mode {
  *	for GPIO IRQs, provided by GPIO driver
  * @irq_default_type: default IRQ triggering type applied during GPIO driver
  *	initialization, provided by GPIO driver
- * @irq_parent: GPIO IRQ chip parent/bank linux irq number,
- *	provided by GPIO driver
+ * @irq_chained_parent: GPIO IRQ chip parent/bank linux irq number,
+ *	provided by GPIO driver for chained interrupt (not for nested
+ *	interrupts).
+ * @irq_nested: True if set the interrupt handling is nested.
  * @irq_need_valid_mask: If set core allocates @irq_valid_mask with all
  *	bits set to one
  * @irq_valid_mask: If not %NULL holds bitmask of GPIOs which are valid to
@@ -166,7 +166,6 @@ struct gpio_chip {
 	u16			ngpio;
 	const char		*const *names;
 	bool			can_sleep;
-	bool			irq_not_threaded;
 
 #if IS_ENABLED(CONFIG_GPIO_GENERIC)
 	unsigned long (*read_reg)(void __iomem *reg);
@@ -192,7 +191,8 @@ struct gpio_chip {
 	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
-	int			irq_parent;
+	int			irq_chained_parent;
+	bool			irq_nested;
 	bool			irq_need_valid_mask;
 	unsigned long		*irq_valid_mask;
 	struct lock_class_key	*lock_key;
@@ -270,24 +270,40 @@ void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
 		int parent_irq,
 		irq_flow_handler_t parent_handler);
 
+void gpiochip_set_nested_irqchip(struct gpio_chip *gpiochip,
+		struct irq_chip *irqchip,
+		int parent_irq);
+
 int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 			  struct irq_chip *irqchip,
 			  unsigned int first_irq,
 			  irq_flow_handler_t handler,
 			  unsigned int type,
+			  bool nested,
 			  struct lock_class_key *lock_key);
 
+/* FIXME: I assume threaded IRQchips do not have the lockdep problem */
+static inline int gpiochip_irqchip_add_nested(struct gpio_chip *gpiochip,
+			  struct irq_chip *irqchip,
+			  unsigned int first_irq,
+			  irq_flow_handler_t handler,
+			  unsigned int type)
+{
+	return _gpiochip_irqchip_add(gpiochip, irqchip, first_irq,
+				     handler, type, true, NULL);
+}
+
 #ifdef CONFIG_LOCKDEP
 #define gpiochip_irqchip_add(...)				\
 (								\
 	({							\
 		static struct lock_class_key _key;		\
-		_gpiochip_irqchip_add(__VA_ARGS__, &_key);	\
+		_gpiochip_irqchip_add(__VA_ARGS__, false, &_key); \
 	})							\
 )
 #else
 #define gpiochip_irqchip_add(...)				\
-	_gpiochip_irqchip_add(__VA_ARGS__, NULL)
+	_gpiochip_irqchip_add(__VA_ARGS__, false, NULL)
 #endif
 
 #endif /* CONFIG_GPIOLIB_IRQCHIP */

commit 08bcd3edec2559833aa0ed0213cc300fc9705dd6
Author: Anthony Best <anthonybest@bestanthony.com>
Date:   Tue Oct 4 14:15:42 2016 -0600

    gpio: fix struct gpio_chip comment
    
    It should have been @reg_clr instead of @reg_clk
    
    Signed-off-by: Anthony Best <anthonybest@bestanthony.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 24e2cc56beb1..2dfcf25b1724 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -91,7 +91,7 @@ enum single_ended_mode {
  *	bit. This callback assigns the right bit mask.
  * @reg_dat: data (in) register for generic GPIO
  * @reg_set: output set register (out=high) for generic GPIO
- * @reg_clk: output clear register (out=low) for generic GPIO
+ * @reg_clr: output clear register (out=low) for generic GPIO
  * @reg_dir: direction setting register for generic GPIO
  * @bgpio_bits: number of register bits used for a generic GPIO i.e.
  *	<register width> * 8

commit 97139d4a6f26445de47b378cddd5192c0278f863
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 11 13:55:58 2016 -0700

    treewide: remove redundant #include <linux/kconfig.h>
    
    Kernel source files need not include <linux/kconfig.h> explicitly
    because the top Makefile forces to include it with:
    
      -include $(srctree)/include/linux/kconfig.h
    
    This commit removes explicit includes except the following:
    
      * arch/s390/include/asm/facilities_src.h
      * tools/testing/radix-tree/linux/kernel.h
    
    These two are used for host programs.
    
    Link: http://lkml.kernel.org/r/1473656164-11929-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1f0be7213e6d..24e2cc56beb1 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -8,7 +8,6 @@
 #include <linux/irqdomain.h>
 #include <linux/lockdep.h>
 #include <linux/pinctrl/pinctrl.h>
-#include <linux/kconfig.h>
 
 struct gpio_desc;
 struct of_phandle_args;

commit 22a5db98a30ea734c29056b0d59cb4fe2a383bc2
Merge: 9132ce450bd1 79b804cb6af4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 23 14:51:18 2016 +0200

    Merge branch 'gpio-irq-validmask' of /home/linus/linux-pinctrl into devel

commit 79b804cb6af4f128b2c53f0887c02537a7eb5824
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Sep 20 15:15:21 2016 +0300

    gpiolib: Make it possible to exclude GPIOs from IRQ domain
    
    When using GPIO irqchip helpers to setup irqchip for a gpiolib based
    driver, it is not possible to select which GPIOs to add to the IRQ domain.
    Instead it just adds all GPIOs which is not always desired. For example
    there might be GPIOs that for some reason cannot generated normal
    interrupts at all.
    
    To support this we add a flag irq_need_valid_mask to struct gpio_chip. When
    this flag is set the core allocates irq_valid_mask that holds one bit for
    each GPIO the chip has. By default all bits are set but drivers can
    manipulate this using set_bit() and clear_bit() accordingly.
    
    Then when gpiochip_irqchip_add() is called, this mask is checked and all
    GPIOs with bit is set are added to the IRQ domain created for the GPIO
    chip.
    
    Suggested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 50882e09289b..420b837f2aa7 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -112,6 +112,10 @@ enum single_ended_mode {
  *	initialization, provided by GPIO driver
  * @irq_parent: GPIO IRQ chip parent/bank linux irq number,
  *	provided by GPIO driver
+ * @irq_need_valid_mask: If set core allocates @irq_valid_mask with all
+ *	bits set to one
+ * @irq_valid_mask: If not %NULL holds bitmask of GPIOs which are valid to
+ *	be included in IRQ domain of the chip
  * @lock_key: per GPIO IRQ chip lockdep class
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
@@ -190,6 +194,8 @@ struct gpio_chip {
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 	int			irq_parent;
+	bool			irq_need_valid_mask;
+	unsigned long		*irq_valid_mask;
 	struct lock_class_key	*lock_key;
 #endif
 

commit d47529b2e9fe0ec2eb1f072afad8849f52e385c4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Sep 12 18:16:31 2016 -0400

    gpio: don't include module.h in shared driver header
    
    Most shared headers in include/linux don't need to know what the
    internals of a struct module are; all they care about is that it
    is a struct and hence they may require a pointer to one.
    
    The advantage in this is that module.h is including a lot of stuff
    itself, and an otherwise empty C file that just contains module.h
    will result in ~750kB from CPP (compared to say 12kB from init.h)
    
    So we have approximately 50 instances of "struct module;" in the
    various include/linux headers already that help us keep module.h
    out of other headers; here we do the same for gpio.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: linux-gpio@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 50882e09289b..216e6f275aa8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -3,7 +3,6 @@
 
 #include <linux/device.h>
 #include <linux/types.h>
-#include <linux/module.h>
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
@@ -16,6 +15,7 @@ struct of_phandle_args;
 struct device_node;
 struct seq_file;
 struct gpio_device;
+struct module;
 
 #ifdef CONFIG_GPIOLIB
 

commit c663e5f56737757db4d0b317c510ab505f93cecb
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 22 10:51:16 2016 +0100

    gpio: support native single-ended hardware drivers
    
    Some GPIO controllers has a special hardware bit we can flip
    to support open drain / source. This means that on these hardwares
    we do not need to emulate OD/OS by setting the line to input
    instead of actively driving it high/low. Add an optional vtable
    callback to the driver set_single_ended() so that driver can
    implement this in hardware if they have it.
    
    We may need a pinctrl_gpio_set_config() call at some point to
    propagate this down to a backing pin control device on systems
    with split GPIO/pin control.
    
    Reported-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index bee976f82788..50882e09289b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -19,6 +19,18 @@ struct gpio_device;
 
 #ifdef CONFIG_GPIOLIB
 
+/**
+ * enum single_ended_mode - mode for single ended operation
+ * @LINE_MODE_PUSH_PULL: normal mode for a GPIO line, drive actively high/low
+ * @LINE_MODE_OPEN_DRAIN: set line to be open drain
+ * @LINE_MODE_OPEN_SOURCE: set line to be open source
+ */
+enum single_ended_mode {
+	LINE_MODE_PUSH_PULL,
+	LINE_MODE_OPEN_DRAIN,
+	LINE_MODE_OPEN_SOURCE,
+};
+
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: a functional name for the GPIO device, such as a part
@@ -38,7 +50,15 @@ struct gpio_device;
  * @set: assigns output value for signal "offset"
  * @set_multiple: assigns output values for multiple signals defined by "mask"
  * @set_debounce: optional hook for setting debounce time for specified gpio in
- *      interrupt triggered gpio chips
+ *	interrupt triggered gpio chips
+ * @set_single_ended: optional hook for setting a line as open drain, open
+ *	source, or non-single ended (restore from open drain/source to normal
+ *	push-pull mode) this should be implemented if the hardware supports
+ *	open drain or open source settings. The GPIOlib will otherwise try
+ *	to emulate open drain/source by not actively driving lines high/low
+ *	if a consumer request this. The driver may return -ENOTSUPP if e.g.
+ *	it supports just open drain but not open source and is called
+ *	with LINE_MODE_OPEN_SOURCE as mode argument.
  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
  *	implementation may not sleep
  * @dbg_show: optional routine to show contents in debugfs; default code
@@ -130,6 +150,9 @@ struct gpio_chip {
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset,
 						unsigned debounce);
+	int			(*set_single_ended)(struct gpio_chip *chip,
+						unsigned offset,
+						enum single_ended_mode mode);
 
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);

commit 0cf3292cde22f8843ae5d1eeb8466d8121243c1a
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Mon Feb 15 16:32:09 2016 +0530

    gpio: Add devm_ apis for gpiochip_add_data and gpiochip_remove
    
    Add device managed APIs devm_gpiochip_add_data() and
    devm_gpiochip_remove() for the APIs gpiochip_add_data()
    and gpiochip_remove().
    
    This helps in reducing code in error path and sometimes
    removal of .remove callback for driver unbind.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 639607658ed8..bee976f82788 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -192,6 +192,10 @@ static inline int gpiochip_add(struct gpio_chip *chip)
 	return gpiochip_add_data(chip, NULL);
 }
 extern void gpiochip_remove(struct gpio_chip *chip);
+extern int devm_gpiochip_add_data(struct device *dev, struct gpio_chip *chip,
+				  void *data);
+extern void devm_gpiochip_remove(struct device *dev, struct gpio_chip *chip);
+
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 

commit df4878e969ccc047da45d2cd3af5d08031da1593
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 12 14:48:23 2016 +0100

    gpio: store reflect the label to userspace
    
    The gpio_chip label is useful for userspace to understand what
    kind of GPIO chip it is dealing with. Let's store a copy of this
    label in the gpio_device, add it to the struct passed to userspace
    for GPIO_GET_CHIPINFO_IOCTL and modify lsgpio to show it.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ff96d0f9fceb..639607658ed8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -21,7 +21,8 @@ struct gpio_device;
 
 /**
  * struct gpio_chip - abstract a GPIO controller
- * @label: for diagnostics
+ * @label: a functional name for the GPIO device, such as a part
+ *	number or the name of the SoC IP-block implementing it.
  * @gpiodev: the internal state holder, opaque struct
  * @parent: optional parent device providing the GPIOs
  * @owner: helps prevent removal of modules exporting active GPIOs

commit 143b65d677a59764e438d457bf2510b3fa5b90f8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 16 15:41:42 2016 +0100

    gpio: create an API to detect open drain/source on lines
    
    My left hand merges code to privatize the descriptor handling
    while my right hand merges drivers that poke around and
    disrespect with the same gpiolib internals.
    
    So let's expose the proper APIs for drivers to ask the gpiolib
    core if a line is marked as open drain or open source and
    get some order around things so this driver compiles again.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Nicolas Saenz Julienne <nicolassaenzj@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index b92ab9efdb69..ff96d0f9fceb 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -199,6 +199,10 @@ int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 
+/* Line status inquiry for drivers */
+bool gpiochip_line_is_open_drain(struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_open_source(struct gpio_chip *chip, unsigned int offset);
+
 /* get driver data */
 void *gpiochip_get_data(struct gpio_chip *chip);
 

commit 43c54ecade400cf6ca8203f960b525fbe5b73a13
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 11 11:37:48 2016 +0100

    gpio: move the subdriver data pointer into gpio_device
    
    We move to manage this pointer under gpiolib control rather than
    leave it in the subdevice's gpio_chip. We can not NULL it after
    gpiochip_remove so at to keep things tight.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e2a934ce3e64..b92ab9efdb69 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -25,7 +25,6 @@ struct gpio_device;
  * @gpiodev: the internal state holder, opaque struct
  * @parent: optional parent device providing the GPIOs
  * @owner: helps prevent removal of modules exporting active GPIOs
- * @data: per-instance data assigned by the driver
  * @request: optional hook for chip-specific activation, such as
  *	enabling module power and clock; may sleep
  * @free: optional hook for chip-specific deactivation, such as
@@ -109,7 +108,6 @@ struct gpio_chip {
 	struct gpio_device	*gpiodev;
 	struct device		*parent;
 	struct module		*owner;
-	void			*data;
 
 	int			(*request)(struct gpio_chip *chip,
 						unsigned offset);
@@ -202,10 +200,7 @@ void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 
 /* get driver data */
-static inline void *gpiochip_get_data(struct gpio_chip *chip)
-{
-	return chip->data;
-}
+void *gpiochip_get_data(struct gpio_chip *chip);
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 

commit 20ec3e39fc12cf3a331ee73eb01d52bddcdd2fa4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 11 11:03:06 2016 +0100

    gpio: move the pin ranges into gpio_device
    
    Instead of keeping this reference to the pin ranges in the
    client driver-supplied gpio_chip, move it to the internal
    gpio_device as the drivers have no need to inspect this.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 41c6144c473b..e2a934ce3e64 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -181,15 +181,6 @@ struct gpio_chip {
 	int (*of_xlate)(struct gpio_chip *gc,
 			const struct of_phandle_args *gpiospec, u32 *flags);
 #endif
-#ifdef CONFIG_PINCTRL
-	/*
-	 * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally
-	 * describe the actual pin range which they serve in an SoC. This
-	 * information would be used by pinctrl subsystem to configure
-	 * corresponding pins for gpio usage.
-	 */
-	struct list_head pin_ranges;
-#endif
 };
 
 extern const char *gpiochip_is_requested(struct gpio_chip *chip,

commit 6cee3821e4e4bd6e6cdf0870b6c72d455460bd39
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 11 20:16:45 2016 +0100

    gpio/pinctrl: sunxi: stop poking around in private vars
    
    This kind of hacks disturbs the refactoring of the gpiolib.
    
    The descriptor table belongs to the gpiolib, if we want to know
    something about something in it, use or define the proper accessor
    functions. Let's add this gpiochip_lins_is_irq() to do what the
    sunxi driver is trying at so we can privatize the descriptors
    properly.
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index bfc842c2fc57..41c6144c473b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -208,6 +208,7 @@ extern struct gpio_chip *gpiochip_find(void *data,
 /* lock/unlock as IRQ */
 int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
+bool gpiochip_line_is_irq(struct gpio_chip *chip, unsigned int offset);
 
 /* get driver data */
 static inline void *gpiochip_get_data(struct gpio_chip *chip)

commit 1c3cdb186172ee3be24005a7ff0e849bc17b67b8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 9 13:51:59 2016 +0100

    gpio: move descriptors into gpio_device
    
    We need gpio_device to hold the descriptors so that they can
    be lifecycled with the struct gpio_device held from userspace.
    Move the descriptor array into gpio_device. Also rename it from
    "desc" (singularis) to "descs" (pluralis) to reflect the fact
    that it is an array.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 4db64ab534ef..bfc842c2fc57 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -52,7 +52,6 @@ struct gpio_device;
  *	get rid of the static GPIO number space in the long run.
  * @ngpio: the number of GPIOs handled by this controller; the last GPIO
  *	handled is (base + ngpio - 1).
- * @desc: array of ngpio descriptors. Private.
  * @names: if set, must be an array of strings to use as alternative
  *      names for the GPIOs in this chip. Any entry in the array
  *      may be NULL if there is no alias for the GPIO, however the
@@ -140,7 +139,6 @@ struct gpio_chip {
 						struct gpio_chip *chip);
 	int			base;
 	u16			ngpio;
-	struct gpio_desc	*desc;
 	const char		*const *names;
 	bool			can_sleep;
 	bool			irq_not_threaded;

commit afbc4f312b5e6e87fcd383eb6764e09f1324c78e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Feb 9 13:21:06 2016 +0100

    gpio: move sysfs mock device to the gpio_device
    
    Since gpio_device is the struct that survives if the backing
    gpio_chip is removed, move the sysfs mock device to this state
    container so it becomes part of the dangling state of the
    GPIO device on removal.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index f3f1dbd43c9b..4db64ab534ef 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -24,7 +24,6 @@ struct gpio_device;
  * @label: for diagnostics
  * @gpiodev: the internal state holder, opaque struct
  * @parent: optional parent device providing the GPIOs
- * @cdev: class device used by sysfs interface (may be NULL)
  * @owner: helps prevent removal of modules exporting active GPIOs
  * @data: per-instance data assigned by the driver
  * @request: optional hook for chip-specific activation, such as
@@ -110,7 +109,6 @@ struct gpio_chip {
 	const char		*label;
 	struct gpio_device	*gpiodev;
 	struct device		*parent;
-	struct device		*cdev;
 	struct module		*owner;
 	void			*data;
 

commit ff2b1359229927563addbf2f5ad480660c350903
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 20 11:10:38 2015 +0200

    gpio: make the gpiochip a real device
    
    GPIO chips have been around for years, but were never real devices,
    instead they were piggy-backing on a parent device (such as a
    platform_device or amba_device) but this was always optional.
    GPIO chips could also exist without any device at all, with its
    struct device *parent (ex *dev) pointer being set to null.
    
    When sysfs was in use, a mock device would be created, with the
    optional parent assigned, or just floating orphaned with NULL
    as parent.
    
    If sysfs is active, it will use this device as parent.
    
    We now create a gpio_device struct containing a real
    struct device and move the subsystem over to using that. The
    list of struct gpio_chip:s is augmented to hold struct
    gpio_device:s and we find gpio_chips:s by first looking up
    the struct gpio_device.
    
    The struct gpio_device is designed to stay around even if the
    gpio_chip is removed, so as to satisfy users in userspace
    that need a backing data structure to hold the state of the
    session initiated with e.g. a character device even if there is
    no physical chip anymore.
    
    From this point on, gpiochips are devices.
    
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Michael Welling <mwelling@ieee.org>
    Cc: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 82fda487453f..f3f1dbd43c9b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -1,6 +1,7 @@
 #ifndef __LINUX_GPIO_DRIVER_H
 #define __LINUX_GPIO_DRIVER_H
 
+#include <linux/device.h>
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/irq.h>
@@ -10,22 +11,22 @@
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/kconfig.h>
 
-struct device;
 struct gpio_desc;
 struct of_phandle_args;
 struct device_node;
 struct seq_file;
+struct gpio_device;
 
 #ifdef CONFIG_GPIOLIB
 
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: for diagnostics
+ * @gpiodev: the internal state holder, opaque struct
  * @parent: optional parent device providing the GPIOs
  * @cdev: class device used by sysfs interface (may be NULL)
  * @owner: helps prevent removal of modules exporting active GPIOs
  * @data: per-instance data assigned by the driver
- * @list: links gpio_chips together for traversal
  * @request: optional hook for chip-specific activation, such as
  *	enabling module power and clock; may sleep
  * @free: optional hook for chip-specific deactivation, such as
@@ -107,11 +108,11 @@ struct seq_file;
  */
 struct gpio_chip {
 	const char		*label;
+	struct gpio_device	*gpiodev;
 	struct device		*parent;
 	struct device		*cdev;
 	struct module		*owner;
 	void			*data;
-	struct list_head        list;
 
 	int			(*request)(struct gpio_chip *chip,
 						unsigned offset);

commit c474e348778bdf5b453a2cdff4b2b1f9e000f343
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jan 9 22:16:42 2016 +0100

    gpio: generic: make bgpio_pdata always visible
    
    Board files that define their own bgpio_pdata are broken when
    CONFIG_GPIO_GENERIC is disabled and the bgpio_pdata structure
    definition is hidden by the #ifdef:
    
    arch/arm/mach-clps711x/board-autcpu12.c:148:15: error: variable 'autcpu12_mmgpio_pdata' has initializer but incomplete type
     static struct bgpio_pdata autcpu12_mmgpio_pdata __initdata = {
    arch/arm/mach-clps711x/board-autcpu12.c:149:2: error: unknown field 'base' specified in initializer
      .base = AUTCPU12_MMGPIO_BASE,
    
    Since the board files should generally not care what drivers are
    enabled, this makes the structure definition visible again.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 0f4630f3720e ("gpio: generic: factor into gpio_chip struct")
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e2d05fd0e6e3..82fda487453f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -220,14 +220,14 @@ static inline void *gpiochip_get_data(struct gpio_chip *chip)
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 
-#if IS_ENABLED(CONFIG_GPIO_GENERIC)
-
 struct bgpio_pdata {
 	const char *label;
 	int base;
 	int ngpio;
 };
 
+#if IS_ENABLED(CONFIG_GPIO_GENERIC)
+
 int bgpio_init(struct gpio_chip *gc, struct device *dev,
 	       unsigned long sz, void __iomem *dat, void __iomem *set,
 	       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,

commit 0f4630f3720e7e6e921bf525c8357fea7ef3dbab
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Dec 4 14:02:58 2015 +0100

    gpio: generic: factor into gpio_chip struct
    
    The separate struct bgpio_chip has been a pain to handle, both
    by being confusingly similar in name to struct gpio_chip and
    for being contained inside a struct so that struct gpio_chip
    is contained in a struct contained in a struct, making several
    steps of dereferencing necessary.
    
    Make things simpler: include the fields directly into
    <linux/gpio/driver.h>, #ifdef:ed for CONFIG_GENERIC_GPIO, and
    get rid of the <linux/basic_mmio_gpio.h> altogether. Prefix
    some of the member variables with bgpio_* and add proper
    kerneldoc while we're at it.
    
    Modify all users to handle the change and use a struct
    gpio_chip directly. And while we're at it: replace all
    container_of() dereferencing by gpiochip_get_data() and
    registering the gpio_chip with gpiochip_add_data().
    
    Cc: arm@kernel.org
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Rabin Vincent <rabin@rab.in>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: bcm-kernel-feedback-list@broadcom.com
    Acked-by: Gregory Fong <gregory.0xf0@gmail.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index b833a5f9629a..e2d05fd0e6e3 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -8,6 +8,7 @@
 #include <linux/irqdomain.h>
 #include <linux/lockdep.h>
 #include <linux/pinctrl/pinctrl.h>
+#include <linux/kconfig.h>
 
 struct device;
 struct gpio_desc;
@@ -65,6 +66,23 @@ struct seq_file;
  *	registers.
  * @irq_not_threaded: flag must be set if @can_sleep is set but the
  *	IRQs don't need to be threaded
+ * @read_reg: reader function for generic GPIO
+ * @write_reg: writer function for generic GPIO
+ * @pin2mask: some generic GPIO controllers work with the big-endian bits
+ *	notation, e.g. in a 8-bits register, GPIO7 is the least significant
+ *	bit. This callback assigns the right bit mask.
+ * @reg_dat: data (in) register for generic GPIO
+ * @reg_set: output set register (out=high) for generic GPIO
+ * @reg_clk: output clear register (out=low) for generic GPIO
+ * @reg_dir: direction setting register for generic GPIO
+ * @bgpio_bits: number of register bits used for a generic GPIO i.e.
+ *	<register width> * 8
+ * @bgpio_lock: used to lock chip->bgpio_data. Also, this is needed to keep
+ *	shadowed and real data registers writes together.
+ * @bgpio_data:	shadowed data register for generic GPIO to clear/set bits
+ *	safely.
+ * @bgpio_dir: shadowed direction register for generic GPIO to clear/set
+ *	direction safely.
  * @irqchip: GPIO IRQ chip impl, provided by GPIO driver
  * @irqdomain: Interrupt translation domain; responsible for mapping
  *	between GPIO hwirq number and linux irq number
@@ -128,6 +146,20 @@ struct gpio_chip {
 	bool			can_sleep;
 	bool			irq_not_threaded;
 
+#if IS_ENABLED(CONFIG_GPIO_GENERIC)
+	unsigned long (*read_reg)(void __iomem *reg);
+	void (*write_reg)(void __iomem *reg, unsigned long data);
+	unsigned long (*pin2mask)(struct gpio_chip *gc, unsigned int pin);
+	void __iomem *reg_dat;
+	void __iomem *reg_set;
+	void __iomem *reg_clr;
+	void __iomem *reg_dir;
+	int bgpio_bits;
+	spinlock_t bgpio_lock;
+	unsigned long bgpio_data;
+	unsigned long bgpio_dir;
+#endif
+
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	/*
 	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
@@ -188,6 +220,28 @@ static inline void *gpiochip_get_data(struct gpio_chip *chip)
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 
+#if IS_ENABLED(CONFIG_GPIO_GENERIC)
+
+struct bgpio_pdata {
+	const char *label;
+	int base;
+	int ngpio;
+};
+
+int bgpio_init(struct gpio_chip *gc, struct device *dev,
+	       unsigned long sz, void __iomem *dat, void __iomem *set,
+	       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,
+	       unsigned long flags);
+
+#define BGPIOF_BIG_ENDIAN		BIT(0)
+#define BGPIOF_UNREADABLE_REG_SET	BIT(1) /* reg_set is unreadable */
+#define BGPIOF_UNREADABLE_REG_DIR	BIT(2) /* reg_dir is unreadable */
+#define BGPIOF_BIG_ENDIAN_BYTE_ORDER	BIT(3)
+#define BGPIOF_READ_OUTPUT_REG_SET	BIT(4) /* reg_set stores output value */
+#define BGPIOF_NO_OUTPUT		BIT(5) /* only input */
+
+#endif
+
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 
 void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,

commit b08ea35a3296ee25c4cb53a977b752266dafa2c2
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Dec 3 15:14:13 2015 +0100

    gpio: add a data pointer to gpio_chip
    
    This adds a void * pointer to gpio_chip so that driver can
    assign and retrieve some states. This is done to get rid of
    container_of() calls for gpio_chips embedded inside state
    containers, so we can remove the need to have the gpio_chip
    or later (planned) struct gpio_device be dynamically allocated
    at registration time, so that its struct device can be properly
    reference counted and not bound to its parent device (e.g.
    a platform_device) but instead live on after unregistration
    if it is opened by e.g. a char device or sysfs.
    
    The data is added with the new function gpiochip_add_data()
    and for compatibility we add static inline wrapper function
    gpiochip_add() that will call gpiochip_add_data() with
    NULL as argument. The latter will be removed once we have
    exorcised gpiochip_add() from the kernel.
    
    gpiochip_get_data() is added as a static inline accessor
    for drivers to quickly get their data out.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 990797589408..b833a5f9629a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -23,6 +23,7 @@ struct seq_file;
  * @parent: optional parent device providing the GPIOs
  * @cdev: class device used by sysfs interface (may be NULL)
  * @owner: helps prevent removal of modules exporting active GPIOs
+ * @data: per-instance data assigned by the driver
  * @list: links gpio_chips together for traversal
  * @request: optional hook for chip-specific activation, such as
  *	enabling module power and clock; may sleep
@@ -91,6 +92,7 @@ struct gpio_chip {
 	struct device		*parent;
 	struct device		*cdev;
 	struct module		*owner;
+	void			*data;
 	struct list_head        list;
 
 	int			(*request)(struct gpio_chip *chip,
@@ -165,7 +167,11 @@ extern const char *gpiochip_is_requested(struct gpio_chip *chip,
 			unsigned offset);
 
 /* add/remove chips */
-extern int gpiochip_add(struct gpio_chip *chip);
+extern int gpiochip_add_data(struct gpio_chip *chip, void *data);
+static inline int gpiochip_add(struct gpio_chip *chip)
+{
+	return gpiochip_add_data(chip, NULL);
+}
 extern void gpiochip_remove(struct gpio_chip *chip);
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
@@ -174,6 +180,12 @@ extern struct gpio_chip *gpiochip_find(void *data,
 int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
 void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 
+/* get driver data */
+static inline void *gpiochip_get_data(struct gpio_chip *chip)
+{
+	return chip->data;
+}
+
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP

commit 60befd2ea1c2061775838ea7bac5cc2b1353afd0
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Tue Dec 22 16:37:28 2015 +0200

    gpio: update gpiochip .get() callback description
    
    Since gpiochip .get() callback may return a negative error value, it
    strictly limits the range of possible non-error returned values to
    a subset of [30:0] bitmask, however on practice on success all
    gpiochip drivers return either 0 for low signal or 1 for high signal,
    this is assured by "gpio: *: Be sure to clamp return value" series of
    changes. To avoid any confusion, misinterpretation and potential
    errors while developing gpiochip drivers in future convert this
    implicit assumption to a mandatory rule.
    
    For output signals with unknown output signal state gpiochip drivers
    should return a negative error instead of 0.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index b02c43be7859..990797589408 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -32,8 +32,7 @@ struct seq_file;
  *	(same as GPIOF_DIR_XXX), or negative error
  * @direction_input: configures signal "offset" as input, or returns error
  * @direction_output: configures signal "offset" as output, or returns error
- * @get: returns value for signal "offset"; for output signals this
- *	returns either the value actually sensed, or zero
+ * @get: returns value for signal "offset", 0=low, 1=high, or negative error
  * @set: assigns output value for signal "offset"
  * @set_multiple: assigns output values for multiple signals defined by "mask"
  * @set_debounce: optional hook for setting debounce time for specified gpio in

commit 58383c78425e4ee1c077253cf297b641c861c02e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 4 09:56:26 2015 +0100

    gpio: change member .dev to .parent
    
    The name .dev in a struct is normally reserved for a struct device
    that is let us say a superclass to the thing described by the struct.
    struct gpio_chip stands out by confusingly using a struct device *dev
    to point to the parent device (such as a platform_device) that
    represents the hardware. As we want to give gpio_chip:s real devices,
    this is not working. We need to rename this member to parent.
    
    This was done by two coccinelle scripts, I guess it is possible to
    combine them into one, but I don't know such stuff. They look like
    this:
    
    @@
    struct gpio_chip *var;
    @@
    -var->dev
    +var->parent
    
    and:
    
    @@
    struct gpio_chip var;
    @@
    -var.dev
    +var.parent
    
    and:
    
    @@
    struct bgpio_chip *var;
    @@
    -var->gc.dev
    +var->gc.parent
    
    Plus a few instances of bgpio that I couldn't figure out how
    to teach Coccinelle to rewrite.
    
    This patch hits all over the place, but I *strongly* prefer this
    solution to any piecemal approaches that just exercise patch
    mechanics all over the place. It mainly hits drivers/gpio and
    drivers/pinctrl which is my own backyard anyway.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Alek Du <alek.du@intel.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index d1baebf350d8..b02c43be7859 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -20,7 +20,7 @@ struct seq_file;
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: for diagnostics
- * @dev: optional device providing the GPIOs
+ * @parent: optional parent device providing the GPIOs
  * @cdev: class device used by sysfs interface (may be NULL)
  * @owner: helps prevent removal of modules exporting active GPIOs
  * @list: links gpio_chips together for traversal
@@ -89,7 +89,7 @@ struct seq_file;
  */
 struct gpio_chip {
 	const char		*label;
-	struct device		*dev;
+	struct device		*parent;
 	struct device		*cdev;
 	struct module		*owner;
 	struct list_head        list;

commit c771c2f484857f3b1fc81d180485e96b7cb67c17
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Sun Oct 11 17:34:15 2015 +0200

    gpiolib: provide generic request/free implementations
    
    Provide generic request/free implementations that pinctrl aware gpio
    drivers can use instead of open coding if they use a 1:1 pin to gpio
    signal mapping.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1aed31c5ffba..d1baebf350d8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -206,6 +206,9 @@ int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 
+int gpiochip_generic_request(struct gpio_chip *chip, unsigned offset);
+void gpiochip_generic_free(struct gpio_chip *chip, unsigned offset);
+
 #ifdef CONFIG_PINCTRL
 
 /**

commit 41d6bb4c890c8db01248b1bdd512a18e7bd29ca3
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Aug 17 15:35:24 2015 +0300

    gpiolib: add description for gpio irqchip fields in struct gpio_chip
    
    Add missed description for GPIO irqchip fields in struct gpio_chip.
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 0c7004dab437..1aed31c5ffba 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -65,6 +65,17 @@ struct seq_file;
  *	registers.
  * @irq_not_threaded: flag must be set if @can_sleep is set but the
  *	IRQs don't need to be threaded
+ * @irqchip: GPIO IRQ chip impl, provided by GPIO driver
+ * @irqdomain: Interrupt translation domain; responsible for mapping
+ *	between GPIO hwirq number and linux irq number
+ * @irq_base: first linux IRQ number assigned to GPIO IRQ chip (deprecated)
+ * @irq_handler: the irq handler to use (often a predefined irq core function)
+ *	for GPIO IRQs, provided by GPIO driver
+ * @irq_default_type: default IRQ triggering type applied during GPIO driver
+ *	initialization, provided by GPIO driver
+ * @irq_parent: GPIO IRQ chip parent/bank linux irq number,
+ *	provided by GPIO driver
+ * @lock_key: per GPIO IRQ chip lockdep class
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
  * they can all be accessed through a common programing interface.

commit a0a8bcf4670c2c696e6e83742539a5e0dd7a62d6
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Aug 17 15:35:23 2015 +0300

    gpiolib: irqchip: use different lockdep class for each gpio irqchip
    
    Since IRQ chip helpers were introduced drivers lose ability to
    register separate lockdep classes for each registered GPIO IRQ
    chip and the gpiolib now is using shared lockdep class for
    all GPIO IRQ chips (gpiochip_irq_lock_class).
    As result, lockdep will produce warning when there are min two
    stacked GPIO chips and all of them are interrupt controllers.
    
    HW configuration which generates lockdep warning (TI dra7-evm):
    
    [SOC GPIO bankA.gpioX]
      <- irq - [pcf875x.gpioY]
                <- irq - DevZ.enable_irq_wake(pcf_gpioY_irq);
    The issue was reported in [1] and discussed [2].
    
    =============================================
    [ INFO: possible recursive locking detected ]
    4.2.0-rc6-00013-g5d050ed-dirty #55 Not tainted
    ---------------------------------------------
    sh/63 is trying to acquire lock:
     (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    but task is already holding lock:
     (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(class);
      lock(class);
    
     *** DEADLOCK ***
    
     May be due to missing lock nesting notation
    
    7 locks held by sh/63:
     #0:  (sb_writers#4){.+.+.+}, at: [<c016bbb8>] vfs_write+0x13c/0x164
     #1:  (&of->mutex){+.+.+.}, at: [<c01debf4>] kernfs_fop_write+0x4c/0x1a0
     #2:  (s_active#36){.+.+.+}, at: [<c01debfc>] kernfs_fop_write+0x54/0x1a0
     #3:  (pm_mutex){+.+.+.}, at: [<c009758c>] pm_suspend+0xec/0x4c4
     #4:  (&dev->mutex){......}, at: [<c03f77f8>] __device_suspend+0xd4/0x398
     #5:  (&gpio->lock){+.+.+.}, at: [<c009b940>] __irq_get_desc_lock+0x74/0x94
     #6:  (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94
    
    stack backtrace:
    CPU: 0 PID: 63 Comm: sh Not tainted 4.2.0-rc6-00013-g5d050ed-dirty #55
    Hardware name: Generic DRA74X (Flattened Device Tree)
    [<c0016e24>] (unwind_backtrace) from [<c0013338>] (show_stack+0x10/0x14)
    [<c0013338>] (show_stack) from [<c05f6b24>] (dump_stack+0x84/0x9c)
    [<c05f6b24>] (dump_stack) from [<c00903f4>] (__lock_acquire+0x19c0/0x1e20)
    [<c00903f4>] (__lock_acquire) from [<c0091098>] (lock_acquire+0xa8/0x128)
    [<c0091098>] (lock_acquire) from [<c05fd61c>] (_raw_spin_lock_irqsave+0x38/0x4c)
    [<c05fd61c>] (_raw_spin_lock_irqsave) from [<c009b91c>] (__irq_get_desc_lock+0x50/0x94)
    [<c009b91c>] (__irq_get_desc_lock) from [<c009c4f4>] (irq_set_irq_wake+0x20/0xfc)
    [<c009c4f4>] (irq_set_irq_wake) from [<c0393ac4>] (pcf857x_irq_set_wake+0x24/0x54)
    [<c0393ac4>] (pcf857x_irq_set_wake) from [<c009c560>] (irq_set_irq_wake+0x8c/0xfc)
    [<c009c560>] (irq_set_irq_wake) from [<c04a02ac>] (gpio_keys_suspend+0x70/0xd4)
    [<c04a02ac>] (gpio_keys_suspend) from [<c03f6a00>] (dpm_run_callback+0x50/0x124)
    [<c03f6a00>] (dpm_run_callback) from [<c03f7830>] (__device_suspend+0x10c/0x398)
    [<c03f7830>] (__device_suspend) from [<c03f90f0>] (dpm_suspend+0x134/0x2f4)
    [<c03f90f0>] (dpm_suspend) from [<c0096e20>] (suspend_devices_and_enter+0xa8/0x728)
    [<c0096e20>] (suspend_devices_and_enter) from [<c00977cc>] (pm_suspend+0x32c/0x4c4)
    [<c00977cc>] (pm_suspend) from [<c0096060>] (state_store+0x64/0xb8)
    [<c0096060>] (state_store) from [<c01dec64>] (kernfs_fop_write+0xbc/0x1a0)
    [<c01dec64>] (kernfs_fop_write) from [<c016b280>] (__vfs_write+0x20/0xd8)
    [<c016b280>] (__vfs_write) from [<c016bb0c>] (vfs_write+0x90/0x164)
    [<c016bb0c>] (vfs_write) from [<c016c330>] (SyS_write+0x44/0x9c)
    [<c016c330>] (SyS_write) from [<c000f500>] (ret_fast_syscall+0x0/0x54)
    
    Lets fix it by using separate lockdep class for each registered GPIO
    IRQ Chip. This is done by wrapping gpiochip_irqchip_add call into macros.
    
    The implementation of this patch inspired by solution done by Nicolas
    Boichat for regmap [3]
    
    [1] http://www.spinics.net/lists/linux-gpio/msg05844.html
    [2] http://www.spinics.net/lists/linux-gpio/msg06021.html
    [3] http://www.spinics.net/lists/arm-kernel/msg429834.html
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roger Quadros <rogerq@ti.com>
    Reported-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c8393cd4d44f..0c7004dab437 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -6,6 +6,7 @@
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/lockdep.h>
 #include <linux/pinctrl/pinctrl.h>
 
 struct device;
@@ -126,6 +127,7 @@ struct gpio_chip {
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 	int			irq_parent;
+	struct lock_class_key	*lock_key;
 #endif
 
 #if defined(CONFIG_OF_GPIO)
@@ -171,11 +173,25 @@ void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
 		int parent_irq,
 		irq_flow_handler_t parent_handler);
 
-int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
-		struct irq_chip *irqchip,
-		unsigned int first_irq,
-		irq_flow_handler_t handler,
-		unsigned int type);
+int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+			  struct irq_chip *irqchip,
+			  unsigned int first_irq,
+			  irq_flow_handler_t handler,
+			  unsigned int type,
+			  struct lock_class_key *lock_key);
+
+#ifdef CONFIG_LOCKDEP
+#define gpiochip_irqchip_add(...)				\
+(								\
+	({							\
+		static struct lock_class_key _key;		\
+		_gpiochip_irqchip_add(__VA_ARGS__, &_key);	\
+	})							\
+)
+#else
+#define gpiochip_irqchip_add(...)				\
+	_gpiochip_irqchip_add(__VA_ARGS__, NULL)
+#endif
 
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 

commit 30bb6fb39e5c08b9db5bc592d6cbc9a5fc5e67a4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jun 15 13:31:33 2015 +0200

    gpio: Remove double "base" in comment
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index cc7ec129b329..c8393cd4d44f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -45,7 +45,7 @@ struct seq_file;
  * @base: identifies the first GPIO number handled by this chip;
  *	or, if negative during registration, requests dynamic ID allocation.
  *	DEPRECATION: providing anything non-negative and nailing the base
- *	base offset of GPIO chips is deprecated. Please pass -1 as base to
+ *	offset of GPIO chips is deprecated. Please pass -1 as base to
  *	let gpiolib select the chip base in all possible cases. We want to
  *	get rid of the static GPIO number space in the long run.
  * @ngpio: the number of GPIOs handled by this controller; the last GPIO

commit af6c235d1a5c112964c3029eb0ed4b52c7aa33bf
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed May 13 13:03:21 2015 +0200

    gpio: discourage passing base to gpio_chip
    
    Passing a fixed base in struct gpio_chip is done for legacy
    systems that cannot handle dynamic allocation. Discourage this
    behaviour in the kerneldoc.
    
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 96a678842cde..cc7ec129b329 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -42,8 +42,12 @@ struct seq_file;
  * @dbg_show: optional routine to show contents in debugfs; default code
  *	will be used when this is omitted, but custom code can show extra
  *	state (such as pullup/pulldown configuration).
- * @base: identifies the first GPIO number handled by this chip; or, if
- *	negative during registration, requests dynamic ID allocation.
+ * @base: identifies the first GPIO number handled by this chip;
+ *	or, if negative during registration, requests dynamic ID allocation.
+ *	DEPRECATION: providing anything non-negative and nailing the base
+ *	base offset of GPIO chips is deprecated. Please pass -1 as base to
+ *	let gpiolib select the chip base in all possible cases. We want to
+ *	get rid of the static GPIO number space in the long run.
  * @ngpio: the number of GPIOs handled by this controller; the last GPIO
  *	handled is (base + ngpio - 1).
  * @desc: array of ngpio descriptors. Private.

commit 25e4fe92a20bbffde87500615250f1d54bfb832f
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Tue May 12 20:12:23 2015 +0300

    gpiolib: cleanup chained handler and data
    
    Clean up chained handler and handler data if they were set by
    gpiochip_set_chained_irqchip().
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 2c1e639f66bd..96a678842cde 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -121,6 +121,7 @@ struct gpio_chip {
 	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
+	int			irq_parent;
 #endif
 
 #if defined(CONFIG_OF_GPIO)

commit 6a4b6b0a3b55f23f4cc9ad85a1539c581bcb0874
Author: Johan Hovold <johan@kernel.org>
Date:   Mon May 4 17:10:31 2015 +0200

    gpio: sysfs: clean up chip class-device handling
    
    Clean gpio-chip class device registration and deregistration.
    
    The class device is registered when a gpio-chip is added (or from
    gpiolib_sysfs_init post-core init call), and deregistered when the chip
    is removed.
    
    Store the class device in struct gpio_chip directly rather than do a
    class-device lookup on deregistration. This also removes the need for
    the exported flag.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index f1b36593ec9f..2c1e639f66bd 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -20,6 +20,7 @@ struct seq_file;
  * struct gpio_chip - abstract a GPIO controller
  * @label: for diagnostics
  * @dev: optional device providing the GPIOs
+ * @cdev: class device used by sysfs interface (may be NULL)
  * @owner: helps prevent removal of modules exporting active GPIOs
  * @list: links gpio_chips together for traversal
  * @request: optional hook for chip-specific activation, such as
@@ -57,7 +58,6 @@ struct seq_file;
  *	implies that if the chip supports IRQs, these IRQs need to be threaded
  *	as the chip access may sleep when e.g. reading out the IRQ status
  *	registers.
- * @exported: flags if the gpiochip is exported for use from sysfs. Private.
  * @irq_not_threaded: flag must be set if @can_sleep is set but the
  *	IRQs don't need to be threaded
  *
@@ -74,6 +74,7 @@ struct seq_file;
 struct gpio_chip {
 	const char		*label;
 	struct device		*dev;
+	struct device		*cdev;
 	struct module		*owner;
 	struct list_head        list;
 
@@ -109,7 +110,6 @@ struct gpio_chip {
 	const char		*const *names;
 	bool			can_sleep;
 	bool			irq_not_threaded;
-	bool			exported;
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	/*

commit 964cb341882f920a1a1043864178f22def3193e4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Mar 18 01:56:17 2015 +0100

    gpio: move pincontrol calls to <linux/gpio/driver.h>
    
    These functions do not belong in <asm-generic/gpio.h> since the
    split into separate GPIO headers under <linux/gpio/*>. Move them
    to <linux/gpio/driver.h> as is apropriate.
    
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c497c62889d1..f1b36593ec9f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -6,6 +6,7 @@
 #include <linux/irq.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
+#include <linux/pinctrl/pinctrl.h>
 
 struct device;
 struct gpio_desc;
@@ -173,6 +174,53 @@ int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 
+#ifdef CONFIG_PINCTRL
+
+/**
+ * struct gpio_pin_range - pin range controlled by a gpio chip
+ * @head: list for maintaining set of pin ranges, used internally
+ * @pctldev: pinctrl device which handles corresponding pins
+ * @range: actual range of pins controlled by a gpio controller
+ */
+
+struct gpio_pin_range {
+	struct list_head node;
+	struct pinctrl_dev *pctldev;
+	struct pinctrl_gpio_range range;
+};
+
+int gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
+			   unsigned int gpio_offset, unsigned int pin_offset,
+			   unsigned int npins);
+int gpiochip_add_pingroup_range(struct gpio_chip *chip,
+			struct pinctrl_dev *pctldev,
+			unsigned int gpio_offset, const char *pin_group);
+void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
+
+#else
+
+static inline int
+gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
+		       unsigned int gpio_offset, unsigned int pin_offset,
+		       unsigned int npins)
+{
+	return 0;
+}
+static inline int
+gpiochip_add_pingroup_range(struct gpio_chip *chip,
+			struct pinctrl_dev *pctldev,
+			unsigned int gpio_offset, const char *pin_group)
+{
+	return 0;
+}
+
+static inline void
+gpiochip_remove_pin_ranges(struct gpio_chip *chip)
+{
+}
+
+#endif /* CONFIG_PINCTRL */
+
 struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
 					    const char *label);
 void gpiochip_free_own_desc(struct gpio_desc *desc);

commit 5f42424354f5b0ca5413b4fb8528d150692c85b7
Author: Rojhalat Ibrahim <imr@rtschenk.de>
Date:   Tue Nov 4 17:12:06 2014 +0100

    gpiolib: allow simultaneous setting of multiple GPIO outputs
    
    Introduce new functions gpiod_set_array & gpiod_set_raw_array to the consumer
    interface which allow setting multiple outputs with just one function call.
    Also add an optional set_multiple function to the driver interface. Without an
    implementation of that function in the chip driver outputs are set
    sequentially.
    
    Implementing the set_multiple function in a chip driver allows for:
    - Improved performance for certain use cases. The original motivation for this
      was the task of configuring an FPGA. In that specific case, where 9 GPIO
      lines have to be set many times, configuration time goes down from 48 s to
      20 s when using the new function.
    - Simultaneous glitch-free setting of multiple pins on any kind of parallel
      bus attached to GPIOs provided they all reside on the same chip and bank.
    
    Limitations:
      Performance is only improved for normal high-low outputs. Open drain and
      open source outputs are always set separately from each other. Those kinds
      of outputs could probably be accelerated in a similar way if we could
      forgo the error checking when setting GPIO directions.
    
    Change log:
      v6: - rebase on current linux-gpio devel branch
      v5: - check can_sleep property per chip
          - remove superfluous checks
          - supplement documentation
      v4: - add gpiod_set_array function for setting logical values
          - change interface of the set_multiple driver function to use
            unsigned long as type for the bit fields
          - use generic bitops (which also use unsigned long for bit fields)
          - do not use ARCH_NR_GPIOS any more
      v3: - add documentation
          - change commit message
      v2: - use descriptor interface
          - allow arbitrary groups of GPIOs spanning multiple chips
    
    Signed-off-by: Rojhalat Ibrahim <imr@rtschenk.de>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ff200a75501e..c497c62889d1 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -32,6 +32,7 @@ struct seq_file;
  * @get: returns value for signal "offset"; for output signals this
  *	returns either the value actually sensed, or zero
  * @set: assigns output value for signal "offset"
+ * @set_multiple: assigns output values for multiple signals defined by "mask"
  * @set_debounce: optional hook for setting debounce time for specified gpio in
  *      interrupt triggered gpio chips
  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
@@ -89,6 +90,9 @@ struct gpio_chip {
 						unsigned offset);
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
+	void			(*set_multiple)(struct gpio_chip *chip,
+						unsigned long *mask,
+						unsigned long *bits);
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset,
 						unsigned debounce);

commit e3a2e87893125bcd99bd7e1ddf9bfc421e492572
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Oct 23 17:27:07 2014 +0900

    gpio: rename gpio_lock_as_irq to gpiochip_lock_as_irq
    
    This function actually operates on a gpio_chip, so its prefix should
    reflect that fact for consistency with other functions defined in
    gpio/driver.h.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 249db3057e4d..ff200a75501e 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -149,8 +149,8 @@ extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 
 /* lock/unlock as IRQ */
-int gpio_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
-void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
+int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
+void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 

commit ea584595fc85e65796335033dfca25ed655cd0ed
Merge: 782d59c5dfc5 a092e19b688b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 14:58:15 2014 -0400

    Merge tag 'gpio-v3.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO changes from Linus Walleij:
     "This is the bulk of GPIO changes for the v3.18 development cycle:
    
       - Increase the default ARCH_NR_GPIO from 256 to 512.  This was done
         to avoid having a custom <asm/gpio.h> header for the x86
         architecture - GPIO is custom and complicated enough as it is
         already! We want to move to a radix to store the descriptors going
         forward, and finally get rid of this fixed array size altogether.
    
       - Endgame patching of the gpio_remove() semantics initiated by
         Abdoulaye Berthe.  It is not accepted by the system that the
         removal of a GPIO chip fails during eg reboot or shutdown, and
         therefore the return value has now painfully been refactored away.
         For special cases like GPIO expanders on a hot-pluggable bus like
         USB, we may later add some gpiochip_try_remove() call, but for the
         cases we have now, return values are moot.
    
       - Some incremental refactoring of the gpiolib core and ACPI GPIO
         library for more descriptor usage.
    
       - Refactor the chained IRQ handler set-up method to handle also
         threaded, nested interrupts and set up the parent IRQ correctly.
         Switch STMPE and TC3589x drivers to use this registration method.
    
       - Add a .irq_not_threaded flag to the struct gpio_chip, so that also
         GPIO expanders that block but are still not using threaded IRQ
         handlers.
    
       - New drivers for the ARM64 X-Gene SoC GPIO controller.
    
       - The syscon GPIO driver has been improved to handle the "DSP GPIO"
         found on the TI Keystone 2 SoC:s.
    
       - ADNP driver switched to use gpiolib irqchip helpers.
    
       - Refactor the DWAPB driver to support being instantiated from and
         MFD cell (platform device).
    
       - Incremental feature improvement in the Zynq, MCP23S08, DWAPB, OMAP,
         Xilinx and Crystalcove drivers.
    
       - Various minor fixes"
    
    * tag 'gpio-v3.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (52 commits)
      gpio: pch: Build context save/restore only for PM
      pinctrl: abx500: get rid of unused variable
      gpio: ks8695: fix 'else should follow close brace '}''
      gpio: stmpe: add verbose debug code
      gpio: stmpe: fix up interrupt enable logic
      gpio: staticize xway_stp_init()
      gpio: handle also nested irqchips in the chained handler set-up
      gpio: set parent irq on chained handlers
      gpiolib: irqchip: use irq_find_mapping while removing irqchip
      gpio: crystalcove: support virtual GPIO
      pinctrl: bcm281xx: make Kconfig dependency more strict
      gpio: kona: enable only on BCM_MOBILE or for compile testing
      gpio, bcm-kona, LLVMLinux: Remove use of __initconst
      gpio: Fix ngpio in gpio-xilinx driver
      gpio: dwapb: fix pointer to integer cast
      gpio: xgene: Remove unneeded #ifdef CONFIG_OF guard
      gpio: xgene: Remove unneeded forward declation for struct xgene_gpio
      gpio: xgene: Fix missing spin_lock_init()
      gpio: ks8695: fix switch case indentation
      gpiolib: add irq_not_threaded flag to gpio_chip
      ...

commit 28596c9722289b2f98fa83a2e4351eb0a031b953
Merge: b6420ebd4a54 7bb38d57fd75
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 7 21:16:26 2014 -0400

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull "trivial tree" updates from Jiri Kosina:
     "Usual pile from trivial tree everyone is so eagerly waiting for"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      Remove MN10300_PROC_MN2WS0038
      mei: fix comments
      treewide: Fix typos in Kconfig
      kprobes: update jprobe_example.c for do_fork() change
      Documentation: change "&" to "and" in Documentation/applying-patches.txt
      Documentation: remove obsolete pcmcia-cs from Changes
      Documentation: update links in Changes
      Documentation: Docbook: Fix generated DocBook/kernel-api.xml
      score: Remove GENERIC_HAS_IOMAP
      gpio: fix 'CONFIG_GPIO_IRQCHIP' comments
      tty: doc: Fix grammar in serial/tty
      dma-debug: modify check_for_stack output
      treewide: fix errors in printk
      genirq: fix reference in devm_request_threaded_irq comment
      treewide: fix synchronize_rcu() in comments
      checkstack.pl: port to AArch64
      doc: queue-sysfs: minor fixes
      init/do_mounts: better syntax description
      MIPS: fix comment spelling
      powerpc/simpleboot: fix comment
      ...

commit 295494af0695bc190e6b939df1036af898c2856f
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Sep 19 23:22:44 2014 +0300

    gpiolib: add irq_not_threaded flag to gpio_chip
    
    Some GPIO chips (e.g. the DLN2 USB adapter) have blocking get/set
    operation but do not need a threaded irq handler.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 560bf7fa614f..719fab209158 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -56,6 +56,8 @@ struct seq_file;
  *	as the chip access may sleep when e.g. reading out the IRQ status
  *	registers.
  * @exported: flags if the gpiochip is exported for use from sysfs. Private.
+ * @irq_not_threaded: flag must be set if @can_sleep is set but the
+ *	IRQs don't need to be threaded
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
  * they can all be accessed through a common programing interface.
@@ -101,6 +103,7 @@ struct gpio_chip {
 	struct gpio_desc	*desc;
 	const char		*const *names;
 	bool			can_sleep;
+	bool			irq_not_threaded;
 	bool			exported;
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP

commit e1db1706c86ee455f25eeaeadeda827e1e02310f
Author: abdoulaye berthe <berthe.ab@gmail.com>
Date:   Sat Jul 5 18:28:50 2014 +0200

    gpio: gpiolib: set gpiochip_remove retval to void
    
    This avoids handling gpiochip remove error in device
    remove handler.
    
    Signed-off-by: Abdoulaye Berthe <berthe.ab@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a2de58fffd19..560bf7fa614f 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -141,7 +141,7 @@ extern const char *gpiochip_is_requested(struct gpio_chip *chip,
 
 /* add/remove chips */
 extern int gpiochip_add(struct gpio_chip *chip);
-extern int gpiochip_remove(struct gpio_chip *chip);
+extern void gpiochip_remove(struct gpio_chip *chip);
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 

commit 7d75a871888e3f5e1a7c99bf240d1cd67d8bdfa0
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Fri Sep 5 13:09:25 2014 +0200

    gpio: fix 'CONFIG_GPIO_IRQCHIP' comments
    
    These two typos were introduced in commit 1425052097b5 ("gpio: add IRQ
    chip helpers in gpiolib").
    
    The correct symbol name is CONFIG_GPIOLIB_IRQCHIP.
    
    [jkosina@suse.cz: add changelog]
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 573e4f3243d0..4fcd60913a42 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -105,7 +105,7 @@ struct gpio_chip {
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	/*
-	 * With CONFIG_GPIO_IRQCHIP we get an irqchip inside the gpiolib
+	 * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib
 	 * to handle IRQs for most practical cases.
 	 */
 	struct irq_chip		*irqchip;
@@ -221,7 +221,7 @@ int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 		irq_flow_handler_t handler,
 		unsigned int type);
 
-#endif /* CONFIG_GPIO_IRQCHIP */
+#endif /* CONFIG_GPIOLIB_IRQCHIP */
 
 #else /* CONFIG_GPIOLIB */
 

commit abdc08a3a263a20e49534a36291d657bf53dda5b
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Aug 19 10:06:09 2014 -0700

    gpio: change gpiochip_request_own_desc() prototype
    
    The current prototype of gpiochip_request_own_desc() requires to obtain
    a pointer to a descriptor. This is in contradiction to all other GPIO
    request schemes, and imposes an extra step of obtaining a descriptor to
    drivers. Most drivers actually cannot even perform that step since the
    function that does it (gpichip_get_desc()) is gpiolib-private.
    
    Change gpiochip_request_own_desc() to return a descriptor from a
    (chip, hwnum) tuple and update users of this function (currently
    gpiolib-acpi only).
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index e78a2373e374..a2de58fffd19 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -166,7 +166,8 @@ int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 
 #endif /* CONFIG_GPIO_IRQCHIP */
 
-int gpiochip_request_own_desc(struct gpio_desc *desc, const char *label);
+struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *chip, u16 hwnum,
+					    const char *label);
 void gpiochip_free_own_desc(struct gpio_desc *desc);
 
 #else /* CONFIG_GPIOLIB */

commit 0a6d315827eedc733d404ecff3cd4cc0e6437865
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jul 24 20:08:55 2014 +0200

    gpio: split gpiod board registration into machine header
    
    As per example from the regulator subsystem: put all defines and
    functions related to registering board info for GPIO descriptors
    into a separate <linux/gpio/machine.h> header.
    
    Cc: Andrew Victor <linux@maxim.org.za>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Reviewed-by: Alexandre Courbot <gnurou@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 4c463fb0155e..e78a2373e374 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -151,60 +151,6 @@ void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 
-enum gpio_lookup_flags {
-	GPIO_ACTIVE_HIGH = (0 << 0),
-	GPIO_ACTIVE_LOW = (1 << 0),
-	GPIO_OPEN_DRAIN = (1 << 1),
-	GPIO_OPEN_SOURCE = (1 << 2),
-};
-
-/**
- * struct gpiod_lookup - lookup table
- * @chip_label: name of the chip the GPIO belongs to
- * @chip_hwnum: hardware number (i.e. relative to the chip) of the GPIO
- * @con_id: name of the GPIO from the device's point of view
- * @idx: index of the GPIO in case several GPIOs share the same name
- * @flags: mask of GPIO_* values
- *
- * gpiod_lookup is a lookup table for associating GPIOs to specific devices and
- * functions using platform data.
- */
-struct gpiod_lookup {
-	const char *chip_label;
-	u16 chip_hwnum;
-	const char *con_id;
-	unsigned int idx;
-	enum gpio_lookup_flags flags;
-};
-
-struct gpiod_lookup_table {
-	struct list_head list;
-	const char *dev_id;
-	struct gpiod_lookup table[];
-};
-
-/*
- * Simple definition of a single GPIO under a con_id
- */
-#define GPIO_LOOKUP(_chip_label, _chip_hwnum, _con_id, _flags) \
-	GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, 0, _flags)
-
-/*
- * Use this macro if you need to have several GPIOs under the same con_id.
- * Each GPIO needs to use a different index and can be accessed using
- * gpiod_get_index()
- */
-#define GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, _idx, _flags)  \
-{                                                                         \
-	.chip_label = _chip_label,                                        \
-	.chip_hwnum = _chip_hwnum,                                        \
-	.con_id = _con_id,                                                \
-	.idx = _idx,                                                      \
-	.flags = _flags,                                                  \
-}
-
-void gpiod_add_lookup_table(struct gpiod_lookup_table *table);
-
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 
 void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,

commit f7d4ad98fdd08932ffda2354c62e2e2ee059adcc
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Jul 22 08:01:01 2014 -0700

    gpiolib: Export gpiochip_request_own_desc and gpiochip_free_own_desc
    
    Both functions were introduced to let gpio drivers request their own
    gpio pins. Without exporting the functions, this can however only be
    used by gpio drivers built into the kernel.
    
    Secondary impact is that the functions can not currently be used by
    platform initialization code associated with the gpio-pca953x driver.
    This code permits auto-export of gpio pins through platform data, but
    if this functionality is used, the module can no longer be unloaded due
    to the problem solved with the introduction of gpiochip_request_own_desc
    and gpiochip_free_own_desc.
    
    Export both function so they can be used from modules and from
    platform initialization code.
    
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c66c91682d9e..4c463fb0155e 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -220,6 +220,9 @@ int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
 
 #endif /* CONFIG_GPIO_IRQCHIP */
 
+int gpiochip_request_own_desc(struct gpio_desc *desc, const char *label);
+void gpiochip_free_own_desc(struct gpio_desc *desc);
+
 #else /* CONFIG_GPIOLIB */
 
 static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)

commit d74be6dfea1b96cfb4bd79d9254fa9d21ed5f131
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 22 16:17:42 2014 +0900

    gpio: remove gpiod_lock/unlock_as_irq()
    
    gpio_lock/unlock_as_irq() are working with (chip, offset) arguments and
    are thus not using the old integer namespace. Therefore, there is no
    reason to have gpiod variants of these functions working with
    descriptors, especially since the (chip, offset) tuple is more suitable
    to the users of these functions (GPIO drivers, whereas GPIO descriptors
    are targeted at GPIO consumers).
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 88f92dfae545..c66c91682d9e 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -146,8 +146,8 @@ extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 
 /* lock/unlock as IRQ */
-int gpiod_lock_as_irq(struct gpio_desc *desc);
-void gpiod_unlock_as_irq(struct gpio_desc *desc);
+int gpio_lock_as_irq(struct gpio_chip *chip, unsigned int offset);
+void gpio_unlock_as_irq(struct gpio_chip *chip, unsigned int offset);
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 

commit 1bd6b601fe196b6fbce2c93536ce0f3f53577cec
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jul 22 16:17:41 2014 +0900

    gpio: make gpiochip_get_desc() gpiolib-private
    
    As GPIO descriptors are not going to remain unique anymore, having this
    function public is not safe. Restrain its use to gpiolib since we have
    no user outside of it.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index ca3024554a2d..88f92dfae545 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -151,9 +151,6 @@ void gpiod_unlock_as_irq(struct gpio_desc *desc);
 
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
 
-struct gpio_desc *gpiochip_get_desc(struct gpio_chip *chip,
-				    u16 hwnum);
-
 enum gpio_lookup_flags {
 	GPIO_ACTIVE_HIGH = (0 << 0),
 	GPIO_ACTIVE_LOW = (1 << 0),

commit 14c8a620ba436511b1347c592633befa49535176
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jul 23 10:47:49 2014 +0200

    gpio: drop retval check enforcing from gpiochip_remove()
    
    As we start to decomission the return value from gpiochip_remove()
    the compilers emit warnings due to the function being tagged
    __must_check. So drop this until we remove the return value
    altogether.
    
    Cc: Abdoulaye Berthe <berthe.ab@gmail.com>
    Suggested-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 573e4f3243d0..ca3024554a2d 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -141,7 +141,7 @@ extern const char *gpiochip_is_requested(struct gpio_chip *chip,
 
 /* add/remove chips */
 extern int gpiochip_add(struct gpio_chip *chip);
-extern int __must_check gpiochip_remove(struct gpio_chip *chip);
+extern int gpiochip_remove(struct gpio_chip *chip);
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 

commit 1c8732bb0355b929b09173464cdca7df4d516f89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Apr 9 13:34:39 2014 +0200

    gpio: support threaded interrupts in irqchip helpers
    
    Some off-chip GPIO expanders need to be communicated by I2C or
    SPI traffic, but may still support IRQs. By the sleeping nature
    of such buses, such IRQ handlers need to be threaded. Support
    such handlers in the gpiochip irqchip helpers by flagging IRQs
    as threaded if the .can_sleep property of the gpiochip is
    true.
    
    Helpfully deny registration of chained IRQ handlers if the
    .can_sleep property is set, as such chips will invariably need
    a nested handler rather than a chained handler.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 1827b43966d9..573e4f3243d0 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -51,7 +51,10 @@ struct seq_file;
  *      format specifier for an unsigned int.  It is substituted by the actual
  *      number of the gpio.
  * @can_sleep: flag must be set iff get()/set() methods sleep, as they
- *	must while accessing GPIO expander chips over I2C or SPI
+ *	must while accessing GPIO expander chips over I2C or SPI. This
+ *	implies that if the chip supports IRQs, these IRQs need to be threaded
+ *	as the chip access may sleep when e.g. reading out the IRQ status
+ *	registers.
  * @exported: flags if the gpiochip is exported for use from sysfs. Private.
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so

commit c3626fdea044cc97bfc035ebb048f7619acb6736
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Mar 28 20:42:01 2014 +0100

    gpio: unmap gpio irqs properly
    
    When using the irqchip helper inside the gpiolib, make sure
    the IRQs are unmapped/disposed before the irqdomain is removed
    as part of removing the gpiochip.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c1c5c2368fc8..1827b43966d9 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -107,6 +107,7 @@ struct gpio_chip {
 	 */
 	struct irq_chip		*irqchip;
 	struct irq_domain	*irqdomain;
+	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
 #endif

commit 1425052097b53de841e064dc190a9009480c208c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 25 10:40:18 2014 +0100

    gpio: add IRQ chip helpers in gpiolib
    
    This provides a function gpiochip_irqchip_add() to set
    up an irqchip for a GPIO controller, and a function
    gpiochip_set_chained_irqchip() to chain it to a parent
    irqchip.
    
    Most GPIOs are of the type where a number of lines form
    a cascaded interrupt controller chained onto
    the primary system interrupt controller (or further down the
    chain) so let's add this helper and factor the code to
    request the lines to be used as IRQs, the .to_irq() function
    and the irqdomain into the core as well.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 9fe283642253..c1c5c2368fc8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -3,6 +3,9 @@
 
 #include <linux/types.h>
 #include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
 
 struct device;
 struct gpio_desc;
@@ -97,6 +100,17 @@ struct gpio_chip {
 	bool			can_sleep;
 	bool			exported;
 
+#ifdef CONFIG_GPIOLIB_IRQCHIP
+	/*
+	 * With CONFIG_GPIO_IRQCHIP we get an irqchip inside the gpiolib
+	 * to handle IRQs for most practical cases.
+	 */
+	struct irq_chip		*irqchip;
+	struct irq_domain	*irqdomain;
+	irq_flow_handler_t	irq_handler;
+	unsigned int		irq_default_type;
+#endif
+
 #if defined(CONFIG_OF_GPIO)
 	/*
 	 * If CONFIG_OF is enabled, then all GPIO controllers described in the
@@ -190,6 +204,21 @@ struct gpiod_lookup_table {
 
 void gpiod_add_lookup_table(struct gpiod_lookup_table *table);
 
+#ifdef CONFIG_GPIOLIB_IRQCHIP
+
+void gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip,
+		struct irq_chip *irqchip,
+		int parent_irq,
+		irq_flow_handler_t parent_handler);
+
+int gpiochip_irqchip_add(struct gpio_chip *gpiochip,
+		struct irq_chip *irqchip,
+		unsigned int first_irq,
+		irq_flow_handler_t handler,
+		unsigned int type);
+
+#endif /* CONFIG_GPIO_IRQCHIP */
+
 #else /* CONFIG_GPIOLIB */
 
 static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)

commit bb1e88ccb771492ac908ac295ec135efa1d53093
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Sun Feb 9 17:43:54 2014 +0900

    gpiolib: add gpiochip_get_desc() driver function
    
    Some drivers dealing with a gpio_chip might need to act on its
    descriptors directly; one example is pinctrl drivers that need to lock a
    GPIO for being used as IRQ using gpiod_lock_as_irq().
    
    This patch exports a gpiochip_get_desc() function that returns the
    GPIO descriptor at the requested index. It also sweeps the
    gpio_to_chip() function out of the consumer interface since any holder
    of a gpio_chip reference can manipulate its GPIOs way beyond what a
    consumer should be allowed to do.
    
    As a result, gpio_chip is not visible anymore to simple GPIO consumers.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Jean-Jacques Hiblot <jjhiblot@traphandler.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a3e181e09636..9fe283642253 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -10,6 +10,8 @@ struct of_phandle_args;
 struct device_node;
 struct seq_file;
 
+#ifdef CONFIG_GPIOLIB
+
 /**
  * struct gpio_chip - abstract a GPIO controller
  * @label: for diagnostics
@@ -129,6 +131,11 @@ extern struct gpio_chip *gpiochip_find(void *data,
 int gpiod_lock_as_irq(struct gpio_desc *desc);
 void gpiod_unlock_as_irq(struct gpio_desc *desc);
 
+struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc);
+
+struct gpio_desc *gpiochip_get_desc(struct gpio_chip *chip,
+				    u16 hwnum);
+
 enum gpio_lookup_flags {
 	GPIO_ACTIVE_HIGH = (0 << 0),
 	GPIO_ACTIVE_LOW = (1 << 0),
@@ -183,4 +190,15 @@ struct gpiod_lookup_table {
 
 void gpiod_add_lookup_table(struct gpiod_lookup_table *table);
 
+#else /* CONFIG_GPIOLIB */
+
+static inline struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
+{
+	/* GPIO can never have been requested */
+	WARN_ON(1);
+	return ERR_PTR(-ENODEV);
+}
+
+#endif /* CONFIG_GPIOLIB */
+
 #endif

commit f9244ae5dce18b73ac42f5979116050da3a5c4d5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Dec 5 11:26:25 2013 +0200

    gpiolib: convert gpiod_lookup description to kernel-doc
    
    The patch moves description of the fields to the top of struct definition and
    converts them to the kernel-doc format.
    
    There is no functional change.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 44c66b29a2d9..a3e181e09636 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -137,29 +137,21 @@ enum gpio_lookup_flags {
 };
 
 /**
- * Lookup table for associating GPIOs to specific devices and functions using
- * platform data.
+ * struct gpiod_lookup - lookup table
+ * @chip_label: name of the chip the GPIO belongs to
+ * @chip_hwnum: hardware number (i.e. relative to the chip) of the GPIO
+ * @con_id: name of the GPIO from the device's point of view
+ * @idx: index of the GPIO in case several GPIOs share the same name
+ * @flags: mask of GPIO_* values
+ *
+ * gpiod_lookup is a lookup table for associating GPIOs to specific devices and
+ * functions using platform data.
  */
 struct gpiod_lookup {
-	/*
-	 * name of the chip the GPIO belongs to
-	 */
 	const char *chip_label;
-	/*
-	 * hardware number (i.e. relative to the chip) of the GPIO
-	 */
 	u16 chip_hwnum;
-	/*
-	 * name of the GPIO from the device's point of view
-	 */
 	const char *con_id;
-	/*
-	 * index of the GPIO in case several GPIOs share the same name
-	 */
 	unsigned int idx;
-	/*
-	 * mask of GPIO_* values
-	 */
 	enum gpio_lookup_flags flags;
 };
 

commit ad824783fb23bbc8295cffb6214b3b82d25f7d4a
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 3 12:20:11 2013 +0900

    gpio: better lookup method for platform GPIOs
    
    Change the format of the platform GPIO lookup tables to make them less
    confusing and improve lookup efficiency.
    
    The previous format was a single linked-list that required to compare
    the device name and function ID of every single GPIO defined for each
    lookup. Switch that to a list of per-device tables, so that the lookup
    can be done in two steps, omitting the GPIOs that are not relevant for a
    particular device.
    
    The matching rules are now defined as follows:
    - The device name must match *exactly*, and can be NULL for GPIOs not
      assigned to a particular device,
    - If the function ID in the lookup table is NULL, the con_id argument of
      gpiod_get() will not be used for lookup. However, if it is defined, it
      must match exactly.
    - The index must always match.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index c849676c6787..44c66b29a2d9 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -141,7 +141,6 @@ enum gpio_lookup_flags {
  * platform data.
  */
 struct gpiod_lookup {
-	struct list_head list;
 	/*
 	 * name of the chip the GPIO belongs to
 	 */
@@ -150,10 +149,6 @@ struct gpiod_lookup {
 	 * hardware number (i.e. relative to the chip) of the GPIO
 	 */
 	u16 chip_hwnum;
-	/*
-	 * name of device that can claim this GPIO
-	 */
-	const char *dev_id;
 	/*
 	 * name of the GPIO from the device's point of view
 	 */
@@ -168,28 +163,32 @@ struct gpiod_lookup {
 	enum gpio_lookup_flags flags;
 };
 
+struct gpiod_lookup_table {
+	struct list_head list;
+	const char *dev_id;
+	struct gpiod_lookup table[];
+};
+
 /*
  * Simple definition of a single GPIO under a con_id
  */
-#define GPIO_LOOKUP(_chip_label, _chip_hwnum, _dev_id, _con_id, _flags) \
-	GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _dev_id, _con_id, 0, _flags)
+#define GPIO_LOOKUP(_chip_label, _chip_hwnum, _con_id, _flags) \
+	GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, 0, _flags)
 
 /*
  * Use this macro if you need to have several GPIOs under the same con_id.
  * Each GPIO needs to use a different index and can be accessed using
  * gpiod_get_index()
  */
-#define GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _dev_id, _con_id, _idx, \
-			_flags)                                           \
+#define GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _con_id, _idx, _flags)  \
 {                                                                         \
 	.chip_label = _chip_label,                                        \
 	.chip_hwnum = _chip_hwnum,                                        \
-	.dev_id = _dev_id,                                                \
 	.con_id = _con_id,                                                \
 	.idx = _idx,                                                      \
 	.flags = _flags,                                                  \
 }
 
-void gpiod_add_table(struct gpiod_lookup *table, size_t size);
+void gpiod_add_lookup_table(struct gpiod_lookup_table *table);
 
 #endif

commit bdc54ef45d7670aeb52ce73f8b7ad5f3e5563661
Merge: 33e0aae11e48 374b105797c3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 9 14:04:37 2013 +0100

    Merge tag 'v3.13-rc3' into devel
    
    Linux 3.13-rc3

commit 9fb1f39eb2d6707d265087ee186376e24995f55a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Dec 4 14:42:46 2013 +0100

    gpio/pinctrl: make gpio_chip members typed boolean
    
    This switches the two members of struct gpio_chip that were
    defined as unsigned foo:1 to bool, because that is indeed what
    they are. Switch all users in the gpio and pinctrl subsystems
    to assign these values with true/false instead of 0/1. The
    users outside these subsystems will survive since true/false
    is 1/0, atleast we set some kind of more strict typing example.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 656a27efb2c8..804ec45365b7 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -36,14 +36,15 @@ struct seq_file;
  * @ngpio: the number of GPIOs handled by this controller; the last GPIO
  *	handled is (base + ngpio - 1).
  * @desc: array of ngpio descriptors. Private.
- * @can_sleep: flag must be set iff get()/set() methods sleep, as they
- *	must while accessing GPIO expander chips over I2C or SPI
  * @names: if set, must be an array of strings to use as alternative
  *      names for the GPIOs in this chip. Any entry in the array
  *      may be NULL if there is no alias for the GPIO, however the
  *      array must be @ngpio entries long.  A name can include a single printk
  *      format specifier for an unsigned int.  It is substituted by the actual
  *      number of the gpio.
+ * @can_sleep: flag must be set iff get()/set() methods sleep, as they
+ *	must while accessing GPIO expander chips over I2C or SPI
+ * @exported: flags if the gpiochip is exported for use from sysfs. Private.
  *
  * A gpio_chip can help platforms abstract various sources of GPIOs so
  * they can all be accessed through a common programing interface.
@@ -88,8 +89,8 @@ struct gpio_chip {
 	u16			ngpio;
 	struct gpio_desc	*desc;
 	const char		*const *names;
-	unsigned		can_sleep:1;
-	unsigned		exported:1;
+	bool			can_sleep;
+	bool			exported;
 
 #if defined(CONFIG_OF_GPIO)
 	/*

commit c9a9972b6f093e4e2f81f58892a7523df894144d
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Mon Nov 25 18:34:24 2013 +0900

    gpiolib: add missing declarations
    
    Add declaration of 'struct of_phandle_args' to avoid the following
    warning:
    
      In file included from arch/arm/mach-tegra/board-paz00.c:21:0:
      include/linux/gpio/driver.h:102:17: warning: 'struct of_phandle_args' declared inside parameter list
      include/linux/gpio/driver.h:102:17: warning: its scope is only this definition or declaration, which is probably not what you want
    
    Also proactively add other definitions/includes that could be missing
    in other contexts.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Reported-by: Stephen Warren <swarren@wwwdotorg.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 82eac610ce1a..3ea2cf6b0e6c 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -2,9 +2,12 @@
 #define __LINUX_GPIO_DRIVER_H
 
 #include <linux/types.h>
+#include <linux/module.h>
 
 struct device;
 struct gpio_desc;
+struct of_phandle_args;
+struct device_node;
 struct seq_file;
 
 /**

commit 53e7cac35db5941f42221314c33693e71ffa496b
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Sat Nov 16 21:44:52 2013 +0900

    gpiolib: use dedicated flags for GPIO properties
    
    GPIO mapping properties were defined using the GPIOF_* flags, which are
    declared in linux/gpio.h. This file is not included when using the
    GPIO descriptor interface.
    
    This patch declares the flags that can be used as GPIO mappings
    properties in linux/gpio/driver.h, and uses them in gpiolib, so that no
    deprecated declarations are used by the GPIO descriptor interface.
    
    This patch also allows GPIO_OPEN_DRAIN and GPIO_OPEN_SOURCE to be
    specified as GPIO mapping properties.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 656a27efb2c8..82eac610ce1a 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -125,6 +125,13 @@ extern struct gpio_chip *gpiochip_find(void *data,
 int gpiod_lock_as_irq(struct gpio_desc *desc);
 void gpiod_unlock_as_irq(struct gpio_desc *desc);
 
+enum gpio_lookup_flags {
+	GPIO_ACTIVE_HIGH = (0 << 0),
+	GPIO_ACTIVE_LOW = (1 << 0),
+	GPIO_OPEN_DRAIN = (1 << 1),
+	GPIO_OPEN_SOURCE = (1 << 2),
+};
+
 /**
  * Lookup table for associating GPIOs to specific devices and functions using
  * platform data.
@@ -152,9 +159,9 @@ struct gpiod_lookup {
 	 */
 	unsigned int idx;
 	/*
-	 * mask of GPIOF_* values
+	 * mask of GPIO_* values
 	 */
-	unsigned long flags;
+	enum gpio_lookup_flags flags;
 };
 
 /*

commit f3ed0b66482fa2a0403280174a998487e9054867
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Oct 29 01:06:23 2013 +1100

    gpiolib: provide a declaration of seq_file in gpio/driver.h
    
    Fixes this build error:
    
    In file included from include/asm-generic/gpio.h:13:0,
                     from include/linux/gpio.h:51,
                     from include/linux/of_gpio.h:20,
                     from arch/powerpc/sysdev/ppc4xx_gpio.c:29:
    include/linux/gpio/driver.h:85:14: error: 'struct seq_file' declared inside=
     parameter list [-Werror]
    include/linux/gpio/driver.h:85:14: error: its scope is only this definition=
     or declaration, which is probably not what you want [-Werror]
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index cd9da3885d79..656a27efb2c8 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -5,6 +5,7 @@
 
 struct device;
 struct gpio_desc;
+struct seq_file;
 
 /**
  * struct gpio_chip - abstract a GPIO controller

commit bae48da237fcedd7ad09569025483b988635efb7
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Oct 17 10:21:38 2013 -0700

    gpiolib: add gpiod_get() and gpiod_put() functions
    
    Add gpiod_get(), gpiod_get_index() and gpiod_put() functions that
    provide safer management of GPIOs.
    
    These functions put the GPIO framework in line with the conventions of
    other frameworks in the kernel, and help ensure every GPIO is declared
    properly and valid while it is used.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 5dc172c72f0f..cd9da3885d79 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -124,4 +124,60 @@ extern struct gpio_chip *gpiochip_find(void *data,
 int gpiod_lock_as_irq(struct gpio_desc *desc);
 void gpiod_unlock_as_irq(struct gpio_desc *desc);
 
+/**
+ * Lookup table for associating GPIOs to specific devices and functions using
+ * platform data.
+ */
+struct gpiod_lookup {
+	struct list_head list;
+	/*
+	 * name of the chip the GPIO belongs to
+	 */
+	const char *chip_label;
+	/*
+	 * hardware number (i.e. relative to the chip) of the GPIO
+	 */
+	u16 chip_hwnum;
+	/*
+	 * name of device that can claim this GPIO
+	 */
+	const char *dev_id;
+	/*
+	 * name of the GPIO from the device's point of view
+	 */
+	const char *con_id;
+	/*
+	 * index of the GPIO in case several GPIOs share the same name
+	 */
+	unsigned int idx;
+	/*
+	 * mask of GPIOF_* values
+	 */
+	unsigned long flags;
+};
+
+/*
+ * Simple definition of a single GPIO under a con_id
+ */
+#define GPIO_LOOKUP(_chip_label, _chip_hwnum, _dev_id, _con_id, _flags) \
+	GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _dev_id, _con_id, 0, _flags)
+
+/*
+ * Use this macro if you need to have several GPIOs under the same con_id.
+ * Each GPIO needs to use a different index and can be accessed using
+ * gpiod_get_index()
+ */
+#define GPIO_LOOKUP_IDX(_chip_label, _chip_hwnum, _dev_id, _con_id, _idx, \
+			_flags)                                           \
+{                                                                         \
+	.chip_label = _chip_label,                                        \
+	.chip_hwnum = _chip_hwnum,                                        \
+	.dev_id = _dev_id,                                                \
+	.con_id = _con_id,                                                \
+	.idx = _idx,                                                      \
+	.flags = _flags,                                                  \
+}
+
+void gpiod_add_table(struct gpiod_lookup *table, size_t size);
+
 #endif

commit 79a9becda8940deb2274b5aa4577c86d52ee7ecb
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Oct 17 10:21:36 2013 -0700

    gpiolib: export descriptor-based GPIO interface
    
    This patch exports the gpiod_* family of API functions, a safer
    alternative to the legacy GPIO interface. Differences between the gpiod
    and legacy gpio APIs are:
    
    - gpio works with integers, whereas gpiod operates on opaque handlers
      which cannot be forged or used before proper acquisition
    - gpiod get/set functions are aware of the active low state of a GPIO
    - gpio consumers should now include <linux/gpio/consumer.h> to access
      the new interface, whereas chips drivers will use
      <linux/gpio/driver.h>
    
    The legacy gpio API is now built as inline functions on top of gpiod.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
new file mode 100644
index 000000000000..5dc172c72f0f
--- /dev/null
+++ b/include/linux/gpio/driver.h
@@ -0,0 +1,127 @@
+#ifndef __LINUX_GPIO_DRIVER_H
+#define __LINUX_GPIO_DRIVER_H
+
+#include <linux/types.h>
+
+struct device;
+struct gpio_desc;
+
+/**
+ * struct gpio_chip - abstract a GPIO controller
+ * @label: for diagnostics
+ * @dev: optional device providing the GPIOs
+ * @owner: helps prevent removal of modules exporting active GPIOs
+ * @list: links gpio_chips together for traversal
+ * @request: optional hook for chip-specific activation, such as
+ *	enabling module power and clock; may sleep
+ * @free: optional hook for chip-specific deactivation, such as
+ *	disabling module power and clock; may sleep
+ * @get_direction: returns direction for signal "offset", 0=out, 1=in,
+ *	(same as GPIOF_DIR_XXX), or negative error
+ * @direction_input: configures signal "offset" as input, or returns error
+ * @direction_output: configures signal "offset" as output, or returns error
+ * @get: returns value for signal "offset"; for output signals this
+ *	returns either the value actually sensed, or zero
+ * @set: assigns output value for signal "offset"
+ * @set_debounce: optional hook for setting debounce time for specified gpio in
+ *      interrupt triggered gpio chips
+ * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
+ *	implementation may not sleep
+ * @dbg_show: optional routine to show contents in debugfs; default code
+ *	will be used when this is omitted, but custom code can show extra
+ *	state (such as pullup/pulldown configuration).
+ * @base: identifies the first GPIO number handled by this chip; or, if
+ *	negative during registration, requests dynamic ID allocation.
+ * @ngpio: the number of GPIOs handled by this controller; the last GPIO
+ *	handled is (base + ngpio - 1).
+ * @desc: array of ngpio descriptors. Private.
+ * @can_sleep: flag must be set iff get()/set() methods sleep, as they
+ *	must while accessing GPIO expander chips over I2C or SPI
+ * @names: if set, must be an array of strings to use as alternative
+ *      names for the GPIOs in this chip. Any entry in the array
+ *      may be NULL if there is no alias for the GPIO, however the
+ *      array must be @ngpio entries long.  A name can include a single printk
+ *      format specifier for an unsigned int.  It is substituted by the actual
+ *      number of the gpio.
+ *
+ * A gpio_chip can help platforms abstract various sources of GPIOs so
+ * they can all be accessed through a common programing interface.
+ * Example sources would be SOC controllers, FPGAs, multifunction
+ * chips, dedicated GPIO expanders, and so on.
+ *
+ * Each chip controls a number of signals, identified in method calls
+ * by "offset" values in the range 0..(@ngpio - 1).  When those signals
+ * are referenced through calls like gpio_get_value(gpio), the offset
+ * is calculated by subtracting @base from the gpio number.
+ */
+struct gpio_chip {
+	const char		*label;
+	struct device		*dev;
+	struct module		*owner;
+	struct list_head        list;
+
+	int			(*request)(struct gpio_chip *chip,
+						unsigned offset);
+	void			(*free)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*get_direction)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*direction_input)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*direction_output)(struct gpio_chip *chip,
+						unsigned offset, int value);
+	int			(*get)(struct gpio_chip *chip,
+						unsigned offset);
+	void			(*set)(struct gpio_chip *chip,
+						unsigned offset, int value);
+	int			(*set_debounce)(struct gpio_chip *chip,
+						unsigned offset,
+						unsigned debounce);
+
+	int			(*to_irq)(struct gpio_chip *chip,
+						unsigned offset);
+
+	void			(*dbg_show)(struct seq_file *s,
+						struct gpio_chip *chip);
+	int			base;
+	u16			ngpio;
+	struct gpio_desc	*desc;
+	const char		*const *names;
+	unsigned		can_sleep:1;
+	unsigned		exported:1;
+
+#if defined(CONFIG_OF_GPIO)
+	/*
+	 * If CONFIG_OF is enabled, then all GPIO controllers described in the
+	 * device tree automatically may have an OF translation
+	 */
+	struct device_node *of_node;
+	int of_gpio_n_cells;
+	int (*of_xlate)(struct gpio_chip *gc,
+			const struct of_phandle_args *gpiospec, u32 *flags);
+#endif
+#ifdef CONFIG_PINCTRL
+	/*
+	 * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally
+	 * describe the actual pin range which they serve in an SoC. This
+	 * information would be used by pinctrl subsystem to configure
+	 * corresponding pins for gpio usage.
+	 */
+	struct list_head pin_ranges;
+#endif
+};
+
+extern const char *gpiochip_is_requested(struct gpio_chip *chip,
+			unsigned offset);
+
+/* add/remove chips */
+extern int gpiochip_add(struct gpio_chip *chip);
+extern int __must_check gpiochip_remove(struct gpio_chip *chip);
+extern struct gpio_chip *gpiochip_find(void *data,
+			      int (*match)(struct gpio_chip *chip, void *data));
+
+/* lock/unlock as IRQ */
+int gpiod_lock_as_irq(struct gpio_desc *desc);
+void gpiod_unlock_as_irq(struct gpio_desc *desc);
+
+#endif
