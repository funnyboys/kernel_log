commit 80ade29e1ed0d04fdb108b2344f27b89997fc408
Merge: 08dd3872770b b5963029d9e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 19 11:23:33 2020 -0700

    Merge tag 'irq-urgent-2020-04-19' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq fixes from Thomas Gleixner:
     "A set of fixes/updates for the interrupt subsystem:
    
       - Remove setup_irq() and remove_irq(). All users have been converted
         so remove them before new users surface.
    
       - A set of bugfixes for various interrupt chip drivers
    
       - Add a few missing static attributes to address sparse warnings"
    
    * tag 'irq-urgent-2020-04-19' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      irqchip/irq-bcm7038-l1: Make bcm7038_l1_of_init() static
      irqchip/irq-mvebu-icu: Make legacy_bindings static
      irqchip/meson-gpio: Fix HARDIRQ-safe -> HARDIRQ-unsafe lock order
      irqchip/sifive-plic: Fix maximum priority threshold value
      irqchip/ti-sci-inta: Fix processing of masked irqs
      irqchip/mbigen: Free msi_desc on device teardown
      irqchip/gic-v4.1: Update effective affinity of virtual SGIs
      irqchip/gic-v4.1: Add support for VPENDBASER's Dirty+Valid signaling
      genirq: Remove setup_irq() and remove_irq()

commit 7856e9f12f1f59cc6abb25f92b336528d0660ebb
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Mar 23 18:01:11 2020 -0500

    irq.h: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9315fbb87db3..fa8ad93029ad 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1043,7 +1043,7 @@ struct irq_chip_generic {
 	unsigned long		unused;
 	struct irq_domain	*domain;
 	struct list_head	list;
-	struct irq_chip_type	chip_types[0];
+	struct irq_chip_type	chip_types[];
 };
 
 /**
@@ -1079,7 +1079,7 @@ struct irq_domain_chip_generic {
 	unsigned int		irq_flags_to_clear;
 	unsigned int		irq_flags_to_set;
 	enum irq_gc_flags	gc_flags;
-	struct irq_chip_generic	*gc[0];
+	struct irq_chip_generic	*gc[];
 };
 
 /* Generic chip callback functions */

commit 07d8350ede4c4c29634b26c163a1eecdf39dfcfb
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Fri Mar 27 21:41:16 2020 +0530

    genirq: Remove setup_irq() and remove_irq()
    
    Now that all the users of setup_irq() & remove_irq() have been replaced by
    request_irq() & free_irq() respectively, delete them.
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lkml.kernel.org/r/0aa8771ada1ac8e1312f6882980c9c08bd023148.1585320721.git.afzal.mohd.ma@gmail.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9315fbb87db3..c63c2aa915ff 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -573,8 +573,6 @@ enum {
 #define IRQ_DEFAULT_INIT_FLAGS	ARCH_IRQ_INIT_FLAGS
 
 struct irqaction;
-extern int setup_irq(unsigned int irq, struct irqaction *new);
-extern void remove_irq(unsigned int irq, struct irqaction *act);
 extern int setup_percpu_irq(unsigned int irq, struct irqaction *new);
 extern void remove_percpu_irq(unsigned int irq, struct irqaction *act);
 

commit c16816acd08697b02a53f56f8936497a9f6f6e7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:03:43 2020 +0100

    genirq: Add protection against unsafe usage of generic_handle_irq()
    
    In general calling generic_handle_irq() with interrupts disabled from non
    interrupt context is harmless. For some interrupt controllers like the x86
    trainwrecks this is outright dangerous as it might corrupt state if an
    interrupt affinity change is pending.
    
    Add infrastructure which allows to mark interrupts as unsafe and catch such
    usage in generic_handle_irq().
    
    Reported-by: sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <maz@kernel.org>
    Link: https://lkml.kernel.org/r/20200306130623.590923677@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3ed5a055b5f4..9315fbb87db3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -211,6 +211,8 @@ struct irq_data {
  * IRQD_CAN_RESERVE		- Can use reservation mode
  * IRQD_MSI_NOMASK_QUIRK	- Non-maskable MSI quirk for affinity change
  *				  required
+ * IRQD_HANDLE_ENFORCE_IRQCTX	- Enforce that handle_irq_*() is only invoked
+ *				  from actual interrupt context.
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -234,6 +236,7 @@ enum {
 	IRQD_DEFAULT_TRIGGER_SET	= (1 << 25),
 	IRQD_CAN_RESERVE		= (1 << 26),
 	IRQD_MSI_NOMASK_QUIRK		= (1 << 27),
+	IRQD_HANDLE_ENFORCE_IRQCTX	= (1 << 28),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -303,6 +306,16 @@ static inline bool irqd_is_single_target(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_SINGLE_TARGET;
 }
 
+static inline void irqd_set_handle_enforce_irqctx(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_HANDLE_ENFORCE_IRQCTX;
+}
+
+static inline bool irqd_is_handle_enforce_irqctx(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_HANDLE_ENFORCE_IRQCTX;
+}
+
 static inline bool irqd_is_wakeup_set(struct irq_data *d)
 {
 	return __irqd_to_state(d) & IRQD_WAKEUP_STATE;

commit 6f1a4891a5928a5969c87fa5a584844c983ec823
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jan 31 15:26:52 2020 +0100

    x86/apic/msi: Plug non-maskable MSI affinity race
    
    Evan tracked down a subtle race between the update of the MSI message and
    the device raising an interrupt internally on PCI devices which do not
    support MSI masking. The update of the MSI message is non-atomic and
    consists of either 2 or 3 sequential 32bit wide writes to the PCI config
    space.
    
       - Write address low 32bits
       - Write address high 32bits (If supported by device)
       - Write data
    
    When an interrupt is migrated then both address and data might change, so
    the kernel attempts to mask the MSI interrupt first. But for MSI masking is
    optional, so there exist devices which do not provide it. That means that
    if the device raises an interrupt internally between the writes then a MSI
    message is sent built from half updated state.
    
    On x86 this can lead to spurious interrupts on the wrong interrupt
    vector when the affinity setting changes both address and data. As a
    consequence the device interrupt can be lost causing the device to
    become stuck or malfunctioning.
    
    Evan tried to handle that by disabling MSI accross an MSI message
    update. That's not feasible because disabling MSI has issues on its own:
    
     If MSI is disabled the PCI device is routing an interrupt to the legacy
     INTx mechanism. The INTx delivery can be disabled, but the disablement is
     not working on all devices.
    
     Some devices lose interrupts when both MSI and INTx delivery are disabled.
    
    Another way to solve this would be to enforce the allocation of the same
    vector on all CPUs in the system for this kind of screwed devices. That
    could be done, but it would bring back the vector space exhaustion problems
    which got solved a few years ago.
    
    Fortunately the high address (if supported by the device) is only relevant
    when X2APIC is enabled which implies interrupt remapping. In the interrupt
    remapping case the affinity setting is happening at the interrupt remapping
    unit and the PCI MSI message is programmed only once when the PCI device is
    initialized.
    
    That makes it possible to solve it with a two step update:
    
      1) Target the MSI msg to the new vector on the current target CPU
    
      2) Target the MSI msg to the new vector on the new target CPU
    
    In both cases writing the MSI message is only changing a single 32bit word
    which prevents the issue of inconsistency.
    
    After writing the final destination it is necessary to check whether the
    device issued an interrupt while the intermediate state #1 (new vector,
    current CPU) was in effect.
    
    This is possible because the affinity change is always happening on the
    current target CPU. The code runs with interrupts disabled, so the
    interrupt can be detected by checking the IRR of the local APIC. If the
    vector is pending in the IRR then the interrupt is retriggered on the new
    target CPU by sending an IPI for the associated vector on the target CPU.
    
    This can cause spurious interrupts on both the local and the new target
    CPU.
    
     1) If the new vector is not in use on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then interrupt entry code will
        ignore that spurious interrupt. The vector is marked so that the
        'No irq handler for vector' warning is supressed once.
    
     2) If the new vector is in use already on the local CPU then the IRR check
        might see an pending interrupt from the device which is using this
        vector. The IPI to the new target CPU will then invoke the handler of
        the device, which got the affinity change, even if that device did not
        issue an interrupt
    
     3) If the new vector is in use already on the local CPU and the device
        affected by the affinity change raised an interrupt during the
        transitional state (step #1 above) then the handler of the device which
        uses that vector on the local CPU will be invoked.
    
    expose issues in device driver interrupt handlers which are not prepared to
    handle a spurious interrupt correctly. This not a regression, it's just
    exposing something which was already broken as spurious interrupts can
    happen for a lot of reasons and all driver handlers need to be able to deal
    with them.
    
    Reported-by: Evan Green <evgreen@chromium.org>
    Debugged-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Evan Green <evgreen@chromium.org>
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/87imkr4s7n.fsf@nanos.tec.linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7853eb9301f2..3ed5a055b5f4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -209,6 +209,8 @@ struct irq_data {
  * IRQD_SINGLE_TARGET		- IRQ allows only a single affinity target
  * IRQD_DEFAULT_TRIGGER_SET	- Expected trigger already been set
  * IRQD_CAN_RESERVE		- Can use reservation mode
+ * IRQD_MSI_NOMASK_QUIRK	- Non-maskable MSI quirk for affinity change
+ *				  required
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -231,6 +233,7 @@ enum {
 	IRQD_SINGLE_TARGET		= (1 << 24),
 	IRQD_DEFAULT_TRIGGER_SET	= (1 << 25),
 	IRQD_CAN_RESERVE		= (1 << 26),
+	IRQD_MSI_NOMASK_QUIRK		= (1 << 27),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -390,6 +393,21 @@ static inline bool irqd_can_reserve(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_CAN_RESERVE;
 }
 
+static inline void irqd_set_msi_nomask_quirk(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_MSI_NOMASK_QUIRK;
+}
+
+static inline void irqd_clr_msi_nomask_quirk(struct irq_data *d)
+{
+	__irqd_to_state(d) &= ~IRQD_MSI_NOMASK_QUIRK;
+}
+
+static inline bool irqd_msi_nomask_quirk(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_MSI_NOMASK_QUIRK;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit 4a169a95d885fe5c050bac1a21d43c86ba955bcf
Author: Maulik Shah <mkshah@codeaurora.org>
Date:   Fri Nov 15 15:11:49 2019 -0700

    genirq: Introduce irq_chip_get/set_parent_state calls
    
    On certain QTI chipsets some GPIOs are direct-connect interrupts to the
    GIC to be used as regular interrupt lines. When the GPIOs are not used
    for interrupt generation the interrupt line is disabled. But disabling
    the interrupt at GIC does not prevent the interrupt to be reported as
    pending at GIC_ISPEND. Later, when drivers call enable_irq() on the
    interrupt, an unwanted interrupt occurs.
    
    Introduce get and set methods for irqchip's parent to clear it's pending
    irq state. This then can be invoked by the GPIO interrupt controller on
    the parents in it hierarchy to clear the interrupt before enabling the
    interrupt.
    
    Signed-off-by: Maulik Shah <mkshah@codeaurora.org>
    Signed-off-by: Lina Iyer <ilina@codeaurora.org>
    Signed-off-by: Marc Zyngier <maz@kernel.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/1573855915-9841-7-git-send-email-ilina@codeaurora.org
    
    [updated commit text and minor code fixes]

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fb301cf29148..7853eb9301f2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -610,6 +610,12 @@ extern int irq_chip_pm_put(struct irq_data *data);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern void handle_fasteoi_ack_irq(struct irq_desc *desc);
 extern void handle_fasteoi_mask_irq(struct irq_desc *desc);
+extern int irq_chip_set_parent_state(struct irq_data *data,
+				     enum irqchip_irq_state which,
+				     bool val);
+extern int irq_chip_get_parent_state(struct irq_data *data,
+				     enum irqchip_irq_state which,
+				     bool *state);
 extern void irq_chip_enable_parent(struct irq_data *data);
 extern void irq_chip_disable_parent(struct irq_data *data);
 extern void irq_chip_ack_parent(struct irq_data *data);

commit 2bd1298ac17777525a41c8425521f569e412df14
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Tue Apr 30 15:42:22 2019 +0530

    genirq: Introduce irq_chip_{request,release}_resource_parent() apis
    
    Introduce irq_chip_{request,release}_resource_parent() apis so
    that these can be used in hierarchical irqchips.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7ae8de5ad0f2..fb301cf29148 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -625,6 +625,8 @@ extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
 extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
 					     void *vcpu_info);
 extern int irq_chip_set_type_parent(struct irq_data *data, unsigned int type);
+extern int irq_chip_request_resources_parent(struct irq_data *data);
+extern void irq_chip_release_resources_parent(struct irq_data *data);
 #endif
 
 /* Handling of unhandled and spurious interrupts: */

commit 551417af91b163bd697eb50b3601adae2177c28a
Author: Peter Xu <peterx@redhat.com>
Date:   Mon Mar 18 14:51:23 2019 +0800

    genirq: Fix typo in comment of IRQD_MOVE_PCNTXT
    
    Signed-off-by: Peter Xu <peterx@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Dou Liyang <douliyangs@gmail.com>
    Cc: Julien Thierry <julien.thierry@arm.com>
    Link: https://lkml.kernel.org/r/20190318065123.11862-1-peterx@redhat.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d6160d479b14..7ae8de5ad0f2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -195,7 +195,7 @@ struct irq_data {
  * IRQD_LEVEL			- Interrupt is level triggered
  * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup
  *				  from suspend
- * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process
+ * IRQD_MOVE_PCNTXT		- Interrupt can be moved in process
  *				  context
  * IRQD_IRQ_DISABLED		- Disabled state of the interrupt
  * IRQD_IRQ_MASKED		- Masked state of the interrupt

commit 3601fe43e8164f67a8de3de8e988bfcb3a94af46
Merge: cf2e8c544cd3 d01849f7deba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 10:09:53 2019 -0800

    Merge tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v5.1 cycle:
    
      Core changes:
    
       - The big change this time around is the irqchip handling in the
         qualcomm pin controllers, closely coupled with the gpiochip. This
         rework, in a classic fall-between-the-chairs fashion has been
         sidestepped for too long.
    
         The Qualcomm IRQchips using the SPMI and SSBI transport mechanisms
         have been rewritten to use hierarchical irqchip. This creates the
         base from which I intend to gradually pull support for hierarchical
         irqchips into the gpiolib irqchip helpers to cut down on duplicate
         code.
    
         We have too many hacks in the kernel because people have been
         working around the missing hierarchical irqchip for years, and once
         it was there, noone understood it for a while. We are now slowly
         adapting to using it.
    
         This is why this pull requests include changes to MFD, SPMI,
         IRQchip core and some ARM Device Trees pertaining to the Qualcomm
         chip family. Since Qualcomm have so many chips and such large
         deployments it is paramount that this platform gets this right, and
         now it (hopefully) does.
    
       - Core support for pull-up and pull-down configuration, also from the
         device tree. When a simple GPIO chip supports an "off or on" pull-up
         or pull-down resistor, we provide a way to set this up using
         machine descriptors or device tree.
    
         If more elaborate control of pull up/down (such as resistance shunt
         setting) is required, drivers should be phased over to use pin
         control. We do not yet provide a userspace ABI for this pull
         up-down setting but I suspect the makers are going to ask for it
         soon enough. PCA953x is the first user of this new API.
    
       - The GPIO mockup driver has been revamped after some discussion
         improving the IRQ simulator in the process.
    
         The idea is to make it possible to use the mockup for both testing
         and virtual prototyping, e.g. when you do not yet have a GPIO
         expander to play with but really want to get something to develop
         code around before hardware is available. It's neat. The blackbox
         testing usecase is currently making its way into kernelci.
    
       - ACPI GPIO core preserves non direction flags when updating flags.
    
       - A new device core helper for devm_platform_ioremap_resource() is
         funneled through the GPIO tree with Greg's ACK.
    
      New drivers:
    
       - TQ-Systems QTMX86 GPIO controllers (using port-mapped I/O)
    
       - Gateworks PLD GPIO driver (vaccumed up from OpenWrt)
    
       - AMD G-Series PCH (Platform Controller Hub) GPIO driver.
    
       - Fintek F81804 & F81966 subvariants.
    
       - PCA953x now supports NXP PCAL6416.
    
      Driver improvements:
    
       - IRQ support on the Nintendo Wii (Hollywood) GPIO.
    
       - get_direction() support for the MVEBU driver.
    
       - Set the right output level on SAMA5D2.
    
       - Drop the unused irq trigger setting on the Spreadtrum driver.
    
       - Wakeup support for PCA953x.
    
       - A slew of cleanups in the various Intel drivers"
    
    * tag 'gpio-v5.1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (110 commits)
      gpio: gpio-omap: fix level interrupt idling
      gpio: amd-fch: Set proper output level for direction_output
      x86: apuv2: remove unused variable
      gpio: pca953x: Use PCA_LATCH_INT
      platform/x86: fix PCENGINES_APU2 Kconfig warning
      gpio: pca953x: Fix dereference of irq data in shutdown
      gpio: amd-fch: Fix type error found by sparse
      gpio: amd-fch: Drop const from resource
      gpio: mxc: add check to return defer probe if clock tree NOT ready
      gpio: ftgpio: Register per-instance irqchip
      gpio: ixp4xx: Add DT bindings
      x86: pcengines apuv2 gpio/leds/keys platform driver
      gpio: AMD G-Series PCH gpio driver
      drivers: depend on HAS_IOMEM for devm_platform_ioremap_resource()
      gpio: tqmx86: Set proper output level for direction_output
      gpio: sprd: Change to use SoC compatible string
      gpio: sprd: Use SoC compatible string instead of wildcard string
      gpio: of: Handle both enable-gpio{,s}
      gpio: of: Restrict enable-gpio quirk to regulator-gpio
      gpio: davinci: use devm_platform_ioremap_resource()
      ...

commit 5aa5bd563ce041d931c0dc1fc436dd18c27c60a7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 7 21:16:23 2019 -0500

    genirq: introduce irq_chip_mask_ack_parent()
    
    The hierarchical irqchip never before ran into a situation
    where the parent is not "simple", i.e. does not implement
    .irq_ack() and .irq_mask() like most, but the qcom-pm8xxx.c
    happens to implement only .irq_mask_ack().
    
    Since we want to make ssbi-gpio a hierarchical child of this
    irqchip, it must *also* only implement .irq_mask_ack()
    and call down to the parent, and for this we of course
    need irq_chip_mask_ack_parent().
    
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index def2b2aac8b1..9a1a67d2e07d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -605,6 +605,7 @@ extern void irq_chip_disable_parent(struct irq_data *data);
 extern void irq_chip_ack_parent(struct irq_data *data);
 extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
 extern void irq_chip_mask_parent(struct irq_data *data);
+extern void irq_chip_mask_ack_parent(struct irq_data *data);
 extern void irq_chip_unmask_parent(struct irq_data *data);
 extern void irq_chip_eoi_parent(struct irq_data *data);
 extern int irq_chip_set_affinity_parent(struct irq_data *data,

commit 2dcf1fbcad352baaa5f47b17e57c5743c8eedbad
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:54:00 2019 +0000

    genirq: Provide NMI handlers
    
    Provide flow handlers that are NMI safe for interrupts and percpu_devid
    interrupts.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a7298e4998c8..5e91f6bcaacd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -601,6 +601,9 @@ extern void handle_percpu_devid_irq(struct irq_desc *desc);
 extern void handle_bad_irq(struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
+extern void handle_fasteoi_nmi(struct irq_desc *desc);
+extern void handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc);
+
 extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
 extern int irq_chip_pm_get(struct irq_data *data);
 extern int irq_chip_pm_put(struct irq_data *data);

commit b525903c254dab2491410f0f23707691b7c2c317
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:53:58 2019 +0000

    genirq: Provide basic NMI management for interrupt lines
    
    Add functionality to allocate interrupt lines that will deliver IRQs
    as Non-Maskable Interrupts. These allocations are only successful if
    the irqchip provides the necessary support and allows NMI delivery for the
    interrupt line.
    
    Interrupt lines allocated for NMI delivery must be enabled/disabled through
    enable_nmi/disable_nmi_nosync to keep their state consistent.
    
    To treat a PERCPU IRQ as NMI, the interrupt must not be shared nor threaded,
    the irqchip directly managing the IRQ must be the root irqchip and the
    irqchip cannot be behind a slow bus.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index def2b2aac8b1..a7298e4998c8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -442,6 +442,8 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
  * @ipi_send_single:	send a single IPI to destination cpus
  * @ipi_send_mask:	send an IPI to destination cpus in cpumask
+ * @irq_nmi_setup:	function called from core code before enabling an NMI
+ * @irq_nmi_teardown:	function called from core code after disabling an NMI
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -490,6 +492,9 @@ struct irq_chip {
 	void		(*ipi_send_single)(struct irq_data *data, unsigned int cpu);
 	void		(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);
 
+	int		(*irq_nmi_setup)(struct irq_data *data);
+	void		(*irq_nmi_teardown)(struct irq_data *data);
+
 	unsigned long	flags;
 };
 
@@ -505,6 +510,7 @@ struct irq_chip {
  * IRQCHIP_ONESHOT_SAFE:	One shot does not require mask/unmask
  * IRQCHIP_EOI_THREADED:	Chip requires eoi() on unmask in threaded mode
  * IRQCHIP_SUPPORTS_LEVEL_MSI	Chip can provide two doorbells for Level MSIs
+ * IRQCHIP_SUPPORTS_NMI:	Chip can deliver NMIs, only for root irqchips
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
@@ -515,6 +521,7 @@ enum {
 	IRQCHIP_ONESHOT_SAFE		= (1 <<  5),
 	IRQCHIP_EOI_THREADED		= (1 <<  6),
 	IRQCHIP_SUPPORTS_LEVEL_MSI	= (1 <<  7),
+	IRQCHIP_SUPPORTS_NMI		= (1 <<  8),
 };
 
 #include <linux/irqdesc.h>

commit bec04037e4e484f41ee4d9409e40616874169d20
Author: Dou Liyang <douliyangs@gmail.com>
Date:   Tue Dec 4 23:51:20 2018 +0800

    genirq/core: Introduce struct irq_affinity_desc
    
    The interrupt affinity management uses straight cpumask pointers to convey
    the automatically assigned affinity masks for managed interrupts. The core
    interrupt descriptor allocation also decides based on the pointer being non
    NULL whether an interrupt is managed or not.
    
    Devices which use managed interrupts usually have two classes of
    interrupts:
    
      - Interrupts for multiple device queues
      - Interrupts for general device management
    
    Currently both classes are treated the same way, i.e. as managed
    interrupts. The general interrupts get the default affinity mask assigned
    while the device queue interrupts are spread out over the possible CPUs.
    
    Treating the general interrupts as managed is both a limitation and under
    certain circumstances a bug. Assume the following situation:
    
     default_irq_affinity = 4..7
    
    So if CPUs 4-7 are offlined, then the core code will shut down the device
    management interrupts because the last CPU in their affinity mask went
    offline.
    
    It's also a limitation because it's desired to allow manual placement of
    the general device interrupts for various reasons. If they are marked
    managed then the interrupt affinity setting from both user and kernel space
    is disabled.
    
    To remedy that situation it's required to convey more information than the
    cpumasks through various interfaces related to interrupt descriptor
    allocation.
    
    Instead of adding yet another argument, create a new data structure
    'irq_affinity_desc' which for now just contains the cpumask. This struct
    can be expanded to convey auxilliary information in the next step.
    
    No functional change, just preparatory work.
    
    [ tglx: Simplified logic and clarified changelog ]
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Dou Liyang <douliyangs@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: kashyap.desai@broadcom.com
    Cc: shivasharan.srikanteshwara@broadcom.com
    Cc: sumit.saxena@broadcom.com
    Cc: ming.lei@redhat.com
    Cc: hch@lst.de
    Cc: douliyang1@huawei.com
    Link: https://lkml.kernel.org/r/20181204155122.6327-2-douliyangs@gmail.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c9bffda04a45..def2b2aac8b1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -27,6 +27,7 @@
 struct seq_file;
 struct module;
 struct msi_msg;
+struct irq_affinity_desc;
 enum irqchip_irq_state;
 
 /*
@@ -834,11 +835,12 @@ struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
 unsigned int arch_dynirq_lower_bound(unsigned int from);
 
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
-		      struct module *owner, const struct cpumask *affinity);
+		      struct module *owner,
+		      const struct irq_affinity_desc *affinity);
 
 int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
 			   unsigned int cnt, int node, struct module *owner,
-			   const struct cpumask *affinity);
+			   const struct irq_affinity_desc *affinity);
 
 /* use macros to avoid needing export.h for THIS_MODULE */
 #define irq_alloc_descs(irq, from, cnt, node)	\

commit 76f99ae5b54d48430d1f0c5512a84da0ff9761e0
Author: Dou Liyang <douly.fnst@cn.fujitsu.com>
Date:   Sun Sep 9 01:58:38 2018 +0800

    irq/matrix: Spread managed interrupts on allocation
    
    Linux spreads out the non managed interrupt across the possible target CPUs
    to avoid vector space exhaustion.
    
    Managed interrupts are treated differently, as for them the vectors are
    reserved (with guarantee) when the interrupt descriptors are initialized.
    
    When the interrupt is requested a real vector is assigned. The assignment
    logic uses the first CPU in the affinity mask for assignment. If the
    interrupt has more than one CPU in the affinity mask, which happens when a
    multi queue device has less queues than CPUs, then doing the same search as
    for non managed interrupts makes sense as it puts the interrupt on the
    least interrupt plagued CPU. For single CPU affine vectors that's obviously
    a NOOP.
    
    Restructre the matrix allocation code so it does the 'best CPU' search, add
    the sanity check for an empty affinity mask and adapt the call site in the
    x86 vector management code.
    
    [ tglx: Added the empty mask check to the core and improved change log ]
    
    Signed-off-by: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: hpa@zytor.com
    Link: https://lkml.kernel.org/r/20180908175838.14450-2-dou_liyang@163.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 201de12a9957..c9bffda04a45 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1151,7 +1151,8 @@ void irq_matrix_offline(struct irq_matrix *m);
 void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit, bool replace);
 int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk);
 void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk);
-int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu);
+int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,
+				unsigned int *mapped_cpu);
 void irq_matrix_reserve(struct irq_matrix *m);
 void irq_matrix_remove_reserved(struct irq_matrix *m);
 int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,

commit 72a8edc2d9134c2895eac2fec5eecf8230a05c96
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Jun 22 10:52:48 2018 +0100

    genirq/debugfs: Add missing IRQCHIP_SUPPORTS_LEVEL_MSI debug
    
    Debug is missing the IRQCHIP_SUPPORTS_LEVEL_MSI debug entry, making debugfs
    slightly less useful.
    
    Take this opportunity to also add a missing comment in the definition of
    IRQCHIP_SUPPORTS_LEVEL_MSI.
    
    Fixes: 6988e0e0d283 ("genirq/msi: Limit level-triggered MSI to platform devices")
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Yang Yingliang <yangyingliang@huawei.com>
    Cc: Sumit Garg <sumit.garg@linaro.org>
    Link: https://lkml.kernel.org/r/20180622095254.5906-2-marc.zyngier@arm.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4bd2f34947f4..201de12a9957 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -503,6 +503,7 @@ struct irq_chip {
  * IRQCHIP_SKIP_SET_WAKE:	Skip chip.irq_set_wake(), for this irq chip
  * IRQCHIP_ONESHOT_SAFE:	One shot does not require mask/unmask
  * IRQCHIP_EOI_THREADED:	Chip requires eoi() on unmask in threaded mode
+ * IRQCHIP_SUPPORTS_LEVEL_MSI	Chip can provide two doorbells for Level MSIs
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),

commit f4e5b30d809d3882c69f43b5c90779af033d40c4
Merge: a2211de0f979 1d9f3e20a56d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 09:44:53 2018 -0700

    Merge branch 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 updates and fixes from Thomas Gleixner:
    
     - Fix the (late) fallout from the vector management rework causing
       hlist corruption and irq descriptor reference leaks caused by a
       missing sanity check.
    
       The straight forward fix triggered another long standing issue to
       surface. The pre rework code hid the issue due to being way slower,
       but now the chance that user space sees an EBUSY error return when
       updating irq affinities is way higher, though quite a bunch of
       userspace tools do not handle it properly despite the fact that EBUSY
       could be returned for at least 10 years.
    
       It turned out that the EBUSY return can be avoided completely by
       utilizing the existing delayed affinity update mechanism for irq
       remapped scenarios as well. That's a bit more error handling in the
       kernel, but avoids fruitless fingerpointing discussions with tool
       developers.
    
     - Decouple PHYSICAL_MASK from AMD SME as its going to be required for
       the upcoming Intel memory encryption support as well.
    
     - Handle legacy device ACPI detection properly for newer platforms
    
     - Fix the wrong argument ordering in the vector allocation tracepoint
    
     - Simplify the IDT setup code for the APIC=n case
    
     - Use the proper string helpers in the MTRR code
    
     - Remove a stale unused VDSO source file
    
     - Convert the microcode update lock to a raw spinlock as its used in
       atomic context.
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/intel_rdt: Enable CMT and MBM on new Skylake stepping
      x86/apic/vector: Print APIC control bits in debugfs
      genirq/affinity: Defer affinity setting if irq chip is busy
      x86/platform/uv: Use apic_ack_irq()
      x86/ioapic: Use apic_ack_irq()
      irq_remapping: Use apic_ack_irq()
      x86/apic: Provide apic_ack_irq()
      genirq/migration: Avoid out of line call if pending is not set
      genirq/generic_pending: Do not lose pending affinity update
      x86/apic/vector: Prevent hlist corruption and leaks
      x86/vector: Fix the args of vector_alloc tracepoint
      x86/idt: Simplify the idt_setup_apic_and_irq_gates()
      x86/platform/uv: Remove extra parentheses
      x86/mm: Decouple dynamic __PHYSICAL_MASK from AMD SME
      x86: Mark native_set_p4d() as __always_inline
      x86/microcode: Make the late update update_lock a raw lock for RT
      x86/mtrr: Convert to use strncpy_from_user() helper
      x86/mtrr: Convert to use match_string() helper
      x86/vdso: Remove unused file
      x86/i8237: Register device based on FADT legacy boot flag

commit d340ebd696f921d3ad01b8c0c29dd38f2ad2bf3e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 6 14:46:59 2018 +0200

    genirq/migration: Avoid out of line call if pending is not set
    
    The upcoming fix for the -EBUSY return from affinity settings requires to
    use the irq_move_irq() functionality even on irq remapped interrupts. To
    avoid the out of line call, move the check for the pending bit into an
    inline helper.
    
    Preparatory change for the real fix. No functional change.
    
    Fixes: dccfe3147b42 ("x86/vector: Simplify vector move cleanup")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Song Liu <liu.song.a23@gmail.com>
    Cc: Dmitry Safonov <0x7f454c46@gmail.com>
    Cc: stable@vger.kernel.org
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Tariq Toukan <tariqt@mellanox.com>
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Link: https://lkml.kernel.org/r/20180604162224.471925894@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 65916a305f3d..4e66378f290b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -551,7 +551,12 @@ extern int irq_affinity_online_cpu(unsigned int cpu);
 #endif
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
-void irq_move_irq(struct irq_data *data);
+void __irq_move_irq(struct irq_data *data);
+static inline void irq_move_irq(struct irq_data *data)
+{
+	if (unlikely(irqd_is_setaffinity_pending(data)))
+		__irq_move_irq(data);
+}
 void irq_move_masked_irq(struct irq_data *data);
 void irq_force_complete_move(struct irq_desc *desc);
 #else

commit 6988e0e0d28328467e218f59589b2770675a9ebd
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue May 8 13:14:31 2018 +0100

    genirq/msi: Limit level-triggered MSI to platform devices
    
    Nobody would be insane enough to try and use level triggered
    MSIs on PCI, but let's make sure it doesn't happen. Also,
    let's mandate that the irqchip backing the platform MSI domain
    is providing the IRQCHIP_SUPPORTS_LEVEL_MSI flag.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lkml.kernel.org/r/20180508121438.11301-3-marc.zyngier@arm.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 65916a305f3d..b2067083aa94 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -512,6 +512,7 @@ enum {
 	IRQCHIP_SKIP_SET_WAKE		= (1 <<  4),
 	IRQCHIP_ONESHOT_SAFE		= (1 <<  5),
 	IRQCHIP_EOI_THREADED		= (1 <<  6),
+	IRQCHIP_SUPPORTS_LEVEL_MSI	= (1 <<  7),
 };
 
 #include <linux/irqdesc.h>

commit caacdbf4aa567ab5e8de1a4070195c5d3e8f1340
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Wed Mar 7 15:57:27 2018 -0800

    genirq: Add CONFIG_GENERIC_IRQ_MULTI_HANDLER
    
    The arm multi irq handler registration mechanism has been copied into a
    handful of architectures, including arm64 and openrisc. RISC-V needs the
    same mechanism.
    
    Instead of adding yet another copy for RISC-V copy the arm implementation
    into the core code depending on a new Kconfig symbol:
    CONFIG_GENERIC_MULTI_IRQ_HANDLER.
    
    Subsequent patches will convert the various architectures.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: jonas@southpole.se
    Cc: catalin.marinas@arm.com
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux@armlinux.org.uk
    Cc: stefan.kristiansson@saunalahti.fi
    Cc: openrisc@lists.librecores.org
    Cc: shorne@gmail.com
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://lkml.kernel.org/r/20180307235731.22627-2-palmer@sifive.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 979eed1b2654..65916a305f3d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1165,4 +1165,22 @@ int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest);
 int ipi_send_single(unsigned int virq, unsigned int cpu);
 int ipi_send_mask(unsigned int virq, const struct cpumask *dest);
 
+#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
+/*
+ * Registers a generic IRQ handling function as the top-level IRQ handler in
+ * the system, which is generally the first C code called from an assembly
+ * architecture-specific interrupt handler.
+ *
+ * Returns 0 on success, or -EBUSY if an IRQ handler has already been
+ * registered.
+ */
+int __init set_handle_irq(void (*handle_irq)(struct pt_regs *));
+
+/*
+ * Allows interrupt handlers to find the irqchip that's been registered as the
+ * top-level IRQ handler.
+ */
+extern void (*handle_arch_irq)(struct pt_regs *) __ro_after_init;
+#endif
+
 #endif /* _LINUX_IRQ_H */

commit e69c61dd050e410d78363e5fe6e56a9f719abdf5
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sat Feb 24 21:22:18 2018 -0800

    genirq: Drop 5 #included header files from irq.h
    
    <linux/irq.h> does not use nor need several of its #included files,
    so drop those header files from irq.h.
    
    <linux/irq.h> is currently #included in around 1135 C source files
    (oops, I didn't count other header files that #include it), making it
    the 29th most-used header file.
    
    Build tested on i386 and x86_64 * (allnoconfig, tiny.config, defconfig,
    allyesconfig, and allmodconfig) and x64_64 allmodconfig + SMP=disabled.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/02745e91-c117-74b5-d043-dceb3d4bb4e0@infradead.org

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a0231e96a578..979eed1b2654 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -10,18 +10,13 @@
  * Thanks. --rmk
  */
 
-#include <linux/smp.h>
-#include <linux/linkage.h>
 #include <linux/cache.h>
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
-#include <linux/gfp.h>
 #include <linux/irqhandler.h>
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
-#include <linux/errno.h>
 #include <linux/topology.h>
-#include <linux/wait.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 

commit 69790ba92b8d67eaee5e50b30a5b696d40664caf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Dec 29 16:44:34 2017 +0100

    genirq: Introduce IRQD_CAN_RESERVE flag
    
    Add a new flag to mark interrupts which can use reservation mode. This is
    going to be used in subsequent patches to disable reservation mode for a
    certain class of MSI devices.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Alexandru Chirvasitu <achirvasub@gmail.com>
    Tested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Dou Liyang <douly.fnst@cn.fujitsu.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Mikael Pettersson <mikpelinux@gmail.com>
    Cc: Josh Poulson <jopoulso@microsoft.com>
    Cc: Mihai Costache <v-micos@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-pci@vger.kernel.org
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Dexuan Cui <decui@microsoft.com>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Saeed Mahameed <saeedm@mellanox.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: devel@linuxdriverproject.org
    Cc: KY Srinivasan <kys@microsoft.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Sakari Ailus <sakari.ailus@intel.com>,
    Cc: linux-media@vger.kernel.org

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e140f69163b6..a0231e96a578 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -212,6 +212,7 @@ struct irq_data {
  *				  mask. Applies only to affinity managed irqs.
  * IRQD_SINGLE_TARGET		- IRQ allows only a single affinity target
  * IRQD_DEFAULT_TRIGGER_SET	- Expected trigger already been set
+ * IRQD_CAN_RESERVE		- Can use reservation mode
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -233,6 +234,7 @@ enum {
 	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
 	IRQD_SINGLE_TARGET		= (1 << 24),
 	IRQD_DEFAULT_TRIGGER_SET	= (1 << 25),
+	IRQD_CAN_RESERVE		= (1 << 26),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -377,6 +379,21 @@ static inline bool irqd_is_managed_and_shutdown(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_MANAGED_SHUTDOWN;
 }
 
+static inline void irqd_set_can_reserve(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_CAN_RESERVE;
+}
+
+static inline void irqd_clr_can_reserve(struct irq_data *d)
+{
+	__irqd_to_state(d) &= ~IRQD_CAN_RESERVE;
+}
+
+static inline bool irqd_can_reserve(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_CAN_RESERVE;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit 41cc30412d6692c25506bf2d4e65c4364c70c10a
Merge: b29c6ef7bb12 29f411399aaa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 14 11:23:05 2017 +0100

    Merge tag 'irqchip-4.15-4' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/urgent
    
    Pull irqchip updates for 4.15, take #4 from Marc Zyngier
    
     - A core irq fix for legacy cases where the irq trigger is not reported
       by firmware
    
     - A couple of GICv3/4 fixes (Kconfig, of-node refcount, error handling)
    
     - Trivial pr_err fixes

commit 670310dfbae0eefe7318ff6a61e29e67a7a7bbce
Merge: 43ff2f4db9d0 ffc661c99f62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:33:11 2017 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq core updates from Thomas Gleixner:
     "A rather large update for the interrupt core code and the irq chip drivers:
    
       - Add a new bitmap matrix allocator and supporting changes, which is
         used to replace the x86 vector allocator which comes with separate
         pull request. This allows to replace the convoluted nested loop
         allocation function in x86 with a facility which supports the
         recently added property of managed interrupts proper and allows to
         switch to a best effort vector reservation scheme, which addresses
         problems with vector exhaustion.
    
       - A large update to the ARM GIC-V3-ITS driver adding support for
         range selectors.
    
       - New interrupt controllers:
           - Meson and Meson8 GPIO
           - BCM7271 L2
           - Socionext EXIU
    
         If you expected that this will stop at some point, I have to
         disappoint you. There are new ones posted already. Sigh!
    
       - STM32 interrupt controller support for new platforms.
    
       - A pile of fixes, cleanups and updates to the MIPS GIC driver
    
       - The usual small fixes, cleanups and updates all over the place.
         Most visible one is to move the irq chip drivers Kconfig switches
         into a separate Kconfig menu"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (70 commits)
      genirq: Fix type of shifting literal 1 in __setup_irq()
      irqdomain: Drop pointless NULL check in virq_debug_show_one
      genirq/proc: Return proper error code when irq_set_affinity() fails
      irq/work: Use llist_for_each_entry_safe
      irqchip: mips-gic: Print warning if inherited GIC base is used
      irqchip/mips-gic: Add pr_fmt and reword pr_* messages
      irqchip/stm32: Move the wakeup on interrupt mask
      irqchip/stm32: Fix initial values
      irqchip/stm32: Add stm32h7 support
      dt-bindings/interrupt-controllers: Add compatible string for stm32h7
      irqchip/stm32: Add multi-bank management
      irqchip/stm32: Select GENERIC_IRQ_CHIP
      irqchip/exiu: Add support for Socionext Synquacer EXIU controller
      dt-bindings: Add description of Socionext EXIU interrupt controller
      irqchip/gic-v3-its: Fix VPE activate callback return value
      irqchip: mips-gic: Make IPI bitmaps static
      irqchip: mips-gic: Share register writes in gic_set_type()
      irqchip: mips-gic: Remove gic_vpes variable
      irqchip: mips-gic: Use num_possible_cpus() to reserve IPIs
      irqchip: mips-gic: Configure EIC when CPUs come online
      ...

commit 4f8413a3a799c958f7a10a6310a451e6b8aef5ad
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Nov 9 14:17:59 2017 +0000

    genirq: Track whether the trigger type has been set
    
    When requesting a shared interrupt, we assume that the firmware
    support code (DT or ACPI) has called irqd_set_trigger_type
    already, so that we can retrieve it and check that the requester
    is being reasonnable.
    
    Unfortunately, we still have non-DT, non-ACPI systems around,
    and these guys won't call irqd_set_trigger_type before requesting
    the interrupt. The consequence is that we fail the request that
    would have worked before.
    
    We can either chase all these use cases (boring), or address it
    in core code (easier). Let's have a per-irq_desc flag that
    indicates whether irqd_set_trigger_type has been called, and
    let's just check it when checking for a shared interrupt.
    If it hasn't been set, just take whatever the interrupt
    requester asks.
    
    Fixes: 382bd4de6182 ("genirq: Use irqd_get_trigger_type to compare the trigger type for shared IRQs")
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Petr Cvek <petrcvekcz@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fda8da7c45e7..73f61eeb152e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -210,6 +210,7 @@ struct irq_data {
  * IRQD_MANAGED_SHUTDOWN	- Interrupt was shutdown due to empty affinity
  *				  mask. Applies only to affinity managed irqs.
  * IRQD_SINGLE_TARGET		- IRQ allows only a single affinity target
+ * IRQD_DEFAULT_TRIGGER_SET	- Expected trigger already been set
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -230,6 +231,7 @@ enum {
 	IRQD_IRQ_STARTED		= (1 << 22),
 	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
 	IRQD_SINGLE_TARGET		= (1 << 24),
+	IRQD_DEFAULT_TRIGGER_SET	= (1 << 25),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -259,18 +261,25 @@ static inline void irqd_mark_affinity_was_set(struct irq_data *d)
 	__irqd_to_state(d) |= IRQD_AFFINITY_SET;
 }
 
+static inline bool irqd_trigger_type_was_set(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_DEFAULT_TRIGGER_SET;
+}
+
 static inline u32 irqd_get_trigger_type(struct irq_data *d)
 {
 	return __irqd_to_state(d) & IRQD_TRIGGER_MASK;
 }
 
 /*
- * Must only be called inside irq_chip.irq_set_type() functions.
+ * Must only be called inside irq_chip.irq_set_type() functions or
+ * from the DT/ACPI setup code.
  */
 static inline void irqd_set_trigger_type(struct irq_data *d, u32 type)
 {
 	__irqd_to_state(d) &= ~IRQD_TRIGGER_MASK;
 	__irqd_to_state(d) |= type & IRQD_TRIGGER_MASK;
+	__irqd_to_state(d) |= IRQD_DEFAULT_TRIGGER_SET;
 }
 
 static inline bool irqd_is_level_type(struct irq_data *d)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5ad10948ea95..4536286cc4d2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_IRQ_H
 #define _LINUX_IRQ_H
 

commit 0d08af35f16a0cc418ad2afde3bc5f70ace82705
Author: Doug Berger <opendmb@gmail.com>
Date:   Wed Oct 4 14:28:17 2017 +0200

    genirq: generic chip: remove irq_gc_mask_disable_reg_and_ack()
    
    Any usage of the irq_gc_mask_disable_reg_and_ack() function has
    been replaced with the desired functionality.
    
    The incorrect and ambiguously named function is removed here to
    prevent accidental misuse.
    
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 494d328f7051..5ad10948ea95 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1009,7 +1009,6 @@ void irq_gc_mask_clr_bit(struct irq_data *d);
 void irq_gc_unmask_enable_reg(struct irq_data *d);
 void irq_gc_ack_set_bit(struct irq_data *d);
 void irq_gc_ack_clr_bit(struct irq_data *d);
-void irq_gc_mask_disable_reg_and_ack(struct irq_data *d);
 void irq_gc_mask_disable_and_ack_set(struct irq_data *d);
 void irq_gc_eoi(struct irq_data *d);
 int irq_gc_set_wake(struct irq_data *d, unsigned int on);

commit 20608924cc2e6bdeaf6f58ccbe9ddfe12dbfa082
Author: Doug Berger <opendmb@gmail.com>
Date:   Wed Oct 4 14:26:26 2017 +0200

    genirq: generic chip: Add irq_gc_mask_disable_and_ack_set()
    
    The irq_gc_mask_disable_reg_and_ack() function name implies that it
    provides the combined functions of irq_gc_mask_disable_reg() and
    irq_gc_ack().  However, the implementation does not actually do
    that since it writes the mask instead of the disable register. It
    also does not maintain the mask cache which makes it inappropriate
    to use with other masking functions.
    
    In addition, commit 659fb32d1b67 ("genirq: replace irq_gc_ack() with
    {set,clr}_bit variants (fwd)") effectively renamed irq_gc_ack() to
    irq_gc_ack_set_bit() so this function probably should have also been
    renamed at that time.
    
    The generic chip code currently provides three functions for use
    with the irq_mask member of the irq_chip structure and two functions
    for use with the irq_ack member of the irq_chip structure. These
    functions could be combined into six functions for use with the
    irq_mask_ack member of the irq_chip structure.  However, since only
    one of the combinations is currently used, only the function
    irq_gc_mask_disable_and_ack_set() is added by this commit.
    
    The '_reg' and '_bit' portions of the base function name were left
    out of the new combined function name in an attempt to keep the
    function name length manageable with the 80 character source code
    line length while still allowing the distinct aspects of each
    combination to be captured by the name.
    
    If other combinations are desired in the future please add them to
    the irq generic chip library at that time.
    
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d4728bf6a537..494d328f7051 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1010,6 +1010,7 @@ void irq_gc_unmask_enable_reg(struct irq_data *d);
 void irq_gc_ack_set_bit(struct irq_data *d);
 void irq_gc_ack_clr_bit(struct irq_data *d);
 void irq_gc_mask_disable_reg_and_ack(struct irq_data *d);
+void irq_gc_mask_disable_and_ack_set(struct irq_data *d);
 void irq_gc_eoi(struct irq_data *d);
 int irq_gc_set_wake(struct irq_data *d, unsigned int on);
 

commit 2f75d9e1c90511bff6d1ce4de94503cc28fec032
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:14 2017 +0200

    genirq: Implement bitmap matrix allocator
    
    Implement the infrastructure for a simple bitmap based allocator, which
    will replace the x86 vector allocator. It's in the core code as other
    architectures might be able to reuse/extend it. For now it only implements
    allocations for single CPUs, but it's simple to add multi CPU allocation
    support if required.
    
    The concept is rather simple:
    
     Global information:
            system_vector bitmap
            global accounting
    
     PerCPU information:
            allocation bitmap
            managed allocation bitmap
            local accounting
    
    The system vector bitmap is used to exclude vectors system wide from the
    allocation space.
    
    The allocation bitmap is used to keep track of per cpu used vectors.
    
    The managed allocation bitmap is used to reserve vectors for managed
    interrupts.
    
    When a regular (non managed) interrupt allocation happens then the
    following rule applies:
    
          tmpmap = system_map | alloc_map | managed_map
          find_zero_bit(tmpmap)
    
    Oring the bitmaps together gives the real available space. The same rule
    applies for reserving a managed interrupt vector. But contrary to the
    regular interrupts the reservation only marks the bit in the managed map
    and therefor excludes it from the regular allocations. The managed map is
    only cleaned out when the a managed interrupt is completely released and it
    stays alive accross CPU offline/online operations.
    
    For managed interrupt allocations the rule is:
    
          tmpmap = managed_map & ~alloc_map
          find_first_bit(tmpmap)
    
    This returns the first bit which is in the managed map, but not yet
    allocated in the allocation map. The allocation marks it in the allocation
    map and hands it back to the caller for use.
    
    The rest of the code are helper functions to handle the various
    requirements and the accounting which are necessary to replace the x86
    vector allocation code. The result is a single patch as the evolution of
    this infrastructure cannot be represented in bits and pieces.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213153.185437174@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d4728bf6a537..fda8da7c45e7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1113,6 +1113,28 @@ static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
 		return readl(gc->reg_base + reg_offset);
 }
 
+struct irq_matrix;
+struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,
+				    unsigned int alloc_start,
+				    unsigned int alloc_end);
+void irq_matrix_online(struct irq_matrix *m);
+void irq_matrix_offline(struct irq_matrix *m);
+void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit, bool replace);
+int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk);
+void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk);
+int irq_matrix_alloc_managed(struct irq_matrix *m, unsigned int cpu);
+void irq_matrix_reserve(struct irq_matrix *m);
+void irq_matrix_remove_reserved(struct irq_matrix *m);
+int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
+		     bool reserved, unsigned int *mapped_cpu);
+void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,
+		     unsigned int bit, bool managed);
+void irq_matrix_assign(struct irq_matrix *m, unsigned int bit);
+unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown);
+unsigned int irq_matrix_allocated(struct irq_matrix *m);
+unsigned int irq_matrix_reserved(struct irq_matrix *m);
+void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind);
+
 /* Contrary to Linux irqs, for hardware irqs the irq number 0 is valid */
 #define INVALID_HWIRQ	(~0UL)
 irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu);

commit 0551968add53777fddd18f4ffb4e3bbc1f646d79
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 21 11:54:44 2017 +0200

    Revert "genirq: Restrict effective affinity to interrupts actually using it"
    
    This reverts commit 74def747bcd09692bdbf8c6a15350795b0f11ca8.
    
    The change to the helper function is only correct for the /proc/irq/
    readout usage, but breaks the existing x86 usage of that function.
    
    Reported-by: Yanko Kaneti <yaneti@declera.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b99a784635ff..d4728bf6a537 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -783,10 +783,7 @@ static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 static inline
 struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
 {
-	if (!cpumask_empty(d->common->effective_affinity))
-		return d->common->effective_affinity;
-
-	return d->common->affinity;
+	return d->common->effective_affinity;
 }
 static inline void irq_data_update_effective_affinity(struct irq_data *d,
 						      const struct cpumask *m)

commit 6629695465ee6eb9f4afab74f1531a89692a136e
Merge: 500912121411 495c38d3001f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 18 11:22:27 2017 +0200

    Merge branch 'irq/for-gpio' into irq/core
    
    Merge the flow handlers and irq domain extensions which are in a separate
    branch so they can be consumed by the gpio folks.

commit 7703b08cc93b3586f9eb733f3a2b10bed634a5cf
Author: David Daney <david.daney@cavium.com>
Date:   Thu Aug 17 17:53:31 2017 -0700

    genirq: Add handle_fasteoi_{level,edge}_irq flow handlers
    
    Follow-on patch for gpio-thunderx uses a irqdomain hierarchy which
    requires slightly different flow handlers, add them to chip.c which
    contains most of the other flow handlers.  Make these conditionally
    compiled based on CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-gpio@vger.kernel.org
    Link: http://lkml.kernel.org/r/1503017616-3252-3-git-send-email-david.daney@cavium.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d2d543794093..d4728bf6a537 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -568,6 +568,8 @@ extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
 extern int irq_chip_pm_get(struct irq_data *data);
 extern int irq_chip_pm_put(struct irq_data *data);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+extern void handle_fasteoi_ack_irq(struct irq_desc *desc);
+extern void handle_fasteoi_mask_irq(struct irq_desc *desc);
 extern void irq_chip_enable_parent(struct irq_data *data);
 extern void irq_chip_disable_parent(struct irq_data *data);
 extern void irq_chip_ack_parent(struct irq_data *data);

commit 74def747bcd09692bdbf8c6a15350795b0f11ca8
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Aug 18 09:39:14 2017 +0100

    genirq: Restrict effective affinity to interrupts actually using it
    
    Just because CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK is selected
    doesn't mean that all the interrupts are using the effective
    affinity mask. For a number of them, this mask is likely to
    be empty.
    
    In order to deal with this, let's restrict the use of the
    effective affinity mask to these interrupts that have a non empty
    effective affinity.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Wei Xu <xuwei5@hisilicon.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: http://lkml.kernel.org/r/20170818083925.10108-2-marc.zyngier@arm.com

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d2d543794093..dcfac6c8ba18 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -781,7 +781,10 @@ static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 static inline
 struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
 {
-	return d->common->effective_affinity;
+	if (!cpumask_empty(d->common->effective_affinity))
+		return d->common->effective_affinity;
+
+	return d->common->affinity;
 }
 static inline void irq_data_update_effective_affinity(struct irq_data *d,
 						      const struct cpumask *m)

commit 8397913303abc9333f376a518a8368fa22ca5e6e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 27 12:21:11 2017 +0200

    genirq/cpuhotplug: Revert "Set force affinity flag on hotplug migration"
    
    That commit was part of the changes moving x86 to the generic CPU hotplug
    interrupt migration code. The force flag was required on x86 before the
    hierarchical irqdomain rework, but invoking set_affinity() with force=true
    stayed and had no side effects.
    
    At some point in the past, the force flag got repurposed to support the
    exynos timer interrupt affinity setting to a not yet online CPU, so the
    interrupt controller callback does not verify the supplied affinity mask
    against cpu_online_mask.
    
    Setting the flag in the CPU hotplug code causes the cpu online masking to
    be blocked on these irq controllers and results in potentially affining an
    interrupt to the CPU which is unplugged, i.e. instead of moving it away,
    it's just reassigned to it.
    
    As the force flags is not longer needed on x86, it's safe to revert that
    patch so the ARM irqchips which use the force flag work again.
    
    Add comments to that effect, so this won't happen again.
    
    Note: The online mask handling should be done in the generic code and the
    force flag and the masking in the irq chips removed all together, but
    that's not a change possible for 4.13.
    
    Fixes: 77f85e66aa8b ("genirq/cpuhotplug: Set force affinity flag on hotplug migration")
    Reported-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1707271217590.3109@nanos
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 00db35b61e9e..d2d543794093 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -388,7 +388,12 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_mask_ack:	ack and mask an interrupt source
  * @irq_unmask:		unmask an interrupt source
  * @irq_eoi:		end of interrupt
- * @irq_set_affinity:	set the CPU affinity on SMP machines
+ * @irq_set_affinity:	Set the CPU affinity on SMP machines. If the force
+ *			argument is true, it tells the driver to
+ *			unconditionally apply the affinity setting. Sanity
+ *			checks against the supplied affinity mask are not
+ *			required. This is used for CPU hotplug where the
+ *			target CPU is not yet set in the cpu_online_mask.
  * @irq_retrigger:	resend an IRQ to the CPU
  * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
  * @irq_set_wake:	enable/disable power-management wake-on of an IRQ

commit d52dd44175bd27ad9d8e34a994fb80877c1f6d61
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:52 2017 +0200

    genirq: Introduce IRQD_SINGLE_TARGET flag
    
    Many interrupt chips allow only a single CPU as interrupt target. The core
    code has no knowledge about that. That's unfortunate as it could avoid
    trying to readd a newly online CPU to the effective affinity mask.
    
    Add the status flag and the necessary accessors.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235447.352343969@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 19cea6326599..00db35b61e9e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -209,6 +209,7 @@ struct irq_data {
  * IRQD_IRQ_STARTED		- Startup state of the interrupt
  * IRQD_MANAGED_SHUTDOWN	- Interrupt was shutdown due to empty affinity
  *				  mask. Applies only to affinity managed irqs.
+ * IRQD_SINGLE_TARGET		- IRQ allows only a single affinity target
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -228,6 +229,7 @@ enum {
 	IRQD_AFFINITY_MANAGED		= (1 << 21),
 	IRQD_IRQ_STARTED		= (1 << 22),
 	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
+	IRQD_SINGLE_TARGET		= (1 << 24),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -276,6 +278,20 @@ static inline bool irqd_is_level_type(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_LEVEL;
 }
 
+/*
+ * Must only be called of irqchip.irq_set_affinity() or low level
+ * hieararchy domain allocation functions.
+ */
+static inline void irqd_set_single_target(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_SINGLE_TARGET;
+}
+
+static inline bool irqd_is_single_target(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_SINGLE_TARGET;
+}
+
 static inline bool irqd_is_wakeup_set(struct irq_data *d)
 {
 	return __irqd_to_state(d) & IRQD_WAKEUP_STATE;

commit c5cb83bb337c25caae995d992d1cdf9b317f83de
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:51 2017 +0200

    genirq/cpuhotplug: Handle managed IRQs on CPU hotplug
    
    If a CPU goes offline, interrupts affine to the CPU are moved away. If the
    outgoing CPU is the last CPU in the affinity mask the migration code breaks
    the affinity and sets it it all online cpus.
    
    This is a problem for affinity managed interrupts as CPU hotplug is often
    used for power management purposes. If the affinity is broken, the
    interrupt is not longer affine to the CPUs to which it was allocated.
    
    The affinity spreading allows to lay out multi queue devices in a way that
    they are assigned to a single CPU or a group of CPUs. If the last CPU goes
    offline, then the queue is not longer used, so the interrupt can be
    shutdown gracefully and parked until one of the assigned CPUs comes online
    again.
    
    Add a graceful shutdown mechanism into the irq affinity breaking code path,
    mark the irq as MANAGED_SHUTDOWN and leave the affinity mask unmodified.
    
    In the online path, scan the active interrupts for managed interrupts and
    if the interrupt is functional and the newly online CPU is part of the
    affinity mask, restart the interrupt if it is marked MANAGED_SHUTDOWN or if
    the interrupts is started up, try to add the CPU back to the effective
    affinity mask.
    
    Originally-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20170619235447.273417334@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 807042b46af1..19cea6326599 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -500,7 +500,12 @@ extern int irq_set_affinity_locked(struct irq_data *data,
 				   const struct cpumask *cpumask, bool force);
 extern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);
 
+#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_IRQ_MIGRATION)
 extern void irq_migrate_all_off_this_cpu(void);
+extern int irq_affinity_online_cpu(unsigned int cpu);
+#else
+# define irq_affinity_online_cpu	NULL
+#endif
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);

commit 761ea388e8c4e3ac883a94e16bcc8c51fa419d4f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:50 2017 +0200

    genirq: Handle managed irqs gracefully in irq_startup()
    
    Affinity managed interrupts should keep their assigned affinity accross CPU
    hotplug. To avoid magic hackery in device drivers, the core code shall
    manage them transparently and set these interrupts into a managed shutdown
    state when the last CPU of the assigned affinity mask goes offline. The
    interrupt will be restarted when one of the CPUs in the assigned affinity
    mask comes back online.
    
    Add the necessary logic to irq_startup(). If an interrupt is requested and
    started up, the code checks whether it is affinity managed and if so, it
    checks whether a CPU in the interrupts affinity mask is online. If not, it
    puts the interrupt into managed shutdown state.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235447.189851170@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0e37276c5315..807042b46af1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -346,7 +346,7 @@ static inline bool irqd_is_started(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_IRQ_STARTED;
 }
 
-static inline bool irqd_is_managed_shutdown(struct irq_data *d)
+static inline bool irqd_is_managed_and_shutdown(struct irq_data *d)
 {
 	return __irqd_to_state(d) & IRQD_MANAGED_SHUTDOWN;
 }

commit 54fdf6a0875ca380647ac1cc9b5b8f2dbbbfa131
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:47 2017 +0200

    genirq: Introduce IRQD_MANAGED_SHUTDOWN
    
    Affinity managed interrupts should keep their assigned affinity accross CPU
    hotplug. To avoid magic hackery in device drivers, the core code shall
    manage them transparently. This will set these interrupts into a managed
    shutdown state when the last CPU of the assigned affinity mask goes
    offline. The interrupt will be restarted when one of the CPUs in the
    assigned affinity mask comes back online.
    
    Introduce the necessary state flag and the accessor functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.954523476@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4087ef268ba9..0e37276c5315 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -207,6 +207,8 @@ struct irq_data {
  * IRQD_FORWARDED_TO_VCPU	- The interrupt is forwarded to a VCPU
  * IRQD_AFFINITY_MANAGED	- Affinity is auto-managed by the kernel
  * IRQD_IRQ_STARTED		- Startup state of the interrupt
+ * IRQD_MANAGED_SHUTDOWN	- Interrupt was shutdown due to empty affinity
+ *				  mask. Applies only to affinity managed irqs.
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -225,6 +227,7 @@ enum {
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 	IRQD_AFFINITY_MANAGED		= (1 << 21),
 	IRQD_IRQ_STARTED		= (1 << 22),
+	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -343,6 +346,11 @@ static inline bool irqd_is_started(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_IRQ_STARTED;
 }
 
+static inline bool irqd_is_managed_shutdown(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_MANAGED_SHUTDOWN;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit 0d3f54257dc300f2db480d6a46b34bdb87f18c1b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:38 2017 +0200

    genirq: Introduce effective affinity mask
    
    There is currently no way to evaluate the effective affinity mask of a
    given interrupt. Many irq chips allow only a single target CPU or a subset
    of CPUs in the affinity mask.
    
    Updating the mask at the time of setting the affinity to the subset would
    be counterproductive because information for cpu hotplug about assigned
    interrupt affinities gets lost. On CPU hotplug it's also pointless to force
    migrate an interrupt, which is not targeted at the CPU effectively. But
    currently the information is not available.
    
    Provide a seperate mask to be updated by the irq_chip->irq_set_affinity()
    implementations. Implement the read only proc files so the user can see the
    effective mask as well w/o trying to deduce it from /proc/interrupts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235446.247834245@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2b7e5a70d05f..4087ef268ba9 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -137,6 +137,9 @@ struct irq_domain;
  * @affinity:		IRQ affinity on SMP. If this is an IPI
  *			related irq, then this is the mask of the
  *			CPUs to which an IPI can be sent.
+ * @effective_affinity:	The effective IRQ affinity on SMP as some irq
+ *			chips do not allow multi CPU destinations.
+ *			A subset of @affinity.
  * @msi_desc:		MSI descriptor
  * @ipi_offset:		Offset of first IPI target cpu in @affinity. Optional.
  */
@@ -148,6 +151,9 @@ struct irq_common_data {
 	void			*handler_data;
 	struct msi_desc		*msi_desc;
 	cpumask_var_t		affinity;
+#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK
+	cpumask_var_t		effective_affinity;
+#endif
 #ifdef CONFIG_GENERIC_IRQ_IPI
 	unsigned int		ipi_offset;
 #endif
@@ -737,6 +743,29 @@ static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 	return d->common->affinity;
 }
 
+#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK
+static inline
+struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
+{
+	return d->common->effective_affinity;
+}
+static inline void irq_data_update_effective_affinity(struct irq_data *d,
+						      const struct cpumask *m)
+{
+	cpumask_copy(d->common->effective_affinity, m);
+}
+#else
+static inline void irq_data_update_effective_affinity(struct irq_data *d,
+						      const struct cpumask *m)
+{
+}
+static inline
+struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
+{
+	return d->common->affinity;
+}
+#endif
+
 unsigned int arch_dynirq_lower_bound(unsigned int from);
 
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,

commit 36d84fb45140f151fa4e145381dbce5e5ffed24d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:34 2017 +0200

    genirq: Move irq_fixup_move_pending() to core
    
    Now that x86 uses the generic code, the function declaration and inline
    stub can move to the core internal header.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235445.928156166@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 299271a4953c..2b7e5a70d05f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -492,15 +492,10 @@ extern void irq_migrate_all_off_this_cpu(void);
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);
 void irq_force_complete_move(struct irq_desc *desc);
-bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);
 #else
 static inline void irq_move_irq(struct irq_data *data) { }
 static inline void irq_move_masked_irq(struct irq_data *data) { }
 static inline void irq_force_complete_move(struct irq_desc *desc) { }
-static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
-{
-	return false;
-}
 #endif
 
 extern int no_irq_affinity;

commit f0383c24b4855f6a4b5a358c7b2d2c16e0437e9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:29 2017 +0200

    genirq/cpuhotplug: Add support for cleaning up move in progress
    
    In order to move x86 to the generic hotplug migration code, add support for
    cleaning up move in progress bits.
    
    On architectures which have this x86 specific (mis)feature not enabled,
    this is optimized out by the compiler.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235445.525817311@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d008065e2f4d..299271a4953c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -491,10 +491,12 @@ extern void irq_migrate_all_off_this_cpu(void);
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);
+void irq_force_complete_move(struct irq_desc *desc);
 bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);
 #else
 static inline void irq_move_irq(struct irq_data *data) { }
 static inline void irq_move_masked_irq(struct irq_data *data) { }
+static inline void irq_force_complete_move(struct irq_desc *desc) { }
 static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
 {
 	return false;

commit cdd16365b0bd7c0cd19e2cc768b6bdc8021f32c3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:19 2017 +0200

    genirq: Provide irq_fixup_move_pending()
    
    If an CPU goes offline, the interrupts are migrated away, but a eventually
    pending interrupt move, which has not yet been made effective is kept
    pending even if the outgoing CPU is the sole target of the pending affinity
    mask. What's worse is, that the pending affinity mask is discarded even if
    it would contain a valid subset of the online CPUs.
    
    Implement a helper function which allows to avoid these issues.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.691345468@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7e62e10e5856..d008065e2f4d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -491,9 +491,14 @@ extern void irq_migrate_all_off_this_cpu(void);
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);
+bool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);
 #else
 static inline void irq_move_irq(struct irq_data *data) { }
 static inline void irq_move_masked_irq(struct irq_data *data) { }
+static inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)
+{
+	return false;
+}
 #endif
 
 extern int no_irq_affinity;

commit 1bb0401680da156ce1549e915e711bf5b2534cc5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:18 2017 +0200

    genirq: Add missing comment for IRQD_STARTED
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.614913014@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d996314b6522..7e62e10e5856 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -200,6 +200,7 @@ struct irq_data {
  * IRQD_WAKEUP_ARMED		- Wakeup mode armed
  * IRQD_FORWARDED_TO_VCPU	- The interrupt is forwarded to a VCPU
  * IRQD_AFFINITY_MANAGED	- Affinity is auto-managed by the kernel
+ * IRQD_IRQ_STARTED		- Startup state of the interrupt
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,

commit 30fd8fc5c91973485705f83c7efe9588b8e6f371
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:07:00 2017 +0200

    irq/generic-chip: Provide devm_irq_setup_generic_chip()
    
    Provide a resource managed variant of irq_setup_generic_chip().
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-6-git-send-email-brgl@bgdev.pl

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 64ae54673e08..d996314b6522 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -962,6 +962,9 @@ struct irq_chip_generic *
 devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
 			    unsigned int irq_base, void __iomem *reg_base,
 			    irq_flow_handler_t handler);
+int devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,
+				u32 msk, enum irq_gc_flags flags,
+				unsigned int clr, unsigned int set);
 
 struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);
 

commit 1c3e36309fe2e94b8a889fa32cb5c871434f8ed6
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:06:59 2017 +0200

    irq/generic-chip: Provide devm_irq_alloc_generic_chip()
    
    Provide a resource managed variant of irq_alloc_generic_chip().
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-5-git-send-email-brgl@bgdev.pl

diff --git a/include/linux/irq.h b/include/linux/irq.h
index dc63aa10ce70..64ae54673e08 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -958,6 +958,11 @@ int irq_setup_alt_chip(struct irq_data *d, unsigned int type);
 void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,
 			     unsigned int clr, unsigned int set);
 
+struct irq_chip_generic *
+devm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,
+			    unsigned int irq_base, void __iomem *reg_base,
+			    irq_flow_handler_t handler);
+
 struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);
 
 int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,

commit 32bb6cbb3b4ea5ca24e3fa13e11772c192616e04
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:06:57 2017 +0200

    irq/generic-chip: Provide irq_destroy_generic_chip()
    
    Most users of irq_alloc_generic_chip() call irq_setup_generic_chip()
    too. To simplify the cleanup provide a function that both removes a
    generic chip and frees its memory.
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-3-git-send-email-brgl@bgdev.pl

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2c957fe5d9d7..dc63aa10ce70 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -979,6 +979,14 @@ static inline void irq_free_generic_chip(struct irq_chip_generic *gc)
 	kfree(gc);
 }
 
+static inline void irq_destroy_generic_chip(struct irq_chip_generic *gc,
+					    u32 msk, unsigned int clr,
+					    unsigned int set)
+{
+	irq_remove_generic_chip(gc, msk, clr, set);
+	irq_free_generic_chip(gc);
+}
+
 static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
 {
 	return container_of(d->chip, struct irq_chip_type, chip);

commit 707188f5f2421a304324e6ef3aaf4413cfab0f3d
Author: Bartosz Golaszewski <brgl@bgdev.pl>
Date:   Wed May 31 18:06:56 2017 +0200

    irq/generic-chip: Provide irq_free_generic_chip()
    
    Currently there's no way for users of irq_alloc_generic_chip() to free
    the allocated memory other than calling kfree() manually on the
    returned pointer. This may lead to errors if the internals of
    irq_alloc_generic_chip() ever change. Provide a routine to free the
    generic chip.
    
    Signed-off-by: Bartosz Golaszewski <brgl@bgdev.pl>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1496246820-13250-2-git-send-email-brgl@bgdev.pl

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 94d1ad6ffdd4..2c957fe5d9d7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -22,6 +22,7 @@
 #include <linux/topology.h>
 #include <linux/wait.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -973,6 +974,11 @@ int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,
 					 handler, clr, set, flags);	\
 })
 
+static inline void irq_free_generic_chip(struct irq_chip_generic *gc)
+{
+	kfree(gc);
+}
+
 static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
 {
 	return container_of(d->chip, struct irq_chip_type, chip);

commit 201d7f47f34bd7cb19161d0426f13b141e381f30
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 31 11:58:32 2017 +0200

    genirq: Handle NOAUTOEN interrupt setup proper
    
    If an interrupt is marked NOAUTOEN then request_irq() installs the action,
    but does not enable the interrupt via startup_irq().  The interrupt is
    enabled via enable_irq() later from the driver. enable_irq() calls
    irq_enable().
    
    That means that for interrupts which have a irq_startup() callback this
    callback is never invoked. Neither is irq_domain_activate_irq() invoked for
    such interrupts.
    
    If an interrupt depends on irq_startup() or irq_domain_activate_irq() then
    the enable via irq_enable() is not enough.
    
    Add a status flag IRQD_IRQ_STARTED_UP and use this to select the proper
    mechanism in enable_irq(). Use the flag also to avoid pointless calls into
    the low level functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: dianders@chromium.org
    Cc: jeffy <jeffy.chen@rock-chips.com>
    Cc: Brian Norris <briannorris@chromium.org>
    Cc: tfiga@chromium.org
    Link: http://lkml.kernel.org/r/20170531100212.130986205@linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f887351aa80e..94d1ad6ffdd4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -216,6 +216,7 @@ enum {
 	IRQD_WAKEUP_ARMED		= (1 << 19),
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 	IRQD_AFFINITY_MANAGED		= (1 << 21),
+	IRQD_IRQ_STARTED		= (1 << 22),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -329,6 +330,11 @@ static inline void irqd_clr_activated(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_ACTIVATED;
 }
 
+static inline bool irqd_is_started(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_IRQ_STARTED;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit 1cd4027cfe33390dc3f442aea8e7caeeeaa861a1
Merge: 20dcfe1b7df4 3900dea4cda7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 20 10:52:23 2017 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "This update provides:
    
       - Yet another two irq controller chip drivers
    
       - A few updates and fixes for GICV3
    
       - A resource managed function for interrupt allocation
    
       - Fixes, updates and enhancements all over the place"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      irqchip/qcom: Fix error handling
      genirq: Clarify logic calculating bogus irqreturn_t values
      genirq/msi: Add stubs for get_cached_msi_msg/pci_write_msi_msg
      genirq/devres: Use dev_name(dev) as default for devname
      genirq: Fix /proc/interrupts output alignment
      irqdesc: Add a resource managed version of irq_alloc_descs()
      irqchip/gic-v3-its: Zero command on allocation
      irqchip/gic-v3-its: Fix command buffer allocation
      irqchip/mips-gic: Fix local interrupts
      irqchip: Add a driver for Cortina Gemini
      irqchip: DT bindings for Cortina Gemini irqchip
      irqchip/gic-v3: Remove duplicate definition of GICD_TYPER_LPIS
      irqchip/gic-v3-its: Rename MAPVI to MAPTI
      irqchip/gic-v3-its: Drop deprecated GITS_BASER_TYPE_CPU
      irqchip/gic-v3-its: Refactor command encoding
      irqchip/gic-v3-its: Enable cacheable attribute Read-allocate hints
      irqchip/qcom: Add IRQ combiner driver
      ACPI: Add support for ResourceSource/IRQ domain mapping
      ACPI: Generic GSI: Do not attempt to map non-GSI IRQs during bus scan
      irq/platform-msi: Fix comment about maximal MSIs

commit 2b5e77308f3356faad640b24af6dc5aa7233eb2d
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Feb 10 13:23:23 2017 +0100

    irqdesc: Add a resource managed version of irq_alloc_descs()
    
    Add a devres flavor of __devm_irq_alloc_descs() and corresponding
    helper macros.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-doc@vger.kernel.org
    Cc: Jonathan Corbet <corbet@lwn.net>
    Link: http://lkml.kernel.org/r/1486729403-21132-1-git-send-email-bgolaszewski@baylibre.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e79875574b39..d915caecafa1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -715,6 +715,10 @@ unsigned int arch_dynirq_lower_bound(unsigned int from);
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 		      struct module *owner, const struct cpumask *affinity);
 
+int __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,
+			   unsigned int cnt, int node, struct module *owner,
+			   const struct cpumask *affinity);
+
 /* use macros to avoid needing export.h for THIS_MODULE */
 #define irq_alloc_descs(irq, from, cnt, node)	\
 	__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE, NULL)
@@ -731,6 +735,21 @@ int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 #define irq_alloc_descs_from(from, cnt, node)	\
 	irq_alloc_descs(-1, from, cnt, node)
 
+#define devm_irq_alloc_descs(dev, irq, from, cnt, node)		\
+	__devm_irq_alloc_descs(dev, irq, from, cnt, node, THIS_MODULE, NULL)
+
+#define devm_irq_alloc_desc(dev, node)				\
+	devm_irq_alloc_descs(dev, -1, 0, 1, node)
+
+#define devm_irq_alloc_desc_at(dev, at, node)			\
+	devm_irq_alloc_descs(dev, at, at, 1, node)
+
+#define devm_irq_alloc_desc_from(dev, from, node)		\
+	devm_irq_alloc_descs(dev, -1, from, 1, node)
+
+#define devm_irq_alloc_descs_from(dev, from, cnt, node)		\
+	devm_irq_alloc_descs(dev, -1, from, cnt, node)
+
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 static inline void irq_free_desc(unsigned int irq)
 {

commit 08d85f3ea99f1eeafc4e8507936190e86a16ee8c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jan 17 16:00:48 2017 +0000

    irqdomain: Avoid activating interrupts more than once
    
    Since commit f3b0946d629c ("genirq/msi: Make sure PCI MSIs are
    activated early"), we can end-up activating a PCI/MSI twice (once
    at allocation time, and once at startup time).
    
    This is normally of no consequences, except that there is some
    HW out there that may misbehave if activate is used more than once
    (the GICv3 ITS, for example, uses the activate callback
    to issue the MAPVI command, and the architecture spec says that
    "If there is an existing mapping for the EventID-DeviceID
    combination, behavior is UNPREDICTABLE").
    
    While this could be worked around in each individual driver, it may
    make more sense to tackle the issue at the core level. In order to
    avoid getting in that situation, let's have a per-interrupt flag
    to remember if we have already activated that interrupt or not.
    
    Fixes: f3b0946d629c ("genirq/msi: Make sure PCI MSIs are activated early")
    Reported-and-tested-by: Andre Przywara <andre.przywara@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1484668848-24361-1-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e79875574b39..39e3254e5769 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -184,6 +184,7 @@ struct irq_data {
  *
  * IRQD_TRIGGER_MASK		- Mask for the trigger type bits
  * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
+ * IRQD_ACTIVATED		- Interrupt has already been activated
  * IRQD_NO_BALANCING		- Balancing disabled for this IRQ
  * IRQD_PER_CPU			- Interrupt is per cpu
  * IRQD_AFFINITY_SET		- Interrupt affinity was set
@@ -202,6 +203,7 @@ struct irq_data {
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
 	IRQD_SETAFFINITY_PENDING	= (1 <<  8),
+	IRQD_ACTIVATED			= (1 <<  9),
 	IRQD_NO_BALANCING		= (1 << 10),
 	IRQD_PER_CPU			= (1 << 11),
 	IRQD_AFFINITY_SET		= (1 << 12),
@@ -312,6 +314,21 @@ static inline bool irqd_affinity_is_managed(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_AFFINITY_MANAGED;
 }
 
+static inline bool irqd_is_activated(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_ACTIVATED;
+}
+
+static inline void irqd_set_activated(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_ACTIVATED;
+}
+
+static inline void irqd_clr_activated(struct irq_data *d)
+{
+	__irqd_to_state(d) &= ~IRQD_ACTIVATED;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit 464b5847e61085f81bb99ce48eb427a0dc7617dc
Merge: 0a30d6919560 e875bd66dfb6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 20 23:20:32 2016 +0200

    Merge branch 'irq/urgent' into irq/core
    
    Merge urgent fixes so pending patches for 4.9 can be applied.

commit ebf9ff753c041b296241990aef76163bbb2cc9c8
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Sep 13 15:58:28 2016 +0200

    genirq: Provide irq_gc_{lock_irqsave,unlock_irqrestore}() helpers
    
    Some irqchip drivers need to take the generic chip lock outside of the
    irq context.
    
    Provide the irq_gc_{lock_irqsave,unlock_irqrestore}() helpers to allow
    one to disable irqs while entering a critical section protected by
    gc->lock.
    
    Note that we do not provide optimized version of these helpers for !SMP,
    because they are not called from the hot-path.
    
    [ tglx: Added a comment when these helpers should be [not] used ]
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: stable@vger.kernel.org
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Link: http://lkml.kernel.org/r/1473775109-4192-1-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b52424eaa0ed..0ac26c892fe2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -945,6 +945,16 @@ static inline void irq_gc_lock(struct irq_chip_generic *gc) { }
 static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
 #endif
 
+/*
+ * The irqsave variants are for usage in non interrupt code. Do not use
+ * them in irq_chip callbacks. Use irq_gc_lock() instead.
+ */
+#define irq_gc_lock_irqsave(gc, flags)	\
+	raw_spin_lock_irqsave(&(gc)->lock, flags)
+
+#define irq_gc_unlock_irqrestore(gc, flags)	\
+	raw_spin_unlock_irqrestore(&(gc)->lock, flags)
+
 static inline void irq_reg_writel(struct irq_chip_generic *gc,
 				  u32 val, int reg_offset)
 {

commit f88eecfe2f22b2790e7527c0aaec14ea175919de
Author: Sebastian Frias <sf84@laposte.net>
Date:   Tue Aug 16 16:05:08 2016 +0200

    genirq/generic_chip: Verify irqs_per_chip <= 32
    
    Most (if not all) code here implicitly assumes that the maximum number of
    IRQs per chip will be 32, and thus uses 'u32' or 'unsigned long' for many
    tasks (for example "struct irq_data" declares its 'mask' field as 'u32',
    and "struct irq_chip_generic" declares its 'installed' field as 'unsigned
    long')
    
    However, there is no check to verify that irqs_per_chip is <= 32.  Hence,
    calling irq_alloc_domain_generic_chips() with a bigger value will result in
    unexpected results.
    
    Provide a wrapper with a MAYBE_BUILD_BUG_ON(nrirqs >= 32) to catch such
    cases.
    
    [ tglx: Reduced changelog to the essential information ]
    
    Signed-off-by: Sebastian Frias <sf84@laposte.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mason <slash.tmp@free.fr>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/57B31D94.5040701@laposte.net
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b52424eaa0ed..603986741f2c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -916,12 +916,20 @@ void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,
 			     unsigned int clr, unsigned int set);
 
 struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);
-int irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,
-				   int num_ct, const char *name,
-				   irq_flow_handler_t handler,
-				   unsigned int clr, unsigned int set,
-				   enum irq_gc_flags flags);
 
+int __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,
+				     int num_ct, const char *name,
+				     irq_flow_handler_t handler,
+				     unsigned int clr, unsigned int set,
+				     enum irq_gc_flags flags);
+
+#define irq_alloc_domain_generic_chips(d, irqs_per_chip, num_ct, name,	\
+				       handler,	clr, set, flags)	\
+({									\
+	MAYBE_BUILD_BUG_ON(irqs_per_chip > 32);				\
+	__irq_alloc_domain_generic_chips(d, irqs_per_chip, num_ct, name,\
+					 handler, clr, set, flags);	\
+})
 
 static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
 {

commit 8658be133baa92c06b6d832a436d437deb2e2a22
Merge: 4030103b9b2e 5e385a6ef31f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 12:26:05 2016 +0200

    Merge branch 'irq/for-block' into irq/core
    
    Pull the irq affinity managing code which is in a seperate branch for block
    developers to pull.

commit 06ee6d571f0e350253a8fc3492316b2be007fae2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 17:39:24 2016 +0900

    genirq: Add affinity hint to irq allocation
    
    Add an extra argument to the irq(domain) allocation functions, so we can hand
    down affinity hints to the allocator. Thats necessary to implement proper
    support for multiqueue devices.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-nvme@lists.infradead.org
    Cc: axboe@fb.com
    Cc: agordeev@redhat.com
    Link: http://lkml.kernel.org/r/1467621574-8277-4-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f6074813688d..39ce46ac5c18 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -708,11 +708,11 @@ static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 unsigned int arch_dynirq_lower_bound(unsigned int from);
 
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
-		struct module *owner);
+		      struct module *owner, const struct cpumask *affinity);
 
 /* use macros to avoid needing export.h for THIS_MODULE */
 #define irq_alloc_descs(irq, from, cnt, node)	\
-	__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE)
+	__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE, NULL)
 
 #define irq_alloc_desc(node)			\
 	irq_alloc_descs(-1, 0, 1, node)

commit 9c2555835bb3d34dfac52a0be943dcc4bedd650f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 4 17:39:23 2016 +0900

    genirq: Introduce IRQD_AFFINITY_MANAGED flag
    
    Interupts marked with this flag are excluded from user space interrupt
    affinity changes. Contrary to the IRQ_NO_BALANCING flag, the kernel internal
    affinity mechanism is not blocked.
    
    This flag will be used for multi-queue device interrupts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: linux-block@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-nvme@lists.infradead.org
    Cc: axboe@fb.com
    Cc: agordeev@redhat.com
    Link: http://lkml.kernel.org/r/1467621574-8277-3-git-send-email-hch@lst.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4d758a7c604a..f6074813688d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -197,6 +197,7 @@ struct irq_data {
  * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt
  * IRQD_WAKEUP_ARMED		- Wakeup mode armed
  * IRQD_FORWARDED_TO_VCPU	- The interrupt is forwarded to a VCPU
+ * IRQD_AFFINITY_MANAGED	- Affinity is auto-managed by the kernel
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -212,6 +213,7 @@ enum {
 	IRQD_IRQ_INPROGRESS		= (1 << 18),
 	IRQD_WAKEUP_ARMED		= (1 << 19),
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
+	IRQD_AFFINITY_MANAGED		= (1 << 21),
 };
 
 #define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
@@ -305,6 +307,11 @@ static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
 }
 
+static inline bool irqd_affinity_is_managed(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_AFFINITY_MANAGED;
+}
+
 #undef __irqd_to_state
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit edd14cfebc4404698544d407ecf8eda6e19aa19e
Author: Keith Busch <keith.busch@intel.com>
Date:   Fri Jun 17 16:00:20 2016 -0600

    genirq: Add untracked irq handler
    
    This adds a software irq handler for controllers that multiplex
    interrupts from multiple devices, but don't know which device generated
    the interrupt. For these devices, the irq handler that demuxes must
    check every action for every software irq using the same h/w irq in order
    to find out which device generated the interrupt. This will inevitably
    trigger spurious interrupt detection if we are noting the irq.
    
    The new irq handler does not track the handling for spurious interrupt
    detection. An irq that uses this also won't get stats tracked since it
    didn't generate the interrupt, nor added to randomness since they are
    not random.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: linux-pci@vger.kernel.org
    Cc: Jon Derrick <jonathan.derrick@intel.com>
    Link: http://lkml.kernel.org/r/1466200821-29159-1-git-send-email-keith.busch@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6c92a847394d..562cef010aa8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -484,6 +484,7 @@ extern void handle_fasteoi_irq(struct irq_desc *desc);
 extern void handle_edge_irq(struct irq_desc *desc);
 extern void handle_edge_eoi_irq(struct irq_desc *desc);
 extern void handle_simple_irq(struct irq_desc *desc);
+extern void handle_untracked_irq(struct irq_desc *desc);
 extern void handle_percpu_irq(struct irq_desc *desc);
 extern void handle_percpu_devid_irq(struct irq_desc *desc);
 extern void handle_bad_irq(struct irq_desc *desc);

commit be45beb2df6909d42a6b3b0052601b3eef878fc0
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Jun 7 16:12:29 2016 +0100

    genirq: Add runtime power management support for IRQ chips
    
    Some IRQ chips may be located in a power domain outside of the CPU
    subsystem and hence will require device specific runtime power
    management. In order to support such IRQ chips, add a pointer for a
    device structure to the irq_chip structure, and if this pointer is
    populated by the IRQ chip driver and CONFIG_PM is selected in the kernel
    configuration, then the pm_runtime_get/put APIs for this chip will be
    called when an IRQ is requested/freed, respectively.
    
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4d758a7c604a..6c92a847394d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -315,6 +315,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *
+ * @parent_device:	pointer to parent device for irqchip
  * @name:		name for /proc/interrupts
  * @irq_startup:	start up the interrupt (defaults to ->enable if NULL)
  * @irq_shutdown:	shut down the interrupt (defaults to ->disable if NULL)
@@ -354,6 +355,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @flags:		chip specific flags
  */
 struct irq_chip {
+	struct device	*parent_device;
 	const char	*name;
 	unsigned int	(*irq_startup)(struct irq_data *data);
 	void		(*irq_shutdown)(struct irq_data *data);
@@ -488,6 +490,8 @@ extern void handle_bad_irq(struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
 extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
+extern int irq_chip_pm_get(struct irq_data *data);
+extern int irq_chip_pm_put(struct irq_data *data);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern void irq_chip_enable_parent(struct irq_data *data);
 extern void irq_chip_disable_parent(struct irq_data *data);

commit 222df54fd8b7641dcc81476f157806bb3144ee1d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Apr 11 09:57:52 2016 +0100

    genirq: Allow the affinity of a percpu interrupt to be set/retrieved
    
    In order to prepare the genirq layer for the concept of partitionned
    percpu interrupts, let's allow an affinity to be associated with
    such an interrupt. We introduce:
    
    - irq_set_percpu_devid_partition: flag an interrupt as a percpu-devid
      interrupt, and associate it with an affinity
    - irq_get_percpu_devid_partition: allow the affinity of that interrupt
      to be retrieved.
    
    This will allow a driver to discover which CPUs the per-cpu interrupt
    can actually fire on.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: devicetree@vger.kernel.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Link: http://lkml.kernel.org/r/1460365075-7316-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c4de62348ff2..4d758a7c604a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -530,6 +530,10 @@ static inline void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *c
 }
 
 extern int irq_set_percpu_devid(unsigned int irq);
+extern int irq_set_percpu_devid_partition(unsigned int irq,
+					  const struct cpumask *affinity);
+extern int irq_get_percpu_devid_partition(unsigned int irq,
+					  struct cpumask *affinity);
 
 extern void
 __irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,

commit df2e37c814d51692803245fcbecca360d4882e96
Merge: 8a284c062ec9 8e7fe2660d4a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 15 12:48:48 2016 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The 4.6 pile of irq updates contains:
    
       - Support for IPI irqdomains to support proper integration of IPIs to
         and from coprocessors.  The first user of this new facility is
         MIPS.  The relevant MIPS patches come with the core to avoid merge
         ordering issues and have been acked by Ralf.
    
       - A new command line option to set the default interrupt affinity
         mask at boot time.
    
       - Support for some more new ARM and MIPS interrupt controllers:
         tango, alpine-msix and bcm6345-l1
    
       - Two small cleanups for x86/apic which we merged into irq/core to
         avoid yet another branch in x86 with two tiny commits.
    
       - The usual set of updates, cleanups in drivers/irqchip.  Mostly in
         the area of ARM-GIC, arada-37-xp and atmel chips.  Nothing
         outstanding here"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (56 commits)
      irqchip/irq-alpine-msi: Release the correct domain on error
      irqchip/mxs: Fix error check of of_io_request_and_map()
      irqchip/sunxi-nmi: Fix error check of of_io_request_and_map()
      genirq: Export IRQ functions for module use
      irqchip/gic/realview: Support more RealView DCC variants
      Documentation/bindings: Document the Alpine MSIX driver
      irqchip: Add the Alpine MSIX interrupt controller
      irqchip/gic-v3: Always return IRQ_SET_MASK_OK_DONE in gic_set_affinity
      irqchip/gic-v3-its: Mark its_init() and its children as __init
      irqchip/gic-v3: Remove gic_root_node variable from the ITS code
      irqchip/gic-v3: ACPI: Add redistributor support via GICC structures
      irqchip/gic-v3: Add ACPI support for GICv3/4 initialization
      irqchip/gic-v3: Refactor gic_of_init() for GICv3 driver
      x86/apic: Deinline _flat_send_IPI_mask, save ~150 bytes
      x86/apic: Deinline __default_send_IPI_*, save ~200 bytes
      dt-bindings: interrupt-controller: Add SoC-specific compatible string to Marvell ODMI
      irqchip/mips-gic: Add new DT property to reserve IPIs
      MIPS: Delete smp-gic.c
      MIPS: Make smp CMP, CPS and MT use the new generic IPI functions
      MIPS: Add generic SMP IPI support
      ...

commit 3b8e29a82dd16c1f2061e0b955a71cd36eeb061b
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:22 2015 +0000

    genirq: Implement ipi_send_mask/single()
    
    Add APIs to send IPIs from driver and arch code.
    
    We have different functions because we allow architecture code to cache the
    irq descriptor to avoid lookups. Driver code has to use the irq number and is
    subject to more restrictive checks.
    
    [ tglx: Polish the implementation ]
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-12-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3b3a5b817469..d5ebd94822d2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -948,5 +948,9 @@ static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
 /* Contrary to Linux irqs, for hardware irqs the irq number 0 is valid */
 #define INVALID_HWIRQ	(~0UL)
 irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu);
+int __ipi_send_single(struct irq_desc *desc, unsigned int cpu);
+int __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest);
+int ipi_send_single(unsigned int virq, unsigned int cpu);
+int ipi_send_mask(unsigned int virq, const struct cpumask *dest);
 
 #endif /* _LINUX_IRQ_H */

commit 34dc1ae101018dbb50e1d04e88aa89052802a7db
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:21 2015 +0000

    genirq: Add send_ipi callbacks to irq_chip
    
    Introduce the new callbacks which can be used by the core code to implement a
    generic IPI send mechanism.
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-11-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 10273dce058a..3b3a5b817469 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -347,6 +347,8 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_get_irqchip_state:	return the internal state of an interrupt
  * @irq_set_irqchip_state:	set the internal state of a interrupt
  * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
+ * @ipi_send_single:	send a single IPI to destination cpus
+ * @ipi_send_mask:	send an IPI to destination cpus in cpumask
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -391,6 +393,9 @@ struct irq_chip {
 
 	int		(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);
 
+	void		(*ipi_send_single)(struct irq_data *data, unsigned int cpu);
+	void		(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);
+
 	unsigned long	flags;
 };
 

commit f9bce791ae2a1a10a965b30427f5507c1a77669f
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:20 2015 +0000

    genirq: Add a new function to get IPI reverse mapping
    
    When dealing with coprocessors we need to find out the actual hwirqs values to
    pass on to the firmware so that it knows what it needs to use to receive IPIs
    from and send IPIs to Linux cpus.
    
    [ tglx: Fixed the single hwirq IPI case. The hardware irq number does not
            change due to the cpu number ]
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-10-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 95f4f66f95f3..10273dce058a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -942,5 +942,6 @@ static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
 
 /* Contrary to Linux irqs, for hardware irqs the irq number 0 is valid */
 #define INVALID_HWIRQ	(~0UL)
+irq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu);
 
 #endif /* _LINUX_IRQ_H */

commit d17bf24e695290d3fe7943aca52ab48098a10653
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:19 2015 +0000

    genirq: Add a new generic IPI reservation code to irq core
    
    Add a generic mechanism to dynamically allocate an IPI. Depending on the
    underlying implementation this creates either a single Linux irq or a
    consective range of Linux irqs. The Linux irq is used later to send IPIs to
    other CPUs.
    
    [ tglx: Massaged the code and removed the 'consecutive mask' restriction for
            the single IRQ case ]
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-9-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a32b47fbf874..95f4f66f95f3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -940,4 +940,7 @@ static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
 		return readl(gc->reg_base + reg_offset);
 }
 
+/* Contrary to Linux irqs, for hardware irqs the irq number 0 is valid */
+#define INVALID_HWIRQ	(~0UL)
+
 #endif /* _LINUX_IRQ_H */

commit f256c9a0c54820ffef21b126f8226be2bece3dd7
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:16 2015 +0000

    genirq: Add ipi_offset to irq_common_data
    
    IPIs are always assumed to be consecutively allocated, hence virqs and hwirqs
    can be inferred by using CPU id as an offset. But the first cpu doesn't always
    have to start at offset 0. ipi_offset stores the position of the first cpu so
    that we can easily calculate the virq or hwirq of an IPI associated with a
    specific cpu.
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-6-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0817afd0d719..a32b47fbf874 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -137,6 +137,7 @@ struct irq_domain;
  *			related irq, then this is the mask of the
  *			CPUs to which an IPI can be sent.
  * @msi_desc:		MSI descriptor
+ * @ipi_offset:		Offset of first IPI target cpu in @affinity. Optional.
  */
 struct irq_common_data {
 	unsigned int		state_use_accessors;
@@ -146,6 +147,9 @@ struct irq_common_data {
 	void			*handler_data;
 	struct msi_desc		*msi_desc;
 	cpumask_var_t		affinity;
+#ifdef CONFIG_GENERIC_IRQ_IPI
+	unsigned int		ipi_offset;
+#endif
 };
 
 /**

commit 955bfe5912e7839abcc83694f06867535487404b
Author: Qais Yousef <qais.yousef@imgtec.com>
Date:   Tue Dec 8 13:20:17 2015 +0000

    genirq: Add an extra comment about the use of affinity in irq_common_data
    
    Affinity will have dual meaning depends on the type of the irq. If it is
    a normal irq, it'll have the standard affinity meaning.
    
    If it is an IPI, it will hold the mask of the cpus to which an IPI can be
    sent.
    
    Signed-off-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: <jason@lakedaemon.net>
    Cc: <marc.zyngier@arm.com>
    Cc: <jiang.liu@linux.intel.com>
    Cc: <ralf@linux-mips.org>
    Cc: <linux-mips@linux-mips.org>
    Cc: <lisa.parratt@imgtec.com>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Link: http://lkml.kernel.org/r/1449580830-23652-7-git-send-email-qais.yousef@imgtec.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3c1c96786248..0817afd0d719 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -133,7 +133,9 @@ struct irq_domain;
  *			Use accessor functions to deal with it
  * @node:		node index useful for balancing
  * @handler_data:	per-IRQ data for the irq_chip methods
- * @affinity:		IRQ affinity on SMP
+ * @affinity:		IRQ affinity on SMP. If this is an IPI
+ *			related irq, then this is the mask of the
+ *			CPUs to which an IPI can be sent.
  * @msi_desc:		MSI descriptor
  */
 struct irq_common_data {

commit b354286effa52da6cb1b1f16604d41ff81b8c445
Author: Boqun Feng <boqun.feng@gmail.com>
Date:   Tue Dec 29 12:18:48 2015 +0800

    irq: Privatize irq_common_data::state_use_accessors
    
    irq_common_data::state_use_accessors is not designed for public use.
    Therefore make it private so that people who write code accessing it
    directly will get blamed by sparse. Also #undef the macro
    __irqd_to_state after used in header files, so that the macro can't be
    misused.
    
    Signed-off-by: Boqun Feng <boqun.feng@gmail.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3c1c96786248..cd14cd4a22b4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -137,7 +137,7 @@ struct irq_domain;
  * @msi_desc:		MSI descriptor
  */
 struct irq_common_data {
-	unsigned int		state_use_accessors;
+	unsigned int		__private state_use_accessors;
 #ifdef CONFIG_NUMA
 	unsigned int		node;
 #endif
@@ -208,7 +208,7 @@ enum {
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 };
 
-#define __irqd_to_state(d)		((d)->common->state_use_accessors)
+#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
 {
@@ -299,6 +299,8 @@ static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
 }
 
+#undef __irqd_to_state
+
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
 {
 	return d->hwirq;

commit e9849777d0e27cdd2902805be51da73e7c79578c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 9 23:28:58 2015 +0200

    genirq: Add flag to force mask in disable_irq[_nosync]()
    
    If an irq chip does not implement the irq_disable callback, then we
    use a lazy approach for disabling the interrupt. That means that the
    interrupt is marked disabled, but the interrupt line is not
    immediately masked in the interrupt chip. It only becomes masked if
    the interrupt is raised while it's marked disabled. We use this to avoid
    possibly expensive mask/unmask operations for common case operations.
    
    Unfortunately there are devices which do not allow the interrupt to be
    disabled easily at the device level. They are forced to use
    disable_irq_nosync(). This can result in taking each interrupt twice.
    
    Instead of enforcing the non lazy mode on all interrupts of a irq
    chip, provide a settings flag, which can be set by the driver for that
    particular interrupt line.
    
    Reported-and-tested-by: Duc Dang <dhdang@apm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1510092348370.6097@nanos

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ba72b60b57b1..3c1c96786248 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -72,6 +72,7 @@ enum irqchip_irq_state;
  * IRQ_IS_POLLED		- Always polled by another interrupt. Exclude
  *				  it from the spurious interrupt detection
  *				  mechanism and from core side polling.
+ * IRQ_DISABLE_UNLAZY		- Disable lazy irq disable
  */
 enum {
 	IRQ_TYPE_NONE		= 0x00000000,
@@ -97,13 +98,14 @@ enum {
 	IRQ_NOTHREAD		= (1 << 16),
 	IRQ_PER_CPU_DEVID	= (1 << 17),
 	IRQ_IS_POLLED		= (1 << 18),
+	IRQ_DISABLE_UNLAZY	= (1 << 19),
 };
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
 	 IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID | \
-	 IRQ_IS_POLLED)
+	 IRQ_IS_POLLED | IRQ_DISABLE_UNLAZY)
 
 #define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
 

commit 9e7e2b0a6a005941a6854cdabae19c3d9e069dbe
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 1 15:54:53 2015 +0300

    genirq: Remove unused functions irqd_[set|clr]_chained_irq_inprogress()
    
    These two functions are not used anywhere in the kernel source tree so
    remove them.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Link: http://lkml.kernel.org/r/1443704093-36837-2-git-send-email-mika.westerberg@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7038f38a63c7..ba72b60b57b1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -297,21 +297,6 @@ static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
 	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
 }
 
-/*
- * Functions for chained handlers which can be enabled/disabled by the
- * standard disable_irq/enable_irq calls. Must be called with
- * irq_desc->lock held.
- */
-static inline void irqd_set_chained_irq_inprogress(struct irq_data *d)
-{
-	__irqd_to_state(d) |= IRQD_IRQ_INPROGRESS;
-}
-
-static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
-{
-	__irqd_to_state(d) &= ~IRQD_IRQ_INPROGRESS;
-}
-
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
 {
 	return d->hwirq;

commit 92068d17c20b218bf1e24505a3e08495476b0ebf
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 1 15:54:52 2015 +0300

    genirq: Fix typo in documentation of enumeration field name
    
    It should say IRQ_NESTED_THREAD instead of IRQ_NESTED_TRHEAD.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Link: http://lkml.kernel.org/r/1443704093-36837-1-git-send-email-mika.westerberg@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 45cc7299bb61..7038f38a63c7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -67,7 +67,7 @@ enum irqchip_irq_state;
  *				  request/setup_irq()
  * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
  * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
- * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
+ * IRQ_NESTED_THREAD		- Interrupt nests into another thread
  * IRQ_PER_CPU_DEVID		- Dev_id is a per-cpu variable
  * IRQ_IS_POLLED		- Always polled by another interrupt. Exclude
  *				  it from the spurious interrupt detection

commit f1e0bb0ad473a32d1b7e6d285ae9f7e47710bb5e
Author: Yang Yingliang <yangyingliang@huawei.com>
Date:   Thu Sep 24 17:32:13 2015 +0800

    genirq: Introduce generic irq migration for cpu hotunplug
    
    ARM and ARM64 have almost identical code for migrating interrupts on
    cpu hotunplug. Provide a generic version which can be used by both.
    
    The new code addresses a shortcoming in the ARM[64] variants which
    fails to update the affinity change in some cases. The solution for
    this is to use the core function irq_do_set_affinity() instead of open
    coding it.
    
    [ tglx: Added copyright notice and license boilerplate. Rewrote
            subject and changelog. ]
    
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Acked-by: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Link: http://lkml.kernel.org/r/1443087135-17044-2-git-send-email-yangyingliang@huawei.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 11bf09288ddb..45cc7299bb61 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -452,6 +452,8 @@ extern int irq_set_affinity_locked(struct irq_data *data,
 				   const struct cpumask *cpumask, bool force);
 extern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);
 
+extern void irq_migrate_all_off_this_cpu(void);
+
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4913c32db942..11bf09288ddb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -475,14 +475,14 @@ static inline int irq_set_parent(int irq, int parent_irq)
  * Built-in IRQ handlers for various IRQ types,
  * callable via desc->handle_irq()
  */
-extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_edge_eoi_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_percpu_devid_irq(unsigned int irq, struct irq_desc *desc);
-extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_level_irq(struct irq_desc *desc);
+extern void handle_fasteoi_irq(struct irq_desc *desc);
+extern void handle_edge_irq(struct irq_desc *desc);
+extern void handle_edge_eoi_irq(struct irq_desc *desc);
+extern void handle_simple_irq(struct irq_desc *desc);
+extern void handle_percpu_irq(struct irq_desc *desc);
+extern void handle_percpu_devid_irq(struct irq_desc *desc);
+extern void handle_bad_irq(struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
 extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);

commit b237721c5d95082a803c0be686f56d2dd1de995b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:43 2015 +0800

    genirq: Move field 'msi_desc' from irq_data into irq_common_data
    
    MSI descriptors are per-irq instead of per irqchip, so move it into
    struct irq_common_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-35-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 75d50544a18f..4913c32db942 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -132,6 +132,7 @@ struct irq_domain;
  * @node:		node index useful for balancing
  * @handler_data:	per-IRQ data for the irq_chip methods
  * @affinity:		IRQ affinity on SMP
+ * @msi_desc:		MSI descriptor
  */
 struct irq_common_data {
 	unsigned int		state_use_accessors;
@@ -139,6 +140,7 @@ struct irq_common_data {
 	unsigned int		node;
 #endif
 	void			*handler_data;
+	struct msi_desc		*msi_desc;
 	cpumask_var_t		affinity;
 };
 
@@ -155,7 +157,6 @@ struct irq_common_data {
  *			irq_domain
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations
- * @msi_desc:		MSI descriptor
  */
 struct irq_data {
 	u32			mask;
@@ -168,7 +169,6 @@ struct irq_data {
 	struct irq_data		*parent_data;
 #endif
 	void			*chip_data;
-	struct msi_desc		*msi_desc;
 };
 
 /*
@@ -652,12 +652,12 @@ static inline void *irq_data_get_irq_handler_data(struct irq_data *d)
 static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
-	return d ? d->msi_desc : NULL;
+	return d ? d->common->msi_desc : NULL;
 }
 
 static inline struct msi_desc *irq_data_get_msi_desc(struct irq_data *d)
 {
-	return d->msi_desc;
+	return d->common->msi_desc;
 }
 
 static inline u32 irq_get_trigger_type(unsigned int irq)

commit 9df872faa7e1619e9278bec00ceaed2236533530
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Jun 3 11:47:50 2015 +0800

    genirq: Move field 'affinity' from irq_data into irq_common_data
    
    Irq affinity mask is per-irq instead of per irqchip, so move it into
    struct irq_common_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433303281-27688-1-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 516aadbfc072..75d50544a18f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -110,8 +110,8 @@ enum {
 /*
  * Return value for chip->irq_set_affinity()
  *
- * IRQ_SET_MASK_OK	- OK, core updates irq_data.affinity
- * IRQ_SET_MASK_NOCPY	- OK, chip did update irq_data.affinity
+ * IRQ_SET_MASK_OK	- OK, core updates irq_common_data.affinity
+ * IRQ_SET_MASK_NOCPY	- OK, chip did update irq_common_data.affinity
  * IRQ_SET_MASK_OK_DONE	- Same as IRQ_SET_MASK_OK for core. Special code to
  *			  support stacked irqchips, which indicates skipping
  *			  all descendent irqchips.
@@ -131,6 +131,7 @@ struct irq_domain;
  *			Use accessor functions to deal with it
  * @node:		node index useful for balancing
  * @handler_data:	per-IRQ data for the irq_chip methods
+ * @affinity:		IRQ affinity on SMP
  */
 struct irq_common_data {
 	unsigned int		state_use_accessors;
@@ -138,6 +139,7 @@ struct irq_common_data {
 	unsigned int		node;
 #endif
 	void			*handler_data;
+	cpumask_var_t		affinity;
 };
 
 /**
@@ -154,7 +156,6 @@ struct irq_common_data {
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations
  * @msi_desc:		MSI descriptor
- * @affinity:		IRQ affinity on SMP
  */
 struct irq_data {
 	u32			mask;
@@ -168,7 +169,6 @@ struct irq_data {
 #endif
 	void			*chip_data;
 	struct msi_desc		*msi_desc;
-	cpumask_var_t		affinity;
 };
 
 /*
@@ -684,12 +684,12 @@ static inline struct cpumask *irq_get_affinity_mask(int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
 
-	return d ? d->affinity : NULL;
+	return d ? d->common->affinity : NULL;
 }
 
 static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 {
-	return d->affinity;
+	return d->common->affinity;
 }
 
 unsigned int arch_dynirq_lower_bound(unsigned int from);

commit af7080e040d223b5e7d0a8de28f7cea24ef017c4
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:21 2015 +0800

    genirq: Move field 'handler_data' from irq_data into irq_common_data
    
    Handler data (handler_data) is per-irq instead of per irqchip, so move
    it into struct irq_common_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-13-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ebcc5c6745eb..516aadbfc072 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -130,12 +130,14 @@ struct irq_domain;
  * @state_use_accessors: status information for irq chip functions.
  *			Use accessor functions to deal with it
  * @node:		node index useful for balancing
+ * @handler_data:	per-IRQ data for the irq_chip methods
  */
 struct irq_common_data {
 	unsigned int		state_use_accessors;
 #ifdef CONFIG_NUMA
 	unsigned int		node;
 #endif
+	void			*handler_data;
 };
 
 /**
@@ -149,7 +151,6 @@ struct irq_common_data {
  *			between hwirq number and linux irq number.
  * @parent_data:	pointer to parent struct irq_data to support hierarchy
  *			irq_domain
- * @handler_data:	per-IRQ data for the irq_chip methods
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations
  * @msi_desc:		MSI descriptor
@@ -165,7 +166,6 @@ struct irq_data {
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	struct irq_data		*parent_data;
 #endif
-	void			*handler_data;
 	void			*chip_data;
 	struct msi_desc		*msi_desc;
 	cpumask_var_t		affinity;
@@ -641,12 +641,12 @@ static inline void *irq_data_get_irq_chip_data(struct irq_data *d)
 static inline void *irq_get_handler_data(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
-	return d ? d->handler_data : NULL;
+	return d ? d->common->handler_data : NULL;
 }
 
 static inline void *irq_data_get_irq_handler_data(struct irq_data *d)
 {
-	return d->handler_data;
+	return d->common->handler_data;
 }
 
 static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)

commit 449e9cae58b06be1293858ec8e5d8cb728238baa
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:16 2015 +0800

    genirq: Move field 'node' from irq_data into irq_common_data
    
    NUMA node information is per-irq instead of per-irqchip, so move it into
    struct irq_common_data. Also use CONFIG_NUMA to guard irq_common_data.node.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433145945-789-8-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e54ae8295460..ebcc5c6745eb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -129,9 +129,13 @@ struct irq_domain;
  * struct irq_common_data - per irq data shared by all irqchips
  * @state_use_accessors: status information for irq chip functions.
  *			Use accessor functions to deal with it
+ * @node:		node index useful for balancing
  */
 struct irq_common_data {
 	unsigned int		state_use_accessors;
+#ifdef CONFIG_NUMA
+	unsigned int		node;
+#endif
 };
 
 /**
@@ -139,7 +143,6 @@ struct irq_common_data {
  * @mask:		precomputed bitmask for accessing the chip registers
  * @irq:		interrupt number
  * @hwirq:		hardware interrupt number, local to the interrupt domain
- * @node:		node index useful for balancing
  * @common:		point to data shared by all irqchips
  * @chip:		low level interrupt hardware access
  * @domain:		Interrupt translation domain; responsible for mapping
@@ -156,7 +159,6 @@ struct irq_data {
 	u32			mask;
 	unsigned int		irq;
 	unsigned long		hwirq;
-	unsigned int		node;
 	struct irq_common_data	*common;
 	struct irq_chip		*chip;
 	struct irq_domain	*domain;
@@ -664,9 +666,18 @@ static inline u32 irq_get_trigger_type(unsigned int irq)
 	return d ? irqd_get_trigger_type(d) : 0;
 }
 
-static inline int irq_data_get_node(struct irq_data *d)
+static inline int irq_common_data_get_node(struct irq_common_data *d)
 {
+#ifdef CONFIG_NUMA
 	return d->node;
+#else
+	return 0;
+#endif
+}
+
+static inline int irq_data_get_node(struct irq_data *d)
+{
+	return irq_common_data_get_node(d->common);
 }
 
 static inline struct cpumask *irq_get_affinity_mask(int irq)

commit fc5697126aa074c289df5e8baae28e115963023f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 15 12:33:42 2015 +0200

    genirq: Provide IRQD_FORWARDED_TO_VCPU status flag
    
    Provide a irq data flag to mark an irq forwarded to a VCPU along with
    the accessor functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 72a6b2feb7bf..e54ae8295460 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -186,6 +186,7 @@ struct irq_data {
  * IRQD_IRQ_MASKED		- Masked state of the interrupt
  * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt
  * IRQD_WAKEUP_ARMED		- Wakeup mode armed
+ * IRQD_FORWARDED_TO_VCPU	- The interrupt is forwarded to a VCPU
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -200,6 +201,7 @@ enum {
 	IRQD_IRQ_MASKED			= (1 << 17),
 	IRQD_IRQ_INPROGRESS		= (1 << 18),
 	IRQD_WAKEUP_ARMED		= (1 << 19),
+	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
 };
 
 #define __irqd_to_state(d)		((d)->common->state_use_accessors)
@@ -278,6 +280,20 @@ static inline bool irqd_is_wakeup_armed(struct irq_data *d)
 	return __irqd_to_state(d) & IRQD_WAKEUP_ARMED;
 }
 
+static inline bool irqd_is_forwarded_to_vcpu(struct irq_data *d)
+{
+	return __irqd_to_state(d) & IRQD_FORWARDED_TO_VCPU;
+}
+
+static inline void irqd_set_forwarded_to_vcpu(struct irq_data *d)
+{
+	__irqd_to_state(d) |= IRQD_FORWARDED_TO_VCPU;
+}
+
+static inline void irqd_clr_forwarded_to_vcpu(struct irq_data *d)
+{
+	__irqd_to_state(d) &= ~IRQD_FORWARDED_TO_VCPU;
+}
 
 /*
  * Functions for chained handlers which can be enabled/disabled by the

commit 3829c664b1eec243f2a355829efa40f0f414de8d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 15 13:47:24 2015 +0200

    genirq: Remove stale comment
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6f8b34066442..72a6b2feb7bf 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -151,10 +151,6 @@ struct irq_common_data {
  *			methods, to allow shared chip implementations
  * @msi_desc:		MSI descriptor
  * @affinity:		IRQ affinity on SMP
- *
- * The fields here need to overlay the ones in irq_desc until we
- * cleaned up the direct references and switched everything over to
- * irq_data.
  */
 struct irq_data {
 	u32			mask;

commit 17e6b00ac422b49d44a0b8d98402a211f726282d
Merge: 5e359bf2219d e324c4dc4a59
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 14:33:35 2015 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "This updated pull request does not contain the last few GIC related
      patches which were reported to cause a regression.  There is a fix
      available, but I let it breed for a couple of days first.
    
      The irq departement provides:
    
       - new infrastructure to support non PCI based MSI interrupts
       - a couple of new irq chip drivers
       - the usual pile of fixlets and updates to irq chip drivers
       - preparatory changes for removal of the irq argument from interrupt
         flow handlers
       - preparatory changes to remove IRQF_VALID"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (129 commits)
      irqchip/imx-gpcv2: IMX GPCv2 driver for wakeup sources
      irqchip: Add bcm2836 interrupt controller for Raspberry Pi 2
      irqchip: Add documentation for the bcm2836 interrupt controller
      irqchip/bcm2835: Add support for being used as a second level controller
      irqchip/bcm2835: Refactor handle_IRQ() calls out of MAKE_HWIRQ
      PCI: xilinx: Fix typo in function name
      irqchip/gic: Ensure gic_cpu_if_up/down() programs correct GIC instance
      irqchip/gic: Only allow the primary GIC to set the CPU map
      PCI/MSI: pci-xgene-msi: Consolidate chained IRQ handler install/remove
      unicore32/irq: Prepare puv3_gpio_handler for irq argument removal
      tile/pci_gx: Prepare trio_handle_level_irq for irq argument removal
      m68k/irq: Prepare irq handlers for irq argument removal
      C6X/megamode-pic: Prepare megamod_irq_cascade for irq argument removal
      blackfin: Prepare irq handlers for irq argument removal
      arc/irq: Prepare idu_cascade_isr for irq argument removal
      sparc/irq: Use access helper irq_data_get_affinity_mask()
      sparc/irq: Use helper irq_data_get_irq_handler_data()
      parisc/irq: Use access helper irq_data_get_affinity_mask()
      mn10300/irq: Use access helper irq_data_get_affinity_mask()
      irqchip/i8259: Prepare i8259_irq_dispatch for irq argument removal
      ...

commit b7560de198222994374c1340a389f12d5efb244a
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Aug 14 15:20:26 2015 +0300

    genirq: Introduce irq_chip_set_type_parent() helper
    
    This helper is required for irq chips which do not implement a
    irq_set_type callback and need to call down the irq domain hierarchy
    for the actual trigger type change.
    
    This helper is required to fix further wreckage caused by the
    conversion of TI OMAP to hierarchical irq domains and therefor tagged
    for stable.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: <linux@arm.linux.org.uk>
    Cc: <nsekhar@ti.com>
    Cc: <jason@lakedaemon.net>
    Cc: <balbi@ti.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: <tony@atomide.com>
    Cc: <marc.zyngier@arm.com>
    Cc: stable@vger.kernel.org # 4.1
    Link: http://lkml.kernel.org/r/1439554830-19502-3-git-send-email-grygorii.strashko@ti.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 92188b0225bb..51744bcf74ee 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -484,6 +484,7 @@ extern int irq_chip_set_affinity_parent(struct irq_data *data,
 extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
 extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
 					     void *vcpu_info);
+extern int irq_chip_set_type_parent(struct irq_data *data, unsigned int type);
 #endif
 
 /* Handling of unhandled and spurious interrupts: */

commit be9b22b6a7e6725162c64155a08b71f0654b675c
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Jul 22 16:21:39 2015 -0700

    genirq: Add chip_[suspend|resume] PM support to irq_chip
    
    Some (admittedly odd) irqchips perform functions that are not directly
    related to any of their child IRQ lines, and therefore need to perform
    some tasks during suspend/resume regardless of whether there are
    any "installed" interrupts for the irqchip. However, the current
    generic-chip framework does not call the chip's irq_{suspend,resume}
    when there are no interrupts installed (this makes sense, because there
    are no irq_data objects for such a call to be made).
    
    More specifically, irq-bcm7120-l2 configures both a forwarding mask
    (which affects other top-level GIC IRQs) and a second-level interrupt
    mask (for managing its own child interrupts). The former must be
    saved/restored on suspend/resume, even when there's nothing to do for
    the latter.
    
    This patch adds a new set of suspend/resume hooks to irq_chip_generic,
    to help represent *chip* suspend/resume, rather than IRQ suspend/resume.
    These callbacks will always be called for an IRQ chip (regardless of the
    installed interrupts) and are based on the per-chip irq_chip_generic
    struct, rather than the per-IRQ irq_data struct.
    
    The original problem report is described in extra detail here:
    http://lkml.kernel.org/g/20150619224123.GL4917@ld-irv-0074
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Gregory Fong <gregory.0xf0@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: linux-mips@linux-mips.org
    Cc: Kevin Cernekee <cernekee@chromium.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1437607300-40858-1-git-send-email-computersforpeace@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5284cb166d90..2c8730a108be 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -324,8 +324,10 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
  * @irq_cpu_online:	configure an interrupt source for a secondary CPU
  * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU
- * @irq_suspend:	function called from core code on suspend once per chip
- * @irq_resume:		function called from core code on resume once per chip
+ * @irq_suspend:	function called from core code on suspend once per
+ *			chip, when one or more interrupts are installed
+ * @irq_resume:		function called from core code on resume once per chip,
+ *			when one ore more interrupts are installed
  * @irq_pm_shutdown:	function called from core code on shutdown once per chip
  * @irq_calc_mask:	Optional function to set irq_data.mask for special cases
  * @irq_print_chip:	optional to print special chip info in show_interrupts
@@ -760,6 +762,12 @@ struct irq_chip_type {
  * @reg_base:		Register base address (virtual)
  * @reg_readl:		Alternate I/O accessor (defaults to readl if NULL)
  * @reg_writel:		Alternate I/O accessor (defaults to writel if NULL)
+ * @suspend:		Function called from core code on suspend once per
+ *			chip; can be useful instead of irq_chip::suspend to
+ *			handle chip details even when no interrupts are in use
+ * @resume:		Function called from core code on resume once per chip;
+ *			can be useful instead of irq_chip::suspend to handle
+ *			chip details even when no interrupts are in use
  * @irq_base:		Interrupt base nr for this chip
  * @irq_cnt:		Number of interrupts handled by this chip
  * @mask_cache:		Cached mask register shared between all chip types
@@ -786,6 +794,8 @@ struct irq_chip_generic {
 	void __iomem		*reg_base;
 	u32			(*reg_readl)(void __iomem *addr);
 	void			(*reg_writel)(u32 val, void __iomem *addr);
+	void			(*suspend)(struct irq_chip_generic *gc);
+	void			(*resume)(struct irq_chip_generic *gc);
 	unsigned int		irq_base;
 	unsigned int		irq_cnt;
 	u32			mask_cache;

commit c391f262bee9d0d6424a99c85183a06c50e307ee
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:41 2015 +0800

    genirq: Rename irq_data_get_msi() as irq_data_get_msi_desc()
    
    Rename irq_data_get_msi() as irq_data_get_msi_desc() to keep consistency
    with other irq_data access helpers.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 429ac266c7c6..5284cb166d90 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -638,7 +638,7 @@ static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)
 	return d ? d->msi_desc : NULL;
 }
 
-static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
+static inline struct msi_desc *irq_data_get_msi_desc(struct irq_data *d)
 {
 	return d->msi_desc;
 }

commit 0dcdbc97557fd8c297c4e38e9f66e304a64bae9d
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:28 2015 +0800

    genirq: Remove the irq argument from note_interrupt()
    
    Only required for the slow path. Retrieve it from irq descriptor if
    necessary.
    
    [ tglx: Split out from combo patch. Left [try_]misrouted_irq()
            untouched as there is no win in the slow path ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433391238-19471-19-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 92188b0225bb..429ac266c7c6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -487,8 +487,7 @@ extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
 #endif
 
 /* Handling of unhandled and spurious interrupts: */
-extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
-			   irqreturn_t action_ret);
+extern void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret);
 
 
 /* Enable/disable irq debugging output: */

commit daf7ab7c58ac5f6304b63cca47a06cdc213361d7
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:11 2015 +0800

    genirq: Clean up outdated comments related to include/linux/irqdesc.h
    
    Seems we have little chance to move irqdesc.h from include/linux/ into
    kernel/irq/, so remove the outdated comments.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433391238-19471-2-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 812149160d3b..92188b0225bb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -407,7 +407,6 @@ enum {
 	IRQCHIP_EOI_THREADED		= (1 <<  6),
 };
 
-/* This include will go away once we isolated irq_desc usage to core code */
 #include <linux/irqdesc.h>
 
 /*

commit f05218651be1ac6a6088e226bd7350fb6c154414
Merge: 62a993df31f7 a614a610ac9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 20 19:14:31 2015 +0200

    Merge branch 'irq/for-x86' into irq/core
    
    Get the infrastructure patches which are required for x86/apic into core

commit 3b0f95be143bea1aa47beb20134ef82e4e4068dc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 16 23:06:20 2015 +0100

    irq: Add irq_set_chained_handler_and_data()
    
    Driver authors seem to get the ordering of irq_set_chained_handler()
    and irq_set_handler_data() wrong - ordering the former before the
    latter.  This opens a race window where, if there is an interrupt
    pending, the handler will be called between these two calls,
    potentially resulting in an oops.
    
    Provide a single interface to set both of these together, especially
    as that's commonly what is required.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/E1Z4yzs-0002Rw-4B@rmk-PC.arm.linux.org.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index de3213d271ff..42861d28fc2a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -525,6 +525,15 @@ irq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)
 	__irq_set_handler(irq, handle, 1, NULL);
 }
 
+/*
+ * Set a highlevel chained flow handler and its data for a given IRQ.
+ * (a chained handler is automatically enabled and set to
+ *  IRQ_NOREQUEST, IRQ_NOPROBE, and IRQ_NOTHREAD)
+ */
+void
+irq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,
+				 void *data);
+
 void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);
 
 static inline void irq_set_status_flags(unsigned int irq, unsigned long set)

commit c64301a230a64dfc2fcf4581cd98a2d703f3c057
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:23 2015 +0800

    genirq: Introduce helper function irq_data_get_affinity_mask()
    
    Introduce helper function irq_data_get_affinity_mask() and
    irq_get_affinity_mask() to hide implementation details,
    so we could move field 'affinity' from struct irq_data into
    struct irq_common_data later.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433145945-789-15-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b3b82a5344c8..1e0ccef205ed 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -645,6 +645,18 @@ static inline int irq_data_get_node(struct irq_data *d)
 	return d->node;
 }
 
+static inline struct cpumask *irq_get_affinity_mask(int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+
+	return d ? d->affinity : NULL;
+}
+
+static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
+{
+	return d->affinity;
+}
+
 unsigned int arch_dynirq_lower_bound(unsigned int from);
 
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,

commit 6783011b48096b9a0c239d0f7645f93070b6eefd
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:13 2015 +0800

    genirq: Introduce helper function irq_data_get_node()
    
    Introduce helper function irq_data_get_node() and variants thereof to
    hide struct irq_data implementation details.
    
    Convert the core code to use them.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1433145945-789-5-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3c7fbe44edae..b3b82a5344c8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -640,6 +640,11 @@ static inline u32 irq_get_trigger_type(unsigned int irq)
 	return d ? irqd_get_trigger_type(d) : 0;
 }
 
+static inline int irq_data_get_node(struct irq_data *d)
+{
+	return d->node;
+}
+
 unsigned int arch_dynirq_lower_bound(unsigned int from);
 
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,

commit 0d0b4c866bcce647f40d73efe5e90aeeb079050a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:12 2015 +0800

    genirq: Introduce struct irq_common_data to host shared irq data
    
    With the introduction of hierarchy irqdomain, struct irq_data becomes
    per-chip instead of per-irq and there may be multiple irq_datas
    associated with the same irq. Some per-irq data stored in struct
    irq_data now may get duplicated into multiple irq_datas, and causes
    inconsistent view.
    
    So introduce struct irq_common_data to host per-irq common data and to
    achieve consistent view among irq_chips.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 48cb7d1aa58f..3c7fbe44edae 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -126,13 +126,21 @@ struct msi_desc;
 struct irq_domain;
 
 /**
- * struct irq_data - per irq and irq chip data passed down to chip functions
+ * struct irq_common_data - per irq data shared by all irqchips
+ * @state_use_accessors: status information for irq chip functions.
+ *			Use accessor functions to deal with it
+ */
+struct irq_common_data {
+	unsigned int		state_use_accessors;
+};
+
+/**
+ * struct irq_data - per irq chip data passed down to chip functions
  * @mask:		precomputed bitmask for accessing the chip registers
  * @irq:		interrupt number
  * @hwirq:		hardware interrupt number, local to the interrupt domain
  * @node:		node index useful for balancing
- * @state_use_accessors: status information for irq chip functions.
- *			Use accessor functions to deal with it
+ * @common:		point to data shared by all irqchips
  * @chip:		low level interrupt hardware access
  * @domain:		Interrupt translation domain; responsible for mapping
  *			between hwirq number and linux irq number.
@@ -153,7 +161,7 @@ struct irq_data {
 	unsigned int		irq;
 	unsigned long		hwirq;
 	unsigned int		node;
-	unsigned int		state_use_accessors;
+	struct irq_common_data	*common;
 	struct irq_chip		*chip;
 	struct irq_domain	*domain;
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
@@ -166,7 +174,7 @@ struct irq_data {
 };
 
 /*
- * Bit masks for irq_data.state
+ * Bit masks for irq_common_data.state_use_accessors
  *
  * IRQD_TRIGGER_MASK		- Mask for the trigger type bits
  * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
@@ -198,34 +206,36 @@ enum {
 	IRQD_WAKEUP_ARMED		= (1 << 19),
 };
 
+#define __irqd_to_state(d)		((d)->common->state_use_accessors)
+
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_SETAFFINITY_PENDING;
+	return __irqd_to_state(d) & IRQD_SETAFFINITY_PENDING;
 }
 
 static inline bool irqd_is_per_cpu(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_PER_CPU;
+	return __irqd_to_state(d) & IRQD_PER_CPU;
 }
 
 static inline bool irqd_can_balance(struct irq_data *d)
 {
-	return !(d->state_use_accessors & (IRQD_PER_CPU | IRQD_NO_BALANCING));
+	return !(__irqd_to_state(d) & (IRQD_PER_CPU | IRQD_NO_BALANCING));
 }
 
 static inline bool irqd_affinity_was_set(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_AFFINITY_SET;
+	return __irqd_to_state(d) & IRQD_AFFINITY_SET;
 }
 
 static inline void irqd_mark_affinity_was_set(struct irq_data *d)
 {
-	d->state_use_accessors |= IRQD_AFFINITY_SET;
+	__irqd_to_state(d) |= IRQD_AFFINITY_SET;
 }
 
 static inline u32 irqd_get_trigger_type(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_TRIGGER_MASK;
+	return __irqd_to_state(d) & IRQD_TRIGGER_MASK;
 }
 
 /*
@@ -233,43 +243,43 @@ static inline u32 irqd_get_trigger_type(struct irq_data *d)
  */
 static inline void irqd_set_trigger_type(struct irq_data *d, u32 type)
 {
-	d->state_use_accessors &= ~IRQD_TRIGGER_MASK;
-	d->state_use_accessors |= type & IRQD_TRIGGER_MASK;
+	__irqd_to_state(d) &= ~IRQD_TRIGGER_MASK;
+	__irqd_to_state(d) |= type & IRQD_TRIGGER_MASK;
 }
 
 static inline bool irqd_is_level_type(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_LEVEL;
+	return __irqd_to_state(d) & IRQD_LEVEL;
 }
 
 static inline bool irqd_is_wakeup_set(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_WAKEUP_STATE;
+	return __irqd_to_state(d) & IRQD_WAKEUP_STATE;
 }
 
 static inline bool irqd_can_move_in_process_context(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_MOVE_PCNTXT;
+	return __irqd_to_state(d) & IRQD_MOVE_PCNTXT;
 }
 
 static inline bool irqd_irq_disabled(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_IRQ_DISABLED;
+	return __irqd_to_state(d) & IRQD_IRQ_DISABLED;
 }
 
 static inline bool irqd_irq_masked(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_IRQ_MASKED;
+	return __irqd_to_state(d) & IRQD_IRQ_MASKED;
 }
 
 static inline bool irqd_irq_inprogress(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_IRQ_INPROGRESS;
+	return __irqd_to_state(d) & IRQD_IRQ_INPROGRESS;
 }
 
 static inline bool irqd_is_wakeup_armed(struct irq_data *d)
 {
-	return d->state_use_accessors & IRQD_WAKEUP_ARMED;
+	return __irqd_to_state(d) & IRQD_WAKEUP_ARMED;
 }
 
 
@@ -280,12 +290,12 @@ static inline bool irqd_is_wakeup_armed(struct irq_data *d)
  */
 static inline void irqd_set_chained_irq_inprogress(struct irq_data *d)
 {
-	d->state_use_accessors |= IRQD_IRQ_INPROGRESS;
+	__irqd_to_state(d) |= IRQD_IRQ_INPROGRESS;
 }
 
 static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
 {
-	d->state_use_accessors &= ~IRQD_IRQ_INPROGRESS;
+	__irqd_to_state(d) &= ~IRQD_IRQ_INPROGRESS;
 }
 
 static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)

commit a6c761e44cfdeffc31785c698aa04d310e7cd686
Merge: 939ef66848ea 0a4377de3056
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 19 15:41:30 2015 +0200

    Merge branch 'irq/for-x86' into irq/core
    
    Pull in the branch which can be consumed by x86 to build their changes
    on top.

commit 0a4377de305684c883bf90ad21e3cbdeead70f5c
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Tue May 19 17:07:14 2015 +0800

    genirq: Introduce irq_set_vcpu_affinity() to target an interrupt to a VCPU
    
    With Posted-Interrupts support in Intel CPU and IOMMU, an external
    interrupt from assigned-devices could be directly delivered to a
    virtual CPU in a virtual machine. Instead of hacking KVM and Intel
    IOMMU drivers, we propose a platform independent interface to target
    an interrupt to a specific virtual CPU in a virtual machine, or set
    virtual CPU affinity for an interrupt.
    
    By adopting this new interface and the hierarchy irqdomain, we could
    easily support posted-interrupts on Intel platforms, and also provide
    flexible enough interfaces for other platforms to support similar
    features.
    
    Here is the usage scenario for this interface:
    Guest update MSI/MSI-X interrupt configuration
            -->QEMU and KVM handle this
            -->KVM call this interface (passing posted interrupts descriptor
               and guest vector)
            -->irq core will transfer the control to IOMMU
            -->IOMMU will do the real work of updating IRTE (IRTE has new
               format for VT-d Posted-Interrupts)
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Feng Wu <feng.wu@intel.com>
    Link: http://lkml.kernel.org/r/1432026437-16560-2-git-send-email-feng.wu@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 62c6901cab55..48cb7d1aa58f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -327,6 +327,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_write_msi_msg:	optional to write message content for MSI
  * @irq_get_irqchip_state:	return the internal state of an interrupt
  * @irq_set_irqchip_state:	set the internal state of a interrupt
+ * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -369,6 +370,8 @@ struct irq_chip {
 	int		(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
 	int		(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);
 
+	int		(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);
+
 	unsigned long	flags;
 };
 
@@ -422,6 +425,7 @@ extern void irq_cpu_online(void);
 extern void irq_cpu_offline(void);
 extern int irq_set_affinity_locked(struct irq_data *data,
 				   const struct cpumask *cpumask, bool force);
+extern int irq_set_vcpu_affinity(unsigned int irq, void *vcpu_info);
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);
@@ -467,6 +471,8 @@ extern int irq_chip_set_affinity_parent(struct irq_data *data,
 					const struct cpumask *dest,
 					bool force);
 extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
+extern int irq_chip_set_vcpu_affinity_parent(struct irq_data *data,
+					     void *vcpu_info);
 #endif
 
 /* Handling of unhandled and spurious interrupts: */

commit 3cfeffc265791bc953527458e0a44ea77c459340
Author: Stefan Agner <stefan@agner.ch>
Date:   Sat May 16 11:44:14 2015 +0200

    genirq: Add irq_chip_(enable/disable)_parent
    
    Add helper irq_chip_enable_parent and irq_chip_disable_parent. The
    helper implement the default behavior in case irq_enable or irq_disable
    is not implemented for the parent interrupt chip, which is calling the
    irq_mask or irq_unmask respectively.
    
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Cc: marc.zyngier@arm.com
    Cc: linux@arm.linux.org.uk
    Cc: u.kleine-koenig@pengutronix.de
    Cc: olof@lixom.net
    Cc: arnd@arndb.de
    Cc: daniel.lezcano@linaro.org
    Cc: mark.rutland@arm.com
    Cc: pawel.moll@arm.com
    Cc: robh+dt@kernel.org
    Cc: ijc+devicetree@hellion.org.uk
    Cc: galak@codeaurora.org
    Cc: mcoquelin.stm32@gmail.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: shawn.guo@linaro.org
    Cc: kernel@pengutronix.de
    Cc: jason@lakedaemon.net
    Link: http://lkml.kernel.org/r/1431769465-26867-3-git-send-email-stefan@agner.ch
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 62c6901cab55..2633061364b1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -458,6 +458,8 @@ extern void handle_nested_irq(unsigned int irq);
 
 extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+extern void irq_chip_enable_parent(struct irq_data *data);
+extern void irq_chip_disable_parent(struct irq_data *data);
 extern void irq_chip_ack_parent(struct irq_data *data);
 extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
 extern void irq_chip_mask_parent(struct irq_data *data);

commit b7dccbea6b079be01e07921264709f249009b8e8
Merge: 425b655ce479 a01e7b3258be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 11 11:17:28 2015 +0200

    Merge tag 'irqchip-core-4.1-3' of git://git.infradead.org/users/jcooper/linux into irq/core
    
    irqchip core change for v4.1 (round 3) from Jason Cooper
    
     Purge the gic_arch_extn hacks and abuse by using the new stacked domains
    
       NOTE: Due to the nature of these changes, patches crossing subsystems have
             been kept together in their own branches.
    
        - tegra
           - Handle the LIC properly
    
        - omap
           - Convert crossbar to stacked domains
           - kill arm,routable-irqs in GIC binding
    
        - exynos
           - Convert PMU wakeup to stacked domains
    
        - shmobile, ux500, zynq (irq_set_wake branch)
           - Switch from abusing gic_arch_extn to using gic_set_irqchip_flags

commit 1b7047edfcfb257f69e306c9afbab150cb987717
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 18 11:01:22 2015 +0000

    genirq: Allow the irqchip state of an IRQ to be save/restored
    
    There is a number of cases where a kernel subsystem may want to
    introspect the state of an interrupt at the irqchip level:
    
    - When a peripheral is shared between virtual machines,
      its interrupt state becomes part of the guest's state,
      and must be switched accordingly. KVM on arm/arm64 requires
      this for its guest-visible timer
    - Some GPIO controllers seem to require peeking into the
      interrupt controller they are connected to to report
      their internal state
    
    This seem to be a pattern that is common enough for the core code
    to try and support this without too many horrible hacks. Introduce
    a pair of accessors (irq_get_irqchip_state/irq_set_irqchip_state)
    to retrieve the bits that can be of interest to another subsystem:
    pending, active, and masked.
    
    - irq_get_irqchip_state returns the state of the interrupt according
      to a parameter set to IRQCHIP_STATE_PENDING, IRQCHIP_STATE_ACTIVE,
      IRQCHIP_STATE_MASKED or IRQCHIP_STATE_LINE_LEVEL.
    - irq_set_irqchip_state similarly sets the state of the interrupt.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Tested-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Phong Vo <pvo@apm.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Tin Huynh <tnhuynh@apm.com>
    Cc: Y Vo <yvo@apm.com>
    Cc: Toan Le <toanle@apm.com>
    Cc: Bjorn Andersson <bjorn@kryo.se>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Link: http://lkml.kernel.org/r/1426676484-21812-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d09ec7a1243e..77dd2e7f93f4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -30,6 +30,7 @@
 struct seq_file;
 struct module;
 struct msi_msg;
+enum irqchip_irq_state;
 
 /*
  * IRQ line status.
@@ -324,6 +325,8 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  *				irq_request_resources
  * @irq_compose_msi_msg:	optional to compose message content for MSI
  * @irq_write_msi_msg:	optional to write message content for MSI
+ * @irq_get_irqchip_state:	return the internal state of an interrupt
+ * @irq_set_irqchip_state:	set the internal state of a interrupt
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -363,6 +366,9 @@ struct irq_chip {
 	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 
+	int		(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
+	int		(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);
+
 	unsigned long	flags;
 };
 

commit 08b55e2a9208e4841a17c9d9c2c454986392977d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 11 15:43:43 2015 +0000

    genirq: Add irqchip_set_wake_parent
    
    This proves to be useful with stacked domains, when the current
    domain doesn't implement wake-up, but expect the parent to do so.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1426088629-15377-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d09ec7a1243e..3057c48e4933 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -460,6 +460,7 @@ extern void irq_chip_eoi_parent(struct irq_data *data);
 extern int irq_chip_set_affinity_parent(struct irq_data *data,
 					const struct cpumask *dest,
 					bool force);
+extern int irq_chip_set_wake_parent(struct irq_data *data, unsigned int on);
 #endif
 
 /* Handling of unhandled and spurious interrupts: */

commit 9e66645d72d3c395da92b0f8855c787f4b5f0e89
Merge: ecb50f0afd35 74faaf7aa64c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 09:01:01 2014 -0800

    Merge branch 'irq-irqdomain-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq domain updates from Thomas Gleixner:
     "The real interesting irq updates:
    
       - Support for hierarchical irq domains:
    
         For complex interrupt routing scenarios where more than one
         interrupt related chip is involved we had no proper representation
         in the generic interrupt infrastructure so far.  That made people
         implement rather ugly constructs in their nested irq chip
         implementations.  The main offenders are x86 and arm/gic.
    
         To distangle that mess we have now hierarchical irqdomains which
         seperate the various interrupt chips and connect them via the
         hierarchical domains.  That keeps the domain specific details
         internal to the particular hierarchy level and removes the
         criss/cross referencing of chip internals.  The resulting hierarchy
         for a complex x86 system will look like this:
    
            vector          mapped: 74
              msi-0         mapped: 2
              dmar-ir-1     mapped: 69
                ioapic-1    mapped: 4
                ioapic-0    mapped: 20
                pci-msi-2   mapped: 45
              dmar-ir-0     mapped: 3
                ioapic-2    mapped: 1
                pci-msi-1   mapped: 2
              htirq         mapped: 0
    
         Neither ioapic nor pci-msi know about the dmar interrupt remapping
         between themself and the vector domain.  If interrupt remapping is
         disabled ioapic and pci-msi become direct childs of the vector
         domain.
    
         In hindsight we should have done that years ago, but in hindsight
         we always know better :)
    
       - Support for generic MSI interrupt domain handling
    
         We have more and more non PCI related MSI interrupts, so providing
         a generic infrastructure for this is better than having all
         affected architectures implementing their own private hacks.
    
       - Support for PCI-MSI interrupt domain handling, based on the generic
         MSI support.
    
         This part carries the pci/msi branch from Bjorn Helgaas pci tree to
         avoid a massive conflict.  The PCI/MSI parts are acked by Bjorn.
    
      I have two more branches on top of this.  The full conversion of x86
      to hierarchical domains and a partial conversion of arm/gic"
    
    * 'irq-irqdomain-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (41 commits)
      genirq: Move irq_chip_write_msi_msg() helper to core
      PCI/MSI: Allow an msi_controller to be associated to an irq domain
      PCI/MSI: Provide mechanism to alloc/free MSI/MSIX interrupt from irqdomain
      PCI/MSI: Enhance core to support hierarchy irqdomain
      PCI/MSI: Move cached entry functions to irq core
      genirq: Provide default callbacks for msi_domain_ops
      genirq: Introduce msi_domain_alloc/free_irqs()
      asm-generic: Add msi.h
      genirq: Add generic msi irq domain support
      genirq: Introduce callback irq_chip.irq_write_msi_msg
      genirq: Work around __irq_set_handler vs stacked domains ordering issues
      irqdomain: Introduce helper function irq_domain_add_hierarchy()
      irqdomain: Implement a method to automatically call parent domains alloc/free
      genirq: Introduce helper irq_domain_set_info() to reduce duplicated code
      genirq: Split out flow handler typedefs into seperate header file
      genirq: Add IRQ_SET_MASK_OK_DONE to support stacked irqchip
      genirq: Introduce irq_chip.irq_compose_msi_msg() to support stacked irqchip
      genirq: Add more helper functions to support stacked irq_chip
      genirq: Introduce helper functions to support stacked irq_chip
      irqdomain: Do irq_find_mapping and set_type for hierarchy irqdomain in case OF
      ...

commit 74faaf7aa64c76b60db0f5c994fd43a46be772ce
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Dec 6 21:20:20 2014 +0100

    genirq: Move irq_chip_write_msi_msg() helper to core
    
    No point to expose this to the world. The only legitimate user is the
    core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8badf34baf0f..33da579d727c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -461,12 +461,6 @@ extern int irq_chip_set_affinity_parent(struct irq_data *data,
 					bool force);
 #endif
 
-static inline void irq_chip_write_msi_msg(struct irq_data *data,
-					  struct msi_msg *msg)
-{
-	data->chip->irq_write_msi_msg(data, msg);
-}
-
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   irqreturn_t action_ret);

commit 9dde55b72dc80bfae4280ddce5dbd69ba8240813
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Sun Nov 9 23:10:28 2014 +0800

    genirq: Introduce callback irq_chip.irq_write_msi_msg
    
    Introduce callback irq_chip.irq_write_msi_msg, so we can share common
    code among MSI alike interrupt controllers, such as HPET and DMAR.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 677482bd8b92..8badf34baf0f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -322,6 +322,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_release_resources:	optional to release resources acquired with
  *				irq_request_resources
  * @irq_compose_msi_msg:	optional to compose message content for MSI
+ * @irq_write_msi_msg:	optional to write message content for MSI
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -359,6 +360,7 @@ struct irq_chip {
 	void		(*irq_release_resources)(struct irq_data *data);
 
 	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
+	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);
 
 	unsigned long	flags;
 };
@@ -459,6 +461,12 @@ extern int irq_chip_set_affinity_parent(struct irq_data *data,
 					bool force);
 #endif
 
+static inline void irq_chip_write_msi_msg(struct irq_data *data,
+					  struct msi_msg *msg)
+{
+	data->chip->irq_write_msi_msg(data, msg);
+}
+
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   irqreturn_t action_ret);

commit 75ffc0075007ca649131a2c42863ce6995d9bf80
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 11 21:58:34 2014 +0100

    genirq: Split out flow handler typedefs into seperate header file
    
    Required to avoid circular include dependencies.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 566b1e541323..677482bd8b92 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -15,6 +15,7 @@
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
 #include <linux/gfp.h>
+#include <linux/irqhandler.h>
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
 #include <linux/errno.h>
@@ -27,12 +28,7 @@
 
 struct seq_file;
 struct module;
-struct irq_desc;
-struct irq_data;
 struct msi_msg;
-typedef	void (*irq_flow_handler_t)(unsigned int irq,
-					    struct irq_desc *desc);
-typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
 
 /*
  * IRQ line status.

commit 2cb625478f8cea0f72b565007a35e1eb7882ac3a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Nov 6 22:20:18 2014 +0800

    genirq: Add IRQ_SET_MASK_OK_DONE to support stacked irqchip
    
    Add IRQ_SET_MASK_OK_DONE in addition to IRQ_SET_MASK_OK and
    IRQ_SET_MASK_OK_NOCOPY to support stacked irqchip. IRQ_SET_MASK_OK_DONE
    is the same as IRQ_SET_MASK_OK to irq core. To stacked irqchip, it means
    that ascendant irqchips have done all the work and no more handling
    needed in descendant irqchips.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d58e58935465..566b1e541323 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -114,10 +114,14 @@ enum {
  *
  * IRQ_SET_MASK_OK	- OK, core updates irq_data.affinity
  * IRQ_SET_MASK_NOCPY	- OK, chip did update irq_data.affinity
+ * IRQ_SET_MASK_OK_DONE	- Same as IRQ_SET_MASK_OK for core. Special code to
+ *			  support stacked irqchips, which indicates skipping
+ *			  all descendent irqchips.
  */
 enum {
 	IRQ_SET_MASK_OK = 0,
 	IRQ_SET_MASK_OK_NOCOPY,
+	IRQ_SET_MASK_OK_DONE,
 };
 
 struct msi_desc;

commit 515085ef7ee74694bc9b02bc45196452defad59a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Nov 6 22:20:17 2014 +0800

    genirq: Introduce irq_chip.irq_compose_msi_msg() to support stacked irqchip
    
    Add callback irq_compose_msi_msg to struct irq_chip, which will be used
    to support stacked irqchip.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fad4bf6f15f6..d58e58935465 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -29,6 +29,7 @@ struct seq_file;
 struct module;
 struct irq_desc;
 struct irq_data;
+struct msi_msg;
 typedef	void (*irq_flow_handler_t)(unsigned int irq,
 					    struct irq_desc *desc);
 typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
@@ -320,6 +321,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  *				any other callback related to this irq
  * @irq_release_resources:	optional to release resources acquired with
  *				irq_request_resources
+ * @irq_compose_msi_msg:	optional to compose message content for MSI
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -356,6 +358,8 @@ struct irq_chip {
 	int		(*irq_request_resources)(struct irq_data *data);
 	void		(*irq_release_resources)(struct irq_data *data);
 
+	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
+
 	unsigned long	flags;
 };
 
@@ -443,6 +447,7 @@ extern void handle_percpu_devid_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
+extern int irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern void irq_chip_ack_parent(struct irq_data *data);
 extern int irq_chip_retrigger_hierarchy(struct irq_data *data);

commit 56e8abab615e0c5858cfb9fa0015a44641762b9d
Author: Yingjoe Chen <yingjoe.chen@mediatek.com>
Date:   Thu Nov 13 23:37:05 2014 +0800

    genirq: Add more helper functions to support stacked irq_chip
    
    Add more helper function for stacked irq_chip to just call parent's
    function.
    
    Signed-off-by: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Gran Likely <grant.likely@linaro.org>
    Cc: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: <srv_heupstream@mediatek.com>
    Cc: <yingjoe.chen@gmail.com>
    Cc: <hc.yen@mediatek.com>
    Cc: <eddie.huang@mediatek.com>
    Cc: <nathan.chung@mediatek.com>
    Cc: <yh.chen@mediatek.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1415893029-2971-3-git-send-email-yingjoe.chen@mediatek.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0adcbbbf2e87..fad4bf6f15f6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -446,6 +446,12 @@ extern void handle_nested_irq(unsigned int irq);
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 extern void irq_chip_ack_parent(struct irq_data *data);
 extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
+extern void irq_chip_mask_parent(struct irq_data *data);
+extern void irq_chip_unmask_parent(struct irq_data *data);
+extern void irq_chip_eoi_parent(struct irq_data *data);
+extern int irq_chip_set_affinity_parent(struct irq_data *data,
+					const struct cpumask *dest,
+					bool force);
 #endif
 
 /* Handling of unhandled and spurious interrupts: */

commit 85f08c17de26f117be6ca7aa260d2ec02a2248ba
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Nov 6 22:20:16 2014 +0800

    genirq: Introduce helper functions to support stacked irq_chip
    
    Now we already support hierarchy irq_data, so introduce several helpers
    to support stacked irq_chips.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 13ba412ce3a0..0adcbbbf2e87 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -443,6 +443,11 @@ extern void handle_percpu_devid_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
+#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+extern void irq_chip_ack_parent(struct irq_data *data);
+extern int irq_chip_retrigger_hierarchy(struct irq_data *data);
+#endif
+
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   irqreturn_t action_ret);

commit f8264e34965aaf43203912ed8f7b543c00c8d70f
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Nov 6 22:20:14 2014 +0800

    irqdomain: Introduce new interfaces to support hierarchy irqdomains
    
    We plan to use hierarchy irqdomain to suppport CPU vector assignment,
    interrupt remapping controller, IO-APIC controller, MSI interrupt
    and hypertransport interrupt etc on x86 platforms. So extend irqdomain
    interfaces to support hierarchy irqdomain.
    
    There are already many clients of current irqdomain interfaces.
    To minimize the changes, we choose to introduce new version 2 interfaces
    to support hierarchy instead of extending existing irqdomain interfaces.
    
    According to Thomas's suggestion, the most important design decision is
    to build hierarchy struct irq_data to support hierarchy irqdomain, so
    hierarchy irqdomain related data could be saved in struct irq_data.
    With support of hierarchy irq_data, we could also support stacked
    irq_chips. This is most useful in case of set_affinity().
    
    The new hierarchy irqdomain introduces following interfaces:
    1) irq_domain_alloc_irqs()/irq_domain_free_irqs(): allocate/release IRQ
       and related resources.
    2) __irq_domain_alloc_irqs(): a special version to support legacy IRQs.
    3) irq_domain_activate_irq()/irq_domain_deactivate_irq(): program
       interrupt controllers to activate/deactivate interrupt.
    
    There are also several help functions to ease irqdomain implemenations:
    1) irq_domain_get_irq_data(): get irq_data associated with a specific
       irqdomain.
    2) irq_domain_set_hwirq_and_chip(): save irqdomain specific data into
       irq_data.
    3) irq_domain_alloc_irqs_parent()/irq_domain_free_irqs_parent(): invoke
       parent irqdomain's alloc/free callbacks.
    
    We also changed irq_startup()/irq_shutdown() to invoke
    irq_domain_activate_irq()/irq_domain_deactivate_irq() to program
    interrupt controller when start/stop interrupts.
    
    [ tglx: Folded parts of the later patch series in ]
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 03f48d936f66..13ba412ce3a0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -133,6 +133,8 @@ struct irq_domain;
  * @chip:		low level interrupt hardware access
  * @domain:		Interrupt translation domain; responsible for mapping
  *			between hwirq number and linux irq number.
+ * @parent_data:	pointer to parent struct irq_data to support hierarchy
+ *			irq_domain
  * @handler_data:	per-IRQ data for the irq_chip methods
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations
@@ -151,6 +153,9 @@ struct irq_data {
 	unsigned int		state_use_accessors;
 	struct irq_chip		*chip;
 	struct irq_domain	*domain;
+#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
+	struct irq_data		*parent_data;
+#endif
 	void			*handler_data;
 	void			*chip_data;
 	struct msi_desc		*msi_desc;

commit b79055952badbd73710685643bab44104f2509ea
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Thu Nov 6 22:44:19 2014 -0800

    genirq: Generic chip: Add big endian I/O accessors
    
    Use io{read,write}32be if the caller specified IRQ_GC_BE_IO when creating
    the irqchip.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Acked-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/1415342669-30640-5-git-send-email-cernekee@gmail.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0fecd95ba271..8588e5efe577 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -738,12 +738,14 @@ struct irq_chip_generic {
  *				the parent irq. Usually GPIO implementations
  * @IRQ_GC_MASK_CACHE_PER_TYPE:	Mask cache is chip type private
  * @IRQ_GC_NO_MASK:		Do not calculate irq_data->mask
+ * @IRQ_GC_BE_IO:		Use big-endian register accesses (default: LE)
  */
 enum irq_gc_flags {
 	IRQ_GC_INIT_MASK_CACHE		= 1 << 0,
 	IRQ_GC_INIT_NESTED_LOCK		= 1 << 1,
 	IRQ_GC_MASK_CACHE_PER_TYPE	= 1 << 2,
 	IRQ_GC_NO_MASK			= 1 << 3,
+	IRQ_GC_BE_IO			= 1 << 4,
 };
 
 /*

commit 2b28037632b1e62b92c0616f08652d806008c80d
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Thu Nov 6 22:44:18 2014 -0800

    genirq: Generic chip: Allow irqchip drivers to override irq_reg_{readl,writel}
    
    Currently, these I/O accessors always assume little endian 32-bit
    registers (readl/writel).  On some systems the IRQ registers need to be
    accessed in BE mode or using 16-bit loads/stores, so we will provide a
    way to override the default behavior.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Acked-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/1415342669-30640-4-git-send-email-cernekee@gmail.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ed1135d32d80..0fecd95ba271 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -686,6 +686,8 @@ struct irq_chip_type {
  * struct irq_chip_generic - Generic irq chip data structure
  * @lock:		Lock to protect register and cache data access
  * @reg_base:		Register base address (virtual)
+ * @reg_readl:		Alternate I/O accessor (defaults to readl if NULL)
+ * @reg_writel:		Alternate I/O accessor (defaults to writel if NULL)
  * @irq_base:		Interrupt base nr for this chip
  * @irq_cnt:		Number of interrupts handled by this chip
  * @mask_cache:		Cached mask register shared between all chip types
@@ -710,6 +712,8 @@ struct irq_chip_type {
 struct irq_chip_generic {
 	raw_spinlock_t		lock;
 	void __iomem		*reg_base;
+	u32			(*reg_readl)(void __iomem *addr);
+	void			(*reg_writel)(u32 val, void __iomem *addr);
 	unsigned int		irq_base;
 	unsigned int		irq_cnt;
 	u32			mask_cache;
@@ -818,13 +822,19 @@ static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
 static inline void irq_reg_writel(struct irq_chip_generic *gc,
 				  u32 val, int reg_offset)
 {
-	writel(val, gc->reg_base + reg_offset);
+	if (gc->reg_writel)
+		gc->reg_writel(val, gc->reg_base + reg_offset);
+	else
+		writel(val, gc->reg_base + reg_offset);
 }
 
 static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
 				int reg_offset)
 {
-	return readl(gc->reg_base + reg_offset);
+	if (gc->reg_readl)
+		return gc->reg_readl(gc->reg_base + reg_offset);
+	else
+		return readl(gc->reg_base + reg_offset);
 }
 
 #endif /* _LINUX_IRQ_H */

commit 332fd7c4fef5f3b166e93decb07fd69eb24f7998
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Thu Nov 6 22:44:17 2014 -0800

    genirq: Generic chip: Change irq_reg_{readl,writel} arguments
    
    Pass in the irq_chip_generic struct so we can use different readl/writel
    settings for each irqchip driver, when appropriate.  Compute
    (gc->reg_base + reg_offset) in the helper function because this is pretty
    much what all callers want to do anyway.
    
    Compile-tested using the following configurations:
    
        at91_dt_defconfig (CONFIG_ATMEL_AIC_IRQ=y)
        sama5_defconfig (CONFIG_ATMEL_AIC5_IRQ=y)
        sunxi_defconfig (CONFIG_ARCH_SUNXI=y)
    
    tb10x (ARC) is untested.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Acked-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/1415342669-30640-3-git-send-email-cernekee@gmail.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 03f48d936f66..ed1135d32d80 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -20,6 +20,7 @@
 #include <linux/errno.h>
 #include <linux/topology.h>
 #include <linux/wait.h>
+#include <linux/io.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -639,13 +640,6 @@ void arch_teardown_hwirq(unsigned int irq);
 void irq_init_desc(unsigned int irq);
 #endif
 
-#ifndef irq_reg_writel
-# define irq_reg_writel(val, addr)	writel(val, addr)
-#endif
-#ifndef irq_reg_readl
-# define irq_reg_readl(addr)		readl(addr)
-#endif
-
 /**
  * struct irq_chip_regs - register offsets for struct irq_gci
  * @enable:	Enable register offset to reg_base
@@ -821,4 +815,16 @@ static inline void irq_gc_lock(struct irq_chip_generic *gc) { }
 static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
 #endif
 
+static inline void irq_reg_writel(struct irq_chip_generic *gc,
+				  u32 val, int reg_offset)
+{
+	writel(val, gc->reg_base + reg_offset);
+}
+
+static inline u32 irq_reg_readl(struct irq_chip_generic *gc,
+				int reg_offset)
+{
+	return readl(gc->reg_base + reg_offset);
+}
+
 #endif /* _LINUX_IRQ_H */

commit b76f16748fa61801b1a1fd3ffb6f25ee228a35e0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 29 13:54:09 2014 +0200

    genirq: Mark wakeup sources as armed on suspend
    
    This allows us to utilize this information in the irq_may_run() check
    without adding another conditional to the fast path.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 62af59242ddc..03f48d936f66 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -173,6 +173,7 @@ struct irq_data {
  * IRQD_IRQ_DISABLED		- Disabled state of the interrupt
  * IRQD_IRQ_MASKED		- Masked state of the interrupt
  * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt
+ * IRQD_WAKEUP_ARMED		- Wakeup mode armed
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -186,6 +187,7 @@ enum {
 	IRQD_IRQ_DISABLED		= (1 << 16),
 	IRQD_IRQ_MASKED			= (1 << 17),
 	IRQD_IRQ_INPROGRESS		= (1 << 18),
+	IRQD_WAKEUP_ARMED		= (1 << 19),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -257,6 +259,12 @@ static inline bool irqd_irq_inprogress(struct irq_data *d)
 	return d->state_use_accessors & IRQD_IRQ_INPROGRESS;
 }
 
+static inline bool irqd_is_wakeup_armed(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_WAKEUP_ARMED;
+}
+
+
 /*
  * Functions for chained handlers which can be enabled/disabled by the
  * standard disable_irq/enable_irq calls. Must be called with

commit a5152c8a125da3c5e16dc2208dd52e80f0803c5c
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Jul 10 19:14:16 2014 +0200

    genirq: generic chip: Export irq_map_generic_chip function
    
    Export the generic irq map function in order to provide irq_domain ops with
    generic mapping and specific of xlate function (needed by the new atmel
    AIC driver).
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/1405012462-766-2-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0d998d8b01d8..62af59242ddc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -771,6 +771,8 @@ void irq_gc_eoi(struct irq_data *d);
 int irq_gc_set_wake(struct irq_data *d, unsigned int on);
 
 /* Setup functions for irq_chip_generic */
+int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,
+			 irq_hw_number_t hw_irq);
 struct irq_chip_generic *
 irq_alloc_generic_chip(const char *name, int nr_ct, unsigned int irq_base,
 		       void __iomem *reg_base, irq_flow_handler_t handler);

commit d8179bc0db8d0c9654d5de43de2874bf6d0a58fa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:23 2014 +0000

    genirq: Remove dynamic_irq mess
    
    No more users. Get rid of the cruft.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140507154341.012847637@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8ff71d14365a..0d998d8b01d8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -525,16 +525,6 @@ static inline void irq_set_percpu_devid_flags(unsigned int irq)
 			     IRQ_NOPROBE | IRQ_PER_CPU_DEVID);
 }
 
-/*
- * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and
- * irq_free_desc instead.
- */
-extern void dynamic_irq_cleanup(unsigned int irq);
-static inline void dynamic_irq_init(unsigned int irq)
-{
-	dynamic_irq_cleanup(irq);
-}
-
 /* Set/get chip/data for an IRQ: */
 extern int irq_set_chip(unsigned int irq, struct irq_chip *chip);
 extern int irq_set_handler_data(unsigned int irq, void *data);

commit c940e01c94e73a2a5318f1b82038e0746aaec753
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:22 2014 +0000

    genirq: Replace dynamic_irq_init/cleanup
    
    Create a new interface and confine it with a config switch which makes
    clear that this is just legacy support and not to be used for new code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140507154340.574437049@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2110f46fcafa..8ff71d14365a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -637,6 +637,10 @@ int arch_setup_hwirq(unsigned int irq, int node);
 void arch_teardown_hwirq(unsigned int irq);
 #endif
 
+#ifdef CONFIG_GENERIC_IRQ_LEGACY
+void irq_init_desc(unsigned int irq);
+#endif
+
 #ifndef irq_reg_writel
 # define irq_reg_writel(val, addr)	writel(val, addr)
 #endif

commit 1d008353ba088fdec0b2a944e140ff9154a5fb20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:21 2014 +0000

    genirq: Remove irq_reserve_irq[s]
    
    No more users. And it's not going to come back. If you need
    hotplugable irq chips, use irq domains.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-and-acked-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20140507154340.302183048@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ac9634286f42..2110f46fcafa 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -617,18 +617,11 @@ int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 	irq_alloc_descs(-1, from, cnt, node)
 
 void irq_free_descs(unsigned int irq, unsigned int cnt);
-int irq_reserve_irqs(unsigned int from, unsigned int cnt);
-
 static inline void irq_free_desc(unsigned int irq)
 {
 	irq_free_descs(irq, 1);
 }
 
-static inline int irq_reserve_irq(unsigned int irq)
-{
-	return irq_reserve_irqs(irq, 1);
-}
-
 #ifdef CONFIG_GENERIC_IRQ_LEGACY_ALLOC_HWIRQ
 unsigned int irq_alloc_hwirqs(int cnt, int node);
 static inline unsigned int irq_alloc_hwirq(int node)

commit e8784e4f9a578344023ae4e08a509b7c5eab5eb0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:17 2014 +0000

    genirq: Make create/destroy_irq() ia64 private
    
    No more users outside of itanic. Confine it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Link: http://lkml.kernel.org/r/20140507154338.700598389@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7549ed59d3d4..ac9634286f42 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -525,10 +525,6 @@ static inline void irq_set_percpu_devid_flags(unsigned int irq)
 			     IRQ_NOPROBE | IRQ_PER_CPU_DEVID);
 }
 
-/* Handle dynamic irq creation and destruction */
-extern int create_irq(void);
-extern void destroy_irq(unsigned int irq);
-
 /*
  * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and
  * irq_free_desc instead.

commit 54859f59fc18e5c104a4095420b3fcef8bc3ae63
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:12 2014 +0000

    x86: Remove create/destroy_irq()
    
    No more users. Remove the cruft
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: x86@kernel.org
    Link: http://lkml.kernel.org/r/20140507154336.760446122@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c75dd161d37f..7549ed59d3d4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -526,12 +526,8 @@ static inline void irq_set_percpu_devid_flags(unsigned int irq)
 }
 
 /* Handle dynamic irq creation and destruction */
-extern unsigned int create_irq_nr(unsigned int irq_want, int node);
-extern unsigned int __create_irqs(unsigned int from, unsigned int count,
-				  int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
-extern void destroy_irqs(unsigned int irq, unsigned int count);
 
 /*
  * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and

commit 7b6ef1262549f6afc5c881aaef80beb8fd15f908
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 7 15:44:05 2014 +0000

    genirq: Provide generic hwirq allocation facility
    
    Not really the solution to the problem, but at least it confines the
    mess in the core code and allows to get rid of the create/destroy_irq
    variants from hell, i.e. 3 implementations with different semantics
    plus the x86 specific variants __create_irqs and create_irq_nr
    which have been invented in another circle of hell.
    
    x86 : x86 should be converted to irq domains and I'm deliberately
          making it impossible to do the multi-vector MSI support by
          adding more crap to the current mess. It's not that hard to do
          and I'm really tired of the trainwrecks which have been invented
          by baindaid engineering so far. Any attempt to do multi-vector
          MSI or ioapic hotplug without converting to irq domains is NAKed
          hereby.
    
    tile: Might use irq domains as well, but it has a very limited
          interrupt space, so handling it via this functionality might be
          the right thing to do even in the long run.
    
    ia64: That's an hopeless case, as I doubt that anyone has the stomach
          to rewrite the homebrewn dynamic allocation facilities. I stared
          at it for a couple of hours and gave up. The create/destroy_irq
          mess could be made private to itanic right away if there
          wouldn't be the iommu/dmar driver being shared with x86. So to
          do that I'm going to add a separate ia64 specific implementation
          later in order not to deep-six itanic right away.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: x86@kernel.org
    Link: http://lkml.kernel.org/r/20140507154334.208629358@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5c57efb863d0..c75dd161d37f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -637,6 +637,21 @@ static inline int irq_reserve_irq(unsigned int irq)
 	return irq_reserve_irqs(irq, 1);
 }
 
+#ifdef CONFIG_GENERIC_IRQ_LEGACY_ALLOC_HWIRQ
+unsigned int irq_alloc_hwirqs(int cnt, int node);
+static inline unsigned int irq_alloc_hwirq(int node)
+{
+	return irq_alloc_hwirqs(1, node);
+}
+void irq_free_hwirqs(unsigned int from, int cnt);
+static inline void irq_free_hwirq(unsigned int irq)
+{
+	return irq_free_hwirqs(irq, 1);
+}
+int arch_setup_hwirq(unsigned int irq, int node);
+void arch_teardown_hwirq(unsigned int irq);
+#endif
+
 #ifndef irq_reg_writel
 # define irq_reg_writel(val, addr)	writel(val, addr)
 #endif

commit 62a08ae2a5763aabeee98264605236b001503e0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 24 09:50:53 2014 +0200

    genirq: x86: Ensure that dynamic irq allocation does not conflict
    
    On x86 the allocation of irq descriptors may allocate interrupts which
    are in the range of the GSI interrupts. That's wrong as those
    interrupts are hardwired and we don't have the irq domain translation
    like PPC. So one of these interrupts can be hooked up later to one of
    the devices which are hard wired to it and the io_apic init code for
    that particular interrupt line happily reuses that descriptor with a
    completely different configuration so hell breaks lose.
    
    Inside x86 we allocate dynamic interrupts from above nr_gsi_irqs,
    except for a few usage sites which have not yet blown up in our face
    for whatever reason. But for drivers which need an irq range, like the
    GPIO drivers, we have no limit in place and we don't want to expose
    such a detail to a driver.
    
    To cure this introduce a function which an architecture can implement
    to impose a lower bound on the dynamic interrupt allocations.
    
    Implement it for x86 and set the lower bound to nr_gsi_irqs, which is
    the end of the hardwired interrupt space, so all dynamic allocations
    happen above.
    
    That not only allows the GPIO driver to work sanely, it also protects
    the bogus callsites of create_irq_nr() in hpet, uv, irq_remapping and
    htirq code. They need to be cleaned up as well, but that's a separate
    issue.
    
    Reported-by: Jin Yao <yao.jin@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Mathias Nyman <mathias.nyman@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Krogerus Heikki <heikki.krogerus@intel.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1404241617360.28206@ionos.tec.linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 10a0b1ac4ea0..5c57efb863d0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -603,6 +603,8 @@ static inline u32 irq_get_trigger_type(unsigned int irq)
 	return d ? irqd_get_trigger_type(d) : 0;
 }
 
+unsigned int arch_dynirq_lower_bound(unsigned int from);
+
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 		struct module *owner);
 

commit 01f8fa4f01d8362358eb90e412bd7ae18a3ec1ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 16 14:36:44 2014 +0000

    genirq: Allow forcing cpu affinity of interrupts
    
    The current implementation of irq_set_affinity() refuses rightfully to
    route an interrupt to an offline cpu.
    
    But there is a special case, where this is actually desired. Some of
    the ARM SoCs have per cpu timers which require setting the affinity
    during cpu startup where the cpu is not yet in the online mask.
    
    If we can't do that, then the local timer interrupt for the about to
    become online cpu is routed to some random online cpu.
    
    The developers of the affected machines tried to work around that
    issue, but that results in a massive mess in that timer code.
    
    We have a yet unused argument in the set_affinity callbacks of the irq
    chips, which I added back then for a similar reason. It was never
    required so it got not used. But I'm happy that I never removed it.
    
    That allows us to implement a sane handling of the above scenario. So
    the affected SoC drivers can add the required force handling to their
    interrupt chip, switch the timer code to irq_force_affinity() and
    things just work.
    
    This does not affect any existing user of irq_set_affinity().
    
    Tagged for stable to allow a simple fix of the affected SoC clock
    event drivers.
    
    Reported-and-tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Tomasz Figa <t.figa@samsung.com>,
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>,
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: linux-arm-kernel@lists.infradead.org,
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/20140416143315.717251504@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d278838908cb..10a0b1ac4ea0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -394,7 +394,8 @@ extern void remove_percpu_irq(unsigned int irq, struct irqaction *act);
 
 extern void irq_cpu_online(void);
 extern void irq_cpu_offline(void);
-extern int __irq_set_affinity_locked(struct irq_data *data,  const struct cpumask *cpumask);
+extern int irq_set_affinity_locked(struct irq_data *data,
+				   const struct cpumask *cpumask, bool force);
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);

commit 328a4978df833249b099c9875738d7b72042ffe1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 13 19:03:51 2014 +0100

    genirq: Add a new IRQCHIP_EOI_THREADED flag
    
    The flag is necessary for interrupt chips which require an ACK/EOI
    after the handler has run. In case of threaded handlers this needs to
    happen after the threaded handler has completed before the unmask of
    the interrupt.
    
    The flag is only unseful in combination with the handle_fasteoi_irq
    flow control handler.
    
    It can be combined with the flag IRQCHIP_EOI_IF_HANDLED, so the EOI is
    not issued when the interrupt is disabled or in progress.
    
    Tested-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-sunxi@googlegroups.com
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://lkml.kernel.org/r/1394733834-26839-2-git-send-email-hdegoede@redhat.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 67ace7aa7947..d278838908cb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -356,6 +356,7 @@ struct irq_chip {
  *				when irq enabled
  * IRQCHIP_SKIP_SET_WAKE:	Skip chip.irq_set_wake(), for this irq chip
  * IRQCHIP_ONESHOT_SAFE:	One shot does not require mask/unmask
+ * IRQCHIP_EOI_THREADED:	Chip requires eoi() on unmask in threaded mode
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
@@ -364,6 +365,7 @@ enum {
 	IRQCHIP_ONOFFLINE_ENABLED	= (1 <<  3),
 	IRQCHIP_SKIP_SET_WAKE		= (1 <<  4),
 	IRQCHIP_ONESHOT_SAFE		= (1 <<  5),
+	IRQCHIP_EOI_THREADED		= (1 <<  6),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit 4f6e4f71c9d39cf49e0cb1be5b7721db5fbe92ac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 13 15:32:47 2014 +0100

    genirq: Document IRQCHIP_ONESHOT_SAFE flag
    
    Add missing documentation of the flag.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e675971bdc3f..67ace7aa7947 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -355,6 +355,7 @@ struct irq_chip {
  * IRQCHIP_ONOFFLINE_ENABLED:	Only call irq_on/off_line callbacks
  *				when irq enabled
  * IRQCHIP_SKIP_SET_WAKE:	Skip chip.irq_set_wake(), for this irq chip
+ * IRQCHIP_ONESHOT_SAFE:	One shot does not require mask/unmask
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),

commit c1bacbae8192dd2a9ebadd22d793b68054f6c6e5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 8 08:59:58 2014 +0100

    genirq: Provide irq_request/release_resources chip callbacks
    
    For certain irq types, e.g. gpios, it's necessary to request resources
    before starting up the irq.
    
    This might fail so we cannot use the irq_startup() callback because we
    might call the irq_set_type() callback before that which does not make
    sense when the resource is not available. Calling irq_startup() before
    irq_set_type() can lead to spurious interrupts which is not desired
    either.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jean-Jacques Hiblot <jjhiblot@traphandler.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1403080857160.18573@ionos.tec.linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7dc10036eff5..e675971bdc3f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -303,6 +303,10 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_pm_shutdown:	function called from core code on shutdown once per chip
  * @irq_calc_mask:	Optional function to set irq_data.mask for special cases
  * @irq_print_chip:	optional to print special chip info in show_interrupts
+ * @irq_request_resources:	optional to request resources before calling
+ *				any other callback related to this irq
+ * @irq_release_resources:	optional to release resources acquired with
+ *				irq_request_resources
  * @flags:		chip specific flags
  */
 struct irq_chip {
@@ -336,6 +340,8 @@ struct irq_chip {
 	void		(*irq_calc_mask)(struct irq_data *data);
 
 	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
+	int		(*irq_request_resources)(struct irq_data *data);
+	void		(*irq_release_resources)(struct irq_data *data);
 
 	unsigned long	flags;
 };

commit b39898cd4077f4b6ec706e717c938751c34e1dc4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 6 12:30:07 2013 +0100

    genirq: Prevent spurious detection for unconditionally polled interrupts
    
    On a 68k platform a couple of interrupts are demultiplexed and
    "polled" from a top level interrupt. Unfortunately there is no way to
    determine which of the sub interrupts raised the top level interrupt,
    so all of the demultiplexed interrupt handlers need to be
    invoked. Given a high enough frequency this can trigger the spurious
    interrupt detection mechanism, if one of the demultiplex interrupts
    returns IRQ_NONE continuously. But this is a false positive as the
    polling causes this behaviour and not buggy hardware/software.
    
    Introduce IRQ_POLLED which can be set at interrupt chip setup time via
    irq_set_status_flags(). The flag excludes the interrupt from the
    spurious detector and from all core polling activities.
    
    Reported-and-tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@vger.kernel.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1311061149250.23353@ionos.tec.linutronix.de

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 56bb0dc8b7d4..7dc10036eff5 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -70,6 +70,9 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
  * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
  * IRQ_PER_CPU_DEVID		- Dev_id is a per-cpu variable
+ * IRQ_IS_POLLED		- Always polled by another interrupt. Exclude
+ *				  it from the spurious interrupt detection
+ *				  mechanism and from core side polling.
  */
 enum {
 	IRQ_TYPE_NONE		= 0x00000000,
@@ -94,12 +97,14 @@ enum {
 	IRQ_NESTED_THREAD	= (1 << 15),
 	IRQ_NOTHREAD		= (1 << 16),
 	IRQ_PER_CPU_DEVID	= (1 << 17),
+	IRQ_IS_POLLED		= (1 << 18),
 };
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
-	 IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID)
+	 IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID | \
+	 IRQ_IS_POLLED)
 
 #define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
 

commit 0244ad004a54e39308d495fee0a2e637f8b5c317
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 30 09:39:53 2013 +0200

    Remove GENERIC_HARDIRQ config option
    
    After the last architecture switched to generic hard irqs the config
    options HAVE_GENERIC_HARDIRQS & GENERIC_HARDIRQS and the related code
    for !CONFIG_GENERIC_HARDIRQS can be removed.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f04d3ba335cb..56bb0dc8b7d4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -382,8 +382,6 @@ extern void irq_cpu_online(void);
 extern void irq_cpu_offline(void);
 extern int __irq_set_affinity_locked(struct irq_data *data,  const struct cpumask *cpumask);
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);
@@ -802,11 +800,4 @@ static inline void irq_gc_lock(struct irq_chip_generic *gc) { }
 static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
 #endif
 
-#else /* !CONFIG_GENERIC_HARDIRQS */
-
-extern struct msi_desc *irq_get_msi_desc(unsigned int irq);
-extern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);
-
-#endif /* CONFIG_GENERIC_HARDIRQS */
-
 #endif /* _LINUX_IRQ_H */

commit 1f6236bfd7c38d5f9f7648fae7215e65274b9e63
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Fri Jun 14 18:40:43 2013 +0200

    genirq: Add irq_get_trigger_type() to get IRQ flags
    
    Drivers that want to get the trigger edge/level type flags for a given
    interrupt have to call irq_get_irq_data(irq) to get the struct
    irq_data and then irqd_get_trigger_type(irq_data) to obtain the IRQ
    flags.
    
    This is not only error prone but also unnecessary exposes the struct
    irq_data to callers.
    
    It's better to have an irq_get_trigger_type() function to obtain the
    edge/level flags for an IRQ.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org
    Link: http://lkml.kernel.org/r/1371228049-27080-2-git-send-email-javier.martinez@collabora.co.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 298a9b9ce675..f04d3ba335cb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -584,6 +584,12 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 	return d->msi_desc;
 }
 
+static inline u32 irq_get_trigger_type(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? irqd_get_trigger_type(d) : 0;
+}
+
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 		struct module *owner);
 

commit e8bd834f73714378ef110a64287db1b77033c8da
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed May 29 03:10:52 2013 +0100

    genirq: irqchip: Add mask to block out invalid irqs
    
    Some controllers have irqs that aren't wired up and must never be used.
    For the generic chip attached to an irq_domain this provides a mask that
    can be used to block out particular irqs so that they never get mapped.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Link: http://lkml.kernel.org/r/1369793454-19197-2-git-send-email-grant.likely@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index af7052c6a45c..298a9b9ce675 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -679,6 +679,7 @@ struct irq_chip_type {
  * @num_ct:		Number of available irq_chip_type instances (usually 1)
  * @private:		Private data for non generic chip callbacks
  * @installed:		bitfield to denote installed interrupts
+ * @unused:		bitfield to denote unused interrupts
  * @domain:		irq domain pointer
  * @list:		List head for keeping track of instances
  * @chip_types:		Array of interrupt irq_chip_types
@@ -702,6 +703,7 @@ struct irq_chip_generic {
 	unsigned int		num_ct;
 	void			*private;
 	unsigned long		installed;
+	unsigned long		unused;
 	struct irq_domain	*domain;
 	struct list_head	list;
 	struct irq_chip_type	chip_types[0];

commit 088f40b7b027dad6519712ff224a5798dd62a204
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 6 14:30:27 2013 +0000

    genirq: Generic chip: Add linear irq domain support
    
    Provide infrastructure for irq chip implementations which work on
    linear irq domains.
    
    - Interface to allocate multiple generic chips which are associated to
      the irq domain.
    
    - Interface to get the generic chip pointer for a particular hardware
      interrupt in the domain.
    
    - irq domain mapping function to install the chip for a particular
      interrupt.
    
    Note: This lacks a removal function for now.
    
    [ Sebastian Hesselbarth: Mask cache and pointer math fixups ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Rob Landley <rob@landley.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: http://lkml.kernel.org/r/20130506142539.450634298@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ab8169faaa65..af7052c6a45c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -678,6 +678,8 @@ struct irq_chip_type {
  * @wake_active:	Interrupt is marked as an wakeup from suspend source
  * @num_ct:		Number of available irq_chip_type instances (usually 1)
  * @private:		Private data for non generic chip callbacks
+ * @installed:		bitfield to denote installed interrupts
+ * @domain:		irq domain pointer
  * @list:		List head for keeping track of instances
  * @chip_types:		Array of interrupt irq_chip_types
  *
@@ -699,6 +701,8 @@ struct irq_chip_generic {
 	u32			wake_active;
 	unsigned int		num_ct;
 	void			*private;
+	unsigned long		installed;
+	struct irq_domain	*domain;
 	struct list_head	list;
 	struct irq_chip_type	chip_types[0];
 };
@@ -719,6 +723,24 @@ enum irq_gc_flags {
 	IRQ_GC_NO_MASK			= 1 << 3,
 };
 
+/*
+ * struct irq_domain_chip_generic - Generic irq chip data structure for irq domains
+ * @irqs_per_chip:	Number of interrupts per chip
+ * @num_chips:		Number of chips
+ * @irq_flags_to_set:	IRQ* flags to set on irq setup
+ * @irq_flags_to_clear:	IRQ* flags to clear on irq setup
+ * @gc_flags:		Generic chip specific setup flags
+ * @gc:			Array of pointers to generic interrupt chips
+ */
+struct irq_domain_chip_generic {
+	unsigned int		irqs_per_chip;
+	unsigned int		num_chips;
+	unsigned int		irq_flags_to_clear;
+	unsigned int		irq_flags_to_set;
+	enum irq_gc_flags	gc_flags;
+	struct irq_chip_generic	*gc[0];
+};
+
 /* Generic chip callback functions */
 void irq_gc_noop(struct irq_data *d);
 void irq_gc_mask_disable_reg(struct irq_data *d);
@@ -742,6 +764,14 @@ int irq_setup_alt_chip(struct irq_data *d, unsigned int type);
 void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,
 			     unsigned int clr, unsigned int set);
 
+struct irq_chip_generic *irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq);
+int irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,
+				   int num_ct, const char *name,
+				   irq_flow_handler_t handler,
+				   unsigned int clr, unsigned int set,
+				   enum irq_gc_flags flags);
+
+
 static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
 {
 	return container_of(d->chip, struct irq_chip_type, chip);

commit d0051816e619f8f082582bec07ffa51bdb4f2104
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 6 14:30:24 2013 +0000

    genirq: irqchip: Add a mask calculation function
    
    Some chips have weird bit mask access patterns instead of the linear
    you expect. Allow them to calculate the cached mask themself.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Rob Landley <rob@landley.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: http://lkml.kernel.org/r/20130506142539.302898834@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d5fc7f5a49b8..ab8169faaa65 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -296,6 +296,7 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_suspend:	function called from core code on suspend once per chip
  * @irq_resume:		function called from core code on resume once per chip
  * @irq_pm_shutdown:	function called from core code on shutdown once per chip
+ * @irq_calc_mask:	Optional function to set irq_data.mask for special cases
  * @irq_print_chip:	optional to print special chip info in show_interrupts
  * @flags:		chip specific flags
  */
@@ -327,6 +328,8 @@ struct irq_chip {
 	void		(*irq_resume)(struct irq_data *data);
 	void		(*irq_pm_shutdown)(struct irq_data *data);
 
+	void		(*irq_calc_mask)(struct irq_data *data);
+
 	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 
 	unsigned long	flags;

commit 966dc736b819999cd2d3a6408d47d33b579f7d56
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 6 14:30:22 2013 +0000

    genirq: Generic chip: Cache per irq bit mask
    
    Cache the per irq bit mask instead of recalculating it over and over.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Rob Landley <rob@landley.net>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: http://lkml.kernel.org/r/20130506142539.227119865@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7f1f0157fd00..d5fc7f5a49b8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -119,6 +119,7 @@ struct irq_domain;
 
 /**
  * struct irq_data - per irq and irq chip data passed down to chip functions
+ * @mask:		precomputed bitmask for accessing the chip registers
  * @irq:		interrupt number
  * @hwirq:		hardware interrupt number, local to the interrupt domain
  * @node:		node index useful for balancing
@@ -138,6 +139,7 @@ struct irq_domain;
  * irq_data.
  */
 struct irq_data {
+	u32			mask;
 	unsigned int		irq;
 	unsigned long		hwirq;
 	unsigned int		node;
@@ -705,11 +707,13 @@ struct irq_chip_generic {
  *				irq chips which need to call irq_set_wake() on
  *				the parent irq. Usually GPIO implementations
  * @IRQ_GC_MASK_CACHE_PER_TYPE:	Mask cache is chip type private
+ * @IRQ_GC_NO_MASK:		Do not calculate irq_data->mask
  */
 enum irq_gc_flags {
 	IRQ_GC_INIT_MASK_CACHE		= 1 << 0,
 	IRQ_GC_INIT_NESTED_LOCK		= 1 << 1,
 	IRQ_GC_MASK_CACHE_PER_TYPE	= 1 << 2,
+	IRQ_GC_NO_MASK			= 1 << 3,
 };
 
 /* Generic chip callback functions */

commit af80b0fed67261dcba2ce2406db1d553d07cbe75
Author: Gerlando Falauto <gerlando.falauto@keymile.com>
Date:   Mon May 6 14:30:21 2013 +0000

    genirq: Generic chip: Handle separate mask registers
    
    There are cases where all irq_chip_type instances have separate mask
    registers, making a shared mask register cache unsuitable for the
    purpose.
    
    Introduce a new flag IRQ_GC_MASK_CACHE_PER_TYPE. If set, point the per
    chip mask pointer to the per chip private mask cache instead.
    
    [ tglx: Simplified code, renamed flag and massaged changelog ]
    
    Signed-off-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Joey Oravec <joravec@drewtech.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Holger Brunck <Holger.Brunck@keymile.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Simon Guinot <simon@sequanux.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Cc: Rob Landley <rob@landley.net>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://lkml.kernel.org/r/20130506142539.152569748@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 38709a3ab1c0..7f1f0157fd00 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -704,10 +704,12 @@ struct irq_chip_generic {
  * @IRQ_GC_INIT_NESTED_LOCK:	Set the lock class of the irqs to nested for
  *				irq chips which need to call irq_set_wake() on
  *				the parent irq. Usually GPIO implementations
+ * @IRQ_GC_MASK_CACHE_PER_TYPE:	Mask cache is chip type private
  */
 enum irq_gc_flags {
 	IRQ_GC_INIT_MASK_CACHE		= 1 << 0,
 	IRQ_GC_INIT_NESTED_LOCK		= 1 << 1,
+	IRQ_GC_MASK_CACHE_PER_TYPE	= 1 << 2,
 };
 
 /* Generic chip callback functions */

commit 899f0e66fff36ebb6dd6a83af9aa631f6cb7e0dc
Author: Gerlando Falauto <gerlando.falauto@keymile.com>
Date:   Mon May 6 14:30:19 2013 +0000

    genirq: Generic chip: Add support for per chip type mask cache
    
    Today the same interrupt mask cache (stored within struct irq_chip_generic)
    is shared between all the irq_chip_type instances. As there are instances
    where each irq_chip_type uses a distinct mask register (as it is the case
    for Orion SoCs), sharing a single mask cache may be incorrect.
    So add a distinct pointer for each irq_chip_type, which for now
    points to the original mask register within irq_chip_generic.
    So no functional changes here.
    
    [ tglx: Minor cosmetic tweaks ]
    
    Reported-by: Joey Oravec <joravec@drewtech.com>
    Signed-off-by: Simon Guinot <sguinot@lacie.com>
    Signed-off-by: Holger Brunck <holger.brunck@keymile.com>
    Signed-off-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Holger Brunck <Holger.Brunck@keymile.com>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Simon Guinot <simon@sequanux.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jean-Francois Moine <moinejf@free.fr>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Cc: Rob Landley <rob@landley.net>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Link: http://lkml.kernel.org/r/20130506142539.082226607@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index bc4e06611958..38709a3ab1c0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -644,6 +644,8 @@ struct irq_chip_regs {
  * @regs:		Register offsets for this chip
  * @handler:		Flow handler associated with this chip
  * @type:		Chip can handle these flow types
+ * @mask_cache_priv:	Cached mask register private to the chip type
+ * @mask_cache:		Pointer to cached mask register
  *
  * A irq_generic_chip can have several instances of irq_chip_type when
  * it requires different functions and register offsets for different
@@ -654,6 +656,8 @@ struct irq_chip_type {
 	struct irq_chip_regs	regs;
 	irq_flow_handler_t	handler;
 	u32			type;
+	u32			mask_cache_priv;
+	u32			*mask_cache;
 };
 
 /**
@@ -662,7 +666,7 @@ struct irq_chip_type {
  * @reg_base:		Register base address (virtual)
  * @irq_base:		Interrupt base nr for this chip
  * @irq_cnt:		Number of interrupts handled by this chip
- * @mask_cache:		Cached mask register
+ * @mask_cache:		Cached mask register shared between all chip types
  * @type_cache:		Cached type register
  * @polarity_cache:	Cached polarity register
  * @wake_enabled:	Interrupt can wakeup from suspend

commit 5afba62cc8a16716508605e02c1b02ee5f969184
Author: Joerg Roedel <joro@8bytes.org>
Date:   Wed Sep 26 12:44:38 2012 +0200

    x86, msi: Use IRQ remapping specific setup_msi_irqs routine
    
    Use seperate routines to setup MSI IRQs for both
    irq_remapping_enabled cases.
    
    Signed-off-by: Joerg Roedel <joro@8bytes.org>
    Acked-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1eab99111e94..bc4e06611958 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -509,8 +509,11 @@ static inline void irq_set_percpu_devid_flags(unsigned int irq)
 
 /* Handle dynamic irq creation and destruction */
 extern unsigned int create_irq_nr(unsigned int irq_want, int node);
+extern unsigned int __create_irqs(unsigned int from, unsigned int count,
+				  int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
+extern void destroy_irqs(unsigned int irq, unsigned int count);
 
 /*
  * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and

commit 51906e779f2b13b38f8153774c4c7163d412ffd9
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Mon Nov 19 16:01:29 2012 +0100

    x86/MSI: Support multiple MSIs in presense of IRQ remapping
    
    The MSI specification has several constraints in comparison with
    MSI-X, most notable of them is the inability to configure MSIs
    independently. As a result, it is impossible to dispatch
    interrupts from different queues to different CPUs. This is
    largely devalues the support of multiple MSIs in SMP systems.
    
    Also, a necessity to allocate a contiguous block of vector
    numbers for devices capable of multiple MSIs might cause a
    considerable pressure on x86 interrupt vector allocator and
    could lead to fragmentation of the interrupt vectors space.
    
    This patch overcomes both drawbacks in presense of IRQ remapping
    and lets devices take advantage of multiple queues and per-IRQ
    affinity assignments.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/c8bd86ff56b5fc118257436768aaa04489ac0a4c.1353324359.git.agordeev@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fdf2c4a238cc..1eab99111e94 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -528,6 +528,8 @@ extern int irq_set_handler_data(unsigned int irq, void *data);
 extern int irq_set_chip_data(unsigned int irq, void *data);
 extern int irq_set_irq_type(unsigned int irq, unsigned int type);
 extern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);
+extern int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,
+				struct msi_desc *entry);
 extern struct irq_data *irq_get_irq_data(unsigned int irq);
 
 static inline struct irq_chip *irq_get_chip(unsigned int irq)
@@ -590,6 +592,9 @@ int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 #define irq_alloc_desc_from(from, node)		\
 	irq_alloc_descs(-1, from, 1, node)
 
+#define irq_alloc_descs_from(from, cnt, node)	\
+	irq_alloc_descs(-1, from, cnt, node)
+
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 int irq_reserve_irqs(unsigned int from, unsigned int cnt);
 

commit c7708fac5a878d6e0f2de0aa19f9749cff4f707f
Merge: 3127f23f013e 6726a807c38d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 14:20:19 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 update from Martin Schwidefsky:
     "Add support to generate code for the latest machine zEC12, MOD and XOR
      instruction support for the BPF jit compiler, the dasd safe offline
      feature and the big one: the s390 architecture gets PCI support!!
      Right before the world ends on the 21st ;-)"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux: (41 commits)
      s390/qdio: rename the misleading PCI flag of qdio devices
      s390/pci: remove obsolete email addresses
      s390/pci: speed up __iowrite64_copy by using pci store block insn
      s390/pci: enable NEED_DMA_MAP_STATE
      s390/pci: no msleep in potential IRQ context
      s390/pci: fix potential NULL pointer dereference in dma_free_seg_table()
      s390/pci: use kmem_cache_zalloc instead of kmem_cache_alloc/memset
      s390/bpf,jit: add support for XOR instruction
      s390/bpf,jit: add support MOD instruction
      s390/cio: fix pgid reserved check
      vga: compile fix, disable vga for s390
      s390/pci: add PCI Kconfig options
      s390/pci: s390 specific PCI sysfs attributes
      s390/pci: PCI hotplug support via SCLP
      s390/pci: CHSC PCI support for error and availability events
      s390/pci: DMA support
      s390/pci: PCI adapter interrupts for MSI/MSI-X
      s390/bitops: find leftmost bit instruction support
      s390/pci: CLP interface
      s390/pci: base support
      ...

commit 9a4da8a5b109906a64bed5aaeb83bf4edb1f5888
Author: Jan Glauber <jang@linux.vnet.ibm.com>
Date:   Thu Nov 29 13:05:05 2012 +0100

    s390/pci: PCI adapter interrupts for MSI/MSI-X
    
    Support PCI adapter interrupts using the Single-IRQ-mode. Single-IRQ-mode
    disables an adapter IRQ automatically after delivering it until the SIC
    instruction enables it again. This is used to reduce the number of IRQs
    for streaming workloads.
    
    Up to 64 MSI handlers can be registered per PCI function.
    A hash table is used to map interrupt numbers to MSI descriptors.
    The interrupt vector is scanned using the flogr instruction.
    Only MSI/MSI-X interrupts are supported, no legacy INTs.
    
    Signed-off-by: Jan Glauber <jang@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 216b0ba109d7..e21ed837c673 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -10,9 +10,6 @@
  */
 
 #include <linux/smp.h>
-
-#ifndef CONFIG_S390
-
 #include <linux/linkage.h>
 #include <linux/cache.h>
 #include <linux/spinlock.h>
@@ -737,8 +734,11 @@ static inline void irq_gc_lock(struct irq_chip_generic *gc) { }
 static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
 #endif
 
-#endif /* CONFIG_GENERIC_HARDIRQS */
+#else /* !CONFIG_GENERIC_HARDIRQS */
 
-#endif /* !CONFIG_S390 */
+extern struct msi_desc *irq_get_msi_desc(unsigned int irq);
+extern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);
+
+#endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* _LINUX_IRQ_H */

commit 293a7a0a165c4f8327bbcf396cee9ec672727c98
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 16 15:07:49 2012 -0700

    genirq: Provide means to retrigger parent
    
    Attempts to retrigger nested threaded IRQs currently fail because they
    have no primary handler. In order to support retrigger of nested
    IRQs, the parent IRQ needs to be retriggered.
    
    To fix, when an IRQ needs to be resent, if the interrupt has a parent
    IRQ and runs in the context of the parent IRQ, then resend the parent.
    
    Also, handle_nested_irq() needs to clear the replay flag like the
    other handlers, otherwise check_irq_resend() will set it and it will
    never be cleared.  Without clearing, it results in the first resend
    working fine, but check_irq_resend() returning early on subsequent
    resends because the replay flag is still set.
    
    Problem discovered on ARM/OMAP platforms where a nested IRQ that's
    also a wakeup IRQ happens late in suspend and needed to be retriggered
    during the resume process.
    
    [khilman@ti.com: changelog edits, clear IRQS_REPLAY in handle_nested_irq()]
    
    Reported-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1350425269-11489-1-git-send-email-khilman@deeprootsystems.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 216b0ba109d7..526f10a637c1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -392,6 +392,15 @@ static inline void irq_move_masked_irq(struct irq_data *data) { }
 
 extern int no_irq_affinity;
 
+#ifdef CONFIG_HARDIRQS_SW_RESEND
+int irq_set_parent(int irq, int parent_irq);
+#else
+static inline int irq_set_parent(int irq, int parent_irq)
+{
+	return 0;
+}
+#endif
+
 /*
  * Built-in IRQ handlers for various IRQ types,
  * callable via desc->handle_irq()

commit dc9b229a58dc0dfed34272ff26c6d5fd17c674e0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 13 19:29:45 2012 +0200

    genirq: Allow irq chips to mark themself oneshot safe
    
    Some interrupt chips like MSI are oneshot safe by implementation. For
    those interrupts we can avoid the mask/unmask sequence for threaded
    interrupt handlers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1207132056540.32033@ionos
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Avi Kivity <avi@redhat.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Jan Kiszka <jan.kiszka@web.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 553fb66da130..216b0ba109d7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -349,6 +349,7 @@ enum {
 	IRQCHIP_MASK_ON_SUSPEND		= (1 <<  2),
 	IRQCHIP_ONOFFLINE_ENABLED	= (1 <<  3),
 	IRQCHIP_SKIP_SET_WAKE		= (1 <<  4),
+	IRQCHIP_ONESHOT_SAFE		= (1 <<  5),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit bd3e57f9132ac55e2848aa10cf50341de2508e1d
Merge: 3fad0953a12f 36d93d88a539
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 22 12:19:36 2012 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 platform changes from Ingo Molnar:
     "This tree mostly involves various APIC driver cleanups/robustization,
      and vSMP motivated platform callback improvements/cleanups"
    
    Fix up trivial conflict due to printk cleanup right next to return value
    change.
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (29 commits)
      Revert "x86/early_printk: Replace obsolete simple_strtoul() usage with kstrtoint()"
      x86/apic/x2apic: Use multiple cluster members for the irq destination only with the explicit affinity
      x86/apic/x2apic: Limit the vector reservation to the user specified mask
      x86/apic: Optimize cpu traversal in __assign_irq_vector() using domain membership
      x86/vsmp: Fix vector_allocation_domain's return value
      irq/apic: Use config_enabled(CONFIG_SMP) checks to clean up irq_set_affinity() for UP
      x86/vsmp: Fix linker error when CONFIG_PROC_FS is not set
      x86/apic/es7000: Make apicid of a cluster (not CPU) from a cpumask
      x86/apic/es7000+summit: Always make valid apicid from a cpumask
      x86/apic/es7000+summit: Fix compile warning in cpu_mask_to_apicid()
      x86/apic: Fix ugly casting and branching in cpu_mask_to_apicid_and()
      x86/apic: Eliminate cpu_mask_to_apicid() operation
      x86/x2apic/cluster: Vector_allocation_domain() should return a value
      x86/apic/irq_remap: Silence a bogus pr_err()
      x86/vsmp: Ignore IOAPIC IRQ affinity if possible
      x86/apic: Make cpu_mask_to_apicid() operations check cpu_online_mask
      x86/apic: Make cpu_mask_to_apicid() operations return error code
      x86/apic: Avoid useless scanning thru a cpumask in assign_irq_vector()
      x86/apic: Try to spread IRQ vectors to different priority levels
      x86/apic: Factor out default vector_allocation_domain() operation
      ...

commit 87fac288083db40b5d5ab845393be268357c8827
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jun 30 15:30:46 2012 -0700

    linux/irq.h: fix kernel-doc warning
    
    Fix kernel-doc warning.  This struct member was removed in commit
    875682648b89 ("irq: Remove irq_chip->release()") so remove its
    associated kernel-doc entry also.
    
      Warning(include/linux/irq.h:338): Excess struct/union/enum/typedef member 'release' description in 'irq_chip'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 61f5cec031e0..a5261e3d2e3c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -301,8 +301,6 @@ static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
  * @irq_pm_shutdown:	function called from core code on shutdown once per chip
  * @irq_print_chip:	optional to print special chip info in show_interrupts
  * @flags:		chip specific flags
- *
- * @release:		release function solely used by UML
  */
 struct irq_chip {
 	const char	*name;

commit 7eb9ae0799b1e9f0b77733b432bc5f6f055b020b
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jun 14 18:28:49 2012 -0700

    irq/apic: Use config_enabled(CONFIG_SMP) checks to clean up irq_set_affinity() for UP
    
    Move the ->irq_set_affinity() routines out of the #ifdef CONFIG_SMP
    sections and use config_enabled(CONFIG_SMP) checks inside those
    routines. Thus making those routines simple null stubs for
    !CONFIG_SMP and retaining those routines with no additional
    runtime overhead for CONFIG_SMP kernels.
    
    Cleans up the ifdef CONFIG_SMP in and around routines related to
    irq_set_affinity in io_apic and irq_remapping subsystems.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: torvalds@linux-foundation.org
    Cc: joerg.roedel@amd.com
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Link: http://lkml.kernel.org/r/1339723729.3475.63.camel@sbsiddha-desk.sc.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 61f5cec031e0..47a937cd84af 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -150,9 +150,7 @@ struct irq_data {
 	void			*handler_data;
 	void			*chip_data;
 	struct msi_desc		*msi_desc;
-#ifdef CONFIG_SMP
 	cpumask_var_t		affinity;
-#endif
 };
 
 /*

commit 875682648b89a3ebc06176d60dc280f810647839
Author: Richard Weinberger <richard@nod.at>
Date:   Tue Apr 17 22:37:16 2012 +0200

    irq: Remove irq_chip->release()
    
    As it's only user (UML) does no longer need it we can get
    rid of it.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b27cfcfd3a59..61f5cec031e0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -335,11 +335,6 @@ struct irq_chip {
 	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 
 	unsigned long	flags;
-
-	/* Currently used only by UML, might disappear one day.*/
-#ifdef CONFIG_IRQ_RELEASE_METHOD
-	void		(*release)(unsigned int irq, void *dev_id);
-#endif
 };
 
 /*

commit 3fca40c704dd013797f2c0c518f37cd2cc8e19fe
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Apr 19 17:29:42 2012 +0000

    irq: Add IRQ_TYPE_DEFAULT for use by PIC drivers
    
    This is meant typically to allow a PIC driver's irq domain map() callback
    to establish sane defaults for the interrupt (and make sure that the HW
    and the irq_desc are in sync as far as the trigger is concerned).
    
    The irq core may not call the set_trigger callback if it thinks the
    trigger is already set to the right setting, so we need to ensure new
    descriptors are properly synchronized with the hardware.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7810406f3d80..b27cfcfd3a59 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -49,6 +49,12 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * IRQ_TYPE_LEVEL_LOW		- low level triggered
  * IRQ_TYPE_LEVEL_MASK		- Mask to filter out the level bits
  * IRQ_TYPE_SENSE_MASK		- Mask for all the above bits
+ * IRQ_TYPE_DEFAULT		- For use by some PICs to ask irq_set_type
+ *				  to setup the HW to a sane default (used
+ *                                by irqdomain map() callbacks to synchronize
+ *                                the HW state and SW flags for a newly
+ *                                allocated descriptor).
+ *
  * IRQ_TYPE_PROBE		- Special flag for probing in progress
  *
  * Bits which can be modified via irq_set/clear/modify_status_flags()
@@ -77,6 +83,7 @@ enum {
 	IRQ_TYPE_LEVEL_LOW	= 0x00000008,
 	IRQ_TYPE_LEVEL_MASK	= (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH),
 	IRQ_TYPE_SENSE_MASK	= 0x0000000f,
+	IRQ_TYPE_DEFAULT	= IRQ_TYPE_SENSE_MASK,
 
 	IRQ_TYPE_PROBE		= 0x00000010,
 

commit a699e4e49ec3fb62c4a44394357d14081df10bef
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 3 07:11:04 2012 -0600

    irq: Kill pointless irqd_to_hw export
    
    It makes no sense to export this trivial function.  Make it a static inline
    instead.
    
    This patch also drops virq_to_hw from arch/c6x since it is unused by that
    architecture.
    
    v2: Move irq_hw_number_t into types.h to fix ARM build failure
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index bff29c58da23..7810406f3d80 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -263,6 +263,11 @@ static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
 	d->state_use_accessors &= ~IRQD_IRQ_INPROGRESS;
 }
 
+static inline irq_hw_number_t irqd_to_hwirq(struct irq_data *d)
+{
+	return d->hwirq;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit ec53cf23c0ddb0c29950b9a4ac46964c4c6c6c2f
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Sep 19 20:33:19 2011 -0400

    irq: don't put module.h into irq.h for tracking irqgen modules.
    
    Recent commit "irq: Track the  owner of irq descriptor" in
    commit ID b6873807a7143b7 placed module.h into linux/irq.h
    but we are trying to limit module.h inclusion to just C files
    that really need it, due to its size and number of children
    includes.  This targets just reversing that include.
    
    Add in the basic "struct module" since that is all we really need
    to ensure things compile.  In theory, b687380 should have added the
    module.h include to the irqdesc.h header as well, but the implicit
    module.h everywhere presence masked this from showing up.  So give
    it the "struct module" as well.
    
    As for the C files, irqdesc.c is only using THIS_MODULE, so it
    does not need module.h - give it export.h instead.  The C file
    irq/manage.c is now (as of b687380) using try_module_get and
    module_put and so it needs module.h (which it already has).
    
    Also convert the irq_alloc_descs variants to macros, since all
    they really do is is call the __irq_alloc_descs primitive.
    This avoids including export.h and no debug info is lost.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 59e49c80cc2c..bff29c58da23 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -23,13 +23,13 @@
 #include <linux/errno.h>
 #include <linux/topology.h>
 #include <linux/wait.h>
-#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
 
 struct seq_file;
+struct module;
 struct irq_desc;
 struct irq_data;
 typedef	void (*irq_flow_handler_t)(unsigned int irq,
@@ -567,29 +567,21 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 		struct module *owner);
 
-static inline int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt,
-		int node)
-{
-	return __irq_alloc_descs(irq, from, cnt, node, THIS_MODULE);
-}
+/* use macros to avoid needing export.h for THIS_MODULE */
+#define irq_alloc_descs(irq, from, cnt, node)	\
+	__irq_alloc_descs(irq, from, cnt, node, THIS_MODULE)
 
-void irq_free_descs(unsigned int irq, unsigned int cnt);
-int irq_reserve_irqs(unsigned int from, unsigned int cnt);
+#define irq_alloc_desc(node)			\
+	irq_alloc_descs(-1, 0, 1, node)
 
-static inline int irq_alloc_desc(int node)
-{
-	return irq_alloc_descs(-1, 0, 1, node);
-}
+#define irq_alloc_desc_at(at, node)		\
+	irq_alloc_descs(at, at, 1, node)
 
-static inline int irq_alloc_desc_at(unsigned int at, int node)
-{
-	return irq_alloc_descs(at, at, 1, node);
-}
+#define irq_alloc_desc_from(from, node)		\
+	irq_alloc_descs(-1, from, 1, node)
 
-static inline int irq_alloc_desc_from(unsigned int from, int node)
-{
-	return irq_alloc_descs(-1, from, 1, node);
-}
+void irq_free_descs(unsigned int irq, unsigned int cnt);
+int irq_reserve_irqs(unsigned int from, unsigned int cnt);
 
 static inline void irq_free_desc(unsigned int irq)
 {

commit 31d9d9b6d83030f748d013e61502fa5477e2ac0e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 23 17:03:06 2011 +0100

    genirq: Add support for per-cpu dev_id interrupts
    
    The ARM GIC interrupt controller offers per CPU interrupts (PPIs),
    which are usually used to connect local timers to each core. Each CPU
    has its own private interface to the GIC, and only sees the PPIs that
    are directly connect to it.
    
    While these timers are separate devices and have a separate interrupt
    line to a core, they all use the same IRQ number.
    
    For these devices, request_irq() is not the right API as it assumes
    that an IRQ number is visible by a number of CPUs (through the
    affinity setting), but makes it very awkward to express that an IRQ
    number can be handled by all CPUs, and yet be a different interrupt
    line on each CPU, requiring a different dev_id cookie to be passed
    back to the handler.
    
    The *_percpu_irq() functions is designed to overcome these
    limitations, by providing a per-cpu dev_id vector:
    
    int request_percpu_irq(unsigned int irq, irq_handler_t handler,
                       const char *devname, void __percpu *percpu_dev_id);
    void free_percpu_irq(unsigned int, void __percpu *);
    int setup_percpu_irq(unsigned int irq, struct irqaction *new);
    void remove_percpu_irq(unsigned int irq, struct irqaction *act);
    void enable_percpu_irq(unsigned int irq);
    void disable_percpu_irq(unsigned int irq);
    
    The API has a number of limitations:
    - no interrupt sharing
    - no threading
    - common handler across all the CPUs
    
    Once the interrupt is requested using setup_percpu_irq() or
    request_percpu_irq(), it must be enabled by each core that wishes its
    local interrupt to be delivered.
    
    Based on an initial patch by Thomas Gleixner.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1316793788-14500-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 73e31abeba1c..59e49c80cc2c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -66,6 +66,7 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
  * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
  * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
+ * IRQ_PER_CPU_DEVID		- Dev_id is a per-cpu variable
  */
 enum {
 	IRQ_TYPE_NONE		= 0x00000000,
@@ -88,12 +89,13 @@ enum {
 	IRQ_MOVE_PCNTXT		= (1 << 14),
 	IRQ_NESTED_THREAD	= (1 << 15),
 	IRQ_NOTHREAD		= (1 << 16),
+	IRQ_PER_CPU_DEVID	= (1 << 17),
 };
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
-	 IRQ_PER_CPU | IRQ_NESTED_THREAD)
+	 IRQ_PER_CPU | IRQ_NESTED_THREAD | IRQ_NOTHREAD | IRQ_PER_CPU_DEVID)
 
 #define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
 
@@ -367,6 +369,8 @@ enum {
 struct irqaction;
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 extern void remove_irq(unsigned int irq, struct irqaction *act);
+extern int setup_percpu_irq(unsigned int irq, struct irqaction *new);
+extern void remove_percpu_irq(unsigned int irq, struct irqaction *act);
 
 extern void irq_cpu_online(void);
 extern void irq_cpu_offline(void);
@@ -394,6 +398,7 @@ extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_edge_eoi_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_percpu_devid_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
@@ -422,6 +427,8 @@ static inline void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *c
 	irq_set_chip_and_handler_name(irq, chip, handle, NULL);
 }
 
+extern int irq_set_percpu_devid(unsigned int irq);
+
 extern void
 __irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 		  const char *name);
@@ -483,6 +490,13 @@ static inline void irq_set_nested_thread(unsigned int irq, bool nest)
 		irq_clear_status_flags(irq, IRQ_NESTED_THREAD);
 }
 
+static inline void irq_set_percpu_devid_flags(unsigned int irq)
+{
+	irq_set_status_flags(irq,
+			     IRQ_NOAUTOEN | IRQ_PER_CPU | IRQ_NOTHREAD |
+			     IRQ_NOPROBE | IRQ_PER_CPU_DEVID);
+}
+
 /* Handle dynamic irq creation and destruction */
 extern unsigned int create_irq_nr(unsigned int irq_want, int node);
 extern int create_irq(void);

commit 60f96b41f71d2a13d1c0a457b8b77958f77142d1
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Sep 9 13:59:35 2011 +0530

    genirq: Add IRQCHIP_SKIP_SET_WAKE flag
    
    Some irq chips need the irq_set_wake() functionality, but do not
    require a irq_set_wake() callback. Instead of forcing an empty
    callback to be implemented add a flag which notes this fact. Check for
    the flag in set_irq_wake_real() and return success when set.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 59517300a315..73e31abeba1c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -336,12 +336,14 @@ struct irq_chip {
  * IRQCHIP_MASK_ON_SUSPEND:	Mask non wake irqs in the suspend path
  * IRQCHIP_ONOFFLINE_ENABLED:	Only call irq_on/off_line callbacks
  *				when irq enabled
+ * IRQCHIP_SKIP_SET_WAKE:	Skip chip.irq_set_wake(), for this irq chip
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
 	IRQCHIP_EOI_IF_HANDLED		= (1 <<  1),
 	IRQCHIP_MASK_ON_SUSPEND		= (1 <<  2),
 	IRQCHIP_ONOFFLINE_ENABLED	= (1 <<  3),
+	IRQCHIP_SKIP_SET_WAKE		= (1 <<  4),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit 950d0a10d12578a270f3dfa9fd76fe5c2deb343f
Merge: ab7e2dbf9b5d b6873807a714
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 17 10:23:50 2011 -0700

    Merge branch 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      irq: Track the owner of irq descriptor
      irq: Always set IRQF_ONESHOT if no primary handler is specified
      genirq: Fix wrong bit operation

commit b6873807a7143b7d6d8b06809295e559d07d7deb
Author: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date:   Mon Jul 11 12:17:31 2011 +0200

    irq: Track the owner of irq descriptor
    
    Interrupt descriptors can be allocated from modules. The interrupts
    are used by other modules, but we have no refcount on the module which
    provides the interrupts and there is no way to establish one on the
    device level as the interrupt using module is agnostic to the fact
    that the interrupt is provided by a module rather than by some builtin
    interrupt controller.
    
    To prevent removal of the interrupt providing module, we can track the
    owner of the interrupt descriptor, which also provides the relevant
    irq chip functions in the irq descriptor.
    
    request/setup_irq() can now acquire a refcount on the owner module to
    prevent unloading. free_irq() drops the refcount.
    
    Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Link: http://lkml.kernel.org/r/20110711101731.GA13804@Chamillionaire.breakpoint.cc
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index baa397eb9c33..16d6f54ef1dd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -23,6 +23,7 @@
 #include <linux/errno.h>
 #include <linux/topology.h>
 #include <linux/wait.h>
+#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -546,7 +547,15 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 	return d->msi_desc;
 }
 
-int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
+int __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
+		struct module *owner);
+
+static inline int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt,
+		int node)
+{
+	return __irq_alloc_descs(irq, from, cnt, node, THIS_MODULE);
+}
+
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 int irq_reserve_irqs(unsigned int from, unsigned int cnt);
 

commit 08a543ad33fc188650801bd36eed4ffe272643e1
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jul 26 03:19:06 2011 -0600

    irq: add irq_domain translation infrastructure
    
    This patch adds irq_domain infrastructure for translating from
    hardware irq numbers to linux irqs.  This is particularly important
    for architectures adding device tree support because the current
    implementation (excluding PowerPC and SPARC) cannot handle
    translation for more than a single interrupt controller.  irq_domain
    supports device tree translation for any number of interrupt
    controllers.
    
    This patch converts x86, Microblaze, ARM and MIPS to use irq_domain
    for device tree irq translation.  x86 is untested beyond compiling it,
    irq_domain is enabled for MIPS and Microblaze, but the old behaviour is
    preserved until the core code is modified to actually register an
    irq_domain yet.  On ARM it works and is required for much of the new
    ARM device tree board support.
    
    PowerPC has /not/ been converted to use this new infrastructure.  It
    is still missing some features before it can replace the virq
    infrastructure already in powerpc (see documentation on
    irq_domain_map/unmap for details).  Followup patches will add the
    missing pieces and migrate PowerPC to use irq_domain.
    
    SPARC has its own method of managing interrupts from the device tree
    and is unaffected by this change.
    
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5f695041090c..87a06f345bd2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -108,14 +108,18 @@ enum {
 };
 
 struct msi_desc;
+struct irq_domain;
 
 /**
  * struct irq_data - per irq and irq chip data passed down to chip functions
  * @irq:		interrupt number
+ * @hwirq:		hardware interrupt number, local to the interrupt domain
  * @node:		node index useful for balancing
  * @state_use_accessors: status information for irq chip functions.
  *			Use accessor functions to deal with it
  * @chip:		low level interrupt hardware access
+ * @domain:		Interrupt translation domain; responsible for mapping
+ *			between hwirq number and linux irq number.
  * @handler_data:	per-IRQ data for the irq_chip methods
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations
@@ -128,9 +132,11 @@ struct msi_desc;
  */
 struct irq_data {
 	unsigned int		irq;
+	unsigned long		hwirq;
 	unsigned int		node;
 	unsigned int		state_use_accessors;
 	struct irq_chip		*chip;
+	struct irq_domain	*domain;
 	void			*handler_data;
 	void			*chip_data;
 	struct msi_desc		*msi_desc;

commit c0c463d34adf0c150e5e24fa412fa23f3f7ddc27
Merge: e72542191cbb a03fc8c37551 f505c553dbe2 a7de915383a6 08a4a43fc407
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 23 10:33:08 2011 -0700

    Merge branches 'x86-urgent-for-linus', 'core-debug-for-linus', 'irq-core-for-linus' and 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      um: Make rwsem.S depend on CONFIG_RWSEM_XCHGADD_ALGORITHM
    
    * 'core-debug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      debug: Make CONFIG_EXPERT select CONFIG_DEBUG_KERNEL to unhide debug options
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq: Remove unused CHECK_IRQ_PER_CPU()
    
    * 'perf-urgent-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      perf tools, x86: Fix 32-bit compile on 64-bit system

commit 659fb32d1b67476f4ade25e9ea0e2642a5b9c4b5
Author: Simon Guinot <sguinot@lacie.com>
Date:   Wed Jul 6 12:41:31 2011 -0400

    genirq: replace irq_gc_ack() with {set,clr}_bit variants (fwd)
    
    This fixes a regression introduced by e59347a "arm: orion:
    Use generic irq chip".
    
    Depending on the device, interrupts acknowledgement is done by setting
    or by clearing a dedicated register. Replace irq_gc_ack() with some
    {set,clr}_bit variants allows to handle both cases.
    
    Note that this patch affects the following SoCs: Davinci, Samsung and
    Orion. Except for this last, the change is minor: irq_gc_ack() is just
    renamed into irq_gc_ack_set_bit().
    
    For the Orion SoCs, the edge GPIO interrupts support is currently
    broken. irq_gc_ack() try to acknowledge a such interrupt by setting
    the corresponding cause register bit. The Orion GPIO device expect the
    opposite. To fix this issue, the irq_gc_ack_clr_bit() variant is used.
    
    Tested on Network Space v2.
    
    Reported-by: Joey Oravec <joravec@drewtech.com>
    Signed-off-by: Simon Guinot <sguinot@lacie.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8b4538446636..baa397eb9c33 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -676,7 +676,8 @@ void irq_gc_mask_disable_reg(struct irq_data *d);
 void irq_gc_mask_set_bit(struct irq_data *d);
 void irq_gc_mask_clr_bit(struct irq_data *d);
 void irq_gc_unmask_enable_reg(struct irq_data *d);
-void irq_gc_ack(struct irq_data *d);
+void irq_gc_ack_set_bit(struct irq_data *d);
+void irq_gc_ack_clr_bit(struct irq_data *d);
 void irq_gc_mask_disable_reg_and_ack(struct irq_data *d);
 void irq_gc_eoi(struct irq_data *d);
 int irq_gc_set_wake(struct irq_data *d, unsigned int on);

commit a7de915383a6d5c05663f9badbd10d5a87bc1586
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 22 22:53:27 2011 +0200

    genirq: Remove unused CHECK_IRQ_PER_CPU()
    
    No more users. Kill it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8b4538446636..68258f0369db 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -96,11 +96,6 @@ enum {
 
 #define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
 
-static inline __deprecated bool CHECK_IRQ_PER_CPU(unsigned int status)
-{
-	return status & IRQ_PER_CPU;
-}
-
 /*
  * Return value for chip->irq_set_affinity()
  *

commit cfefd21e693dca791bf9ecfc9dd3794facad533c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 15 22:36:08 2011 +0200

    genirq: Add chip suspend and resume callbacks
    
    These callbacks are only called in the syscore suspend/resume code on
    interrupt chips which have been registered via the generic irq chip
    mechanism. Calling those callbacks per irq would be rather icky, but
    with the generic irq chip mechanism we can call this per registered
    chip.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2ba2f1216790..8b4538446636 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -280,6 +280,9 @@ static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
  * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
  * @irq_cpu_online:	configure an interrupt source for a secondary CPU
  * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU
+ * @irq_suspend:	function called from core code on suspend once per chip
+ * @irq_resume:		function called from core code on resume once per chip
+ * @irq_pm_shutdown:	function called from core code on shutdown once per chip
  * @irq_print_chip:	optional to print special chip info in show_interrupts
  * @flags:		chip specific flags
  *
@@ -309,6 +312,10 @@ struct irq_chip {
 	void		(*irq_cpu_online)(struct irq_data *data);
 	void		(*irq_cpu_offline)(struct irq_data *data);
 
+	void		(*irq_suspend)(struct irq_data *data);
+	void		(*irq_resume)(struct irq_data *data);
+	void		(*irq_pm_shutdown)(struct irq_data *data);
+
 	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 
 	unsigned long	flags;
@@ -626,6 +633,7 @@ struct irq_chip_type {
  * @wake_active:	Interrupt is marked as an wakeup from suspend source
  * @num_ct:		Number of available irq_chip_type instances (usually 1)
  * @private:		Private data for non generic chip callbacks
+ * @list:		List head for keeping track of instances
  * @chip_types:		Array of interrupt irq_chip_types
  *
  * Note, that irq_chip_generic can have multiple irq_chip_type
@@ -646,6 +654,7 @@ struct irq_chip_generic {
 	u32			wake_active;
 	unsigned int		num_ct;
 	void			*private;
+	struct list_head	list;
 	struct irq_chip_type	chip_types[0];
 };
 
@@ -680,6 +689,8 @@ void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,
 			    enum irq_gc_flags flags, unsigned int clr,
 			    unsigned int set);
 int irq_setup_alt_chip(struct irq_data *d, unsigned int type);
+void irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,
+			     unsigned int clr, unsigned int set);
 
 static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
 {

commit 7d8280624797bbe2f5170bd3c85c75a8c9c74242
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Apr 3 11:42:53 2011 +0200

    genirq: Implement a generic interrupt chip
    
    Implement a generic interrupt chip, which is configurable and is able
    to handle the most common irq chip implementations.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Tested-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by; Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 39c23786c1db..2ba2f1216790 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -568,6 +568,141 @@ static inline int irq_reserve_irq(unsigned int irq)
 	return irq_reserve_irqs(irq, 1);
 }
 
+#ifndef irq_reg_writel
+# define irq_reg_writel(val, addr)	writel(val, addr)
+#endif
+#ifndef irq_reg_readl
+# define irq_reg_readl(addr)		readl(addr)
+#endif
+
+/**
+ * struct irq_chip_regs - register offsets for struct irq_gci
+ * @enable:	Enable register offset to reg_base
+ * @disable:	Disable register offset to reg_base
+ * @mask:	Mask register offset to reg_base
+ * @ack:	Ack register offset to reg_base
+ * @eoi:	Eoi register offset to reg_base
+ * @type:	Type configuration register offset to reg_base
+ * @polarity:	Polarity configuration register offset to reg_base
+ */
+struct irq_chip_regs {
+	unsigned long		enable;
+	unsigned long		disable;
+	unsigned long		mask;
+	unsigned long		ack;
+	unsigned long		eoi;
+	unsigned long		type;
+	unsigned long		polarity;
+};
+
+/**
+ * struct irq_chip_type - Generic interrupt chip instance for a flow type
+ * @chip:		The real interrupt chip which provides the callbacks
+ * @regs:		Register offsets for this chip
+ * @handler:		Flow handler associated with this chip
+ * @type:		Chip can handle these flow types
+ *
+ * A irq_generic_chip can have several instances of irq_chip_type when
+ * it requires different functions and register offsets for different
+ * flow types.
+ */
+struct irq_chip_type {
+	struct irq_chip		chip;
+	struct irq_chip_regs	regs;
+	irq_flow_handler_t	handler;
+	u32			type;
+};
+
+/**
+ * struct irq_chip_generic - Generic irq chip data structure
+ * @lock:		Lock to protect register and cache data access
+ * @reg_base:		Register base address (virtual)
+ * @irq_base:		Interrupt base nr for this chip
+ * @irq_cnt:		Number of interrupts handled by this chip
+ * @mask_cache:		Cached mask register
+ * @type_cache:		Cached type register
+ * @polarity_cache:	Cached polarity register
+ * @wake_enabled:	Interrupt can wakeup from suspend
+ * @wake_active:	Interrupt is marked as an wakeup from suspend source
+ * @num_ct:		Number of available irq_chip_type instances (usually 1)
+ * @private:		Private data for non generic chip callbacks
+ * @chip_types:		Array of interrupt irq_chip_types
+ *
+ * Note, that irq_chip_generic can have multiple irq_chip_type
+ * implementations which can be associated to a particular irq line of
+ * an irq_chip_generic instance. That allows to share and protect
+ * state in an irq_chip_generic instance when we need to implement
+ * different flow mechanisms (level/edge) for it.
+ */
+struct irq_chip_generic {
+	raw_spinlock_t		lock;
+	void __iomem		*reg_base;
+	unsigned int		irq_base;
+	unsigned int		irq_cnt;
+	u32			mask_cache;
+	u32			type_cache;
+	u32			polarity_cache;
+	u32			wake_enabled;
+	u32			wake_active;
+	unsigned int		num_ct;
+	void			*private;
+	struct irq_chip_type	chip_types[0];
+};
+
+/**
+ * enum irq_gc_flags - Initialization flags for generic irq chips
+ * @IRQ_GC_INIT_MASK_CACHE:	Initialize the mask_cache by reading mask reg
+ * @IRQ_GC_INIT_NESTED_LOCK:	Set the lock class of the irqs to nested for
+ *				irq chips which need to call irq_set_wake() on
+ *				the parent irq. Usually GPIO implementations
+ */
+enum irq_gc_flags {
+	IRQ_GC_INIT_MASK_CACHE		= 1 << 0,
+	IRQ_GC_INIT_NESTED_LOCK		= 1 << 1,
+};
+
+/* Generic chip callback functions */
+void irq_gc_noop(struct irq_data *d);
+void irq_gc_mask_disable_reg(struct irq_data *d);
+void irq_gc_mask_set_bit(struct irq_data *d);
+void irq_gc_mask_clr_bit(struct irq_data *d);
+void irq_gc_unmask_enable_reg(struct irq_data *d);
+void irq_gc_ack(struct irq_data *d);
+void irq_gc_mask_disable_reg_and_ack(struct irq_data *d);
+void irq_gc_eoi(struct irq_data *d);
+int irq_gc_set_wake(struct irq_data *d, unsigned int on);
+
+/* Setup functions for irq_chip_generic */
+struct irq_chip_generic *
+irq_alloc_generic_chip(const char *name, int nr_ct, unsigned int irq_base,
+		       void __iomem *reg_base, irq_flow_handler_t handler);
+void irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,
+			    enum irq_gc_flags flags, unsigned int clr,
+			    unsigned int set);
+int irq_setup_alt_chip(struct irq_data *d, unsigned int type);
+
+static inline struct irq_chip_type *irq_data_get_chip_type(struct irq_data *d)
+{
+	return container_of(d->chip, struct irq_chip_type, chip);
+}
+
+#define IRQ_MSK(n) (u32)((n) < 32 ? ((1 << (n)) - 1) : UINT_MAX)
+
+#ifdef CONFIG_SMP
+static inline void irq_gc_lock(struct irq_chip_generic *gc)
+{
+	raw_spin_lock(&gc->lock);
+}
+
+static inline void irq_gc_unlock(struct irq_chip_generic *gc)
+{
+	raw_spin_unlock(&gc->lock);
+}
+#else
+static inline void irq_gc_lock(struct irq_chip_generic *gc) { }
+static inline void irq_gc_unlock(struct irq_chip_generic *gc) { }
+#endif
+
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */

commit 7f1b1244e159a8490d7fb13667c6cb7e1e75046b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 7 06:01:44 2011 +0900

    genirq: Support per-IRQ thread disabling.
    
    This adds support for disabling threading on a per-IRQ basis via the IRQ
    status instead of the IRQ flow, which is necessary for interrupts that
    don't follow the natural IRQ flow channels, such as those that are
    virtually created.
    
    The new APIs added are simply:
    
            irq_set_thread()
            irq_set_nothread()
    
    which follow the rest of the IRQ status routines.
    
    Chained handlers also have IRQ_NOTHREAD set on them automatically, making
    the lack of threading explicit rather than implicit. Subsequently, the
    nothread flag can be viewed through the standard genirq debugging
    facilities.
    
    [ tglx: Fixed cleanup fallout ]
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Link: http://lkml.kernel.org/r/%3C20110406210135.GF18426%40linux-sh.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a71dd18639fb..39c23786c1db 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -59,6 +59,7 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * IRQ_NOPROBE			- Interrupt cannot be probed by autoprobing
  * IRQ_NOREQUEST		- Interrupt cannot be requested via
  *				  request_irq()
+ * IRQ_NOTHREAD			- Interrupt cannot be threaded
  * IRQ_NOAUTOEN			- Interrupt is not automatically enabled in
  *				  request/setup_irq()
  * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
@@ -85,6 +86,7 @@ enum {
 	IRQ_NO_BALANCING	= (1 << 13),
 	IRQ_MOVE_PCNTXT		= (1 << 14),
 	IRQ_NESTED_THREAD	= (1 << 15),
+	IRQ_NOTHREAD		= (1 << 16),
 };
 
 #define IRQF_MODIFY_MASK	\
@@ -422,7 +424,7 @@ irq_set_handler(unsigned int irq, irq_flow_handler_t handle)
 /*
  * Set a highlevel chained flow handler for a given IRQ.
  * (a chained handler is automatically enabled and set to
- *  IRQ_NOREQUEST and IRQ_NOPROBE)
+ *  IRQ_NOREQUEST, IRQ_NOPROBE, and IRQ_NOTHREAD)
  */
 static inline void
 irq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)
@@ -452,6 +454,16 @@ static inline void irq_set_probe(unsigned int irq)
 	irq_modify_status(irq, IRQ_NOPROBE, 0);
 }
 
+static inline void irq_set_nothread(unsigned int irq)
+{
+	irq_modify_status(irq, 0, IRQ_NOTHREAD);
+}
+
+static inline void irq_set_thread(unsigned int irq)
+{
+	irq_modify_status(irq, IRQ_NOTHREAD, 0);
+}
+
 static inline void irq_set_nested_thread(unsigned int irq, bool nest)
 {
 	if (nest)

commit 0911f124bf55357803d53197cc1ae5479f5e37e2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 10 11:01:51 2011 +0200

    genirq: Forgotten updates/deletions after removal of compat code
    
    commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1 ("genirq: Remove compat code")
    removed the compat code, but forgot to update some references in comments and
    delete some of its documentation.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Link: http://lkml.kernel.org/r/%3C1302426113-13808-1-git-send-email-geert%40linux-m68k.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 09a308072f56..a71dd18639fb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -53,7 +53,7 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * Bits which can be modified via irq_set/clear/modify_status_flags()
  * IRQ_LEVEL			- Interrupt is level type. Will be also
  *				  updated in the code when the above trigger
- *				  bits are modified via set_irq_type()
+ *				  bits are modified via irq_set_irq_type()
  * IRQ_PER_CPU			- Mark an interrupt PER_CPU. Will protect
  *				  it from affinity setting
  * IRQ_NOPROBE			- Interrupt cannot be probed by autoprobing
@@ -261,23 +261,6 @@ static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
  * struct irq_chip - hardware interrupt chip descriptor
  *
  * @name:		name for /proc/interrupts
- * @startup:		deprecated, replaced by irq_startup
- * @shutdown:		deprecated, replaced by irq_shutdown
- * @enable:		deprecated, replaced by irq_enable
- * @disable:		deprecated, replaced by irq_disable
- * @ack:		deprecated, replaced by irq_ack
- * @mask:		deprecated, replaced by irq_mask
- * @mask_ack:		deprecated, replaced by irq_mask_ack
- * @unmask:		deprecated, replaced by irq_unmask
- * @eoi:		deprecated, replaced by irq_eoi
- * @end:		deprecated, will go away with __do_IRQ()
- * @set_affinity:	deprecated, replaced by irq_set_affinity
- * @retrigger:		deprecated, replaced by irq_retrigger
- * @set_type:		deprecated, replaced by irq_set_type
- * @set_wake:		deprecated, replaced by irq_wake
- * @bus_lock:		deprecated, replaced by irq_bus_lock
- * @bus_sync_unlock:	deprecated, replaced by irq_bus_sync_unlock
- *
  * @irq_startup:	start up the interrupt (defaults to ->enable if NULL)
  * @irq_shutdown:	shut down the interrupt (defaults to ->disable if NULL)
  * @irq_enable:		enable the interrupt (defaults to chip->unmask if NULL)

commit 28959f268f910b2cd1c25e838b63c342062e28f2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 30 00:37:41 2011 +0200

    genirq: Remove obsolete comment
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2a375a72ce3c..09a308072f56 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -64,13 +64,6 @@ typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
  * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
  * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
  * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
- *
- * Deprecated bits. They are kept updated as long as
- * CONFIG_GENERIC_HARDIRQS_NO_COMPAT is not set. Will go away soon. These bits
- * are internal state of the core code and if you really need to acces
- * them then talk to the genirq maintainer instead of hacking
- * something weird.
- *
  */
 enum {
 	IRQ_TYPE_NONE		= 0x00000000,

commit 851d7cf647e0d31668eb5dc496f7698a2f6136b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 29 02:51:13 2011 +0200

    genirq: Remove move_*irq leftovers
    
    All users converted to new interface.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7b3faace437d..2a375a72ce3c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -386,13 +386,9 @@ extern int __irq_set_affinity_locked(struct irq_data *data,  const struct cpumas
 #ifdef CONFIG_GENERIC_HARDIRQS
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
-void move_native_irq(int irq);
-void move_masked_irq(int irq);
 void irq_move_irq(struct irq_data *data);
 void irq_move_masked_irq(struct irq_data *data);
 #else
-static inline void move_native_irq(int irq) { }
-static inline void move_masked_irq(int irq) { }
 static inline void irq_move_irq(struct irq_data *data) { }
 static inline void irq_move_masked_irq(struct irq_data *data) { }
 #endif

commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 13:32:20 2011 +0200

    genirq: Remove compat code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b3741c83774c..7b3faace437d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -92,18 +92,6 @@ enum {
 	IRQ_NO_BALANCING	= (1 << 13),
 	IRQ_MOVE_PCNTXT		= (1 << 14),
 	IRQ_NESTED_THREAD	= (1 << 15),
-
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-	IRQ_INPROGRESS		= (1 << 16),
-	IRQ_REPLAY		= (1 << 17),
-	IRQ_WAITING		= (1 << 18),
-	IRQ_DISABLED		= (1 << 19),
-	IRQ_PENDING		= (1 << 20),
-	IRQ_MASKED		= (1 << 21),
-	IRQ_MOVE_PENDING	= (1 << 22),
-	IRQ_AFFINITY_SET	= (1 << 23),
-	IRQ_WAKEUP		= (1 << 24),
-#endif
 };
 
 #define IRQF_MODIFY_MASK	\
@@ -321,28 +309,6 @@ static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
  */
 struct irq_chip {
 	const char	*name;
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
-	unsigned int	(*startup)(unsigned int irq);
-	void		(*shutdown)(unsigned int irq);
-	void		(*enable)(unsigned int irq);
-	void		(*disable)(unsigned int irq);
-
-	void		(*ack)(unsigned int irq);
-	void		(*mask)(unsigned int irq);
-	void		(*mask_ack)(unsigned int irq);
-	void		(*unmask)(unsigned int irq);
-	void		(*eoi)(unsigned int irq);
-
-	void		(*end)(unsigned int irq);
-	int		(*set_affinity)(unsigned int irq,
-					const struct cpumask *dest);
-	int		(*retrigger)(unsigned int irq);
-	int		(*set_type)(unsigned int irq, unsigned int flow_type);
-	int		(*set_wake)(unsigned int irq, unsigned int on);
-
-	void		(*bus_lock)(unsigned int irq);
-	void		(*bus_sync_unlock)(unsigned int irq);
-#endif
 	unsigned int	(*irq_startup)(struct irq_data *data);
 	void		(*irq_shutdown)(struct irq_data *data);
 	void		(*irq_enable)(struct irq_data *data);
@@ -589,89 +555,6 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 	return d->msi_desc;
 }
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-/* Please do not use: Use the replacement functions instead */
-static inline int set_irq_chip(unsigned int irq, struct irq_chip *chip)
-{
-	return irq_set_chip(irq, chip);
-}
-static inline int set_irq_data(unsigned int irq, void *data)
-{
-	return irq_set_handler_data(irq, data);
-}
-static inline int set_irq_chip_data(unsigned int irq, void *data)
-{
-	return irq_set_chip_data(irq, data);
-}
-static inline int set_irq_type(unsigned int irq, unsigned int type)
-{
-	return irq_set_irq_type(irq, type);
-}
-static inline int set_irq_msi(unsigned int irq, struct msi_desc *entry)
-{
-	return irq_set_msi_desc(irq, entry);
-}
-static inline struct irq_chip *get_irq_chip(unsigned int irq)
-{
-	return irq_get_chip(irq);
-}
-static inline void *get_irq_chip_data(unsigned int irq)
-{
-	return irq_get_chip_data(irq);
-}
-static inline void *get_irq_data(unsigned int irq)
-{
-	return irq_get_handler_data(irq);
-}
-static inline void *irq_data_get_irq_data(struct irq_data *d)
-{
-	return irq_data_get_irq_handler_data(d);
-}
-static inline struct msi_desc *get_irq_msi(unsigned int irq)
-{
-	return irq_get_msi_desc(irq);
-}
-static inline void set_irq_noprobe(unsigned int irq)
-{
-	irq_set_noprobe(irq);
-}
-static inline void set_irq_probe(unsigned int irq)
-{
-	irq_set_probe(irq);
-}
-static inline void set_irq_nested_thread(unsigned int irq, int nest)
-{
-	irq_set_nested_thread(irq, nest);
-}
-static inline void
-set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
-			      irq_flow_handler_t handle, const char *name)
-{
-	irq_set_chip_and_handler_name(irq, chip, handle, name);
-}
-static inline void
-set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
-			 irq_flow_handler_t handle)
-{
-	irq_set_chip_and_handler(irq, chip, handle);
-}
-static inline void
-__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
-		  const char *name)
-{
-	__irq_set_handler(irq, handle, is_chained, name);
-}
-static inline void set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
-{
-	irq_set_handler(irq, handle);
-}
-static inline void
-set_irq_chained_handler(unsigned int irq, irq_flow_handler_t handle)
-{
-	irq_set_chained_handler(irq, handle);
-}
-#endif
-
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 int irq_reserve_irqs(unsigned int from, unsigned int cnt);

commit 30398bf6c684a77274dbdabf7efc1f24e4a99028
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Mar 18 09:33:56 2011 -0700

    genirq: Fix new kernel-doc warnings
    
    Fix new irq-related kernel-doc warnings in 2.6.38:
    
    Warning(kernel/irq/manage.c:149): No description found for parameter 'mask'
    Warning(kernel/irq/manage.c:149): Excess function parameter 'cpumask' description in 'irq_set_affinity'
    Warning(include/linux/irq.h:161): No description found for parameter 'state_use_accessors'
    Warning(include/linux/irq.h:161): Excess struct/union/enum/typedef member 'state_use_accessor' description in 'irq_data'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    LKML-Reference: <20110318093356.b939558d.randy.dunlap@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 34b954e54267..b3741c83774c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -135,7 +135,7 @@ struct msi_desc;
  * struct irq_data - per irq and irq chip data passed down to chip functions
  * @irq:		interrupt number
  * @node:		node index useful for balancing
- * @state_use_accessor: status information for irq chip functions.
+ * @state_use_accessors: status information for irq chip functions.
  *			Use accessor functions to deal with it
  * @chip:		low level interrupt hardware access
  * @handler_data:	per-IRQ data for the irq_chip methods

commit ee38c04b58983a236b43bae71b2415d38bceaf75
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 17:11:13 2011 +0200

    genirq: Add setter for AFFINITY_SET in irq_data state
    
    Some archs want to prevent the default affinity being set on their
    chips in the reqeust_irq() path.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 84e1c5832c93..34b954e54267 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -212,6 +212,11 @@ static inline bool irqd_affinity_was_set(struct irq_data *d)
 	return d->state_use_accessors & IRQD_AFFINITY_SET;
 }
 
+static inline void irqd_mark_affinity_was_set(struct irq_data *d)
+{
+	d->state_use_accessors |= IRQD_AFFINITY_SET;
+}
+
 static inline u32 irqd_get_trigger_type(struct irq_data *d)
 {
 	return d->state_use_accessors & IRQD_TRIGGER_MASK;

commit 9cff60dfc3d54b60bc069627cee5624bfaa3f823
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 16:41:14 2011 +0200

    genirq: Provide setter inline for IRQD_IRQ_INPROGRESS
    
    Special function for demultiplexing handlers which can be disabled via
    disable_irq().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 41fc783171fd..84e1c5832c93 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -256,6 +256,21 @@ static inline bool irqd_irq_inprogress(struct irq_data *d)
 	return d->state_use_accessors & IRQD_IRQ_INPROGRESS;
 }
 
+/*
+ * Functions for chained handlers which can be enabled/disabled by the
+ * standard disable_irq/enable_irq calls. Must be called with
+ * irq_desc->lock held.
+ */
+static inline void irqd_set_chained_irq_inprogress(struct irq_data *d)
+{
+	d->state_use_accessors |= IRQD_IRQ_INPROGRESS;
+}
+
+static inline void irqd_clr_chained_irq_inprogress(struct irq_data *d)
+{
+	d->state_use_accessors &= ~IRQD_IRQ_INPROGRESS;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit 33b054b867b84015173a38d9cd9ff513b6498818
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 16:27:31 2011 +0200

    genirq: Remove handle_IRQ_event
    
    Last user gone.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 44ebca745789..41fc783171fd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -413,9 +413,6 @@ static inline void irq_move_masked_irq(struct irq_data *data) { }
 
 extern int no_irq_affinity;
 
-/* Handle irq action chains: */
-extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
-
 /*
  * Built-in IRQ handlers for various IRQ types,
  * callable via desc->handle_irq()

commit 0521c8fbb3da45c2a58cd551ca6e9644983f6028
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 16:13:24 2011 +0200

    genirq: Provide edge_eoi flow handler
    
    This is a replacment for the cell flow handler which is in the way of
    cleanups. Must be selected to avoid general bloat.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 18aacccb0fae..44ebca745789 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -423,6 +423,7 @@ extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
 extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_edge_eoi_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);

commit 32f4125ebffee4f3c4dbc6a437fc656129eb9e60
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 14:10:52 2011 +0200

    genirq: Move INPROGRESS, MASKED and DISABLED state flags to irq_data
    
    We really need these flags for some of the interrupt chips. Move it
    from internal state to irq_data and provide proper accessors.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Daney <ddaney@caviumnetworks.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a10717e1c1f3..18aacccb0fae 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -174,8 +174,9 @@ struct irq_data {
  *				  from suspend
  * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process
  *				  context
- * IRQD_IRQ_DISABLED		- Some chip function need to know the
- *				  disabled state.
+ * IRQD_IRQ_DISABLED		- Disabled state of the interrupt
+ * IRQD_IRQ_MASKED		- Masked state of the interrupt
+ * IRQD_IRQ_INPROGRESS		- In progress state of the interrupt
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -187,6 +188,8 @@ enum {
 	IRQD_WAKEUP_STATE		= (1 << 14),
 	IRQD_MOVE_PCNTXT		= (1 << 15),
 	IRQD_IRQ_DISABLED		= (1 << 16),
+	IRQD_IRQ_MASKED			= (1 << 17),
+	IRQD_IRQ_INPROGRESS		= (1 << 18),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -243,6 +246,16 @@ static inline bool irqd_irq_disabled(struct irq_data *d)
 	return d->state_use_accessors & IRQD_IRQ_DISABLED;
 }
 
+static inline bool irqd_irq_masked(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_IRQ_MASKED;
+}
+
+static inline bool irqd_irq_inprogress(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_IRQ_INPROGRESS;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit c2d0c555c22242c3a76e366074c4d83ef9fa3b8c
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Mar 25 12:38:50 2011 -0700

    genirq: Split irq_set_affinity() so it can be called with lock held.
    
    The .irq_cpu_online() and .irq_cpu_offline() functions may need to
    adjust affinity, but they are called with the descriptor lock held.
    Create __irq_set_affinity_locked() which is called with the lock held.
    Make irq_set_affinity() just a wrapper that acquires the lock.
    
    [ tglx: Changed the argument to irq_data, added a !desc check and
            moved the !irq_set_affinity check where it belongs ]
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Cc: linux-mips@linux-mips.org
    Cc: ralf@linux-mips.org
    LKML-Reference: <1301081931-11240-4-git-send-email-ddaney@caviumnetworks.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 76e948fa88f8..a10717e1c1f3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -382,6 +382,7 @@ extern void remove_irq(unsigned int irq, struct irqaction *act);
 
 extern void irq_cpu_online(void);
 extern void irq_cpu_offline(void);
+extern int __irq_set_affinity_locked(struct irq_data *data,  const struct cpumask *cpumask);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 

commit b3d422329f2e061d66af4f933ef316e50e5edcac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 27 16:05:36 2011 +0200

    genirq: Add chip flag for restricting cpu_on/offline calls
    
    Add a flag which indicates that the on/offline callback should only be
    called on enabled interrupts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c2a0c1929690..76e948fa88f8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -348,11 +348,14 @@ struct irq_chip {
  * IRQCHIP_SET_TYPE_MASKED:	Mask before calling chip.irq_set_type()
  * IRQCHIP_EOI_IF_HANDLED:	Only issue irq_eoi() when irq was handled
  * IRQCHIP_MASK_ON_SUSPEND:	Mask non wake irqs in the suspend path
+ * IRQCHIP_ONOFFLINE_ENABLED:	Only call irq_on/off_line callbacks
+ *				when irq enabled
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
 	IRQCHIP_EOI_IF_HANDLED		= (1 <<  1),
 	IRQCHIP_MASK_ON_SUSPEND		= (1 <<  2),
+	IRQCHIP_ONOFFLINE_ENABLED	= (1 <<  3),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit 0fdb4b259ed3e91b687ac26848202f5e7c217e62
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Mar 25 12:38:49 2011 -0700

    genirq: Add chip hooks for taking CPUs on/off line.
    
    [ tglx: Removed the enabled argument as this is now available in
    irq_data ]
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Cc: linux-mips@linux-mips.org
    Cc: ralf@linux-mips.org
    LKML-Reference: <1301081931-11240-3-git-send-email-ddaney@caviumnetworks.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8649b0fb9daf..c2a0c1929690 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -279,6 +279,8 @@ static inline bool irqd_irq_disabled(struct irq_data *d)
  * @irq_set_wake:	enable/disable power-management wake-on of an IRQ
  * @irq_bus_lock:	function to lock access to slow bus (i2c) chips
  * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
+ * @irq_cpu_online:	configure an interrupt source for a secondary CPU
+ * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU
  * @irq_print_chip:	optional to print special chip info in show_interrupts
  * @flags:		chip specific flags
  *
@@ -327,6 +329,9 @@ struct irq_chip {
 	void		(*irq_bus_lock)(struct irq_data *data);
 	void		(*irq_bus_sync_unlock)(struct irq_data *data);
 
+	void		(*irq_cpu_online)(struct irq_data *data);
+	void		(*irq_cpu_offline)(struct irq_data *data);
+
 	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
 
 	unsigned long	flags;
@@ -372,6 +377,9 @@ struct irqaction;
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 extern void remove_irq(unsigned int irq, struct irqaction *act);
 
+extern void irq_cpu_online(void);
+extern void irq_cpu_offline(void);
+
 #ifdef CONFIG_GENERIC_HARDIRQS
 
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)

commit 801a0e9ae36e9b487092e31699d28c0b9a21ad52
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 27 11:02:49 2011 +0200

    genirq: Add irq disabled flag to irq_data state
    
    Some irq_chip implementation require to know the disabled state of the
    interrupt in certain callbacks. Add a state flag and accessor to
    irq_data.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5d876c9b3a3d..8649b0fb9daf 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -174,6 +174,8 @@ struct irq_data {
  *				  from suspend
  * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process
  *				  context
+ * IRQD_IRQ_DISABLED		- Some chip function need to know the
+ *				  disabled state.
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -184,6 +186,7 @@ enum {
 	IRQD_LEVEL			= (1 << 13),
 	IRQD_WAKEUP_STATE		= (1 << 14),
 	IRQD_MOVE_PCNTXT		= (1 << 15),
+	IRQD_IRQ_DISABLED		= (1 << 16),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -235,6 +238,11 @@ static inline bool irqd_can_move_in_process_context(struct irq_data *d)
 	return d->state_use_accessors & IRQD_MOVE_PCNTXT;
 }
 
+static inline bool irqd_irq_disabled(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_IRQ_DISABLED;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit ab7798ffcf98b11a9525cf65bacdae3fd58d357f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 16:48:50 2011 +0100

    genirq: Expand generic show_interrupts()
    
    Some archs want to print extra information for certain irq_chips which
    is per irq and not per chip. Allow them to provide a chip callback to
    print the chip name and the extra information.
    
    PowerPC wants to print the LEVEL/EDGE type information. Make it configurable.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1d3577f30d45..5d876c9b3a3d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -28,6 +28,7 @@
 #include <asm/ptrace.h>
 #include <asm/irq_regs.h>
 
+struct seq_file;
 struct irq_desc;
 struct irq_data;
 typedef	void (*irq_flow_handler_t)(unsigned int irq,
@@ -270,6 +271,7 @@ static inline bool irqd_can_move_in_process_context(struct irq_data *d)
  * @irq_set_wake:	enable/disable power-management wake-on of an IRQ
  * @irq_bus_lock:	function to lock access to slow bus (i2c) chips
  * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
+ * @irq_print_chip:	optional to print special chip info in show_interrupts
  * @flags:		chip specific flags
  *
  * @release:		release function solely used by UML
@@ -317,6 +319,8 @@ struct irq_chip {
 	void		(*irq_bus_lock)(struct irq_data *data);
 	void		(*irq_bus_sync_unlock)(struct irq_data *data);
 
+	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
+
 	unsigned long	flags;
 
 	/* Currently used only by UML, might disappear one day.*/

commit d209a699a0b975ad47f399d70ddc3791f1b84496
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 11 21:22:14 2011 +0100

    genirq: Add chip flag to force mask on suspend
    
    On suspend we disable all interrupts in the core code, but this does
    not mask the interrupt line in the default implementation as we use a
    lazy disable approach. That means we mark the interrupt disabled, but
    leave the hardware unmasked. That's an optimization because we avoid
    the hardware access for the common case where no interrupt happens
    after we marked it disabled. If an interrupt happens, then the
    interrupt flow handler masks the line at the hardware level and marks
    it pending.
    
    Suspend makes use of this delayed disable as it "disables" all
    interrupts when preparing the suspend transition. Right before the
    system goes into hardware suspend state it checks whether one of the
    interrupts which is marked as a wakeup interrupt came in after
    disabling it.
    
    Most interrupt chips have a separate register which selects the
    interrupts which can wake up the system from suspend, so we don't have
    to mask any on the non wakeup interrupts.
    
    But now we have to deal with brilliant designed hardware which lacks
    such a wakeup configuration facility. For such hardware it's necessary
    to mask all non wakeup interrupts before going into suspend in order
    to avoid the wakeup from random interrupts.
    
    Rather than working around this in the affected interrupt chip
    implementations we can solve this elegant in the core code itself.
    
    Add a flag IRQCHIP_MASK_ON_SUSPEND which can be set by the irq chip
    implementation to indicate, that the interrupts which are not selected
    as wakeup sources must be masked in the suspend path. Mask them in the
    loop which checks the wakeup interrupts pending flag.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    LKML-Reference: <alpine.LFD.2.00.1103112112310.2787@localhost6.localdomain6>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ff62d0145b8f..1d3577f30d45 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -330,10 +330,12 @@ struct irq_chip {
  *
  * IRQCHIP_SET_TYPE_MASKED:	Mask before calling chip.irq_set_type()
  * IRQCHIP_EOI_IF_HANDLED:	Only issue irq_eoi() when irq was handled
+ * IRQCHIP_MASK_ON_SUSPEND:	Mask non wake irqs in the suspend path
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
 	IRQCHIP_EOI_IF_HANDLED		= (1 <<  1),
+	IRQCHIP_MASK_ON_SUSPEND		= (1 <<  2),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit a439520f8b18917b322f576be04c54aba84bb044
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 4 18:46:16 2011 +0100

    genirq: Implement irq_data based move_*_irq() versions
    
    No need to lookup the irq descriptor when calling from a chip callback
    function which has irq_data already handy.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ea2970c294aa..ff62d0145b8f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -363,9 +363,13 @@ extern void remove_irq(unsigned int irq, struct irqaction *act);
 #if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
+void irq_move_irq(struct irq_data *data);
+void irq_move_masked_irq(struct irq_data *data);
 #else
 static inline void move_native_irq(int irq) { }
 static inline void move_masked_irq(int irq) { }
+static inline void irq_move_irq(struct irq_data *data) { }
+static inline void irq_move_masked_irq(struct irq_data *data) { }
 #endif
 
 extern int no_irq_affinity;

commit 77694b408abb8f92195ad5ed6ce5492f1d794c77
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 15 10:33:57 2011 +0100

    genirq; Add fasteoi irq_chip quirk
    
    Some chips want irq_eoi() only called when an interrupt is actually
    handled. So they have checks for INPROGRESS and DISABLED in their
    irq_eoi callbacks. Add a chip flag, which allows to handle that in the
    generic code. No impact on the fastpath.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 36390970693c..ea2970c294aa 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -328,10 +328,12 @@ struct irq_chip {
 /*
  * irq_chip specific flags
  *
- * IRQCHIP_SET_TYPE_MASKED:		Mask before calling chip.irq_set_type()
+ * IRQCHIP_SET_TYPE_MASKED:	Mask before calling chip.irq_set_type()
+ * IRQCHIP_EOI_IF_HANDLED:	Only issue irq_eoi() when irq was handled
  */
 enum {
 	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
+	IRQCHIP_EOI_IF_HANDLED		= (1 <<  1),
 };
 
 /* This include will go away once we isolated irq_desc usage to core code */

commit 781295762defc709a609efc01d8bb065276cd9a2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 15:14:20 2011 +0100

    genirq: Add preflow handler support
    
    sparc64 needs to call a preflow handler on certain interrupts befor
    calling the action chain. Integrate it into handle_fasteoi_irq. Must
    be enabled via CONFIG_IRQ_FASTEOI_PREFLOW. No impact when disabled.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3e29e2f42e04..36390970693c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -29,9 +29,10 @@
 #include <asm/irq_regs.h>
 
 struct irq_desc;
+struct irq_data;
 typedef	void (*irq_flow_handler_t)(unsigned int irq,
 					    struct irq_desc *desc);
-
+typedef	void (*irq_preflow_handler_t)(struct irq_data *data);
 
 /*
  * IRQ line status.

commit 3836ca08aad4575c120ccf328652f3873eea9063
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 14 20:09:19 2011 +0100

    genirq: Consolidate set_chip_handler functions
    
    No need to have separate functions if we have one plus inline wrappers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c101ad4b821f..3e29e2f42e04 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -398,23 +398,23 @@ extern struct irq_chip no_irq_chip;
 extern struct irq_chip dummy_irq_chip;
 
 extern void
-set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
-			 irq_flow_handler_t handle);
-extern void
-set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
+irq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
 			      irq_flow_handler_t handle, const char *name);
 
+static inline void irq_set_chip_and_handler(unsigned int irq, struct irq_chip *chip,
+					    irq_flow_handler_t handle)
+{
+	irq_set_chip_and_handler_name(irq, chip, handle, NULL);
+}
+
 extern void
-__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
+__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 		  const char *name);
 
-/*
- * Set a highlevel flow handler for a given IRQ:
- */
 static inline void
-set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
+irq_set_handler(unsigned int irq, irq_flow_handler_t handle)
 {
-	__set_irq_handler(irq, handle, 0, NULL);
+	__irq_set_handler(irq, handle, 0, NULL);
 }
 
 /*
@@ -423,9 +423,9 @@ set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
  *  IRQ_NOREQUEST and IRQ_NOPROBE)
  */
 static inline void
-set_irq_chained_handler(unsigned int irq, irq_flow_handler_t handle)
+irq_set_chained_handler(unsigned int irq, irq_flow_handler_t handle)
 {
-	__set_irq_handler(irq, handle, 1, NULL);
+	__irq_set_handler(irq, handle, 1, NULL);
 }
 
 void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);
@@ -579,6 +579,33 @@ static inline void set_irq_nested_thread(unsigned int irq, int nest)
 {
 	irq_set_nested_thread(irq, nest);
 }
+static inline void
+set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
+			      irq_flow_handler_t handle, const char *name)
+{
+	irq_set_chip_and_handler_name(irq, chip, handle, name);
+}
+static inline void
+set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
+			 irq_flow_handler_t handle)
+{
+	irq_set_chip_and_handler(irq, chip, handle);
+}
+static inline void
+__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
+		  const char *name)
+{
+	__irq_set_handler(irq, handle, is_chained, name);
+}
+static inline void set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
+{
+	irq_set_handler(irq, handle);
+}
+static inline void
+set_irq_chained_handler(unsigned int irq, irq_flow_handler_t handle)
+{
+	irq_set_chained_handler(irq, handle);
+}
 #endif
 
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);

commit e1ef824146131709d7466e37f889f2dab24ca98e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 22:25:31 2011 +0100

    genirq: Reflect IRQ_MOVE_PCNTXT in irq_data state
    
    Required by x86.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 94c8f5bb548f..c101ad4b821f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -170,6 +170,8 @@ struct irq_data {
  * IRQD_LEVEL			- Interrupt is level triggered
  * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup
  *				  from suspend
+ * IRDQ_MOVE_PCNTXT		- Interrupt can be moved in process
+ *				  context
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -179,6 +181,7 @@ enum {
 	IRQD_AFFINITY_SET		= (1 << 12),
 	IRQD_LEVEL			= (1 << 13),
 	IRQD_WAKEUP_STATE		= (1 << 14),
+	IRQD_MOVE_PCNTXT		= (1 << 15),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -225,6 +228,11 @@ static inline bool irqd_is_wakeup_set(struct irq_data *d)
 	return d->state_use_accessors & IRQD_WAKEUP_STATE;
 }
 
+static inline bool irqd_can_move_in_process_context(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_MOVE_PCNTXT;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit 7f94226f03299f1ca32f118f02f2a0295e0e5e93
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 19:46:26 2011 +0100

    genirq: Move wakeup state to irq_data
    
    Some irq_chips need to know the state of wakeup mode for
    setting the trigger type etc. Reflect it in irq_data state.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ef6b66dc9d03..94c8f5bb548f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -168,6 +168,8 @@ struct irq_data {
  * IRQD_PER_CPU			- Interrupt is per cpu
  * IRQD_AFFINITY_SET		- Interrupt affinity was set
  * IRQD_LEVEL			- Interrupt is level triggered
+ * IRQD_WAKEUP_STATE		- Interrupt is configured for wakeup
+ *				  from suspend
  */
 enum {
 	IRQD_TRIGGER_MASK		= 0xf,
@@ -176,6 +178,7 @@ enum {
 	IRQD_PER_CPU			= (1 << 11),
 	IRQD_AFFINITY_SET		= (1 << 12),
 	IRQD_LEVEL			= (1 << 13),
+	IRQD_WAKEUP_STATE		= (1 << 14),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -217,6 +220,11 @@ static inline bool irqd_is_level_type(struct irq_data *d)
 	return d->state_use_accessors & IRQD_LEVEL;
 }
 
+static inline bool irqd_is_wakeup_set(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_WAKEUP_STATE;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit d4d5e08960844a062da8387ee5f16ca7a33200d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 13:16:14 2011 +0100

    genirq: Add IRQCHIP_SET_TYPE_MASKED flag
    
    irq_chips, which require to mask the chip before changing the trigger
    type should set this flag. So the core takes care of it and the
    requirement for looking into desc->status in the chip goes away.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index aefb30bbcf0e..ef6b66dc9d03 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -308,6 +308,15 @@ struct irq_chip {
 #endif
 };
 
+/*
+ * irq_chip specific flags
+ *
+ * IRQCHIP_SET_TYPE_MASKED:		Mask before calling chip.irq_set_type()
+ */
+enum {
+	IRQCHIP_SET_TYPE_MASKED		= (1 <<  0),
+};
+
 /* This include will go away once we isolated irq_desc usage to core code */
 #include <linux/irqdesc.h>
 

commit 2bff17ad2107c66fc8ca96501a7128dd7fa7a390
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 13:08:38 2011 +0100

    genirq: Add flags to irq_chip
    
    Looking through irq_chip implementations I noticed that some of them
    have special requirements, like setting the type masked and therefor
    fiddle in irq_desc->status. Add a flag field, so the core code can
    handle it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2e3d1e5f0408..aefb30bbcf0e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -253,6 +253,7 @@ static inline bool irqd_is_level_type(struct irq_data *d)
  * @irq_set_wake:	enable/disable power-management wake-on of an IRQ
  * @irq_bus_lock:	function to lock access to slow bus (i2c) chips
  * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
+ * @flags:		chip specific flags
  *
  * @release:		release function solely used by UML
  */
@@ -299,6 +300,8 @@ struct irq_chip {
 	void		(*irq_bus_lock)(struct irq_data *data);
 	void		(*irq_bus_sync_unlock)(struct irq_data *data);
 
+	unsigned long	flags;
+
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);

commit 5d4d8fc9ac3e9a90bbdf90bae6864cb2c01f2208
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:27:18 2011 +0100

    genirq: Cleanup irq.h
    
    Put the constants into an enum and document them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index be73c0a3c19d..2e3d1e5f0408 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -36,44 +36,73 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 /*
  * IRQ line status.
  *
- * Bits 0-7 are reserved for the IRQF_* bits in linux/interrupt.h
+ * Bits 0-7 are the same as the IRQF_* bits in linux/interrupt.h
+ *
+ * IRQ_TYPE_NONE		- default, unspecified type
+ * IRQ_TYPE_EDGE_RISING		- rising edge triggered
+ * IRQ_TYPE_EDGE_FALLING	- falling edge triggered
+ * IRQ_TYPE_EDGE_BOTH		- rising and falling edge triggered
+ * IRQ_TYPE_LEVEL_HIGH		- high level triggered
+ * IRQ_TYPE_LEVEL_LOW		- low level triggered
+ * IRQ_TYPE_LEVEL_MASK		- Mask to filter out the level bits
+ * IRQ_TYPE_SENSE_MASK		- Mask for all the above bits
+ * IRQ_TYPE_PROBE		- Special flag for probing in progress
+ *
+ * Bits which can be modified via irq_set/clear/modify_status_flags()
+ * IRQ_LEVEL			- Interrupt is level type. Will be also
+ *				  updated in the code when the above trigger
+ *				  bits are modified via set_irq_type()
+ * IRQ_PER_CPU			- Mark an interrupt PER_CPU. Will protect
+ *				  it from affinity setting
+ * IRQ_NOPROBE			- Interrupt cannot be probed by autoprobing
+ * IRQ_NOREQUEST		- Interrupt cannot be requested via
+ *				  request_irq()
+ * IRQ_NOAUTOEN			- Interrupt is not automatically enabled in
+ *				  request/setup_irq()
+ * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
+ * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
+ * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
+ *
+ * Deprecated bits. They are kept updated as long as
+ * CONFIG_GENERIC_HARDIRQS_NO_COMPAT is not set. Will go away soon. These bits
+ * are internal state of the core code and if you really need to acces
+ * them then talk to the genirq maintainer instead of hacking
+ * something weird.
  *
- * IRQ types
  */
-#define IRQ_TYPE_NONE		0x00000000	/* Default, unspecified type */
-#define IRQ_TYPE_EDGE_RISING	0x00000001	/* Edge rising type */
-#define IRQ_TYPE_EDGE_FALLING	0x00000002	/* Edge falling type */
-#define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
-#define IRQ_TYPE_LEVEL_HIGH	0x00000004	/* Level high type */
-#define IRQ_TYPE_LEVEL_LOW	0x00000008	/* Level low type */
-#define IRQ_TYPE_LEVEL_MASK	(IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH)
-#define IRQ_TYPE_SENSE_MASK	0x0000000f	/* Mask of the above */
-
-#define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
-
-/* Internal flags */
+enum {
+	IRQ_TYPE_NONE		= 0x00000000,
+	IRQ_TYPE_EDGE_RISING	= 0x00000001,
+	IRQ_TYPE_EDGE_FALLING	= 0x00000002,
+	IRQ_TYPE_EDGE_BOTH	= (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING),
+	IRQ_TYPE_LEVEL_HIGH	= 0x00000004,
+	IRQ_TYPE_LEVEL_LOW	= 0x00000008,
+	IRQ_TYPE_LEVEL_MASK	= (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH),
+	IRQ_TYPE_SENSE_MASK	= 0x0000000f,
+
+	IRQ_TYPE_PROBE		= 0x00000010,
+
+	IRQ_LEVEL		= (1 <<  8),
+	IRQ_PER_CPU		= (1 <<  9),
+	IRQ_NOPROBE		= (1 << 10),
+	IRQ_NOREQUEST		= (1 << 11),
+	IRQ_NOAUTOEN		= (1 << 12),
+	IRQ_NO_BALANCING	= (1 << 13),
+	IRQ_MOVE_PCNTXT		= (1 << 14),
+	IRQ_NESTED_THREAD	= (1 << 15),
 
 #ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-#define IRQ_INPROGRESS		0x00000100	/* DEPRECATED */
-#define IRQ_REPLAY		0x00000200	/* DEPRECATED */
-#define IRQ_WAITING		0x00000400	/* DEPRECATED */
-#define IRQ_DISABLED		0x00000800	/* DEPRECATED */
-#define IRQ_PENDING		0x00001000	/* DEPRECATED */
-#define IRQ_MASKED		0x00002000	/* DEPRECATED */
-/* DEPRECATED use irq_setaffinity_pending() instead*/
-#define IRQ_MOVE_PENDING	0x00004000
-#define IRQ_AFFINITY_SET	0x02000000	/* DEPRECATED */
+	IRQ_INPROGRESS		= (1 << 16),
+	IRQ_REPLAY		= (1 << 17),
+	IRQ_WAITING		= (1 << 18),
+	IRQ_DISABLED		= (1 << 19),
+	IRQ_PENDING		= (1 << 20),
+	IRQ_MASKED		= (1 << 21),
+	IRQ_MOVE_PENDING	= (1 << 22),
+	IRQ_AFFINITY_SET	= (1 << 23),
+	IRQ_WAKEUP		= (1 << 24),
 #endif
-
-#define IRQ_LEVEL		0x00008000	/* IRQ level triggered */
-#define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */
-#define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
-#define IRQ_NOREQUEST		0x00040000	/* IRQ cannot be requested */
-#define IRQ_NOAUTOEN		0x00080000	/* IRQ will not be enabled on request irq */
-#define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
-#define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
-#define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
-#define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
+};
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \

commit 876dbd4cc1b35c1a4cb96a2be1d43ea0eabce3b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:28:12 2011 +0100

    genirq: Mirror irq trigger type bits in irq_data.state
    
    That's the data structure chip functions get provided. Also allow them
    to signal the core code that they updated the flags in irq_data.state
    by returning IRQ_SET_MASK_OK_NOCOPY. The default is unchanged.
    
    The type bits should be accessed via:
    
    val = irqd_get_trigger_type(irqdata);
    and
    irqd_set_trigger_type(irqdata, val);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8da1782ecfca..be73c0a3c19d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -46,7 +46,9 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
 #define IRQ_TYPE_LEVEL_HIGH	0x00000004	/* Level high type */
 #define IRQ_TYPE_LEVEL_LOW	0x00000008	/* Level low type */
+#define IRQ_TYPE_LEVEL_MASK	(IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH)
 #define IRQ_TYPE_SENSE_MASK	0x0000000f	/* Mask of the above */
+
 #define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
 
 /* Internal flags */
@@ -131,17 +133,20 @@ struct irq_data {
 /*
  * Bit masks for irq_data.state
  *
+ * IRQD_TRIGGER_MASK		- Mask for the trigger type bits
  * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
  * IRQD_NO_BALANCING		- Balancing disabled for this IRQ
  * IRQD_PER_CPU			- Interrupt is per cpu
  * IRQD_AFFINITY_SET		- Interrupt affinity was set
+ * IRQD_LEVEL			- Interrupt is level triggered
  */
 enum {
-	/* Bit 0 - 7 reserved for TYPE will use later */
+	IRQD_TRIGGER_MASK		= 0xf,
 	IRQD_SETAFFINITY_PENDING	= (1 <<  8),
 	IRQD_NO_BALANCING		= (1 << 10),
 	IRQD_PER_CPU			= (1 << 11),
 	IRQD_AFFINITY_SET		= (1 << 12),
+	IRQD_LEVEL			= (1 << 13),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -164,6 +169,25 @@ static inline bool irqd_affinity_was_set(struct irq_data *d)
 	return d->state_use_accessors & IRQD_AFFINITY_SET;
 }
 
+static inline u32 irqd_get_trigger_type(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_TRIGGER_MASK;
+}
+
+/*
+ * Must only be called inside irq_chip.irq_set_type() functions.
+ */
+static inline void irqd_set_trigger_type(struct irq_data *d, u32 type)
+{
+	d->state_use_accessors &= ~IRQD_TRIGGER_MASK;
+	d->state_use_accessors |= type & IRQD_TRIGGER_MASK;
+}
+
+static inline bool irqd_is_level_type(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_LEVEL;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit 2bdd10558c8d93009cb6c32ce9e30800fbb08add
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:22:00 2011 +0100

    genirq: Move IRQ_AFFINITY_SET to core
    
    Keep status in sync until last abuser is gone.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d5312e6fe1aa..8da1782ecfca 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -60,6 +60,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MASKED		0x00002000	/* DEPRECATED */
 /* DEPRECATED use irq_setaffinity_pending() instead*/
 #define IRQ_MOVE_PENDING	0x00004000
+#define IRQ_AFFINITY_SET	0x02000000	/* DEPRECATED */
 #endif
 
 #define IRQ_LEVEL		0x00008000	/* IRQ level triggered */
@@ -70,7 +71,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
-#define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
 
 #define IRQF_MODIFY_MASK	\
@@ -134,12 +134,14 @@ struct irq_data {
  * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
  * IRQD_NO_BALANCING		- Balancing disabled for this IRQ
  * IRQD_PER_CPU			- Interrupt is per cpu
+ * IRQD_AFFINITY_SET		- Interrupt affinity was set
  */
 enum {
 	/* Bit 0 - 7 reserved for TYPE will use later */
 	IRQD_SETAFFINITY_PENDING	= (1 <<  8),
 	IRQD_NO_BALANCING		= (1 << 10),
 	IRQD_PER_CPU			= (1 << 11),
+	IRQD_AFFINITY_SET		= (1 << 12),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -157,6 +159,11 @@ static inline bool irqd_can_balance(struct irq_data *d)
 	return !(d->state_use_accessors & (IRQD_PER_CPU | IRQD_NO_BALANCING));
 }
 
+static inline bool irqd_affinity_was_set(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_AFFINITY_SET;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit a005677b3dd05decdd8880cf3044ae709856f58f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 17:11:03 2011 +0100

    genirq: Mirror IRQ_PER_CPU and IRQ_NO_BALANCING in irq_data.state
    
    That's the right data structure to look at for arch code.
    
    Accessor functions are provided.
    
             irqd_is_per_cpu(irqdata);
             irqd_can_balance(irqdata);
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3f607ad94220..d5312e6fe1aa 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -132,10 +132,14 @@ struct irq_data {
  * Bit masks for irq_data.state
  *
  * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
+ * IRQD_NO_BALANCING		- Balancing disabled for this IRQ
+ * IRQD_PER_CPU			- Interrupt is per cpu
  */
 enum {
 	/* Bit 0 - 7 reserved for TYPE will use later */
-	IRQD_SETAFFINITY_PENDING = (1 << 8),
+	IRQD_SETAFFINITY_PENDING	= (1 <<  8),
+	IRQD_NO_BALANCING		= (1 << 10),
+	IRQD_PER_CPU			= (1 << 11),
 };
 
 static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
@@ -143,6 +147,16 @@ static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
 	return d->state_use_accessors & IRQD_SETAFFINITY_PENDING;
 }
 
+static inline bool irqd_is_per_cpu(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_PER_CPU;
+}
+
+static inline bool irqd_can_balance(struct irq_data *d)
+{
+	return !(d->state_use_accessors & (IRQD_PER_CPU | IRQD_NO_BALANCING));
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit 8f53f92404bead2ab2154d45c8f508880bb5d95d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 16:50:00 2011 +0100

    genirq: Make CHECK_IRQ_PER_CPU an inline and deprecate it
    
    Its' too ugly and needs to go. The only users are core code and
    parisc. Core code does not need it and parisc gets a new check once
    IRQ_PER_CPU is reflected in irq_data.state.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ab708f27a33b..3f607ad94220 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -78,8 +78,12 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
 	 IRQ_PER_CPU | IRQ_NESTED_THREAD)
 
-# define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
-# define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
+#define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
+
+static inline __deprecated bool CHECK_IRQ_PER_CPU(unsigned int status)
+{
+	return status & IRQ_PER_CPU;
+}
 
 /*
  * Return value for chip->irq_set_affinity()

commit 6a58fb3bad099076f36f0f30f44507bc3275cdb6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 15:40:05 2011 +0100

    genirq: Remove CONFIG_IRQ_PER_CPU
    
    The saving of this switch is minimal versus the ifdef mess it
    creates. Simple enable PER_CPU unconditionally and remove the config
    switch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2899905bfac7..ab708f27a33b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -78,13 +78,8 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
 	 IRQ_PER_CPU | IRQ_NESTED_THREAD)
 
-#ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 # define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
-#else
-# define CHECK_IRQ_PER_CPU(var) 0
-# define IRQ_NO_BALANCING_MASK	IRQ_NO_BALANCING
-#endif
 
 /*
  * Return value for chip->irq_set_affinity()

commit f230b6d5c48f8d12f4dfa1f8b5ab0b0320076d21
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 5 15:20:04 2011 +0100

    genirq: Add IRQ_MOVE_PENDING to irq_data.state
    
    chip implementations need to know about it. Keep status in sync until
    all users are fixed.
    
    Accessor function: irqd_is_setaffinity_pending(irqdata)
    
    Coders who access them directly will be tracked down and slapped with
    stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 62bb08e4af13..2899905bfac7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -58,15 +58,16 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_DISABLED		0x00000800	/* DEPRECATED */
 #define IRQ_PENDING		0x00001000	/* DEPRECATED */
 #define IRQ_MASKED		0x00002000	/* DEPRECATED */
+/* DEPRECATED use irq_setaffinity_pending() instead*/
+#define IRQ_MOVE_PENDING	0x00004000
 #endif
 
-#define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
+#define IRQ_LEVEL		0x00008000	/* IRQ level triggered */
 #define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */
 #define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
 #define IRQ_NOREQUEST		0x00040000	/* IRQ cannot be requested */
 #define IRQ_NOAUTOEN		0x00080000	/* IRQ will not be enabled on request irq */
 #define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
-#define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
@@ -128,6 +129,21 @@ struct irq_data {
 #endif
 };
 
+/*
+ * Bit masks for irq_data.state
+ *
+ * IRQD_SETAFFINITY_PENDING	- Affinity setting is pending
+ */
+enum {
+	/* Bit 0 - 7 reserved for TYPE will use later */
+	IRQD_SETAFFINITY_PENDING = (1 << 8),
+};
+
+static inline bool irqd_is_setaffinity_pending(struct irq_data *d)
+{
+	return d->state_use_accessors & IRQD_SETAFFINITY_PENDING;
+}
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *

commit 91c499178139d6597e68db19638e4135510a34b8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 3 20:48:29 2011 +0100

    genirq: Add state field to irq_data
    
    Some chip implementations need to access certain status flags. With
    sparse irqs that requires a lookup of the irq descriptor. Add a state
    field which contains such flags.
    
    Name it in a way which will make coders happy to access it with the
    proper accessor functions. And it's easy to grep for.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3ce45c257edb..62bb08e4af13 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -102,6 +102,8 @@ struct msi_desc;
  * struct irq_data - per irq and irq chip data passed down to chip functions
  * @irq:		interrupt number
  * @node:		node index useful for balancing
+ * @state_use_accessor: status information for irq chip functions.
+ *			Use accessor functions to deal with it
  * @chip:		low level interrupt hardware access
  * @handler_data:	per-IRQ data for the irq_chip methods
  * @chip_data:		platform-specific per-chip private data for the chip
@@ -116,6 +118,7 @@ struct msi_desc;
 struct irq_data {
 	unsigned int		irq;
 	unsigned int		node;
+	unsigned int		state_use_accessors;
 	struct irq_chip		*chip;
 	void			*handler_data;
 	void			*chip_data;

commit c531e8361f1968d664e6e97fbd3bfa4cf0e62e42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:44:58 2011 +0100

    genirq: Move IRQ_SUSPENDED to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9800bac4c398..3ce45c257edb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -60,7 +60,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MASKED		0x00002000	/* DEPRECATED */
 #endif
 
-
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
 #define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */
 #define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
@@ -71,7 +70,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
-#define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
 
 #define IRQF_MODIFY_MASK	\

commit 6e40262ea43c4b0e3f435b3a083e4461ef921c17
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:36:06 2011 +0100

    genirq: Move IRQ_MASKED to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7ca55c9deba4..9800bac4c398 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -57,11 +57,11 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_WAITING		0x00000400	/* DEPRECATED */
 #define IRQ_DISABLED		0x00000800	/* DEPRECATED */
 #define IRQ_PENDING		0x00001000	/* DEPRECATED */
+#define IRQ_MASKED		0x00002000	/* DEPRECATED */
 #endif
 
 
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
-#define IRQ_MASKED		0x00008000	/* IRQ masked - shouldn't be seen again */
 #define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */
 #define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
 #define IRQ_NOREQUEST		0x00040000	/* IRQ cannot be requested */

commit 2a0d6fb335d4428285dab2d254911748e6040807
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 12:17:57 2011 +0100

    genirq: Move IRQ_PENDING flag to core
    
    Keep status in sync until all users are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 32efca71ce88..7ca55c9deba4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -56,9 +56,9 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_REPLAY		0x00000200	/* DEPRECATED */
 #define IRQ_WAITING		0x00000400	/* DEPRECATED */
 #define IRQ_DISABLED		0x00000800	/* DEPRECATED */
+#define IRQ_PENDING		0x00001000	/* DEPRECATED */
 #endif
 
-#define IRQ_PENDING		0x00001000	/* IRQ pending - replay on enable */
 
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
 #define IRQ_MASKED		0x00008000	/* IRQ masked - shouldn't be seen again */

commit c1594b77e46124bb462f961e536120e471c67446
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 22:11:30 2011 +0100

    genirq: Move IRQ_DISABLED to core
    
    Keep status in sync until all abusers are fixed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c38dbd506656..32efca71ce88 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -55,9 +55,9 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_INPROGRESS		0x00000100	/* DEPRECATED */
 #define IRQ_REPLAY		0x00000200	/* DEPRECATED */
 #define IRQ_WAITING		0x00000400	/* DEPRECATED */
+#define IRQ_DISABLED		0x00000800	/* DEPRECATED */
 #endif
 
-#define IRQ_DISABLED		0x00000800	/* IRQ disabled - do not enter! */
 #define IRQ_PENDING		0x00001000	/* IRQ pending - replay on enable */
 
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
@@ -231,7 +231,7 @@ struct irq_chip {
 # define ARCH_IRQ_INIT_FLAGS	0
 #endif
 
-#define IRQ_DEFAULT_INIT_FLAGS	(IRQ_DISABLED | ARCH_IRQ_INIT_FLAGS)
+#define IRQ_DEFAULT_INIT_FLAGS	ARCH_IRQ_INIT_FLAGS
 
 struct irqaction;
 extern int setup_irq(unsigned int irq, struct irqaction *new);

commit 163ef3091195f514a06f064b12914597d2644c55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Feb 8 11:39:15 2011 +0100

    genirq: Move IRQ_REPLAY and IRQ_WAITING to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1a4c723e74e1..c38dbd506656 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -53,12 +53,13 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 
 #ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
 #define IRQ_INPROGRESS		0x00000100	/* DEPRECATED */
+#define IRQ_REPLAY		0x00000200	/* DEPRECATED */
+#define IRQ_WAITING		0x00000400	/* DEPRECATED */
 #endif
 
-#define IRQ_DISABLED		0x00000200	/* IRQ disabled - do not enter! */
-#define IRQ_PENDING		0x00000400	/* IRQ pending - replay on enable */
-#define IRQ_REPLAY		0x00000800	/* IRQ has been replayed but not acked yet */
-#define IRQ_WAITING		0x00002000	/* IRQ not yet seen - for autodetection */
+#define IRQ_DISABLED		0x00000800	/* IRQ disabled - do not enter! */
+#define IRQ_PENDING		0x00001000	/* IRQ pending - replay on enable */
+
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
 #define IRQ_MASKED		0x00008000	/* IRQ masked - shouldn't be seen again */
 #define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */

commit 3d67baec7f1b01fc289ac1a2f1a7e6d5e43391c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 21:02:10 2011 +0100

    genirq: Move IRQ_ONESHOT to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 274590fc55a3..1a4c723e74e1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -71,7 +71,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
-#define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
 
 #define IRQF_MODIFY_MASK	\

commit 009b4c3b8ad584b3462734127a5bec680d5d6af4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 21:48:49 2011 +0100

    genirq: Add IRQ_INPROGRESS to core
    
    We need to maintain the flag for now in both fields status and istate.
    Add a CONFIG_GENERIC_HARDIRQS_NO_COMPAT switch to allow testing w/o
    the status one. Wrap the access to status IRQ_INPROGRESS in a inline
    which can be turned of with CONFIG_GENERIC_HARDIRQS_NO_COMPAT along
    with the define.
    
    There is no reason that anything outside of core looks at this. That
    needs some modifications, but we'll get there.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 047a695511df..274590fc55a3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -50,7 +50,11 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
 
 /* Internal flags */
-#define IRQ_INPROGRESS		0x00000100	/* IRQ handler active - do not enter! */
+
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+#define IRQ_INPROGRESS		0x00000100	/* DEPRECATED */
+#endif
+
 #define IRQ_DISABLED		0x00000200	/* IRQ disabled - do not enter! */
 #define IRQ_PENDING		0x00000400	/* IRQ pending - replay on enable */
 #define IRQ_REPLAY		0x00000800	/* IRQ has been replayed but not acked yet */

commit 6954b75b488dd740950573f244ddd66fd28620aa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:55:35 2011 +0100

    genirq: Move IRQ_POLL_INPROGRESS to core
    
    No users outside of core.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 67b77cfb2a34..047a695511df 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -69,7 +69,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
 #define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
-#define IRQ_POLL_INPROGRESS	0x20000000	/* IRQ poll is in progress */
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \

commit 6f91a52d9bb28396177662f1da0f2e2cef9cf5d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 14 13:33:16 2011 +0100

    genirq: Use modify_status for set_irq_nested_thread
    
    No need for a separate function in the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a900741b43ea..67b77cfb2a34 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -74,7 +74,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
 	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
-	 IRQ_PER_CPU)
+	 IRQ_PER_CPU | IRQ_NESTED_THREAD)
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
@@ -307,8 +307,6 @@ set_irq_chained_handler(unsigned int irq, irq_flow_handler_t handle)
 	__set_irq_handler(irq, handle, 1, NULL);
 }
 
-extern void set_irq_nested_thread(unsigned int irq, int nest);
-
 void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);
 
 static inline void irq_set_status_flags(unsigned int irq, unsigned long set)
@@ -331,6 +329,14 @@ static inline void irq_set_probe(unsigned int irq)
 	irq_modify_status(irq, IRQ_NOPROBE, 0);
 }
 
+static inline void irq_set_nested_thread(unsigned int irq, bool nest)
+{
+	if (nest)
+		irq_set_status_flags(irq, IRQ_NESTED_THREAD);
+	else
+		irq_clear_status_flags(irq, IRQ_NESTED_THREAD);
+}
+
 /* Handle dynamic irq creation and destruction */
 extern unsigned int create_irq_nr(unsigned int irq_want, int node);
 extern int create_irq(void);
@@ -448,6 +454,10 @@ static inline void set_irq_probe(unsigned int irq)
 {
 	irq_set_probe(irq);
 }
+static inline void set_irq_nested_thread(unsigned int irq, int nest)
+{
+	irq_set_nested_thread(irq, nest);
+}
 #endif
 
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);

commit 7acdd53e5b2c55b6f7e3427e85e2f91fa814a4f9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:40:54 2011 +0100

    genirq: Move IRQ_SPURIOUS_DISABLED to core state
    
    No users outside.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d1f9c352cd1b..a900741b43ea 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -64,7 +64,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
 #define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
-#define IRQ_SPURIOUS_DISABLED	0x00800000	/* IRQ was disabled by the spurious trap */
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */

commit bd062e7667ac173afef57fbfe9327f3b914a9d4c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:25:25 2011 +0100

    genirq: Move IRQ_AUTODETECT to internal state
    
    No users outside of core
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e32b64ccdc89..d1f9c352cd1b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -54,7 +54,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_DISABLED		0x00000200	/* IRQ disabled - do not enter! */
 #define IRQ_PENDING		0x00000400	/* IRQ pending - replay on enable */
 #define IRQ_REPLAY		0x00000800	/* IRQ has been replayed but not acked yet */
-#define IRQ_AUTODETECT		0x00001000	/* IRQ is being autodetected */
 #define IRQ_WAITING		0x00002000	/* IRQ not yet seen - for autodetection */
 #define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
 #define IRQ_MASKED		0x00008000	/* IRQ masked - shouldn't be seen again */

commit fe200ae48ef5c79bf7941fe8046ff9505c570ff6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 10:34:30 2011 +0100

    genirq: Mark polled irqs and defer the real handler
    
    With the chip.end() function gone we might run into a situation where
    a poll call runs and the real interrupt comes in, sees IRQ_INPROGRESS
    and disables the line. That might be a perfect working one, which will
    then be masked forever.
    
    So mark them polled while the poll runs. When the real handler sees
    IRQ_INPROGRESS it checks the poll flag and waits for the polling to
    complete. Add the necessary amount of sanity checks to it to avoid
    deadlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f5e900309d21..e32b64ccdc89 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -71,6 +71,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
 #define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
+#define IRQ_POLL_INPROGRESS	0x20000000	/* IRQ poll is in progress */
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \

commit 3b8249e759c701c4a82f99d957be651a7657bf6f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 16:02:20 2011 +0100

    genirq: Do not copy affinity before set
    
    While rumaging through arch code I found that there are a few
    workarounds which deal with the fact that the initial affinity setting
    from request_irq() copies the mask into irq_data->affinity before the
    chip code is called. In the normal path we unconditionally copy the
    mask when the chip code returns 0.
    
    Copy after the code is called and add a return code
    IRQ_SET_MASK_OK_NOCOPY for the chip functions, which prevents the
    copy. That way we see the real mask when the chip function decided to
    truncate it further as some arches do. IRQ_SET_MASK_OK is 0, which is
    the current behaviour.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e9f847d56c4d..f5e900309d21 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -85,6 +85,17 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 # define IRQ_NO_BALANCING_MASK	IRQ_NO_BALANCING
 #endif
 
+/*
+ * Return value for chip->irq_set_affinity()
+ *
+ * IRQ_SET_MASK_OK	- OK, core updates irq_data.affinity
+ * IRQ_SET_MASK_NOCPY	- OK, chip did update irq_data.affinity
+ */
+enum {
+	IRQ_SET_MASK_OK = 0,
+	IRQ_SET_MASK_OK_NOCOPY,
+};
+
 struct msi_desc;
 
 /**

commit a0cd9ca2b907d7ee26575e7b63ac92dad768a75e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 11:36:33 2011 +0100

    genirq: Namespace cleanup
    
    The irq namespace has become quite convoluted. My bad.  Clean it up
    and deprecate the old functions. All new functions follow the scheme:
    
    irq number based:
        irq_set/get/xxx/_xxx(unsigned int irq, ...)
    
    irq_data based:
             irq_data_set/get/xxx/_xxx(struct irq_data *d, ....)
    
    irq_desc based:
             irq_desc_get_xxx(struct irq_desc *desc)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 80fcb53057bc..e9f847d56c4d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -292,8 +292,7 @@ set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
  *  IRQ_NOREQUEST and IRQ_NOPROBE)
  */
 static inline void
-set_irq_chained_handler(unsigned int irq,
-			irq_flow_handler_t handle)
+set_irq_chained_handler(unsigned int irq, irq_flow_handler_t handle)
 {
 	__set_irq_handler(irq, handle, 1, NULL);
 }
@@ -312,12 +311,12 @@ static inline void irq_clear_status_flags(unsigned int irq, unsigned long clr)
 	irq_modify_status(irq, clr, 0);
 }
 
-static inline void set_irq_noprobe(unsigned int irq)
+static inline void irq_set_noprobe(unsigned int irq)
 {
 	irq_modify_status(irq, 0, IRQ_NOPROBE);
 }
 
-static inline void set_irq_probe(unsigned int irq)
+static inline void irq_set_probe(unsigned int irq)
 {
 	irq_modify_status(irq, IRQ_NOPROBE, 0);
 }
@@ -338,14 +337,14 @@ static inline void dynamic_irq_init(unsigned int irq)
 }
 
 /* Set/get chip/data for an IRQ: */
-extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);
-extern int set_irq_data(unsigned int irq, void *data);
-extern int set_irq_chip_data(unsigned int irq, void *data);
-extern int set_irq_type(unsigned int irq, unsigned int type);
-extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
+extern int irq_set_chip(unsigned int irq, struct irq_chip *chip);
+extern int irq_set_handler_data(unsigned int irq, void *data);
+extern int irq_set_chip_data(unsigned int irq, void *data);
+extern int irq_set_irq_type(unsigned int irq, unsigned int type);
+extern int irq_set_msi_desc(unsigned int irq, struct msi_desc *entry);
 extern struct irq_data *irq_get_irq_data(unsigned int irq);
 
-static inline struct irq_chip *get_irq_chip(unsigned int irq)
+static inline struct irq_chip *irq_get_chip(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
 	return d ? d->chip : NULL;
@@ -356,7 +355,7 @@ static inline struct irq_chip *irq_data_get_irq_chip(struct irq_data *d)
 	return d->chip;
 }
 
-static inline void *get_irq_chip_data(unsigned int irq)
+static inline void *irq_get_chip_data(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
 	return d ? d->chip_data : NULL;
@@ -367,18 +366,18 @@ static inline void *irq_data_get_irq_chip_data(struct irq_data *d)
 	return d->chip_data;
 }
 
-static inline void *get_irq_data(unsigned int irq)
+static inline void *irq_get_handler_data(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
 	return d ? d->handler_data : NULL;
 }
 
-static inline void *irq_data_get_irq_data(struct irq_data *d)
+static inline void *irq_data_get_irq_handler_data(struct irq_data *d)
 {
 	return d->handler_data;
 }
 
-static inline struct msi_desc *get_irq_msi(unsigned int irq)
+static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)
 {
 	struct irq_data *d = irq_get_irq_data(irq);
 	return d ? d->msi_desc : NULL;
@@ -389,6 +388,58 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 	return d->msi_desc;
 }
 
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+/* Please do not use: Use the replacement functions instead */
+static inline int set_irq_chip(unsigned int irq, struct irq_chip *chip)
+{
+	return irq_set_chip(irq, chip);
+}
+static inline int set_irq_data(unsigned int irq, void *data)
+{
+	return irq_set_handler_data(irq, data);
+}
+static inline int set_irq_chip_data(unsigned int irq, void *data)
+{
+	return irq_set_chip_data(irq, data);
+}
+static inline int set_irq_type(unsigned int irq, unsigned int type)
+{
+	return irq_set_irq_type(irq, type);
+}
+static inline int set_irq_msi(unsigned int irq, struct msi_desc *entry)
+{
+	return irq_set_msi_desc(irq, entry);
+}
+static inline struct irq_chip *get_irq_chip(unsigned int irq)
+{
+	return irq_get_chip(irq);
+}
+static inline void *get_irq_chip_data(unsigned int irq)
+{
+	return irq_get_chip_data(irq);
+}
+static inline void *get_irq_data(unsigned int irq)
+{
+	return irq_get_handler_data(irq);
+}
+static inline void *irq_data_get_irq_data(struct irq_data *d)
+{
+	return irq_data_get_irq_handler_data(d);
+}
+static inline struct msi_desc *get_irq_msi(unsigned int irq)
+{
+	return irq_get_msi_desc(irq);
+}
+static inline void set_irq_noprobe(unsigned int irq)
+{
+	irq_set_noprobe(irq);
+}
+static inline void set_irq_probe(unsigned int irq)
+{
+	irq_set_probe(irq);
+}
+#endif
+
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 int irq_reserve_irqs(unsigned int from, unsigned int cnt);

commit 872434d69c644b8aa5088b835598dc3cd9832aff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 5 16:25:25 2011 +0100

    genirq: Add missing status flags to modification mask
    
    The mask which filters out the valid bits which can be set via
    irq_modify_status() is missing IRQ_NO_BALANCING, which breaks UV.
    
    Add IRQ_PER_CPU as well to avoid another one line patch for 39.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index abde2527c699..80fcb53057bc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -74,7 +74,8 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 
 #define IRQF_MODIFY_MASK	\
 	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
-	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL)
+	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL | IRQ_NO_BALANCING | \
+	 IRQ_PER_CPU)
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit 639bd12f778d55a2632fde5af7d0719abc1871b9
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 26 16:19:13 2010 +0900

    genirq: Add single IRQ reservation helper
    
    For cases that wish to reserve a single IRQ at a given place simply
    provide a wrapper in to the ranged reservation routine.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    LKML-Reference: <20101026071912.GD4733@linux-sh.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e9639115dff1..abde2527c699 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -412,6 +412,11 @@ static inline void irq_free_desc(unsigned int irq)
 	irq_free_descs(irq, 1);
 }
 
+static inline int irq_reserve_irq(unsigned int irq)
+{
+	return irq_reserve_irqs(irq, 1);
+}
+
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */

commit b7b29338dc7111ed8bd4d6555d84afae13ebe752
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 29 18:46:55 2010 +0200

    genirq: Sanitize dynamic irq handling
    
    Use the cleanup functions of the dynamic allocator. No need to have
    separate implementations.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 49702b22883e..e9639115dff1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -326,11 +326,15 @@ extern unsigned int create_irq_nr(unsigned int irq_want, int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
 
-/* Dynamic irq helper functions */
-extern void dynamic_irq_init(unsigned int irq);
-void dynamic_irq_init_keep_chip_data(unsigned int irq);
+/*
+ * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and
+ * irq_free_desc instead.
+ */
 extern void dynamic_irq_cleanup(unsigned int irq);
-void dynamic_irq_cleanup_keep_chip_data(unsigned int irq);
+static inline void dynamic_irq_init(unsigned int irq)
+{
+	dynamic_irq_cleanup(irq);
+}
 
 /* Set/get chip/data for an IRQ: */
 extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);

commit 10ba1e0eeef6a3c9453d96364e28cb4d911e1ac3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 11 12:21:18 2010 +0200

    genirq: Remove irq_2_iommu
    
    irq_2_iommu is now in the x86 code where it belongs. Remove all
    leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ef878823ee3b..49702b22883e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -85,7 +85,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #endif
 
 struct msi_desc;
-struct irq_2_iommu;
 
 /**
  * struct irq_data - per irq and irq chip data passed down to chip functions
@@ -97,7 +96,6 @@ struct irq_2_iommu;
  *			methods, to allow shared chip implementations
  * @msi_desc:		MSI descriptor
  * @affinity:		IRQ affinity on SMP
- * @irq_2_iommu:	iommu with this irq
  *
  * The fields here need to overlay the ones in irq_desc until we
  * cleaned up the direct references and switched everything over to
@@ -113,9 +111,6 @@ struct irq_data {
 #ifdef CONFIG_SMP
 	cpumask_var_t		affinity;
 #endif
-#ifdef CONFIG_INTR_REMAP
-	struct irq_2_iommu      *irq_2_iommu;
-#endif
 };
 
 /**
@@ -389,19 +384,6 @@ static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
 	return d->msi_desc;
 }
 
-#ifdef CONFIG_INTR_REMAP
-static inline struct irq_2_iommu *get_irq_iommu(unsigned int irq)
-{
-	struct irq_data *d = irq_get_irq_data(irq);
-	return d ? d->irq_2_iommu : NULL;
-}
-
-static inline struct irq_2_iommu *irq_data_get_iommu(struct irq_data *d)
-{
-	return d->irq_2_iommu;
-}
-#endif
-
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
 void irq_free_descs(unsigned int irq, unsigned int cnt);
 int irq_reserve_irqs(unsigned int from, unsigned int cnt);

commit b683de2b3cb17bb10fa6fd4af614dc75b5749fe0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 20:55:03 2010 +0200

    genirq: Query arch for number of early descriptors
    
    sparse irq sets up NR_IRQS_LEGACY irq descriptors and archs then go
    ahead and allocate more.
    
    Use the unused return value of arch_probe_nr_irqs() to let the
    architecture return the number of early allocations. Fix up all users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 096b74d5d0d7..ef878823ee3b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -214,6 +214,10 @@ struct irq_chip {
  */
 #include <asm/hw_irq.h>
 
+#ifndef NR_IRQS_LEGACY
+# define NR_IRQS_LEGACY 0
+#endif
+
 #ifndef ARCH_IRQ_INIT_FLAGS
 # define ARCH_IRQ_INIT_FLAGS	0
 #endif

commit 06f6c3399e9f9ff6eafc200e80f9226c3cee0eaf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 12 12:31:46 2010 +0200

    genirq: Implement irq reservation
    
    Mark a range of interrupts as allocated. In the SPARSE_IRQ=n case we
    need this to update the bitmap for the legacy irqs so the enumerator
    via irq_get_next_irq() works.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index cefacf928b33..096b74d5d0d7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -400,6 +400,7 @@ static inline struct irq_2_iommu *irq_data_get_iommu(struct irq_data *d)
 
 int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
 void irq_free_descs(unsigned int irq, unsigned int cnt);
+int irq_reserve_irqs(unsigned int from, unsigned int cnt);
 
 static inline int irq_alloc_desc(int node)
 {

commit 1f5a5b87f78fade3ae48dfd55e8765d1d622ea4e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 17:48:26 2010 +0200

    genirq: Implement a sane sparse_irq allocator
    
    The current sparse_irq allocator has several short comings due to
    failures in the design or the lack of it:
    
     - Requires iteration over the number of active irqs to find a free slot
       (Some architectures have grown their own workarounds for this)
     - Removal of entries is not possible
     - Racy between create_irq_nr and destroy_irq (plugged by horrible
       callbacks)
     - Migration of active irq descriptors is not possible
     - No bulk allocation of irq ranges
     - Sprinkeled irq_desc references all over the place outside of kernel/irq/
       (The previous chip functions series is addressing this issue)
    
    Implement a sane allocator which fixes the above short comings (though
    migration of active descriptors needs a full tree wide cleanup of the
    direct and mostly unlocked access to irq_desc).
    
    The new allocator still uses a radix_tree, but uses a bitmap for
    keeping track of allocated irq numbers. That allows:
    
     - Fast lookup of a free slot
     - Allows the removal of descriptors
     - Prevents the create/destroy race
     - Bulk allocation of consecutive irq ranges
     - Basic design is ready for migration of life descriptors after
       further cleanups
    
    The bitmap is also used in the SPARSE_IRQ=n case for lookup and
    raceless (de)allocation of irq numbers. So it removes the requirement
    for looping through the descriptor array to find slots.
    
    Right now it uses sparse_irq_lock to protect the bitmap and the radix
    tree, but after cleaning up all users we should be able convert that
    to a mutex and to switch the radix_tree and decriptor allocations to
    GFP_KERNEL.
    
    [ Folded in a bugfix from Yinghai Lu ]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 30a300991ed4..cefacf928b33 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -398,6 +398,29 @@ static inline struct irq_2_iommu *irq_data_get_iommu(struct irq_data *d)
 }
 #endif
 
+int irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node);
+void irq_free_descs(unsigned int irq, unsigned int cnt);
+
+static inline int irq_alloc_desc(int node)
+{
+	return irq_alloc_descs(-1, 0, 1, node);
+}
+
+static inline int irq_alloc_desc_at(unsigned int at, int node)
+{
+	return irq_alloc_descs(at, at, 1, node);
+}
+
+static inline int irq_alloc_desc_from(unsigned int from, int node)
+{
+	return irq_alloc_descs(-1, from, 1, node);
+}
+
+static inline void irq_free_desc(unsigned int irq)
+{
+	irq_free_descs(irq, 1);
+}
+
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */

commit 1318a481fc37c503a901b96ae06b692ca2b21af5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 21:01:37 2010 +0200

    genirq: Provide default irq init flags
    
    Arch code sets it's own irq_desc.status flags right after boot and for
    dynamically allocated interrupts. That might involve iterating over a
    huge array.
    
    Allow ARCH_IRQ_INIT_FLAGS to set separate flags aside of IRQ_DISABLED
    which is the default.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index bea40556c5a6..30a300991ed4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -214,6 +214,12 @@ struct irq_chip {
  */
 #include <asm/hw_irq.h>
 
+#ifndef ARCH_IRQ_INIT_FLAGS
+# define ARCH_IRQ_INIT_FLAGS	0
+#endif
+
+#define IRQ_DEFAULT_INIT_FLAGS	(IRQ_DISABLED | ARCH_IRQ_INIT_FLAGS)
+
 struct irqaction;
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 extern void remove_irq(unsigned int irq, struct irqaction *act);

commit f303a6dd127b5ec6de90d1cd79ed19820c7e9658
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 28 17:34:01 2010 +0200

    genirq: Sanitize irq_data accessors
    
    Get the data structure from the core and provide inline wrappers to
    access the irq_data members.
    
    Provide accessor inlines for irq_data as well.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e7e7ac83edd8..bea40556c5a6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -85,6 +85,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #endif
 
 struct msi_desc;
+struct irq_2_iommu;
 
 /**
  * struct irq_data - per irq and irq chip data passed down to chip functions
@@ -332,11 +333,64 @@ extern int set_irq_data(unsigned int irq, void *data);
 extern int set_irq_chip_data(unsigned int irq, void *data);
 extern int set_irq_type(unsigned int irq, unsigned int type);
 extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
+extern struct irq_data *irq_get_irq_data(unsigned int irq);
 
-#define get_irq_chip(irq)	(irq_to_desc(irq)->irq_data.chip)
-#define get_irq_chip_data(irq)	(irq_to_desc(irq)->irq_data.chip_data)
-#define get_irq_data(irq)	(irq_to_desc(irq)->irq_data.handler_data)
-#define get_irq_msi(irq)	(irq_to_desc(irq)->irq_data.msi_desc)
+static inline struct irq_chip *get_irq_chip(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? d->chip : NULL;
+}
+
+static inline struct irq_chip *irq_data_get_irq_chip(struct irq_data *d)
+{
+	return d->chip;
+}
+
+static inline void *get_irq_chip_data(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? d->chip_data : NULL;
+}
+
+static inline void *irq_data_get_irq_chip_data(struct irq_data *d)
+{
+	return d->chip_data;
+}
+
+static inline void *get_irq_data(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? d->handler_data : NULL;
+}
+
+static inline void *irq_data_get_irq_data(struct irq_data *d)
+{
+	return d->handler_data;
+}
+
+static inline struct msi_desc *get_irq_msi(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? d->msi_desc : NULL;
+}
+
+static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
+{
+	return d->msi_desc;
+}
+
+#ifdef CONFIG_INTR_REMAP
+static inline struct irq_2_iommu *get_irq_iommu(unsigned int irq)
+{
+	struct irq_data *d = irq_get_irq_data(irq);
+	return d ? d->irq_2_iommu : NULL;
+}
+
+static inline struct irq_2_iommu *irq_data_get_iommu(struct irq_data *d)
+{
+	return d->irq_2_iommu;
+}
+#endif
 
 #endif /* CONFIG_GENERIC_HARDIRQS */
 

commit 442471848f5abb55b99cba1229301655f67492b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 28 10:40:18 2010 +0200

    genirq: Provide status modifier
    
    Provide a irq_desc.status modifier function to cleanup the direct
    access to irq_desc in arch and driver code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 80fdab208c13..e7e7ac83edd8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -72,6 +72,10 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
 #define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
 
+#define IRQF_MODIFY_MASK	\
+	(IRQ_TYPE_SENSE_MASK | IRQ_NOPROBE | IRQ_NOREQUEST | \
+	 IRQ_NOAUTOEN | IRQ_MOVE_PCNTXT | IRQ_LEVEL)
+
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 # define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
@@ -289,8 +293,27 @@ set_irq_chained_handler(unsigned int irq,
 
 extern void set_irq_nested_thread(unsigned int irq, int nest);
 
-extern void set_irq_noprobe(unsigned int irq);
-extern void set_irq_probe(unsigned int irq);
+void irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set);
+
+static inline void irq_set_status_flags(unsigned int irq, unsigned long set)
+{
+	irq_modify_status(irq, 0, set);
+}
+
+static inline void irq_clear_status_flags(unsigned int irq, unsigned long clr)
+{
+	irq_modify_status(irq, clr, 0);
+}
+
+static inline void set_irq_noprobe(unsigned int irq)
+{
+	irq_modify_status(irq, 0, IRQ_NOPROBE);
+}
+
+static inline void set_irq_probe(unsigned int irq)
+{
+	irq_modify_status(irq, IRQ_NOPROBE, 0);
+}
 
 /* Handle dynamic irq creation and destruction */
 extern unsigned int create_irq_nr(unsigned int irq_want, int node);

commit 3a3856d00c74560a7b8d9f8a13c1ca94ee786b78
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 4 13:47:12 2010 +0200

    genirq: Remove unsused inline
    
    move_irq() has no users. Remove it and simplify the ifdef forrest while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f5827abbc034..80fdab208c13 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -215,15 +215,9 @@ extern void remove_irq(unsigned int irq, struct irqaction *act);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
-#ifdef CONFIG_SMP
-# ifdef CONFIG_GENERIC_PENDING_IRQ
+#if defined(CONFIG_SMP) && defined(CONFIG_GENERIC_PENDING_IRQ)
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
-# else
-static inline void move_irq(int irq) { }
-static inline void move_native_irq(int irq) { }
-static inline void move_masked_irq(int irq) { }
-# endif
 #else
 static inline void move_native_irq(int irq) { }
 static inline void move_masked_irq(int irq) { }

commit e144710b302525de5b90b9c3ba43562458d8957f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 16:03:45 2010 +0200

    genirq: Distangle irq.h
    
    Move irq_desc and internal functions out of irq.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 82ed8231394a..f5827abbc034 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -80,7 +80,6 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 # define IRQ_NO_BALANCING_MASK	IRQ_NO_BALANCING
 #endif
 
-struct proc_dir_entry;
 struct msi_desc;
 
 /**
@@ -202,152 +201,36 @@ struct irq_chip {
 #endif
 };
 
-struct timer_rand_state;
-struct irq_2_iommu;
-/**
- * struct irq_desc - interrupt descriptor
- * @irq_data:		per irq and chip data passed down to chip functions
- * @timer_rand_state:	pointer to timer rand state struct
- * @kstat_irqs:		irq stats per cpu
- * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
- * @action:		the irq action chain
- * @status:		status information
- * @depth:		disable-depth, for nested irq_disable() calls
- * @wake_depth:		enable depth, for multiple set_irq_wake() callers
- * @irq_count:		stats field to detect stalled irqs
- * @last_unhandled:	aging timer for unhandled count
- * @irqs_unhandled:	stats field for spurious unhandled interrupts
- * @lock:		locking for SMP
- * @pending_mask:	pending rebalanced interrupts
- * @threads_active:	number of irqaction threads currently running
- * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
- * @dir:		/proc/irq/ procfs entry
- * @name:		flow handler name for /proc/interrupts output
- */
-struct irq_desc {
-
-#ifdef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
-	struct irq_data		irq_data;
-#else
-	/*
-	 * This union will go away, once we fixed the direct access to
-	 * irq_desc all over the place. The direct fields are a 1:1
-	 * overlay of irq_data.
-	 */
-	union {
-		struct irq_data		irq_data;
-		struct {
-			unsigned int		irq;
-			unsigned int		node;
-			struct irq_chip		*chip;
-			void			*handler_data;
-			void			*chip_data;
-			struct msi_desc		*msi_desc;
-#ifdef CONFIG_SMP
-			cpumask_var_t		affinity;
-#endif
-#ifdef CONFIG_INTR_REMAP
-			struct irq_2_iommu      *irq_2_iommu;
-#endif
-		};
-	};
-#endif
-
-	struct timer_rand_state *timer_rand_state;
-	unsigned int            *kstat_irqs;
-	irq_flow_handler_t	handle_irq;
-	struct irqaction	*action;	/* IRQ action list */
-	unsigned int		status;		/* IRQ status */
-
-	unsigned int		depth;		/* nested irq disables */
-	unsigned int		wake_depth;	/* nested wake enables */
-	unsigned int		irq_count;	/* For detecting broken IRQs */
-	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
-	unsigned int		irqs_unhandled;
-	raw_spinlock_t		lock;
-#ifdef CONFIG_SMP
-	const struct cpumask	*affinity_hint;
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_var_t		pending_mask;
-#endif
-#endif
-	atomic_t		threads_active;
-	wait_queue_head_t       wait_for_threads;
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry	*dir;
-#endif
-	const char		*name;
-} ____cacheline_internodealigned_in_smp;
-
-extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
-					struct irq_desc *desc, int node);
-extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
-
-#ifndef CONFIG_SPARSE_IRQ
-extern struct irq_desc irq_desc[NR_IRQS];
-#endif
-
-#ifdef CONFIG_NUMA_IRQ_DESC
-extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int node);
-#else
-static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
-{
-	return desc;
-}
-#endif
-
-extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
+/* This include will go away once we isolated irq_desc usage to core code */
+#include <linux/irqdesc.h>
 
 /*
  * Pick up the arch-dependent methods:
  */
 #include <asm/hw_irq.h>
 
+struct irqaction;
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 extern void remove_irq(unsigned int irq, struct irqaction *act);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
 #ifdef CONFIG_SMP
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-
+# ifdef CONFIG_GENERIC_PENDING_IRQ
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
-
-#else /* CONFIG_GENERIC_PENDING_IRQ */
-
-static inline void move_irq(int irq)
-{
-}
-
-static inline void move_native_irq(int irq)
-{
-}
-
-static inline void move_masked_irq(int irq)
-{
-}
-
-#endif /* CONFIG_GENERIC_PENDING_IRQ */
-
-#else /* CONFIG_SMP */
-
-#define move_native_irq(x)
-#define move_masked_irq(x)
-
-#endif /* CONFIG_SMP */
+# else
+static inline void move_irq(int irq) { }
+static inline void move_native_irq(int irq) { }
+static inline void move_masked_irq(int irq) { }
+# endif
+#else
+static inline void move_native_irq(int irq) { }
+static inline void move_masked_irq(int irq) { }
+#endif
 
 extern int no_irq_affinity;
 
-static inline int irq_balancing_disabled(unsigned int irq)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-	return desc->status & IRQ_NO_BALANCING_MASK;
-}
-
 /* Handle irq action chains: */
 extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
 
@@ -363,42 +246,10 @@ extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_nested_irq(unsigned int irq);
 
-/*
- * Monolithic do_IRQ implementation.
- */
-#ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-extern unsigned int __do_IRQ(unsigned int irq);
-#endif
-
-/*
- * Architectures call this to let the generic IRQ layer
- * handle an interrupt. If the descriptor is attached to an
- * irqchip-style controller then we call the ->handle_irq() handler,
- * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
- */
-static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
-{
-#ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-	desc->handle_irq(irq, desc);
-#else
-	if (likely(desc->handle_irq))
-		desc->handle_irq(irq, desc);
-	else
-		__do_IRQ(irq);
-#endif
-}
-
-static inline void generic_handle_irq(unsigned int irq)
-{
-	generic_handle_irq_desc(irq, irq_to_desc(irq));
-}
-
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   irqreturn_t action_ret);
 
-/* Resending of interrupts :*/
-void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 
 /* Enable/disable irq debugging output: */
 extern int noirqdebug_setup(char *str);
@@ -421,16 +272,6 @@ extern void
 __set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 		  const char *name);
 
-/* caller has locked the irq_desc and both params are valid */
-static inline void __set_irq_handler_unlocked(int irq,
-					      irq_flow_handler_t handler)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-	desc->handle_irq = handler;
-}
-
 /*
  * Set a highlevel flow handler for a given IRQ:
  */
@@ -462,13 +303,6 @@ extern unsigned int create_irq_nr(unsigned int irq_want, int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
 
-/* Test to see if a driver has successfully requested an irq */
-static inline int irq_has_action(unsigned int irq)
-{
-	struct irq_desc *desc = irq_to_desc(irq);
-	return desc->action != NULL;
-}
-
 /* Dynamic irq helper functions */
 extern void dynamic_irq_init(unsigned int irq);
 void dynamic_irq_init_keep_chip_data(unsigned int irq);
@@ -487,108 +321,8 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 #define get_irq_data(irq)	(irq_to_desc(irq)->irq_data.handler_data)
 #define get_irq_msi(irq)	(irq_to_desc(irq)->irq_data.msi_desc)
 
-#define get_irq_desc_chip(desc)		((desc)->irq_data.chip)
-#define get_irq_desc_chip_data(desc)	((desc)->irq_data.chip_data)
-#define get_irq_desc_data(desc)		((desc)->irq_data.handler_data)
-#define get_irq_desc_msi(desc)		((desc)->irq_data.msi_desc)
-
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */
 
-#ifdef CONFIG_SMP
-/**
- * alloc_desc_masks - allocate cpumasks for irq_desc
- * @desc:	pointer to irq_desc struct
- * @node:	node which will be handling the cpumasks
- * @boot:	true if need bootmem
- *
- * Allocates affinity and pending_mask cpumask if required.
- * Returns true if successful (or not required).
- */
-static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
-							bool boot)
-{
-	gfp_t gfp = GFP_ATOMIC;
-
-	if (boot)
-		gfp = GFP_NOWAIT;
-
-#ifdef CONFIG_CPUMASK_OFFSTACK
-	if (!alloc_cpumask_var_node(&desc->irq_data.affinity, gfp, node))
-		return false;
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	if (!alloc_cpumask_var_node(&desc->pending_mask, gfp, node)) {
-		free_cpumask_var(desc->irq_data.affinity);
-		return false;
-	}
-#endif
-#endif
-	return true;
-}
-
-static inline void init_desc_masks(struct irq_desc *desc)
-{
-	cpumask_setall(desc->irq_data.affinity);
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_clear(desc->pending_mask);
-#endif
-}
-
-/**
- * init_copy_desc_masks - copy cpumasks for irq_desc
- * @old_desc:	pointer to old irq_desc struct
- * @new_desc:	pointer to new irq_desc struct
- *
- * Insures affinity and pending_masks are copied to new irq_desc.
- * If !CONFIG_CPUMASKS_OFFSTACK the cpumasks are embedded in the
- * irq_desc struct so the copy is redundant.
- */
-
-static inline void init_copy_desc_masks(struct irq_desc *old_desc,
-					struct irq_desc *new_desc)
-{
-#ifdef CONFIG_CPUMASK_OFFSTACK
-	cpumask_copy(new_desc->irq_data.affinity, old_desc->irq_data.affinity);
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_copy(new_desc->pending_mask, old_desc->pending_mask);
-#endif
-#endif
-}
-
-static inline void free_desc_masks(struct irq_desc *old_desc,
-				   struct irq_desc *new_desc)
-{
-	free_cpumask_var(old_desc->irq_data.affinity);
-
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-	free_cpumask_var(old_desc->pending_mask);
-#endif
-}
-
-#else /* !CONFIG_SMP */
-
-static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
-								bool boot)
-{
-	return true;
-}
-
-static inline void init_desc_masks(struct irq_desc *desc)
-{
-}
-
-static inline void init_copy_desc_masks(struct irq_desc *old_desc,
-					struct irq_desc *new_desc)
-{
-}
-
-static inline void free_desc_masks(struct irq_desc *old_desc,
-				   struct irq_desc *new_desc)
-{
-}
-#endif	/* CONFIG_SMP */
-
 #endif /* _LINUX_IRQ_H */

commit bd151412263a67b5321e9dd1d5b4bf6d96fdebf3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 15:17:14 2010 +0200

    genirq: Provide config option to disable deprecated code
    
    This option covers now the old chip functions and the irq_desc data
    fields which are moving to struct irq_data. More stuff will follow.
    
    Pretty handy for testing a conversion, whether something broke or not.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0c83cbd2df4e..82ed8231394a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -155,6 +155,7 @@ struct irq_data {
  */
 struct irq_chip {
 	const char	*name;
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
 	unsigned int	(*startup)(unsigned int irq);
 	void		(*shutdown)(unsigned int irq);
 	void		(*enable)(unsigned int irq);
@@ -175,7 +176,7 @@ struct irq_chip {
 
 	void		(*bus_lock)(unsigned int irq);
 	void		(*bus_sync_unlock)(unsigned int irq);
-
+#endif
 	unsigned int	(*irq_startup)(struct irq_data *data);
 	void		(*irq_shutdown)(struct irq_data *data);
 	void		(*irq_enable)(struct irq_data *data);
@@ -225,6 +226,9 @@ struct irq_2_iommu;
  */
 struct irq_desc {
 
+#ifdef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
+	struct irq_data		irq_data;
+#else
 	/*
 	 * This union will go away, once we fixed the direct access to
 	 * irq_desc all over the place. The direct fields are a 1:1
@@ -247,6 +251,8 @@ struct irq_desc {
 #endif
 		};
 	};
+#endif
+
 	struct timer_rand_state *timer_rand_state;
 	unsigned int            *kstat_irqs;
 	irq_flow_handler_t	handle_irq;

commit f8822657e799b02c55556c99a601261e207a299d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 12:44:32 2010 +0000

    genirq: Provide advanced irq chip functions
    
    The low level irq chip functions want access to irq_desc->irq_data.
    Provide new functions which hand down irq_data instead of the irq
    number so these functions avoid to call irq_to_desc() which is a radix
    tree lookup in case of sparse irq.
    
    This provides all the old functions except one: end(). end() is a
    relict of __do_IRQ() and will just go away with the __do_IRQ() code.
    
    The replacement for set_affinity() has an extra argument "bool
    force". The reason for this is to notify the low level code, that the
    move has to be done right away and cannot be delayed until the next
    interrupt happens. That's necessary to handle the irq fixup on cpu
    unplug in the generic code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20100927121841.742126604@linutronix.de>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 002351d83c3f..0c83cbd2df4e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -118,23 +118,38 @@ struct irq_data {
  * struct irq_chip - hardware interrupt chip descriptor
  *
  * @name:		name for /proc/interrupts
- * @startup:		start up the interrupt (defaults to ->enable if NULL)
- * @shutdown:		shut down the interrupt (defaults to ->disable if NULL)
- * @enable:		enable the interrupt (defaults to chip->unmask if NULL)
- * @disable:		disable the interrupt
- * @ack:		start of a new interrupt
- * @mask:		mask an interrupt source
- * @mask_ack:		ack and mask an interrupt source
- * @unmask:		unmask an interrupt source
- * @eoi:		end of interrupt - chip level
- * @end:		end of interrupt - flow level
- * @set_affinity:	set the CPU affinity on SMP machines
- * @retrigger:		resend an IRQ to the CPU
- * @set_type:		set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
- * @set_wake:		enable/disable power-management wake-on of an IRQ
+ * @startup:		deprecated, replaced by irq_startup
+ * @shutdown:		deprecated, replaced by irq_shutdown
+ * @enable:		deprecated, replaced by irq_enable
+ * @disable:		deprecated, replaced by irq_disable
+ * @ack:		deprecated, replaced by irq_ack
+ * @mask:		deprecated, replaced by irq_mask
+ * @mask_ack:		deprecated, replaced by irq_mask_ack
+ * @unmask:		deprecated, replaced by irq_unmask
+ * @eoi:		deprecated, replaced by irq_eoi
+ * @end:		deprecated, will go away with __do_IRQ()
+ * @set_affinity:	deprecated, replaced by irq_set_affinity
+ * @retrigger:		deprecated, replaced by irq_retrigger
+ * @set_type:		deprecated, replaced by irq_set_type
+ * @set_wake:		deprecated, replaced by irq_wake
+ * @bus_lock:		deprecated, replaced by irq_bus_lock
+ * @bus_sync_unlock:	deprecated, replaced by irq_bus_sync_unlock
  *
- * @bus_lock:		function to lock access to slow bus (i2c) chips
- * @bus_sync_unlock:	function to sync and unlock slow bus (i2c) chips
+ * @irq_startup:	start up the interrupt (defaults to ->enable if NULL)
+ * @irq_shutdown:	shut down the interrupt (defaults to ->disable if NULL)
+ * @irq_enable:		enable the interrupt (defaults to chip->unmask if NULL)
+ * @irq_disable:	disable the interrupt
+ * @irq_ack:		start of a new interrupt
+ * @irq_mask:		mask an interrupt source
+ * @irq_mask_ack:	ack and mask an interrupt source
+ * @irq_unmask:		unmask an interrupt source
+ * @irq_eoi:		end of interrupt
+ * @irq_set_affinity:	set the CPU affinity on SMP machines
+ * @irq_retrigger:	resend an IRQ to the CPU
+ * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
+ * @irq_set_wake:	enable/disable power-management wake-on of an IRQ
+ * @irq_bus_lock:	function to lock access to slow bus (i2c) chips
+ * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
  *
  * @release:		release function solely used by UML
  */
@@ -161,6 +176,25 @@ struct irq_chip {
 	void		(*bus_lock)(unsigned int irq);
 	void		(*bus_sync_unlock)(unsigned int irq);
 
+	unsigned int	(*irq_startup)(struct irq_data *data);
+	void		(*irq_shutdown)(struct irq_data *data);
+	void		(*irq_enable)(struct irq_data *data);
+	void		(*irq_disable)(struct irq_data *data);
+
+	void		(*irq_ack)(struct irq_data *data);
+	void		(*irq_mask)(struct irq_data *data);
+	void		(*irq_mask_ack)(struct irq_data *data);
+	void		(*irq_unmask)(struct irq_data *data);
+	void		(*irq_eoi)(struct irq_data *data);
+
+	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force);
+	int		(*irq_retrigger)(struct irq_data *data);
+	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type);
+	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);
+
+	void		(*irq_bus_lock)(struct irq_data *data);
+	void		(*irq_bus_sync_unlock)(struct irq_data *data);
+
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);

commit 6b8ff3120c758340505dddf08ad685ebb841d5d5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 12:58:38 2010 +0200

    genirq: Convert core code to irq_data
    
    Convert all references in the core code to orq, chip, handler_data,
    chip_data, msi_desc, affinity to irq_data.*
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 363c76ff82c8..002351d83c3f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -475,12 +475,12 @@ static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
 		gfp = GFP_NOWAIT;
 
 #ifdef CONFIG_CPUMASK_OFFSTACK
-	if (!alloc_cpumask_var_node(&desc->affinity, gfp, node))
+	if (!alloc_cpumask_var_node(&desc->irq_data.affinity, gfp, node))
 		return false;
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	if (!alloc_cpumask_var_node(&desc->pending_mask, gfp, node)) {
-		free_cpumask_var(desc->affinity);
+		free_cpumask_var(desc->irq_data.affinity);
 		return false;
 	}
 #endif
@@ -490,7 +490,7 @@ static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
 
 static inline void init_desc_masks(struct irq_desc *desc)
 {
-	cpumask_setall(desc->affinity);
+	cpumask_setall(desc->irq_data.affinity);
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_clear(desc->pending_mask);
 #endif
@@ -510,7 +510,7 @@ static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 					struct irq_desc *new_desc)
 {
 #ifdef CONFIG_CPUMASK_OFFSTACK
-	cpumask_copy(new_desc->affinity, old_desc->affinity);
+	cpumask_copy(new_desc->irq_data.affinity, old_desc->irq_data.affinity);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_copy(new_desc->pending_mask, old_desc->pending_mask);
@@ -521,7 +521,7 @@ static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 static inline void free_desc_masks(struct irq_desc *old_desc,
 				   struct irq_desc *new_desc)
 {
-	free_cpumask_var(old_desc->affinity);
+	free_cpumask_var(old_desc->irq_data.affinity);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	free_cpumask_var(old_desc->pending_mask);

commit ff7dcd44dd446db2c3e13bdedf2d52b8e0127f16
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 27 12:44:25 2010 +0000

    genirq: Create irq_data
    
    Low level chip functions need access to irq_desc->handler_data,
    irq_desc->chip_data and irq_desc->msi_desc. We hand down the irq
    number to the low level functions, so they need to lookup irq_desc.
    With sparse irq this means a radix tree lookup.
    
    We could hand down irq_desc itself, but low level chip functions have
    no need to fiddle with it directly and we want to restrict access to
    irq_desc further.
    
    Preparatory patch for new chip functions.
    
    Note, that the ugly anon union/struct is there to avoid a full tree
    wide clean up for now. This is not going to last 3 years like __do_IRQ()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20100927121841.645542300@linutronix.de>
    Reviewed-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 06273a2a17e7..363c76ff82c8 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -83,6 +83,37 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 struct proc_dir_entry;
 struct msi_desc;
 
+/**
+ * struct irq_data - per irq and irq chip data passed down to chip functions
+ * @irq:		interrupt number
+ * @node:		node index useful for balancing
+ * @chip:		low level interrupt hardware access
+ * @handler_data:	per-IRQ data for the irq_chip methods
+ * @chip_data:		platform-specific per-chip private data for the chip
+ *			methods, to allow shared chip implementations
+ * @msi_desc:		MSI descriptor
+ * @affinity:		IRQ affinity on SMP
+ * @irq_2_iommu:	iommu with this irq
+ *
+ * The fields here need to overlay the ones in irq_desc until we
+ * cleaned up the direct references and switched everything over to
+ * irq_data.
+ */
+struct irq_data {
+	unsigned int		irq;
+	unsigned int		node;
+	struct irq_chip		*chip;
+	void			*handler_data;
+	void			*chip_data;
+	struct msi_desc		*msi_desc;
+#ifdef CONFIG_SMP
+	cpumask_var_t		affinity;
+#endif
+#ifdef CONFIG_INTR_REMAP
+	struct irq_2_iommu      *irq_2_iommu;
+#endif
+};
+
 /**
  * struct irq_chip - hardware interrupt chip descriptor
  *
@@ -140,16 +171,10 @@ struct timer_rand_state;
 struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
- * @irq:		interrupt number for this descriptor
+ * @irq_data:		per irq and chip data passed down to chip functions
  * @timer_rand_state:	pointer to timer rand state struct
  * @kstat_irqs:		irq stats per cpu
- * @irq_2_iommu:	iommu with this irq
  * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
- * @chip:		low level interrupt hardware access
- * @msi_desc:		MSI descriptor
- * @handler_data:	per-IRQ data for the irq_chip methods
- * @chip_data:		platform-specific per-chip private data for the chip
- *			methods, to allow shared chip implementations
  * @action:		the irq action chain
  * @status:		status information
  * @depth:		disable-depth, for nested irq_disable() calls
@@ -158,8 +183,6 @@ struct irq_2_iommu;
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
- * @affinity:		IRQ affinity on SMP
- * @node:		node index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
  * @threads_active:	number of irqaction threads currently running
  * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
@@ -167,17 +190,32 @@ struct irq_2_iommu;
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {
-	unsigned int		irq;
-	struct timer_rand_state *timer_rand_state;
-	unsigned int            *kstat_irqs;
+
+	/*
+	 * This union will go away, once we fixed the direct access to
+	 * irq_desc all over the place. The direct fields are a 1:1
+	 * overlay of irq_data.
+	 */
+	union {
+		struct irq_data		irq_data;
+		struct {
+			unsigned int		irq;
+			unsigned int		node;
+			struct irq_chip		*chip;
+			void			*handler_data;
+			void			*chip_data;
+			struct msi_desc		*msi_desc;
+#ifdef CONFIG_SMP
+			cpumask_var_t		affinity;
+#endif
 #ifdef CONFIG_INTR_REMAP
-	struct irq_2_iommu      *irq_2_iommu;
+			struct irq_2_iommu      *irq_2_iommu;
 #endif
+		};
+	};
+	struct timer_rand_state *timer_rand_state;
+	unsigned int            *kstat_irqs;
 	irq_flow_handler_t	handle_irq;
-	struct irq_chip		*chip;
-	struct msi_desc		*msi_desc;
-	void			*handler_data;
-	void			*chip_data;
 	struct irqaction	*action;	/* IRQ action list */
 	unsigned int		status;		/* IRQ status */
 
@@ -188,9 +226,7 @@ struct irq_desc {
 	unsigned int		irqs_unhandled;
 	raw_spinlock_t		lock;
 #ifdef CONFIG_SMP
-	cpumask_var_t		affinity;
 	const struct cpumask	*affinity_hint;
-	unsigned int		node;
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_var_t		pending_mask;
 #endif
@@ -406,15 +442,15 @@ extern int set_irq_chip_data(unsigned int irq, void *data);
 extern int set_irq_type(unsigned int irq, unsigned int type);
 extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
-#define get_irq_chip(irq)	(irq_to_desc(irq)->chip)
-#define get_irq_chip_data(irq)	(irq_to_desc(irq)->chip_data)
-#define get_irq_data(irq)	(irq_to_desc(irq)->handler_data)
-#define get_irq_msi(irq)	(irq_to_desc(irq)->msi_desc)
+#define get_irq_chip(irq)	(irq_to_desc(irq)->irq_data.chip)
+#define get_irq_chip_data(irq)	(irq_to_desc(irq)->irq_data.chip_data)
+#define get_irq_data(irq)	(irq_to_desc(irq)->irq_data.handler_data)
+#define get_irq_msi(irq)	(irq_to_desc(irq)->irq_data.msi_desc)
 
-#define get_irq_desc_chip(desc)		((desc)->chip)
-#define get_irq_desc_chip_data(desc)	((desc)->chip_data)
-#define get_irq_desc_data(desc)		((desc)->handler_data)
-#define get_irq_desc_msi(desc)		((desc)->msi_desc)
+#define get_irq_desc_chip(desc)		((desc)->irq_data.chip)
+#define get_irq_desc_chip_data(desc)	((desc)->irq_data.chip_data)
+#define get_irq_desc_data(desc)		((desc)->irq_data.handler_data)
+#define get_irq_desc_msi(desc)		((desc)->irq_data.msi_desc)
 
 #endif /* CONFIG_GENERIC_HARDIRQS */
 

commit d1ea13c6e2cce0106531852daaa93dd97aec9580
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 23 18:40:07 2010 +0200

    genirq: Cleanup irq_chip->typename leftovers
    
    3 years transition phase is enough. Cleanup the last users and remove
    the cruft.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Leo Chen <leochen@broadcom.com>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Chris Zankel <chris@zankel.net>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c03243ad84b4..06273a2a17e7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -106,7 +106,6 @@ struct msi_desc;
  * @bus_sync_unlock:	function to sync and unlock slow bus (i2c) chips
  *
  * @release:		release function solely used by UML
- * @typename:		obsoleted by name, kept as migration helper
  */
 struct irq_chip {
 	const char	*name;
@@ -135,11 +134,6 @@ struct irq_chip {
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);
 #endif
-	/*
-	 * For compatibility, ->typename is copied into ->name.
-	 * Will disappear.
-	 */
-	const char	*typename;
 };
 
 struct timer_rand_state;

commit e7a297b0d7d6049bd4e423ac1e17da31e4c401b8
Author: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
Date:   Fri Apr 30 14:44:50 2010 -0700

    genirq: Add CPU mask affinity hint
    
    This patch adds a cpumask affinity hint to the irq_desc structure,
    along with a registration function and a read-only proc entry for each
    interrupt.
    
    This affinity_hint handle for each interrupt can be used by underlying
    drivers that need a better mechanism to control interrupt affinity.
    The underlying driver can register a cpumask for the interrupt, which
    will allow the driver to provide the CPU mask for the interrupt to
    anything that requests it.  The intent is to extend the userspace
    daemon, irqbalance, to help hint to it a preferred CPU mask to balance
    the interrupt into.
    
    [ tglx: Fixed compile warnings, added WARN_ON, made SMP only ]
    
    Signed-off-by: Peter P Waskiewicz Jr <peter.p.waskiewicz.jr@intel.com>
    Cc: davem@davemloft.net
    Cc: arjan@linux.jf.intel.com
    Cc: bhutchings@solarflare.com
    LKML-Reference: <20100430214445.3992.41647.stgit@ppwaskie-hc2.jf.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 707ab122e2e6..c03243ad84b4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -195,6 +195,7 @@ struct irq_desc {
 	raw_spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_var_t		affinity;
+	const struct cpumask	*affinity_hint;
 	unsigned int		node;
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_var_t		pending_mask;

commit fb7b096d949fa852442ed9d8f982bce526ccfe7e
Merge: a626b46e17d0 fad539956c9e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 3 08:15:37 2010 -0800

    Merge branch 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-apic-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (25 commits)
      x86: Fix out of order of gsi
      x86: apic: Fix mismerge, add arch_probe_nr_irqs() again
      x86, irq: Keep chip_data in create_irq_nr and destroy_irq
      xen: Remove unnecessary arch specific xen irq functions.
      smp: Use nr_cpus= to set nr_cpu_ids early
      x86, irq: Remove arch_probe_nr_irqs
      sparseirq: Use radix_tree instead of ptrs array
      sparseirq: Change irq_desc_ptrs to static
      init: Move radix_tree_init() early
      irq: Remove unnecessary bootmem code
      x86: Add iMac9,1 to pci_reboot_dmi_table
      x86: Convert i8259_lock to raw_spinlock
      x86: Convert nmi_lock to raw_spinlock
      x86: Convert ioapic_lock and vector_lock to raw_spinlock
      x86: Avoid race condition in pci_enable_msix()
      x86: Fix SCI on IOAPIC != 0
      x86, ia32_aout: do not kill argument mapping
      x86, irq: Move __setup_vector_irq() before the first irq enable in cpu online path
      x86, irq: Update the vector domain for legacy irqs handled by io-apic
      x86, irq: Don't block IRQ0_VECTOR..IRQ15_VECTOR's on all cpu's
      ...

commit ced5b697a76d325e7a7ac7d382dbbb632c765093
Author: Brandon Phiilps <bphilips@suse.de>
Date:   Wed Feb 10 01:20:06 2010 -0800

    x86: Avoid race condition in pci_enable_msix()
    
    Keep chip_data in create_irq_nr and destroy_irq.
    
    When two drivers are setting up MSI-X at the same time via
    pci_enable_msix() there is a race.  See this dmesg excerpt:
    
    [   85.170610] ixgbe 0000:02:00.1: irq 97 for MSI/MSI-X
    [   85.170611]   alloc irq_desc for 99 on node -1
    [   85.170613] igb 0000:08:00.1: irq 98 for MSI/MSI-X
    [   85.170614]   alloc kstat_irqs on node -1
    [   85.170616] alloc irq_2_iommu on node -1
    [   85.170617]   alloc irq_desc for 100 on node -1
    [   85.170619]   alloc kstat_irqs on node -1
    [   85.170621] alloc irq_2_iommu on node -1
    [   85.170625] ixgbe 0000:02:00.1: irq 99 for MSI/MSI-X
    [   85.170626]   alloc irq_desc for 101 on node -1
    [   85.170628] igb 0000:08:00.1: irq 100 for MSI/MSI-X
    [   85.170630]   alloc kstat_irqs on node -1
    [   85.170631] alloc irq_2_iommu on node -1
    [   85.170635]   alloc irq_desc for 102 on node -1
    [   85.170636]   alloc kstat_irqs on node -1
    [   85.170639] alloc irq_2_iommu on node -1
    [   85.170646] BUG: unable to handle kernel NULL pointer dereference
    at 0000000000000088
    
    As you can see igb and ixgbe are both alternating on create_irq_nr()
    via pci_enable_msix() in their probe function.
    
    ixgbe: While looping through irq_desc_ptrs[] via create_irq_nr() ixgbe
    choses irq_desc_ptrs[102] and exits the loop, drops vector_lock and
    calls dynamic_irq_init. Then it sets irq_desc_ptrs[102]->chip_data =
    NULL via dynamic_irq_init().
    
    igb: Grabs the vector_lock now and starts looping over irq_desc_ptrs[]
    via create_irq_nr(). It gets to irq_desc_ptrs[102] and does this:
    
            cfg_new = irq_desc_ptrs[102]->chip_data;
            if (cfg_new->vector != 0)
                    continue;
    
    This hits the NULL deref.
    
    Another possible race exists via pci_disable_msix() in a driver or in
    the number of error paths that call free_msi_irqs():
    
    destroy_irq()
    dynamic_irq_cleanup() which sets desc->chip_data = NULL
    ...race window...
    desc->chip_data = cfg;
    
    Remove the save and restore code for cfg in create_irq_nr() and
    destroy_irq() and take the desc->lock when checking the irq_cfg.
    
    Reported-and-analyzed-by: Brandon Philips <bphilips@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    LKML-Reference: <1265793639-15071-3-git-send-email-yinghai@kernel.org>
    Signed-off-by: Brandon Phililps <bphilips@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 451481c082b5..4d9b26e044bc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -400,7 +400,9 @@ static inline int irq_has_action(unsigned int irq)
 
 /* Dynamic irq helper functions */
 extern void dynamic_irq_init(unsigned int irq);
+void dynamic_irq_init_keep_chip_data(unsigned int irq);
 extern void dynamic_irq_cleanup(unsigned int irq);
+void dynamic_irq_cleanup_keep_chip_data(unsigned int irq);
 
 /* Set/get chip/data for an IRQ: */
 extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);

commit 599faa0e264fe2e7f563f87b4aad8c83e9dc46d1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 5 13:29:58 2010 +0000

    genirq: Fix documentation of default chip disable()
    
    The documentation says that by default disable() will be
    chip->mask but in fact default_disable() is a noop.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    LKML-Reference: <1262698198-30392-1-git-send-email-broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 451481c082b5..d13492df57a1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -90,7 +90,7 @@ struct msi_desc;
  * @startup:		start up the interrupt (defaults to ->enable if NULL)
  * @shutdown:		shut down the interrupt (defaults to ->disable if NULL)
  * @enable:		enable the interrupt (defaults to chip->unmask if NULL)
- * @disable:		disable the interrupt (defaults to chip->mask if NULL)
+ * @disable:		disable the interrupt
  * @ack:		start of a new interrupt
  * @mask:		mask an interrupt source
  * @mask_ack:		ack and mask an interrupt source

commit 239007b8440abff689632f50cdf0f2b9e895b534
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 17 16:46:45 2009 +0100

    genirq: Convert irq_desc.lock to raw_spinlock
    
    Convert locks which cannot be sleeping locks in preempt-rt to
    raw_spinlocks.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a287cfc0b1a6..451481c082b5 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -192,7 +192,7 @@ struct irq_desc {
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	unsigned int		irqs_unhandled;
-	spinlock_t		lock;
+	raw_spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_var_t		affinity;
 	unsigned int		node;

commit bebd04cc4569844effbdae49c01a48e57fa77864
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Sun Nov 15 18:57:24 2009 +0100

    doc: Fix IRQ chip docs
    
    This patch updates the IRQ docs to match reality.
    
    Signed-off-by: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ae9653dbcd78..a287cfc0b1a6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -282,7 +282,7 @@ extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
 
 /*
  * Built-in IRQ handlers for various IRQ types,
- * callable via desc->chip->handle_irq()
+ * callable via desc->handle_irq()
  */
 extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);

commit d90a7e86401ffea2163a4337f3a47f3909c4e255
Merge: 12a499612e1f 4dbc9ca219b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 11 13:21:31 2009 -0700

    Merge branch 'irq-threaded-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-threaded-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq: Do not mask oneshot edge type interrupts
      genirq: Support nested threaded irq handling
      genirq: Add buslock support
      genirq: Add oneshot support

commit 31b47cf7609288893a10706c648faa932c7aef90
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 24 20:28:04 2009 +0100

    genirq: Add prototype for handle_nested_irq()
    
    The function is supposed to be called from the primary IRQ
    handler for a demultiplexing chip so make a protype visible for
    them.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    LKML-Reference: <1251142084-9852-1-git-send-email-broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6956df9961ab..9e9eb76faf81 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -282,6 +282,7 @@ extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
 extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_nested_irq(unsigned int irq);
 
 /*
  * Monolithic do_IRQ implementation.

commit 399b5da29b9f851eb7b96e2882097127f003e87c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 13 13:21:38 2009 +0200

    genirq: Support nested threaded irq handling
    
    Interrupt chips which are behind a slow bus (i2c, spi ...) and
    demultiplex other interrupt sources need to run their interrupt
    handler in a thread.
    
    The demultiplexed interrupt handlers need to run in thread context as
    well and need to finish before the demux handler thread can reenable
    the interrupt line. So the easiest way is to run the sub device
    handlers in the context of the demultiplexing handler thread.
    
    To avoid that a separate thread is created for the subdevices the
    function set_nested_irq_thread() is provided which sets the
    IRQ_NESTED_THREAD flag in the interrupt descriptor.
    
    A driver which calls request_threaded_irq() must not be aware of the
    fact that the threaded handler is called in the context of the
    demultiplexing handler thread. The setup code checks the
    IRQ_NESTED_THREAD flag which was set from the irq chip setup code and
    does not setup a separate thread for the interrupt. The primary
    function which is provided by the device driver is replaced by an
    internal dummy function which warns when it is called.
    
    For the demultiplexing handler a helper function handle_nested_irq()
    is provided which calls the demux interrupt thread function in the
    context of the caller and does the proper interrupt accounting and
    takes the interrupt disabled status of the demultiplexed subdevice
    into account.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Trilok Soni <soni.trilok@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Brian Swetland <swetland@google.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: m.szyprowski@samsung.com
    Cc: t.fujak@samsung.com
    Cc: kyungmin.park@samsung.com,
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: arve@android.com
    Cc: Barry Song <21cnbao@gmail.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ce8171bc6fac..8778ee993937 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -70,6 +70,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
 #define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
+#define IRQ_NESTED_THREAD	0x10000000	/* IRQ is nested into another, no own handler thread */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
@@ -386,6 +387,8 @@ set_irq_chained_handler(unsigned int irq,
 	__set_irq_handler(irq, handle, 1, NULL);
 }
 
+extern void set_irq_nested_thread(unsigned int irq, int nest);
+
 extern void set_irq_noprobe(unsigned int irq);
 extern void set_irq_probe(unsigned int irq);
 

commit 70aedd24d20e75198f5a0b11750faabbb56924e2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 13 12:17:48 2009 +0200

    genirq: Add buslock support
    
    Some interrupt chips are connected to a "slow" bus (i2c, spi ...). The
    bus access needs to sleep and therefor cannot be called in atomic
    contexts.
    
    Some of the generic interrupt management functions like disable_irq(),
    enable_irq() ... call interrupt chip functions with the irq_desc->lock
    held and interrupts disabled. This does not work for such devices.
    
    Provide a separate synchronization mechanism for such interrupt
    chips. The irq_chip structure is extended by two optional functions
    (bus_lock and bus_sync_and_unlock).
    
    The idea is to serialize the bus access for those operations in the
    core code so that drivers which are behind that bus operated interrupt
    controller do not have to worry about it and just can use the normal
    interfaces. To achieve this we add two function pointers to the
    irq_chip: bus_lock and bus_sync_unlock.
    
    bus_lock() is called to serialize access to the interrupt controller
    bus.
    
    Now the core code can issue chip->mask/unmask ... commands without
    changing the fast path code at all. The chip implementation merily
    stores that information in a chip private data structure and
    returns. No bus interaction as these functions are called from atomic
    context.
    
    After that bus_sync_unlock() is called outside the atomic context. Now
    the chip implementation issues the bus commands, waits for completion
    and unlocks the interrupt controller bus.
    
    The irq_chip implementation as pseudo code:
    
    struct irq_chip_data {
           struct mutex   mutex;
           unsigned int   irq_offset;
           unsigned long  mask;
           unsigned long  mask_status;
    }
    
    static void bus_lock(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            mutex_lock(&data->mutex);
    }
    
    static void mask(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            irq -= data->irq_offset;
            data->mask |= (1 << irq);
    }
    
    static void unmask(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            irq -= data->irq_offset;
            data->mask &= ~(1 << irq);
    }
    
    static void bus_sync_unlock(unsigned int irq)
    {
            struct irq_chip_data *data = get_irq_desc_chip_data(irq);
    
            if (data->mask != data->mask_status) {
                    do_bus_magic_to_set_mask(data->mask);
                    data->mask_status = data->mask;
            }
            mutex_unlock(&data->mutex);
    }
    
    The device drivers can use request_threaded_irq, free_irq, disable_irq
    and enable_irq as usual with the only restriction that the calls need
    to come from non atomic context.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Trilok Soni <soni.trilok@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Brian Swetland <swetland@google.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: m.szyprowski@samsung.com
    Cc: t.fujak@samsung.com
    Cc: kyungmin.park@samsung.com,
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: arve@android.com
    Cc: Barry Song <21cnbao@gmail.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5e7c6ee8c35c..ce8171bc6fac 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -101,6 +101,9 @@ struct msi_desc;
  * @set_type:		set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
  * @set_wake:		enable/disable power-management wake-on of an IRQ
  *
+ * @bus_lock:		function to lock access to slow bus (i2c) chips
+ * @bus_sync_unlock:	function to sync and unlock slow bus (i2c) chips
+ *
  * @release:		release function solely used by UML
  * @typename:		obsoleted by name, kept as migration helper
  */
@@ -124,6 +127,9 @@ struct irq_chip {
 	int		(*set_type)(unsigned int irq, unsigned int flow_type);
 	int		(*set_wake)(unsigned int irq, unsigned int on);
 
+	void		(*bus_lock)(unsigned int irq);
+	void		(*bus_sync_unlock)(unsigned int irq);
+
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);

commit b25c340c195447afb1860da580fe2a85a6b652c5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 13 12:17:22 2009 +0200

    genirq: Add oneshot support
    
    For threaded interrupt handlers we expect the hard interrupt handler
    part to mask the interrupt on the originating device. The interrupt
    line itself is reenabled after the hard interrupt handler has
    executed.
    
    This requires access to the originating device from hard interrupt
    context which is not always possible. There are devices which can only
    be accessed via a bus (i2c, spi, ...). The bus access requires thread
    context. For such devices we need to keep the interrupt line masked
    until the threaded handler has executed.
    
    Add a new flag IRQF_ONESHOT which allows drivers to request that the
    interrupt is not unmasked after the hard interrupt context handler has
    been executed and the thread has been woken. The interrupt line is
    unmasked after the thread handler function has been executed.
    
    Note that for now IRQF_ONESHOT cannot be used with IRQF_SHARED to
    avoid complex accounting mechanisms.
    
    For oneshot interrupts the primary handler simply returns
    IRQ_WAKE_THREAD and does nothing else. A generic implementation
    irq_default_primary_handler() is provided to avoid useless copies all
    over the place. It is automatically installed when
    request_threaded_irq() is called with handler=NULL and
    thread_fn!=NULL.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Trilok Soni <soni.trilok@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Brian Swetland <swetland@google.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: m.szyprowski@samsung.com
    Cc: t.fujak@samsung.com
    Cc: kyungmin.park@samsung.com,
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: arve@android.com
    Cc: Barry Song <21cnbao@gmail.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index cb2e77a3f7f7..5e7c6ee8c35c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -69,6 +69,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 #define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
+#define IRQ_ONESHOT		0x08000000	/* IRQ is not unmasked after hardirq */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit 96ccd4a43a4d80c80be636cd025a69959cf47424
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 5 12:47:52 2009 +0200

    genirq: Remove obsolete defines and typedefs
    
    The defines and typedefs (hw_interrupt_type, no_irq_type, irq_desc_t)
    have been kept around for migration reasons. The last users are gone,
    remove them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index cb2e77a3f7f7..6956df9961ab 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -219,13 +219,6 @@ static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
 
 extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
 
-/*
- * Migration helpers for obsolete names, they will go away:
- */
-#define hw_interrupt_type	irq_chip
-#define no_irq_type		no_irq_chip
-typedef struct irq_desc		irq_desc_t;
-
 /*
  * Pick up the arch-dependent methods:
  */

commit 2453d6ff6ffc5f0d496b7b14f509a26f99bf115e
Merge: 12e24f34cb0d ab33dcff40d7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 20 11:30:01 2009 -0700

    Merge branch 'irq-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'irq-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq, irq.h: Fix kernel-doc warnings
      genirq: fix comment to say IRQ_WAKE_THREAD

commit ab33dcff40d7a9a28587e4425621e4cbc4089e03
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Jun 13 20:01:00 2009 -0700

    genirq, irq.h: Fix kernel-doc warnings
    
    Fix kernel-doc warnings in linux/irq.h:
    
      Warning(include/linux/irq.h:201): No description found for parameter 'node'
      Warning(include/linux/irq.h:201): Excess struct/union/enum/typedef member 'cpu' description in 'irq_desc'
      Warning(include/linux/irq.h:434): No description found for parameter 'node'
      Warning(include/linux/irq.h:434): Excess function parameter 'cpu' description in 'alloc_desc_masks'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    LKML-Reference: <4A3467EC.50006@oracle.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b7cbeed972e4..0c001c15752a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -157,7 +157,7 @@ struct irq_2_iommu;
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
  * @affinity:		IRQ affinity on SMP
- * @cpu:		cpu index useful for balancing
+ * @node:		node index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
  * @threads_active:	number of irqaction threads currently running
  * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
@@ -426,7 +426,7 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 /**
  * init_alloc_desc_masks - allocate cpumasks for irq_desc
  * @desc:	pointer to irq_desc struct
- * @cpu:	cpu which will be handling the cpumasks
+ * @node:	node which will be handling the cpumasks
  * @boot:	true if need bootmem
  *
  * Allocates affinity and pending_mask cpumask if required.

commit 38c7fed2f5ffee17e1fa3e0f78b0e1bf43d52d13
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon May 25 15:10:58 2009 +0300

    x86: remove some alloc_bootmem_cpumask_var calling
    
    Now that we set up the slab allocator earlier, we can get rid of some
    alloc_bootmem_cpumask_var() calls in boot code.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index eedbb8e5e0cc..1e50c34f0062 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -430,23 +430,19 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
  * Returns true if successful (or not required).
  */
 static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
-								bool boot)
+							bool boot)
 {
-#ifdef CONFIG_CPUMASK_OFFSTACK
-	if (boot) {
-		alloc_bootmem_cpumask_var(&desc->affinity);
+	gfp_t gfp = GFP_ATOMIC;
 
-#ifdef CONFIG_GENERIC_PENDING_IRQ
-		alloc_bootmem_cpumask_var(&desc->pending_mask);
-#endif
-		return true;
-	}
+	if (boot)
+		gfp = GFP_NOWAIT;
 
-	if (!alloc_cpumask_var_node(&desc->affinity, GFP_ATOMIC, node))
+#ifdef CONFIG_CPUMASK_OFFSTACK
+	if (!alloc_cpumask_var_node(&desc->affinity, gfp, node))
 		return false;
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
-	if (!alloc_cpumask_var_node(&desc->pending_mask, GFP_ATOMIC, node)) {
+	if (!alloc_cpumask_var_node(&desc->pending_mask, gfp, node)) {
 		free_cpumask_var(desc->affinity);
 		return false;
 	}

commit 15e957d08dd4a841359cfec59ecb74041e0097aa
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 30 01:17:50 2009 -0700

    x86/irq: use move_irq_desc() in create_irq_nr()
    
    move_irq_desc() will try to move irq_desc to the home node if
    the allocated one is not correct, in create_irq_nr().
    
    ( This can happen on devices that are on different nodes that
      are using MSI, when drivers are loaded and unloaded randomly. )
    
    v2: fix non-smp build
    v3: add NUMA_IRQ_DESC to eliminate #ifdefs
    
    [ Impact: improve irq descriptor locality on NUMA systems ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49F95EAE.2050903@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4b95ddb5304b..eedbb8e5e0cc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -206,9 +206,16 @@ extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc
 
 #ifndef CONFIG_SPARSE_IRQ
 extern struct irq_desc irq_desc[NR_IRQS];
-#else /* CONFIG_SPARSE_IRQ */
+#endif
+
+#ifdef CONFIG_NUMA_IRQ_DESC
 extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int node);
-#endif /* CONFIG_SPARSE_IRQ */
+#else
+static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
+{
+	return desc;
+}
+#endif
 
 extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
 

commit d047f53a2ecce37e3bdf79eac5a326fbaadb3628
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 18:02:23 2009 -0700

    x86/irq: change MSI irq_desc to be more numa aware
    
    Try to get irq_desc on the home node in create_irq_nr().
    
    v2: don't check if we can move it when sparse_irq is not used
    v3: use move_irq_des, if that node is not what we want
    
    [ Impact: optimization, make MSI IRQ descriptors more NUMA aware ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49F6559F.7070005@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a09baf8f9d99..4b95ddb5304b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -376,7 +376,7 @@ extern void set_irq_noprobe(unsigned int irq);
 extern void set_irq_probe(unsigned int irq);
 
 /* Handle dynamic irq creation and destruction */
-extern unsigned int create_irq_nr(unsigned int irq_want);
+extern unsigned int create_irq_nr(unsigned int irq_want, int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
 

commit 85ac16d033370caf6f48d743c8dc8103700f5cc5
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 18:00:38 2009 -0700

    x86/irq: change irq_desc_alloc() to take node instead of cpu
    
    This simplifies the node awareness of the code. All our allocators
    only deal with a NUMA node ID locality not with CPU ids anyway - so
    there's no need to maintain (and transform) a CPU id all across the
    IRq layer.
    
    v2: keep move_irq_desc related
    
    [ Impact: cleanup, prepare IRQ code to be NUMA-aware ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    LKML-Reference: <49F65536.2020300@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8e4c18b29157..a09baf8f9d99 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -187,7 +187,7 @@ struct irq_desc {
 	spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_var_t		affinity;
-	unsigned int		cpu;
+	unsigned int		node;
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_var_t		pending_mask;
 #endif
@@ -201,16 +201,16 @@ struct irq_desc {
 } ____cacheline_internodealigned_in_smp;
 
 extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
-					struct irq_desc *desc, int cpu);
+					struct irq_desc *desc, int node);
 extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
 
 #ifndef CONFIG_SPARSE_IRQ
 extern struct irq_desc irq_desc[NR_IRQS];
 #else /* CONFIG_SPARSE_IRQ */
-extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
+extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int node);
 #endif /* CONFIG_SPARSE_IRQ */
 
-extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
+extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
 
 /*
  * Migration helpers for obsolete names, they will go away:
@@ -422,12 +422,10 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
  * Allocates affinity and pending_mask cpumask if required.
  * Returns true if successful (or not required).
  */
-static inline bool alloc_desc_masks(struct irq_desc *desc, int cpu,
+static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
 								bool boot)
 {
 #ifdef CONFIG_CPUMASK_OFFSTACK
-	int node;
-
 	if (boot) {
 		alloc_bootmem_cpumask_var(&desc->affinity);
 
@@ -437,8 +435,6 @@ static inline bool alloc_desc_masks(struct irq_desc *desc, int cpu,
 		return true;
 	}
 
-	node = cpu_to_node(cpu);
-
 	if (!alloc_cpumask_var_node(&desc->affinity, GFP_ATOMIC, node))
 		return false;
 
@@ -494,7 +490,7 @@ static inline void free_desc_masks(struct irq_desc *old_desc,
 
 #else /* !CONFIG_SMP */
 
-static inline bool alloc_desc_masks(struct irq_desc *desc, int cpu,
+static inline bool alloc_desc_masks(struct irq_desc *desc, int node,
 								bool boot)
 {
 	return true;

commit d5dedd4507d307eb3f35f21b6e16f336fdc0d82a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 17:59:21 2009 -0700

    irq: change ->set_affinity() to return status
    
    according to Ingo, change set_affinity() in irq_chip should return int,
    because that way we can handle failure cases in a much cleaner way, in
    the genirq layer.
    
    v2: fix two typos
    
    [ Impact: extend API ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: linux-arch@vger.kernel.org
    LKML-Reference: <49F654E9.4070809@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2a34cd6281d7..8e4c18b29157 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -117,7 +117,7 @@ struct irq_chip {
 	void		(*eoi)(unsigned int irq);
 
 	void		(*end)(unsigned int irq);
-	void		(*set_affinity)(unsigned int irq,
+	int		(*set_affinity)(unsigned int irq,
 					const struct cpumask *dest);
 	int		(*retrigger)(unsigned int irq);
 	int		(*set_type)(unsigned int irq, unsigned int flow_type);

commit fcef5911c7ea89b80d5bfc727f402f37c9eefd57
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 17:58:23 2009 -0700

    x86/irq: remove leftover code from NUMA_MIGRATE_IRQ_DESC
    
    The original feature of migrating irq_desc dynamic was too fragile
    and was causing problems: it caused crashes on systems with lots of
    cards with MSI-X when user-space irq-balancer was enabled.
    
    We now have new patches that create irq_desc according to device
    numa node. This patch removes the leftover bits of the dynamic balancer.
    
    [ Impact: remove dead code ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49F654AF.8000808@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c4953cf27e5e..2a34cd6281d7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -212,16 +212,6 @@ extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
 
 extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
 
-static inline struct irq_desc *
-irq_remap_to_desc(unsigned int irq, struct irq_desc *desc)
-{
-#ifdef CONFIG_NUMA_MIGRATE_IRQ_DESC
-	return irq_to_desc(irq);
-#else
-	return desc;
-#endif
-}
-
 /*
  * Migration helpers for obsolete names, they will go away:
  */

commit 9ec4fa271faf2db3b8e1419c998da1ca6b094eb6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 27 17:57:18 2009 -0700

    irq, cpumask: correct CPUMASKS_OFFSTACK typo and fix fallout
    
    CPUMASKS_OFFSTACK is not defined anywhere (it is CPUMASK_OFFSTACK).
    It is a typo and init_allocate_desc_masks() is called before it set
    affinity to all cpus...
    
    Split init_alloc_desc_masks() into all_desc_masks() and init_desc_masks().
    
    Also use CPUMASK_OFFSTACK in alloc_desc_masks().
    
    [ Impact: fix smp_affinity copying/setup when moving irq_desc between CPUs ]
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    LKML-Reference: <49F6546E.3040406@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b7cbeed972e4..c4953cf27e5e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -424,27 +424,25 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
 #ifdef CONFIG_SMP
 /**
- * init_alloc_desc_masks - allocate cpumasks for irq_desc
+ * alloc_desc_masks - allocate cpumasks for irq_desc
  * @desc:	pointer to irq_desc struct
  * @cpu:	cpu which will be handling the cpumasks
  * @boot:	true if need bootmem
  *
  * Allocates affinity and pending_mask cpumask if required.
  * Returns true if successful (or not required).
- * Side effect: affinity has all bits set, pending_mask has all bits clear.
  */
-static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
+static inline bool alloc_desc_masks(struct irq_desc *desc, int cpu,
 								bool boot)
 {
+#ifdef CONFIG_CPUMASK_OFFSTACK
 	int node;
 
 	if (boot) {
 		alloc_bootmem_cpumask_var(&desc->affinity);
-		cpumask_setall(desc->affinity);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 		alloc_bootmem_cpumask_var(&desc->pending_mask);
-		cpumask_clear(desc->pending_mask);
 #endif
 		return true;
 	}
@@ -453,18 +451,25 @@ static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
 
 	if (!alloc_cpumask_var_node(&desc->affinity, GFP_ATOMIC, node))
 		return false;
-	cpumask_setall(desc->affinity);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	if (!alloc_cpumask_var_node(&desc->pending_mask, GFP_ATOMIC, node)) {
 		free_cpumask_var(desc->affinity);
 		return false;
 	}
-	cpumask_clear(desc->pending_mask);
+#endif
 #endif
 	return true;
 }
 
+static inline void init_desc_masks(struct irq_desc *desc)
+{
+	cpumask_setall(desc->affinity);
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	cpumask_clear(desc->pending_mask);
+#endif
+}
+
 /**
  * init_copy_desc_masks - copy cpumasks for irq_desc
  * @old_desc:	pointer to old irq_desc struct
@@ -478,7 +483,7 @@ static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
 static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 					struct irq_desc *new_desc)
 {
-#ifdef CONFIG_CPUMASKS_OFFSTACK
+#ifdef CONFIG_CPUMASK_OFFSTACK
 	cpumask_copy(new_desc->affinity, old_desc->affinity);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
@@ -499,12 +504,16 @@ static inline void free_desc_masks(struct irq_desc *old_desc,
 
 #else /* !CONFIG_SMP */
 
-static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
+static inline bool alloc_desc_masks(struct irq_desc *desc, int cpu,
 								bool boot)
 {
 	return true;
 }
 
+static inline void init_desc_masks(struct irq_desc *desc)
+{
+}
+
 static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 					struct irq_desc *new_desc)
 {

commit 422a253483aa5de71a2bcdc27b0aa023053f97f8
Merge: 91e58b6e95a9 022624a758dc 9756b15e1b58 8f2e586567b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 9 10:35:30 2009 -0700

    Merge branches 'core-fixes-for-linus', 'irq-fixes-for-linus' and 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      printk: fix wrong format string iter for printk
      futex: comment requeue key reference semantics
    
    * 'irq-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      irq: fix cpumask memory leak on offstack cpumask kernels
    
    * 'timers-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      posix-timers: fix RLIMIT_CPU && setitimer(CPUCLOCK_PROF)
      posix-timers: fix RLIMIT_CPU && fork()
      timers: add missing kernel-doc

commit 9efe21cb82b5dbe3b0b2ae4de4eccc64ecb94e95
Merge: de18836e447c 0221c81b1b8e
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Apr 6 01:41:22 2009 +0200

    Merge branch 'linus' into irq/threaded
    
    Conflicts:
            include/linux/irq.h
            kernel/irq/handle.c

commit 9756b15e1b58453a6fd54b85c1ad8515209e10bb
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Mar 30 20:37:20 2009 -0700

    irq: fix cpumask memory leak on offstack cpumask kernels
    
    Need to free the old cpumask for affinity and pending_mask.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    LKML-Reference: <49D18FF0.50707@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 974890b3c52f..99d147efe399 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -482,6 +482,16 @@ static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 #endif
 }
 
+static inline void free_desc_masks(struct irq_desc *old_desc,
+				   struct irq_desc *new_desc)
+{
+	free_cpumask_var(old_desc->affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	free_cpumask_var(old_desc->pending_mask);
+#endif
+}
+
 #else /* !CONFIG_SMP */
 
 static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
@@ -495,6 +505,10 @@ static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 {
 }
 
+static inline void free_desc_masks(struct irq_desc *old_desc,
+				   struct irq_desc *new_desc)
+{
+}
 #endif	/* CONFIG_SMP */
 
 #endif /* _LINUX_IRQ_H */

commit 0a0c5168df270a50e3518e4f12bddb31f8f5f38f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:33:49 2009 +0100

    PM: Introduce functions for suspending and resuming device interrupts
    
    Introduce helper functions allowing us to prevent device drivers from
    getting any interrupts (without disabling interrupts on the CPU)
    during suspend (or hibernation) and to make them start to receive
    interrupts again during the subsequent resume.  These functions make it
    possible to keep timer interrupts enabled while the "late" suspend and
    "early" resume callbacks provided by device drivers are being
    executed.  In turn, this allows device drivers' "late" suspend and
    "early" resume callbacks to sleep, execute ACPI callbacks etc.
    
    The functions introduced here will be used to rework the handling of
    interrupts during suspend (hibernation) and resume.  Namely,
    interrupts will only be disabled on the CPU right before suspending
    sysdevs, while device drivers will be prevented from receiving
    interrupts, with the help of the new helper function, before their
    "late" suspend callbacks run (and analogously during resume).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9c62fbe2ef30..974890b3c52f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -67,6 +67,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_SPURIOUS_DISABLED	0x00800000	/* IRQ was disabled by the spurious trap */
 #define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
 #define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
+#define IRQ_SUSPENDED		0x04000000	/* IRQ has gone through suspend sequence */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit 503e57630309643562c12f09d4c8a96eb629ee33
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Mar 29 12:59:50 2009 +0200

    Fix build error in <linux/irq.h>
    
    <linux/irq.h> relies on <linux/gfp.h> and <linux/topology.h> having been
    included previous.  If not, the errors like below will result.
    
        CC      arch/mips/mti-malta/malta-int.o
      In file included from arch/mips/mti-malta/malta-int.c:25:
      include/linux/irq.h: In function init_alloc_desc_masks:
      include/linux/irq.h:444: error: implicit declaration of function cpu_to_node
      include/linux/irq.h:446: error: GFP_ATOMIC undeclared (first use in this function)
      include/linux/irq.h:446: error: (Each undeclared identifier is reported only once
      include/linux/irq.h:446: error: for each function it appears in.)
      make[3]: *** [arch/mips/mti-malta/malta-int.o] Error 1
      make[2]: *** [arch/mips/mti-malta] Error 2
      make[1]: *** [sub-make] Error 2
    
    Fixed by including the two missing headers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 873e4ac11b81..9c62fbe2ef30 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -17,9 +17,11 @@
 #include <linux/cache.h>
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
+#include <linux/gfp.h>
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
 #include <linux/errno.h>
+#include <linux/topology.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>

commit 6e15cf04860074ad032e88c306bea656bbdd0f22
Merge: be0ea69674ed 60db56422043
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 26 21:39:17 2009 +0100

    Merge branch 'core/percpu' into percpu-cpumask-x86-for-linus-2
    
    Conflicts:
            arch/parisc/kernel/irq.c
            arch/x86/include/asm/fixmap_64.h
            arch/x86/include/asm/setup.h
            kernel/irq/handle.c
    
    Semantic merge:
            arch/x86/include/asm/fixmap.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 3aa551c9b4c40018f0e261a178e3d25478dc04a9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 23 18:28:15 2009 +0100

    genirq: add threaded interrupt handler support
    
    Add support for threaded interrupt handlers:
    
    A device driver can request that its main interrupt handler runs in a
    thread. To achive this the device driver requests the interrupt with
    request_threaded_irq() and provides additionally to the handler a
    thread function. The handler function is called in hard interrupt
    context and needs to check whether the interrupt originated from the
    device. If the interrupt originated from the device then the handler
    can either return IRQ_HANDLED or IRQ_WAKE_THREAD. IRQ_HANDLED is
    returned when no further action is required. IRQ_WAKE_THREAD causes
    the genirq code to invoke the threaded (main) handler. When
    IRQ_WAKE_THREAD is returned handler must have disabled the interrupt
    on the device level. This is mandatory for shared interrupt handlers,
    but we need to do it as well for obscure x86 hardware where disabling
    an interrupt on the IO_APIC level redirects the interrupt to the
    legacy PIC interrupt lines.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 873e4ac11b81..8b1cf0630210 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -20,6 +20,7 @@
 #include <linux/irqreturn.h>
 #include <linux/irqnr.h>
 #include <linux/errno.h>
+#include <linux/wait.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -155,6 +156,8 @@ struct irq_2_iommu;
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
+ * @threads_active:	number of irqaction threads currently running
+ * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
  * @dir:		/proc/irq/ procfs entry
  * @name:		flow handler name for /proc/interrupts output
  */
@@ -186,6 +189,8 @@ struct irq_desc {
 	cpumask_var_t		pending_mask;
 #endif
 #endif
+	atomic_t		threads_active;
+	wait_queue_head_t       wait_for_threads;
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif

commit 80c5520811d3805adcb15c570ea5e2d489fa5d0b
Merge: b3e3b302cf6d 8c083f081d00
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 23 14:50:03 2009 +0100

    Merge branch 'cpus4096' into irq/threaded
    
    Conflicts:
            arch/parisc/kernel/irq.c
            kernel/irq/handle.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit edb35028e40515beb2f94808aff8b3e71fb9f35a
Merge: 8f8573ae9f5d cb065c06b6cc 5bee17f18b59
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Mar 16 09:20:13 2009 +0100

    Merge branches 'irq/genirq' and 'linus' into irq/core

commit bedd30d986a05e32dc3eab874e4b9ed8a38058bb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 30 23:14:27 2008 +0200

    genirq: make irqreturn_t an enum
    
    Impact: cleanup
    
    Remove the 2.4 compabiliy cruft
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Peter Zijlstra <peterz@infradead.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7c07a09931db..19770923bcb0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -280,7 +280,7 @@ static inline int irq_balancing_disabled(unsigned int irq)
 }
 
 /* Handle irq action chains: */
-extern int handle_IRQ_event(unsigned int irq, struct irqaction *action);
+extern irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action);
 
 /*
  * Built-in IRQ handlers for various IRQ types,
@@ -325,7 +325,7 @@ static inline void generic_handle_irq(unsigned int irq)
 
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
-			   int action_ret);
+			   irqreturn_t action_ret);
 
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);

commit 3dd3d46b78c22503957230ca5981849b7bb29b9a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 9 21:48:32 2009 +0100

    genirq: remove unused hw_irq_controller typedef
    
    hw_irq_controller is unused. Remove the typedef
    
    Impact: cleanup
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 737eafbc1f3d..7c07a09931db 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -226,7 +226,6 @@ irq_remap_to_desc(unsigned int irq, struct irq_desc *desc)
  * Migration helpers for obsolete names, they will go away:
  */
 #define hw_interrupt_type	irq_chip
-typedef struct irq_chip		hw_irq_controller;
 #define no_irq_type		no_irq_chip
 typedef struct irq_desc		irq_desc_t;
 

commit cbf94f06824780183e4bba165c7c29d5c7bd9a51
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Mar 12 21:05:51 2009 +0900

    irq: match remove_irq() args with setup_irq()
    
    Modify remove_irq() to match setup_irq().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    LKML-Reference: <20090312120551.2926.43942.sendpatchset@rx1.opensource.se>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 56f9988362ec..737eafbc1f3d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -236,7 +236,7 @@ typedef struct irq_desc		irq_desc_t;
 #include <asm/hw_irq.h>
 
 extern int setup_irq(unsigned int irq, struct irqaction *new);
-extern struct irqaction *remove_irq(unsigned int irq, void *dev_id);
+extern void remove_irq(unsigned int irq, struct irqaction *act);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 

commit f21cfb258df6dd3ea0b3e56d75c7e994edb81b35
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Mar 12 21:05:42 2009 +0900

    irq: add remove_irq() for freeing of setup_irq() irqs
    
    Impact: add new API
    
    This patch adds a remove_irq() function for releasing
    interrupts requested with setup_irq().
    
    Without this patch we have no way of releasing such
    interrupts since free_irq() today tries to kfree()
    the irqaction passed with setup_irq().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    LKML-Reference: <20090312120542.2926.56609.sendpatchset@rx1.opensource.se>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f899b502f186..56f9988362ec 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -236,6 +236,7 @@ typedef struct irq_desc		irq_desc_t;
 #include <asm/hw_irq.h>
 
 extern int setup_irq(unsigned int irq, struct irqaction *new);
+extern struct irqaction *remove_irq(unsigned int irq, void *dev_id);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 

commit d52a61c04c6c0814ca270a088feedb126436598e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Jan 22 00:38:56 2009 -0800

    irq: clean up irq stat methods
    
    David Miller suggested, related to a kstat_irqs related build breakage:
    
    > Either linux/kernel_stat.h provides the kstat_incr_irqs_this_cpu
    > interface or linux/irq.h does, not both.
    
    So move them to kernel_stat.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e9a878978c85..48901e9a33b9 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -202,12 +202,6 @@ extern struct irq_desc irq_desc[NR_IRQS];
 extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
 #endif /* CONFIG_SPARSE_IRQ */
 
-#define kstat_irqs_this_cpu(DESC) \
-	((DESC)->kstat_irqs[smp_processor_id()])
-#define kstat_incr_irqs_this_cpu(irqno, DESC) \
-	((DESC)->kstat_irqs[smp_processor_id()]++)
-
-
 extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
 
 static inline struct irq_desc *

commit 802bf931f2688ad125b73db597ce63cc842fb27a
Author: Mike Travis <travis@sgi.com>
Date:   Sat Jan 10 21:58:09 2009 -0800

    cpumask: fix bug in use cpumask_var_t in irq_desc
    
    Impact: fix bug where new irq_desc uses old cpumask pointers which are freed.
    
    As Yinghai pointed out, init_copy_one_irq_desc() copies the old desc to
    the new desc overwriting the cpumask pointers.  Since the old_desc and
    the cpumask pointers are freed, then memory corruption will occur if
    these old pointers are used.
    
    Move the allocation of these pointers to after the copy.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Cc: Yinghai Lu <yinghai@kernel.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fa27210f1dfd..27a67536511e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -426,15 +426,18 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 /**
  * init_alloc_desc_masks - allocate cpumasks for irq_desc
  * @desc:	pointer to irq_desc struct
+ * @cpu:	cpu which will be handling the cpumasks
  * @boot:	true if need bootmem
  *
  * Allocates affinity and pending_mask cpumask if required.
  * Returns true if successful (or not required).
  * Side effect: affinity has all bits set, pending_mask has all bits clear.
  */
-static inline bool init_alloc_desc_masks(struct irq_desc *desc, int node,
+static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
 								bool boot)
 {
+	int node;
+
 	if (boot) {
 		alloc_bootmem_cpumask_var(&desc->affinity);
 		cpumask_setall(desc->affinity);
@@ -446,6 +449,8 @@ static inline bool init_alloc_desc_masks(struct irq_desc *desc, int node,
 		return true;
 	}
 
+	node = cpu_to_node(cpu);
+
 	if (!alloc_cpumask_var_node(&desc->affinity, GFP_ATOMIC, node))
 		return false;
 	cpumask_setall(desc->affinity);
@@ -484,7 +489,7 @@ static inline void init_copy_desc_masks(struct irq_desc *old_desc,
 
 #else /* !CONFIG_SMP */
 
-static inline bool init_alloc_desc_masks(struct irq_desc *desc, int node,
+static inline bool init_alloc_desc_masks(struct irq_desc *desc, int cpu,
 								bool boot)
 {
 	return true;

commit 7f7ace0cda64c99599c23785f8979a072e118058
Author: Mike Travis <travis@sgi.com>
Date:   Sat Jan 10 21:58:08 2009 -0800

    cpumask: update irq_desc to use cpumask_var_t
    
    Impact: reduce memory usage, use new cpumask API.
    
    Replace the affinity and pending_masks with cpumask_var_t's.  This adds
    to the significant size reduction done with the SPARSE_IRQS changes.
    
    The added functions (init_alloc_desc_masks & init_copy_desc_masks) are
    in the include file so they can be inlined (and optimized out for the
    !CONFIG_CPUMASKS_OFFSTACK case.)  [Naming chosen to be consistent with
    the other init*irq functions, as well as the backwards arg declaration
    of "from, to" instead of the more common "to, from" standard.]
    
    Includes a slight change to the declaration of struct irq_desc to embed
    the pending_mask within ifdef(CONFIG_SMP) to be consistent with other
    references, and some small changes to Xen.
    
    Tested: sparse/non-sparse/cpumask_offstack/non-cpumask_offstack/nonuma/nosmp on x86_64
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: virtualization@lists.osdl.org
    Cc: xen-devel@lists.xensource.com
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f899b502f186..fa27210f1dfd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -182,11 +182,11 @@ struct irq_desc {
 	unsigned int		irqs_unhandled;
 	spinlock_t		lock;
 #ifdef CONFIG_SMP
-	cpumask_t		affinity;
+	cpumask_var_t		affinity;
 	unsigned int		cpu;
-#endif
 #ifdef CONFIG_GENERIC_PENDING_IRQ
-	cpumask_t		pending_mask;
+	cpumask_var_t		pending_mask;
+#endif
 #endif
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
@@ -422,4 +422,79 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
 #endif /* !CONFIG_S390 */
 
+#ifdef CONFIG_SMP
+/**
+ * init_alloc_desc_masks - allocate cpumasks for irq_desc
+ * @desc:	pointer to irq_desc struct
+ * @boot:	true if need bootmem
+ *
+ * Allocates affinity and pending_mask cpumask if required.
+ * Returns true if successful (or not required).
+ * Side effect: affinity has all bits set, pending_mask has all bits clear.
+ */
+static inline bool init_alloc_desc_masks(struct irq_desc *desc, int node,
+								bool boot)
+{
+	if (boot) {
+		alloc_bootmem_cpumask_var(&desc->affinity);
+		cpumask_setall(desc->affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+		alloc_bootmem_cpumask_var(&desc->pending_mask);
+		cpumask_clear(desc->pending_mask);
+#endif
+		return true;
+	}
+
+	if (!alloc_cpumask_var_node(&desc->affinity, GFP_ATOMIC, node))
+		return false;
+	cpumask_setall(desc->affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	if (!alloc_cpumask_var_node(&desc->pending_mask, GFP_ATOMIC, node)) {
+		free_cpumask_var(desc->affinity);
+		return false;
+	}
+	cpumask_clear(desc->pending_mask);
+#endif
+	return true;
+}
+
+/**
+ * init_copy_desc_masks - copy cpumasks for irq_desc
+ * @old_desc:	pointer to old irq_desc struct
+ * @new_desc:	pointer to new irq_desc struct
+ *
+ * Insures affinity and pending_masks are copied to new irq_desc.
+ * If !CONFIG_CPUMASKS_OFFSTACK the cpumasks are embedded in the
+ * irq_desc struct so the copy is redundant.
+ */
+
+static inline void init_copy_desc_masks(struct irq_desc *old_desc,
+					struct irq_desc *new_desc)
+{
+#ifdef CONFIG_CPUMASKS_OFFSTACK
+	cpumask_copy(new_desc->affinity, old_desc->affinity);
+
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	cpumask_copy(new_desc->pending_mask, old_desc->pending_mask);
+#endif
+#endif
+}
+
+#else /* !CONFIG_SMP */
+
+static inline bool init_alloc_desc_masks(struct irq_desc *desc, int node,
+								bool boot)
+{
+	return true;
+}
+
+static inline void init_copy_desc_masks(struct irq_desc *old_desc,
+					struct irq_desc *new_desc)
+{
+}
+
+#endif	/* CONFIG_SMP */
+
 #endif /* _LINUX_IRQ_H */

commit d7e51e66899f95dabc89b4d4c6674a6e50fa37fc
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Jan 7 15:03:13 2009 -0800

    sparseirq: make some func to be used with genirq
    
    Impact: clean up sparseirq fallout on random.c
    
    Ingo suggested to change some ifdef from SPARSE_IRQ to GENERIC_HARDIRQS
    so we could some #ifdef later if all arch support genirq
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f899b502f186..e9a878978c85 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -160,12 +160,10 @@ struct irq_2_iommu;
  */
 struct irq_desc {
 	unsigned int		irq;
-#ifdef CONFIG_SPARSE_IRQ
 	struct timer_rand_state *timer_rand_state;
 	unsigned int            *kstat_irqs;
-# ifdef CONFIG_INTR_REMAP
+#ifdef CONFIG_INTR_REMAP
 	struct irq_2_iommu      *irq_2_iommu;
-# endif
 #endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
@@ -202,13 +200,13 @@ extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc
 extern struct irq_desc irq_desc[NR_IRQS];
 #else /* CONFIG_SPARSE_IRQ */
 extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
+#endif /* CONFIG_SPARSE_IRQ */
 
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])
 #define kstat_incr_irqs_this_cpu(irqno, DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()]++)
 
-#endif /* CONFIG_SPARSE_IRQ */
 
 extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
 

commit b840d79631c882786925303c2b0f4fefc31845ed
Merge: 597b0d21626d c3d80000e3a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 2 11:44:09 2009 -0800

    Merge branch 'cpus4096-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (66 commits)
      x86: export vector_used_by_percpu_irq
      x86: use logical apicid in x2apic_cluster's x2apic_cpu_mask_to_apicid_and()
      sched: nominate preferred wakeup cpu, fix
      x86: fix lguest used_vectors breakage, -v2
      x86: fix warning in arch/x86/kernel/io_apic.c
      sched: fix warning in kernel/sched.c
      sched: move test_sd_parent() to an SMP section of sched.h
      sched: add SD_BALANCE_NEWIDLE at MC and CPU level for sched_mc>0
      sched: activate active load balancing in new idle cpus
      sched: bias task wakeups to preferred semi-idle packages
      sched: nominate preferred wakeup cpu
      sched: favour lower logical cpu number for sched_mc balance
      sched: framework for sched_mc/smt_power_savings=N
      sched: convert BALANCE_FOR_xx_POWER to inline functions
      x86: use possible_cpus=NUM to extend the possible cpus allowed
      x86: fix cpu_mask_to_apicid_and to include cpu_online_mask
      x86: update io_apic.c to the new cpumask code
      x86: Introduce topology_core_cpumask()/topology_thread_cpumask()
      x86: xen: use smp_call_function_many()
      x86: use work_on_cpu in x86/kernel/cpu/mcheck/mce_amd_64.c
      ...
    
    Fixed up trivial conflict in kernel/time/tick-sched.c manually

commit 43a256322ac1fc105c181b3cade3b9bfc0b63ca1
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Sun Dec 28 16:01:13 2008 -0800

    sparseirq: move __weak symbols into separate compilation unit
    
    GCC has a bug with __weak alias functions: if the functions are in
    the same compilation unit as their call site, GCC can decide to
    inline them - and thus rob the linker of the opportunity to override
    the weak alias with the real thing.
    
    So move all the IRQ handling related __weak symbols to kernel/irq/chip.c.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0e40af4bac40..d64a6d49bdef 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -193,9 +193,6 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-extern int early_irq_init(void);
-extern int arch_early_irq_init(void);
-extern int arch_init_chip_data(struct irq_desc *desc, int cpu);
 extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
 					struct irq_desc *desc, int cpu);
 extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);

commit 13a0c3c269b223f60abfac8a9811d77111a8b4ba
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 26 02:05:47 2008 -0800

    sparseirq: work around compiler optimizing away __weak functions
    
    Impact: fix panic on null pointer with sparseirq
    
    Some GCC versions seem to inline the weak global function,
    when that function is empty.
    
    Work it around, by making the functions return a (dummy) integer.
    
    Signed-off-by: Yinghai <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 69da275c0ebd..0e40af4bac40 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -193,9 +193,9 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-extern void early_irq_init(void);
-extern void arch_early_irq_init(void);
-extern void arch_init_chip_data(struct irq_desc *desc, int cpu);
+extern int early_irq_init(void);
+extern int arch_early_irq_init(void);
+extern int arch_init_chip_data(struct irq_desc *desc, int cpu);
 extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
 					struct irq_desc *desc, int cpu);
 extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);

commit f9af0e70911e9d6cc9a68f784dca86415486084d
Author: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Date:   Fri Dec 26 12:24:24 2008 +0900

    irq: for_each_irq_desc() move to irqnr.h
    
    Impact: cleanup
    
    before CONFIG_SPARSE_IRQ age, for_each_irq_desc() sat in irqnr.h and
    could be called from generic code.
    
    CONFIG_SPARSE_IRQ breaks this assumption, but SPARSE_IRQ version
    for_each_irq_desc() also can move into irqnr.h easily.
    
    Also, this patch unifies CONFIG_SPARSE_IRQ and !CONFIG_SPARSE_IRQ
    for_each_irq_desc().
    
    Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 98564dc64476..69da275c0ebd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -202,33 +202,17 @@ extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc
 
 #ifndef CONFIG_SPARSE_IRQ
 extern struct irq_desc irq_desc[NR_IRQS];
-
-static inline struct irq_desc *irq_to_desc(unsigned int irq)
-{
-	return (irq < NR_IRQS) ? irq_desc + irq : NULL;
-}
-static inline struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu)
-{
-	return irq_to_desc(irq);
-}
-
-#else
-
-extern struct irq_desc *irq_to_desc(unsigned int irq);
-extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
+#else /* CONFIG_SPARSE_IRQ */
 extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
 
-# define for_each_irq_desc(irq, desc)		\
-	for (irq = 0, desc = irq_to_desc(irq); irq < nr_irqs; irq++, desc = irq_to_desc(irq))
-# define for_each_irq_desc_reverse(irq, desc)                          \
-	for (irq = nr_irqs - 1, desc = irq_to_desc(irq); irq >= 0; irq--, desc = irq_to_desc(irq))
-
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])
 #define kstat_incr_irqs_this_cpu(irqno, DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()]++)
 
-#endif
+#endif /* CONFIG_SPARSE_IRQ */
+
+extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
 
 static inline struct irq_desc *
 irq_remap_to_desc(unsigned int irq, struct irq_desc *desc)

commit 860cf8894b326e4b89720f520540604834337b72
Merge: e262a7ba31f0 973656fe1afb f2b662da8d6b 4a6908a3a050
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Dec 25 16:27:54 2008 +0100

    Merge branches 'irq/sparseirq', 'irq/genirq' and 'irq/urgent'; commit 'v2.6.28' into irq/core

commit 078a55db075bf4dcc03115dc94875b3dd83f69d4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Dec 18 16:57:52 2008 -0800

    sparseirq: add kernel-doc notation for new member in irq_desc, -v2
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 36a015746788..7fa7f30fccb6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -134,6 +134,9 @@ struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
  * @irq:		interrupt number for this descriptor
+ * @timer_rand_state:	pointer to timer rand state struct
+ * @kstat_irqs:		irq stats per cpu
+ * @irq_2_iommu:	iommu with this irq
  * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
  * @chip:		low level interrupt hardware access
  * @msi_desc:		MSI descriptor

commit 948a7b2b5e2bf126fb697aeb11ff379b2c85dd2e
Merge: 9466d6036f73 17483a1f34c9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Dec 17 13:16:08 2008 +0100

    Merge branch 'irq/sparseirq' into cpus4096
    
    Conflicts:
            arch/x86/kernel/io_apic.c
    
    Merge irq/sparseirq here, to resolve conflicts.

commit 48a1b10aff588833b73994704c47bbd0deb73e9c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Dec 11 00:15:01 2008 -0800

    x86, sparseirq: move irq_desc according to smp_affinity, v7
    
    Impact: improve NUMA handling by migrating irq_desc on smp_affinity changes
    
    if CONFIG_NUMA_MIGRATE_IRQ_DESC is set:
    
    -  make irq_desc to go with affinity aka irq_desc moving etc
    -  call move_irq_desc in irq_complete_move()
    -  legacy irq_desc is not moved, because they are allocated via static array
    
    for logical apic mode, need to add move_desc_in_progress_in_same_domain,
    otherwise it will not be moved ==> also could need two phases to get
    irq_desc moved.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b5749db3e5a1..36a015746788 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -227,6 +227,16 @@ extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
 
 #endif
 
+static inline struct irq_desc *
+irq_remap_to_desc(unsigned int irq, struct irq_desc *desc)
+{
+#ifdef CONFIG_NUMA_MIGRATE_IRQ_DESC
+	return irq_to_desc(irq);
+#else
+	return desc;
+#endif
+}
+
 /*
  * Migration helpers for obsolete names, they will go away:
  */

commit 968ea6d80e395cf11a51143cfa1b9a14ada676df
Merge: 7be7585393d3 8299608f140a
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:55:51 2008 +1030

    Merge ../linux-2.6-x86
    
    Conflicts:
    
            arch/x86/kernel/io_apic.c
            kernel/sched.c
            kernel/sched_stats.h

commit 0de26520c7cabf36e1de090ea8092f011a6106ce
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: make irq_set_affinity() take a const struct cpumask
    
    Impact: change existing irq_chip API
    
    Not much point with gentle transition here: the struct irq_chip's
    setaffinity method signature needs to change.
    
    Fortunately, not widely used code, but hits a few architectures.
    
    Note: In irq_select_affinity() I save a temporary in by mangling
    irq_desc[irq].affinity directly.  Ingo, does this break anything?
    
    (Folded in fix from KOSAKI Motohiro)
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Acked-by: Ingo Molnar <mingo@redhat.com>
    Cc: ralf@linux-mips.org
    Cc: grundler@parisc-linux.org
    Cc: jeremy@xensource.com
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3dddfa703ebd..ab70fd604d3a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -113,7 +113,8 @@ struct irq_chip {
 	void		(*eoi)(unsigned int irq);
 
 	void		(*end)(unsigned int irq);
-	void		(*set_affinity)(unsigned int irq, cpumask_t dest);
+	void		(*set_affinity)(unsigned int irq,
+					const struct cpumask *dest);
 	int		(*retrigger)(unsigned int irq);
 	int		(*set_type)(unsigned int irq, unsigned int flow_type);
 	int		(*set_wake)(unsigned int irq, unsigned int on);

commit 240d367b4e6c6e3c5075e034db14dba60a6f5fa7
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 8 14:06:17 2008 -0800

    sparseirq: fix Alpha build failure
    
    Impact: build fix on Alpha
    
    -tip testing found this build failure on the Alpha defconfig:
    
    /home/mingo/tip/fs/proc/stat.c: In function 'show_stat':
    /home/mingo/tip/fs/proc/stat.c:48: error: implicit declaration of function 'for_each_irq_desc'
    /home/mingo/tip/fs/proc/stat.c:48: error: expected ';' before '{' token
    
    can not use irq_desc() in stat.c on older architectures.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.orgg>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 63b00439d4d2..b5749db3e5a1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -198,7 +198,6 @@ extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
 extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
 
 #ifndef CONFIG_SPARSE_IRQ
-
 extern struct irq_desc irq_desc[NR_IRQS];
 
 static inline struct irq_desc *irq_to_desc(unsigned int irq)
@@ -210,14 +209,6 @@ static inline struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu)
 	return irq_to_desc(irq);
 }
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-# define for_each_irq_desc(irq, desc)		\
-	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc++)
-# define for_each_irq_desc_reverse(irq, desc)                          \
-	for (irq = nr_irqs - 1, desc = irq_desc + (nr_irqs - 1);        \
-	    irq >= 0; irq--, desc--)
-#endif
-
 #else
 
 extern struct irq_desc *irq_to_desc(unsigned int irq);

commit 0b8f1efad30bd58f89961b82dfe68b9edf8fd2ac
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 5 18:58:31 2008 -0800

    sparse irq_desc[] array: core kernel and x86 changes
    
    Impact: new feature
    
    Problem on distro kernels: irq_desc[NR_IRQS] takes megabytes of RAM with
    NR_CPUS set to large values. The goal is to be able to scale up to much
    larger NR_IRQS value without impacting the (important) common case.
    
    To solve this, we generalize irq_desc[NR_IRQS] to an (optional) array of
    irq_desc pointers.
    
    When CONFIG_SPARSE_IRQ=y is used, we use kzalloc_node to get irq_desc,
    this also makes the IRQ descriptors NUMA-local (to the site that calls
    request_irq()).
    
    This gets rid of the irq_cfg[] static array on x86 as well: irq_cfg now
    uses desc->chip_data for x86 to store irq_cfg.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3dddfa703ebd..63b00439d4d2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -129,6 +129,8 @@ struct irq_chip {
 	const char	*typename;
 };
 
+struct timer_rand_state;
+struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
  * @irq:		interrupt number for this descriptor
@@ -154,6 +156,13 @@ struct irq_chip {
  */
 struct irq_desc {
 	unsigned int		irq;
+#ifdef CONFIG_SPARSE_IRQ
+	struct timer_rand_state *timer_rand_state;
+	unsigned int            *kstat_irqs;
+# ifdef CONFIG_INTR_REMAP
+	struct irq_2_iommu      *irq_2_iommu;
+# endif
+#endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
 	struct msi_desc		*msi_desc;
@@ -181,14 +190,52 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
+extern void early_irq_init(void);
+extern void arch_early_irq_init(void);
+extern void arch_init_chip_data(struct irq_desc *desc, int cpu);
+extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
+					struct irq_desc *desc, int cpu);
+extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
+
+#ifndef CONFIG_SPARSE_IRQ
 
 extern struct irq_desc irq_desc[NR_IRQS];
 
 static inline struct irq_desc *irq_to_desc(unsigned int irq)
 {
-	return (irq < nr_irqs) ? irq_desc + irq : NULL;
+	return (irq < NR_IRQS) ? irq_desc + irq : NULL;
+}
+static inline struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu)
+{
+	return irq_to_desc(irq);
 }
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+# define for_each_irq_desc(irq, desc)		\
+	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc++)
+# define for_each_irq_desc_reverse(irq, desc)                          \
+	for (irq = nr_irqs - 1, desc = irq_desc + (nr_irqs - 1);        \
+	    irq >= 0; irq--, desc--)
+#endif
+
+#else
+
+extern struct irq_desc *irq_to_desc(unsigned int irq);
+extern struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu);
+extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
+
+# define for_each_irq_desc(irq, desc)		\
+	for (irq = 0, desc = irq_to_desc(irq); irq < nr_irqs; irq++, desc = irq_to_desc(irq))
+# define for_each_irq_desc_reverse(irq, desc)                          \
+	for (irq = nr_irqs - 1, desc = irq_to_desc(irq); irq >= 0; irq--, desc = irq_to_desc(irq))
+
+#define kstat_irqs_this_cpu(DESC) \
+	((DESC)->kstat_irqs[smp_processor_id()])
+#define kstat_incr_irqs_this_cpu(irqno, DESC) \
+	((DESC)->kstat_irqs[smp_processor_id()]++)
+
+#endif
+
 /*
  * Migration helpers for obsolete names, they will go away:
  */
@@ -380,6 +427,11 @@ extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 #define get_irq_data(irq)	(irq_to_desc(irq)->handler_data)
 #define get_irq_msi(irq)	(irq_to_desc(irq)->msi_desc)
 
+#define get_irq_desc_chip(desc)		((desc)->chip)
+#define get_irq_desc_chip_data(desc)	((desc)->chip_data)
+#define get_irq_desc_data(desc)		((desc)->handler_data)
+#define get_irq_desc_msi(desc)		((desc)->msi_desc)
+
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */

commit e262a7ba31f0cd4dae225e6d2e9037e5ac6108e8
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Sun Nov 23 14:34:43 2008 +0000

    irq.h: remove padding from irq_desc on 64bits
    
    Impact: reduce struct irq_desc size
    
    struct irq_desc: reorder to remove padding on 64bits
    
    shrinks irq_desc to 128 bytes which saves data space & cache lines
    
    On a generic x86_64/SMP build this reduces the reported data size by
    64k.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d058c57be02d..838a977885e1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -142,8 +142,8 @@ struct irq_chip {
  * @depth:		disable-depth, for nested irq_disable() calls
  * @wake_depth:		enable depth, for multiple set_irq_wake() callers
  * @irq_count:		stats field to detect stalled irqs
- * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @last_unhandled:	aging timer for unhandled count
+ * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing
@@ -165,8 +165,8 @@ struct irq_desc {
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		wake_depth;	/* nested wake enables */
 	unsigned int		irq_count;	/* For detecting broken IRQs */
-	unsigned int		irqs_unhandled;
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
+	unsigned int		irqs_unhandled;
 	spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_t		affinity;

commit 2ed1cdcf9a83205d1343f29b630abff232eaa72c
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Nov 21 16:59:57 2008 -0800

    irq.h: fix missing/extra kernel-doc
    
    Impact: fix kernel-doc build
    
    Fix missing & excess irq.h kernel-doc:
    
    Warning(include/linux/irq.h:182): No description found for parameter 'irq'
    Warning(include/linux/irq.h:182): Excess struct/union/enum/typedef member 'affinity_entry' description in 'irq_desc'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 36b186eb318b..3dddfa703ebd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -131,7 +131,7 @@ struct irq_chip {
 
 /**
  * struct irq_desc - interrupt descriptor
- *
+ * @irq:		interrupt number for this descriptor
  * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
  * @chip:		low level interrupt hardware access
  * @msi_desc:		MSI descriptor
@@ -150,7 +150,6 @@ struct irq_chip {
  * @cpu:		cpu index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
  * @dir:		/proc/irq/ procfs entry
- * @affinity_entry:	/proc/irq/smp_affinity procfs entry on SMP
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {

commit f6d87f4bd259cf33e092cd1a8fde05f291c47af1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Nov 7 13:18:30 2008 +0100

    genirq: keep affinities set from userspace across free/request_irq()
    
    Impact: preserve user-modified affinities on interrupts
    
    Kumar Galak noticed that commit
    18404756765c713a0be4eb1082920c04822ce588 (genirq: Expose default irq
    affinity mask (take 3))
    
    overrides an already set affinity setting across a free /
    request_irq(). Happens e.g. with ifdown/ifup of a network device.
    
    Change the logic to mark the affinities as set and keep them
    intact. This also fixes the unlocked access to irq_desc in
    irq_select_affinity() when called from irq_affinity_proc_write()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d058c57be02d..36b186eb318b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -63,7 +63,8 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 #define IRQ_SPURIOUS_DISABLED	0x00800000	/* IRQ was disabled by the spurious trap */
-#define IRQ_MOVE_PCNTXT	0x01000000	/* IRQ migration from process context */
+#define IRQ_MOVE_PCNTXT		0x01000000	/* IRQ migration from process context */
+#define IRQ_AFFINITY_SET	0x02000000	/* IRQ affinity was set from userspace*/
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
@@ -210,7 +211,6 @@ extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 
-void set_pending_irq(unsigned int irq, cpumask_t mask);
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
 
@@ -228,10 +228,6 @@ static inline void move_masked_irq(int irq)
 {
 }
 
-static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
-{
-}
-
 #endif /* CONFIG_GENERIC_PENDING_IRQ */
 
 #else /* CONFIG_SMP */

commit dd3a1db900f2a215a7d7dd71b836e149a6cf5fed
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 16 18:20:58 2008 +0200

    genirq: improve include files
    
    Move the irq_desc related iterators out of irq.h, into irqnr.h, also
    available via interrupt.h.
    
    This way non-genirq (and even non-hardirq) architectures get the
    common definitions and iterators.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0618fb362cb4..d058c57be02d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -11,25 +11,6 @@
 
 #include <linux/smp.h>
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-# define nr_irqs		NR_IRQS
-
-# define for_each_irq_desc(irq, desc)		\
-	for (irq = 0; irq < nr_irqs; irq++)
-#else
-extern int nr_irqs;
-
-# define for_each_irq_desc(irq, desc)		\
-	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc++)
-
-# define for_each_irq_desc_reverse(irq, desc)			\
-	for (irq = nr_irqs -1, desc = irq_desc + (nr_irqs -1 );	\
-	     irq > 0; irq--, desc--)
-#endif
-
-#define for_each_irq_nr(irq)			\
-	for (irq = 0; irq < nr_irqs; irq++)
-
 #ifndef CONFIG_S390
 
 #include <linux/linkage.h>
@@ -37,6 +18,7 @@ extern int nr_irqs;
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
+#include <linux/irqnr.h>
 #include <linux/errno.h>
 
 #include <asm/irq.h>

commit 2be3b52a5785a6a5c5349fbd315f57595f7074be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 16 14:50:27 2008 +0200

    proc: fixup irq iterator
    
    There is no need for irq_desc here. Even for sparse_irq we can
    handle this clever in for_each_irq_nr().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 31632aa65d16..0618fb362cb4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -27,6 +27,9 @@ extern int nr_irqs;
 	     irq > 0; irq--, desc--)
 #endif
 
+#define for_each_irq_nr(irq)			\
+	for (irq = 0; irq < nr_irqs; irq++)
+
 #ifndef CONFIG_S390
 
 #include <linux/linkage.h>

commit 811410fdb6b9d82a518542289efe9b2a51e3cbfb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Oct 16 14:16:11 2008 +0200

    genirq: add reverse iterator for irq_desc
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 38bf89f2ade0..31632aa65d16 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -21,6 +21,10 @@ extern int nr_irqs;
 
 # define for_each_irq_desc(irq, desc)		\
 	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc++)
+
+# define for_each_irq_desc_reverse(irq, desc)			\
+	for (irq = nr_irqs -1, desc = irq_desc + (nr_irqs -1 );	\
+	     irq > 0; irq--, desc--)
 #endif
 
 #ifndef CONFIG_S390

commit d6c88a507ef0b6afdb013cba4e7804ba7324d99a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 15:27:23 2008 +0200

    genirq: revert dynarray
    
    Revert the dynarray changes. They need more thought and polishing.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3f33c7790300..38bf89f2ade0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -139,8 +139,6 @@ struct irq_chip {
 	const char	*typename;
 };
 
-struct timer_rand_state;
-struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
  *
@@ -167,9 +165,6 @@ struct irq_2_iommu;
  */
 struct irq_desc {
 	unsigned int		irq;
-#ifdef CONFIG_HAVE_DYN_ARRAY
-	unsigned int            *kstat_irqs;
-#endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
 	struct msi_desc		*msi_desc;
@@ -198,23 +193,13 @@ struct irq_desc {
 } ____cacheline_internodealigned_in_smp;
 
 
-#ifndef CONFIG_HAVE_DYN_ARRAY
-/* could be removed if we get rid of all irq_desc reference */
 extern struct irq_desc irq_desc[NR_IRQS];
-#else
-extern struct irq_desc *irq_desc;
-#endif
 
 static inline struct irq_desc *irq_to_desc(unsigned int irq)
 {
 	return (irq < nr_irqs) ? irq_desc + irq : NULL;
 }
 
-#ifdef CONFIG_HAVE_DYN_ARRAY
-#define kstat_irqs_this_cpu(DESC) \
-	((DESC)->kstat_irqs[smp_processor_id()])
-#endif
-
 /*
  * Migration helpers for obsolete names, they will go away:
  */

commit ee32c9732244bde4b9b59eeac2814c23e2b71f8d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 14:34:09 2008 +0200

    genirq: remove irq_to_desc_alloc
    
    Remove the leftover of sparseirqs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 68e0f3f9df30..3f33c7790300 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -210,11 +210,6 @@ static inline struct irq_desc *irq_to_desc(unsigned int irq)
 	return (irq < nr_irqs) ? irq_desc + irq : NULL;
 }
 
-static inline struct irq_desc *irq_to_desc_alloc(unsigned int irq)
-{
-	return irq_to_desc(irq);
-}
-
 #ifdef CONFIG_HAVE_DYN_ARRAY
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])

commit 2cc21ef843d4fb7da122239b644a1f6f0aca60a6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 14:16:55 2008 +0200

    genirq: remove sparse irq code
    
    This code is not ready, but we need to rip it out instead of rebasing
    as we would lose the APIC/IO_APIC unification otherwise.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7d1adacaadb4..68e0f3f9df30 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -167,15 +167,8 @@ struct irq_2_iommu;
  */
 struct irq_desc {
 	unsigned int		irq;
-#ifdef CONFIG_HAVE_SPARSE_IRQ
-	struct irq_desc		*next;
-	struct timer_rand_state *timer_rand_state;
-#endif
 #ifdef CONFIG_HAVE_DYN_ARRAY
 	unsigned int            *kstat_irqs;
-#endif
-#if defined(CONFIG_INTR_REMAP) && defined(CONFIG_HAVE_SPARSE_IRQ)
-       struct irq_2_iommu      *irq_2_iommu;
 #endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
@@ -205,8 +198,6 @@ struct irq_desc {
 } ____cacheline_internodealigned_in_smp;
 
 
-#ifndef CONFIG_HAVE_SPARSE_IRQ
-
 #ifndef CONFIG_HAVE_DYN_ARRAY
 /* could be removed if we get rid of all irq_desc reference */
 extern struct irq_desc irq_desc[NR_IRQS];
@@ -224,17 +215,6 @@ static inline struct irq_desc *irq_to_desc_alloc(unsigned int irq)
 	return irq_to_desc(irq);
 }
 
-#else
-
-extern struct irq_desc *irq_to_desc(unsigned int irq);
-extern struct irq_desc *irq_to_desc_alloc(unsigned int irq);
-
-extern struct irq_desc *sparse_irqs;
-#define for_each_irq_desc(irqX, desc)		\
-	for (desc = sparse_irqs, irqX = desc->irq; desc; desc = desc->next, irqX = desc ? desc->irq : -1U)
-
-#endif
-
 #ifdef CONFIG_HAVE_DYN_ARRAY
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])

commit c6b7674f323622d86316bf7951ad9cae1ce24642
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 14:31:29 2008 +0200

    genirq: use inline function for irq_to_desc
    
    For the non sparse irq case an inline function is perfectly fine.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index dbe8734ae86c..7d1adacaadb4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -204,8 +204,6 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-extern struct irq_desc *irq_to_desc(unsigned int irq);
-extern struct irq_desc *irq_to_desc_alloc(unsigned int irq);
 
 #ifndef CONFIG_HAVE_SPARSE_IRQ
 
@@ -216,8 +214,21 @@ extern struct irq_desc irq_desc[NR_IRQS];
 extern struct irq_desc *irq_desc;
 #endif
 
+static inline struct irq_desc *irq_to_desc(unsigned int irq)
+{
+	return (irq < nr_irqs) ? irq_desc + irq : NULL;
+}
+
+static inline struct irq_desc *irq_to_desc_alloc(unsigned int irq)
+{
+	return irq_to_desc(irq);
+}
+
 #else
 
+extern struct irq_desc *irq_to_desc(unsigned int irq);
+extern struct irq_desc *irq_to_desc_alloc(unsigned int irq);
+
 extern struct irq_desc *sparse_irqs;
 #define for_each_irq_desc(irqX, desc)		\
 	for (desc = sparse_irqs, irqX = desc->irq; desc; desc = desc->next, irqX = desc ? desc->irq : -1U)

commit 70dd4d992ab324a59cdcd6bedc3f4e729863d514
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 15 15:39:27 2008 +0200

    genirq: consolidate nr_irqs and for_each_irq_desc()
    
    Move all of those to linux/irq.h where they belong.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 93fe9a943e71..dbe8734ae86c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -11,6 +11,18 @@
 
 #include <linux/smp.h>
 
+#ifndef CONFIG_GENERIC_HARDIRQS
+# define nr_irqs		NR_IRQS
+
+# define for_each_irq_desc(irq, desc)		\
+	for (irq = 0; irq < nr_irqs; irq++)
+#else
+extern int nr_irqs;
+
+# define for_each_irq_desc(irq, desc)		\
+	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc++)
+#endif
+
 #ifndef CONFIG_S390
 
 #include <linux/linkage.h>
@@ -204,11 +216,6 @@ extern struct irq_desc irq_desc[NR_IRQS];
 extern struct irq_desc *irq_desc;
 #endif
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-#define for_each_irq_desc(irq, desc)		\
-	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc = &irq_desc[irq])
-#endif
-
 #else
 
 extern struct irq_desc *sparse_irqs;

commit 8c464a4b23ca283b414022ebc77787f3c7040fa7
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Aug 25 12:41:19 2008 -0700

    sparseirq: move kstat_irqs from kstat to irq_desc - fix
    
    fix non-sparseirq architectures.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 2445d2b3d5dc..93fe9a943e71 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -161,8 +161,6 @@ struct irq_desc {
 #endif
 #ifdef CONFIG_HAVE_DYN_ARRAY
 	unsigned int            *kstat_irqs;
-#else
-	unsigned int            kstat_irqs[NR_CPUS];
 #endif
 #if defined(CONFIG_INTR_REMAP) && defined(CONFIG_HAVE_SPARSE_IRQ)
        struct irq_2_iommu      *irq_2_iommu;
@@ -219,8 +217,10 @@ extern struct irq_desc *sparse_irqs;
 
 #endif
 
+#ifdef CONFIG_HAVE_DYN_ARRAY
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])
+#endif
 
 /*
  * Migration helpers for obsolete names, they will go away:

commit 8b8e8c1bf7275eca859fe551dfa484134eaf013b
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:23 2008 -0700

    x86: remove irqbalance in kernel for 32 bit
    
    This has been deprecated for years, the user space irqbalanced utility
    works better with numa, has configurable policies, etc...
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmai.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 704136138dc7..2445d2b3d5dc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -185,7 +185,7 @@ struct irq_desc {
 	cpumask_t		affinity;
 	unsigned int		cpu;
 #endif
-#if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
+#ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_t		pending_mask;
 #endif
 #ifdef CONFIG_PROC_FS
@@ -241,13 +241,13 @@ extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_SMP
 
-#if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
+#ifdef CONFIG_GENERIC_PENDING_IRQ
 
 void set_pending_irq(unsigned int irq, cpumask_t mask);
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
 
-#else /* CONFIG_GENERIC_PENDING_IRQ || CONFIG_IRQBALANCE */
+#else /* CONFIG_GENERIC_PENDING_IRQ */
 
 static inline void move_irq(int irq)
 {
@@ -274,14 +274,6 @@ static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 
 #endif /* CONFIG_SMP */
 
-#ifdef CONFIG_IRQBALANCE
-extern void set_balance_irq_affinity(unsigned int irq, cpumask_t mask);
-#else
-static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
-{
-}
-#endif
-
 extern int no_irq_affinity;
 
 static inline int irq_balancing_disabled(unsigned int irq)

commit 6d50bc26836e16a9589e0b128d527c29e30d722a
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:22 2008 -0700

    x86: use 28 bits irq NR for pci msi/msix and ht
    
    also print out irq no in /proc/interrups and /proc/stat in hex, so could
    tell bus/dev/func.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 788d5a35a580..704136138dc7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -399,6 +399,7 @@ extern void set_irq_noprobe(unsigned int irq);
 extern void set_irq_probe(unsigned int irq);
 
 /* Handle dynamic irq creation and destruction */
+extern unsigned int create_irq_nr(unsigned int irq_want);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
 

commit e420dfb40c453a9760b86c7f338052bdb4dfa755
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:21 2008 -0700

    x86: put irq_2_iommu pointer into irq_desc
    
    when CONFIG_HAVE_SPARSE_IRQ
    preallocate some irq_2_iommu entries, and use get_one_free_irq_2_iomm to
    get new one and link to irq_desc if needed.
    
    else will use dyn_array or static array.
    
    v2: <= nr_irqs fix
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index d5749852ee69..788d5a35a580 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -128,6 +128,7 @@ struct irq_chip {
 };
 
 struct timer_rand_state;
+struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
  *
@@ -162,6 +163,9 @@ struct irq_desc {
 	unsigned int            *kstat_irqs;
 #else
 	unsigned int            kstat_irqs[NR_CPUS];
+#endif
+#if defined(CONFIG_INTR_REMAP) && defined(CONFIG_HAVE_SPARSE_IRQ)
+       struct irq_2_iommu      *irq_2_iommu;
 #endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;

commit 67fb283e148e9bd761f73691d3173b6eab9ba8db
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:18 2008 -0700

    irq: separate sparse_irqs from sparse_irqs_free
    
    so later don't need compare with -1U
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5fe1b01c11fe..d5749852ee69 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -211,7 +211,7 @@ extern struct irq_desc *irq_desc;
 
 extern struct irq_desc *sparse_irqs;
 #define for_each_irq_desc(irqX, desc)		\
-	for (desc = sparse_irqs, irqX = desc->irq; desc && irqX != -1U; desc = desc->next, irqX = desc ? desc->irq : -1U)
+	for (desc = sparse_irqs, irqX = desc->irq; desc; desc = desc->next, irqX = desc ? desc->irq : -1U)
 
 #endif
 

commit cb5bc83225a86ca53bbb889ed8439e4fd6cf44ac
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:17 2008 -0700

    x86_64: rename irq_desc/irq_desc_alloc
    
    change names:
    
              irq_desc() ==> irq_desc_alloc
            __irq_desc() ==> irq_desc
    
    Also split a few of the uses in lowlevel x86 code.
    
    v2: need to check if desc is null in smp_irq_move_cleanup
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7b59e193a119..5fe1b01c11fe 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -191,7 +191,7 @@ struct irq_desc {
 } ____cacheline_internodealigned_in_smp;
 
 extern struct irq_desc *irq_to_desc(unsigned int irq);
-extern struct irq_desc *__irq_to_desc(unsigned int irq);
+extern struct irq_desc *irq_to_desc_alloc(unsigned int irq);
 
 #ifndef CONFIG_HAVE_SPARSE_IRQ
 

commit 46926b67fc663d357a1a8174328998a9e49da0b8
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:15 2008 -0700

    generic: add irq_desc in function in parameter
    
    So we could remove some duplicated calling to irq_desc
    
    v2: make sure irq_desc in  init/main.c is not used without generic_hardirqs
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9de16ca8b8e5..7b59e193a119 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -315,10 +315,8 @@ extern unsigned int __do_IRQ(unsigned int irq);
  * irqchip-style controller then we call the ->handle_irq() handler,
  * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
  */
-static inline void generic_handle_irq(unsigned int irq)
+static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
 #else
@@ -329,6 +327,11 @@ static inline void generic_handle_irq(unsigned int irq)
 #endif
 }
 
+static inline void generic_handle_irq(unsigned int irq)
+{
+	generic_handle_irq_desc(irq, irq_to_desc(irq));
+}
+
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   int action_ret);

commit 2c6927a38f65b53b62f86158fba29a068c4e8b6a
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:11 2008 -0700

    irq: replace loop with nr_irqs with for_each_irq_desc
    
    There are a handful of loops that go from 0 to nr_irqs and use
    get_irq_desc() on them. These would allocate all the irq_desc
    entries, regardless of the need for them.
    
    Use the smarter for_each_irq_desc() iterator that will only iterate
    over the present ones.
    
    v2: make sure arch without GENERIC_HARDIRQS work too
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c9ffef7c3b44..9de16ca8b8e5 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -202,9 +202,16 @@ extern struct irq_desc irq_desc[NR_IRQS];
 extern struct irq_desc *irq_desc;
 #endif
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+#define for_each_irq_desc(irq, desc)		\
+	for (irq = 0, desc = irq_desc; irq < nr_irqs; irq++, desc = &irq_desc[irq])
+#endif
+
 #else
 
 extern struct irq_desc *sparse_irqs;
+#define for_each_irq_desc(irqX, desc)		\
+	for (desc = sparse_irqs, irqX = desc->irq; desc && irqX != -1U; desc = desc->next, irqX = desc ? desc->irq : -1U)
 
 #endif
 

commit 9059d8fa4a3a9153da53da890039f7f956cc9d19
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:10 2008 -0700

    irq: add irq_desc_without_new
    
    add an irq_desc accessor that will not allocate any sparse entry
    but returns failure if there's no entry present.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index cbf471aee1ce..c9ffef7c3b44 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -191,10 +191,23 @@ struct irq_desc {
 } ____cacheline_internodealigned_in_smp;
 
 extern struct irq_desc *irq_to_desc(unsigned int irq);
+extern struct irq_desc *__irq_to_desc(unsigned int irq);
+
+#ifndef CONFIG_HAVE_SPARSE_IRQ
+
 #ifndef CONFIG_HAVE_DYN_ARRAY
 /* could be removed if we get rid of all irq_desc reference */
 extern struct irq_desc irq_desc[NR_IRQS];
+#else
+extern struct irq_desc *irq_desc;
 #endif
+
+#else
+
+extern struct irq_desc *sparse_irqs;
+
+#endif
+
 #define kstat_irqs_this_cpu(DESC) \
 	((DESC)->kstat_irqs[smp_processor_id()])
 

commit 7f95ec9e4c12fd067febfd57532da1166d75d858
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:09 2008 -0700

    x86: move kstat_irqs from kstat to irq_desc
    
    based on Eric's patch ...
    
    together mold it with dyn_array for irq_desc, will allcate kstat_irqs for
    nr_irq_desc alltogether if needed. -- at that point nr_cpus is known already.
    
    v2: make sure system without generic_hardirqs works they don't have irq_desc
    v3: fix merging
    v4: [mingo@elte.hu] fix typo
    
    [ mingo@elte.hu ] irq: build fix
    
    fix:
    
     arch/x86/xen/spinlock.c: In function 'xen_spin_lock_slow':
     arch/x86/xen/spinlock.c:90: error: 'struct kernel_stat' has no member named 'irqs'
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 60c856aaac0f..cbf471aee1ce 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -157,6 +157,11 @@ struct irq_desc {
 #ifdef CONFIG_HAVE_SPARSE_IRQ
 	struct irq_desc		*next;
 	struct timer_rand_state *timer_rand_state;
+#endif
+#ifdef CONFIG_HAVE_DYN_ARRAY
+	unsigned int            *kstat_irqs;
+#else
+	unsigned int            kstat_irqs[NR_CPUS];
 #endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
@@ -190,6 +195,8 @@ extern struct irq_desc *irq_to_desc(unsigned int irq);
 /* could be removed if we get rid of all irq_desc reference */
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
+#define kstat_irqs_this_cpu(DESC) \
+	((DESC)->kstat_irqs[smp_processor_id()])
 
 /*
  * Migration helpers for obsolete names, they will go away:

commit 3060d6fe28570640c2d7d66d38b9eaa848c3b9e3
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:08 2008 -0700

    x86: put timer_rand_state pointer into irq_desc
    
    irq_timer_state[] is a NR_IRQS sized array that is a side-by array to
    the real irq_desc[] array.
    
    Integrate that field into the (now dynamic) irq_desc dynamic array and
    save some RAM.
    
    v2: keep the old way to support arch not support irq_desc
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 80b8200f2adb..60c856aaac0f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -127,6 +127,7 @@ struct irq_chip {
 	const char	*typename;
 };
 
+struct timer_rand_state;
 /**
  * struct irq_desc - interrupt descriptor
  *
@@ -155,6 +156,7 @@ struct irq_desc {
 	unsigned int		irq;
 #ifdef CONFIG_HAVE_SPARSE_IRQ
 	struct irq_desc		*next;
+	struct timer_rand_state *timer_rand_state;
 #endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;

commit 08678b0841267c1d00d771fe01548d86043d065e
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:05 2008 -0700

    generic: sparse irqs: use irq_desc() together with dyn_array, instead of irq_desc[]
    
    add CONFIG_HAVE_SPARSE_IRQ to for use condensed array.
    Get rid of irq_desc[] array assumptions.
    
    Preallocate 32 irq_desc, and irq_desc() will try to get more.
    
    ( No change in functionality is expected anywhere, except the odd build
      failure where we missed a code site or where a crossing commit itroduces
      new irq_desc[] usage. )
    
    v2: according to Eric, change get_irq_desc() to irq_desc()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5f4b013624dc..80b8200f2adb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -152,6 +152,10 @@ struct irq_chip {
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {
+	unsigned int		irq;
+#ifdef CONFIG_HAVE_SPARSE_IRQ
+	struct irq_desc		*next;
+#endif
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
 	struct msi_desc		*msi_desc;
@@ -179,9 +183,9 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-#ifdef CONFIG_HAVE_DYN_ARRAY
-extern struct irq_desc *irq_desc;
-#else
+extern struct irq_desc *irq_to_desc(unsigned int irq);
+#ifndef CONFIG_HAVE_DYN_ARRAY
+/* could be removed if we get rid of all irq_desc reference */
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 
@@ -249,7 +253,10 @@ extern int no_irq_affinity;
 
 static inline int irq_balancing_disabled(unsigned int irq)
 {
-	return irq_desc[irq].status & IRQ_NO_BALANCING_MASK;
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	return desc->status & IRQ_NO_BALANCING_MASK;
 }
 
 /* Handle irq action chains: */
@@ -281,7 +288,7 @@ extern unsigned int __do_IRQ(unsigned int irq);
  */
 static inline void generic_handle_irq(unsigned int irq)
 {
-	struct irq_desc *desc = irq_desc + irq;
+	struct irq_desc *desc = irq_to_desc(irq);
 
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
@@ -325,7 +332,10 @@ __set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 static inline void __set_irq_handler_unlocked(int irq,
 					      irq_flow_handler_t handler)
 {
-	irq_desc[irq].handle_irq = handler;
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	desc->handle_irq = handler;
 }
 
 /*
@@ -359,7 +369,7 @@ extern void destroy_irq(unsigned int irq);
 /* Test to see if a driver has successfully requested an irq */
 static inline int irq_has_action(unsigned int irq)
 {
-	struct irq_desc *desc = irq_desc + irq;
+	struct irq_desc *desc = irq_to_desc(irq);
 	return desc->action != NULL;
 }
 
@@ -374,10 +384,10 @@ extern int set_irq_chip_data(unsigned int irq, void *data);
 extern int set_irq_type(unsigned int irq, unsigned int type);
 extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
-#define get_irq_chip(irq)	(irq_desc[irq].chip)
-#define get_irq_chip_data(irq)	(irq_desc[irq].chip_data)
-#define get_irq_data(irq)	(irq_desc[irq].handler_data)
-#define get_irq_msi(irq)	(irq_desc[irq].msi_desc)
+#define get_irq_chip(irq)	(irq_to_desc(irq)->chip)
+#define get_irq_chip_data(irq)	(irq_to_desc(irq)->chip_data)
+#define get_irq_data(irq)	(irq_to_desc(irq)->handler_data)
+#define get_irq_msi(irq)	(irq_to_desc(irq)->msi_desc)
 
 #endif /* CONFIG_GENERIC_HARDIRQS */
 

commit d60458b224d6b997a582a05cb8c4b9bed9e17a1d
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:00 2008 -0700

    irq: make irq_desc to use dyn_array
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1d73d1abb834..5f4b013624dc 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -179,7 +179,11 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
+#ifdef CONFIG_HAVE_DYN_ARRAY
+extern struct irq_desc *irq_desc;
+#else
 extern struct irq_desc irq_desc[NR_IRQS];
+#endif
 
 /*
  * Migration helpers for obsolete names, they will go away:

commit 5fef06e8c8c52aa7170dbbb068aa996d83738d38
Merge: 0c5d1eb77a8b 278429cff880
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Oct 16 16:51:32 2008 +0200

    Merge branch 'linus' into genirq

commit 8d00a6c8f6b08e7167bc03bf955cdc7e47c5132e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jul 22 08:39:57 2008 +0200

    genirq: remove last NO_IDLE_HZ leftovers
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8ccb462ea42c..f3047df2d23c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -197,10 +197,6 @@ extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
-#ifndef handle_dynamic_tick
-# define handle_dynamic_tick(a)		do { } while (0)
-#endif
-
 #ifdef CONFIG_SMP
 
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)

commit a208f37a465e222218974ab20a31b42b7b4893b2
Merge: 511d9d341836 5b664cb235e9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 18 22:50:34 2008 +0200

    Merge branch 'linus' into x86/x2apic

commit 72b1e22dfcad1daca6906148fd956ffe404bb0bc
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Thu Jul 10 11:16:45 2008 -0700

    x64, x2apic/intr-remap: generic irq migration support from process context
    
    Generic infrastructure for migrating the irq from the process context in the
    presence of CONFIG_GENERIC_PENDING_IRQ.
    
    This will be used later for migrating irq in the presence of
    interrupt-remapping.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: akpm@linux-foundation.org
    Cc: arjan@linux.intel.com
    Cc: andi@firstfloor.org
    Cc: ebiederm@xmission.com
    Cc: jbarnes@virtuousgeek.org
    Cc: steiner@sgi.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 552e0ec269c9..c211984b55e5 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -62,6 +62,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 #define IRQ_SPURIOUS_DISABLED	0x00800000	/* IRQ was disabled by the spurious trap */
+#define IRQ_MOVE_PCNTXT	0x01000000	/* IRQ migration from process context */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit 18404756765c713a0be4eb1082920c04822ce588
Author: Max Krasnyansky <maxk@qualcomm.com>
Date:   Thu May 29 11:02:52 2008 -0700

    genirq: Expose default irq affinity mask (take 3)
    
    Current IRQ affinity interface does not provide a way to set affinity
    for the IRQs that will be allocated/activated in the future.
    This patch creates /proc/irq/default_smp_affinity that lets users set
    default affinity mask for the newly allocated IRQs. Changing the default
    does not affect affinity masks for the currently active IRQs, they
    have to be changed explicitly.
    
    Updated based on Paul J's comments and added some more documentation.
    
    Signed-off-by: Max Krasnyansky <maxk@qualcomm.com>
    Cc: pj@sgi.com
    Cc: a.p.zijlstra@chello.nl
    Cc: tglx@linutronix.de
    Cc: rdunlap@xenotime.net
    Cc: mingo@elte.hu
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 552e0ec269c9..8ccb462ea42c 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -244,15 +244,6 @@ static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
 }
 #endif
 
-#ifdef CONFIG_AUTO_IRQ_AFFINITY
-extern int select_smp_affinity(unsigned int irq);
-#else
-static inline int select_smp_affinity(unsigned int irq)
-{
-	return 1;
-}
-#endif
-
 extern int no_irq_affinity;
 
 static inline int irq_balancing_disabled(unsigned int irq)

commit 1adb0850a1254333d81e64121c80af100c6d6e06
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Apr 28 17:01:56 2008 +0200

    genirq: reenable a nobody cared disabled irq when a new driver arrives
    
    Uwe Kleine-Koenig has some strange hardware where one of the shared
    interrupts can be asserted during boot before the appropriate driver
    loads. Requesting the shared irq line from another driver result in a
    spurious interrupt storm which finally disables the interrupt line.
    
    I have seen similar behaviour on resume before (the hardware does not
    work anymore so I can not verify).
    
    Change the spurious disable logic to increment the disable depth and
    mark the interrupt with an extra flag which allows us to reenable the
    interrupt when a new driver arrives which requests the same irq
    line. In the worst case this will disable the irq again via the
    spurious trap, but there is a decent chance that the new driver is the
    one which can handle the already asserted interrupt and makes the box
    usable again.
    
    Eric Biederman said further: This case also happens on a regular basis
    in kdump kernels where we deliberately don't shutdown the hardware
    before starting the new kernel.  This patch should reduce the need for
    using irqpoll in that situation by a small amount.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-and-Acked-by: Uwe Kleine-Knig <Uwe.Kleine-Koenig@digi.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1883a85625dd..552e0ec269c9 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -61,6 +61,7 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
 #define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
 #define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
+#define IRQ_SPURIOUS_DISABLED	0x00800000	/* IRQ was disabled by the spurious trap */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit d7b906897e9caae452947e33674df0a2d6f7e10f
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Thu Apr 17 07:46:24 2008 +0200

    [S390] genirq/clockevents: move irq affinity prototypes/inlines to interrupt.h
    
    > Generic code is not supposed to include irq.h. Replace this include
    > by linux/hardirq.h instead and add/replace an include of linux/irq.h
    > in asm header files where necessary.
    > This change should only matter for architectures that make use of
    > GENERIC_CLOCKEVENTS.
    > Architectures in question are mips, x86, arm, sh, powerpc, uml and sparc64.
    >
    > I did some cross compile tests for mips, x86_64, arm, powerpc and sparc64.
    > This patch fixes also build breakages caused by the include replacement in
    > tick-common.h.
    
    I generally dislike adding optional linux/* includes in asm/* includes -
    I'm nervous about this causing include loops.
    
    However, there's a separate point to be discussed here.
    
    That is, what interfaces are expected of every architecture in the kernel.
    If generic code wants to be able to set the affinity of interrupts, then
    that needs to become part of the interfaces listed in linux/interrupt.h
    rather than linux/irq.h.
    
    So what I suggest is this approach instead (against Linus' tree of a
    couple of days ago) - we move irq_set_affinity() and irq_can_set_affinity()
    to linux/interrupt.h, change the linux/irq.h includes to linux/interrupt.h
    and include asm/irq_regs.h where needed (asm/irq_regs.h is supposed to be
    rarely used include since not much touches the stacked parent context
    registers.)
    
    Build tested on ARM PXA family kernels and ARM's Realview platform
    kernels which both use genirq.
    
    [ tglx@linutronix.de: add GENERIC_HARDIRQ dependencies ]
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 176e5e790a44..1883a85625dd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -228,21 +228,11 @@ static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 
 #endif /* CONFIG_GENERIC_PENDING_IRQ */
 
-extern int irq_set_affinity(unsigned int irq, cpumask_t cpumask);
-extern int irq_can_set_affinity(unsigned int irq);
-
 #else /* CONFIG_SMP */
 
 #define move_native_irq(x)
 #define move_masked_irq(x)
 
-static inline int irq_set_affinity(unsigned int irq, cpumask_t cpumask)
-{
-	return -EINVAL;
-}
-
-static inline int irq_can_set_affinity(unsigned int irq) { return 0; }
-
 #endif /* CONFIG_SMP */
 
 #ifdef CONFIG_IRQBALANCE

commit 21534301ea1801783bd88fba2a2e617ee4d2bd28
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Feb 13 15:03:17 2008 -0800

    Final removal of FASTCALL()/fastcall
    
    All users are gone, remove definitions and comments referring
    to them.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index bfd9efb5cb49..176e5e790a44 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -285,7 +285,6 @@ extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 
 /*
  * Monolithic do_IRQ implementation.
- * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
  */
 #ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 extern unsigned int __do_IRQ(unsigned int irq);

commit 46f4f8f665080900e865392f4b3593be463bf0d8
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Feb 8 04:22:01 2008 -0800

    IRQ_NOPROBE helper functions
    
    Probing non-ISA interrupts using the handle_percpu_irq as their handle_irq
    method may crash the system because handle_percpu_irq does not check
    IRQ_WAITING.  This for example hits the MIPS Qemu configuration.
    
    This patch provides two helper functions set_irq_noprobe and set_irq_probe to
    set rsp.  clear the IRQ_NOPROBE flag.  The only current caller is MIPS code
    but this really belongs into generic code.
    
    As an aside, interrupt probing these days has become a mostly obsolete if not
    dangerous art.  I think Linux interrupts should be changed to default to
    non-probing but that's subject of this patch.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-and-tested-by: Rob Landley <rob@landley.net>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a19b381d4112..bfd9efb5cb49 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -367,6 +367,9 @@ set_irq_chained_handler(unsigned int irq,
 	__set_irq_handler(irq, handle, 1, NULL);
 }
 
+extern void set_irq_noprobe(unsigned int irq);
+extern void set_irq_probe(unsigned int irq);
+
 /* Handle dynamic irq creation and destruction */
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);

commit ec7015840ad7a8cdc87f52367ffe9c0b0401d919
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Fri Feb 8 04:19:55 2008 -0800

    Remove fastcall from linux/include
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4669be080617..a19b381d4112 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -25,7 +25,7 @@
 #include <asm/irq_regs.h>
 
 struct irq_desc;
-typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
+typedef	void (*irq_flow_handler_t)(unsigned int irq,
 					    struct irq_desc *desc);
 
 
@@ -276,19 +276,19 @@ extern int handle_IRQ_event(unsigned int irq, struct irqaction *action);
  * Built-in IRQ handlers for various IRQ types,
  * callable via desc->chip->handle_irq()
  */
-extern void fastcall handle_level_irq(unsigned int irq, struct irq_desc *desc);
-extern void fastcall handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
-extern void fastcall handle_edge_irq(unsigned int irq, struct irq_desc *desc);
-extern void fastcall handle_simple_irq(unsigned int irq, struct irq_desc *desc);
-extern void fastcall handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
-extern void fastcall handle_bad_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_level_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_edge_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_simple_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
+extern void handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 
 /*
  * Monolithic do_IRQ implementation.
  * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
  */
 #ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-extern fastcall unsigned int __do_IRQ(unsigned int irq);
+extern unsigned int __do_IRQ(unsigned int irq);
 #endif
 
 /*

commit b019e57321f3e006c0ec7a54f13efc377bcb6451
Author: Kevin Hilman <khilman@mvista.com>
Date:   Tue Dec 18 18:05:58 2007 +0100

    genirq: add unlocked version of set_irq_handler()
    
    Add unlocked version for use by irq_chip.set_type handlers which may
    wish to change handler to level or edge handler when IRQ type is
    changed.
    
    The normal set_irq_handler() call cannot be used because it tries to
    take irq_desc.lock which is already held when the irq_chip.set_type
    hook is called.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index efc88538b2ba..4669be080617 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -339,6 +339,13 @@ extern void
 __set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 		  const char *name);
 
+/* caller has locked the irq_desc and both params are valid */
+static inline void __set_irq_handler_unlocked(int irq,
+					      irq_flow_handler_t handler)
+{
+	irq_desc[irq].handle_irq = handler;
+}
+
 /*
  * Set a highlevel flow handler for a given IRQ:
  */

commit 5ac4d823fd93be49c2a90fb877fc5fc6317936d5
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Jul 31 00:39:03 2007 -0700

    irq.h fix kernel-doc
    
    Add kernel-doc entry in <linux/irq.h> for:
    
    Warning(linux-2.6.22-git12//include/linux/irq.h:177): No description found for parameter 'last_unhandled'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 44657197fcb0..efc88538b2ba 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -140,6 +140,7 @@ struct irq_chip {
  * @wake_depth:		enable depth, for multiple set_irq_wake() callers
  * @irq_count:		stats field to detect stalled irqs
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
+ * @last_unhandled:	aging timer for unhandled count
  * @lock:		locking for SMP
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing

commit 4f27c00bf80f122513d3a5be16ed851573164534
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sun Jul 15 23:40:55 2007 -0700

    Improve behaviour of spurious IRQ detect
    
    Currently we handle spurious IRQ activity based upon seeing a lot of
    invalid interrupts, and we clear things back on the base of lots of valid
    interrupts.
    
    Unfortunately in some cases you get legitimate invalid interrupts caused by
    timing asynchronicity between the PCI bus and the APIC bus when disabling
    interrupts and pulling other tricks.  In this case although the spurious
    IRQs are not a problem our unhandled counters didn't clear and they act as
    a slow running timebomb.  (This is effectively what the serial port/tty
    problem that was fixed by clearing counters when registering a handler
    showed up)
    
    It's easy enough to add a second parameter - time.  This means that if we
    see a regular stream of harmless spurious interrupts which are not harming
    processing we don't go off and do something stupid like disable the IRQ
    after a month of running.  OTOH lockups and performance killers show up a
    lot more than 10/second
    
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1695054e8c63..44657197fcb0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -161,6 +161,7 @@ struct irq_desc {
 	unsigned int		wake_depth;	/* nested wake enables */
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned int		irqs_unhandled;
+	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_t		affinity;

commit e729aa16b168fb202d1a20f936028cb7c2a0278d
Author: Ravikiran G Thirumalai <kiran@scalex86.org>
Date:   Tue May 8 00:29:13 2007 -0700

    Pad irq_desc to internode cacheline size
    
    We noticed a drop in n/w performance due to the irq_desc being cacheline
    aligned rather than internode aligned.  We see 50% of expected performance
    when two e1000 nics local to two different nodes have consecutive irq
    descriptors allocated, due to false sharing.
    
    Note that this patch does away with cacheline padding for the UP case, as
    it does not seem useful for UP configurations.
    
    Signed-off-by: Ravikiran Thirumalai <kiran@scalex86.org>
    Signed-off-by: Shai Fultheim <shai@scalex86.org>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a6899402b522..1695054e8c63 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -147,8 +147,6 @@ struct irq_chip {
  * @dir:		/proc/irq/ procfs entry
  * @affinity_entry:	/proc/irq/smp_affinity procfs entry on SMP
  * @name:		flow handler name for /proc/interrupts output
- *
- * Pad this out to 32 bytes for cache and indexing reasons.
  */
 struct irq_desc {
 	irq_flow_handler_t	handle_irq;
@@ -175,7 +173,7 @@ struct irq_desc {
 	struct proc_dir_entry	*dir;
 #endif
 	const char		*name;
-} ____cacheline_aligned;
+} ____cacheline_internodealigned_in_smp;
 
 extern struct irq_desc irq_desc[NR_IRQS];
 

commit 77904fd64eb9131c337dd068e4196d25c2f9de7e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Feb 28 20:13:26 2007 -0800

    [PATCH] FRV: Missing error defs
    
    linux/irq.h uses EINVAL but does not #include linux/errno.h.  This results in
    the compiler spitting out errors on some files.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b0a44b8e0281..a6899402b522 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
+#include <linux/errno.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>

commit 9f0a5ba5508143731dc63235de19659be20d26dc
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 23 04:13:55 2007 -0700

    [PATCH] irq: Remove set_native_irq_info
    
    This patch replaces all instances of "set_native_irq_info(irq, mask)"
    with "irq_desc[irq].affinity = mask".  The latter form is clearer
    uses fewer abstractions, and makes access to this field uniform
    accross different architectures.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index aa5b3e6178a0..b0a44b8e0281 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -199,17 +199,6 @@ extern int setup_irq(unsigned int irq, struct irqaction *new);
 # define handle_dynamic_tick(a)		do { } while (0)
 #endif
 
-#ifdef CONFIG_SMP
-static inline void set_native_irq_info(int irq, cpumask_t mask)
-{
-	irq_desc[irq].affinity = mask;
-}
-#else
-static inline void set_native_irq_info(int irq, cpumask_t mask)
-{
-}
-#endif
-
 #ifdef CONFIG_SMP
 
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)

commit 6168a702ab0be181e5e57a0b2d0e7376f7a47f0b
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Feb 17 21:22:39 2007 -0800

    [PATCH] Declare init_irq_proc before we use it.
    
    powerpc gets:
    
    init/main.c: In function `do_basic_setup':
    init/main.c:714: warning: implicit declaration of function `init_irq_proc'
    
    but we cannot include linux/irq.h in generic code.
    
    Fix it by moving the declaration into linux/interrupt.h instead.
    
    And make sure all code that defines init_irq_proc() is including
    linux/interrupt.h.
    
    And nuke an ifdef-in-C
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1939d42c21d2..aa5b3e6178a0 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -328,9 +328,6 @@ extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 
-/* Initialize /proc/irq/ */
-extern void init_irq_proc(void);
-
 /* Enable/disable irq debugging output: */
 extern int noirqdebug_setup(char *str);
 

commit 472900b8b02bf3782b06dcf0acdef26811c2b995
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Feb 16 01:28:25 2007 -0800

    [PATCH] IRQ kernel-doc fixes
    
    Fix kernel-doc warnings in IRQ management.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f486c4dee1bf..1939d42c21d2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -129,6 +129,7 @@ struct irq_chip {
  *
  * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
  * @chip:		low level interrupt hardware access
+ * @msi_desc:		MSI descriptor
  * @handler_data:	per-IRQ data for the irq_chip methods
  * @chip_data:		platform-specific per-chip private data for the chip
  *			methods, to allow shared chip implementations

commit d7e25f3394ba05a6d64cb2be42c2765fe72ea6b2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Feb 16 01:28:24 2007 -0800

    [PATCH] genirq: remove IRQ_DISABLED
    
    Now that disable_irq() defaults to delayed-disable semantics, the IRQ_DISABLED
    flag is not needed anymore.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 29f715e71bdd..f486c4dee1bf 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -57,10 +57,9 @@ typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
 #define IRQ_NOREQUEST		0x00040000	/* IRQ cannot be requested */
 #define IRQ_NOAUTOEN		0x00080000	/* IRQ will not be enabled on request irq */
-#define IRQ_DELAYED_DISABLE	0x00100000	/* IRQ disable (masking) happens delayed. */
-#define IRQ_WAKEUP		0x00200000	/* IRQ triggers system wakeup */
-#define IRQ_MOVE_PENDING	0x00400000	/* need to re-target IRQ destination */
-#define IRQ_NO_BALANCING	0x00800000	/* IRQ is excluded from balancing */
+#define IRQ_WAKEUP		0x00100000	/* IRQ triggers system wakeup */
+#define IRQ_MOVE_PENDING	0x00200000	/* need to re-target IRQ destination */
+#define IRQ_NO_BALANCING	0x00400000	/* IRQ is excluded from balancing */
 
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)

commit 771ee3b04eaac6184312825eb600b4c598f027a5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:25 2007 -0800

    [PATCH] Add a function to handle interrupt affinity setting
    
    Provide funtions to:
     - check, whether an interrupt can set the affinity
     - pin the interrupt to a given cpu
    
    Necessary for the ability to setup clocksources more flexible (e.g.  use the
    different HPET channels per CPU)
    
    [akpm@osdl.org: alpha build fix]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 8930fb0ac9c7..29f715e71bdd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -238,11 +238,21 @@ static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 
 #endif /* CONFIG_GENERIC_PENDING_IRQ */
 
+extern int irq_set_affinity(unsigned int irq, cpumask_t cpumask);
+extern int irq_can_set_affinity(unsigned int irq);
+
 #else /* CONFIG_SMP */
 
 #define move_native_irq(x)
 #define move_masked_irq(x)
 
+static inline int irq_set_affinity(unsigned int irq, cpumask_t cpumask)
+{
+	return -EINVAL;
+}
+
+static inline int irq_can_set_affinity(unsigned int irq) { return 0; }
+
 #endif /* CONFIG_SMP */
 
 #ifdef CONFIG_IRQBALANCE

commit 950f4427c2ddc921164088a20f01304cf231437c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:24 2007 -0800

    [PATCH] Add irq flag to disable balancing for an interrupt
    
    Add a flag so we can prevent the irq balancing of an interrupt.  Move the
    bits, so we have room for more :)
    
    Necessary for the ability to setup clocksources more flexible (e.g.  use the
    different HPET channels per CPU)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 5504b671357f..8930fb0ac9c7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -31,7 +31,7 @@ typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
 /*
  * IRQ line status.
  *
- * Bits 0-16 are reserved for the IRQF_* bits in linux/interrupt.h
+ * Bits 0-7 are reserved for the IRQF_* bits in linux/interrupt.h
  *
  * IRQ types
  */
@@ -45,28 +45,31 @@ typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
 
 /* Internal flags */
-#define IRQ_INPROGRESS		0x00010000	/* IRQ handler active - do not enter! */
-#define IRQ_DISABLED		0x00020000	/* IRQ disabled - do not enter! */
-#define IRQ_PENDING		0x00040000	/* IRQ pending - replay on enable */
-#define IRQ_REPLAY		0x00080000	/* IRQ has been replayed but not acked yet */
-#define IRQ_AUTODETECT		0x00100000	/* IRQ is being autodetected */
-#define IRQ_WAITING		0x00200000	/* IRQ not yet seen - for autodetection */
-#define IRQ_LEVEL		0x00400000	/* IRQ level triggered */
-#define IRQ_MASKED		0x00800000	/* IRQ masked - shouldn't be seen again */
-#define IRQ_PER_CPU		0x01000000	/* IRQ is per CPU */
+#define IRQ_INPROGRESS		0x00000100	/* IRQ handler active - do not enter! */
+#define IRQ_DISABLED		0x00000200	/* IRQ disabled - do not enter! */
+#define IRQ_PENDING		0x00000400	/* IRQ pending - replay on enable */
+#define IRQ_REPLAY		0x00000800	/* IRQ has been replayed but not acked yet */
+#define IRQ_AUTODETECT		0x00001000	/* IRQ is being autodetected */
+#define IRQ_WAITING		0x00002000	/* IRQ not yet seen - for autodetection */
+#define IRQ_LEVEL		0x00004000	/* IRQ level triggered */
+#define IRQ_MASKED		0x00008000	/* IRQ masked - shouldn't be seen again */
+#define IRQ_PER_CPU		0x00010000	/* IRQ is per CPU */
+#define IRQ_NOPROBE		0x00020000	/* IRQ is not valid for probing */
+#define IRQ_NOREQUEST		0x00040000	/* IRQ cannot be requested */
+#define IRQ_NOAUTOEN		0x00080000	/* IRQ will not be enabled on request irq */
+#define IRQ_DELAYED_DISABLE	0x00100000	/* IRQ disable (masking) happens delayed. */
+#define IRQ_WAKEUP		0x00200000	/* IRQ triggers system wakeup */
+#define IRQ_MOVE_PENDING	0x00400000	/* need to re-target IRQ destination */
+#define IRQ_NO_BALANCING	0x00800000	/* IRQ is excluded from balancing */
+
 #ifdef CONFIG_IRQ_PER_CPU
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
+# define IRQ_NO_BALANCING_MASK	(IRQ_PER_CPU | IRQ_NO_BALANCING)
 #else
 # define CHECK_IRQ_PER_CPU(var) 0
+# define IRQ_NO_BALANCING_MASK	IRQ_NO_BALANCING
 #endif
 
-#define IRQ_NOPROBE		0x02000000	/* IRQ is not valid for probing */
-#define IRQ_NOREQUEST		0x04000000	/* IRQ cannot be requested */
-#define IRQ_NOAUTOEN		0x08000000	/* IRQ will not be enabled on request irq */
-#define IRQ_DELAYED_DISABLE	0x10000000	/* IRQ disable (masking) happens delayed. */
-#define IRQ_WAKEUP		0x20000000	/* IRQ triggers system wakeup */
-#define IRQ_MOVE_PENDING	0x40000000	/* need to re-target IRQ destination */
-
 struct proc_dir_entry;
 struct msi_desc;
 
@@ -261,6 +264,11 @@ static inline int select_smp_affinity(unsigned int irq)
 
 extern int no_irq_affinity;
 
+static inline int irq_balancing_disabled(unsigned int irq)
+{
+	return irq_desc[irq].status & IRQ_NO_BALANCING_MASK;
+}
+
 /* Handle irq action chains: */
 extern int handle_IRQ_event(unsigned int irq, struct irqaction *action);
 

commit 5b912c108c8b1fcecbfe13d6d9a183db97b682d3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Jan 28 12:52:03 2007 -0700

    msi: Kill the msi_desc array.
    
    We need to be able to get from an irq number to a struct msi_desc.
    The msi_desc array in msi.c had several short comings the big one was
    that it could not be used outside of msi.c.  Using irq_data in struct
    irq_desc almost worked except on some architectures irq_data needs to
    be used for something else.
    
    So this patch adds a msi_desc pointer to irq_desc, adds the appropriate
    wrappers and changes all of the msi code to use them.
    
    The dynamic_irq_init/cleanup code was tweaked to ensure the new
    field is left in a well defined state.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 52fc4052a0ae..5504b671357f 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -68,6 +68,7 @@ typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_MOVE_PENDING	0x40000000	/* need to re-target IRQ destination */
 
 struct proc_dir_entry;
+struct msi_desc;
 
 /**
  * struct irq_chip - hardware interrupt chip descriptor
@@ -148,6 +149,7 @@ struct irq_chip {
 struct irq_desc {
 	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
+	struct msi_desc		*msi_desc;
 	void			*handler_data;
 	void			*chip_data;
 	struct irqaction	*action;	/* IRQ action list */
@@ -373,10 +375,12 @@ extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);
 extern int set_irq_data(unsigned int irq, void *data);
 extern int set_irq_chip_data(unsigned int irq, void *data);
 extern int set_irq_type(unsigned int irq, unsigned int type);
+extern int set_irq_msi(unsigned int irq, struct msi_desc *entry);
 
 #define get_irq_chip(irq)	(irq_desc[irq].chip)
 #define get_irq_chip_data(irq)	(irq_desc[irq].chip_data)
 #define get_irq_data(irq)	(irq_desc[irq].handler_data)
+#define get_irq_msi(irq)	(irq_desc[irq].msi_desc)
 
 #endif /* CONFIG_GENERIC_HARDIRQS */
 

commit 145fc655a1ceabda76cf2ad74f7cf96863c65b65
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Oct 19 23:28:28 2006 -0700

    [PATCH] genirq: clean up irq-flow-type naming, fix
    
    Re-add the set_irq_chip_and_handler() prototype, it's still widely used.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 775f5a7da493..52fc4052a0ae 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -321,6 +321,9 @@ extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 extern struct irq_chip no_irq_chip;
 extern struct irq_chip dummy_irq_chip;
 
+extern void
+set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
+			 irq_flow_handler_t handle);
 extern void
 set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
 			      irq_flow_handler_t handle, const char *name);

commit a460e745e8f9c75a0525ff94154a0629f9d3e05d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Oct 17 00:10:03 2006 -0700

    [PATCH] genirq: clean up irq-flow-type naming
    
    Introduce desc->name and eliminate the handle_irq_name() hack.  Add
    set_irq_chip_and_handler_name() to set the flow type and name at once.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c64f3cc7e870..775f5a7da493 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -141,6 +141,7 @@ struct irq_chip {
  * @pending_mask:	pending rebalanced interrupts
  * @dir:		/proc/irq/ procfs entry
  * @affinity_entry:	/proc/irq/smp_affinity procfs entry on SMP
+ * @name:		flow handler name for /proc/interrupts output
  *
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
@@ -165,8 +166,9 @@ struct irq_desc {
 	cpumask_t		pending_mask;
 #endif
 #ifdef CONFIG_PROC_FS
-	struct proc_dir_entry *dir;
+	struct proc_dir_entry	*dir;
 #endif
+	const char		*name;
 } ____cacheline_aligned;
 
 extern struct irq_desc irq_desc[NR_IRQS];
@@ -271,12 +273,6 @@ extern void fastcall handle_simple_irq(unsigned int irq, struct irq_desc *desc);
 extern void fastcall handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
 extern void fastcall handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 
-/*
- * Get a descriptive string for the highlevel handler, for
- * /proc/interrupts output:
- */
-extern const char *handle_irq_name(irq_flow_handler_t handle);
-
 /*
  * Monolithic do_IRQ implementation.
  * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
@@ -326,10 +322,12 @@ extern struct irq_chip no_irq_chip;
 extern struct irq_chip dummy_irq_chip;
 
 extern void
-set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
-			 irq_flow_handler_t handle);
+set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,
+			      irq_flow_handler_t handle, const char *name);
+
 extern void
-__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained);
+__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
+		  const char *name);
 
 /*
  * Set a highlevel flow handler for a given IRQ:
@@ -337,7 +335,7 @@ __set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained);
 static inline void
 set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
 {
-	__set_irq_handler(irq, handle, 0);
+	__set_irq_handler(irq, handle, 0, NULL);
 }
 
 /*
@@ -349,7 +347,7 @@ static inline void
 set_irq_chained_handler(unsigned int irq,
 			irq_flow_handler_t handle)
 {
-	__set_irq_handler(irq, handle, 1);
+	__set_irq_handler(irq, handle, 1, NULL);
 }
 
 /* Handle dynamic irq creation and destruction */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b947d46e4b18..c64f3cc7e870 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -21,11 +21,11 @@
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
+#include <asm/irq_regs.h>
 
 struct irq_desc;
 typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
-					    struct irq_desc *desc,
-					    struct pt_regs *regs);
+					    struct irq_desc *desc);
 
 
 /*
@@ -258,28 +258,18 @@ static inline int select_smp_affinity(unsigned int irq)
 extern int no_irq_affinity;
 
 /* Handle irq action chains: */
-extern int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
-			    struct irqaction *action);
+extern int handle_IRQ_event(unsigned int irq, struct irqaction *action);
 
 /*
  * Built-in IRQ handlers for various IRQ types,
  * callable via desc->chip->handle_irq()
  */
-extern void fastcall
-handle_level_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
-extern void fastcall
-handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc,
-			 struct pt_regs *regs);
-extern void fastcall
-handle_edge_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
-extern void fastcall
-handle_simple_irq(unsigned int irq, struct irq_desc *desc,
-		  struct pt_regs *regs);
-extern void fastcall
-handle_percpu_irq(unsigned int irq, struct irq_desc *desc,
-		  struct pt_regs *regs);
-extern void fastcall
-handle_bad_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
+extern void fastcall handle_level_irq(unsigned int irq, struct irq_desc *desc);
+extern void fastcall handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc);
+extern void fastcall handle_edge_irq(unsigned int irq, struct irq_desc *desc);
+extern void fastcall handle_simple_irq(unsigned int irq, struct irq_desc *desc);
+extern void fastcall handle_percpu_irq(unsigned int irq, struct irq_desc *desc);
+extern void fastcall handle_bad_irq(unsigned int irq, struct irq_desc *desc);
 
 /*
  * Get a descriptive string for the highlevel handler, for
@@ -292,7 +282,7 @@ extern const char *handle_irq_name(irq_flow_handler_t handle);
  * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
  */
 #ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
+extern fastcall unsigned int __do_IRQ(unsigned int irq);
 #endif
 
 /*
@@ -301,23 +291,23 @@ extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
  * irqchip-style controller then we call the ->handle_irq() handler,
  * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
  */
-static inline void generic_handle_irq(unsigned int irq, struct pt_regs *regs)
+static inline void generic_handle_irq(unsigned int irq)
 {
 	struct irq_desc *desc = irq_desc + irq;
 
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-	desc->handle_irq(irq, desc, regs);
+	desc->handle_irq(irq, desc);
 #else
 	if (likely(desc->handle_irq))
-		desc->handle_irq(irq, desc, regs);
+		desc->handle_irq(irq, desc);
 	else
-		__do_IRQ(irq, regs);
+		__do_IRQ(irq);
 #endif
 }
 
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
-			   int action_ret, struct pt_regs *regs);
+			   int action_ret);
 
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);

commit 57a58a9435aef3e0342ba4b2c97e0ddfea6f2c7f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 13:06:34 2006 +0100

    IRQ: Typedef the IRQ flow handler function type
    
    Typedef the IRQ flow handler function type.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 8e973fbdf5716b93a0a8c0365be33a31ca0fa351 commit)

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6f463606c318..b947d46e4b18 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -22,6 +22,12 @@
 #include <asm/irq.h>
 #include <asm/ptrace.h>
 
+struct irq_desc;
+typedef	void fastcall (*irq_flow_handler_t)(unsigned int irq,
+					    struct irq_desc *desc,
+					    struct pt_regs *regs);
+
+
 /*
  * IRQ line status.
  *
@@ -139,9 +145,7 @@ struct irq_chip {
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
 struct irq_desc {
-	void fastcall		(*handle_irq)(unsigned int irq,
-					      struct irq_desc *desc,
-					      struct pt_regs *regs);
+	irq_flow_handler_t	handle_irq;
 	struct irq_chip		*chip;
 	void			*handler_data;
 	void			*chip_data;
@@ -281,9 +285,7 @@ handle_bad_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
  * Get a descriptive string for the highlevel handler, for
  * /proc/interrupts output:
  */
-extern const char *
-handle_irq_name(void fastcall (*handle)(unsigned int, struct irq_desc *,
-					struct pt_regs *));
+extern const char *handle_irq_name(irq_flow_handler_t handle);
 
 /*
  * Monolithic do_IRQ implementation.
@@ -335,22 +337,15 @@ extern struct irq_chip dummy_irq_chip;
 
 extern void
 set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
-			 void fastcall (*handle)(unsigned int,
-						 struct irq_desc *,
-						 struct pt_regs *));
+			 irq_flow_handler_t handle);
 extern void
-__set_irq_handler(unsigned int irq,
-		  void fastcall (*handle)(unsigned int, struct irq_desc *,
-					  struct pt_regs *),
-		  int is_chained);
+__set_irq_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained);
 
 /*
  * Set a highlevel flow handler for a given IRQ:
  */
 static inline void
-set_irq_handler(unsigned int irq,
-		void fastcall (*handle)(unsigned int, struct irq_desc *,
-					struct pt_regs *))
+set_irq_handler(unsigned int irq, irq_flow_handler_t handle)
 {
 	__set_irq_handler(irq, handle, 0);
 }
@@ -362,8 +357,7 @@ set_irq_handler(unsigned int irq,
  */
 static inline void
 set_irq_chained_handler(unsigned int irq,
-			void fastcall (*handle)(unsigned int, struct irq_desc *,
-						struct pt_regs *))
+			irq_flow_handler_t handle)
 {
 	__set_irq_handler(irq, handle, 1);
 }

commit 1f80025e624bb14fefadfef7e80fbfb9740d4714
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 4 02:16:56 2006 -0700

    [PATCH] msi: simplify msi sanity checks by adding with generic irq code
    
    Currently msi.c is doing sanity checks that make certain before an irq is
    destroyed it has no more users.
    
    By adding irq_has_action I can perform the test is a generic way, instead of
    relying on a msi specific data structure.
    
    By performing the core check in dynamic_irq_cleanup I ensure every user of
    dynamic irqs has a test present and we don't free resources that are in use.
    
    In msi.c this allows me to kill the attrib.state member of msi_desc and all of
    the assciated code to maintain it.
    
    To keep from freeing data structures when irq cleanup code is called to soon
    changing dyanamic_irq_cleanup is insufficient because there are msi specific
    data structures that are also not safe to free.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Greg KH <greg@kroah.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 69855b23dff9..6f463606c318 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -372,6 +372,13 @@ set_irq_chained_handler(unsigned int irq,
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
 
+/* Test to see if a driver has successfully requested an irq */
+static inline int irq_has_action(unsigned int irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	return desc->action != NULL;
+}
+
 /* Dynamic irq helper functions */
 extern void dynamic_irq_init(unsigned int irq);
 extern void dynamic_irq_cleanup(unsigned int irq);

commit 323a01c50832749d23664954f91df6fc43e73975
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 4 02:16:48 2006 -0700

    [PATCH] genirq: irq: remove msi hacks
    
    Because of the nasty way that CONFIG_PCI_MSI was implemented we wound up with
    set_irq_info and set_native_irq_info, with move_irq and move_native_irq.  Both
    functions did the same thing but they were built and called under different
    circumstances.  Now that the msi hacks are gone we can kill move_irq and
    set_irq_info.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Protasevich, Natalie" <Natalie.Protasevich@UNISYS.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 82dbb0e8f40b..69855b23dff9 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -207,36 +207,6 @@ void set_pending_irq(unsigned int irq, cpumask_t mask);
 void move_native_irq(int irq);
 void move_masked_irq(int irq);
 
-#ifdef CONFIG_PCI_MSI
-/*
- * Wonder why these are dummies?
- * For e.g the set_ioapic_affinity_vector() calls the set_ioapic_affinity_irq()
- * counter part after translating the vector to irq info. We need to perform
- * this operation on the real irq, when we dont use vector, i.e when
- * pci_use_vector() is false.
- */
-static inline void move_irq(int irq)
-{
-}
-
-static inline void set_irq_info(int irq, cpumask_t mask)
-{
-}
-
-#else /* CONFIG_PCI_MSI */
-
-static inline void move_irq(int irq)
-{
-	move_native_irq(irq);
-}
-
-static inline void set_irq_info(int irq, cpumask_t mask)
-{
-	set_native_irq_info(irq, mask);
-}
-
-#endif /* CONFIG_PCI_MSI */
-
 #else /* CONFIG_GENERIC_PENDING_IRQ || CONFIG_IRQBALANCE */
 
 static inline void move_irq(int irq)
@@ -255,16 +225,10 @@ static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 {
 }
 
-static inline void set_irq_info(int irq, cpumask_t mask)
-{
-	set_native_irq_info(irq, mask);
-}
-
 #endif /* CONFIG_GENERIC_PENDING_IRQ */
 
 #else /* CONFIG_SMP */
 
-#define move_irq(x)
 #define move_native_irq(x)
 #define move_masked_irq(x)
 

commit 3a16d713626735f3016da0521b7bf251cd78e836
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 4 02:16:37 2006 -0700

    [PATCH] genirq: irq: add a dynamic irq creation API
    
    With the msi support comes a new concept in irq handling, irqs that are
    created dynamically at run time.
    
    Currently the msi code allocates irqs backwards.  First it allocates a
    platform dependent routing value for an interrupt the ``vector'' and then it
    figures out from the vector which irq you are on.
    
    This msi backwards allocator suffers from two basic problems.  The allocator
    suffers because it is trying to do something that is architecture specific in
    a generic way making it brittle, inflexible, and tied to tightly to the
    architecture implementation.  The alloctor also suffers from it's very
    backwards nature as it has tied things together that should have no
    dependencies.
    
    To solve the basic dynamic irq allocation problem two new architecture
    specific functions are added: create_irq and destroy_irq.
    
    create_irq takes no input and returns an unused irq number, that won't be
    reused until it is returned to the free poll with destroy_irq.  The irq then
    can be used for any purpose although the only initial consumer is the msi
    code.
    
    destroy_irq takes an irq number allocated with create_irq and returns it to
    the free pool.
    
    Making this functionality per architecture increases the simplicity of the irq
    allocation code and increases it's flexibility.
    
    dynamic_irq_init() and dynamic_irq_cleanup() are added to automate the
    irq_desc initializtion that should happen for dynamic irqs.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Protasevich, Natalie" <Natalie.Protasevich@UNISYS.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index a31a7d8acdb2..82dbb0e8f40b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -404,8 +404,15 @@ set_irq_chained_handler(unsigned int irq,
 	__set_irq_handler(irq, handle, 1);
 }
 
-/* Set/get chip/data for an IRQ: */
+/* Handle dynamic irq creation and destruction */
+extern int create_irq(void);
+extern void destroy_irq(unsigned int irq);
+
+/* Dynamic irq helper functions */
+extern void dynamic_irq_init(unsigned int irq);
+extern void dynamic_irq_cleanup(unsigned int irq);
 
+/* Set/get chip/data for an IRQ: */
 extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);
 extern int set_irq_data(unsigned int irq, void *data);
 extern int set_irq_chip_data(unsigned int irq, void *data);

commit e7b946e98a456077dd6897f726f3d6197bd7e3b9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 4 02:16:29 2006 -0700

    [PATCH] genirq: irq: add moved_masked_irq
    
    Currently move_native_irq disables and renables the irq we are migrating to
    ensure we don't take that irq when we are actually doing the migration
    operation.  Disabling the irq needs to happen but sometimes doing the work is
    move_native_irq is too late.
    
    On x86 with ioapics the irq move sequences needs to be:
    edge_triggered:
      mask irq.
      move irq.
      unmask irq.
      ack irq.
    level_triggered:
      mask irq.
      ack irq.
      move irq.
      unmask irq.
    
    We can easily perform the edge triggered sequence, with the current defintion
    of move_native_irq.  However the level triggered case does not map well.  For
    that I have added move_masked_irq, to allow me to disable the irqs around both
    the ack and the move.
    
    Q: Why have we not seen this problem earlier?
    
    A: The only symptom I have been able to reproduce is that if we change
       the vector before acknowleding an irq the wrong irq is acknowledged.
       Since we currently are not reprogramming the irq vector during
       migration no problems show up.
    
       We have to mask the irq before we acknowledge the irq or else we could
       hit a window where an irq is asserted just before we acknowledge it.
    
       Edge triggered irqs do not have this problem because acknowledgements
       do not propogate in the same way.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Protasevich, Natalie" <Natalie.Protasevich@UNISYS.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 3eab46f590a9..a31a7d8acdb2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -205,6 +205,7 @@ static inline void set_native_irq_info(int irq, cpumask_t mask)
 
 void set_pending_irq(unsigned int irq, cpumask_t mask);
 void move_native_irq(int irq);
+void move_masked_irq(int irq);
 
 #ifdef CONFIG_PCI_MSI
 /*
@@ -246,6 +247,10 @@ static inline void move_native_irq(int irq)
 {
 }
 
+static inline void move_masked_irq(int irq)
+{
+}
+
 static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
 {
 }
@@ -261,6 +266,7 @@ static inline void set_irq_info(int irq, cpumask_t mask)
 
 #define move_irq(x)
 #define move_native_irq(x)
+#define move_masked_irq(x)
 
 #endif /* CONFIG_SMP */
 

commit a24ceab4f44f21749aa0b6bd38bee37c775e036f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Oct 4 02:16:27 2006 -0700

    [PATCH] genirq: irq: convert the move_irq flag from a 32bit word to a single bit
    
    The primary aim of this patchset is to remove maintenances problems caused by
    the irq infrastructure.  The two big issues I address are an artificially
    small cap on the number of irqs, and that MSI assumes vector == irq.  My
    primary focus is on x86_64 but I have touched other architectures where
    necessary to keep them from breaking.
    
    - To increase the number of irqs I modify the code to look at the (cpu,
      vector) pair instead of just looking at the vector.
    
      With a large number of irqs available systems with a large irq count no
      longer need to compress their irq numbers to fit.  Removing a lot of brittle
      special cases.
    
      For acpi guys the result is that irq == gsi.
    
    - Addressing the fact that MSI assumes irq == vector takes a few more
      patches.  But suffice it to say when I am done none of the generic irq code
      even knows what a vector is.
    
    In quick testing on a large Unisys x86_64 machine we stumbled over at least
    one driver that assumed that NR_IRQS could always fit into an 8 bit number.
    This driver is clearly buggy today.  But this has become a class of bugs that
    it is now much easier to hit.
    
    This patch:
    
    This is a minor space optimization.  In practice I don't think this has any
    affect because of our alignment constraints and the other fields but there is
    not point in chewing up an uncessary word and since we already read the flag
    field this should improve the cache hit ratio of the irq handler.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rajesh Shah <rajesh.shah@intel.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Protasevich, Natalie" <Natalie.Protasevich@UNISYS.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 48d3cb3b6a47..3eab46f590a9 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -59,6 +59,7 @@
 #define IRQ_NOAUTOEN		0x08000000	/* IRQ will not be enabled on request irq */
 #define IRQ_DELAYED_DISABLE	0x10000000	/* IRQ disable (masking) happens delayed. */
 #define IRQ_WAKEUP		0x20000000	/* IRQ triggers system wakeup */
+#define IRQ_MOVE_PENDING	0x40000000	/* need to re-target IRQ destination */
 
 struct proc_dir_entry;
 
@@ -132,7 +133,6 @@ struct irq_chip {
  * @affinity:		IRQ affinity on SMP
  * @cpu:		cpu index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
- * @move_irq:		need to re-target IRQ destination
  * @dir:		/proc/irq/ procfs entry
  * @affinity_entry:	/proc/irq/smp_affinity procfs entry on SMP
  *
@@ -159,7 +159,6 @@ struct irq_desc {
 #endif
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 	cpumask_t		pending_mask;
-	unsigned int		move_irq;	/* need to re-target IRQ dest */
 #endif
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *dir;

commit af8c65b57aaa4ae321af34dbfc5ca7f5625263fe
Author: David Howells <dhowells@redhat.com>
Date:   Mon Sep 25 23:32:07 2006 -0700

    [PATCH] FRV: permit __do_IRQ() to be dispensed with
    
    Permit __do_IRQ() to be dispensed with based on a configuration option.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index fbf6d901e9c2..48d3cb3b6a47 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -320,7 +320,9 @@ handle_irq_name(void fastcall (*handle)(unsigned int, struct irq_desc *,
  * Monolithic do_IRQ implementation.
  * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
  */
+#ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
+#endif
 
 /*
  * Architectures call this to let the generic IRQ layer
@@ -332,10 +334,14 @@ static inline void generic_handle_irq(unsigned int irq, struct pt_regs *regs)
 {
 	struct irq_desc *desc = irq_desc + irq;
 
+#ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
+	desc->handle_irq(irq, desc, regs);
+#else
 	if (likely(desc->handle_irq))
 		desc->handle_irq(irq, desc, regs);
 	else
 		__do_IRQ(irq, regs);
+#endif
 }
 
 /* Handling of unhandled and spurious interrupts: */

commit b8bdb460b7ecf08a4fed6e8b5b6b3fe874587aaa
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 30 03:03:33 2006 -0700

    [PATCH] always define IRQ_PER_CPU
    
    Reduce the likelihood of someone accidentally introducing namespace
    collisions.
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6e59ac05ef2a..fbf6d901e9c2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -47,8 +47,8 @@
 #define IRQ_WAITING		0x00200000	/* IRQ not yet seen - for autodetection */
 #define IRQ_LEVEL		0x00400000	/* IRQ level triggered */
 #define IRQ_MASKED		0x00800000	/* IRQ masked - shouldn't be seen again */
+#define IRQ_PER_CPU		0x01000000	/* IRQ is per CPU */
 #ifdef CONFIG_IRQ_PER_CPU
-# define IRQ_PER_CPU		0x01000000	/* IRQ is per CPU */
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 #else
 # define CHECK_IRQ_PER_CPU(var) 0

commit 15a647eba94c3da27ccc666bea72e7cca06b2d19
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jul 30 03:03:08 2006 -0700

    [PATCH] genirq: {en,dis}able_irq_wake() need refcounting too
    
    IRQs need refcounting and a state flag to track whether the the IRQ should
    be enabled or disabled as a "normal IRQ" source after a series of calls to
    {en,dis}able_irq().  For shared IRQs, the IRQ must be enabled so long as at
    least one driver needs it active.
    
    Likewise, IRQs need the same support to track whether the IRQ should be
    enabled or disabled as a "wakeup event" source after a series of calls to
    {en,dis}able_irq_wake().  For shared IRQs, the IRQ must be enabled as a
    wakeup source during sleep so long as at least one driver needs it.  But
    right now they _don't have_ that refcounting ...  which means sharing a
    wakeup-capable IRQ can't work correctly in some configurations.
    
    This patch adds the refcount and flag mechanisms to set_irq_wake() -- which
    is what {en,dis}able_irq_wake() call -- and minimal documentation of what
    the irq wake mechanism does.
    
    Drivers relying on the older (broken) "toggle" semantics will trigger a
    warning; that'll be a handful of drivers on ARM systems.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b48eae32dc61..6e59ac05ef2a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -58,6 +58,7 @@
 #define IRQ_NOREQUEST		0x04000000	/* IRQ cannot be requested */
 #define IRQ_NOAUTOEN		0x08000000	/* IRQ will not be enabled on request irq */
 #define IRQ_DELAYED_DISABLE	0x10000000	/* IRQ disable (masking) happens delayed. */
+#define IRQ_WAKEUP		0x20000000	/* IRQ triggers system wakeup */
 
 struct proc_dir_entry;
 
@@ -124,6 +125,7 @@ struct irq_chip {
  * @action:		the irq action chain
  * @status:		status information
  * @depth:		disable-depth, for nested irq_disable() calls
+ * @wake_depth:		enable depth, for multiple set_irq_wake() callers
  * @irq_count:		stats field to detect stalled irqs
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
@@ -147,6 +149,7 @@ struct irq_desc {
 	unsigned int		status;		/* IRQ status */
 
 	unsigned int		depth;		/* nested irq disables */
+	unsigned int		wake_depth;	/* nested wake enables */
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned int		irqs_unhandled;
 	spinlock_t		lock;

commit d061daa0e3abdddc28e21a37c8ac4536dedbf239
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 3 02:18:48 2006 +0200

    [PATCH] genirq: ARM dyntick cleanup
    
    Linus: "The hacks in kernel/irq/handle.c are really horrid. REALLY
    horrid."
    
    They are indeed. Move the dyntick quirks to ARM where they belong.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 95d7aa7954d2..b48eae32dc61 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -182,6 +182,10 @@ extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
+#ifndef handle_dynamic_tick
+# define handle_dynamic_tick(a)		do { } while (0)
+#endif
+
 #ifdef CONFIG_SMP
 static inline void set_native_irq_info(int irq, cpumask_t mask)
 {

commit b4b9034132c7e1e4474999e688dd7d03b7d97a99
Merge: a8c4c20dfa8b 07d265dd5945
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jul 2 15:07:45 2006 -0700

    Merge branch 'genirq' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'genirq' of master.kernel.org:/home/rmk/linux-2.6-arm: (24 commits)
      [ARM] 3683/2:  ARM: Convert at91rm9200 to generic irq handling
      [ARM] 3682/2:  ARM: Convert ixp4xx to generic irq handling
      [ARM] 3702/1: ARM: Convert ixp23xx to generic irq handling
      [ARM] 3701/1: ARM: Convert plat-omap to generic irq handling
      [ARM] 3700/1: ARM: Convert lh7a40x to generic irq handling
      [ARM] 3699/1: ARM: Convert s3c2410 to generic irq handling
      [ARM] 3698/1: ARM: Convert sa1100 to generic irq handling
      [ARM] 3697/1: ARM: Convert shark to generic irq handling
      [ARM] 3696/1: ARM: Convert clps711x to generic irq handling
      [ARM] 3694/1: ARM: Convert ecard driver to generic irq handling
      [ARM] 3693/1: ARM: Convert omap1 to generic irq handling
      [ARM] 3691/1: ARM: Convert imx to generic irq handling
      [ARM] 3688/1: ARM: Convert clps7500 to generic irq handling
      [ARM] 3687/1: ARM: Convert integrator to generic irq handling
      [ARM] 3685/1: ARM: Convert pxa to generic irq handling
      [ARM] 3684/1: ARM: Convert l7200 to generic irq handling
      [ARM] 3681/1: ARM: Convert ixp2000 to generic irq handling
      [ARM] 3680/1: ARM: Convert footbridge to generic irq handling
      [ARM] 3695/1: ARM drivers/pcmcia: Fixup includes
      [ARM] 3689/1: ARM drivers/input/touchscreen: Fixup includes
      ...
    
    Manual conflict resolved in kernel/irq/handle.c (butt-ugly ARM tickless
    code).

commit 6e21361619328751e2637b004e14cf360aafbddc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:03 2006 -0700

    [PATCH] irq-flags: consolidate flags for request_irq
    
    The recent interrupt rework introduced bit value conflicts with sparc.
    Instead of introducing new architecture flags mess, move the interrupt SA_
    flags out of the signal namespace and replace them by interrupt related flags.
    
    This allows to remove the obsolete SA_INTERRUPT flag and clean up the bit
    field values.
    
    This patch:
    
    Move the interrupt related SA_ flags out of linux/signal.h and rename them to
    IRQF_ .  This moves the interrupt related flags out of the signal namespace
    and allows to remove the architecture dependencies.
    
    SA_INTERRUPT is not needed by userspace and glibc so it can be removed safely.
    
    The existing SA_ constants are kept for easy transition and will be
    removed after a 6 month grace period.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Jody McIntyre <scjody@modernduck.com>
    Cc: Ben Collins <bcollins@debian.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>                                 Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0832149cdb18..ae1e422f18e3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -24,41 +24,40 @@
 
 /*
  * IRQ line status.
+ *
+ * Bits 0-16 are reserved for the IRQF_* bits in linux/interrupt.h
+ *
+ * IRQ types
  */
-#define IRQ_INPROGRESS	1	/* IRQ handler active - do not enter! */
-#define IRQ_DISABLED	2	/* IRQ disabled - do not enter! */
-#define IRQ_PENDING	4	/* IRQ pending - replay on enable */
-#define IRQ_REPLAY	8	/* IRQ has been replayed but not acked yet */
-#define IRQ_AUTODETECT	16	/* IRQ is being autodetected */
-#define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
-#define IRQ_LEVEL	64	/* IRQ level triggered */
-#define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
+#define IRQ_TYPE_NONE		0x00000000	/* Default, unspecified type */
+#define IRQ_TYPE_EDGE_RISING	0x00000001	/* Edge rising type */
+#define IRQ_TYPE_EDGE_FALLING	0x00000002	/* Edge falling type */
+#define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
+#define IRQ_TYPE_LEVEL_HIGH	0x00000004	/* Level high type */
+#define IRQ_TYPE_LEVEL_LOW	0x00000008	/* Level low type */
+#define IRQ_TYPE_SENSE_MASK	0x0000000f	/* Mask of the above */
+#define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
+
+/* Internal flags */
+#define IRQ_INPROGRESS		0x00010000	/* IRQ handler active - do not enter! */
+#define IRQ_DISABLED		0x00020000	/* IRQ disabled - do not enter! */
+#define IRQ_PENDING		0x00040000	/* IRQ pending - replay on enable */
+#define IRQ_REPLAY		0x00080000	/* IRQ has been replayed but not acked yet */
+#define IRQ_AUTODETECT		0x00100000	/* IRQ is being autodetected */
+#define IRQ_WAITING		0x00200000	/* IRQ not yet seen - for autodetection */
+#define IRQ_LEVEL		0x00400000	/* IRQ level triggered */
+#define IRQ_MASKED		0x00800000	/* IRQ masked - shouldn't be seen again */
 #ifdef CONFIG_IRQ_PER_CPU
-# define IRQ_PER_CPU	256	/* IRQ is per CPU */
+# define IRQ_PER_CPU		0x01000000	/* IRQ is per CPU */
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 #else
 # define CHECK_IRQ_PER_CPU(var) 0
 #endif
 
-#define IRQ_NOPROBE	512	/* IRQ is not valid for probing */
-#define IRQ_NOREQUEST	1024	/* IRQ cannot be requested */
-#define IRQ_NOAUTOEN	2048	/* IRQ will not be enabled on request irq */
-#define IRQ_DELAYED_DISABLE \
-			4096	/* IRQ disable (masking) happens delayed. */
-
-/*
- * IRQ types, see also include/linux/interrupt.h
- */
-#define IRQ_TYPE_NONE		0x0000		/* Default, unspecified type */
-#define IRQ_TYPE_EDGE_RISING	0x0001		/* Edge rising type */
-#define IRQ_TYPE_EDGE_FALLING	0x0002		/* Edge falling type */
-#define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
-#define IRQ_TYPE_LEVEL_HIGH	0x0004		/* Level high type */
-#define IRQ_TYPE_LEVEL_LOW	0x0008		/* Level low type */
-#define IRQ_TYPE_SENSE_MASK	0x000f		/* Mask of the above */
-#define IRQ_TYPE_SIMPLE		0x0010		/* Simple type */
-#define IRQ_TYPE_PERCPU		0x0020		/* Per CPU type */
-#define IRQ_TYPE_PROBE		0x0040		/* Probing in progress */
+#define IRQ_NOPROBE		0x02000000	/* IRQ is not valid for probing */
+#define IRQ_NOREQUEST		0x04000000	/* IRQ cannot be requested */
+#define IRQ_NOAUTOEN		0x08000000	/* IRQ will not be enabled on request irq */
+#define IRQ_DELAYED_DISABLE	0x10000000	/* IRQ disable (masking) happens delayed. */
 
 struct proc_dir_entry;
 

commit f8b5473fcbddbfde827ecf82aa0e81fa2a878220
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 22:30:08 2006 +0100

    [ARM] 3690/1: genirq: Introduce and make use of dummy irq chip
    
    Patch from Thomas Gleixner
    
    From: Thomas Gleixner <tglx@linutronix.de>
    
    ARM has a couple of really dumb interrupt controllers.
    Implement a generic one and fixup the ARM migration. ARM reused
    the no_irq_chip for this purpose, but this does not work out
    for platforms which are not converted to the new interrupt
    type handling model.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0832149cdb18..00b6ef8b2f93 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -348,8 +348,9 @@ extern int noirqdebug_setup(char *str);
 /* Checks whether the interrupt can be requested by request_irq(): */
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
-/* Dummy irq-chip implementation: */
+/* Dummy irq-chip implementations: */
 extern struct irq_chip no_irq_chip;
+extern struct irq_chip dummy_irq_chip;
 
 extern void
 set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,

commit 47c2a3aa4475d27073dd3c7e183fcc13f495c8f5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:25:03 2006 -0700

    [PATCH] genirq: add chip->eoi(), fastack -> fasteoi
    
    Clean up the fastack concept by turning it into fasteoi and introducing the
    ->eoi() method for chips.
    
    This also allows the cleanup of an i386 EOI quirk - now the quirk is
    cleanly separated from the pure ACK implementation.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0d8eaf3e4036..0832149cdb18 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -74,7 +74,8 @@ struct proc_dir_entry;
  * @mask:		mask an interrupt source
  * @mask_ack:		ack and mask an interrupt source
  * @unmask:		unmask an interrupt source
- * @end:		end of interrupt
+ * @eoi:		end of interrupt - chip level
+ * @end:		end of interrupt - flow level
  * @set_affinity:	set the CPU affinity on SMP machines
  * @retrigger:		resend an IRQ to the CPU
  * @set_type:		set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
@@ -94,6 +95,7 @@ struct irq_chip {
 	void		(*mask)(unsigned int irq);
 	void		(*mask_ack)(unsigned int irq);
 	void		(*unmask)(unsigned int irq);
+	void		(*eoi)(unsigned int irq);
 
 	void		(*end)(unsigned int irq);
 	void		(*set_affinity)(unsigned int irq, cpumask_t dest);
@@ -287,7 +289,7 @@ extern int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 extern void fastcall
 handle_level_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
 extern void fastcall
-handle_fastack_irq(unsigned int irq, struct irq_desc *desc,
+handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc,
 			 struct pt_regs *regs);
 extern void fastcall
 handle_edge_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);

commit f210be198ddd3f54b17d4aa6e69b829f75f226e5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Jun 29 02:25:00 2006 -0700

    [PATCH] genirq: add IRQ_TYPE_SENSE_MASK
    
    Add a #define for the mask of the part of IRQ_TYPE that represents the
    trigger type.  I use that in my in-progress work as I've standardized the
    way the irq description in the firmware device-tree get translated to linux
    useable things by using those constants.  Having this mask to isolate the
    "trigger type" part of the flags is useful in a few places.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ca8d2a849cff..0d8eaf3e4036 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -55,6 +55,7 @@
 #define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
 #define IRQ_TYPE_LEVEL_HIGH	0x0004		/* Level high type */
 #define IRQ_TYPE_LEVEL_LOW	0x0008		/* Level low type */
+#define IRQ_TYPE_SENSE_MASK	0x000f		/* Mask of the above */
 #define IRQ_TYPE_SIMPLE		0x0010		/* Simple type */
 #define IRQ_TYPE_PERCPU		0x0020		/* Per CPU type */
 #define IRQ_TYPE_PROBE		0x0040		/* Probing in progress */

commit dd87eb3a24c4527741122713e223d74b85d43c85
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:53 2006 -0700

    [PATCH] genirq: add irq-chip support
    
    Enable platforms to use the irq-chip and irq-flow abstractions: allow setting
    of the chip, the type and provide highlevel handlers for common irq-flows.
    
    [rostedt@goodmis.org: misroute-irq: Don't call desc->chip->end because of edge interrupts]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b40771dd114a..ca8d2a849cff 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -383,6 +383,17 @@ set_irq_chained_handler(unsigned int irq,
 	__set_irq_handler(irq, handle, 1);
 }
 
+/* Set/get chip/data for an IRQ: */
+
+extern int set_irq_chip(unsigned int irq, struct irq_chip *chip);
+extern int set_irq_data(unsigned int irq, void *data);
+extern int set_irq_chip_data(unsigned int irq, void *data);
+extern int set_irq_type(unsigned int irq, unsigned int type);
+
+#define get_irq_chip(irq)	(irq_desc[irq].chip)
+#define get_irq_chip_data(irq)	(irq_desc[irq].chip_data)
+#define get_irq_data(irq)	(irq_desc[irq].handler_data)
+
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */

commit dae8620421833bb2e9a01c4ccc42bdc3759b81df
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:52 2006 -0700

    [PATCH] genirq MSI fixes
    
    This is a fixed up and cleaned up replacement for genirq-msi-fixes.patch,
    which should solve the i386 4KSTACKS problem.  I also added Ben's idea of
    pushing the __do_IRQ() check into generic_handle_irq().
    
    I booted this with MSI enabled, but i only have MSI devices, not MSI-X
    devices.  I'd still expect MSI-X to work now.
    
    irqchip migration helper: call __do_IRQ() if a descriptor is attached to an
    irqtype-style controller.  This also fixes MSI-X IRQ handling on i386 and
    x86_64.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 437f2c635db6..b40771dd114a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -176,17 +176,6 @@ typedef struct irq_desc		irq_desc_t;
  */
 #include <asm/hw_irq.h>
 
-/*
- * Architectures call this to let the generic IRQ layer
- * handle an interrupt:
- */
-static inline void generic_handle_irq(unsigned int irq, struct pt_regs *regs)
-{
-	struct irq_desc *desc = irq_desc + irq;
-
-	desc->handle_irq(irq, desc, regs);
-}
-
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
@@ -324,6 +313,22 @@ handle_irq_name(void fastcall (*handle)(unsigned int, struct irq_desc *,
  */
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
 
+/*
+ * Architectures call this to let the generic IRQ layer
+ * handle an interrupt. If the descriptor is attached to an
+ * irqchip-style controller then we call the ->handle_irq() handler,
+ * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
+ */
+static inline void generic_handle_irq(unsigned int irq, struct pt_regs *regs)
+{
+	struct irq_desc *desc = irq_desc + irq;
+
+	if (likely(desc->handle_irq))
+		desc->handle_irq(irq, desc, regs);
+	else
+		__do_IRQ(irq, regs);
+}
+
 /* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   int action_ret, struct pt_regs *regs);

commit 6a6de9ef5850d063c3d3fb50784bfe3a6d0712c6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:51 2006 -0700

    [PATCH] genirq: core
    
    Core genirq support: add the irq-chip and irq-flow abstractions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 14d7e94048dd..437f2c635db6 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -43,20 +43,36 @@
 #define IRQ_NOPROBE	512	/* IRQ is not valid for probing */
 #define IRQ_NOREQUEST	1024	/* IRQ cannot be requested */
 #define IRQ_NOAUTOEN	2048	/* IRQ will not be enabled on request irq */
+#define IRQ_DELAYED_DISABLE \
+			4096	/* IRQ disable (masking) happens delayed. */
+
+/*
+ * IRQ types, see also include/linux/interrupt.h
+ */
+#define IRQ_TYPE_NONE		0x0000		/* Default, unspecified type */
+#define IRQ_TYPE_EDGE_RISING	0x0001		/* Edge rising type */
+#define IRQ_TYPE_EDGE_FALLING	0x0002		/* Edge falling type */
+#define IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING)
+#define IRQ_TYPE_LEVEL_HIGH	0x0004		/* Level high type */
+#define IRQ_TYPE_LEVEL_LOW	0x0008		/* Level low type */
+#define IRQ_TYPE_SIMPLE		0x0010		/* Simple type */
+#define IRQ_TYPE_PERCPU		0x0020		/* Per CPU type */
+#define IRQ_TYPE_PROBE		0x0040		/* Probing in progress */
+
+struct proc_dir_entry;
+
 /**
- * struct hw_interrupt_type - hardware interrupt type descriptor
+ * struct irq_chip - hardware interrupt chip descriptor
  *
  * @name:		name for /proc/interrupts
  * @startup:		start up the interrupt (defaults to ->enable if NULL)
  * @shutdown:		shut down the interrupt (defaults to ->disable if NULL)
  * @enable:		enable the interrupt (defaults to chip->unmask if NULL)
  * @disable:		disable the interrupt (defaults to chip->mask if NULL)
- * @handle_irq:		irq flow handler called from the arch IRQ glue code
  * @ack:		start of a new interrupt
  * @mask:		mask an interrupt source
  * @mask_ack:		ack and mask an interrupt source
  * @unmask:		unmask an interrupt source
- * @hold:		same interrupt while the handler is running
  * @end:		end of interrupt
  * @set_affinity:	set the CPU affinity on SMP machines
  * @retrigger:		resend an IRQ to the CPU
@@ -64,33 +80,45 @@
  * @set_wake:		enable/disable power-management wake-on of an IRQ
  *
  * @release:		release function solely used by UML
+ * @typename:		obsoleted by name, kept as migration helper
  */
-struct hw_interrupt_type {
-	const char	*typename;
+struct irq_chip {
+	const char	*name;
 	unsigned int	(*startup)(unsigned int irq);
 	void		(*shutdown)(unsigned int irq);
 	void		(*enable)(unsigned int irq);
 	void		(*disable)(unsigned int irq);
+
 	void		(*ack)(unsigned int irq);
+	void		(*mask)(unsigned int irq);
+	void		(*mask_ack)(unsigned int irq);
+	void		(*unmask)(unsigned int irq);
+
 	void		(*end)(unsigned int irq);
 	void		(*set_affinity)(unsigned int irq, cpumask_t dest);
 	int		(*retrigger)(unsigned int irq);
+	int		(*set_type)(unsigned int irq, unsigned int flow_type);
+	int		(*set_wake)(unsigned int irq, unsigned int on);
 
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);
 #endif
+	/*
+	 * For compatibility, ->typename is copied into ->name.
+	 * Will disappear.
+	 */
+	const char	*typename;
 };
 
-typedef struct hw_interrupt_type  hw_irq_controller;
-
-struct proc_dir_entry;
-
 /**
  * struct irq_desc - interrupt descriptor
  *
- * @handler:		interrupt type dependent handler functions
- * @handler_data:	data for the type handlers
+ * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
+ * @chip:		low level interrupt hardware access
+ * @handler_data:	per-IRQ data for the irq_chip methods
+ * @chip_data:		platform-specific per-chip private data for the chip
+ *			methods, to allow shared chip implementations
  * @action:		the irq action chain
  * @status:		status information
  * @depth:		disable-depth, for nested irq_disable() calls
@@ -98,6 +126,7 @@ struct proc_dir_entry;
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
  * @affinity:		IRQ affinity on SMP
+ * @cpu:		cpu index useful for balancing
  * @pending_mask:	pending rebalanced interrupts
  * @move_irq:		need to re-target IRQ destination
  * @dir:		/proc/irq/ procfs entry
@@ -106,16 +135,22 @@ struct proc_dir_entry;
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
 struct irq_desc {
-	hw_irq_controller	*chip;
+	void fastcall		(*handle_irq)(unsigned int irq,
+					      struct irq_desc *desc,
+					      struct pt_regs *regs);
+	struct irq_chip		*chip;
+	void			*handler_data;
 	void			*chip_data;
 	struct irqaction	*action;	/* IRQ action list */
 	unsigned int		status;		/* IRQ status */
+
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned int		irqs_unhandled;
 	spinlock_t		lock;
 #ifdef CONFIG_SMP
 	cpumask_t		affinity;
+	unsigned int		cpu;
 #endif
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 	cpumask_t		pending_mask;
@@ -131,6 +166,9 @@ extern struct irq_desc irq_desc[NR_IRQS];
 /*
  * Migration helpers for obsolete names, they will go away:
  */
+#define hw_interrupt_type	irq_chip
+typedef struct irq_chip		hw_irq_controller;
+#define no_irq_type		no_irq_chip
 typedef struct irq_desc		irq_desc_t;
 
 /*
@@ -138,6 +176,17 @@ typedef struct irq_desc		irq_desc_t;
  */
 #include <asm/hw_irq.h>
 
+/*
+ * Architectures call this to let the generic IRQ layer
+ * handle an interrupt:
+ */
+static inline void generic_handle_irq(unsigned int irq, struct pt_regs *regs)
+{
+	struct irq_desc *desc = irq_desc + irq;
+
+	desc->handle_irq(irq, desc, regs);
+}
+
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
@@ -236,27 +285,100 @@ static inline int select_smp_affinity(unsigned int irq)
 #endif
 
 extern int no_irq_affinity;
-extern int noirqdebug_setup(char *str);
 
-extern irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
-				    struct irqaction *action);
+/* Handle irq action chains: */
+extern int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
+			    struct irqaction *action);
+
+/*
+ * Built-in IRQ handlers for various IRQ types,
+ * callable via desc->chip->handle_irq()
+ */
+extern void fastcall
+handle_level_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
+extern void fastcall
+handle_fastack_irq(unsigned int irq, struct irq_desc *desc,
+			 struct pt_regs *regs);
+extern void fastcall
+handle_edge_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
+extern void fastcall
+handle_simple_irq(unsigned int irq, struct irq_desc *desc,
+		  struct pt_regs *regs);
+extern void fastcall
+handle_percpu_irq(unsigned int irq, struct irq_desc *desc,
+		  struct pt_regs *regs);
+extern void fastcall
+handle_bad_irq(unsigned int irq, struct irq_desc *desc, struct pt_regs *regs);
+
+/*
+ * Get a descriptive string for the highlevel handler, for
+ * /proc/interrupts output:
+ */
+extern const char *
+handle_irq_name(void fastcall (*handle)(unsigned int, struct irq_desc *,
+					struct pt_regs *));
+
 /*
- * Explicit fastcall, because i386 4KSTACKS calls it from assembly:
+ * Monolithic do_IRQ implementation.
+ * (is an explicit fastcall, because i386 4KSTACKS calls it from assembly)
  */
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
 
+/* Handling of unhandled and spurious interrupts: */
 extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   int action_ret, struct pt_regs *regs);
-extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 /* Resending of interrupts :*/
 void check_irq_resend(struct irq_desc *desc, unsigned int irq);
 
+/* Initialize /proc/irq/ */
 extern void init_irq_proc(void);
 
-#endif /* CONFIG_GENERIC_HARDIRQS */
+/* Enable/disable irq debugging output: */
+extern int noirqdebug_setup(char *str);
+
+/* Checks whether the interrupt can be requested by request_irq(): */
+extern int can_request_irq(unsigned int irq, unsigned long irqflags);
+
+/* Dummy irq-chip implementation: */
+extern struct irq_chip no_irq_chip;
+
+extern void
+set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
+			 void fastcall (*handle)(unsigned int,
+						 struct irq_desc *,
+						 struct pt_regs *));
+extern void
+__set_irq_handler(unsigned int irq,
+		  void fastcall (*handle)(unsigned int, struct irq_desc *,
+					  struct pt_regs *),
+		  int is_chained);
 
-extern hw_irq_controller no_irq_type;  /* needed in every arch ? */
+/*
+ * Set a highlevel flow handler for a given IRQ:
+ */
+static inline void
+set_irq_handler(unsigned int irq,
+		void fastcall (*handle)(unsigned int, struct irq_desc *,
+					struct pt_regs *))
+{
+	__set_irq_handler(irq, handle, 0);
+}
+
+/*
+ * Set a highlevel chained flow handler for a given IRQ.
+ * (a chained handler is automatically enabled and set to
+ *  IRQ_NOREQUEST and IRQ_NOPROBE)
+ */
+static inline void
+set_irq_chained_handler(unsigned int irq,
+			void fastcall (*handle)(unsigned int, struct irq_desc *,
+						struct pt_regs *))
+{
+	__set_irq_handler(irq, handle, 1);
+}
+
+#endif /* CONFIG_GENERIC_HARDIRQS */
 
 #endif /* !CONFIG_S390 */
 

commit 94d39e1f6e8132ea982a1d61acbe0423d3d14365
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:50 2006 -0700

    [PATCH] genirq: add IRQ_NOAUTOEN support
    
    Enable platforms to disable the automatic enabling of freshly set up irqs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1df49ec7f820..14d7e94048dd 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -42,6 +42,7 @@
 
 #define IRQ_NOPROBE	512	/* IRQ is not valid for probing */
 #define IRQ_NOREQUEST	1024	/* IRQ cannot be requested */
+#define IRQ_NOAUTOEN	2048	/* IRQ will not be enabled on request irq */
 /**
  * struct hw_interrupt_type - hardware interrupt type descriptor
  *

commit 6550c775cb5ee94c132d93d84de3bb23f0abf37b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:49 2006 -0700

    [PATCH] genirq: add IRQ_NOREQUEST support
    
    Enable platforms to disable request_irq() for certain interrupts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b2fcf330cf2e..1df49ec7f820 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -41,6 +41,7 @@
 #endif
 
 #define IRQ_NOPROBE	512	/* IRQ is not valid for probing */
+#define IRQ_NOREQUEST	1024	/* IRQ cannot be requested */
 /**
  * struct hw_interrupt_type - hardware interrupt type descriptor
  *

commit 3418d72404e35eb19e7995cbf3e7a76ba8fefbce
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:49 2006 -0700

    [PATCH] genirq: add IRQ_NOPROBE support
    
    Introduce IRQ_NOPROBE: enables platforms to control chip-probing.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9a39756bfd31..b2fcf330cf2e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -40,6 +40,7 @@
 # define CHECK_IRQ_PER_CPU(var) 0
 #endif
 
+#define IRQ_NOPROBE	512	/* IRQ is not valid for probing */
 /**
  * struct hw_interrupt_type - hardware interrupt type descriptor
  *

commit a4633adcdbc15ac51afcd0e1395de58cee27cf92
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 02:24:48 2006 -0700

    [PATCH] genirq: add genirq sw IRQ-retrigger
    
    Enable platforms that do not have a hardware-assisted hardirq-resend mechanism
    to resend them via a softirq-driven IRQ emulation mechanism.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b2688157b51b..9a39756bfd31 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -246,6 +246,9 @@ extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   int action_ret, struct pt_regs *regs);
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
+/* Resending of interrupts :*/
+void check_irq_resend(struct irq_desc *desc, unsigned int irq);
+
 extern void init_irq_proc(void);
 
 #endif /* CONFIG_GENERIC_HARDIRQS */

commit 8fee5c36177ee098fa41f5fe72999609fef4df6b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:45 2006 -0700

    [PATCH] genirq: doc: comment include/linux/irq.h structures
    
    Better document the hw_interrupt_type and irq_desc structures.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e58cfb9c66a3..b2688157b51b 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -40,9 +40,27 @@
 # define CHECK_IRQ_PER_CPU(var) 0
 #endif
 
-/*
- * Interrupt controller descriptor. This is all we need
- * to describe about the low-level hardware. 
+/**
+ * struct hw_interrupt_type - hardware interrupt type descriptor
+ *
+ * @name:		name for /proc/interrupts
+ * @startup:		start up the interrupt (defaults to ->enable if NULL)
+ * @shutdown:		shut down the interrupt (defaults to ->disable if NULL)
+ * @enable:		enable the interrupt (defaults to chip->unmask if NULL)
+ * @disable:		disable the interrupt (defaults to chip->mask if NULL)
+ * @handle_irq:		irq flow handler called from the arch IRQ glue code
+ * @ack:		start of a new interrupt
+ * @mask:		mask an interrupt source
+ * @mask_ack:		ack and mask an interrupt source
+ * @unmask:		unmask an interrupt source
+ * @hold:		same interrupt while the handler is running
+ * @end:		end of interrupt
+ * @set_affinity:	set the CPU affinity on SMP machines
+ * @retrigger:		resend an IRQ to the CPU
+ * @set_type:		set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
+ * @set_wake:		enable/disable power-management wake-on of an IRQ
+ *
+ * @release:		release function solely used by UML
  */
 struct hw_interrupt_type {
 	const char	*typename;
@@ -65,10 +83,22 @@ typedef struct hw_interrupt_type  hw_irq_controller;
 
 struct proc_dir_entry;
 
-/*
- * This is the "IRQ descriptor", which contains various information
- * about the irq, including what kind of hardware handling it has,
- * whether it is disabled etc etc.
+/**
+ * struct irq_desc - interrupt descriptor
+ *
+ * @handler:		interrupt type dependent handler functions
+ * @handler_data:	data for the type handlers
+ * @action:		the irq action chain
+ * @status:		status information
+ * @depth:		disable-depth, for nested irq_disable() calls
+ * @irq_count:		stats field to detect stalled irqs
+ * @irqs_unhandled:	stats field for spurious unhandled interrupts
+ * @lock:		locking for SMP
+ * @affinity:		IRQ affinity on SMP
+ * @pending_mask:	pending rebalanced interrupts
+ * @move_irq:		need to re-target IRQ destination
+ * @dir:		/proc/irq/ procfs entry
+ * @affinity_entry:	/proc/irq/smp_affinity procfs entry on SMP
  *
  * Pad this out to 32 bytes for cache and indexing reasons.
  */

commit c0ad90a32fb60f4129d0e24dfd5fd7128e2e09f2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:44 2006 -0700

    [PATCH] genirq: add ->retrigger() irq op to consolidate hw_irq_resend()
    
    Add ->retrigger() irq op to consolidate hw_irq_resend() implementations.
    (Most architectures had it defined to NOP anyway.)
    
    NOTE: ia64 needs testing. i386 and x86_64 tested.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 519a1cb7c331..e58cfb9c66a3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -53,6 +53,8 @@ struct hw_interrupt_type {
 	void		(*ack)(unsigned int irq);
 	void		(*end)(unsigned int irq);
 	void		(*set_affinity)(unsigned int irq, cpumask_t dest);
+	int		(*retrigger)(unsigned int irq);
+
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
 	void		(*release)(unsigned int irq, void *dev_id);

commit 0d7012a968d006e277eb0fe20edd7a9b5563c2b7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:43 2006 -0700

    [PATCH] genirq: cleanup: turn ARCH_HAS_IRQ_PER_CPU into CONFIG_IRQ_PER_CPU
    
    Cleanup: change ARCH_HAS_IRQ_PER_CPU into a Kconfig method.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 81f3d976bb32..519a1cb7c331 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -33,7 +33,7 @@
 #define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
 #define IRQ_LEVEL	64	/* IRQ level triggered */
 #define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
-#ifdef ARCH_HAS_IRQ_PER_CPU
+#ifdef CONFIG_IRQ_PER_CPU
 # define IRQ_PER_CPU	256	/* IRQ is per CPU */
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 #else

commit cd916d31cc31273eca8a620fae02b7bf7f577559
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:42 2006 -0700

    [PATCH] genirq: cleanup: merge pending_irq_cpumask[] into irq_desc[]
    
    Consolidation: remove the pending_irq_cpumask[NR_IRQS] array and move it into
    the irq_desc[NR_IRQS].pending_mask field.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 1022c5d42546..81f3d976bb32 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -83,6 +83,7 @@ struct irq_desc {
 	cpumask_t		affinity;
 #endif
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
+	cpumask_t		pending_mask;
 	unsigned int		move_irq;	/* need to re-target IRQ dest */
 #endif
 #ifdef CONFIG_PROC_FS
@@ -120,7 +121,6 @@ static inline void set_native_irq_info(int irq, cpumask_t mask)
 #ifdef CONFIG_SMP
 
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
-extern cpumask_t pending_irq_cpumask[NR_IRQS];
 
 void set_pending_irq(unsigned int irq, cpumask_t mask);
 void move_native_irq(int irq);

commit 4a733ee12618cf3ec25cbc337a5e0ba3ad5d7fb6
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:42 2006 -0700

    [PATCH] genirq: cleanup: merge irq_dir[], smp_affinity_entry[] into irq_desc[]
    
    Consolidation: remove the irq_dir[NR_IRQS] and the smp_affinity_entry[NR_IRQS]
    arrays and move them into the irq_desc[] array.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c13f23dee286..1022c5d42546 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -61,6 +61,8 @@ struct hw_interrupt_type {
 
 typedef struct hw_interrupt_type  hw_irq_controller;
 
+struct proc_dir_entry;
+
 /*
  * This is the "IRQ descriptor", which contains various information
  * about the irq, including what kind of hardware handling it has,
@@ -83,6 +85,9 @@ struct irq_desc {
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 	unsigned int		move_irq;	/* need to re-target IRQ dest */
 #endif
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *dir;
+#endif
 } ____cacheline_aligned;
 
 extern struct irq_desc irq_desc[NR_IRQS];

commit 71d218b75fa91219c6bd310fbdd257dfbcac6c88
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:41 2006 -0700

    [PATCH] genirq: cleanup: include/linux/irq.h
    
    Small cleanups in include/linux/irq.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9ce276a2374a..c13f23dee286 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -45,17 +45,17 @@
  * to describe about the low-level hardware. 
  */
 struct hw_interrupt_type {
-	const char *typename;
-	unsigned int (*startup)(unsigned int irq);
-	void (*shutdown)(unsigned int irq);
-	void (*enable)(unsigned int irq);
-	void (*disable)(unsigned int irq);
-	void (*ack)(unsigned int irq);
-	void (*end)(unsigned int irq);
-	void (*set_affinity)(unsigned int irq, cpumask_t dest);
+	const char	*typename;
+	unsigned int	(*startup)(unsigned int irq);
+	void		(*shutdown)(unsigned int irq);
+	void		(*enable)(unsigned int irq);
+	void		(*disable)(unsigned int irq);
+	void		(*ack)(unsigned int irq);
+	void		(*end)(unsigned int irq);
+	void		(*set_affinity)(unsigned int irq, cpumask_t dest);
 	/* Currently used only by UML, might disappear one day.*/
 #ifdef CONFIG_IRQ_RELEASE_METHOD
-	void (*release)(unsigned int irq, void *dev_id);
+	void		(*release)(unsigned int irq, void *dev_id);
 #endif
 };
 
@@ -69,19 +69,19 @@ typedef struct hw_interrupt_type  hw_irq_controller;
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
 struct irq_desc {
-	hw_irq_controller *chip;
-	void *chip_data;
-	struct irqaction *action;	/* IRQ action list */
-	unsigned int status;		/* IRQ status */
-	unsigned int depth;		/* nested irq disables */
-	unsigned int irq_count;		/* For detecting broken interrupts */
-	unsigned int irqs_unhandled;
-	spinlock_t lock;
+	hw_irq_controller	*chip;
+	void			*chip_data;
+	struct irqaction	*action;	/* IRQ action list */
+	unsigned int		status;		/* IRQ status */
+	unsigned int		depth;		/* nested irq disables */
+	unsigned int		irq_count;	/* For detecting broken IRQs */
+	unsigned int		irqs_unhandled;
+	spinlock_t		lock;
 #ifdef CONFIG_SMP
-	cpumask_t affinity;
+	cpumask_t		affinity;
 #endif
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
-	unsigned int move_irq;		/* Flag need to re-target intr dest*/
+	unsigned int		move_irq;	/* need to re-target IRQ dest */
 #endif
 } ____cacheline_aligned;
 
@@ -186,6 +186,15 @@ static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
 }
 #endif
 
+#ifdef CONFIG_AUTO_IRQ_AFFINITY
+extern int select_smp_affinity(unsigned int irq);
+#else
+static inline int select_smp_affinity(unsigned int irq)
+{
+	return 1;
+}
+#endif
+
 extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 
@@ -202,15 +211,6 @@ extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 extern void init_irq_proc(void);
 
-#ifdef CONFIG_AUTO_IRQ_AFFINITY
-extern int select_smp_affinity(unsigned int irq);
-#else
-static inline int select_smp_affinity(unsigned int irq)
-{
-	return 1;
-}
-#endif
-
 #endif /* CONFIG_GENERIC_HARDIRQS */
 
 extern hw_irq_controller no_irq_type;  /* needed in every arch ? */

commit 34ffdb7233d5847808d2b63ca6761dac3af9c942
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:40 2006 -0700

    [PATCH] genirq: cleanup: reduce irq_desc_t use, mark it obsolete
    
    Cleanup: remove irq_desc_t use from the generic IRQ code, and mark it
    obsolete.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 92c685414622..9ce276a2374a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -68,7 +68,7 @@ typedef struct hw_interrupt_type  hw_irq_controller;
  *
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
-typedef struct irq_desc {
+struct irq_desc {
 	hw_irq_controller *chip;
 	void *chip_data;
 	struct irqaction *action;	/* IRQ action list */
@@ -83,11 +83,19 @@ typedef struct irq_desc {
 #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 	unsigned int move_irq;		/* Flag need to re-target intr dest*/
 #endif
-} ____cacheline_aligned irq_desc_t;
+} ____cacheline_aligned;
 
-extern irq_desc_t irq_desc [NR_IRQS];
+extern struct irq_desc irq_desc[NR_IRQS];
 
-#include <asm/hw_irq.h> /* the arch dependent stuff */
+/*
+ * Migration helpers for obsolete names, they will go away:
+ */
+typedef struct irq_desc		irq_desc_t;
+
+/*
+ * Pick up the arch-dependent methods:
+ */
+#include <asm/hw_irq.h>
 
 extern int setup_irq(unsigned int irq, struct irqaction *new);
 
@@ -188,7 +196,7 @@ extern irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
  */
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
 
-extern void note_interrupt(unsigned int irq, irq_desc_t *desc,
+extern void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			   int action_ret, struct pt_regs *regs);
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 

commit 06fcb0c6fb3aae9570a32ac3b72a8222563baa69
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:40 2006 -0700

    [PATCH] genirq: cleanup: misc code cleanups
    
    Assorted code cleanups to the generic IRQ code.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index eac1273dc4e1..92c685414622 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -1,5 +1,5 @@
-#ifndef __irq_h
-#define __irq_h
+#ifndef _LINUX_IRQ_H
+#define _LINUX_IRQ_H
 
 /*
  * Please do not include this file in generic code.  There is currently
@@ -11,7 +11,7 @@
 
 #include <linux/smp.h>
 
-#if !defined(CONFIG_S390)
+#ifndef CONFIG_S390
 
 #include <linux/linkage.h>
 #include <linux/cache.h>
@@ -33,7 +33,7 @@
 #define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
 #define IRQ_LEVEL	64	/* IRQ level triggered */
 #define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
-#if defined(ARCH_HAS_IRQ_PER_CPU)
+#ifdef ARCH_HAS_IRQ_PER_CPU
 # define IRQ_PER_CPU	256	/* IRQ is per CPU */
 # define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
 #else
@@ -45,7 +45,7 @@
  * to describe about the low-level hardware. 
  */
 struct hw_interrupt_type {
-	const char * typename;
+	const char *typename;
 	unsigned int (*startup)(unsigned int irq);
 	void (*shutdown)(unsigned int irq);
 	void (*enable)(unsigned int irq);
@@ -80,7 +80,7 @@ typedef struct irq_desc {
 #ifdef CONFIG_SMP
 	cpumask_t affinity;
 #endif
-#if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
+#if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 	unsigned int move_irq;		/* Flag need to re-target intr dest*/
 #endif
 } ____cacheline_aligned irq_desc_t;
@@ -89,9 +89,10 @@ extern irq_desc_t irq_desc [NR_IRQS];
 
 #include <asm/hw_irq.h> /* the arch dependent stuff */
 
-extern int setup_irq(unsigned int irq, struct irqaction * new);
+extern int setup_irq(unsigned int irq, struct irqaction *new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
+
 #ifdef CONFIG_SMP
 static inline void set_native_irq_info(int irq, cpumask_t mask)
 {
@@ -105,7 +106,7 @@ static inline void set_native_irq_info(int irq, cpumask_t mask)
 
 #ifdef CONFIG_SMP
 
-#if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
+#if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
 extern cpumask_t pending_irq_cpumask[NR_IRQS];
 
 void set_pending_irq(unsigned int irq, cpumask_t mask);
@@ -127,7 +128,7 @@ static inline void set_irq_info(int irq, cpumask_t mask)
 {
 }
 
-#else // CONFIG_PCI_MSI
+#else /* CONFIG_PCI_MSI */
 
 static inline void move_irq(int irq)
 {
@@ -138,26 +139,36 @@ static inline void set_irq_info(int irq, cpumask_t mask)
 {
 	set_native_irq_info(irq, mask);
 }
-#endif // CONFIG_PCI_MSI
 
-#else	// CONFIG_GENERIC_PENDING_IRQ || CONFIG_IRQBALANCE
+#endif /* CONFIG_PCI_MSI */
+
+#else /* CONFIG_GENERIC_PENDING_IRQ || CONFIG_IRQBALANCE */
+
+static inline void move_irq(int irq)
+{
+}
+
+static inline void move_native_irq(int irq)
+{
+}
+
+static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
+{
+}
 
-#define move_irq(x)
-#define move_native_irq(x)
-#define set_pending_irq(x,y)
 static inline void set_irq_info(int irq, cpumask_t mask)
 {
 	set_native_irq_info(irq, mask);
 }
 
-#endif // CONFIG_GENERIC_PENDING_IRQ
+#endif /* CONFIG_GENERIC_PENDING_IRQ */
 
-#else // CONFIG_SMP
+#else /* CONFIG_SMP */
 
 #define move_irq(x)
 #define move_native_irq(x)
 
-#endif // CONFIG_SMP
+#endif /* CONFIG_SMP */
 
 #ifdef CONFIG_IRQBALANCE
 extern void set_balance_irq_affinity(unsigned int irq, cpumask_t mask);
@@ -186,17 +197,16 @@ extern void init_irq_proc(void);
 #ifdef CONFIG_AUTO_IRQ_AFFINITY
 extern int select_smp_affinity(unsigned int irq);
 #else
-static inline int
-select_smp_affinity(unsigned int irq)
+static inline int select_smp_affinity(unsigned int irq)
 {
 	return 1;
 }
 #endif
 
-#endif
+#endif /* CONFIG_GENERIC_HARDIRQS */
 
 extern hw_irq_controller no_irq_type;  /* needed in every arch ? */
 
-#endif
+#endif /* !CONFIG_S390 */
 
-#endif /* __irq_h */
+#endif /* _LINUX_IRQ_H */

commit 2e60bbb6d50de654d8e68f115161e27878b5e72d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:39 2006 -0700

    [PATCH] genirq: cleanup: remove fastcall
    
    Now that i386 defaults to regparm, explicit uses of fastcall are not needed
    anymore.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 80713d6e8c8d..eac1273dc4e1 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -170,11 +170,15 @@ static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
 extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 
-extern fastcall irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
-					struct irqaction *action);
+extern irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
+				    struct irqaction *action);
+/*
+ * Explicit fastcall, because i386 4KSTACKS calls it from assembly:
+ */
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
+
 extern void note_interrupt(unsigned int irq, irq_desc_t *desc,
-					int action_ret, struct pt_regs *regs);
+			   int action_ret, struct pt_regs *regs);
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 extern void init_irq_proc(void);

commit a8553acd6c14e827078779c0a0ee1c18f27b2403
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:38 2006 -0700

    [PATCH] genirq: cleanup: remove irq_descp()
    
    Cleanup: remove irq_descp() - explicit use of irq_desc[] is shorter and more
    readable.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6e3ad6245bd3..80713d6e8c8d 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -87,13 +87,6 @@ typedef struct irq_desc {
 
 extern irq_desc_t irq_desc [NR_IRQS];
 
-/* Return a pointer to the irq descriptor for IRQ.  */
-static inline irq_desc_t *
-irq_descp (int irq)
-{
-	return irq_desc + irq;
-}
-
 #include <asm/hw_irq.h> /* the arch dependent stuff */
 
 extern int setup_irq(unsigned int irq, struct irqaction * new);

commit a53da52fd743fd637637572838c0a7af23a2d038
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:38 2006 -0700

    [PATCH] genirq: cleanup: merge irq_affinity[] into irq_desc[]
    
    Consolidation: remove the irq_affinity[NR_IRQS] array and move it into the
    irq_desc[NR_IRQS].affinity field.
    
    [akpm@osdl.org: sparc64 build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 9597a6904239..6e3ad6245bd3 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -77,6 +77,9 @@ typedef struct irq_desc {
 	unsigned int irq_count;		/* For detecting broken interrupts */
 	unsigned int irqs_unhandled;
 	spinlock_t lock;
+#ifdef CONFIG_SMP
+	cpumask_t affinity;
+#endif
 #if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
 	unsigned int move_irq;		/* Flag need to re-target intr dest*/
 #endif
@@ -96,12 +99,10 @@ irq_descp (int irq)
 extern int setup_irq(unsigned int irq, struct irqaction * new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
-extern cpumask_t irq_affinity[NR_IRQS];
-
 #ifdef CONFIG_SMP
 static inline void set_native_irq_info(int irq, cpumask_t mask)
 {
-	irq_affinity[irq] = mask;
+	irq_desc[irq].affinity = mask;
 }
 #else
 static inline void set_native_irq_info(int irq, cpumask_t mask)

commit d1bef4ed5faf7d9872337b33c4269e45ae1bf960
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:36 2006 -0700

    [PATCH] genirq: rename desc->handler to desc->chip
    
    This patch-queue improves the generic IRQ layer to be truly generic, by adding
    various abstractions and features to it, without impacting existing
    functionality.
    
    While the queue can be best described as "fix and improve everything in the
    generic IRQ layer that we could think of", and thus it consists of many
    smaller features and lots of cleanups, the one feature that stands out most is
    the new 'irq chip' abstraction.
    
    The irq-chip abstraction is about describing and coding and IRQ controller
    driver by mapping its raw hardware capabilities [and quirks, if needed] in a
    straightforward way, without having to think about "IRQ flow"
    (level/edge/etc.) type of details.
    
    This stands in contrast with the current 'irq-type' model of genirq
    architectures, which 'mixes' raw hardware capabilities with 'flow' details.
    The patchset supports both types of irq controller designs at once, and
    converts i386 and x86_64 to the new irq-chip design.
    
    As a bonus side-effect of the irq-chip approach, chained interrupt controllers
    (master/slave PIC constructs, etc.) are now supported by design as well.
    
    The end result of this patchset intends to be simpler architecture-level code
    and more consolidation between architectures.
    
    We reused many bits of code and many concepts from Russell King's ARM IRQ
    layer, the merging of which was one of the motivations for this patchset.
    
    This patch:
    
    rename desc->handler to desc->chip.
    
    Originally i did not want to do this, because it's a big patch.  But having
    both "desc->handler", "desc->handle_irq" and "action->handler" caused a
    large degree of confusion and made the code appear alot less clean than it
    truly is.
    
    I have also attempted a dual approach as well by introducing a
    desc->chip alias - but that just wasnt robust enough and broke
    frequently.
    
    So lets get over with this quickly.  The conversion was done automatically
    via scripts and converts all the code in the kernel.
    
    This renaming patch is the first one amongst the patches, so that the
    remaining patches can stay flexible and can be merged and split up
    without having some big monolithic patch act as a merge barrier.
    
    [akpm@osdl.org: build fix]
    [akpm@osdl.org: another build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 676e00dfb21a..9597a6904239 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -69,8 +69,8 @@ typedef struct hw_interrupt_type  hw_irq_controller;
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
 typedef struct irq_desc {
-	hw_irq_controller *handler;
-	void *handler_data;
+	hw_irq_controller *chip;
+	void *chip_data;
 	struct irqaction *action;	/* IRQ action list */
 	unsigned int status;		/* IRQ status */
 	unsigned int depth;		/* nested irq disables */

commit 908dcecda1d18803b5823f30e6c47d2882dc0cf1
Author: Jan Beulich <jbeulich@novell.com>
Date:   Fri Jun 23 02:06:00 2006 -0700

    [PATCH] adjust handle_IRR_event() return type
    
    Correct the return type of handle_IRQ_event() (inconsistency noticed during
    Xen development), and remove redundant declarations.  The return type
    adjustment required breaking out the definition of irqreturn_t into a
    separate header, in order to satisfy current include order dependencies.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index e8a07e75e4fb..676e00dfb21a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -17,6 +17,7 @@
 #include <linux/cache.h>
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
+#include <linux/irqreturn.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
@@ -175,7 +176,7 @@ static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
 extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 
-extern fastcall int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
+extern fastcall irqreturn_t handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 					struct irqaction *action);
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
 extern void note_interrupt(unsigned int irq, irq_desc_t *desc,

commit 1b61b910e99059abdd54c93aa70e84e076e33d16
Author: Zhang Yanmin <yanmin.zhang@intel.com>
Date:   Fri Jun 23 02:04:22 2006 -0700

    [PATCH] x86: kernel irq balance doesn't work
    
    On i386, kernel irq balance doesn't work.
    
    1) In function do_irq_balance, after kernel finds the min_loaded cpu but
       before calling set_pending_irq to really pin the selected_irq to the
       target cpu, kernel does a cpus_and with irq_affinity[selected_irq].
       Later on, when the irq is acked, kernel would calls
       move_native_irq=>desc->handler->set_affinity to change the irq affinity.
        However, every function pointed by
       hw_interrupt_type->set_affinity(unsigned int irq, cpumask_t cpumask)
       always changes irq_affinity[irq] to cpumask.  Next time when recalling
       do_irq_balance, it has to do cpu_ands again with
       irq_affinity[selected_irq], but irq_affinity[selected_irq] already
       becomes one cpu selected by the first irq balance.
    
    2) Function balance_irq in file arch/i386/kernel/io_apic.c has the same
       issue.
    
    [akpm@osdl.org: cleanups]
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 42c9cd562860..e8a07e75e4fb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -164,6 +164,14 @@ static inline void set_irq_info(int irq, cpumask_t mask)
 
 #endif // CONFIG_SMP
 
+#ifdef CONFIG_IRQBALANCE
+extern void set_balance_irq_affinity(unsigned int irq, cpumask_t mask);
+#else
+static inline void set_balance_irq_affinity(unsigned int irq, cpumask_t mask)
+{
+}
+#endif
+
 extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index ee2a82a572f7..42c9cd562860 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -9,7 +9,6 @@
  * Thanks. --rmk
  */
 
-#include <linux/config.h>
 #include <linux/smp.h>
 
 #if !defined(CONFIG_S390)

commit c777ac5594f772ac760e02c3ac71d067616b579d
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Mar 25 03:07:36 2006 -0800

    [PATCH] irq: uninline migration functions
    
    Uninline some massive IRQ migration functions.  Put them in the new
    kernel/irq/migration.c.
    
    Cc: Andi Kleen <ak@muc.de>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 6c5d4c898ccb..ee2a82a572f7 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -114,53 +114,8 @@ static inline void set_native_irq_info(int irq, cpumask_t mask)
 #if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
 extern cpumask_t pending_irq_cpumask[NR_IRQS];
 
-static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
-{
-	irq_desc_t *desc = irq_desc + irq;
-	unsigned long flags;
-
-	spin_lock_irqsave(&desc->lock, flags);
-	desc->move_irq = 1;
-	pending_irq_cpumask[irq] = mask;
-	spin_unlock_irqrestore(&desc->lock, flags);
-}
-
-static inline void
-move_native_irq(int irq)
-{
-	cpumask_t tmp;
-	irq_desc_t *desc = irq_descp(irq);
-
-	if (likely (!desc->move_irq))
-		return;
-
-	desc->move_irq = 0;
-
-	if (likely(cpus_empty(pending_irq_cpumask[irq])))
-		return;
-
-	if (!desc->handler->set_affinity)
-		return;
-
-	/* note - we hold the desc->lock */
-	cpus_and(tmp, pending_irq_cpumask[irq], cpu_online_map);
-
-	/*
-	 * If there was a valid mask to work with, please
-	 * do the disable, re-program, enable sequence.
-	 * This is *not* particularly important for level triggered
-	 * but in a edge trigger case, we might be setting rte
-	 * when an active trigger is comming in. This could
-	 * cause some ioapics to mal-function.
-	 * Being paranoid i guess!
-	 */
-	if (unlikely(!cpus_empty(tmp))) {
-		desc->handler->disable(irq);
-		desc->handler->set_affinity(irq,tmp);
-		desc->handler->enable(irq);
-	}
-	cpus_clear(pending_irq_cpumask[irq]);
-}
+void set_pending_irq(unsigned int irq, cpumask_t mask);
+void move_native_irq(int irq);
 
 #ifdef CONFIG_PCI_MSI
 /*

commit 347a8dc3b815f0c0fa62a1df075184ffe4cbdcf1
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Jan 6 00:19:28 2006 -0800

    [PATCH] s390: cleanup Kconfig
    
    Sanitize some s390 Kconfig options.  We have ARCH_S390, ARCH_S390X,
    ARCH_S390_31, 64BIT, S390_SUPPORT and COMPAT.  Replace these 6 options by
    S390, 64BIT and COMPAT.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 60f8bc78a35a..6c5d4c898ccb 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -12,7 +12,7 @@
 #include <linux/config.h>
 #include <linux/smp.h>
 
-#if !defined(CONFIG_ARCH_S390)
+#if !defined(CONFIG_S390)
 
 #include <linux/linkage.h>
 #include <linux/cache.h>

commit eee45269b0f5979c70bc151c6c2f4e5f4f5ababe
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Fri Jan 6 00:12:21 2006 -0800

    [PATCH] Alpha: convert to generic irq framework (generic part)
    
    Thanks to Christoph for doing most of the work.
    
    This allows automatic SMP IRQ affinity assignment other than default "all
    interrupts on all CPUs" which is rather expensive.  This might be useful if
    the hardware can be programmed to distribute interrupts among different
    CPUs, like Alpha does.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index f04ba20712a2..60f8bc78a35a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -221,6 +221,17 @@ extern void note_interrupt(unsigned int irq, irq_desc_t *desc,
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 extern void init_irq_proc(void);
+
+#ifdef CONFIG_AUTO_IRQ_AFFINITY
+extern int select_smp_affinity(unsigned int irq);
+#else
+static inline int
+select_smp_affinity(unsigned int irq)
+{
+	return 1;
+}
+#endif
+
 #endif
 
 extern hw_irq_controller no_irq_type;  /* needed in every arch ? */

commit 23f9b317e0ba4fbc5fc9524275d0105fa87e2027
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed Dec 21 02:27:50 2005 +0100

    [PATCH] include/linux/irq.h: #include <linux/smp.h>
    
    Jan's crosscompile page [1] shows, that one regression in 2.6.15-rc is
    that the v850 defconfig does no longer compile.
    
    The compile error is:
    
    <--  snip  -->
    
    ...
      CC      arch/v850/kernel/setup.o
    In file included from /usr/src/ctest/rc/kernel/arch/v850/kernel/setup.c:17:
    /usr/src/ctest/rc/kernel/include/linux/irq.h:13:43: asm/smp.h: No such file or directory
    make[2]: *** [arch/v850/kernel/setup.o] Error 1
    
    <--  snip  -->
    
    The #include <asm/smp.h> in irq.h was intruduced in 2.6.15-rc.
    
    Since include/linux/irq.h needs code from asm/smp.h only in the
    CONFIG_SMP=y case and linux/smp.h #include's asm/smp.h only in the
    CONFIG_SMP=y case, I'm suggesting this patch to #include <linux/smp.h>
    in irq.h.
    
    I've tested the compilation with both CONFIG_SMP=y and CONFIG_SMP=n
    on i386.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c516382fbec2..f04ba20712a2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -10,7 +10,7 @@
  */
 
 #include <linux/config.h>
-#include <asm/smp.h>		/* cpu_online_map */
+#include <linux/smp.h>
 
 #if !defined(CONFIG_ARCH_S390)
 

commit 8c65b4a60450590e79a28e9717ceffa9e4debb3f
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Mon Nov 7 00:59:43 2005 -0800

    [PATCH] fix remaining missing includes
    
    Fix more include file problems that surfaced since I submitted the previous
    fix-missing-includes.patch.  This should now allow not to include sched.h
    from module.h, which is done by a followup patch.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 69681c3b1f05..c516382fbec2 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -10,6 +10,7 @@
  */
 
 #include <linux/config.h>
+#include <asm/smp.h>		/* cpu_online_map */
 
 #if !defined(CONFIG_ARCH_S390)
 

commit f26fdd59929e1144c6caf72adcaf4561d6e682a4
Author: Karsten Wiese <annabellesgarden@yahoo.de>
Date:   Tue Sep 6 15:17:25 2005 -0700

    [PATCH] CHECK_IRQ_PER_CPU() to avoid dead code in __do_IRQ()
    
    IRQ_PER_CPU is not used by all architectures.  This patch introduces the
    macros ARCH_HAS_IRQ_PER_CPU and CHECK_IRQ_PER_CPU() to avoid the generation
    of dead code in __do_IRQ().
    
    ARCH_HAS_IRQ_PER_CPU is defined by architectures using IRQ_PER_CPU in their
    include/asm_ARCH/irq.h file.
    
    Through grepping the tree I found the following architectures currently use
    IRQ_PER_CPU:
    
            cris, ia64, ppc, ppc64 and parisc.
    
    Signed-off-by: Karsten Wiese <annabellesgarden@yahoo.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 4a362b9ec966..69681c3b1f05 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -32,7 +32,12 @@
 #define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
 #define IRQ_LEVEL	64	/* IRQ level triggered */
 #define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
-#define IRQ_PER_CPU	256	/* IRQ is per CPU */
+#if defined(ARCH_HAS_IRQ_PER_CPU)
+# define IRQ_PER_CPU	256	/* IRQ is per CPU */
+# define CHECK_IRQ_PER_CPU(var) ((var) & IRQ_PER_CPU)
+#else
+# define CHECK_IRQ_PER_CPU(var) 0
+#endif
 
 /*
  * Interrupt controller descriptor. This is all we need

commit 54d5d42404e7705cf3804593189e963350d470e5
Author: Ashok Raj <ashok.raj@intel.com>
Date:   Tue Sep 6 15:16:15 2005 -0700

    [PATCH] x86/x86_64: deferred handling of writes to /proc/irqxx/smp_affinity
    
    When handling writes to /proc/irq, current code is re-programming rte
    entries directly. This is not recommended and could potentially cause
    chipset's to lockup, or cause missing interrupts.
    
    CONFIG_IRQ_BALANCE does this correctly, where it re-programs only when the
    interrupt is pending. The same needs to be done for /proc/irq handling as well.
    Otherwise user space irq balancers are really not doing the right thing.
    
    - Changed pending_irq_balance_cpumask to pending_irq_migrate_cpumask for
      lack of a generic name.
    - added move_irq out of IRQ_BALANCE, and added this same to X86_64
    - Added new proc handler for write, so we can do deferred write at irq
      handling time.
    - Display of /proc/irq/XX/smp_affinity used to display CPU_MASKALL, instead
      it now shows only active cpu masks, or exactly what was set.
    - Provided a common move_irq implementation, instead of duplicating
      when using generic irq framework.
    
    Tested on i386/x86_64 and ia64 with CONFIG_PCI_MSI turned on and off.
    Tested UP builds as well.
    
    MSI testing: tbd: I have cards, need to look for a x-over cable, although I
    did test an earlier version of this patch.  Will test in a couple days.
    
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Acked-by: Zwane Mwaikambo <zwane@holomorphy.com>
    Grudgingly-acked-by: Andi Kleen <ak@muc.de>
    Signed-off-by: Coywolf Qi Hunt <coywolf@lovecn.org>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 069d3b84d311..4a362b9ec966 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -71,16 +71,139 @@ typedef struct irq_desc {
 	unsigned int irq_count;		/* For detecting broken interrupts */
 	unsigned int irqs_unhandled;
 	spinlock_t lock;
+#if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
+	unsigned int move_irq;		/* Flag need to re-target intr dest*/
+#endif
 } ____cacheline_aligned irq_desc_t;
 
 extern irq_desc_t irq_desc [NR_IRQS];
 
+/* Return a pointer to the irq descriptor for IRQ.  */
+static inline irq_desc_t *
+irq_descp (int irq)
+{
+	return irq_desc + irq;
+}
+
 #include <asm/hw_irq.h> /* the arch dependent stuff */
 
 extern int setup_irq(unsigned int irq, struct irqaction * new);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 extern cpumask_t irq_affinity[NR_IRQS];
+
+#ifdef CONFIG_SMP
+static inline void set_native_irq_info(int irq, cpumask_t mask)
+{
+	irq_affinity[irq] = mask;
+}
+#else
+static inline void set_native_irq_info(int irq, cpumask_t mask)
+{
+}
+#endif
+
+#ifdef CONFIG_SMP
+
+#if defined (CONFIG_GENERIC_PENDING_IRQ) || defined (CONFIG_IRQBALANCE)
+extern cpumask_t pending_irq_cpumask[NR_IRQS];
+
+static inline void set_pending_irq(unsigned int irq, cpumask_t mask)
+{
+	irq_desc_t *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	desc->move_irq = 1;
+	pending_irq_cpumask[irq] = mask;
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+static inline void
+move_native_irq(int irq)
+{
+	cpumask_t tmp;
+	irq_desc_t *desc = irq_descp(irq);
+
+	if (likely (!desc->move_irq))
+		return;
+
+	desc->move_irq = 0;
+
+	if (likely(cpus_empty(pending_irq_cpumask[irq])))
+		return;
+
+	if (!desc->handler->set_affinity)
+		return;
+
+	/* note - we hold the desc->lock */
+	cpus_and(tmp, pending_irq_cpumask[irq], cpu_online_map);
+
+	/*
+	 * If there was a valid mask to work with, please
+	 * do the disable, re-program, enable sequence.
+	 * This is *not* particularly important for level triggered
+	 * but in a edge trigger case, we might be setting rte
+	 * when an active trigger is comming in. This could
+	 * cause some ioapics to mal-function.
+	 * Being paranoid i guess!
+	 */
+	if (unlikely(!cpus_empty(tmp))) {
+		desc->handler->disable(irq);
+		desc->handler->set_affinity(irq,tmp);
+		desc->handler->enable(irq);
+	}
+	cpus_clear(pending_irq_cpumask[irq]);
+}
+
+#ifdef CONFIG_PCI_MSI
+/*
+ * Wonder why these are dummies?
+ * For e.g the set_ioapic_affinity_vector() calls the set_ioapic_affinity_irq()
+ * counter part after translating the vector to irq info. We need to perform
+ * this operation on the real irq, when we dont use vector, i.e when
+ * pci_use_vector() is false.
+ */
+static inline void move_irq(int irq)
+{
+}
+
+static inline void set_irq_info(int irq, cpumask_t mask)
+{
+}
+
+#else // CONFIG_PCI_MSI
+
+static inline void move_irq(int irq)
+{
+	move_native_irq(irq);
+}
+
+static inline void set_irq_info(int irq, cpumask_t mask)
+{
+	set_native_irq_info(irq, mask);
+}
+#endif // CONFIG_PCI_MSI
+
+#else	// CONFIG_GENERIC_PENDING_IRQ || CONFIG_IRQBALANCE
+
+#define move_irq(x)
+#define move_native_irq(x)
+#define set_pending_irq(x,y)
+static inline void set_irq_info(int irq, cpumask_t mask)
+{
+	set_native_irq_info(irq, mask);
+}
+
+#endif // CONFIG_GENERIC_PENDING_IRQ
+
+#else // CONFIG_SMP
+
+#define move_irq(x)
+#define move_native_irq(x)
+
+#endif // CONFIG_SMP
+
 extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 

commit 200803dfe4ff772740d63db725ab2f1b185ccf92
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jun 28 20:45:18 2005 -0700

    [PATCH] irqpoll
    
    Anyone reporting a stuck IRQ should try these options.  Its effectiveness
    varies we've found in the Fedora case.  Quite a few systems with misdescribed
    IRQ routing just work when you use irqpoll.  It also fixes up the VIA systems
    although thats now fixed with the VIA quirk (which we could just make default
    as its what Redmond OS does but Linus didn't like it historically).
    
    A small number of systems have jammed IRQ sources or misdescribes that cause
    an IRQ that we have no handler registered anywhere for.  In those cases it
    doesn't help.
    
    Signed-off-by: Alan Cox <number6@the-village.bc.nu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 12277799c007..069d3b84d311 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -85,9 +85,10 @@ extern int no_irq_affinity;
 extern int noirqdebug_setup(char *str);
 
 extern fastcall int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
-				       struct irqaction *action);
+					struct irqaction *action);
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
-extern void note_interrupt(unsigned int irq, irq_desc_t *desc, int action_ret);
+extern void note_interrupt(unsigned int irq, irq_desc_t *desc,
+					int action_ret, struct pt_regs *regs);
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 extern void init_irq_proc(void);

commit 52c1da39534fb382c061de58b65f678ad74b59f5
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 23 22:05:33 2005 -0700

    [PATCH] make various thing static
    
    Another rollup of patches which give various symbols static scope
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index 7fc1022be9ee..12277799c007 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -88,7 +88,6 @@ extern fastcall int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
 				       struct irqaction *action);
 extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
 extern void note_interrupt(unsigned int irq, irq_desc_t *desc, int action_ret);
-extern void report_bad_irq(unsigned int irq, irq_desc_t *desc, int action_ret);
 extern int can_request_irq(unsigned int irq, unsigned long irqflags);
 
 extern void init_irq_proc(void);

commit b77d6adc922b8bbf8b16b67f567958c42962cf88
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Tue Jun 21 17:16:24 2005 -0700

    [PATCH] uml: make hw_controller_type->release exist only for archs needing it
    
    With Chris Wedgwood <cw@f00f.org>
    
    As suggested by Chris, we can make the "just added" method ->release
    conditional to UML only (better: to archs requesting it, i.e.  only UML
    currently), so that other archs don't get this unneeded crud, and if UML
    won't need it any more we can kill this.
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    CC: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index b68ad80e2464..7fc1022be9ee 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -47,7 +47,10 @@ struct hw_interrupt_type {
 	void (*ack)(unsigned int irq);
 	void (*end)(unsigned int irq);
 	void (*set_affinity)(unsigned int irq, cpumask_t dest);
+	/* Currently used only by UML, might disappear one day.*/
+#ifdef CONFIG_IRQ_RELEASE_METHOD
 	void (*release)(unsigned int irq, void *dev_id);
+#endif
 };
 
 typedef struct hw_interrupt_type  hw_irq_controller;

commit dbce706e2550253c5ab6043f4f5dfde0cd02470f
Author: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
Date:   Tue Jun 21 17:16:19 2005 -0700

    [PATCH] uml: add and use generic hw_controller_type->release
    
    With Chris Wedgwood <cw@f00f.org>
    
    Currently UML must explicitly call the UML-specific
    free_irq_by_irq_and_dev() for each free_irq call it's done.
    
    This is needed because ->shutdown and/or ->disable are only called when the
    last "action" for that irq is removed.
    
    Instead, for UML shared IRQs (UML IRQs are very often, if not always,
    shared), for each dev_id some setup is done, which must be cleared on the
    release of that fd.  For instance, for each open console a new instance
    (i.e.  new dev_id) of the same IRQ is requested().
    
    Exactly, a fd is stored in an array (pollfds), which is after read by a
    host thread and passed to poll().  Each event registered by poll() triggers
    an interrupt.  So, for each free_irq() we must remove the corresponding
    host fd from the table, which we do via this -release() method.
    
    In this patch we add an appropriate hook for this, and remove all uses of
    it by pointing the hook to the said procedure; this is safe to do since the
    said procedure.
    
    Also some cosmetic improvements are included.
    
    This is heavily based on some work by Chris Wedgwood, which however didn't
    get the patch merged for something I'd call a "misunderstanding" (the need
    for this patch wasn't cleanly explained, thus adding the generic hook was
    felt as undesirable).
    
    Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    CC: Ingo Molnar <mingo@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/irq.h b/include/linux/irq.h
index c3ff4d101667..b68ad80e2464 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -47,6 +47,7 @@ struct hw_interrupt_type {
 	void (*ack)(unsigned int irq);
 	void (*end)(unsigned int irq);
 	void (*set_affinity)(unsigned int irq, cpumask_t dest);
+	void (*release)(unsigned int irq, void *dev_id);
 };
 
 typedef struct hw_interrupt_type  hw_irq_controller;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/irq.h b/include/linux/irq.h
new file mode 100644
index 000000000000..c3ff4d101667
--- /dev/null
+++ b/include/linux/irq.h
@@ -0,0 +1,97 @@
+#ifndef __irq_h
+#define __irq_h
+
+/*
+ * Please do not include this file in generic code.  There is currently
+ * no requirement for any architecture to implement anything held
+ * within this file.
+ *
+ * Thanks. --rmk
+ */
+
+#include <linux/config.h>
+
+#if !defined(CONFIG_ARCH_S390)
+
+#include <linux/linkage.h>
+#include <linux/cache.h>
+#include <linux/spinlock.h>
+#include <linux/cpumask.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+
+/*
+ * IRQ line status.
+ */
+#define IRQ_INPROGRESS	1	/* IRQ handler active - do not enter! */
+#define IRQ_DISABLED	2	/* IRQ disabled - do not enter! */
+#define IRQ_PENDING	4	/* IRQ pending - replay on enable */
+#define IRQ_REPLAY	8	/* IRQ has been replayed but not acked yet */
+#define IRQ_AUTODETECT	16	/* IRQ is being autodetected */
+#define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
+#define IRQ_LEVEL	64	/* IRQ level triggered */
+#define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
+#define IRQ_PER_CPU	256	/* IRQ is per CPU */
+
+/*
+ * Interrupt controller descriptor. This is all we need
+ * to describe about the low-level hardware. 
+ */
+struct hw_interrupt_type {
+	const char * typename;
+	unsigned int (*startup)(unsigned int irq);
+	void (*shutdown)(unsigned int irq);
+	void (*enable)(unsigned int irq);
+	void (*disable)(unsigned int irq);
+	void (*ack)(unsigned int irq);
+	void (*end)(unsigned int irq);
+	void (*set_affinity)(unsigned int irq, cpumask_t dest);
+};
+
+typedef struct hw_interrupt_type  hw_irq_controller;
+
+/*
+ * This is the "IRQ descriptor", which contains various information
+ * about the irq, including what kind of hardware handling it has,
+ * whether it is disabled etc etc.
+ *
+ * Pad this out to 32 bytes for cache and indexing reasons.
+ */
+typedef struct irq_desc {
+	hw_irq_controller *handler;
+	void *handler_data;
+	struct irqaction *action;	/* IRQ action list */
+	unsigned int status;		/* IRQ status */
+	unsigned int depth;		/* nested irq disables */
+	unsigned int irq_count;		/* For detecting broken interrupts */
+	unsigned int irqs_unhandled;
+	spinlock_t lock;
+} ____cacheline_aligned irq_desc_t;
+
+extern irq_desc_t irq_desc [NR_IRQS];
+
+#include <asm/hw_irq.h> /* the arch dependent stuff */
+
+extern int setup_irq(unsigned int irq, struct irqaction * new);
+
+#ifdef CONFIG_GENERIC_HARDIRQS
+extern cpumask_t irq_affinity[NR_IRQS];
+extern int no_irq_affinity;
+extern int noirqdebug_setup(char *str);
+
+extern fastcall int handle_IRQ_event(unsigned int irq, struct pt_regs *regs,
+				       struct irqaction *action);
+extern fastcall unsigned int __do_IRQ(unsigned int irq, struct pt_regs *regs);
+extern void note_interrupt(unsigned int irq, irq_desc_t *desc, int action_ret);
+extern void report_bad_irq(unsigned int irq, irq_desc_t *desc, int action_ret);
+extern int can_request_irq(unsigned int irq, unsigned long irqflags);
+
+extern void init_irq_proc(void);
+#endif
+
+extern hw_irq_controller no_irq_type;  /* needed in every arch ? */
+
+#endif
+
+#endif /* __irq_h */
