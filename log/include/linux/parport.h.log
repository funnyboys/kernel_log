commit bae9defb06a781083844cafd0a359f423cd98388
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Apr 3 14:43:24 2020 +0100

    parport: remove unused parport_register_device()
    
    All the drivers that are using parallel port has been converted to use
    the new device model api, and parport_register_device() is no longer
    used.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-10-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 36a0f6270238..1fb508c19e83 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -325,18 +325,6 @@ struct pardev_cb {
 	unsigned int flags;
 };
 
-/* parport_register_device declares that a device is connected to a
-   port, and tells the kernel all it needs to know.
-   - pf is the preemption function (may be NULL for no callback)
-   - kf is the wake-up function (may be NULL for no callback)
-   - irq_func is the interrupt handler (may be NULL for no interrupts)
-   - handle is a user pointer that gets handed to callback functions.  */
-struct pardevice *parport_register_device(struct parport *port, 
-			  const char *name,
-			  int (*pf)(void *), void (*kf)(void *),
-			  void (*irq_func)(void *), 
-			  int flags, void *handle);
-
 /*
  * parport_register_dev_model declares that a device is connected to a
  * port, and tells the kernel all it needs to know.

commit 6824f0ce38cb4b903a3cbf00dd528861f6c2ea7c
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Apr 3 14:43:23 2020 +0100

    parport: Add comments for parport_register_dev_model()
    
    In preparation to remove parport_register_device(), copy the comments
    to parport_register_dev_model() and modify the parameters according to
    what parport_register_dev_model() has.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-9-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 13932ce8b37b..36a0f6270238 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -337,6 +337,10 @@ struct pardevice *parport_register_device(struct parport *port,
 			  void (*irq_func)(void *), 
 			  int flags, void *handle);
 
+/*
+ * parport_register_dev_model declares that a device is connected to a
+ * port, and tells the kernel all it needs to know.
+ */
 struct pardevice *
 parport_register_dev_model(struct parport *port, const char *name,
 			   const struct pardev_cb *par_dev_cb, int cnt);

commit c059d579961d62c1a675cb89ef799902e6bce815
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 16 15:45:37 2019 +0100

    parport: daisy: avoid hardcoded name
    
    The daisy device name is hardcoded, define it in the header file and
    use it in the code.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20191016144540.18810-1-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 397607a0c0eb..13932ce8b37b 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -460,6 +460,7 @@ extern size_t parport_ieee1284_epp_read_addr (struct parport *,
 					      void *, size_t, int);
 
 /* IEEE1284.3 functions */
+#define daisy_dev_name "Device ID probe"
 extern int parport_daisy_init (struct parport *port);
 extern void parport_daisy_fini (struct parport *port);
 extern struct pardevice *parport_open (int devnum, const char *name);

commit a3ac7917b73070010c05b4485b8582a6c9cd69b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 25 14:49:00 2019 -0700

    Revert "parport: daisy: use new parport device model"
    
    This reverts commit 1aec4211204d9463d1fd209eb50453de16254599.
    
    Steven Rostedt reports that it causes a hang at bootup and bisected it
    to this commit.
    
    The troigger is apparently a module alias for "parport_lowlevel" that
    points to "parport_pc", which causes a hang with
    
        modprobe -q -- parport_lowlevel
    
    blocking forever with a backtrace like this:
    
        wait_for_completion_killable+0x1c/0x28
        call_usermodehelper_exec+0xa7/0x108
        __request_module+0x351/0x3d8
        get_lowlevel_driver+0x28/0x41 [parport]
        __parport_register_driver+0x39/0x1f4 [parport]
        daisy_drv_init+0x31/0x4f [parport]
        parport_bus_init+0x5d/0x7b [parport]
        parport_default_proc_register+0x26/0x1000 [parport]
        do_one_initcall+0xc2/0x1e0
        do_init_module+0x50/0x1d4
        load_module+0x1c2e/0x21b3
        sys_init_module+0xef/0x117
    
    Supid says:
     "Due to the new device model daisy driver will now try to find the
      parallel ports while trying to register its driver so that it can bind
      with them. Now, since daisy driver is loaded while parport bus is
      initialising the list of parport is still empty and it tries to load
      the lowlevel driver, which has an alias set to parport_pc, now causes
      a deadlock"
    
    But I don't think the daisy driver should be loaded by the parport
    initialization in the first place, so let's revert the whole change.
    
    If the daisy driver can just initialize separately on its own (like a
    driver should), instead of hooking into the parport init sequence
    directly, this issue probably would go away.
    
    Reported-and-bisected-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reported-by: Michal Kubecek <mkubecek@suse.cz>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index f41f1d041e2c..397607a0c0eb 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -460,7 +460,6 @@ extern size_t parport_ieee1284_epp_read_addr (struct parport *,
 					      void *, size_t, int);
 
 /* IEEE1284.3 functions */
-#define daisy_dev_name "Device ID probe"
 extern int parport_daisy_init (struct parport *port);
 extern void parport_daisy_fini (struct parport *port);
 extern struct pardevice *parport_open (int devnum, const char *name);
@@ -469,18 +468,6 @@ extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
 extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 
-#ifdef CONFIG_PARPORT_1284
-extern int daisy_drv_init(void);
-extern void daisy_drv_exit(void);
-#else
-static inline int daisy_drv_init(void)
-{
-	return 0;
-}
-
-static inline void daisy_drv_exit(void) {}
-#endif
-
 /* Lowlevel drivers _can_ call this support function to handle irqs.  */
 static inline void parport_generic_irq(struct parport *port)
 {

commit 1aec4211204d9463d1fd209eb50453de16254599
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Feb 13 08:47:06 2019 +0000

    parport: daisy: use new parport device model
    
    Modify parport daisy driver to use the new parallel port device model.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 397607a0c0eb..f41f1d041e2c 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -460,6 +460,7 @@ extern size_t parport_ieee1284_epp_read_addr (struct parport *,
 					      void *, size_t, int);
 
 /* IEEE1284.3 functions */
+#define daisy_dev_name "Device ID probe"
 extern int parport_daisy_init (struct parport *port);
 extern void parport_daisy_fini (struct parport *port);
 extern struct pardevice *parport_open (int devnum, const char *name);
@@ -468,6 +469,18 @@ extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
 extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 
+#ifdef CONFIG_PARPORT_1284
+extern int daisy_drv_init(void);
+extern void daisy_drv_exit(void);
+#else
+static inline int daisy_drv_init(void)
+{
+	return 0;
+}
+
+static inline void daisy_drv_exit(void) {}
+#endif
+
 /* Lowlevel drivers _can_ call this support function to handle irqs.  */
 static inline void parport_generic_irq(struct parport *port)
 {

commit 9c6c273aa4248c60569de6ef7e7e9c7bed3cd32e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:26:57 2017 -0700

    timer: Remove init_timer_on_stack() in favor of timer_setup_on_stack()
    
    Remove uses of init_timer_on_stack() with open-coded function and data
    assignments that could be expressed using timer_setup_on_stack(). Several
    were removed from the stack entirely since there was a one-to-one mapping
    of parent structure to timer, those are switched to using timer_setup()
    instead. All related callbacks were adjusted to use from_timer().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: linux-scsi@vger.kernel.org
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-4-git-send-email-keescook@chromium.org

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 58e3c64c6b49..397607a0c0eb 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -225,6 +225,7 @@ struct parport {
 	struct pardevice *waittail;
 
 	struct list_head list;
+	struct timer_list timer;
 	unsigned int flags;
 
 	void *sysctl_table;

commit 6fa45a22689722dac9f0e90c0931d4b34b334ede
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed May 20 20:56:57 2015 +0530

    parport: add device-model to parport subsystem
    
    parport subsystem starts using the device-model. Drivers using the
    device-model has to define devmodel as true and should register the
    device with parport using parport_register_dev_model().
    
    Tested-by: Jean Delvare <jdelvare@suse.de>
    Tested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index c22f12547324..58e3c64c6b49 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -13,6 +13,7 @@
 #include <linux/wait.h>
 #include <linux/irqreturn.h>
 #include <linux/semaphore.h>
+#include <linux/device.h>
 #include <asm/ptrace.h>
 #include <uapi/linux/parport.h>
 
@@ -145,6 +146,8 @@ struct pardevice {
 	unsigned int flags;
 	struct pardevice *next;
 	struct pardevice *prev;
+	struct device dev;
+	bool devmodel;
 	struct parport_state *state;     /* saved status over preemption */
 	wait_queue_head_t wait_q;
 	unsigned long int time;
@@ -156,6 +159,8 @@ struct pardevice {
 	void * sysctl_table;
 };
 
+#define to_pardevice(n) container_of(n, struct pardevice, dev)
+
 /* IEEE1284 information */
 
 /* IEEE1284 phases. These are exposed to userland through ppdev IOCTL
@@ -195,7 +200,7 @@ struct parport {
 				 * This may unfortulately be null if the
 				 * port has a legacy driver.
 				 */
-
+	struct device bus_dev;	/* to link with the bus */
 	struct parport *physport;
 				/* If this is a non-default mux
 				   parport, i.e. we're a clone of a real
@@ -245,15 +250,26 @@ struct parport {
 	struct parport *slaves[3];
 };
 
+#define to_parport_dev(n) container_of(n, struct parport, bus_dev)
+
 #define DEFAULT_SPIN_TIME 500 /* us */
 
 struct parport_driver {
 	const char *name;
 	void (*attach) (struct parport *);
 	void (*detach) (struct parport *);
+	void (*match_port)(struct parport *);
+	int (*probe)(struct pardevice *);
+	struct device_driver driver;
+	bool devmodel;
 	struct list_head list;
 };
 
+#define to_parport_driver(n) container_of(n, struct parport_driver, driver)
+
+int parport_bus_init(void);
+void parport_bus_exit(void);
+
 /* parport_register_port registers a new parallel port at the given
    address (if one does not already exist) and returns a pointer to it.
    This entails claiming the I/O region, IRQ and DMA.  NULL is returned
@@ -272,10 +288,20 @@ void parport_announce_port (struct parport *port);
 extern void parport_remove_port(struct parport *port);
 
 /* Register a new high-level driver. */
-extern int parport_register_driver (struct parport_driver *);
+
+int __must_check __parport_register_driver(struct parport_driver *,
+					   struct module *,
+					   const char *mod_name);
+/*
+ * parport_register_driver must be a macro so that KBUILD_MODNAME can
+ * be expanded
+ */
+#define parport_register_driver(driver)             \
+	__parport_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)
 
 /* Unregister a high-level driver. */
 extern void parport_unregister_driver (struct parport_driver *);
+void parport_unregister_driver(struct parport_driver *);
 
 /* If parport_register_driver doesn't fit your needs, perhaps
  * parport_find_xxx does. */
@@ -288,6 +314,15 @@ extern irqreturn_t parport_irq_handler(int irq, void *dev_id);
 /* Reference counting for ports. */
 extern struct parport *parport_get_port (struct parport *);
 extern void parport_put_port (struct parport *);
+void parport_del_port(struct parport *);
+
+struct pardev_cb {
+	int (*preempt)(void *);
+	void (*wakeup)(void *);
+	void *private;
+	void (*irq_func)(void *);
+	unsigned int flags;
+};
 
 /* parport_register_device declares that a device is connected to a
    port, and tells the kernel all it needs to know.
@@ -301,6 +336,10 @@ struct pardevice *parport_register_device(struct parport *port,
 			  void (*irq_func)(void *), 
 			  int flags, void *handle);
 
+struct pardevice *
+parport_register_dev_model(struct parport *port, const char *name,
+			   const struct pardev_cb *par_dev_cb, int cnt);
+
 /* parport_unregister unlinks a device from the chain. */
 extern void parport_unregister_device(struct pardevice *dev);
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 106c2ca9440b..c22f12547324 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -3,96 +3,9 @@
  * the GNU Free Documentation License, Version 1.1 or any later version
  * published by the Free Software Foundation.
  */
-
 #ifndef _PARPORT_H_
 #define _PARPORT_H_
 
-/* Start off with user-visible constants */
-
-/* Maximum of 16 ports per machine */
-#define PARPORT_MAX  16
-
-/* Magic numbers */
-#define PARPORT_IRQ_NONE  -1
-#define PARPORT_DMA_NONE  -1
-#define PARPORT_IRQ_AUTO  -2
-#define PARPORT_DMA_AUTO  -2
-#define PARPORT_DMA_NOFIFO -3
-#define PARPORT_DISABLE   -2
-#define PARPORT_IRQ_PROBEONLY -3
-#define PARPORT_IOHI_AUTO -1
-
-#define PARPORT_CONTROL_STROBE    0x1
-#define PARPORT_CONTROL_AUTOFD    0x2
-#define PARPORT_CONTROL_INIT      0x4
-#define PARPORT_CONTROL_SELECT    0x8
-
-#define PARPORT_STATUS_ERROR      0x8
-#define PARPORT_STATUS_SELECT     0x10
-#define PARPORT_STATUS_PAPEROUT   0x20
-#define PARPORT_STATUS_ACK        0x40
-#define PARPORT_STATUS_BUSY       0x80
-
-/* Type classes for Plug-and-Play probe.  */
-typedef enum {
-	PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
-	PARPORT_CLASS_PRINTER,
-	PARPORT_CLASS_MODEM,
-	PARPORT_CLASS_NET,
-	PARPORT_CLASS_HDC,              /* Hard disk controller */
-	PARPORT_CLASS_PCMCIA,
-	PARPORT_CLASS_MEDIA,            /* Multimedia device */
-	PARPORT_CLASS_FDC,              /* Floppy disk controller */
-	PARPORT_CLASS_PORTS,
-	PARPORT_CLASS_SCANNER,
-	PARPORT_CLASS_DIGCAM,
-	PARPORT_CLASS_OTHER,            /* Anything else */
-	PARPORT_CLASS_UNSPEC,           /* No CLS field in ID */
-	PARPORT_CLASS_SCSIADAPTER
-} parport_device_class;
-
-/* The "modes" entry in parport is a bit field representing the
-   capabilities of the hardware. */
-#define PARPORT_MODE_PCSPP	(1<<0) /* IBM PC registers available. */
-#define PARPORT_MODE_TRISTATE	(1<<1) /* Can tristate. */
-#define PARPORT_MODE_EPP	(1<<2) /* Hardware EPP. */
-#define PARPORT_MODE_ECP	(1<<3) /* Hardware ECP. */
-#define PARPORT_MODE_COMPAT	(1<<4) /* Hardware 'printer protocol'. */
-#define PARPORT_MODE_DMA	(1<<5) /* Hardware can DMA. */
-#define PARPORT_MODE_SAFEININT	(1<<6) /* SPP registers accessible in IRQ. */
-
-/* IEEE1284 modes: 
-   Nibble mode, byte mode, ECP, ECPRLE and EPP are their own
-   'extensibility request' values.  Others are special.
-   'Real' ECP modes must have the IEEE1284_MODE_ECP bit set.  */
-#define IEEE1284_MODE_NIBBLE             0
-#define IEEE1284_MODE_BYTE              (1<<0)
-#define IEEE1284_MODE_COMPAT            (1<<8)
-#define IEEE1284_MODE_BECP              (1<<9) /* Bounded ECP mode */
-#define IEEE1284_MODE_ECP               (1<<4)
-#define IEEE1284_MODE_ECPRLE            (IEEE1284_MODE_ECP | (1<<5))
-#define IEEE1284_MODE_ECPSWE            (1<<10) /* Software-emulated */
-#define IEEE1284_MODE_EPP               (1<<6)
-#define IEEE1284_MODE_EPPSL             (1<<11) /* EPP 1.7 */
-#define IEEE1284_MODE_EPPSWE            (1<<12) /* Software-emulated */
-#define IEEE1284_DEVICEID               (1<<2)  /* This is a flag */
-#define IEEE1284_EXT_LINK               (1<<14) /* This flag causes the
-						 * extensibility link to
-						 * be requested, using
-						 * bits 0-6. */
-
-/* For the benefit of parport_read/write, you can use these with
- * parport_negotiate to use address operations.  They have no effect
- * other than to make parport_read/write use address transfers. */
-#define IEEE1284_ADDR			(1<<13)	/* This is a flag */
-#define IEEE1284_DATA			 0	/* So is this */
-
-/* Flags for block transfer operations. */
-#define PARPORT_EPP_FAST		(1<<0) /* Unreliable counts. */
-#define PARPORT_W91284PIC		(1<<1) /* have a Warp9 w91284pic in the device */
-
-/* The rest is for the kernel only */
-#ifdef __KERNEL__
 
 #include <linux/jiffies.h>
 #include <linux/proc_fs.h>
@@ -101,6 +14,7 @@ typedef enum {
 #include <linux/irqreturn.h>
 #include <linux/semaphore.h>
 #include <asm/ptrace.h>
+#include <uapi/linux/parport.h>
 
 /* Define this later. */
 struct parport;
@@ -564,5 +478,4 @@ extern int parport_device_proc_unregister(struct pardevice *device);
 extern unsigned long parport_default_timeslice;
 extern int parport_default_spintime;
 
-#endif /* __KERNEL__ */
 #endif /* _PARPORT_H_ */

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 38a423ed3c01..106c2ca9440b 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -100,7 +100,6 @@ typedef enum {
 #include <linux/wait.h>
 #include <linux/irqreturn.h>
 #include <linux/semaphore.h>
-#include <asm/system.h>
 #include <asm/ptrace.h>
 
 /* Define this later. */

commit 05ad709d04799125ed85dd816fdb558258102172
Author: Alan Cox <alan@etchedpixels.co.uk>
Date:   Tue Jun 2 16:58:10 2009 +0100

    parport: quickfix the proc registration bug
    
    Ideally we should have a directory of drivers and a link to the 'active'
    driver. For now just show the first device which is effectively the existing
    semantics without a warning.
    
    This is an update on the original buggy patch that I then forgot to
    resubmit. Confusingly it was proposed by Red Hat, written by Etched Pixels
    fixed and submitted by Intel ...
    
    Resolves-Bug: http://bugzilla.kernel.org/show_bug.cgi?id=9749
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index e1f83c5065c5..38a423ed3c01 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -324,6 +324,10 @@ struct parport {
 	int spintime;
 	atomic_t ref_count;
 
+	unsigned long devflags;
+#define PARPORT_DEVPROC_REGISTERED	0
+	struct pardevice *proc_device;	/* Currently register proc device */
+
 	struct list_head full_list;
 	struct parport *slaves[3];
 };

commit 612de10db06c0704a66bbe7fd13990cb1c2cb958
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 15 22:04:33 2008 -0700

    parport: remove CVS keywords
    
    Remove CVS keywords that weren't updated for a long time from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 6a0d7cdb5774..e1f83c5065c5 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -1,5 +1,3 @@
-/* $Id: parport.h,v 1.1 1998/05/17 10:57:52 andrea Exp andrea $ */
-
 /*
  * Any part of this program may be used in documents licensed under
  * the GNU Free Documentation License, Version 1.1 or any later version

commit 929dfb24fbcd60e2544b2de7bfb4a68da4dfc747
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Jul 25 19:44:54 2008 -0700

    parport/share.c: proper externs
    
    This patch adds proper externs for parport_default_timeslice and
    parport_default_spintime in include/linux/parport.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index dcb9e01a69ca..6a0d7cdb5774 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -560,5 +560,8 @@ extern int parport_device_proc_unregister(struct pardevice *device);
 
 #endif /*  !CONFIG_PARPORT_NOT_PC  */
 
+extern unsigned long parport_default_timeslice;
+extern int parport_default_spintime;
+
 #endif /* __KERNEL__ */
 #endif /* _PARPORT_H_ */

commit 6188e10d38b8d7244ee7776d5f1f88c837b4b93f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Apr 18 22:21:05 2008 -0400

    Convert asm/semaphore.h users to linux/semaphore.h
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index d1ad546c8c9e..dcb9e01a69ca 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -101,9 +101,9 @@ typedef enum {
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/irqreturn.h>
+#include <linux/semaphore.h>
 #include <asm/system.h>
 #include <asm/ptrace.h>
-#include <asm/semaphore.h>
 
 /* Define this later. */
 struct parport;

commit 5712cb3d81566893c3b14e24075cf48ec5c35d00
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 02:54:26 2007 -0400

    [PARPORT] Remove unused 'irq' argument from parport irq functions
    
    None of the drivers with a struct pardevice's ->irq_func() hook ever
    used the 'irq' argument passed to it, so remove it.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 557c37de1f38..d1ad546c8c9e 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -230,7 +230,7 @@ struct pardevice {
 	int (*preempt)(void *);
 	void (*wakeup)(void *);
 	void *private;
-	void (*irq_func)(int, void *);
+	void (*irq_func)(void *);
 	unsigned int flags;
 	struct pardevice *next;
 	struct pardevice *prev;
@@ -383,7 +383,7 @@ extern void parport_put_port (struct parport *);
 struct pardevice *parport_register_device(struct parport *port, 
 			  const char *name,
 			  int (*pf)(void *), void (*kf)(void *),
-			  void (*irq_func)(int, void *), 
+			  void (*irq_func)(void *), 
 			  int flags, void *handle);
 
 /* parport_unregister unlinks a device from the chain. */
@@ -507,11 +507,7 @@ extern size_t parport_ieee1284_epp_read_addr (struct parport *,
 /* IEEE1284.3 functions */
 extern int parport_daisy_init (struct parport *port);
 extern void parport_daisy_fini (struct parport *port);
-extern struct pardevice *parport_open (int devnum, const char *name,
-				       int (*pf) (void *),
-				       void (*kf) (void *),
-				       void (*irqf) (int, void *),
-				       int flags, void *handle);
+extern struct pardevice *parport_open (int devnum, const char *name);
 extern void parport_close (struct pardevice *dev);
 extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
 extern void parport_daisy_deselect_all (struct parport *port);
@@ -523,7 +519,7 @@ static inline void parport_generic_irq(struct parport *port)
 	parport_ieee1284_interrupt (port);
 	read_lock(&port->cad_lock);
 	if (port->cad && port->cad->irq_func)
-		port->cad->irq_func(port->irq, port->cad->private);
+		port->cad->irq_func(port->cad->private);
 	read_unlock(&port->cad_lock);
 }
 

commit f230d1010ad0dcd71d9ca8ea6864afac49c5aa9b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:56:02 2007 -0400

    [PARPORT] Kill useful 'irq' arg from parport_{generic_irq,ieee1284_interrupt}
    
    parport_ieee1284_interrupt() was not using its first arg at all.
    Delete.
    
    parport_generic_irq()'s second arg makes its first arg completely
    redundant.  Delete, and use port->irq in the one place where we actually
    need it.
    
    Also, s/__inline__/inline/ to make the code look nicer.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 66026eab10c7..557c37de1f38 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -465,7 +465,7 @@ static __inline__ int parport_yield_blocking(struct pardevice *dev)
 #define PARPORT_FLAG_EXCL		(1<<1)	/* EXCL driver registered. */
 
 /* IEEE1284 functions */
-extern void parport_ieee1284_interrupt (int, void *);
+extern void parport_ieee1284_interrupt (void *);
 extern int parport_negotiate (struct parport *, int mode);
 extern ssize_t parport_write (struct parport *, const void *buf, size_t len);
 extern ssize_t parport_read (struct parport *, void *buf, size_t len);
@@ -518,12 +518,12 @@ extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 
 /* Lowlevel drivers _can_ call this support function to handle irqs.  */
-static inline void parport_generic_irq(int irq, struct parport *port)
+static inline void parport_generic_irq(struct parport *port)
 {
-	parport_ieee1284_interrupt (irq, port);
+	parport_ieee1284_interrupt (port);
 	read_lock(&port->cad_lock);
 	if (port->cad && port->cad->irq_func)
-		port->cad->irq_func(irq, port->cad->private);
+		port->cad->irq_func(port->irq, port->cad->private);
 	read_unlock(&port->cad_lock);
 }
 

commit 3f2e40df0e1d7694224c3083b0bebd129039a40a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:42:14 2007 -0400

    [PARPORT] Consolidate code copies into a single generic irq handler
    
    Several arches used the exact same code for their parport irq handling.
    Make that code generic, in parport_irq_handler().
    
    Also, s/__inline__/inline/ in include/linux/parport.h.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index ec3f76598327..66026eab10c7 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -100,6 +100,7 @@ typedef enum {
 #include <linux/proc_fs.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
+#include <linux/irqreturn.h>
 #include <asm/system.h>
 #include <asm/ptrace.h>
 #include <asm/semaphore.h>
@@ -366,6 +367,9 @@ extern void parport_unregister_driver (struct parport_driver *);
 extern struct parport *parport_find_number (int);
 extern struct parport *parport_find_base (unsigned long);
 
+/* generic irq handler, if it suits your needs */
+extern irqreturn_t parport_irq_handler(int irq, void *dev_id);
+
 /* Reference counting for ports. */
 extern struct parport *parport_get_port (struct parport *);
 extern void parport_put_port (struct parport *);
@@ -514,7 +518,7 @@ extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 
 /* Lowlevel drivers _can_ call this support function to handle irqs.  */
-static __inline__ void parport_generic_irq(int irq, struct parport *port)
+static inline void parport_generic_irq(int irq, struct parport *port)
 {
 	parport_ieee1284_interrupt (irq, port);
 	read_lock(&port->cad_lock);

commit 25398a158d86b993fa5bf36f5a6752134b584d60
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Oct 18 03:05:30 2007 -0700

    sysctl: parport remove binary paths
    
    The sysctl binary paths don't look as if they even code work, .data is not
    filled in, and all of the proc_handlers look at extra1 and there is not
    strategy routine.
    
    So just kill the binary paths.
    
    In addition this patch removes the setting of extra1 on directories.  It
    doesn't look like the parport code ever examines it, and it's bad sysctl form.
    
    [bunk@kernel.org: remove parport_device_num()]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 9cdd6943e01b..ec3f76598327 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -510,7 +510,6 @@ extern struct pardevice *parport_open (int devnum, const char *name,
 				       int flags, void *handle);
 extern void parport_close (struct pardevice *dev);
 extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
-extern int parport_device_num (int parport, int mux, int daisy);
 extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 

commit c15a3837d2aa30e3ea41aed49d80abed355ab6bd
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:27:35 2007 -0700

    parport->dev driver model support
    
    Currently a parport_driver can't get a handle on the device node for the
    underlying parport (PNPACPI, PCI, etc).  That prevents correct placement of
    sysfs child nodes, which can affect things like power management.
    
    This patch adds a field to "struct parport" pointing to that device node, and
    updates non-legacy port drivers to initialize that device pointer.  That field
    replaces the analagous PCI-only support in parport_pc.
    
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 80682aaa8f18..9cdd6943e01b 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -279,6 +279,10 @@ struct parport {
 	int dma;
 	int muxport;		/* which muxport (if any) this is */
 	int portnum;		/* which physical parallel port (not mux) */
+	struct device *dev;	/* Physical device associated with IO/DMA.
+				 * This may unfortulately be null if the
+				 * port has a legacy driver.
+				 */
 
 	struct parport *physport;
 				/* If this is a non-default mux
@@ -289,7 +293,7 @@ struct parport {
 				   following structure members are
 				   meaningless: devices, cad, muxsel,
 				   waithead, waittail, flags, pdir,
-				   ieee1284, *_lock.
+				   dev, ieee1284, *_lock.
 
 				   It this is a default mux parport, or
 				   there is no mux involved, this points to
@@ -302,7 +306,7 @@ struct parport {
 
 	struct pardevice *waithead;
 	struct pardevice *waittail;
-	
+
 	struct list_head list;
 	unsigned int flags;
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 5bf321e82c99..80682aaa8f18 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -229,7 +229,7 @@ struct pardevice {
 	int (*preempt)(void *);
 	void (*wakeup)(void *);
 	void *private;
-	void (*irq_func)(int, void *, struct pt_regs *);
+	void (*irq_func)(int, void *);
 	unsigned int flags;
 	struct pardevice *next;
 	struct pardevice *prev;
@@ -375,7 +375,7 @@ extern void parport_put_port (struct parport *);
 struct pardevice *parport_register_device(struct parport *port, 
 			  const char *name,
 			  int (*pf)(void *), void (*kf)(void *),
-			  void (*irq_func)(int, void *, struct pt_regs *), 
+			  void (*irq_func)(int, void *), 
 			  int flags, void *handle);
 
 /* parport_unregister unlinks a device from the chain. */
@@ -457,7 +457,7 @@ static __inline__ int parport_yield_blocking(struct pardevice *dev)
 #define PARPORT_FLAG_EXCL		(1<<1)	/* EXCL driver registered. */
 
 /* IEEE1284 functions */
-extern void parport_ieee1284_interrupt (int, void *, struct pt_regs *);
+extern void parport_ieee1284_interrupt (int, void *);
 extern int parport_negotiate (struct parport *, int mode);
 extern ssize_t parport_write (struct parport *, const void *buf, size_t len);
 extern ssize_t parport_read (struct parport *, void *buf, size_t len);
@@ -502,8 +502,7 @@ extern void parport_daisy_fini (struct parport *port);
 extern struct pardevice *parport_open (int devnum, const char *name,
 				       int (*pf) (void *),
 				       void (*kf) (void *),
-				       void (*irqf) (int, void *,
-						     struct pt_regs *),
+				       void (*irqf) (int, void *),
 				       int flags, void *handle);
 extern void parport_close (struct pardevice *dev);
 extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
@@ -512,13 +511,12 @@ extern void parport_daisy_deselect_all (struct parport *port);
 extern int parport_daisy_select (struct parport *port, int daisy, int mode);
 
 /* Lowlevel drivers _can_ call this support function to handle irqs.  */
-static __inline__ void parport_generic_irq(int irq, struct parport *port,
-					   struct pt_regs *regs)
+static __inline__ void parport_generic_irq(int irq, struct parport *port)
 {
-	parport_ieee1284_interrupt (irq, port, regs);
+	parport_ieee1284_interrupt (irq, port);
 	read_lock(&port->cad_lock);
 	if (port->cad && port->cad->irq_func)
-		port->cad->irq_func(irq, port->cad->private, regs);
+		port->cad->irq_func(irq, port->cad->private);
 	read_unlock(&port->cad_lock);
 }
 

commit ad4063b0b2ffd7c8359b62c830e88152fc39ab20
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Sun Jun 25 05:48:03 2006 -0700

    [PATCH] AX88796 parallel port driver
    
    Driver for the simple parallel port interface on the Asix AX88796 chip on
    an platform_bus.
    
    [akpm@osdl.org: x86_64 build fix]
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index d42737eeee06..5bf321e82c99 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -127,6 +127,10 @@ struct amiga_parport_state {
        unsigned char statusdir;/* ciab.ddrb & 7 */
 };
 
+struct ax88796_parport_state {
+	unsigned char cpr;
+};
+
 struct ip32_parport_state {
 	unsigned int dcr;
 	unsigned int ecr;
@@ -138,6 +142,7 @@ struct parport_state {
 		/* ARC has no state. */
 		struct ax_parport_state ax;
 		struct amiga_parport_state amiga;
+		struct ax88796_parport_state ax88796;
 		/* Atari has not state. */
 		struct ip32_parport_state ip32;
 		void *misc; 

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index 008d736a6c9a..d42737eeee06 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -96,7 +96,6 @@ typedef enum {
 /* The rest is for the kernel only */
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/jiffies.h>
 #include <linux/proc_fs.h>
 #include <linux/spinlock.h>

commit 8e75f744289f0a1c38b669e39a489af460640881
Author: Arnaud Giersch <arnaud.giersch@free.fr>
Date:   Fri Feb 3 03:04:16 2006 -0800

    [PATCH] parport: add parallel port support for SGI O2
    
    Add support for the built-in parallel port on SGI O2 (a.k.a.  IP32).
    Define a new configuration option: PARPORT_IP32.  The module is named
    parport_ip32.
    
    Hardware support for SPP, EPP and ECP modes along with DMA support when
    available are currently implemented.
    
    Signed-off-by: Arnaud Giersch <arnaud.giersch@free.fr>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index f67f838a3a1f..008d736a6c9a 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -128,6 +128,11 @@ struct amiga_parport_state {
        unsigned char statusdir;/* ciab.ddrb & 7 */
 };
 
+struct ip32_parport_state {
+	unsigned int dcr;
+	unsigned int ecr;
+};
+
 struct parport_state {
 	union {
 		struct pc_parport_state pc;
@@ -135,6 +140,7 @@ struct parport_state {
 		struct ax_parport_state ax;
 		struct amiga_parport_state amiga;
 		/* Atari has not state. */
+		struct ip32_parport_state ip32;
 		void *misc; 
 	} u;
 };

commit d8a33496671e4533aed090793436d58debea6f3a
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Sun Jan 8 01:05:06 2006 -0800

    [PATCH] parport: bring back an unused phase for ppdev ioctl
    
    Earlier fix removed unused phase, but that changed the values for other
    phases.  Since these are exposed to userspace through ppdev, it is safer
    not to change them.  Restore the unused phase value.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index f7ff0b0c4031..f67f838a3a1f 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -236,12 +236,14 @@ struct pardevice {
 
 /* IEEE1284 information */
 
-/* IEEE1284 phases */
+/* IEEE1284 phases. These are exposed to userland through ppdev IOCTL
+ * PP[GS]ETPHASE, so do not change existing values. */
 enum ieee1284_phase {
 	IEEE1284_PH_FWD_DATA,
 	IEEE1284_PH_FWD_IDLE,
 	IEEE1284_PH_TERMINATE,
 	IEEE1284_PH_NEGOTIATION,
+	IEEE1284_PH_HBUSY_DNA,
 	IEEE1284_PH_REV_IDLE,
 	IEEE1284_PH_HBUSY_DAVAIL,
 	IEEE1284_PH_REV_DATA,

commit 742ec650e9b63ea61891455bb6f76bac37025c78
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:44 2006 -0800

    [PATCH] parport: phase fixes
    
    Did not move the parport interface properly into IEEE1284_PH_REV_IDLE phase at
    end of data due to comparing bytes with nibbles.  Internal phase
    IEEE1284_PH_HBUSY_DNA became unused, so remove it.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/parport.h b/include/linux/parport.h
index d2a4d9e1e6d1..f7ff0b0c4031 100644
--- a/include/linux/parport.h
+++ b/include/linux/parport.h
@@ -242,7 +242,6 @@ enum ieee1284_phase {
 	IEEE1284_PH_FWD_IDLE,
 	IEEE1284_PH_TERMINATE,
 	IEEE1284_PH_NEGOTIATION,
-	IEEE1284_PH_HBUSY_DNA,
 	IEEE1284_PH_REV_IDLE,
 	IEEE1284_PH_HBUSY_DAVAIL,
 	IEEE1284_PH_REV_DATA,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/parport.h b/include/linux/parport.h
new file mode 100644
index 000000000000..d2a4d9e1e6d1
--- /dev/null
+++ b/include/linux/parport.h
@@ -0,0 +1,552 @@
+/* $Id: parport.h,v 1.1 1998/05/17 10:57:52 andrea Exp andrea $ */
+
+/*
+ * Any part of this program may be used in documents licensed under
+ * the GNU Free Documentation License, Version 1.1 or any later version
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _PARPORT_H_
+#define _PARPORT_H_
+
+/* Start off with user-visible constants */
+
+/* Maximum of 16 ports per machine */
+#define PARPORT_MAX  16
+
+/* Magic numbers */
+#define PARPORT_IRQ_NONE  -1
+#define PARPORT_DMA_NONE  -1
+#define PARPORT_IRQ_AUTO  -2
+#define PARPORT_DMA_AUTO  -2
+#define PARPORT_DMA_NOFIFO -3
+#define PARPORT_DISABLE   -2
+#define PARPORT_IRQ_PROBEONLY -3
+#define PARPORT_IOHI_AUTO -1
+
+#define PARPORT_CONTROL_STROBE    0x1
+#define PARPORT_CONTROL_AUTOFD    0x2
+#define PARPORT_CONTROL_INIT      0x4
+#define PARPORT_CONTROL_SELECT    0x8
+
+#define PARPORT_STATUS_ERROR      0x8
+#define PARPORT_STATUS_SELECT     0x10
+#define PARPORT_STATUS_PAPEROUT   0x20
+#define PARPORT_STATUS_ACK        0x40
+#define PARPORT_STATUS_BUSY       0x80
+
+/* Type classes for Plug-and-Play probe.  */
+typedef enum {
+	PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
+	PARPORT_CLASS_PRINTER,
+	PARPORT_CLASS_MODEM,
+	PARPORT_CLASS_NET,
+	PARPORT_CLASS_HDC,              /* Hard disk controller */
+	PARPORT_CLASS_PCMCIA,
+	PARPORT_CLASS_MEDIA,            /* Multimedia device */
+	PARPORT_CLASS_FDC,              /* Floppy disk controller */
+	PARPORT_CLASS_PORTS,
+	PARPORT_CLASS_SCANNER,
+	PARPORT_CLASS_DIGCAM,
+	PARPORT_CLASS_OTHER,            /* Anything else */
+	PARPORT_CLASS_UNSPEC,           /* No CLS field in ID */
+	PARPORT_CLASS_SCSIADAPTER
+} parport_device_class;
+
+/* The "modes" entry in parport is a bit field representing the
+   capabilities of the hardware. */
+#define PARPORT_MODE_PCSPP	(1<<0) /* IBM PC registers available. */
+#define PARPORT_MODE_TRISTATE	(1<<1) /* Can tristate. */
+#define PARPORT_MODE_EPP	(1<<2) /* Hardware EPP. */
+#define PARPORT_MODE_ECP	(1<<3) /* Hardware ECP. */
+#define PARPORT_MODE_COMPAT	(1<<4) /* Hardware 'printer protocol'. */
+#define PARPORT_MODE_DMA	(1<<5) /* Hardware can DMA. */
+#define PARPORT_MODE_SAFEININT	(1<<6) /* SPP registers accessible in IRQ. */
+
+/* IEEE1284 modes: 
+   Nibble mode, byte mode, ECP, ECPRLE and EPP are their own
+   'extensibility request' values.  Others are special.
+   'Real' ECP modes must have the IEEE1284_MODE_ECP bit set.  */
+#define IEEE1284_MODE_NIBBLE             0
+#define IEEE1284_MODE_BYTE              (1<<0)
+#define IEEE1284_MODE_COMPAT            (1<<8)
+#define IEEE1284_MODE_BECP              (1<<9) /* Bounded ECP mode */
+#define IEEE1284_MODE_ECP               (1<<4)
+#define IEEE1284_MODE_ECPRLE            (IEEE1284_MODE_ECP | (1<<5))
+#define IEEE1284_MODE_ECPSWE            (1<<10) /* Software-emulated */
+#define IEEE1284_MODE_EPP               (1<<6)
+#define IEEE1284_MODE_EPPSL             (1<<11) /* EPP 1.7 */
+#define IEEE1284_MODE_EPPSWE            (1<<12) /* Software-emulated */
+#define IEEE1284_DEVICEID               (1<<2)  /* This is a flag */
+#define IEEE1284_EXT_LINK               (1<<14) /* This flag causes the
+						 * extensibility link to
+						 * be requested, using
+						 * bits 0-6. */
+
+/* For the benefit of parport_read/write, you can use these with
+ * parport_negotiate to use address operations.  They have no effect
+ * other than to make parport_read/write use address transfers. */
+#define IEEE1284_ADDR			(1<<13)	/* This is a flag */
+#define IEEE1284_DATA			 0	/* So is this */
+
+/* Flags for block transfer operations. */
+#define PARPORT_EPP_FAST		(1<<0) /* Unreliable counts. */
+#define PARPORT_W91284PIC		(1<<1) /* have a Warp9 w91284pic in the device */
+
+/* The rest is for the kernel only */
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/jiffies.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/semaphore.h>
+
+/* Define this later. */
+struct parport;
+struct pardevice;
+
+struct pc_parport_state {
+	unsigned int ctr;
+	unsigned int ecr;
+};
+
+struct ax_parport_state {
+	unsigned int ctr;
+	unsigned int ecr;
+	unsigned int dcsr;
+};
+
+/* used by both parport_amiga and parport_mfc3 */
+struct amiga_parport_state {
+       unsigned char data;     /* ciaa.prb */
+       unsigned char datadir;  /* ciaa.ddrb */
+       unsigned char status;   /* ciab.pra & 7 */
+       unsigned char statusdir;/* ciab.ddrb & 7 */
+};
+
+struct parport_state {
+	union {
+		struct pc_parport_state pc;
+		/* ARC has no state. */
+		struct ax_parport_state ax;
+		struct amiga_parport_state amiga;
+		/* Atari has not state. */
+		void *misc; 
+	} u;
+};
+
+struct parport_operations {
+	/* IBM PC-style virtual registers. */
+	void (*write_data)(struct parport *, unsigned char);
+	unsigned char (*read_data)(struct parport *);
+
+	void (*write_control)(struct parport *, unsigned char);
+	unsigned char (*read_control)(struct parport *);
+	unsigned char (*frob_control)(struct parport *, unsigned char mask,
+				      unsigned char val);
+
+	unsigned char (*read_status)(struct parport *);
+
+	/* IRQs. */
+	void (*enable_irq)(struct parport *);
+	void (*disable_irq)(struct parport *);
+
+	/* Data direction. */
+	void (*data_forward) (struct parport *);
+	void (*data_reverse) (struct parport *);
+
+	/* For core parport code. */
+	void (*init_state)(struct pardevice *, struct parport_state *);
+	void (*save_state)(struct parport *, struct parport_state *);
+	void (*restore_state)(struct parport *, struct parport_state *);
+
+	/* Block read/write */
+	size_t (*epp_write_data) (struct parport *port, const void *buf,
+				  size_t len, int flags);
+	size_t (*epp_read_data) (struct parport *port, void *buf, size_t len,
+				 int flags);
+	size_t (*epp_write_addr) (struct parport *port, const void *buf,
+				  size_t len, int flags);
+	size_t (*epp_read_addr) (struct parport *port, void *buf, size_t len,
+				 int flags);
+
+	size_t (*ecp_write_data) (struct parport *port, const void *buf,
+				  size_t len, int flags);
+	size_t (*ecp_read_data) (struct parport *port, void *buf, size_t len,
+				 int flags);
+	size_t (*ecp_write_addr) (struct parport *port, const void *buf,
+				  size_t len, int flags);
+
+	size_t (*compat_write_data) (struct parport *port, const void *buf,
+				     size_t len, int flags);
+	size_t (*nibble_read_data) (struct parport *port, void *buf,
+				    size_t len, int flags);
+	size_t (*byte_read_data) (struct parport *port, void *buf,
+				  size_t len, int flags);
+	struct module *owner;
+};
+
+struct parport_device_info {
+	parport_device_class class;
+	const char *class_name;
+	const char *mfr;
+	const char *model;
+	const char *cmdset;
+	const char *description;
+};
+
+/* Each device can have two callback functions:
+ *  1) a preemption function, called by the resource manager to request
+ *     that the driver relinquish control of the port.  The driver should
+ *     return zero if it agrees to release the port, and nonzero if it 
+ *     refuses.  Do not call parport_release() - the kernel will do this
+ *     implicitly.
+ *
+ *  2) a wake-up function, called by the resource manager to tell drivers
+ *     that the port is available to be claimed.  If a driver wants to use
+ *     the port, it should call parport_claim() here.
+ */
+
+/* A parallel port device */
+struct pardevice {
+	const char *name;
+	struct parport *port;
+	int daisy;
+	int (*preempt)(void *);
+	void (*wakeup)(void *);
+	void *private;
+	void (*irq_func)(int, void *, struct pt_regs *);
+	unsigned int flags;
+	struct pardevice *next;
+	struct pardevice *prev;
+	struct parport_state *state;     /* saved status over preemption */
+	wait_queue_head_t wait_q;
+	unsigned long int time;
+	unsigned long int timeslice;
+	volatile long int timeout;
+	unsigned long waiting;		 /* long req'd for set_bit --RR */
+	struct pardevice *waitprev;
+	struct pardevice *waitnext;
+	void * sysctl_table;
+};
+
+/* IEEE1284 information */
+
+/* IEEE1284 phases */
+enum ieee1284_phase {
+	IEEE1284_PH_FWD_DATA,
+	IEEE1284_PH_FWD_IDLE,
+	IEEE1284_PH_TERMINATE,
+	IEEE1284_PH_NEGOTIATION,
+	IEEE1284_PH_HBUSY_DNA,
+	IEEE1284_PH_REV_IDLE,
+	IEEE1284_PH_HBUSY_DAVAIL,
+	IEEE1284_PH_REV_DATA,
+	IEEE1284_PH_ECP_SETUP,
+	IEEE1284_PH_ECP_FWD_TO_REV,
+	IEEE1284_PH_ECP_REV_TO_FWD,
+	IEEE1284_PH_ECP_DIR_UNKNOWN,
+};
+struct ieee1284_info {
+	int mode;
+	volatile enum ieee1284_phase phase;
+	struct semaphore irq;
+};
+
+/* A parallel port */
+struct parport {
+	unsigned long base;	/* base address */
+	unsigned long base_hi;  /* base address (hi - ECR) */
+	unsigned int size;	/* IO extent */
+	const char *name;
+	unsigned int modes;
+	int irq;		/* interrupt (or -1 for none) */
+	int dma;
+	int muxport;		/* which muxport (if any) this is */
+	int portnum;		/* which physical parallel port (not mux) */
+
+	struct parport *physport;
+				/* If this is a non-default mux
+				   parport, i.e. we're a clone of a real
+				   physical port, this is a pointer to that
+				   port. The locking is only done in the
+				   real port.  For a clone port, the
+				   following structure members are
+				   meaningless: devices, cad, muxsel,
+				   waithead, waittail, flags, pdir,
+				   ieee1284, *_lock.
+
+				   It this is a default mux parport, or
+				   there is no mux involved, this points to
+				   ourself. */
+
+	struct pardevice *devices;
+	struct pardevice *cad;	/* port owner */
+	int daisy;		/* currently selected daisy addr */
+	int muxsel;		/* currently selected mux port */
+
+	struct pardevice *waithead;
+	struct pardevice *waittail;
+	
+	struct list_head list;
+	unsigned int flags;
+
+	void *sysctl_table;
+	struct parport_device_info probe_info[5]; /* 0-3 + non-IEEE1284.3 */
+	struct ieee1284_info ieee1284;
+
+	struct parport_operations *ops;
+	void *private_data;     /* for lowlevel driver */
+
+	int number;		/* port index - the `n' in `parportn' */
+	spinlock_t pardevice_lock;
+	spinlock_t waitlist_lock;
+	rwlock_t cad_lock;
+
+	int spintime;
+	atomic_t ref_count;
+
+	struct list_head full_list;
+	struct parport *slaves[3];
+};
+
+#define DEFAULT_SPIN_TIME 500 /* us */
+
+struct parport_driver {
+	const char *name;
+	void (*attach) (struct parport *);
+	void (*detach) (struct parport *);
+	struct list_head list;
+};
+
+/* parport_register_port registers a new parallel port at the given
+   address (if one does not already exist) and returns a pointer to it.
+   This entails claiming the I/O region, IRQ and DMA.  NULL is returned
+   if initialisation fails. */
+struct parport *parport_register_port(unsigned long base, int irq, int dma,
+				      struct parport_operations *ops);
+
+/* Once a registered port is ready for high-level drivers to use, the
+   low-level driver that registered it should announce it.  This will
+   call the high-level drivers' attach() functions (after things like
+   determining the IEEE 1284.3 topology of the port and collecting
+   DeviceIDs). */
+void parport_announce_port (struct parport *port);
+
+/* Unregister a port. */
+extern void parport_remove_port(struct parport *port);
+
+/* Register a new high-level driver. */
+extern int parport_register_driver (struct parport_driver *);
+
+/* Unregister a high-level driver. */
+extern void parport_unregister_driver (struct parport_driver *);
+
+/* If parport_register_driver doesn't fit your needs, perhaps
+ * parport_find_xxx does. */
+extern struct parport *parport_find_number (int);
+extern struct parport *parport_find_base (unsigned long);
+
+/* Reference counting for ports. */
+extern struct parport *parport_get_port (struct parport *);
+extern void parport_put_port (struct parport *);
+
+/* parport_register_device declares that a device is connected to a
+   port, and tells the kernel all it needs to know.
+   - pf is the preemption function (may be NULL for no callback)
+   - kf is the wake-up function (may be NULL for no callback)
+   - irq_func is the interrupt handler (may be NULL for no interrupts)
+   - handle is a user pointer that gets handed to callback functions.  */
+struct pardevice *parport_register_device(struct parport *port, 
+			  const char *name,
+			  int (*pf)(void *), void (*kf)(void *),
+			  void (*irq_func)(int, void *, struct pt_regs *), 
+			  int flags, void *handle);
+
+/* parport_unregister unlinks a device from the chain. */
+extern void parport_unregister_device(struct pardevice *dev);
+
+/* parport_claim tries to gain ownership of the port for a particular
+   driver.  This may fail (return non-zero) if another driver is busy.
+   If this driver has registered an interrupt handler, it will be
+   enabled.  */
+extern int parport_claim(struct pardevice *dev);
+
+/* parport_claim_or_block is the same, but sleeps if the port cannot
+   be claimed.  Return value is 1 if it slept, 0 normally and -errno
+   on error.  */
+extern int parport_claim_or_block(struct pardevice *dev);
+
+/* parport_release reverses a previous parport_claim.  This can never
+   fail, though the effects are undefined (except that they are bad)
+   if you didn't previously own the port.  Once you have released the
+   port you should make sure that neither your code nor the hardware
+   on the port tries to initiate any communication without first
+   re-claiming the port.  If you mess with the port state (enabling
+   ECP for example) you should clean up before releasing the port. */
+
+extern void parport_release(struct pardevice *dev);
+
+/**
+ * parport_yield - relinquish a parallel port temporarily
+ * @dev: a device on the parallel port
+ *
+ * This function relinquishes the port if it would be helpful to other
+ * drivers to do so.  Afterwards it tries to reclaim the port using
+ * parport_claim(), and the return value is the same as for
+ * parport_claim().  If it fails, the port is left unclaimed and it is
+ * the driver's responsibility to reclaim the port.
+ *
+ * The parport_yield() and parport_yield_blocking() functions are for
+ * marking points in the driver at which other drivers may claim the
+ * port and use their devices.  Yielding the port is similar to
+ * releasing it and reclaiming it, but is more efficient because no
+ * action is taken if there are no other devices needing the port.  In
+ * fact, nothing is done even if there are other devices waiting but
+ * the current device is still within its "timeslice".  The default
+ * timeslice is half a second, but it can be adjusted via the /proc
+ * interface.
+ **/
+static __inline__ int parport_yield(struct pardevice *dev)
+{
+	unsigned long int timeslip = (jiffies - dev->time);
+	if ((dev->port->waithead == NULL) || (timeslip < dev->timeslice))
+		return 0;
+	parport_release(dev);
+	return parport_claim(dev);
+}
+
+/**
+ * parport_yield_blocking - relinquish a parallel port temporarily
+ * @dev: a device on the parallel port
+ *
+ * This function relinquishes the port if it would be helpful to other
+ * drivers to do so.  Afterwards it tries to reclaim the port using
+ * parport_claim_or_block(), and the return value is the same as for
+ * parport_claim_or_block().
+ **/
+static __inline__ int parport_yield_blocking(struct pardevice *dev)
+{
+	unsigned long int timeslip = (jiffies - dev->time);
+	if ((dev->port->waithead == NULL) || (timeslip < dev->timeslice))
+		return 0;
+	parport_release(dev);
+	return parport_claim_or_block(dev);
+}
+
+/* Flags used to identify what a device does. */
+#define PARPORT_DEV_TRAN		0	/* WARNING !! DEPRECATED !! */
+#define PARPORT_DEV_LURK		(1<<0)	/* WARNING !! DEPRECATED !! */
+#define PARPORT_DEV_EXCL		(1<<1)	/* Need exclusive access. */
+
+#define PARPORT_FLAG_EXCL		(1<<1)	/* EXCL driver registered. */
+
+/* IEEE1284 functions */
+extern void parport_ieee1284_interrupt (int, void *, struct pt_regs *);
+extern int parport_negotiate (struct parport *, int mode);
+extern ssize_t parport_write (struct parport *, const void *buf, size_t len);
+extern ssize_t parport_read (struct parport *, void *buf, size_t len);
+
+#define PARPORT_INACTIVITY_O_NONBLOCK 1
+extern long parport_set_timeout (struct pardevice *, long inactivity);
+
+extern int parport_wait_event (struct parport *, long timeout);
+extern int parport_wait_peripheral (struct parport *port,
+				    unsigned char mask,
+				    unsigned char val);
+extern int parport_poll_peripheral (struct parport *port,
+				    unsigned char mask,
+				    unsigned char val,
+				    int usec);
+
+/* For architectural drivers */
+extern size_t parport_ieee1284_write_compat (struct parport *,
+					     const void *, size_t, int);
+extern size_t parport_ieee1284_read_nibble (struct parport *,
+					    void *, size_t, int);
+extern size_t parport_ieee1284_read_byte (struct parport *,
+					  void *, size_t, int);
+extern size_t parport_ieee1284_ecp_read_data (struct parport *,
+					      void *, size_t, int);
+extern size_t parport_ieee1284_ecp_write_data (struct parport *,
+					       const void *, size_t, int);
+extern size_t parport_ieee1284_ecp_write_addr (struct parport *,
+					       const void *, size_t, int);
+extern size_t parport_ieee1284_epp_write_data (struct parport *,
+					       const void *, size_t, int);
+extern size_t parport_ieee1284_epp_read_data (struct parport *,
+					      void *, size_t, int);
+extern size_t parport_ieee1284_epp_write_addr (struct parport *,
+					       const void *, size_t, int);
+extern size_t parport_ieee1284_epp_read_addr (struct parport *,
+					      void *, size_t, int);
+
+/* IEEE1284.3 functions */
+extern int parport_daisy_init (struct parport *port);
+extern void parport_daisy_fini (struct parport *port);
+extern struct pardevice *parport_open (int devnum, const char *name,
+				       int (*pf) (void *),
+				       void (*kf) (void *),
+				       void (*irqf) (int, void *,
+						     struct pt_regs *),
+				       int flags, void *handle);
+extern void parport_close (struct pardevice *dev);
+extern ssize_t parport_device_id (int devnum, char *buffer, size_t len);
+extern int parport_device_num (int parport, int mux, int daisy);
+extern void parport_daisy_deselect_all (struct parport *port);
+extern int parport_daisy_select (struct parport *port, int daisy, int mode);
+
+/* Lowlevel drivers _can_ call this support function to handle irqs.  */
+static __inline__ void parport_generic_irq(int irq, struct parport *port,
+					   struct pt_regs *regs)
+{
+	parport_ieee1284_interrupt (irq, port, regs);
+	read_lock(&port->cad_lock);
+	if (port->cad && port->cad->irq_func)
+		port->cad->irq_func(irq, port->cad->private, regs);
+	read_unlock(&port->cad_lock);
+}
+
+/* Prototypes from parport_procfs */
+extern int parport_proc_register(struct parport *pp);
+extern int parport_proc_unregister(struct parport *pp);
+extern int parport_device_proc_register(struct pardevice *device);
+extern int parport_device_proc_unregister(struct pardevice *device);
+
+/* If PC hardware is the only type supported, we can optimise a bit.  */
+#if !defined(CONFIG_PARPORT_NOT_PC)
+
+#include <linux/parport_pc.h>
+#define parport_write_data(p,x)            parport_pc_write_data(p,x)
+#define parport_read_data(p)               parport_pc_read_data(p)
+#define parport_write_control(p,x)         parport_pc_write_control(p,x)
+#define parport_read_control(p)            parport_pc_read_control(p)
+#define parport_frob_control(p,m,v)        parport_pc_frob_control(p,m,v)
+#define parport_read_status(p)             parport_pc_read_status(p)
+#define parport_enable_irq(p)              parport_pc_enable_irq(p)
+#define parport_disable_irq(p)             parport_pc_disable_irq(p)
+#define parport_data_forward(p)            parport_pc_data_forward(p)
+#define parport_data_reverse(p)            parport_pc_data_reverse(p)
+
+#else  /*  !CONFIG_PARPORT_NOT_PC  */
+
+/* Generic operations vector through the dispatch table. */
+#define parport_write_data(p,x)            (p)->ops->write_data(p,x)
+#define parport_read_data(p)               (p)->ops->read_data(p)
+#define parport_write_control(p,x)         (p)->ops->write_control(p,x)
+#define parport_read_control(p)            (p)->ops->read_control(p)
+#define parport_frob_control(p,m,v)        (p)->ops->frob_control(p,m,v)
+#define parport_read_status(p)             (p)->ops->read_status(p)
+#define parport_enable_irq(p)              (p)->ops->enable_irq(p)
+#define parport_disable_irq(p)             (p)->ops->disable_irq(p)
+#define parport_data_forward(p)            (p)->ops->data_forward(p)
+#define parport_data_reverse(p)            (p)->ops->data_reverse(p)
+
+#endif /*  !CONFIG_PARPORT_NOT_PC  */
+
+#endif /* __KERNEL__ */
+#endif /* _PARPORT_H_ */
