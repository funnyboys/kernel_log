commit c6b38fbbde91ee7b072febe4b83022e4850f934f
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Mar 1 10:24:59 2019 +0100

    drm: move i915_kick_out_vgacon to vgaarb
    
    Also rename it to vga_remove_vgacon and add kerneldoc text.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190301092502.30948-2-kraxel@redhat.com

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index ee162e3e879b..553b34c8b5f7 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -125,9 +125,11 @@ extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
 #ifdef CONFIG_VGA_ARB
 extern struct pci_dev *vga_default_device(void);
 extern void vga_set_default_device(struct pci_dev *pdev);
+extern int vga_remove_vgacon(struct pci_dev *pdev);
 #else
 static inline struct pci_dev *vga_default_device(void) { return NULL; };
 static inline void vga_set_default_device(struct pci_dev *pdev) { };
+static inline int vga_remove_vgacon(struct pci_dev *pdev) { return 0; };
 #endif
 
 /*

commit b754b35b089ddfea3ff7b9b1d2e99e61d726d177
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:56 2016 +0200

    vgaarbiter: rst-ifiy and polish kerneldoc
    
    Move the documentation into Documentation/gpu, link it up and pull in
    the kernel doc.
    
    No actual text changes except that I did polish the kerneldoc a bit,
    especially for vga_client_register().
    
    v2: Remove some rst from vga-switcheroo.rst that I don't understand,
    but which seems to be the reason why the new vgaarbiter.rst sometimes
    drops out of the sidebar index.
    
    v3: Drop one level of headings and clarify the vgaarb one a bit.
    
    v4: Fix some typos (Sean).
    
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: linux-doc@vger.kernel.org
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-20-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 8c3b412d84df..ee162e3e879b 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -73,34 +73,6 @@ static inline void vga_set_legacy_decoding(struct pci_dev *pdev,
 					   unsigned int decodes) { };
 #endif
 
-/**
- *     vga_get         - acquire & locks VGA resources
- *
- *     @pdev: pci device of the VGA card or NULL for the system default
- *     @rsrc: bit mask of resources to acquire and lock
- *     @interruptible: blocking should be interruptible by signals ?
- *
- *     This function acquires VGA resources for the given
- *     card and mark those resources locked. If the resource requested
- *     are "normal" (and not legacy) resources, the arbiter will first check
- *     whether the card is doing legacy decoding for that type of resource. If
- *     yes, the lock is "converted" into a legacy resource lock.
- *     The arbiter will first look for all VGA cards that might conflict
- *     and disable their IOs and/or Memory access, including VGA forwarding
- *     on P2P bridges if necessary, so that the requested resources can
- *     be used. Then, the card is marked as locking these resources and
- *     the IO and/or Memory accesse are enabled on the card (including
- *     VGA forwarding on parent P2P bridges if any).
- *     This function will block if some conflicting card is already locking
- *     one of the required resources (or any resource on a different bus
- *     segment, since P2P bridges don't differenciate VGA memory and IO
- *     afaik). You can indicate whether this blocking should be interruptible
- *     by a signal (for userland interface) or not.
- *     Must not be called at interrupt time or in atomic context.
- *     If the card already owns the resources, the function succeeds.
- *     Nested calls are supported (a per-resource counter is maintained)
- */
-
 #if defined(CONFIG_VGA_ARB)
 extern int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible);
 #else
@@ -108,11 +80,14 @@ static inline int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interrupt
 #endif
 
 /**
- *     vga_get_interruptible
+ * vga_get_interruptible
+ * @pdev: pci device of the VGA card or NULL for the system default
+ * @rsrc: bit mask of resources to acquire and lock
  *
- *     Shortcut to vga_get
+ * Shortcut to vga_get with interruptible set to true.
+ *
+ * On success, release the VGA resource again with vga_put().
  */
-
 static inline int vga_get_interruptible(struct pci_dev *pdev,
 					unsigned int rsrc)
 {
@@ -120,47 +95,26 @@ static inline int vga_get_interruptible(struct pci_dev *pdev,
 }
 
 /**
- *     vga_get_uninterruptible
+ * vga_get_uninterruptible - shortcut to vga_get()
+ * @pdev: pci device of the VGA card or NULL for the system default
+ * @rsrc: bit mask of resources to acquire and lock
  *
- *     Shortcut to vga_get
+ * Shortcut to vga_get with interruptible set to false.
+ *
+ * On success, release the VGA resource again with vga_put().
  */
-
 static inline int vga_get_uninterruptible(struct pci_dev *pdev,
 					  unsigned int rsrc)
 {
        return vga_get(pdev, rsrc, 0);
 }
 
-/**
- *     vga_tryget      - try to acquire & lock legacy VGA resources
- *
- *     @pdev: pci devivce of VGA card or NULL for system default
- *     @rsrc: bit mask of resources to acquire and lock
- *
- *     This function performs the same operation as vga_get(), but
- *     will return an error (-EBUSY) instead of blocking if the resources
- *     are already locked by another card. It can be called in any context
- */
-
 #if defined(CONFIG_VGA_ARB)
 extern int vga_tryget(struct pci_dev *pdev, unsigned int rsrc);
 #else
 static inline int vga_tryget(struct pci_dev *pdev, unsigned int rsrc) { return 0; }
 #endif
 
-/**
- *     vga_put         - release lock on legacy VGA resources
- *
- *     @pdev: pci device of VGA card or NULL for system default
- *     @rsrc: but mask of resource to release
- *
- *     This function releases resources previously locked by vga_get()
- *     or vga_tryget(). The resources aren't disabled right away, so
- *     that a subsequence vga_get() on the same card will succeed
- *     immediately. Resources have a counter, so locks are only
- *     released if the counter reaches 0.
- */
-
 #if defined(CONFIG_VGA_ARB)
 extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
 #else
@@ -168,25 +122,6 @@ extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
 #endif
 
 
-/**
- *     vga_default_device
- *
- *     This can be defined by the platform. The default implementation
- *     is rather dumb and will probably only work properly on single
- *     vga card setups and/or x86 platforms.
- *
- *     If your VGA default device is not PCI, you'll have to return
- *     NULL here. In this case, I assume it will not conflict with
- *     any PCI card. If this is not true, I'll have to define two archs
- *     hooks for enabling/disabling the VGA default device if that is
- *     possible. This may be a problem with real _ISA_ VGA cards, in
- *     addition to a PCI one. I don't know at this point how to deal
- *     with that card. Can theirs IOs be disabled at all ? If not, then
- *     I suppose it's a matter of having the proper arch hook telling
- *     us about it, so we basically never allow anybody to succeed a
- *     vga_get()...
- */
-
 #ifdef CONFIG_VGA_ARB
 extern struct pci_dev *vga_default_device(void);
 extern void vga_set_default_device(struct pci_dev *pdev);
@@ -195,14 +130,11 @@ static inline struct pci_dev *vga_default_device(void) { return NULL; };
 static inline void vga_set_default_device(struct pci_dev *pdev) { };
 #endif
 
-/**
- *     vga_conflicts
- *
- *     Architectures should define this if they have several
- *     independent PCI domains that can afford concurrent VGA
- *     decoding
+/*
+ * Architectures should define this if they have several
+ * independent PCI domains that can afford concurrent VGA
+ * decoding
  */
-
 #ifndef __ARCH_HAS_VGA_CONFLICT
 static inline int vga_conflicts(struct pci_dev *p1, struct pci_dev *p2)
 {
@@ -210,34 +142,6 @@ static inline int vga_conflicts(struct pci_dev *p1, struct pci_dev *p2)
 }
 #endif
 
-/**
- *	vga_client_register
- *
- *	@pdev: pci device of the VGA client
- *	@cookie: client cookie to be used in callbacks
- *	@irq_set_state: irq state change callback
- *	@set_vga_decode: vga decode change callback
- *
- * 	return value: 0 on success, -1 on failure
- * 	Register a client with the VGA arbitration logic
- *
- *	Clients have two callback mechanisms they can use.
- *	irq enable/disable callback -
- *		If a client can't disable its GPUs VGA resources, then we
- *		need to be able to ask it to turn off its irqs when we
- *		turn off its mem and io decoding.
- *	set_vga_decode
- *		If a client can disable its GPU VGA resource, it will
- *		get a callback from this to set the encode/decode state
- *
- * Rationale: we cannot disable VGA decode resources unconditionally
- * some single GPU laptops seem to require ACPI or BIOS access to the
- * VGA registers to control things like backlights etc.
- * Hopefully newer multi-GPU laptops do something saner, and desktops
- * won't have any special ACPI for this.
- * They driver will get a callback when VGA arbitration is first used
- * by userspace since we some older X servers have issues.
- */
 #if defined(CONFIG_VGA_ARB)
 int vga_client_register(struct pci_dev *pdev, void *cookie,
 			void (*irq_set_state)(void *cookie, bool state),

commit 0ea18b40cdd382a8a338d02e06c4646c35bd753b
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Apr 7 11:14:38 2015 -0600

    vgaarb: Stub vga_set_legacy_decoding()
    
    vga_set_legacy_decoding() is defined in drivers/gpu/vga/vgaarb.c,
    which is only compiled with CONFIG_VGA_ARB.  A caller would
    therefore get an undefined symbol if the VGA arbiter is not
    enabled.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index c37bd4d06739..8c3b412d84df 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -65,8 +65,13 @@ struct pci_dev;
  *     out of the arbitration process (and can be safe to take
  *     interrupts at any time.
  */
+#if defined(CONFIG_VGA_ARB)
 extern void vga_set_legacy_decoding(struct pci_dev *pdev,
 				    unsigned int decodes);
+#else
+static inline void vga_set_legacy_decoding(struct pci_dev *pdev,
+					   unsigned int decodes) { };
+#endif
 
 /**
  *     vga_get         - acquire & locks VGA resources

commit ce6eacb07e287c0c3c8b5c316a9a7f9cecf69e95
Author: Bruno Prémont <bonbons@linux-vserver.org>
Date:   Sun Aug 24 23:13:15 2014 +0200

    vgaarb: Drop obsolete #ifndef
    
    Commit 20cde694027e ("x86, ia64: Move EFI_FB vga_default_device()
    initialization to pci_vga_fixup()") moved boot video device detection from
    efifb to x86 and ia64 pci/fixup.c.
    
    Remove the left-over #ifndef check that will always match since the
    corresponding arch-specific define is gone with above patch.
    
    Signed-off-by: Bruno Prémont <bonbons@linux-vserver.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Matthew Garrett <matthew.garrett@nebula.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 2c02f3a8d2ba..c37bd4d06739 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -182,7 +182,6 @@ extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
  *     vga_get()...
  */
 
-#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE
 #ifdef CONFIG_VGA_ARB
 extern struct pci_dev *vga_default_device(void);
 extern void vga_set_default_device(struct pci_dev *pdev);
@@ -190,7 +189,6 @@ extern void vga_set_default_device(struct pci_dev *pdev);
 static inline struct pci_dev *vga_default_device(void) { return NULL; };
 static inline void vga_set_default_device(struct pci_dev *pdev) { };
 #endif
-#endif
 
 /**
  *     vga_conflicts

commit ebff5fa9d545574324095d9c6a3cb80c9157abc5
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 15:12:04 2013 +1000

    Revert "i915: Update VGA arbiter support for newer devices"
    
    This reverts commit 81b5c7bc8de3e6f63419139c2fc91bf81dea8a7d.
    
    Adding drm/i915 into the vga arbiter chain means that X (in a piece of
    well-meant paranoia) will do a get/put on the vga decoding around
    _every_ accel call down into the ddx. Which results in some nice
    performance disasters [1]. This really breaks userspace, by disabling
    DRI for everyone, and stops OpenGL from working, this isn't limited
    to just the i915 but both the integrated and discrete GPUs on
    multi-gpu systems, in other words this causes untold worlds of pain,
    
    Ville tried to come up with a Great Hack to fiddle the required VGA
    I/O ops behind everyone's back using stop_machine, but that didn't
    really work out [2]. Given that we're fairly late in the -rc stage for
    such games let's just revert this all.
    
    One thing we might want to keep is to delay the disabling of the vga
    decoding until the fbdev emulation and the fbcon screen is set up. If
    we kill vga mem decoding beforehand fbcon can end up with a white
    square in the top-left corner it tried to save from the vga memory for
    a seamless transition. And we have bug reports on older platforms
    which seem to match these symptoms.
    
    But again that's something to play around with in -next.
    
    References: [1] http://lists.x.org/archives/xorg-devel/2013-September/037763.html
    References: [2] http://www.spinics.net/lists/intel-gfx/msg34062.html
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 80cf8173a65b..2c02f3a8d2ba 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -65,15 +65,8 @@ struct pci_dev;
  *     out of the arbitration process (and can be safe to take
  *     interrupts at any time.
  */
-#if defined(CONFIG_VGA_ARB)
 extern void vga_set_legacy_decoding(struct pci_dev *pdev,
 				    unsigned int decodes);
-#else
-static inline void vga_set_legacy_decoding(struct pci_dev *pdev,
-					   unsigned int decodes)
-{
-}
-#endif
 
 /**
  *     vga_get         - acquire & locks VGA resources

commit 81b5c7bc8de3e6f63419139c2fc91bf81dea8a7d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Aug 28 09:39:08 2013 -0600

    i915: Update VGA arbiter support for newer devices
    
    This is intended to add VGA arbiter support for Intel HD graphics on
    Core processors.  The old GMCH registers no longer exist, so even
    though it appears that i915 participates in VGA arbitration, it doesn't
    work.  On Intel HD graphics we already attempt to disable VGA regions
    of the device.  This makes registering as a VGA client unnecessary since
    we don't intend to operate differently depending on how many VGA devices
    are present.  We can disable VGA memory regions by clearing the memory
    enable bit in the VGA MSR.  That only leaves VGA IO, which we update
    the VGA arbiter to know that we don't participate in VGA memory
    arbitration.  We also add a hook on unload to re-enable memory and
    reinstate VGA memory arbitration.
    
    v3: Use explicit LEGACY_IO | LEGACY_MEM when restoring rather than
        LEGACY_MASK, per Ville's comments.
    
    v2: I915_READ/WRITE accessors don't work in i915_disable_vga, use inb/outb
        directly.  Also, on the driver unbind VGA enable path, acquire legacy
        IO to re-enable VGA memory.  Correct comment.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    [danvet: Add patch changelog. Also squash in a fixup to have a dummy
    static inline for vga_set_legacy_decoding for CONFIG_VGA_ARB=n as
    reported by the 0-day kernel build bot.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    
    fixup 2

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 2c02f3a8d2ba..80cf8173a65b 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -65,8 +65,15 @@ struct pci_dev;
  *     out of the arbitration process (and can be safe to take
  *     interrupts at any time.
  */
+#if defined(CONFIG_VGA_ARB)
 extern void vga_set_legacy_decoding(struct pci_dev *pdev,
 				    unsigned int decodes);
+#else
+static inline void vga_set_legacy_decoding(struct pci_dev *pdev,
+					   unsigned int decodes)
+{
+}
+#endif
 
 /**
  *     vga_get         - acquire & locks VGA resources

commit 48fc7f7e787dd65ffe88521bce31f4062ba273eb
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Sep 19 21:48:00 2012 -0400

    Fix misspellings of "whether" in comments.
    
    "Whether" is misspelled in various comments across the tree; this
    fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 0ee42d9acdc0..2c02f3a8d2ba 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -78,7 +78,7 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
  *     This function acquires VGA resources for the given
  *     card and mark those resources locked. If the resource requested
  *     are "normal" (and not legacy) resources, the arbiter will first check
- *     wether the card is doing legacy decoding for that type of resource. If
+ *     whether the card is doing legacy decoding for that type of resource. If
  *     yes, the lock is "converted" into a legacy resource lock.
  *     The arbiter will first look for all VGA cards that might conflict
  *     and disable their IOs and/or Memory access, including VGA forwarding
@@ -89,7 +89,7 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
  *     This function will block if some conflicting card is already locking
  *     one of the required resources (or any resource on a different bus
  *     segment, since P2P bridges don't differenciate VGA memory and IO
- *     afaik). You can indicate wether this blocking should be interruptible
+ *     afaik). You can indicate whether this blocking should be interruptible
  *     by a signal (for userland interface) or not.
  *     Must not be called at interrupt time or in atomic context.
  *     If the card already owns the resources, the function succeeds.

commit 6e079d53c116ed9b95d0cad16237e06d5a60b9c4
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu May 3 09:29:01 2012 +0100

    vgaarb: Provide dummy default device functions
    
    Add some stub functions for the case where CONFIG_VGA_ARB is disabled.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 367ab18dccf7..0ee42d9acdc0 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -183,8 +183,13 @@ extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
  */
 
 #ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE
+#ifdef CONFIG_VGA_ARB
 extern struct pci_dev *vga_default_device(void);
 extern void vga_set_default_device(struct pci_dev *pdev);
+#else
+static inline struct pci_dev *vga_default_device(void) { return NULL; };
+static inline void vga_set_default_device(struct pci_dev *pdev) { };
+#endif
 #endif
 
 /**

commit 5bc69bf9aeb73547cad8e1ce683a103fe9728282
Merge: c6543a6e64ad a85d4bcb8a0c
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 2 09:21:50 2012 +0100

    Merge tag 'drm-intel-next-2012-04-23' of git://people.freedesktop.org/~danvet/drm-intel into drm-core-next
    
    Daniel Vetter writes:
    
    A new drm-intel-next pull. Highlights:
    - More gmbus patches from Daniel Kurtz, I think gmbus is now ready, all
     known issues fixed.
    - Fencing cleanup and pipelined fencing removal from Chris.
    - rc6 residency interface from Ben, useful for powertop.
    - Cleanups and code reorg around the ringbuffer code (Ben&me).
    - Use hw semaphores in the pageflip code from Ben.
    - More vlv stuff from Jesse, unfortunately his vlv cpu is doa, so less
     merged than I've hoped for - we still have the unused function warning :(
    - More hsw patches from Eugeni, again, not yet enabled fully.
    - intel_pm.c refactoring from Eugeni.
    - Ironlake sprite support from Chris.
    - And various smaller improvements/fixes all over the place.
    
    Note that this pull request also contains a backmerge of -rc3 to sort out
    a few things in -next. I've also had to frob the shortlog a bit to exclude
    anything that -rc3 brings in with this pull.
    
    Regression wise we have a few strange bugs going on, but for all of them
    closer inspection revealed that they've been pre-existing, just now
    slightly more likely to be hit. And for most of them we have a patch
    already. Otherwise QA has not reported any regressions, and I'm also not
    aware of anything bad happening in 3.4.
    
    * tag 'drm-intel-next-2012-04-23' of git://people.freedesktop.org/~danvet/drm-intel: (420 commits)
      drm/i915: rc6 residency (fix the fix)
      drm/i915/tv: fix open-coded ARRAY_SIZE.
      drm/i915: invalidate render cache on gen2
      drm/i915: Silence the change of LVDS sync polarity
      drm/i915: add generic power management initialization
      drm/i915: move clock gating functionality into intel_pm module
      drm/i915: move emon functionality into intel_pm module
      drm/i915: move drps, rps and rc6-related functions to intel_pm
      drm/i915: fix line breaks in intel_pm
      drm/i915: move watermarks settings into intel_pm module
      drm/i915: move fbc-related functionality into intel_pm module
      drm/i915: Refactor get_fence() to use the common fence writing routine
      drm/i915: Refactor fence clearing to use the common fence writing routine
      drm/i915: Refactor put_fence() to use the common fence writing routine
      drm/i915: Prepare to consolidate fence writing
      drm/i915: Remove the unsightly "optimisation" from flush_fence()
      drm/i915: Simplify fence finding
      drm/i915: Discard the unused obj->last_fenced_ring
      drm/i915: Remove unused ring->setup_seqno
      drm/i915: Remove fence pipelining
      ...

commit 1a39b310e920bb7098067d96411b31e459ae8f32
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Apr 16 16:26:02 2012 -0400

    vgaarb: Add support for setting the default video device (v2)
    
    The default VGA device is a somewhat fluid concept on platforms with
    multiple GPUs. Add support for setting it so switching code can update
    things appropriately, and make sure that the sysfs code returns the right
    device if it's changed.
    
    v2: Updated to fix builds when __ARCH_HAS_VGA_DEFAULT_DEVICE is false.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Acked-by: benh@kernel.crashing.org
    Cc: airlied@redhat.com
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 9c3120dca294..759a25ba0539 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -31,6 +31,7 @@
 #ifndef LINUX_VGA_H
 #define LINUX_VGA_H
 
+#include <video/vga.h>
 
 /* Legacy VGA regions */
 #define VGA_RSRC_NONE	       0x00
@@ -181,6 +182,7 @@ extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
 
 #ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE
 extern struct pci_dev *vga_default_device(void);
+extern void vga_set_default_device(struct pci_dev *pdev);
 #endif
 
 /**

commit 6069a4c988d75c0fb309fa7da0909df2a222a65e
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Jan 30 11:43:52 2012 -0800

    vgaarb.h: fix build warnings
    
    Fix build warnings by providing a struct stub since no fields of
    the struct are used:
    
    include/linux/vgaarb.h:66:9: warning: 'struct pci_dev' declared inside parameter list
    include/linux/vgaarb.h:66:9: warning: its scope is only this definition or declaration, which is probably not what you want
    include/linux/vgaarb.h:99:34: warning: 'struct pci_dev' declared inside parameter list
    include/linux/vgaarb.h:109:6: warning: 'struct pci_dev' declared inside parameter list
    include/linux/vgaarb.h:121:8: warning: 'struct pci_dev' declared inside parameter list
    include/linux/vgaarb.h:140:37: warning: 'struct pci_dev' declared inside parameter list
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 9c3120dca294..b572f80bdfd5 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -47,6 +47,8 @@
  */
 #define VGA_DEFAULT_DEVICE     (NULL)
 
+struct pci_dev;
+
 /* For use by clients */
 
 /**

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index e9e1524b582c..9c3120dca294 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -78,7 +78,7 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
  *     wether the card is doing legacy decoding for that type of resource. If
  *     yes, the lock is "converted" into a legacy resource lock.
  *     The arbiter will first look for all VGA cards that might conflict
- *     and disable their IOs and/or Memory access, inlcuding VGA forwarding
+ *     and disable their IOs and/or Memory access, including VGA forwarding
  *     on P2P bridges if necessary, so that the requested resources can
  *     be used. Then, the card is marked as locking these resources and
  *     the IO and/or Memory accesse are enabled on the card (including
@@ -187,7 +187,7 @@ extern struct pci_dev *vga_default_device(void);
  *     vga_conflicts
  *
  *     Architectures should define this if they have several
- *     independant PCI domains that can afford concurrent VGA
+ *     independent PCI domains that can afford concurrent VGA
  *     decoding
  */
 

commit 04cbe1de6fbda9649a6f25666194e6955d3e717e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 19 21:29:43 2010 +0100

    vgaarb: Wrap vga_(get|put) in CONFIG_VGA_ARB
    
    Fix link failure without the vga arbitrator.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 6228b5b77d35..e9e1524b582c 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -93,8 +93,11 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
  *     Nested calls are supported (a per-resource counter is maintained)
  */
 
-extern int vga_get(struct pci_dev *pdev, unsigned int rsrc,
-											int interruptible);
+#if defined(CONFIG_VGA_ARB)
+extern int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible);
+#else
+static inline int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible) { return 0; }
+#endif
 
 /**
  *     vga_get_interruptible
@@ -131,7 +134,11 @@ static inline int vga_get_uninterruptible(struct pci_dev *pdev,
  *     are already locked by another card. It can be called in any context
  */
 
+#if defined(CONFIG_VGA_ARB)
 extern int vga_tryget(struct pci_dev *pdev, unsigned int rsrc);
+#else
+static inline int vga_tryget(struct pci_dev *pdev, unsigned int rsrc) { return 0; }
+#endif
 
 /**
  *     vga_put         - release lock on legacy VGA resources
@@ -146,7 +153,11 @@ extern int vga_tryget(struct pci_dev *pdev, unsigned int rsrc);
  *     released if the counter reaches 0.
  */
 
+#if defined(CONFIG_VGA_ARB)
 extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
+#else
+#define vga_put(pdev, rsrc)
+#endif
 
 
 /**

commit 71beefe8c0b9e12ed4ac9fe13b98a035ddeaf8eb
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Aug 12 11:44:50 2010 +1000

    vgaarb: drop vga.h include
    
    We don't actually need this include on any platform.
    
    built on powerpc + x86, reported on m68k.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 814f294d4cd0..6228b5b77d35 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -31,7 +31,6 @@
 #ifndef LINUX_VGA_H
 #define LINUX_VGA_H
 
-#include <asm/vga.h>
 
 /* Legacy VGA regions */
 #define VGA_RSRC_NONE	       0x00

commit a6a1a095ec8ace2912fc280d371eee8ff5da5736
Author: Doug Goldstein <cardoe@gentoo.org>
Date:   Tue Jul 20 15:22:25 2010 -0700

    include/linux/vgaarb.h: add missing part of include guard
    
    vgaarb.h was missing the #define of the #ifndef at the top for the guard
    to prevent multiple #include's from causing re-define errors
    
    Signed-off-by: Doug Goldstein <cardoe@gentoo.org>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index c9a975976995..814f294d4cd0 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -29,6 +29,7 @@
  */
 
 #ifndef LINUX_VGA_H
+#define LINUX_VGA_H
 
 #include <asm/vga.h>
 

commit c0db9cbc73338d8e2987a19a02388d67aeec0bfe
Author: Tiago Vignatti <tiago.vignatti@nokia.com>
Date:   Mon May 24 18:24:31 2010 +0300

    vgaarb: use MIT license
    
    Signed-off-by: Tiago Vignatti <tiago.vignatti@nokia.com>
    Cc: Henry Zhao <Henry.Zhao@Sun.COM>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 2dfaa293ae8c..c9a975976995 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -5,6 +5,27 @@
  * (C) Copyright 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
  * (C) Copyright 2007 Paulo R. Zanoni <przanoni@gmail.com>
  * (C) Copyright 2007, 2009 Tiago Vignatti <vignatti@freedesktop.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS
+ * IN THE SOFTWARE.
+ *
  */
 
 #ifndef LINUX_VGA_H

commit b7f21bb2e23b4fec16b448a34889f467465be659
Merge: 7ca263cdf8cf 76baeebf7df4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 24 09:57:08 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (21 commits)
      x86/PCI: make 32 bit NUMA node array int, not unsigned char
      x86/PCI: default pcibus cpumask to all cpus if it lacks affinity
      MAINTAINTERS: remove hotplug driver entries
      PCI: pciehp: remove slot capabilities definitions
      PCI: pciehp: remove error message definitions
      PCI: pciehp: remove number field
      PCI: pciehp: remove hpc_ops
      PCI: pciehp: remove pci_dev field
      PCI: pciehp: remove crit_sect mutex
      PCI: pciehp: remove slot_bus field
      PCI: pciehp: remove first_slot field
      PCI: pciehp: remove slot_device_offset field
      PCI: pciehp: remove hp_slot field
      PCI: pciehp: remove device field
      PCI: pciehp: remove bus field
      PCI: pciehp: remove slot_num_inc field
      PCI: pciehp: remove num_slots field
      PCI: pciehp: remove slot_list field
      PCI: fix VGA arbiter header file
      PCI: Disable AER with pci=nomsi
      ...
    
    Fixed up trivial conflicts in MAINTAINERS

commit 7c329288d72e025db4feac65f0fed95fb3e3ef1c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Sep 23 09:52:18 2009 +1000

    vgaarb: make client interface config invariant.
    
    Fixes build when VGA_ARB is off.
    
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index e81c64af80c1..923f9040ea20 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -41,7 +41,7 @@
  *     interrupts at any time.
  */
 extern void vga_set_legacy_decoding(struct pci_dev *pdev,
-									unsigned int decodes);
+				    unsigned int decodes);
 
 /**
  *     vga_get         - acquire & locks VGA resources
@@ -193,8 +193,17 @@ static inline int vga_conflicts(struct pci_dev *p1, struct pci_dev *p2)
  * They driver will get a callback when VGA arbitration is first used
  * by userspace since we some older X servers have issues.
  */
+#if defined(CONFIG_VGA_ARB)
 int vga_client_register(struct pci_dev *pdev, void *cookie,
 			void (*irq_set_state)(void *cookie, bool state),
 			unsigned int (*set_vga_decode)(void *cookie, bool state));
+#else
+static inline int vga_client_register(struct pci_dev *pdev, void *cookie,
+				      void (*irq_set_state)(void *cookie, bool state),
+				      unsigned int (*set_vga_decode)(void *cookie, bool state))
+{
+	return 0;
+}
+#endif
 
 #endif /* LINUX_VGA_H */

commit e2d4304b7d2b85c45de89ec420037d6b9261a12d
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Thu Sep 17 09:40:31 2009 -0700

    PCI: fix VGA arbiter header file
    
    Remove reference to vgaarb.c and replace it with a comment about the
    arbiter itself.
    
    Reported-by: Tiago Vignatti <tiago.vignatti@nokia.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index e81c64af80c1..a1fa1da8dc1a 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -1,5 +1,6 @@
 /*
- * vgaarb.c
+ * The VGA aribiter manages VGA space routing and VGA resource decode to
+ * allow multiple VGA devices to be used in a system in a safe way.
  *
  * (C) Copyright 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
  * (C) Copyright 2007 Paulo R. Zanoni <przanoni@gmail.com>

commit 6ac3bd527007eeecb148b67ca47b21731fd8a503
Author: Dave Airlie <airlied@linux.ie>
Date:   Wed Aug 19 15:21:57 2009 +1000

    PCI/vgaarb: cleanup some warnings + cleanup some comments.
    
    Fix some warnings reported in linux-next + also cleanup some
    comment errors noticed by Pekka Paalanen.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
index 68229ce80fde..e81c64af80c1 100644
--- a/include/linux/vgaarb.h
+++ b/include/linux/vgaarb.h
@@ -46,9 +46,9 @@ extern void vga_set_legacy_decoding(struct pci_dev *pdev,
 /**
  *     vga_get         - acquire & locks VGA resources
  *
- *     pdev: pci device of the VGA card or NULL for the system default
- *     rsrc: bit mask of resources to acquire and lock
- *     interruptible: blocking should be interruptible by signals ?
+ *     @pdev: pci device of the VGA card or NULL for the system default
+ *     @rsrc: bit mask of resources to acquire and lock
+ *     @interruptible: blocking should be interruptible by signals ?
  *
  *     This function acquires VGA resources for the given
  *     card and mark those resources locked. If the resource requested
@@ -81,19 +81,19 @@ extern int vga_get(struct pci_dev *pdev, unsigned int rsrc,
  */
 
 static inline int vga_get_interruptible(struct pci_dev *pdev,
-										unsigned int rsrc)
+					unsigned int rsrc)
 {
        return vga_get(pdev, rsrc, 1);
 }
 
 /**
- *     vga_get_interruptible
+ *     vga_get_uninterruptible
  *
  *     Shortcut to vga_get
  */
 
 static inline int vga_get_uninterruptible(struct pci_dev *pdev,
-											unsigned int rsrc)
+					  unsigned int rsrc)
 {
        return vga_get(pdev, rsrc, 0);
 }
@@ -165,28 +165,33 @@ static inline int vga_conflicts(struct pci_dev *p1, struct pci_dev *p2)
 }
 #endif
 
-/*
- * Register a client with the VGA arbitration logic
- * return value: number of VGA devices in system.
- *
- * Clients have two callback mechanisms they can use.
- * irq enable/disable callback -
- *    If a client can't disable its GPUs VGA resources, then we
- *    need to be able to ask it to turn off its irqs when we
- *    turn off its mem and io decoding.
- * set_vga_decode
- *    If a client can disable its GPU VGA resource, it will
- *    get a callback from this to set the encode/decode state
- *
- * Clients with disable abilities should check the return value
- * of this function and if the VGA device count is > 1, should
- * disable VGA decoding resources.
+/**
+ *	vga_client_register
+ *
+ *	@pdev: pci device of the VGA client
+ *	@cookie: client cookie to be used in callbacks
+ *	@irq_set_state: irq state change callback
+ *	@set_vga_decode: vga decode change callback
+ *
+ * 	return value: 0 on success, -1 on failure
+ * 	Register a client with the VGA arbitration logic
+ *
+ *	Clients have two callback mechanisms they can use.
+ *	irq enable/disable callback -
+ *		If a client can't disable its GPUs VGA resources, then we
+ *		need to be able to ask it to turn off its irqs when we
+ *		turn off its mem and io decoding.
+ *	set_vga_decode
+ *		If a client can disable its GPU VGA resource, it will
+ *		get a callback from this to set the encode/decode state
  *
  * Rationale: we cannot disable VGA decode resources unconditionally
  * some single GPU laptops seem to require ACPI or BIOS access to the
  * VGA registers to control things like backlights etc.
  * Hopefully newer multi-GPU laptops do something saner, and desktops
  * won't have any special ACPI for this.
+ * They driver will get a callback when VGA arbitration is first used
+ * by userspace since we some older X servers have issues.
  */
 int vga_client_register(struct pci_dev *pdev, void *cookie,
 			void (*irq_set_state)(void *cookie, bool state),

commit deb2d2ecd43dfc51efe71eed7128fda514da96c6
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Aug 11 15:52:06 2009 +1000

    PCI/GPU: implement VGA arbitration on Linux
    
    Background:
    Graphic devices are accessed through ranges in I/O or memory space. While most
    modern devices allow relocation of such ranges, some "Legacy" VGA devices
    implemented on PCI will typically have the same "hard-decoded" addresses as
    they did on ISA. For more details see "PCI Bus Binding to IEEE Std 1275-1994
    Standard for Boot (Initialization Configuration) Firmware Revision 2.1"
    Section 7, Legacy Devices.
    
    The Resource Access Control (RAC) module inside the X server currently does
    the task of arbitration when more than one legacy device co-exists on the same
    machine. But the problem happens when these devices are trying to be accessed
    by different userspace clients (e.g. two server in parallel). Their address
    assignments conflict. Therefore an arbitration scheme _outside_ of the X
    server is needed to control the sharing of these resources. This document
    introduces the operation of the VGA arbiter implemented for Linux kernel.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Tiago Vignatti <tiago.vignatti@nokia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/vgaarb.h b/include/linux/vgaarb.h
new file mode 100644
index 000000000000..68229ce80fde
--- /dev/null
+++ b/include/linux/vgaarb.h
@@ -0,0 +1,195 @@
+/*
+ * vgaarb.c
+ *
+ * (C) Copyright 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ * (C) Copyright 2007 Paulo R. Zanoni <przanoni@gmail.com>
+ * (C) Copyright 2007, 2009 Tiago Vignatti <vignatti@freedesktop.org>
+ */
+
+#ifndef LINUX_VGA_H
+
+#include <asm/vga.h>
+
+/* Legacy VGA regions */
+#define VGA_RSRC_NONE	       0x00
+#define VGA_RSRC_LEGACY_IO     0x01
+#define VGA_RSRC_LEGACY_MEM    0x02
+#define VGA_RSRC_LEGACY_MASK   (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM)
+/* Non-legacy access */
+#define VGA_RSRC_NORMAL_IO     0x04
+#define VGA_RSRC_NORMAL_MEM    0x08
+
+/* Passing that instead of a pci_dev to use the system "default"
+ * device, that is the one used by vgacon. Archs will probably
+ * have to provide their own vga_default_device();
+ */
+#define VGA_DEFAULT_DEVICE     (NULL)
+
+/* For use by clients */
+
+/**
+ *     vga_set_legacy_decoding
+ *
+ *     @pdev: pci device of the VGA card
+ *     @decodes: bit mask of what legacy regions the card decodes
+ *
+ *     Indicates to the arbiter if the card decodes legacy VGA IOs,
+ *     legacy VGA Memory, both, or none. All cards default to both,
+ *     the card driver (fbdev for example) should tell the arbiter
+ *     if it has disabled legacy decoding, so the card can be left
+ *     out of the arbitration process (and can be safe to take
+ *     interrupts at any time.
+ */
+extern void vga_set_legacy_decoding(struct pci_dev *pdev,
+									unsigned int decodes);
+
+/**
+ *     vga_get         - acquire & locks VGA resources
+ *
+ *     pdev: pci device of the VGA card or NULL for the system default
+ *     rsrc: bit mask of resources to acquire and lock
+ *     interruptible: blocking should be interruptible by signals ?
+ *
+ *     This function acquires VGA resources for the given
+ *     card and mark those resources locked. If the resource requested
+ *     are "normal" (and not legacy) resources, the arbiter will first check
+ *     wether the card is doing legacy decoding for that type of resource. If
+ *     yes, the lock is "converted" into a legacy resource lock.
+ *     The arbiter will first look for all VGA cards that might conflict
+ *     and disable their IOs and/or Memory access, inlcuding VGA forwarding
+ *     on P2P bridges if necessary, so that the requested resources can
+ *     be used. Then, the card is marked as locking these resources and
+ *     the IO and/or Memory accesse are enabled on the card (including
+ *     VGA forwarding on parent P2P bridges if any).
+ *     This function will block if some conflicting card is already locking
+ *     one of the required resources (or any resource on a different bus
+ *     segment, since P2P bridges don't differenciate VGA memory and IO
+ *     afaik). You can indicate wether this blocking should be interruptible
+ *     by a signal (for userland interface) or not.
+ *     Must not be called at interrupt time or in atomic context.
+ *     If the card already owns the resources, the function succeeds.
+ *     Nested calls are supported (a per-resource counter is maintained)
+ */
+
+extern int vga_get(struct pci_dev *pdev, unsigned int rsrc,
+											int interruptible);
+
+/**
+ *     vga_get_interruptible
+ *
+ *     Shortcut to vga_get
+ */
+
+static inline int vga_get_interruptible(struct pci_dev *pdev,
+										unsigned int rsrc)
+{
+       return vga_get(pdev, rsrc, 1);
+}
+
+/**
+ *     vga_get_interruptible
+ *
+ *     Shortcut to vga_get
+ */
+
+static inline int vga_get_uninterruptible(struct pci_dev *pdev,
+											unsigned int rsrc)
+{
+       return vga_get(pdev, rsrc, 0);
+}
+
+/**
+ *     vga_tryget      - try to acquire & lock legacy VGA resources
+ *
+ *     @pdev: pci devivce of VGA card or NULL for system default
+ *     @rsrc: bit mask of resources to acquire and lock
+ *
+ *     This function performs the same operation as vga_get(), but
+ *     will return an error (-EBUSY) instead of blocking if the resources
+ *     are already locked by another card. It can be called in any context
+ */
+
+extern int vga_tryget(struct pci_dev *pdev, unsigned int rsrc);
+
+/**
+ *     vga_put         - release lock on legacy VGA resources
+ *
+ *     @pdev: pci device of VGA card or NULL for system default
+ *     @rsrc: but mask of resource to release
+ *
+ *     This function releases resources previously locked by vga_get()
+ *     or vga_tryget(). The resources aren't disabled right away, so
+ *     that a subsequence vga_get() on the same card will succeed
+ *     immediately. Resources have a counter, so locks are only
+ *     released if the counter reaches 0.
+ */
+
+extern void vga_put(struct pci_dev *pdev, unsigned int rsrc);
+
+
+/**
+ *     vga_default_device
+ *
+ *     This can be defined by the platform. The default implementation
+ *     is rather dumb and will probably only work properly on single
+ *     vga card setups and/or x86 platforms.
+ *
+ *     If your VGA default device is not PCI, you'll have to return
+ *     NULL here. In this case, I assume it will not conflict with
+ *     any PCI card. If this is not true, I'll have to define two archs
+ *     hooks for enabling/disabling the VGA default device if that is
+ *     possible. This may be a problem with real _ISA_ VGA cards, in
+ *     addition to a PCI one. I don't know at this point how to deal
+ *     with that card. Can theirs IOs be disabled at all ? If not, then
+ *     I suppose it's a matter of having the proper arch hook telling
+ *     us about it, so we basically never allow anybody to succeed a
+ *     vga_get()...
+ */
+
+#ifndef __ARCH_HAS_VGA_DEFAULT_DEVICE
+extern struct pci_dev *vga_default_device(void);
+#endif
+
+/**
+ *     vga_conflicts
+ *
+ *     Architectures should define this if they have several
+ *     independant PCI domains that can afford concurrent VGA
+ *     decoding
+ */
+
+#ifndef __ARCH_HAS_VGA_CONFLICT
+static inline int vga_conflicts(struct pci_dev *p1, struct pci_dev *p2)
+{
+       return 1;
+}
+#endif
+
+/*
+ * Register a client with the VGA arbitration logic
+ * return value: number of VGA devices in system.
+ *
+ * Clients have two callback mechanisms they can use.
+ * irq enable/disable callback -
+ *    If a client can't disable its GPUs VGA resources, then we
+ *    need to be able to ask it to turn off its irqs when we
+ *    turn off its mem and io decoding.
+ * set_vga_decode
+ *    If a client can disable its GPU VGA resource, it will
+ *    get a callback from this to set the encode/decode state
+ *
+ * Clients with disable abilities should check the return value
+ * of this function and if the VGA device count is > 1, should
+ * disable VGA decoding resources.
+ *
+ * Rationale: we cannot disable VGA decode resources unconditionally
+ * some single GPU laptops seem to require ACPI or BIOS access to the
+ * VGA registers to control things like backlights etc.
+ * Hopefully newer multi-GPU laptops do something saner, and desktops
+ * won't have any special ACPI for this.
+ */
+int vga_client_register(struct pci_dev *pdev, void *cookie,
+			void (*irq_set_state)(void *cookie, bool state),
+			unsigned int (*set_vga_decode)(void *cookie, bool state));
+
+#endif /* LINUX_VGA_H */
