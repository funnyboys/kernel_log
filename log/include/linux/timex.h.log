commit c70a772fda11570ebddecbce1543a3fda008db4a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 7 00:00:34 2019 +0100

    y2038: remove struct definition redirects
    
    We now use 64-bit time_t on all architectures, so the __kernel_timex,
    __kernel_timeval and __kernel_timespec redirects can be removed
    after having served their purpose.
    
    This makes it all much less confusing, as the __kernel_* types
    now always refer to the same layout based on 64-bit time_t across
    all 32-bit and 64-bit architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 4aff9f0d1367..ce0859763670 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -53,13 +53,6 @@
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
 
-/* CONFIG_64BIT_TIME enables new 64 bit time_t syscalls in the compat path
- * and 32-bit emulation.
- */
-#ifndef CONFIG_64BIT_TIME
-#define __kernel_timex timex
-#endif
-
 #include <uapi/linux/timex.h>
 
 #define ADJ_ADJTIME		0x8000	/* switch between adjtime/adjtimex modes */

commit ead25417f82ed7f8a21da4dcefc768169f7da884
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Jul 2 22:44:21 2018 -0700

    timex: use __kernel_timex internally
    
    struct timex is not y2038 safe.
    Replace all uses of timex with y2038 safe __kernel_timex.
    
    Note that struct __kernel_timex is an ABI interface definition.
    We could define a new structure based on __kernel_timex that
    is only available internally instead. Right now, there isn't
    a strong motivation for this as the structure is isolated to
    a few defined struct timex interfaces and such a structure would
    be exactly the same as struct timex.
    
    The patch was generated by the following coccinelle script:
    
    virtual patch
    
    @depends on patch forall@
    identifier ts;
    expression e;
    @@
    (
    - struct timex ts;
    + struct __kernel_timex ts;
    |
    - struct timex ts = {};
    + struct __kernel_timex ts = {};
    |
    - struct timex ts = e;
    + struct __kernel_timex ts = e;
    |
    - struct timex *ts;
    + struct __kernel_timex *ts;
    |
    (memset \| copy_from_user \| copy_to_user \)(...,
    - sizeof(struct timex))
    + sizeof(struct __kernel_timex))
    )
    
    @depends on patch forall@
    identifier ts;
    identifier fn;
    @@
    fn(...,
    - struct timex *ts,
    + struct __kernel_timex *ts,
    ...) {
    ...
    }
    
    @depends on patch forall@
    identifier ts;
    identifier fn;
    @@
    fn(...,
    - struct timex *ts) {
    + struct __kernel_timex *ts) {
    ...
    }
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: linux-alpha@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index a15e6aeb8d49..4aff9f0d1367 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -158,8 +158,8 @@ extern unsigned long tick_nsec;		/* SHIFTED_HZ period (nsec) */
 #define NTP_INTERVAL_FREQ  (HZ)
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
-extern int do_adjtimex(struct timex *);
-extern int do_clock_adjtime(const clockid_t which_clock, struct timex * ktx);
+extern int do_adjtimex(struct __kernel_timex *);
+extern int do_clock_adjtime(const clockid_t which_clock, struct __kernel_timex * ktx);
 
 extern void hardpps(const struct timespec64 *, const struct timespec64 *);
 

commit 1a596398a3d75f966b75f428e992cf1f242f9a5b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jan 3 21:12:39 2019 +0100

    sparc64: add custom adjtimex/clock_adjtime functions
    
    sparc64 is the only architecture on Linux that has a 'timeval'
    definition with a 32-bit tv_usec but a 64-bit tv_sec. This causes
    problems for sparc32 compat mode when we convert it to use the
    new __kernel_timex type that has the same layout as all other
    64-bit architectures.
    
    To avoid adding sparc64 specific code into the generic adjtimex
    implementation, this adds a wrapper in the sparc64 system call handling
    that converts the sparc64 'timex' into the new '__kernel_timex'.
    
    At this point, the two structures are defined to be identical,
    but that will change in the next step once we convert sparc32.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 7f40e9e42ecc..a15e6aeb8d49 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -159,6 +159,8 @@ extern unsigned long tick_nsec;		/* SHIFTED_HZ period (nsec) */
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
 extern int do_adjtimex(struct timex *);
+extern int do_clock_adjtime(const clockid_t which_clock, struct timex * ktx);
+
 extern void hardpps(const struct timespec64 *, const struct timespec64 *);
 
 int read_current_timer(unsigned long *timer_val);

commit 2c620ff93d9fbd5d644760d4c21d389078ec1080
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Jul 2 22:44:20 2018 -0700

    time: Add struct __kernel_timex
    
    struct timex uses struct timeval internally.
    struct timeval is not y2038 safe.
    Introduce a new UAPI type struct __kernel_timex
    that is y2038 safe.
    
    struct __kernel_timex uses a timeval type that is
    similar to struct __kernel_timespec which preserves the
    same structure size across 32 bit and 64 bit ABIs.
    struct __kernel_timex also restructures other members of the
    structure to make the structure the same on 64 bit and 32 bit
    architectures.
    Note that struct __kernel_timex is the same as struct timex
    on a 64 bit architecture.
    
    The above solution is similar to other new y2038 syscalls
    that are being introduced: both 32 bit and 64 bit ABIs
    have a common entry, and the compat entry supports the old 32 bit
    syscall interface.
    
    Alternatives considered were:
    1. Add new time type to struct timex that makes use of padded
       bits. This time type could be based on the struct __kernel_timespec.
       modes will use a flag to notify which time structure should be
       used internally.
       This needs some application level changes on both 64 bit and 32 bit
       architectures. Although 64 bit machines could continue to use the
       older timeval structure without any changes.
    
    2. Add a new u8 type to struct timex that makes use of padded bits. This
       can be used to save higher order tv_sec bits. modes will use a flag to
       notify presence of such a type.
       This will need some application level changes on 32 bit architectures.
    
    3. Add a new compat_timex structure that differs in only the size of the
       time type; keep rest of struct timex the same.
       This requires extra syscalls to manage all 3 cases on 64 bit
       architectures. This will not need any application level changes but will
       add more complexity from kernel side.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 39c25dbebfe8..7f40e9e42ecc 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -53,6 +53,13 @@
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
 
+/* CONFIG_64BIT_TIME enables new 64 bit time_t syscalls in the compat path
+ * and 32-bit emulation.
+ */
+#ifndef CONFIG_64BIT_TIME
+#define __kernel_timex timex
+#endif
+
 #include <uapi/linux/timex.h>
 
 #define ADJ_ADJTIME		0x8000	/* switch between adjtime/adjtimex modes */

commit 7ec88e4be461590b5a3817460c34603f76d9b3ae
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Sep 28 22:21:28 2015 +0200

    ntp/pps: use timespec64 for hardpps()
    
    There is only one user of the hardpps function in the kernel, so
    it makes sense to atomically change it over to using 64-bit
    timestamps for y2038 safety. In the hardpps implementation,
    we also need to change the pps_normtime structure, which is
    similar to struct timespec and also requires a 64-bit
    seconds portion.
    
    This introduces two temporary variables in pps_kc_event() to
    do the conversion, they will be removed again in the next step,
    which seemed preferable to having a larger patch changing it
    all at the same time.
    
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 9d3f1a5b6178..39c25dbebfe8 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -152,7 +152,7 @@ extern unsigned long tick_nsec;		/* SHIFTED_HZ period (nsec) */
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
 extern int do_adjtimex(struct timex *);
-extern void hardpps(const struct timespec *, const struct timespec *);
+extern void hardpps(const struct timespec64 *, const struct timespec64 *);
 
 int read_current_timer(unsigned long *timer_val);
 void ntp_notify_cmos_timer(void);

commit f715729ee4cb666f51749f6cd86d06fff1e6e17b
Merge: 8273548c5455 61875f30daf6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 10 12:31:43 2013 -0700

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull /dev/random changes from Ted Ts'o:
     "These patches are designed to enable improvements to /dev/random for
      non-x86 platforms, in particular MIPS and ARM"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      random: allow architectures to optionally define random_get_entropy()
      random: run random_int_secret_init() run after all late_initcalls

commit 61875f30daf60305712e25b209ef41ced2635bad
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Sep 21 13:58:22 2013 -0400

    random: allow architectures to optionally define random_get_entropy()
    
    Allow architectures which have a disabled get_cycles() function to
    provide a random_get_entropy() function which provides a fine-grained,
    rapidly changing counter that can be used by the /dev/random driver.
    
    For example, an architecture might have a rapidly changing register
    used to control random TLB cache eviction, or DRAM refresh that
    doesn't meet the requirements of get_cycles(), but which is good
    enough for the needs of the random driver.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b3726e61368e..da4c32dbb2aa 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -64,6 +64,20 @@
 
 #include <asm/timex.h>
 
+#ifndef random_get_entropy
+/*
+ * The random_get_entropy() function is used by the /dev/random driver
+ * in order to extract entropy via the relative unpredictability of
+ * when an interrupt takes places versus a high speed, fine-grained
+ * timing source or cycle counter.  Since it will be occurred on every
+ * single interrupt, it must have a very low cost/overhead.
+ *
+ * By default we use get_cycles() for this purpose, but individual
+ * architectures may override this in their asm/timex.h header file.
+ */
+#define random_get_entropy()	get_cycles()
+#endif
+
 /*
  * SHIFT_PLL is used as a dampening factor to define how much we
  * adjust the frequency correction for a given offset in PLL mode.

commit 7bd36014460f793c19e7d6c94dab67b0afcfcb7f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Sep 11 16:50:56 2013 -0700

    timekeeping: Fix HRTICK related deadlock from ntp lock changes
    
    Gerlando Falauto reported that when HRTICK is enabled, it is
    possible to trigger system deadlocks. These were hard to
    reproduce, as HRTICK has been broken in the past, but seemed
    to be connected to the timekeeping_seq lock.
    
    Since seqlock/seqcount's aren't supported w/ lockdep, I added
    some extra spinlock based locking and triggered the following
    lockdep output:
    
    [   15.849182] ntpd/4062 is trying to acquire lock:
    [   15.849765]  (&(&pool->lock)->rlock){..-...}, at: [<ffffffff810aa9b5>] __queue_work+0x145/0x480
    [   15.850051]
    [   15.850051] but task is already holding lock:
    [   15.850051]  (timekeeper_lock){-.-.-.}, at: [<ffffffff810df6df>] do_adjtimex+0x7f/0x100
    
    <snip>
    
    [   15.850051] Chain exists of: &(&pool->lock)->rlock --> &p->pi_lock --> timekeeper_lock
    [   15.850051]  Possible unsafe locking scenario:
    [   15.850051]
    [   15.850051]        CPU0                    CPU1
    [   15.850051]        ----                    ----
    [   15.850051]   lock(timekeeper_lock);
    [   15.850051]                                lock(&p->pi_lock);
    [   15.850051] lock(timekeeper_lock);
    [   15.850051] lock(&(&pool->lock)->rlock);
    [   15.850051]
    [   15.850051]  *** DEADLOCK ***
    
    The deadlock was introduced by 06c017fdd4dc48451a ("timekeeping:
    Hold timekeepering locks in do_adjtimex and hardpps") in 3.10
    
    This patch avoids this deadlock, by moving the call to
    schedule_delayed_work() outside of the timekeeper lock
    critical section.
    
    Reported-by: Gerlando Falauto <gerlando.falauto@keymile.com>
    Tested-by: Lin Ming <minggr@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: stable <stable@vger.kernel.org> #3.11, 3.10
    Link: http://lkml.kernel.org/r/1378943457-27314-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b3726e61368e..dd3edd7dfc94 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -141,6 +141,7 @@ extern int do_adjtimex(struct timex *);
 extern void hardpps(const struct timespec *, const struct timespec *);
 
 int read_current_timer(unsigned long *timer_val);
+void ntp_notify_cmos_timer(void);
 
 /* The clock frequency of the i8253/i8254 PIT */
 #define PIT_TICK_RATE 1193182ul

commit aa6f9c595d857328e5d815e5b94c0e7cd31a6b59
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Mar 22 11:31:29 2013 -0700

    ntp: Move do_adjtimex() and hardpps() functions to timekeeping.c
    
    In preparation for changing the ntp locking rules, move
    do_adjtimex and hardpps accessor functions to timekeeping.c,
    but keep the code logic in ntp.c.
    
    This patch also introduces a ntp_internal.h file so timekeeping
    specific interfaces of ntp.c can be more limitedly shared with
    timekeeping.c.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 5ec87c60b97c..b3726e61368e 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -125,9 +125,6 @@
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
 extern unsigned long tick_nsec;		/* SHIFTED_HZ period (nsec) */
 
-extern void ntp_init(void);
-extern void ntp_clear(void);
-
 /* Required to safely shift negative values */
 #define shift_right(x, s) ({	\
 	__typeof__(x) __x = (x);	\
@@ -140,10 +137,6 @@ extern void ntp_clear(void);
 #define NTP_INTERVAL_FREQ  (HZ)
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
-/* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */
-extern u64 ntp_tick_length(void);
-
-extern int second_overflow(unsigned long secs);
 extern int do_adjtimex(struct timex *);
 extern void hardpps(const struct timespec *, const struct timespec *);
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 7c5ceb20e03a..5ec87c60b97c 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -53,120 +53,11 @@
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
 
-#include <linux/time.h>
+#include <uapi/linux/timex.h>
 
-#define NTP_API		4	/* NTP API version */
-
-/*
- * syscall interface - used (mainly by NTP daemon)
- * to discipline kernel clock oscillator
- */
-struct timex {
-	unsigned int modes;	/* mode selector */
-	long offset;		/* time offset (usec) */
-	long freq;		/* frequency offset (scaled ppm) */
-	long maxerror;		/* maximum error (usec) */
-	long esterror;		/* estimated error (usec) */
-	int status;		/* clock command/status */
-	long constant;		/* pll time constant */
-	long precision;		/* clock precision (usec) (read only) */
-	long tolerance;		/* clock frequency tolerance (ppm)
-				 * (read only)
-				 */
-	struct timeval time;	/* (read only, except for ADJ_SETOFFSET) */
-	long tick;		/* (modified) usecs between clock ticks */
-
-	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
-	long jitter;            /* pps jitter (us) (ro) */
-	int shift;              /* interval duration (s) (shift) (ro) */
-	long stabil;            /* pps stability (scaled ppm) (ro) */
-	long jitcnt;            /* jitter limit exceeded (ro) */
-	long calcnt;            /* calibration intervals (ro) */
-	long errcnt;            /* calibration errors (ro) */
-	long stbcnt;            /* stability limit exceeded (ro) */
-
-	int tai;		/* TAI offset (ro) */
-
-	int  :32; int  :32; int  :32; int  :32;
-	int  :32; int  :32; int  :32; int  :32;
-	int  :32; int  :32; int  :32;
-};
-
-/*
- * Mode codes (timex.mode)
- */
-#define ADJ_OFFSET		0x0001	/* time offset */
-#define ADJ_FREQUENCY		0x0002	/* frequency offset */
-#define ADJ_MAXERROR		0x0004	/* maximum time error */
-#define ADJ_ESTERROR		0x0008	/* estimated time error */
-#define ADJ_STATUS		0x0010	/* clock status */
-#define ADJ_TIMECONST		0x0020	/* pll time constant */
-#define ADJ_TAI			0x0080	/* set TAI offset */
-#define ADJ_SETOFFSET		0x0100  /* add 'time' to current time */
-#define ADJ_MICRO		0x1000	/* select microsecond resolution */
-#define ADJ_NANO		0x2000	/* select nanosecond resolution */
-#define ADJ_TICK		0x4000	/* tick value */
-
-#ifdef __KERNEL__
 #define ADJ_ADJTIME		0x8000	/* switch between adjtime/adjtimex modes */
 #define ADJ_OFFSET_SINGLESHOT	0x0001	/* old-fashioned adjtime */
 #define ADJ_OFFSET_READONLY	0x2000	/* read-only adjtime */
-#else
-#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
-#define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
-#endif
-
-/* NTP userland likes the MOD_ prefix better */
-#define MOD_OFFSET	ADJ_OFFSET
-#define MOD_FREQUENCY	ADJ_FREQUENCY
-#define MOD_MAXERROR	ADJ_MAXERROR
-#define MOD_ESTERROR	ADJ_ESTERROR
-#define MOD_STATUS	ADJ_STATUS
-#define MOD_TIMECONST	ADJ_TIMECONST
-#define MOD_TAI	ADJ_TAI
-#define MOD_MICRO	ADJ_MICRO
-#define MOD_NANO	ADJ_NANO
-
-
-/*
- * Status codes (timex.status)
- */
-#define STA_PLL		0x0001	/* enable PLL updates (rw) */
-#define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
-#define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
-#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
-
-#define STA_INS		0x0010	/* insert leap (rw) */
-#define STA_DEL		0x0020	/* delete leap (rw) */
-#define STA_UNSYNC	0x0040	/* clock unsynchronized (rw) */
-#define STA_FREQHOLD	0x0080	/* hold frequency (rw) */
-
-#define STA_PPSSIGNAL	0x0100	/* PPS signal present (ro) */
-#define STA_PPSJITTER	0x0200	/* PPS signal jitter exceeded (ro) */
-#define STA_PPSWANDER	0x0400	/* PPS signal wander exceeded (ro) */
-#define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
-
-#define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
-#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
-#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
-#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
-
-/* read-only bits */
-#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
-	STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
-
-/*
- * Clock states (time_state)
- */
-#define TIME_OK		0	/* clock synchronized, no leap second */
-#define TIME_INS	1	/* insert leap second */
-#define TIME_DEL	2	/* delete leap second */
-#define TIME_OOP	3	/* leap second in progress */
-#define TIME_WAIT	4	/* leap second has occurred */
-#define TIME_ERROR	5	/* clock not synchronized */
-#define TIME_BAD	TIME_ERROR /* bw compat */
-
-#ifdef __KERNEL__
 #include <linux/compiler.h>
 #include <linux/types.h>
 #include <linux/param.h>
@@ -261,6 +152,4 @@ int read_current_timer(unsigned long *timer_val);
 /* The clock frequency of the i8253/i8254 PIT */
 #define PIT_TICK_RATE 1193182ul
 
-#endif /* KERNEL */
-
 #endif /* LINUX_TIMEX_H */

commit 02ab20ae38337b99b5c29c81090f594b8fd61283
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jul 27 14:48:10 2012 -0400

    time/jiffies: Rename ACTHZ to SHIFTED_HZ
    
    Ingo noted that ACTHZ is a confusing name, and requested it
    be renamed, so this patch renames ACTHZ to SHIFTED_HZ to
    better describe it.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Link: http://lkml.kernel.org/r/1343414893-45779-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 99bc88b1fc02..7c5ceb20e03a 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -232,7 +232,7 @@ struct timex {
  * estimated error = NTP dispersion.
  */
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
-extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
+extern unsigned long tick_nsec;		/* SHIFTED_HZ period (nsec) */
 
 extern void ntp_init(void);
 extern void ntp_clear(void);

commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Mar 15 13:04:03 2012 -0700

    ntp: Fix leap-second hrtimer livelock
    
    Since commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168 the ntp
    subsystem has used an hrtimer for triggering the leapsecond
    adjustment. However, this can cause a potential livelock.
    
    Thomas diagnosed this as the following pattern:
    CPU 0                                                    CPU 1
    do_adjtimex()
      spin_lock_irq(&ntp_lock);
        process_adjtimex_modes();                            timer_interrupt()
          process_adj_status();                                do_timer()
            ntp_start_leap_timer();                             write_lock(&xtime_lock);
              hrtimer_start();                                  update_wall_time();
                 hrtimer_reprogram();                            ntp_tick_length()
                   tick_program_event()                            spin_lock(&ntp_lock);
                     clockevents_program_event()
                       ktime_get()
                         seq = req_seqbegin(xtime_lock);
    
    This patch tries to avoid the problem by reverting back to not using
    an hrtimer to inject leapseconds, and instead we handle the leapsecond
    processing in the second_overflow() function.
    
    The downside to this change is that on systems that support highres
    timers, the leap second processing will occur on a HZ tick boundary,
    (ie: ~1-10ms, depending on HZ)  after the leap second instead of
    possibly sooner (~34us in my tests w/ x86_64 lapic).
    
    This patch applies on top of tip/timers/core.
    
    CC: Sasha Levin <levinsasha928@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Diagnoised-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b75e1864ed19..99bc88b1fc02 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -252,7 +252,7 @@ extern void ntp_clear(void);
 /* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */
 extern u64 ntp_tick_length(void);
 
-extern void second_overflow(void);
+extern int second_overflow(unsigned long secs);
 extern int do_adjtimex(struct timex *);
 extern void hardpps(const struct timespec *, const struct timespec *);
 

commit ea7cf49a7633c2b70125f59b4e3553d9181cb15d
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Nov 14 13:18:07 2011 -0800

    ntp: Access tick_length variable via ntp_tick_length()
    
    Currently the NTP managed tick_length value is accessed globally,
    in preparations for locking cleanups, make sure it is accessed via
    a function and mark it as static.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 92e01fc31ca6..b75e1864ed19 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -250,7 +250,7 @@ extern void ntp_clear(void);
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
 /* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */
-extern u64 tick_length;
+extern u64 ntp_tick_length(void);
 
 extern void second_overflow(void);
 extern int do_adjtimex(struct timex *);

commit 8357929e6ae3661d5a3a7378a717f29873ea18c6
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Nov 14 13:06:21 2011 -0800

    ntp: Cleanup timex.h
    
    Move ntp_sycned to ntp.c and mark time_status as static.
    Also yank function declaration for non-existant function.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index aa60fe7b6ed6..92e01fc31ca6 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -234,23 +234,9 @@ struct timex {
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
 extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
 
-/*
- * phase-lock loop variables
- */
-extern int time_status;		/* clock synchronization status bits */
-
 extern void ntp_init(void);
 extern void ntp_clear(void);
 
-/**
- * ntp_synced - Returns 1 if the NTP status is not UNSYNC
- *
- */
-static inline int ntp_synced(void)
-{
-	return !(time_status & STA_UNSYNC);
-}
-
 /* Required to safely shift negative values */
 #define shift_right(x, s) ({	\
 	__typeof__(x) __x = (x);	\
@@ -267,7 +253,6 @@ static inline int ntp_synced(void)
 extern u64 tick_length;
 
 extern void second_overflow(void);
-extern void update_ntp_one_tick(void);
 extern int do_adjtimex(struct timex *);
 extern void hardpps(const struct timespec *, const struct timespec *);
 

commit 094aa1881fdc1b8889b442eb3511b31f3ec2b762
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Tue Feb 1 13:52:20 2011 +0000

    ntp: Add ADJ_SETOFFSET mode bit
    
    This patch adds a new mode bit into the timex structure. When set, the bit
    instructs the kernel to add the given time value to the current time.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134320.688829863@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index d23999f9499d..aa60fe7b6ed6 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -73,7 +73,7 @@ struct timex {
 	long tolerance;		/* clock frequency tolerance (ppm)
 				 * (read only)
 				 */
-	struct timeval time;	/* (read only) */
+	struct timeval time;	/* (read only, except for ADJ_SETOFFSET) */
 	long tick;		/* (modified) usecs between clock ticks */
 
 	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
@@ -102,6 +102,7 @@ struct timex {
 #define ADJ_STATUS		0x0010	/* clock status */
 #define ADJ_TIMECONST		0x0020	/* pll time constant */
 #define ADJ_TAI			0x0080	/* set TAI offset */
+#define ADJ_SETOFFSET		0x0100  /* add 'time' to current time */
 #define ADJ_MICRO		0x1000	/* select microsecond resolution */
 #define ADJ_NANO		0x2000	/* select nanosecond resolution */
 #define ADJ_TICK		0x4000	/* tick value */

commit 025b40abe715d638e60516a657d354e8560c1a85
Author: Alexander Gordeev <lasaine@lvk.cs.msu.su>
Date:   Wed Jan 12 17:00:56 2011 -0800

    ntp: add hardpps implementation
    
    This commit adds hardpps() implementation based upon the original one from
    the NTPv4 reference kernel code from David Mills.  However, it is highly
    optimized towards very fast syncronization and maximum stickness to PPS
    signal.  The typical error is less then a microsecond.
    
    To make it sync faster I had to throw away exponential phase filter so
    that the full phase offset is corrected immediately.  Then I also had to
    throw away median phase filter because it gives a bigger error itself if
    used without exponential filter.
    
    Maybe we will find an appropriate filtering scheme in the future but it's
    not necessary if the signal quality is ok.
    
    Signed-off-by: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Rodolfo Giometti <giometti@enneenne.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 32d852f8cbe4..d23999f9499d 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -268,6 +268,7 @@ extern u64 tick_length;
 extern void second_overflow(void);
 extern void update_ntp_one_tick(void);
 extern int do_adjtimex(struct timex *);
+extern void hardpps(const struct timespec *, const struct timespec *);
 
 int read_current_timer(unsigned long *timer_val);
 

commit 3d0205bd1383aa3cac93c209b7c7d03b27930195
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 18 20:19:28 2010 -0700

    ntp: Remove tickadj
    
    There are zero users of tickadj. So remove it.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1268968769-19209-2-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index e2de51eedf05..32d852f8cbe4 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -232,7 +232,6 @@ struct timex {
  */
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
 extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
-extern int tickadj;			/* amount of adjustment per tick */
 
 /*
  * phase-lock loop variables
@@ -270,9 +269,6 @@ extern void second_overflow(void);
 extern void update_ntp_one_tick(void);
 extern int do_adjtimex(struct timex *);
 
-/* Don't use! Compatibility define for existing users. */
-#define tickadj	(500/HZ ? : 1)
-
 int read_current_timer(unsigned long *timer_val);
 
 /* The clock frequency of the i8253/i8254 PIT */

commit e1292ba164742e3a236e407148e00300b7196906
Author: John Stultz <johnstul@us.ibm.com>
Date:   Thu Mar 18 20:19:27 2010 -0700

    ntp: Make time_adjust static
    
    Now that no arches are accessing time_adjust directly,
    make it static.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1268968769-19209-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 7a082b32d8e1..e2de51eedf05 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -238,7 +238,6 @@ extern int tickadj;			/* amount of adjustment per tick */
  * phase-lock loop variables
  */
 extern int time_status;		/* clock synchronization status bits */
-extern long time_adjust;	/* The amount of adjtime left */
 
 extern void ntp_init(void);
 extern void ntp_clear(void);

commit 1f5b8f8a2031ae9507eb67743cad4d424739bfff
Author: john stultz <johnstul@us.ibm.com>
Date:   Thu Jan 28 15:02:41 2010 -0800

    ntp: Make time_esterror and time_maxerror static
    
    Make time_esterror and time_maxerror static as no one uses them
    outside of ntp.c
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: richard@rsk.demon.co.uk
    LKML-Reference: <1264719761.3437.47.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 94f8faecdcbc..7a082b32d8e1 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -238,9 +238,6 @@ extern int tickadj;			/* amount of adjustment per tick */
  * phase-lock loop variables
  */
 extern int time_status;		/* clock synchronization status bits */
-extern long time_maxerror;	/* maximum error */
-extern long time_esterror;	/* estimated error */
-
 extern long time_adjust;	/* The amount of adjtime left */
 
 extern void ntp_init(void);

commit 2b876f95d03e226394b5d360c86127cbefaf614b
Merge: fbf07eac7bf2 c95b4502ad7f 6ce51c431019
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 19:30:19 2009 -0800

    Merge branches 'timers-for-linus-ntp' and 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-ntp' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      ntp: Provide compability defines (You say MOD_NANO, I say ADJ_NANO)
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      genirq: do not execute DEBUG_SHIRQ when irq setup failed

commit a092ff0f90cae22b2ac8028ecd2c6f6c1a9e4601
Author: john stultz <johnstul@us.ibm.com>
Date:   Fri Oct 2 16:17:53 2009 -0700

    time: Implement logarithmic time accumulation
    
    Accumulating one tick at a time works well unless we're using NOHZ.
    Then it can be an issue, since we may have to run through the loop
    a few thousand times, which can increase timer interrupt caused
    latency.
    
    The current solution was to accumulate in half-second intervals
    with NOHZ. This kept the number of loops down, however it did
    slightly change how we make NTP adjustments. While not an issue
    with NTPd users, as NTPd makes adjustments over a longer period of
    time, other adjtimex() users have noticed the half-second
    granularity with which we can apply frequency changes to the clock.
    
    For instance, if a application tries to apply a 100ppm frequency
    correction for 20ms to correct a 2us offset, with NOHZ they either
    get no correction, or a 50us correction.
    
    Now, there will always be some granularity error for applying
    frequency corrections. However with users sensitive to this error
    have seen a 50-500x increase with NOHZ compared to running without
    NOHZ.
    
    So I figured I'd try another approach then just simply increasing
    the interval. My approach is to consume the time interval
    logarithmically. This reduces the number of times through the loop
    needed keeping latency down, while still preserving the original
    granularity error for adjtimex() changes.
    
    Further, this change allows us to remove the xtime_cache code
    (patch to follow), as xtime is always within one tick of the
    current time, instead of the half-second updates it saw before.
    
    An earlier version of this patch has been shipping to x86 users in
    the RedHat MRG releases for awhile without issue, but I've reworked
    this version to be even more careful about avoiding possible
    overflows if the shift value gets too large.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: John Kacur <jkacur@redhat.com>
    Cc: Clark Williams <williams@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <1254525473.7741.88.camel@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index e6967d10d9e5..0c0ef7d4db7c 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -261,11 +261,7 @@ static inline int ntp_synced(void)
 
 #define NTP_SCALE_SHIFT		32
 
-#ifdef CONFIG_NO_HZ
-#define NTP_INTERVAL_FREQ  (2)
-#else
 #define NTP_INTERVAL_FREQ  (HZ)
-#endif
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
 /* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */

commit c95b4502ad7fe8f3b9954aec794b00ac0046ab3a
Author: john stultz <johnstul@us.ibm.com>
Date:   Thu Aug 27 17:04:42 2009 -0700

    ntp: Provide compability defines (You say MOD_NANO, I say ADJ_NANO)
    
    MOD_NANO, ADJ_NANO, MOD_NANO, ADJ_NANO!
    Lets call the whole thing off!
    But oh! If we call the whole thing off,
    Then we must part.
    And oh! If we ever part,
    Then that might break my heart^H^H^H^Hclock!
    So, if you like MOD_NANO and I like ADJ_NANO,
    I'll include MOD_NANO and give up ADJ_NANO (not really!).
    For we know we need each other,
    So we better call the calling off off.
    Let's call the whole thing off!
    
    The tumultuous NTP and Linux relationship has hit another snag: Ends
    up NTPd still uses the "xntp 3.4 compatability names" and when the
    STA_NANO value was added (along with ADJ_NANO), NTPd expected MOD_NANO
    to be added and has apparently hit some build errors.
    
    Report to ntp hackers:
    https://lists.ntp.org/pipermail/hackers/2009-August/004455.html
    
    Related Bugs:
    https://support.ntp.org/bugs/show_bug.cgi?id=1219
    https://bugzilla.redhat.com/show_bug.cgi?id=505566
    
    So in an effort to make peace, here's a patch to help get things
    building again. I also have updated the comment to make sure folks
    don't think the MOD_* values are just legacy constants.
    
    Of course, NTPd really uses the glibc-headers, so those will need to
    be similarly updated before things are working again (the RH bug above
    should probably cover that).
    
    Thanks to Michael Tatarinov and Hal Murray for finding and reporting
    the issue!
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: hmurray@megapathdsl.net
    Cc: Ulrich Drepper <drepper@redhat.com>
    Cc: Michael Tatarinov <kukabu@gmail.com>
    LKML-Reference: <1251417882.7905.42.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index e6967d10d9e5..782ccd45c0d9 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -115,13 +115,16 @@ struct timex {
 #define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
 #endif
 
-/* xntp 3.4 compatibility names */
+/* NTP userland likes the MOD_ prefix better */
 #define MOD_OFFSET	ADJ_OFFSET
 #define MOD_FREQUENCY	ADJ_FREQUENCY
 #define MOD_MAXERROR	ADJ_MAXERROR
 #define MOD_ESTERROR	ADJ_ESTERROR
 #define MOD_STATUS	ADJ_STATUS
 #define MOD_TIMECONST	ADJ_TIMECONST
+#define MOD_TAI	ADJ_TAI
+#define MOD_MICRO	ADJ_MICRO
+#define MOD_NANO	ADJ_NANO
 
 
 /*

commit 08604bd9935dc98fb62ef61d5b7baa7ccc10f8c2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 16 15:31:12 2009 -0700

    time: move PIT_TICK_RATE to linux/timex.h
    
    PIT_TICK_RATE is currently defined in four architectures, but in three
    different places.  While linux/timex.h is not the perfect place for it, it
    is still a reasonable replacement for those drivers that traditionally use
    asm/timex.h to get CLOCK_TICK_RATE and expect it to be the PIT frequency.
    
    Note that for Alpha, the actual value changed from 1193182UL to 1193180UL.
     This is unlikely to make a difference, and probably can only improve
    accuracy.  There was a discussion on the correct value of CLOCK_TICK_RATE
    a few years ago, after which every existing instance was getting changed
    to 1193182.  According to the specification, it should be
    1193181.818181...
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 9910e3bd5b31..e6967d10d9e5 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -280,6 +280,9 @@ extern int do_adjtimex(struct timex *);
 
 int read_current_timer(unsigned long *timer_val);
 
+/* The clock frequency of the i8253/i8254 PIT */
+#define PIT_TICK_RATE 1193182ul
+
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */

commit e13cf6e04ebc231653e03ebde4799dc55bf62849
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon May 11 18:13:13 2009 -0700

    ntp: fix comment typos
    
    Bernhard Schiffner noticed I had a few comment typos in this patch,
    (note: to save embarrassment, when making typos, avoid copying and
    pasting them) so this patch corrects them.
    
    [ Impact: cleanup ]
    
    Reported-by: Bernhard Schiffner <bernhard@schiffner-limbach.de>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: riel@redhat.com
    Cc: akpm@linux-foundation.org
    LKML-Reference: <1242090794.7214.131.camel@localhost.localdomain>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 0daf9611ef4f..9910e3bd5b31 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -179,7 +179,7 @@ struct timex {
  * NTP convergence time. A higher value makes it stiffer, increasing
  * convergence time, but making the clock more stable.
  *
- * In David Mills' nanokenrel reference implmentation SHIFT_PLL is 4.
+ * In David Mills' nanokernel reference implementation SHIFT_PLL is 4.
  * However this seems to increase convergence time much too long.
  *
  * https://lists.ntp.org/pipermail/hackers/2008-January/003487.html
@@ -196,7 +196,7 @@ struct timex {
  *
  * SHIFT_FLL is used as a dampening factor to define how much we
  * adjust the frequency correction for a given offset in FLL mode.
- * In David Mills' nanokenrel reference implmentation SHIFT_PLL is 2.
+ * In David Mills' nanokernel reference implementation SHIFT_FLL is 2.
  *
  * MAXTC establishes the maximum time constant of the PLL.
  */

commit 22cfbbfd9f67b67fe073010f51cb71d3632387d5
Author: john stultz <johnstul@us.ibm.com>
Date:   Wed May 6 11:43:57 2009 +0200

    ntp: adjust SHIFT_PLL to improve NTP convergence
    
    The conversion to the ntpv4 reference model
    f19923937321244e7dc334767eb4b67e0e3d5c74 ("ntp: convert to the NTP4
    reference model") in 2.6.19 added nanosecond resolution the adjtimex
    interface, but also changed the "stiffness" of the frequency adjustments,
    causing NTP convergence time to greatly increase.
    
    SHIFT_PLL, which reduces the stiffness of the freq adjustments, was
    designed to be inversely linked to HZ, and the reference value of 4 was
    designed for Unix systems using HZ=100.  However Linux's clock steering
    code mostly independent of HZ.
    
    So this patch reduces the SHIFT_PLL value from 4 to 2, which causes NTPd
    behavior to match kernels prior to 2.6.19, greatly reducing convergence
    times, and improving close synchronization through environmental thermal
    changes.
    
    The patch also changes some l's to L's in nearby code to avoid misreading
    50l as 501.
    
    [ Impact: tweak NTP algorithm for faster convergence ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: zippel@linux-m68k.org
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <200905051956.n45JuVo9025575@imap1.linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index aa3475fcff64..0daf9611ef4f 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -170,17 +170,37 @@ struct timex {
 #include <asm/timex.h>
 
 /*
- * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
- * for a slightly underdamped convergence characteristic. SHIFT_KH
- * establishes the damping of the FLL and is chosen by wisdom and black
- * art.
+ * SHIFT_PLL is used as a dampening factor to define how much we
+ * adjust the frequency correction for a given offset in PLL mode.
+ * It also used in dampening the offset correction, to define how
+ * much of the current value in time_offset we correct for each
+ * second. Changing this value changes the stiffness of the ntp
+ * adjustment code. A lower value makes it more flexible, reducing
+ * NTP convergence time. A higher value makes it stiffer, increasing
+ * convergence time, but making the clock more stable.
  *
- * MAXTC establishes the maximum time constant of the PLL. With the
- * SHIFT_KG and SHIFT_KF values given and a time constant range from
- * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
- * respectively.
+ * In David Mills' nanokenrel reference implmentation SHIFT_PLL is 4.
+ * However this seems to increase convergence time much too long.
+ *
+ * https://lists.ntp.org/pipermail/hackers/2008-January/003487.html
+ *
+ * In the above mailing list discussion, it seems the value of 4
+ * was appropriate for other Unix systems with HZ=100, and that
+ * SHIFT_PLL should be decreased as HZ increases. However, Linux's
+ * clock steering implementation is HZ independent.
+ *
+ * Through experimentation, a SHIFT_PLL value of 2 was found to allow
+ * for fast convergence (very similar to the NTPv3 code used prior to
+ * v2.6.19), with good clock stability.
+ *
+ *
+ * SHIFT_FLL is used as a dampening factor to define how much we
+ * adjust the frequency correction for a given offset in FLL mode.
+ * In David Mills' nanokenrel reference implmentation SHIFT_PLL is 2.
+ *
+ * MAXTC establishes the maximum time constant of the PLL.
  */
-#define SHIFT_PLL	4	/* PLL frequency factor (shift) */
+#define SHIFT_PLL	2	/* PLL frequency factor (shift) */
 #define SHIFT_FLL	2	/* FLL frequency factor (shift) */
 #define MAXTC		10	/* maximum time constant (shift) */
 
@@ -192,10 +212,10 @@ struct timex {
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
 #define PPM_SCALE ((s64)NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
 #define PPM_SCALE_INV_SHIFT 19
-#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
+#define PPM_SCALE_INV ((1LL << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
 		       PPM_SCALE + 1)
 
-#define MAXPHASE 500000000l	/* max phase error (ns) */
+#define MAXPHASE 500000000L	/* max phase error (ns) */
 #define MAXFREQ 500000		/* max frequency error (ns/s) */
 #define MAXFREQ_SCALED ((s64)MAXFREQ << NTP_SCALE_SHIFT)
 #define MINSEC 256		/* min interval between updates (s) */

commit 2b9d1496e7835a603c340e8f0dd81f4b74d5f248
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 15:48:43 2009 +0100

    time: ntp: make 64-bit constants more robust
    
    Impact: cleanup, no functionality changed
    
     - make PPM_SCALE an explicit s64 constant, to
       remove (s64) casts from usage sites.
    
    kernel/time/ntp.o:
    
       text    data     bss     dec     hex filename
       2536     114     136    2786     ae2 ntp.o.before
       2536     114     136    2786     ae2 ntp.o.after
    
    md5:
       40a7728d1188aa18e83e21a81fa7b150  ntp.o.before.asm
       40a7728d1188aa18e83e21a81fa7b150  ntp.o.after.asm
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 998a55d80acf..aa3475fcff64 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -190,7 +190,7 @@ struct timex {
  * offset and maximum frequency tolerance.
  */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
-#define PPM_SCALE (NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
+#define PPM_SCALE ((s64)NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
 #define PPM_SCALE_INV_SHIFT 19
 #define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
 		       PPM_SCALE + 1)

commit c29541b24fb2c6301021637229ae5347c877330a
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Mon Dec 1 14:18:11 2008 -0800

    linux/timex.h: cleanup for userspace
    
    Impact: fix user-space exported use
    
    Move all the kernel-specific defines and includes into the __KERNEL__
    section so that they don't get leaked into userspace.
    
    [akpm@linux-foundation.org: coding-style fixes]
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 9007313b5b71..998a55d80acf 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -53,46 +53,10 @@
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
 
-#include <linux/compiler.h>
 #include <linux/time.h>
 
-#include <asm/param.h>
-
 #define NTP_API		4	/* NTP API version */
 
-/*
- * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
- * for a slightly underdamped convergence characteristic. SHIFT_KH
- * establishes the damping of the FLL and is chosen by wisdom and black
- * art.
- *
- * MAXTC establishes the maximum time constant of the PLL. With the
- * SHIFT_KG and SHIFT_KF values given and a time constant range from
- * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
- * respectively.
- */
-#define SHIFT_PLL	4	/* PLL frequency factor (shift) */
-#define SHIFT_FLL	2	/* FLL frequency factor (shift) */
-#define MAXTC		10	/* maximum time constant (shift) */
-
-/*
- * SHIFT_USEC defines the scaling (shift) of the time_freq and
- * time_tolerance variables, which represent the current frequency
- * offset and maximum frequency tolerance.
- */
-#define SHIFT_USEC 16		/* frequency offset scale (shift) */
-#define PPM_SCALE (NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
-#define PPM_SCALE_INV_SHIFT 19
-#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
-		       PPM_SCALE + 1)
-
-#define MAXPHASE 500000000l	/* max phase error (ns) */
-#define MAXFREQ 500000		/* max frequency error (ns/s) */
-#define MAXFREQ_SCALED ((s64)MAXFREQ << NTP_SCALE_SHIFT)
-#define MINSEC 256		/* min interval between updates (s) */
-#define MAXSEC 2048		/* max interval between updates (s) */
-#define NTP_PHASE_LIMIT ((MAXPHASE / NSEC_PER_USEC) << 5) /* beyond max. dispersion */
-
 /*
  * syscall interface - used (mainly by NTP daemon)
  * to discipline kernel clock oscillator
@@ -199,8 +163,45 @@ struct timex {
 #define TIME_BAD	TIME_ERROR /* bw compat */
 
 #ifdef __KERNEL__
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/param.h>
+
 #include <asm/timex.h>
 
+/*
+ * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
+ * for a slightly underdamped convergence characteristic. SHIFT_KH
+ * establishes the damping of the FLL and is chosen by wisdom and black
+ * art.
+ *
+ * MAXTC establishes the maximum time constant of the PLL. With the
+ * SHIFT_KG and SHIFT_KF values given and a time constant range from
+ * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
+ * respectively.
+ */
+#define SHIFT_PLL	4	/* PLL frequency factor (shift) */
+#define SHIFT_FLL	2	/* FLL frequency factor (shift) */
+#define MAXTC		10	/* maximum time constant (shift) */
+
+/*
+ * SHIFT_USEC defines the scaling (shift) of the time_freq and
+ * time_tolerance variables, which represent the current frequency
+ * offset and maximum frequency tolerance.
+ */
+#define SHIFT_USEC 16		/* frequency offset scale (shift) */
+#define PPM_SCALE (NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
+#define PPM_SCALE_INV_SHIFT 19
+#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
+		       PPM_SCALE + 1)
+
+#define MAXPHASE 500000000l	/* max phase error (ns) */
+#define MAXFREQ 500000		/* max frequency error (ns/s) */
+#define MAXFREQ_SCALED ((s64)MAXFREQ << NTP_SCALE_SHIFT)
+#define MINSEC 256		/* min interval between updates (s) */
+#define MAXSEC 2048		/* max interval between updates (s) */
+#define NTP_PHASE_LIMIT ((MAXPHASE / NSEC_PER_USEC) << 5) /* beyond max. dispersion */
+
 /*
  * kernel variables
  * Note: maximum error = NTP synch distance = dispersion + delay / 2;

commit d40e944c25fb4642adb2a4c580a48218a9f3f824
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Sep 22 14:42:44 2008 -0700

    ntp: improve adjtimex frequency rounding
    
    Change PPM_SCALE_INV_SHIFT so that it doesn't throw away any input bits
    (19 is the amount of the factor 2 in PPM_SCALE), the output frequency
    can then be calculated back to its input value, as the inverse divide
    produce a slightly larger value, which is then correctly rounded by the
    final shift.
    
    Reported-by: Martin Ziegler <ziegler@uni-freiburg.de>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index c00bcdd3ae42..9007313b5b71 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -82,7 +82,7 @@
  */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
 #define PPM_SCALE (NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
-#define PPM_SCALE_INV_SHIFT 20
+#define PPM_SCALE_INV_SHIFT 19
 #define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
 		       PPM_SCALE + 1)
 

commit 916c7a855174e3b53d182b97a26b2e27a29726a1
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Wed Aug 20 16:46:08 2008 -0700

    ntp: fix ADJ_OFFSET_SS_READ bug and do_adjtimex() cleanup
    
    Thanks to the review by Michael Kerrisk a bug in the recent
    ADJ_OFFSET_SS_READ option was discovered, where the ntp time_offset was
    inadvertently set by it.  This fixes this by making the adjtime code
    more separate from the ntp_adjtime code (both of which really want to
    be separate syscalls).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index fc6035d29d56..c00bcdd3ae42 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -141,8 +141,15 @@ struct timex {
 #define ADJ_MICRO		0x1000	/* select microsecond resolution */
 #define ADJ_NANO		0x2000	/* select nanosecond resolution */
 #define ADJ_TICK		0x4000	/* tick value */
+
+#ifdef __KERNEL__
+#define ADJ_ADJTIME		0x8000	/* switch between adjtime/adjtimex modes */
+#define ADJ_OFFSET_SINGLESHOT	0x0001	/* old-fashioned adjtime */
+#define ADJ_OFFSET_READONLY	0x2000	/* read-only adjtime */
+#else
 #define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
-#define ADJ_OFFSET_SS_READ	0xa001  /* read-only adjtime */
+#define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
+#endif
 
 /* xntp 3.4 compatibility names */
 #define MOD_OFFSET	ADJ_OFFSET

commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:41 2008 -0700

    ntp: handle leap second via timer
    
    Remove the leap second handling from second_overflow(), which doesn't have to
    check for it every second anymore.  With CONFIG_NO_HZ this also makes sure the
    leap second is handled close to the full second.  Additionally this makes it
    possible to abort a leap second properly by resetting the STA_INS/STA_DEL
    status bits.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index da431f8c5c6e..fc6035d29d56 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -212,6 +212,7 @@ extern long time_esterror;	/* estimated error */
 
 extern long time_adjust;	/* The amount of adjtime left */
 
+extern void ntp_init(void);
 extern void ntp_clear(void);
 
 /**

commit 8383c42399f394a89bd6c2f03632c53689bdde7a
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:39 2008 -0700

    ntp: remove current_tick_length()
    
    current_tick_length used to do a little more, but now it just returns
    tick_length, which we can also access directly at the few places, where it's
    needed.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 5994d39de778..da431f8c5c6e 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -239,8 +239,8 @@ static inline int ntp_synced(void)
 #endif
 #define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
-/* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
-extern u64 current_tick_length(void);
+/* Returns how long ticks are at present, in ns / 2^NTP_SCALE_SHIFT. */
+extern u64 tick_length;
 
 extern void second_overflow(void);
 extern void update_ntp_one_tick(void);

commit 7fc5c78409479d826341b103bdf734cb4fb02436
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:38 2008 -0700

    ntp: rename TICK_LENGTH_SHIFT to NTP_SCALE_SHIFT
    
    As TICK_LENGTH_SHIFT is used for more than just the tick length, the name
    isn't quite approriate anymore, so this renames it to NTP_SCALE_SHIFT.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 6ff92237759a..5994d39de778 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -81,14 +81,14 @@
  * offset and maximum frequency tolerance.
  */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
-#define PPM_SCALE (NSEC_PER_USEC << (TICK_LENGTH_SHIFT - SHIFT_USEC))
+#define PPM_SCALE (NSEC_PER_USEC << (NTP_SCALE_SHIFT - SHIFT_USEC))
 #define PPM_SCALE_INV_SHIFT 20
-#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + TICK_LENGTH_SHIFT)) / \
+#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + NTP_SCALE_SHIFT)) / \
 		       PPM_SCALE + 1)
 
 #define MAXPHASE 500000000l	/* max phase error (ns) */
 #define MAXFREQ 500000		/* max frequency error (ns/s) */
-#define MAXFREQ_SCALED ((s64)MAXFREQ << TICK_LENGTH_SHIFT)
+#define MAXFREQ_SCALED ((s64)MAXFREQ << NTP_SCALE_SHIFT)
 #define MINSEC 256		/* min interval between updates (s) */
 #define MAXSEC 2048		/* max interval between updates (s) */
 #define NTP_PHASE_LIMIT ((MAXPHASE / NSEC_PER_USEC) << 5) /* beyond max. dispersion */
@@ -230,7 +230,7 @@ static inline int ntp_synced(void)
 	__x < 0 ? -(-__x >> __s) : __x >> __s;	\
 })
 
-#define TICK_LENGTH_SHIFT	32
+#define NTP_SCALE_SHIFT		32
 
 #ifdef CONFIG_NO_HZ
 #define NTP_INTERVAL_FREQ  (2)

commit 153b5d054ac2d98ea0d86504884326b6777f683d
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:37 2008 -0700

    ntp: support for TAI
    
    This adds support for setting the TAI value (International Atomic Time).  The
    value is reported back to userspace via timex (as we don't have a
    ntp_gettime() syscall).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 9fbdd12a52f1..6ff92237759a 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -121,9 +121,11 @@ struct timex {
 	long errcnt;            /* calibration errors (ro) */
 	long stbcnt;            /* stability limit exceeded (ro) */
 
+	int tai;		/* TAI offset (ro) */
+
 	int  :32; int  :32; int  :32; int  :32;
 	int  :32; int  :32; int  :32; int  :32;
-	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32;
 };
 
 /*
@@ -135,6 +137,7 @@ struct timex {
 #define ADJ_ESTERROR		0x0008	/* estimated time error */
 #define ADJ_STATUS		0x0010	/* clock status */
 #define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_TAI			0x0080	/* set TAI offset */
 #define ADJ_MICRO		0x1000	/* select microsecond resolution */
 #define ADJ_NANO		0x2000	/* select nanosecond resolution */
 #define ADJ_TICK		0x4000	/* tick value */

commit 9f14f669d18477fe3df071e2fa4da36c00acee8e
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:36 2008 -0700

    ntp: increase time_offset resolution
    
    time_offset is already a 64bit value but its resolution barely used, so this
    makes better use of it by replacing SHIFT_UPDATE with TICK_LENGTH_SHIFT.
    
    Side note: the SHIFT_HZ in SHIFT_UPDATE was incorrect for CONFIG_NO_HZ and the
    primary reason for changing time_offset to 64bit to avoid the overflow.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 48c3376dce71..9fbdd12a52f1 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -76,27 +76,22 @@
 #define MAXTC		10	/* maximum time constant (shift) */
 
 /*
- * The SHIFT_UPDATE define establishes the decimal point of the
- * time_offset variable which represents the current offset with
- * respect to standard time.
- *
  * SHIFT_USEC defines the scaling (shift) of the time_freq and
  * time_tolerance variables, which represent the current frequency
  * offset and maximum frequency tolerance.
  */
-#define SHIFT_UPDATE (SHIFT_HZ + 1) /* time offset scale (shift) */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
 #define PPM_SCALE (NSEC_PER_USEC << (TICK_LENGTH_SHIFT - SHIFT_USEC))
 #define PPM_SCALE_INV_SHIFT 20
 #define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + TICK_LENGTH_SHIFT)) / \
 		       PPM_SCALE + 1)
 
-#define MAXPHASE 512000L        /* max phase error (us) */
+#define MAXPHASE 500000000l	/* max phase error (ns) */
 #define MAXFREQ 500000		/* max frequency error (ns/s) */
 #define MAXFREQ_SCALED ((s64)MAXFREQ << TICK_LENGTH_SHIFT)
 #define MINSEC 256		/* min interval between updates (s) */
 #define MAXSEC 2048		/* max interval between updates (s) */
-#define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
+#define NTP_PHASE_LIMIT ((MAXPHASE / NSEC_PER_USEC) << 5) /* beyond max. dispersion */
 
 /*
  * syscall interface - used (mainly by NTP daemon)

commit 074b3b87941c99bc0ce35385b5817924b1ed0c23
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:34 2008 -0700

    ntp: increase time_freq resolution
    
    This changes time_freq to a 64bit value and makes it static (the only outside
    user had no real need to modify it).  Intermediate values were already 64bit,
    so the change isn't that big, but it saves a little in shifts by replacing
    SHIFT_NSEC with TICK_LENGTH_SHIFT.  PPM_SCALE is then used to convert between
    user space and kernel space representation.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 3c49d173bf39..48c3376dce71 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -86,11 +86,14 @@
  */
 #define SHIFT_UPDATE (SHIFT_HZ + 1) /* time offset scale (shift) */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
-#define SHIFT_NSEC 12		/* kernel frequency offset scale */
+#define PPM_SCALE (NSEC_PER_USEC << (TICK_LENGTH_SHIFT - SHIFT_USEC))
+#define PPM_SCALE_INV_SHIFT 20
+#define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + TICK_LENGTH_SHIFT)) / \
+		       PPM_SCALE + 1)
 
 #define MAXPHASE 512000L        /* max phase error (us) */
-#define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
-#define MAXFREQ_NSEC (512000L << SHIFT_NSEC) /* max frequency error (ppb) */
+#define MAXFREQ 500000		/* max frequency error (ns/s) */
+#define MAXFREQ_SCALED ((s64)MAXFREQ << TICK_LENGTH_SHIFT)
 #define MINSEC 256		/* min interval between updates (s) */
 #define MAXSEC 2048		/* max interval between updates (s) */
 #define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
@@ -209,8 +212,6 @@ extern int time_status;		/* clock synchronization status bits */
 extern long time_maxerror;	/* maximum error */
 extern long time_esterror;	/* estimated error */
 
-extern long time_freq;		/* frequency offset (scaled ppm) */
-
 extern long time_adjust;	/* The amount of adjtime left */
 
 extern void ntp_clear(void);

commit eea83d896e318bda54be2d2770d2c5d6668d11db
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:33 2008 -0700

    ntp: NTP4 user space bits update
    
    This adds a few more things from the ntp nanokernel related to user space.
    It's now possible to select the resolution used of some values via STA_NANO
    and the kernel reports in which mode it works (pll/fll).
    
    If some values for adjtimex() are outside the acceptable range, they are now
    simply normalized instead of letting the syscall fail.  I removed
    MOD_CLKA/MOD_CLKB as the mapping didn't really makes any sense, the kernel
    doesn't support setting the clock.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 8ea3e71ba7fa..3c49d173bf39 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -58,6 +58,8 @@
 
 #include <asm/param.h>
 
+#define NTP_API		4	/* NTP API version */
+
 /*
  * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
  * for a slightly underdamped convergence characteristic. SHIFT_KH
@@ -135,6 +137,8 @@ struct timex {
 #define ADJ_ESTERROR		0x0008	/* estimated time error */
 #define ADJ_STATUS		0x0010	/* clock status */
 #define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_MICRO		0x1000	/* select microsecond resolution */
+#define ADJ_NANO		0x2000	/* select nanosecond resolution */
 #define ADJ_TICK		0x4000	/* tick value */
 #define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
 #define ADJ_OFFSET_SS_READ	0xa001  /* read-only adjtime */
@@ -146,8 +150,6 @@ struct timex {
 #define MOD_ESTERROR	ADJ_ESTERROR
 #define MOD_STATUS	ADJ_STATUS
 #define MOD_TIMECONST	ADJ_TIMECONST
-#define MOD_CLKB	ADJ_TICK
-#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT /* 0x8000 in original */
 
 
 /*
@@ -169,9 +171,13 @@ struct timex {
 #define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
 
 #define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
+#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
+#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
 
+/* read-only bits */
 #define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
-    STA_PPSERROR | STA_CLOCKERR) /* read-only bits */
+	STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
 
 /*
  * Clock states (time_state)

commit 10a398d04c4a1fc395840f4d040493375f562302
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue Mar 4 15:14:26 2008 -0800

    time: remove obsolete CLOCK_TICK_ADJUST
    
    The first version of the ntp_interval/tick_length inconsistent usage patch was
    recently merged as bbe4d18ac2e058c56adb0cd71f49d9ed3216a405
    
    http://git.kernel.org/gitweb.cgi?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=bbe4d18ac2e058c56adb0cd71f49d9ed3216a405
    
    While the fix did greatly improve the situation, it was correctly pointed out
    by Roman that it does have a small bug: If the users change clocksources after
    the system has been running and NTP has made corrections, the correctoins made
    against the old clocksource will be applied against the new clocksource,
    causing error.
    
    The second attempt, which corrects the issue in the NTP_INTERVAL_LENGTH
    definition has also made it up-stream as commit
    e13a2e61dd5152f5499d2003470acf9c838eab84
    
    http://git.kernel.org/gitweb.cgi?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=e13a2e61dd5152f5499d2003470acf9c838eab84
    
    Roman has correctly pointed out that CLOCK_TICK_ADJUST is calculated
    based on the PIT's frequency, and isn't really relevant to non-PIT
    driven clocksources (that is, clocksources other then jiffies and pit).
    
    This patch reverts both of those changes, and simply removes
    CLOCK_TICK_ADJUST.
    
    This does remove the granularity error correction for users of PIT and Jiffies
    clocksource users, but the granularity error but for the majority of users, it
    should be within the 500ppm range NTP can accommodate for.
    
    For systems that have granularity errors greater then 500ppm, the
    "ntp_tick_adj=" boot option can be used to compensate.
    
    [johnstul@us.ibm.com: provided changelog]
    [mattilinnanvuori@yahoo.com: maek ntp_tick_adj static]
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Matti Linnanvuori <mattilinnanvuori@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: mingo@elte.hu
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index c3f374786a43..8ea3e71ba7fa 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -232,14 +232,7 @@ static inline int ntp_synced(void)
 #else
 #define NTP_INTERVAL_FREQ  (HZ)
 #endif
-
-#define CLOCK_TICK_OVERFLOW	(LATCH * HZ - CLOCK_TICK_RATE)
-#define CLOCK_TICK_ADJUST	(((s64)CLOCK_TICK_OVERFLOW * NSEC_PER_SEC) / \
-					(s64)CLOCK_TICK_RATE)
-
-/* Because using NSEC_PER_SEC would be too easy */
-#define NTP_INTERVAL_LENGTH ((((s64)TICK_USEC * NSEC_PER_USEC * USER_HZ) + \
-			      CLOCK_TICK_ADJUST) / NTP_INTERVAL_FREQ)
+#define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
 
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
 extern u64 current_tick_length(void);

commit e13a2e61dd5152f5499d2003470acf9c838eab84
Author: john stultz <johnstul@us.ibm.com>
Date:   Sun Feb 10 10:48:03 2008 +0100

    ntp: correct inconsistent interval/tick_length usage
    
    clocksource initialization and error accumulation.  This corrects a 280ppm
    drift seen on some systems using acpi_pm, and affects other clocksources as
    well (likely to a lesser degree).
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 8ea3e71ba7fa..c3f374786a43 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -232,7 +232,14 @@ static inline int ntp_synced(void)
 #else
 #define NTP_INTERVAL_FREQ  (HZ)
 #endif
-#define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
+
+#define CLOCK_TICK_OVERFLOW	(LATCH * HZ - CLOCK_TICK_RATE)
+#define CLOCK_TICK_ADJUST	(((s64)CLOCK_TICK_OVERFLOW * NSEC_PER_SEC) / \
+					(s64)CLOCK_TICK_RATE)
+
+/* Because using NSEC_PER_SEC would be too easy */
+#define NTP_INTERVAL_LENGTH ((((s64)TICK_USEC * NSEC_PER_USEC * USER_HZ) + \
+			      CLOCK_TICK_ADJUST) / NTP_INTERVAL_FREQ)
 
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
 extern u64 current_tick_length(void);

commit 941e492bdb1239d2ca8f5736cdfd3ff83d00cb90
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Feb 6 01:36:42 2008 -0800

    read_current_timer() cleanups
    
    - All implementations can be __devinit
    
    - The function prototypes were in asm/timex.h but they all must be the same,
      so create a single declaration in linux/timex.h.
    
    - uninline the sparc64 version to match the other architectures
    
    - Don't bother #defining ARCH_HAS_READ_CURRENT_TIMER to a particular value.
    
    [ezk@cs.sunysb.edu: fix build]
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 24c6a2b59511..8ea3e71ba7fa 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -244,6 +244,8 @@ extern int do_adjtimex(struct timex *);
 /* Don't use! Compatibility define for existing users. */
 #define tickadj	(500/HZ ? : 1)
 
+int read_current_timer(unsigned long *timer_val);
+
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */

commit 52bfb36050c8529d9031d2c2513b281a360922ec
Author: John Stultz <johnstul@us.ibm.com>
Date:   Mon Nov 26 20:42:19 2007 +0100

    time: add ADJ_OFFSET_SS_READ
    
    Michael Kerrisk reported that a long standing bug in the adjtimex()
    system call causes glibc's adjtime(3) function to deliver the wrong
    results if 'delta' is NULL.
    
    add the ADJ_OFFSET_SS_READ API detail, which will be used by glibc
    to fix this API compatibility bug.
    
    Also see: http://bugzilla.kernel.org/show_bug.cgi?id=6761
    
    [ mingo@elte.hu: added patch description and made it backwards compatible ]
    
    NOTE: the new flag is defined 0xa001 so that it returns -EINVAL on
    older kernels - this way glibc can use it safely. Suggested by Ulrich
    Drepper.
    
    Acked-by: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 37ac3ff90faf..24c6a2b59511 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -137,6 +137,7 @@ struct timex {
 #define ADJ_TIMECONST		0x0020	/* pll time constant */
 #define ADJ_TICK		0x4000	/* tick value */
 #define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
+#define ADJ_OFFSET_SS_READ	0xa001  /* read-only adjtime */
 
 /* xntp 3.4 compatibility names */
 #define MOD_OFFSET	ADJ_OFFSET

commit 1f564ad6d4182859612cbae452122e5eb2d62a76
Author: Bob Picco <bob.picco@hp.com>
Date:   Wed Jul 18 15:51:28 2007 -0700

    [IA64] remove time interpolator
    
    Remove time_interpolator code (This is generic code, but
    only user was ia64.  It has been superseded by the
    CONFIG_GENERIC_TIME code).
    
    Signed-off-by: Bob Picco <bob.picco@hp.com>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Peter Keilty <peter.keilty@hp.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index da929dbbea2a..37ac3ff90faf 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -224,66 +224,6 @@ static inline int ntp_synced(void)
 	__x < 0 ? -(-__x >> __s) : __x >> __s;	\
 })
 
-
-#ifdef CONFIG_TIME_INTERPOLATION
-
-#define TIME_SOURCE_CPU 0
-#define TIME_SOURCE_MMIO64 1
-#define TIME_SOURCE_MMIO32 2
-#define TIME_SOURCE_FUNCTION 3
-
-/* For proper operations time_interpolator clocks must run slightly slower
- * than the standard clock since the interpolator may only correct by having
- * time jump forward during a tick. A slower clock is usually a side effect
- * of the integer divide of the nanoseconds in a second by the frequency.
- * The accuracy of the division can be increased by specifying a shift.
- * However, this may cause the clock not to be slow enough.
- * The interpolator will self-tune the clock by slowing down if no
- * resets occur or speeding up if the time jumps per analysis cycle
- * become too high.
- *
- * Setting jitter compensates for a fluctuating timesource by comparing
- * to the last value read from the timesource to insure that an earlier value
- * is not returned by a later call. The price to pay
- * for the compensation is that the timer routines are not as scalable anymore.
- */
-
-struct time_interpolator {
-	u16 source;			/* time source flags */
-	u8 shift;			/* increases accuracy of multiply by shifting. */
-				/* Note that bits may be lost if shift is set too high */
-	u8 jitter;			/* if set compensate for fluctuations */
-	u32 nsec_per_cyc;		/* set by register_time_interpolator() */
-	void *addr;			/* address of counter or function */
-	cycles_t mask;			/* mask the valid bits of the counter */
-	unsigned long offset;		/* nsec offset at last update of interpolator */
-	u64 last_counter;		/* counter value in units of the counter at last update */
-	cycles_t last_cycle;		/* Last timer value if TIME_SOURCE_JITTER is set */
-	u64 frequency;			/* frequency in counts/second */
-	long drift;			/* drift in parts-per-million (or -1) */
-	unsigned long skips;		/* skips forward */
-	unsigned long ns_skipped;	/* nanoseconds skipped */
-	struct time_interpolator *next;
-};
-
-extern void register_time_interpolator(struct time_interpolator *);
-extern void unregister_time_interpolator(struct time_interpolator *);
-extern void time_interpolator_reset(void);
-extern unsigned long time_interpolator_get_offset(void);
-extern void time_interpolator_update(long delta_nsec);
-
-#else /* !CONFIG_TIME_INTERPOLATION */
-
-static inline void time_interpolator_reset(void)
-{
-}
-
-static inline void time_interpolator_update(long delta_nsec)
-{
-}
-
-#endif /* !CONFIG_TIME_INTERPOLATION */
-
 #define TICK_LENGTH_SHIFT	32
 
 #ifdef CONFIG_NO_HZ

commit f4304ab21513b834c8fe3403927c60c2b81a72d7
Author: john stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:27:26 2007 -0800

    [PATCH] HZ free ntp
    
    Distangle the NTP update from HZ.  This is necessary for dynamic tick enabled
    kernels.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 9a24e500c311..da929dbbea2a 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -286,6 +286,13 @@ static inline void time_interpolator_update(long delta_nsec)
 
 #define TICK_LENGTH_SHIFT	32
 
+#ifdef CONFIG_NO_HZ
+#define NTP_INTERVAL_FREQ  (2)
+#else
+#define NTP_INTERVAL_FREQ  (HZ)
+#endif
+#define NTP_INTERVAL_LENGTH (NSEC_PER_SEC/NTP_INTERVAL_FREQ)
+
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
 extern u64 current_tick_length(void);
 

commit 3db5db4fcdafc85b99d171336a7d2f25765ccd13
Author: Helge Deller <deller@gmx.de>
Date:   Sat Feb 10 01:45:40 2007 -0800

    [PATCH] use cycle_t instead of u64 in struct time_interpolator
    
    The 32bit and 64bit PARISC Linux kernels suffers from the problem, that the
    gettimeofday() call sometimes returns non-monotonic times.
    
    The easiest way to fix this, is to drop the PARISC-specific implementation
    and switch over to the generic TIME_INTERPOLATION framework.
    
    But in order to make it even compile on 32bit PARISC, the patch below which
    touches the generic Linux code, is mandatory.
    
    More information and the full patch with the parisc-specific changes is included in this thread: http://lists.parisc-linux.org/pipermail/parisc-linux/2006-December/031003.html
    
    As far as I could see, this patch does not change anything for the existing
    architectures which use this framework (IA64 and SPARC64), since "cycles_t"
    is defined there as unsigned 64bit-integer anyway (which then makes this
    patch a no-change for them).
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: <linux-arch@vger.kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index db501dc23c29..9a24e500c311 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -255,10 +255,10 @@ struct time_interpolator {
 	u8 jitter;			/* if set compensate for fluctuations */
 	u32 nsec_per_cyc;		/* set by register_time_interpolator() */
 	void *addr;			/* address of counter or function */
-	u64 mask;			/* mask the valid bits of the counter */
+	cycles_t mask;			/* mask the valid bits of the counter */
 	unsigned long offset;		/* nsec offset at last update of interpolator */
 	u64 last_counter;		/* counter value in units of the counter at last update */
-	u64 last_cycle;			/* Last timer value if TIME_SOURCE_JITTER is set */
+	cycles_t last_cycle;		/* Last timer value if TIME_SOURCE_JITTER is set */
 	u64 frequency;			/* frequency in counts/second */
 	long drift;			/* drift in parts-per-million (or -1) */
 	unsigned long skips;		/* skips forward */

commit 7236e978a3883406ca06ee79e0739743c7c92a85
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Oct 6 00:43:54 2006 -0700

    [PATCH] provide tickadj define
    
    Provide a tickadj compatibility define for archs still using it.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 049dfe4a11f2..db501dc23c29 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -293,6 +293,9 @@ extern void second_overflow(void);
 extern void update_ntp_one_tick(void);
 extern int do_adjtimex(struct timex *);
 
+/* Don't use! Compatibility define for existing users. */
+#define tickadj	(500/HZ ? : 1)
+
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */

commit 70bc42f90a3f4721c89dbe865e6c95da8565b41c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Sep 30 23:28:29 2006 -0700

    [PATCH] kernel/time/ntp.c: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global function static:
      - ntp_update_frequency()
    - make the following needlessly global variables static:
      - time_state
      - time_offset
      - time_constant
      - time_reftime
    - remove the following read-only global variable:
      - time_precision
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 261381b5da82..049dfe4a11f2 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -198,21 +198,15 @@ extern int tickadj;			/* amount of adjustment per tick */
 /*
  * phase-lock loop variables
  */
-extern int time_state;		/* clock status */
 extern int time_status;		/* clock synchronization status bits */
-extern long time_offset;	/* time adjustment (us) */
-extern long time_constant;	/* pll time constant */
-extern long time_precision;	/* clock precision (us) */
 extern long time_maxerror;	/* maximum error */
 extern long time_esterror;	/* estimated error */
 
 extern long time_freq;		/* frequency offset (scaled ppm) */
-extern long time_reftime;	/* time at last adjustment (s) */
 
 extern long time_adjust;	/* The amount of adjtime left */
 
 extern void ntp_clear(void);
-extern void ntp_update_frequency(void);
 
 /**
  * ntp_synced - Returns 1 if the NTP status is not UNSYNC

commit 0883d899ef862c1b0f8b2c2d38098470c193a3dd
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:29 2006 -0700

    [PATCH] ntp: cleanup defines and comments
    
    Remove a few unused defines and remove obsolete information from comments.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index ac808f13fa0e..261381b5da82 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -74,24 +74,17 @@
 #define MAXTC		10	/* maximum time constant (shift) */
 
 /*
- * The SHIFT_SCALE define establishes the decimal point of the time_phase
- * variable which serves as an extension to the low-order bits of the
- * system clock variable. The SHIFT_UPDATE define establishes the decimal
- * point of the time_offset variable which represents the current offset
- * with respect to standard time. The FINENSEC define represents 1 nsec in
- * scaled units.
+ * The SHIFT_UPDATE define establishes the decimal point of the
+ * time_offset variable which represents the current offset with
+ * respect to standard time.
  *
  * SHIFT_USEC defines the scaling (shift) of the time_freq and
  * time_tolerance variables, which represent the current frequency
  * offset and maximum frequency tolerance.
- *
- * FINENSEC is 1 ns in SHIFT_UPDATE units of the time_phase variable.
  */
-#define SHIFT_SCALE 22		/* phase scale (shift) */
 #define SHIFT_UPDATE (SHIFT_HZ + 1) /* time offset scale (shift) */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
 #define SHIFT_NSEC 12		/* kernel frequency offset scale */
-#define FINENSEC (1L << (SHIFT_SCALE - 10)) /* ~1 ns in phase units */
 
 #define MAXPHASE 512000L        /* max phase error (us) */
 #define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */

commit f19923937321244e7dc334767eb4b67e0e3d5c74
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:28 2006 -0700

    [PATCH] ntp: convert to the NTP4 reference model
    
    This converts the kernel ntp model into a model which matches the nanokernel
    reference implementations.  The previous patches already increased the
    resolution and precision of the computations, so that this conversion becomes
    quite simple.
    
    <linux@horizon.com> explains:
    
    The original NTP kernel interface was defined in units of microseconds.
    That's what Linux implements.  As computers have gotten faster and can now
    split microseconds easily, a new kernel interface using nanosecond units was
    defined ("the nanokernel", confusing as that name is to OS hackers), and
    there's an STA_NANO bit in the adjtimex() status field to tell the application
    which units it's using.
    
    The current ntpd supports both, but Linux loses some possible timing
    resolution because of quantization effects, and the ntpd hackers would really
    like to be able to drop the backwards compatibility code.
    
    Ulrich Windl has been maintaining a patch set to do the conversion for years,
    but it's hard to keep in sync.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 671609ee1a3d..ac808f13fa0e 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -69,10 +69,9 @@
  * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
  * respectively.
  */
-#define SHIFT_KG 6		/* phase factor (shift) */
-#define SHIFT_KF 16		/* PLL frequency factor (shift) */
-#define SHIFT_KH 2		/* FLL frequency factor (shift) */
-#define MAXTC 6			/* maximum time constant (shift) */
+#define SHIFT_PLL	4	/* PLL frequency factor (shift) */
+#define SHIFT_FLL	2	/* FLL frequency factor (shift) */
+#define MAXTC		10	/* maximum time constant (shift) */
 
 /*
  * The SHIFT_SCALE define establishes the decimal point of the time_phase
@@ -97,8 +96,8 @@
 #define MAXPHASE 512000L        /* max phase error (us) */
 #define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
 #define MAXFREQ_NSEC (512000L << SHIFT_NSEC) /* max frequency error (ppb) */
-#define MINSEC 16L              /* min interval between updates (s) */
-#define MAXSEC 1200L            /* max interval between updates (s) */
+#define MINSEC 256		/* min interval between updates (s) */
+#define MAXSEC 2048		/* max interval between updates (s) */
 #define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
 
 /*

commit 04b617e71e363e640e88be1e43f53fa6a3afef9f
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:27 2006 -0700

    [PATCH] ntp: convert time_freq to nsec value
    
    This converts time_freq to a scaled nsec value and adds around 6bit of extra
    resolution.  This pushes the time_freq to its 32bit limits so the calculatons
    have to be done with 64bit.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 7715b4c0caf9..671609ee1a3d 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -91,10 +91,12 @@
 #define SHIFT_SCALE 22		/* phase scale (shift) */
 #define SHIFT_UPDATE (SHIFT_HZ + 1) /* time offset scale (shift) */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
+#define SHIFT_NSEC 12		/* kernel frequency offset scale */
 #define FINENSEC (1L << (SHIFT_SCALE - 10)) /* ~1 ns in phase units */
 
 #define MAXPHASE 512000L        /* max phase error (us) */
 #define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
+#define MAXFREQ_NSEC (512000L << SHIFT_NSEC) /* max frequency error (ppb) */
 #define MINSEC 16L              /* min interval between updates (s) */
 #define MAXSEC 1200L            /* max interval between updates (s) */
 #define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */

commit 97eebe138caaf78354b1fad233e63bafdcc4fd54
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:26 2006 -0700

    [PATCH] ntp: remove time_tolerance
    
    time_tolerance isn't changed at all in the kernel, so simply remove it, this
    simplifies the next patch, as it avoids a number of conversions.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b5f297e17668..7715b4c0caf9 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -208,7 +208,6 @@ extern int time_state;		/* clock status */
 extern int time_status;		/* clock synchronization status bits */
 extern long time_offset;	/* time adjustment (us) */
 extern long time_constant;	/* pll time constant */
-extern long time_tolerance;	/* frequency tolerance (ppm) */
 extern long time_precision;	/* clock precision (us) */
 extern long time_maxerror;	/* maximum error */
 extern long time_esterror;	/* estimated error */

commit 8f807f8d2137ba728d22820103131038639b68a9
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:25 2006 -0700

    [PATCH] ntp: add time_adjust to tick length
    
    This folds update_ntp_one_tick() into second_overflow() and adds time_adjust
    to the tick length, this makes time_next_adjust unnecessary.  This slightly
    changes the adjtime() behaviour, instead of applying it to the next tick, it's
    applied to the next second.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 1cde6f6a2712..b5f297e17668 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -217,7 +217,6 @@ extern long time_freq;		/* frequency offset (scaled ppm) */
 extern long time_reftime;	/* time at last adjustment (s) */
 
 extern long time_adjust;	/* The amount of adjtime left */
-extern long time_next_adjust;	/* Value for time_adjust at next tick */
 
 extern void ntp_clear(void);
 extern void ntp_update_frequency(void);

commit 3d3675cc3d04d7fd4bb11e8c1ea79e5ade4f5e44
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:25 2006 -0700

    [PATCH] ntp: prescale time_offset
    
    This converts time_offset into a scaled per tick value.  This avoids now
    completely the crude compensation in second_overflow().
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b589c8218bb9..1cde6f6a2712 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -89,7 +89,7 @@
  * FINENSEC is 1 ns in SHIFT_UPDATE units of the time_phase variable.
  */
 #define SHIFT_SCALE 22		/* phase scale (shift) */
-#define SHIFT_UPDATE (SHIFT_KG + MAXTC) /* time offset scale (shift) */
+#define SHIFT_UPDATE (SHIFT_HZ + 1) /* time offset scale (shift) */
 #define SHIFT_USEC 16		/* frequency offset scale (shift) */
 #define FINENSEC (1L << (SHIFT_SCALE - 10)) /* ~1 ns in phase units */
 

commit b0ee75561beadc4db4d9a899c8ef4a7db50aa0ab
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 30 23:28:22 2006 -0700

    [PATCH] ntp: add ntp_update_frequency
    
    This introduces ntp_update_frequency() and deinlines ntp_clear() (as it's not
    performance critical).  ntp_update_frequency() calculates the base tick length
    using tick_usec and adds a base adjustment, in case the frequency doesn't
    divide evenly by HZ.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 2a21485bf183..b589c8218bb9 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -219,18 +219,8 @@ extern long time_reftime;	/* time at last adjustment (s) */
 extern long time_adjust;	/* The amount of adjtime left */
 extern long time_next_adjust;	/* Value for time_adjust at next tick */
 
-/**
- * ntp_clear - Clears the NTP state variables
- *
- * Must be called while holding a write on the xtime_lock
- */
-static inline void ntp_clear(void)
-{
-	time_adjust = 0;		/* stop active adjtime() */
-	time_status |= STA_UNSYNC;
-	time_maxerror = NTP_PHASE_LIMIT;
-	time_esterror = NTP_PHASE_LIMIT;
-}
+extern void ntp_clear(void);
+extern void ntp_update_frequency(void);
 
 /**
  * ntp_synced - Returns 1 if the NTP status is not UNSYNC

commit 4c7ee8de956fc250fe31e2fa91f6da980fabe317
Author: john stultz <johnstul@us.ibm.com>
Date:   Sat Sep 30 23:28:22 2006 -0700

    [PATCH] NTP: Move all the NTP related code to ntp.c
    
    Move all the NTP related code to ntp.c
    
    [akpm@osdl.org: cleanups, build fix]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index d543d3871e38..2a21485bf183 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -294,11 +294,15 @@ extern void register_time_interpolator(struct time_interpolator *);
 extern void unregister_time_interpolator(struct time_interpolator *);
 extern void time_interpolator_reset(void);
 extern unsigned long time_interpolator_get_offset(void);
+extern void time_interpolator_update(long delta_nsec);
 
 #else /* !CONFIG_TIME_INTERPOLATION */
 
-static inline void
-time_interpolator_reset(void)
+static inline void time_interpolator_reset(void)
+{
+}
+
+static inline void time_interpolator_update(long delta_nsec)
 {
 }
 
@@ -309,6 +313,8 @@ time_interpolator_reset(void)
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
 extern u64 current_tick_length(void);
 
+extern void second_overflow(void);
+extern void update_ntp_one_tick(void);
 extern int do_adjtimex(struct timex *);
 
 #endif /* KERNEL */

commit ee6baf884b27739cca110e5167a2edfa061ca19f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Sep 12 20:36:03 2006 -0700

    [PATCH] headers_check: remove <asm/timex.h> from user export
    
    There's useful stuff in <linux/timex.h> but <asm/timex.h> has nothing for
    userspace.  Stop exporting it, and include it only from within the existing
    #ifdef __KERNEL__ part of <linux/timex.h>
    
    This fixes a 'make headers_check' failure on i386 because asm-i386/timex.h
    includes both asm-i386/tsc.h and asm-i386/processor.h, neither of which are
    exported to userspace.  It's not entirely clear _why_ it includes either of
    these, but it does.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 19bb6538b49e..d543d3871e38 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -57,7 +57,6 @@
 #include <linux/time.h>
 
 #include <asm/param.h>
-#include <asm/timex.h>
 
 /*
  * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
@@ -191,6 +190,8 @@ struct timex {
 #define TIME_BAD	TIME_ERROR /* bw compat */
 
 #ifdef __KERNEL__
+#include <asm/timex.h>
+
 /*
  * kernel variables
  * Note: maximum error = NTP synch distance = dispersion + delay / 2;

commit 19923c190e0932bf0ac1e1d06a48f5c3678dd0de
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jun 26 00:25:18 2006 -0700

    [PATCH] fix and optimize clock source update
    
    This fixes the clock source updates in update_wall_time() to correctly
    track the time coming in via current_tick_length().  Optimize the fast
    paths to be as short as possible to keep the overhead low.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 1ba3071fcb82..19bb6538b49e 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -303,8 +303,10 @@ time_interpolator_reset(void)
 
 #endif /* !CONFIG_TIME_INTERPOLATION */
 
+#define TICK_LENGTH_SHIFT	32
+
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
-extern u64 current_tick_length(long);
+extern u64 current_tick_length(void);
 
 extern int do_adjtimex(struct timex *);
 

commit 260a42309b31cbc54eb4b6b85649e412bcad053f
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:07 2006 -0700

    [PATCH] Time: Let user request precision from current_tick_length()
    
    Change the current_tick_length() function so it takes an argument which
    specifies how much precision to return in shifted nanoseconds.  This provides
    a simple way to convert between NTPs internal nanoseconds shifted by
    (SHIFT_SCALE - 10) to other shifted nanosecond units that are used by the
    clocksource abstraction.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 34d3ccff7bbb..1ba3071fcb82 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -304,7 +304,7 @@ time_interpolator_reset(void)
 #endif /* !CONFIG_TIME_INTERPOLATION */
 
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
-extern u64 current_tick_length(void);
+extern u64 current_tick_length(long);
 
 extern int do_adjtimex(struct timex *);
 

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 03914b7e41b1..34d3ccff7bbb 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -53,7 +53,6 @@
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
 
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <linux/time.h>
 

commit 3158e9411a66fb98d495ac441c242264f31aaf3e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Sun Mar 26 01:37:29 2006 -0800

    [PATCH] consolidate sys32/compat_adjtimex
    
    Create compat_sys_adjtimex and use it an all appropriate places.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 82dc9ae79d37..03914b7e41b1 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -307,6 +307,8 @@ time_interpolator_reset(void)
 /* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
 extern u64 current_tick_length(void);
 
+extern int do_adjtimex(struct timex *);
+
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */

commit 5ddcfa878d5b10b0ab94251a4229a8a9daaf93ed
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Mar 25 03:08:28 2006 -0800

    [PATCH] remove pps support
    
    This removes the support for pps.  It's completely unused within the kernel
    and is basically in the way for further cleanups.  It should be easier to
    readd proper support for it after the rest has been converted to NTP4
    (where the pps mechanisms are quite different from NTP3 anyway).
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index b7ca1204e42a..82dc9ae79d37 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -97,37 +97,10 @@
 
 #define MAXPHASE 512000L        /* max phase error (us) */
 #define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
-#define MAXTIME (200L << PPS_AVG) /* max PPS error (jitter) (200 us) */
 #define MINSEC 16L              /* min interval between updates (s) */
 #define MAXSEC 1200L            /* max interval between updates (s) */
 #define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
 
-/*
- * The following defines are used only if a pulse-per-second (PPS)
- * signal is available and connected via a modem control lead, such as
- * produced by the optional ppsclock feature incorporated in the Sun
- * asynch driver. They establish the design parameters of the frequency-
- * lock loop used to discipline the CPU clock oscillator to the PPS
- * signal.
- *
- * PPS_AVG is the averaging factor for the frequency loop, as well as
- * the time and frequency dispersion.
- *
- * PPS_SHIFT and PPS_SHIFTMAX specify the minimum and maximum
- * calibration intervals, respectively, in seconds as a power of two.
- *
- * PPS_VALID is the maximum interval before the PPS signal is considered
- * invalid and protocol updates used directly instead.
- *
- * MAXGLITCH is the maximum interval before a time offset of more than
- * MAXTIME is believed.
- */
-#define PPS_AVG 2		/* pps averaging constant (shift) */
-#define PPS_SHIFT 2		/* min interval duration (s) (shift) */
-#define PPS_SHIFTMAX 8		/* max interval duration (s) (shift) */
-#define PPS_VALID 120		/* pps signal watchdog max (s) */
-#define MAXGLITCH 30		/* pps signal glitch max (s) */
-
 /*
  * syscall interface - used (mainly by NTP daemon)
  * to discipline kernel clock oscillator
@@ -246,20 +219,6 @@ extern long time_reftime;	/* time at last adjustment (s) */
 extern long time_adjust;	/* The amount of adjtime left */
 extern long time_next_adjust;	/* Value for time_adjust at next tick */
 
-/* interface variables pps->timer interrupt */
-extern long pps_offset;		/* pps time offset (us) */
-extern long pps_jitter;		/* time dispersion (jitter) (us) */
-extern long pps_freq;		/* frequency offset (scaled ppm) */
-extern long pps_stabil;		/* frequency dispersion (scaled ppm) */
-extern long pps_valid;		/* pps signal watchdog counter */
-
-/* interface variables pps->adjtimex */
-extern int pps_shift;		/* interval duration (s) (shift) */
-extern long pps_jitcnt;		/* jitter limit exceeded */
-extern long pps_calcnt;		/* calibration intervals */
-extern long pps_errcnt;		/* calibration errors */
-extern long pps_stbcnt;		/* stability limit exceeded */
-
 /**
  * ntp_clear - Clears the NTP state variables
  *

commit 726c14bf499e91e7ede4f1728830aba05c675061
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Feb 17 10:30:23 2006 +1100

    [PATCH] Provide an interface for getting the current tick length
    
    This provides an interface for arch code to find out how many
    nanoseconds are going to be added on to xtime by the next call to
    do_timer.  The value returned is a fixed-point number in 52.12 format
    in nanoseconds.  The reason for this format is that it gives the
    full precision that the timekeeping code is using internally.
    
    The motivation for this is to fix a problem that has arisen on 32-bit
    powerpc in that the value returned by do_gettimeofday drifts apart
    from xtime if NTP is being used.  PowerPC is now using a lockless
    do_gettimeofday based on reading the timebase register and performing
    some simple arithmetic.  (This method of getting the time is also
    exported to userspace via the VDSO.)  However, the factor and offset
    it uses were calculated based on the nominal tick length and weren't
    being adjusted when NTP varied the tick length.
    
    Note that 64-bit powerpc has had the lockless do_gettimeofday for a
    long time now.  It also had an extremely hairy routine that got called
    from the 32-bit compat routine for adjtimex, which adjusted the
    factor and offset according to what it thought the timekeeping code
    was going to do.  Not only was this only called if a 32-bit task did
    adjtimex (i.e. not if a 64-bit task did adjtimex), it was also
    duplicating computations from kernel/timer.c and it wasn't clear that
    it was (still) correct.
    
    The simple solution is to ask the timekeeping code how long the
    current jiffy will be on each timer interrupt, after calling
    do_timer.  If this jiffy will be a different length from the last one,
    we then need to compute new values for the factor and offset used in
    the lockless do_gettimeofday.  In this way we can keep xtime and
    do_gettimeofday in sync, even when NTP is varying the tick length.
    
    Note that when adjtimex varies the tick length, it almost always
    introduces the variation from the next tick on.  The only case I could
    see where adjtimex would vary the length of the current tick is when
    an old-style adjtime adjustment is being cancelled.  (It's not clear
    to me why the adjustment has to be cancelled immediately rather than
    from the next tick on.)  Thus I don't see any real need for a hook in
    adjtimex; the rare case of an old-style adjustment being cancelled can
    be fixed up at the next tick.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Acked-by: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 04a4a8cb4ed3..b7ca1204e42a 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -345,6 +345,9 @@ time_interpolator_reset(void)
 
 #endif /* !CONFIG_TIME_INTERPOLATION */
 
+/* Returns how long ticks are at present, in ns / 2^(SHIFT_SCALE-10). */
+extern u64 current_tick_length(void);
+
 #endif /* KERNEL */
 
 #endif /* LINUX_TIMEX_H */

commit 1bb34a412750291e4e5e9f1d0fe7ae1b7e976098
Author: john stultz <johnstul@us.ibm.com>
Date:   Sun Oct 30 15:01:42 2005 -0800

    [PATCH] NTP shift_right cleanup
    
    Create a macro shift_right() that avoids the numerous ugly conditionals in the
    NTP code that look like:
    
            if(a < 0)
                    b = -(-a >> shift);
            else
                    b = a >> shift;
    
    Replacing it with:
    
            b = shift_right(a, shift);
    
    This should have zero effect on the logic, however it should probably have
    a bit of testing just to be sure.
    
    Also replace open-coded min/max with the macros.
    
    Signed-off-by : John Stultz <johnstul@us.ibm.com>
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 7e050a2cc35b..04a4a8cb4ed3 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -282,6 +282,13 @@ static inline int ntp_synced(void)
 	return !(time_status & STA_UNSYNC);
 }
 
+/* Required to safely shift negative values */
+#define shift_right(x, s) ({	\
+	__typeof__(x) __x = (x);	\
+	__typeof__(s) __s = (s);	\
+	__x < 0 ? -(-__x >> __s) : __x >> __s;	\
+})
+
 
 #ifdef CONFIG_TIME_INTERPOLATION
 

commit b149ee2233edf08fb59b11e879a2c5941929bcb8
Author: john stultz <johnstul@us.ibm.com>
Date:   Tue Sep 6 15:17:46 2005 -0700

    [PATCH] NTP: ntp-helper functions
    
    This patch cleans up a commonly repeated set of changes to the NTP state
    variables by adding two helper inline functions:
    
    ntp_clear(): Clears the ntp state variables
    
    ntp_synced(): Returns 1 if the system is synced with a time server.
    
    This was compile tested for alpha, arm, i386, x86-64, ppc64, s390, sparc,
    sparc64.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/timex.h b/include/linux/timex.h
index 74fdd07d3792..7e050a2cc35b 100644
--- a/include/linux/timex.h
+++ b/include/linux/timex.h
@@ -260,6 +260,29 @@ extern long pps_calcnt;		/* calibration intervals */
 extern long pps_errcnt;		/* calibration errors */
 extern long pps_stbcnt;		/* stability limit exceeded */
 
+/**
+ * ntp_clear - Clears the NTP state variables
+ *
+ * Must be called while holding a write on the xtime_lock
+ */
+static inline void ntp_clear(void)
+{
+	time_adjust = 0;		/* stop active adjtime() */
+	time_status |= STA_UNSYNC;
+	time_maxerror = NTP_PHASE_LIMIT;
+	time_esterror = NTP_PHASE_LIMIT;
+}
+
+/**
+ * ntp_synced - Returns 1 if the NTP status is not UNSYNC
+ *
+ */
+static inline int ntp_synced(void)
+{
+	return !(time_status & STA_UNSYNC);
+}
+
+
 #ifdef CONFIG_TIME_INTERPOLATION
 
 #define TIME_SOURCE_CPU 0

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/timex.h b/include/linux/timex.h
new file mode 100644
index 000000000000..74fdd07d3792
--- /dev/null
+++ b/include/linux/timex.h
@@ -0,0 +1,320 @@
+/*****************************************************************************
+ *                                                                           *
+ * Copyright (c) David L. Mills 1993                                         *
+ *                                                                           *
+ * Permission to use, copy, modify, and distribute this software and its     *
+ * documentation for any purpose and without fee is hereby granted, provided *
+ * that the above copyright notice appears in all copies and that both the   *
+ * copyright notice and this permission notice appear in supporting          *
+ * documentation, and that the name University of Delaware not be used in    *
+ * advertising or publicity pertaining to distribution of the software       *
+ * without specific, written prior permission.  The University of Delaware   *
+ * makes no representations about the suitability this software for any      *
+ * purpose.  It is provided "as is" without express or implied warranty.     *
+ *                                                                           *
+ *****************************************************************************/
+
+/*
+ * Modification history timex.h
+ *
+ * 29 Dec 97	Russell King
+ *	Moved CLOCK_TICK_RATE, CLOCK_TICK_FACTOR and FINETUNE to asm/timex.h
+ *	for ARM machines
+ *
+ *  9 Jan 97    Adrian Sun
+ *      Shifted LATCH define to allow access to alpha machines.
+ *
+ * 26 Sep 94	David L. Mills
+ *	Added defines for hybrid phase/frequency-lock loop.
+ *
+ * 19 Mar 94	David L. Mills
+ *	Moved defines from kernel routines to header file and added new
+ *	defines for PPS phase-lock loop.
+ *
+ * 20 Feb 94	David L. Mills
+ *	Revised status codes and structures for external clock and PPS
+ *	signal discipline.
+ *
+ * 28 Nov 93	David L. Mills
+ *	Adjusted parameters to improve stability and increase poll
+ *	interval.
+ *
+ * 17 Sep 93    David L. Mills
+ *      Created file $NTP/include/sys/timex.h
+ * 07 Oct 93    Torsten Duwe
+ *      Derived linux/timex.h
+ * 1995-08-13    Torsten Duwe
+ *      kernel PLL updated to 1994-12-13 specs (rfc-1589)
+ * 1997-08-30    Ulrich Windl
+ *      Added new constant NTP_PHASE_LIMIT
+ * 2004-08-12    Christoph Lameter
+ *      Reworked time interpolation logic
+ */
+#ifndef _LINUX_TIMEX_H
+#define _LINUX_TIMEX_H
+
+#include <linux/config.h>
+#include <linux/compiler.h>
+#include <linux/time.h>
+
+#include <asm/param.h>
+#include <asm/timex.h>
+
+/*
+ * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
+ * for a slightly underdamped convergence characteristic. SHIFT_KH
+ * establishes the damping of the FLL and is chosen by wisdom and black
+ * art.
+ *
+ * MAXTC establishes the maximum time constant of the PLL. With the
+ * SHIFT_KG and SHIFT_KF values given and a time constant range from
+ * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
+ * respectively.
+ */
+#define SHIFT_KG 6		/* phase factor (shift) */
+#define SHIFT_KF 16		/* PLL frequency factor (shift) */
+#define SHIFT_KH 2		/* FLL frequency factor (shift) */
+#define MAXTC 6			/* maximum time constant (shift) */
+
+/*
+ * The SHIFT_SCALE define establishes the decimal point of the time_phase
+ * variable which serves as an extension to the low-order bits of the
+ * system clock variable. The SHIFT_UPDATE define establishes the decimal
+ * point of the time_offset variable which represents the current offset
+ * with respect to standard time. The FINENSEC define represents 1 nsec in
+ * scaled units.
+ *
+ * SHIFT_USEC defines the scaling (shift) of the time_freq and
+ * time_tolerance variables, which represent the current frequency
+ * offset and maximum frequency tolerance.
+ *
+ * FINENSEC is 1 ns in SHIFT_UPDATE units of the time_phase variable.
+ */
+#define SHIFT_SCALE 22		/* phase scale (shift) */
+#define SHIFT_UPDATE (SHIFT_KG + MAXTC) /* time offset scale (shift) */
+#define SHIFT_USEC 16		/* frequency offset scale (shift) */
+#define FINENSEC (1L << (SHIFT_SCALE - 10)) /* ~1 ns in phase units */
+
+#define MAXPHASE 512000L        /* max phase error (us) */
+#define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
+#define MAXTIME (200L << PPS_AVG) /* max PPS error (jitter) (200 us) */
+#define MINSEC 16L              /* min interval between updates (s) */
+#define MAXSEC 1200L            /* max interval between updates (s) */
+#define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
+
+/*
+ * The following defines are used only if a pulse-per-second (PPS)
+ * signal is available and connected via a modem control lead, such as
+ * produced by the optional ppsclock feature incorporated in the Sun
+ * asynch driver. They establish the design parameters of the frequency-
+ * lock loop used to discipline the CPU clock oscillator to the PPS
+ * signal.
+ *
+ * PPS_AVG is the averaging factor for the frequency loop, as well as
+ * the time and frequency dispersion.
+ *
+ * PPS_SHIFT and PPS_SHIFTMAX specify the minimum and maximum
+ * calibration intervals, respectively, in seconds as a power of two.
+ *
+ * PPS_VALID is the maximum interval before the PPS signal is considered
+ * invalid and protocol updates used directly instead.
+ *
+ * MAXGLITCH is the maximum interval before a time offset of more than
+ * MAXTIME is believed.
+ */
+#define PPS_AVG 2		/* pps averaging constant (shift) */
+#define PPS_SHIFT 2		/* min interval duration (s) (shift) */
+#define PPS_SHIFTMAX 8		/* max interval duration (s) (shift) */
+#define PPS_VALID 120		/* pps signal watchdog max (s) */
+#define MAXGLITCH 30		/* pps signal glitch max (s) */
+
+/*
+ * syscall interface - used (mainly by NTP daemon)
+ * to discipline kernel clock oscillator
+ */
+struct timex {
+	unsigned int modes;	/* mode selector */
+	long offset;		/* time offset (usec) */
+	long freq;		/* frequency offset (scaled ppm) */
+	long maxerror;		/* maximum error (usec) */
+	long esterror;		/* estimated error (usec) */
+	int status;		/* clock command/status */
+	long constant;		/* pll time constant */
+	long precision;		/* clock precision (usec) (read only) */
+	long tolerance;		/* clock frequency tolerance (ppm)
+				 * (read only)
+				 */
+	struct timeval time;	/* (read only) */
+	long tick;		/* (modified) usecs between clock ticks */
+
+	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
+	long jitter;            /* pps jitter (us) (ro) */
+	int shift;              /* interval duration (s) (shift) (ro) */
+	long stabil;            /* pps stability (scaled ppm) (ro) */
+	long jitcnt;            /* jitter limit exceeded (ro) */
+	long calcnt;            /* calibration intervals (ro) */
+	long errcnt;            /* calibration errors (ro) */
+	long stbcnt;            /* stability limit exceeded (ro) */
+
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32; int  :32;
+	int  :32; int  :32; int  :32; int  :32;
+};
+
+/*
+ * Mode codes (timex.mode)
+ */
+#define ADJ_OFFSET		0x0001	/* time offset */
+#define ADJ_FREQUENCY		0x0002	/* frequency offset */
+#define ADJ_MAXERROR		0x0004	/* maximum time error */
+#define ADJ_ESTERROR		0x0008	/* estimated time error */
+#define ADJ_STATUS		0x0010	/* clock status */
+#define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_TICK		0x4000	/* tick value */
+#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
+
+/* xntp 3.4 compatibility names */
+#define MOD_OFFSET	ADJ_OFFSET
+#define MOD_FREQUENCY	ADJ_FREQUENCY
+#define MOD_MAXERROR	ADJ_MAXERROR
+#define MOD_ESTERROR	ADJ_ESTERROR
+#define MOD_STATUS	ADJ_STATUS
+#define MOD_TIMECONST	ADJ_TIMECONST
+#define MOD_CLKB	ADJ_TICK
+#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT /* 0x8000 in original */
+
+
+/*
+ * Status codes (timex.status)
+ */
+#define STA_PLL		0x0001	/* enable PLL updates (rw) */
+#define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
+#define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
+#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
+
+#define STA_INS		0x0010	/* insert leap (rw) */
+#define STA_DEL		0x0020	/* delete leap (rw) */
+#define STA_UNSYNC	0x0040	/* clock unsynchronized (rw) */
+#define STA_FREQHOLD	0x0080	/* hold frequency (rw) */
+
+#define STA_PPSSIGNAL	0x0100	/* PPS signal present (ro) */
+#define STA_PPSJITTER	0x0200	/* PPS signal jitter exceeded (ro) */
+#define STA_PPSWANDER	0x0400	/* PPS signal wander exceeded (ro) */
+#define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
+
+#define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+
+#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
+    STA_PPSERROR | STA_CLOCKERR) /* read-only bits */
+
+/*
+ * Clock states (time_state)
+ */
+#define TIME_OK		0	/* clock synchronized, no leap second */
+#define TIME_INS	1	/* insert leap second */
+#define TIME_DEL	2	/* delete leap second */
+#define TIME_OOP	3	/* leap second in progress */
+#define TIME_WAIT	4	/* leap second has occurred */
+#define TIME_ERROR	5	/* clock not synchronized */
+#define TIME_BAD	TIME_ERROR /* bw compat */
+
+#ifdef __KERNEL__
+/*
+ * kernel variables
+ * Note: maximum error = NTP synch distance = dispersion + delay / 2;
+ * estimated error = NTP dispersion.
+ */
+extern unsigned long tick_usec;		/* USER_HZ period (usec) */
+extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
+extern int tickadj;			/* amount of adjustment per tick */
+
+/*
+ * phase-lock loop variables
+ */
+extern int time_state;		/* clock status */
+extern int time_status;		/* clock synchronization status bits */
+extern long time_offset;	/* time adjustment (us) */
+extern long time_constant;	/* pll time constant */
+extern long time_tolerance;	/* frequency tolerance (ppm) */
+extern long time_precision;	/* clock precision (us) */
+extern long time_maxerror;	/* maximum error */
+extern long time_esterror;	/* estimated error */
+
+extern long time_freq;		/* frequency offset (scaled ppm) */
+extern long time_reftime;	/* time at last adjustment (s) */
+
+extern long time_adjust;	/* The amount of adjtime left */
+extern long time_next_adjust;	/* Value for time_adjust at next tick */
+
+/* interface variables pps->timer interrupt */
+extern long pps_offset;		/* pps time offset (us) */
+extern long pps_jitter;		/* time dispersion (jitter) (us) */
+extern long pps_freq;		/* frequency offset (scaled ppm) */
+extern long pps_stabil;		/* frequency dispersion (scaled ppm) */
+extern long pps_valid;		/* pps signal watchdog counter */
+
+/* interface variables pps->adjtimex */
+extern int pps_shift;		/* interval duration (s) (shift) */
+extern long pps_jitcnt;		/* jitter limit exceeded */
+extern long pps_calcnt;		/* calibration intervals */
+extern long pps_errcnt;		/* calibration errors */
+extern long pps_stbcnt;		/* stability limit exceeded */
+
+#ifdef CONFIG_TIME_INTERPOLATION
+
+#define TIME_SOURCE_CPU 0
+#define TIME_SOURCE_MMIO64 1
+#define TIME_SOURCE_MMIO32 2
+#define TIME_SOURCE_FUNCTION 3
+
+/* For proper operations time_interpolator clocks must run slightly slower
+ * than the standard clock since the interpolator may only correct by having
+ * time jump forward during a tick. A slower clock is usually a side effect
+ * of the integer divide of the nanoseconds in a second by the frequency.
+ * The accuracy of the division can be increased by specifying a shift.
+ * However, this may cause the clock not to be slow enough.
+ * The interpolator will self-tune the clock by slowing down if no
+ * resets occur or speeding up if the time jumps per analysis cycle
+ * become too high.
+ *
+ * Setting jitter compensates for a fluctuating timesource by comparing
+ * to the last value read from the timesource to insure that an earlier value
+ * is not returned by a later call. The price to pay
+ * for the compensation is that the timer routines are not as scalable anymore.
+ */
+
+struct time_interpolator {
+	u16 source;			/* time source flags */
+	u8 shift;			/* increases accuracy of multiply by shifting. */
+				/* Note that bits may be lost if shift is set too high */
+	u8 jitter;			/* if set compensate for fluctuations */
+	u32 nsec_per_cyc;		/* set by register_time_interpolator() */
+	void *addr;			/* address of counter or function */
+	u64 mask;			/* mask the valid bits of the counter */
+	unsigned long offset;		/* nsec offset at last update of interpolator */
+	u64 last_counter;		/* counter value in units of the counter at last update */
+	u64 last_cycle;			/* Last timer value if TIME_SOURCE_JITTER is set */
+	u64 frequency;			/* frequency in counts/second */
+	long drift;			/* drift in parts-per-million (or -1) */
+	unsigned long skips;		/* skips forward */
+	unsigned long ns_skipped;	/* nanoseconds skipped */
+	struct time_interpolator *next;
+};
+
+extern void register_time_interpolator(struct time_interpolator *);
+extern void unregister_time_interpolator(struct time_interpolator *);
+extern void time_interpolator_reset(void);
+extern unsigned long time_interpolator_get_offset(void);
+
+#else /* !CONFIG_TIME_INTERPOLATION */
+
+static inline void
+time_interpolator_reset(void)
+{
+}
+
+#endif /* !CONFIG_TIME_INTERPOLATION */
+
+#endif /* KERNEL */
+
+#endif /* LINUX_TIMEX_H */
