commit 9ff7258575d5fee011649d20cc56de720a395191
Merge: 051c3556e3d6 9d78edeaec75
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 4 13:54:34 2020 -0700

    Merge branch 'proc-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull proc updates from Eric Biederman:
     "This has four sets of changes:
    
       - modernize proc to support multiple private instances
    
       - ensure we see the exit of each process tid exactly
    
       - remove has_group_leader_pid
    
       - use pids not tasks in posix-cpu-timers lookup
    
      Alexey updated proc so each mount of proc uses a new superblock. This
      allows people to actually use mount options with proc with no fear of
      messing up another mount of proc. Given the kernel's internal mounts
      of proc for things like uml this was a real problem, and resulted in
      Android's hidepid mount options being ignored and introducing security
      issues.
    
      The rest of the changes are small cleanups and fixes that came out of
      my work to allow this change to proc. In essence it is swapping the
      pids in de_thread during exec which removes a special case the code
      had to handle. Then updating the code to stop handling that special
      case"
    
    * 'proc-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      proc: proc_pid_ns takes super_block as an argument
      remove the no longer needed pid_alive() check in __task_pid_nr_ns()
      posix-cpu-timers: Replace __get_task_for_clock with pid_for_clock
      posix-cpu-timers: Replace cpu_timer_pid_type with clock_pid_type
      posix-cpu-timers: Extend rcu_read_lock removing task_struct references
      signal: Remove has_group_leader_pid
      exec: Remove BUG_ON(has_group_leader_pid)
      posix-cpu-timer:  Unify the now redundant code in lookup_task
      posix-cpu-timer: Tidy up group_leader logic in lookup_task
      proc: Ensure we see the exit of each process tid exactly once
      rculist: Add hlists_swap_heads_rcu
      proc: Use PIDTYPE_TGID in next_tgid
      Use proc_pid_ns() to get pid_namespace from the proc superblock
      proc: use named enums for better readability
      proc: use human-readable values for hidepid
      docs: proc: add documentation for "hidepid=4" and "subset=pid" options and new mount behavior
      proc: add option to mount only a pids subset
      proc: instantiate only pids that we can ptrace on 'hidepid=4' mount option
      proc: allow to mount many instances of proc in one pid namespace
      proc: rename struct proc_fs_info to proc_fs_opts

commit 6b03d1304a32dc8450c7516000a0fe07bef7c446
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Apr 19 06:35:02 2020 -0500

    proc: Ensure we see the exit of each process tid exactly once
    
    When the thread group leader changes during exec and the old leaders
    thread is reaped proc_flush_pid will flush the dentries for the entire
    process because the leader still has it's original pid.
    
    Fix this by exchanging the pids in an rcu safe manner,
    and wrapping the code to do that up in a helper exchange_tids.
    
    When I removed switch_exec_pids and introduced this behavior
    in d73d65293e3e ("[PATCH] pidhash: kill switch_exec_pids") there
    really was nothing that cared as flushing happened with
    the cached dentry and de_thread flushed both of them on exec.
    
    This lack of fully exchanging pids became a problem a few months later
    when I introduced 48e6484d4902 ("[PATCH] proc: Rewrite the proc dentry
    flush on exit optimization").  Which overlooked the de_thread case
    was no longer swapping pids, and I was looking up proc dentries
    by task->pid.
    
    The current behavior isn't properly a bug as everything in proc will
    continue to work correctly just a little bit less efficiently.  Fix
    this just so there are no little surprise corner cases waiting to bite
    people.
    
    -- Oleg points out this could be an issue in next_tgid in proc where
       has_group_leader_pid is called, and reording some of the assignments
       should fix that.
    
    -- Oleg points out this will break the 10 year old hack in __exit_signal.c
    >       /*
    >        * This can only happen if the caller is de_thread().
    >        * FIXME: this is the temporary hack, we should teach
    >        * posix-cpu-timers to handle this case correctly.
    >        */
    >       if (unlikely(has_group_leader_pid(tsk)))
    >               posix_cpu_timers_exit_group(tsk);
    
    The code in next_tgid has been changed to use PIDTYPE_TGID,
    and the posix cpu timers code has been fixed so it does not
    need the 10 year old hack, so this should be safe to merge
    now.
    
    Link: https://lore.kernel.org/lkml/87h7x3ajll.fsf_-_@x220.int.ebiederm.org/
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Fixes: 48e6484d4902 ("[PATCH] proc: Rewrite the proc dentry flush on exit optimization").
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index cc896f0fc4e3..2159ffca63fc 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -102,6 +102,7 @@ extern void attach_pid(struct task_struct *task, enum pid_type);
 extern void detach_pid(struct task_struct *task, enum pid_type);
 extern void change_pid(struct task_struct *task, enum pid_type,
 			struct pid *pid);
+extern void exchange_tids(struct task_struct *task, struct task_struct *old);
 extern void transfer_pid(struct task_struct *old, struct task_struct *new,
 			 enum pid_type);
 

commit 2374c09b1c8a883bb9b4b2fc3756703eeb618f4a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 24 08:43:36 2020 +0200

    sysctl: remove all extern declaration from sysctl.c
    
    Extern declarations in .c files are a bad style and can lead to
    mismatches.  Use existing definitions in headers where they exist,
    and otherwise move the external declarations to suitable header
    files.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index cc896f0fc4e3..93543cbc0e6b 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -108,6 +108,9 @@ extern void transfer_pid(struct task_struct *old, struct task_struct *new,
 struct pid_namespace;
 extern struct pid_namespace init_pid_ns;
 
+extern int pid_max;
+extern int pid_max_min, pid_max_max;
+
 /*
  * look up a PID in the hash table. Must be called with the tasklist_lock
  * or rcu_read_lock() held.

commit 63f818f46af9f8b3f17b9695501e8d08959feb60
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Apr 7 09:43:04 2020 -0500

    proc: Use a dedicated lock in struct pid
    
    syzbot wrote:
    > ========================================================
    > WARNING: possible irq lock inversion dependency detected
    > 5.6.0-syzkaller #0 Not tainted
    > --------------------------------------------------------
    > swapper/1/0 just changed the state of lock:
    > ffffffff898090d8 (tasklist_lock){.+.?}-{2:2}, at: send_sigurg+0x9f/0x320 fs/fcntl.c:840
    > but this lock took another, SOFTIRQ-unsafe lock in the past:
    >  (&pid->wait_pidfd){+.+.}-{2:2}
    >
    >
    > and interrupts could create inverse lock ordering between them.
    >
    >
    > other info that might help us debug this:
    >  Possible interrupt unsafe locking scenario:
    >
    >        CPU0                    CPU1
    >        ----                    ----
    >   lock(&pid->wait_pidfd);
    >                                local_irq_disable();
    >                                lock(tasklist_lock);
    >                                lock(&pid->wait_pidfd);
    >   <Interrupt>
    >     lock(tasklist_lock);
    >
    >  *** DEADLOCK ***
    >
    > 4 locks held by swapper/1/0:
    
    The problem is that because wait_pidfd.lock is taken under the tasklist
    lock.  It must always be taken with irqs disabled as tasklist_lock can be
    taken from interrupt context and if wait_pidfd.lock was already taken this
    would create a lock order inversion.
    
    Oleg suggested just disabling irqs where I have added extra calls to
    wait_pidfd.lock.  That should be safe and I think the code will eventually
    do that.  It was rightly pointed out by Christian that sharing the
    wait_pidfd.lock was a premature optimization.
    
    It is also true that my pre-merge window testing was insufficient.  So
    remove the premature optimization and give struct pid a dedicated lock of
    it's own for struct pid things.  I have verified that lockdep sees all 3
    paths where we take the new pid->lock and lockdep does not complain.
    
    It is my current day dream that one day pid->lock can be used to guard the
    task lists as well and then the tasklist_lock won't need to be held to
    deliver signals.  That will require taking pid->lock with irqs disabled.
    
    Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/lkml/00000000000011d66805a25cd73f@google.com/
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Reported-by: syzbot+343f75cdeea091340956@syzkaller.appspotmail.com
    Reported-by: syzbot+832aabf700bc3ec920b9@syzkaller.appspotmail.com
    Reported-by: syzbot+f675f964019f884dbd0f@syzkaller.appspotmail.com
    Reported-by: syzbot+a9fb1457d720a55d6dc5@syzkaller.appspotmail.com
    Fixes: 7bc3e6e55acf ("proc: Use a list of inodes to flush from proc")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 01a0d4e28506..cc896f0fc4e3 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -60,6 +60,7 @@ struct pid
 {
 	refcount_t count;
 	unsigned int level;
+	spinlock_t lock;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct hlist_head inodes;

commit 7bc3e6e55acf065500a24621f3b313e7e5998acf
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 19 18:22:26 2020 -0600

    proc: Use a list of inodes to flush from proc
    
    Rework the flushing of proc to use a list of directory inodes that
    need to be flushed.
    
    The list is kept on struct pid not on struct task_struct, as there is
    a fixed connection between proc inodes and pids but at least for the
    case of de_thread the pid of a task_struct changes.
    
    This removes the dependency on proc_mnt which allows for different
    mounts of proc having different mount options even in the same pid
    namespace and this allows for the removal of proc_mnt which will
    trivially the first mount of proc to honor it's mount options.
    
    This flushing remains an optimization.  The functions
    pid_delete_dentry and pid_revalidate ensure that ordinary dcache
    management will not attempt to use dentries past the point their
    respective task has died.  When unused the shrinker will
    eventually be able to remove these dentries.
    
    There is a case in de_thread where proc_flush_pid can be
    called early for a given pid.  Which winds up being
    safe (if suboptimal) as this is just an optiimization.
    
    Only pid directories are put on the list as the other
    per pid files are children of those directories and
    d_invalidate on the directory will get them as well.
    
    So that the pid can be used during flushing it's reference count is
    taken in release_task and dropped in proc_flush_pid.  Further the call
    of proc_flush_pid is moved after the tasklist_lock is released in
    release_task so that it is certain that the pid has already been
    unhashed when flushing it taking place.  This removes a small race
    where a dentry could recreated.
    
    As struct pid is supposed to be small and I need a per pid lock
    I reuse the only lock that currently exists in struct pid the
    the wait_pidfd.lock.
    
    The net result is that this adds all of this functionality
    with just a little extra list management overhead and
    a single extra pointer in struct pid.
    
    v2: Initialize pid->inodes.  I somehow failed to get that
        initialization into the initial version of the patch.  A boot
        failure was reported by "kernel test robot <lkp@intel.com>", and
        failure to initialize that pid->inodes matches all of the reported
        symptoms.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 998ae7d24450..01a0d4e28506 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -62,6 +62,7 @@ struct pid
 	unsigned int level;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
+	struct hlist_head inodes;
 	/* wait queue for pidfd notifications */
 	wait_queue_head_t wait_pidfd;
 	struct rcu_head rcu;

commit 49cb2fc42ce4b7a656ee605e30c302efaa39c1a7
Author: Adrian Reber <areber@redhat.com>
Date:   Fri Nov 15 13:36:20 2019 +0100

    fork: extend clone3() to support setting a PID
    
    The main motivation to add set_tid to clone3() is CRIU.
    
    To restore a process with the same PID/TID CRIU currently uses
    /proc/sys/kernel/ns_last_pid. It writes the desired (PID - 1) to
    ns_last_pid and then (quickly) does a clone(). This works most of the
    time, but it is racy. It is also slow as it requires multiple syscalls.
    
    Extending clone3() to support *set_tid makes it possible restore a
    process using CRIU without accessing /proc/sys/kernel/ns_last_pid and
    race free (as long as the desired PID/TID is available).
    
    This clone3() extension places the same restrictions (CAP_SYS_ADMIN)
    on clone3() with *set_tid as they are currently in place for ns_last_pid.
    
    The original version of this change was using a single value for
    set_tid. At the 2019 LPC, after presenting set_tid, it was, however,
    decided to change set_tid to an array to enable setting the PID of a
    process in multiple PID namespaces at the same time. If a process is
    created in a PID namespace it is possible to influence the PID inside
    and outside of the PID namespace. Details also in the corresponding
    selftest.
    
    To create a process with the following PIDs:
    
          PID NS level         Requested PID
            0 (host)              31496
            1                        42
            2                         1
    
    For that example the two newly introduced parameters to struct
    clone_args (set_tid and set_tid_size) would need to be:
    
      set_tid[0] = 1;
      set_tid[1] = 42;
      set_tid[2] = 31496;
      set_tid_size = 3;
    
    If only the PIDs of the two innermost nested PID namespaces should be
    defined it would look like this:
    
      set_tid[0] = 1;
      set_tid[1] = 42;
      set_tid_size = 2;
    
    The PID of the newly created process would then be the next available
    free PID in the PID namespace level 0 (host) and 42 in the PID namespace
    at level 1 and the PID of the process in the innermost PID namespace
    would be 1.
    
    The set_tid array is used to specify the PID of a process starting
    from the innermost nested PID namespaces up to set_tid_size PID namespaces.
    
    set_tid_size cannot be larger then the current PID namespace level.
    
    Signed-off-by: Adrian Reber <areber@redhat.com>
    Reviewed-by: Christian Brauner <christian.brauner@ubuntu.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Dmitry Safonov <0x7f454c46@gmail.com>
    Acked-by: Andrei Vagin <avagin@gmail.com>
    Link: https://lore.kernel.org/r/20191115123621.142252-1-areber@redhat.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 034e3cd60dc0..998ae7d24450 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -124,7 +124,8 @@ extern struct pid *find_vpid(int nr);
 extern struct pid *find_get_pid(int nr);
 extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
 
-extern struct pid *alloc_pid(struct pid_namespace *ns);
+extern struct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,
+			     size_t set_tid_size);
 extern void free_pid(struct pid *pid);
 extern void disable_pid_allocation(struct pid_namespace *ns);
 

commit 3d6d8da48d0b214d65ea0227d47228abc75d7c88
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Oct 17 12:18:28 2019 +0200

    pidfd: check pid has attached task in fdinfo
    
    Currently, when a task is dead we still print the pid it used to use in
    the fdinfo files of its pidfds. This doesn't make much sense since the
    pid may have already been reused. So verify that the task is still alive
    by introducing the pid_has_task() helper which will be used by other
    callers in follow-up patches.
    If the task is not alive anymore, we will print -1. This allows us to
    differentiate between a task not being present in a given pid namespace
    - in which case we already print 0 - and a task having been reaped.
    
    Note that this uses PIDTYPE_PID for the check. Technically, we could've
    checked PIDTYPE_TGID since pidfds currently only refer to thread-group
    leaders but if they won't anymore in the future then this check becomes
    problematic without it being immediately obvious to non-experts imho. If
    a thread is created via clone(CLONE_THREAD) than struct pid has a single
    non-empty list pid->tasks[PIDTYPE_PID] and this pid can't be used as a
    PIDTYPE_TGID meaning pid->tasks[PIDTYPE_TGID] will return NULL even
    though the thread-group leader might still be very much alive. So
    checking PIDTYPE_PID is fine and is easier to maintain should we ever
    allow pidfds to refer to threads.
    
    Cc: Jann Horn <jannh@google.com>
    Cc: Christian Kellner <christian@kellner.me>
    Cc: linux-api@vger.kernel.org
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Link: https://lore.kernel.org/r/20191017101832.5985-1-christian.brauner@ubuntu.com

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 9645b1194c98..034e3cd60dc0 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -85,6 +85,10 @@ static inline struct pid *get_pid(struct pid *pid)
 
 extern void put_pid(struct pid *pid);
 extern struct task_struct *pid_task(struct pid *pid, enum pid_type);
+static inline bool pid_has_task(struct pid *pid, enum pid_type type)
+{
+	return !hlist_empty(&pid->tasks[type]);
+}
 extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);
 
 extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);

commit 3695eae5fee0605f316fbaad0b9e3de791d7dfaf
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Sun Jul 28 00:22:29 2019 +0200

    pidfd: add P_PIDFD to waitid()
    
    This adds the P_PIDFD type to waitid().
    One of the last remaining bits for the pidfd api is to make it possible
    to wait on pidfds. With P_PIDFD added to waitid() the parts of userspace
    that want to use the pidfd api to exclusively manage processes can do so
    now.
    
    One of the things this will unblock in the future is the ability to make
    it possible to retrieve the exit status via waitid(P_PIDFD) for
    non-parent processes if handed a _suitable_ pidfd that has this feature
    set. This is similar to what you can do on FreeBSD with kqueue(). It
    might even end up being possible to wait on a process as a non-parent if
    an appropriate property is enabled on the pidfd.
    
    With P_PIDFD no scoping of the process identified by the pidfd is
    possible, i.e. it explicitly blocks things such as wait4(-1), wait4(0),
    waitid(P_ALL), waitid(P_PGID) etc. It only allows for semantics
    equivalent to wait4(pid), waitid(P_PID). Users that need scoping should
    rely on pid-based wait*() syscalls for now.
    
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Joel Fernandes (Google) <joel@joelfernandes.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jann Horn <jannh@google.com>
    Cc: Andy Lutomirsky <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Aleksa Sarai <cyphar@cyphar.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Link: https://lore.kernel.org/r/20190727222229.6516-2-christian@brauner.io

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 2a83e434db9d..9645b1194c98 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -72,6 +72,10 @@ extern struct pid init_struct_pid;
 
 extern const struct file_operations pidfd_fops;
 
+struct file;
+
+extern struct pid *pidfd_pid(const struct file *file);
+
 static inline struct pid *get_pid(struct pid *pid)
 {
 	if (pid)

commit f57e515a1b56325a28a0972c632a623a9c84590c
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Tue Jul 16 16:30:06 2019 -0700

    kernel/pid.c: convert struct pid count to refcount_t
    
    struct pid's count is an atomic_t field used as a refcount.  Use
    refcount_t for it which is basically atomic_t but does additional
    checking to prevent use-after-free bugs.
    
    For memory ordering, the only change is with the following:
    
     -      if ((atomic_read(&pid->count) == 1) ||
     -           atomic_dec_and_test(&pid->count)) {
     +      if (refcount_dec_and_test(&pid->count)) {
                    kmem_cache_free(ns->pid_cachep, pid);
    
    Here the change is from: Fully ordered --> RELEASE + ACQUIRE (as per
    refcount-vs-atomic.rst) This ACQUIRE should take care of making sure the
    free happens after the refcount_dec_and_test().
    
    The above hunk also removes atomic_read() since it is not needed for the
    code to work and it is unclear how beneficial it is.  The removal lets
    refcount_dec_and_test() check for cases where get_pid() happened before
    the object was freed.
    
    Link: http://lkml.kernel.org/r/20190701183826.191936-1-joel@joelfernandes.org
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Reviewed-by: Andrea Parri <andrea.parri@amarulasolutions.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Elena Reshetova <elena.reshetova@intel.com>
    Cc: Jann Horn <jannh@google.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: KJ Tsanaktsidis <ktsanaktsidis@zendesk.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 1484db6ca8d1..2a83e434db9d 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -4,6 +4,7 @@
 
 #include <linux/rculist.h>
 #include <linux/wait.h>
+#include <linux/refcount.h>
 
 enum pid_type
 {
@@ -57,7 +58,7 @@ struct upid {
 
 struct pid
 {
-	atomic_t count;
+	refcount_t count;
 	unsigned int level;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
@@ -74,7 +75,7 @@ extern const struct file_operations pidfd_fops;
 static inline struct pid *get_pid(struct pid *pid)
 {
 	if (pid)
-		atomic_inc(&pid->count);
+		refcount_inc(&pid->count);
 	return pid;
 }
 

commit b53b0b9d9a613c418057f6cb921c2f40a6f78c24
Author: Joel Fernandes (Google) <joel@joelfernandes.org>
Date:   Tue Apr 30 12:21:53 2019 -0400

    pidfd: add polling support
    
    This patch adds polling support to pidfd.
    
    Android low memory killer (LMK) needs to know when a process dies once
    it is sent the kill signal. It does so by checking for the existence of
    /proc/pid which is both racy and slow. For example, if a PID is reused
    between when LMK sends a kill signal and checks for existence of the
    PID, since the wrong PID is now possibly checked for existence.
    Using the polling support, LMK will be able to get notified when a process
    exists in race-free and fast way, and allows the LMK to do other things
    (such as by polling on other fds) while awaiting the process being killed
    to die.
    
    For notification to polling processes, we follow the same existing
    mechanism in the kernel used when the parent of the task group is to be
    notified of a child's death (do_notify_parent). This is precisely when the
    tasks waiting on a poll of pidfd are also awakened in this patch.
    
    We have decided to include the waitqueue in struct pid for the following
    reasons:
    1. The wait queue has to survive for the lifetime of the poll. Including
       it in task_struct would not be option in this case because the task can
       be reaped and destroyed before the poll returns.
    
    2. By including the struct pid for the waitqueue means that during
       de_thread(), the new thread group leader automatically gets the new
       waitqueue/pid even though its task_struct is different.
    
    Appropriate test cases are added in the second patch to provide coverage of
    all the cases the patch is handling.
    
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Daniel Colascione <dancol@google.com>
    Cc: Jann Horn <jannh@google.com>
    Cc: Tim Murray <timmurray@google.com>
    Cc: Jonathan Kowalski <bl0pbl33p@gmail.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: kernel-team@android.com
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Co-developed-by: Daniel Colascione <dancol@google.com>
    Signed-off-by: Daniel Colascione <dancol@google.com>
    Signed-off-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Signed-off-by: Christian Brauner <christian@brauner.io>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 3c8ef5a199ca..1484db6ca8d1 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -3,6 +3,7 @@
 #define _LINUX_PID_H
 
 #include <linux/rculist.h>
+#include <linux/wait.h>
 
 enum pid_type
 {
@@ -60,6 +61,8 @@ struct pid
 	unsigned int level;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
+	/* wait queue for pidfd notifications */
+	wait_queue_head_t wait_pidfd;
 	struct rcu_head rcu;
 	struct upid numbers[1];
 };

commit b3e5838252665ee4cfa76b82bdf1198dca81e5be
Author: Christian Brauner <christian@brauner.io>
Date:   Wed Mar 27 13:04:15 2019 +0100

    clone: add CLONE_PIDFD
    
    This patchset makes it possible to retrieve pid file descriptors at
    process creation time by introducing the new flag CLONE_PIDFD to the
    clone() system call.  Linus originally suggested to implement this as a
    new flag to clone() instead of making it a separate system call.  As
    spotted by Linus, there is exactly one bit for clone() left.
    
    CLONE_PIDFD creates file descriptors based on the anonymous inode
    implementation in the kernel that will also be used to implement the new
    mount api.  They serve as a simple opaque handle on pids.  Logically,
    this makes it possible to interpret a pidfd differently, narrowing or
    widening the scope of various operations (e.g. signal sending).  Thus, a
    pidfd cannot just refer to a tgid, but also a tid, or in theory - given
    appropriate flag arguments in relevant syscalls - a process group or
    session. A pidfd does not represent a privilege.  This does not imply it
    cannot ever be that way but for now this is not the case.
    
    A pidfd comes with additional information in fdinfo if the kernel supports
    procfs.  The fdinfo file contains the pid of the process in the callers
    pid namespace in the same format as the procfs status file, i.e. "Pid:\t%d".
    
    As suggested by Oleg, with CLONE_PIDFD the pidfd is returned in the
    parent_tidptr argument of clone.  This has the advantage that we can
    give back the associated pid and the pidfd at the same time.
    
    To remove worries about missing metadata access this patchset comes with
    a sample program that illustrates how a combination of CLONE_PIDFD, and
    pidfd_send_signal() can be used to gain race-free access to process
    metadata through /proc/<pid>.  The sample program can easily be
    translated into a helper that would be suitable for inclusion in libc so
    that users don't have to worry about writing it themselves.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Christian Brauner <christian@brauner.io>
    Co-developed-by: Jann Horn <jannh@google.com>
    Signed-off-by: Jann Horn <jannh@google.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Michael Kerrisk (man-pages)" <mtk.manpages@gmail.com>
    Cc: Andy Lutomirsky <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Aleksa Sarai <cyphar@cyphar.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index b6f4ba16065a..3c8ef5a199ca 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -66,6 +66,8 @@ struct pid
 
 extern struct pid init_struct_pid;
 
+extern const struct file_operations pidfd_fops;
+
 static inline struct pid *get_pid(struct pid *pid)
 {
 	if (pid)

commit 3c82066e6a920b30de84fce00fb7fd701bf23f09
Author: Nadav Amit <namit@vmware.com>
Date:   Thu Mar 7 16:27:18 2019 -0800

    include/linux/pid.h: remove next_pidmap() declaration
    
    Commit 95846ecf9dac ("pid: replace pid bitmap implementation with IDR
    API") removed next_pidmap() but left its declaration.
    
    Remove it.  No functional change.
    
    Link: http://lkml.kernel.org/r/20190213113736.21922-1-namit@vmware.com
    Signed-off-by: Nadav Amit <namit@vmware.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Gargi Sharma <gs051095@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 14a9a39da9c7..b6f4ba16065a 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -109,7 +109,6 @@ extern struct pid *find_vpid(int nr);
  */
 extern struct pid *find_get_pid(int nr);
 extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
-int next_pidmap(struct pid_namespace *pid_ns, unsigned int last);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void free_pid(struct pid *pid);

commit 6883f81aac6f44e7df70a6af189b3689ff52cbfb
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Jun 4 04:32:13 2017 -0500

    pid: Implement PIDTYPE_TGID
    
    Everywhere except in the pid array we distinguish between a tasks pid and
    a tasks tgid (thread group id).  Even in the enumeration we want that
    distinction sometimes so we have added __PIDTYPE_TGID.  With leader_pid
    we almost have an implementation of PIDTYPE_TGID in struct signal_struct.
    
    Add PIDTYPE_TGID as a first class member of the pid_type enumeration and
    into the pids array.  Then remove the __PIDTYPE_TGID special case and the
    leader_pid in signal_struct.
    
    The net size increase is just an extra pointer added to struct pid and
    an extra pair of pointers of an hlist_node added to task_struct.
    
    The effect on code maintenance is the removal of a number of special
    cases today and the potential to remove many more special cases as
    PIDTYPE_TGID gets used to it's fullest.  The long term potential
    is allowing zombie thread group leaders to exit, which will remove
    a lot more special cases in the code.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 3d4c504dcc8c..14a9a39da9c7 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -7,11 +7,10 @@
 enum pid_type
 {
 	PIDTYPE_PID,
+	PIDTYPE_TGID,
 	PIDTYPE_PGID,
 	PIDTYPE_SID,
 	PIDTYPE_MAX,
-	/* only valid to __task_pid_nr_ns() */
-	__PIDTYPE_TGID
 };
 
 /*

commit 2c4704756cab7cfa031ada4dab361562f0e357c0
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 26 13:06:43 2017 -0500

    pids: Move the pgrp and session pid pointers from task_struct to signal_struct
    
    To access these fields the code always has to go to group leader so
    going to signal struct is no loss and is actually a fundamental simplification.
    
    This saves a little bit of memory by only allocating the pid pointer array
    once instead of once for every thread, and even better this removes a
    few potential races caused by the fact that group_leader can be changed
    by de_thread, while signal_struct can not.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 7633d55d9a24..3d4c504dcc8c 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -67,12 +67,6 @@ struct pid
 
 extern struct pid init_struct_pid;
 
-struct pid_link
-{
-	struct hlist_node node;
-	struct pid *pid;
-};
-
 static inline struct pid *get_pid(struct pid *pid)
 {
 	if (pid)
@@ -177,7 +171,7 @@ pid_t pid_vnr(struct pid *pid);
 	do {								\
 		if ((pid) != NULL)					\
 			hlist_for_each_entry_rcu((task),		\
-				&(pid)->tasks[type], pids[type].node) {
+				&(pid)->tasks[type], pid_links[type]) {
 
 			/*
 			 * Both old and new leaders may be attached to

commit e8cfbc245e24887e3c30235f71e9e9405e0cfc39
Author: Gargi Sharma <gs051095@gmail.com>
Date:   Fri Nov 17 15:30:34 2017 -0800

    pid: remove pidhash
    
    pidhash is no longer required as all the information can be looked up
    from idr tree.  nr_hashed represented the number of pids that had been
    hashed.  Since, nr_hashed and PIDNS_HASH_ADDING are no longer relevant,
    it has been renamed to pid_allocated and PIDNS_ADDING respectively.
    
    [gs051095@gmail.com: v6]
      Link: http://lkml.kernel.org/r/1507760379-21662-3-git-send-email-gs051095@gmail.com
    Link: http://lkml.kernel.org/r/1507583624-22146-3-git-send-email-gs051095@gmail.com
    Signed-off-by: Gargi Sharma <gs051095@gmail.com>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Tested-by: Tony Luck <tony.luck@intel.com>      [ia64]
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Pavel Tatashin <pasha.tatashin@oracle.com>
    Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index dfd684ce0787..7633d55d9a24 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -51,10 +51,8 @@ enum pid_type
  */
 
 struct upid {
-	/* Try to keep pid_chain in the same cacheline as nr for find_vpid */
 	int nr;
 	struct pid_namespace *ns;
-	struct hlist_node pid_chain;
 };
 
 struct pid

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 719582744a2e..dfd684ce0787 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_PID_H
 #define _LINUX_PID_H
 

commit dd1c1f2f2028a7b851f701fc6a8ebe39dcb95e7c
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Aug 21 17:35:02 2017 +0200

    pids: make task_tgid_nr_ns() safe
    
    This was reported many times, and this was even mentioned in commit
    52ee2dfdd4f5 ("pids: refactor vnr/nr_ns helpers to make them safe") but
    somehow nobody bothered to fix the obvious problem: task_tgid_nr_ns() is
    not safe because task->group_leader points to nowhere after the exiting
    task passes exit_notify(), rcu_read_lock() can not help.
    
    We really need to change __unhash_process() to nullify group_leader,
    parent, and real_parent, but this needs some cleanups.  Until then we
    can turn task_tgid_nr_ns() into another user of __task_pid_nr_ns() and
    fix the problem.
    
    Reported-by: Troy Kensinger <tkensinger@google.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 4d179316e431..719582744a2e 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -8,7 +8,9 @@ enum pid_type
 	PIDTYPE_PID,
 	PIDTYPE_PGID,
 	PIDTYPE_SID,
-	PIDTYPE_MAX
+	PIDTYPE_MAX,
+	/* only valid to __task_pid_nr_ns() */
+	__PIDTYPE_TGID
 };
 
 /*

commit b2d091031075ac9a1598e3cc3a29c28f02e64c0d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Feb 4 01:27:20 2017 +0100

    sched/headers: Prepare to use <linux/rcuupdate.h> instead of <linux/rculist.h> in <linux/sched.h>
    
    We don't actually need the full rculist.h header in sched.h anymore,
    we will be able to include the smaller rcupdate.h header instead.
    
    But first update code that relied on the implicit header inclusion.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 298ead5512e5..4d179316e431 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_PID_H
 #define _LINUX_PID_H
 
-#include <linux/rcupdate.h>
+#include <linux/rculist.h>
 
 enum pid_type
 {

commit e3b5a342ab9643b4079c8d417d90519388469341
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Mon Feb 27 14:27:37 2017 -0800

    include/linux/pid.h: use for_each_thread() in do_each_pid_thread()
    
    while_each_pid_thread() is using while_each_thread(), which is unsafe
    under RCU lock according to commit 0c740d0afc3b ("introduce
    for_each_thread() to replace the buggy while_each_thread()").  Use
    for_each_thread() in do_each_pid_thread() which is safe under RCU lock.
    
    Link: http://lkml.kernel.org/r/201702011947.DBD56740.OMVHOLOtSJFFFQ@I-love.SAKURA.ne.jp
    Link: http://lkml.kernel.org/r/1486041779-4401-2-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 23705a53abba..298ead5512e5 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -191,10 +191,10 @@ pid_t pid_vnr(struct pid *pid);
 #define do_each_pid_thread(pid, type, task)				\
 	do_each_pid_task(pid, type, task) {				\
 		struct task_struct *tg___ = task;			\
-		do {
+		for_each_thread(tg___, task) {
 
 #define while_each_pid_thread(pid, type, task)				\
-		} while_each_thread(tg___, task);			\
+		}							\
 		task = tg___;						\
 	} while_each_pid_task(pid, type, task)
 #endif /* _LINUX_PID_H */

commit 8190773985141f063e1d6dc10200527c655abfb5
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Jul 3 15:08:31 2013 -0700

    kernel/fork.c:copy_process(): don't add the uninitialized child to thread/task/pid lists
    
    copy_process() adds the new child to thread_group/init_task.tasks list and
    then does attach_pid(child, PIDTYPE_PID).  This means that the lockless
    next_thread() or next_task() can see this thread with the wrong pid.  Say,
    "ls /proc/pid/task" can list the same inode twice.
    
    We could move attach_pid(child, PIDTYPE_PID) up, but in this case
    find_task_by_vpid() can find the new thread before it was fully
    initialized.
    
    And this is already true for PIDTYPE_PGID/PIDTYPE_SID, With this patch
    copy_process() initializes child->pids[*].pid first, then calls
    attach_pid() to insert the task into the pid->tasks list.
    
    attach_pid() no longer need the "struct pid*" argument, it is always
    called after pid_link->pid was already set.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Sergey Dyasly <dserrg@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index a089a3c447fc..23705a53abba 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -86,11 +86,9 @@ extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);
 extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
 
 /*
- * attach_pid() and detach_pid() must be called with the tasklist_lock
- * write-held.
+ * these helpers must be called with the tasklist_lock write-held.
  */
-extern void attach_pid(struct task_struct *task, enum pid_type type,
-			struct pid *pid);
+extern void attach_pid(struct task_struct *task, enum pid_type);
 extern void detach_pid(struct task_struct *task, enum pid_type);
 extern void change_pid(struct task_struct *task, enum pid_type,
 			struct pid *pid);

commit b67bfe0d42cac56c512dd5da4b1b347a23f4b70a
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Feb 27 17:06:00 2013 -0800

    hlist: drop the node parameter from iterators
    
    I'm not sure why, but the hlist for each entry iterators were conceived
    
            list_for_each_entry(pos, head, member)
    
    The hlist ones were greedy and wanted an extra parameter:
    
            hlist_for_each_entry(tpos, pos, head, member)
    
    Why did they need an extra pos parameter? I'm not quite sure. Not only
    they don't really need it, it also prevents the iterator from looking
    exactly like the list iterator, which is unfortunate.
    
    Besides the semantic patch, there was some manual work required:
    
     - Fix up the actual hlist iterators in linux/list.h
     - Fix up the declaration of other iterators based on the hlist ones.
     - A very small amount of places were using the 'node' parameter, this
     was modified to use 'obj->member' instead.
     - Coccinelle didn't handle the hlist_for_each_entry_safe iterator
     properly, so those had to be fixed up manually.
    
    The semantic patch which is mostly the work of Peter Senna Tschudin is here:
    
    @@
    iterator name hlist_for_each_entry, hlist_for_each_entry_continue, hlist_for_each_entry_from, hlist_for_each_entry_rcu, hlist_for_each_entry_rcu_bh, hlist_for_each_entry_continue_rcu_bh, for_each_busy_worker, ax25_uid_for_each, ax25_for_each, inet_bind_bucket_for_each, sctp_for_each_hentry, sk_for_each, sk_for_each_rcu, sk_for_each_from, sk_for_each_safe, sk_for_each_bound, hlist_for_each_entry_safe, hlist_for_each_entry_continue_rcu, nr_neigh_for_each, nr_neigh_for_each_safe, nr_node_for_each, nr_node_for_each_safe, for_each_gfn_indirect_valid_sp, for_each_gfn_sp, for_each_host;
    
    type T;
    expression a,c,d,e;
    identifier b;
    statement S;
    @@
    
    -T b;
        <+... when != b
    (
    hlist_for_each_entry(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue(a,
    - b,
    c) S
    |
    hlist_for_each_entry_from(a,
    - b,
    c) S
    |
    hlist_for_each_entry_rcu(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_rcu_bh(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue_rcu_bh(a,
    - b,
    c) S
    |
    for_each_busy_worker(a, c,
    - b,
    d) S
    |
    ax25_uid_for_each(a,
    - b,
    c) S
    |
    ax25_for_each(a,
    - b,
    c) S
    |
    inet_bind_bucket_for_each(a,
    - b,
    c) S
    |
    sctp_for_each_hentry(a,
    - b,
    c) S
    |
    sk_for_each(a,
    - b,
    c) S
    |
    sk_for_each_rcu(a,
    - b,
    c) S
    |
    sk_for_each_from
    -(a, b)
    +(a)
    S
    + sk_for_each_from(a) S
    |
    sk_for_each_safe(a,
    - b,
    c, d) S
    |
    sk_for_each_bound(a,
    - b,
    c) S
    |
    hlist_for_each_entry_safe(a,
    - b,
    c, d, e) S
    |
    hlist_for_each_entry_continue_rcu(a,
    - b,
    c) S
    |
    nr_neigh_for_each(a,
    - b,
    c) S
    |
    nr_neigh_for_each_safe(a,
    - b,
    c, d) S
    |
    nr_node_for_each(a,
    - b,
    c) S
    |
    nr_node_for_each_safe(a,
    - b,
    c, d) S
    |
    - for_each_gfn_sp(a, c, d, b) S
    + for_each_gfn_sp(a, c, d) S
    |
    - for_each_gfn_indirect_valid_sp(a, c, d, b) S
    + for_each_gfn_indirect_valid_sp(a, c, d) S
    |
    for_each_host(a,
    - b,
    c) S
    |
    for_each_host_safe(a,
    - b,
    c, d) S
    |
    for_each_mesh_entry(a,
    - b,
    c, d) S
    )
        ...+>
    
    [akpm@linux-foundation.org: drop bogus change from net/ipv4/raw.c]
    [akpm@linux-foundation.org: drop bogus hunk from net/ipv6/raw.c]
    [akpm@linux-foundation.org: checkpatch fixes]
    [akpm@linux-foundation.org: fix warnings]
    [akpm@linux-foudnation.org: redo intrusive kvm changes]
    Tested-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 2381c973d897..a089a3c447fc 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -176,9 +176,8 @@ pid_t pid_vnr(struct pid *pid);
 
 #define do_each_pid_task(pid, type, task)				\
 	do {								\
-		struct hlist_node *pos___;				\
 		if ((pid) != NULL)					\
-			hlist_for_each_entry_rcu((task), pos___,	\
+			hlist_for_each_entry_rcu((task),		\
 				&(pid)->tasks[type], pids[type].node) {
 
 			/*

commit c876ad7682155958d0c9c27afe9017925c230d64
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 21 20:27:12 2012 -0800

    pidns: Stop pid allocation when init dies
    
    Oleg pointed out that in a pid namespace the sequence.
    - pid 1 becomes a zombie
    - setns(thepidns), fork,...
    - reaping pid 1.
    - The injected processes exiting.
    
    Can lead to processes attempting access their child reaper and
    instead following a stale pointer.
    
    That waitpid for init can return before all of the processes in
    the pid namespace have exited is also unfortunate.
    
    Avoid these problems by disabling the allocation of new pids in a pid
    namespace when init dies, instead of when the last process in a pid
    namespace is reaped.
    
    Pointed-out-by:  Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index b152d44fb181..2381c973d897 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -121,6 +121,7 @@ int next_pidmap(struct pid_namespace *pid_ns, unsigned int last);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void free_pid(struct pid *pid);
+extern void disable_pid_allocation(struct pid_namespace *ns);
 
 /*
  * ns_of_pid() returns the pid namespace in which the specified pid was

commit 26498e89e83c62cffcb8836a2ac2c5b795d84258
Author: Sisir Koppaka <sisir.koppaka@gmail.com>
Date:   Thu May 26 16:25:57 2011 -0700

    pid: fix typo in function description
    
    finds is misspelt as finr. No functional change.
    
    Signed-off-by: Sisir Koppaka <sisir.koppaka@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index cdced84261d7..b152d44fb181 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -105,7 +105,7 @@ extern struct pid_namespace init_pid_ns;
  * or rcu_read_lock() held.
  *
  * find_pid_ns() finds the pid in the namespace specified
- * find_vpid() finr the pid by its virtual id, i.e. in the current namespace
+ * find_vpid() finds the pid by its virtual id, i.e. in the current namespace
  *
  * see also find_task_by_vpid() set in include/linux/sched.h
  */

commit c78193e9c7bcbf25b8237ad0dec82f805c4ea69b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 18 10:35:30 2011 -0700

    next_pidmap: fix overflow condition
    
    next_pidmap() just quietly accepted whatever 'last' pid that was passed
    in, which is not all that safe when one of the users is /proc.
    
    Admittedly the proc code should do some sanity checking on the range
    (and that will be the next commit), but that doesn't mean that the
    helper functions should just do that pidmap pointer arithmetic without
    checking the range of its arguments.
    
    So clamp 'last' to PID_MAX_LIMIT.  The fact that we then do "last+1"
    doesn't really matter, the for-loop does check against the end of the
    pidmap array properly (it's only the actual pointer arithmetic overflow
    case we need to worry about, and going one bit beyond isn't going to
    overflow).
    
    [ Use PID_MAX_LIMIT rather than pid_max as per Eric Biederman ]
    
    Reported-by: Tavis Ormandy <taviso@cmpxchg8b.com>
    Analyzed-by: Robert wicki <robert@swiecki.net>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 31afb7ecbe1f..cdced84261d7 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -117,7 +117,7 @@ extern struct pid *find_vpid(int nr);
  */
 extern struct pid *find_get_pid(int nr);
 extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
-int next_pidmap(struct pid_namespace *pid_ns, int last);
+int next_pidmap(struct pid_namespace *pid_ns, unsigned int last);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void free_pid(struct pid *pid);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index efceda0a51b1..31afb7ecbe1f 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -21,7 +21,7 @@ enum pid_type
  * quickly from the numeric pid value.  The attached processes may be
  * quickly accessed by following pointers from struct pid.
  *
- * Storing pid_t values in the kernel and refering to them later has a
+ * Storing pid_t values in the kernel and referring to them later has a
  * problem.  The process originally with that pid may have exited and the
  * pid allocator wrapped, and another process could have come along
  * and been assigned that pid.

commit 45a68628d37222e655219febce9e91b6484789b2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Mar 23 16:43:12 2011 -0700

    pid: remove the child_reaper special case in init/main.c
    
    This patchset is a cleanup and a preparation to unshare the pid namespace.
    These prerequisites prepare for Eric's patchset to give a file descriptor
    to a namespace and join an existing namespace.
    
    This patch:
    
    It turns out that the existing assignment in copy_process of the
    child_reaper can handle the initial assignment of child_reaper we just
    need to generalize the test in kernel/fork.c
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Serge E. Hallyn <serge@hallyn.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 49f1c2f66e95..efceda0a51b1 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -140,6 +140,17 @@ static inline struct pid_namespace *ns_of_pid(struct pid *pid)
 	return ns;
 }
 
+/*
+ * is_child_reaper returns true if the pid is the init process
+ * of the current namespace. As this one could be checked before
+ * pid_ns->child_reaper is assigned in copy_process, we check
+ * with the pid number.
+ */
+static inline bool is_child_reaper(struct pid *pid)
+{
+	return pid->numbers[pid->level].nr == 1;
+}
+
 /*
  * the helpers to get the pid's id seen from different namespaces
  *

commit f9fb860f67b9542cd78d1558dec7058092b57d8e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 7 18:08:46 2009 -0800

    pid: implement ns_of_pid
    
    A current problem with the pid namespace is that it is easy to do pid
    related work after exit_task_namespaces which drops the nsproxy pointer.
    
    However if we are doing pid namespace related work we are always operating
    on some struct pid which retains the pid_namespace pointer of the pid
    namespace it was allocated in.
    
    So provide ns_of_pid which allows us to find the pid namespace a pid was
    allocated in.
    
    Using this we have the needed infrastructure to do pid namespace related
    work at anytime we have a struct pid, removing the chance of accidentally
    having a NULL pointer dereference when accessing current->nsproxy.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Bastian Blank <bastian@waldi.eu.org>
    Cc: Pavel Emelyanov <xemul@openvz.org>
    Cc: Nadia Derbey <Nadia.Derbey@bull.net>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index bb206c56d1f0..49f1c2f66e95 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -122,6 +122,24 @@ int next_pidmap(struct pid_namespace *pid_ns, int last);
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void free_pid(struct pid *pid);
 
+/*
+ * ns_of_pid() returns the pid namespace in which the specified pid was
+ * allocated.
+ *
+ * NOTE:
+ * 	ns_of_pid() is expected to be called for a process (task) that has
+ * 	an attached 'struct pid' (see attach_pid(), detach_pid()) i.e @pid
+ * 	is expected to be non-NULL. If @pid is NULL, caller should handle
+ * 	the resulting NULL pid-ns.
+ */
+static inline struct pid_namespace *ns_of_pid(struct pid *pid)
+{
+	struct pid_namespace *ns = NULL;
+	if (pid)
+		ns = pid->numbers[pid->level].ns;
+	return ns;
+}
+
 /*
  * the helpers to get the pid's id seen from different namespaces
  *

commit 5ef6476190d24419a9a537baa0b5641845136989
Author: Steven Rostedt <srostedt@redhat.com>
Date:   Thu Dec 4 00:26:39 2008 -0500

    pid: fix the do_each_pid_task() macro
    
    Impact: macro side-effects fix
    
    This patch adds parenthesis around 'pid' in the do_each_pid_task
    macro to allow callers to pass in more complex parameters.
    
    e.g.  do_each_pid_task(*pid, type, task)
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index d7e98ff8021e..bb206c56d1f0 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -147,9 +147,9 @@ pid_t pid_vnr(struct pid *pid);
 #define do_each_pid_task(pid, type, task)				\
 	do {								\
 		struct hlist_node *pos___;				\
-		if (pid != NULL)					\
+		if ((pid) != NULL)					\
 			hlist_for_each_entry_rcu((task), pos___,	\
-				&pid->tasks[type], pids[type].node) {
+				&(pid)->tasks[type], pids[type].node) {
 
 			/*
 			 * Both old and new leaders may be attached to

commit 2d70b68d42b5196a48ccb639e3797f097ef5bea3
Author: Ken Chen <kenchen@google.com>
Date:   Wed Aug 20 14:09:17 2008 -0700

    fix setpriority(PRIO_PGRP) thread iterator breakage
    
    When user calls sys_setpriority(PRIO_PGRP ...) on a NPTL style multi-LWP
    process, only the task leader of the process is affected, all other
    sibling LWP threads didn't receive the setting.  The problem was that the
    iterator used in sys_setpriority() only iteartes over one task for each
    process, ignoring all other sibling thread.
    
    Introduce a new macro do_each_pid_thread / while_each_pid_thread to walk
    each thread of a process.  Convert 4 call sites in {set/get}priority and
    ioprio_{set/get}.
    
    Signed-off-by: Ken Chen <kenchen@google.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 22921ac4cfd9..d7e98ff8021e 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -161,4 +161,13 @@ pid_t pid_vnr(struct pid *pid);
 			}						\
 	} while (0)
 
+#define do_each_pid_thread(pid, type, task)				\
+	do_each_pid_task(pid, type, task) {				\
+		struct task_struct *tg___ = task;			\
+		do {
+
+#define while_each_pid_thread(pid, type, task)				\
+		} while_each_thread(tg___, task);			\
+		task = tg___;						\
+	} while_each_pid_task(pid, type, task)
 #endif /* _LINUX_PID_H */

commit dbda0de52618d13d1b927c7ba7bb839cfddc4e8c
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Fri Jul 25 01:48:37 2008 -0700

    pidns: remove find_task_by_pid, unused for a long time
    
    It seems to me that it was a mistake marking this function as deprecated
    and scheduling it for removal, rather than resolutely removing it after
    the last caller's death.
    
    Anyway - better late, then never.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index ff1b2a5814d4..22921ac4cfd9 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -107,7 +107,7 @@ extern struct pid_namespace init_pid_ns;
  * find_pid_ns() finds the pid in the namespace specified
  * find_vpid() finr the pid by its virtual id, i.e. in the current namespace
  *
- * see also find_task_by_pid() set in include/linux/sched.h
+ * see also find_task_by_vpid() set in include/linux/sched.h
  */
 extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
 extern struct pid *find_vpid(int nr);

commit e49859e71e0318b564de1546bdc30fab738f9deb
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Fri Jul 25 01:48:36 2008 -0700

    pidns: remove now unused find_pid function.
    
    This one had the only users so far - the kill_proc, which is removed, so
    drop this (invalid in namespaced world) call too.
    
    And of course - erase all references on it from comments.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 6f084b9e2c40..ff1b2a5814d4 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -48,7 +48,7 @@ enum pid_type
  */
 
 struct upid {
-	/* Try to keep pid_chain in the same cacheline as nr for find_pid */
+	/* Try to keep pid_chain in the same cacheline as nr for find_vpid */
 	int nr;
 	struct pid_namespace *ns;
 	struct hlist_node pid_chain;
@@ -105,14 +105,12 @@ extern struct pid_namespace init_pid_ns;
  * or rcu_read_lock() held.
  *
  * find_pid_ns() finds the pid in the namespace specified
- * find_pid() find the pid by its global id, i.e. in the init namespace
  * find_vpid() finr the pid by its virtual id, i.e. in the current namespace
  *
  * see also find_task_by_pid() set in include/linux/sched.h
  */
 extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
 extern struct pid *find_vpid(int nr);
-extern struct pid *find_pid(int nr);
 
 /*
  * Lookup a PID in the hash table, and return with it's count elevated.

commit 33166b1ffca5e1945246bcaa77d72a22b0d3e531
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Fri Jul 25 01:48:35 2008 -0700

    shrink struct pid by removing padding on 64 bit builds
    
    When struct pid is built on a 64 bit platform gcc has to insert padding to
    maintain the correct alignment, by simply reordering its members the
    memory usage shrinks from 88 bytes to 80.
    
    I've successfully run with this patch on my desktop AMD64 machine.
    
    There are no significant kernel size changes to a default config.X86_64
    on the latest git v2.6.26-rc1
    
       text    data     bss     dec     hex filename
    5404828  976760  734280 7115868  6c945c vmlinux
    5404811  976760  734280 7115851  6c944b vmlinux.pid-patch
    
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index c21c7e8124a7..6f084b9e2c40 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -57,10 +57,10 @@ struct upid {
 struct pid
 {
 	atomic_t count;
+	unsigned int level;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct rcu_head rcu;
-	unsigned int level;
 	struct upid numbers[1];
 };
 

commit caafa4324335aeb11bc233d5f87aca8cce30beba
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Wed Apr 30 00:54:31 2008 -0700

    pidns: make pid->level and pid_ns->level unsigned
    
    These values represent the nesting level of a namespace and pids living in it,
    and it's always non-negative.
    
    Turning this from int to unsigned int saves some space in pid.c (11 bytes on
    x86 and 64 on ia64) by letting the compiler optimize the pid_nr_ns a bit.
    E.g.  on ia64 this removes the sign extension calls, which compiler adds to
    optimize access to pid->nubers[ns->level].
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 8d199033c0ca..c21c7e8124a7 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -60,7 +60,7 @@ struct pid
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct rcu_head rcu;
-	int level;
+	unsigned int level;
 	struct upid numbers[1];
 };
 

commit 24336eaeecea860b2a82530e07c80bc7e0558b73
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Wed Apr 30 00:54:26 2008 -0700

    pids: introduce change_pid() helper
    
    Based on Eric W. Biederman's idea.
    
    Without tasklist_lock held task_session()/task_pgrp() can return NULL if the
    caller races with setprgp()/setsid() which does detach_pid() + attach_pid().
    This can happen even if task == current.
    
    Intoduce the new helper, change_pid(), which should be used instead.  This way
    the caller always sees the special pid != NULL, either old or new.
    
    Also change the prototype of attach_pid(), it always returns 0 and nobody
    check the returned value.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc:  "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Emelyanov <xemul@openvz.org>
    Cc: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index c7980810eb09..8d199033c0ca 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -89,9 +89,11 @@ extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
  * attach_pid() and detach_pid() must be called with the tasklist_lock
  * write-held.
  */
-extern int attach_pid(struct task_struct *task, enum pid_type type,
-		      struct pid *pid);
+extern void attach_pid(struct task_struct *task, enum pid_type type,
+			struct pid *pid);
 extern void detach_pid(struct task_struct *task, enum pid_type);
+extern void change_pid(struct task_struct *task, enum pid_type,
+			struct pid *pid);
 extern void transfer_pid(struct task_struct *old, struct task_struct *new,
 			 enum pid_type);
 

commit b3c97528689619fc66569b30bf83d09d9929521a
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Feb 13 15:03:15 2008 -0800

    include/linux: Remove all users of FASTCALL() macro
    
    FASTCALL() is always expanded to empty, remove it.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index f84d532b5d23..c7980810eb09 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -79,10 +79,9 @@ static inline struct pid *get_pid(struct pid *pid)
 	return pid;
 }
 
-extern void FASTCALL(put_pid(struct pid *pid));
-extern struct task_struct *FASTCALL(pid_task(struct pid *pid, enum pid_type));
-extern struct task_struct *FASTCALL(get_pid_task(struct pid *pid,
-						enum pid_type));
+extern void put_pid(struct pid *pid);
+extern struct task_struct *pid_task(struct pid *pid, enum pid_type);
+extern struct task_struct *get_pid_task(struct pid *pid, enum pid_type);
 
 extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
 
@@ -90,11 +89,11 @@ extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
  * attach_pid() and detach_pid() must be called with the tasklist_lock
  * write-held.
  */
-extern int FASTCALL(attach_pid(struct task_struct *task,
-				enum pid_type type, struct pid *pid));
-extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
-extern void FASTCALL(transfer_pid(struct task_struct *old,
-				  struct task_struct *new, enum pid_type));
+extern int attach_pid(struct task_struct *task, enum pid_type type,
+		      struct pid *pid);
+extern void detach_pid(struct task_struct *task, enum pid_type);
+extern void transfer_pid(struct task_struct *old, struct task_struct *new,
+			 enum pid_type);
 
 struct pid_namespace;
 extern struct pid_namespace init_pid_ns;
@@ -109,7 +108,7 @@ extern struct pid_namespace init_pid_ns;
  *
  * see also find_task_by_pid() set in include/linux/sched.h
  */
-extern struct pid *FASTCALL(find_pid_ns(int nr, struct pid_namespace *ns));
+extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns);
 extern struct pid *find_vpid(int nr);
 extern struct pid *find_pid(int nr);
 
@@ -121,7 +120,7 @@ extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
 int next_pidmap(struct pid_namespace *pid_ns, int last);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
-extern void FASTCALL(free_pid(struct pid *pid));
+extern void free_pid(struct pid *pid);
 
 /*
  * the helpers to get the pid's id seen from different namespaces

commit 46f382d2b69d2221086b823f0dbc8f32c027cac2
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Fri Feb 8 04:19:19 2008 -0800

    uglify while_each_pid_task() to make sure we don't count the execing pricess twice
    
    There is a window when de_thread() switches the leader and drops
    tasklist_lock.  In that window do_each_pid_task(PIDTYPE_PID) finds both new
    and old leaders.
    
    The problem is pretty much theoretical and probably can be ignored.  Currently
    the only users of do_each_pid_task(PIDTYPE_PID) are send_sigio/send_sigurg, so
    they can send the signal to the same process twice.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: Pavel Emelyanov <xemul@openvz.org>
    Cc: Roland McGrath <roland@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index b91f4732dc1b..f84d532b5d23 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -152,7 +152,13 @@ pid_t pid_vnr(struct pid *pid);
 			hlist_for_each_entry_rcu((task), pos___,	\
 				&pid->tasks[type], pids[type].node) {
 
+			/*
+			 * Both old and new leaders may be attached to
+			 * the same pid in the middle of de_thread().
+			 */
 #define while_each_pid_task(pid, type, task)				\
+				if (type == PIDTYPE_PID)		\
+					break;				\
 			}						\
 	} while (0)
 

commit 44c4e1b2581f7273ab14ef30b6430618801c57b1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 8 04:19:15 2008 -0800

    pid: Extend/Fix pid_vnr
    
    pid_vnr returns the user space pid with respect to the pid namespace the
    struct pid was allocated in.  What we want before we return a pid to user
    space is the user space pid with respect to the pid namespace of current.
    
    pid_vnr is a very nice optimization but because it isn't quite what we want
    it is easy to use pid_vnr at times when we aren't certain the struct pid
    was allocated in our pid namespace.
    
    Currently this describes at least tiocgpgrp and tiocgsid in ttyio.c the
    parent process reported in the core dumps and the parent process in
    get_signal_to_deliver.
    
    So unless the performance impact is huge having an interface that does what
    we want instead of always what we want should be much more reliable and
    much less error prone.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Acked-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 061abb6c0796..b91f4732dc1b 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -127,9 +127,8 @@ extern void FASTCALL(free_pid(struct pid *pid));
  * the helpers to get the pid's id seen from different namespaces
  *
  * pid_nr()    : global id, i.e. the id seen from the init namespace;
- * pid_vnr()   : virtual id, i.e. the id seen from the namespace this pid
- *               belongs to. this only makes sence when called in the
- *               context of the task that belongs to the same namespace;
+ * pid_vnr()   : virtual id, i.e. the id seen from the pid namespace of
+ *               current.
  * pid_nr_ns() : id seen from the ns specified.
  *
  * see also task_xid_nr() etc in include/linux/sched.h
@@ -144,14 +143,7 @@ static inline pid_t pid_nr(struct pid *pid)
 }
 
 pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
-
-static inline pid_t pid_vnr(struct pid *pid)
-{
-	pid_t nr = 0;
-	if (pid)
-		nr = pid->numbers[pid->level].nr;
-	return nr;
-}
+pid_t pid_vnr(struct pid *pid);
 
 #define do_each_pid_task(pid, type, task)				\
 	do {								\

commit 74bd59bb39eb08b4379e2590c5f160748d83f812
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Fri Feb 8 04:18:24 2008 -0800

    namespaces: cleanup the code managed with PID_NS option
    
    Just like with the user namespaces, move the namespace management code into
    the separate .c file and mark the (already existing) PID_NS option as "depend
    on NAMESPACES"
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Kirill Korotaev <dev@sw.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index e29a900a8499..061abb6c0796 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -118,10 +118,10 @@ extern struct pid *find_pid(int nr);
  */
 extern struct pid *find_get_pid(int nr);
 extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
+int next_pidmap(struct pid_namespace *pid_ns, int last);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void FASTCALL(free_pid(struct pid *pid));
-extern void zap_pid_ns_processes(struct pid_namespace *pid_ns);
 
 /*
  * the helpers to get the pid's id seen from different namespaces

commit 8990571eb573032c1192440febb17132074c5575
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:19 2007 -0700

    Uninline find_pid etc set of functions
    
    The find_pid/_vpid/_pid_ns functions are used to find the struct pid by its
    id, depending on whic id - global or virtual - is used.
    
    The find_vpid() is a macro that pushes the current->nsproxy->pid_ns on the
    stack to call another function - find_pid_ns().  It turned out, that this
    dereference together with the push itself cause the kernel text size to
    grow too much.
    
    Move all these out-of-line.  Together with the previous patch this saves a
    bit less that 400 bytes from .text section.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 4817c6671e77..e29a900a8499 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -110,9 +110,8 @@ extern struct pid_namespace init_pid_ns;
  * see also find_task_by_pid() set in include/linux/sched.h
  */
 extern struct pid *FASTCALL(find_pid_ns(int nr, struct pid_namespace *ns));
-
-#define find_vpid(pid)	find_pid_ns(pid, current->nsproxy->pid_ns)
-#define find_pid(pid)	find_pid_ns(pid, &init_pid_ns)
+extern struct pid *find_vpid(int nr);
+extern struct pid *find_pid(int nr);
 
 /*
  * Lookup a PID in the hash table, and return with it's count elevated.

commit 19b9b9b54e5f115907efd56be2c3799775a46561
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:17 2007 -0700

    pid namespaces: remove the struct pid unneeded fields
    
    Since we've switched from using pid->nr to pid->upids->nr some
    fields on struct pid are no longer needed
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 16644cceb946..4817c6671e77 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -57,9 +57,6 @@ struct upid {
 struct pid
 {
 	atomic_t count;
-	/* Try to keep pid_chain in the same cacheline as nr for find_pid */
-	int nr;
-	struct hlist_node pid_chain;
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct rcu_head rcu;

commit 3eb07c8c8adb6f0572baba844ba2d9e501654316
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Thu Oct 18 23:40:13 2007 -0700

    pid namespaces: destroy pid namespace on init's death
    
    Terminate all processes in a namespace when the reaper of the namespace is
    exiting.  We do this by walking the pidmap of the namespace and sending
    SIGKILL to all processes.
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Acked-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 0dc940f4be46..16644cceb946 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -125,6 +125,7 @@ extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void FASTCALL(free_pid(struct pid *pid));
+extern void zap_pid_ns_processes(struct pid_namespace *pid_ns);
 
 /*
  * the helpers to get the pid's id seen from different namespaces

commit 198fe21b0a17fe9c68cb519ecc566534b04f122b
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:06 2007 -0700

    pid namespaces: helpers to find the task by its numerical ids
    
    When searching the task by numerical id on may need to find it using global
    pid (as it is done now in kernel) or by its virtual id, e.g.  when sending a
    signal to a task from one namespace the sender will specify the task's virtual
    id and we should find the task by this value.
    
    [akpm@linux-foundation.org: fix gfs2 linkage]
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index c5fee61bfb4f..0dc940f4be46 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -99,17 +99,29 @@ extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
 extern void FASTCALL(transfer_pid(struct task_struct *old,
 				  struct task_struct *new, enum pid_type));
 
+struct pid_namespace;
+extern struct pid_namespace init_pid_ns;
+
 /*
  * look up a PID in the hash table. Must be called with the tasklist_lock
  * or rcu_read_lock() held.
+ *
+ * find_pid_ns() finds the pid in the namespace specified
+ * find_pid() find the pid by its global id, i.e. in the init namespace
+ * find_vpid() finr the pid by its virtual id, i.e. in the current namespace
+ *
+ * see also find_task_by_pid() set in include/linux/sched.h
  */
-extern struct pid *FASTCALL(find_pid(int nr));
+extern struct pid *FASTCALL(find_pid_ns(int nr, struct pid_namespace *ns));
+
+#define find_vpid(pid)	find_pid_ns(pid, current->nsproxy->pid_ns)
+#define find_pid(pid)	find_pid_ns(pid, &init_pid_ns)
 
 /*
  * Lookup a PID in the hash table, and return with it's count elevated.
  */
 extern struct pid *find_get_pid(int nr);
-extern struct pid *find_ge_pid(int nr);
+extern struct pid *find_ge_pid(int nr, struct pid_namespace *);
 
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void FASTCALL(free_pid(struct pid *pid));

commit 7af5729474b5b8ad385adadab78d6e723e7655a3
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:06 2007 -0700

    pid namespaces: helpers to obtain pid numbers
    
    When showing pid to user or getting the pid numerical id for in-kernel use the
    value of this id may differ depending on the namespace.
    
    This set of helpers is used to get the global pid nr, the virtual (i.e.  seen
    by task in its namespace) nr and the nr as it is seen from the specified
    namespace.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 67470ade3212..c5fee61bfb4f 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -114,11 +114,33 @@ extern struct pid *find_ge_pid(int nr);
 extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void FASTCALL(free_pid(struct pid *pid));
 
+/*
+ * the helpers to get the pid's id seen from different namespaces
+ *
+ * pid_nr()    : global id, i.e. the id seen from the init namespace;
+ * pid_vnr()   : virtual id, i.e. the id seen from the namespace this pid
+ *               belongs to. this only makes sence when called in the
+ *               context of the task that belongs to the same namespace;
+ * pid_nr_ns() : id seen from the ns specified.
+ *
+ * see also task_xid_nr() etc in include/linux/sched.h
+ */
+
 static inline pid_t pid_nr(struct pid *pid)
 {
 	pid_t nr = 0;
 	if (pid)
-		nr = pid->nr;
+		nr = pid->numbers[0].nr;
+	return nr;
+}
+
+pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
+
+static inline pid_t pid_vnr(struct pid *pid)
+{
+	pid_t nr = 0;
+	if (pid)
+		nr = pid->numbers[pid->level].nr;
 	return nr;
 }
 

commit 8ef047aaaeb811247a5639c92e2f2ae1221a28dd
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:05 2007 -0700

    pid namespaces: make alloc_pid(), free_pid() and put_pid() work with struct upid
    
    Each struct upid element of struct pid has to be initialized properly, i.e.
    its nr mst be allocated from appropriate pidmap and ns set to appropriate
    namespace.
    
    When allocating a new pid, we need to know the namespace this pid will live
    in, so the additional argument is added to alloc_pid().
    
    On the other hand, the rest of the kernel still uses the pid->nr and
    pid->pid_chain fields, so these ones are still initialized, but this will be
    removed soon.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index e5865a9c58a6..67470ade3212 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -111,7 +111,7 @@ extern struct pid *FASTCALL(find_pid(int nr));
 extern struct pid *find_get_pid(int nr);
 extern struct pid *find_ge_pid(int nr);
 
-extern struct pid *alloc_pid(void);
+extern struct pid *alloc_pid(struct pid_namespace *ns);
 extern void FASTCALL(free_pid(struct pid *pid));
 
 static inline pid_t pid_nr(struct pid *pid)

commit 4c3f2ead5a3dff9069a45560ba4d007c8ae2e2ee
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Thu Oct 18 23:40:03 2007 -0700

    pid namespaces: introduce struct upid
    
    Since task will be visible from different pid namespaces each of them have to
    be addressed by multiple pids.  struct upid is to store the information about
    which id refers to which namespace.
    
    The constuciton looks like this.  Each struct pid carried the reference
    counter and the list of tasks attached to this pid.  At its end it has a
    variable length array of struct upid-s.  Each struct upid has a numerical id
    (pid itself), pointer to the namespace, this ID is valid in and is hashed into
    a pid_hash for searching the pids.
    
    The nr and pid_chain fields are kept in struct pid for a while to make kernel
    still work (no patch initialize the upids yet), but it will be removed at the
    end of this series when we switch to upids completely.
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 1e0e4e3423a6..e5865a9c58a6 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -40,6 +40,20 @@ enum pid_type
  * processes.
  */
 
+
+/*
+ * struct upid is used to get the id of the struct pid, as it is
+ * seen in particular namespace. Later the struct pid is found with
+ * find_pid_ns() using the int nr and struct pid_namespace *ns.
+ */
+
+struct upid {
+	/* Try to keep pid_chain in the same cacheline as nr for find_pid */
+	int nr;
+	struct pid_namespace *ns;
+	struct hlist_node pid_chain;
+};
+
 struct pid
 {
 	atomic_t count;
@@ -49,6 +63,8 @@ struct pid
 	/* lists of tasks that use this pid */
 	struct hlist_head tasks[PIDTYPE_MAX];
 	struct rcu_head rcu;
+	int level;
+	struct upid numbers[1];
 };
 
 extern struct pid init_struct_pid;

commit 820e45db2380eb1545fa2bc5d34b8b2f2933faeb
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Thu May 10 22:23:00 2007 -0700

    statically initialize struct pid for swapper
    
    Statically initialize a struct pid for the swapper process (pid_t == 0) and
    attach it to init_task.  This is needed so task_pid(), task_pgrp() and
    task_session() interfaces work on the swapper process also.
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: <containers@lists.osdl.org>
    Acked-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 33d343880d89..1e0e4e3423a6 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -51,6 +51,8 @@ struct pid
 	struct rcu_head rcu;
 };
 
+extern struct pid init_struct_pid;
+
 struct pid_link
 {
 	struct hlist_node node;

commit e713d0dab21a68500720e222fa02567fc7dfb14b
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Thu May 10 22:22:58 2007 -0700

    attach_pid() with struct pid parameter
    
    attach_pid() currently takes a pid_t and then uses find_pid() to find the
    corresponding struct pid.  Sometimes we already have the struct pid.  We can
    then skip find_pid() if attach_pid() were to take a struct pid parameter.
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Cc: <containers@lists.osdl.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 2ac27f9997dd..33d343880d89 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -76,8 +76,7 @@ extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
  * write-held.
  */
 extern int FASTCALL(attach_pid(struct task_struct *task,
-				enum pid_type type, int nr));
-
+				enum pid_type type, struct pid *pid));
 extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
 extern void FASTCALL(transfer_pid(struct task_struct *old,
 				  struct task_struct *new, enum pid_type));

commit 9f57a54b6cf3f626334d97e93b5b917ad11e1efc
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Feb 12 00:53:02 2007 -0800

    [PATCH] pid: remove now unused do_each_task_pid and while_each_task_pid
    
    Now that I have changed all of the users remove the old version of these
    functions.  This should be a clear hint to any out of tree users that they
    should use do_each_pid_task and while_each_pid_task for new code.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 4dec047b1837..2ac27f9997dd 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -105,20 +105,6 @@ static inline pid_t pid_nr(struct pid *pid)
 	return nr;
 }
 
-
-#define do_each_task_pid(who, type, task)				\
-	do {								\
-		struct hlist_node *pos___;				\
-		struct pid *pid___ = find_pid(who);			\
-		if (pid___ != NULL)					\
-			hlist_for_each_entry_rcu((task), pos___,	\
-				&pid___->tasks[type], pids[type].node) {
-
-#define while_each_task_pid(who, type, task)				\
-			}						\
-	} while (0)
-
-
 #define do_each_pid_task(pid, type, task)				\
 	do {								\
 		struct hlist_node *pos___;				\

commit 84d737866e2babdeab0c6b18ea155c6a649663b8
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Fri Dec 8 02:38:01 2006 -0800

    [PATCH] add child reaper to pid_namespace
    
    Add a per pid_namespace child-reaper.  This is needed so processes are reaped
    within the same pid space and do not spill over to the parent pid space.  Its
    also needed so containers preserve existing semantic that pid == 1 would reap
    orphaned children.
    
    This is based on Eric Biederman's patch: http://lkml.org/lkml/2006/2/6/285
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Kirill Korotaev <dev@openvz.org>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 2c0007d17218..4dec047b1837 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -35,8 +35,9 @@ enum pid_type
  *
  * Holding a reference to struct pid solves both of these problems.
  * It is small so holding a reference does not consume a lot of
- * resources, and since a new struct pid is allocated when the numeric
- * pid value is reused we don't mistakenly refer to new processes.
+ * resources, and since a new struct pid is allocated when the numeric pid
+ * value is reused (when pids wrap around) we don't mistakenly refer to new
+ * processes.
  */
 
 struct pid

commit 1d32849b14bc8792e6f35ab27dd990d74b16126c
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Oct 3 01:13:45 2006 -0700

    [PATCH] pid.h cleanup
    
    Make the pid.h macros look less revolting in an 80-col window.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 17b9e04d3586..2c0007d17218 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -105,28 +105,28 @@ static inline pid_t pid_nr(struct pid *pid)
 }
 
 
-#define do_each_task_pid(who, type, task)					\
-	do {									\
-		struct hlist_node *pos___;					\
-		struct pid *pid___ = find_pid(who);				\
-		if (pid___ != NULL)						\
-			hlist_for_each_entry_rcu((task), pos___,		\
+#define do_each_task_pid(who, type, task)				\
+	do {								\
+		struct hlist_node *pos___;				\
+		struct pid *pid___ = find_pid(who);			\
+		if (pid___ != NULL)					\
+			hlist_for_each_entry_rcu((task), pos___,	\
 				&pid___->tasks[type], pids[type].node) {
 
-#define while_each_task_pid(who, type, task)					\
-			}							\
+#define while_each_task_pid(who, type, task)				\
+			}						\
 	} while (0)
 
 
-#define do_each_pid_task(pid, type, task)					\
-	do {									\
-		struct hlist_node *pos___;					\
-		if (pid != NULL)						\
-			hlist_for_each_entry_rcu((task), pos___,		\
+#define do_each_pid_task(pid, type, task)				\
+	do {								\
+		struct hlist_node *pos___;				\
+		if (pid != NULL)					\
+			hlist_for_each_entry_rcu((task), pos___,	\
 				&pid->tasks[type], pids[type].node) {
 
-#define while_each_pid_task(pid, type, task)					\
-			}							\
+#define while_each_pid_task(pid, type, task)				\
+			}						\
 	} while (0)
 
 #endif /* _LINUX_PID_H */

commit 1a657f78dcc8ea7c53eaa1f2a45ea2315738c15f
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Mon Oct 2 02:18:59 2006 -0700

    [PATCH] introduce get_task_pid() to fix unsafe get_pid()
    
    proc_pid_make_inode:
    
            ei->pid = get_pid(task_pid(task));
    
    I think this is not safe.  get_pid() can be preempted after checking "pid
    != NULL".  Then the task exits, does detach_pid(), and RCU frees the pid.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 7e39767b4c60..17b9e04d3586 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -68,6 +68,8 @@ extern struct task_struct *FASTCALL(pid_task(struct pid *pid, enum pid_type));
 extern struct task_struct *FASTCALL(get_pid_task(struct pid *pid,
 						enum pid_type));
 
+extern struct pid *get_task_pid(struct task_struct *task, enum pid_type type);
+
 /*
  * attach_pid() and detach_pid() must be called with the tasklist_lock
  * write-held.

commit d387cae075b0aec479adbdfb71df39f7de8e9adb
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Mon Oct 2 02:17:22 2006 -0700

    [PATCH] pid: simplify pid iterators
    
    I think it is hardly possible to read the current do_each_task_pid().  The
    new version is much simpler and makes the code smaller.
    
    Only the do_each_task_pid change is tested, the do_each_pid_task isn't.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index dba1b2d677a3..7e39767b4c60 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -102,42 +102,29 @@ static inline pid_t pid_nr(struct pid *pid)
 	return nr;
 }
 
-#define pid_next(task, type)					\
-	((task)->pids[(type)].node.next)
 
-#define pid_next_task(task, type) 				\
-	hlist_entry(pid_next(task, type), struct task_struct,	\
-			pids[(type)].node)
-
-
-/* We could use hlist_for_each_entry_rcu here but it takes more arguments
- * than the do_each_task_pid/while_each_task_pid.  So we roll our own
- * to preserve the existing interface.
- */
-#define do_each_task_pid(who, type, task)				\
-	if ((task = find_task_by_pid_type(type, who))) {		\
-		prefetch(pid_next(task, type));				\
-		do {
-
-#define while_each_task_pid(who, type, task)				\
-		} while (pid_next(task, type) &&  ({			\
-				task = pid_next_task(task, type);	\
-				rcu_dereference(task);			\
-				prefetch(pid_next(task, type));		\
-				1; }) );				\
-	}
-
-#define do_each_pid_task(pid, type, task)				\
-	if ((task = pid_task(pid, type))) {				\
-		prefetch(pid_next(task, type));				\
-		do {
-
-#define while_each_pid_task(pid, type, task)				\
-		} while (pid_next(task, type) &&  ({			\
-				task = pid_next_task(task, type);	\
-				rcu_dereference(task);			\
-				prefetch(pid_next(task, type));		\
-				1; }) );				\
-	}
+#define do_each_task_pid(who, type, task)					\
+	do {									\
+		struct hlist_node *pos___;					\
+		struct pid *pid___ = find_pid(who);				\
+		if (pid___ != NULL)						\
+			hlist_for_each_entry_rcu((task), pos___,		\
+				&pid___->tasks[type], pids[type].node) {
+
+#define while_each_task_pid(who, type, task)					\
+			}							\
+	} while (0)
+
+
+#define do_each_pid_task(pid, type, task)					\
+	do {									\
+		struct hlist_node *pos___;					\
+		if (pid != NULL)						\
+			hlist_for_each_entry_rcu((task), pos___,		\
+				&pid->tasks[type], pids[type].node) {
+
+#define while_each_pid_task(pid, type, task)					\
+			}							\
+	} while (0)
 
 #endif /* _LINUX_PID_H */

commit 5feb8f5f8403d8874a04aac443692dfe83bd63d2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 2 02:17:12 2006 -0700

    [PATCH] pid: implement pid_nr
    
    As we stop storing pid_t's and move to storing struct pid *.  We need a way to
    get the pid_t from the struct pid to report to user space what we have stored.
    
    Having a clean well defined way to do this is especially important as we move
    to multiple pid spaces as may need to report a different value to the caller
    depending on which pid space the caller is in.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 8cf9b11ed264..dba1b2d677a3 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -94,6 +94,14 @@ extern struct pid *find_ge_pid(int nr);
 extern struct pid *alloc_pid(void);
 extern void FASTCALL(free_pid(struct pid *pid));
 
+static inline pid_t pid_nr(struct pid *pid)
+{
+	pid_t nr = 0;
+	if (pid)
+		nr = pid->nr;
+	return nr;
+}
+
 #define pid_next(task, type)					\
 	((task)->pids[(type)].node.next)
 

commit 558cb325485aaf655130f140e8ddd25392f6c972
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 2 02:17:09 2006 -0700

    [PATCH] pid: add do_each_pid_task
    
    To avoid pid rollover confusion the kernel needs to work with struct pid *
    instead of pid_t.  Currently there is not an iterator that walks through all
    of the tasks of a given pid type starting with a struct pid.  This prevents us
    replacing some pid_t instances with struct pid.  So this patch adds
    do_each_pid_task which walks through the set of task for a given pid type
    starting with a struct pid.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 359121086de1..8cf9b11ed264 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -119,4 +119,17 @@ extern void FASTCALL(free_pid(struct pid *pid));
 				1; }) );				\
 	}
 
+#define do_each_pid_task(pid, type, task)				\
+	if ((task = pid_task(pid, type))) {				\
+		prefetch(pid_next(task, type));				\
+		do {
+
+#define while_each_pid_task(pid, type, task)				\
+		} while (pid_next(task, type) &&  ({			\
+				task = pid_next_task(task, type);	\
+				rcu_dereference(task);			\
+				prefetch(pid_next(task, type));		\
+				1; }) );				\
+	}
+
 #endif /* _LINUX_PID_H */

commit 0804ef4b0de7121261f77c565b20a11ac694e877
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 2 02:17:04 2006 -0700

    [PATCH] proc: readdir race fix (take 3)
    
    The problem: An opendir, readdir, closedir sequence can fail to report
    process ids that are continually in use throughout the sequence of system
    calls.  For this race to trigger the process that proc_pid_readdir stops at
    must exit before readdir is called again.
    
    This can cause ps to fail to report processes, and it is in violation of
    posix guarantees and normal application expectations with respect to
    readdir.
    
    Currently there is no way to work around this problem in user space short
    of providing a gargantuan buffer to user space so the directory read all
    happens in on system call.
    
    This patch implements the normal directory semantics for proc, that
    guarantee that a directory entry that is neither created nor destroyed
    while reading the directory entry will be returned.  For directory that are
    either created or destroyed during the readdir you may or may not see them.
     Furthermore you may seek to a directory offset you have previously seen.
    
    These are the guarantee that ext[23] provides and that posix requires, and
    more importantly that user space expects.  Plus it is a simple semantic to
    implement reliable service.  It is just a matter of calling readdir a
    second time if you are wondering if something new has show up.
    
    These better semantics are implemented by scanning through the pids in
    numerical order and by making the file offset a pid plus a fixed offset.
    
    The pid scan happens on the pid bitmap, which when you look at it is
    remarkably efficient for a brute force algorithm.  Given that a typical
    cache line is 64 bytes and thus covers space for 64*8 == 200 pids.  There
    are only 40 cache lines for the entire 32K pid space.  A typical system
    will have 100 pids or more so this is actually fewer cache lines we have to
    look at to scan a linked list, and the worst case of having to scan the
    entire pid bitmap is pretty reasonable.
    
    If we need something more efficient we can go to a more efficient data
    structure for indexing the pids, but for now what we have should be
    sufficient.
    
    In addition this takes no additional locks and is actually less code than
    what we are doing now.
    
    Also another very subtle bug in this area has been fixed.  It is possible
    to catch a task in the middle of de_thread where a thread is assuming the
    thread of it's thread group leader.  This patch carefully handles that case
    so if we hit it we don't fail to return the pid, that is undergoing the
    de_thread dance.
    
    Thanks to KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com> for
    providing the first fix, pointing this out and working on it.
    
    [oleg@tv-sign.ru: fix it]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 93da7e2d9f30..359121086de1 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -89,6 +89,7 @@ extern struct pid *FASTCALL(find_pid(int nr));
  * Lookup a PID in the hash table, and return with it's count elevated.
  */
 extern struct pid *find_get_pid(int nr);
+extern struct pid *find_ge_pid(int nr);
 
 extern struct pid *alloc_pid(void);
 extern void FASTCALL(free_pid(struct pid *pid));

commit c18258c6f0848f97e85287f6271c511a092bb784
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Sep 27 01:51:06 2006 -0700

    [PATCH] pid: Implement transfer_pid and use it to simplify de_thread
    
    In de_thread we move pids from one process to another, a rather ugly case.
    The function transfer_pid makes it clear what we are doing, and makes the
    action atomic.  This is useful we ever want to atomically traverse the
    process group and session lists, in a rcu safe manner.
    
    Even if the atomic properties this change should be a win as transfer_pid
    should be less code to execute than executing both attach_pid and
    detach_pid, and this should make de_thread slightly smaller as only a
    single function call needs to be emitted.  The only downside is that the
    code might be slower to execute as the odds are against transfer_pid being
    in cache.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 29960b03bef7..93da7e2d9f30 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -76,6 +76,8 @@ extern int FASTCALL(attach_pid(struct task_struct *task,
 				enum pid_type type, int nr));
 
 extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
+extern void FASTCALL(transfer_pid(struct task_struct *old,
+				  struct task_struct *new, enum pid_type));
 
 /*
  * look up a PID in the hash table. Must be called with the tasklist_lock

commit 92476d7fc0326a409ab1d3864a04093a6be9aca7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 31 02:31:42 2006 -0800

    [PATCH] pidhash: Refactor the pid hash table
    
    Simplifies the code, reduces the need for 4 pid hash tables, and makes the
    code more capable.
    
    In the discussions I had with Oleg it was felt that to a large extent the
    cleanup itself justified the work.  With struct pid being dynamically
    allocated meant we could create the hash table entry when the pid was
    allocated and free the hash table entry when the pid was freed.  Instead of
    playing with the hash lists when ever a process would attach or detach to a
    process.
    
    For myself the fact that it gave what my previous task_ref patch gave for free
    with simpler code was a big win.  The problem is that if you hold a reference
    to struct task_struct you lock in 10K of low memory.  If you do that in a user
    controllable way like /proc does, with an unprivileged but hostile user space
    application with typical resource limits of 1000 fds and 100 processes I can
    trigger the OOM killer by consuming all of low memory with task structs, on a
    machine wight 1GB of low memory.
    
    If I instead hold a reference to struct pid which holds a pointer to my
    task_struct, I don't suffer from that problem because struct pid is 2 orders
    of magnitude smaller.  In fact struct pid is small enough that most other
    kernel data structures dwarf it, so simply limiting the number of referring
    data structures is enough to prevent exhaustion of low memory.
    
    This splits the current struct pid into two structures, struct pid and struct
    pid_link, and reduces our number of hash tables from PIDTYPE_MAX to just one.
    struct pid_link is the per process linkage into the hash tables and lives in
    struct task_struct.  struct pid is given an indepedent lifetime, and holds
    pointers to each of the pid types.
    
    The independent life of struct pid simplifies attach_pid, and detach_pid,
    because we are always manipulating the list of pids and not the hash table.
    In addition in giving struct pid an indpendent life it makes the concept much
    more powerful.
    
    Kernel data structures can now embed a struct pid * instead of a pid_t and
    not suffer from pid wrap around problems or from keeping unnecessarily
    large amounts of memory allocated.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 5b9082cc600f..29960b03bef7 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -1,6 +1,8 @@
 #ifndef _LINUX_PID_H
 #define _LINUX_PID_H
 
+#include <linux/rcupdate.h>
+
 enum pid_type
 {
 	PIDTYPE_PID,
@@ -9,45 +11,109 @@ enum pid_type
 	PIDTYPE_MAX
 };
 
+/*
+ * What is struct pid?
+ *
+ * A struct pid is the kernel's internal notion of a process identifier.
+ * It refers to individual tasks, process groups, and sessions.  While
+ * there are processes attached to it the struct pid lives in a hash
+ * table, so it and then the processes that it refers to can be found
+ * quickly from the numeric pid value.  The attached processes may be
+ * quickly accessed by following pointers from struct pid.
+ *
+ * Storing pid_t values in the kernel and refering to them later has a
+ * problem.  The process originally with that pid may have exited and the
+ * pid allocator wrapped, and another process could have come along
+ * and been assigned that pid.
+ *
+ * Referring to user space processes by holding a reference to struct
+ * task_struct has a problem.  When the user space process exits
+ * the now useless task_struct is still kept.  A task_struct plus a
+ * stack consumes around 10K of low kernel memory.  More precisely
+ * this is THREAD_SIZE + sizeof(struct task_struct).  By comparison
+ * a struct pid is about 64 bytes.
+ *
+ * Holding a reference to struct pid solves both of these problems.
+ * It is small so holding a reference does not consume a lot of
+ * resources, and since a new struct pid is allocated when the numeric
+ * pid value is reused we don't mistakenly refer to new processes.
+ */
+
 struct pid
 {
+	atomic_t count;
 	/* Try to keep pid_chain in the same cacheline as nr for find_pid */
 	int nr;
 	struct hlist_node pid_chain;
-	/* list of pids with the same nr, only one of them is in the hash */
-	struct list_head pid_list;
+	/* lists of tasks that use this pid */
+	struct hlist_head tasks[PIDTYPE_MAX];
+	struct rcu_head rcu;
 };
 
-#define pid_task(elem, type) \
-	list_entry(elem, struct task_struct, pids[type].pid_list)
+struct pid_link
+{
+	struct hlist_node node;
+	struct pid *pid;
+};
+
+static inline struct pid *get_pid(struct pid *pid)
+{
+	if (pid)
+		atomic_inc(&pid->count);
+	return pid;
+}
+
+extern void FASTCALL(put_pid(struct pid *pid));
+extern struct task_struct *FASTCALL(pid_task(struct pid *pid, enum pid_type));
+extern struct task_struct *FASTCALL(get_pid_task(struct pid *pid,
+						enum pid_type));
 
 /*
  * attach_pid() and detach_pid() must be called with the tasklist_lock
  * write-held.
  */
-extern int FASTCALL(attach_pid(struct task_struct *task, enum pid_type type, int nr));
+extern int FASTCALL(attach_pid(struct task_struct *task,
+				enum pid_type type, int nr));
 
 extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
 
 /*
  * look up a PID in the hash table. Must be called with the tasklist_lock
- * held.
+ * or rcu_read_lock() held.
+ */
+extern struct pid *FASTCALL(find_pid(int nr));
+
+/*
+ * Lookup a PID in the hash table, and return with it's count elevated.
  */
-extern struct pid *FASTCALL(find_pid(enum pid_type, int));
+extern struct pid *find_get_pid(int nr);
 
-extern int alloc_pidmap(void);
-extern void FASTCALL(free_pidmap(int));
+extern struct pid *alloc_pid(void);
+extern void FASTCALL(free_pid(struct pid *pid));
 
+#define pid_next(task, type)					\
+	((task)->pids[(type)].node.next)
+
+#define pid_next_task(task, type) 				\
+	hlist_entry(pid_next(task, type), struct task_struct,	\
+			pids[(type)].node)
+
+
+/* We could use hlist_for_each_entry_rcu here but it takes more arguments
+ * than the do_each_task_pid/while_each_task_pid.  So we roll our own
+ * to preserve the existing interface.
+ */
 #define do_each_task_pid(who, type, task)				\
 	if ((task = find_task_by_pid_type(type, who))) {		\
-		prefetch((task)->pids[type].pid_list.next);		\
+		prefetch(pid_next(task, type));				\
 		do {
 
 #define while_each_task_pid(who, type, task)				\
-		} while (task = pid_task((task)->pids[type].pid_list.next,\
-						type),			\
-			prefetch((task)->pids[type].pid_list.next),	\
-			hlist_unhashed(&(task)->pids[type].pid_chain));	\
-	}								\
+		} while (pid_next(task, type) &&  ({			\
+				task = pid_next_task(task, type);	\
+				rcu_dereference(task);			\
+				prefetch(pid_next(task, type));		\
+				1; }) );				\
+	}
 
 #endif /* _LINUX_PID_H */

commit 47e65328a7b1cdfc4e3102e50d60faf94ebba7d3
Author: Oleg Nesterov <oleg@tv-sign.ru>
Date:   Tue Mar 28 16:11:25 2006 -0800

    [PATCH] pids: kill PIDTYPE_TGID
    
    This patch kills PIDTYPE_TGID pid_type thus saving one hash table in
    kernel/pid.c and speeding up subthreads create/destroy a bit.  It is also a
    preparation for the further tref/pids rework.
    
    This patch adds 'struct list_head thread_group' to 'struct task_struct'
    instead.
    
    We don't detach group leader from PIDTYPE_PID namespace until another
    thread inherits it's ->pid == ->tgid, so we are safe wrt premature
    free_pidmap(->tgid) call.
    
    Currently there are no users of find_task_by_pid_type(PIDTYPE_TGID).
    Should the need arise, we can use find_task_by_pid()->group_leader.
    
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Acked-By: Eric Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 099e70ecf7c7..5b9082cc600f 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -4,7 +4,6 @@
 enum pid_type
 {
 	PIDTYPE_PID,
-	PIDTYPE_TGID,
 	PIDTYPE_PGID,
 	PIDTYPE_SID,
 	PIDTYPE_MAX

commit d73d65293e3e2de7e916a89c8da30be0948afab7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 28 16:11:03 2006 -0800

    [PATCH] pidhash: kill switch_exec_pids
    
    switch_exec_pids is only called from de_thread by way of exec, and it is
    only called when we are exec'ing from a non thread group leader.
    
    Currently switch_exec_pids gives the leader the pid of the thread and
    unhashes and rehashes all of the process groups.  The leader is already in
    the EXIT_DEAD state so no one cares about it's pids.  The only concern for
    the leader is that __unhash_process called from release_task will function
    correctly.  If we don't touch the leader at all we know that
    __unhash_process will work fine so there is no need to touch the leader.
    
    For the task becomming the thread group leader, we just need to give it the
    pid of the old thread group leader, add it to the task list, and attach it
    to the session and the process group of the thread group.
    
    Currently de_thread is also adding the task to the task list which is just
    silly.
    
    Currently the only leader of __detach_pid besides detach_pid is
    switch_exec_pids because of the ugly extra work that was being
    performed.
    
    So this patch removes switch_exec_pids because it is doing too much, it is
    creating an unnecessary special case in pid.c, duing work duplicated in
    de_thread, and generally obscuring what it is going on.
    
    The necessary work is added to de_thread, and it seems to be a little
    clearer there what is going on.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Kirill Korotaev <dev@sw.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pid.h b/include/linux/pid.h
index 5b2fcb19d2da..099e70ecf7c7 100644
--- a/include/linux/pid.h
+++ b/include/linux/pid.h
@@ -38,7 +38,6 @@ extern struct pid *FASTCALL(find_pid(enum pid_type, int));
 
 extern int alloc_pidmap(void);
 extern void FASTCALL(free_pidmap(int));
-extern void switch_exec_pids(struct task_struct *leader, struct task_struct *thread);
 
 #define do_each_task_pid(who, type, task)				\
 	if ((task = find_task_by_pid_type(type, who))) {		\

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/pid.h b/include/linux/pid.h
new file mode 100644
index 000000000000..5b2fcb19d2da
--- /dev/null
+++ b/include/linux/pid.h
@@ -0,0 +1,55 @@
+#ifndef _LINUX_PID_H
+#define _LINUX_PID_H
+
+enum pid_type
+{
+	PIDTYPE_PID,
+	PIDTYPE_TGID,
+	PIDTYPE_PGID,
+	PIDTYPE_SID,
+	PIDTYPE_MAX
+};
+
+struct pid
+{
+	/* Try to keep pid_chain in the same cacheline as nr for find_pid */
+	int nr;
+	struct hlist_node pid_chain;
+	/* list of pids with the same nr, only one of them is in the hash */
+	struct list_head pid_list;
+};
+
+#define pid_task(elem, type) \
+	list_entry(elem, struct task_struct, pids[type].pid_list)
+
+/*
+ * attach_pid() and detach_pid() must be called with the tasklist_lock
+ * write-held.
+ */
+extern int FASTCALL(attach_pid(struct task_struct *task, enum pid_type type, int nr));
+
+extern void FASTCALL(detach_pid(struct task_struct *task, enum pid_type));
+
+/*
+ * look up a PID in the hash table. Must be called with the tasklist_lock
+ * held.
+ */
+extern struct pid *FASTCALL(find_pid(enum pid_type, int));
+
+extern int alloc_pidmap(void);
+extern void FASTCALL(free_pidmap(int));
+extern void switch_exec_pids(struct task_struct *leader, struct task_struct *thread);
+
+#define do_each_task_pid(who, type, task)				\
+	if ((task = find_task_by_pid_type(type, who))) {		\
+		prefetch((task)->pids[type].pid_list.next);		\
+		do {
+
+#define while_each_task_pid(who, type, task)				\
+		} while (task = pid_task((task)->pids[type].pid_list.next,\
+						type),			\
+			prefetch((task)->pids[type].pid_list.next),	\
+			hlist_unhashed(&(task)->pids[type].pid_chain));	\
+	}								\
+
+#endif /* _LINUX_PID_H */
