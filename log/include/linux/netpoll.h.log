commit 1ddabdfaf70c202b88925edd74c66f4707dbd92e
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:20 2020 -0700

    netpoll: netpoll_send_skb() returns transmit status
    
    Some callers want to know if the packet has been sent or
    dropped, to inform upper stacks.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index e466ddffef61..f47af135bd56 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,7 +63,7 @@ int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
-void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
+netdev_tx_t netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 
 #ifdef CONFIG_NETPOLL
 static inline void *netpoll_poll_lock(struct napi_struct *napi)

commit fb1eee476b0d3be3e58dac1a3a96f726c6278bed
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:19 2020 -0700

    netpoll: move netpoll_send_skb() out of line
    
    There is no need to inline this helper, as we intend to add more
    code in this function.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 00e0bae3d402..e466ddffef61 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,14 +63,7 @@ int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
-void __netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
-static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
-{
-	unsigned long flags;
-	local_irq_save(flags);
-	__netpoll_send_skb(np, skb);
-	local_irq_restore(flags);
-}
+void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 
 #ifdef CONFIG_NETPOLL
 static inline void *netpoll_poll_lock(struct napi_struct *napi)

commit 307f660d056b5eb8f5bb2328fac3915ab75b5007
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:18 2020 -0700

    netpoll: remove dev argument from netpoll_send_skb_on_dev()
    
    netpoll_send_skb_on_dev() can get the device pointer directly from np->dev
    
    Rename it to __netpoll_send_skb()
    
    Following patch will move netpoll_send_skb() out-of-line.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 676f1ff161a9..00e0bae3d402 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,13 +63,12 @@ int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
-void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
-			     struct net_device *dev);
+void __netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 {
 	unsigned long flags;
 	local_irq_save(flags);
-	netpoll_send_skb_on_dev(np, skb, np->dev);
+	__netpoll_send_skb(np, skb);
 	local_irq_restore(flags);
 }
 

commit c9fbd71f73094311b31ee703a918e9e0df502cef
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Thu Oct 18 11:18:26 2018 -0400

    netpoll: allow cleanup to be synchronous
    
    This fixes a problem introduced by:
    commit 2cde6acd49da ("netpoll: Fix __netpoll_rcu_free so that it can hold the rtnl lock")
    
    When using netconsole on a bond, __netpoll_cleanup can asynchronously
    recurse multiple times, each __netpoll_free_async call can result in
    more __netpoll_free_async's. This means there is now a race between
    cleanup_work queues on multiple netpoll_info's on multiple devices and
    the configuration of a new netpoll. For example if a netconsole is set
    to enable 0, reconfigured, and enable 1 immediately, this netconsole
    will likely not work.
    
    Given the reason for __netpoll_free_async is it can be called when rtnl
    is not locked, if it is locked, we should be able to execute
    synchronously. It appears to be locked everywhere it's called from.
    
    Generalize the design pattern from the teaming driver for current
    callers of __netpoll_free_async.
    
    CC: Neil Horman <nhorman@tuxdriver.com>
    CC: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 3ef82d3a78db..676f1ff161a9 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -31,8 +31,6 @@ struct netpoll {
 	bool ipv6;
 	u16 local_port, remote_port;
 	u8 remote_mac[ETH_ALEN];
-
-	struct work_struct cleanup_work;
 };
 
 struct netpoll_info {
@@ -63,7 +61,7 @@ int netpoll_parse_options(struct netpoll *np, char *opt);
 int __netpoll_setup(struct netpoll *np, struct net_device *ndev);
 int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
-void __netpoll_free_async(struct netpoll *np);
+void __netpoll_free(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
 void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
 			     struct net_device *dev);

commit ac3d9dd034e565df2c034ab2ca71f0a9f69153c1
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 21 15:27:38 2018 -0700

    netpoll: make ndo_poll_controller() optional
    
    As diagnosed by Song Liu, ndo_poll_controller() can
    be very dangerous on loaded hosts, since the cpu
    calling ndo_poll_controller() might steal all NAPI
    contexts (for all RX/TX queues of the NIC). This capture
    can last for unlimited amount of time, since one
    cpu is generally not able to drain all the queues under load.
    
    It seems that all networking drivers that do use NAPI
    for their TX completions, should not provide a ndo_poll_controller().
    
    NAPI drivers have netpoll support already handled
    in core networking stack, since netpoll_poll_dev()
    uses poll_napi(dev) to iterate through registered
    NAPI contexts for a device.
    
    This patch allows netpoll_poll_dev() to process NAPI
    contexts even for drivers not providing ndo_poll_controller(),
    allowing for following patches in NAPI drivers.
    
    Also we export netpoll_poll_dev() so that it can be called
    by bonding/team drivers in following patches.
    
    Reported-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Tested-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 67662d01130a..3ef82d3a78db 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -49,8 +49,9 @@ struct netpoll_info {
 };
 
 #ifdef CONFIG_NETPOLL
-extern void netpoll_poll_disable(struct net_device *dev);
-extern void netpoll_poll_enable(struct net_device *dev);
+void netpoll_poll_dev(struct net_device *dev);
+void netpoll_poll_disable(struct net_device *dev);
+void netpoll_poll_enable(struct net_device *dev);
 #else
 static inline void netpoll_poll_disable(struct net_device *dev) { return; }
 static inline void netpoll_poll_enable(struct net_device *dev) { return; }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 27c0aaa22cb0..67662d01130a 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Common code for low-level network console, dump, and debugger code
  *

commit 433cea4d9bbb83cc848b80c51bb849a2ceb49379
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Fri Jun 30 13:08:04 2017 +0300

    net: convert netpoll_info.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 1828900c9411..27c0aaa22cb0 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -11,6 +11,7 @@
 #include <linux/interrupt.h>
 #include <linux/rcupdate.h>
 #include <linux/list.h>
+#include <linux/refcount.h>
 
 union inet_addr {
 	__u32		all[4];
@@ -34,7 +35,7 @@ struct netpoll {
 };
 
 struct netpoll_info {
-	atomic_t refcnt;
+	refcount_t refcnt;
 
 	struct semaphore dev_lock;
 

commit 89c4b442b78bdba388337cc746fe63caba85f46c
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Nov 16 14:54:50 2016 -0800

    netpoll: more efficient locking
    
    Callers of netpoll_poll_lock() own NAPI_STATE_SCHED
    
    Callers of netpoll_poll_unlock() have BH blocked between
    the NAPI_STATE_SCHED being cleared and poll_lock is released.
    
    We can avoid the spinlock which has no contention, and use cmpxchg()
    on poll_owner which we need to set anyway.
    
    This removes a possible lockdep violation after the cited commit,
    since sk_busy_loop() re-enables BH before calling busy_poll_stop()
    
    Fixes: 217f69743681 ("net: busy-poll: allow preemption in sk_busy_loop()")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index b25ee9ffdbe6..1828900c9411 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -78,8 +78,11 @@ static inline void *netpoll_poll_lock(struct napi_struct *napi)
 	struct net_device *dev = napi->dev;
 
 	if (dev && dev->npinfo) {
-		spin_lock(&napi->poll_lock);
-		napi->poll_owner = smp_processor_id();
+		int owner = smp_processor_id();
+
+		while (cmpxchg(&napi->poll_owner, -1, owner) != -1)
+			cpu_relax();
+
 		return napi;
 	}
 	return NULL;
@@ -89,10 +92,8 @@ static inline void netpoll_poll_unlock(void *have)
 {
 	struct napi_struct *napi = have;
 
-	if (napi) {
-		napi->poll_owner = -1;
-		spin_unlock(&napi->poll_lock);
-	}
+	if (napi)
+		smp_store_release(&napi->poll_owner, -1);
 }
 
 static inline bool netpoll_tx_running(struct net_device *dev)

commit 66b5552fc2dfbaa6445b1bdadd10c9305ce261bd
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 27 15:39:03 2014 -0700

    netpoll: Rename netpoll_rx_enable/disable to netpoll_poll_disable/enable
    
    The netpoll_rx_enable and netpoll_rx_disable functions have always
    controlled polling the network drivers transmit and receive queues.
    
    Rename them to netpoll_poll_enable and netpoll_poll_disable to make
    their functionality clear.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 893b9e66060e..b25ee9ffdbe6 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -47,11 +47,11 @@ struct netpoll_info {
 };
 
 #ifdef CONFIG_NETPOLL
-extern void netpoll_rx_disable(struct net_device *dev);
-extern void netpoll_rx_enable(struct net_device *dev);
+extern void netpoll_poll_disable(struct net_device *dev);
+extern void netpoll_poll_enable(struct net_device *dev);
 #else
-static inline void netpoll_rx_disable(struct net_device *dev) { return; }
-static inline void netpoll_rx_enable(struct net_device *dev) { return; }
+static inline void netpoll_poll_disable(struct net_device *dev) { return; }
+static inline void netpoll_poll_enable(struct net_device *dev) { return; }
 #endif
 
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);

commit a8779ec1c5e60548b7b661a8d74a8cecf7775690
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 27 15:36:38 2014 -0700

    netpoll: Remove gfp parameter from __netpoll_setup
    
    The gfp parameter was added in:
    commit 47be03a28cc6c80e3aa2b3e8ed6d960ff0c5c0af
    Author: Amerigo Wang <amwang@redhat.com>
    Date:   Fri Aug 10 01:24:37 2012 +0000
    
        netpoll: use GFP_ATOMIC in slave_enable_netpoll() and __netpoll_setup()
    
        slave_enable_netpoll() and __netpoll_setup() may be called
        with read_lock() held, so should use GFP_ATOMIC to allocate
        memory. Eric suggested to pass gfp flags to __netpoll_setup().
    
        Cc: Eric Dumazet <eric.dumazet@gmail.com>
        Cc: "David S. Miller" <davem@davemloft.net>
        Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
        Signed-off-by: Eric Dumazet <edumazet@google.com>
        Signed-off-by: Cong Wang <amwang@redhat.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
    The reason for the gfp parameter was removed in:
    commit c4cdef9b7183159c23c7302aaf270d64c549f557
    Author: dingtianhong <dingtianhong@huawei.com>
    Date:   Tue Jul 23 15:25:27 2013 +0800
    
        bonding: don't call slave_xxx_netpoll under spinlocks
    
        The slave_xxx_netpoll will call synchronize_rcu_bh(),
        so the function may schedule and sleep, it should't be
        called under spinlocks.
    
        bond_netpoll_setup() and bond_netpoll_cleanup() are always
        protected by rtnl lock, it is no need to take the read lock,
        as the slave list couldn't be changed outside rtnl lock.
    
        Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
        Cc: Jay Vosburgh <fubar@us.ibm.com>
        Cc: Andy Gospodarek <andy@greyhouse.net>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
    Nothing else that calls __netpoll_setup or ndo_netpoll_setup
    requires a gfp paramter, so remove the gfp parameter from both
    of these functions making the code clearer.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 1b475a5a7239..893b9e66060e 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -57,7 +57,7 @@ static inline void netpoll_rx_enable(struct net_device *dev) { return; }
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
-int __netpoll_setup(struct netpoll *np, struct net_device *ndev, gfp_t gfp);
+int __netpoll_setup(struct netpoll *np, struct net_device *ndev);
 int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free_async(struct netpoll *np);

commit 9c62a68d13119a1ca9718381d97b0cb415ff4e9d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 20:51:52 2014 -0700

    netpoll: Remove dead packet receive code (CONFIG_NETPOLL_TRAP)
    
    The netpoll packet receive code only becomes active if the netpoll
    rx_skb_hook is implemented, and there is not a single implementation
    of the netpoll rx_skb_hook in the kernel.
    
    All of the out of tree implementations I have found all call
    netpoll_poll which was removed from the kernel in 2011, so this
    change should not add any additional breakage.
    
    There are problems with the netpoll packet receive code.  __netpoll_rx
    does not call dev_kfree_skb_irq or dev_kfree_skb_any in hard irq
    context.  netpoll_neigh_reply leaks every skb it receives.  Reception
    of packets does not work successfully on stacked devices (aka bonding,
    team, bridge, and vlans).
    
    Given that the netpoll packet receive code is buggy, there are no
    out of tree users that will be merged soon, and the code has
    not been used for in tree for a decade let's just remove it.
    
    Reverting this commit can server as a starting point for anyone
    who wants to resurrect netpoll packet reception support.
    
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index a0632af88d8b..1b475a5a7239 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -31,12 +31,6 @@ struct netpoll {
 	u8 remote_mac[ETH_ALEN];
 
 	struct work_struct cleanup_work;
-
-#ifdef CONFIG_NETPOLL_TRAP
-	void (*rx_skb_hook)(struct netpoll *np, int source, struct sk_buff *skb,
-			    int offset, int len);
-	struct list_head rx; /* rx_np list element */
-#endif
 };
 
 struct netpoll_info {
@@ -50,12 +44,6 @@ struct netpoll_info {
 
 	struct netpoll *netpoll;
 	struct rcu_head rcu;
-
-#ifdef CONFIG_NETPOLL_TRAP
-	spinlock_t rx_lock;
-	struct list_head rx_np; /* netpolls that registered an rx_skb_hook */
-	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
-#endif
 };
 
 #ifdef CONFIG_NETPOLL
@@ -84,78 +72,6 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 	local_irq_restore(flags);
 }
 
-#ifdef CONFIG_NETPOLL_TRAP
-int netpoll_trap(void);
-void netpoll_set_trap(int trap);
-int __netpoll_rx(struct sk_buff *skb, struct netpoll_info *npinfo);
-static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
-{
-	return !list_empty(&npinfo->rx_np);
-}
-
-static inline bool netpoll_rx_on(struct sk_buff *skb)
-{
-	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
-
-	return npinfo && netpoll_rx_processing(npinfo);
-}
-
-static inline bool netpoll_rx(struct sk_buff *skb)
-{
-	struct netpoll_info *npinfo;
-	unsigned long flags;
-	bool ret = false;
-
-	local_irq_save(flags);
-
-	if (!netpoll_rx_on(skb))
-		goto out;
-
-	npinfo = rcu_dereference_bh(skb->dev->npinfo);
-	spin_lock(&npinfo->rx_lock);
-	/* check rx_processing again with the lock held */
-	if (netpoll_rx_processing(npinfo) && __netpoll_rx(skb, npinfo))
-		ret = true;
-	spin_unlock(&npinfo->rx_lock);
-
-out:
-	local_irq_restore(flags);
-	return ret;
-}
-
-static inline int netpoll_receive_skb(struct sk_buff *skb)
-{
-	if (!list_empty(&skb->dev->napi_list))
-		return netpoll_rx(skb);
-	return 0;
-}
-
-#else
-static inline int netpoll_trap(void)
-{
-	return 0;
-}
-static inline void netpoll_set_trap(int trap)
-{
-}
-static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
-{
-	return false;
-}
-static inline bool netpoll_rx(struct sk_buff *skb)
-{
-	return false;
-}
-static inline bool netpoll_rx_on(struct sk_buff *skb)
-{
-	return false;
-}
-static inline int netpoll_receive_skb(struct sk_buff *skb)
-{
-	return 0;
-}
-#endif
-
 #ifdef CONFIG_NETPOLL
 static inline void *netpoll_poll_lock(struct napi_struct *napi)
 {

commit e1bd4d3d7dd2a4a0e731ffe07c439927c23f16ea
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 20:50:58 2014 -0700

    netpoll: Move all receive processing under CONFIG_NETPOLL_TRAP
    
    Make rx_skb_hook, and rx in struct netpoll depend on
    CONFIG_NETPOLL_TRAP Make rx_lock, rx_np, and neigh_tx in struct
    netpoll_info depend on CONFIG_NETPOLL_TRAP
    
    Make the functions netpoll_rx_on, netpoll_rx, and netpoll_receive_skb
    no-ops when CONFIG_NETPOLL_TRAP is not set.
    
    Only build netpoll_neigh_reply, checksum_udp service_neigh_queue,
    pkt_is_ns, and __netpoll_rx when CONFIG_NETPOLL_TRAP is defined.
    
    Add helper functions netpoll_trap_setup, netpoll_trap_setup_info,
    netpoll_trap_cleanup, and netpoll_trap_cleanup_info that initialize
    and cleanup the struct netpoll and struct netpoll_info receive
    specific fields when CONFIG_NETPOLL_TRAP is enabled and do nothing
    otherwise.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index ab9aaaff8d04..a0632af88d8b 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -24,32 +24,38 @@ struct netpoll {
 	struct net_device *dev;
 	char dev_name[IFNAMSIZ];
 	const char *name;
-	void (*rx_skb_hook)(struct netpoll *np, int source, struct sk_buff *skb,
-			    int offset, int len);
 
 	union inet_addr local_ip, remote_ip;
 	bool ipv6;
 	u16 local_port, remote_port;
 	u8 remote_mac[ETH_ALEN];
 
-	struct list_head rx; /* rx_np list element */
 	struct work_struct cleanup_work;
+
+#ifdef CONFIG_NETPOLL_TRAP
+	void (*rx_skb_hook)(struct netpoll *np, int source, struct sk_buff *skb,
+			    int offset, int len);
+	struct list_head rx; /* rx_np list element */
+#endif
 };
 
 struct netpoll_info {
 	atomic_t refcnt;
 
-	spinlock_t rx_lock;
 	struct semaphore dev_lock;
-	struct list_head rx_np; /* netpolls that registered an rx_skb_hook */
 
-	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
 	struct sk_buff_head txq;
 
 	struct delayed_work tx_work;
 
 	struct netpoll *netpoll;
 	struct rcu_head rcu;
+
+#ifdef CONFIG_NETPOLL_TRAP
+	spinlock_t rx_lock;
+	struct list_head rx_np; /* netpolls that registered an rx_skb_hook */
+	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
+#endif
 };
 
 #ifdef CONFIG_NETPOLL
@@ -68,7 +74,6 @@ int netpoll_setup(struct netpoll *np);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free_async(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
-int __netpoll_rx(struct sk_buff *skb, struct netpoll_info *npinfo);
 void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
 			     struct net_device *dev);
 static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
@@ -82,25 +87,12 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 #ifdef CONFIG_NETPOLL_TRAP
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);
+int __netpoll_rx(struct sk_buff *skb, struct netpoll_info *npinfo);
 static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
 {
 	return !list_empty(&npinfo->rx_np);
 }
-#else
-static inline int netpoll_trap(void)
-{
-	return 0;
-}
-static inline void netpoll_set_trap(int trap)
-{
-}
-static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
-{
-	return false;
-}
-#endif
 
-#ifdef CONFIG_NETPOLL
 static inline bool netpoll_rx_on(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
@@ -138,6 +130,33 @@ static inline int netpoll_receive_skb(struct sk_buff *skb)
 	return 0;
 }
 
+#else
+static inline int netpoll_trap(void)
+{
+	return 0;
+}
+static inline void netpoll_set_trap(int trap)
+{
+}
+static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
+{
+	return false;
+}
+static inline bool netpoll_rx(struct sk_buff *skb)
+{
+	return false;
+}
+static inline bool netpoll_rx_on(struct sk_buff *skb)
+{
+	return false;
+}
+static inline int netpoll_receive_skb(struct sk_buff *skb)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_NETPOLL
 static inline void *netpoll_poll_lock(struct napi_struct *napi)
 {
 	struct net_device *dev = napi->dev;
@@ -166,18 +185,6 @@ static inline bool netpoll_tx_running(struct net_device *dev)
 }
 
 #else
-static inline bool netpoll_rx(struct sk_buff *skb)
-{
-	return false;
-}
-static inline bool netpoll_rx_on(struct sk_buff *skb)
-{
-	return false;
-}
-static inline int netpoll_receive_skb(struct sk_buff *skb)
-{
-	return 0;
-}
 static inline void *netpoll_poll_lock(struct napi_struct *napi)
 {
 	return NULL;

commit ad8d475244b4112a0f5331e78d043d3a4c9eb37e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 20:49:43 2014 -0700

    netpoll: Move netpoll_trap under CONFIG_NETPOLL_TRAP
    
    Now that we no longer need to receive packets to safely drain the
    network drivers receive queue move netpoll_trap and netpoll_set_trap
    under CONFIG_NETPOLL_TRAP
    
    Making netpoll_trap and netpoll_set_trap noop inline functions
    when CONFIG_NETPOLL_TRAP is not set.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 154f9776056c..ab9aaaff8d04 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -65,8 +65,6 @@ void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
 int __netpoll_setup(struct netpoll *np, struct net_device *ndev, gfp_t gfp);
 int netpoll_setup(struct netpoll *np);
-int netpoll_trap(void);
-void netpoll_set_trap(int trap);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free_async(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
@@ -82,11 +80,20 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 }
 
 #ifdef CONFIG_NETPOLL_TRAP
+int netpoll_trap(void);
+void netpoll_set_trap(int trap);
 static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
 {
 	return !list_empty(&npinfo->rx_np);
 }
 #else
+static inline int netpoll_trap(void)
+{
+	return 0;
+}
+static inline void netpoll_set_trap(int trap)
+{
+}
 static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
 {
 	return false;

commit b6bacd550c33124ea76291bd84ac42c8d30767eb
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 20:48:28 2014 -0700

    netpoll: Don't drop all received packets.
    
    Change the strategy of netpoll from dropping all packets received
    during netpoll_poll_dev to calling napi poll with a budget of 0
    (to avoid processing drivers rx queue), and to ignore packets received
    with netif_rx (those will safely be placed on the backlog queue).
    
    All of the netpoll supporting drivers have been reviewed to ensure
    either thay use netif_rx or that a budget of 0 is supported by their
    napi poll routine and that a budget of 0 will not process the drivers
    rx queues.
    
    Not dropping packets makes NETPOLL_RX_DROP unnecesary so it is removed.
    
    npinfo->rx_flags is removed  as rx_flags with just the NETPOLL_RX_ENABLED
    flag becomes just a redundant mirror of list_empty(&npinfo->rx_np).
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 479d15c97770..154f9776056c 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -39,7 +39,6 @@ struct netpoll {
 struct netpoll_info {
 	atomic_t refcnt;
 
-	unsigned long rx_flags;
 	spinlock_t rx_lock;
 	struct semaphore dev_lock;
 	struct list_head rx_np; /* netpolls that registered an rx_skb_hook */
@@ -99,7 +98,7 @@ static inline bool netpoll_rx_on(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
-	return npinfo && (netpoll_rx_processing(npinfo) || npinfo->rx_flags);
+	return npinfo && netpoll_rx_processing(npinfo);
 }
 
 static inline bool netpoll_rx(struct sk_buff *skb)

commit ff6076314339e079806d9d2f3de9c9b768e94db1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Mar 14 20:47:49 2014 -0700

    netpoll: Add netpoll_rx_processing
    
    Add a helper netpoll_rx_processing that reports when netpoll has
    receive side processing to perform.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index fbfdb9d8d3a7..479d15c97770 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -82,14 +82,24 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 	local_irq_restore(flags);
 }
 
-
+#ifdef CONFIG_NETPOLL_TRAP
+static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
+{
+	return !list_empty(&npinfo->rx_np);
+}
+#else
+static inline bool netpoll_rx_processing(struct netpoll_info *npinfo)
+{
+	return false;
+}
+#endif
 
 #ifdef CONFIG_NETPOLL
 static inline bool netpoll_rx_on(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
-	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
+	return npinfo && (netpoll_rx_processing(npinfo) || npinfo->rx_flags);
 }
 
 static inline bool netpoll_rx(struct sk_buff *skb)
@@ -105,8 +115,8 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 
 	npinfo = rcu_dereference_bh(skb->dev->npinfo);
 	spin_lock(&npinfo->rx_lock);
-	/* check rx_flags again with the lock held */
-	if (npinfo->rx_flags && __netpoll_rx(skb, npinfo))
+	/* check rx_processing again with the lock held */
+	if (netpoll_rx_processing(npinfo) && __netpoll_rx(skb, npinfo))
 		ret = true;
 	spin_unlock(&npinfo->rx_lock);
 

commit 8fb479a47c869820966e7298f38038aa334d889c
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Wed Oct 23 23:36:30 2013 +0200

    netpoll: fix rx_hook() interface by passing the skb
    
    Right now skb->data is passed to rx_hook() even if the skb
    has not been linearised and without giving rx_hook() a way
    to linearise it.
    
    Change the rx_hook() interface and make it accept the skb
    and the offset to the UDP payload as arguments. rx_hook() is
    also renamed to rx_skb_hook() to ensure that out of the tree
    users notice the API change.
    
    In this way any rx_skb_hook() implementation can perform all
    the needed operations to properly (and safely) access the
    skb data.
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index f3c7c24bec1c..fbfdb9d8d3a7 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -24,7 +24,8 @@ struct netpoll {
 	struct net_device *dev;
 	char dev_name[IFNAMSIZ];
 	const char *name;
-	void (*rx_hook)(struct netpoll *, int, char *, int);
+	void (*rx_skb_hook)(struct netpoll *np, int source, struct sk_buff *skb,
+			    int offset, int len);
 
 	union inet_addr local_ip, remote_ip;
 	bool ipv6;
@@ -41,7 +42,7 @@ struct netpoll_info {
 	unsigned long rx_flags;
 	spinlock_t rx_lock;
 	struct semaphore dev_lock;
-	struct list_head rx_np; /* netpolls that registered an rx_hook */
+	struct list_head rx_np; /* netpolls that registered an rx_skb_hook */
 
 	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
 	struct sk_buff_head txq;

commit da6e378ba918cd0feeb90eeb84d8b42148bb0c82
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Mon May 27 19:53:31 2013 +0000

    netpoll: remove return value from netpoll_rx_disable()
    
    The netpoll_rx_disable() will always return 0, it is no use and looks wordy,
    so remove the unnecessary code and get rid of it in _dev_open and _dev_close.
    
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index fa2cb76a7029..f3c7c24bec1c 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -53,10 +53,10 @@ struct netpoll_info {
 };
 
 #ifdef CONFIG_NETPOLL
-extern int netpoll_rx_disable(struct net_device *dev);
+extern void netpoll_rx_disable(struct net_device *dev);
 extern void netpoll_rx_enable(struct net_device *dev);
 #else
-static inline int netpoll_rx_disable(struct net_device *dev) { return 0; }
+static inline void netpoll_rx_disable(struct net_device *dev) { return; }
 static inline void netpoll_rx_enable(struct net_device *dev) { return; }
 #endif
 

commit bd7c4b604a6cd707803c7c6ba142bfa131f9a9f3
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue Apr 30 05:35:05 2013 +0000

    netpoll: convert mutex into a semaphore
    
    Bart Van Assche recently reported a warning to me:
    
    <IRQ>  [<ffffffff8103d79f>] warn_slowpath_common+0x7f/0xc0
    [<ffffffff8103d7fa>] warn_slowpath_null+0x1a/0x20
    [<ffffffff814761dd>] mutex_trylock+0x16d/0x180
    [<ffffffff813968c9>] netpoll_poll_dev+0x49/0xc30
    [<ffffffff8136a2d2>] ? __alloc_skb+0x82/0x2a0
    [<ffffffff81397715>] netpoll_send_skb_on_dev+0x265/0x410
    [<ffffffff81397c5a>] netpoll_send_udp+0x28a/0x3a0
    [<ffffffffa0541843>] ? write_msg+0x53/0x110 [netconsole]
    [<ffffffffa05418bf>] write_msg+0xcf/0x110 [netconsole]
    [<ffffffff8103eba1>] call_console_drivers.constprop.17+0xa1/0x1c0
    [<ffffffff8103fb76>] console_unlock+0x2d6/0x450
    [<ffffffff8104011e>] vprintk_emit+0x1ee/0x510
    [<ffffffff8146f9f6>] printk+0x4d/0x4f
    [<ffffffffa0004f1d>] scsi_print_command+0x7d/0xe0 [scsi_mod]
    
    This resulted from my commit ca99ca14c which introduced a mutex_trylock
    operation in a path that could execute in interrupt context.  When mutex
    debugging is enabled, the above warns the user when we are in fact
    exectuting in interrupt context
    interrupt context.
    
    After some discussion, It seems that a semaphore is the proper mechanism to use
    here.  While mutexes are defined to be unusable in interrupt context, no such
    condition exists for semaphores (save for the fact that the non blocking api
    calls, like up and down_trylock must be used when in irq context).
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: Bart Van Assche <bvanassche@acm.org>
    CC: Bart Van Assche <bvanassche@acm.org>
    CC: David Miller <davem@davemloft.net>
    CC: netdev@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 9d7d8c64f7c8..fa2cb76a7029 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -40,7 +40,7 @@ struct netpoll_info {
 
 	unsigned long rx_flags;
 	spinlock_t rx_lock;
-	struct mutex dev_lock;
+	struct semaphore dev_lock;
 	struct list_head rx_np; /* netpolls that registered an rx_hook */
 
 	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */

commit 2cde6acd49daca58b96f1fbc697492825511ad31
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Mon Feb 11 10:25:30 2013 +0000

    netpoll: Fix __netpoll_rcu_free so that it can hold the rtnl lock
    
    __netpoll_rcu_free is used to free netpoll structures when the rtnl_lock is
    already held.  The mechanism is used to asynchronously call __netpoll_cleanup
    outside of the holding of the rtnl_lock, so as to avoid deadlock.
    Unfortunately, __netpoll_cleanup modifies pointers (dev->np), which means the
    rtnl_lock must be held while calling it.  Further, it cannot be held, because
    rcu callbacks may be issued in softirq contexts, which cannot sleep.
    
    Fix this by converting the rcu callback to a work queue that is guaranteed to
    get scheduled in process context, so that we can hold the rtnl properly while
    calling __netpoll_cleanup
    
    Tested successfully by myself.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Cong Wang <amwang@redhat.com>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index ab856d507b7e..9d7d8c64f7c8 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -32,7 +32,7 @@ struct netpoll {
 	u8 remote_mac[ETH_ALEN];
 
 	struct list_head rx; /* rx_np list element */
-	struct rcu_head rcu;
+	struct work_struct cleanup_work;
 };
 
 struct netpoll_info {
@@ -68,7 +68,7 @@ int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);
 void __netpoll_cleanup(struct netpoll *np);
-void __netpoll_free_rcu(struct netpoll *np);
+void __netpoll_free_async(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb, struct netpoll_info *npinfo);
 void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,

commit ca99ca14c95ae49fb4c9cd3abf5f84d11a7e8a61
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue Feb 5 08:05:43 2013 +0000

    netpoll: protect napi_poll and poll_controller during dev_[open|close]
    
    Ivan Vercera was recently backporting commit
    9c13cb8bb477a83b9a3c9e5a5478a4e21294a760 to a RHEL kernel, and I noticed that,
    while this patch protects the tg3 driver from having its ndo_poll_controller
    routine called during device initalization, it does nothing for the driver
    during shutdown. I.e. it would be entirely possible to have the
    ndo_poll_controller method (or subsequently the ndo_poll) routine called for a
    driver in the netpoll path on CPU A while in parallel on CPU B, the ndo_close or
    ndo_open routine could be called.  Given that the two latter routines tend to
    initizlize and free many data structures that the former two rely on, the result
    can easily be data corruption or various other crashes.  Furthermore, it seems
    that this is potentially a problem with all net drivers that support netpoll,
    and so this should ideally be fixed in a common path.
    
    As Ben H Pointed out to me, we can't preform dev_open/dev_close in atomic
    context, so I've come up with this solution.  We can use a mutex to sleep in
    open/close paths and just do a mutex_trylock in the napi poll path and abandon
    the poll attempt if we're locked, as we'll just retry the poll on the next send
    anyway.
    
    I've tested this here by flooding netconsole with messages on a system whos nic
    driver I modfied to periodically return NETDEV_TX_BUSY, so that the netpoll tx
    workqueue would be forced to send frames and poll the device.  While this was
    going on I rapidly ifdown/up'ed the interface and watched for any problems.
    I've not found any.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Ivan Vecera <ivecera@redhat.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Ben Hutchings <bhutchings@solarflare.com>
    CC: Francois Romieu <romieu@fr.zoreil.com>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index f54c3bb6a22b..ab856d507b7e 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -38,8 +38,9 @@ struct netpoll {
 struct netpoll_info {
 	atomic_t refcnt;
 
-	int rx_flags;
+	unsigned long rx_flags;
 	spinlock_t rx_lock;
+	struct mutex dev_lock;
 	struct list_head rx_np; /* netpolls that registered an rx_hook */
 
 	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
@@ -51,6 +52,14 @@ struct netpoll_info {
 	struct rcu_head rcu;
 };
 
+#ifdef CONFIG_NETPOLL
+extern int netpoll_rx_disable(struct net_device *dev);
+extern void netpoll_rx_enable(struct net_device *dev);
+#else
+static inline int netpoll_rx_disable(struct net_device *dev) { return 0; }
+static inline void netpoll_rx_enable(struct net_device *dev) { return; }
+#endif
+
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);

commit b7394d2429c198b1da3d46ac39192e891029ec0f
Author: Cong Wang <amwang@redhat.com>
Date:   Mon Jan 7 20:52:39 2013 +0000

    netpoll: prepare for ipv6
    
    This patch adjusts some struct and functions, to prepare
    for supporting IPv6.
    
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 66d5379c305e..f54c3bb6a22b 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -12,13 +12,22 @@
 #include <linux/rcupdate.h>
 #include <linux/list.h>
 
+union inet_addr {
+	__u32		all[4];
+	__be32		ip;
+	__be32		ip6[4];
+	struct in_addr	in;
+	struct in6_addr	in6;
+};
+
 struct netpoll {
 	struct net_device *dev;
 	char dev_name[IFNAMSIZ];
 	const char *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
 
-	__be32 local_ip, remote_ip;
+	union inet_addr local_ip, remote_ip;
+	bool ipv6;
 	u16 local_port, remote_port;
 	u8 remote_mac[ETH_ALEN];
 
@@ -33,7 +42,7 @@ struct netpoll_info {
 	spinlock_t rx_lock;
 	struct list_head rx_np; /* netpolls that registered an rx_hook */
 
-	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
+	struct sk_buff_head neigh_tx; /* list of neigh requests to reply to */
 	struct sk_buff_head txq;
 
 	struct delayed_work tx_work;

commit 77ab8a54d9a8dcc4a46484a04133314f33f2aba6
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:46 2012 +0000

    netpoll: convert several functions to bool
    
    These functions are just boolean, let them return
    bool instead of int.
    
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 61aee86cf21d..66d5379c305e 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -66,7 +66,7 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 
 
 #ifdef CONFIG_NETPOLL
-static inline int netpoll_rx_on(struct sk_buff *skb)
+static inline bool netpoll_rx_on(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
@@ -125,7 +125,7 @@ static inline void netpoll_poll_unlock(void *have)
 	}
 }
 
-static inline int netpoll_tx_running(struct net_device *dev)
+static inline bool netpoll_tx_running(struct net_device *dev)
 {
 	return irqs_disabled();
 }
@@ -133,11 +133,11 @@ static inline int netpoll_tx_running(struct net_device *dev)
 #else
 static inline bool netpoll_rx(struct sk_buff *skb)
 {
-	return 0;
+	return false;
 }
-static inline int netpoll_rx_on(struct sk_buff *skb)
+static inline bool netpoll_rx_on(struct sk_buff *skb)
 {
-	return 0;
+	return false;
 }
 static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
@@ -153,9 +153,9 @@ static inline void netpoll_poll_unlock(void *have)
 static inline void netpoll_netdev_init(struct net_device *dev)
 {
 }
-static inline int netpoll_tx_running(struct net_device *dev)
+static inline bool netpoll_tx_running(struct net_device *dev)
 {
-	return 0;
+	return false;
 }
 #endif
 

commit 2899656b494dcd118123af1126826b115c8ea6f9
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:42 2012 +0000

    netpoll: take rcu_read_lock_bh() in netpoll_send_skb_on_dev()
    
    This patch fixes several problems in the call path of
    netpoll_send_skb_on_dev():
    
    1. Disable IRQ's before calling netpoll_send_skb_on_dev().
    
    2. All the callees of netpoll_send_skb_on_dev() should use
       rcu_dereference_bh() to dereference ->npinfo.
    
    3. Rename arp_reply() to netpoll_arp_reply(), the former is too generic.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 2d178baa49df..61aee86cf21d 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -57,7 +57,10 @@ void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
 			     struct net_device *dev);
 static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 {
+	unsigned long flags;
+	local_irq_save(flags);
 	netpoll_send_skb_on_dev(np, skb, np->dev);
+	local_irq_restore(flags);
 }
 
 

commit 91fe4a4b9e490a24f6702dd8afe72d8afab6fcdb
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:41 2012 +0000

    netpoll: use netpoll_rx_on() in netpoll_rx()
    
    The logic of the code is same, just call netpoll_rx_on().
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 5d881c388273..2d178baa49df 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,6 +63,13 @@ static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
 
 
 #ifdef CONFIG_NETPOLL
+static inline int netpoll_rx_on(struct sk_buff *skb)
+{
+	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
+
+	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
+}
+
 static inline bool netpoll_rx(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo;
@@ -70,11 +77,11 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 	bool ret = false;
 
 	local_irq_save(flags);
-	npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
-	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
+	if (!netpoll_rx_on(skb))
 		goto out;
 
+	npinfo = rcu_dereference_bh(skb->dev->npinfo);
 	spin_lock(&npinfo->rx_lock);
 	/* check rx_flags again with the lock held */
 	if (npinfo->rx_flags && __netpoll_rx(skb, npinfo))
@@ -86,13 +93,6 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 	return ret;
 }
 
-static inline int netpoll_rx_on(struct sk_buff *skb)
-{
-	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
-
-	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
-}
-
 static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
 	if (!list_empty(&skb->dev->napi_list))

commit 57c5d46191e75312934c00eba65b13a31ca95120
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:40 2012 +0000

    netpoll: take rcu_read_lock_bh() in netpoll_rx()
    
    In __netpoll_rx(), it dereferences ->npinfo without rcu_dereference_bh(),
    this patch fixes it by using the 'npinfo' passed from netpoll_rx()
    where it is already dereferenced with rcu_dereference_bh().
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 907812efb4d9..5d881c388273 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -52,7 +52,7 @@ void netpoll_set_trap(int trap);
 void __netpoll_cleanup(struct netpoll *np);
 void __netpoll_free_rcu(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
-int __netpoll_rx(struct sk_buff *skb);
+int __netpoll_rx(struct sk_buff *skb, struct netpoll_info *npinfo);
 void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
 			     struct net_device *dev);
 static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
@@ -77,7 +77,7 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 
 	spin_lock(&npinfo->rx_lock);
 	/* check rx_flags again with the lock held */
-	if (npinfo->rx_flags && __netpoll_rx(skb))
+	if (npinfo->rx_flags && __netpoll_rx(skb, npinfo))
 		ret = true;
 	spin_unlock(&npinfo->rx_lock);
 

commit 38e6bc185d9544dfad1774b3f8902a0b061aea25
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:38 2012 +0000

    netpoll: make __netpoll_cleanup non-block
    
    Like the previous patch, slave_disable_netpoll() and __netpoll_cleanup()
    may be called with read_lock() held too, so we should make them
    non-block, by moving the cleanup and kfree() to call_rcu_bh() callbacks.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index bf2d51eec0f3..907812efb4d9 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -23,6 +23,7 @@ struct netpoll {
 	u8 remote_mac[ETH_ALEN];
 
 	struct list_head rx; /* rx_np list element */
+	struct rcu_head rcu;
 };
 
 struct netpoll_info {
@@ -38,6 +39,7 @@ struct netpoll_info {
 	struct delayed_work tx_work;
 
 	struct netpoll *netpoll;
+	struct rcu_head rcu;
 };
 
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
@@ -48,6 +50,7 @@ int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);
 void __netpoll_cleanup(struct netpoll *np);
+void __netpoll_free_rcu(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb);
 void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,

commit 47be03a28cc6c80e3aa2b3e8ed6d960ff0c5c0af
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:37 2012 +0000

    netpoll: use GFP_ATOMIC in slave_enable_netpoll() and __netpoll_setup()
    
    slave_enable_netpoll() and __netpoll_setup() may be called
    with read_lock() held, so should use GFP_ATOMIC to allocate
    memory. Eric suggested to pass gfp flags to __netpoll_setup().
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 28f5389c924b..bf2d51eec0f3 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -43,7 +43,7 @@ struct netpoll_info {
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
-int __netpoll_setup(struct netpoll *np, struct net_device *ndev);
+int __netpoll_setup(struct netpoll *np, struct net_device *ndev, gfp_t gfp);
 int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);

commit 30fdd8a082a00126a6feec994e43e8dc12f5bccb
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Tue Jul 17 05:22:35 2012 +0000

    netpoll: move np->dev and np->dev_name init into __netpoll_setup()
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 5dfa091c3347..28f5389c924b 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -43,7 +43,7 @@ struct netpoll_info {
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
-int __netpoll_setup(struct netpoll *np);
+int __netpoll_setup(struct netpoll *np, struct net_device *ndev);
 int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);

commit 234b921dbcf144826e2e2b3663cd8090892ee2b2
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 30 15:08:57 2011 +0000

    netpoll: Remove unused EXPORT_SYMBOLs of netpoll_poll and netpoll_poll_dev
    
    Unused symbols waste space.
    
    Commit 0e34e93177fb
    "(netpoll: add generic support for bridge and bonding devices)"
    added the symbol more than a year ago with the promise of "future use".
    
    Because it is so far unused, remove it for now.
    It can be easily readded if or when it actually needs to be used.
    
    cc: WANG Cong <amwang@redhat.com>
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 79358bb712c6..5dfa091c3347 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -40,8 +40,6 @@ struct netpoll_info {
 	struct netpoll *netpoll;
 };
 
-void netpoll_poll_dev(struct net_device *dev);
-void netpoll_poll(struct netpoll *np);
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);

commit c2355e1ab910278a94d487b78590ee3c8eecd08a
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Oct 13 16:01:49 2010 +0000

    bonding: Fix bonding drivers improper modification of netpoll structure
    
    The bonding driver currently modifies the netpoll structure in its xmit path
    while sending frames from netpoll.  This is racy, as other cpus can access the
    netpoll structure in parallel. Since the bonding driver points np->dev to a
    slave device, other cpus can inadvertently attempt to send data directly to
    slave devices, leading to improper locking with the bonding master, lost frames,
    and deadlocks.  This patch fixes that up.
    
    This patch also removes the real_dev pointer from the netpoll structure as that
    data is really only used by bonding in the poll_controller, and we can emulate
    its behavior by check each slave for IS_UP.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 50d8009be86c..79358bb712c6 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -14,7 +14,6 @@
 
 struct netpoll {
 	struct net_device *dev;
-	struct net_device *real_dev;
 	char dev_name[IFNAMSIZ];
 	const char *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
@@ -53,7 +52,13 @@ void netpoll_set_trap(int trap);
 void __netpoll_cleanup(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb);
-void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
+void netpoll_send_skb_on_dev(struct netpoll *np, struct sk_buff *skb,
+			     struct net_device *dev);
+static inline void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)
+{
+	netpoll_send_skb_on_dev(np, skb, np->dev);
+}
+
 
 
 #ifdef CONFIG_NETPOLL

commit f0f9deae9e7c421fa0c1c627beb8e174325e1ba7
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Sep 17 16:55:03 2010 -0700

    netpoll: Disable IRQ around RCU dereference in netpoll_rx
    
    We cannot use rcu_dereference_bh safely in netpoll_rx as we may
    be called with IRQs disabled.  We could however simply disable
    IRQs as that too causes BH to be disabled and is safe in either
    case.
    
    Thanks to John Linville for discovering this bug and providing
    a patch.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 791d5109f34c..50d8009be86c 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,20 +63,20 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 	unsigned long flags;
 	bool ret = false;
 
-	rcu_read_lock_bh();
+	local_irq_save(flags);
 	npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
 	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
 		goto out;
 
-	spin_lock_irqsave(&npinfo->rx_lock, flags);
+	spin_lock(&npinfo->rx_lock);
 	/* check rx_flags again with the lock held */
 	if (npinfo->rx_flags && __netpoll_rx(skb))
 		ret = true;
-	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
+	spin_unlock(&npinfo->rx_lock);
 
 out:
-	rcu_read_unlock_bh();
+	local_irq_restore(flags);
 	return ret;
 }
 

commit 969a6e521730153380ad7781095f503c040b684c
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue Aug 10 16:24:41 2010 -0700

    net: make netpoll_rx return bool for !CONFIG_NETPOLL
    
    "netpoll: Use 'bool' for netpoll_rx() return type." missed the case when
    CONFIG_NETPOLL is disabled.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 413742c92d14..791d5109f34c 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -122,7 +122,7 @@ static inline int netpoll_tx_running(struct net_device *dev)
 }
 
 #else
-static inline int netpoll_rx(struct sk_buff *skb)
+static inline bool netpoll_rx(struct sk_buff *skb)
 {
 	return 0;
 }

commit d5f31fbfd8fa3836a918592032853c41d1797c3d
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Jun 15 21:44:29 2010 -0700

    netpoll: Use correct primitives for RCU dereferencing
    
    Now that RCU debugging checks for matching rcu_dereference calls
    and rcu_read_lock, we need to use the correct primitives or face
    nasty warnings.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 4c77fe78ceff..413742c92d14 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -64,7 +64,7 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 	bool ret = false;
 
 	rcu_read_lock_bh();
-	npinfo = rcu_dereference(skb->dev->npinfo);
+	npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
 	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
 		goto out;
@@ -82,7 +82,7 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 
 static inline int netpoll_rx_on(struct sk_buff *skb)
 {
-	struct netpoll_info *npinfo = rcu_dereference(skb->dev->npinfo);
+	struct netpoll_info *npinfo = rcu_dereference_bh(skb->dev->npinfo);
 
 	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
 }

commit c18370f5b2949d9cca519355f33690b75e1e7c8b
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Jun 10 16:12:49 2010 +0000

    netpoll: Add netpoll_tx_running
    
    This patch adds the helper netpoll_tx_running for use within
    ndo_start_xmit.  It returns non-zero if ndo_start_xmit is being
    invoked by netpoll, and zero otherwise.
    
    This is currently implemented by simply looking at the hardirq
    count.  This is because for all non-netpoll uses of ndo_start_xmit,
    IRQs must be enabled while netpoll always disables IRQs before
    calling ndo_start_xmit.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index f3ad74af7e1f..4c77fe78ceff 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -116,6 +116,11 @@ static inline void netpoll_poll_unlock(void *have)
 	}
 }
 
+static inline int netpoll_tx_running(struct net_device *dev)
+{
+	return irqs_disabled();
+}
+
 #else
 static inline int netpoll_rx(struct sk_buff *skb)
 {
@@ -139,6 +144,10 @@ static inline void netpoll_poll_unlock(void *have)
 static inline void netpoll_netdev_init(struct net_device *dev)
 {
 }
+static inline int netpoll_tx_running(struct net_device *dev)
+{
+	return 0;
+}
 #endif
 
 #endif

commit 8fdd95ec162a8fbac7f41d6f54f90402fe3e8cb1
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Jun 10 16:12:48 2010 +0000

    netpoll: Allow netpoll_setup/cleanup recursion
    
    This patch adds the functions __netpoll_setup/__netpoll_cleanup
    which is designed to be called recursively through ndo_netpoll_seutp.
    
    They must be called with RTNL held, and the caller must initialise
    np->dev and ensure that it has a valid reference count.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 95c9f7e16776..f3ad74af7e1f 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -46,9 +46,11 @@ void netpoll_poll(struct netpoll *np);
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
+int __netpoll_setup(struct netpoll *np);
 int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);
 void netpoll_set_trap(int trap);
+void __netpoll_cleanup(struct netpoll *np);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb);
 void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);

commit de85d99eb7b595f6751550184b94c1e2f74a828b
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Jun 10 16:12:44 2010 +0000

    netpoll: Fix RCU usage
    
    The use of RCU in netpoll is incorrect in a number of places:
    
    1) The initial setting is lacking a write barrier.
    2) The synchronize_rcu is in the wrong place.
    3) Read barriers are missing.
    4) Some places are even missing rcu_read_lock.
    5) npinfo is zeroed after freeing.
    
    This patch fixes those issues.  As most users are in BH context,
    this also converts the RCU usage to the BH variant.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index e9e231215865..95c9f7e16776 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -57,12 +57,15 @@ void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 #ifdef CONFIG_NETPOLL
 static inline bool netpoll_rx(struct sk_buff *skb)
 {
-	struct netpoll_info *npinfo = skb->dev->npinfo;
+	struct netpoll_info *npinfo;
 	unsigned long flags;
 	bool ret = false;
 
+	rcu_read_lock_bh();
+	npinfo = rcu_dereference(skb->dev->npinfo);
+
 	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
-		return false;
+		goto out;
 
 	spin_lock_irqsave(&npinfo->rx_lock, flags);
 	/* check rx_flags again with the lock held */
@@ -70,12 +73,14 @@ static inline bool netpoll_rx(struct sk_buff *skb)
 		ret = true;
 	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
 
+out:
+	rcu_read_unlock_bh();
 	return ret;
 }
 
 static inline int netpoll_rx_on(struct sk_buff *skb)
 {
-	struct netpoll_info *npinfo = skb->dev->npinfo;
+	struct netpoll_info *npinfo = rcu_dereference(skb->dev->npinfo);
 
 	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
 }
@@ -91,7 +96,6 @@ static inline void *netpoll_poll_lock(struct napi_struct *napi)
 {
 	struct net_device *dev = napi->dev;
 
-	rcu_read_lock(); /* deal with race on ->npinfo */
 	if (dev && dev->npinfo) {
 		spin_lock(&napi->poll_lock);
 		napi->poll_owner = smp_processor_id();
@@ -108,7 +112,6 @@ static inline void netpoll_poll_unlock(void *have)
 		napi->poll_owner = -1;
 		spin_unlock(&napi->poll_lock);
 	}
-	rcu_read_unlock();
 }
 
 #else

commit ffb273623bc506d854902a415ef241b79232f93a
Author: David S. Miller <davem@davemloft.net>
Date:   Thu May 6 01:20:10 2010 -0700

    netpoll: Use 'bool' for netpoll_rx() return type.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 017e604d05f8..e9e231215865 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -55,19 +55,19 @@ void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 
 
 #ifdef CONFIG_NETPOLL
-static inline int netpoll_rx(struct sk_buff *skb)
+static inline bool netpoll_rx(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = skb->dev->npinfo;
 	unsigned long flags;
-	int ret = 0;
+	bool ret = false;
 
 	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
-		return 0;
+		return false;
 
 	spin_lock_irqsave(&npinfo->rx_lock, flags);
 	/* check rx_flags again with the lock held */
 	if (npinfo->rx_flags && __netpoll_rx(skb))
-		ret = 1;
+		ret = true;
 	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
 
 	return ret;

commit 0e34e93177fb1f642cab080e0bde664c06c7183a
Author: WANG Cong <amwang@redhat.com>
Date:   Thu May 6 00:47:21 2010 -0700

    netpoll: add generic support for bridge and bonding devices
    
    This whole patchset is for adding netpoll support to bridge and bonding
    devices. I already tested it for bridge, bonding, bridge over bonding,
    and bonding over bridge. It looks fine now.
    
    To make bridge and bonding support netpoll, we need to adjust
    some netpoll generic code. This patch does the following things:
    
    1) introduce two new priv_flags for struct net_device:
       IFF_IN_NETPOLL which identifies we are processing a netpoll;
       IFF_DISABLE_NETPOLL is used to disable netpoll support for a device
       at run-time;
    
    2) introduce one new method for netdev_ops:
       ->ndo_netpoll_cleanup() is used to clean up netpoll when a device is
         removed.
    
    3) introduce netpoll_poll_dev() which takes a struct net_device * parameter;
       export netpoll_send_skb() and netpoll_poll_dev() which will be used later;
    
    4) hide a pointer to struct netpoll in struct netpoll_info, ditto.
    
    5) introduce ->real_dev for struct netpoll.
    
    6) introduce a new status NETDEV_BONDING_DESLAE, which is used to disable
       netconsole before releasing a slave, to avoid deadlocks.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index a765ea898549..017e604d05f8 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -14,6 +14,7 @@
 
 struct netpoll {
 	struct net_device *dev;
+	struct net_device *real_dev;
 	char dev_name[IFNAMSIZ];
 	const char *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
@@ -36,8 +37,11 @@ struct netpoll_info {
 	struct sk_buff_head txq;
 
 	struct delayed_work tx_work;
+
+	struct netpoll *netpoll;
 };
 
+void netpoll_poll_dev(struct net_device *dev);
 void netpoll_poll(struct netpoll *np);
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
 void netpoll_print_options(struct netpoll *np);
@@ -47,6 +51,7 @@ int netpoll_trap(void);
 void netpoll_set_trap(int trap);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb);
+void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb);
 
 
 #ifdef CONFIG_NETPOLL

commit 508e14b4a4fb1a824a14f2c5b8d7df67b313f8e4
Author: Daniel Borkmann <danborkmann@googlemail.com>
Date:   Tue Jan 12 14:27:30 2010 +0000

    netpoll: allow execution of multiple rx_hooks per interface
    
    Signed-off-by: Daniel Borkmann <danborkmann@googlemail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 2524267210d3..a765ea898549 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -21,15 +21,20 @@ struct netpoll {
 	__be32 local_ip, remote_ip;
 	u16 local_port, remote_port;
 	u8 remote_mac[ETH_ALEN];
+
+	struct list_head rx; /* rx_np list element */
 };
 
 struct netpoll_info {
 	atomic_t refcnt;
+
 	int rx_flags;
 	spinlock_t rx_lock;
-	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
+	struct list_head rx_np; /* netpolls that registered an rx_hook */
+
 	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
 	struct sk_buff_head txq;
+
 	struct delayed_work tx_work;
 };
 
@@ -51,7 +56,7 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	unsigned long flags;
 	int ret = 0;
 
-	if (!npinfo || (!npinfo->rx_np && !npinfo->rx_flags))
+	if (!npinfo || (list_empty(&npinfo->rx_np) && !npinfo->rx_flags))
 		return 0;
 
 	spin_lock_irqsave(&npinfo->rx_lock, flags);
@@ -67,7 +72,7 @@ static inline int netpoll_rx_on(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = skb->dev->npinfo;
 
-	return npinfo && (npinfo->rx_np || npinfo->rx_flags);
+	return npinfo && (!list_empty(&npinfo->rx_np) || npinfo->rx_flags);
 }
 
 static inline int netpoll_receive_skb(struct sk_buff *skb)

commit e7557af56a576762a655f1aaaded253ad14c5958
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Sat Mar 28 15:38:31 2009 +0000

    netpoll: store local and remote ip in net-endian
    
    Allows for the removal of byteswapping in some places and
    the removal of HIPQUAD (replaced by %pI4).
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index de99025f2c5d..2524267210d3 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -18,7 +18,7 @@ struct netpoll {
 	const char *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
 
-	u32 local_ip, remote_ip;
+	__be32 local_ip, remote_ip;
 	u16 local_port, remote_port;
 	u8 remote_mac[ETH_ALEN];
 };

commit d1c76af9e2434fac3add561e26c61b06503de986
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Mar 16 10:50:02 2009 -0700

    GRO: Move netpoll checks to correct location
    
    As my netpoll fix for net doesn't really work for net-next, we
    need this update to move the checks into the right place.  As it
    stands we may pass freed skbs to netpoll_receive_skb.
    
    This patch also introduces a netpoll_rx_on function to avoid GRO
    completely if we're invoked through netpoll.  This might seem
    paranoid but as netpoll may have an external receive hook it's
    better to be safe than sorry.  I don't think we need this for
    2.6.29 though since there's nothing immediately broken by it.
    
    This patch also moves the GRO_* return values to netdevice.h since
    VLAN needs them too (I tried to avoid this originally but alas
    this seems to be the easiest way out).  This fixes a bug in VLAN
    where it continued to use the old return value 2 instead of the
    correct GRO_DROP.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index e38d3c9dccda..de99025f2c5d 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -63,6 +63,13 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	return ret;
 }
 
+static inline int netpoll_rx_on(struct sk_buff *skb)
+{
+	struct netpoll_info *npinfo = skb->dev->npinfo;
+
+	return npinfo && (npinfo->rx_np || npinfo->rx_flags);
+}
+
 static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
 	if (!list_empty(&skb->dev->napi_list))
@@ -99,6 +106,10 @@ static inline int netpoll_rx(struct sk_buff *skb)
 {
 	return 0;
 }
+static inline int netpoll_rx_on(struct sk_buff *skb)
+{
+	return 0;
+}
 static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
 	return 0;

commit d565b0a1a9b6ee7dff46e1f68b26b526ac11ae50
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Dec 15 23:38:52 2008 -0800

    net: Add Generic Receive Offload infrastructure
    
    This patch adds the top-level GRO (Generic Receive Offload) infrastructure.
    This is pretty similar to LRO except that this is protocol-independent.
    Instead of holding packets in an lro_mgr structure, they're now held in
    napi_struct.
    
    For drivers that intend to use this, they can set the NETIF_F_GRO bit and
    call napi_gro_receive instead of netif_receive_skb or just call netif_rx.
    The latter will call napi_receive_skb automatically.  When napi_gro_receive
    is used, the driver must either call napi_complete/napi_rx_complete, or
    call napi_gro_flush in softirq context if the driver uses the primitives
    __napi_complete/__napi_rx_complete.
    
    Protocols will set the gro_receive and gro_complete function pointers in
    order to participate in this scheme.
    
    In addition to the packet, gro_receive will get a list of currently held
    packets.  Each packet in the list has a same_flow field which is non-zero
    if it is a potential match for the new packet.  For each packet that may
    match, they also have a flush field which is non-zero if the held packet
    must not be merged with the new packet.
    
    Once gro_receive has determined that the new skb matches a held packet,
    the held packet may be processed immediately if the new skb cannot be
    merged with it.  In this case gro_receive should return the pointer to
    the existing skb in gro_list.  Otherwise the new skb should be merged into
    the existing packet and NULL should be returned, unless the new skb makes
    it impossible for any further merges to be made (e.g., FIN packet) where
    the merged skb should be returned.
    
    Whenever the skb is merged into an existing entry, the gro_receive
    function should set NAPI_GRO_CB(skb)->same_flow.  Note that if an skb
    merely matches an existing entry but can't be merged with it, then
    this shouldn't be set.
    
    If gro_receive finds it pointless to hold the new skb for future merging,
    it should set NAPI_GRO_CB(skb)->flush.
    
    Held packets will be flushed by napi_gro_flush which is called by
    napi_complete and napi_rx_complete.
    
    Currently held packets are stored in a singly liked list just like LRO.
    The list is limited to a maximum of 8 entries.  In future, this may be
    expanded to use a hash table to allow more flows to be held for merging.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index e3d79593fb3a..e38d3c9dccda 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -94,11 +94,6 @@ static inline void netpoll_poll_unlock(void *have)
 	rcu_read_unlock();
 }
 
-static inline void netpoll_netdev_init(struct net_device *dev)
-{
-	INIT_LIST_HEAD(&dev->napi_list);
-}
-
 #else
 static inline int netpoll_rx(struct sk_buff *skb)
 {

commit d9452e9f81e997cbd0c9bface8d2c2a4b064cc3e
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 4 12:28:49 2008 -0800

    [NETPOLL]: Revert two bogus cleanups that broke netconsole.
    
    Based upon a report by Andrew Morton and code analysis done
    by Jarek Poplawski.
    
    This reverts 33f807ba0d9259e7c75c7a2ce8bd2787e5b540c7 ("[NETPOLL]:
    Kill NETPOLL_RX_DROP, set but never tested.")  and
    c7b6ea24b43afb5749cb704e143df19d70e23dea ("[NETPOLL]: Don't need
    rx_flags.").
    
    The rx_flags did get tested for zero vs. non-zero and therefore we do
    need those tests and that code which sets NETPOLL_RX_DROP et al.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index a0525a1f4715..e3d79593fb3a 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -25,6 +25,7 @@ struct netpoll {
 
 struct netpoll_info {
 	atomic_t refcnt;
+	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
 	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
@@ -50,12 +51,12 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	unsigned long flags;
 	int ret = 0;
 
-	if (!npinfo || !npinfo->rx_np)
+	if (!npinfo || (!npinfo->rx_np && !npinfo->rx_flags))
 		return 0;
 
 	spin_lock_irqsave(&npinfo->rx_lock, flags);
-	/* check rx_np again with the lock held */
-	if (npinfo->rx_np && __netpoll_rx(skb))
+	/* check rx_flags again with the lock held */
+	if (npinfo->rx_flags && __netpoll_rx(skb))
 		ret = 1;
 	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
 

commit c7b6ea24b43afb5749cb704e143df19d70e23dea
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Mon Nov 19 19:37:09 2007 -0800

    [NETPOLL]: Don't need rx_flags.
    
    The rx_flags variable is redundant. Turning rx on/off is done
    via setting the rx_np pointer.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index e3d79593fb3a..a0525a1f4715 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -25,7 +25,6 @@ struct netpoll {
 
 struct netpoll_info {
 	atomic_t refcnt;
-	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
 	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
@@ -51,12 +50,12 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	unsigned long flags;
 	int ret = 0;
 
-	if (!npinfo || (!npinfo->rx_np && !npinfo->rx_flags))
+	if (!npinfo || !npinfo->rx_np)
 		return 0;
 
 	spin_lock_irqsave(&npinfo->rx_lock, flags);
-	/* check rx_flags again with the lock held */
-	if (npinfo->rx_flags && __netpoll_rx(skb))
+	/* check rx_np again with the lock held */
+	if (npinfo->rx_np && __netpoll_rx(skb))
 		ret = 1;
 	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
 

commit 0953864160bdd28dfe45fd46fa462b4d2d53cb96
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Mon Nov 19 19:23:29 2007 -0800

    [NETPOLL]: no need to store local_mac
    
    The local_mac is managed by the network device, no need to keep a
    spare copy and all the management problems that could cause.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 20250d963d72..e3d79593fb3a 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -20,7 +20,7 @@ struct netpoll {
 
 	u32 local_ip, remote_ip;
 	u16 local_port, remote_port;
- 	u8 local_mac[ETH_ALEN], remote_mac[ETH_ALEN];
+	u8 remote_mac[ETH_ALEN];
 };
 
 struct netpoll_info {

commit 0bcc1816188e570bde1d56a208996660f2633ae0
Author: Satyam Sharma <satyam@infradead.org>
Date:   Fri Aug 10 15:35:05 2007 -0700

    [NET] netconsole: Support dynamic reconfiguration using configfs
    
    Based upon initial work by Keiichi Kii <k-keiichi@bx.jp.nec.com>.
    
    This patch introduces support for dynamic reconfiguration (adding, removing
    and/or modifying parameters of netconsole targets at runtime) using a
    userspace interface exported via configfs.  Documentation is also updated
    accordingly.
    
    Issues and brief design overview:
    
    (1) Kernel-initiated creation / destruction of kernel objects is not
        possible with configfs -- the lifetimes of the "config items" is managed
        exclusively from userspace.  But netconsole must support boot/module
        params too, and these are parsed in kernel and hence netpolls must be
        setup from the kernel.  Joel Becker suggested to separately manage the
        lifetimes of the two kinds of netconsole_target objects -- those created
        via configfs mkdir(2) from userspace and those specified from the
        boot/module option string.  This adds complexity and some redundancy here
        and also means that boot/module param-created targets are not exposed
        through the configfs namespace (and hence cannot be updated / destroyed
        dynamically).  However, this saves us from locking / refcounting
        complexities that would need to be introduced in configfs to support
        kernel-initiated item creation / destroy there.
    
    (2) In configfs, item creation takes place in the call chain of the
        mkdir(2) syscall in the driver subsystem.  If we used an ioctl(2) to
        create / destroy objects from userspace, the special userspace program is
        able to fill out the structure to be passed into the ioctl and hence
        specify attributes such as local interface that are required at the time
        we set up the netpoll.  For configfs, this information is not available at
        the time of mkdir(2).  So, we keep all newly-created targets (via
        configfs) disabled by default.  The user is expected to set various
        attributes appropriately (including the local network interface if
        required) and then write(2) "1" to the "enabled" attribute.  Thus,
        netpoll_setup() is then called on the set parameters in the context of
        _this_ write(2) on the "enabled" attribute itself.  This design enables
        the user to reconfigure existing netconsole targets at runtime to be
        attached to newly-come-up interfaces that may not have existed when
        netconsole was loaded or when the targets were actually created.  All this
        effectively enables us to get rid of custom ioctls.
    
    (3) Ultra-paranoid configfs attribute show() and store() operations, with
        sanity and input range checking, using only safe string primitives, and
        compliant with the recommendations in Documentation/filesystems/sysfs.txt.
    
    (4) A new function netpoll_print_options() is created in the netpoll API,
        that just prints out the configured parameters for a netpoll structure.
        netpoll_parse_options() is modified to use that and it is also exported to
        be used from netconsole.
    
    Signed-off-by: Satyam Sharma <satyam@infradead.org>
    Acked-by: Keiichi Kii <k-keiichi@bx.jp.nec.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 08dcc39ec18d..20250d963d72 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -35,6 +35,7 @@ struct netpoll_info {
 
 void netpoll_poll(struct netpoll *np);
 void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
+void netpoll_print_options(struct netpoll *np);
 int netpoll_parse_options(struct netpoll *np, char *opt);
 int netpoll_setup(struct netpoll *np);
 int netpoll_trap(void);

commit bea3348eef27e6044b6161fd04c3152215f96411
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Wed Oct 3 16:41:36 2007 -0700

    [NET]: Make NAPI polling independent of struct net_device objects.
    
    Several devices have multiple independant RX queues per net
    device, and some have a single interrupt doorbell for several
    queues.
    
    In either case, it's easier to support layouts like that if the
    structure representing the poll is independant from the net
    device itself.
    
    The signature of the ->poll() call back goes from:
    
            int foo_poll(struct net_device *dev, int *budget)
    
    to
    
            int foo_poll(struct napi_struct *napi, int budget)
    
    The caller is returned the number of RX packets processed (or
    the number of "NAPI credits" consumed if you want to get
    abstract).  The callee no longer messes around bumping
    dev->quota, *budget, etc. because that is all handled in the
    caller upon return.
    
    The napi_struct is to be embedded in the device driver private data
    structures.
    
    Furthermore, it is the driver's responsibility to disable all NAPI
    instances in it's ->stop() device close handler.  Since the
    napi_struct is privatized into the driver's private data structures,
    only the driver knows how to get at all of the napi_struct instances
    it may have per-device.
    
    With lots of help and suggestions from Rusty Russell, Roland Dreier,
    Michael Chan, Jeff Garzik, and Jamal Hadi Salim.
    
    Bug fixes from Thomas Graf, Roland Dreier, Peter Zijlstra,
    Joseph Fannin, Scott Wood, Hans J. Koch, and Michael Chan.
    
    [ Ported to current tree and all drivers converted.  Integrated
      Stephen's follow-on kerneldoc additions, and restored poll_list
      handling to the old style to fix mutual exclusion issues.  -DaveM ]
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 29930b71a9aa..08dcc39ec18d 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -25,8 +25,6 @@ struct netpoll {
 
 struct netpoll_info {
 	atomic_t refcnt;
-	spinlock_t poll_lock;
-	int poll_owner;
 	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
@@ -64,32 +62,61 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	return ret;
 }
 
-static inline void *netpoll_poll_lock(struct net_device *dev)
+static inline int netpoll_receive_skb(struct sk_buff *skb)
 {
+	if (!list_empty(&skb->dev->napi_list))
+		return netpoll_rx(skb);
+	return 0;
+}
+
+static inline void *netpoll_poll_lock(struct napi_struct *napi)
+{
+	struct net_device *dev = napi->dev;
+
 	rcu_read_lock(); /* deal with race on ->npinfo */
-	if (dev->npinfo) {
-		spin_lock(&dev->npinfo->poll_lock);
-		dev->npinfo->poll_owner = smp_processor_id();
-		return dev->npinfo;
+	if (dev && dev->npinfo) {
+		spin_lock(&napi->poll_lock);
+		napi->poll_owner = smp_processor_id();
+		return napi;
 	}
 	return NULL;
 }
 
 static inline void netpoll_poll_unlock(void *have)
 {
-	struct netpoll_info *npi = have;
+	struct napi_struct *napi = have;
 
-	if (npi) {
-		npi->poll_owner = -1;
-		spin_unlock(&npi->poll_lock);
+	if (napi) {
+		napi->poll_owner = -1;
+		spin_unlock(&napi->poll_lock);
 	}
 	rcu_read_unlock();
 }
 
+static inline void netpoll_netdev_init(struct net_device *dev)
+{
+	INIT_LIST_HEAD(&dev->napi_list);
+}
+
 #else
-#define netpoll_rx(a) 0
-#define netpoll_poll_lock(a) NULL
-#define netpoll_poll_unlock(a)
+static inline int netpoll_rx(struct sk_buff *skb)
+{
+	return 0;
+}
+static inline int netpoll_receive_skb(struct sk_buff *skb)
+{
+	return 0;
+}
+static inline void *netpoll_poll_lock(struct napi_struct *napi)
+{
+	return NULL;
+}
+static inline void netpoll_poll_unlock(void *have)
+{
+}
+static inline void netpoll_netdev_init(struct net_device *dev)
+{
+}
 #endif
 
 #endif

commit 6d5aefb8eaa38e44b5b8cf60c812aceafc02d924
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 19:36:26 2006 +0000

    WorkQueue: Fix up arch-specific work items where possible
    
    Fix up arch-specific work items where possible to use the new work_struct and
    delayed_work structs.
    
    Three places that enqueue bits of their stack and then return have been marked
    with #error as this is not permitted.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 2cc9867b1626..29930b71a9aa 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -32,7 +32,7 @@ struct netpoll_info {
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
 	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
 	struct sk_buff_head txq;
-	struct work_struct tx_work;
+	struct delayed_work tx_work;
 };
 
 void netpoll_poll(struct netpoll *np);

commit bf6bce71eae386dbc37f93af7e5ad173450d9945
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 26 15:46:56 2006 -0700

    netpoll header cleanup
    
    As Steve left netpoll beast, hopefully not to return soon.
    He noticed that the header was messy. He straightened it
    up and polished it a little, then waved goodbye.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index b7eb008c43de..2cc9867b1626 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -12,16 +12,15 @@
 #include <linux/rcupdate.h>
 #include <linux/list.h>
 
-struct netpoll;
-
 struct netpoll {
 	struct net_device *dev;
-	char dev_name[16], *name;
+	char dev_name[IFNAMSIZ];
+	const char *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
 
 	u32 local_ip, remote_ip;
 	u16 local_port, remote_port;
-	unsigned char local_mac[6], remote_mac[6];
+ 	u8 local_mac[ETH_ALEN], remote_mac[ETH_ALEN];
 };
 
 struct netpoll_info {

commit 5de4a473bda49554e4e9bd93b78f43c49a7ea69c
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 26 15:46:55 2006 -0700

    netpoll queue cleanup
    
    The beast had a long and not very happy history. At one
    point, a friend (netdump) had asked that he open up a little.
    Well, the friend was long gone now, and the beast had
    this dangling piece hanging (netpoll_queue).
    
    It wasn't hard to stitch the netpoll_queue back in
    where it belonged and make everything tidy.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index c65d12ec7bb0..b7eb008c43de 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -18,7 +18,7 @@ struct netpoll {
 	struct net_device *dev;
 	char dev_name[16], *name;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
-	void (*drop)(struct sk_buff *skb);
+
 	u32 local_ip, remote_ip;
 	u16 local_port, remote_port;
 	unsigned char local_mac[6], remote_mac[6];
@@ -44,7 +44,7 @@ int netpoll_trap(void);
 void netpoll_set_trap(int trap);
 void netpoll_cleanup(struct netpoll *np);
 int __netpoll_rx(struct sk_buff *skb);
-void netpoll_queue(struct sk_buff *skb);
+
 
 #ifdef CONFIG_NETPOLL
 static inline int netpoll_rx(struct sk_buff *skb)

commit 2bdfe0baeca0e2750037b8fba71905c00ac3c515
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 26 15:46:54 2006 -0700

    netpoll retry cleanup
    
    The netpoll beast was still not happy. If the beast got
    clogged pipes, it tended to stare blankly off in space
    for a long time.
    
    The problem couldn't be completely fixed because the
    beast talked with irq's disabled. But it could be made
    less painful and shorter.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 93a8b7664423..c65d12ec7bb0 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -28,7 +28,6 @@ struct netpoll_info {
 	atomic_t refcnt;
 	spinlock_t poll_lock;
 	int poll_owner;
-	int tries;
 	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */

commit b6cd27ed33886a5ffaf0925a6d98e13e18e8a1af
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 26 15:46:51 2006 -0700

    netpoll per device txq
    
    When the netpoll beast got really busy, it tended to clog
    things, so it stored them for later. But the beast was putting
    all it's skb's in one basket. This was bad because maybe some
    pipes were clogged and others were not.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 39845fc975f9..93a8b7664423 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -33,6 +33,8 @@ struct netpoll_info {
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
 	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
+	struct sk_buff_head txq;
+	struct work_struct tx_work;
 };
 
 void netpoll_poll(struct netpoll *np);

commit 93ec2c723e3f8a216dde2899aeb85c648672bc6b
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 26 15:46:50 2006 -0700

    netpoll info leak
    
    After looking harder, Steve noticed that the netpoll
    beast leaked a little every time it shutdown for a nap.
    Not a big leak, but a nuisance kind of thing.
    
    He took out his refcount duct tape and patched the
    leak. It was overkill since there was already other
    locking in that area, but it looked clean and wouldn't
    attract fleas.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 1efe60c5c00c..39845fc975f9 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -25,6 +25,7 @@ struct netpoll {
 };
 
 struct netpoll_info {
+	atomic_t refcnt;
 	spinlock_t poll_lock;
 	int poll_owner;
 	int tries;

commit 068c6e98bc7ec4419299b38cd40be26ebf4bdeda
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Mon Jun 26 00:04:27 2006 -0700

    [NET] netpoll: break recursive loop in netpoll rx path
    
    The netpoll system currently has a rx to tx path via:
    
    netpoll_rx
     __netpoll_rx
      arp_reply
       netpoll_send_skb
        dev->hard_start_tx
    
    This rx->tx loop places network drivers at risk of inadvertently causing a
    deadlock or BUG halt by recursively trying to acquire a spinlock that is
    used in both their rx and tx paths (this problem was origionally reported
    to me in the 3c59x driver, which shares a spinlock between the
    boomerang_interrupt and boomerang_start_xmit routines).
    
    This patch breaks this loop, by queueing arp frames, so that they can be
    responded to after all receive operations have been completed.  Tested by
    myself and the reported with successful results.
    
    Specifically it was tested with netdump.  Heres the BZ with details:
    https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=194055
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index ca5a8733000f..1efe60c5c00c 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -31,6 +31,7 @@ struct netpoll_info {
 	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
+	struct sk_buff_head arp_tx; /* list of arp requests to reply to */
 };
 
 void netpoll_poll(struct netpoll *np);

commit afb997c6163b33292d31a09d6aa5cbb03ffa5bf1
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Oct 12 15:12:21 2005 -0700

    [NETPOLL]: wrong return for null netpoll_poll_lock()
    
    When netpoll is not being used, the macro that
    defines the removed routing netpoll_poll_lock
    defines the return as zero, but the real
    routine returns a `void *`
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 5ade54a78dbb..ca5a8733000f 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -86,7 +86,7 @@ static inline void netpoll_poll_unlock(void *have)
 
 #else
 #define netpoll_rx(a) 0
-#define netpoll_poll_lock(a) 0
+#define netpoll_poll_lock(a) NULL
 #define netpoll_poll_unlock(a)
 #endif
 

commit 53fb95d3c14290fd6ee808b221e35493f096246f
Author: Matt Mackall <mpm@selenic.com>
Date:   Thu Aug 11 19:27:43 2005 -0700

    [NETPOLL]: fix initialization/NAPI race
    
    This fixes a race during initialization with the NAPI softirq
    processing by using an RCU approach.
    
    This race was discovered when refill_skbs() was added to
    the setup code.
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index be68d94b03d5..5ade54a78dbb 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -9,6 +9,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/interrupt.h>
+#include <linux/rcupdate.h>
 #include <linux/list.h>
 
 struct netpoll;
@@ -61,25 +62,31 @@ static inline int netpoll_rx(struct sk_buff *skb)
 	return ret;
 }
 
-static inline void netpoll_poll_lock(struct net_device *dev)
+static inline void *netpoll_poll_lock(struct net_device *dev)
 {
+	rcu_read_lock(); /* deal with race on ->npinfo */
 	if (dev->npinfo) {
 		spin_lock(&dev->npinfo->poll_lock);
 		dev->npinfo->poll_owner = smp_processor_id();
+		return dev->npinfo;
 	}
+	return NULL;
 }
 
-static inline void netpoll_poll_unlock(struct net_device *dev)
+static inline void netpoll_poll_unlock(void *have)
 {
-	if (dev->npinfo) {
-		dev->npinfo->poll_owner = -1;
-		spin_unlock(&dev->npinfo->poll_lock);
+	struct netpoll_info *npi = have;
+
+	if (npi) {
+		npi->poll_owner = -1;
+		spin_unlock(&npi->poll_lock);
 	}
+	rcu_read_unlock();
 }
 
 #else
 #define netpoll_rx(a) 0
-#define netpoll_poll_lock(a)
+#define netpoll_poll_lock(a) 0
 #define netpoll_poll_unlock(a)
 #endif
 

commit 0db1d6fc1ea051af49ebe03c503d23996a7c5bbb
Author: Matt Mackall <mpm@selenic.com>
Date:   Thu Aug 11 19:25:54 2005 -0700

    [NETPOLL]: add retry timeout
    
    Add limited retry logic to netpoll_send_skb
    
    Each time we attempt to send, decrement our per-device retry counter.
    On every successful send, we reset the counter.
    
    We delay 50us between attempts with up to 20000 retries for a total of
    1 second. After we've exhausted our retries, subsequent failed
    attempts will try only once until reset by success.
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index bcd0ac33f592..be68d94b03d5 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -26,6 +26,7 @@ struct netpoll {
 struct netpoll_info {
 	spinlock_t poll_lock;
 	int poll_owner;
+	int tries;
 	int rx_flags;
 	spinlock_t rx_lock;
 	struct netpoll *rx_np; /* netpoll that registered an rx_hook */

commit fbeec2e1552949002065435c9829dc244ad85407
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Wed Jun 22 22:05:59 2005 -0700

    [NETPOLL]: allow multiple netpoll_clients to register against one interface
    
    This patch provides support for registering multiple netpoll clients to the
    same network device.  Only one of these clients may register an rx_hook,
    however.  In practice, this restriction has not been problematic.  It is
    worth mentioning, though, that the current design can be easily extended to
    allow for the registration of multiple rx_hooks.
    
    The basic idea of the patch is that the rx_np pointer in the netpoll_info
    structure points to the struct netpoll that has rx_hook filled in.  Aside
    from this one case, there is no need for a pointer from the struct
    net_device to an individual struct netpoll.
    
    A lock is introduced to protect the setting and clearing of the np_rx
    pointer.  The pointer will only be cleared upon netpoll client module
    removal, and the lock should be uncontested.
    
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 388cd91bc7a6..bcd0ac33f592 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -27,7 +27,8 @@ struct netpoll_info {
 	spinlock_t poll_lock;
 	int poll_owner;
 	int rx_flags;
-	struct netpoll *np;
+	spinlock_t rx_lock;
+	struct netpoll *rx_np; /* netpoll that registered an rx_hook */
 };
 
 void netpoll_poll(struct netpoll *np);
@@ -44,11 +45,19 @@ void netpoll_queue(struct sk_buff *skb);
 static inline int netpoll_rx(struct sk_buff *skb)
 {
 	struct netpoll_info *npinfo = skb->dev->npinfo;
+	unsigned long flags;
+	int ret = 0;
 
-	if (!npinfo || !npinfo->rx_flags)
+	if (!npinfo || (!npinfo->rx_np && !npinfo->rx_flags))
 		return 0;
 
-	return npinfo->np && __netpoll_rx(skb);
+	spin_lock_irqsave(&npinfo->rx_lock, flags);
+	/* check rx_flags again with the lock held */
+	if (npinfo->rx_flags && __netpoll_rx(skb))
+		ret = 1;
+	spin_unlock_irqrestore(&npinfo->rx_lock, flags);
+
+	return ret;
 }
 
 static inline void netpoll_poll_lock(struct net_device *dev)

commit 115c1d6e61b70851d9a363328c3b8d4c2559a1d3
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Wed Jun 22 22:05:31 2005 -0700

    [NETPOLL]: Introduce a netpoll_info struct
    
    This patch introduces a netpoll_info structure, which the struct net_device
    will now point to instead of pointing to a struct netpoll.  The reason for
    this is two-fold: 1) fields such as the rx_flags, poll_owner, and poll_lock
    should be maintained per net_device, not per netpoll;  and 2) this is a first
    step in providing support for multiple netpoll clients to register against the
    same net_device.
    
    The struct netpoll is now pointed to by the netpoll_info structure.  As
    such, the previous behaviour of the code is preserved.
    
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index 449a4fde6587..388cd91bc7a6 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -16,14 +16,18 @@ struct netpoll;
 struct netpoll {
 	struct net_device *dev;
 	char dev_name[16], *name;
-	int rx_flags;
 	void (*rx_hook)(struct netpoll *, int, char *, int);
 	void (*drop)(struct sk_buff *skb);
 	u32 local_ip, remote_ip;
 	u16 local_port, remote_port;
 	unsigned char local_mac[6], remote_mac[6];
+};
+
+struct netpoll_info {
 	spinlock_t poll_lock;
 	int poll_owner;
+	int rx_flags;
+	struct netpoll *np;
 };
 
 void netpoll_poll(struct netpoll *np);
@@ -39,22 +43,27 @@ void netpoll_queue(struct sk_buff *skb);
 #ifdef CONFIG_NETPOLL
 static inline int netpoll_rx(struct sk_buff *skb)
 {
-	return skb->dev->np && skb->dev->np->rx_flags && __netpoll_rx(skb);
+	struct netpoll_info *npinfo = skb->dev->npinfo;
+
+	if (!npinfo || !npinfo->rx_flags)
+		return 0;
+
+	return npinfo->np && __netpoll_rx(skb);
 }
 
 static inline void netpoll_poll_lock(struct net_device *dev)
 {
-	if (dev->np) {
-		spin_lock(&dev->np->poll_lock);
-		dev->np->poll_owner = smp_processor_id();
+	if (dev->npinfo) {
+		spin_lock(&dev->npinfo->poll_lock);
+		dev->npinfo->poll_owner = smp_processor_id();
 	}
 }
 
 static inline void netpoll_poll_unlock(struct net_device *dev)
 {
-	if (dev->np) {
-		dev->np->poll_owner = -1;
-		spin_unlock(&dev->np->poll_lock);
+	if (dev->npinfo) {
+		dev->npinfo->poll_owner = -1;
+		spin_unlock(&dev->npinfo->poll_lock);
 	}
 }
 

commit 6ca4f65e6b390d09e1de7280cf9fd4f5d8e4b48b
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Wed Jun 22 22:04:55 2005 -0700

    [NETPOLL]: Set poll_owner to -1 before unlocking in netpoll_poll_unlock()
    
    This trivial patch moves the assignment of poll_owner to -1 inside of
    the lock.  This fixes a potential SMP race in the code.
    
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
index c0d8b90c5202..449a4fde6587 100644
--- a/include/linux/netpoll.h
+++ b/include/linux/netpoll.h
@@ -53,8 +53,8 @@ static inline void netpoll_poll_lock(struct net_device *dev)
 static inline void netpoll_poll_unlock(struct net_device *dev)
 {
 	if (dev->np) {
-		spin_unlock(&dev->np->poll_lock);
 		dev->np->poll_owner = -1;
+		spin_unlock(&dev->np->poll_lock);
 	}
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/netpoll.h b/include/linux/netpoll.h
new file mode 100644
index 000000000000..c0d8b90c5202
--- /dev/null
+++ b/include/linux/netpoll.h
@@ -0,0 +1,67 @@
+/*
+ * Common code for low-level network console, dump, and debugger code
+ *
+ * Derived from netconsole, kgdb-over-ethernet, and netdump patches
+ */
+
+#ifndef _LINUX_NETPOLL_H
+#define _LINUX_NETPOLL_H
+
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+
+struct netpoll;
+
+struct netpoll {
+	struct net_device *dev;
+	char dev_name[16], *name;
+	int rx_flags;
+	void (*rx_hook)(struct netpoll *, int, char *, int);
+	void (*drop)(struct sk_buff *skb);
+	u32 local_ip, remote_ip;
+	u16 local_port, remote_port;
+	unsigned char local_mac[6], remote_mac[6];
+	spinlock_t poll_lock;
+	int poll_owner;
+};
+
+void netpoll_poll(struct netpoll *np);
+void netpoll_send_udp(struct netpoll *np, const char *msg, int len);
+int netpoll_parse_options(struct netpoll *np, char *opt);
+int netpoll_setup(struct netpoll *np);
+int netpoll_trap(void);
+void netpoll_set_trap(int trap);
+void netpoll_cleanup(struct netpoll *np);
+int __netpoll_rx(struct sk_buff *skb);
+void netpoll_queue(struct sk_buff *skb);
+
+#ifdef CONFIG_NETPOLL
+static inline int netpoll_rx(struct sk_buff *skb)
+{
+	return skb->dev->np && skb->dev->np->rx_flags && __netpoll_rx(skb);
+}
+
+static inline void netpoll_poll_lock(struct net_device *dev)
+{
+	if (dev->np) {
+		spin_lock(&dev->np->poll_lock);
+		dev->np->poll_owner = smp_processor_id();
+	}
+}
+
+static inline void netpoll_poll_unlock(struct net_device *dev)
+{
+	if (dev->np) {
+		spin_unlock(&dev->np->poll_lock);
+		dev->np->poll_owner = -1;
+	}
+}
+
+#else
+#define netpoll_rx(a) 0
+#define netpoll_poll_lock(a)
+#define netpoll_poll_unlock(a)
+#endif
+
+#endif
