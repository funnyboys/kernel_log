commit 3e2ffd655cc6a694608d997738989ff5572a8266
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed Jan 2 15:57:49 2019 -0500

    include/linux/compiler*.h: fix OPTIMIZER_HIDE_VAR
    
    Since commit 815f0ddb346c ("include/linux/compiler*.h: make compiler-*.h
    mutually exclusive") clang no longer reuses the OPTIMIZER_HIDE_VAR macro
    from compiler-gcc - instead it gets the version in
    include/linux/compiler.h.  Unfortunately that version doesn't actually
    prevent compiler from optimizing out the variable.
    
    Fix up by moving the macro out from compiler-gcc.h to compiler.h.
    Compilers without incline asm support will keep working
    since it's protected by an ifdef.
    
    Also fix up comments to match reality since we are no longer overriding
    any macros.
    
    Build-tested with gcc and clang.
    
    Fixes: 815f0ddb346c ("include/linux/compiler*.h: make compiler-*.h mutually exclusive")
    Cc: Eli Friedman <efriedma@codeaurora.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 517bd14e1222..b17f3cd18334 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -5,9 +5,7 @@
 
 #ifdef __ECC
 
-/* Some compiler specific definitions are overwritten here
- * for Intel ECC compiler
- */
+/* Compiler specific definitions for Intel ECC compiler */
 
 #include <asm/intrinsics.h>
 

commit a3f8a30f3f0079c7edfc72e329eee8594fb3e3cb
Author: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
Date:   Thu Aug 30 20:36:59 2018 +0200

    Compiler Attributes: use feature checks instead of version checks
    
    Instead of using version checks per-compiler to define (or not)
    each attribute, use __has_attribute to test for them, following
    the cleanup started with commit 815f0ddb346c
    ("include/linux/compiler*.h: make compiler-*.h mutually exclusive"),
    which is supported on gcc >= 5, clang >= 2.9 and icc >= 17.
    In the meantime, to support 4.6 <= gcc < 5, we implement
    __has_attribute by hand.
    
    All the attributes that can be unconditionally defined and directly
    map to compiler attribute(s) (even if optional) have been moved
    to a new file include/linux/compiler_attributes.h
    
    In an effort to make the file as regular as possible, comments
    stating the purpose of attributes have been removed. Instead,
    links to the compiler docs have been added (i.e. to gcc and,
    if available, to clang as well). In addition, they have been sorted.
    
    Finally, if an attribute is optional (i.e. if it is guarded
    by __has_attribute), the reason has been stated for future reference.
    
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 6004b4588bd4..517bd14e1222 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -34,9 +34,3 @@
 /* icc has this, but it's called _bswap16 */
 #define __HAVE_BUILTIN_BSWAP16__
 #define __builtin_bswap16 _bswap16
-
-/* The following are for compatibility with GCC, from compiler-gcc.h,
- * and may be redefined here because they should not be shared with other
- * compilers, like clang.
- */
-#define __visible	__attribute__((__externally_visible__))

commit ec0bbef66f867854691d5af18c2231d746958e0e
Author: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
Date:   Thu Aug 30 19:25:14 2018 +0200

    Compiler Attributes: homogenize __must_be_array
    
    Different definitions of __must_be_array:
    
      * gcc: disabled for __CHECKER__
    
      * clang: same definition as gcc's, but without __CHECKER__
    
      * intel: the comment claims __builtin_types_compatible_p()
        is unsupported; but icc seems to support it since 13.0.1
        (released in 2012). See https://godbolt.org/z/S0l6QQ
    
    Therefore, we can remove all of them and have a single definition
    in compiler.h
    
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index fef8bb3e53ef..6004b4588bd4 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -29,9 +29,6 @@
  */
 #define OPTIMIZER_HIDE_VAR(var) barrier()
 
-/* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
-#define __must_be_array(a) 0
-
 #endif
 
 /* icc has this, but it's called _bswap16 */

commit 5c67a52f3da0f0d22764f2daec417702695a8112
Author: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
Date:   Thu Aug 30 19:13:37 2018 +0200

    Compiler Attributes: always use the extra-underscores syntax
    
    The attribute syntax optionally allows to surround attribute names
    with "__" in order to avoid collisions with macros of the same name
    (see https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html).
    
    This homogenizes all attributes to use the syntax with underscores.
    While there are currently only a handful of cases of some TUs defining
    macros like "error" which may collide with the attributes,
    this should prevent futures surprises.
    
    This has been done only for "standard" attributes supported by
    the major compilers. In other words, those of third-party tools
    (e.g. sparse, plugins...) have not been changed for the moment.
    
    Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 4c7f9befa9f6..fef8bb3e53ef 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -42,4 +42,4 @@
  * and may be redefined here because they should not be shared with other
  * compilers, like clang.
  */
-#define __visible	__attribute__((externally_visible))
+#define __visible	__attribute__((__externally_visible__))

commit 815f0ddb346c196018d4d8f8f55c12b83da1de3f
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Wed Aug 22 16:37:24 2018 -0700

    include/linux/compiler*.h: make compiler-*.h mutually exclusive
    
    Commit cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
    recently exposed a brittle part of the build for supporting non-gcc
    compilers.
    
    Both Clang and ICC define __GNUC__, __GNUC_MINOR__, and
    __GNUC_PATCHLEVEL__ for quick compatibility with code bases that haven't
    added compiler specific checks for __clang__ or __INTEL_COMPILER.
    
    This is brittle, as they happened to get compatibility by posing as a
    certain version of GCC.  This broke when upgrading the minimal version
    of GCC required to build the kernel, to a version above what ICC and
    Clang claim to be.
    
    Rather than always including compiler-gcc.h then undefining or
    redefining macros in compiler-intel.h or compiler-clang.h, let's
    separate out the compiler specific macro definitions into mutually
    exclusive headers, do more proper compiler detection, and keep shared
    definitions in compiler_types.h.
    
    Fixes: cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
    Reported-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Suggested-by: Eli Friedman <efriedma@codeaurora.org>
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 547cdc920a3c..4c7f9befa9f6 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -14,10 +14,6 @@
 /* Intel ECC compiler doesn't support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
-#undef barrier
-#undef barrier_data
-#undef RELOC_HIDE
-#undef OPTIMIZER_HIDE_VAR
 
 #define barrier() __memory_barrier()
 #define barrier_data(ptr) barrier()
@@ -38,13 +34,12 @@
 
 #endif
 
-#ifndef __HAVE_BUILTIN_BSWAP16__
 /* icc has this, but it's called _bswap16 */
 #define __HAVE_BUILTIN_BSWAP16__
 #define __builtin_bswap16 _bswap16
-#endif
 
-/*
- * icc defines __GNUC__, but does not implement the builtin overflow checkers.
+/* The following are for compatibility with GCC, from compiler-gcc.h,
+ * and may be redefined here because they should not be shared with other
+ * compilers, like clang.
  */
-#undef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
+#define __visible	__attribute__((externally_visible))

commit f0907827a8a9152aedac2833ed1b674a7b2a44f2
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Tue May 8 00:36:27 2018 +0200

    compiler.h: enable builtin overflow checkers and add fallback code
    
    This adds wrappers for the __builtin overflow checkers present in gcc
    5.1+ as well as fallback implementations for earlier compilers. It's not
    that easy to implement the fully generic __builtin_X_overflow(T1 a, T2
    b, T3 *d) in macros, so the fallback code assumes that T1, T2 and T3 are
    the same. We obviously don't want the wrappers to have different
    semantics depending on $GCC_VERSION, so we also insist on that even when
    using the builtins.
    
    There are a few problems with the 'a+b < a' idiom for checking for
    overflow: For signed types, it relies on undefined behaviour and is
    not actually complete (it doesn't check underflow;
    e.g. INT_MIN+INT_MIN == 0 isn't caught). Due to type promotion it
    is wrong for all types (signed and unsigned) narrower than
    int. Similarly, when a and b does not have the same type, there are
    subtle cases like
    
      u32 a;
    
      if (a + sizeof(foo) < a)
        return -EOVERFLOW;
      a += sizeof(foo);
    
    where the test is always false on 64 bit platforms. Add to that that it
    is not always possible to determine the types involved at a glance.
    
    The new overflow.h is somewhat bulky, but that's mostly a result of
    trying to be type-generic, complete (e.g. catching not only overflow
    but also signed underflow) and not relying on undefined behaviour.
    
    Linus is of course right [1] that for unsigned subtraction a-b, the
    right way to check for overflow (underflow) is "b > a" and not
    "__builtin_sub_overflow(a, b, &d)", but that's just one out of six cases
    covered here, and included mostly for completeness.
    
    So is it worth it? I think it is, if nothing else for the documentation
    value of seeing
    
      if (check_add_overflow(a, b, &d))
        return -EGOAWAY;
      do_stuff_with(d);
    
    instead of the open-coded (and possibly wrong and/or incomplete and/or
    UBsan-tickling)
    
      if (a+b < a)
        return -EGOAWAY;
      do_stuff_with(a+b);
    
    While gcc does recognize the 'a+b < a' idiom for testing unsigned add
    overflow, it doesn't do nearly as good for unsigned multiplication
    (there's also no single well-established idiom). So using
    check_mul_overflow in kcalloc and friends may also make gcc generate
    slightly better code.
    
    [1] https://lkml.org/lkml/2015/11/2/658
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index bfa08160db3a..547cdc920a3c 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -44,3 +44,7 @@
 #define __builtin_bswap16 _bswap16
 #endif
 
+/*
+ * icc defines __GNUC__, but does not implement the builtin overflow checkers.
+ */
+#undef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW

commit 8c5db92a705d9e2c986adec475980d1120fa07b4
Merge: ca5d376e1707 e4880bc5dfb1
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Nov 7 10:32:44 2017 +0100

    Merge branch 'linus' into locking/core, to resolve conflicts
    
    Conflicts:
            include/linux/compiler-clang.h
            include/linux/compiler-gcc.h
            include/linux/compiler-intel.h
            include/uapi/linux/stddef.h
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index d4c71132d07f..523d1b74550f 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_COMPILER_H
 #error "Please don't include <linux/compiler-intel.h> directly, include <linux/compiler.h> instead."
 #endif

commit d15155824c5014803d91b829736d249c500bdda6
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Oct 24 11:22:46 2017 +0100

    linux/compiler.h: Split into compiler.h and compiler_types.h
    
    linux/compiler.h is included indirectly by linux/types.h via
    uapi/linux/types.h -> uapi/linux/posix_types.h -> linux/stddef.h
    -> uapi/linux/stddef.h and is needed to provide a proper definition of
    offsetof.
    
    Unfortunately, compiler.h requires a definition of
    smp_read_barrier_depends() for defining lockless_dereference() and soon
    for defining READ_ONCE(), which means that all
    users of READ_ONCE() will need to include asm/barrier.h to avoid splats
    such as:
    
       In file included from include/uapi/linux/stddef.h:1:0,
                        from include/linux/stddef.h:4,
                        from arch/h8300/kernel/asm-offsets.c:11:
       include/linux/list.h: In function 'list_empty':
    >> include/linux/compiler.h:343:2: error: implicit declaration of function 'smp_read_barrier_depends' [-Werror=implicit-function-declaration]
         smp_read_barrier_depends(); /* Enforce dependency ordering from x */ \
         ^
    
    A better alternative is to include asm/barrier.h in linux/compiler.h,
    but this requires a type definition for "bool" on some architectures
    (e.g. x86), which is defined later by linux/types.h. Type "bool" is also
    used directly in linux/compiler.h, so the whole thing is pretty fragile.
    
    This patch splits compiler.h in two: compiler_types.h contains type
    annotations, definitions and the compiler-specific parts, whereas
    compiler.h #includes compiler-types.h and additionally defines macros
    such as {READ,WRITE.ACCESS}_ONCE().
    
    uapi/linux/stddef.h and linux/linkage.h are then moved over to include
    linux/compiler_types.h, which fixes the build for h8 and blackfin.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1508840570-22169-2-git-send-email-will.deacon@arm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index d4c71132d07f..e438ac89c692 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -1,4 +1,4 @@
-#ifndef __LINUX_COMPILER_H
+#ifndef __LINUX_COMPILER_TYPES_H
 #error "Please don't include <linux/compiler-intel.h> directly, include <linux/compiler.h> instead."
 #endif
 

commit b86a50c3b5414eafdbee7f34af4a201a4a7817c2
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Jun 25 15:01:05 2015 -0700

    compiler-intel: fix wrong compiler barrier() macro
    
    Cleanup commit 73679e508201 ("compiler-intel.h: Remove duplicate
    definition") removed the double definition of __memory_barrier()
    intrinsics.
    
    However, in doing so, it also removed the preceding #undef barrier by
    accident, meaning, the actual barrier() macro from compiler-gcc.h with
    inline asm is still in place as __GNUC__ is provided.
    
    Subsequently, barrier() can never be defined as __memory_barrier() from
    compiler.h since it already has a definition in place and if we trust
    the comment in compiler-intel.h, ecc doesn't support gcc specific asm
    statements.
    
    I don't have an ecc at hand (unsure if that's still used in the field?)
    and only found this by accident during code review, a revert of that
    cleanup would be simplest option.
    
    Fixes: 73679e508201 ("compiler-intel.h: Remove duplicate definition")
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Reviewed-by: Pranith Kumar <bobby.prani@gmail.com>
    Cc: Pranith Kumar <bobby.prani@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: mancha security <mancha1@zoho.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 0c9a2f2c2802..d4c71132d07f 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -13,10 +13,12 @@
 /* Intel ECC compiler doesn't support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
+#undef barrier
 #undef barrier_data
 #undef RELOC_HIDE
 #undef OPTIMIZER_HIDE_VAR
 
+#define barrier() __memory_barrier()
 #define barrier_data(ptr) barrier()
 
 #define RELOC_HIDE(ptr, off)					\

commit 7829fb09a2b4268b30dd9bc782fa5ebee278b137
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Apr 30 04:13:52 2015 +0200

    lib: make memzero_explicit more robust against dead store elimination
    
    In commit 0b053c951829 ("lib: memzero_explicit: use barrier instead
    of OPTIMIZER_HIDE_VAR"), we made memzero_explicit() more robust in
    case LTO would decide to inline memzero_explicit() and eventually
    find out it could be elimiated as dead store.
    
    While using barrier() works well for the case of gcc, recent efforts
    from LLVMLinux people suggest to use llvm as an alternative to gcc,
    and there, Stephan found in a simple stand-alone user space example
    that llvm could nevertheless optimize and thus elimitate the memset().
    A similar issue has been observed in the referenced llvm bug report,
    which is regarded as not-a-bug.
    
    Based on some experiments, icc is a bit special on its own, while it
    doesn't seem to eliminate the memset(), it could do so with an own
    implementation, and then result in similar findings as with llvm.
    
    The fix in this patch now works for all three compilers (also tested
    with more aggressive optimization levels). Arguably, in the current
    kernel tree it's more of a theoretical issue, but imho, it's better
    to be pedantic about it.
    
    It's clearly visible with gcc/llvm though, with the below code: if we
    would have used barrier() only here, llvm would have omitted clearing,
    not so with barrier_data() variant:
    
      static inline void memzero_explicit(void *s, size_t count)
      {
        memset(s, 0, count);
        barrier_data(s);
      }
    
      int main(void)
      {
        char buff[20];
        memzero_explicit(buff, sizeof(buff));
        return 0;
      }
    
      $ gcc -O2 test.c
      $ gdb a.out
      (gdb) disassemble main
      Dump of assembler code for function main:
       0x0000000000400400  <+0>: lea   -0x28(%rsp),%rax
       0x0000000000400405  <+5>: movq  $0x0,-0x28(%rsp)
       0x000000000040040e <+14>: movq  $0x0,-0x20(%rsp)
       0x0000000000400417 <+23>: movl  $0x0,-0x18(%rsp)
       0x000000000040041f <+31>: xor   %eax,%eax
       0x0000000000400421 <+33>: retq
      End of assembler dump.
    
      $ clang -O2 test.c
      $ gdb a.out
      (gdb) disassemble main
      Dump of assembler code for function main:
       0x00000000004004f0  <+0>: xorps  %xmm0,%xmm0
       0x00000000004004f3  <+3>: movaps %xmm0,-0x18(%rsp)
       0x00000000004004f8  <+8>: movl   $0x0,-0x8(%rsp)
       0x0000000000400500 <+16>: lea    -0x18(%rsp),%rax
       0x0000000000400505 <+21>: xor    %eax,%eax
       0x0000000000400507 <+23>: retq
      End of assembler dump.
    
    As gcc, clang, but also icc defines __GNUC__, it's sufficient to define
    this in compiler-gcc.h only to be picked up. For a fallback or otherwise
    unsupported compiler, we define it as a barrier. Similarly, for ecc which
    does not support gcc inline asm.
    
    Reference: https://llvm.org/bugs/show_bug.cgi?id=15495
    Reported-by: Stephan Mueller <smueller@chronox.de>
    Tested-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Stephan Mueller <smueller@chronox.de>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Cc: mancha security <mancha1@zoho.com>
    Cc: Mark Charlebois <charlebm@gmail.com>
    Cc: Behan Webster <behanw@converseincode.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index ba147a1727e6..0c9a2f2c2802 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -13,9 +13,12 @@
 /* Intel ECC compiler doesn't support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
+#undef barrier_data
 #undef RELOC_HIDE
 #undef OPTIMIZER_HIDE_VAR
 
+#define barrier_data(ptr) barrier()
+
 #define RELOC_HIDE(ptr, off)					\
   ({ unsigned long __ptr;					\
      __ptr = (unsigned long) (ptr);				\

commit 73679e50820123ebdedc67ebcda4562d1d6e4aba
Author: Pranith Kumar <bobby.prani@gmail.com>
Date:   Tue Apr 15 12:05:22 2014 -0400

    compiler-intel.h: Remove duplicate definition
    
    barrier is already defined as __memory_barrier in compiler.h
    Remove this unnecessary redefinition.
    
    Signed-off-by: Pranith Kumar <bobby.prani@gmail.com>
    Link: http://lkml.kernel.org/r/CAJhHMCAnYPy0%2BqD-1KBnJPLt3XgAjdR12j%2BySSnPgmZcpbE7HQ@mail.gmail.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 5529c5239421..ba147a1727e6 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -13,12 +13,9 @@
 /* Intel ECC compiler doesn't support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
-#undef barrier
 #undef RELOC_HIDE
 #undef OPTIMIZER_HIDE_VAR
 
-#define barrier() __memory_barrier()
-
 #define RELOC_HIDE(ptr, off)					\
   ({ unsigned long __ptr;					\
      __ptr = (unsigned long) (ptr);				\

commit 13c789a6b219aa23f917466c7e630566106b14c2
Merge: 6dd9158ae857 79ba451d66ca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 23 18:11:00 2014 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto update from Herbert Xu:
     "Here is the crypto update for 3.14:
    
       - Improved crypto_memneq helper
       - Use cyprto_memneq in arch-specific crypto code
       - Replaced orphaned DCP driver with Freescale MXS DCP driver
       - Added AVX/AVX2 version of AESNI-GCM encode and decode
       - Added AMD Cryptographic Coprocessor (CCP) driver
       - Misc fixes"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (41 commits)
      crypto: aesni - fix build on x86 (32bit)
      crypto: mxs - Fix sparse non static symbol warning
      crypto: ccp - CCP device enabled/disabled changes
      crypto: ccp - Cleanup hash invocation calls
      crypto: ccp - Change data length declarations to u64
      crypto: ccp - Check for caller result area before using it
      crypto: ccp - Cleanup scatterlist usage
      crypto: ccp - Apply appropriate gfp_t type to memory allocations
      crypto: drivers - Sort drivers/crypto/Makefile
      ARM: mxs: dts: Enable DCP for MXS
      crypto: mxs - Add Freescale MXS DCP driver
      crypto: mxs - Remove the old DCP driver
      crypto: ahash - Fully restore ahash request before completing
      crypto: aesni - fix build on x86 (32bit)
      crypto: talitos - Remove redundant dev_set_drvdata
      crypto: ccp - Remove redundant dev_set_drvdata
      crypto: crypto4xx - Remove redundant dev_set_drvdata
      crypto: caam - simplify and harden key parsing
      crypto: omap-sham - Fix Polling mode for larger blocks
      crypto: tcrypt - Added speed tests for AEAD crypto alogrithms in tcrypt test suite
      ...

commit 503cf95c061a0551eb684da364509297efbe55d9
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Tue Dec 10 14:56:06 2013 -0800

    x86, build, icc: Remove uninitialized_var() from compiler-intel.h
    
    When compiling with icc, <linux/compiler-gcc.h> ends up included
    because the icc environment defines __GNUC__.  Thus, we neither need
    nor want to have this macro defined in both compiler-gcc.h and
    compiler-intel.h, and the fact that they are inconsistent just makes
    the compiler spew warnings.
    
    Reported-by: Sunil K. Pandey <sunil.k.pandey@intel.com>
    Cc: Kevin B. Smith <kevin.b.smith@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Link: http://lkml.kernel.org/n/tip-0mbwou1zt7pafij09b897lg3@git.kernel.org
    Cc: <stable@vger.kernel.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 973ce10c40b6..dc1bd3dcf11f 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -28,8 +28,6 @@
 
 #endif
 
-#define uninitialized_var(x) x
-
 #ifndef __HAVE_BUILTIN_BSWAP16__
 /* icc has this, but it's called _bswap16 */
 #define __HAVE_BUILTIN_BSWAP16__

commit fe8c8a126806fea4465c43d62a1f9d273a572bf5
Author: Cesar Eduardo Barros <cesarb@cesarb.eti.br>
Date:   Mon Nov 25 22:00:41 2013 -0200

    crypto: more robust crypto_memneq
    
    Disabling compiler optimizations can be fragile, since a new
    optimization could be added to -O0 or -Os that breaks the assumptions
    the code is making.
    
    Instead of disabling compiler optimizations, use a dummy inline assembly
    (based on RELOC_HIDE) to block the problematic kinds of optimization,
    while still allowing other optimizations to be applied to the code.
    
    The dummy inline assembly is added after every OR, and has the
    accumulator variable as its input and output. The compiler is forced to
    assume that the dummy inline assembly could both depend on the
    accumulator variable and change the accumulator variable, so it is
    forced to compute the value correctly before the inline assembly, and
    cannot assume anything about its value after the inline assembly.
    
    This change should be enough to make crypto_memneq work correctly (with
    data-independent timing) even if it is inlined at its call sites. That
    can be done later in a followup patch.
    
    Compile-tested on x86_64.
    
    Signed-off-by: Cesar Eduardo Barros <cesarb@cesarb.eti.br>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 973ce10c40b6..e784f5707749 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -15,6 +15,7 @@
  */
 #undef barrier
 #undef RELOC_HIDE
+#undef OPTIMIZER_HIDE_VAR
 
 #define barrier() __memory_barrier()
 
@@ -23,6 +24,12 @@
      __ptr = (unsigned long) (ptr);				\
     (typeof(ptr)) (__ptr + (off)); })
 
+/* This should act as an optimization barrier on var.
+ * Given that this compiler does not have inline assembly, a compiler barrier
+ * is the best we can do.
+ */
+#define OPTIMIZER_HIDE_VAR(var) barrier()
+
 /* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
 #define __must_be_array(a) 0
 

commit cf66bb93e0f75e0a4ba1ec070692618fa028e994
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Dec 3 16:25:40 2012 +0000

    byteorder: allow arch to opt to use GCC intrinsics for byteswapping
    
    Since GCC 4.4, there have been __builtin_bswap32() and __builtin_bswap16()
    intrinsics. A __builtin_bswap16() came a little later (4.6 for PowerPC,
    48 for other platforms).
    
    By using these instead of the inline assembler that most architectures
    have in their __arch_swabXX() macros, we let the compiler see what's
    actually happening. The resulting code should be at least as good, and
    much *better* in the cases where it can be combined with a nearby load
    or store, using a load-and-byteswap or store-and-byteswap instruction
    (e.g. lwbrx/stwbrx on PowerPC, movbe on Atom).
    
    When GCC is sufficiently recent *and* the architecture opts in to using
    the intrinsics by setting CONFIG_ARCH_USE_BUILTIN_BSWAP, they will be
    used in preference to the __arch_swabXX() macros. An architecture which
    does not set ARCH_USE_BUILTIN_BSWAP will continue to use its own
    hand-crafted macros.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index d8e636e5607d..973ce10c40b6 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -29,3 +29,10 @@
 #endif
 
 #define uninitialized_var(x) x
+
+#ifndef __HAVE_BUILTIN_BSWAP16__
+/* icc has this, but it's called _bswap16 */
+#define __HAVE_BUILTIN_BSWAP16__
+#define __builtin_bswap16 _bswap16
+#endif
+

commit 94f582f82a85a941678c80c60a3baa8187c74217
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Tue Oct 16 23:26:11 2007 -0700

    Force erroneous inclusions of compiler-*.h files to be errors
    
    Replace worthless comments with actual preprocessor errors when including
    the wrong versions of the compiler.h files.
    
    [akpm@linux-foundation.org: make it work]
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index b769961e6f23..d8e636e5607d 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -1,4 +1,6 @@
-/* Never include this file directly.  Include <linux/compiler.h> instead.  */
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-intel.h> directly, include <linux/compiler.h> instead."
+#endif
 
 #ifdef __ECC
 

commit c5e631cf65f4d6875efcd571275436f2964a8b48
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sun May 6 14:51:05 2007 -0700

    ARRAY_SIZE: check for type
    
    We can use a gcc extension to ensure that ARRAY_SIZE() is handed an array,
    not a pointer.  This is especially important when code is changed from a
    fixed array to a pointer.  I assume the Intel compiler doesn't support
    __builtin_types_compatible_p.
    
    [jdike@addtoit.com: uml: update UML definition of ARRAY_SIZE]
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index a436eea43912..b769961e6f23 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -21,6 +21,9 @@
      __ptr = (unsigned long) (ptr);				\
     (typeof(ptr)) (__ptr + (off)); })
 
+/* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
+#define __must_be_array(a) 0
+
 #endif
 
 #define uninitialized_var(x) x

commit 9490991482a2091a828d997adbc088e24c310a4d
Author: Borislav Petkov <bbpetkov@yahoo.de>
Date:   Sun May 6 14:49:17 2007 -0700

    Add unitialized_var() macro for suppressing gcc warnings
    
    Introduce a macro for suppressing gcc from generating a warning about a
    probable uninitialized state of a variable.
    
    Example:
    
    -       spinlock_t *ptl;
    +       spinlock_t *uninitialized_var(ptl);
    
    Not a happy solution, but those warnings are obnoxious.
    
    - Using the usual pointlessly-set-it-to-zero approach wastes several
      bytes of text.
    
    - Using a macro means we can (hopefully) do something else if gcc changes
      cause the `x = x' hack to stop working
    
    - Using a macro means that people who are worried about hiding true bugs
      can easily turn it off.
    
    Signed-off-by: Borislav Petkov <bbpetkov@yahoo.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 1d1c3ceaff4e..a436eea43912 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -22,3 +22,5 @@
     (typeof(ptr)) (__ptr + (off)); })
 
 #endif
+
+#define uninitialized_var(x) x

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
new file mode 100644
index 000000000000..1d1c3ceaff4e
--- /dev/null
+++ b/include/linux/compiler-intel.h
@@ -0,0 +1,24 @@
+/* Never include this file directly.  Include <linux/compiler.h> instead.  */
+
+#ifdef __ECC
+
+/* Some compiler specific definitions are overwritten here
+ * for Intel ECC compiler
+ */
+
+#include <asm/intrinsics.h>
+
+/* Intel ECC compiler doesn't support gcc specific asm stmts.
+ * It uses intrinsics to do the equivalent things.
+ */
+#undef barrier
+#undef RELOC_HIDE
+
+#define barrier() __memory_barrier()
+
+#define RELOC_HIDE(ptr, off)					\
+  ({ unsigned long __ptr;					\
+     __ptr = (unsigned long) (ptr);				\
+    (typeof(ptr)) (__ptr + (off)); })
+
+#endif
