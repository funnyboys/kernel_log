commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index a116926598fd..8ae9a95ebf5b 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*  linux/include/linux/clockchips.h
  *
  *  This file contains the structure definitions for clockchips.

commit 8e0931022e12e45bab9afe01e830d697d9c8e73d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 15:30:34 2017 +0200

    Revert "clockevents: Add a clkevt-of mechanism like clksrc-of"
    
    After discussing it, this feature is dropped as it is not considered
    adequate:
    
            https://patchwork.kernel.org/patch/9639317/
    
    There is no user of this macro yet, so there is no impact on the drivers.
    
    This reverts commit 376bc27150f180d9f5eddec6a14117780177589d.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index acc9ce05e5f0..a116926598fd 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -223,13 +223,4 @@ static inline void tick_setup_hrtimer_broadcast(void) { }
 
 #endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
-#define CLOCKEVENT_OF_DECLARE(name, compat, fn) \
-	OF_DECLARE_1_RET(clkevt, name, compat, fn)
-
-#ifdef CONFIG_CLKEVT_PROBE
-extern int clockevent_probe(void);
-#else
-static inline int clockevent_probe(void) { return 0; }
-#endif
-
 #endif /* _LINUX_CLOCKCHIPS_H */

commit 174ddfd5dfbfc2d91a45332f809977050ac3fdc5
Merge: 3cb6653552dd b94bf594cf8e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 1 16:15:18 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "The timer departement delivers:
    
       - more year 2038 rework
    
       - a massive rework of the arm achitected timer
    
       - preparatory patches to allow NTP correction of clock event devices
         to avoid early expiry
    
       - the usual pile of fixes and enhancements all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (91 commits)
      timer/sysclt: Restrict timer migration sysctl values to 0 and 1
      arm64/arch_timer: Mark errata handlers as __maybe_unused
      Clocksource/mips-gic: Remove redundant non devicetree init
      MIPS/Malta: Probe gic-timer via devicetree
      clocksource: Use GENMASK_ULL in definition of CLOCKSOURCE_MASK
      acpi/arm64: Add SBSA Generic Watchdog support in GTDT driver
      clocksource: arm_arch_timer: add GTDT support for memory-mapped timer
      acpi/arm64: Add memory-mapped timer support in GTDT driver
      clocksource: arm_arch_timer: simplify ACPI support code.
      acpi/arm64: Add GTDT table parse driver
      clocksource: arm_arch_timer: split MMIO timer probing.
      clocksource: arm_arch_timer: add structs to describe MMIO timer
      clocksource: arm_arch_timer: move arch_timer_needs_of_probing into DT init call
      clocksource: arm_arch_timer: refactor arch_timer_needs_probing
      clocksource: arm_arch_timer: split dt-only rate handling
      x86/uv/time: Set ->min_delta_ticks and ->max_delta_ticks
      unicore32/time: Set ->min_delta_ticks and ->max_delta_ticks
      um/time: Set ->min_delta_ticks and ->max_delta_ticks
      tile/time: Set ->min_delta_ticks and ->max_delta_ticks
      score/time: Set ->min_delta_ticks and ->max_delta_ticks
      ...

commit 07de36b378a58f1d1426829acf0ab7cf86f651f3
Author: Alexander Kochetkov <al.kochet@gmail.com>
Date:   Wed Mar 22 17:32:49 2017 +0300

    clockevents: Fix syntax error in clkevt-of macro
    
    The patch fix syntax errors introduced by commit 0c8893c9095d
    ("clockevents: Add a clkevt-of mechanism like clksrc-of").
    
    Fixes: 0c8893c9095d ("clockevents: Add a clkevt-of mechanism like clksrc-of")
    Signed-off-by: Alexander Kochetkov <al.kochet@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 5d3053c34fb3..6d7edc3082f9 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -229,7 +229,7 @@ static inline void tick_setup_hrtimer_broadcast(void) { }
 
 #ifdef CONFIG_CLKEVT_PROBE
 extern int clockevent_probe(void);
-#els
+#else
 static inline int clockevent_probe(void) { return 0; }
 #endif
 

commit 0695bd99c0d22bef4d9d4c72cf537b722ba98531
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:04 2017 +0100

    clockevents: Make clockevents_config() static
    
    A clockevent device's rate should be configured before or at registration
    and changed afterwards through clockevents_update_freq() only.
    
    For the configuration at registration, we already have
    clockevents_config_and_register().
    
    Right now, there are no clockevents_config() users outside of the
    clockevents core.
    
    To mitigiate the risk of drivers errorneously reconfiguring their rates
    through clockevents_config() *after* device registration, make
    clockevents_config() static.
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 5d3053c34fb3..eef1569e5cd0 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -182,7 +182,6 @@ extern u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *e
 extern void clockevents_register_device(struct clock_event_device *dev);
 extern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);
 
-extern void clockevents_config(struct clock_event_device *dev, u32 freq);
 extern void clockevents_config_and_register(struct clock_event_device *dev,
 					    u32 freq, unsigned long min_delta,
 					    unsigned long max_delta);

commit 376bc27150f180d9f5eddec6a14117780177589d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Apr 19 08:56:27 2016 +0200

    clockevents: Add a clkevt-of mechanism like clksrc-of
    
    The current code uses the CLOCKSOURCE_OF_DECLARE macro to fill the clksrc
    table with a t-uple (name, init_function).
    
    Unfortunately it ends up to the clockevent and the clocksource being
    both initialized with this macro. It is not a problem by itself but there
    is not a clear distinction between a clockevent and a clocksource in the
    code initialization path. Somebody can argue there are the same IP block
    and the same DT node. But conceptually from the software side, there are
    two distincts entities and as is they should be initialized separetely.
    Some drivers which do not have a clocksource end up by using the
    CLOCKSOURCE_OF_DECLARE macro to declare a clockevent.
    
    Another result is the fuzzy organization in the clocksource directory,
    where the clockevents are implemented in the same file than the
    clocksources or file labelled timer-something implementing a clocksource.
    
    This patch provides another macro to specifically declare a clockevent in
    the same way than the clocksource and gives the opportunity to write two
    separate drivers, one for the clocksource and another for the clockevents.
    
    Hopefully, that can help to do some housework in the directory, perhaps
    split the drivers in to entities, for example:
            - clksrc-rockchip.c
            - clkevt-rockchip.c
    
    Also, it gives the possibility to declare clocksources separately in the
    DT and then use a clocksource from IP block while while clockevents are
    used from another IP block.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 0d442e34c349..5d3053c34fb3 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -224,4 +224,13 @@ static inline void tick_setup_hrtimer_broadcast(void) { }
 
 #endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
+#define CLOCKEVENT_OF_DECLARE(name, compat, fn) \
+	OF_DECLARE_1_RET(clkevt, name, compat, fn)
+
+#ifdef CONFIG_CLKEVT_PROBE
+extern int clockevent_probe(void);
+#els
+static inline int clockevent_probe(void) { return 0; }
+#endif
+
 #endif /* _LINUX_CLOCKCHIPS_H */

commit dd42ac8f02aea32661756554aace2095f7181d34
Author: Alexander Kuleshov <kuleshovmail@gmail.com>
Date:   Fri Oct 16 15:20:53 2015 +0600

    clockevents: Rename last parameter of clocks_calc_mult_shift() to maxsec
    
    Last parameter of the clocks_calc_mult_shift() was renamed from minsec to
    maxsec in the 5fdade95 (time: Rename misnamed minsec argument of
    clocks_calc_mult_shift()).
    
    Signed-off-by: Alexander Kuleshov <kuleshovmail@gmail.com>
    Link: http://lkml.kernel.org/r/1444987253-11018-1-git-send-email-kuleshovmail@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index bdcf358dfce2..0d442e34c349 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -190,9 +190,9 @@ extern void clockevents_config_and_register(struct clock_event_device *dev,
 extern int clockevents_update_freq(struct clock_event_device *ce, u32 freq);
 
 static inline void
-clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
+clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 maxsec)
 {
-	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC, freq, minsec);
+	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC, freq, maxsec);
 }
 
 extern void clockevents_suspend(void);

commit eef7635a22f6b144206b5ca2f1398f637acffc4d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Sep 11 09:34:26 2015 +0530

    clockevents: Remove unused set_mode() callback
    
    All users are migrated to the per-state callbacks, get rid of the
    unused interface and the core support code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linaro-kernel@lists.linaro.org
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/fd60de14cf6d125489c031207567bb255ad946f6.1441943991.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 31ce435981fe..bdcf358dfce2 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -18,15 +18,6 @@
 struct clock_event_device;
 struct module;
 
-/* Clock event mode commands for legacy ->set_mode(): OBSOLETE */
-enum clock_event_mode {
-	CLOCK_EVT_MODE_UNUSED,
-	CLOCK_EVT_MODE_SHUTDOWN,
-	CLOCK_EVT_MODE_PERIODIC,
-	CLOCK_EVT_MODE_ONESHOT,
-	CLOCK_EVT_MODE_RESUME,
-};
-
 /*
  * Possible states of a clock event device.
  *
@@ -86,16 +77,14 @@ enum clock_event_state {
  * @min_delta_ns:	minimum delta value in ns
  * @mult:		nanosecond to cycles multiplier
  * @shift:		nanoseconds to cycles divisor (power of two)
- * @mode:		operating mode, relevant only to ->set_mode(), OBSOLETE
  * @state_use_accessors:current state of the device, assigned by the core code
  * @features:		features
  * @retries:		number of forced programming retries
- * @set_mode:		legacy set mode function, only for modes <= CLOCK_EVT_MODE_RESUME.
- * @set_state_periodic:	switch state to periodic, if !set_mode
- * @set_state_oneshot:	switch state to oneshot, if !set_mode
- * @set_state_oneshot_stopped: switch state to oneshot_stopped, if !set_mode
- * @set_state_shutdown:	switch state to shutdown, if !set_mode
- * @tick_resume:	resume clkevt device, if !set_mode
+ * @set_state_periodic:	switch state to periodic
+ * @set_state_oneshot:	switch state to oneshot
+ * @set_state_oneshot_stopped: switch state to oneshot_stopped
+ * @set_state_shutdown:	switch state to shutdown
+ * @tick_resume:	resume clkevt device
  * @broadcast:		function to broadcast events
  * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
  * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
@@ -116,18 +105,10 @@ struct clock_event_device {
 	u64			min_delta_ns;
 	u32			mult;
 	u32			shift;
-	enum clock_event_mode	mode;
 	enum clock_event_state	state_use_accessors;
 	unsigned int		features;
 	unsigned long		retries;
 
-	/*
-	 * State transition callback(s): Only one of the two groups should be
-	 * defined:
-	 * - set_mode(), only for modes <= CLOCK_EVT_MODE_RESUME.
-	 * - set_state_{shutdown|periodic|oneshot|oneshot_stopped}(), tick_resume().
-	 */
-	void			(*set_mode)(enum clock_event_mode mode, struct clock_event_device *);
 	int			(*set_state_periodic)(struct clock_event_device *);
 	int			(*set_state_oneshot)(struct clock_event_device *);
 	int			(*set_state_oneshot_stopped)(struct clock_event_device *);

commit 87dc11220df266d7d4b6dc594b55d0729b92809d
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 15 11:21:40 2015 -0700

    clockevents: Remove clockevents_notify() prototype
    
    This function no longer exists after commit a49b116dcb12
    (clockevents: Cleanup dead cpu explicitely, 2015-04-03). Remove
    the prototype and the stub function.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: trivial@kernel.org
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Link: http://lkml.kernel.org/r/1436984500-5425-1-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 597a1e836f22..31ce435981fe 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -234,13 +234,10 @@ static inline int tick_check_broadcast_expired(void) { return 0; }
 static inline void tick_setup_hrtimer_broadcast(void) { }
 # endif
 
-extern int clockevents_notify(unsigned long reason, void *arg);
-
 #else /* !CONFIG_GENERIC_CLOCKEVENTS: */
 
 static inline void clockevents_suspend(void) { }
 static inline void clockevents_resume(void) { }
-static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
 static inline void tick_setup_hrtimer_broadcast(void) { }
 

commit be3ef76e9d9b97962c70bd6351787d29071ae481
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 2 14:30:11 2015 +0200

    clockevents: Rename state to state_use_accessors
    
    The only sensible way to make abuse of core internal fields obvious
    and easy to grep for.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 64214ad85af9..597a1e836f22 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -87,7 +87,7 @@ enum clock_event_state {
  * @mult:		nanosecond to cycles multiplier
  * @shift:		nanoseconds to cycles divisor (power of two)
  * @mode:		operating mode, relevant only to ->set_mode(), OBSOLETE
- * @state:		current state of the device, assigned by the core code
+ * @state_use_accessors:current state of the device, assigned by the core code
  * @features:		features
  * @retries:		number of forced programming retries
  * @set_mode:		legacy set mode function, only for modes <= CLOCK_EVT_MODE_RESUME.
@@ -117,7 +117,7 @@ struct clock_event_device {
 	u32			mult;
 	u32			shift;
 	enum clock_event_mode	mode;
-	enum clock_event_state	state;
+	enum clock_event_state	state_use_accessors;
 	unsigned int		features;
 	unsigned long		retries;
 
@@ -152,27 +152,27 @@ struct clock_event_device {
 /* Helpers to verify state of a clockevent device */
 static inline bool clockevent_state_detached(struct clock_event_device *dev)
 {
-	return dev->state == CLOCK_EVT_STATE_DETACHED;
+	return dev->state_use_accessors == CLOCK_EVT_STATE_DETACHED;
 }
 
 static inline bool clockevent_state_shutdown(struct clock_event_device *dev)
 {
-	return dev->state == CLOCK_EVT_STATE_SHUTDOWN;
+	return dev->state_use_accessors == CLOCK_EVT_STATE_SHUTDOWN;
 }
 
 static inline bool clockevent_state_periodic(struct clock_event_device *dev)
 {
-	return dev->state == CLOCK_EVT_STATE_PERIODIC;
+	return dev->state_use_accessors == CLOCK_EVT_STATE_PERIODIC;
 }
 
 static inline bool clockevent_state_oneshot(struct clock_event_device *dev)
 {
-	return dev->state == CLOCK_EVT_STATE_ONESHOT;
+	return dev->state_use_accessors == CLOCK_EVT_STATE_ONESHOT;
 }
 
 static inline bool clockevent_state_oneshot_stopped(struct clock_event_device *dev)
 {
-	return dev->state == CLOCK_EVT_STATE_ONESHOT_STOPPED;
+	return dev->state_use_accessors == CLOCK_EVT_STATE_ONESHOT_STOPPED;
 }
 
 /*

commit 3434d23b694e5cb6e44e966914563406c31c4053
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 21 13:33:45 2015 +0530

    clockevents: Add helpers to check the state of a clockevent device
    
    Some clockevent drivers, once migrated to use per-state callbacks,
    need to check the state of the clockevent device in their callbacks or
    interrupt handler.
    
    Add accessor functions clockevent_state_*() to get this information.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/04a717d490335c688dd7af899fbcede97e1bb8ee.1432192527.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 271fa4c8eb29..64214ad85af9 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -149,6 +149,32 @@ struct clock_event_device {
 	struct module		*owner;
 } ____cacheline_aligned;
 
+/* Helpers to verify state of a clockevent device */
+static inline bool clockevent_state_detached(struct clock_event_device *dev)
+{
+	return dev->state == CLOCK_EVT_STATE_DETACHED;
+}
+
+static inline bool clockevent_state_shutdown(struct clock_event_device *dev)
+{
+	return dev->state == CLOCK_EVT_STATE_SHUTDOWN;
+}
+
+static inline bool clockevent_state_periodic(struct clock_event_device *dev)
+{
+	return dev->state == CLOCK_EVT_STATE_PERIODIC;
+}
+
+static inline bool clockevent_state_oneshot(struct clock_event_device *dev)
+{
+	return dev->state == CLOCK_EVT_STATE_ONESHOT;
+}
+
+static inline bool clockevent_state_oneshot_stopped(struct clock_event_device *dev)
+{
+	return dev->state == CLOCK_EVT_STATE_ONESHOT_STOPPED;
+}
+
 /*
  * Calculate a multiplication factor for scaled math, which is used to convert
  * nanoseconds based values to clock ticks:

commit 8fff52fd50934580c5108afed12043a774edf728
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 3 09:04:04 2015 +0530

    clockevents: Introduce CLOCK_EVT_STATE_ONESHOT_STOPPED state
    
    When no timers/hrtimers are pending, the expiry time is set to a
    special value: 'KTIME_MAX'. This normally happens with
    NO_HZ_{IDLE|FULL} in both LOWRES/HIGHRES modes.
    
    When 'expiry == KTIME_MAX', we either cancel the 'tick-sched' hrtimer
    (NOHZ_MODE_HIGHRES) or skip reprogramming clockevent device
    (NOHZ_MODE_LOWRES).  But, the clockevent device is already
    reprogrammed from the tick-handler for next tick.
    
    As the clock event device is programmed in ONESHOT mode it will at
    least fire one more time (unnecessarily). Timers on few
    implementations (like arm_arch_timer, etc.) only support PERIODIC mode
    and their drivers emulate ONESHOT over that. Which means that on these
    platforms we will get spurious interrupts periodically (at last
    programmed interval rate, normally tick rate).
    
    In order to avoid spurious interrupts, the clockevent device should be
    stopped or its interrupts should be masked.
    
    A simple (yet hacky) solution to get this fixed could be: update
    hrtimer_force_reprogram() to always reprogram clockevent device and
    update clockevent drivers to STOP generating events (or delay it to
    max time) when 'expires' is set to KTIME_MAX. But the drawback here is
    that every clockevent driver has to be hacked for this particular case
    and its very easy for new ones to miss this.
    
    However, Thomas suggested to add an optional state ONESHOT_STOPPED to
    solve this problem: lkml.org/lkml/2014/5/9/508.
    
    This patch adds support for ONESHOT_STOPPED state in clockevents
    core. It will only be available to drivers that implement the
    state-specific callbacks instead of the legacy ->set_mode() callback.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Preeti U. Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/b8b383a03ac07b13312c16850b5106b82e4245b5.1428031396.git.viresh.kumar@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 96c280b2c263..271fa4c8eb29 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -37,12 +37,15 @@ enum clock_event_mode {
  *		reached from DETACHED or SHUTDOWN.
  * ONESHOT:	Device is programmed to generate event only once. Can be reached
  *		from DETACHED or SHUTDOWN.
+ * ONESHOT_STOPPED: Device was programmed in ONESHOT mode and is temporarily
+ *		    stopped.
  */
 enum clock_event_state {
 	CLOCK_EVT_STATE_DETACHED,
 	CLOCK_EVT_STATE_SHUTDOWN,
 	CLOCK_EVT_STATE_PERIODIC,
 	CLOCK_EVT_STATE_ONESHOT,
+	CLOCK_EVT_STATE_ONESHOT_STOPPED,
 };
 
 /*
@@ -90,6 +93,7 @@ enum clock_event_state {
  * @set_mode:		legacy set mode function, only for modes <= CLOCK_EVT_MODE_RESUME.
  * @set_state_periodic:	switch state to periodic, if !set_mode
  * @set_state_oneshot:	switch state to oneshot, if !set_mode
+ * @set_state_oneshot_stopped: switch state to oneshot_stopped, if !set_mode
  * @set_state_shutdown:	switch state to shutdown, if !set_mode
  * @tick_resume:	resume clkevt device, if !set_mode
  * @broadcast:		function to broadcast events
@@ -121,11 +125,12 @@ struct clock_event_device {
 	 * State transition callback(s): Only one of the two groups should be
 	 * defined:
 	 * - set_mode(), only for modes <= CLOCK_EVT_MODE_RESUME.
-	 * - set_state_{shutdown|periodic|oneshot}(), tick_resume().
+	 * - set_state_{shutdown|periodic|oneshot|oneshot_stopped}(), tick_resume().
 	 */
 	void			(*set_mode)(enum clock_event_mode mode, struct clock_event_device *);
 	int			(*set_state_periodic)(struct clock_event_device *);
 	int			(*set_state_oneshot)(struct clock_event_device *);
+	int			(*set_state_oneshot_stopped)(struct clock_event_device *);
 	int			(*set_state_shutdown)(struct clock_event_device *);
 	int			(*tick_resume)(struct clock_event_device *);
 

commit a49b116dcb1265f238f3169507424257b0519069
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:38:05 2015 +0200

    clockevents: Cleanup dead cpu explicitely
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the cleanup function for a dead cpu and invoke it
    directly from the cpu down code. Make it conditional on
    CPU_HOTPLUG as well.
    
    Temporary change, will be refined in the future.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebased, added clockevents_notify() removal ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1735025.raBZdQHM3m@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index f4bde22f8a05..96c280b2c263 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -8,12 +8,6 @@
 #ifndef _LINUX_CLOCKCHIPS_H
 #define _LINUX_CLOCKCHIPS_H
 
-/* Clock event notification values */
-enum clock_event_nofitiers {
-	CLOCK_EVT_NOTIFY_ADD,
-	CLOCK_EVT_NOTIFY_CPU_DEAD,
-};
-
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 
 # include <linux/clocksource.h>

commit 52c063d1adbc16c76e70fffa20727fcd4e9343b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:37:24 2015 +0200

    clockevents: Make tick handover explicit
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call. We are way better off to have explicit
    calls instead of this monstrosity.
    
    Split out the tick_handover call and invoke it explicitely from
    the hotplug code. Temporary solution will be cleaned up in later
    patches.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebase ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/1658173.RkEEILFiQZ@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index f97f498a5d10..f4bde22f8a05 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -11,7 +11,6 @@
 /* Clock event notification values */
 enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_ADD,
-	CLOCK_EVT_NOTIFY_CPU_DYING,
 	CLOCK_EVT_NOTIFY_CPU_DEAD,
 };
 

commit ffa48c0d76803057ee89bf220305466d74256d7b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 3 02:36:10 2015 +0200

    clockevents: Remove broadcast oneshot control leftovers
    
    Now that all users are converted over to explicit calls into the
    clockevents state machine, remove the notification chain leftovers.
    
    Original-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/14018863.NQUzkFuafr@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 438fafa75067..f97f498a5d10 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -11,8 +11,6 @@
 /* Clock event notification values */
 enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_ADD,
-	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
-	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
 	CLOCK_EVT_NOTIFY_CPU_DYING,
 	CLOCK_EVT_NOTIFY_CPU_DEAD,
 };

commit 89feddbfe7023ccfb4a6d7f5e3f5161d91b28b18
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Apr 3 02:03:42 2015 +0200

    clockevents: Remove the broadcast control leftovers
    
    All users converted. Remove the notify leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/2076318.76XJZ8QYP3@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index caeca76d7b32..438fafa75067 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -11,9 +11,6 @@
 /* Clock event notification values */
 enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_ADD,
-	CLOCK_EVT_NOTIFY_BROADCAST_ON,
-	CLOCK_EVT_NOTIFY_BROADCAST_OFF,
-	CLOCK_EVT_NOTIFY_BROADCAST_FORCE,
 	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
 	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
 	CLOCK_EVT_NOTIFY_CPU_DYING,

commit 9eed56e889d8a0bb7870e1216d8d4326dd63ec50
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Apr 2 11:26:23 2015 +0200

    clockevents: Clean up clockchips.h
    
    Do various cleanups on the clockchips.h file:
    
     - indent preprocessor blocks to make it more clear which block we are in,
       this also makes merge resolution easier
    
     - comment larger preprocessor blocks consistently, using the:
    
         #if FOO
         ...
         #else /* !FOO: */
         ...
         #endif /* !FOO */
    
       notation.
    
     - unbreak lines
    
     - etc.
    
    No change in functionality.
    
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 3ac7e2d90374..caeca76d7b32 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -22,17 +22,17 @@ enum clock_event_nofitiers {
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 
-#include <linux/clocksource.h>
-#include <linux/cpumask.h>
-#include <linux/ktime.h>
-#include <linux/notifier.h>
+# include <linux/clocksource.h>
+# include <linux/cpumask.h>
+# include <linux/ktime.h>
+# include <linux/notifier.h>
 
 struct clock_event_device;
 struct module;
 
 /* Clock event mode commands for legacy ->set_mode(): OBSOLETE */
 enum clock_event_mode {
-	CLOCK_EVT_MODE_UNUSED = 0,
+	CLOCK_EVT_MODE_UNUSED,
 	CLOCK_EVT_MODE_SHUTDOWN,
 	CLOCK_EVT_MODE_PERIODIC,
 	CLOCK_EVT_MODE_ONESHOT,
@@ -51,7 +51,7 @@ enum clock_event_mode {
  *		from DETACHED or SHUTDOWN.
  */
 enum clock_event_state {
-	CLOCK_EVT_STATE_DETACHED = 0,
+	CLOCK_EVT_STATE_DETACHED,
 	CLOCK_EVT_STATE_SHUTDOWN,
 	CLOCK_EVT_STATE_PERIODIC,
 	CLOCK_EVT_STATE_ONESHOT,
@@ -60,28 +60,29 @@ enum clock_event_state {
 /*
  * Clock event features
  */
-#define CLOCK_EVT_FEAT_PERIODIC		0x000001
-#define CLOCK_EVT_FEAT_ONESHOT		0x000002
-#define CLOCK_EVT_FEAT_KTIME		0x000004
+# define CLOCK_EVT_FEAT_PERIODIC	0x000001
+# define CLOCK_EVT_FEAT_ONESHOT		0x000002
+# define CLOCK_EVT_FEAT_KTIME		0x000004
+
 /*
- * x86(64) specific misfeatures:
+ * x86(64) specific (mis)features:
  *
  * - Clockevent source stops in C3 State and needs broadcast support.
  * - Local APIC timer is used as a dummy device.
  */
-#define CLOCK_EVT_FEAT_C3STOP		0x000008
-#define CLOCK_EVT_FEAT_DUMMY		0x000010
+# define CLOCK_EVT_FEAT_C3STOP		0x000008
+# define CLOCK_EVT_FEAT_DUMMY		0x000010
 
 /*
  * Core shall set the interrupt affinity dynamically in broadcast mode
  */
-#define CLOCK_EVT_FEAT_DYNIRQ		0x000020
-#define CLOCK_EVT_FEAT_PERCPU		0x000040
+# define CLOCK_EVT_FEAT_DYNIRQ		0x000020
+# define CLOCK_EVT_FEAT_PERCPU		0x000040
 
 /*
  * Clockevent device is based on a hrtimer for broadcast
  */
-#define CLOCK_EVT_FEAT_HRTIMER		0x000080
+# define CLOCK_EVT_FEAT_HRTIMER		0x000080
 
 /**
  * struct clock_event_device - clock event device descriptor
@@ -116,10 +117,8 @@ enum clock_event_state {
  */
 struct clock_event_device {
 	void			(*event_handler)(struct clock_event_device *);
-	int			(*set_next_event)(unsigned long evt,
-						  struct clock_event_device *);
-	int			(*set_next_ktime)(ktime_t expires,
-						  struct clock_event_device *);
+	int			(*set_next_event)(unsigned long evt, struct clock_event_device *);
+	int			(*set_next_ktime)(ktime_t expires, struct clock_event_device *);
 	ktime_t			next_event;
 	u64			max_delta_ns;
 	u64			min_delta_ns;
@@ -136,8 +135,7 @@ struct clock_event_device {
 	 * - set_mode(), only for modes <= CLOCK_EVT_MODE_RESUME.
 	 * - set_state_{shutdown|periodic|oneshot}(), tick_resume().
 	 */
-	void			(*set_mode)(enum clock_event_mode mode,
-					    struct clock_event_device *);
+	void			(*set_mode)(enum clock_event_mode mode, struct clock_event_device *);
 	int			(*set_state_periodic)(struct clock_event_device *);
 	int			(*set_state_oneshot)(struct clock_event_device *);
 	int			(*set_state_shutdown)(struct clock_event_device *);
@@ -169,18 +167,18 @@ struct clock_event_device {
  *
  * factor = (clock_ticks << shift) / nanoseconds
  */
-static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
-				   int shift)
+static inline unsigned long
+div_sc(unsigned long ticks, unsigned long nsec, int shift)
 {
-	uint64_t tmp = ((uint64_t)ticks) << shift;
+	u64 tmp = ((u64)ticks) << shift;
 
 	do_div(tmp, nsec);
+
 	return (unsigned long) tmp;
 }
 
 /* Clock event layer functions */
-extern u64 clockevent_delta2ns(unsigned long latch,
-			       struct clock_event_device *evt);
+extern u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
 extern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);
 
@@ -194,42 +192,39 @@ extern int clockevents_update_freq(struct clock_event_device *ce, u32 freq);
 static inline void
 clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 {
-	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC,
-				      freq, minsec);
+	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC, freq, minsec);
 }
 
 extern void clockevents_suspend(void);
 extern void clockevents_resume(void);
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
-#ifdef CONFIG_ARCH_HAS_TICK_BROADCAST
+# ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+#  ifdef CONFIG_ARCH_HAS_TICK_BROADCAST
 extern void tick_broadcast(const struct cpumask *mask);
-#else
-#define tick_broadcast	NULL
-#endif
+#  else
+#   define tick_broadcast	NULL
+#  endif
 extern int tick_receive_broadcast(void);
-#endif
+# endif
 
-#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
+# if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
 extern void tick_setup_hrtimer_broadcast(void);
 extern int tick_check_broadcast_expired(void);
-#else
+# else
 static inline int tick_check_broadcast_expired(void) { return 0; }
-static inline void tick_setup_hrtimer_broadcast(void) {};
-#endif
+static inline void tick_setup_hrtimer_broadcast(void) { }
+# endif
 
 extern int clockevents_notify(unsigned long reason, void *arg);
 
-#else /* CONFIG_GENERIC_CLOCKEVENTS */
-
-static inline void clockevents_suspend(void) {}
-static inline void clockevents_resume(void) {}
+#else /* !CONFIG_GENERIC_CLOCKEVENTS: */
 
+static inline void clockevents_suspend(void) { }
+static inline void clockevents_resume(void) { }
 static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
-static inline void tick_setup_hrtimer_broadcast(void) {};
-static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
+static inline void tick_setup_hrtimer_broadcast(void) { }
 
-#endif
+#endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
-#endif
+#endif /* _LINUX_CLOCKCHIPS_H */

commit 7270d11c56f594af4d166b2988421cd8ed933dc1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:11:52 2015 +0100

    arm/bL_switcher: Kill tick suspend hackery
    
    Use the new tick_suspend/resume_local() and get rid of the
    homebrewn implementation of these in the ARM bL switcher.  The
    check for the cpumask is completely pointless.  There is no harm
    to suspend a per cpu tick device unconditionally.  If that's a
    real issue then we fix it proper at the core level and not with
    some completely undocumented hacks in some random core code.
    
    Move the tick internals to the core code, now that this nuisance
    is gone.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ rjw: Rebase, changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Link: http://lkml.kernel.org/r/1655112.Ws17YsMfN7@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 50ce9750754f..3ac7e2d90374 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -198,12 +198,6 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 				      freq, minsec);
 }
 
-/* Should be core only, but is abused by arm bl_switcher */
-extern void clockevents_set_state(struct clock_event_device *dev,
-				 enum clock_event_state state);
-extern int clockevents_program_event(struct clock_event_device *dev,
-				     ktime_t expires, bool force);
-
 extern void clockevents_suspend(void);
 extern void clockevents_resume(void);
 

commit 4ffee521f36390c7720d493591b764ca35c8030b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:09:16 2015 +0100

    clockevents: Make suspend/resume calls explicit
    
    clockevents_notify() is a leftover from the early design of the
    clockevents facility. It's really not a notification mechanism,
    it's a multiplex call.
    
    We are way better off to have explicit calls instead of this
    monstrosity. Split out the suspend/resume() calls and invoke
    them directly from the call sites.
    
    No locking required at this point because these calls happen
    with interrupts disabled and a single cpu online.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebased on top of 4.0-rc5. ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/713674030.jVm1qaHuPf@vostro.rjw.lan
    [ Rebased on top of latest timers/core. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index bc3af821350b..50ce9750754f 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -16,8 +16,6 @@ enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_BROADCAST_FORCE,
 	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
 	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
-	CLOCK_EVT_NOTIFY_SUSPEND,
-	CLOCK_EVT_NOTIFY_RESUME,
 	CLOCK_EVT_NOTIFY_CPU_DYING,
 	CLOCK_EVT_NOTIFY_CPU_DEAD,
 };

commit c1797baf6880174f899ce3960d0598f5bbeeb7ff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:07:37 2015 +0100

    tick: Move core only declarations and functions to core
    
    No point to expose everything to the world. People just believe
    such functions can be abused for whatever purposes. Sigh.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    [ Rebased on top of 4.0-rc5 ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/28017337.VbCUc39Gme@vostro.rjw.lan
    [ Merged to latest timers/core ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 57975131dac1..bc3af821350b 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -193,15 +193,6 @@ extern void clockevents_config_and_register(struct clock_event_device *dev,
 
 extern int clockevents_update_freq(struct clock_event_device *ce, u32 freq);
 
-extern void clockevents_exchange_device(struct clock_event_device *old,
-					struct clock_event_device *new);
-extern void clockevents_set_state(struct clock_event_device *dev,
-				  enum clock_event_state state);
-extern int clockevents_program_event(struct clock_event_device *dev,
-				     ktime_t expires, bool force);
-
-extern void clockevents_handle_noop(struct clock_event_device *dev);
-
 static inline void
 clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 {
@@ -209,6 +200,12 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 				      freq, minsec);
 }
 
+/* Should be core only, but is abused by arm bl_switcher */
+extern void clockevents_set_state(struct clock_event_device *dev,
+				 enum clock_event_state state);
+extern int clockevents_program_event(struct clock_event_device *dev,
+				     ktime_t expires, bool force);
+
 extern void clockevents_suspend(void);
 extern void clockevents_resume(void);
 

commit 9f083b74df3a7eaa100b456f2dc195512daf728e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 25 13:05:19 2015 +0100

    clockevents: Remove CONFIG_GENERIC_CLOCKEVENTS_BUILD
    
    This option was for simpler migration to the clock events code.
    Most architectures have been converted and the option has been
    disfunctional as a standalone option for quite some time. Remove
    it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/5021859.jl9OC1medj@vostro.rjw.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index e20232c3320a..57975131dac1 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -22,7 +22,7 @@ enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_CPU_DEAD,
 };
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS_BUILD
+#ifdef CONFIG_GENERIC_CLOCKEVENTS
 
 #include <linux/clocksource.h>
 #include <linux/cpumask.h>
@@ -229,13 +229,9 @@ static inline int tick_check_broadcast_expired(void) { return 0; }
 static inline void tick_setup_hrtimer_broadcast(void) {};
 #endif
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern int clockevents_notify(unsigned long reason, void *arg);
-#else
-static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
-#endif
 
-#else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
+#else /* CONFIG_GENERIC_CLOCKEVENTS */
 
 static inline void clockevents_suspend(void) {}
 static inline void clockevents_resume(void) {}
@@ -243,6 +239,7 @@ static inline void clockevents_resume(void) {}
 static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
 static inline void tick_setup_hrtimer_broadcast(void) {};
+static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 
 #endif
 

commit 77e32c89a7117614ab3d66d20c1088de721abfaa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 17:21:33 2015 +0530

    clockevents: Manage device's state separately for the core
    
    'enum clock_event_mode' is used for two purposes today:
    
     - to pass mode to the driver of clockevent device::set_mode().
    
     - for managing state of the device for clockevents core.
    
    For supporting new modes/states we have moved away from the
    legacy set_mode() callback to new per-mode/state callbacks. New
    modes/states shouldn't be exposed to the legacy (now OBSOLOTE)
    callbacks and so we shouldn't add new states to 'enum
    clock_event_mode'.
    
    Lets have separate enums for the two use cases mentioned above.
    Keep using the earlier enum for legacy set_mode() callback and
    mark it OBSOLETE. And add another enum to clearly specify the
    possible states of a clockevent device.
    
    This also renames the newly added per-mode callbacks to reflect
    state changes.
    
    We haven't got rid of 'mode' member of 'struct
    clock_event_device' as it is used by some of the clockevent
    drivers and it would automatically die down once we migrate
    those drivers to the new interface. It ('mode') is only updated
    now for the drivers using the legacy interface.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Suggested-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/b6b0143a8a57bd58352ad35e08c25424c879c0cb.1425037853.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index a41749543d48..e20232c3320a 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -32,15 +32,31 @@ enum clock_event_nofitiers {
 struct clock_event_device;
 struct module;
 
-/* Clock event mode commands */
+/* Clock event mode commands for legacy ->set_mode(): OBSOLETE */
 enum clock_event_mode {
 	CLOCK_EVT_MODE_UNUSED = 0,
 	CLOCK_EVT_MODE_SHUTDOWN,
 	CLOCK_EVT_MODE_PERIODIC,
 	CLOCK_EVT_MODE_ONESHOT,
 	CLOCK_EVT_MODE_RESUME,
+};
 
-	/* Legacy ->set_mode() callback doesn't support below modes */
+/*
+ * Possible states of a clock event device.
+ *
+ * DETACHED:	Device is not used by clockevents core. Initial state or can be
+ *		reached from SHUTDOWN.
+ * SHUTDOWN:	Device is powered-off. Can be reached from PERIODIC or ONESHOT.
+ * PERIODIC:	Device is programmed to generate events periodically. Can be
+ *		reached from DETACHED or SHUTDOWN.
+ * ONESHOT:	Device is programmed to generate event only once. Can be reached
+ *		from DETACHED or SHUTDOWN.
+ */
+enum clock_event_state {
+	CLOCK_EVT_STATE_DETACHED = 0,
+	CLOCK_EVT_STATE_SHUTDOWN,
+	CLOCK_EVT_STATE_PERIODIC,
+	CLOCK_EVT_STATE_ONESHOT,
 };
 
 /*
@@ -80,13 +96,14 @@ enum clock_event_mode {
  * @min_delta_ns:	minimum delta value in ns
  * @mult:		nanosecond to cycles multiplier
  * @shift:		nanoseconds to cycles divisor (power of two)
- * @mode:		operating mode assigned by the management code
+ * @mode:		operating mode, relevant only to ->set_mode(), OBSOLETE
+ * @state:		current state of the device, assigned by the core code
  * @features:		features
  * @retries:		number of forced programming retries
  * @set_mode:		legacy set mode function, only for modes <= CLOCK_EVT_MODE_RESUME.
- * @set_mode_periodic:	switch mode to periodic, if !set_mode
- * @set_mode_oneshot:	switch mode to oneshot, if !set_mode
- * @set_mode_shutdown:	switch mode to shutdown, if !set_mode
+ * @set_state_periodic:	switch state to periodic, if !set_mode
+ * @set_state_oneshot:	switch state to oneshot, if !set_mode
+ * @set_state_shutdown:	switch state to shutdown, if !set_mode
  * @tick_resume:	resume clkevt device, if !set_mode
  * @broadcast:		function to broadcast events
  * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
@@ -111,20 +128,21 @@ struct clock_event_device {
 	u32			mult;
 	u32			shift;
 	enum clock_event_mode	mode;
+	enum clock_event_state	state;
 	unsigned int		features;
 	unsigned long		retries;
 
 	/*
-	 * Mode transition callback(s): Only one of the two groups should be
+	 * State transition callback(s): Only one of the two groups should be
 	 * defined:
 	 * - set_mode(), only for modes <= CLOCK_EVT_MODE_RESUME.
-	 * - set_mode_{shutdown|periodic|oneshot|resume}().
+	 * - set_state_{shutdown|periodic|oneshot}(), tick_resume().
 	 */
 	void			(*set_mode)(enum clock_event_mode mode,
 					    struct clock_event_device *);
-	int			(*set_mode_periodic)(struct clock_event_device *);
-	int			(*set_mode_oneshot)(struct clock_event_device *);
-	int			(*set_mode_shutdown)(struct clock_event_device *);
+	int			(*set_state_periodic)(struct clock_event_device *);
+	int			(*set_state_oneshot)(struct clock_event_device *);
+	int			(*set_state_shutdown)(struct clock_event_device *);
 	int			(*tick_resume)(struct clock_event_device *);
 
 	void			(*broadcast)(const struct cpumask *mask);
@@ -177,8 +195,8 @@ extern int clockevents_update_freq(struct clock_event_device *ce, u32 freq);
 
 extern void clockevents_exchange_device(struct clock_event_device *old,
 					struct clock_event_device *new);
-extern void clockevents_set_mode(struct clock_event_device *dev,
-				 enum clock_event_mode mode);
+extern void clockevents_set_state(struct clock_event_device *dev,
+				  enum clock_event_state state);
 extern int clockevents_program_event(struct clock_event_device *dev,
 				     ktime_t expires, bool force);
 

commit 554ef3876c6acdff1331feab10275e9e9e0adb84
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 17:21:32 2015 +0530

    clockevents: Handle tick device's resume separately
    
    Upcoming patch will redefine possible states of a clockevent
    device. The RESUME mode is a special case only for tick's
    clockevent devices. In future it can be replaced by ->resume()
    callback already available for clockevent devices.
    
    Lets handle it separately so that clockevents_set_mode() only
    handles states valid across all devices. This also renames
    set_mode_resume() to tick_resume() to make it more explicit.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/c1b0112410870f49e7bf06958e1483eac6c15e20.1425037853.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 59af26b54d15..a41749543d48 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -87,7 +87,7 @@ enum clock_event_mode {
  * @set_mode_periodic:	switch mode to periodic, if !set_mode
  * @set_mode_oneshot:	switch mode to oneshot, if !set_mode
  * @set_mode_shutdown:	switch mode to shutdown, if !set_mode
- * @set_mode_resume:	resume clkevt device, if !set_mode
+ * @tick_resume:	resume clkevt device, if !set_mode
  * @broadcast:		function to broadcast events
  * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
  * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
@@ -125,7 +125,7 @@ struct clock_event_device {
 	int			(*set_mode_periodic)(struct clock_event_device *);
 	int			(*set_mode_oneshot)(struct clock_event_device *);
 	int			(*set_mode_shutdown)(struct clock_event_device *);
-	int			(*set_mode_resume)(struct clock_event_device *);
+	int			(*tick_resume)(struct clock_event_device *);
 
 	void			(*broadcast)(const struct cpumask *mask);
 	void			(*suspend)(struct clock_event_device *);

commit bd624d75db21ea5402f9ecf4450b311794d80352
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 13 08:54:56 2015 +0800

    clockevents: Introduce mode specific callbacks
    
    It is not possible for the clockevents core to know which modes (other than
    those with a corresponding feature flag) are supported by a particular
    implementation. And drivers are expected to handle transition to all modes
    elegantly, as ->set_mode() would be issued for them unconditionally.
    
    Now, adding support for a new mode complicates things a bit if we want to use
    the legacy ->set_mode() callback. We need to closely review all clockevents
    drivers to see if they would break on addition of a new mode. And after such
    reviews, it is found that we have to do non-trivial changes to most of the
    drivers [1].
    
    Introduce mode-specific set_mode_*() callbacks, some of which the drivers may or
    may not implement. A missing callback would clearly convey the message that the
    corresponding mode isn't supported.
    
    A driver may still choose to keep supporting the legacy ->set_mode() callback,
    but ->set_mode() wouldn't be supporting any new modes beyond RESUME. If a driver
    wants to benefit from using a new mode, it would be required to migrate to
    the mode specific callbacks.
    
    The legacy ->set_mode() callback and the newly introduced mode-specific
    callbacks are mutually exclusive. Only one of them should be supported by the
    driver.
    
    Sanity check is done at the time of registration to distinguish between optional
    and required callbacks and to make error recovery and handling simpler. If the
    legacy ->set_mode() callback is provided, all mode specific ones would be
    ignored by the core but a warning is thrown if they are present.
    
    Call sites calling ->set_mode() directly are also updated to use
    __clockevents_set_mode() instead, as ->set_mode() may not be available anymore
    for few drivers.
    
     [1] https://lkml.org/lkml/2014/12/9/605
     [2] https://lkml.org/lkml/2015/1/23/255
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de> [2]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: linaro-kernel@lists.linaro.org
    Cc: linaro-networking@linaro.org
    Link: http://lkml.kernel.org/r/792d59a40423f0acffc9bb0bec9de1341a06fa02.1423788565.git.viresh.kumar@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 2e4cb67f6e56..59af26b54d15 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -39,6 +39,8 @@ enum clock_event_mode {
 	CLOCK_EVT_MODE_PERIODIC,
 	CLOCK_EVT_MODE_ONESHOT,
 	CLOCK_EVT_MODE_RESUME,
+
+	/* Legacy ->set_mode() callback doesn't support below modes */
 };
 
 /*
@@ -81,7 +83,11 @@ enum clock_event_mode {
  * @mode:		operating mode assigned by the management code
  * @features:		features
  * @retries:		number of forced programming retries
- * @set_mode:		set mode function
+ * @set_mode:		legacy set mode function, only for modes <= CLOCK_EVT_MODE_RESUME.
+ * @set_mode_periodic:	switch mode to periodic, if !set_mode
+ * @set_mode_oneshot:	switch mode to oneshot, if !set_mode
+ * @set_mode_shutdown:	switch mode to shutdown, if !set_mode
+ * @set_mode_resume:	resume clkevt device, if !set_mode
  * @broadcast:		function to broadcast events
  * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
  * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
@@ -108,9 +114,20 @@ struct clock_event_device {
 	unsigned int		features;
 	unsigned long		retries;
 
-	void			(*broadcast)(const struct cpumask *mask);
+	/*
+	 * Mode transition callback(s): Only one of the two groups should be
+	 * defined:
+	 * - set_mode(), only for modes <= CLOCK_EVT_MODE_RESUME.
+	 * - set_mode_{shutdown|periodic|oneshot|resume}().
+	 */
 	void			(*set_mode)(enum clock_event_mode mode,
 					    struct clock_event_device *);
+	int			(*set_mode_periodic)(struct clock_event_device *);
+	int			(*set_mode_oneshot)(struct clock_event_device *);
+	int			(*set_mode_shutdown)(struct clock_event_device *);
+	int			(*set_mode_resume)(struct clock_event_device *);
+
+	void			(*broadcast)(const struct cpumask *mask);
 	void			(*suspend)(struct clock_event_device *);
 	void			(*resume)(struct clock_event_device *);
 	unsigned long		min_delta_ticks;

commit 849401b66d305f3feb75b6db7459b95ad190552a
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Sun Feb 9 11:32:22 2014 +0530

    tick: Fixup more fallout from hrtimer broadcast mode
    
    The hrtimer mode of broadcast is supported only when
    GENERIC_CLOCKEVENTS_BROADCAST and TICK_ONESHOT config options
    are enabled. Hence compile in the functions for hrtimer mode
    of broadcast only when these options are selected.
    Also fix max_delta_ticks value for the pseudo clock device.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/52F719EE.9010304@linux.vnet.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 20a7183f2831..2e4cb67f6e56 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -207,6 +207,7 @@ static inline void clockevents_resume(void) {}
 
 static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
+static inline void tick_setup_hrtimer_broadcast(void) {};
 
 #endif
 

commit f1689bb7abec8e2e670d8ad11eaa86d54bad8cfd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 16:00:46 2014 +0100

    time: Fixup fallout from recent clockevent/tick changes
    
    Make the stub function static inline instead of static and move the
    clockevents related function into the proper ifdeffed section.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index dbe9e1457168..20a7183f2831 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -191,7 +191,7 @@ extern void tick_setup_hrtimer_broadcast(void);
 extern int tick_check_broadcast_expired(void);
 #else
 static inline int tick_check_broadcast_expired(void) { return 0; }
-static void tick_setup_hrtimer_broadcast(void) {};
+static inline void tick_setup_hrtimer_broadcast(void) {};
 #endif
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS

commit 5d1638acb9f62fa7eb0c07cb85318bbe1f13b227
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Fri Feb 7 13:36:32 2014 +0530

    tick: Introduce hrtimer based broadcast
    
    On some architectures, in certain CPU deep idle states the local timers stop.
    An external clock device is used to wakeup these CPUs. The kernel support for the
    wakeup of these CPUs is provided by the tick broadcast framework by using the
    external clock device as the wakeup source.
    
    However not all implementations of architectures provide such an external
    clock device. This patch includes support in the broadcast framework to handle
    the wakeup of the CPUs in deep idle states on such systems by queuing a hrtimer
    on one of the CPUs, which is meant to handle the wakeup of CPUs in deep idle states.
    
    This patchset introduces a pseudo clock device which can be registered by the
    archs as tick_broadcast_device in the absence of a real external clock
    device. Once registered, the broadcast framework will work as is for these
    architectures as long as the archs take care of the BROADCAST_ENTER
    notification failing for one of the CPUs. This CPU is made the stand by CPU to
    handle wakeup of the CPUs in deep idle and it *must not enter deep idle states*.
    
    The CPU with the earliest wakeup is chosen to be this CPU. Hence this way the
    stand by CPU dynamically moves around and so does the hrtimer which is queued
    to trigger at the next earliest wakeup time. This is consistent with the case where
    an external clock device is present. The smp affinity of this clock device is
    set to the CPU with the earliest wakeup. This patchset handles the hotplug of
    the stand by CPU as well by moving the hrtimer on to the CPU handling the CPU_DEAD
    notification.
    
    Originally-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: deepthi@linux.vnet.ibm.com
    Cc: paulmck@linux.vnet.ibm.com
    Cc: fweisbec@gmail.com
    Cc: paulus@samba.org
    Cc: srivatsa.bhat@linux.vnet.ibm.com
    Cc: svaidy@linux.vnet.ibm.com
    Cc: peterz@infradead.org
    Cc: benh@kernel.crashing.org
    Cc: rafael.j.wysocki@intel.com
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20140207080632.17187.80532.stgit@preeti.in.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index e0c5a6c418de..dbe9e1457168 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -62,6 +62,11 @@ enum clock_event_mode {
 #define CLOCK_EVT_FEAT_DYNIRQ		0x000020
 #define CLOCK_EVT_FEAT_PERCPU		0x000040
 
+/*
+ * Clockevent device is based on a hrtimer for broadcast
+ */
+#define CLOCK_EVT_FEAT_HRTIMER		0x000080
+
 /**
  * struct clock_event_device - clock event device descriptor
  * @event_handler:	Assigned by the framework to be called by the low
@@ -83,6 +88,7 @@ enum clock_event_mode {
  * @name:		ptr to clock event name
  * @rating:		variable to rate clock event devices
  * @irq:		IRQ number (only for non CPU local devices)
+ * @bound_on:		Bound on CPU
  * @cpumask:		cpumask to indicate for which CPUs this device works
  * @list:		list head for the management code
  * @owner:		module reference
@@ -113,6 +119,7 @@ struct clock_event_device {
 	const char		*name;
 	int			rating;
 	int			irq;
+	int			bound_on;
 	const struct cpumask	*cpumask;
 	struct list_head	list;
 	struct module		*owner;
@@ -180,9 +187,11 @@ extern int tick_receive_broadcast(void);
 #endif
 
 #if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
+extern void tick_setup_hrtimer_broadcast(void);
 extern int tick_check_broadcast_expired(void);
 #else
 static inline int tick_check_broadcast_expired(void) { return 0; }
+static void tick_setup_hrtimer_broadcast(void) {};
 #endif
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS

commit da7e6f45c34d39186b72328bacc4dd86bff60e0a
Author: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Date:   Fri Feb 7 13:36:06 2014 +0530

    time: Change the return type of clockevents_notify() to integer
    
    The broadcast framework can potentially be made use of by archs which do not have an
    external clock device as well. Then, it is required that one of the CPUs need
    to handle the broadcasting of wakeup IPIs to the CPUs in deep idle. As a
    result its local timers should remain functional all the time. For such
    a CPU, the BROADCAST_ENTER notification has to fail indicating that its clock
    device cannot be shutdown. To make way for this support, change the return
    type of tick_broadcast_oneshot_control() and hence clockevents_notify() to
    indicate such scenarios.
    
    Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: deepthi@linux.vnet.ibm.com
    Cc: paulmck@linux.vnet.ibm.com
    Cc: fweisbec@gmail.com
    Cc: paulus@samba.org
    Cc: srivatsa.bhat@linux.vnet.ibm.com
    Cc: svaidy@linux.vnet.ibm.com
    Cc: peterz@infradead.org
    Cc: benh@kernel.crashing.org
    Cc: rafael.j.wysocki@intel.com
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20140207080606.17187.78306.stgit@preeti.in.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 493aa021c7a9..e0c5a6c418de 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -186,9 +186,9 @@ static inline int tick_check_broadcast_expired(void) { return 0; }
 #endif
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
-extern void clockevents_notify(unsigned long reason, void *arg);
+extern int clockevents_notify(unsigned long reason, void *arg);
 #else
-static inline void clockevents_notify(unsigned long reason, void *arg) {}
+static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 #endif
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
@@ -196,7 +196,7 @@ static inline void clockevents_notify(unsigned long reason, void *arg) {}
 static inline void clockevents_suspend(void) {}
 static inline void clockevents_resume(void) {}
 
-static inline void clockevents_notify(unsigned long reason, void *arg) {}
+static inline int clockevents_notify(unsigned long reason, void *arg) { return 0; }
 static inline int tick_check_broadcast_expired(void) { return 0; }
 
 #endif

commit 3713c0cfd06fa49729a12929a7ee8b7ad48f3c02
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Wed Sep 18 11:48:35 2013 -0700

    clockchips: Add FEAT_PERCPU clockevent flag
    
    Add the flag CLOCK_EVT_FEAT_PERCPU which is supposed to be set for per
    cpu clockevent devices.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 0857922e8ad0..493aa021c7a9 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -60,6 +60,7 @@ enum clock_event_mode {
  * Core shall set the interrupt affinity dynamically in broadcast mode
  */
 #define CLOCK_EVT_FEAT_DYNIRQ		0x000020
+#define CLOCK_EVT_FEAT_PERCPU		0x000040
 
 /**
  * struct clock_event_device - clock event device descriptor

commit 03e13cf5ee60584fe0c831682c67212effb7fca4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:50 2013 +0000

    clockevents: Implement unbind functionality
    
    Provide a sysfs interface to allow unbinding of clockevent
    devices. The device is unbound if it is unused or if there is a
    replacement device available. Unbinding of broadcast devices is not
    supported as we don't want to foster that nonsense. If no replacement
    device is available the unbind returns -EBUSY. Unbind is available
    from the kernel and through sysfs, which is necessary to drop the
    module refcount.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.499216659@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index ae1193bcf074..0857922e8ad0 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -141,6 +141,7 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 extern u64 clockevent_delta2ns(unsigned long latch,
 			       struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
+extern int clockevents_unbind_device(struct clock_event_device *ced, int cpu);
 
 extern void clockevents_config(struct clock_event_device *dev, u32 freq);
 extern void clockevents_config_and_register(struct clock_event_device *dev,

commit ccf33d6880f39a35158fff66db13000ae4943fac
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:49 2013 +0000

    clockevents: Add module refcount
    
    We want to be able to remove clockevent modules as well. Add a
    refcount so we don't remove a module with an active clock event
    device.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.307435149@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 2f498f66c1bb..ae1193bcf074 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -30,6 +30,7 @@ enum clock_event_nofitiers {
 #include <linux/notifier.h>
 
 struct clock_event_device;
+struct module;
 
 /* Clock event mode commands */
 enum clock_event_mode {
@@ -83,6 +84,7 @@ enum clock_event_mode {
  * @irq:		IRQ number (only for non CPU local devices)
  * @cpumask:		cpumask to indicate for which CPUs this device works
  * @list:		list head for the management code
+ * @owner:		module reference
  */
 struct clock_event_device {
 	void			(*event_handler)(struct clock_event_device *);
@@ -112,6 +114,7 @@ struct clock_event_device {
 	int			irq;
 	const struct cpumask	*cpumask;
 	struct list_head	list;
+	struct module		*owner;
 } ____cacheline_aligned;
 
 /*

commit 7172a286ced0c1f4f239a0fa09db54ed37d3ead2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:47 2013 +0000

    clockevents: Get rid of the notifier chain
    
    7+ years and still a single user. Kill it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.098520211@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 963d71431388..2f498f66c1bb 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -150,7 +150,6 @@ extern void clockevents_exchange_device(struct clock_event_device *old,
 					struct clock_event_device *new);
 extern void clockevents_set_mode(struct clock_event_device *dev,
 				 enum clock_event_mode mode);
-extern int clockevents_register_notifier(struct notifier_block *nb);
 extern int clockevents_program_event(struct clock_event_device *dev,
 				     ktime_t expires, bool force);
 

commit 3ed1c478eff8db80e234d5446cb378b503135888
Merge: 151173e8ce9b 371deb950083
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 30 15:21:02 2013 -0700

    Merge tag 'pm+acpi-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael J Wysocki:
    
     - ARM big.LITTLE cpufreq driver from Viresh Kumar.
    
     - exynos5440 cpufreq driver from Amit Daniel Kachhap.
    
     - cpufreq core cleanup and code consolidation from Viresh Kumar and
       Stratos Karafotis.
    
     - cpufreq scalability improvement from Nathan Zimmer.
    
     - AMD "frequency sensitivity feedback" powersave bias for the ondemand
       cpufreq governor from Jacob Shin.
    
     - cpuidle code consolidation and cleanups from Daniel Lezcano.
    
     - ARM OMAP cpuidle fixes from Santosh Shilimkar and Daniel Lezcano.
    
     - ACPICA fixes and other improvements from Bob Moore, Jung-uk Kim, Lv
       Zheng, Yinghai Lu, Tang Chen, Colin Ian King, and Linn Crosetto.
    
     - ACPI core updates related to hotplug from Toshi Kani, Paul Bolle,
       Yasuaki Ishimatsu, and Rafael J Wysocki.
    
     - Intel Lynxpoint LPSS (Low-Power Subsystem) support improvements from
       Rafael J Wysocki and Andy Shevchenko.
    
    * tag 'pm+acpi-3.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (192 commits)
      cpufreq: Revert incorrect commit 5800043
      cpufreq: MAINTAINERS: Add co-maintainer
      cpuidle: add maintainer entry
      ACPI / thermal: do not always return THERMAL_TREND_RAISING for active trip points
      ARM: s3c64xx: cpuidle: use init/exit common routine
      cpufreq: pxa2xx: initialize variables
      ACPI: video: correct acpi_video_bus_add error processing
      SH: cpuidle: use init/exit common routine
      ARM: S5pv210: compiling issue, ARM_S5PV210_CPUFREQ needs CONFIG_CPU_FREQ_TABLE=y
      ACPI: Fix wrong parameter passed to memblock_reserve
      cpuidle: fix comment format
      pnp: use %*phC to dump small buffers
      isapnp: remove debug leftovers
      ARM: imx: cpuidle: use init/exit common routine
      ARM: davinci: cpuidle: use init/exit common routine
      ARM: kirkwood: cpuidle: use init/exit common routine
      ARM: calxeda: cpuidle: use init/exit common routine
      ARM: tegra: cpuidle: use init/exit common routine for tegra3
      ARM: tegra: cpuidle: use init/exit common routine for tegra2
      ARM: OMAP4: cpuidle: use init/exit common routine
      ...

commit 4dbad816febb6cb7340e36af4f5c0dc86e55a2ca
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Mar 27 10:22:09 2013 +0000

    timer: move enum definition out of ifdef section
    
    The next patch will setup automatically the broadcast timer for
    the different cpuidle driver when one idle state stops its timer.
    This will be part of the generic code.
    
    But some ARM boards, like s3c64xx, uses cpuidle but without the
    CONFIG_GENERIC_CLOCKEVENTS_BUILD set. Hence the cpuidle framework
    will be compiled with the code supposed to be generic, that is
    with clockevents_notify and the different enum.
    
    Also the function clockevents_notify is a noop macro, this is fine
    except the usual code is:
    
            int cpu = smp_processor_id();
            clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ON, &cpu);
    
    and that raises a warning for the variable cpu which is not used.
    
    Move the clock_event_nofitiers enum definition out of the
    CONFIG_GENERIC_CLOCKEVENTS_BUILD section to prevent a compilation
    error when these are used in the code.
    
    Change the clockevents_notify macro to a static inline noop function
    to prevent a compilation warning.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 66346521cb65..f9fd93758333 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -8,6 +8,20 @@
 #ifndef _LINUX_CLOCKCHIPS_H
 #define _LINUX_CLOCKCHIPS_H
 
+/* Clock event notification values */
+enum clock_event_nofitiers {
+	CLOCK_EVT_NOTIFY_ADD,
+	CLOCK_EVT_NOTIFY_BROADCAST_ON,
+	CLOCK_EVT_NOTIFY_BROADCAST_OFF,
+	CLOCK_EVT_NOTIFY_BROADCAST_FORCE,
+	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
+	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
+	CLOCK_EVT_NOTIFY_SUSPEND,
+	CLOCK_EVT_NOTIFY_RESUME,
+	CLOCK_EVT_NOTIFY_CPU_DYING,
+	CLOCK_EVT_NOTIFY_CPU_DEAD,
+};
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS_BUILD
 
 #include <linux/clocksource.h>
@@ -26,20 +40,6 @@ enum clock_event_mode {
 	CLOCK_EVT_MODE_RESUME,
 };
 
-/* Clock event notification values */
-enum clock_event_nofitiers {
-	CLOCK_EVT_NOTIFY_ADD,
-	CLOCK_EVT_NOTIFY_BROADCAST_ON,
-	CLOCK_EVT_NOTIFY_BROADCAST_OFF,
-	CLOCK_EVT_NOTIFY_BROADCAST_FORCE,
-	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
-	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
-	CLOCK_EVT_NOTIFY_SUSPEND,
-	CLOCK_EVT_NOTIFY_RESUME,
-	CLOCK_EVT_NOTIFY_CPU_DYING,
-	CLOCK_EVT_NOTIFY_CPU_DEAD,
-};
-
 /*
  * Clock event features
  */
@@ -173,7 +173,7 @@ extern int tick_receive_broadcast(void);
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else
-# define clockevents_notify(reason, arg) do { } while (0)
+static inline void clockevents_notify(unsigned long reason, void *arg) {}
 #endif
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
@@ -181,7 +181,7 @@ extern void clockevents_notify(unsigned long reason, void *arg);
 static inline void clockevents_suspend(void) {}
 static inline void clockevents_resume(void) {}
 
-#define clockevents_notify(reason, arg) do { } while (0)
+static inline void clockevents_notify(unsigned long reason, void *arg) {}
 
 #endif
 

commit 19919226c3f20e6bf5de3df96432ce80ffd63ff2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 22 10:48:33 2013 +0100

    clockevents: Add missing tick_check_broadcast_expired() for CLOCKEVENTS=n
    
    Fengs build robot reports:
    
    arch/arm/kernel/process.c: In function 'cpu_idle':
    arch/arm/kernel/process.c:211:4: error: implicit declaration of function
    'tick_check_broadcast_expired' [-Werror=implicit-function-declaration]
    
    Add the missing inline function for non clockevent builds
    
    Reported-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 646aac136eed..464e229e7d84 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -193,6 +193,7 @@ static inline void clockevents_suspend(void) {}
 static inline void clockevents_resume(void) {}
 
 #define clockevents_notify(reason, arg) do { } while (0)
+static inline int tick_check_broadcast_expired(void) { return 0; }
 
 #endif
 

commit eaa907c546f76222227dfc41784b22588af1e3d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 6 11:18:36 2013 +0000

    tick: Provide a check for a forced broadcast pending
    
    On the CPU which gets woken along with the target CPU of the broadcast
    the following happens:
    
      deep_idle()
                            <-- spurious wakeup
      broadcast_exit()
        set forced bit
    
      enable interrupts
    
                            <-- Nothing happens
    
      disable interrupts
    
      broadcast_enter()
                            <-- Here we observe the forced bit is set
      deep_idle()
    
    Now after that the target CPU of the broadcast runs the broadcast
    handler and finds the other CPU in both the broadcast and the forced
    mask, sends the IPI and stuff gets back to normal.
    
    So it's not actually harmful, just more evidence for the theory, that
    hardware designers have access to very special drug supplies.
    
    Now there is no point in going back to deep idle just to wake up again
    right away via an IPI. Provide a check which allows the idle code to
    avoid the deep idle transition.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Arjan van de Veen <arjan@infradead.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Jason Liu <liu.h.jason@gmail.com>
    Link: http://lkml.kernel.org/r/20130306111537.565418308@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 494d33ea78f8..646aac136eed 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -175,6 +175,12 @@ extern void tick_broadcast(const struct cpumask *mask);
 extern int tick_receive_broadcast(void);
 #endif
 
+#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)
+extern int tick_check_broadcast_expired(void);
+#else
+static inline int tick_check_broadcast_expired(void) { return 0; }
+#endif
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else

commit d2348fb6fdc6d671ad45b62db237f76c8c115603
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sat Mar 2 11:10:11 2013 +0100

    tick: Dynamically set broadcast irq affinity
    
    When a cpu goes to a deep idle state where its local timer is
    shutdown, it notifies the time frame work to use the broadcast timer
    instead.  Unfortunately, the broadcast device could wake up any CPU,
    including an idle one which is not concerned by the wake up at all. So
    in the worst case an idle CPU will wake up to send an IPI to the CPU
    whose timer expired.
    
    Provide an opt-in feature CLOCK_EVT_FEAT_DYNIRQ which tells the core
    that is should set the interrupt affinity of the broadcast interrupt
    to the cpu which has the earliest expiry time. This avoids unnecessary
    spurious wakeups and IPIs.
    
    [ tglx: Adopted to cpumask rework, silenced an uninitialized warning,
      massaged changelog ]
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: viresh.kumar@linaro.org
    Cc: jacob.jun.pan@linux.intel.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: santosh.shilimkar@ti.com
    Cc: linaro-kernel@lists.linaro.org
    Cc: patches@linaro.org
    Cc: rickard.andersson@stericsson.com
    Cc: vincent.guittot@linaro.org
    Cc: linus.walleij@stericsson.com
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1362219013-18173-3-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 66346521cb65..494d33ea78f8 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -55,6 +55,11 @@ enum clock_event_nofitiers {
 #define CLOCK_EVT_FEAT_C3STOP		0x000008
 #define CLOCK_EVT_FEAT_DUMMY		0x000010
 
+/*
+ * Core shall set the interrupt affinity dynamically in broadcast mode
+ */
+#define CLOCK_EVT_FEAT_DYNIRQ		0x000020
+
 /**
  * struct clock_event_device - clock event device descriptor
  * @event_handler:	Assigned by the framework to be called by the low

commit 12ad10004645d38356b14d1fbba379c523a61916
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jan 14 17:05:22 2013 +0000

    clockevents: Add generic timer broadcast function
    
    Currently, the timer broadcast mechanism is defined by a function
    pointer on struct clock_event_device. As the fundamental mechanism for
    broadcast is architecture-specific, this means that clock_event_device
    drivers cannot be shared across multiple architectures.
    
    This patch adds an (optional) architecture-specific function for timer
    tick broadcast, allowing drivers which may require broadcast
    functionality to be shared across multiple architectures.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: nico@linaro.org
    Cc: Will.Deacon@arm.com
    Cc: Marc.Zyngier@arm.com
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1358183124-28461-3-git-send-email-mark.rutland@arm.com
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index e1089aa7816d..66346521cb65 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -162,6 +162,11 @@ extern void clockevents_suspend(void);
 extern void clockevents_resume(void);
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+#ifdef CONFIG_ARCH_HAS_TICK_BROADCAST
+extern void tick_broadcast(const struct cpumask *mask);
+#else
+#define tick_broadcast	NULL
+#endif
 extern int tick_receive_broadcast(void);
 #endif
 

commit 12572dbb53638c6e454ef831c8fee7de3df24389
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Jan 14 17:05:21 2013 +0000

    clockevents: Add generic timer broadcast receiver
    
    Currently the broadcast mechanism used for timers is abstracted by a
    function pointer on struct clock_event_device. As the fundamental
    mechanism for broadcast is architecture-specific, this ties each
    clock_event_device driver to a single architecture, even where the
    driver is otherwise generic.
    
    This patch adds a standard path for the receipt of timer broadcasts, so
    drivers and/or architecture backends need not manage redundant lists of
    timers for the purpose of routing broadcast timer ticks.
    
    [tglx: Made the implementation depend on the config switch as well ]
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: nico@linaro.org
    Cc: Will.Deacon@arm.com
    Cc: Marc.Zyngier@arm.com
    Cc: john.stultz@linaro.org
    Link: http://lkml.kernel.org/r/1358183124-28461-2-git-send-email-mark.rutland@arm.com
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 8a7096fcb01e..e1089aa7816d 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -161,6 +161,10 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 extern void clockevents_suspend(void);
 extern void clockevents_resume(void);
 
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+extern int tick_receive_broadcast(void);
+#endif
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else

commit adc78e6b9946a4b22e22403d961f3b03c469e5d3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:40:41 2012 +0200

    timekeeping: Add suspend and resume of clock event devices
    
    Some clock event devices, for example such that belong to PM domains,
    need to be handled in a spcial way during the timekeeping suspend
    and resume (which takes place in the system core, or "syscore",
    stages of system power transitions) in analogy with clock sources.
    
    Introduce .suspend() and .resume() callbacks for clock event devices
    that will be executed by timekeeping_suspend/_resume(), respectively,
    next the the clock sources' .suspend() and .resume() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index acba894374a1..8a7096fcb01e 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -97,6 +97,8 @@ struct clock_event_device {
 	void			(*broadcast)(const struct cpumask *mask);
 	void			(*set_mode)(enum clock_event_mode mode,
 					    struct clock_event_device *);
+	void			(*suspend)(struct clock_event_device *);
+	void			(*resume)(struct clock_event_device *);
 	unsigned long		min_delta_ticks;
 	unsigned long		max_delta_ticks;
 
@@ -156,6 +158,9 @@ clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
 				      freq, minsec);
 }
 
+extern void clockevents_suspend(void);
+extern void clockevents_resume(void);
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else
@@ -164,6 +169,9 @@ extern void clockevents_notify(unsigned long reason, void *arg);
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
 
+static inline void clockevents_suspend(void) {}
+static inline void clockevents_resume(void) {}
+
 #define clockevents_notify(reason, arg) do { } while (0)
 
 #endif

commit e5400321a6f15ce0fe77c8455954f213ef7dcc54
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Wed May 9 23:39:34 2012 +0900

    clockevents: Make clockevents_config() a global symbol
    
    Make clockevents_config() into a global symbol to allow it to be used
    by compiled-in clockevent drivers. This is needed by drivers that want
    to update the timer frequency after registration time.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Tested-by: Simon Horman <horms@verge.net.au>
    Cc: arnd@arndb.de
    Cc: johnstul@us.ibm.com
    Cc: rjw@sisk.pl
    Cc: lethal@linux-sh.org
    Cc: gregkh@linuxfoundation.org
    Cc: olof@lixom.net
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20120509143934.27521.46553.sendpatchset@w520
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 81e803e90aa4..acba894374a1 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -132,6 +132,7 @@ extern u64 clockevent_delta2ns(unsigned long latch,
 			       struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
 
+extern void clockevents_config(struct clock_event_device *dev, u32 freq);
 extern void clockevents_config_and_register(struct clock_event_device *dev,
 					    u32 freq, unsigned long min_delta,
 					    unsigned long max_delta);

commit 65516f8a7c2028381f0dae4c16ddb621c96158cc
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Aug 23 15:29:43 2011 +0200

    clockevents: Add direct ktime programming function
    
    There is at least one architecture (s390) with a sane clockevent device
    that can be programmed with the equivalent of a ktime. No need to create
    a delta against the current time, the ktime can be used directly.
    
    A new clock device function 'set_next_ktime' is introduced that is called
    with the unmodified ktime for the timer if the clock event device has the
    CLOCK_EVT_FEAT_KTIME bit set.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20110823133142.815350967@de.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 39bb050bdbb2..81e803e90aa4 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -45,20 +45,22 @@ enum clock_event_nofitiers {
  */
 #define CLOCK_EVT_FEAT_PERIODIC		0x000001
 #define CLOCK_EVT_FEAT_ONESHOT		0x000002
+#define CLOCK_EVT_FEAT_KTIME		0x000004
 /*
  * x86(64) specific misfeatures:
  *
  * - Clockevent source stops in C3 State and needs broadcast support.
  * - Local APIC timer is used as a dummy device.
  */
-#define CLOCK_EVT_FEAT_C3STOP		0x000004
-#define CLOCK_EVT_FEAT_DUMMY		0x000008
+#define CLOCK_EVT_FEAT_C3STOP		0x000008
+#define CLOCK_EVT_FEAT_DUMMY		0x000010
 
 /**
  * struct clock_event_device - clock event device descriptor
  * @event_handler:	Assigned by the framework to be called by the low
  *			level handler of the event source
- * @set_next_event:	set next event function
+ * @set_next_event:	set next event function using a clocksource delta
+ * @set_next_ktime:	set next event function using a direct ktime value
  * @next_event:		local storage for the next event in oneshot mode
  * @max_delta_ns:	maximum delta value in ns
  * @min_delta_ns:	minimum delta value in ns
@@ -81,6 +83,8 @@ struct clock_event_device {
 	void			(*event_handler)(struct clock_event_device *);
 	int			(*set_next_event)(unsigned long evt,
 						  struct clock_event_device *);
+	int			(*set_next_ktime)(ktime_t expires,
+						  struct clock_event_device *);
 	ktime_t			next_event;
 	u64			max_delta_ns;
 	u64			min_delta_ns;

commit d1748302f70be7469809809283fe164156a34231
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Aug 23 15:29:42 2011 +0200

    clockevents: Make minimum delay adjustments configurable
    
    The automatic increase of the min_delta_ns of a clockevents device
    should be done in the clockevents code as the minimum delay is an
    attribute of the clockevents device.
    
    In addition not all architectures want the automatic adjustment, on a
    massively virtualized system it can happen that the programming of a
    clock event fails several times in a row because the virtual cpu has
    been rescheduled quickly enough. In that case the minimum delay will
    erroneously be increased with no way back. The new config symbol
    GENERIC_CLOCKEVENTS_MIN_ADJUST is used to enable the automatic
    adjustment. The config option is selected only for x86.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20110823133142.494157493@de.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index d6733e27af34..39bb050bdbb2 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -140,7 +140,7 @@ extern void clockevents_set_mode(struct clock_event_device *dev,
 				 enum clock_event_mode mode);
 extern int clockevents_register_notifier(struct notifier_block *nb);
 extern int clockevents_program_event(struct clock_event_device *dev,
-				     ktime_t expires, ktime_t now);
+				     ktime_t expires, bool force);
 
 extern void clockevents_handle_noop(struct clock_event_device *dev);
 

commit 80b816b736cfa5b9582279127099b20a479ab7d9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:42 2011 +0000

    clockevents: Provide interface to reconfigure an active clock event device
    
    Some ARM SoCs have clock event devices which have their frequency
    modified due to frequency scaling. Provide an interface which allows
    to reconfigure an active device. After reconfiguration reprogram the
    current pending event.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: LAK <linux-arm-kernel@lists.infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.437459958%40linutronix.de%3E

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 80acc79e0dc5..d6733e27af34 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -132,6 +132,8 @@ extern void clockevents_config_and_register(struct clock_event_device *dev,
 					    u32 freq, unsigned long min_delta,
 					    unsigned long max_delta);
 
+extern int clockevents_update_freq(struct clock_event_device *ce, u32 freq);
+
 extern void clockevents_exchange_device(struct clock_event_device *old,
 					struct clock_event_device *new);
 extern void clockevents_set_mode(struct clock_event_device *dev,

commit 57f0fcbe1dea8a36c9d1673086326059991c5f81
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:41 2011 +0000

    clockevents: Provide combined configure and register function
    
    All clockevent devices have the same open coded initialization
    functions. Provide an interface which does all necessary
    initialization in the core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.331975870%40linutronix.de%3E

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 9466eebc8e19..80acc79e0dc5 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -69,6 +69,8 @@ enum clock_event_nofitiers {
  * @retries:		number of forced programming retries
  * @set_mode:		set mode function
  * @broadcast:		function to broadcast events
+ * @min_delta_ticks:	minimum delta value in ticks stored for reconfiguration
+ * @max_delta_ticks:	maximum delta value in ticks stored for reconfiguration
  * @name:		ptr to clock event name
  * @rating:		variable to rate clock event devices
  * @irq:		IRQ number (only for non CPU local devices)
@@ -91,6 +93,9 @@ struct clock_event_device {
 	void			(*broadcast)(const struct cpumask *mask);
 	void			(*set_mode)(enum clock_event_mode mode,
 					    struct clock_event_device *);
+	unsigned long		min_delta_ticks;
+	unsigned long		max_delta_ticks;
+
 	const char		*name;
 	int			rating;
 	int			irq;
@@ -123,6 +128,10 @@ extern u64 clockevent_delta2ns(unsigned long latch,
 			       struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
 
+extern void clockevents_config_and_register(struct clock_event_device *dev,
+					    u32 freq, unsigned long min_delta,
+					    unsigned long max_delta);
+
 extern void clockevents_exchange_device(struct clock_event_device *old,
 					struct clock_event_device *new);
 extern void clockevents_set_mode(struct clock_event_device *dev,

commit 847b2f42be203f3cff7f243fdd3ee50c1e06c882
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:41 2011 +0000

    clockevents: Restructure clock_event_device members
    
    Group the hot path members of struct clock_event_device together so we
    have a better cache line footprint. Make it cacheline aligned.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.223607682%40linutronix.de%3E

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index fc53492b6ad7..9466eebc8e19 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -56,46 +56,47 @@ enum clock_event_nofitiers {
 
 /**
  * struct clock_event_device - clock event device descriptor
- * @name:		ptr to clock event name
- * @features:		features
+ * @event_handler:	Assigned by the framework to be called by the low
+ *			level handler of the event source
+ * @set_next_event:	set next event function
+ * @next_event:		local storage for the next event in oneshot mode
  * @max_delta_ns:	maximum delta value in ns
  * @min_delta_ns:	minimum delta value in ns
  * @mult:		nanosecond to cycles multiplier
  * @shift:		nanoseconds to cycles divisor (power of two)
+ * @mode:		operating mode assigned by the management code
+ * @features:		features
+ * @retries:		number of forced programming retries
+ * @set_mode:		set mode function
+ * @broadcast:		function to broadcast events
+ * @name:		ptr to clock event name
  * @rating:		variable to rate clock event devices
  * @irq:		IRQ number (only for non CPU local devices)
  * @cpumask:		cpumask to indicate for which CPUs this device works
- * @set_next_event:	set next event function
- * @set_mode:		set mode function
- * @event_handler:	Assigned by the framework to be called by the low
- *			level handler of the event source
- * @broadcast:		function to broadcast events
  * @list:		list head for the management code
- * @mode:		operating mode assigned by the management code
- * @next_event:		local storage for the next event in oneshot mode
- * @retries:		number of forced programming retries
  */
 struct clock_event_device {
-	const char		*name;
-	unsigned int		features;
+	void			(*event_handler)(struct clock_event_device *);
+	int			(*set_next_event)(unsigned long evt,
+						  struct clock_event_device *);
+	ktime_t			next_event;
 	u64			max_delta_ns;
 	u64			min_delta_ns;
 	u32			mult;
 	u32			shift;
+	enum clock_event_mode	mode;
+	unsigned int		features;
+	unsigned long		retries;
+
+	void			(*broadcast)(const struct cpumask *mask);
+	void			(*set_mode)(enum clock_event_mode mode,
+					    struct clock_event_device *);
+	const char		*name;
 	int			rating;
 	int			irq;
 	const struct cpumask	*cpumask;
-	int			(*set_next_event)(unsigned long evt,
-						  struct clock_event_device *);
-	void			(*set_mode)(enum clock_event_mode mode,
-					    struct clock_event_device *);
-	void			(*event_handler)(struct clock_event_device *);
-	void			(*broadcast)(const struct cpumask *mask);
 	struct list_head	list;
-	enum clock_event_mode	mode;
-	ktime_t			next_event;
-	unsigned long		retries;
-};
+} ____cacheline_aligned;
 
 /*
  * Calculate a multiplication factor for scaled math, which is used to convert

commit 80a05b9ffa7dc13f6693902dd8999a2b61a3a0d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 12 17:34:14 2010 +0100

    clockevents: Sanitize min_delta_ns adjustment and prevent overflows
    
    The current logic which handles clock events programming failures can
    increase min_delta_ns unlimited and even can cause overflows.
    
    Sanitize it by:
     - prevent zero increase when min_delta_ns == 1
     - limiting min_delta_ns to a jiffie
     - bail out if the jiffie limit is hit
     - add retries stats for /proc/timer_list so we can gather data
    
    Reported-by: Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 0cf725bdd2a1..fc53492b6ad7 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -73,6 +73,7 @@ enum clock_event_nofitiers {
  * @list:		list head for the management code
  * @mode:		operating mode assigned by the management code
  * @next_event:		local storage for the next event in oneshot mode
+ * @retries:		number of forced programming retries
  */
 struct clock_event_device {
 	const char		*name;
@@ -93,6 +94,7 @@ struct clock_event_device {
 	struct list_head	list;
 	enum clock_event_mode	mode;
 	ktime_t			next_event;
+	unsigned long		retries;
 };
 
 /*

commit 97813f2fe77804a4464564c75ba8d8826377feea
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Aug 18 12:45:11 2009 -0500

    nohz: Allow 32-bit machines to sleep for more than 2.15 seconds
    
    In the dynamic tick code, "max_delta_ns" (member of the
    "clock_event_device" structure) represents the maximum sleep time
    that can occur between timer events in nanoseconds.
    
    The variable, "max_delta_ns", is defined as an unsigned long
    which is a 32-bit integer for 32-bit machines and a 64-bit
    integer for 64-bit machines (if -m64 option is used for gcc).
    The value of max_delta_ns is set by calling the function
    "clockevent_delta2ns()" which returns a maximum value of LONG_MAX.
    For a 32-bit machine LONG_MAX is equal to 0x7fffffff and in
    nanoseconds this equates to ~2.15 seconds. Hence, the maximum
    sleep time for a 32-bit machine is ~2.15 seconds, where as for
    a 64-bit machine it will be many years.
    
    This patch changes the type of max_delta_ns to be "u64" instead of
    "unsigned long" so that this variable is a 64-bit type for both 32-bit
    and 64-bit machines. It also changes the maximum value returned by
    clockevent_delta2ns() to KTIME_MAX.  Hence this allows a 32-bit
    machine to sleep for longer than ~2.15 seconds. Please note that this
    patch also changes "min_delta_ns" to be "u64" too and although this is
    unnecessary, it makes the patch simpler as it avoids to fixup all
    callers of clockevent_delta2ns().
    
    [ tglx: changed "unsigned long long" to u64 as we use this data type
            through out the time code ]
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1250617512-23567-3-git-send-email-jon-hunter@ti.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 4d438b0bc10a..0cf725bdd2a1 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -77,8 +77,8 @@ enum clock_event_nofitiers {
 struct clock_event_device {
 	const char		*name;
 	unsigned int		features;
-	unsigned long		max_delta_ns;
-	unsigned long		min_delta_ns;
+	u64			max_delta_ns;
+	u64			min_delta_ns;
 	u32			mult;
 	u32			shift;
 	int			rating;
@@ -116,8 +116,8 @@ static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
 }
 
 /* Clock event layer functions */
-extern unsigned long clockevent_delta2ns(unsigned long latch,
-					 struct clock_event_device *evt);
+extern u64 clockevent_delta2ns(unsigned long latch,
+			       struct clock_event_device *evt);
 extern void clockevents_register_device(struct clock_event_device *dev);
 
 extern void clockevents_exchange_device(struct clock_event_device *old,

commit 7d2f944a2b836c69a9d260a0a5f0d1720d57fdff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 11 14:05:29 2009 +0000

    clocksource: Provide a generic mult/shift factor calculation
    
    MIPS has two functions to calculcate the mult/shift factors for clock
    sources and clock events at run time. ARM needs such functions as
    well.
    
    Implement a function which calculates the mult/shift factors based on
    the frequencies to which and from which is converted. The function
    also has a parameter to specify the minimum conversion range in
    seconds. This range is guaranteed not to produce a 64bit overflow when
    a value is multiplied with the calculated mult factor. The larger the
    conversion range the less becomes the conversion accuracy.
    
    Provide two inline wrappers which handle clock events and clock
    sources. For clock events the "from" frequency is nano seconds per
    second which corresponds to 1GHz and "to" is the device frequency. For
    clock sources "from" is the device frequency and "to" is nano seconds
    per second.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20091111134229.766673305@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 3b5841016276..4d438b0bc10a 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -130,6 +130,13 @@ extern int clockevents_program_event(struct clock_event_device *dev,
 
 extern void clockevents_handle_noop(struct clock_event_device *dev);
 
+static inline void
+clockevents_calc_mult_shift(struct clock_event_device *ce, u32 freq, u32 minsec)
+{
+	return clocks_calc_mult_shift(&ce->mult, &ce->shift, NSEC_PER_SEC,
+				      freq, minsec);
+}
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else

commit 23af368e9a904f59256c27d371ce223d6cee0430
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 11 14:05:25 2009 +0000

    clockevents: Use u32 for mult and shift factors
    
    The mult and shift factors of clock events differ in their data type
    from those of clock sources for no reason. u32 is sufficient for
    both. shift is always <= 32 and mult is limited to 2^32-1 to avoid
    64bit multiplication overflows in the conversion.
    
    Preparatory patch for a generic mult/shift factor calculation
    function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20091111134229.725664788@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 3a1dbba4d3ae..3b5841016276 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -79,8 +79,8 @@ struct clock_event_device {
 	unsigned int		features;
 	unsigned long		max_delta_ns;
 	unsigned long		min_delta_ns;
-	unsigned long		mult;
-	int			shift;
+	u32			mult;
+	u32			shift;
 	int			rating;
 	int			irq;
 	const struct cpumask	*cpumask;

commit 6ff7041dbfeb3bd7dfe9aa67275c21199ef760d6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 10 14:57:05 2009 +0200

    hrtimer: Fix migration expiry check
    
    The timer migration expiry check should prevent the migration of a
    timer to another CPU when the timer expires before the next event is
    scheduled on the other CPU. Migrating the timer might delay it because
    we can not reprogram the clock event device on the other CPU. But the
    code implementing that check has two flaws:
    
    - for !HIGHRES the check compares the expiry value with the clock
      events device expiry value which is wrong for CLOCK_REALTIME based
      timers.
    
    - the check is racy. It holds the hrtimer base lock of the target CPU,
      but the clock event device expiry value can be modified
      nevertheless, e.g. by an timer interrupt firing.
    
    The !HIGHRES case is easy to fix as we can enqueue the timer on the
    cpu which was selected by the load balancer. It runs the idle
    balancing code once per jiffy anyway. So the maximum delay for the
    timer is the same as when we keep the tick on the current cpu going.
    
    In the HIGHRES case we can get the next expiry value from the hrtimer
    cpu_base of the target CPU and serialize the update with the cpu_base
    lock. This moves the lock section in hrtimer_interrupt() so we can set
    next_event to KTIME_MAX while we are handling the expired timers and
    set it to the next expiry value after we handled the timers under the
    base lock. While the expired timers are processed timer migration is
    blocked because the expiry time of the timer is always <= KTIME_MAX.
    
    Also remove the now useless clockevents_get_next_event() function.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 20a100fe2b4f..3a1dbba4d3ae 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -143,12 +143,3 @@ extern void clockevents_notify(unsigned long reason, void *arg);
 #endif
 
 #endif
-
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
-extern ktime_t clockevents_get_next_event(int cpu);
-#else
-static inline ktime_t clockevents_get_next_event(int cpu)
-{
-	return (ktime_t) { .tv64 = KTIME_MAX };
-}
-#endif

commit eea08f32adb3f97553d49a4f79a119833036000a
Author: Arun R Bharadwaj <arun@linux.vnet.ibm.com>
Date:   Thu Apr 16 12:16:41 2009 +0530

    timers: Logic to move non pinned timers
    
    * Arun R Bharadwaj <arun@linux.vnet.ibm.com> [2009-04-16 12:11:36]:
    
    This patch migrates all non pinned timers and hrtimers to the current
    idle load balancer, from all the idle CPUs. Timers firing on busy CPUs
    are not migrated.
    
    While migrating hrtimers, care should be taken to check if migrating
    a hrtimer would result in a latency or not. So we compare the expiry of the
    hrtimer with the next timer interrupt on the target cpu and migrate the
    hrtimer only if it expires *after* the next interrupt on the target cpu.
    So, added a clockevents_get_next_event() helper function to return the
    next_event on the target cpu's clock_event_device.
    
    [ tglx: cleanups and simplifications ]
    
    Signed-off-by: Arun R Bharadwaj <arun@linux.vnet.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 3a1dbba4d3ae..20a100fe2b4f 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -143,3 +143,12 @@ extern void clockevents_notify(unsigned long reason, void *arg);
 #endif
 
 #endif
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS
+extern ktime_t clockevents_get_next_event(int cpu);
+#else
+static inline ktime_t clockevents_get_next_event(int cpu)
+{
+	return (ktime_t) { .tv64 = KTIME_MAX };
+}
+#endif

commit 94df7de0289bc2df3d6e85cd2ece52bf42682f45
Author: Sebastien Dugue <sebastien.dugue@bull.net>
Date:   Mon Dec 1 14:09:07 2008 +0100

    hrtimers: allow the hot-unplugging of all cpus
    
    Impact: fix CPU hotplug hang on Power6 testbox
    
    On architectures that support offlining all cpus (at least powerpc/pseries),
    hot-unpluging the tick_do_timer_cpu can result in a system hang.
    
    This comes from the fact that if the cpu going down happens to be the
    cpu doing the tick, then as the tick_do_timer_cpu handover happens after the
    cpu is dead (via the CPU_DEAD notification), we're left without ticks,
    jiffies are frozen and any task relying on timers (msleep, ...) is stuck.
    That's particularly the case for the cpu looping in __cpu_die() waiting
    for the dying cpu to be dead.
    
    This patch addresses this by having the tick_do_timer_cpu handover happen
    earlier during the CPU_DYING notification. For this, a new clockevent
    notification type is introduced (CLOCK_EVT_NOTIFY_CPU_DYING) which is triggered
    in hrtimer_cpu_notify().
    
    Signed-off-by: Sebastien Dugue <sebastien.dugue@bull.net>
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index cea153697ec7..3a1dbba4d3ae 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -36,6 +36,7 @@ enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
 	CLOCK_EVT_NOTIFY_SUSPEND,
 	CLOCK_EVT_NOTIFY_RESUME,
+	CLOCK_EVT_NOTIFY_CPU_DYING,
 	CLOCK_EVT_NOTIFY_CPU_DEAD,
 };
 

commit 320ab2b0b1e08e3805a3e1084a2f0eb1938d5d67
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: convert struct clock_event_device to cpumask pointers.
    
    Impact: change calling convention of existing clock_event APIs
    
    struct clock_event_timer's cpumask field gets changed to take pointer,
    as does the ->broadcast function.
    
    Another single-patch change.  For safety, we BUG_ON() in
    clockevents_register_device() if it's not set.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index ed3a5d473e52..cea153697ec7 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -82,13 +82,13 @@ struct clock_event_device {
 	int			shift;
 	int			rating;
 	int			irq;
-	cpumask_t		cpumask;
+	const struct cpumask	*cpumask;
 	int			(*set_next_event)(unsigned long evt,
 						  struct clock_event_device *);
 	void			(*set_mode)(enum clock_event_mode mode,
 					    struct clock_event_device *);
 	void			(*event_handler)(struct clock_event_device *);
-	void			(*broadcast)(cpumask_t mask);
+	void			(*broadcast)(const struct cpumask *mask);
 	struct list_head	list;
 	enum clock_event_mode	mode;
 	ktime_t			next_event;

commit 7c1e76897492d92b6a1c2d6892494d39ded9680c
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed Sep 3 21:36:50 2008 +0000

    clockevents: prevent clockevent event_handler ending up handler_noop
    
    There is a ordering related problem with clockevents code, due to which
    clockevents_register_device() called after tickless/highres switch
    will not work. The new clockevent ends up with clockevents_handle_noop as
    event handler, resulting in no timer activity.
    
    The problematic path seems to be
    
    * old device already has hrtimer_interrupt as the event_handler
    * new clockevent device registers with a higher rating
    * tick_check_new_device() is called
      * clockevents_exchange_device() gets called
        * old->event_handler is set to clockevents_handle_noop
      * tick_setup_device() is called for the new device
        * which sets new->event_handler using the old->event_handler which is noop.
    
    Change the ordering so that new device inherits the proper handler.
    
    This does not have any issue in normal case as most likely all the clockevent
    devices are setup before the highres switch. But, can potentially be affecting
    some corner case where HPET force detect happens after the highres switch.
    This was a problem with HPET in MSI mode code that we have been experimenting
    with.
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index c33b0dc28e4d..ed3a5d473e52 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -127,6 +127,8 @@ extern int clockevents_register_notifier(struct notifier_block *nb);
 extern int clockevents_program_event(struct clock_event_device *dev,
 				     ktime_t expires, ktime_t now);
 
+extern void clockevents_handle_noop(struct clock_event_device *dev);
+
 #ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
 #else

commit 1595f452f3d8daa066bfd3ba4120754bed3329e1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 14 22:57:45 2007 +0200

    clockevents: introduce force broadcast notifier
    
    The 64bit SMP bootup is slightly different to the 32bit one. It enables
    the boot CPU local APIC timer before all CPUs are brought up. Some AMD C1E
    systems have the C1E feature flag only set in the secondary CPU. Due to
    the early enable of the boot CPU local APIC timer the APIC timer is
    registered as a fully functional device. When we detect the wreckage during
    the bringup of the secondary CPU, we need to force the boot CPU into
    broadcast mode.
    
    Add a new notifier reason and implement the force broadcast in the clock
    events layer.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index d2ddea926895..c33b0dc28e4d 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -31,6 +31,7 @@ enum clock_event_nofitiers {
 	CLOCK_EVT_NOTIFY_ADD,
 	CLOCK_EVT_NOTIFY_BROADCAST_ON,
 	CLOCK_EVT_NOTIFY_BROADCAST_OFF,
+	CLOCK_EVT_NOTIFY_BROADCAST_FORCE,
 	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
 	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
 	CLOCK_EVT_NOTIFY_SUSPEND,

commit de68d9b173ee657115dd0e584c2365b7954253a5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:05 2007 +0200

    clockevents: Allow build w/o run-tine usage for migration purposes
    
    Migration aid to allow preparatory patches which introduce not yet
    used parts of clock events code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index f368a6fe8cc9..d2ddea926895 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -8,7 +8,7 @@
 #ifndef _LINUX_CLOCKCHIPS_H
 #define _LINUX_CLOCKCHIPS_H
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BUILD
 
 #include <linux/clocksource.h>
 #include <linux/cpumask.h>
@@ -126,9 +126,13 @@ extern int clockevents_register_notifier(struct notifier_block *nb);
 extern int clockevents_program_event(struct clock_event_device *dev,
 				     ktime_t expires, ktime_t now);
 
+#ifdef CONFIG_GENERIC_CLOCKEVENTS
 extern void clockevents_notify(unsigned long reason, void *arg);
-
 #else
+# define clockevents_notify(reason, arg) do { } while (0)
+#endif
+
+#else /* CONFIG_GENERIC_CLOCKEVENTS_BUILD */
 
 #define clockevents_notify(reason, arg) do { } while (0)
 

commit 7f8033b76c8eea89dec9f658f4a31bcd4fe84bbb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 12 23:04:05 2007 +0200

    clockevents: Remove unused inline function
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index def5a659b8a5..f368a6fe8cc9 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -130,7 +130,6 @@ extern void clockevents_notify(unsigned long reason, void *arg);
 
 #else
 
-static inline void clockevents_resume_events(void) { }
 #define clockevents_notify(reason, arg) do { } while (0)
 
 #endif

commit 6ddfca9548d8ecc26096a30667423ba919109533
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Fri Aug 10 13:01:09 2007 -0700

    timer: remove clockevents_unregister_notifier
    
    I find a function(clockevents_unregister_notifier) which is not called by
    anything in tree.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index e0bd46eb2414..def5a659b8a5 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -123,7 +123,6 @@ extern void clockevents_exchange_device(struct clock_event_device *old,
 extern void clockevents_set_mode(struct clock_event_device *dev,
 				 enum clock_event_mode mode);
 extern int clockevents_register_notifier(struct notifier_block *nb);
-extern void clockevents_unregister_notifier(struct notifier_block *nb);
 extern int clockevents_program_event(struct clock_event_device *dev,
 				     ktime_t expires, ktime_t now);
 

commit 18de5bc4c1f1f1fa5e14f354a7603bd6e9d4e3b6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:34 2007 -0700

    clockevents: fix resume logic
    
    We need to make sure, that the clockevent devices are resumed, before
    the tick is resumed. The current resume logic does not guarantee this.
    
    Add CLOCK_EVT_MODE_RESUME and call the set mode functions of the clock
    event devices before resuming the tick / oneshot functionality.
    
    Fixup the existing users.
    
    Thanks to Nigel Cunningham for tracking down a long standing thinko,
    which affected the jinxed VAIO.
    
    [akpm@linux-foundation.org: xen build fix]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 8d7a39019ace..e0bd46eb2414 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -23,6 +23,7 @@ enum clock_event_mode {
 	CLOCK_EVT_MODE_SHUTDOWN,
 	CLOCK_EVT_MODE_PERIODIC,
 	CLOCK_EVT_MODE_ONESHOT,
+	CLOCK_EVT_MODE_RESUME,
 };
 
 /* Clock event notification values */

commit 93da56efcf8c6a111f0349f6b7651172d4745ca0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:33 2007 -0700

    clockevents: remove prototypes of removed functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 8486e78f7335..8d7a39019ace 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -119,10 +119,6 @@ extern void clockevents_register_device(struct clock_event_device *dev);
 
 extern void clockevents_exchange_device(struct clock_event_device *old,
 					struct clock_event_device *new);
-extern
-struct clock_event_device *clockevents_request_device(unsigned int features,
-						      cpumask_t cpumask);
-extern void clockevents_release_device(struct clock_event_device *dev);
 extern void clockevents_set_mode(struct clock_event_device *dev,
 				 enum clock_event_mode mode);
 extern int clockevents_register_notifier(struct notifier_block *nb);

commit ce0be1273d1473a5a7b57bf0b4995b40c22d6b54
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Tue May 8 00:31:55 2007 -0700

    clockchips.h: kernel-doc fix
    
    Fix misnamed fields of 'struct clock_event_device' in the kernel-doc
    comment.  Convert the acronyms to uppercase, while at it...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
index 4ea7e7bcfafe..8486e78f7335 100644
--- a/include/linux/clockchips.h
+++ b/include/linux/clockchips.h
@@ -54,17 +54,17 @@ enum clock_event_nofitiers {
 /**
  * struct clock_event_device - clock event device descriptor
  * @name:		ptr to clock event name
- * @hints:		usage hints
+ * @features:		features
  * @max_delta_ns:	maximum delta value in ns
  * @min_delta_ns:	minimum delta value in ns
  * @mult:		nanosecond to cycles multiplier
  * @shift:		nanoseconds to cycles divisor (power of two)
  * @rating:		variable to rate clock event devices
- * @irq:		irq number (only for non cpu local devices)
- * @cpumask:		cpumask to indicate for which cpus this device works
- * @set_next_event:	set next event
+ * @irq:		IRQ number (only for non CPU local devices)
+ * @cpumask:		cpumask to indicate for which CPUs this device works
+ * @set_next_event:	set next event function
  * @set_mode:		set mode function
- * @evthandler:		Assigned by the framework to be called by the low
+ * @event_handler:	Assigned by the framework to be called by the low
  *			level handler of the event source
  * @broadcast:		function to broadcast events
  * @list:		list head for the management code

commit d316c57ff6bfad9557462b9100f25c6260d2b774
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:28:00 2007 -0800

    [PATCH] clockevents: add core functionality
    
    Architectures register their clock event devices, in the clock events core.
    Users of the clockevents core can get clock event devices for their use.  The
    clockevents core code provides notification mechanisms for various clock
    related management events.
    
    This allows to control the clock event devices without the architectures
    having to worry about the details of function assignment.  This is also a
    preliminary for high resolution timers and dynamic ticks to allow the core
    code to control the clock functionality without intrusive changes to the
    architecture code.
    
    [Fixes-by: Ingo Molnar <mingo@elte.hu>]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clockchips.h b/include/linux/clockchips.h
new file mode 100644
index 000000000000..4ea7e7bcfafe
--- /dev/null
+++ b/include/linux/clockchips.h
@@ -0,0 +1,142 @@
+/*  linux/include/linux/clockchips.h
+ *
+ *  This file contains the structure definitions for clockchips.
+ *
+ *  If you are not a clockchip, or the time of day code, you should
+ *  not be including this file!
+ */
+#ifndef _LINUX_CLOCKCHIPS_H
+#define _LINUX_CLOCKCHIPS_H
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS
+
+#include <linux/clocksource.h>
+#include <linux/cpumask.h>
+#include <linux/ktime.h>
+#include <linux/notifier.h>
+
+struct clock_event_device;
+
+/* Clock event mode commands */
+enum clock_event_mode {
+	CLOCK_EVT_MODE_UNUSED = 0,
+	CLOCK_EVT_MODE_SHUTDOWN,
+	CLOCK_EVT_MODE_PERIODIC,
+	CLOCK_EVT_MODE_ONESHOT,
+};
+
+/* Clock event notification values */
+enum clock_event_nofitiers {
+	CLOCK_EVT_NOTIFY_ADD,
+	CLOCK_EVT_NOTIFY_BROADCAST_ON,
+	CLOCK_EVT_NOTIFY_BROADCAST_OFF,
+	CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
+	CLOCK_EVT_NOTIFY_BROADCAST_EXIT,
+	CLOCK_EVT_NOTIFY_SUSPEND,
+	CLOCK_EVT_NOTIFY_RESUME,
+	CLOCK_EVT_NOTIFY_CPU_DEAD,
+};
+
+/*
+ * Clock event features
+ */
+#define CLOCK_EVT_FEAT_PERIODIC		0x000001
+#define CLOCK_EVT_FEAT_ONESHOT		0x000002
+/*
+ * x86(64) specific misfeatures:
+ *
+ * - Clockevent source stops in C3 State and needs broadcast support.
+ * - Local APIC timer is used as a dummy device.
+ */
+#define CLOCK_EVT_FEAT_C3STOP		0x000004
+#define CLOCK_EVT_FEAT_DUMMY		0x000008
+
+/**
+ * struct clock_event_device - clock event device descriptor
+ * @name:		ptr to clock event name
+ * @hints:		usage hints
+ * @max_delta_ns:	maximum delta value in ns
+ * @min_delta_ns:	minimum delta value in ns
+ * @mult:		nanosecond to cycles multiplier
+ * @shift:		nanoseconds to cycles divisor (power of two)
+ * @rating:		variable to rate clock event devices
+ * @irq:		irq number (only for non cpu local devices)
+ * @cpumask:		cpumask to indicate for which cpus this device works
+ * @set_next_event:	set next event
+ * @set_mode:		set mode function
+ * @evthandler:		Assigned by the framework to be called by the low
+ *			level handler of the event source
+ * @broadcast:		function to broadcast events
+ * @list:		list head for the management code
+ * @mode:		operating mode assigned by the management code
+ * @next_event:		local storage for the next event in oneshot mode
+ */
+struct clock_event_device {
+	const char		*name;
+	unsigned int		features;
+	unsigned long		max_delta_ns;
+	unsigned long		min_delta_ns;
+	unsigned long		mult;
+	int			shift;
+	int			rating;
+	int			irq;
+	cpumask_t		cpumask;
+	int			(*set_next_event)(unsigned long evt,
+						  struct clock_event_device *);
+	void			(*set_mode)(enum clock_event_mode mode,
+					    struct clock_event_device *);
+	void			(*event_handler)(struct clock_event_device *);
+	void			(*broadcast)(cpumask_t mask);
+	struct list_head	list;
+	enum clock_event_mode	mode;
+	ktime_t			next_event;
+};
+
+/*
+ * Calculate a multiplication factor for scaled math, which is used to convert
+ * nanoseconds based values to clock ticks:
+ *
+ * clock_ticks = (nanoseconds * factor) >> shift.
+ *
+ * div_sc is the rearranged equation to calculate a factor from a given clock
+ * ticks / nanoseconds ratio:
+ *
+ * factor = (clock_ticks << shift) / nanoseconds
+ */
+static inline unsigned long div_sc(unsigned long ticks, unsigned long nsec,
+				   int shift)
+{
+	uint64_t tmp = ((uint64_t)ticks) << shift;
+
+	do_div(tmp, nsec);
+	return (unsigned long) tmp;
+}
+
+/* Clock event layer functions */
+extern unsigned long clockevent_delta2ns(unsigned long latch,
+					 struct clock_event_device *evt);
+extern void clockevents_register_device(struct clock_event_device *dev);
+
+extern void clockevents_exchange_device(struct clock_event_device *old,
+					struct clock_event_device *new);
+extern
+struct clock_event_device *clockevents_request_device(unsigned int features,
+						      cpumask_t cpumask);
+extern void clockevents_release_device(struct clock_event_device *dev);
+extern void clockevents_set_mode(struct clock_event_device *dev,
+				 enum clock_event_mode mode);
+extern int clockevents_register_notifier(struct notifier_block *nb);
+extern void clockevents_unregister_notifier(struct notifier_block *nb);
+extern int clockevents_program_event(struct clock_event_device *dev,
+				     ktime_t expires, ktime_t now);
+
+extern void clockevents_notify(unsigned long reason, void *arg);
+
+#else
+
+static inline void clockevents_resume_events(void) { }
+#define clockevents_notify(reason, arg) do { } while (0)
+
+#endif
+
+#endif
