commit eaf8e3e4b54a8b778257fc3921ad8f793c941882
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 25 09:57:03 2020 +0200

    cdrom: factor out a cdrom_multisession helper
    
    Factor out a version of the CDROMMULTISESSION ioctl handler that can
    be called directly from kernel space.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 008c4d79fa33..8543fa59da72 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -94,6 +94,8 @@ struct cdrom_device_ops {
 			       struct packet_command *);
 };
 
+int cdrom_multisession(struct cdrom_device_info *cdi,
+		struct cdrom_multisession *info);
 int cdrom_read_tocentry(struct cdrom_device_info *cdi,
 		struct cdrom_tocentry *entry);
 

commit 4c3cfcce45152309c2031b3b87bcf10e4f3899e1
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 25 09:57:02 2020 +0200

    cdrom: factor out a cdrom_read_tocentry helper
    
    Factor out a version of the CDROMREADTOCENTRY ioctl handler that can
    be called directly from kernel space.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 4f74ce050253..008c4d79fa33 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -94,6 +94,9 @@ struct cdrom_device_ops {
 			       struct packet_command *);
 };
 
+int cdrom_read_tocentry(struct cdrom_device_info *cdi,
+		struct cdrom_tocentry *entry);
+
 /* the general block_device operations structure: */
 extern int cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev,
 			fmode_t mode);

commit a711d91cd97e6c9a554ccd1652527a7f36661857
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 25 09:57:00 2020 +0200

    block: add a cdrom_device_info pointer to struct gendisk
    
    Add a pointer to the CDROM information structure to struct gendisk.
    This will allow various removable media file systems to call directly
    into the CDROM layer instead of abusing ioctls with kernel pointers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 528271c60018..4f74ce050253 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -104,7 +104,7 @@ extern unsigned int cdrom_check_events(struct cdrom_device_info *cdi,
 				       unsigned int clearing);
 extern int cdrom_media_changed(struct cdrom_device_info *);
 
-extern int register_cdrom(struct cdrom_device_info *cdi);
+extern int register_cdrom(struct gendisk *disk, struct cdrom_device_info *cdi);
 extern void unregister_cdrom(struct cdrom_device_info *cdi);
 
 typedef struct {

commit e7d0748dd71695b94f3a35c8bdc05226a7f3d919
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Aug 2 15:22:13 2018 -0600

    block: Switch struct packet_command to use struct scsi_sense_hdr
    
    There is a lot of needless struct request_sense usage in the CDROM
    code. These can all be struct scsi_sense_hdr instead, to avoid any
    confusion over their respective structure sizes. This patch is a lot
    of noise changing "sense" to "sshdr", but the final code is more
    readable to distinguish between "sense" meaning "struct request_sense"
    and "sshdr" meaning "struct scsi_sense_hdr".
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index e75dfd1f1dec..528271c60018 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -13,6 +13,7 @@
 
 #include <linux/fs.h>		/* not really needed, later.. */
 #include <linux/list.h>
+#include <scsi/scsi_common.h>
 #include <uapi/linux/cdrom.h>
 
 struct packet_command
@@ -21,7 +22,7 @@ struct packet_command
 	unsigned char 		*buffer;
 	unsigned int 		buflen;
 	int			stat;
-	struct request_sense	*sense;
+	struct scsi_sense_hdr	*sshdr;
 	unsigned char		data_direction;
 	int			quiet;
 	int			timeout;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 6e8f209a6dff..e75dfd1f1dec 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * -- <linux/cdrom.h>
  * General header file for linux CD-ROM drivers 

commit 853fe1bf7554155376bb3b231112cdff9ff79177
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Feb 13 16:25:26 2017 -0800

    cdrom: Make device operations read-only
    
    Since function tables are a common target for attackers, it's best to keep
    them in read-only memory. As such, this makes the CDROM device ops tables
    const. This drops additionally n_minors, since it isn't used meaningfully,
    and sets the only user of cdrom_dummy_generic_packet explicitly so the
    variables can all be const.
    
    Inspired by similar changes in grsecurity/PaX.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 8609d577bb66..6e8f209a6dff 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -36,7 +36,7 @@ struct packet_command
 
 /* Uniform cdrom data structures for cdrom.c */
 struct cdrom_device_info {
-	struct cdrom_device_ops  *ops;  /* link to device_ops */
+	const struct cdrom_device_ops *ops; /* link to device_ops */
 	struct list_head list;		/* linked list of all device_info */
 	struct gendisk *disk;		/* matching block layer disk */
 	void *handle;		        /* driver-dependent data */
@@ -87,7 +87,6 @@ struct cdrom_device_ops {
 
 /* driver specifications */
 	const int capability;   /* capability flags */
-	int n_minors;           /* number of active minor devices */
 	/* handle uniform packets for scsi type devices (scsi,atapi) */
 	int (*generic_packet) (struct cdrom_device_info *,
 			       struct packet_command *);
@@ -123,6 +122,8 @@ extern int cdrom_mode_sense(struct cdrom_device_info *cdi,
 			    int page_code, int page_control);
 extern void init_cdrom_command(struct packet_command *cgc,
 			       void *buffer, int len, int type);
+extern int cdrom_dummy_generic_packet(struct cdrom_device_info *cdi,
+				      struct packet_command *cgc);
 
 /* The SCSI spec says there could be 256 slots. */
 #define CDROM_MAX_SLOTS	256

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index dfd7f187c351..8609d577bb66 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -7,910 +7,12 @@
  *               1997, 1998   Erik Andersen, andersee@debian.org
  *               1998-2002    Jens Axboe, axboe@suse.de
  */
- 
 #ifndef	_LINUX_CDROM_H
 #define	_LINUX_CDROM_H
 
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-/*******************************************************
- * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
- * (and only this) include file.  It is my hope to provide Linux with
- * a uniform interface between software accessing CD-ROMs and the various 
- * device drivers that actually talk to the drives.  There may still be
- * 23 different kinds of strange CD-ROM drives, but at least there will 
- * now be one, and only one, Linux CD-ROM interface.
- *
- * Additionally, as of Linux 2.1.x, all Linux application programs 
- * should use the O_NONBLOCK option when opening a CD-ROM device 
- * for subsequent ioctl commands.  This allows for neat system errors 
- * like "No medium found" or "Wrong medium type" upon attempting to 
- * mount or play an empty slot, mount an audio disc, or play a data disc.
- * Generally, changing an application program to support O_NONBLOCK
- * is as easy as the following:
- *       -    drive = open("/dev/cdrom", O_RDONLY);
- *       +    drive = open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
- * It is worth the small change.
- *
- *  Patches for many common CD programs (provided by David A. van Leeuwen)
- *  can be found at:  ftp://ftp.gwdg.de/pub/linux/cdrom/drivers/cm206/
- * 
- *******************************************************/
-
-/* When a driver supports a certain function, but the cdrom drive we are 
- * using doesn't, we will return the error EDRIVE_CANT_DO_THIS.  We will 
- * borrow the "Operation not supported" error from the network folks to 
- * accomplish this.  Maybe someday we will get a more targeted error code, 
- * but this will do for now... */
-#define EDRIVE_CANT_DO_THIS  EOPNOTSUPP
-
-/*******************************************************
- * The CD-ROM IOCTL commands  -- these should be supported by 
- * all the various cdrom drivers.  For the CD-ROM ioctls, we 
- * will commandeer byte 0x53, or 'S'.
- *******************************************************/
-#define CDROMPAUSE		0x5301 /* Pause Audio Operation */ 
-#define CDROMRESUME		0x5302 /* Resume paused Audio Operation */
-#define CDROMPLAYMSF		0x5303 /* Play Audio MSF (struct cdrom_msf) */
-#define CDROMPLAYTRKIND		0x5304 /* Play Audio Track/index 
-                                           (struct cdrom_ti) */
-#define CDROMREADTOCHDR		0x5305 /* Read TOC header 
-                                           (struct cdrom_tochdr) */
-#define CDROMREADTOCENTRY	0x5306 /* Read TOC entry 
-                                           (struct cdrom_tocentry) */
-#define CDROMSTOP		0x5307 /* Stop the cdrom drive */
-#define CDROMSTART		0x5308 /* Start the cdrom drive */
-#define CDROMEJECT		0x5309 /* Ejects the cdrom media */
-#define CDROMVOLCTRL		0x530a /* Control output volume 
-                                           (struct cdrom_volctrl) */
-#define CDROMSUBCHNL		0x530b /* Read subchannel data 
-                                           (struct cdrom_subchnl) */
-#define CDROMREADMODE2		0x530c /* Read CDROM mode 2 data (2336 Bytes) 
-                                           (struct cdrom_read) */
-#define CDROMREADMODE1		0x530d /* Read CDROM mode 1 data (2048 Bytes)
-                                           (struct cdrom_read) */
-#define CDROMREADAUDIO		0x530e /* (struct cdrom_read_audio) */
-#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
-#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
-                                           address of multi session disks 
-                                           (struct cdrom_multisession) */
-#define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
-                                           if available (struct cdrom_mcn) */
-#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is deprecated, 
-                                          but here anyway for compatibility */
-#define CDROMRESET		0x5312 /* hard-reset the drive */
-#define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
-                                          (struct cdrom_volctrl) */
-#define CDROMREADRAW		0x5314	/* read data in raw mode (2352 Bytes)
-                                           (struct cdrom_read) */
-/* 
- * These ioctls are used only used in aztcd.c and optcd.c
- */
-#define CDROMREADCOOKED		0x5315	/* read data in cooked mode */
-#define CDROMSEEK		0x5316  /* seek msf address */
-  
-/*
- * This ioctl is only used by the scsi-cd driver.  
-   It is for playing audio in logical block addressing mode.
- */
-#define CDROMPLAYBLK		0x5317	/* (struct cdrom_blk) */
-
-/* 
- * These ioctls are only used in optcd.c
- */
-#define CDROMREADALL		0x5318	/* read all 2646 bytes */
-
-/* 
- * These ioctls are (now) only in ide-cd.c for controlling 
- * drive spindown time.  They should be implemented in the
- * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,
- * GPCMD_MODE_SENSE_10 and the GPMODE_POWER_PAGE...
- *  -Erik
- */
-#define CDROMGETSPINDOWN        0x531d
-#define CDROMSETSPINDOWN        0x531e
-
-/* 
- * These ioctls are implemented through the uniform CD-ROM driver
- * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
- * drivers are eventually ported to the uniform CD-ROM driver interface.
- */
-#define CDROMCLOSETRAY		0x5319	/* pendant of CDROMEJECT */
-#define CDROM_SET_OPTIONS	0x5320  /* Set behavior options */
-#define CDROM_CLEAR_OPTIONS	0x5321  /* Clear behavior options */
-#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
-#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
-#define CDROM_MEDIA_CHANGED	0x5325  /* Check is media changed  */
-#define CDROM_DRIVE_STATUS	0x5326  /* Get tray position, etc. */
-#define CDROM_DISC_STATUS	0x5327  /* Get disc type, etc. */
-#define CDROM_CHANGER_NSLOTS    0x5328  /* Get number of slots */
-#define CDROM_LOCKDOOR		0x5329  /* lock or unlock door */
-#define CDROM_DEBUG		0x5330	/* Turn debug messages on/off */
-#define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */
-
-/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
- * Future CDROM ioctls should be kept below 0x537F
- */
-
-/* This ioctl is only used by sbpcd at the moment */
-#define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */
-					/* conflict with SCSI_IOCTL_GET_IDLUN */
-
-/* DVD-ROM Specific ioctls */
-#define DVD_READ_STRUCT		0x5390  /* Read structure */
-#define DVD_WRITE_STRUCT	0x5391  /* Write structure */
-#define DVD_AUTH		0x5392  /* Authentication */
-
-#define CDROM_SEND_PACKET	0x5393	/* send a packet to the drive */
-#define CDROM_NEXT_WRITABLE	0x5394	/* get next writable block */
-#define CDROM_LAST_WRITTEN	0x5395	/* get last block written on disc */
-
-/*******************************************************
- * CDROM IOCTL structures
- *******************************************************/
-
-/* Address in MSF format */
-struct cdrom_msf0		
-{
-	__u8	minute;
-	__u8	second;
-	__u8	frame;
-};
-
-/* Address in either MSF or logical format */
-union cdrom_addr		
-{
-	struct cdrom_msf0	msf;
-	int			lba;
-};
-
-/* This struct is used by the CDROMPLAYMSF ioctl */ 
-struct cdrom_msf 
-{
-	__u8	cdmsf_min0;	/* start minute */
-	__u8	cdmsf_sec0;	/* start second */
-	__u8	cdmsf_frame0;	/* start frame */
-	__u8	cdmsf_min1;	/* end minute */
-	__u8	cdmsf_sec1;	/* end second */
-	__u8	cdmsf_frame1;	/* end frame */
-};
-
-/* This struct is used by the CDROMPLAYTRKIND ioctl */
-struct cdrom_ti 
-{
-	__u8	cdti_trk0;	/* start track */
-	__u8	cdti_ind0;	/* start index */
-	__u8	cdti_trk1;	/* end track */
-	__u8	cdti_ind1;	/* end index */
-};
-
-/* This struct is used by the CDROMREADTOCHDR ioctl */
-struct cdrom_tochdr 	
-{
-	__u8	cdth_trk0;	/* start track */
-	__u8	cdth_trk1;	/* end track */
-};
-
-/* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */
-struct cdrom_volctrl
-{
-	__u8	channel0;
-	__u8	channel1;
-	__u8	channel2;
-	__u8	channel3;
-};
-
-/* This struct is used by the CDROMSUBCHNL ioctl */
-struct cdrom_subchnl 
-{
-	__u8	cdsc_format;
-	__u8	cdsc_audiostatus;
-	__u8	cdsc_adr:	4;
-	__u8	cdsc_ctrl:	4;
-	__u8	cdsc_trk;
-	__u8	cdsc_ind;
-	union cdrom_addr cdsc_absaddr;
-	union cdrom_addr cdsc_reladdr;
-};
-
-
-/* This struct is used by the CDROMREADTOCENTRY ioctl */
-struct cdrom_tocentry 
-{
-	__u8	cdte_track;
-	__u8	cdte_adr	:4;
-	__u8	cdte_ctrl	:4;
-	__u8	cdte_format;
-	union cdrom_addr cdte_addr;
-	__u8	cdte_datamode;
-};
-
-/* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */
-struct cdrom_read      
-{
-	int	cdread_lba;
-	char 	*cdread_bufaddr;
-	int	cdread_buflen;
-};
-
-/* This struct is used by the CDROMREADAUDIO ioctl */
-struct cdrom_read_audio
-{
-	union cdrom_addr addr; /* frame address */
-	__u8 addr_format;      /* CDROM_LBA or CDROM_MSF */
-	int nframes;           /* number of 2352-byte-frames to read at once */
-	__u8 __user *buf;      /* frame buffer (size: nframes*2352 bytes) */
-};
-
-/* This struct is used with the CDROMMULTISESSION ioctl */
-struct cdrom_multisession
-{
-	union cdrom_addr addr; /* frame address: start-of-last-session 
-	                           (not the new "frame 16"!).  Only valid
-	                           if the "xa_flag" is true. */
-	__u8 xa_flag;        /* 1: "is XA disk" */
-	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
-};
-
-/* This struct is used with the CDROM_GET_MCN ioctl.  
- * Very few audio discs actually have Universal Product Code information, 
- * which should just be the Medium Catalog Number on the box.  Also note 
- * that the way the codeis written on CD is _not_ uniform across all discs!
- */  
-struct cdrom_mcn 
-{
-  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
-};
-
-/* This is used by the CDROMPLAYBLK ioctl */
-struct cdrom_blk 
-{
-	unsigned from;
-	unsigned short len;
-};
-
-#define CDROM_PACKET_SIZE	12
-
-#define CGC_DATA_UNKNOWN	0
-#define CGC_DATA_WRITE		1
-#define CGC_DATA_READ		2
-#define CGC_DATA_NONE		3
-
-/* for CDROM_PACKET_COMMAND ioctl */
-struct cdrom_generic_command
-{
-	unsigned char 		cmd[CDROM_PACKET_SIZE];
-	unsigned char		__user *buffer;
-	unsigned int 		buflen;
-	int			stat;
-	struct request_sense	__user *sense;
-	unsigned char		data_direction;
-	int			quiet;
-	int			timeout;
-	void			__user *reserved[1];	/* unused, actually */
-};
-
-/*
- * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
- * 2340, or 2352 bytes long.  
-
-*         Sector types of the standard CD-ROM data formats:
- *
- * format   sector type               user data size (bytes)
- * -----------------------------------------------------------------------------
- *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
- *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
- *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
- *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
- *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
- *
- *
- *       The layout of the standard CD-ROM data formats:
- * -----------------------------------------------------------------------------
- * - audio (red):                  | audio_sample_bytes |
- *                                 |        2352        |
- *
- * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
- *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
- *
- * - data (yellow, mode2):         | sync - head - data |
- *                                 |  12  -   4  - 2336 |
- *
- * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
- *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
- *
- * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
- *                                 |  12  -   4  -  8  - 2324 -  4    |
- *
- */
-
-/* Some generally useful CD-ROM information -- mostly based on the above */
-#define CD_MINS              74 /* max. minutes per CD, not really a limit */
-#define CD_SECS              60 /* seconds per minute */
-#define CD_FRAMES            75 /* frames per second */
-#define CD_SYNC_SIZE         12 /* 12 sync bytes per raw data frame */
-#define CD_MSF_OFFSET       150 /* MSF numbering offset of first frame */
-#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
-#define CD_NUM_OF_CHUNKS     98 /* chunks per frame */
-#define CD_FRAMESIZE_SUB     96 /* subchannel data "frame" size */
-#define CD_HEAD_SIZE          4 /* header (address) bytes per raw data frame */
-#define CD_SUBHEAD_SIZE       8 /* subheader bytes per raw XA data frame */
-#define CD_EDC_SIZE           4 /* bytes EDC per most raw data frame types */
-#define CD_ZERO_SIZE          8 /* bytes zero per yellow book mode 1 frame */
-#define CD_ECC_SIZE         276 /* bytes ECC per most raw data frame types */
-#define CD_FRAMESIZE       2048 /* bytes per frame, "cooked" mode */
-#define CD_FRAMESIZE_RAW   2352 /* bytes per frame, "raw" mode */
-#define CD_FRAMESIZE_RAWER 2646 /* The maximum possible returned bytes */ 
-/* most drives don't deliver everything: */
-#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
-#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
-
-#define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* "before data" part of raw XA frame */
-#define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* "after data" part of raw XA frame */
-#define CD_XA_SYNC_HEAD   (CD_SYNC_SIZE+CD_XA_HEAD) /* sync bytes + header of XA frame */
-
-/* CD-ROM address types (cdrom_tocentry.cdte_format) */
-#define	CDROM_LBA 0x01 /* "logical block": first frame is #0 */
-#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */
-
-/* bit to tell whether track is data or audio (cdrom_tocentry.cdte_ctrl) */
-#define	CDROM_DATA_TRACK	0x04
-
-/* The leadout track is always 0xAA, regardless of # of tracks on disc */
-#define	CDROM_LEADOUT		0xAA
-
-/* audio states (from SCSI-2, but seen with other drives, too) */
-#define	CDROM_AUDIO_INVALID	0x00	/* audio status not supported */
-#define	CDROM_AUDIO_PLAY	0x11	/* audio play operation in progress */
-#define	CDROM_AUDIO_PAUSED	0x12	/* audio play operation paused */
-#define	CDROM_AUDIO_COMPLETED	0x13	/* audio play successfully completed */
-#define	CDROM_AUDIO_ERROR	0x14	/* audio play stopped due to error */
-#define	CDROM_AUDIO_NO_STATUS	0x15	/* no current audio status to return */
-
-/* capability flags used with the uniform CD-ROM driver */ 
-#define CDC_CLOSE_TRAY		0x1     /* caddy systems _can't_ close */
-#define CDC_OPEN_TRAY		0x2     /* but _can_ eject.  */
-#define CDC_LOCK		0x4     /* disable manual eject */
-#define CDC_SELECT_SPEED 	0x8     /* programmable speed */
-#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
-#define CDC_MULTI_SESSION 	0x20    /* read sessions>1 */
-#define CDC_MCN			0x40    /* Medium Catalog Number */
-#define CDC_MEDIA_CHANGED 	0x80    /* media changed */
-#define CDC_PLAY_AUDIO		0x100   /* audio functions */
-#define CDC_RESET               0x200   /* hard reset device */
-#define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
-#define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
-#define CDC_CD_R		0x2000	/* drive is a CD-R */
-#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
-#define CDC_DVD			0x8000	/* drive is a DVD */
-#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
-#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
-#define CDC_MO_DRIVE		0x40000 /* drive is an MO device */
-#define CDC_MRW			0x80000 /* drive can read MRW */
-#define CDC_MRW_W		0x100000 /* drive can write MRW */
-#define CDC_RAM			0x200000 /* ok to open for WRITE */
-
-/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
-#define CDS_NO_INFO		0	/* if not implemented */
-#define CDS_NO_DISC		1
-#define CDS_TRAY_OPEN		2
-#define CDS_DRIVE_NOT_READY	3
-#define CDS_DISC_OK		4
-
-/* return values for the CDROM_DISC_STATUS ioctl */
-/* can also return CDS_NO_[INFO|DISC], from above */
-#define CDS_AUDIO		100
-#define CDS_DATA_1		101
-#define CDS_DATA_2		102
-#define CDS_XA_2_1		103
-#define CDS_XA_2_2		104
-#define CDS_MIXED		105
-
-/* User-configurable behavior options for the uniform CD-ROM driver */
-#define CDO_AUTO_CLOSE		0x1     /* close tray on first open() */
-#define CDO_AUTO_EJECT		0x2     /* open tray on last release() */
-#define CDO_USE_FFLAGS		0x4     /* use O_NONBLOCK information on open */
-#define CDO_LOCK		0x8     /* lock tray on open files */
-#define CDO_CHECK_TYPE		0x10    /* check type on open for data */
-
-/* Special codes used when specifying changer slots. */
-#define CDSL_NONE       	(INT_MAX-1)
-#define CDSL_CURRENT    	INT_MAX
-
-/* For partition based multisession access. IDE can handle 64 partitions
- * per drive - SCSI CD-ROM's use minors to differentiate between the
- * various drives, so we can't do multisessions the same way there.
- * Use the -o session=x option to mount on them.
- */
-#define CD_PART_MAX		64
-#define CD_PART_MASK		(CD_PART_MAX - 1)
-
-/*********************************************************************
- * Generic Packet commands, MMC commands, and such
- *********************************************************************/
-
- /* The generic packet command opcodes for CD/DVD Logical Units,
- * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
-#define GPCMD_BLANK			    0xa1
-#define GPCMD_CLOSE_TRACK		    0x5b
-#define GPCMD_FLUSH_CACHE		    0x35
-#define GPCMD_FORMAT_UNIT		    0x04
-#define GPCMD_GET_CONFIGURATION		    0x46
-#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
-#define GPCMD_GET_PERFORMANCE		    0xac
-#define GPCMD_INQUIRY			    0x12
-#define GPCMD_LOAD_UNLOAD		    0xa6
-#define GPCMD_MECHANISM_STATUS		    0xbd
-#define GPCMD_MODE_SELECT_10		    0x55
-#define GPCMD_MODE_SENSE_10		    0x5a
-#define GPCMD_PAUSE_RESUME		    0x4b
-#define GPCMD_PLAY_AUDIO_10		    0x45
-#define GPCMD_PLAY_AUDIO_MSF		    0x47
-#define GPCMD_PLAY_AUDIO_TI		    0x48
-#define GPCMD_PLAY_CD			    0xbc
-#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
-#define GPCMD_READ_10			    0x28
-#define GPCMD_READ_12			    0xa8
-#define GPCMD_READ_BUFFER		    0x3c
-#define GPCMD_READ_BUFFER_CAPACITY	    0x5c
-#define GPCMD_READ_CDVD_CAPACITY	    0x25
-#define GPCMD_READ_CD			    0xbe
-#define GPCMD_READ_CD_MSF		    0xb9
-#define GPCMD_READ_DISC_INFO		    0x51
-#define GPCMD_READ_DVD_STRUCTURE	    0xad
-#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
-#define GPCMD_READ_HEADER		    0x44
-#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
-#define GPCMD_READ_SUBCHANNEL		    0x42
-#define GPCMD_READ_TOC_PMA_ATIP		    0x43
-#define GPCMD_REPAIR_RZONE_TRACK	    0x58
-#define GPCMD_REPORT_KEY		    0xa4
-#define GPCMD_REQUEST_SENSE		    0x03
-#define GPCMD_RESERVE_RZONE_TRACK	    0x53
-#define GPCMD_SEND_CUE_SHEET		    0x5d
-#define GPCMD_SCAN			    0xba
-#define GPCMD_SEEK			    0x2b
-#define GPCMD_SEND_DVD_STRUCTURE	    0xbf
-#define GPCMD_SEND_EVENT		    0xa2
-#define GPCMD_SEND_KEY			    0xa3
-#define GPCMD_SEND_OPC			    0x54
-#define GPCMD_SET_READ_AHEAD		    0xa7
-#define GPCMD_SET_STREAMING		    0xb6
-#define GPCMD_START_STOP_UNIT		    0x1b
-#define GPCMD_STOP_PLAY_SCAN		    0x4e
-#define GPCMD_TEST_UNIT_READY		    0x00
-#define GPCMD_VERIFY_10			    0x2f
-#define GPCMD_WRITE_10			    0x2a
-#define GPCMD_WRITE_12			    0xaa
-#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
-#define GPCMD_WRITE_BUFFER		    0x3b
-/* This is listed as optional in ATAPI 2.6, but is (curiously) 
- * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
- * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
- * drives support it. */
-#define GPCMD_SET_SPEED			    0xbb
-/* This seems to be a SCSI specific CD-ROM opcode 
- * to play data at track/index */
-#define GPCMD_PLAYAUDIO_TI		    0x48
-/*
- * From MS Media Status Notification Support Specification. For
- * older drives only.
- */
-#define GPCMD_GET_MEDIA_STATUS		    0xda
-
-/* Mode page codes for mode sense/set */
-#define GPMODE_VENDOR_PAGE		0x00
-#define GPMODE_R_W_ERROR_PAGE		0x01
-#define GPMODE_WRITE_PARMS_PAGE		0x05
-#define GPMODE_WCACHING_PAGE		0x08
-#define GPMODE_AUDIO_CTL_PAGE		0x0e
-#define GPMODE_POWER_PAGE		0x1a
-#define GPMODE_FAULT_FAIL_PAGE		0x1c
-#define GPMODE_TO_PROTECT_PAGE		0x1d
-#define GPMODE_CAPABILITIES_PAGE	0x2a
-#define GPMODE_ALL_PAGES		0x3f
-/* Not in Mt. Fuji, but in ATAPI 2.6 -- deprecated now in favor
- * of MODE_SENSE_POWER_PAGE */
-#define GPMODE_CDROM_PAGE		0x0d
-
-
-
-/* DVD struct types */
-#define DVD_STRUCT_PHYSICAL	0x00
-#define DVD_STRUCT_COPYRIGHT	0x01
-#define DVD_STRUCT_DISCKEY	0x02
-#define DVD_STRUCT_BCA		0x03
-#define DVD_STRUCT_MANUFACT	0x04
-
-struct dvd_layer {
-	__u8 book_version	: 4;
-	__u8 book_type		: 4;
-	__u8 min_rate		: 4;
-	__u8 disc_size		: 4;
-	__u8 layer_type		: 4;
-	__u8 track_path		: 1;
-	__u8 nlayers		: 2;
-	__u8 track_density	: 4;
-	__u8 linear_density	: 4;
-	__u8 bca		: 1;
-	__u32 start_sector;
-	__u32 end_sector;
-	__u32 end_sector_l0;
-};
-
-#define DVD_LAYERS	4
-
-struct dvd_physical {
-	__u8 type;
-	__u8 layer_num;
-	struct dvd_layer layer[DVD_LAYERS];
-};
-
-struct dvd_copyright {
-	__u8 type;
-
-	__u8 layer_num;
-	__u8 cpst;
-	__u8 rmi;
-};
-
-struct dvd_disckey {
-	__u8 type;
-
-	unsigned agid		: 2;
-	__u8 value[2048];
-};
-
-struct dvd_bca {
-	__u8 type;
-
-	int len;
-	__u8 value[188];
-};
-
-struct dvd_manufact {
-	__u8 type;
-
-	__u8 layer_num;
-	int len;
-	__u8 value[2048];
-};
-
-typedef union {
-	__u8 type;
-
-	struct dvd_physical	physical;
-	struct dvd_copyright	copyright;
-	struct dvd_disckey	disckey;
-	struct dvd_bca		bca;
-	struct dvd_manufact	manufact;
-} dvd_struct;
-
-/*
- * DVD authentication ioctl
- */
-
-/* Authentication states */
-#define DVD_LU_SEND_AGID	0
-#define DVD_HOST_SEND_CHALLENGE	1
-#define DVD_LU_SEND_KEY1	2
-#define DVD_LU_SEND_CHALLENGE	3
-#define DVD_HOST_SEND_KEY2	4
-
-/* Termination states */
-#define DVD_AUTH_ESTABLISHED	5
-#define DVD_AUTH_FAILURE	6
-
-/* Other functions */
-#define DVD_LU_SEND_TITLE_KEY	7
-#define DVD_LU_SEND_ASF		8
-#define DVD_INVALIDATE_AGID	9
-#define DVD_LU_SEND_RPC_STATE	10
-#define DVD_HOST_SEND_RPC_STATE	11
-
-/* State data */
-typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
-typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
-
-struct dvd_lu_send_agid {
-	__u8 type;
-	unsigned agid		: 2;
-};
-
-struct dvd_host_send_challenge {
-	__u8 type;
-	unsigned agid		: 2;
-
-	dvd_challenge chal;
-};
-
-struct dvd_send_key {
-	__u8 type;
-	unsigned agid		: 2;
-
-	dvd_key key;
-};
-
-struct dvd_lu_send_challenge {
-	__u8 type;
-	unsigned agid		: 2;
-
-	dvd_challenge chal;
-};
-
-#define DVD_CPM_NO_COPYRIGHT	0
-#define DVD_CPM_COPYRIGHTED	1
-
-#define DVD_CP_SEC_NONE		0
-#define DVD_CP_SEC_EXIST	1
-
-#define DVD_CGMS_UNRESTRICTED	0
-#define DVD_CGMS_SINGLE		2
-#define DVD_CGMS_RESTRICTED	3
-
-struct dvd_lu_send_title_key {
-	__u8 type;
-	unsigned agid		: 2;
-
-	dvd_key title_key;
-	int lba;
-	unsigned cpm		: 1;
-	unsigned cp_sec		: 1;
-	unsigned cgms		: 2;
-};
-
-struct dvd_lu_send_asf {
-	__u8 type;
-	unsigned agid		: 2;
-
-	unsigned asf		: 1;
-};
-
-struct dvd_host_send_rpcstate {
-	__u8 type;
-	__u8 pdrc;
-};
-
-struct dvd_lu_send_rpcstate {
-	__u8 type		: 2;
-	__u8 vra		: 3;
-	__u8 ucca		: 3;
-	__u8 region_mask;
-	__u8 rpc_scheme;
-};
-
-typedef union {
-	__u8 type;
-
-	struct dvd_lu_send_agid		lsa;
-	struct dvd_host_send_challenge	hsc;
-	struct dvd_send_key		lsk;
-	struct dvd_lu_send_challenge	lsc;
-	struct dvd_send_key		hsk;
-	struct dvd_lu_send_title_key	lstk;
-	struct dvd_lu_send_asf		lsasf;
-	struct dvd_host_send_rpcstate	hrpcs;
-	struct dvd_lu_send_rpcstate	lrpcs;
-} dvd_authinfo;
-
-struct request_sense {
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 valid		: 1;
-	__u8 error_code		: 7;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 error_code		: 7;
-	__u8 valid		: 1;
-#endif
-	__u8 segment_number;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved1		: 2;
-	__u8 ili		: 1;
-	__u8 reserved2		: 1;
-	__u8 sense_key		: 4;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 sense_key		: 4;
-	__u8 reserved2		: 1;
-	__u8 ili		: 1;
-	__u8 reserved1		: 2;
-#endif
-	__u8 information[4];
-	__u8 add_sense_len;
-	__u8 command_info[4];
-	__u8 asc;
-	__u8 ascq;
-	__u8 fruc;
-	__u8 sks[3];
-	__u8 asb[46];
-};
-
-/*
- * feature profile
- */
-#define CDF_RWRT	0x0020	/* "Random Writable" */
-#define CDF_HWDM	0x0024	/* "Hardware Defect Management" */
-#define CDF_MRW 	0x0028
-
-/*
- * media status bits
- */
-#define CDM_MRW_NOTMRW			0
-#define CDM_MRW_BGFORMAT_INACTIVE	1
-#define CDM_MRW_BGFORMAT_ACTIVE		2
-#define CDM_MRW_BGFORMAT_COMPLETE	3
-
-/*
- * mrw address spaces
- */
-#define MRW_LBA_DMA			0
-#define MRW_LBA_GAA			1
-
-/*
- * mrw mode pages (first is deprecated) -- probed at init time and
- * cdi->mrw_mode_page is set
- */
-#define MRW_MODE_PC_PRE1		0x2c
-#define MRW_MODE_PC			0x03
-
-struct mrw_feature_desc {
-	__be16 feature_code;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved1		: 2;
-	__u8 feature_version	: 4;
-	__u8 persistent		: 1;
-	__u8 curr		: 1;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 curr		: 1;
-	__u8 persistent		: 1;
-	__u8 feature_version	: 4;
-	__u8 reserved1		: 2;
-#endif
-	__u8 add_len;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved2		: 7;
-	__u8 write		: 1;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 write		: 1;
-	__u8 reserved2		: 7;
-#endif
-	__u8 reserved3;
-	__u8 reserved4;
-	__u8 reserved5;
-};
-
-/* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
-struct rwrt_feature_desc {
-	__be16 feature_code;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved1		: 2;
-	__u8 feature_version	: 4;
-	__u8 persistent		: 1;
-	__u8 curr		: 1;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 curr		: 1;
-	__u8 persistent		: 1;
-	__u8 feature_version	: 4;
-	__u8 reserved1		: 2;
-#endif
-	__u8 add_len;
-	__u32 last_lba;
-	__u32 block_size;
-	__u16 blocking;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved2		: 7;
-	__u8 page_present	: 1;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 page_present	: 1;
-	__u8 reserved2		: 7;
-#endif
-	__u8 reserved3;
-};
-
-typedef struct {
-	__be16 disc_information_length;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved1			: 3;
-        __u8 erasable			: 1;
-        __u8 border_status		: 2;
-        __u8 disc_status		: 2;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-        __u8 disc_status		: 2;
-        __u8 border_status		: 2;
-        __u8 erasable			: 1;
-	__u8 reserved1			: 3;
-#else
-#error "Please fix <asm/byteorder.h>"
-#endif
-	__u8 n_first_track;
-	__u8 n_sessions_lsb;
-	__u8 first_track_lsb;
-	__u8 last_track_lsb;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 did_v			: 1;
-        __u8 dbc_v			: 1;
-        __u8 uru			: 1;
-        __u8 reserved2			: 2;
-	__u8 dbit			: 1;
-	__u8 mrw_status			: 2;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8 mrw_status			: 2;
-	__u8 dbit			: 1;
-        __u8 reserved2			: 2;
-        __u8 uru			: 1;
-        __u8 dbc_v			: 1;
-	__u8 did_v			: 1;
-#endif
-	__u8 disc_type;
-	__u8 n_sessions_msb;
-	__u8 first_track_msb;
-	__u8 last_track_msb;
-	__u32 disc_id;
-	__u32 lead_in;
-	__u32 lead_out;
-	__u8 disc_bar_code[8];
-	__u8 reserved3;
-	__u8 n_opc;
-} disc_information;
-
-typedef struct {
-	__be16 track_information_length;
-	__u8 track_lsb;
-	__u8 session_lsb;
-	__u8 reserved1;
-#if defined(__BIG_ENDIAN_BITFIELD)
-	__u8 reserved2			: 2;
-        __u8 damage			: 1;
-        __u8 copy			: 1;
-        __u8 track_mode			: 4;
-	__u8 rt				: 1;
-	__u8 blank			: 1;
-	__u8 packet			: 1;
-	__u8 fp				: 1;
-	__u8 data_mode			: 4;
-	__u8 reserved3			: 6;
-	__u8 lra_v			: 1;
-	__u8 nwa_v			: 1;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-        __u8 track_mode			: 4;
-        __u8 copy			: 1;
-        __u8 damage			: 1;
-	__u8 reserved2			: 2;
-	__u8 data_mode			: 4;
-	__u8 fp				: 1;
-	__u8 packet			: 1;
-	__u8 blank			: 1;
-	__u8 rt				: 1;
-	__u8 nwa_v			: 1;
-	__u8 lra_v			: 1;
-	__u8 reserved3			: 6;
-#endif
-	__be32 track_start;
-	__be32 next_writable;
-	__be32 free_blocks;
-	__be32 fixed_packet_size;
-	__be32 track_size;
-	__be32 last_rec_address;
-} track_information;
-
-struct feature_header {
-	__u32 data_len;
-	__u8 reserved1;
-	__u8 reserved2;
-	__u16 curr_profile;
-};
-
-struct mode_page_header {
-	__be16 mode_data_length;
-	__u8 medium_type;
-	__u8 reserved1;
-	__u8 reserved2;
-	__u8 reserved3;
-	__be16 desc_length;
-};
-
-#ifdef __KERNEL__
 #include <linux/fs.h>		/* not really needed, later.. */
 #include <linux/list.h>
+#include <uapi/linux/cdrom.h>
 
 struct packet_command
 {
@@ -1209,6 +311,4 @@ static inline int msf_to_lba(u8 m, u8 s, u8 f)
 {
 	return (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;
 }
-#endif  /* End of kernel only stuff */ 
-
 #endif  /* _LINUX_CDROM_H */

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 35eae4b67503..d35a12fbd8f1 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -910,7 +910,6 @@ struct mode_page_header {
 
 #ifdef __KERNEL__
 #include <linux/fs.h>		/* not really needed, later.. */
-#include <linux/device.h>
 #include <linux/list.h>
 
 struct packet_command

commit cdccaa9467b982d57b139818d15e1e994feca372
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Wed Feb 8 20:03:14 2012 +0100

    cdrom: move shared static to cdrom_device_info
    
    The keeplocked variable in the cdrom driver is shared across multiple
    drives, but set in per-device ioctls.  Move it to the per-device struct,
    avoiding that the setting on one drive affects the driver's behavior
    when closing another.
    
    [ Impact: limit udev's confusion to one drive when a CD burning program
      unlocks the CD door at the end of burning. ]
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 35eae4b67503..7c48029dffe6 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -952,7 +952,8 @@ struct cdrom_device_info {
     	char name[20];                  /* name of the device type */
 /* per-device flags */
         __u8 sanyo_slot		: 2;	/* Sanyo 3 CD changer support */
-        __u8 reserved		: 6;	/* not used yet */
+        __u8 keeplocked		: 1;	/* CDROM_LOCKDOOR status */
+        __u8 reserved		: 5;	/* not used yet */
 	int cdda_method;		/* see flags */
 	__u8 last_sense;
 	__u8 media_written;		/* dirty flag, DVD+RW bookkeeping */

commit 2d9217296bfa6fdc0d3707264076e5296faffdbd
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 8 20:57:38 2010 +0100

    cdrom: add ->check_events() support
    
    In principle, cdrom just needs to pass through ->check_events() but
    CDROM_MEDIA_CHANGED ioctl makes things a bit more complex.  Just as
    with ->media_changed() support, cdrom code needs to buffer the events
    and serve them to ioctl and vfs as requested.
    
    As the code has to deal with both ->check_events() and
    ->media_changed(), and vfs and ioctl event buffering, this patch adds
    check_events caching on top of the existing cdi->mc_flags buffering.
    
    It may be a good idea to deprecate CDROM_MEDIA_CHANGED ioctl and
    remove all this mess.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 78e904796622..35eae4b67503 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -946,6 +946,8 @@ struct cdrom_device_info {
 /* device-related storage */
 	unsigned int options	: 30;	/* options flags */
 	unsigned mc_flags	: 2;	/* media change buffer flags */
+	unsigned int vfs_events;	/* cached events for vfs path */
+	unsigned int ioctl_events;	/* cached events for ioctl path */
     	int use_count;                  /* number of times device opened */
     	char name[20];                  /* name of the device type */
 /* per-device flags */
@@ -965,6 +967,8 @@ struct cdrom_device_ops {
 	int (*open) (struct cdrom_device_info *, int);
 	void (*release) (struct cdrom_device_info *);
 	int (*drive_status) (struct cdrom_device_info *, int);
+	unsigned int (*check_events) (struct cdrom_device_info *cdi,
+				      unsigned int clearing, int slot);
 	int (*media_changed) (struct cdrom_device_info *, int);
 	int (*tray_move) (struct cdrom_device_info *, int);
 	int (*lock_door) (struct cdrom_device_info *, int);
@@ -993,6 +997,8 @@ extern int cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev,
 extern void cdrom_release(struct cdrom_device_info *cdi, fmode_t mode);
 extern int cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,
 		       fmode_t mode, unsigned int cmd, unsigned long arg);
+extern unsigned int cdrom_check_events(struct cdrom_device_info *cdi,
+				       unsigned int clearing);
 extern int cdrom_media_changed(struct cdrom_device_info *);
 
 extern int register_cdrom(struct cdrom_device_info *cdi);

commit 960066a919f1db57817df6d02e72b01542f1deed
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Fri Jan 30 20:41:51 2009 +0530

    headers_check fix: linux/cdrom.h
    
    fix the following 'make headers_check' warning:
    
      usr/include/linux/cdrom.h:155: found __[us]{8,16,32,64} type without #include <linux/types.h>
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 0b49e08d3cb0..78e904796622 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -11,6 +11,7 @@
 #ifndef	_LINUX_CDROM_H
 #define	_LINUX_CDROM_H
 
+#include <linux/types.h>
 #include <asm/byteorder.h>
 
 /*******************************************************

commit bbc1cc978404105da23d505163ce9fd5598ed5b1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 7 17:54:28 2007 -0400

    [PATCH] switch cdrom_{open,release,ioctl} to sane APIs
    
    ... convert to it in callers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 5db265ea60f6..0b49e08d3cb0 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -987,11 +987,11 @@ struct cdrom_device_ops {
 };
 
 /* the general block_device operations structure: */
-extern int cdrom_open(struct cdrom_device_info *cdi, struct inode *ip,
-			struct file *fp);
-extern int cdrom_release(struct cdrom_device_info *cdi, struct file *fp);
-extern int cdrom_ioctl(struct file *file, struct cdrom_device_info *cdi,
-		struct inode *ip, unsigned int cmd, unsigned long arg);
+extern int cdrom_open(struct cdrom_device_info *cdi, struct block_device *bdev,
+			fmode_t mode);
+extern void cdrom_release(struct cdrom_device_info *cdi, fmode_t mode);
+extern int cdrom_ioctl(struct cdrom_device_info *cdi, struct block_device *bdev,
+		       fmode_t mode, unsigned int cmd, unsigned long arg);
 extern int cdrom_media_changed(struct cdrom_device_info *);
 
 extern int register_cdrom(struct cdrom_device_info *cdi);

commit 0a0c4114df4a6903bccb65b06cabb6ddc968f877
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Mar 26 12:09:02 2008 +0100

    cdrom: make unregister_cdrom() return void
    
    Now unregister_cdrom() always returns 0.
    Make it return void and update all callers that check the return value.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Adrian McMenamin <adrian@mcmen.demon.co.uk>
    Cc: Borislav Petkov <petkovbb@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 40e05d0a6e45..5db265ea60f6 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -995,7 +995,7 @@ extern int cdrom_ioctl(struct file *file, struct cdrom_device_info *cdi,
 extern int cdrom_media_changed(struct cdrom_device_info *);
 
 extern int register_cdrom(struct cdrom_device_info *cdi);
-extern int unregister_cdrom(struct cdrom_device_info *cdi);
+extern void unregister_cdrom(struct cdrom_device_info *cdi);
 
 typedef struct {
     int data;

commit 7fd097d42b90afadae4867db5d580bcd7b3b596d
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Mar 26 12:09:02 2008 +0100

    cdrom: use list_head for cdrom_device_info list
    
    Use list_head for cdrom_device_info list instead of opencoded
    singly list handling.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index a5cd2047624e..40e05d0a6e45 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -910,6 +910,7 @@ struct mode_page_header {
 #ifdef __KERNEL__
 #include <linux/fs.h>		/* not really needed, later.. */
 #include <linux/device.h>
+#include <linux/list.h>
 
 struct packet_command
 {
@@ -934,7 +935,7 @@ struct packet_command
 /* Uniform cdrom data structures for cdrom.c */
 struct cdrom_device_info {
 	struct cdrom_device_ops  *ops;  /* link to device_ops */
-	struct cdrom_device_info *next; /* next device_info for this major */
+	struct list_head list;		/* linked list of all device_info */
 	struct gendisk *disk;		/* matching block layer disk */
 	void *handle;		        /* driver-dependent data */
 /* specifications */

commit a1bb9457f06439f22571e93bddcca63144a08296
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Feb 1 23:09:24 2008 +0100

    ide-cd: move lba_to_msf() and msf_to_lba() to <linux/cdrom.h>
    
    * Move lba_to_msf() and msf_to_lba() to <linux/cdrom.h>
      (use 'u8' type instead of 'byte' while at it).
    
    * Remove msf_to_lba() copy from drivers/cdrom/cdrom.c.
    
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index fcdc11b9609b..a5cd2047624e 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -1187,6 +1187,20 @@ struct media_event_desc {
 
 extern int cdrom_get_media_event(struct cdrom_device_info *cdi, struct media_event_desc *med);
 
+static inline void lba_to_msf(int lba, u8 *m, u8 *s, u8 *f)
+{
+	lba += CD_MSF_OFFSET;
+	lba &= 0xffffff;  /* negative lbas use only 24 bits */
+	*m = lba / (CD_SECS * CD_FRAMES);
+	lba %= (CD_SECS * CD_FRAMES);
+	*s = lba / CD_FRAMES;
+	*f = lba % CD_FRAMES;
+}
+
+static inline int msf_to_lba(u8 m, u8 s, u8 f)
+{
+	return (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_MSF_OFFSET;
+}
 #endif  /* End of kernel only stuff */ 
 
 #endif  /* _LINUX_CDROM_H */

commit 537b53c1692960b8b3b0324e886fbe48cb9e5c00
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Dec 5 16:43:04 2007 +0900

    cdrom: add more GPCMD_* constants
    
    Add GPCMD_* constants for READ_BUFFER, WRITE_12 and WRITE_BUFFER for
    completeness.  These will be used libata.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index c6d3e22c0624..fcdc11b9609b 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -451,6 +451,7 @@ struct cdrom_generic_command
 #define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
 #define GPCMD_READ_10			    0x28
 #define GPCMD_READ_12			    0xa8
+#define GPCMD_READ_BUFFER		    0x3c
 #define GPCMD_READ_BUFFER_CAPACITY	    0x5c
 #define GPCMD_READ_CDVD_CAPACITY	    0x25
 #define GPCMD_READ_CD			    0xbe
@@ -480,7 +481,9 @@ struct cdrom_generic_command
 #define GPCMD_TEST_UNIT_READY		    0x00
 #define GPCMD_VERIFY_10			    0x2f
 #define GPCMD_WRITE_10			    0x2a
+#define GPCMD_WRITE_12			    0xaa
 #define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+#define GPCMD_WRITE_BUFFER		    0x3b
 /* This is listed as optional in ATAPI 2.6, but is (curiously) 
  * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
  * Table 377 as an MMC command for SCSi devices though...  Most ATAPI

commit 405bbe9fa345050f46c411d77727f381d74a2ba8
Author: Rolf Eike Beer <eike-kernel@sf-tec.de>
Date:   Sat Oct 20 03:10:57 2007 +0200

    Typo: depricated -> deprecated
    
    Typo: depricated -> deprecated
    
    Signed-off-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index b6e4b52350aa..c6d3e22c0624 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -76,7 +76,7 @@
                                            (struct cdrom_multisession) */
 #define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
                                            if available (struct cdrom_mcn) */
-#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is depricated, 
+#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is deprecated, 
                                           but here anyway for compatibility */
 #define CDROMRESET		0x5312 /* hard-reset the drive */
 #define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
@@ -506,7 +506,7 @@ struct cdrom_generic_command
 #define GPMODE_TO_PROTECT_PAGE		0x1d
 #define GPMODE_CAPABILITIES_PAGE	0x2a
 #define GPMODE_ALL_PAGES		0x3f
-/* Not in Mt. Fuji, but in ATAPI 2.6 -- depricated now in favor
+/* Not in Mt. Fuji, but in ATAPI 2.6 -- deprecated now in favor
  * of MODE_SENSE_POWER_PAGE */
 #define GPMODE_CDROM_PAGE		0x0d
 

commit 96de0e252cedffad61b3cb5e05662c591898e69a
Author: Jan Engelhardt <jengelh@gmx.de>
Date:   Fri Oct 19 23:21:04 2007 +0200

    Convert files to UTF-8 and some cleanups
    
    * Convert files to UTF-8.
    
      * Also correct some people's names
        (one example is Eißfeldt, which was found in a source file.
        Given that the author used an ß at all in a source file
        indicates that the real name has in fact a 'ß' and not an 'ss',
        which is commonly used as a substitute for 'ß' when limited to
        7bit.)
    
      * Correct town names (Goettingen -> Göttingen)
    
      * Update Eberhard Mönkeberg's address (http://lkml.org/lkml/2007/1/8/313)
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 2b641b176e7f..b6e4b52350aa 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -2,7 +2,7 @@
  * -- <linux/cdrom.h>
  * General header file for linux CD-ROM drivers 
  * Copyright (C) 1992         David Giller, rafetmad@oxy.edu
- *               1994, 1995   Eberhard Moenkeberg, emoenke@gwdg.de
+ *               1994, 1995   Eberhard Mönkeberg, emoenke@gwdg.de
  *               1996         David van Leeuwen, david@tm.tno.nl
  *               1997, 1998   Erik Andersen, andersee@debian.org
  *               1998-2002    Jens Axboe, axboe@suse.de

commit 132e4b0a049c39337c535501561b8301c7f2b202
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Sun Jul 15 23:41:19 2007 -0700

    cdrom: replace hard-coded constants by kernel.h macro.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index f50f04bdbc16..2b641b176e7f 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -414,8 +414,8 @@ struct cdrom_generic_command
 #define CDO_CHECK_TYPE		0x10    /* check type on open for data */
 
 /* Special codes used when specifying changer slots. */
-#define CDSL_NONE       	((int) (~0U>>1)-1)
-#define CDSL_CURRENT    	((int) (~0U>>1))
+#define CDSL_NONE       	(INT_MAX-1)
+#define CDSL_CURRENT    	INT_MAX
 
 /* For partition based multisession access. IDE can handle 64 partitions
  * per drive - SCSI CD-ROM's use minors to differentiate between the

commit 0cba01db647fa87d14aeccac5267aebfeb2fc1d2
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Feb 20 13:58:05 2007 -0800

    [PATCH] cdrom: use unsigned bitfields
    
    Fix 23 of these sparse warnings on x86_64 allmodconfig:
    include/linux/cdrom.h:942:19: error: dubious bitfield without explicit
    `signed' or `unsigned'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index bbbe7b4da0bb..f50f04bdbc16 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -939,7 +939,7 @@ struct cdrom_device_info {
 	int speed;			/* maximum speed for reading data */
 	int capacity;			/* number of discs in jukebox */
 /* device-related storage */
-	int options		: 30;	/* options flags */
+	unsigned int options	: 30;	/* options flags */
 	unsigned mc_flags	: 2;	/* media change buffer flags */
     	int use_count;                  /* number of times device opened */
     	char name[20];                  /* name of the device type */

commit 56052d525a05ba9e53d4f11be2d5deee64924514
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Dec 1 17:10:40 2005 -0500

    [PATCH] cdrom: add endianness annotations
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index 3c9b0bc05123..bbbe7b4da0bb 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -749,7 +749,7 @@ struct request_sense {
 #define MRW_MODE_PC			0x03
 
 struct mrw_feature_desc {
-	__u16 feature_code;
+	__be16 feature_code;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1		: 2;
 	__u8 feature_version	: 4;
@@ -776,7 +776,7 @@ struct mrw_feature_desc {
 
 /* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
 struct rwrt_feature_desc {
-	__u16 feature_code;
+	__be16 feature_code;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1		: 2;
 	__u8 feature_version	: 4;
@@ -803,7 +803,7 @@ struct rwrt_feature_desc {
 };
 
 typedef struct {
-	__u16 disc_information_length;
+	__be16 disc_information_length;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1			: 3;
         __u8 erasable			: 1;
@@ -849,7 +849,7 @@ typedef struct {
 } disc_information;
 
 typedef struct {
-	__u16 track_information_length;
+	__be16 track_information_length;
 	__u8 track_lsb;
 	__u8 session_lsb;
 	__u8 reserved1;
@@ -880,12 +880,12 @@ typedef struct {
 	__u8 lra_v			: 1;
 	__u8 reserved3			: 6;
 #endif
-	__u32 track_start;
-	__u32 next_writable;
-	__u32 free_blocks;
-	__u32 fixed_packet_size;
-	__u32 track_size;
-	__u32 last_rec_address;
+	__be32 track_start;
+	__be32 next_writable;
+	__be32 free_blocks;
+	__be32 fixed_packet_size;
+	__be32 track_size;
+	__be32 last_rec_address;
 } track_information;
 
 struct feature_header {
@@ -896,12 +896,12 @@ struct feature_header {
 };
 
 struct mode_page_header {
-	__u16 mode_data_length;
+	__be16 mode_data_length;
 	__u8 medium_type;
 	__u8 reserved1;
 	__u8 reserved2;
 	__u8 reserved3;
-	__u16 desc_length;
+	__be16 desc_length;
 };
 
 #ifdef __KERNEL__
@@ -1106,7 +1106,7 @@ typedef struct {
 #endif
 	__u8 session_format;
 	__u8 reserved6;
-	__u32 packet_size;
+	__be32 packet_size;
 	__u16 audio_pause;
 	__u8 mcn[16];
 	__u8 isrc[16];
@@ -1151,7 +1151,7 @@ typedef struct {
 } rpc_state_t;
 
 struct event_header {
-	__u16 data_len;
+	__be16 data_len;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 nea		: 1;
 	__u8 reserved1		: 4;

commit 6a2900b67652421b51fe25e4b86ecfec742b1f30
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Mar 23 03:00:15 2006 -0800

    [PATCH] kill cdrom ->dev_ioctl method
    
    Since early 2.4.x all cdrom drivers implement the block_device methods
    themselves, so they can handle additional ioctls directly instead of going
    through the cdrom layer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
index b68fdf1f3156..3c9b0bc05123 100644
--- a/include/linux/cdrom.h
+++ b/include/linux/cdrom.h
@@ -378,7 +378,6 @@ struct cdrom_generic_command
 #define CDC_MEDIA_CHANGED 	0x80    /* media changed */
 #define CDC_PLAY_AUDIO		0x100   /* audio functions */
 #define CDC_RESET               0x200   /* hard reset device */
-#define CDC_IOCTLS              0x400   /* driver has non-standard ioctls */
 #define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
 #define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
 #define CDC_CD_R		0x2000	/* drive is a CD-R */
@@ -974,9 +973,7 @@ struct cdrom_device_ops {
 	int (*reset) (struct cdrom_device_info *);
 	/* play stuff */
 	int (*audio_ioctl) (struct cdrom_device_info *,unsigned int, void *);
-	/* dev-specific */
- 	int (*dev_ioctl) (struct cdrom_device_info *,
-			  unsigned int, unsigned long);
+
 /* driver specifications */
 	const int capability;   /* capability flags */
 	int n_minors;           /* number of active minor devices */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/cdrom.h b/include/linux/cdrom.h
new file mode 100644
index 000000000000..b68fdf1f3156
--- /dev/null
+++ b/include/linux/cdrom.h
@@ -0,0 +1,1192 @@
+/*
+ * -- <linux/cdrom.h>
+ * General header file for linux CD-ROM drivers 
+ * Copyright (C) 1992         David Giller, rafetmad@oxy.edu
+ *               1994, 1995   Eberhard Moenkeberg, emoenke@gwdg.de
+ *               1996         David van Leeuwen, david@tm.tno.nl
+ *               1997, 1998   Erik Andersen, andersee@debian.org
+ *               1998-2002    Jens Axboe, axboe@suse.de
+ */
+ 
+#ifndef	_LINUX_CDROM_H
+#define	_LINUX_CDROM_H
+
+#include <asm/byteorder.h>
+
+/*******************************************************
+ * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
+ * (and only this) include file.  It is my hope to provide Linux with
+ * a uniform interface between software accessing CD-ROMs and the various 
+ * device drivers that actually talk to the drives.  There may still be
+ * 23 different kinds of strange CD-ROM drives, but at least there will 
+ * now be one, and only one, Linux CD-ROM interface.
+ *
+ * Additionally, as of Linux 2.1.x, all Linux application programs 
+ * should use the O_NONBLOCK option when opening a CD-ROM device 
+ * for subsequent ioctl commands.  This allows for neat system errors 
+ * like "No medium found" or "Wrong medium type" upon attempting to 
+ * mount or play an empty slot, mount an audio disc, or play a data disc.
+ * Generally, changing an application program to support O_NONBLOCK
+ * is as easy as the following:
+ *       -    drive = open("/dev/cdrom", O_RDONLY);
+ *       +    drive = open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
+ * It is worth the small change.
+ *
+ *  Patches for many common CD programs (provided by David A. van Leeuwen)
+ *  can be found at:  ftp://ftp.gwdg.de/pub/linux/cdrom/drivers/cm206/
+ * 
+ *******************************************************/
+
+/* When a driver supports a certain function, but the cdrom drive we are 
+ * using doesn't, we will return the error EDRIVE_CANT_DO_THIS.  We will 
+ * borrow the "Operation not supported" error from the network folks to 
+ * accomplish this.  Maybe someday we will get a more targeted error code, 
+ * but this will do for now... */
+#define EDRIVE_CANT_DO_THIS  EOPNOTSUPP
+
+/*******************************************************
+ * The CD-ROM IOCTL commands  -- these should be supported by 
+ * all the various cdrom drivers.  For the CD-ROM ioctls, we 
+ * will commandeer byte 0x53, or 'S'.
+ *******************************************************/
+#define CDROMPAUSE		0x5301 /* Pause Audio Operation */ 
+#define CDROMRESUME		0x5302 /* Resume paused Audio Operation */
+#define CDROMPLAYMSF		0x5303 /* Play Audio MSF (struct cdrom_msf) */
+#define CDROMPLAYTRKIND		0x5304 /* Play Audio Track/index 
+                                           (struct cdrom_ti) */
+#define CDROMREADTOCHDR		0x5305 /* Read TOC header 
+                                           (struct cdrom_tochdr) */
+#define CDROMREADTOCENTRY	0x5306 /* Read TOC entry 
+                                           (struct cdrom_tocentry) */
+#define CDROMSTOP		0x5307 /* Stop the cdrom drive */
+#define CDROMSTART		0x5308 /* Start the cdrom drive */
+#define CDROMEJECT		0x5309 /* Ejects the cdrom media */
+#define CDROMVOLCTRL		0x530a /* Control output volume 
+                                           (struct cdrom_volctrl) */
+#define CDROMSUBCHNL		0x530b /* Read subchannel data 
+                                           (struct cdrom_subchnl) */
+#define CDROMREADMODE2		0x530c /* Read CDROM mode 2 data (2336 Bytes) 
+                                           (struct cdrom_read) */
+#define CDROMREADMODE1		0x530d /* Read CDROM mode 1 data (2048 Bytes)
+                                           (struct cdrom_read) */
+#define CDROMREADAUDIO		0x530e /* (struct cdrom_read_audio) */
+#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
+#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
+                                           address of multi session disks 
+                                           (struct cdrom_multisession) */
+#define CDROM_GET_MCN		0x5311 /* Obtain the "Universal Product Code" 
+                                           if available (struct cdrom_mcn) */
+#define CDROM_GET_UPC		CDROM_GET_MCN  /* This one is depricated, 
+                                          but here anyway for compatibility */
+#define CDROMRESET		0x5312 /* hard-reset the drive */
+#define CDROMVOLREAD		0x5313 /* Get the drive's volume setting 
+                                          (struct cdrom_volctrl) */
+#define CDROMREADRAW		0x5314	/* read data in raw mode (2352 Bytes)
+                                           (struct cdrom_read) */
+/* 
+ * These ioctls are used only used in aztcd.c and optcd.c
+ */
+#define CDROMREADCOOKED		0x5315	/* read data in cooked mode */
+#define CDROMSEEK		0x5316  /* seek msf address */
+  
+/*
+ * This ioctl is only used by the scsi-cd driver.  
+   It is for playing audio in logical block addressing mode.
+ */
+#define CDROMPLAYBLK		0x5317	/* (struct cdrom_blk) */
+
+/* 
+ * These ioctls are only used in optcd.c
+ */
+#define CDROMREADALL		0x5318	/* read all 2646 bytes */
+
+/* 
+ * These ioctls are (now) only in ide-cd.c for controlling 
+ * drive spindown time.  They should be implemented in the
+ * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,
+ * GPCMD_MODE_SENSE_10 and the GPMODE_POWER_PAGE...
+ *  -Erik
+ */
+#define CDROMGETSPINDOWN        0x531d
+#define CDROMSETSPINDOWN        0x531e
+
+/* 
+ * These ioctls are implemented through the uniform CD-ROM driver
+ * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
+ * drivers are eventually ported to the uniform CD-ROM driver interface.
+ */
+#define CDROMCLOSETRAY		0x5319	/* pendant of CDROMEJECT */
+#define CDROM_SET_OPTIONS	0x5320  /* Set behavior options */
+#define CDROM_CLEAR_OPTIONS	0x5321  /* Clear behavior options */
+#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
+#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
+#define CDROM_MEDIA_CHANGED	0x5325  /* Check is media changed  */
+#define CDROM_DRIVE_STATUS	0x5326  /* Get tray position, etc. */
+#define CDROM_DISC_STATUS	0x5327  /* Get disc type, etc. */
+#define CDROM_CHANGER_NSLOTS    0x5328  /* Get number of slots */
+#define CDROM_LOCKDOOR		0x5329  /* lock or unlock door */
+#define CDROM_DEBUG		0x5330	/* Turn debug messages on/off */
+#define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */
+
+/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
+ * Future CDROM ioctls should be kept below 0x537F
+ */
+
+/* This ioctl is only used by sbpcd at the moment */
+#define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */
+					/* conflict with SCSI_IOCTL_GET_IDLUN */
+
+/* DVD-ROM Specific ioctls */
+#define DVD_READ_STRUCT		0x5390  /* Read structure */
+#define DVD_WRITE_STRUCT	0x5391  /* Write structure */
+#define DVD_AUTH		0x5392  /* Authentication */
+
+#define CDROM_SEND_PACKET	0x5393	/* send a packet to the drive */
+#define CDROM_NEXT_WRITABLE	0x5394	/* get next writable block */
+#define CDROM_LAST_WRITTEN	0x5395	/* get last block written on disc */
+
+/*******************************************************
+ * CDROM IOCTL structures
+ *******************************************************/
+
+/* Address in MSF format */
+struct cdrom_msf0		
+{
+	__u8	minute;
+	__u8	second;
+	__u8	frame;
+};
+
+/* Address in either MSF or logical format */
+union cdrom_addr		
+{
+	struct cdrom_msf0	msf;
+	int			lba;
+};
+
+/* This struct is used by the CDROMPLAYMSF ioctl */ 
+struct cdrom_msf 
+{
+	__u8	cdmsf_min0;	/* start minute */
+	__u8	cdmsf_sec0;	/* start second */
+	__u8	cdmsf_frame0;	/* start frame */
+	__u8	cdmsf_min1;	/* end minute */
+	__u8	cdmsf_sec1;	/* end second */
+	__u8	cdmsf_frame1;	/* end frame */
+};
+
+/* This struct is used by the CDROMPLAYTRKIND ioctl */
+struct cdrom_ti 
+{
+	__u8	cdti_trk0;	/* start track */
+	__u8	cdti_ind0;	/* start index */
+	__u8	cdti_trk1;	/* end track */
+	__u8	cdti_ind1;	/* end index */
+};
+
+/* This struct is used by the CDROMREADTOCHDR ioctl */
+struct cdrom_tochdr 	
+{
+	__u8	cdth_trk0;	/* start track */
+	__u8	cdth_trk1;	/* end track */
+};
+
+/* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */
+struct cdrom_volctrl
+{
+	__u8	channel0;
+	__u8	channel1;
+	__u8	channel2;
+	__u8	channel3;
+};
+
+/* This struct is used by the CDROMSUBCHNL ioctl */
+struct cdrom_subchnl 
+{
+	__u8	cdsc_format;
+	__u8	cdsc_audiostatus;
+	__u8	cdsc_adr:	4;
+	__u8	cdsc_ctrl:	4;
+	__u8	cdsc_trk;
+	__u8	cdsc_ind;
+	union cdrom_addr cdsc_absaddr;
+	union cdrom_addr cdsc_reladdr;
+};
+
+
+/* This struct is used by the CDROMREADTOCENTRY ioctl */
+struct cdrom_tocentry 
+{
+	__u8	cdte_track;
+	__u8	cdte_adr	:4;
+	__u8	cdte_ctrl	:4;
+	__u8	cdte_format;
+	union cdrom_addr cdte_addr;
+	__u8	cdte_datamode;
+};
+
+/* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */
+struct cdrom_read      
+{
+	int	cdread_lba;
+	char 	*cdread_bufaddr;
+	int	cdread_buflen;
+};
+
+/* This struct is used by the CDROMREADAUDIO ioctl */
+struct cdrom_read_audio
+{
+	union cdrom_addr addr; /* frame address */
+	__u8 addr_format;      /* CDROM_LBA or CDROM_MSF */
+	int nframes;           /* number of 2352-byte-frames to read at once */
+	__u8 __user *buf;      /* frame buffer (size: nframes*2352 bytes) */
+};
+
+/* This struct is used with the CDROMMULTISESSION ioctl */
+struct cdrom_multisession
+{
+	union cdrom_addr addr; /* frame address: start-of-last-session 
+	                           (not the new "frame 16"!).  Only valid
+	                           if the "xa_flag" is true. */
+	__u8 xa_flag;        /* 1: "is XA disk" */
+	__u8 addr_format;    /* CDROM_LBA or CDROM_MSF */
+};
+
+/* This struct is used with the CDROM_GET_MCN ioctl.  
+ * Very few audio discs actually have Universal Product Code information, 
+ * which should just be the Medium Catalog Number on the box.  Also note 
+ * that the way the codeis written on CD is _not_ uniform across all discs!
+ */  
+struct cdrom_mcn 
+{
+  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
+};
+
+/* This is used by the CDROMPLAYBLK ioctl */
+struct cdrom_blk 
+{
+	unsigned from;
+	unsigned short len;
+};
+
+#define CDROM_PACKET_SIZE	12
+
+#define CGC_DATA_UNKNOWN	0
+#define CGC_DATA_WRITE		1
+#define CGC_DATA_READ		2
+#define CGC_DATA_NONE		3
+
+/* for CDROM_PACKET_COMMAND ioctl */
+struct cdrom_generic_command
+{
+	unsigned char 		cmd[CDROM_PACKET_SIZE];
+	unsigned char		__user *buffer;
+	unsigned int 		buflen;
+	int			stat;
+	struct request_sense	__user *sense;
+	unsigned char		data_direction;
+	int			quiet;
+	int			timeout;
+	void			__user *reserved[1];	/* unused, actually */
+};
+
+/*
+ * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
+ * 2340, or 2352 bytes long.  
+
+*         Sector types of the standard CD-ROM data formats:
+ *
+ * format   sector type               user data size (bytes)
+ * -----------------------------------------------------------------------------
+ *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
+ *   2     (Yellow Book) Mode1 Form1    2048    (CD_FRAMESIZE)
+ *   3     (Yellow Book) Mode1 Form2    2336    (CD_FRAMESIZE_RAW0)
+ *   4     (Green Book)  Mode2 Form1    2048    (CD_FRAMESIZE)
+ *   5     (Green Book)  Mode2 Form2    2328    (2324+4 spare bytes)
+ *
+ *
+ *       The layout of the standard CD-ROM data formats:
+ * -----------------------------------------------------------------------------
+ * - audio (red):                  | audio_sample_bytes |
+ *                                 |        2352        |
+ *
+ * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
+ *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
+ *
+ * - data (yellow, mode2):         | sync - head - data |
+ *                                 |  12  -   4  - 2336 |
+ *
+ * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
+ *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
+ *
+ * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
+ *                                 |  12  -   4  -  8  - 2324 -  4    |
+ *
+ */
+
+/* Some generally useful CD-ROM information -- mostly based on the above */
+#define CD_MINS              74 /* max. minutes per CD, not really a limit */
+#define CD_SECS              60 /* seconds per minute */
+#define CD_FRAMES            75 /* frames per second */
+#define CD_SYNC_SIZE         12 /* 12 sync bytes per raw data frame */
+#define CD_MSF_OFFSET       150 /* MSF numbering offset of first frame */
+#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
+#define CD_NUM_OF_CHUNKS     98 /* chunks per frame */
+#define CD_FRAMESIZE_SUB     96 /* subchannel data "frame" size */
+#define CD_HEAD_SIZE          4 /* header (address) bytes per raw data frame */
+#define CD_SUBHEAD_SIZE       8 /* subheader bytes per raw XA data frame */
+#define CD_EDC_SIZE           4 /* bytes EDC per most raw data frame types */
+#define CD_ZERO_SIZE          8 /* bytes zero per yellow book mode 1 frame */
+#define CD_ECC_SIZE         276 /* bytes ECC per most raw data frame types */
+#define CD_FRAMESIZE       2048 /* bytes per frame, "cooked" mode */
+#define CD_FRAMESIZE_RAW   2352 /* bytes per frame, "raw" mode */
+#define CD_FRAMESIZE_RAWER 2646 /* The maximum possible returned bytes */ 
+/* most drives don't deliver everything: */
+#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
+#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
+
+#define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* "before data" part of raw XA frame */
+#define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* "after data" part of raw XA frame */
+#define CD_XA_SYNC_HEAD   (CD_SYNC_SIZE+CD_XA_HEAD) /* sync bytes + header of XA frame */
+
+/* CD-ROM address types (cdrom_tocentry.cdte_format) */
+#define	CDROM_LBA 0x01 /* "logical block": first frame is #0 */
+#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */
+
+/* bit to tell whether track is data or audio (cdrom_tocentry.cdte_ctrl) */
+#define	CDROM_DATA_TRACK	0x04
+
+/* The leadout track is always 0xAA, regardless of # of tracks on disc */
+#define	CDROM_LEADOUT		0xAA
+
+/* audio states (from SCSI-2, but seen with other drives, too) */
+#define	CDROM_AUDIO_INVALID	0x00	/* audio status not supported */
+#define	CDROM_AUDIO_PLAY	0x11	/* audio play operation in progress */
+#define	CDROM_AUDIO_PAUSED	0x12	/* audio play operation paused */
+#define	CDROM_AUDIO_COMPLETED	0x13	/* audio play successfully completed */
+#define	CDROM_AUDIO_ERROR	0x14	/* audio play stopped due to error */
+#define	CDROM_AUDIO_NO_STATUS	0x15	/* no current audio status to return */
+
+/* capability flags used with the uniform CD-ROM driver */ 
+#define CDC_CLOSE_TRAY		0x1     /* caddy systems _can't_ close */
+#define CDC_OPEN_TRAY		0x2     /* but _can_ eject.  */
+#define CDC_LOCK		0x4     /* disable manual eject */
+#define CDC_SELECT_SPEED 	0x8     /* programmable speed */
+#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
+#define CDC_MULTI_SESSION 	0x20    /* read sessions>1 */
+#define CDC_MCN			0x40    /* Medium Catalog Number */
+#define CDC_MEDIA_CHANGED 	0x80    /* media changed */
+#define CDC_PLAY_AUDIO		0x100   /* audio functions */
+#define CDC_RESET               0x200   /* hard reset device */
+#define CDC_IOCTLS              0x400   /* driver has non-standard ioctls */
+#define CDC_DRIVE_STATUS        0x800   /* driver implements drive status */
+#define CDC_GENERIC_PACKET	0x1000	/* driver implements generic packets */
+#define CDC_CD_R		0x2000	/* drive is a CD-R */
+#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
+#define CDC_DVD			0x8000	/* drive is a DVD */
+#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
+#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
+#define CDC_MO_DRIVE		0x40000 /* drive is an MO device */
+#define CDC_MRW			0x80000 /* drive can read MRW */
+#define CDC_MRW_W		0x100000 /* drive can write MRW */
+#define CDC_RAM			0x200000 /* ok to open for WRITE */
+
+/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
+#define CDS_NO_INFO		0	/* if not implemented */
+#define CDS_NO_DISC		1
+#define CDS_TRAY_OPEN		2
+#define CDS_DRIVE_NOT_READY	3
+#define CDS_DISC_OK		4
+
+/* return values for the CDROM_DISC_STATUS ioctl */
+/* can also return CDS_NO_[INFO|DISC], from above */
+#define CDS_AUDIO		100
+#define CDS_DATA_1		101
+#define CDS_DATA_2		102
+#define CDS_XA_2_1		103
+#define CDS_XA_2_2		104
+#define CDS_MIXED		105
+
+/* User-configurable behavior options for the uniform CD-ROM driver */
+#define CDO_AUTO_CLOSE		0x1     /* close tray on first open() */
+#define CDO_AUTO_EJECT		0x2     /* open tray on last release() */
+#define CDO_USE_FFLAGS		0x4     /* use O_NONBLOCK information on open */
+#define CDO_LOCK		0x8     /* lock tray on open files */
+#define CDO_CHECK_TYPE		0x10    /* check type on open for data */
+
+/* Special codes used when specifying changer slots. */
+#define CDSL_NONE       	((int) (~0U>>1)-1)
+#define CDSL_CURRENT    	((int) (~0U>>1))
+
+/* For partition based multisession access. IDE can handle 64 partitions
+ * per drive - SCSI CD-ROM's use minors to differentiate between the
+ * various drives, so we can't do multisessions the same way there.
+ * Use the -o session=x option to mount on them.
+ */
+#define CD_PART_MAX		64
+#define CD_PART_MASK		(CD_PART_MAX - 1)
+
+/*********************************************************************
+ * Generic Packet commands, MMC commands, and such
+ *********************************************************************/
+
+ /* The generic packet command opcodes for CD/DVD Logical Units,
+ * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
+#define GPCMD_BLANK			    0xa1
+#define GPCMD_CLOSE_TRACK		    0x5b
+#define GPCMD_FLUSH_CACHE		    0x35
+#define GPCMD_FORMAT_UNIT		    0x04
+#define GPCMD_GET_CONFIGURATION		    0x46
+#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
+#define GPCMD_GET_PERFORMANCE		    0xac
+#define GPCMD_INQUIRY			    0x12
+#define GPCMD_LOAD_UNLOAD		    0xa6
+#define GPCMD_MECHANISM_STATUS		    0xbd
+#define GPCMD_MODE_SELECT_10		    0x55
+#define GPCMD_MODE_SENSE_10		    0x5a
+#define GPCMD_PAUSE_RESUME		    0x4b
+#define GPCMD_PLAY_AUDIO_10		    0x45
+#define GPCMD_PLAY_AUDIO_MSF		    0x47
+#define GPCMD_PLAY_AUDIO_TI		    0x48
+#define GPCMD_PLAY_CD			    0xbc
+#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
+#define GPCMD_READ_10			    0x28
+#define GPCMD_READ_12			    0xa8
+#define GPCMD_READ_BUFFER_CAPACITY	    0x5c
+#define GPCMD_READ_CDVD_CAPACITY	    0x25
+#define GPCMD_READ_CD			    0xbe
+#define GPCMD_READ_CD_MSF		    0xb9
+#define GPCMD_READ_DISC_INFO		    0x51
+#define GPCMD_READ_DVD_STRUCTURE	    0xad
+#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
+#define GPCMD_READ_HEADER		    0x44
+#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
+#define GPCMD_READ_SUBCHANNEL		    0x42
+#define GPCMD_READ_TOC_PMA_ATIP		    0x43
+#define GPCMD_REPAIR_RZONE_TRACK	    0x58
+#define GPCMD_REPORT_KEY		    0xa4
+#define GPCMD_REQUEST_SENSE		    0x03
+#define GPCMD_RESERVE_RZONE_TRACK	    0x53
+#define GPCMD_SEND_CUE_SHEET		    0x5d
+#define GPCMD_SCAN			    0xba
+#define GPCMD_SEEK			    0x2b
+#define GPCMD_SEND_DVD_STRUCTURE	    0xbf
+#define GPCMD_SEND_EVENT		    0xa2
+#define GPCMD_SEND_KEY			    0xa3
+#define GPCMD_SEND_OPC			    0x54
+#define GPCMD_SET_READ_AHEAD		    0xa7
+#define GPCMD_SET_STREAMING		    0xb6
+#define GPCMD_START_STOP_UNIT		    0x1b
+#define GPCMD_STOP_PLAY_SCAN		    0x4e
+#define GPCMD_TEST_UNIT_READY		    0x00
+#define GPCMD_VERIFY_10			    0x2f
+#define GPCMD_WRITE_10			    0x2a
+#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+/* This is listed as optional in ATAPI 2.6, but is (curiously) 
+ * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
+ * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
+ * drives support it. */
+#define GPCMD_SET_SPEED			    0xbb
+/* This seems to be a SCSI specific CD-ROM opcode 
+ * to play data at track/index */
+#define GPCMD_PLAYAUDIO_TI		    0x48
+/*
+ * From MS Media Status Notification Support Specification. For
+ * older drives only.
+ */
+#define GPCMD_GET_MEDIA_STATUS		    0xda
+
+/* Mode page codes for mode sense/set */
+#define GPMODE_VENDOR_PAGE		0x00
+#define GPMODE_R_W_ERROR_PAGE		0x01
+#define GPMODE_WRITE_PARMS_PAGE		0x05
+#define GPMODE_WCACHING_PAGE		0x08
+#define GPMODE_AUDIO_CTL_PAGE		0x0e
+#define GPMODE_POWER_PAGE		0x1a
+#define GPMODE_FAULT_FAIL_PAGE		0x1c
+#define GPMODE_TO_PROTECT_PAGE		0x1d
+#define GPMODE_CAPABILITIES_PAGE	0x2a
+#define GPMODE_ALL_PAGES		0x3f
+/* Not in Mt. Fuji, but in ATAPI 2.6 -- depricated now in favor
+ * of MODE_SENSE_POWER_PAGE */
+#define GPMODE_CDROM_PAGE		0x0d
+
+
+
+/* DVD struct types */
+#define DVD_STRUCT_PHYSICAL	0x00
+#define DVD_STRUCT_COPYRIGHT	0x01
+#define DVD_STRUCT_DISCKEY	0x02
+#define DVD_STRUCT_BCA		0x03
+#define DVD_STRUCT_MANUFACT	0x04
+
+struct dvd_layer {
+	__u8 book_version	: 4;
+	__u8 book_type		: 4;
+	__u8 min_rate		: 4;
+	__u8 disc_size		: 4;
+	__u8 layer_type		: 4;
+	__u8 track_path		: 1;
+	__u8 nlayers		: 2;
+	__u8 track_density	: 4;
+	__u8 linear_density	: 4;
+	__u8 bca		: 1;
+	__u32 start_sector;
+	__u32 end_sector;
+	__u32 end_sector_l0;
+};
+
+#define DVD_LAYERS	4
+
+struct dvd_physical {
+	__u8 type;
+	__u8 layer_num;
+	struct dvd_layer layer[DVD_LAYERS];
+};
+
+struct dvd_copyright {
+	__u8 type;
+
+	__u8 layer_num;
+	__u8 cpst;
+	__u8 rmi;
+};
+
+struct dvd_disckey {
+	__u8 type;
+
+	unsigned agid		: 2;
+	__u8 value[2048];
+};
+
+struct dvd_bca {
+	__u8 type;
+
+	int len;
+	__u8 value[188];
+};
+
+struct dvd_manufact {
+	__u8 type;
+
+	__u8 layer_num;
+	int len;
+	__u8 value[2048];
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_physical	physical;
+	struct dvd_copyright	copyright;
+	struct dvd_disckey	disckey;
+	struct dvd_bca		bca;
+	struct dvd_manufact	manufact;
+} dvd_struct;
+
+/*
+ * DVD authentication ioctl
+ */
+
+/* Authentication states */
+#define DVD_LU_SEND_AGID	0
+#define DVD_HOST_SEND_CHALLENGE	1
+#define DVD_LU_SEND_KEY1	2
+#define DVD_LU_SEND_CHALLENGE	3
+#define DVD_HOST_SEND_KEY2	4
+
+/* Termination states */
+#define DVD_AUTH_ESTABLISHED	5
+#define DVD_AUTH_FAILURE	6
+
+/* Other functions */
+#define DVD_LU_SEND_TITLE_KEY	7
+#define DVD_LU_SEND_ASF		8
+#define DVD_INVALIDATE_AGID	9
+#define DVD_LU_SEND_RPC_STATE	10
+#define DVD_HOST_SEND_RPC_STATE	11
+
+/* State data */
+typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
+typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
+
+struct dvd_lu_send_agid {
+	__u8 type;
+	unsigned agid		: 2;
+};
+
+struct dvd_host_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+struct dvd_send_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key key;
+};
+
+struct dvd_lu_send_challenge {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_challenge chal;
+};
+
+#define DVD_CPM_NO_COPYRIGHT	0
+#define DVD_CPM_COPYRIGHTED	1
+
+#define DVD_CP_SEC_NONE		0
+#define DVD_CP_SEC_EXIST	1
+
+#define DVD_CGMS_UNRESTRICTED	0
+#define DVD_CGMS_SINGLE		2
+#define DVD_CGMS_RESTRICTED	3
+
+struct dvd_lu_send_title_key {
+	__u8 type;
+	unsigned agid		: 2;
+
+	dvd_key title_key;
+	int lba;
+	unsigned cpm		: 1;
+	unsigned cp_sec		: 1;
+	unsigned cgms		: 2;
+};
+
+struct dvd_lu_send_asf {
+	__u8 type;
+	unsigned agid		: 2;
+
+	unsigned asf		: 1;
+};
+
+struct dvd_host_send_rpcstate {
+	__u8 type;
+	__u8 pdrc;
+};
+
+struct dvd_lu_send_rpcstate {
+	__u8 type		: 2;
+	__u8 vra		: 3;
+	__u8 ucca		: 3;
+	__u8 region_mask;
+	__u8 rpc_scheme;
+};
+
+typedef union {
+	__u8 type;
+
+	struct dvd_lu_send_agid		lsa;
+	struct dvd_host_send_challenge	hsc;
+	struct dvd_send_key		lsk;
+	struct dvd_lu_send_challenge	lsc;
+	struct dvd_send_key		hsk;
+	struct dvd_lu_send_title_key	lstk;
+	struct dvd_lu_send_asf		lsasf;
+	struct dvd_host_send_rpcstate	hrpcs;
+	struct dvd_lu_send_rpcstate	lrpcs;
+} dvd_authinfo;
+
+struct request_sense {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 valid		: 1;
+	__u8 error_code		: 7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 error_code		: 7;
+	__u8 valid		: 1;
+#endif
+	__u8 segment_number;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 ili		: 1;
+	__u8 reserved2		: 1;
+	__u8 sense_key		: 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 sense_key		: 4;
+	__u8 reserved2		: 1;
+	__u8 ili		: 1;
+	__u8 reserved1		: 2;
+#endif
+	__u8 information[4];
+	__u8 add_sense_len;
+	__u8 command_info[4];
+	__u8 asc;
+	__u8 ascq;
+	__u8 fruc;
+	__u8 sks[3];
+	__u8 asb[46];
+};
+
+/*
+ * feature profile
+ */
+#define CDF_RWRT	0x0020	/* "Random Writable" */
+#define CDF_HWDM	0x0024	/* "Hardware Defect Management" */
+#define CDF_MRW 	0x0028
+
+/*
+ * media status bits
+ */
+#define CDM_MRW_NOTMRW			0
+#define CDM_MRW_BGFORMAT_INACTIVE	1
+#define CDM_MRW_BGFORMAT_ACTIVE		2
+#define CDM_MRW_BGFORMAT_COMPLETE	3
+
+/*
+ * mrw address spaces
+ */
+#define MRW_LBA_DMA			0
+#define MRW_LBA_GAA			1
+
+/*
+ * mrw mode pages (first is deprecated) -- probed at init time and
+ * cdi->mrw_mode_page is set
+ */
+#define MRW_MODE_PC_PRE1		0x2c
+#define MRW_MODE_PC			0x03
+
+struct mrw_feature_desc {
+	__u16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 write		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 write		: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+	__u8 reserved4;
+	__u8 reserved5;
+};
+
+/* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
+struct rwrt_feature_desc {
+	__u16 feature_code;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 2;
+	__u8 feature_version	: 4;
+	__u8 persistent		: 1;
+	__u8 curr		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curr		: 1;
+	__u8 persistent		: 1;
+	__u8 feature_version	: 4;
+	__u8 reserved1		: 2;
+#endif
+	__u8 add_len;
+	__u32 last_lba;
+	__u32 block_size;
+	__u16 blocking;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2		: 7;
+	__u8 page_present	: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 page_present	: 1;
+	__u8 reserved2		: 7;
+#endif
+	__u8 reserved3;
+};
+
+typedef struct {
+	__u16 disc_information_length;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1			: 3;
+        __u8 erasable			: 1;
+        __u8 border_status		: 2;
+        __u8 disc_status		: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 disc_status		: 2;
+        __u8 border_status		: 2;
+        __u8 erasable			: 1;
+	__u8 reserved1			: 3;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	__u8 n_first_track;
+	__u8 n_sessions_lsb;
+	__u8 first_track_lsb;
+	__u8 last_track_lsb;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 did_v			: 1;
+        __u8 dbc_v			: 1;
+        __u8 uru			: 1;
+        __u8 reserved2			: 2;
+	__u8 dbit			: 1;
+	__u8 mrw_status			: 2;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 mrw_status			: 2;
+	__u8 dbit			: 1;
+        __u8 reserved2			: 2;
+        __u8 uru			: 1;
+        __u8 dbc_v			: 1;
+	__u8 did_v			: 1;
+#endif
+	__u8 disc_type;
+	__u8 n_sessions_msb;
+	__u8 first_track_msb;
+	__u8 last_track_msb;
+	__u32 disc_id;
+	__u32 lead_in;
+	__u32 lead_out;
+	__u8 disc_bar_code[8];
+	__u8 reserved3;
+	__u8 n_opc;
+} disc_information;
+
+typedef struct {
+	__u16 track_information_length;
+	__u8 track_lsb;
+	__u8 session_lsb;
+	__u8 reserved1;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved2			: 2;
+        __u8 damage			: 1;
+        __u8 copy			: 1;
+        __u8 track_mode			: 4;
+	__u8 rt				: 1;
+	__u8 blank			: 1;
+	__u8 packet			: 1;
+	__u8 fp				: 1;
+	__u8 data_mode			: 4;
+	__u8 reserved3			: 6;
+	__u8 lra_v			: 1;
+	__u8 nwa_v			: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 track_mode			: 4;
+        __u8 copy			: 1;
+        __u8 damage			: 1;
+	__u8 reserved2			: 2;
+	__u8 data_mode			: 4;
+	__u8 fp				: 1;
+	__u8 packet			: 1;
+	__u8 blank			: 1;
+	__u8 rt				: 1;
+	__u8 nwa_v			: 1;
+	__u8 lra_v			: 1;
+	__u8 reserved3			: 6;
+#endif
+	__u32 track_start;
+	__u32 next_writable;
+	__u32 free_blocks;
+	__u32 fixed_packet_size;
+	__u32 track_size;
+	__u32 last_rec_address;
+} track_information;
+
+struct feature_header {
+	__u32 data_len;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u16 curr_profile;
+};
+
+struct mode_page_header {
+	__u16 mode_data_length;
+	__u8 medium_type;
+	__u8 reserved1;
+	__u8 reserved2;
+	__u8 reserved3;
+	__u16 desc_length;
+};
+
+#ifdef __KERNEL__
+#include <linux/fs.h>		/* not really needed, later.. */
+#include <linux/device.h>
+
+struct packet_command
+{
+	unsigned char 		cmd[CDROM_PACKET_SIZE];
+	unsigned char 		*buffer;
+	unsigned int 		buflen;
+	int			stat;
+	struct request_sense	*sense;
+	unsigned char		data_direction;
+	int			quiet;
+	int			timeout;
+	void			*reserved[1];
+};
+
+/*
+ * _OLD will use PIO transfer on atapi devices, _BPC_* will use DMA
+ */
+#define CDDA_OLD		0	/* old style */
+#define CDDA_BPC_SINGLE		1	/* single frame block pc */
+#define CDDA_BPC_FULL		2	/* multi frame block pc */
+
+/* Uniform cdrom data structures for cdrom.c */
+struct cdrom_device_info {
+	struct cdrom_device_ops  *ops;  /* link to device_ops */
+	struct cdrom_device_info *next; /* next device_info for this major */
+	struct gendisk *disk;		/* matching block layer disk */
+	void *handle;		        /* driver-dependent data */
+/* specifications */
+	int mask;                       /* mask of capability: disables them */
+	int speed;			/* maximum speed for reading data */
+	int capacity;			/* number of discs in jukebox */
+/* device-related storage */
+	int options		: 30;	/* options flags */
+	unsigned mc_flags	: 2;	/* media change buffer flags */
+    	int use_count;                  /* number of times device opened */
+    	char name[20];                  /* name of the device type */
+/* per-device flags */
+        __u8 sanyo_slot		: 2;	/* Sanyo 3 CD changer support */
+        __u8 reserved		: 6;	/* not used yet */
+	int cdda_method;		/* see flags */
+	__u8 last_sense;
+	__u8 media_written;		/* dirty flag, DVD+RW bookkeeping */
+	unsigned short mmc3_profile;	/* current MMC3 profile */
+	int for_data;
+	int (*exit)(struct cdrom_device_info *);
+	int mrw_mode_page;
+};
+
+struct cdrom_device_ops {
+/* routines */
+	int (*open) (struct cdrom_device_info *, int);
+	void (*release) (struct cdrom_device_info *);
+	int (*drive_status) (struct cdrom_device_info *, int);
+	int (*media_changed) (struct cdrom_device_info *, int);
+	int (*tray_move) (struct cdrom_device_info *, int);
+	int (*lock_door) (struct cdrom_device_info *, int);
+	int (*select_speed) (struct cdrom_device_info *, int);
+	int (*select_disc) (struct cdrom_device_info *, int);
+	int (*get_last_session) (struct cdrom_device_info *,
+				 struct cdrom_multisession *);
+	int (*get_mcn) (struct cdrom_device_info *,
+			struct cdrom_mcn *);
+	/* hard reset device */
+	int (*reset) (struct cdrom_device_info *);
+	/* play stuff */
+	int (*audio_ioctl) (struct cdrom_device_info *,unsigned int, void *);
+	/* dev-specific */
+ 	int (*dev_ioctl) (struct cdrom_device_info *,
+			  unsigned int, unsigned long);
+/* driver specifications */
+	const int capability;   /* capability flags */
+	int n_minors;           /* number of active minor devices */
+	/* handle uniform packets for scsi type devices (scsi,atapi) */
+	int (*generic_packet) (struct cdrom_device_info *,
+			       struct packet_command *);
+};
+
+/* the general block_device operations structure: */
+extern int cdrom_open(struct cdrom_device_info *cdi, struct inode *ip,
+			struct file *fp);
+extern int cdrom_release(struct cdrom_device_info *cdi, struct file *fp);
+extern int cdrom_ioctl(struct file *file, struct cdrom_device_info *cdi,
+		struct inode *ip, unsigned int cmd, unsigned long arg);
+extern int cdrom_media_changed(struct cdrom_device_info *);
+
+extern int register_cdrom(struct cdrom_device_info *cdi);
+extern int unregister_cdrom(struct cdrom_device_info *cdi);
+
+typedef struct {
+    int data;
+    int audio;
+    int cdi;
+    int xa;
+    long error;
+} tracktype;
+
+extern int cdrom_get_last_written(struct cdrom_device_info *cdi, long *last_written);
+extern int cdrom_number_of_slots(struct cdrom_device_info *cdi);
+extern int cdrom_mode_select(struct cdrom_device_info *cdi,
+			     struct packet_command *cgc);
+extern int cdrom_mode_sense(struct cdrom_device_info *cdi,
+			    struct packet_command *cgc,
+			    int page_code, int page_control);
+extern void init_cdrom_command(struct packet_command *cgc,
+			       void *buffer, int len, int type);
+
+/* The SCSI spec says there could be 256 slots. */
+#define CDROM_MAX_SLOTS	256
+
+struct cdrom_mechstat_header {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 fault         : 1;
+	__u8 changer_state : 2;
+	__u8 curslot       : 5;
+	__u8 mech_state    : 3;
+	__u8 door_open     : 1;
+	__u8 reserved1     : 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 curslot       : 5;
+	__u8 changer_state : 2;
+	__u8 fault         : 1;
+	__u8 reserved1     : 4;
+	__u8 door_open     : 1;
+	__u8 mech_state    : 3;
+#endif
+	__u8     curlba[3];
+	__u8     nslots;
+	__u16 slot_tablelen;
+};
+
+struct cdrom_slot {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 disc_present : 1;
+	__u8 reserved1    : 6;
+	__u8 change       : 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 change       : 1;
+	__u8 reserved1    : 6;
+	__u8 disc_present : 1;
+#endif
+	__u8 reserved2[3];
+};
+
+struct cdrom_changer_info {
+	struct cdrom_mechstat_header hdr;
+	struct cdrom_slot slots[CDROM_MAX_SLOTS];
+};
+
+typedef enum {
+	mechtype_caddy = 0,
+	mechtype_tray  = 1,
+	mechtype_popup = 2,
+	mechtype_individual_changer = 4,
+	mechtype_cartridge_changer  = 5
+} mechtype_t;
+
+typedef struct {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 ps			: 1;
+	__u8 reserved1		: 1;
+	__u8 page_code		: 6;
+        __u8 page_length;
+	__u8 reserved2		: 1;
+	__u8 bufe		: 1;
+	__u8 ls_v		: 1;
+	__u8 test_write		: 1;
+        __u8 write_type		: 4;
+	__u8 multi_session	: 2; /* or border, DVD */
+	__u8 fp			: 1;
+	__u8 copy		: 1;
+	__u8 track_mode		: 4;
+	__u8 reserved3		: 4;
+	__u8 data_block_type	: 4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 page_code		: 6;
+	__u8 reserved1		: 1;
+	__u8 ps			: 1;
+        __u8 page_length;
+        __u8 write_type		: 4;
+	__u8 test_write		: 1;
+	__u8 ls_v		: 1;
+	__u8 bufe		: 1;
+	__u8 reserved2		: 1;
+	__u8 track_mode		: 4;
+	__u8 copy		: 1;
+	__u8 fp			: 1;
+	__u8 multi_session	: 2; /* or border, DVD */
+	__u8 data_block_type	: 4;
+	__u8 reserved3		: 4;
+#endif
+	__u8 link_size;
+	__u8 reserved4;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved5		: 2;
+	__u8 app_code		: 6;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 app_code		: 6;
+	__u8 reserved5		: 2;
+#endif
+	__u8 session_format;
+	__u8 reserved6;
+	__u32 packet_size;
+	__u16 audio_pause;
+	__u8 mcn[16];
+	__u8 isrc[16];
+	__u8 subhdr0;
+	__u8 subhdr1;
+	__u8 subhdr2;
+	__u8 subhdr3;
+} __attribute__((packed)) write_param_page;
+
+struct modesel_head
+{
+	__u8	reserved1;
+	__u8	medium;
+	__u8	reserved2;
+	__u8	block_desc_length;
+	__u8	density;
+	__u8	number_of_blocks_hi;
+	__u8	number_of_blocks_med;
+	__u8	number_of_blocks_lo;
+	__u8	reserved3;
+	__u8	block_length_hi;
+	__u8	block_length_med;
+	__u8	block_length_lo;
+};
+
+typedef struct {
+	__u16 report_key_length;
+	__u8 reserved1;
+	__u8 reserved2;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 type_code			: 2;
+	__u8 vra			: 3;
+	__u8 ucca			: 3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 ucca			: 3;
+	__u8 vra			: 3;
+	__u8 type_code			: 2;
+#endif
+	__u8 region_mask;
+	__u8 rpc_scheme;
+	__u8 reserved3;
+} rpc_state_t;
+
+struct event_header {
+	__u16 data_len;
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 nea		: 1;
+	__u8 reserved1		: 4;
+	__u8 notification_class	: 3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 notification_class	: 3;
+	__u8 reserved1		: 4;
+	__u8 nea		: 1;
+#endif
+	__u8 supp_event_class;
+};
+
+struct media_event_desc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8 reserved1		: 4;
+	__u8 media_event_code	: 4;
+	__u8 reserved2		: 6;
+	__u8 media_present	: 1;
+	__u8 door_open		: 1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 media_event_code	: 4;
+	__u8 reserved1		: 4;
+	__u8 door_open		: 1;
+	__u8 media_present	: 1;
+	__u8 reserved2		: 6;
+#endif
+	__u8 start_slot;
+	__u8 end_slot;
+};
+
+extern int cdrom_get_media_event(struct cdrom_device_info *cdi, struct media_event_desc *med);
+
+#endif  /* End of kernel only stuff */ 
+
+#endif  /* _LINUX_CDROM_H */
