commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 5ef5c7c412a7..7b22366d0065 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2011-2016 Synaptics Incorporated
  * Copyright (c) 2011 Unixphere
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 
 #ifndef _RMI_H

commit 24d28e4f1271cb2f91613dada8f2acccd00eff56
Author: Nick Dyer <nick@shmanahar.org>
Date:   Tue Jun 5 10:17:51 2018 -0700

    Input: synaptics-rmi4 - convert irq distribution to irq_domain
    
    Convert the RMI driver to use the standard mechanism for
    distributing IRQs to the various functions.
    
    Tested on:
    * S7300 (F11, F34, F54)
    * S7817 (F12, F34, F54)
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Acked-by: Christopher Heiny <cheiny@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 64125443f8a6..5ef5c7c412a7 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -354,6 +354,8 @@ struct rmi_driver_data {
 	struct mutex irq_mutex;
 	struct input_dev *input;
 
+	struct irq_domain *irqdomain;
+
 	u8 pdt_props;
 
 	u8 num_rx_electrodes;

commit 5191d88acc688743eef56f1c598a4e4cddf6c6cd
Author: Nick Dyer <nick@shmanahar.org>
Date:   Sat Dec 10 23:27:32 2016 -0800

    Input: synaptics-rmi4 - add support for F34 V7 bootloader
    
    Port firmware update code from Samsung Galaxy S7 driver into
    mainline framework.
    
    This patch has been tested on Synaptics S7813.
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Tested-by: Chris Healy <cphealy@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index ac910f730688..64125443f8a6 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -342,7 +342,7 @@ struct rmi_driver_data {
 
 	struct rmi_function *f01_container;
 	struct rmi_function *f34_container;
-	bool f01_bootloader_mode;
+	bool bootloader_mode;
 
 	int num_of_irq_regs;
 	int irq_count;

commit ae9979c31007d5366b73640ee7dcbb271357053e
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Dec 2 17:49:10 2016 -0800

    Input: synaptics-rmi4 - store the attn data in the driver
    
    Now that we have a proper API to set the attention data, there is
    no point in keeping it in the transport driver.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 1d4865621493..ac910f730688 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -272,9 +272,6 @@ struct rmi_transport_dev {
 	struct rmi_device_platform_data pdata;
 
 	struct input_dev *input;
-
-	void *attn_data;
-	int attn_size;
 };
 
 /**
@@ -364,6 +361,8 @@ struct rmi_driver_data {
 
 	bool enabled;
 	struct mutex enabled_mutex;
+
+	struct rmi4_attn_data attn_data;
 	DECLARE_KFIFO(attn_fifo, struct rmi4_attn_data, 16);
 };
 

commit b908d3cd812abe3f4a74d7550bbf0a8cbcfbe6ed
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Fri Dec 2 17:48:51 2016 -0800

    Input: synaptics-rmi4 - allow to add attention data
    
    The HID implementation of RMI4 provides the data during
    the interrupt (in the input report). We need to provide
    a way for this transport driver to provide the attention
    data while calling an IRQ.
    
    We use a fifo in rmi_core to not lose any incoming event.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Reviewed-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 7780e40a2573..1d4865621493 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
+#include <linux/kfifo.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -331,6 +332,12 @@ struct rmi_device {
 
 };
 
+struct rmi4_attn_data {
+	unsigned long irq_status;
+	size_t size;
+	void *data;
+};
+
 struct rmi_driver_data {
 	struct list_head function_list;
 
@@ -357,11 +364,15 @@ struct rmi_driver_data {
 
 	bool enabled;
 	struct mutex enabled_mutex;
+	DECLARE_KFIFO(attn_fifo, struct rmi4_attn_data, 16);
 };
 
 int rmi_register_transport_device(struct rmi_transport_dev *xport);
 void rmi_unregister_transport_device(struct rmi_transport_dev *xport);
 
+void rmi_set_attn_data(struct rmi_device *rmi_dev, unsigned long irq_status,
+		       void *data, size_t size);
+
 int rmi_driver_suspend(struct rmi_device *rmi_dev, bool enable_wake);
 int rmi_driver_resume(struct rmi_device *rmi_dev, bool clear_wake);
 #endif

commit 0a135b88bceac40d0036e401c19cdbda65b38a8f
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Wed Nov 30 17:01:50 2016 -0800

    Input: synaptics-rmi4 - have only one struct platform data
    
    If struct rmi_device_platform_data contains pointers to other struct,
    it gets difficult to allocate a fixed size struct and copy it over between
    drivers.
    
    Change the pointers into a struct and change the code in rmi4 accordingly.
    
    Reviewed-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 621f098f1243..7780e40a2573 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -218,9 +218,9 @@ struct rmi_device_platform_data {
 	struct rmi_device_platform_data_spi spi_data;
 
 	/* function handler pdata */
-	struct rmi_2d_sensor_platform_data *sensor_pdata;
+	struct rmi_2d_sensor_platform_data sensor_pdata;
 	struct rmi_f01_power_management power_management;
-	struct rmi_f30_data *f30_data;
+	struct rmi_f30_data f30_data;
 };
 
 /**

commit a64ea311f1e4bc090c89960650637423e86c35c0
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Nov 29 17:42:13 2016 -0800

    Input: synaptics-rmi4 - add rmi_enable/disable_irq
    
    Set the .enabled boolean and trigger an event processing when enabling
    for edge-triggered systems.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 0b118ab47b8d..621f098f1243 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -356,6 +356,7 @@ struct rmi_driver_data {
 	u8 num_tx_electrodes;
 
 	bool enabled;
+	struct mutex enabled_mutex;
 };
 
 int rmi_register_transport_device(struct rmi_transport_dev *xport);

commit 0d37d63a001202b4932f6b14b05d8d055a0a45b6
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Nov 29 17:42:01 2016 -0800

    Input: synaptics-rmi4 - remove unused fields in struct rmi_driver_data
    
    These fields are not used anywhere, there is no point in carrying them.
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 27dd9aa4090c..0b118ab47b8d 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -340,7 +340,6 @@ struct rmi_driver_data {
 	struct rmi_function *f34_container;
 	bool f01_bootloader_mode;
 
-	u32 attn_count;
 	int num_of_irq_regs;
 	int irq_count;
 	void *irq_memory;
@@ -352,14 +351,11 @@ struct rmi_driver_data {
 	struct input_dev *input;
 
 	u8 pdt_props;
-	u8 bsr;
 
 	u8 num_rx_electrodes;
 	u8 num_tx_electrodes;
 
 	bool enabled;
-
-	void *data;
 };
 
 int rmi_register_transport_device(struct rmi_transport_dev *xport);

commit 9e421b7c60860f150aa29e9f7bc902f003d87e68
Author: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Date:   Tue Nov 29 17:41:50 2016 -0800

    Input: synaptics-rmi4 - fix documentation of rmi_2d_sensor_platform_data
    
    Typos...
    
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 8499b6aa2221..27dd9aa4090c 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -108,7 +108,7 @@ struct rmi_2d_sensor_platform_data {
  * @buttonpad - the touchpad is a buttonpad, so enable only the first actual
  * button that is found.
  * @trackstick_buttons - Set when the function 30 is handling the physical
- * buttons of the trackstick (as a PD/2 passthrough device.
+ * buttons of the trackstick (as a PS/2 passthrough device).
  * @disable - the touchpad incorrectly reports F30 and it should be ignored.
  * This is a special case which is due to misconfigured firmware.
  */

commit c762cc68b6a12eedebefc156ea4838e54804e2eb
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Nov 22 17:57:02 2016 -0800

    Input: synaptics-rmi4 - propagate correct number of rx and tx electrodes to F54
    
    F54 diagnostics report functions provide data based on the number of
    enabled rx and tx electrodes, which is not identical to the number of
    electrodes reported with F54:Query0 and F54:Query1. Those values report
    the number of supported electrodes, not the number of enabled electrodes.
    The number of enabled electrodes can be determined by analyzing F55:Ctrl1
    (sensor receiver assignment) and F55:Ctrl2 (sensor transmitter assignment).
    
    Propagate the number of enabled electrodes from F55 to F54 to avoid
    corrupted output if not all electrodes are enabled.
    
    Fixes: 3a762dbd5347 ("[media] Input: synaptics-rmi4 - add support for F54 ...")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Nick Dyer <nick@shmanahar.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 4096b0246c23..8499b6aa2221 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -354,6 +354,9 @@ struct rmi_driver_data {
 	u8 pdt_props;
 	u8 bsr;
 
+	u8 num_rx_electrodes;
+	u8 num_tx_electrodes;
+
 	bool enabled;
 
 	void *data;

commit 29fd0ec2bdbef6734fd4c39c23f61d9f030a66a0
Author: Nick Dyer <nick@shmanahar.org>
Date:   Tue Nov 22 17:44:12 2016 -0800

    Input: synaptics-rmi4 - add support for F34 device reflash
    
    Add support for updating firmware, triggered by a sysfs attribute.
    
    This patch has been tested on Synaptics S7300.
    
    Signed-off-by: Nick Dyer <nick@shmanahar.org>
    Tested-by: Chris Healy <cphealy@gmail.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index ac904bb439a5..4096b0246c23 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -337,11 +337,13 @@ struct rmi_driver_data {
 	struct rmi_device *rmi_dev;
 
 	struct rmi_function *f01_container;
+	struct rmi_function *f34_container;
 	bool f01_bootloader_mode;
 
 	u32 attn_count;
 	int num_of_irq_regs;
 	int irq_count;
+	void *irq_memory;
 	unsigned long *irq_status;
 	unsigned long *fn_irq_bits;
 	unsigned long *current_irq_mask;

commit 2775e523246e11c5ce90b69226c5e67aa43e64a5
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Tue Nov 8 16:48:48 2016 -0800

    Input: synaptics-rmi4 - add parameters for dribble packets and palm detect gesture
    
    The rmi_f11 driver currently disables dribble packets and the palm detect
    gesture for all devices. This patch creates a parameter in the 2d sensor
    platform data for controlling this functionality on a per device basis.
    
    For more information on dribble packets:
    Commit 05ba999fcabb ("HID: rmi: disable dribble packets on Synaptics
    touchpads")
    
    For more information on the palm detect gesture:
    Commit f097deef59a6 ("HID: rmi: disable palm detect gesture when present")
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index 5944e6c2470d..ac904bb439a5 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -99,6 +99,8 @@ struct rmi_2d_sensor_platform_data {
 	bool topbuttonpad;
 	bool kernel_tracking;
 	int dmax;
+	int dribble;
+	int palm_detect;
 };
 
 /**
@@ -116,14 +118,17 @@ struct rmi_f30_data {
 	bool disable;
 };
 
-/**
- * struct rmi_f01_power - override default power management settings.
- *
+
+/*
+ * Set the state of a register
+ *	DEFAULT - use the default value set by the firmware config
+ *	OFF - explicitly disable the register
+ *	ON - explicitly enable the register
  */
-enum rmi_f01_nosleep {
-	RMI_F01_NOSLEEP_DEFAULT = 0,
-	RMI_F01_NOSLEEP_OFF = 1,
-	RMI_F01_NOSLEEP_ON = 2
+enum rmi_reg_state {
+	RMI_REG_STATE_DEFAULT = 0,
+	RMI_REG_STATE_OFF = 1,
+	RMI_REG_STATE_ON = 2
 };
 
 /**
@@ -143,7 +148,7 @@ enum rmi_f01_nosleep {
  * when the touch sensor is in doze mode, in units of 10ms.
  */
 struct rmi_f01_power_management {
-	enum rmi_f01_nosleep nosleep;
+	enum rmi_reg_state nosleep;
 	u8 wakeup_threshold;
 	u8 doze_holdoff;
 	u8 doze_interval;

commit 3aeed5b573f97b4525841cc07c1e948227af389f
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Tue Nov 8 16:34:57 2016 -0800

    Input: synaptics-rmi4 - move IRQ handling to rmi_driver
    
    The attn IRQ is related to the chip, rather than the transport, so move
    all handling of interrupts to the core driver. This also makes sure that
    there are no races between interrupts and availability of the resources
    used by the core driver.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index e0aca1476001..5944e6c2470d 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -204,9 +204,11 @@ struct rmi_device_platform_data_spi {
  * @reset_delay_ms - after issuing a reset command to the touch sensor, the
  * driver waits a few milliseconds to give the firmware a chance to
  * to re-initialize.  You can override the default wait period here.
+ * @irq: irq associated with the attn gpio line, or negative
  */
 struct rmi_device_platform_data {
 	int reset_delay_ms;
+	int irq;
 
 	struct rmi_device_platform_data_spi spi_data;
 
@@ -352,8 +354,7 @@ struct rmi_driver_data {
 
 int rmi_register_transport_device(struct rmi_transport_dev *xport);
 void rmi_unregister_transport_device(struct rmi_transport_dev *xport);
-int rmi_process_interrupt_requests(struct rmi_device *rmi_dev);
 
-int rmi_driver_suspend(struct rmi_device *rmi_dev);
-int rmi_driver_resume(struct rmi_device *rmi_dev);
+int rmi_driver_suspend(struct rmi_device *rmi_dev, bool enable_wake);
+int rmi_driver_resume(struct rmi_device *rmi_dev, bool clear_wake);
 #endif

commit 8d99758dee31ff4a72bfc35d3a7a51fe66b7bb91
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:58:12 2016 -0800

    Input: synaptics-rmi4 - add SPI transport driver
    
    Add the transport driver for devices using RMI4 over SPI.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index ac89d1e731dc..e0aca1476001 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -149,6 +149,55 @@ struct rmi_f01_power_management {
 	u8 doze_interval;
 };
 
+/**
+ * struct rmi_device_platform_data_spi - provides parameters used in SPI
+ * communications.  All Synaptics SPI products support a standard SPI
+ * interface; some also support what is called SPI V2 mode, depending on
+ * firmware and/or ASIC limitations.  In V2 mode, the touch sensor can
+ * support shorter delays during certain operations, and these are specified
+ * separately from the standard mode delays.
+ *
+ * @block_delay - for standard SPI transactions consisting of both a read and
+ * write operation, the delay (in microseconds) between the read and write
+ * operations.
+ * @split_read_block_delay_us - for V2 SPI transactions consisting of both a
+ * read and write operation, the delay (in microseconds) between the read and
+ * write operations.
+ * @read_delay_us - the delay between each byte of a read operation in normal
+ * SPI mode.
+ * @write_delay_us - the delay between each byte of a write operation in normal
+ * SPI mode.
+ * @split_read_byte_delay_us - the delay between each byte of a read operation
+ * in V2 mode.
+ * @pre_delay_us - the delay before the start of a SPI transaction.  This is
+ * typically useful in conjunction with custom chip select assertions (see
+ * below).
+ * @post_delay_us - the delay after the completion of an SPI transaction.  This
+ * is typically useful in conjunction with custom chip select assertions (see
+ * below).
+ * @cs_assert - For systems where the SPI subsystem does not control the CS/SSB
+ * line, or where such control is broken, you can provide a custom routine to
+ * handle a GPIO as CS/SSB.  This routine will be called at the beginning and
+ * end of each SPI transaction.  The RMI SPI implementation will wait
+ * pre_delay_us after this routine returns before starting the SPI transfer;
+ * and post_delay_us after completion of the SPI transfer(s) before calling it
+ * with assert==FALSE.
+ */
+struct rmi_device_platform_data_spi {
+	u32 block_delay_us;
+	u32 split_read_block_delay_us;
+	u32 read_delay_us;
+	u32 write_delay_us;
+	u32 split_read_byte_delay_us;
+	u32 pre_delay_us;
+	u32 post_delay_us;
+	u8 bits_per_word;
+	u16 mode;
+
+	void *cs_assert_data;
+	int (*cs_assert)(const void *cs_assert_data, const bool assert);
+};
+
 /**
  * struct rmi_device_platform_data - system specific configuration info.
  *
@@ -159,6 +208,8 @@ struct rmi_f01_power_management {
 struct rmi_device_platform_data {
 	int reset_delay_ms;
 
+	struct rmi_device_platform_data_spi spi_data;
+
 	/* function handler pdata */
 	struct rmi_2d_sensor_platform_data *sensor_pdata;
 	struct rmi_f01_power_management power_management;

commit 562b42d3ee305472e1b2ea31574c59925e95fd7e
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:56:58 2016 -0800

    Input: synaptics-rmi4 - add support for F30
    
    RMI4 F30 supports input from clickpad buttons and controls LEDs located
    on the touchpad PCB. This patch adds support of the clickpad buttons and
    defers supporting LEDs for the future.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index b527064bac47..ac89d1e731dc 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -101,6 +101,21 @@ struct rmi_2d_sensor_platform_data {
 	int dmax;
 };
 
+/**
+ * struct rmi_f30_data - overrides defaults for a single F30 GPIOs/LED chip.
+ * @buttonpad - the touchpad is a buttonpad, so enable only the first actual
+ * button that is found.
+ * @trackstick_buttons - Set when the function 30 is handling the physical
+ * buttons of the trackstick (as a PD/2 passthrough device.
+ * @disable - the touchpad incorrectly reports F30 and it should be ignored.
+ * This is a special case which is due to misconfigured firmware.
+ */
+struct rmi_f30_data {
+	bool buttonpad;
+	bool trackstick_buttons;
+	bool disable;
+};
+
 /**
  * struct rmi_f01_power - override default power management settings.
  *
@@ -147,6 +162,7 @@ struct rmi_device_platform_data {
 	/* function handler pdata */
 	struct rmi_2d_sensor_platform_data *sensor_pdata;
 	struct rmi_f01_power_management power_management;
+	struct rmi_f30_data *f30_data;
 };
 
 /**

commit ff8f83708b3e36c050dc3fd7e2f04ea7f1752599
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:47:28 2016 -0800

    Input: synaptics-rmi4 - add support for 2D sensors and F11
    
    RMI4 currently defines two functions for reporting data for 2D sensors
    (F11 and F12). This patch adds the common functionality which is shared
    by devices with 2D reporting along with implementing functionality for
    F11.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Christopher Heiny <cheiny@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
index c748fa302067..b527064bac47 100644
--- a/include/linux/rmi.h
+++ b/include/linux/rmi.h
@@ -19,6 +19,88 @@
 
 #define NAME_BUFFER_SIZE 256
 
+/**
+ * struct rmi_2d_axis_alignment - target axis alignment
+ * @swap_axes: set to TRUE if desired to swap x- and y-axis
+ * @flip_x: set to TRUE if desired to flip direction on x-axis
+ * @flip_y: set to TRUE if desired to flip direction on y-axis
+ * @clip_x_low - reported X coordinates below this setting will be clipped to
+ *               the specified value
+ * @clip_x_high - reported X coordinates above this setting will be clipped to
+ *               the specified value
+ * @clip_y_low - reported Y coordinates below this setting will be clipped to
+ *               the specified value
+ * @clip_y_high - reported Y coordinates above this setting will be clipped to
+ *               the specified value
+ * @offset_x - this value will be added to all reported X coordinates
+ * @offset_y - this value will be added to all reported Y coordinates
+ * @rel_report_enabled - if set to true, the relative reporting will be
+ *               automatically enabled for this sensor.
+ */
+struct rmi_2d_axis_alignment {
+	bool swap_axes;
+	bool flip_x;
+	bool flip_y;
+	u16 clip_x_low;
+	u16 clip_y_low;
+	u16 clip_x_high;
+	u16 clip_y_high;
+	u16 offset_x;
+	u16 offset_y;
+	u8 delta_x_threshold;
+	u8 delta_y_threshold;
+};
+
+/** This is used to override any hints an F11 2D sensor might have provided
+ * as to what type of sensor it is.
+ *
+ * @rmi_f11_sensor_default - do not override, determine from F11_2D_QUERY14 if
+ * available.
+ * @rmi_f11_sensor_touchscreen - treat the sensor as a touchscreen (direct
+ * pointing).
+ * @rmi_f11_sensor_touchpad - thread the sensor as a touchpad (indirect
+ * pointing).
+ */
+enum rmi_sensor_type {
+	rmi_sensor_default = 0,
+	rmi_sensor_touchscreen,
+	rmi_sensor_touchpad
+};
+
+#define RMI_F11_DISABLE_ABS_REPORT      BIT(0)
+
+/**
+ * struct rmi_2d_sensor_data - overrides defaults for a 2D sensor.
+ * @axis_align - provides axis alignment overrides (see above).
+ * @sensor_type - Forces the driver to treat the sensor as an indirect
+ * pointing device (touchpad) rather than a direct pointing device
+ * (touchscreen).  This is useful when F11_2D_QUERY14 register is not
+ * available.
+ * @disable_report_mask - Force data to not be reported even if it is supported
+ * by the firware.
+ * @topbuttonpad - Used with the "5 buttons touchpads" found on the Lenovo 40
+ * series
+ * @kernel_tracking - most moderns RMI f11 firmwares implement Multifinger
+ * Type B protocol. However, there are some corner cases where the user
+ * triggers some jumps by tapping with two fingers on the touchpad.
+ * Use this setting and dmax to filter out these jumps.
+ * Also, when using an old sensor using MF Type A behavior, set to true to
+ * report an actual MT protocol B.
+ * @dmax - the maximum distance (in sensor units) the kernel tracking allows two
+ * distincts fingers to be considered the same.
+ */
+struct rmi_2d_sensor_platform_data {
+	struct rmi_2d_axis_alignment axis_align;
+	enum rmi_sensor_type sensor_type;
+	int x_mm;
+	int y_mm;
+	int disable_report_mask;
+	u16 rezero_wait;
+	bool topbuttonpad;
+	bool kernel_tracking;
+	int dmax;
+};
+
 /**
  * struct rmi_f01_power - override default power management settings.
  *
@@ -63,6 +145,7 @@ struct rmi_device_platform_data {
 	int reset_delay_ms;
 
 	/* function handler pdata */
+	struct rmi_2d_sensor_platform_data *sensor_pdata;
 	struct rmi_f01_power_management power_management;
 };
 

commit 2b6a321da9a2d8725a1d3dbb0b2e96a7618ebe56
Author: Andrew Duggan <aduggan@synaptics.com>
Date:   Thu Mar 10 15:35:49 2016 -0800

    Input: synaptics-rmi4 - add support for Synaptics RMI4 devices
    
    Synaptics uses the Register Mapped Interface (RMI) protocol as a
    communications interface for their devices. This driver adds the core
    functionality needed to interface with RMI4 devices.
    
    RMI devices can be connected to the host via several transport protocols
    and can supports a wide variety of functionality defined by RMI functions.
    Support for transport protocols and RMI functions are implemented in
    individual drivers. The RMI4 core driver uses a bus architecture to
    facilitate the various combinations of transport and function drivers
    needed by a particular device.
    
    Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
    Signed-off-by: Christopher Heiny <cheiny@synaptics.com>
    Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/rmi.h b/include/linux/rmi.h
new file mode 100644
index 000000000000..c748fa302067
--- /dev/null
+++ b/include/linux/rmi.h
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2011-2016 Synaptics Incorporated
+ * Copyright (c) 2011 Unixphere
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _RMI_H
+#define _RMI_H
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/types.h>
+
+#define NAME_BUFFER_SIZE 256
+
+/**
+ * struct rmi_f01_power - override default power management settings.
+ *
+ */
+enum rmi_f01_nosleep {
+	RMI_F01_NOSLEEP_DEFAULT = 0,
+	RMI_F01_NOSLEEP_OFF = 1,
+	RMI_F01_NOSLEEP_ON = 2
+};
+
+/**
+ * struct rmi_f01_power_management -When non-zero, these values will be written
+ * to the touch sensor to override the default firmware settigns.  For a
+ * detailed explanation of what each field does, see the corresponding
+ * documention in the RMI4 specification.
+ *
+ * @nosleep - specifies whether the device is permitted to sleep or doze (that
+ * is, enter a temporary low power state) when no fingers are touching the
+ * sensor.
+ * @wakeup_threshold - controls the capacitance threshold at which the touch
+ * sensor will decide to wake up from that low power state.
+ * @doze_holdoff - controls how long the touch sensor waits after the last
+ * finger lifts before entering the doze state, in units of 100ms.
+ * @doze_interval - controls the interval between checks for finger presence
+ * when the touch sensor is in doze mode, in units of 10ms.
+ */
+struct rmi_f01_power_management {
+	enum rmi_f01_nosleep nosleep;
+	u8 wakeup_threshold;
+	u8 doze_holdoff;
+	u8 doze_interval;
+};
+
+/**
+ * struct rmi_device_platform_data - system specific configuration info.
+ *
+ * @reset_delay_ms - after issuing a reset command to the touch sensor, the
+ * driver waits a few milliseconds to give the firmware a chance to
+ * to re-initialize.  You can override the default wait period here.
+ */
+struct rmi_device_platform_data {
+	int reset_delay_ms;
+
+	/* function handler pdata */
+	struct rmi_f01_power_management power_management;
+};
+
+/**
+ * struct rmi_function_descriptor - RMI function base addresses
+ *
+ * @query_base_addr: The RMI Query base address
+ * @command_base_addr: The RMI Command base address
+ * @control_base_addr: The RMI Control base address
+ * @data_base_addr: The RMI Data base address
+ * @interrupt_source_count: The number of irqs this RMI function needs
+ * @function_number: The RMI function number
+ *
+ * This struct is used when iterating the Page Description Table. The addresses
+ * are 16-bit values to include the current page address.
+ *
+ */
+struct rmi_function_descriptor {
+	u16 query_base_addr;
+	u16 command_base_addr;
+	u16 control_base_addr;
+	u16 data_base_addr;
+	u8 interrupt_source_count;
+	u8 function_number;
+	u8 function_version;
+};
+
+struct rmi_device;
+
+/**
+ * struct rmi_transport_dev - represent an RMI transport device
+ *
+ * @dev: Pointer to the communication device, e.g. i2c or spi
+ * @rmi_dev: Pointer to the RMI device
+ * @proto_name: name of the transport protocol (SPI, i2c, etc)
+ * @ops: pointer to transport operations implementation
+ *
+ * The RMI transport device implements the glue between different communication
+ * buses such as I2C and SPI.
+ *
+ */
+struct rmi_transport_dev {
+	struct device *dev;
+	struct rmi_device *rmi_dev;
+
+	const char *proto_name;
+	const struct rmi_transport_ops *ops;
+
+	struct rmi_device_platform_data pdata;
+
+	struct input_dev *input;
+
+	void *attn_data;
+	int attn_size;
+};
+
+/**
+ * struct rmi_transport_ops - defines transport protocol operations.
+ *
+ * @write_block: Writing a block of data to the specified address
+ * @read_block: Read a block of data from the specified address.
+ */
+struct rmi_transport_ops {
+	int (*write_block)(struct rmi_transport_dev *xport, u16 addr,
+			   const void *buf, size_t len);
+	int (*read_block)(struct rmi_transport_dev *xport, u16 addr,
+			  void *buf, size_t len);
+	int (*reset)(struct rmi_transport_dev *xport, u16 reset_addr);
+};
+
+/**
+ * struct rmi_driver - driver for an RMI4 sensor on the RMI bus.
+ *
+ * @driver: Device driver model driver
+ * @reset_handler: Called when a reset is detected.
+ * @clear_irq_bits: Clear the specified bits in the current interrupt mask.
+ * @set_irq_bist: Set the specified bits in the current interrupt mask.
+ * @store_productid: Callback for cache product id from function 01
+ * @data: Private data pointer
+ *
+ */
+struct rmi_driver {
+	struct device_driver driver;
+
+	int (*reset_handler)(struct rmi_device *rmi_dev);
+	int (*clear_irq_bits)(struct rmi_device *rmi_dev, unsigned long *mask);
+	int (*set_irq_bits)(struct rmi_device *rmi_dev, unsigned long *mask);
+	int (*store_productid)(struct rmi_device *rmi_dev);
+	int (*set_input_params)(struct rmi_device *rmi_dev,
+			struct input_dev *input);
+	void *data;
+};
+
+/**
+ * struct rmi_device - represents an RMI4 sensor device on the RMI bus.
+ *
+ * @dev: The device created for the RMI bus
+ * @number: Unique number for the device on the bus.
+ * @driver: Pointer to associated driver
+ * @xport: Pointer to the transport interface
+ *
+ */
+struct rmi_device {
+	struct device dev;
+	int number;
+
+	struct rmi_driver *driver;
+	struct rmi_transport_dev *xport;
+
+};
+
+struct rmi_driver_data {
+	struct list_head function_list;
+
+	struct rmi_device *rmi_dev;
+
+	struct rmi_function *f01_container;
+	bool f01_bootloader_mode;
+
+	u32 attn_count;
+	int num_of_irq_regs;
+	int irq_count;
+	unsigned long *irq_status;
+	unsigned long *fn_irq_bits;
+	unsigned long *current_irq_mask;
+	unsigned long *new_irq_mask;
+	struct mutex irq_mutex;
+	struct input_dev *input;
+
+	u8 pdt_props;
+	u8 bsr;
+
+	bool enabled;
+
+	void *data;
+};
+
+int rmi_register_transport_device(struct rmi_transport_dev *xport);
+void rmi_unregister_transport_device(struct rmi_transport_dev *xport);
+int rmi_process_interrupt_requests(struct rmi_device *rmi_dev);
+
+int rmi_driver_suspend(struct rmi_device *rmi_dev);
+int rmi_driver_resume(struct rmi_device *rmi_dev);
+#endif
