commit 2f46a2c1d4eb982b82c199e1bd5cddab12681275
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 11 21:53:32 2018 -0400

    tty_ioctl(): start taking TIOC[SG]SERIAL into separate methods
    
    ->set_serial() and ->get_serial() resp., both taking tty and
    a kernel pointer to serial_struct.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 71dbc891851a..358446247ccd 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -249,6 +249,7 @@
 struct tty_struct;
 struct tty_driver;
 struct serial_icounter_struct;
+struct serial_struct;
 
 struct tty_operations {
 	struct tty_struct * (*lookup)(struct tty_driver *driver,
@@ -287,6 +288,8 @@ struct tty_operations {
 	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
 	int (*get_icount)(struct tty_struct *tty,
 				struct serial_icounter_struct *icount);
+	int  (*get_serial)(struct tty_struct *tty, struct serial_struct *p);
+	int  (*set_serial)(struct tty_struct *tty, struct serial_struct *p);
 	void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);

commit 8a8dcabffb991a08fa1fab4e75b80a9075825606
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 21:04:45 2018 +0200

    tty: replace ->proc_fops with ->proc_show
    
    Just set up the show callback in the tty_operations, and use
    proc_create_single_data to create the file without additional
    boilerplace code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 31c2b5b166de..71dbc891851a 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -293,7 +293,7 @@ struct tty_operations {
 	int (*poll_get_char)(struct tty_driver *driver, int line);
 	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
 #endif
-	const struct file_operations *proc_fops;
+	int (*proc_show)(struct seq_file *, void *);
 } __randomize_layout;
 
 struct tty_driver {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index fcdc0f5d9098..31c2b5b166de 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_TTY_DRIVER_H
 #define _LINUX_TTY_DRIVER_H
 

commit d01c3289e7d68162e32bc08c2b65dd1a216a7ef8
Author: Masatake YAMATO <yamato@redhat.com>
Date:   Tue Jul 18 06:27:59 2017 +0900

    pty: show associative slave of ptmx in fdinfo
    
    This patch adds "tty-index" field to /proc/PID/fdinfo/N if N
    specifies /dev/ptmx. The field shows the index of associative
    slave pts.
    
    Though a minor number is given for each pts instance, ptmx is not.
    It means there is no way in user-space to know the association between
    file descriptors for pts/n and ptmx. (n = 0, 1, ...)
    
    This is different from pipe. About pipe such association can be solved
    by inode of pipefs.
    
    Providing the way to know the association between pts/n and ptmx helps
    users understand the status of running system. lsof can utilize this field.
    
    Signed-off-by: Masatake YAMATO <yamato@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 00b2213f6a35..fcdc0f5d9098 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -243,6 +243,7 @@
 #include <linux/list.h>
 #include <linux/cdev.h>
 #include <linux/termios.h>
+#include <linux/seq_file.h>
 
 struct tty_struct;
 struct tty_driver;
@@ -285,6 +286,7 @@ struct tty_operations {
 	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
 	int (*get_icount)(struct tty_struct *tty,
 				struct serial_icounter_struct *icount);
+	void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);
 	int (*poll_get_char)(struct tty_driver *driver, int line);

commit 3859a271a003aba01e45b85c9d8b355eb7bf25f9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 28 01:22:25 2016 -0700

    randstruct: Mark various structs for randomization
    
    This marks many critical kernel structures for randomization. These are
    structures that have been targeted in the past in security exploits, or
    contain functions pointers, pointers to function pointer tables, lists,
    workqueues, ref-counters, credentials, permissions, or are otherwise
    sensitive. This initial list was extracted from Brad Spengler/PaX Team's
    code in the last public patch of grsecurity/PaX based on my understanding
    of the code. Changes or omissions from the original code are mine and
    don't reflect the original grsecurity/PaX code.
    
    Left out of this list is task_struct, which requires special handling
    and will be covered in a subsequent patch.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index b742b5e47cc2..00b2213f6a35 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -291,7 +291,7 @@ struct tty_operations {
 	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
 #endif
 	const struct file_operations *proc_fops;
-};
+} __randomize_layout;
 
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
@@ -325,7 +325,7 @@ struct tty_driver {
 
 	const struct tty_operations *ops;
 	struct list_head tty_drivers;
-};
+} __randomize_layout;
 
 extern struct list_head tty_drivers;
 

commit 8ead9dd54716d1e05e129959f702fcc1786f82b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 25 20:04:08 2016 -0700

    devpts: more pty driver interface cleanups
    
    This is more prep-work for the upcoming pty changes.  Still just code
    cleanup with no actual semantic changes.
    
    This removes a bunch pointless complexity by just having the slave pty
    side remember the dentry associated with the devpts slave rather than
    the inode.  That allows us to remove all the "look up the dentry" code
    for when we want to remove it again.
    
    Together with moving the tty pointer from "inode->i_private" to
    "dentry->d_fsdata" and getting rid of pointless inode locking, this
    removes about 30 lines of code.  Not only is the end result smaller,
    it's simpler and easier to understand.
    
    The old code, for example, depended on the d_find_alias() to not just
    find the dentry, but also to check that it is still hashed, which in
    turn validated the tty pointer in the inode.
    
    That is a _very_ roundabout way to say "invalidate the cached tty
    pointer when the dentry is removed".
    
    The new code just does
    
            dentry->d_fsdata = NULL;
    
    in devpts_pty_kill() instead, invalidating the tty pointer rather more
    directly and obviously.  Don't do something complex and subtle when the
    obvious straightforward approach will do.
    
    The rest of the patch (ie apart from code deletion and the above tty
    pointer clearing) is just switching the calling convention to pass the
    dentry or file pointer around instead of the inode.
    
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Florian Weimer <fw@deneb.enyo.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 161052477f77..b742b5e47cc2 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -7,7 +7,7 @@
  * defined; unless noted otherwise, they are optional, and can be
  * filled in with a null pointer.
  *
- * struct tty_struct * (*lookup)(struct tty_driver *self, int idx)
+ * struct tty_struct * (*lookup)(struct tty_driver *self, struct file *, int idx)
  *
  *	Return the tty device corresponding to idx, NULL if there is not
  *	one currently in use and an ERR_PTR value on error. Called under
@@ -250,7 +250,7 @@ struct serial_icounter_struct;
 
 struct tty_operations {
 	struct tty_struct * (*lookup)(struct tty_driver *driver,
-			struct inode *inode, int idx);
+			struct file *filp, int idx);
 	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
 	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
 	int  (*open)(struct tty_struct * tty, struct file * filp);

commit a3a10ce3429e5dee623ad5c8407ea58e204fcb0a
Author: Richard Watts <rrw@kynesim.co.uk>
Date:   Tue May 19 16:06:53 2015 +0100

    Avoid usb reset crashes by making tty_io cdevs truly dynamic
    
    Avoid usb reset crashes by making tty_io cdevs truly dynamic
    
    Signed-off-by: Richard Watts <rrw@kynesim.co.uk>
    Reported-by: Duncan Mackintosh <DMackintosh@cbnl.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 92e337c18839..161052477f77 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -296,7 +296,7 @@ struct tty_operations {
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
 	struct kref kref;	/* Reference management */
-	struct cdev *cdevs;
+	struct cdev **cdevs;
 	struct module	*owner;
 	const char	*driver_name;
 	const char	*name;

commit f9e053dcfc02b0ad29daec8524fb1afe09774976
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Sep 10 15:06:31 2014 -0400

    tty: Serialize tty flow control changes with flow_lock
    
    Without serialization, the flow control state can become inverted
    wrt. the actual hardware state. For example,
    
    CPU 0                          | CPU 1
    stop_tty()                     |
      lock ctrl_lock               |
      tty->stopped = 1             |
      unlock ctrl_lock             |
                                   | start_tty()
                                   |   lock ctrl_lock
                                   |   tty->stopped = 0
                                   |   unlock ctrl_lock
                                   |   driver->start()
      driver->stop()               |
    
    In this case, the flow control state now indicates the tty has
    been started, but the actual hardware state has actually been stopped.
    
    Introduce tty->flow_lock spinlock to serialize tty flow control changes.
    Split out unlocked __start_tty()/__stop_tty() flavors for use by
    ioctl(TCXONC) in follow-on patch.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index e48c608a8fa8..92e337c18839 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -152,6 +152,8 @@
  * 	This routine notifies the tty driver that it should stop
  * 	outputting characters to the tty device.  
  *
+ *	Called with ->flow_lock held. Serialized with start() method.
+ *
  *	Optional:
  *
  *	Note: Call stop_tty not this method.
@@ -161,6 +163,8 @@
  * 	This routine notifies the tty driver that it resume sending
  *	characters to the tty device.
  *
+ *	Called with ->flow_lock held. Serialized with stop() method.
+ *
  *	Optional:
  *
  *	Note: Call start_tty not this method.

commit ed617e44234ee03a60edbf0809f696f0b9cf1b90
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Jun 16 09:16:58 2014 -0400

    tty: Document locking for tty driver methods
    
    The tty core calls the tty driver's open, close and hangup
    methods holding the tty lock.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 756a60989294..e48c608a8fa8 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -35,14 +35,14 @@
  * 	This routine is mandatory; if this routine is not filled in,
  * 	the attempted open will fail with ENODEV.
  *
- *	Required method.
- *     
+ *	Required method. Called with tty lock held.
+ *
  * void (*close)(struct tty_struct * tty, struct file * filp);
  *
  * 	This routine is called when a particular tty device is closed.
  *	Note: called even if the corresponding open() failed.
  *
- *	Required method.
+ *	Required method. Called with tty lock held.
  *
  * void (*shutdown)(struct tty_struct * tty);
  *
@@ -172,6 +172,8 @@
  *
  *	Optional:
  *
+ *	Called with tty lock held.
+ *
  * int (*break_ctl)(struct tty_struct *tty, int state);
  *
  * 	This optional routine requests the tty driver to turn on or

commit 7be88b4ccb62737abe4bf27f9e66e224a70a12c4
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Jan 30 12:43:51 2013 -0500

    tty: Document required behavior of tty driver close()
    
    If the tty driver open() fails, the tty driver close() is still
    called during the resultant tty release.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index dd976cfb6131..756a60989294 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -40,6 +40,7 @@
  * void (*close)(struct tty_struct * tty, struct file * filp);
  *
  * 	This routine is called when a particular tty device is closed.
+ *	Note: called even if the corresponding open() failed.
  *
  *	Required method.
  *

commit 7e73eca6a7b2967423902a4543821bb97cbbe698
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 8 22:26:44 2012 +0200

    TTY: move cdev_add to tty_register_device
    
    We need the /dev/ node not to be available before we call
    tty_register_device. Otherwise we might race with open and
    tty_struct->port might not be available at that time.
    
    This is not an issue now, but would be a problem after "TTY: use
    tty_port_register_device" is applied.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 44e05b75d573..dd976cfb6131 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -289,7 +289,7 @@ struct tty_operations {
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
 	struct kref kref;	/* Reference management */
-	struct cdev cdev;
+	struct cdev *cdevs;
 	struct module	*owner;
 	const char	*driver_name;
 	const char	*name;

commit 0019b4089ccef8148d8be83cc8adfc81a75b47d4
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 8 22:26:43 2012 +0200

    TTY: add support for unnumbered device nodes
    
    This allows drivers like ttyprintk to avoid hacks to create an
    unnumbered node in /dev. It used to set TTY_DRIVER_DYNAMIC_DEV in
    flags and call device_create on its own. That is incorrect, because
    TTY_DRIVER_DYNAMIC_DEV may be set only if tty_register_device is
    called explicitly.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 1a85f003d646..44e05b75d573 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -394,6 +394,11 @@ static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
  * TTY_DRIVER_DYNAMIC_ALLOC -- do not allocate structures which are
  *	needed per line for this driver as it would waste memory.
  *	The driver will take care.
+ *
+ * TTY_DRIVER_UNNUMBERED_NODE -- do not create numbered /dev nodes. In
+ *	other words create /dev/ttyprintk and not /dev/ttyprintk0.
+ *	Applicable only when a driver for a single tty device is
+ *	being allocated.
  */
 #define TTY_DRIVER_INSTALLED		0x0001
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
@@ -402,6 +407,7 @@ static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
 #define TTY_DRIVER_DEVPTS_MEM		0x0010
 #define TTY_DRIVER_HARDWARE_BREAK	0x0020
 #define TTY_DRIVER_DYNAMIC_ALLOC	0x0040
+#define TTY_DRIVER_UNNUMBERED_NODE	0x0080
 
 /* tty driver types */
 #define TTY_DRIVER_TYPE_SYSTEM		0x0001

commit 21aca2fa00259f781d228496631b61dbb4274e90
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 8 22:26:41 2012 +0200

    TTY: pty, switch to tty_alloc_driver
    
    Switch to the new driver allocation interface, as this is one of the
    special call-sites. Here, we need TTY_DRIVER_DYNAMIC_ALLOC to not
    allocate tty_driver->ports, cdevs and potentially other structures
    because we reserve too many lines in pty. Instead, it provides the
    tty_port<->tty_struct link in tty->ops->install already.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 3adc362f0bd2..1a85f003d646 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -391,6 +391,9 @@ static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
  *	the requested timeout to the caller instead of using a simple
  *	on/off interface.
  *
+ * TTY_DRIVER_DYNAMIC_ALLOC -- do not allocate structures which are
+ *	needed per line for this driver as it would waste memory.
+ *	The driver will take care.
  */
 #define TTY_DRIVER_INSTALLED		0x0001
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
@@ -398,6 +401,7 @@ static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
 #define TTY_DRIVER_DYNAMIC_DEV		0x0008
 #define TTY_DRIVER_DEVPTS_MEM		0x0010
 #define TTY_DRIVER_HARDWARE_BREAK	0x0020
+#define TTY_DRIVER_DYNAMIC_ALLOC	0x0040
 
 /* tty driver types */
 #define TTY_DRIVER_TYPE_SYSTEM		0x0001

commit 7f0bc6a68ed93f3b4ad77b94df5ef32446c583e3
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Tue Aug 7 21:47:42 2012 +0200

    TTY: pass flags to alloc_tty_driver
    
    We need to allow drivers that use neither tty_port_install nor
    tty_port_register_device to link a tty_port to a tty somehow.  To
    avoid a race with open, this has to be performed before
    tty_register_device. But currently tty_driver->ports is allocated even
    in tty_register_device because we do not know whether this is the PTY
    driver. The PTY driver is special here due to an excessive count of
    lines it declares to handle. We cannot handle tty_ports there this
    way.
    
    To circumvent this, we start passing tty_driver flags to
    alloc_tty_driver already and we create tty_alloc_driver for this
    purpose. There we can allocate tty_driver->ports and do all the magic
    between tty_alloc_driver and tty_register_device. Later we will
    introduce tty_port_link_device function for that purpose.
    
    All drivers should eventually switch to this new tty driver allocation
    interface.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 80e72dc564a5..3adc362f0bd2 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -296,11 +296,11 @@ struct tty_driver {
 	int	name_base;	/* offset of printed name */
 	int	major;		/* major device number */
 	int	minor_start;	/* start of minor device number */
-	int	num;		/* number of devices allocated */
+	unsigned int	num;	/* number of devices allocated */
 	short	type;		/* type of tty driver */
 	short	subtype;	/* subtype of tty driver */
 	struct ktermios init_termios; /* Initial termios */
-	int	flags;		/* tty driver flags */
+	unsigned long	flags;		/* tty driver flags */
 	struct proc_dir_entry *proc_entry; /* /proc fs entry */
 	struct tty_driver *other; /* only used for the PTY driver */
 
@@ -322,7 +322,8 @@ struct tty_driver {
 
 extern struct list_head tty_drivers;
 
-extern struct tty_driver *__alloc_tty_driver(int lines, struct module *owner);
+extern struct tty_driver *__tty_alloc_driver(unsigned int lines,
+		struct module *owner, unsigned long flags);
 extern void put_tty_driver(struct tty_driver *driver);
 extern void tty_set_operations(struct tty_driver *driver,
 			const struct tty_operations *op);
@@ -330,7 +331,21 @@ extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
 
 extern void tty_driver_kref_put(struct tty_driver *driver);
 
-#define alloc_tty_driver(lines) __alloc_tty_driver(lines, THIS_MODULE)
+/* Use TTY_DRIVER_* flags below */
+#define tty_alloc_driver(lines, flags) \
+		__tty_alloc_driver(lines, THIS_MODULE, flags)
+
+/*
+ * DEPRECATED Do not use this in new code, use tty_alloc_driver instead.
+ * (And change the return value checks.)
+ */
+static inline struct tty_driver *alloc_tty_driver(unsigned int lines)
+{
+	struct tty_driver *ret = tty_alloc_driver(lines, 0);
+	if (IS_ERR(ret))
+		return NULL;
+	return ret;
+}
 
 static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
 {

commit 36b3c070d2346c890d690d71f6eab02f8c511137
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Jul 17 17:06:57 2012 +0100

    tty: Move the handling of the tty release logic
    
    Now that we don't have tty->termios tied to drivers->tty we can untangle
    the logic here. In addition we can push the removal logic out of the
    destructor path.
    
    At that point we can think about sorting out tty_port and console and all
    the other ugly hangovers.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 04419c141b00..80e72dc564a5 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -45,14 +45,9 @@
  *
  * void (*shutdown)(struct tty_struct * tty);
  *
- * 	This routine is called synchronously when a particular tty device
- *	is closed for the last time freeing up the resources.
- *	Note that tty_shutdown() is not called if ops->shutdown is defined.
- *	This means one is responsible to take care of calling ops->remove (e.g.
- *	via tty_driver_remove_tty) and releasing tty->termios.
- *	Note that this hook may be called from *all* the contexts where one
- *	uses tty refcounting (e.g. tty_port_tty_get).
- *
+ * 	This routine is called under the tty lock when a particular tty device
+ *	is closed for the last time. It executes before the tty resources
+ *	are freed so may execute while another function holds a tty kref.
  *
  * void (*cleanup)(struct tty_struct * tty);
  *

commit 04831dc154df9b83c3e5fd54b18448da507871f7
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Jun 4 13:35:36 2012 +0200

    TTY: add ports array to tty_driver
    
    It will hold tty_port structures for all drivers which do not want to
    define tty->ops->install hook.
    
    We ignore PTY here because it wants 1 million lines and it installs
    tty_port in ->install anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 6e6dbb7447b6..04419c141b00 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -313,6 +313,7 @@ struct tty_driver {
 	 * Pointer to the tty data structures
 	 */
 	struct tty_struct **ttys;
+	struct tty_port **ports;
 	struct ktermios **termios;
 	void *driver_state;
 

commit 26b23209c0ea5503824df60b8f218fb04b80cad0
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Mar 5 14:51:56 2012 +0100

    TTY: tty_driver, document tty->ops->shutdown limitation
    
    Note that tty->ops->shutdown is called from whatever context the user
    drops the last tty reference from. E.g. if one takes a reference in
    an ISR, tty close happens on other CPU and the final tty put is from
    the ISR, tty->ops->shutdown will be called from that hard irq context.
    
    We would have a problem in vt if we start using tty refcounting from
    other contexts than user there. It is because vt's shutdown uses
    mutexes. This is yet to be fixed.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reported-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index e064f1704e20..6e6dbb7447b6 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -50,6 +50,8 @@
  *	Note that tty_shutdown() is not called if ops->shutdown is defined.
  *	This means one is responsible to take care of calling ops->remove (e.g.
  *	via tty_driver_remove_tty) and releasing tty->termios.
+ *	Note that this hook may be called from *all* the contexts where one
+ *	uses tty refcounting (e.g. tty_port_tty_get).
  *
  *
  * void (*cleanup)(struct tty_struct * tty);

commit 87cab16beb882d3f9e61a2c0184fa7cf76de1f90
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Mar 5 14:51:51 2012 +0100

    TTY: remove minor_num from tty_driver
    
    It was added back in 2004 and never used for anything real. Remove the
    only assignment in the tree as well.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 6e65493a5e6c..e064f1704e20 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -299,7 +299,6 @@ struct tty_driver {
 	int	name_base;	/* offset of printed name */
 	int	major;		/* major device number */
 	int	minor_start;	/* start of minor device number */
-	int	minor_num;	/* number of *possible* devices */
 	int	num;		/* number of devices allocated */
 	short	type;		/* type of tty driver */
 	short	subtype;	/* subtype of tty driver */

commit 1a54a76d5171f3ffd89eb69f6f38d535724e3d05
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Mar 5 14:51:50 2012 +0100

    TTY: let alloc_tty_driver deduce the owner automatically
    
    Like the rest of the kernel, make a stub from alloc_tty_driver which
    calls __alloc_tty_driver with proper owner. This will save us one more
    assignment on the driver side.
    
    Also this fixes some drivers which didn't set the owner. This allowed
    user to remove the module from the system even though a tty from the
    driver is still open.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 5cf685086dd3..6e65493a5e6c 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -234,6 +234,7 @@
  *	if provided (otherwise EINVAL will be returned).
  */
 
+#include <linux/export.h>
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/cdev.h>
@@ -324,7 +325,7 @@ struct tty_driver {
 
 extern struct list_head tty_drivers;
 
-extern struct tty_driver *alloc_tty_driver(int lines);
+extern struct tty_driver *__alloc_tty_driver(int lines, struct module *owner);
 extern void put_tty_driver(struct tty_driver *driver);
 extern void tty_set_operations(struct tty_driver *driver,
 			const struct tty_operations *op);
@@ -332,6 +333,8 @@ extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
 
 extern void tty_driver_kref_put(struct tty_driver *driver);
 
+#define alloc_tty_driver(lines) __alloc_tty_driver(lines, THIS_MODULE)
+
 static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
 {
 	kref_get(&d->kref);

commit 20c300b10c358daa507be335aec6aa3987ef425a
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Tue Jan 17 12:54:01 2012 +0400

    tty: remove unused tty_driver->termios_locked
    
    This field is unused since 2.6.28 (commit fe6e29fdb1a7: "tty: simplify
    ktermios allocation", to be exact)
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index ecdaeb98b293..5cf685086dd3 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -312,7 +312,6 @@ struct tty_driver {
 	 */
 	struct tty_struct **ttys;
 	struct ktermios **termios;
-	struct ktermios **termios_locked;
 	void *driver_state;
 
 	/*

commit 24d406a6bf736f7aebdc8fa0f0ec86e0890c6d24
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Aug 10 14:59:28 2011 +0200

    TTY: pty, fix pty counting
    
    tty_operations->remove is normally called like:
    queue_release_one_tty
     ->tty_shutdown
       ->tty_driver_remove_tty
         ->tty_operations->remove
    
    However tty_shutdown() is called from queue_release_one_tty() only if
    tty_operations->shutdown is NULL. But for pty, it is not.
    pty_unix98_shutdown() is used there as ->shutdown.
    
    So tty_operations->remove of pty (i.e. pty_unix98_remove()) is never
    called. This results in invalid pty_count. I.e. what can be seen in
    /proc/sys/kernel/pty/nr.
    
    I see this was already reported at:
      https://lkml.org/lkml/2009/11/5/370
    But it was not fixed since then.
    
    This patch is kind of a hackish way. The problem lies in ->install. We
    allocate there another tty (so-called tty->link). So ->install is
    called once, but ->remove twice, for both tty and tty->link. The fix
    here is to count both tty and tty->link and divide the count by 2 for
    user.
    
    And to have ->remove called, let's make tty_driver_remove_tty() global
    and call that from pty_unix98_shutdown() (tty_operations->shutdown).
    
    While at it, let's document that when ->shutdown is defined,
    tty_shutdown() is not called.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 9deeac855240..ecdaeb98b293 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -47,6 +47,9 @@
  *
  * 	This routine is called synchronously when a particular tty device
  *	is closed for the last time freeing up the resources.
+ *	Note that tty_shutdown() is not called if ops->shutdown is defined.
+ *	This means one is responsible to take care of calling ops->remove (e.g.
+ *	via tty_driver_remove_tty) and releasing tty->termios.
  *
  *
  * void (*cleanup)(struct tty_struct * tty);

commit 6caa76b7786891b42b66a0e61e2c2fff2c884620
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:27:22 2011 +0000

    tty: now phase out the ioctl file pointer for good
    
    Only oddities here are a couple of drivers that bogusly called the ldisc
    helpers instead of returning -ENOIOCTLCMD. Fix the bug and the rest goes
    away.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 5dabaa2e6da3..9deeac855240 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -98,8 +98,7 @@
  *
  *	Note: Do not call this function directly, call tty_write_room
  * 
- * int  (*ioctl)(struct tty_struct *tty, struct file * file,
- * 	    unsigned int cmd, unsigned long arg);
+ * int  (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
  *
  * 	This routine allows the tty driver to implement
  *	device-specific ioctls.  If the ioctl number passed in cmd
@@ -107,7 +106,7 @@
  *
  *	Optional
  *
- * long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
+ * long (*compat_ioctl)(struct tty_struct *tty,,
  * 	                unsigned int cmd, unsigned long arg);
  *
  * 	implement ioctl processing for 32 bit process on 64 bit system
@@ -256,9 +255,9 @@ struct tty_operations {
 	void (*flush_chars)(struct tty_struct *tty);
 	int  (*write_room)(struct tty_struct *tty);
 	int  (*chars_in_buffer)(struct tty_struct *tty);
-	int  (*ioctl)(struct tty_struct *tty, struct file * file,
+	int  (*ioctl)(struct tty_struct *tty,
 		    unsigned int cmd, unsigned long arg);
-	long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
+	long (*compat_ioctl)(struct tty_struct *tty,
 			     unsigned int cmd, unsigned long arg);
 	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
 	void (*throttle)(struct tty_struct * tty);

commit 20b9d17715017ae4dd4ec87fabc36d33b9de708e
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:50 2011 +0000

    tiocmset: kill the file pointer argument
    
    Doing tiocmget was such fun we should do tiocmset as well for the same
    reasons
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 9539d74171db..5dabaa2e6da3 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -272,7 +272,7 @@ struct tty_operations {
 	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
 	void (*send_xchar)(struct tty_struct *tty, char ch);
 	int (*tiocmget)(struct tty_struct *tty);
-	int (*tiocmset)(struct tty_struct *tty, struct file *file,
+	int (*tiocmset)(struct tty_struct *tty,
 			unsigned int set, unsigned int clear);
 	int (*resize)(struct tty_struct *tty, struct winsize *ws);
 	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);

commit 60b33c133ca0b7c0b6072c87234b63fee6e80558
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:14 2011 +0000

    tiocmget: kill off the passing of the struct file
    
    We don't actually need this and it causes problems for internal use of
    this functionality. Currently there is a single use of the FILE * pointer.
    That is the serial core which uses it to check tty_hung_up_p. However if
    that is true then IO_ERROR is also already set so the check may be removed.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index c3d43eb4150c..9539d74171db 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -271,7 +271,7 @@ struct tty_operations {
 	void (*set_ldisc)(struct tty_struct *tty);
 	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
 	void (*send_xchar)(struct tty_struct *tty, char ch);
-	int (*tiocmget)(struct tty_struct *tty, struct file *file);
+	int (*tiocmget)(struct tty_struct *tty);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
 	int (*resize)(struct tty_struct *tty, struct winsize *ws);

commit 6ce5b1ce5f6922db32599e73bcb22f5cdcbf241f
Author: Timur Tabi <timur@freescale.com>
Date:   Mon Dec 13 14:08:53 2010 -0600

    tty: fix typos/errors in tty_driver.h comments
    
    Fix various typos and other errors in comments of tty_driver.h.  The most
    significant is the wrong name of a function for the description of
    TTY_DRIVER_DYNAMIC_DEV.
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 09678ed370f8..c3d43eb4150c 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -102,7 +102,7 @@
  * 	    unsigned int cmd, unsigned long arg);
  *
  * 	This routine allows the tty driver to implement
- *	device-specific ioctl's.  If the ioctl number passed in cmd
+ *	device-specific ioctls.  If the ioctl number passed in cmd
  * 	is not recognized by the driver, it should return ENOIOCTLCMD.
  *
  *	Optional
@@ -167,12 +167,12 @@
  * 
  * void (*hangup)(struct tty_struct *tty);
  *
- * 	This routine notifies the tty driver that it should hangup the
+ * 	This routine notifies the tty driver that it should hang up the
  * 	tty device.
  *
  *	Optional:
  *
- * int (*break_ctl)(struct tty_stuct *tty, int state);
+ * int (*break_ctl)(struct tty_struct *tty, int state);
  *
  * 	This optional routine requests the tty driver to turn on or
  * 	off BREAK status on the RS-232 port.  If state is -1,
@@ -358,7 +358,7 @@ static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
  * 	overruns, either.)
  *
  * TTY_DRIVER_DYNAMIC_DEV --- if set, the individual tty devices need
- *	to be registered with a call to tty_register_driver() when the
+ *	to be registered with a call to tty_register_device() when the
  *	device is found in the system and unregistered with a call to
  *	tty_unregister_device() so the devices will be show up
  *	properly in sysfs.  If not set, driver->num entries will be

commit 3dfbd044d0d99cad2fe50e4f6c79845703fa0558
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Nov 4 16:20:23 2010 +0100

    TTY: include termios.h in tty_driver.h
    
    We reference termios and termiox in tty_driver.h, but we do not include
    linux/termios.h where these are defined. Add the #include properly.
    
    Otherwise when we include tty_driver.h, we get compile errors.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Greg KH <gregkh@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index db2d227694da..09678ed370f8 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -235,6 +235,7 @@
 #include <linux/fs.h>
 #include <linux/list.h>
 #include <linux/cdev.h>
+#include <linux/termios.h>
 
 struct tty_struct;
 struct tty_driver;

commit d281da7ff6f70efca0553c288bb883e8605b3862
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Sep 16 18:21:24 2010 +0100

    tty: Make tiocgicount a handler
    
    Dan Rosenberg noted that various drivers return the struct with uncleared
    fields. Instead of spending forever trying to stomp all the drivers that
    get it wrong (and every new driver) do the job in one place.
    
    This first patch adds the needed operations and hooks them up, including
    the needed USB midlayer and serial core plumbing.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index b08677982525..db2d227694da 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -224,6 +224,12 @@
  *	unless the tty also has a valid tty->termiox pointer.
  *
  *	Optional: Called under the termios lock
+ *
+ * int (*get_icount)(struct tty_struct *tty, struct serial_icounter *icount);
+ *
+ *	Called when the device receives a TIOCGICOUNT ioctl. Passed a kernel
+ *	structure to complete. This method is optional and will only be called
+ *	if provided (otherwise EINVAL will be returned).
  */
 
 #include <linux/fs.h>
@@ -232,6 +238,7 @@
 
 struct tty_struct;
 struct tty_driver;
+struct serial_icounter_struct;
 
 struct tty_operations {
 	struct tty_struct * (*lookup)(struct tty_driver *driver,
@@ -268,6 +275,8 @@ struct tty_operations {
 			unsigned int set, unsigned int clear);
 	int (*resize)(struct tty_struct *tty, struct winsize *ws);
 	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
+	int (*get_icount)(struct tty_struct *tty,
+				struct serial_icounter_struct *icount);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);
 	int (*poll_get_char)(struct tty_driver *driver, int line);

commit f278a2f7bbc2239f479eaf63d0b3ae573b1d746c
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Sun Sep 27 16:00:42 2009 +0000

    tty: Fix regressions caused by commit b50989dc
    
    The following commit made console open fails while booting:
    
            commit b50989dc444599c8b21edc23536fc305f4e9b7d5
            Author: Alan Cox <alan@linux.intel.com>
            Date:   Sat Sep 19 13:13:22 2009 -0700
    
            tty: make the kref destructor occur asynchronously
    
    Due to tty release routines run in a workqueue now, error like the
    following will be reported while booting:
    
    INIT open /dev/console Input/output error
    
    It also causes hibernation regression to appear as reported at
    http://bugzilla.kernel.org/show_bug.cgi?id=14229
    
    The reason is that now there's latency issue with closing, but when
    we open a "closing not finished" tty, -EIO will be returned.
    
    Fix it as per the following Alan's suggestion:
    
      Fun but it's actually not a bug and the fix is wrong in itself as
      the port may be closing but not yet being destructed, in which case
      it seems to do the wrong thing.  Opening a tty that is closing (and
      could be closing for long periods) is supposed to return -EIO.
    
      I suspect a better way to deal with this and keep the old console
      timing is to split tty->shutdown into two functions.
    
      tty->shutdown() - called synchronously just before we dump the tty
      onto the waitqueue for destruction
    
      tty->cleanup() - called when the destructor runs.
    
      We would then do the shutdown part which can occur in IRQ context
      fine, before queueing the rest of the release (from tty->magic = 0
      ...  the end) to occur asynchronously
    
      The USB update in -next would then need a call like
    
           if (tty->cleanup)
                   tty->cleanup(tty);
    
      at the top of the async function and the USB shutdown to be split
      between shutdown and cleanup as the USB resource cleanup and final
      tidy cannot occur synchronously as it needs to sleep.
    
      In other words the logic becomes
    
           final kref put
                   make object unfindable
    
           async
                   clean it up
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    [ rjw: Rebased on top of 2.6.31-git, reworked the changelog. ]
    Signed-off-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    [ Changed serial naming to match new rules, dropped tty_shutdown as per
      comments from Alan Stern  - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 3566129384a4..b08677982525 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -45,8 +45,16 @@
  *
  * void (*shutdown)(struct tty_struct * tty);
  *
- * 	This routine is called when a particular tty device is closed for
- *	the last time freeing up the resources.
+ * 	This routine is called synchronously when a particular tty device
+ *	is closed for the last time freeing up the resources.
+ *
+ *
+ * void (*cleanup)(struct tty_struct * tty);
+ *
+ *	This routine is called asynchronously when a particular tty device
+ *	is closed for the last time freeing up the resources. This is
+ *	actually the second part of shutdown for routines that might sleep.
+ *
  *
  * int (*write)(struct tty_struct * tty,
  * 		 const unsigned char *buf, int count);
@@ -233,6 +241,7 @@ struct tty_operations {
 	int  (*open)(struct tty_struct * tty, struct file * filp);
 	void (*close)(struct tty_struct * tty, struct file * filp);
 	void (*shutdown)(struct tty_struct *tty);
+	void (*cleanup)(struct tty_struct *tty);
 	int  (*write)(struct tty_struct * tty,
 		      const unsigned char *buf, int count);
 	int  (*put_char)(struct tty_struct *tty, unsigned char ch);

commit 38db89799bdf11625a831c5af33938dcb11908b6
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Jun 11 12:44:17 2009 +0100

    tty: throttling race fix
    
    The tty throttling code can race due to the lock drops. It takes very high
    loads but this has been observed and verified by Rob Duncan.
    
    The basic problem is that on an SMP box we can go
    
            CPU #1                          CPU #2
            need to throttle ?
            suppose we should               buffer space cleared
                                            are we throttled
                                            yes ? - unthrottle
            call throttle method
    
    This changeet take the termios lock to protect against this. The termios
    lock isn't the initial obvious candidate but many implementations of throttle
    methods already need to poke around their own termios structures (and nobody
    really locks them against a racing change of flow control).
    
    This does mean that anyone who is setting tty->low_latency = 1 and then
    calling tty_flip_buffer_push from their unthrottle method is going to end up
    collapsing in a pile of locks. However we've removed all the known bogus
    users of low_latency = 1 and such use isn't safe anyway for other reasons so
    catching it would be an improvement.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index bcba84ea2d86..3566129384a4 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -127,7 +127,8 @@
  * 	the line discipline are close to full, and it should somehow
  * 	signal that no more characters should be sent to the tty.
  *
- *	Optional: Always invoke via tty_throttle();
+ *	Optional: Always invoke via tty_throttle(), called under the
+ *	termios lock.
  * 
  * void (*unthrottle)(struct tty_struct * tty);
  *
@@ -135,7 +136,8 @@
  * 	that characters can now be sent to the tty without fear of
  * 	overrunning the input buffers of the line disciplines.
  * 
- *	Optional: Always invoke via tty_unthrottle();
+ *	Optional: Always invoke via tty_unthrottle(), called under the
+ *	termios lock.
  *
  * void (*stop)(struct tty_struct *tty);
  *

commit f786ddd285b4100909a013041d3eee1be9fac4db
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 7 16:48:07 2009 +0100

    tty: Correct inline types for tty_driver_kref_get()
    
    tty_driver_kref_get() should be static inline and not extern inline
    (the latter even changed it's semantics in gcc >= 4.3).
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 8615d661ab60..bcba84ea2d86 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -309,7 +309,8 @@ extern void tty_set_operations(struct tty_driver *driver,
 extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
 
 extern void tty_driver_kref_put(struct tty_driver *driver);
-extern inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
+
+static inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
 {
 	kref_get(&d->kref);
 	return d;

commit 0f043a81ebe84be3576667f04fdda481609e3816
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 31 15:19:25 2009 -0700

    proc tty: remove struct tty_operations::read_proc
    
    struct tty_operations::proc_fops took it's place and there is one less
    create_proc_read_entry() user now!
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index c9a69575ded6..8615d661ab60 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -252,8 +252,6 @@ struct tty_operations {
 	void (*set_ldisc)(struct tty_struct *tty);
 	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
 	void (*send_xchar)(struct tty_struct *tty, char ch);
-	int (*read_proc)(char *page, char **start, off_t off,
-			  int count, int *eof, void *data);
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);

commit ae149b6bec64a09373ba20fce75f8aa6b14b78fd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Mar 31 15:19:15 2009 -0700

    proc tty: add struct tty_operations::proc_fops
    
    Used for gradual switch of TTY drivers from using ->read_proc which helps
    with gradual switch from ->read_proc for the whole tree.
    
    As side effect, fix possible race condition when ->data initialized after
    PDE is hooked into proc tree.
    
    ->proc_fops takes precedence over ->read_proc.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 08e088334dba..c9a69575ded6 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -264,6 +264,7 @@ struct tty_operations {
 	int (*poll_get_char)(struct tty_driver *driver, int line);
 	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
 #endif
+	const struct file_operations *proc_fops;
 };
 
 struct tty_driver {

commit fc6f6238226e6d1248e1967eae2bf556eaf3ac17
Author: Alan Cox <alan@redhat.com>
Date:   Fri Jan 2 13:43:17 2009 +0000

    pty: simplify resize
    
    We have special case logic for resizing pty/tty pairs. We also have a per
    driver resize method so for the pty case we should use it.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 78416b901589..08e088334dba 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -196,8 +196,7 @@
  *	Optional: If not provided then the write method is called under
  *	the atomic write lock to keep it serialized with the ldisc.
  *
- * int (*resize)(struct tty_struct *tty, struct tty_struct *real_tty,
- *				unsigned int rows, unsigned int cols);
+ * int (*resize)(struct tty_struct *tty, struct winsize *ws)
  *
  *	Called when a termios request is issued which changes the
  *	requested terminal geometry.
@@ -258,8 +257,7 @@ struct tty_operations {
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
-	int (*resize)(struct tty_struct *tty, struct tty_struct *real_tty,
-				struct winsize *ws);
+	int (*resize)(struct tty_struct *tty, struct winsize *ws);
 	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);

commit 15f1a6338ddd4e69fff965d4b3a0e1bfb7a13d9c
Author: Sukadev Bhattiprolu <sukadev@us.ibm.com>
Date:   Mon Oct 13 10:42:59 2008 +0100

    Add an instance parameter devpts interfaces
    
    Pass-in 'inode' or 'tty' parameter to devpts interfaces.  With multiple
    devpts instances, these parameters will be used in subsequent patches
    to identify the instance of devpts mounted. The parameters also help
    simplify devpts implementation.
    
    Changelog[v3]:
            - minor changes due to merge with ttydev updates
            - rename parameters to emphasize they are ptmx or pts inodes
            - pass-in tty_struct * to devpts_pty_kill() (this will help
              cleanup the get_node() call in a subsequent patch)
    
    Signed-off-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 005d06ad46a6..78416b901589 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -225,7 +225,8 @@ struct tty_struct;
 struct tty_driver;
 
 struct tty_operations {
-	struct tty_struct * (*lookup)(struct tty_driver *driver, int idx);
+	struct tty_struct * (*lookup)(struct tty_driver *driver,
+			struct inode *inode, int idx);
 	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
 	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
 	int  (*open)(struct tty_struct * tty, struct file * filp);

commit 8b0a88d5912ab549d5adac2c8498ecdaae5319a5
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:42:19 2008 +0100

    tty: More driver operations
    
    We have the lookup operation abstracted which is nice for pty cleanup but
    we really want to abstract the add/remove entries as well so that we can
    pull the pty code out of the tty core and create a clear defined interface
    for the tty driver table.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index ba891dd23550..005d06ad46a6 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -15,6 +15,20 @@
  *
  *	Optional method. Default behaviour is to use the ttys array
  *
+ * int (*install)(struct tty_driver *self, struct tty_struct *tty)
+ *
+ *	Install a new tty into the tty driver internal tables. Used in
+ *	conjunction with lookup and remove methods.
+ *
+ *	Optional method. Default behaviour is to use the ttys array
+ *
+ * void (*remove)(struct tty_driver *self, struct tty_struct *tty)
+ *
+ *	Remove a closed tty from the tty driver internal tables. Used in
+ *	conjunction with lookup and remove methods.
+ *
+ *	Optional method. Default behaviour is to use the ttys array
+ *
  * int  (*open)(struct tty_struct * tty, struct file * filp);
  *
  * 	This routine is called when a particular tty device is opened.
@@ -212,6 +226,8 @@ struct tty_driver;
 
 struct tty_operations {
 	struct tty_struct * (*lookup)(struct tty_driver *driver, int idx);
+	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
+	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
 	int  (*open)(struct tty_struct * tty, struct file * filp);
 	void (*close)(struct tty_struct * tty, struct file * filp);
 	void (*shutdown)(struct tty_struct *tty);

commit 7d7b93c1452f381350dbaf276a63357fa6559e6d
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:42:09 2008 +0100

    tty: kref the tty driver object
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 2c5c35c4656f..ba891dd23550 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -253,6 +253,7 @@ struct tty_operations {
 
 struct tty_driver {
 	int	magic;		/* magic number for this structure */
+	struct kref kref;	/* Reference management */
 	struct cdev cdev;
 	struct module	*owner;
 	const char	*driver_name;
@@ -266,7 +267,6 @@ struct tty_driver {
 	short	subtype;	/* subtype of tty driver */
 	struct ktermios init_termios; /* Initial termios */
 	int	flags;		/* tty driver flags */
-	int	refcount;	/* for loadable tty drivers */
 	struct proc_dir_entry *proc_entry; /* /proc fs entry */
 	struct tty_driver *other; /* only used for the PTY driver */
 
@@ -288,12 +288,19 @@ struct tty_driver {
 
 extern struct list_head tty_drivers;
 
-struct tty_driver *alloc_tty_driver(int lines);
-void put_tty_driver(struct tty_driver *driver);
-void tty_set_operations(struct tty_driver *driver,
+extern struct tty_driver *alloc_tty_driver(int lines);
+extern void put_tty_driver(struct tty_driver *driver);
+extern void tty_set_operations(struct tty_driver *driver,
 			const struct tty_operations *op);
 extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
 
+extern void tty_driver_kref_put(struct tty_driver *driver);
+extern inline struct tty_driver *tty_driver_kref_get(struct tty_driver *d)
+{
+	kref_get(&d->kref);
+	return d;
+}
+
 /* tty driver magic number */
 #define TTY_DRIVER_MAGIC		0x5402
 

commit 99f1fe189daf8e99a847e420567e49dd7ee2aae7
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:42:00 2008 +0100

    tty: Clean up the tty_init_dev changes further
    
    Fix up the naming, style and extract some bits of code into the driver
    specific code
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 2322313a8589..2c5c35c4656f 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -7,6 +7,14 @@
  * defined; unless noted otherwise, they are optional, and can be
  * filled in with a null pointer.
  *
+ * struct tty_struct * (*lookup)(struct tty_driver *self, int idx)
+ *
+ *	Return the tty device corresponding to idx, NULL if there is not
+ *	one currently in use and an ERR_PTR value on error. Called under
+ *	tty_mutex (for now!)
+ *
+ *	Optional method. Default behaviour is to use the ttys array
+ *
  * int  (*open)(struct tty_struct * tty, struct file * filp);
  *
  * 	This routine is called when a particular tty device is opened.
@@ -203,6 +211,7 @@ struct tty_struct;
 struct tty_driver;
 
 struct tty_operations {
+	struct tty_struct * (*lookup)(struct tty_driver *driver, int idx);
 	int  (*open)(struct tty_struct * tty, struct file * filp);
 	void (*close)(struct tty_struct * tty, struct file * filp);
 	void (*shutdown)(struct tty_struct *tty);

commit feebed6515a113eeb33919e9557a8b9710ea627c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:41:30 2008 +0100

    tty: shutdown method
    
    Right now there are various drivers that try to use tty->count to know when
    they get the final close. Aristeau Rozanski showed while debugging the vt
    sysfs race that this isn't entirely safe.
    
    Instead of driver side tricks to work around this introduce a shutdown which
    is called when the tty is being destructed. This also means that the shutdown
    method is tied into the refcounting.
    
    Use this to rework the console close/sysfs logic.
    
    Remove lots of special case code from the tty core code. The pty code can now
    have a shutdown() method that replaces the special case hackery in the tree
    free up paths.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index ac6e58e26b73..2322313a8589 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -21,6 +21,11 @@
  *
  *	Required method.
  *
+ * void (*shutdown)(struct tty_struct * tty);
+ *
+ * 	This routine is called when a particular tty device is closed for
+ *	the last time freeing up the resources.
+ *
  * int (*write)(struct tty_struct * tty,
  * 		 const unsigned char *buf, int count);
  *
@@ -200,6 +205,7 @@ struct tty_driver;
 struct tty_operations {
 	int  (*open)(struct tty_struct * tty, struct file * filp);
 	void (*close)(struct tty_struct * tty, struct file * filp);
+	void (*shutdown)(struct tty_struct *tty);
 	int  (*write)(struct tty_struct * tty,
 		      const unsigned char *buf, int count);
 	int  (*put_char)(struct tty_struct *tty, unsigned char ch);

commit 1d65b4a088de407e99714fdc27862449db04fb5c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:38:18 2008 +0100

    tty: Add termiox
    
    We need a way to describe the various additional modes and flow control
    features that random weird hardware shows up and software such as wine
    wants to emulate as Windows supports them.
    
    TCGETX/TCSETX and the termiox ioctl are a SYS5 extension that we might as
    well adopt. This patches adds the structures and the basic ioctl interfaces
    when the TCGETX etc defines are added for an architecture. Drivers wishing
    to use this stuff need to add new methods.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 16d27944c321..ac6e58e26b73 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -180,6 +180,14 @@
  *	not force errors here if they are not resizable objects (eg a serial
  *	line). See tty_do_resize() if you need to wrap the standard method
  *	in your own logic - the usual case.
+ *
+ * void (*set_termiox)(struct tty_struct *tty, struct termiox *new);
+ *
+ *	Called when the device receives a termiox based ioctl. Passes down
+ *	the requested data from user space. This method will not be invoked
+ *	unless the tty also has a valid tty->termiox pointer.
+ *
+ *	Optional: Called under the termios lock
  */
 
 #include <linux/fs.h>
@@ -220,6 +228,7 @@ struct tty_operations {
 			unsigned int set, unsigned int clear);
 	int (*resize)(struct tty_struct *tty, struct tty_struct *real_tty,
 				struct winsize *ws);
+	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);
 	int (*poll_get_char)(struct tty_driver *driver, int line);

commit 8c9a9dd0fa3a269d380eaae2dc1bee39e865fae1
Author: Alan Cox <alan@redhat.com>
Date:   Fri Aug 15 10:39:38 2008 +0100

    tty: remove resize window special case
    
    This moves it to being a tty operation. That removes special cases and now
    also means that resize can be picked up by um and other non vt consoles
    which may have a resize operation.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index e1065ac0d922..16d27944c321 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -168,6 +168,18 @@
  *
  *	Optional: If not provided then the write method is called under
  *	the atomic write lock to keep it serialized with the ldisc.
+ *
+ * int (*resize)(struct tty_struct *tty, struct tty_struct *real_tty,
+ *				unsigned int rows, unsigned int cols);
+ *
+ *	Called when a termios request is issued which changes the
+ *	requested terminal geometry.
+ *
+ *	Optional: the default action is to update the termios structure
+ *	without error. This is usually the correct behaviour. Drivers should
+ *	not force errors here if they are not resizable objects (eg a serial
+ *	line). See tty_do_resize() if you need to wrap the standard method
+ *	in your own logic - the usual case.
  */
 
 #include <linux/fs.h>
@@ -206,6 +218,8 @@ struct tty_operations {
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
+	int (*resize)(struct tty_struct *tty, struct tty_struct *real_tty,
+				struct winsize *ws);
 #ifdef CONFIG_CONSOLE_POLL
 	int (*poll_init)(struct tty_driver *driver, int line, char *options);
 	int (*poll_get_char)(struct tty_driver *driver, int line);

commit 9e98966c7bb94355689478bc84cc3e0c190f977e
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:18:03 2008 +0100

    tty: rework break handling
    
    Some hardware needs to do break handling itself and may have partial
    support only. Make break_ctl return an error code. Add a tty driver flag
    so you can indicate driver hardware side break support.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index d2a003586761..e1065ac0d922 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -135,7 +135,7 @@
  *
  *	Optional:
  *
- * void (*break_ctl)(struct tty_stuct *tty, int state);
+ * int (*break_ctl)(struct tty_stuct *tty, int state);
  *
  * 	This optional routine requests the tty driver to turn on or
  * 	off BREAK status on the RS-232 port.  If state is -1,
@@ -146,6 +146,10 @@
  * 	handle the following ioctls: TCSBRK, TCSBRKP, TIOCSBRK,
  * 	TIOCCBRK.
  *
+ *	If the driver sets TTY_DRIVER_HARDWARE_BREAK then the interface
+ *	will also be called with actual times and the hardware is expected
+ *	to do the delay work itself. 0 and -1 are still used for on/off.
+ *
  *	Optional: Required for TCSBRK/BRKP/etc handling.
  *
  * void (*wait_until_sent)(struct tty_struct *tty, int timeout);
@@ -192,7 +196,7 @@ struct tty_operations {
 	void (*stop)(struct tty_struct *tty);
 	void (*start)(struct tty_struct *tty);
 	void (*hangup)(struct tty_struct *tty);
-	void (*break_ctl)(struct tty_struct *tty, int state);
+	int (*break_ctl)(struct tty_struct *tty, int state);
 	void (*flush_buffer)(struct tty_struct *tty);
 	void (*set_ldisc)(struct tty_struct *tty);
 	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
@@ -285,12 +289,18 @@ extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
  * TTY_DRIVER_DEVPTS_MEM -- don't use the standard arrays, instead
  *	use dynamic memory keyed through the devpts filesystem.  This
  *	is only applicable to the pty driver.
+ *
+ * TTY_DRIVER_HARDWARE_BREAK -- hardware handles break signals. Pass
+ *	the requested timeout to the caller instead of using a simple
+ *	on/off interface.
+ *
  */
 #define TTY_DRIVER_INSTALLED		0x0001
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
 #define TTY_DRIVER_REAL_RAW		0x0004
 #define TTY_DRIVER_DYNAMIC_DEV		0x0008
 #define TTY_DRIVER_DEVPTS_MEM		0x0010
+#define TTY_DRIVER_HARDWARE_BREAK	0x0020
 
 /* tty driver types */
 #define TTY_DRIVER_TYPE_SYSTEM		0x0001

commit 36c7343b4ecac2432430f5393314f1bdc2c219a5
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jun 23 12:06:52 2008 +0100

    tty_driver: Update required method documentation
    
    Some of the requirement rules are now more relaxed. Also correct a
    contradiction in the previous update
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 59f1c0bd8f9c..d2a003586761 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -27,8 +27,7 @@
  * 	This routine is called by the kernel to write a series of
  * 	characters to the tty device.  The characters may come from
  * 	user space or kernel space.  This routine will return the
- *	number of characters actually accepted for writing.  This
- *	routine is mandatory.
+ *	number of characters actually accepted for writing.
  *
  *	Optional: Required for writable devices.
  *
@@ -134,7 +133,7 @@
  * 	This routine notifies the tty driver that it should hangup the
  * 	tty device.
  *
- *	Required:
+ *	Optional:
  *
  * void (*break_ctl)(struct tty_stuct *tty, int state);
  *

commit 39c2e60f8c584c1b29b5c4375dd49df7995386bb
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 30 00:54:18 2008 -0700

    tty: add throttle/unthrottle helpers
    
    Something Arjan suggested which allows us to clean up the code nicely
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index f80d73b690f6..59f1c0bd8f9c 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -100,6 +100,8 @@
  * 	This routine notifies the tty driver that input buffers for
  * 	the line discipline are close to full, and it should somehow
  * 	signal that no more characters should be sent to the tty.
+ *
+ *	Optional: Always invoke via tty_throttle();
  * 
  * void (*unthrottle)(struct tty_struct * tty);
  *
@@ -107,6 +109,8 @@
  * 	that characters can now be sent to the tty without fear of
  * 	overrunning the input buffers of the line disciplines.
  * 
+ *	Optional: Always invoke via tty_unthrottle();
+ *
  * void (*stop)(struct tty_struct *tty);
  *
  * 	This routine notifies the tty driver that it should stop

commit f34d7a5b7010b82fe97da95496b9971435530062
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 30 00:54:13 2008 -0700

    tty: The big operations rework
    
    - Operations are now a shared const function block as with most other Linux
      objects
    
    - Introduce wrappers for some optional functions to get consistent behaviour
    
    - Wrap put_char which used to be patched by the tty layer
    
    - Document which functions are needed/optional
    
    - Make put_char report success/fail
    
    - Cache the driver->ops pointer in the tty as tty->ops
    
    - Remove various surplus lock calls we no longer need
    
    - Remove proc_write method as noted by Alexey Dobriyan
    
    - Introduce some missing sanity checks where certain driver/ldisc
      combinations would oops as they didn't check needed methods were present
    
    [akpm@linux-foundation.org: fix fs/compat_ioctl.c build]
    [akpm@linux-foundation.org: fix isicom]
    [akpm@linux-foundation.org: fix arch/ia64/hp/sim/simserial.c build]
    [akpm@linux-foundation.org: fix kgdb]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 21f69aca4505..f80d73b690f6 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -12,11 +12,15 @@
  * 	This routine is called when a particular tty device is opened.
  * 	This routine is mandatory; if this routine is not filled in,
  * 	the attempted open will fail with ENODEV.
+ *
+ *	Required method.
  *     
  * void (*close)(struct tty_struct * tty, struct file * filp);
  *
  * 	This routine is called when a particular tty device is closed.
  *
+ *	Required method.
+ *
  * int (*write)(struct tty_struct * tty,
  * 		 const unsigned char *buf, int count);
  *
@@ -26,7 +30,9 @@
  *	number of characters actually accepted for writing.  This
  *	routine is mandatory.
  *
- * void (*put_char)(struct tty_struct *tty, unsigned char ch);
+ *	Optional: Required for writable devices.
+ *
+ * int (*put_char)(struct tty_struct *tty, unsigned char ch);
  *
  * 	This routine is called by the kernel to write a single
  * 	character to the tty device.  If the kernel uses this routine,
@@ -34,10 +40,18 @@
  * 	done stuffing characters into the driver.  If there is no room
  * 	in the queue, the character is ignored.
  *
+ *	Optional: Kernel will use the write method if not provided.
+ *
+ *	Note: Do not call this function directly, call tty_put_char
+ *
  * void (*flush_chars)(struct tty_struct *tty);
  *
  * 	This routine is called by the kernel after it has written a
  * 	series of characters to the tty device using put_char().  
+ *
+ *	Optional:
+ *
+ *	Note: Do not call this function directly, call tty_driver_flush_chars
  * 
  * int  (*write_room)(struct tty_struct *tty);
  *
@@ -45,6 +59,10 @@
  * 	will accept for queuing to be written.  This number is subject
  * 	to change as output buffers get emptied, or if the output flow
  *	control is acted.
+ *
+ *	Required if write method is provided else not needed.
+ *
+ *	Note: Do not call this function directly, call tty_write_room
  * 
  * int  (*ioctl)(struct tty_struct *tty, struct file * file,
  * 	    unsigned int cmd, unsigned long arg);
@@ -53,22 +71,29 @@
  *	device-specific ioctl's.  If the ioctl number passed in cmd
  * 	is not recognized by the driver, it should return ENOIOCTLCMD.
  *
+ *	Optional
+ *
  * long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
  * 	                unsigned int cmd, unsigned long arg);
  *
  * 	implement ioctl processing for 32 bit process on 64 bit system
+ *
+ *	Optional
  * 
  * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
  *
  * 	This routine allows the tty driver to be notified when
- * 	device's termios settings have changed.  Note that a
- * 	well-designed tty driver should be prepared to accept the case
- * 	where old == NULL, and try to do something rational.
+ * 	device's termios settings have changed.
+ *
+ *	Optional: Called under the termios lock
+ *
  *
  * void (*set_ldisc)(struct tty_struct *tty);
  *
  * 	This routine allows the tty driver to be notified when the
  * 	device's termios settings have changed.
+ *
+ *	Optional: Called under BKL (currently)
  * 
  * void (*throttle)(struct tty_struct * tty);
  *
@@ -86,17 +111,27 @@
  *
  * 	This routine notifies the tty driver that it should stop
  * 	outputting characters to the tty device.  
+ *
+ *	Optional:
+ *
+ *	Note: Call stop_tty not this method.
  * 
  * void (*start)(struct tty_struct *tty);
  *
  * 	This routine notifies the tty driver that it resume sending
  *	characters to the tty device.
+ *
+ *	Optional:
+ *
+ *	Note: Call start_tty not this method.
  * 
  * void (*hangup)(struct tty_struct *tty);
  *
  * 	This routine notifies the tty driver that it should hangup the
  * 	tty device.
  *
+ *	Required:
+ *
  * void (*break_ctl)(struct tty_stuct *tty, int state);
  *
  * 	This optional routine requests the tty driver to turn on or
@@ -106,18 +141,26 @@
  *
  * 	If this routine is implemented, the high-level tty driver will
  * 	handle the following ioctls: TCSBRK, TCSBRKP, TIOCSBRK,
- * 	TIOCCBRK.  Otherwise, these ioctls will be passed down to the
- * 	driver to handle.
+ * 	TIOCCBRK.
+ *
+ *	Optional: Required for TCSBRK/BRKP/etc handling.
  *
  * void (*wait_until_sent)(struct tty_struct *tty, int timeout);
  * 
  * 	This routine waits until the device has written out all of the
  * 	characters in its transmitter FIFO.
  *
+ *	Optional: If not provided the device is assumed to have no FIFO
+ *
+ *	Note: Usually correct to call tty_wait_until_sent
+ *
  * void (*send_xchar)(struct tty_struct *tty, char ch);
  *
  * 	This routine is used to send a high-priority XON/XOFF
  * 	character to the device.
+ *
+ *	Optional: If not provided then the write method is called under
+ *	the atomic write lock to keep it serialized with the ldisc.
  */
 
 #include <linux/fs.h>
@@ -132,7 +175,7 @@ struct tty_operations {
 	void (*close)(struct tty_struct * tty, struct file * filp);
 	int  (*write)(struct tty_struct * tty,
 		      const unsigned char *buf, int count);
-	void (*put_char)(struct tty_struct *tty, unsigned char ch);
+	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
 	void (*flush_chars)(struct tty_struct *tty);
 	int  (*write_room)(struct tty_struct *tty);
 	int  (*chars_in_buffer)(struct tty_struct *tty);
@@ -153,8 +196,6 @@ struct tty_operations {
 	void (*send_xchar)(struct tty_struct *tty, char ch);
 	int (*read_proc)(char *page, char **start, off_t off,
 			  int count, int *eof, void *data);
-	int (*write_proc)(struct file *file, const char __user *buffer,
-			  unsigned long count, void *data);
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
@@ -190,48 +231,13 @@ struct tty_driver {
 	struct tty_struct **ttys;
 	struct ktermios **termios;
 	struct ktermios **termios_locked;
-	void *driver_state;	/* only used for the PTY driver */
-	
+	void *driver_state;
+
 	/*
-	 * Interface routines from the upper tty layer to the tty
-	 * driver.	Will be replaced with struct tty_operations.
+	 * Driver methods
 	 */
-	int  (*open)(struct tty_struct * tty, struct file * filp);
-	void (*close)(struct tty_struct * tty, struct file * filp);
-	int  (*write)(struct tty_struct * tty,
-		      const unsigned char *buf, int count);
-	void (*put_char)(struct tty_struct *tty, unsigned char ch);
-	void (*flush_chars)(struct tty_struct *tty);
-	int  (*write_room)(struct tty_struct *tty);
-	int  (*chars_in_buffer)(struct tty_struct *tty);
-	int  (*ioctl)(struct tty_struct *tty, struct file * file,
-		    unsigned int cmd, unsigned long arg);
-	long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
-			     unsigned int cmd, unsigned long arg);
-	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
-	void (*throttle)(struct tty_struct * tty);
-	void (*unthrottle)(struct tty_struct * tty);
-	void (*stop)(struct tty_struct *tty);
-	void (*start)(struct tty_struct *tty);
-	void (*hangup)(struct tty_struct *tty);
-	void (*break_ctl)(struct tty_struct *tty, int state);
-	void (*flush_buffer)(struct tty_struct *tty);
-	void (*set_ldisc)(struct tty_struct *tty);
-	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
-	void (*send_xchar)(struct tty_struct *tty, char ch);
-	int (*read_proc)(char *page, char **start, off_t off,
-			  int count, int *eof, void *data);
-	int (*write_proc)(struct file *file, const char __user *buffer,
-			  unsigned long count, void *data);
-	int (*tiocmget)(struct tty_struct *tty, struct file *file);
-	int (*tiocmset)(struct tty_struct *tty, struct file *file,
-			unsigned int set, unsigned int clear);
-#ifdef CONFIG_CONSOLE_POLL
-	int (*poll_init)(struct tty_driver *driver, int line, char *options);
-	int (*poll_get_char)(struct tty_driver *driver, int line);
-	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
-#endif
 
+	const struct tty_operations *ops;
 	struct list_head tty_drivers;
 };
 

commit f2d937f3bf00665ccf048b3b6616ef95859b0945
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Apr 17 20:05:37 2008 +0200

    consoles: polling support, kgdboc
    
    polled console handling support, to access a console in an irq-less
    way while in debug or irq context.
    
    absolutely zero impact as long as CONFIG_CONSOLE_POLL is disabled.
    (which is the default)
    
    [ jan.kiszka@siemens.com: lots of cleanups ]
    [ mingo@elte.hu: redesign, splitups, cleanups. ]
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jan Kiszka <jan.kiszka@web.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 85c95cd39bc3..21f69aca4505 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -125,6 +125,7 @@
 #include <linux/cdev.h>
 
 struct tty_struct;
+struct tty_driver;
 
 struct tty_operations {
 	int  (*open)(struct tty_struct * tty, struct file * filp);
@@ -157,6 +158,11 @@ struct tty_operations {
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
+#ifdef CONFIG_CONSOLE_POLL
+	int (*poll_init)(struct tty_driver *driver, int line, char *options);
+	int (*poll_get_char)(struct tty_driver *driver, int line);
+	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
+#endif
 };
 
 struct tty_driver {
@@ -220,6 +226,11 @@ struct tty_driver {
 	int (*tiocmget)(struct tty_struct *tty, struct file *file);
 	int (*tiocmset)(struct tty_struct *tty, struct file *file,
 			unsigned int set, unsigned int clear);
+#ifdef CONFIG_CONSOLE_POLL
+	int (*poll_init)(struct tty_driver *driver, int line, char *options);
+	int (*poll_get_char)(struct tty_driver *driver, int line);
+	void (*poll_put_char)(struct tty_driver *driver, int line, char ch);
+#endif
 
 	struct list_head tty_drivers;
 };
@@ -230,6 +241,7 @@ struct tty_driver *alloc_tty_driver(int lines);
 void put_tty_driver(struct tty_driver *driver);
 void tty_set_operations(struct tty_driver *driver,
 			const struct tty_operations *op);
+extern struct tty_driver *tty_find_polling_driver(char *name, int *line);
 
 /* tty driver magic number */
 #define TTY_DRIVER_MAGIC		0x5402

commit e10cc1df1d2014f68a4bdcf73f6dd122c4561f94
Author: Paul Fulghum <paulkf@microgate.com>
Date:   Thu May 10 22:22:50 2007 -0700

    tty: add compat_ioctl
    
    Add compat_ioctl method for tty code to allow processing of 32 bit ioctl
    calls on 64 bit systems by tty core, tty drivers, and line disciplines.
    
    Based on patch by Arnd Bergmann:
    http://www.uwsg.iu.edu/hypermail/linux/kernel/0511.0/1732.html
    
    [akpm@linux-foundation.org: make things static]
    Signed-off-by: Paul Fulghum <paulkf@microgate.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 659487e3ebeb..85c95cd39bc3 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -52,6 +52,11 @@
  * 	This routine allows the tty driver to implement
  *	device-specific ioctl's.  If the ioctl number passed in cmd
  * 	is not recognized by the driver, it should return ENOIOCTLCMD.
+ *
+ * long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
+ * 	                unsigned int cmd, unsigned long arg);
+ *
+ * 	implement ioctl processing for 32 bit process on 64 bit system
  * 
  * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
  *
@@ -132,6 +137,8 @@ struct tty_operations {
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	int  (*ioctl)(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg);
+	long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
+			     unsigned int cmd, unsigned long arg);
 	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
 	void (*throttle)(struct tty_struct * tty);
 	void (*unthrottle)(struct tty_struct * tty);
@@ -193,6 +200,8 @@ struct tty_driver {
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	int  (*ioctl)(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg);
+	long (*compat_ioctl)(struct tty_struct *tty, struct file * file,
+			     unsigned int cmd, unsigned long arg);
 	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
 	void (*throttle)(struct tty_struct * tty);
 	void (*unthrottle)(struct tty_struct * tty);

commit edc6afc5496875a640bef0913604be7550c1795d
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Dec 8 02:38:44 2006 -0800

    [PATCH] tty: switch to ktermios and new framework
    
    This is the core of the switch to the new framework.  I've split it from the
    driver patches which are mostly search/replace and would encourage people to
    give this one a good hard stare.
    
    The references to BOTHER and ISHIFT are the termios values that must be
    defined by a platform once it wants to turn on "new style" ioctl support.  The
    code patches here ensure that providing
    
    1. The termios overlays the ktermios in memory
    2. The only new kernel only fields are c_ispeed/c_ospeed (or none)
    
    the existing behaviour is retained.  This is true for the patches at this
    point in time.
    
    Future patches will define BOTHER, ISHIFT and enable newer termios structures
    for each architecture, and once they are all done some of the ifdefs also
    vanish.
    
    [akpm@osdl.org: warning fix]
    [akpm@osdl.org: IRDA fix]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 5c8473bb6882..659487e3ebeb 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -53,7 +53,7 @@
  *	device-specific ioctl's.  If the ioctl number passed in cmd
  * 	is not recognized by the driver, it should return ENOIOCTLCMD.
  * 
- * void (*set_termios)(struct tty_struct *tty, struct termios * old);
+ * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
  *
  * 	This routine allows the tty driver to be notified when
  * 	device's termios settings have changed.  Note that a
@@ -132,7 +132,7 @@ struct tty_operations {
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	int  (*ioctl)(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg);
-	void (*set_termios)(struct tty_struct *tty, struct termios * old);
+	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
 	void (*throttle)(struct tty_struct * tty);
 	void (*unthrottle)(struct tty_struct * tty);
 	void (*stop)(struct tty_struct *tty);
@@ -165,7 +165,7 @@ struct tty_driver {
 	int	num;		/* number of devices allocated */
 	short	type;		/* type of tty driver */
 	short	subtype;	/* subtype of tty driver */
-	struct termios init_termios; /* Initial termios */
+	struct ktermios init_termios; /* Initial termios */
 	int	flags;		/* tty driver flags */
 	int	refcount;	/* for loadable tty drivers */
 	struct proc_dir_entry *proc_entry; /* /proc fs entry */
@@ -175,8 +175,8 @@ struct tty_driver {
 	 * Pointer to the tty data structures
 	 */
 	struct tty_struct **ttys;
-	struct termios **termios;
-	struct termios **termios_locked;
+	struct ktermios **termios;
+	struct ktermios **termios_locked;
 	void *driver_state;	/* only used for the PTY driver */
 	
 	/*
@@ -193,7 +193,7 @@ struct tty_driver {
 	int  (*chars_in_buffer)(struct tty_struct *tty);
 	int  (*ioctl)(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg);
-	void (*set_termios)(struct tty_struct *tty, struct termios * old);
+	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
 	void (*throttle)(struct tty_struct * tty);
 	void (*unthrottle)(struct tty_struct * tty);
 	void (*stop)(struct tty_struct *tty);

commit b68e31d0ebbcc909d1941f9f230c9d062a3a13d3
Author: Jeff Dike <jdike@addtoit.com>
Date:   Mon Oct 2 02:17:18 2006 -0700

    [PATCH] const struct tty_operations
    
    As part of an SMP cleanliness pass over UML, I consted a bunch of
    structures in order to not have to document their locking.  One of these
    structures was a struct tty_operations.  In order to const it in UML
    without introducing compiler complaints, the declaration of
    tty_set_operations needs to be changed, and then all of its callers need to
    be fixed.
    
    This patch declares all struct tty_operations in the tree as const.  In all
    cases, they are static and used only as input to tty_set_operations.  As an
    extra check, I ran an i386 allyesconfig build which produced no extra
    warnings.
    
    53 drivers are affected.  I checked the history of a bunch of them, and in
    most cases, there have been only a handful of maintenance changes in the
    last six months.  serial_core.c was the busiest one that I looked at.
    
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 58c961c9e170..5c8473bb6882 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -219,7 +219,8 @@ extern struct list_head tty_drivers;
 
 struct tty_driver *alloc_tty_driver(int lines);
 void put_tty_driver(struct tty_driver *driver);
-void tty_set_operations(struct tty_driver *driver, struct tty_operations *op);
+void tty_set_operations(struct tty_driver *driver,
+			const struct tty_operations *op);
 
 /* tty driver magic number */
 #define TTY_DRIVER_MAGIC		0x5402

commit 331b831983f9d706f4a40d08a996d5c2c7a6ea7b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Rename TTY_DRIVER_NO_DEVFS to TTY_DRIVER_DYNAMIC_DEV
    
    I've always found this flag confusing.  Now that devfs is no longer around, it
    has been renamed, and the documentation for when this flag should be used has
    been updated.
    
    Also fixes all drivers that use this flag.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index 0bd31f0830f9..58c961c9e170 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -241,8 +241,15 @@ void tty_set_operations(struct tty_driver *driver, struct tty_operations *op);
  * 	is also a promise, if the above case is true, not to signal
  * 	overruns, either.)
  *
- * TTY_DRIVER_NO_DEVFS --- if set, do not create devfs entries. This
- *	is only used by tty_register_driver().
+ * TTY_DRIVER_DYNAMIC_DEV --- if set, the individual tty devices need
+ *	to be registered with a call to tty_register_driver() when the
+ *	device is found in the system and unregistered with a call to
+ *	tty_unregister_device() so the devices will be show up
+ *	properly in sysfs.  If not set, driver->num entries will be
+ *	created by the tty core in sysfs when tty_register_driver() is
+ *	called.  This is to be used by drivers that have tty devices
+ *	that can appear and disappear while the main tty driver is
+ *	registered with the tty core.
  *
  * TTY_DRIVER_DEVPTS_MEM -- don't use the standard arrays, instead
  *	use dynamic memory keyed through the devpts filesystem.  This
@@ -251,7 +258,7 @@ void tty_set_operations(struct tty_driver *driver, struct tty_operations *op);
 #define TTY_DRIVER_INSTALLED		0x0001
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
 #define TTY_DRIVER_REAL_RAW		0x0004
-#define TTY_DRIVER_NO_DEVFS		0x0008
+#define TTY_DRIVER_DYNAMIC_DEV		0x0008
 #define TTY_DRIVER_DEVPTS_MEM		0x0010
 
 /* tty driver types */

commit f4eaa37017a5a68f67ef86729508022c13fb8e6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove the tty_driver devfs_name field as it's no longer needed
    
    Also fixes all drivers that set this field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
index b368b296d035..0bd31f0830f9 100644
--- a/include/linux/tty_driver.h
+++ b/include/linux/tty_driver.h
@@ -157,7 +157,6 @@ struct tty_driver {
 	struct cdev cdev;
 	struct module	*owner;
 	const char	*driver_name;
-	const char	*devfs_name;
 	const char	*name;
 	int	name_base;	/* offset of printed name */
 	int	major;		/* major device number */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/tty_driver.h b/include/linux/tty_driver.h
new file mode 100644
index 000000000000..b368b296d035
--- /dev/null
+++ b/include/linux/tty_driver.h
@@ -0,0 +1,279 @@
+#ifndef _LINUX_TTY_DRIVER_H
+#define _LINUX_TTY_DRIVER_H
+
+/*
+ * This structure defines the interface between the low-level tty
+ * driver and the tty routines.  The following routines can be
+ * defined; unless noted otherwise, they are optional, and can be
+ * filled in with a null pointer.
+ *
+ * int  (*open)(struct tty_struct * tty, struct file * filp);
+ *
+ * 	This routine is called when a particular tty device is opened.
+ * 	This routine is mandatory; if this routine is not filled in,
+ * 	the attempted open will fail with ENODEV.
+ *     
+ * void (*close)(struct tty_struct * tty, struct file * filp);
+ *
+ * 	This routine is called when a particular tty device is closed.
+ *
+ * int (*write)(struct tty_struct * tty,
+ * 		 const unsigned char *buf, int count);
+ *
+ * 	This routine is called by the kernel to write a series of
+ * 	characters to the tty device.  The characters may come from
+ * 	user space or kernel space.  This routine will return the
+ *	number of characters actually accepted for writing.  This
+ *	routine is mandatory.
+ *
+ * void (*put_char)(struct tty_struct *tty, unsigned char ch);
+ *
+ * 	This routine is called by the kernel to write a single
+ * 	character to the tty device.  If the kernel uses this routine,
+ * 	it must call the flush_chars() routine (if defined) when it is
+ * 	done stuffing characters into the driver.  If there is no room
+ * 	in the queue, the character is ignored.
+ *
+ * void (*flush_chars)(struct tty_struct *tty);
+ *
+ * 	This routine is called by the kernel after it has written a
+ * 	series of characters to the tty device using put_char().  
+ * 
+ * int  (*write_room)(struct tty_struct *tty);
+ *
+ * 	This routine returns the numbers of characters the tty driver
+ * 	will accept for queuing to be written.  This number is subject
+ * 	to change as output buffers get emptied, or if the output flow
+ *	control is acted.
+ * 
+ * int  (*ioctl)(struct tty_struct *tty, struct file * file,
+ * 	    unsigned int cmd, unsigned long arg);
+ *
+ * 	This routine allows the tty driver to implement
+ *	device-specific ioctl's.  If the ioctl number passed in cmd
+ * 	is not recognized by the driver, it should return ENOIOCTLCMD.
+ * 
+ * void (*set_termios)(struct tty_struct *tty, struct termios * old);
+ *
+ * 	This routine allows the tty driver to be notified when
+ * 	device's termios settings have changed.  Note that a
+ * 	well-designed tty driver should be prepared to accept the case
+ * 	where old == NULL, and try to do something rational.
+ *
+ * void (*set_ldisc)(struct tty_struct *tty);
+ *
+ * 	This routine allows the tty driver to be notified when the
+ * 	device's termios settings have changed.
+ * 
+ * void (*throttle)(struct tty_struct * tty);
+ *
+ * 	This routine notifies the tty driver that input buffers for
+ * 	the line discipline are close to full, and it should somehow
+ * 	signal that no more characters should be sent to the tty.
+ * 
+ * void (*unthrottle)(struct tty_struct * tty);
+ *
+ * 	This routine notifies the tty drivers that it should signals
+ * 	that characters can now be sent to the tty without fear of
+ * 	overrunning the input buffers of the line disciplines.
+ * 
+ * void (*stop)(struct tty_struct *tty);
+ *
+ * 	This routine notifies the tty driver that it should stop
+ * 	outputting characters to the tty device.  
+ * 
+ * void (*start)(struct tty_struct *tty);
+ *
+ * 	This routine notifies the tty driver that it resume sending
+ *	characters to the tty device.
+ * 
+ * void (*hangup)(struct tty_struct *tty);
+ *
+ * 	This routine notifies the tty driver that it should hangup the
+ * 	tty device.
+ *
+ * void (*break_ctl)(struct tty_stuct *tty, int state);
+ *
+ * 	This optional routine requests the tty driver to turn on or
+ * 	off BREAK status on the RS-232 port.  If state is -1,
+ * 	then the BREAK status should be turned on; if state is 0, then
+ * 	BREAK should be turned off.
+ *
+ * 	If this routine is implemented, the high-level tty driver will
+ * 	handle the following ioctls: TCSBRK, TCSBRKP, TIOCSBRK,
+ * 	TIOCCBRK.  Otherwise, these ioctls will be passed down to the
+ * 	driver to handle.
+ *
+ * void (*wait_until_sent)(struct tty_struct *tty, int timeout);
+ * 
+ * 	This routine waits until the device has written out all of the
+ * 	characters in its transmitter FIFO.
+ *
+ * void (*send_xchar)(struct tty_struct *tty, char ch);
+ *
+ * 	This routine is used to send a high-priority XON/XOFF
+ * 	character to the device.
+ */
+
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/cdev.h>
+
+struct tty_struct;
+
+struct tty_operations {
+	int  (*open)(struct tty_struct * tty, struct file * filp);
+	void (*close)(struct tty_struct * tty, struct file * filp);
+	int  (*write)(struct tty_struct * tty,
+		      const unsigned char *buf, int count);
+	void (*put_char)(struct tty_struct *tty, unsigned char ch);
+	void (*flush_chars)(struct tty_struct *tty);
+	int  (*write_room)(struct tty_struct *tty);
+	int  (*chars_in_buffer)(struct tty_struct *tty);
+	int  (*ioctl)(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg);
+	void (*set_termios)(struct tty_struct *tty, struct termios * old);
+	void (*throttle)(struct tty_struct * tty);
+	void (*unthrottle)(struct tty_struct * tty);
+	void (*stop)(struct tty_struct *tty);
+	void (*start)(struct tty_struct *tty);
+	void (*hangup)(struct tty_struct *tty);
+	void (*break_ctl)(struct tty_struct *tty, int state);
+	void (*flush_buffer)(struct tty_struct *tty);
+	void (*set_ldisc)(struct tty_struct *tty);
+	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
+	void (*send_xchar)(struct tty_struct *tty, char ch);
+	int (*read_proc)(char *page, char **start, off_t off,
+			  int count, int *eof, void *data);
+	int (*write_proc)(struct file *file, const char __user *buffer,
+			  unsigned long count, void *data);
+	int (*tiocmget)(struct tty_struct *tty, struct file *file);
+	int (*tiocmset)(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear);
+};
+
+struct tty_driver {
+	int	magic;		/* magic number for this structure */
+	struct cdev cdev;
+	struct module	*owner;
+	const char	*driver_name;
+	const char	*devfs_name;
+	const char	*name;
+	int	name_base;	/* offset of printed name */
+	int	major;		/* major device number */
+	int	minor_start;	/* start of minor device number */
+	int	minor_num;	/* number of *possible* devices */
+	int	num;		/* number of devices allocated */
+	short	type;		/* type of tty driver */
+	short	subtype;	/* subtype of tty driver */
+	struct termios init_termios; /* Initial termios */
+	int	flags;		/* tty driver flags */
+	int	refcount;	/* for loadable tty drivers */
+	struct proc_dir_entry *proc_entry; /* /proc fs entry */
+	struct tty_driver *other; /* only used for the PTY driver */
+
+	/*
+	 * Pointer to the tty data structures
+	 */
+	struct tty_struct **ttys;
+	struct termios **termios;
+	struct termios **termios_locked;
+	void *driver_state;	/* only used for the PTY driver */
+	
+	/*
+	 * Interface routines from the upper tty layer to the tty
+	 * driver.	Will be replaced with struct tty_operations.
+	 */
+	int  (*open)(struct tty_struct * tty, struct file * filp);
+	void (*close)(struct tty_struct * tty, struct file * filp);
+	int  (*write)(struct tty_struct * tty,
+		      const unsigned char *buf, int count);
+	void (*put_char)(struct tty_struct *tty, unsigned char ch);
+	void (*flush_chars)(struct tty_struct *tty);
+	int  (*write_room)(struct tty_struct *tty);
+	int  (*chars_in_buffer)(struct tty_struct *tty);
+	int  (*ioctl)(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg);
+	void (*set_termios)(struct tty_struct *tty, struct termios * old);
+	void (*throttle)(struct tty_struct * tty);
+	void (*unthrottle)(struct tty_struct * tty);
+	void (*stop)(struct tty_struct *tty);
+	void (*start)(struct tty_struct *tty);
+	void (*hangup)(struct tty_struct *tty);
+	void (*break_ctl)(struct tty_struct *tty, int state);
+	void (*flush_buffer)(struct tty_struct *tty);
+	void (*set_ldisc)(struct tty_struct *tty);
+	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
+	void (*send_xchar)(struct tty_struct *tty, char ch);
+	int (*read_proc)(char *page, char **start, off_t off,
+			  int count, int *eof, void *data);
+	int (*write_proc)(struct file *file, const char __user *buffer,
+			  unsigned long count, void *data);
+	int (*tiocmget)(struct tty_struct *tty, struct file *file);
+	int (*tiocmset)(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear);
+
+	struct list_head tty_drivers;
+};
+
+extern struct list_head tty_drivers;
+
+struct tty_driver *alloc_tty_driver(int lines);
+void put_tty_driver(struct tty_driver *driver);
+void tty_set_operations(struct tty_driver *driver, struct tty_operations *op);
+
+/* tty driver magic number */
+#define TTY_DRIVER_MAGIC		0x5402
+
+/*
+ * tty driver flags
+ * 
+ * TTY_DRIVER_RESET_TERMIOS --- requests the tty layer to reset the
+ * 	termios setting when the last process has closed the device.
+ * 	Used for PTY's, in particular.
+ * 
+ * TTY_DRIVER_REAL_RAW --- if set, indicates that the driver will
+ * 	guarantee never not to set any special character handling
+ * 	flags if ((IGNBRK || (!BRKINT && !PARMRK)) && (IGNPAR ||
+ * 	!INPCK)).  That is, if there is no reason for the driver to
+ * 	send notifications of parity and break characters up to the
+ * 	line driver, it won't do so.  This allows the line driver to
+ *	optimize for this case if this flag is set.  (Note that there
+ * 	is also a promise, if the above case is true, not to signal
+ * 	overruns, either.)
+ *
+ * TTY_DRIVER_NO_DEVFS --- if set, do not create devfs entries. This
+ *	is only used by tty_register_driver().
+ *
+ * TTY_DRIVER_DEVPTS_MEM -- don't use the standard arrays, instead
+ *	use dynamic memory keyed through the devpts filesystem.  This
+ *	is only applicable to the pty driver.
+ */
+#define TTY_DRIVER_INSTALLED		0x0001
+#define TTY_DRIVER_RESET_TERMIOS	0x0002
+#define TTY_DRIVER_REAL_RAW		0x0004
+#define TTY_DRIVER_NO_DEVFS		0x0008
+#define TTY_DRIVER_DEVPTS_MEM		0x0010
+
+/* tty driver types */
+#define TTY_DRIVER_TYPE_SYSTEM		0x0001
+#define TTY_DRIVER_TYPE_CONSOLE		0x0002
+#define TTY_DRIVER_TYPE_SERIAL		0x0003
+#define TTY_DRIVER_TYPE_PTY		0x0004
+#define TTY_DRIVER_TYPE_SCC		0x0005	/* scc driver */
+#define TTY_DRIVER_TYPE_SYSCONS		0x0006
+
+/* system subtypes (magic, used by tty_io.c) */
+#define SYSTEM_TYPE_TTY			0x0001
+#define SYSTEM_TYPE_CONSOLE		0x0002
+#define SYSTEM_TYPE_SYSCONS		0x0003
+#define SYSTEM_TYPE_SYSPTMX		0x0004
+
+/* pty subtypes (magic, used by tty_io.c) */
+#define PTY_TYPE_MASTER			0x0001
+#define PTY_TYPE_SLAVE			0x0002
+
+/* serial subtype definitions */
+#define SERIAL_TYPE_NORMAL	1
+
+#endif /* #ifdef _LINUX_TTY_DRIVER_H */
