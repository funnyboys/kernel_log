commit b4c0353693d22f9dcfa4757262dab0aab8376d19
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 19 11:44:51 2020 -0500

    sanitize handling of nd->last_type, kill LAST_BIND
    
    ->last_type values are set in 3 places: path_init() (sets to LAST_ROOT),
    link_path_walk (LAST_NORM/DOT/DOTDOT) and pick_link (LAST_BIND).
    
    The are checked in walk_component(), lookup_last() and do_last().
    They also get copied to the caller by filename_parentat().  In the last
    3 cases the value is what we had at the return from link_path_walk().
    In case of walk_component() it's either directly downstream from
    assignment in link_path_walk() or, when called by lookup_last(), the
    value we have at the return from link_path_walk().
    
    The value at the entry into link_path_walk() can survive to return only
    if the pathname contains nothing but slashes.  Note that pick_link()
    never returns such - pure jumps are handled directly.  So for the calls
    of link_path_walk() for trailing symlinks it does not matter what value
    had been there at the entry; the value at the return won't depend upon it.
    
    There are 3 call chains that might have pick_link() storing LAST_BIND:
    
    1) pick_link() from step_into() from walk_component() from
    link_path_walk().  In that case we will either be parsing the next
    component immediately after return into link_path_walk(), which will
    overwrite the ->last_type before anyone has a chance to look at it,
    or we'll fail, in which case nobody will be looking at ->last_type at all.
    
    2) pick_link() from step_into() from walk_component() from lookup_last().
    The value is never looked at due to the above; it won't affect the value
    seen at return from any link_path_walk().
    
    3) pick_link() from step_into() from do_last().  Ditto.
    
    In other words, assignemnt in pick_link() is pointless, and so is
    LAST_BIND itself; nothing ever looks at that value.  Kill it off.
    And make link_path_walk() _always_ assign ->last_type - in the only
    case when the value at the entry might survive to the return that value
    is always LAST_ROOT, inherited from path_init().  Move that assignment
    from path_init() into the beginning of link_path_walk(), to consolidate
    the things.
    
    Historical note: LAST_BIND used to be used for the kludge with trailing
    pure jump symlinks (extra iteration through the top-level loop).
    No point keeping it anymore...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d9576a051808..a4bb992623c4 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -15,7 +15,7 @@ enum { MAX_NESTED_LINKS = 8 };
 /*
  * Type of the last component on LOOKUP_PARENT
  */
-enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
+enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT};
 
 /* pathwalk mode */
 #define LOOKUP_FOLLOW		0x0001	/* follow links at the end */

commit 161aff1d93abf0e5b5e9dbca88928998c155f677
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 11 22:52:26 2020 -0500

    LOOKUP_MOUNTPOINT: fold path_mountpointat() into path_lookupat()
    
    New LOOKUP flag, telling path_lookupat() to act as path_mountpointat().
    IOW, traverse mounts at the final point and skip revalidation of the
    location where it ends up.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 0dd980d7318f..d9576a051808 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -23,6 +23,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_AUTOMOUNT	0x0004  /* force terminal automount */
 #define LOOKUP_EMPTY		0x4000	/* accept empty path [user_... only] */
 #define LOOKUP_DOWN		0x8000	/* follow mounts in the starting point */
+#define LOOKUP_MOUNTPOINT	0x0080	/* follow mounts in the end */
 
 #define LOOKUP_REVAL		0x0020	/* tell ->d_revalidate() to trust no cache */
 #define LOOKUP_RCU		0x0040	/* RCU pathwalk mode; semi-internal */
@@ -64,7 +65,6 @@ extern struct dentry *kern_path_create(int, const char *, struct path *, unsigne
 extern struct dentry *user_path_create(int, const char __user *, struct path *, unsigned int);
 extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
-extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
 extern struct dentry *try_lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);

commit 6aee4badd8126f3a2b6d31c5e2db2439d316374f
Merge: 15d663249653 b55eef872a96
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 11:20:24 2020 -0800

    Merge branch 'work.openat2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull openat2 support from Al Viro:
     "This is the openat2() series from Aleksa Sarai.
    
      I'm afraid that the rest of namei stuff will have to wait - it got
      zero review the last time I'd posted #work.namei, and there had been a
      leak in the posted series I'd caught only last weekend. I was going to
      repost it on Monday, but the window opened and the odds of getting any
      review during that... Oh, well.
    
      Anyway, openat2 part should be ready; that _did_ get sane amount of
      review and public testing, so here it comes"
    
    From Aleksa's description of the series:
     "For a very long time, extending openat(2) with new features has been
      incredibly frustrating. This stems from the fact that openat(2) is
      possibly the most famous counter-example to the mantra "don't silently
      accept garbage from userspace" -- it doesn't check whether unknown
      flags are present[1].
    
      This means that (generally) the addition of new flags to openat(2) has
      been fraught with backwards-compatibility issues (O_TMPFILE has to be
      defined as __O_TMPFILE|O_DIRECTORY|[O_RDWR or O_WRONLY] to ensure old
      kernels gave errors, since it's insecure to silently ignore the
      flag[2]). All new security-related flags therefore have a tough road
      to being added to openat(2).
    
      Furthermore, the need for some sort of control over VFS's path
      resolution (to avoid malicious paths resulting in inadvertent
      breakouts) has been a very long-standing desire of many userspace
      applications.
    
      This patchset is a revival of Al Viro's old AT_NO_JUMPS[3] patchset
      (which was a variant of David Drysdale's O_BENEATH patchset[4] which
      was a spin-off of the Capsicum project[5]) with a few additions and
      changes made based on the previous discussion within [6] as well as
      others I felt were useful.
    
      In line with the conclusions of the original discussion of
      AT_NO_JUMPS, the flag has been split up into separate flags. However,
      instead of being an openat(2) flag it is provided through a new
      syscall openat2(2) which provides several other improvements to the
      openat(2) interface (see the patch description for more details). The
      following new LOOKUP_* flags are added:
    
      LOOKUP_NO_XDEV:
    
         Blocks all mountpoint crossings (upwards, downwards, or through
         absolute links). Absolute pathnames alone in openat(2) do not
         trigger this. Magic-link traversal which implies a vfsmount jump is
         also blocked (though magic-link jumps on the same vfsmount are
         permitted).
    
      LOOKUP_NO_MAGICLINKS:
    
         Blocks resolution through /proc/$pid/fd-style links. This is done
         by blocking the usage of nd_jump_link() during resolution in a
         filesystem. The term "magic-links" is used to match with the only
         reference to these links in Documentation/, but I'm happy to change
         the name.
    
         It should be noted that this is different to the scope of
         ~LOOKUP_FOLLOW in that it applies to all path components. However,
         you can do openat2(NO_FOLLOW|NO_MAGICLINKS) on a magic-link and it
         will *not* fail (assuming that no parent component was a
         magic-link), and you will have an fd for the magic-link.
    
         In order to correctly detect magic-links, the introduction of a new
         LOOKUP_MAGICLINK_JUMPED state flag was required.
    
      LOOKUP_BENEATH:
    
         Disallows escapes to outside the starting dirfd's
         tree, using techniques such as ".." or absolute links. Absolute
         paths in openat(2) are also disallowed.
    
         Conceptually this flag is to ensure you "stay below" a certain
         point in the filesystem tree -- but this requires some additional
         to protect against various races that would allow escape using
         "..".
    
         Currently LOOKUP_BENEATH implies LOOKUP_NO_MAGICLINKS, because it
         can trivially beam you around the filesystem (breaking the
         protection). In future, there might be similar safety checks done
         as in LOOKUP_IN_ROOT, but that requires more discussion.
    
      In addition, two new flags are added that expand on the above ideas:
    
      LOOKUP_NO_SYMLINKS:
    
         Does what it says on the tin. No symlink resolution is allowed at
         all, including magic-links. Just as with LOOKUP_NO_MAGICLINKS this
         can still be used with NOFOLLOW to open an fd for the symlink as
         long as no parent path had a symlink component.
    
      LOOKUP_IN_ROOT:
    
         This is an extension of LOOKUP_BENEATH that, rather than blocking
         attempts to move past the root, forces all such movements to be
         scoped to the starting point. This provides chroot(2)-like
         protection but without the cost of a chroot(2) for each filesystem
         operation, as well as being safe against race attacks that
         chroot(2) is not.
    
         If a race is detected (as with LOOKUP_BENEATH) then an error is
         generated, and similar to LOOKUP_BENEATH it is not permitted to
         cross magic-links with LOOKUP_IN_ROOT.
    
         The primary need for this is from container runtimes, which
         currently need to do symlink scoping in userspace[7] when opening
         paths in a potentially malicious container.
    
         There is a long list of CVEs that could have bene mitigated by
         having RESOLVE_THIS_ROOT (such as CVE-2017-1002101,
         CVE-2017-1002102, CVE-2018-15664, and CVE-2019-5736, just to name a
         few).
    
      In order to make all of the above more usable, I'm working on
      libpathrs[8] which is a C-friendly library for safe path resolution.
      It features a userspace-emulated backend if the kernel doesn't support
      openat2(2). Hopefully we can get userspace to switch to using it, and
      thus get openat2(2) support for free once it's ready.
    
      Future work would include implementing things like
      RESOLVE_NO_AUTOMOUNT and possibly a RESOLVE_NO_REMOTE (to allow
      programs to be sure they don't hit DoSes though stale NFS handles)"
    
    * 'work.openat2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      Documentation: path-lookup: include new LOOKUP flags
      selftests: add openat2(2) selftests
      open: introduce openat2(2) syscall
      namei: LOOKUP_{IN_ROOT,BENEATH}: permit limited ".." resolution
      namei: LOOKUP_IN_ROOT: chroot-like scoped resolution
      namei: LOOKUP_BENEATH: O_BENEATH-like scoped resolution
      namei: LOOKUP_NO_XDEV: block mountpoint crossing
      namei: LOOKUP_NO_MAGICLINKS: block magic-link resolution
      namei: LOOKUP_NO_SYMLINKS: block symlink resolution
      namei: allow set_root() to produce errors
      namei: allow nd_jump_link() to produce errors
      nsfs: clean-up ns_get_path() signature to return int
      namei: only return -ECHILD from follow_dotdot_rcu()

commit c64cd6e34ea340adbb2a0a2f99cc884b96dcdca5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 10 17:17:19 2020 -0500

    reimplement path_mountpoint() with less magic
    
    ... and get rid of a bunch of bugs in it.  Background:
    the reason for path_mountpoint() is that umount() really doesn't
    want attempts to revalidate the root of what it's trying to umount.
    The thing we want to avoid actually happen from complete_walk();
    solution was to do something parallel to normal path_lookupat()
    and it both went overboard and got the boilerplate subtly
    (and not so subtly) wrong.
    
    A better solution is to do pretty much what the normal path_lookupat()
    does, but instead of complete_walk() do unlazy_walk().  All it takes
    to avoid that ->d_weak_revalidate() call...  mountpoint_last() goes
    away, along with everything it got wrong, and so does the magic around
    LOOKUP_NO_REVAL.
    
    Another source of bugs is that when we traverse mounts at the final
    location (and we need to do that - umount . expects to get whatever's
    overmounting ., if any, out of the lookup) we really ought to take
    care of ->d_manage() - as it is, manual umount of autofs automount
    in progress can lead to unpleasant surprises for the daemon.  Easily
    solved by using handle_lookup_down() instead of follow_mount().
    
    Tested-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 7fe7b87a3ded..07bfb0874033 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -34,7 +34,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
 /* internal use only */
 #define LOOKUP_PARENT		0x0010
-#define LOOKUP_NO_REVAL		0x0080
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_ROOT_GRABBED	0x0008

commit 8db52c7e7ee1bd861b6096fcafc0fe7d0f24a994
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:34 2019 +1100

    namei: LOOKUP_IN_ROOT: chroot-like scoped resolution
    
    /* Background. */
    Container runtimes or other administrative management processes will
    often interact with root filesystems while in the host mount namespace,
    because the cost of doing a chroot(2) on every operation is too
    prohibitive (especially in Go, which cannot safely use vfork). However,
    a malicious program can trick the management process into doing
    operations on files outside of the root filesystem through careful
    crafting of symlinks.
    
    Most programs that need this feature have attempted to make this process
    safe, by doing all of the path resolution in userspace (with symlinks
    being scoped to the root of the malicious root filesystem).
    Unfortunately, this method is prone to foot-guns and usually such
    implementations have subtle security bugs.
    
    Thus, what userspace needs is a way to resolve a path as though it were
    in a chroot(2) -- with all absolute symlinks being resolved relative to
    the dirfd root (and ".." components being stuck under the dirfd root).
    It is much simpler and more straight-forward to provide this
    functionality in-kernel (because it can be done far more cheaply and
    correctly).
    
    More classical applications that also have this problem (which have
    their own potentially buggy userspace path sanitisation code) include
    web servers, archive extraction tools, network file servers, and so on.
    
    /* Userspace API. */
    LOOKUP_IN_ROOT will be exposed to userspace through openat2(2).
    
    /* Semantics. */
    Unlike most other LOOKUP flags (most notably LOOKUP_FOLLOW),
    LOOKUP_IN_ROOT applies to all components of the path.
    
    With LOOKUP_IN_ROOT, any path component which attempts to cross the
    starting point of the pathname lookup (the dirfd passed to openat) will
    remain at the starting point. Thus, all absolute paths and symlinks will
    be scoped within the starting point.
    
    There is a slight change in behaviour regarding pathnames -- if the
    pathname is absolute then the dirfd is still used as the root of
    resolution of LOOKUP_IN_ROOT is specified (this is to avoid obvious
    foot-guns, at the cost of a minor API inconsistency).
    
    As with LOOKUP_BENEATH, Jann's security concern about ".."[1] applies to
    LOOKUP_IN_ROOT -- therefore ".." resolution is blocked. This restriction
    will be lifted in a future patch, but requires more work to ensure that
    permitting ".." is done safely.
    
    Magic-link jumps are also blocked, because they can beam the path lookup
    across the starting point. It would be possible to detect and block
    only the "bad" crossings with path_is_under() checks, but it's unclear
    whether it makes sense to permit magic-links at all. However, userspace
    is recommended to pass LOOKUP_NO_MAGICLINKS if they want to ensure that
    magic-link crossing is entirely disabled.
    
    /* Testing. */
    LOOKUP_IN_ROOT is tested as part of the openat2(2) selftests.
    
    [1]: https://lore.kernel.org/lkml/CAG48ez1jzNvxB+bfOBnERFGp=oMM0vHWuLD6EULmne3R6xa53w@mail.gmail.com/
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d2a98083be77..4e77068f7a1a 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -45,8 +45,9 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_NO_MAGICLINKS	0x020000 /* No nd_jump_link() crossing. */
 #define LOOKUP_NO_XDEV		0x040000 /* No mountpoint crossing. */
 #define LOOKUP_BENEATH		0x080000 /* No escaping from starting point. */
+#define LOOKUP_IN_ROOT		0x100000 /* Treat dirfd as fs root. */
 /* LOOKUP_* flags which do scope-related checks based on the dirfd. */
-#define LOOKUP_IS_SCOPED LOOKUP_BENEATH
+#define LOOKUP_IS_SCOPED (LOOKUP_BENEATH | LOOKUP_IN_ROOT)
 
 extern int path_pts(struct path *path);
 

commit adb21d2b526f7f196b2f3fdca97d80ba05dd14a0
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:33 2019 +1100

    namei: LOOKUP_BENEATH: O_BENEATH-like scoped resolution
    
    /* Background. */
    There are many circumstances when userspace wants to resolve a path and
    ensure that it doesn't go outside of a particular root directory during
    resolution. Obvious examples include archive extraction tools, as well as
    other security-conscious userspace programs. FreeBSD spun out O_BENEATH
    from their Capsicum project[1,2], so it also seems reasonable to
    implement similar functionality for Linux.
    
    This is part of a refresh of Al's AT_NO_JUMPS patchset[3] (which was a
    variation on David Drysdale's O_BENEATH patchset[4], which in turn was
    based on the Capsicum project[5]).
    
    /* Userspace API. */
    LOOKUP_BENEATH will be exposed to userspace through openat2(2).
    
    /* Semantics. */
    Unlike most other LOOKUP flags (most notably LOOKUP_FOLLOW),
    LOOKUP_BENEATH applies to all components of the path.
    
    With LOOKUP_BENEATH, any path component which attempts to "escape" the
    starting point of the filesystem lookup (the dirfd passed to openat)
    will yield -EXDEV. Thus, all absolute paths and symlinks are disallowed.
    
    Due to a security concern brought up by Jann[6], any ".." path
    components are also blocked. This restriction will be lifted in a future
    patch, but requires more work to ensure that permitting ".." is done
    safely.
    
    Magic-link jumps are also blocked, because they can beam the path lookup
    across the starting point. It would be possible to detect and block
    only the "bad" crossings with path_is_under() checks, but it's unclear
    whether it makes sense to permit magic-links at all. However, userspace
    is recommended to pass LOOKUP_NO_MAGICLINKS if they want to ensure that
    magic-link crossing is entirely disabled.
    
    /* Testing. */
    LOOKUP_BENEATH is tested as part of the openat2(2) selftests.
    
    [1]: https://reviews.freebsd.org/D2808
    [2]: https://reviews.freebsd.org/D17547
    [3]: https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/
    [4]: https://lore.kernel.org/lkml/1415094884-18349-1-git-send-email-drysdale@google.com/
    [5]: https://lore.kernel.org/lkml/1404124096-21445-1-git-send-email-drysdale@google.com/
    [6]: https://lore.kernel.org/lkml/CAG48ez1jzNvxB+bfOBnERFGp=oMM0vHWuLD6EULmne3R6xa53w@mail.gmail.com/
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Suggested-by: David Drysdale <drysdale@google.com>
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index edb4562b5c4e..d2a98083be77 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -2,6 +2,7 @@
 #ifndef _LINUX_NAMEI_H
 #define _LINUX_NAMEI_H
 
+#include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/path.h>
 #include <linux/fcntl.h>
@@ -43,6 +44,9 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_NO_SYMLINKS	0x010000 /* No symlink crossing. */
 #define LOOKUP_NO_MAGICLINKS	0x020000 /* No nd_jump_link() crossing. */
 #define LOOKUP_NO_XDEV		0x040000 /* No mountpoint crossing. */
+#define LOOKUP_BENEATH		0x080000 /* No escaping from starting point. */
+/* LOOKUP_* flags which do scope-related checks based on the dirfd. */
+#define LOOKUP_IS_SCOPED LOOKUP_BENEATH
 
 extern int path_pts(struct path *path);
 

commit 72ba29297e1439efaa54d9125b866ae9d15df339
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:32 2019 +1100

    namei: LOOKUP_NO_XDEV: block mountpoint crossing
    
    /* Background. */
    The need to contain path operations within a mountpoint has been a
    long-standing usecase that userspace has historically implemented
    manually with liberal usage of stat(). find, rsync, tar and
    many other programs implement these semantics -- but it'd be much
    simpler to have a fool-proof way of refusing to open a path if it
    crosses a mountpoint.
    
    This is part of a refresh of Al's AT_NO_JUMPS patchset[1] (which was a
    variation on David Drysdale's O_BENEATH patchset[2], which in turn was
    based on the Capsicum project[3]).
    
    /* Userspace API. */
    LOOKUP_NO_XDEV will be exposed to userspace through openat2(2).
    
    /* Semantics. */
    Unlike most other LOOKUP flags (most notably LOOKUP_FOLLOW),
    LOOKUP_NO_XDEV applies to all components of the path.
    
    With LOOKUP_NO_XDEV, any path component which crosses a mount-point
    during path resolution (including "..") will yield an -EXDEV. Absolute
    paths, absolute symlinks, and magic-links will only yield an -EXDEV if
    the jump involved changing mount-points.
    
    /* Testing. */
    LOOKUP_NO_XDEV is tested as part of the openat2(2) selftests.
    
    [1]: https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/
    [2]: https://lore.kernel.org/lkml/1415094884-18349-1-git-send-email-drysdale@google.com/
    [3]: https://lore.kernel.org/lkml/1404124096-21445-1-git-send-email-drysdale@google.com/
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Suggested-by: David Drysdale <drysdale@google.com>
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index f8acec81cf03..edb4562b5c4e 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -42,6 +42,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 /* Scoping flags for lookup. */
 #define LOOKUP_NO_SYMLINKS	0x010000 /* No symlink crossing. */
 #define LOOKUP_NO_MAGICLINKS	0x020000 /* No nd_jump_link() crossing. */
+#define LOOKUP_NO_XDEV		0x040000 /* No mountpoint crossing. */
 
 extern int path_pts(struct path *path);
 

commit 4b99d4996979d582859c5a49072e92de124bf691
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:31 2019 +1100

    namei: LOOKUP_NO_MAGICLINKS: block magic-link resolution
    
    /* Background. */
    There has always been a special class of symlink-like objects in procfs
    (and a few other pseudo-filesystems) which allow for non-lexical
    resolution of paths using nd_jump_link(). These "magic-links" do not
    follow traditional mount namespace boundaries, and have been used
    consistently in container escape attacks because they can be used to
    trick unsuspecting privileged processes into resolving unexpected paths.
    
    It is also non-trivial for userspace to unambiguously avoid resolving
    magic-links, because they do not have a reliable indication that they
    are a magic-link (in order to verify them you'd have to manually open
    the path given by readlink(2) and then verify that the two file
    descriptors reference the same underlying file, which is plagued with
    possible race conditions or supplementary attack scenarios).
    
    It would therefore be very helpful for userspace to be able to avoid
    these symlinks easily, thus hopefully removing a tool from attackers'
    toolboxes.
    
    This is part of a refresh of Al's AT_NO_JUMPS patchset[1] (which was a
    variation on David Drysdale's O_BENEATH patchset[2], which in turn was
    based on the Capsicum project[3]).
    
    /* Userspace API. */
    LOOKUP_NO_MAGICLINKS will be exposed to userspace through openat2(2).
    
    /* Semantics. */
    Unlike most other LOOKUP flags (most notably LOOKUP_FOLLOW),
    LOOKUP_NO_MAGICLINKS applies to all components of the path.
    
    With LOOKUP_NO_MAGICLINKS, any magic-link path component encountered
    during path resolution will yield -ELOOP. The handling of ~LOOKUP_FOLLOW
    for a trailing magic-link is identical to LOOKUP_NO_SYMLINKS.
    
    LOOKUP_NO_SYMLINKS implies LOOKUP_NO_MAGICLINKS.
    
    /* Testing. */
    LOOKUP_NO_MAGICLINKS is tested as part of the openat2(2) selftests.
    
    [1]: https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/
    [2]: https://lore.kernel.org/lkml/1415094884-18349-1-git-send-email-drysdale@google.com/
    [3]: https://lore.kernel.org/lkml/1404124096-21445-1-git-send-email-drysdale@google.com/
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Suggested-by: David Drysdale <drysdale@google.com>
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index c42a1924ad67..f8acec81cf03 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -41,6 +41,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
 /* Scoping flags for lookup. */
 #define LOOKUP_NO_SYMLINKS	0x010000 /* No symlink crossing. */
+#define LOOKUP_NO_MAGICLINKS	0x020000 /* No nd_jump_link() crossing. */
 
 extern int path_pts(struct path *path);
 

commit 278121417a72d87fb29dd8c48801f80821e8f75a
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:30 2019 +1100

    namei: LOOKUP_NO_SYMLINKS: block symlink resolution
    
    /* Background. */
    Userspace cannot easily resolve a path without resolving symlinks, and
    would have to manually resolve each path component with O_PATH and
    O_NOFOLLOW. This is clearly inefficient, and can be fairly easy to screw
    up (resulting in possible security bugs). Linus has mentioned that Git
    has a particular need for this kind of flag[1]. It also resolves a
    fairly long-standing perceived deficiency in O_NOFOLLOw -- that it only
    blocks the opening of trailing symlinks.
    
    This is part of a refresh of Al's AT_NO_JUMPS patchset[2] (which was a
    variation on David Drysdale's O_BENEATH patchset[3], which in turn was
    based on the Capsicum project[4]).
    
    /* Userspace API. */
    LOOKUP_NO_SYMLINKS will be exposed to userspace through openat2(2).
    
    /* Semantics. */
    Unlike most other LOOKUP flags (most notably LOOKUP_FOLLOW),
    LOOKUP_NO_SYMLINKS applies to all components of the path.
    
    With LOOKUP_NO_SYMLINKS, any symlink path component encountered during
    path resolution will yield -ELOOP. If the trailing component is a
    symlink (and no other components were symlinks), then O_PATH|O_NOFOLLOW
    will not error out and will instead provide a handle to the trailing
    symlink -- without resolving it.
    
    /* Testing. */
    LOOKUP_NO_SYMLINKS is tested as part of the openat2(2) selftests.
    
    [1]: https://lore.kernel.org/lkml/CA+55aFyOKM7DW7+0sdDFKdZFXgptb5r1id9=Wvhd8AgSP7qjwQ@mail.gmail.com/
    [2]: https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/
    [3]: https://lore.kernel.org/lkml/1415094884-18349-1-git-send-email-drysdale@google.com/
    [4]: https://lore.kernel.org/lkml/1404124096-21445-1-git-send-email-drysdale@google.com/
    
    Cc: Christian Brauner <christian.brauner@ubuntu.com>
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index b2479cc119c6..c42a1924ad67 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -39,6 +39,9 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_ROOT_GRABBED	0x0008
 
+/* Scoping flags for lookup. */
+#define LOOKUP_NO_SYMLINKS	0x010000 /* No symlink crossing. */
+
 extern int path_pts(struct path *path);
 
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);

commit 1bc82070fa2763bdca626fa8bde72b35f11e8960
Author: Aleksa Sarai <cyphar@cyphar.com>
Date:   Sat Dec 7 01:13:28 2019 +1100

    namei: allow nd_jump_link() to produce errors
    
    In preparation for LOOKUP_NO_MAGICLINKS, it's necessary to add the
    ability for nd_jump_link() to return an error which the corresponding
    get_link() caller must propogate back up to the VFS.
    
    Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Aleksa Sarai <cyphar@cyphar.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 7fe7b87a3ded..b2479cc119c6 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -69,7 +69,7 @@ extern int follow_up(struct path *);
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
-extern void nd_jump_link(struct path *path);
+extern int __must_check nd_jump_link(struct path *path);
 
 static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
 {

commit 6c2d4798a8d16cf4f3a28c3cd4af4f1dcbbb4d04
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 31 01:21:58 2019 -0400

    new helper: lookup_positive_unlocked()
    
    Most of the callers of lookup_one_len_unlocked() treat negatives are
    ERR_PTR(-ENOENT).  Provide a helper that would do just that.  Note
    that a pinned positive dentry remains positive - it's ->d_inode is
    stable, etc.; a pinned _negative_ dentry can become positive at any
    point as long as you are not holding its parent at least shared.
    So using lookup_one_len_unlocked() needs to be careful;
    lookup_positive_unlocked() is safer and that's what the callers
    end up open-coding anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 397a08ade6a2..7fe7b87a3ded 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -60,6 +60,7 @@ extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 extern struct dentry *try_lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
+extern struct dentry *lookup_positive_unlocked(const char *, struct dentry *, int);
 
 extern int follow_down_one(struct path *);
 extern int follow_down(struct path *);

commit 84a2bd39405ffd5fa6d6d77e408c5b9210da98de
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 16 21:20:17 2019 -0400

    fs/namei.c: keep track of nd->root refcount status
    
    The rules for nd->root are messy:
            * if we have LOOKUP_ROOT, it doesn't contribute to refcounts
            * if we have LOOKUP_RCU, it doesn't contribute to refcounts
            * if nd->root.mnt is NULL, it doesn't contribute to refcounts
            * otherwise it does contribute
    
    terminate_walk() needs to drop the references if they are contributing.
    So everything else should be careful not to confuse it, leading to
    rather convoluted code.
    
    It's easier to keep track of whether we'd grabbed the reference(s)
    explicitly.  Use a new flag for that.  Don't bother with zeroing
    nd->root.mnt on unlazy failures and in terminate_walk - it's not
    needed anymore (terminate_walk() won't care and the next path_init()
    will zero nd->root in !LOOKUP_ROOT case anyway).
    
    Resulting rules for nd->root refcounts are much simpler: they are
    contributing iff LOOKUP_ROOT_GRABBED is set in nd->flags.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index b7993980516e..397a08ade6a2 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -37,6 +37,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_NO_REVAL		0x0080
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
+#define LOOKUP_ROOT_GRABBED	0x0008
 
 extern int path_pts(struct path *path);
 

commit ce6595a28a15c874aee374757dcd08f537d7b24d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 14 16:42:44 2019 -0400

    kill the last users of user_{path,lpath,path_dir}()
    
    old wrappers with few callers remaining; put them out of their misery...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 1a504fc7994f..b7993980516e 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -48,22 +48,6 @@ static inline int user_path_at(int dfd, const char __user *name, unsigned flags,
 	return user_path_at_empty(dfd, name, flags, path, NULL);
 }
 
-static inline int user_path(const char __user *name, struct path *path)
-{
-	return user_path_at_empty(AT_FDCWD, name, LOOKUP_FOLLOW, path, NULL);
-}
-
-static inline int user_lpath(const char __user *name, struct path *path)
-{
-	return user_path_at_empty(AT_FDCWD, name, 0, path, NULL);
-}
-
-static inline int user_path_dir(const char __user *name, struct path *path)
-{
-	return user_path_at_empty(AT_FDCWD, name,
-				  LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path, NULL);
-}
-
 extern int kern_path(const char *, unsigned, struct path *);
 
 extern struct dentry *kern_path_create(int, const char *, struct path *, unsigned int);

commit 6b61aed06a3b0eb8e8d49142ddd1e101a064444d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 14 14:00:23 2019 -0400

    namei.h: get the comments on LOOKUP_... in sync with reality
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index ac665cbc659f..1a504fc7994f 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -16,37 +16,27 @@ enum { MAX_NESTED_LINKS = 8 };
  */
 enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
-/*
- * The bitmask for a lookup event:
- *  - follow links at the end
- *  - require a directory
- *  - ending slashes ok even for nonexistent files
- *  - internal "there are more path components" flag
- *  - dentry cache is untrusted; force a real lookup
- *  - suppress terminal automount
- *  - skip revalidation
- */
-#define LOOKUP_FOLLOW		0x0001
-#define LOOKUP_DIRECTORY	0x0002
-#define LOOKUP_AUTOMOUNT	0x0004
-
+/* pathwalk mode */
+#define LOOKUP_FOLLOW		0x0001	/* follow links at the end */
+#define LOOKUP_DIRECTORY	0x0002	/* require a directory */
+#define LOOKUP_AUTOMOUNT	0x0004  /* force terminal automount */
+#define LOOKUP_EMPTY		0x4000	/* accept empty path [user_... only] */
+#define LOOKUP_DOWN		0x8000	/* follow mounts in the starting point */
+
+#define LOOKUP_REVAL		0x0020	/* tell ->d_revalidate() to trust no cache */
+#define LOOKUP_RCU		0x0040	/* RCU pathwalk mode; semi-internal */
+
+/* These tell filesystem methods that we are dealing with the final component... */
+#define LOOKUP_OPEN		0x0100	/* ... in open */
+#define LOOKUP_CREATE		0x0200	/* ... in object creation */
+#define LOOKUP_EXCL		0x0400	/* ... in exclusive creation */
+#define LOOKUP_RENAME_TARGET	0x0800	/* ... in destination of rename() */
+
+/* internal use only */
 #define LOOKUP_PARENT		0x0010
-#define LOOKUP_REVAL		0x0020
-#define LOOKUP_RCU		0x0040
 #define LOOKUP_NO_REVAL		0x0080
-
-/*
- * Intent data
- */
-#define LOOKUP_OPEN		0x0100
-#define LOOKUP_CREATE		0x0200
-#define LOOKUP_EXCL		0x0400
-#define LOOKUP_RENAME_TARGET	0x0800
-
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
-#define LOOKUP_EMPTY		0x4000
-#define LOOKUP_DOWN		0x8000
 
 extern int path_pts(struct path *path);
 

commit fbb7d9d56d167247f2eb7261038385cab1073c37
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 14 13:24:54 2019 -0400

    kill LOOKUP_NO_EVAL, don't bother including namei.h from audit.h
    
    The former has no users left; the latter was only to get LOOKUP_...
    values to remapper in audit_inode() and that's an ex-parrot now.
    
    All places that use symbols from namei.h include it either directly
    or (in a few cases) via a local header, like fs/autofs/autofs_i.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 9138b4471dbf..ac665cbc659f 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -25,7 +25,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - dentry cache is untrusted; force a real lookup
  *  - suppress terminal automount
  *  - skip revalidation
- *  - don't fetch xattrs on audit_inode
  */
 #define LOOKUP_FOLLOW		0x0001
 #define LOOKUP_DIRECTORY	0x0002
@@ -35,7 +34,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_REVAL		0x0020
 #define LOOKUP_RCU		0x0040
 #define LOOKUP_NO_REVAL		0x0080
-#define LOOKUP_NO_EVAL		0x0100
 
 /*
  * Intent data

commit 57d4657716aca81ef4d7ec23e8123d26e3d28954
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Jan 23 13:35:00 2019 -0500

    audit: ignore fcaps on umount
    
    Don't fetch fcaps when umount2 is called to avoid a process hang while
    it waits for the missing resource to (possibly never) re-appear.
    
    Note the comment above user_path_mountpoint_at():
     * A umount is a special case for path walking. We're not actually interested
     * in the inode in this situation, and ESTALE errors can be a problem.  We
     * simply want track down the dentry and vfsmount attached at the mountpoint
     * and avoid revalidating the last component.
    
    This can happen on ceph, cifs, 9p, lustre, fuse (gluster) or NFS.
    
    Please see the github issue tracker
    https://github.com/linux-audit/audit-kernel/issues/100
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in audit_log_fcaps()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index a78606e8e3df..9138b4471dbf 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -24,6 +24,8 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - internal "there are more path components" flag
  *  - dentry cache is untrusted; force a real lookup
  *  - suppress terminal automount
+ *  - skip revalidation
+ *  - don't fetch xattrs on audit_inode
  */
 #define LOOKUP_FOLLOW		0x0001
 #define LOOKUP_DIRECTORY	0x0002
@@ -33,6 +35,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_REVAL		0x0020
 #define LOOKUP_RCU		0x0040
 #define LOOKUP_NO_REVAL		0x0080
+#define LOOKUP_NO_EVAL		0x0100
 
 /*
  * Intent data

commit 0da0b7fd73e4f20e1a987dfade0b36bb4813cf10
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 15 15:19:22 2018 +0100

    afs: Display manually added cells in dynamic root mount
    
    Alter the dynroot mount so that cells created by manipulation of
    /proc/fs/afs/cells and /proc/fs/afs/rootcell and by specification of a root
    cell as a module parameter will cause directories for those cells to be
    created in the dynamic root superblock for the network namespace[*].
    
    To this end:
    
     (1) Only one dynamic root superblock is now created per network namespace
         and this is shared between all attempts to mount it.  This makes it
         easier to find the superblock to modify.
    
     (2) When a dynamic root superblock is created, the list of cells is walked
         and directories created for each cell already defined.
    
     (3) When a new cell is added, if a dynamic root superblock exists, a
         directory is created for it.
    
     (4) When a cell is destroyed, the directory is removed.
    
     (5) These directories are created by calling lookup_one_len() on the root
         dir which automatically creates them if they don't exist.
    
    [*] Inasmuch as network namespaces are currently supported here.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index a982bb7cd480..a78606e8e3df 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -81,6 +81,7 @@ extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
 extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
+extern struct dentry *try_lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 8b4794e83196..a982bb7cd480 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_NAMEI_H
 #define _LINUX_NAMEI_H
 

commit 4f757f3cbf54edef7b75c68d6d6d2f1a0ca08d2e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 15 17:31:22 2017 -0400

    make sure that mntns_install() doesn't end up with referral for root
    
    new flag: LOOKUP_DOWN.  If the starting point is overmounted, cross
    into whatever's mounted on top, triggering referrals et.al.
    
    Use that instead of follow_down_one() loop in mntns_install(), handle
    errors properly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index f29abda31e6d..8b4794e83196 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -44,6 +44,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_EMPTY		0x4000
+#define LOOKUP_DOWN		0x8000
 
 extern int path_pts(struct path *path);
 

commit 20d00ee829428ea6aab77fa3acca048a6f57d3bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 12:17:52 2016 -0700

    Revert "vfs: add lookup_hash() helper"
    
    This reverts commit 3c9fe8cdff1b889a059a30d22f130372f2b3885f.
    
    As Miklos points out in commit c1b2cc1a765a, the "lookup_hash()" helper
    is now unused, and in fact, with the hash salting changes, since the
    hash of a dentry name now depends on the directory dentry it is in, the
    helper function isn't even really likely to be useful.
    
    So rather than keep it around in case somebody else might end up finding
    a use for it, let's just remove the helper and not trick people into
    thinking it might be a useful thing.
    
    For example, I had obviously completely missed how the helper didn't
    follow the normal dentry hashing patterns, and how the hash salting
    patch broke overlayfs.  Things would quietly build and look sane, but
    not work.
    
    Suggested-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d3d0398f2a1b..f29abda31e6d 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -81,8 +81,6 @@ extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
-struct qstr;
-extern struct dentry *lookup_hash(const struct qstr *, struct dentry *);
 
 extern int follow_down_one(struct path *);
 extern int follow_down(struct path *);

commit eedf265aa003b4781de24cfed40a655a664457e6
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 2 10:29:47 2016 -0500

    devpts: Make each mount of devpts an independent filesystem.
    
    The /dev/ptmx device node is changed to lookup the directory entry "pts"
    in the same directory as the /dev/ptmx device node was opened in.  If
    there is a "pts" entry and that entry is a devpts filesystem /dev/ptmx
    uses that filesystem.  Otherwise the open of /dev/ptmx fails.
    
    The DEVPTS_MULTIPLE_INSTANCES configuration option is removed, so that
    userspace can now safely depend on each mount of devpts creating a new
    instance of the filesystem.
    
    Each mount of devpts is now a separate and equal filesystem.
    
    Reserved ttys are now available to all instances of devpts where the
    mounter is in the initial mount namespace.
    
    A new vfs helper path_pts is introduced that finds a directory entry
    named "pts" in the directory of the passed in path, and changes the
    passed in path to point to it.  The helper path_pts uses a function
    path_parent_directory that was factored out of follow_dotdot.
    
    In the implementation of devpts:
     - devpts_mnt is killed as it is no longer meaningful if all mounts of
       devpts are equal.
     - pts_sb_from_inode is replaced by just inode->i_sb as all cached
       inodes in the tty layer are now from the devpts filesystem.
     - devpts_add_ref is rolled into the new function devpts_ptmx.  And the
       unnecessary inode hold is removed.
     - devpts_del_ref is renamed devpts_release and reduced to just a
       deacrivate_super.
     - The newinstance mount option continues to be accepted but is now
       ignored.
    
    In devpts_fs.h definitions for when !CONFIG_UNIX98_PTYS are removed as
    they are never used.
    
    Documentation/filesystems/devices.txt is updated to describe the current
    situation.
    
    This has been verified to work properly on openwrt-15.05, centos5,
    centos6, centos7, debian-6.0.2, debian-7.9, debian-8.2, ubuntu-14.04.3,
    ubuntu-15.10, fedora23, magia-5, mint-17.3, opensuse-42.1,
    slackware-14.1, gentoo-20151225 (13.0?), archlinux-2015-12-01.  With the
    caveat that on centos6 and on slackware-14.1 that there wind up being
    two instances of the devpts filesystem mounted on /dev/pts, the lower
    copy does not end up getting used.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
    Cc: Jann Horn <jann@thejh.net>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Florian Weimer <fw@deneb.enyo.de>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index ec5ec2818a28..d3d0398f2a1b 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -45,6 +45,8 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_EMPTY		0x4000
 
+extern int path_pts(struct path *path);
+
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
 
 static inline int user_path_at(int dfd, const char __user *name, unsigned flags,

commit 3c9fe8cdff1b889a059a30d22f130372f2b3885f
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add lookup_hash() helper
    
    Overlayfs needs lookup without inode_permission() and already has the name
    hash (in form of dentry->d_name on overlayfs dentry).  It also doesn't
    support filesystems with d_op->d_hash() so basically it only needs
    the actual hashed lookup from lookup_one_len_unlocked()
    
    So add a new helper that does unlocked lookup of a hashed name.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 77d01700daf7..ec5ec2818a28 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -79,6 +79,8 @@ extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
+struct qstr;
+extern struct dentry *lookup_hash(const struct qstr *, struct dentry *);
 
 extern int follow_down_one(struct path *);
 extern int follow_down(struct path *);

commit 949a852e46dda07caaa0ff02e181f55d24e3ebf8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 6 14:20:52 2016 -0500

    namei: teach lookup_slow() to skip revalidate
    
    ... and make mountpoint_last() use it.  That makes all
    candidates for lookup with parent locked shared go
    through lookup_slow().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d0f25d81b46a..77d01700daf7 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -31,6 +31,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_PARENT		0x0010
 #define LOOKUP_REVAL		0x0020
 #define LOOKUP_RCU		0x0040
+#define LOOKUP_NO_REVAL		0x0080
 
 /*
  * Intent data

commit bbddca8e8fac07ece3938e03526b5d00fa791a4c
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jan 7 16:08:20 2016 -0500

    nfsd: don't hold i_mutex over userspace upcalls
    
    We need information about exports when crossing mountpoints during
    lookup or NFSv4 readdir.  If we don't already have that information
    cached, we may have to ask (and wait for) rpc.mountd.
    
    In both cases we currently hold the i_mutex on the parent of the
    directory we're asking rpc.mountd about.  We've seen situations where
    rpc.mountd performs some operation on that directory that tries to take
    the i_mutex again, resulting in deadlock.
    
    With some care, we may be able to avoid that in rpc.mountd.  But it
    seems better just to avoid holding a mutex while waiting on userspace.
    
    It appears that lookup_one_len is pretty much the only operation that
    needs the i_mutex.  So we could just drop the i_mutex elsewhere and do
    something like
    
            mutex_lock()
            lookup_one_len()
            mutex_unlock()
    
    In many cases though the lookup would have been cached and not required
    the i_mutex, so it's more efficient to create a lookup_one_len() variant
    that only takes the i_mutex when necessary.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d8c6334cd150..d0f25d81b46a 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -77,6 +77,7 @@ extern struct dentry *kern_path_locked(const char *, struct path *);
 extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
+extern struct dentry *lookup_one_len_unlocked(const char *, struct dentry *, int);
 
 extern int follow_down_one(struct path *);
 extern int follow_down(struct path *);

commit b853a16176cf3e02c57e215743015614152c2428
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 13 09:12:02 2015 -0400

    turn user_{path_at,path,lpath,path_dir}() into static inlines
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 1208e489f83e..d8c6334cd150 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -1,12 +1,10 @@
 #ifndef _LINUX_NAMEI_H
 #define _LINUX_NAMEI_H
 
-#include <linux/dcache.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
+#include <linux/kernel.h>
 #include <linux/path.h>
-
-struct vfsmount;
+#include <linux/fcntl.h>
+#include <linux/errno.h>
 
 enum { MAX_NESTED_LINKS = 8 };
 
@@ -46,13 +44,29 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_ROOT		0x2000
 #define LOOKUP_EMPTY		0x4000
 
-extern int user_path_at(int, const char __user *, unsigned, struct path *);
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
 
-#define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)
-#define user_lpath(name, path) user_path_at(AT_FDCWD, name, 0, path)
-#define user_path_dir(name, path) \
-	user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path)
+static inline int user_path_at(int dfd, const char __user *name, unsigned flags,
+		 struct path *path)
+{
+	return user_path_at_empty(dfd, name, flags, path, NULL);
+}
+
+static inline int user_path(const char __user *name, struct path *path)
+{
+	return user_path_at_empty(AT_FDCWD, name, LOOKUP_FOLLOW, path, NULL);
+}
+
+static inline int user_lpath(const char __user *name, struct path *path)
+{
+	return user_path_at_empty(AT_FDCWD, name, 0, path, NULL);
+}
+
+static inline int user_path_dir(const char __user *name, struct path *path)
+{
+	return user_path_at_empty(AT_FDCWD, name,
+				  LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path, NULL);
+}
 
 extern int kern_path(const char *, unsigned, struct path *);
 

commit 89076bc31950eee576ecc06460c23466e2d50939
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue May 12 08:29:38 2015 -0400

    get rid of assorted nameidata-related debris
    
    pointless forward declarations, stale comments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d756304aa09b..1208e489f83e 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -7,7 +7,6 @@
 #include <linux/path.h>
 
 struct vfsmount;
-struct nameidata;
 
 enum { MAX_NESTED_LINKS = 8 };
 

commit 6e77137b363b8d866ac29c5a0c95e953614fb2d8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 13:37:52 2015 -0400

    don't pass nameidata to ->follow_link()
    
    its only use is getting passed to nd_jump_link(), which can obtain
    it from current->nameidata
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 3a6cc9651712..d756304aa09b 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,7 +72,7 @@ extern int follow_up(struct path *);
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
-extern void nd_jump_link(struct nameidata *nd, struct path *path);
+extern void nd_jump_link(struct path *path);
 
 static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
 {

commit 894bc8c4662ba9daceafe943a5ba0dd407da5cd3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 07:16:16 2015 -0400

    namei: remove restrictions on nesting depth
    
    The only restriction is that on the total amount of symlinks
    crossed; how they are nested does not matter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index a5d5bed2c0e1..3a6cc9651712 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -11,6 +11,8 @@ struct nameidata;
 
 enum { MAX_NESTED_LINKS = 8 };
 
+#define MAXSYMLINKS 40
+
 /*
  * Type of the last component on LOOKUP_PARENT
  */

commit 680baacbca69d18a6d7315374ad83d05ac9c0977
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 13:32:22 2015 -0400

    new ->follow_link() and ->put_link() calling conventions
    
    a) instead of storing the symlink body (via nd_set_link()) and returning
    an opaque pointer later passed to ->put_link(), ->follow_link() _stores_
    that opaque pointer (into void * passed by address by caller) and returns
    the symlink body.  Returning ERR_PTR() on error, NULL on jump (procfs magic
    symlinks) and pointer to symlink body for normal symlinks.  Stored pointer
    is ignored in all cases except the last one.
    
    Storing NULL for opaque pointer (or not storing it at all) means no call
    of ->put_link().
    
    b) the body used to be passed to ->put_link() implicitly (via nameidata).
    Now only the opaque pointer is.  In the cases when we used the symlink body
    to free stuff, ->follow_link() now should store it as opaque pointer in addition
    to returning it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index c8990779f0c3..a5d5bed2c0e1 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -71,8 +71,6 @@ extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
 extern void nd_jump_link(struct nameidata *nd, struct path *path);
-extern void nd_set_link(struct nameidata *nd, char *path);
-extern char *nd_get_link(struct nameidata *nd);
 
 static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
 {

commit 1f55a6ec940fb45e3edaa52b6e9fc40cf8e18dcb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Nov 1 19:30:41 2014 -0400

    make nameidata completely opaque outside of fs/namei.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 492de72560fa..c8990779f0c3 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -7,21 +7,10 @@
 #include <linux/path.h>
 
 struct vfsmount;
+struct nameidata;
 
 enum { MAX_NESTED_LINKS = 8 };
 
-struct nameidata {
-	struct path	path;
-	struct qstr	last;
-	struct path	root;
-	struct inode	*inode; /* path.dentry.d_inode */
-	unsigned int	flags;
-	unsigned	seq, m_seq;
-	int		last_type;
-	unsigned	depth;
-	char *saved_names[MAX_NESTED_LINKS + 1];
-};
-
 /*
  * Type of the last component on LOOKUP_PARENT
  */
@@ -82,16 +71,8 @@ extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
 extern void nd_jump_link(struct nameidata *nd, struct path *path);
-
-static inline void nd_set_link(struct nameidata *nd, char *path)
-{
-	nd->saved_names[nd->depth] = path;
-}
-
-static inline char *nd_get_link(struct nameidata *nd)
-{
-	return nd->saved_names[nd->depth];
-}
+extern void nd_set_link(struct nameidata *nd, char *path);
+extern char *nd_get_link(struct nameidata *nd);
 
 static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
 {

commit 48a066e72d970a3e225a9c18690d570c736fc455
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 29 22:06:07 2013 -0400

    RCU'd vfsmounts
    
    * RCU-delayed freeing of vfsmounts
    * vfsmount_lock replaced with a seqlock (mount_lock)
    * sequence number from mount_lock is stored in nameidata->m_seq and
    used when we exit RCU mode
    * new vfsmount flag - MNT_SYNC_UMOUNT.  Set by umount_tree() when its
    caller knows that vfsmount will have no surviving references.
    * synchronize_rcu() done between unlocking namespace_sem in namespace_unlock()
    and doing pending mntput().
    * new helper: legitimize_mnt(mnt, seq).  Checks the mount_lock sequence
    number against seq, then grabs reference to mnt.  Then it rechecks mount_lock
    again to close the race and either returns success or drops the reference it
    has acquired.  The subtle point is that in case of MNT_SYNC_UMOUNT we can
    simply decrement the refcount and sod off - aforementioned synchronize_rcu()
    makes sure that final mntput() won't come until we leave RCU mode.  We need
    that, since we don't want to end up with some lazy pathwalk racing with
    umount() and stealing the final mntput() from it - caller of umount() may
    expect it to return only once the fs is shut down and we don't want to break
    that.  In other cases (i.e. with MNT_SYNC_UMOUNT absent) we have to do
    full-blown mntput() in case of mount_lock sequence number mismatch happening
    just as we'd grabbed the reference, but in those cases we won't be stealing
    the final mntput() from anything that would care.
    * mntput_no_expire() doesn't lock anything on the fast path now.  Incidentally,
    SMP and UP cases are handled the same way - no ifdefs there.
    * normal pathname resolution does *not* do any writes to mount_lock.  It does,
    of course, bump the refcounts of vfsmount and dentry in the very end, but that's
    it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 8e47bc7a1665..492de72560fa 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -16,7 +16,7 @@ struct nameidata {
 	struct path	root;
 	struct inode	*inode; /* path.dentry.d_inode */
 	unsigned int	flags;
-	unsigned	seq;
+	unsigned	seq, m_seq;
 	int		last_type;
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];

commit 2d8646510120bb1eb251ae3381e950805a877763
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 8 20:18:44 2013 -0400

    introduce kern_path_mountpoint()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 53c18f00d9fb..8e47bc7a1665 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -70,6 +70,7 @@ extern struct dentry *kern_path_create(int, const char *, struct path *, unsigne
 extern struct dentry *user_path_create(int, const char __user *, struct path *, unsigned int);
 extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
+extern int kern_path_mountpoint(int, const char *, struct path *, unsigned int);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 

commit 197df04c749a07616621b762e699b1fff4102fac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 8 14:03:27 2013 -0400

    rename user_path_umountat() to user_path_mountpoint_at()
    
    ... and move the extern from linux/namei.h to fs/internal.h,
    along with that of vfs_path_lookup().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index cd09751c71a0..53c18f00d9fb 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -58,7 +58,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
-extern int user_path_umountat(int, const char __user *, unsigned int, struct path *);
 
 #define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)
 #define user_lpath(name, path) user_path_at(AT_FDCWD, name, 0, path)
@@ -71,8 +70,6 @@ extern struct dentry *kern_path_create(int, const char *, struct path *, unsigne
 extern struct dentry *user_path_create(int, const char __user *, struct path *, unsigned int);
 extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
-extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
-			   const char *, unsigned int, struct path *);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 

commit 8033426e6bdb2690d302872ac1e1fadaec1a5581
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jul 26 06:23:25 2013 -0400

    vfs: allow umount to handle mountpoints without revalidating them
    
    Christopher reported a regression where he was unable to unmount a NFS
    filesystem where the root had gone stale. The problem is that
    d_revalidate handles the root of the filesystem differently from other
    dentries, but d_weak_revalidate does not. We could simply fix this by
    making d_weak_revalidate return success on IS_ROOT dentries, but there
    are cases where we do want to revalidate the root of the fs.
    
    A umount is really a special case. We generally aren't interested in
    anything but the dentry and vfsmount that's attached at that point. If
    the inode turns out to be stale we just don't care since the intent is
    to stop using it anyway.
    
    Try to handle this situation better by treating umount as a special
    case in the lookup code. Have it resolve the parent using normal
    means, and then do a lookup of the final dentry without revalidating
    it. In most cases, the final lookup will come out of the dcache, but
    the case where there's a trailing symlink or !LAST_NORM entry on the
    end complicates things a bit.
    
    Cc: Neil Brown <neilb@suse.de>
    Reported-by: Christopher T Vogan <cvogan@us.ibm.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 5a5ff57ceed4..cd09751c71a0 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -58,6 +58,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
+extern int user_path_umountat(int, const char __user *, unsigned int, struct path *);
 
 #define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)
 #define user_lpath(name, path) user_path_at(AT_FDCWD, name, 0, path)

commit 08b60f8438879a84246d7debded31c9cb7aea6e4
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Mon Dec 24 11:14:58 2012 -0700

    namei.h: include errno.h
    
    This solves:
    
    In file included from fs/ext3/symlink.c:20:0:
    include/linux/namei.h: In function 'retry_estale':
    include/linux/namei.h:114:19: error: 'ESTALE' undeclared (first use in this function)
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index e998c030061d..5a5ff57ceed4 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -2,6 +2,7 @@
 #define _LINUX_NAMEI_H
 
 #include <linux/dcache.h>
+#include <linux/errno.h>
 #include <linux/linkage.h>
 #include <linux/path.h>
 

commit 1ac12b4b6d707937f9de6d09622823b2fd0c93ef
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Dec 11 12:10:06 2012 -0500

    vfs: turn is_dir argument to kern_path_create into a lookup_flags arg
    
    Where we can pass in LOOKUP_DIRECTORY or LOOKUP_REVAL. Any other flags
    passed in here are currently ignored.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 66542b644804..e998c030061d 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -65,8 +65,8 @@ extern int user_path_at_empty(int, const char __user *, unsigned, struct path *,
 
 extern int kern_path(const char *, unsigned, struct path *);
 
-extern struct dentry *kern_path_create(int, const char *, struct path *, int);
-extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
+extern struct dentry *kern_path_create(int, const char *, struct path *, unsigned int);
+extern struct dentry *user_path_create(int, const char __user *, struct path *, unsigned int);
 extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,

commit b9d6ba94b875192ef5e2dab92d72beea33b83c3d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Dec 20 14:59:40 2012 -0500

    vfs: add a retry_estale helper function to handle retries on ESTALE
    
    This function is expected to be called from path-based syscalls to help
    them decide whether to try the lookup and call again in the event that
    they got an -ESTALE return back on an earier try.
    
    Currently, we only retry the call once on an ESTALE error, but in the
    event that we decide that that's not enough in the future, we should be
    able to change the logic in this helper without too much effort.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 4bf19d8174ed..66542b644804 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -98,4 +98,20 @@ static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
 	((char *) name)[min(len, maxlen)] = '\0';
 }
 
+/**
+ * retry_estale - determine whether the caller should retry an operation
+ * @error: the error that would currently be returned
+ * @flags: flags being used for next lookup attempt
+ *
+ * Check to see if the error code was -ESTALE, and then determine whether
+ * to retry the call based on whether "flags" already has LOOKUP_REVAL set.
+ *
+ * Returns true if the caller should try the operation again.
+ */
+static inline bool
+retry_estale(const long error, const unsigned int flags)
+{
+	return error == -ESTALE && !(flags & LOOKUP_REVAL);
+}
+
 #endif /* _LINUX_NAMEI_H */

commit 921a1650de9eed40dd64d681aba4a4d98856f289
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 20 01:15:31 2012 +0400

    new helper: done_path_create()
    
    releases what needs to be released after {kern,user}_path_create()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d2ef8b34b967..4bf19d8174ed 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -67,6 +67,7 @@ extern int kern_path(const char *, unsigned, struct path *);
 
 extern struct dentry *kern_path_create(int, const char *, struct path *, int);
 extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
+extern void done_path_create(struct path *, struct dentry *);
 extern struct dentry *kern_path_locked(const char *, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);

commit b5fb63c18315c5510c1d0636179c057e0c761c77
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Jun 18 10:47:04 2012 -0400

    fs: add nd_jump_link
    
    Add a helper that abstracts out the jump to an already parsed struct path
    from ->follow_link operation from procfs.  Not only does this clean up
    the code by moving the two sides of this game into a single helper, but
    it also prepares for making struct nameidata private to namei.c
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index f5931489e150..d2ef8b34b967 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -80,6 +80,8 @@ extern int follow_up(struct path *);
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);
 
+extern void nd_jump_link(struct nameidata *nd, struct path *path);
+
 static inline void nd_set_link(struct nameidata *nd, char *path)
 {
 	nd->saved_names[nd->depth] = path;

commit 79714f72d3b964611997de512cb29198c9f2dbbb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 15 03:01:42 2012 +0400

    get rid of kern_path_parent()
    
    all callers want the same thing, actually - a kinda-sorta analog of
    kern_path_create().  I.e. they want parent vfsmount/dentry (with
    ->i_mutex held, to make sure the child dentry is still their child)
    + the child dentry.
    
    Signed-off-by Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 23d859879210..f5931489e150 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -67,7 +67,7 @@ extern int kern_path(const char *, unsigned, struct path *);
 
 extern struct dentry *kern_path_create(int, const char *, struct path *, int);
 extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
-extern int kern_path_parent(const char *, struct nameidata *);
+extern struct dentry *kern_path_locked(const char *, struct path *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
 

commit 015c3bbcd88df2305aae5b017a9c91c08b380aa1
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:27 2012 +0200

    vfs: remove open intents from nameidata
    
    All users of open intents have been converted to use ->atomic_{open,create}.
    
    This patch gets rid of nd->intent.open and related infrastructure.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index ffc02135c483..23d859879210 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -7,12 +7,6 @@
 
 struct vfsmount;
 
-struct open_intent {
-	int	flags;
-	int	create_mode;
-	struct file *file;
-};
-
 enum { MAX_NESTED_LINKS = 8 };
 
 struct nameidata {
@@ -25,11 +19,6 @@ struct nameidata {
 	int		last_type;
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];
-
-	/* Intent data */
-	union {
-		struct open_intent open;
-	} intent;
 };
 
 /*
@@ -82,9 +71,6 @@ extern int kern_path_parent(const char *, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct path *);
 
-extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
-		int (*open)(struct inode *, struct file *));
-
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 
 extern int follow_down_one(struct path *);

commit 1fa1e7f615f4d3ae436fa319af6e4eebdd4026a8
Author: Andy Whitcroft <apw@canonical.com>
Date:   Wed Nov 2 09:44:39 2011 +0100

    readlinkat: ensure we return ENOENT for the empty pathname for normal lookups
    
    Since the commit below which added O_PATH support to the *at() calls, the
    error return for readlink/readlinkat for the empty pathname has switched
    from ENOENT to EINVAL:
    
      commit 65cfc6722361570bfe255698d9cd4dccaf47570d
      Author: Al Viro <viro@zeniv.linux.org.uk>
      Date:   Sun Mar 13 15:56:26 2011 -0400
    
        readlinkat(), fchownat() and fstatat() with empty relative pathnames
    
    This is both unexpected for userspace and makes readlink/readlinkat
    inconsistant with all other interfaces; and inconsistant with our stated
    return for these pathnames.
    
    As the readlinkat call does not have a flags parameter we cannot use the
    AT_EMPTY_PATH approach used in the other calls.  Therefore expose whether
    the original path is infact entry via a new user_path_at_empty() path
    lookup function.  Use this to determine whether to default to EINVAL or
    ENOENT for failures.
    
    Addresses http://bugs.launchpad.net/bugs/817187
    
    [akpm@linux-foundation.org: remove unused getname_flags()]
    Signed-off-by: Andy Whitcroft <apw@canonical.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 409328d1cbbb..ffc02135c483 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -67,6 +67,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_EMPTY		0x4000
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
+extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
 
 #define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)
 #define user_lpath(name, path) user_path_at(AT_FDCWD, name, 0, path)

commit b6c8069d3577481390b3f24a8434ad72a3235594
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 27 08:12:33 2011 -0700

    vfs: remove LOOKUP_NO_AUTOMOUNT flag
    
    That flag no longer makes sense, since we don't look up automount points
    as eagerly any more.  Additionally, it turns out that the NO_AUTOMOUNT
    handling was buggy to begin with: it would avoid automounting even for
    cases where we really *needed* to do the automount handling, and could
    return ENOENT for autofs entries that hadn't been instantiated yet.
    
    With our new non-eager automount semantics, one discussion has been
    about adding a AT_AUTOMOUNT flag to vfs_fstatat (and thus the
    newfstatat() and fstatat64() system calls), but it's probably not worth
    it: you can always force at least directory automounting by simply
    adding the final '/' to the filename, which works for *all* of the stat
    family system calls, old and new.
    
    So AT_NO_AUTOMOUNT (and thus LOOKUP_NO_AUTOMOUNT) really were just a
    result of our bad default behavior.
    
    Acked-by: Ian Kent <raven@themaw.net>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index e13dac7caab2..409328d1cbbb 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -53,7 +53,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_PARENT		0x0010
 #define LOOKUP_REVAL		0x0020
 #define LOOKUP_RCU		0x0040
-#define LOOKUP_NO_AUTOMOUNT	0x0080
+
 /*
  * Intent data
  */

commit d94c177beeb4469cd4f6e83354ab0223353e98ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 26 17:44:55 2011 -0700

    vfs pathname lookup: Add LOOKUP_AUTOMOUNT flag
    
    Since we've now turned around and made LOOKUP_FOLLOW *not* force an
    automount, we want to add the ability to force an automount event on
    lookup even if we don't happen to have one of the other flags that force
    it implicitly (LOOKUP_OPEN, LOOKUP_DIRECTORY, LOOKUP_PARENT..)
    
    Most cases will never want to use this, since you'd normally want to
    delay automounting as long as possible, which usually implies
    LOOKUP_OPEN (when we open a file or directory, we really cannot avoid
    the automount any more).
    
    But Trond argued sufficiently forcefully that at a minimum bind mounting
    a file and quotactl will want to force the automount lookup.  Some other
    cases (like nfs_follow_remote_path()) could use it too, although
    LOOKUP_DIRECTORY would work there as well.
    
    This commit just adds the flag and logic, no users yet, though.  It also
    doesn't actually touch the LOOKUP_NO_AUTOMOUNT flag that is related, and
    was made irrelevant by the same change that made us not follow on
    LOOKUP_FOLLOW.
    
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg KH <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 76fe2c62ae71..e13dac7caab2 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -48,6 +48,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  */
 #define LOOKUP_FOLLOW		0x0001
 #define LOOKUP_DIRECTORY	0x0002
+#define LOOKUP_AUTOMOUNT	0x0004
 
 #define LOOKUP_PARENT		0x0010
 #define LOOKUP_REVAL		0x0020

commit e0a0124936171af6156b80fe8ac8799f039e767f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 27 17:00:37 2011 -0400

    switch vfs_path_lookup() to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index b8cea804d31a..76fe2c62ae71 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -78,7 +78,7 @@ extern struct dentry *kern_path_create(int, const char *, struct path *, int);
 extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
 extern int kern_path_parent(const char *, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
-			   const char *, unsigned int, struct nameidata *);
+			   const char *, unsigned int, struct path *);
 
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));

commit dae6ad8f37529963ae7df52baaccf056b38f210e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 26 11:50:15 2011 -0400

    new helpers: kern_path_create/user_path_create
    
    combination of kern_path_parent() and lookup_create().  Does *not*
    expose struct nameidata to caller.  Syscalls converted to that...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 3439ab862e1d..b8cea804d31a 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -74,6 +74,8 @@ extern int user_path_at(int, const char __user *, unsigned, struct path *);
 
 extern int kern_path(const char *, unsigned, struct path *);
 
+extern struct dentry *kern_path_create(int, const char *, struct path *, int);
+extern struct dentry *user_path_create(int, const char __user *, struct path *, int);
 extern int kern_path_parent(const char *, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);

commit 49084c3bb2055c401f3493c13edae14d49128ca0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 25 21:59:52 2011 -0400

    kill LOOKUP_CONTINUE
    
    LOOKUP_PARENT is equivalent to it now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index eba45ea10298..3439ab862e1d 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -48,7 +48,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  */
 #define LOOKUP_FOLLOW		0x0001
 #define LOOKUP_DIRECTORY	0x0002
-#define LOOKUP_CONTINUE		0x0004
 
 #define LOOKUP_PARENT		0x0010
 #define LOOKUP_REVAL		0x0020

commit 7cc90cc3ffe22a0d81b8d605b20a82ec7911012d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 18 09:04:20 2011 -0400

    don't pass 'mounting_here' flag to follow_down()
    
    it's always false now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 9c8603872c36..eba45ea10298 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -85,7 +85,7 @@ extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 
 extern int follow_down_one(struct path *);
-extern int follow_down(struct path *, bool);
+extern int follow_down(struct path *);
 extern int follow_up(struct path *);
 
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);

commit f52e0c11305aa09ed56cad97ffc8f0cdc3d78b5d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 14 18:56:51 2011 -0400

    New AT_... flag: AT_EMPTY_PATH
    
    For name_to_handle_at(2) we'll want both ...at()-style syscall that
    would be usable for non-directory descriptors (with empty relative
    pathname).  Introduce new flag (AT_EMPTY_PATH) to deal with that and
    corresponding LOOKUP_EMPTY; teach user_path_at() and path_init() to
    deal with the latter.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 83cd6e5cd7dc..9c8603872c36 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -64,6 +64,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 
 #define LOOKUP_JUMPED		0x1000
 #define LOOKUP_ROOT		0x2000
+#define LOOKUP_EMPTY		0x4000
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 

commit 5b6ca027d85b7438c84b78a54ccdc2e53f2909cd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 9 23:04:47 2011 -0500

    reduce vfs_path_lookup() to do_path_lookup()
    
    New lookup flag: LOOKUP_ROOT.  nd->root is set (and held) by caller,
    path_init() starts walking from that place and all pathname resolution
    machinery never drops nd->root if that flag is set.  That turns
    vfs_path_lookup() into a special case of do_path_lookup() *and*
    gets us down to 3 callers of link_path_walk(), making it finally
    feasible to rip the handling of trailing symlink out of link_path_walk().
    That will not only simply the living hell out of it, but make life
    much simpler for unionfs merge.  Trailing symlink handling will
    become iterative, which is a good thing for stack footprint in
    a lot of situations as well.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 72ffd62ac736..83cd6e5cd7dc 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -63,6 +63,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_RENAME_TARGET	0x0800
 
 #define LOOKUP_JUMPED		0x1000
+#define LOOKUP_ROOT		0x2000
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 

commit 70e9b3571107b88674cd55ae4bed33f76261e7d3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 5 21:12:22 2011 -0500

    get rid of nd->file
    
    Don't stash the struct file * used as starting point of walk in nameidata;
    pass file ** to path_init() instead.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 265378a707bd..72ffd62ac736 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -19,7 +19,6 @@ struct nameidata {
 	struct path	path;
 	struct qstr	last;
 	struct path	root;
-	struct file	*file;
 	struct inode	*inode; /* path.dentry.d_inode */
 	unsigned int	flags;
 	unsigned	seq;

commit 16c2cd7179881d5dd87779512ca5a0d657c64f62
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 22 15:50:10 2011 -0500

    untangle the "need_reval_dot" mess
    
    instead of ad-hackery around need_reval_dot(), do the following:
    set a flag (LOOKUP_JUMPED) in the beginning of path, on absolute
    symlink traversal, on ".." and on procfs-style symlinks.  Clear on
    normal components, leave unchanged on ".".  Non-nested callers of
    link_path_walk() call handle_reval_path(), which checks that flag
    is set and that fs does want the final revalidate thing, then does
    ->d_revalidate().  In link_path_walk() all the return_reval stuff
    is gone.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 58ce3433d4ec..265378a707bd 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -63,6 +63,8 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_EXCL		0x0400
 #define LOOKUP_RENAME_TARGET	0x0800
 
+#define LOOKUP_JUMPED		0x1000
+
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 
 #define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)

commit c9c6cac0c2bdbda42e7b804838648d0bc60ddb13
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 16 15:15:47 2011 -0500

    kill path_lookup()
    
    all remaining callers pass LOOKUP_PARENT to it, so
    flags argument can die; renamed to kern_path_parent()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index f276d4fa01fc..58ce3433d4ec 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,7 +72,7 @@ extern int user_path_at(int, const char __user *, unsigned, struct path *);
 
 extern int kern_path(const char *, unsigned, struct path *);
 
-extern int path_lookup(const char *, unsigned, struct nameidata *);
+extern int kern_path_parent(const char *, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 

commit 6f45b65672c8017d5e210e338bb5858a938ef445
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 14 18:45:31 2011 +0000

    Add an AT_NO_AUTOMOUNT flag to suppress terminal automount
    
    Add an AT_NO_AUTOMOUNT flag to suppress terminal automounting of automount
    point directories.  This can be used by fstatat() users to permit the
    gathering of attributes on an automount point and also prevent
    mass-automounting of a directory of automount points by ls.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 8ef2c789c2a8..f276d4fa01fc 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -45,6 +45,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - ending slashes ok even for nonexistent files
  *  - internal "there are more path components" flag
  *  - dentry cache is untrusted; force a real lookup
+ *  - suppress terminal automount
  */
 #define LOOKUP_FOLLOW		0x0001
 #define LOOKUP_DIRECTORY	0x0002
@@ -53,6 +54,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_PARENT		0x0010
 #define LOOKUP_REVAL		0x0020
 #define LOOKUP_RCU		0x0040
+#define LOOKUP_NO_AUTOMOUNT	0x0080
 /*
  * Intent data
  */

commit cc53ce53c86924bfe98a12ea20b7465038a08792
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 14 18:45:26 2011 +0000

    Add a dentry op to allow processes to be held during pathwalk transit
    
    Add a dentry op (d_manage) to permit a filesystem to hold a process and make it
    sleep when it tries to transit away from one of that filesystem's directories
    during a pathwalk.  The operation is keyed off a new dentry flag
    (DCACHE_MANAGE_TRANSIT).
    
    The filesystem is allowed to be selective about which processes it holds and
    which it permits to continue on or prohibits from transiting from each flagged
    directory.  This will allow autofs to hold up client processes whilst letting
    its userspace daemon through to maintain the directory or the stuff behind it
    or mounted upon it.
    
    The ->d_manage() dentry operation:
    
            int (*d_manage)(struct path *path, bool mounting_here);
    
    takes a pointer to the directory about to be transited away from and a flag
    indicating whether the transit is undertaken by do_add_mount() or
    do_move_mount() skipping through a pile of filesystems mounted on a mountpoint.
    
    It should return 0 if successful and to let the process continue on its way;
    -EISDIR to prohibit the caller from skipping to overmounted filesystems or
    automounting, and to use this directory; or some other error code to return to
    the user.
    
    ->d_manage() is called with namespace_sem writelocked if mounting_here is true
    and no other locks held, so it may sleep.  However, if mounting_here is true,
    it may not initiate or wait for a mount or unmount upon the parameter
    directory, even if the act is actually performed by userspace.
    
    Within fs/namei.c, follow_managed() is extended to check with d_manage() first
    on each managed directory, before transiting away from it or attempting to
    automount upon it.
    
    follow_down() is renamed follow_down_one() and should only be used where the
    filesystem deliberately intends to avoid management steps (e.g. autofs).
    
    A new follow_down() is added that incorporates the loop done by all other
    callers of follow_down() (do_add/move_mount(), autofs and NFSD; whilst AFS, NFS
    and CIFS do use it, their use is removed by converting them to use
    d_automount()).  The new follow_down() calls d_manage() as appropriate.  It
    also takes an extra parameter to indicate if it is being called from mount code
    (with namespace_sem writelocked) which it passes to d_manage().  follow_down()
    ignores automount points so that it can be used to mount on them.
    
    __follow_mount_rcu() is made to abort rcu-walk mode if it hits a directory with
    DCACHE_MANAGE_TRANSIT set on the basis that we're probably going to have to
    sleep.  It would be possible to enter d_manage() in rcu-walk mode too, and have
    that determine whether to abort or not itself.  That would allow the autofs
    daemon to continue on in rcu-walk mode.
    
    Note that DCACHE_MANAGE_TRANSIT on a directory should be cleared when it isn't
    required as every tranist from that directory will cause d_manage() to be
    invoked.  It can always be set again when necessary.
    
    ==========================
    WHAT THIS MEANS FOR AUTOFS
    ==========================
    
    Autofs currently uses the lookup() inode op and the d_revalidate() dentry op to
    trigger the automounting of indirect mounts, and both of these can be called
    with i_mutex held.
    
    autofs knows that the i_mutex will be held by the caller in lookup(), and so
    can drop it before invoking the daemon - but this isn't so for d_revalidate(),
    since the lock is only held on _some_ of the code paths that call it.  This
    means that autofs can't risk dropping i_mutex from its d_revalidate() function
    before it calls the daemon.
    
    The bug could manifest itself as, for example, a process that's trying to
    validate an automount dentry that gets made to wait because that dentry is
    expired and needs cleaning up:
    
            mkdir         S ffffffff8014e05a     0 32580  24956
            Call Trace:
             [<ffffffff885371fd>] :autofs4:autofs4_wait+0x674/0x897
             [<ffffffff80127f7d>] avc_has_perm+0x46/0x58
             [<ffffffff8009fdcf>] autoremove_wake_function+0x0/0x2e
             [<ffffffff88537be6>] :autofs4:autofs4_expire_wait+0x41/0x6b
             [<ffffffff88535cfc>] :autofs4:autofs4_revalidate+0x91/0x149
             [<ffffffff80036d96>] __lookup_hash+0xa0/0x12f
             [<ffffffff80057a2f>] lookup_create+0x46/0x80
             [<ffffffff800e6e31>] sys_mkdirat+0x56/0xe4
    
    versus the automount daemon which wants to remove that dentry, but can't
    because the normal process is holding the i_mutex lock:
    
            automount     D ffffffff8014e05a     0 32581      1              32561
            Call Trace:
             [<ffffffff80063c3f>] __mutex_lock_slowpath+0x60/0x9b
             [<ffffffff8000ccf1>] do_path_lookup+0x2ca/0x2f1
             [<ffffffff80063c89>] .text.lock.mutex+0xf/0x14
             [<ffffffff800e6d55>] do_rmdir+0x77/0xde
             [<ffffffff8005d229>] tracesys+0x71/0xe0
             [<ffffffff8005d28d>] tracesys+0xd5/0xe0
    
    which means that the system is deadlocked.
    
    This patch allows autofs to hold up normal processes whilst the daemon goes
    ahead and does things to the dentry tree behind the automouter point without
    risking a deadlock as almost no locks are held in d_manage() and none in
    d_automount().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Was-Acked-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 18d06add0a40..8ef2c789c2a8 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -79,7 +79,8 @@ extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 
-extern int follow_down(struct path *);
+extern int follow_down_one(struct path *);
+extern int follow_down(struct path *, bool);
 extern int follow_up(struct path *);
 
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);

commit 31e6b01f4183ff419a6d1f86177cbf4662347cec
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:52 2011 +1100

    fs: rcu-walk for path lookup
    
    Perform common cases of path lookups without any stores or locking in the
    ancestor dentry elements. This is called rcu-walk, as opposed to the current
    algorithm which is a refcount based walk, or ref-walk.
    
    This results in far fewer atomic operations on every path element,
    significantly improving path lookup performance. It also avoids cacheline
    bouncing on common dentries, significantly improving scalability.
    
    The overall design is like this:
    * LOOKUP_RCU is set in nd->flags, which distinguishes rcu-walk from ref-walk.
    * Take the RCU lock for the entire path walk, starting with the acquiring
      of the starting path (eg. root/cwd/fd-path). So now dentry refcounts are
      not required for dentry persistence.
    * synchronize_rcu is called when unregistering a filesystem, so we can
      access d_ops and i_ops during rcu-walk.
    * Similarly take the vfsmount lock for the entire path walk. So now mnt
      refcounts are not required for persistence. Also we are free to perform mount
      lookups, and to assume dentry mount points and mount roots are stable up and
      down the path.
    * Have a per-dentry seqlock to protect the dentry name, parent, and inode,
      so we can load this tuple atomically, and also check whether any of its
      members have changed.
    * Dentry lookups (based on parent, candidate string tuple) recheck the parent
      sequence after the child is found in case anything changed in the parent
      during the path walk.
    * inode is also RCU protected so we can load d_inode and use the inode for
      limited things.
    * i_mode, i_uid, i_gid can be tested for exec permissions during path walk.
    * i_op can be loaded.
    
    When we reach the destination dentry, we lock it, recheck lookup sequence,
    and increment its refcount and mountpoint refcount. RCU and vfsmount locks
    are dropped. This is termed "dropping rcu-walk". If the dentry refcount does
    not match, we can not drop rcu-walk gracefully at the current point in the
    lokup, so instead return -ECHILD (for want of a better errno). This signals the
    path walking code to re-do the entire lookup with a ref-walk.
    
    Aside from the final dentry, there are other situations that may be encounted
    where we cannot continue rcu-walk. In that case, we drop rcu-walk (ie. take
    a reference on the last good dentry) and continue with a ref-walk. Again, if
    we can drop rcu-walk gracefully, we return -ECHILD and do the whole lookup
    using ref-walk. But it is very important that we can continue with ref-walk
    for most cases, particularly to avoid the overhead of double lookups, and to
    gain the scalability advantages on common path elements (like cwd and root).
    
    The cases where rcu-walk cannot continue are:
    * NULL dentry (ie. any uncached path element)
    * parent with d_inode->i_op->permission or ACLs
    * dentries with d_revalidate
    * Following links
    
    In future patches, permission checks and d_revalidate become rcu-walk aware. It
    may be possible eventually to make following links rcu-walk aware.
    
    Uncached path elements will always require dropping to ref-walk mode, at the
    very least because i_mutex needs to be grabbed, and objects allocated.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index aec730b53935..18d06add0a40 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -19,7 +19,10 @@ struct nameidata {
 	struct path	path;
 	struct qstr	last;
 	struct path	root;
+	struct file	*file;
+	struct inode	*inode; /* path.dentry.d_inode */
 	unsigned int	flags;
+	unsigned	seq;
 	int		last_type;
 	unsigned	depth;
 	char *saved_names[MAX_NESTED_LINKS + 1];
@@ -43,11 +46,13 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - internal "there are more path components" flag
  *  - dentry cache is untrusted; force a real lookup
  */
-#define LOOKUP_FOLLOW		 1
-#define LOOKUP_DIRECTORY	 2
-#define LOOKUP_CONTINUE		 4
-#define LOOKUP_PARENT		16
-#define LOOKUP_REVAL		64
+#define LOOKUP_FOLLOW		0x0001
+#define LOOKUP_DIRECTORY	0x0002
+#define LOOKUP_CONTINUE		0x0004
+
+#define LOOKUP_PARENT		0x0010
+#define LOOKUP_REVAL		0x0020
+#define LOOKUP_RCU		0x0040
 /*
  * Intent data
  */

commit b5c84bf6f6fa3a7dfdcb556023a62953574b60ee
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:38 2011 +1100

    fs: dcache remove dcache_lock
    
    dcache_lock no longer protects anything. remove it.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 05b441d93642..aec730b53935 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -41,7 +41,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - require a directory
  *  - ending slashes ok even for nonexistent files
  *  - internal "there are more path components" flag
- *  - locked when lookup done with dcache_lock held
  *  - dentry cache is untrusted; force a real lookup
  */
 #define LOOKUP_FOLLOW		 1

commit 482928d59db668b8d82a48717f78986d8cea72e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 19 10:10:39 2009 -0500

    Fix f_flags/f_mode in case of lookup_instantiate_filp() from open(pathname, 3)
    
    Just set f_flags when shoving struct file into nameidata; don't
    postpone that until __dentry_open().  do_filp_open() has correct
    value; lookup_instantiate_filp() doesn't - we lose the difference
    between O_RDWR and 3 by that point.
    
    We still set .intent.open.flags, so no fs code needs to be changed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 028946750289..05b441d93642 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,8 +72,6 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));
-extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
-extern void release_open_intent(struct nameidata *);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 

commit 832b6af198aefe6034310e124594cc8b833c0ef9
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Nov 20 16:08:56 2009 -0800

    sysfs: Propagate renames to the vfs on demand
    
    By teaching sysfs_revalidate to hide a dentry for
    a sysfs_dirent if the sysfs_dirent has been renamed,
    and by teaching sysfs_lookup to return the original
    dentry if the sysfs dirent has been renamed.  I can
    show the results of renames correctly without having to
    update the dcache during the directory rename.
    
    This massively simplifies the rename logic allowing a lot
    of weird sysfs special cases to be removed along with
    a lot of now unnecesary helper code.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index ec0f607b364a..028946750289 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -76,7 +76,6 @@ extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry *lookup_one_noperm(const char *, struct dentry *);
 
 extern int follow_down(struct path *);
 extern int follow_up(struct path *);

commit 47a0dfaad9eb82b16193477cf99c2462af03c329
Author: Ori Avtalion <ori@avtalion.name>
Date:   Tue Jun 16 12:17:53 2009 +0300

    trivial: fix typo in namei.h comment
    
    Signed-off-by: Ori Avtalion <ori@avtalion.name>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d870ae2faedc..ec0f607b364a 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -40,7 +40,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  *  - follow links at the end
  *  - require a directory
  *  - ending slashes ok even for nonexistent files
- *  - internal "there are more path compnents" flag
+ *  - internal "there are more path components" flag
  *  - locked when lookup done with dcache_lock held
  *  - dentry cache is untrusted; force a real lookup
  */

commit 9393bd07cf218ca51d0e627653f906a9d76a9131
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 18 13:58:15 2009 -0400

    switch follow_down()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 9cd5a717be3b..d870ae2faedc 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -78,7 +78,7 @@ extern void release_open_intent(struct nameidata *);
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_noperm(const char *, struct dentry *);
 
-extern int follow_down(struct vfsmount **, struct dentry **);
+extern int follow_down(struct path *);
 extern int follow_up(struct path *);
 
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);

commit bab77ebf51e3902f608ecf08c9d34a0a52ac35a9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 18 03:26:48 2009 -0400

    switch follow_up() to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 325dd3ad39a0..9cd5a717be3b 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -79,7 +79,7 @@ extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_noperm(const char *, struct dentry *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
-extern int follow_up(struct vfsmount **, struct dentry **);
+extern int follow_up(struct path *);
 
 extern struct dentry *lock_rename(struct dentry *, struct dentry *);
 extern void unlock_rename(struct dentry *, struct dentry *);

commit 2a737871108de9ba8930f7650d549f1383767f8b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 7 11:49:53 2009 -0400

    Cache root in nameidata
    
    New field: nd->root.  When pathname resolution wants to know the root,
    check if nd->root.mnt is non-NULL; use nd->root if it is, otherwise
    copy current->fs->root there.  After path_walk() is finished, we check
    if we'd got a cached value in nd->root and drop it.  Before calling
    path_walk() we should either set nd->root.mnt to NULL *or* copy (and
    pin down) some path to nd->root.  In the latter case we won't be
    looking at current->fs->root at all.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 518098fe63af..325dd3ad39a0 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -18,6 +18,7 @@ enum { MAX_NESTED_LINKS = 8 };
 struct nameidata {
 	struct path	path;
 	struct qstr	last;
+	struct path	root;
 	unsigned int	flags;
 	int		last_type;
 	unsigned	depth;

commit 6e8341a11eb21826b7192d0bb88cb5b44900a9af
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 6 11:16:22 2009 -0400

    Switch open_exec() and sys_uselib() to do_open_filp()
    
    ... and make path_lookup_open() static
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index fc2e03579877..518098fe63af 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -69,7 +69,6 @@ extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 
-extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));
 extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);

commit 035146851cfa2fe24c1d9dc7637bb009ad06b2f7
Author: Duane Griffin <duaneg@dghda.com>
Date:   Fri Dec 19 20:47:11 2008 +0000

    vfs: introduce helper function to safely NUL-terminate symlinks
    
    A number of filesystems were potentially triggering kernel bugs due to
    corrupted symlink names on disk. This function helps safely terminate
    the names.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Duane Griffin <duaneg@dghda.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 99eb80306dc5..fc2e03579877 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -94,4 +94,9 @@ static inline char *nd_get_link(struct nameidata *nd)
 	return nd->saved_names[nd->depth];
 }
 
+static inline void nd_terminate_link(void *name, size_t len, size_t maxlen)
+{
+	((char *) name)[min(len, maxlen)] = '\0';
+}
+
 #endif /* _LINUX_NAMEI_H */

commit 4e9ed2f85af7adfa7c3f0efa839a53186254fdcb
Author: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
Date:   Thu Oct 16 07:50:29 2008 +0900

    [PATCH vfs-2.6 6/6] vfs: add LOOKUP_RENAME_TARGET intent
    
    This adds LOOKUP_RENAME_TARGET intent for lookup of rename destination.
    
    LOOKUP_RENAME_TARGET is going to be used like LOOKUP_CREATE. But since
    the destination of rename() can be existing directory entry, so it has a
    difference. Although that difference doesn't matter in my usage, this
    tells it to user of this intent.
    
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 6b5627afd2eb..99eb80306dc5 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -54,6 +54,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_OPEN		0x0100
 #define LOOKUP_CREATE		0x0200
 #define LOOKUP_EXCL		0x0400
+#define LOOKUP_RENAME_TARGET	0x0800
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 

commit 3516586a424ea5727be089da6541cbd5644f0497
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Aug 5 03:00:49 2008 -0400

    [PATCH] make O_EXCL in nd->intent.flags visible in nd->flags
    
    New flag: LOOKUP_EXCL.  Set before doing the final step of pathname
    resolution on the paths that have LOOKUP_CREATE and O_EXCL.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 221e8bc894ba..6b5627afd2eb 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -51,8 +51,9 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 /*
  * Intent data
  */
-#define LOOKUP_OPEN		(0x0100)
-#define LOOKUP_CREATE		(0x0200)
+#define LOOKUP_OPEN		0x0100
+#define LOOKUP_CREATE		0x0200
+#define LOOKUP_EXCL		0x0400
 
 extern int user_path_at(int, const char __user *, unsigned, struct path *);
 

commit d181146572c4fa9af2a068b967cb53dcac7da944
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Aug 2 00:49:18 2008 -0400

    [PATCH] new helper - kern_path()
    
    Analog of lookup_path(), takes struct path *.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 68f8c3203c89..221e8bc894ba 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -61,6 +61,8 @@ extern int user_path_at(int, const char __user *, unsigned, struct path *);
 #define user_path_dir(name, path) \
 	user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path)
 
+extern int kern_path(const char *, unsigned, struct path *);
+
 extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);

commit 964bd183624c03680796b63b4ab97ee3905a806a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 26 03:33:14 2008 -0400

    [PATCH] get rid of __user_path_lookup_open
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 00888ff69504..68f8c3203c89 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -65,7 +65,6 @@ extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 
-extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
 extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));

commit 2d8f30380ab8c706f4e0a8f1aaa22b5886e9ac8a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 22 09:59:21 2008 -0400

    [PATCH] sanitize __user_walk_fd() et.al.
    
    * do not pass nameidata; struct path is all the callers want.
    * switch to new helpers:
            user_path_at(dfd, pathname, flags, &path)
            user_path(pathname, &path)
            user_lpath(pathname, &path)
            user_path_dir(pathname, &path)  (fail if not a directory)
      The last 3 are trivial macro wrappers for the first one.
    * remove nameidata in callers.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 60e35a02f6cb..00888ff69504 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -54,12 +54,13 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_OPEN		(0x0100)
 #define LOOKUP_CREATE		(0x0200)
 
-extern int __user_walk(const char __user *, unsigned, struct nameidata *);
-extern int __user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *);
-#define user_path_walk(name,nd) \
-	__user_walk_fd(AT_FDCWD, name, LOOKUP_FOLLOW, nd)
-#define user_path_walk_link(name,nd) \
-	__user_walk_fd(AT_FDCWD, name, 0, nd)
+extern int user_path_at(int, const char __user *, unsigned, struct path *);
+
+#define user_path(name, path) user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW, path)
+#define user_lpath(name, path) user_path_at(AT_FDCWD, name, 0, path)
+#define user_path_dir(name, path) \
+	user_path_at(AT_FDCWD, name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, path)
+
 extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);

commit a110343f0d6d41f68b7cf8c00b57a3172c67f816
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 17 09:19:08 2008 -0400

    [PATCH] fix MAY_CHDIR/MAY_ACCESS/LOOKUP_ACCESS mess
    
    * MAY_CHDIR is redundant - it's an equivalent of MAY_ACCESS
    * MAY_ACCESS on fuse should affect only the last step of pathname resolution
    * fchdir() and chroot() should pass MAY_ACCESS, for the same reason why
      chdir() needs that.
    * now that we pass MAY_ACCESS explicitly in all cases, LOOKUP_ACCESS can be
      removed; it has no business being in nameidata.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 768773d57857..60e35a02f6cb 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -53,7 +53,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
  */
 #define LOOKUP_OPEN		(0x0100)
 #define LOOKUP_CREATE		(0x0200)
-#define LOOKUP_ACCESS		(0x0400)
 
 extern int __user_walk(const char __user *, unsigned, struct nameidata *);
 extern int __user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *);

commit 7f2da1e7d0330395e5e9e350b879b98a1ea495df
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 10 20:44:54 2008 -0400

    [PATCH] kill altroot
    
    long overdue...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 3cf62d26d493..768773d57857 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -47,7 +47,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_DIRECTORY	 2
 #define LOOKUP_CONTINUE		 4
 #define LOOKUP_PARENT		16
-#define LOOKUP_NOALT		32
 #define LOOKUP_REVAL		64
 /*
  * Intent data

commit 8bb79224b87aab92071e94d46e70bd160d89bf34
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 16 09:51:03 2008 -0400

    [PATCH] permission checks for chdir need special treatment only on the last step
    
    ... so we ought to pass MAY_CHDIR to vfs_permission() instead of having
    it triggered on every step of preceding pathname resolution.  LOOKUP_CHDIR
    is killed by that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 24d88e98a626..3cf62d26d493 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -55,7 +55,6 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_OPEN		(0x0100)
 #define LOOKUP_CREATE		(0x0200)
 #define LOOKUP_ACCESS		(0x0400)
-#define LOOKUP_CHDIR		(0x0800)
 
 extern int __user_walk(const char __user *, unsigned, struct nameidata *);
 extern int __user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *);

commit 1d957f9bf87da74f420424d16ece005202bbebd3
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:35 2008 -0800

    Introduce path_put()
    
    * Add path_put() functions for releasing a reference to the dentry and
      vfsmount of a struct path in the right order
    
    * Switch from path_release(nd) to path_put(&nd->path)
    
    * Rename dput_path() to path_put_conditional()
    
    [akpm@linux-foundation.org: fix cifs]
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: <linux-fsdevel@vger.kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 52fa2f78bb71..24d88e98a626 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -66,7 +66,6 @@ extern int __user_walk_fd(int dfd, const char __user *, unsigned, struct nameida
 extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
-extern void path_release(struct nameidata *);
 
 extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
 extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);

commit 4ac9137858e08a19f29feac4e1f4df7c268b0ba5
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:32 2008 -0800

    Embed a struct path into struct nameidata instead of nd->{dentry,mnt}
    
    This is the central patch of a cleanup series. In most cases there is no good
    reason why someone would want to use a dentry for itself. This series reflects
    that fact and embeds a struct path into nameidata.
    
    Together with the other patches of this series
    - it enforced the correct order of getting/releasing the reference count on
      <dentry,vfsmount> pairs
    - it prepares the VFS for stacking support since it is essential to have a
      struct path in every place where the stack can be traversed
    - it reduces the overall code size:
    
    without patch series:
       text    data     bss     dec     hex filename
    5321639  858418  715768 6895825  6938d1 vmlinux
    
    with patch series:
       text    data     bss     dec     hex filename
    5320026  858418  715768 6894212  693284 vmlinux
    
    This patch:
    
    Switch from nd->{dentry,mnt} to nd->path.{dentry,mnt} everywhere.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: fix cifs]
    [akpm@linux-foundation.org: fix smack]
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 1cd15dad2469..52fa2f78bb71 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -16,8 +16,7 @@ struct open_intent {
 enum { MAX_NESTED_LINKS = 8 };
 
 struct nameidata {
-	struct dentry	*dentry;
-	struct vfsmount *mnt;
+	struct path	path;
 	struct qstr	last;
 	unsigned int	flags;
 	int		last_type;

commit c5e725f33b733a77de622e91b6ba5645fcf070be
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:31 2008 -0800

    Move struct path into its own header
    
    Move the definition of struct path into its own header file for further
    patches.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 307b1b31d37f..1cd15dad2469 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -3,6 +3,7 @@
 
 #include <linux/dcache.h>
 #include <linux/linkage.h>
+#include <linux/path.h>
 
 struct vfsmount;
 
@@ -29,11 +30,6 @@ struct nameidata {
 	} intent;
 };
 
-struct path {
-	struct vfsmount *mnt;
-	struct dentry *dentry;
-};
-
 /*
  * Type of the last component on LOOKUP_PARENT
  */

commit 429731b1553bacf9a331c260c317a28aaa878edb
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:34:31 2008 -0800

    Remove path_release_on_umount()
    
    path_release_on_umount() should only be called from sys_umount(). I merged the
    function into sys_umount() instead of having in in namei.c.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index c13e411491f4..307b1b31d37f 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,7 +72,6 @@ extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 extern void path_release(struct nameidata *);
-extern void path_release_on_umount(struct nameidata *);
 
 extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
 extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);

commit b3c97528689619fc66569b30bf83d09d9929521a
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Feb 13 15:03:15 2008 -0800

    include/linux: Remove all users of FASTCALL() macro
    
    FASTCALL() is always expanded to empty, remove it.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 4cb4f8d2f78d..c13e411491f4 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -62,13 +62,13 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_ACCESS		(0x0400)
 #define LOOKUP_CHDIR		(0x0800)
 
-extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
-extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *));
+extern int __user_walk(const char __user *, unsigned, struct nameidata *);
+extern int __user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *);
 #define user_path_walk(name,nd) \
 	__user_walk_fd(AT_FDCWD, name, LOOKUP_FOLLOW, nd)
 #define user_path_walk_link(name,nd) \
 	__user_walk_fd(AT_FDCWD, name, 0, nd)
-extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
+extern int path_lookup(const char *, unsigned, struct nameidata *);
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 extern void path_release(struct nameidata *);

commit eead19115329c5615ba03cbaf1c3fe24c14858a3
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 16 23:25:38 2007 -0700

    partially fix up the lookup_one_noperm mess
    
    Try to fix the mess created by sysfs braindamage.
    
     - refactor code internal to fs/namei.c a little to avoid too much
       duplication:
            o __lookup_hash_kern is renamed back to __lookup_hash
            o the old __lookup_hash goes away, permission checks moves to
              the two callers
            o useless inline qualifiers on above functions go away
     - lookup_one_len_kern loses it's last argument and is renamed to
       lookup_one_noperm to make it's useage a little more clear
     - added kerneldoc comments to describe lookup_one_len aswell as
       lookup_one_noperm and make it very clear that no one should use
       the latter ever.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 6c38efbd810f..4cb4f8d2f78d 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -81,8 +81,8 @@ extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry
 extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
-extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry *lookup_one_len_kern(const char *, struct dentry *, int);
+extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
+extern struct dentry *lookup_one_noperm(const char *, struct dentry *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);

commit f79c20f52532d38fd0aee7ef64e138cc1613c484
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Thu Jul 19 01:48:22 2007 -0700

    fs: remove path_walk export
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 18ea81265068..6c38efbd810f 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -71,7 +71,6 @@ extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struc
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
-extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);
 extern void path_release_on_umount(struct nameidata *);
 

commit c4a7808fc3d7a346d5d12e0d69d76d66d821488b
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Thu Jul 19 01:48:22 2007 -0700

    fs: mark link_path_walk static
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 2e21af0989d9..18ea81265068 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,7 +72,6 @@ extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 			   const char *, unsigned int, struct nameidata *);
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
-extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);
 extern void path_release_on_umount(struct nameidata *);
 

commit 16f1820028d660d9da9c03b2ae7e98253c11795b
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Thu Jul 19 01:48:18 2007 -0700

    fs: introduce vfs_path_lookup
    
    Stackable file systems, among others, frequently need to lookup paths or
    path components starting from an arbitrary point in the namespace
    (identified by a dentry and a vfsmount).  Currently, such file systems use
    lookup_one_len, which is frowned upon [1] as it does not pass the lookup
    intent along; not passing a lookup intent, for example, can trigger BUG_ON's
    when stacking on top of NFSv4.
    
    The first patch introduces a new lookup function to allow lookup starting
    from an arbitrary point in the namespace.  This approach has been suggested
    by Christoph Hellwig [2].
    
    The second patch changes sunrpc to use vfs_path_lookup.
    
    The third patch changes nfsctl.c to use vfs_path_lookup.
    
    The fourth patch marks link_path_walk static.
    
    The fifth, and last patch, unexports path_walk because it is no longer
    unnecessary to call it directly, and using the new vfs_path_lookup is
    cleaner.
    
    For example, the following snippet of code, looks up "some/path/component"
    in a directory pointed to by parent_{dentry,vfsmnt}:
    
    err = vfs_path_lookup(parent_dentry, parent_vfsmnt,
                          "some/path/component", 0, &nd);
    if (!err) {
            /* exits */
    
            ...
    
            /* once done, release the references */
            path_release(&nd);
    } else if (err == -ENOENT) {
            /* doesn't exist */
    } else {
            /* other error */
    }
    
    VFS functions such as lookup_create can be used on the nameidata structure
    to pass the create intent to the file system.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index b7dd24917f0d..2e21af0989d9 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -69,6 +69,8 @@ extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struc
 #define user_path_walk_link(name,nd) \
 	__user_walk_fd(AT_FDCWD, name, 0, nd)
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
+extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
+			   const char *, unsigned int, struct nameidata *);
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);

commit 057f6c019fff9ee290641d50647359bb8898918e
Author: James Morris <jmorris@namei.org>
Date:   Thu Apr 26 00:12:05 2007 -0700

    security: prevent permission checking of file removal via sysfs_remove_group()
    
    Prevent permission checking from being performed when the kernel wants to
    unconditionally remove a sysfs group, by introducing an kernel-only variant
    of lookup_one_len(), lookup_one_len_kern().
    
    Additionally, as sysfs_remove_group() does not check the return value of
    the lookup before using it, a BUG_ON has been added to pinpoint the cause
    of any problems potentially caused by this (and as a form of annotation).
    
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Nagendra Singh Tomar <nagendra_tomar@adaptec.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index d39a5a67e979..b7dd24917f0d 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -82,6 +82,7 @@ extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
+extern struct dentry *lookup_one_len_kern(const char *, struct dentry *, int);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);

commit 346f20ff6020ffa11d40b789069079c56a444ae6
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Dec 8 02:36:34 2006 -0800

    [PATCH] struct path: move struct path from fs/namei.c into include/linux
    
    Moved struct path from fs/namei.c to include/linux/namei.h.  This allows many
    places in the VFS, as well as any stackable filesystem to easily keep track of
    dentry-vfsmount pairs.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index f5f19606effb..d39a5a67e979 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -29,6 +29,11 @@ struct nameidata {
 	} intent;
 };
 
+struct path {
+	struct vfsmount *mnt;
+	struct dentry *dentry;
+};
+
 /*
  * Type of the last component on LOOKUP_PARENT
  */

commit 82b0547cfae1fb2ee26cad588f6d49a347d24740
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Sep 30 23:27:22 2006 -0700

    [PATCH] Create fs/utimes.c
    
    * fs/open.c is getting bit crowdy
    * preparation to lutimes(2)
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index c6470ba00668..f5f19606effb 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -1,6 +1,7 @@
 #ifndef _LINUX_NAMEI_H
 #define _LINUX_NAMEI_H
 
+#include <linux/dcache.h>
 #include <linux/linkage.h>
 
 struct vfsmount;

commit 650a898342b3fa21c392c06a2b7010fa19823efa
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Sep 29 01:59:35 2006 -0700

    [PATCH] vfs: define new lookup flag for chdir
    
    In the "operation does permission checking" model used by fuse, chdir
    permission is not checked, since there's no chdir method.
    
    For this case set a lookup flag, which will be passed to ->permission(), so
    fuse can distinguish it from permission checks for other operations.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 45511a5918d3..c6470ba00668 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -54,6 +54,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_OPEN		(0x0100)
 #define LOOKUP_CREATE		(0x0200)
 #define LOOKUP_ACCESS		(0x0400)
+#define LOOKUP_CHDIR		(0x0800)
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
 extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *));

commit 737bebd137561e184f0a8b4332d9bb0238d8b639
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 14 00:24:29 2006 -0700

    [PATCH] symlink nesting level change
    
    It's way past time to bump it to 8.  Everyone had been warned - for
    months now.
    
    RH kernels have had this for more than a year.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 58cb3d3d44b4..45511a5918d3 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -11,7 +11,7 @@ struct open_intent {
 	struct file *file;
 };
 
-enum { MAX_NESTED_LINKS = 5 };
+enum { MAX_NESTED_LINKS = 8 };
 
 struct nameidata {
 	struct dentry	*dentry;

commit a244e1698ae3609cdfe24088e1293593cb7a5278
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Mar 31 02:32:11 2006 -0800

    [PATCH] fs/namei.c: make lookup_hash() static
    
    As announced, lookup_hash() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index e6698013e4d0..58cb3d3d44b4 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -75,7 +75,6 @@ extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern __deprecated_for_modules struct dentry * lookup_hash(struct nameidata *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);

commit 5590ff0d5528b60153c0b4e7b771472b5a95e297
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jan 18 17:43:53 2006 -0800

    [PATCH] vfs: *at functions: core
    
    Here is a series of patches which introduce in total 13 new system calls
    which take a file descriptor/filename pair instead of a single file
    name.  These functions, openat etc, have been discussed on numerous
    occasions.  They are needed to implement race-free filesystem traversal,
    they are necessary to implement a virtual per-thread current working
    directory (think multi-threaded backup software), etc.
    
    We have in glibc today implementations of the interfaces which use the
    /proc/self/fd magic.  But this code is rather expensive.  Here are some
    results (similar to what Jim Meyering posted before).
    
    The test creates a deep directory hierarchy on a tmpfs filesystem.  Then
    rm -fr is used to remove all directories.  Without syscall support I get
    this:
    
    real    0m31.921s
    user    0m0.688s
    sys     0m31.234s
    
    With syscall support the results are much better:
    
    real    0m20.699s
    user    0m0.536s
    sys     0m20.149s
    
    The interfaces are for obvious reasons currently not much used.  But they'll
    be used.  coreutils (and Jeff's posixutils) are already using them.
    Furthermore, code like ftw/fts in libc (maybe even glob) will also start using
    them.  I expect a patch to make follow soon.  Every program which is walking
    the filesystem tree will benefit.
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index b699e427c00c..e6698013e4d0 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -56,10 +56,11 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_ACCESS		(0x0400)
 
 extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+extern int FASTCALL(__user_walk_fd(int dfd, const char __user *, unsigned, struct nameidata *));
 #define user_path_walk(name,nd) \
-	__user_walk(name, LOOKUP_FOLLOW, nd)
+	__user_walk_fd(AT_FDCWD, name, LOOKUP_FOLLOW, nd)
 #define user_path_walk_link(name,nd) \
-	__user_walk(name, 0, nd)
+	__user_walk_fd(AT_FDCWD, name, 0, nd)
 extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
 extern int FASTCALL(path_walk(const char *, struct nameidata *));
 extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
@@ -67,7 +68,7 @@ extern void path_release(struct nameidata *);
 extern void path_release_on_umount(struct nameidata *);
 
 extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
-extern int path_lookup_open(const char *, unsigned lookup_flags, struct nameidata *, int open_flags);
+extern int path_lookup_open(int dfd, const char *name, unsigned lookup_flags, struct nameidata *, int open_flags);
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));
 extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);

commit bdff071dbf911bf5d1dcaedfaafebb549d2fd969
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jan 9 20:52:03 2006 -0800

    [PATCH] __deprecated_for_modules the lookup_hash() prototype
    
    This patch __deprecated_for_modules the lookup_hash() prototype.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 455660eafba9..b699e427c00c 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -74,7 +74,7 @@ extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct nameidata *);
+extern __deprecated_for_modules struct dentry * lookup_hash(struct nameidata *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);

commit 49705b7743fd8f5632a95ec4c6547d169d27ac1f
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 21:35:06 2005 -0800

    [PATCH] sanitize lookup_hash prototype
    
    ->permission and ->lookup have a struct nameidata * argument these days to
    pass down lookup intents.  Unfortunately some callers of lookup_hash don't
    actually pass this one down.  For lookup_one_len() we don't have a struct
    nameidata to pass down, but as this function is a library function only
    used by filesystem code this is an acceptable limitation.  All other
    callers should pass down the nameidata, so this patch changes the
    lookup_hash interface to only take a struct nameidata argument and derives
    the other two arguments to __lookup_hash from it.  All callers already have
    the nameidata argument available so this is not a problem.
    
    At the same time I'd like to deprecate the lookup_hash interface as there
    are better exported interfaces for filesystem usage.  Before it can
    actually be removed I need to fix up rpc_pipefs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 1c975d0d9e94..455660eafba9 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -74,7 +74,7 @@ extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
 extern void release_open_intent(struct nameidata *);
 
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
-extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+extern struct dentry * lookup_hash(struct nameidata *);
 
 extern int follow_down(struct vfsmount **, struct dentry **);
 extern int follow_up(struct vfsmount **, struct dentry **);

commit 834f2a4a1554dc5b2598038b3fe8703defcbe467
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:16 2005 -0700

    VFS: Allow the filesystem to return a full file pointer on open intent
    
     This is needed by NFSv4 for atomicity reasons: our open command is in
     fact a lookup+open, so we need to be able to propagate open context
     information from lookup() into the resulting struct file's
     private_data field.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/namei.h b/include/linux/namei.h
index 7db67b008cac..1c975d0d9e94 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -8,6 +8,7 @@ struct vfsmount;
 struct open_intent {
 	int	flags;
 	int	create_mode;
+	struct file *file;
 };
 
 enum { MAX_NESTED_LINKS = 5 };
@@ -65,6 +66,13 @@ extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
 extern void path_release(struct nameidata *);
 extern void path_release_on_umount(struct nameidata *);
 
+extern int __user_path_lookup_open(const char __user *, unsigned lookup_flags, struct nameidata *nd, int open_flags);
+extern int path_lookup_open(const char *, unsigned lookup_flags, struct nameidata *, int open_flags);
+extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
+		int (*open)(struct inode *, struct file *));
+extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
+extern void release_open_intent(struct nameidata *);
+
 extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/namei.h b/include/linux/namei.h
new file mode 100644
index 000000000000..7db67b008cac
--- /dev/null
+++ b/include/linux/namei.h
@@ -0,0 +1,87 @@
+#ifndef _LINUX_NAMEI_H
+#define _LINUX_NAMEI_H
+
+#include <linux/linkage.h>
+
+struct vfsmount;
+
+struct open_intent {
+	int	flags;
+	int	create_mode;
+};
+
+enum { MAX_NESTED_LINKS = 5 };
+
+struct nameidata {
+	struct dentry	*dentry;
+	struct vfsmount *mnt;
+	struct qstr	last;
+	unsigned int	flags;
+	int		last_type;
+	unsigned	depth;
+	char *saved_names[MAX_NESTED_LINKS + 1];
+
+	/* Intent data */
+	union {
+		struct open_intent open;
+	} intent;
+};
+
+/*
+ * Type of the last component on LOOKUP_PARENT
+ */
+enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
+
+/*
+ * The bitmask for a lookup event:
+ *  - follow links at the end
+ *  - require a directory
+ *  - ending slashes ok even for nonexistent files
+ *  - internal "there are more path compnents" flag
+ *  - locked when lookup done with dcache_lock held
+ *  - dentry cache is untrusted; force a real lookup
+ */
+#define LOOKUP_FOLLOW		 1
+#define LOOKUP_DIRECTORY	 2
+#define LOOKUP_CONTINUE		 4
+#define LOOKUP_PARENT		16
+#define LOOKUP_NOALT		32
+#define LOOKUP_REVAL		64
+/*
+ * Intent data
+ */
+#define LOOKUP_OPEN		(0x0100)
+#define LOOKUP_CREATE		(0x0200)
+#define LOOKUP_ACCESS		(0x0400)
+
+extern int FASTCALL(__user_walk(const char __user *, unsigned, struct nameidata *));
+#define user_path_walk(name,nd) \
+	__user_walk(name, LOOKUP_FOLLOW, nd)
+#define user_path_walk_link(name,nd) \
+	__user_walk(name, 0, nd)
+extern int FASTCALL(path_lookup(const char *, unsigned, struct nameidata *));
+extern int FASTCALL(path_walk(const char *, struct nameidata *));
+extern int FASTCALL(link_path_walk(const char *, struct nameidata *));
+extern void path_release(struct nameidata *);
+extern void path_release_on_umount(struct nameidata *);
+
+extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
+extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
+
+extern int follow_down(struct vfsmount **, struct dentry **);
+extern int follow_up(struct vfsmount **, struct dentry **);
+
+extern struct dentry *lock_rename(struct dentry *, struct dentry *);
+extern void unlock_rename(struct dentry *, struct dentry *);
+
+static inline void nd_set_link(struct nameidata *nd, char *path)
+{
+	nd->saved_names[nd->depth] = path;
+}
+
+static inline char *nd_get_link(struct nameidata *nd)
+{
+	return nd->saved_names[nd->depth];
+}
+
+#endif /* _LINUX_NAMEI_H */
