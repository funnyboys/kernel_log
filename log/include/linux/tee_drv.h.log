commit be4ad166b4e229ba7f129c5e3bd5ff0347652422
Merge: 0417a5c6a4c5 c5b4312bea5d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 25 23:15:02 2020 +0200

    Merge tag 'tee-login-for-5.8' of git://git.linaro.org/people/jens.wiklander/linux-tee into arm/drivers
    
    Adds utility function in TEE subsystem for client UUID generation. This
    function is also used in the optee driver.
    
    * tag 'tee-login-for-5.8' of git://git.linaro.org/people/jens.wiklander/linux-tee:
      tee: optee: Add support for session login client UUID generation
      tee: add support for session's client UUID generation
    
    Link: https://lore.kernel.org/r/20200512131243.GA10028@jade
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit e33bcbab16d1c0dd85d72bec275308369ad901f5
Author: Vesa Jääskeläinen <vesa.jaaskelainen@vaisala.com>
Date:   Thu Apr 30 15:37:09 2020 +0300

    tee: add support for session's client UUID generation
    
    TEE Client API defines that from user space only information needed for
    specified login operations is group identifier for group based logins.
    
    REE kernel is expected to formulate trustworthy client UUID and pass that
    to TEE environment. REE kernel is required to verify that provided group
    identifier for group based logins matches calling processes group
    memberships.
    
    TEE specification only defines that the information passed from REE
    environment to TEE environment is encoded into on UUID.
    
    In order to guarantee trustworthiness of client UUID user space is not
    allowed to freely pass client UUID.
    
    UUIDv5 form is used encode variable amount of information needed for
    different login types.
    
    Signed-off-by: Vesa Jääskeläinen <vesa.jaaskelainen@vaisala.com>
    [jw: remove unused variable application_id]
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 1412e9cc79ce..8471b790e858 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -165,6 +165,22 @@ int tee_device_register(struct tee_device *teedev);
  */
 void tee_device_unregister(struct tee_device *teedev);
 
+/**
+ * tee_session_calc_client_uuid() - Calculates client UUID for session
+ * @uuid:		Resulting UUID
+ * @connection_method:	Connection method for session (TEE_IOCTL_LOGIN_*)
+ * @connectuon_data:	Connection data for opening session
+ *
+ * Based on connection method calculates UUIDv5 based client UUID.
+ *
+ * For group based logins verifies that calling process has specified
+ * credentials.
+ *
+ * @return < 0 on failure
+ */
+int tee_session_calc_client_uuid(uuid_t *uuid, u32 connection_method,
+				 const u8 connection_data[TEE_IOCTL_UUID_LEN]);
+
 /**
  * struct tee_shm - shared memory object
  * @ctx:	context using the object

commit 2a6ba3f794e892c37d67b8ebb19487ce105eabc2
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Fri Mar 27 10:59:47 2020 +0530

    tee: enable support to register kernel memory
    
    Enable support to register kernel memory reference with TEE. This change
    will allow TEE bus drivers to register memory references.
    
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 1412e9cc79ce..e96154d92b1e 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -26,6 +26,7 @@
 #define TEE_SHM_REGISTER	BIT(3)  /* Memory registered in secure world */
 #define TEE_SHM_USER_MAPPED	BIT(4)  /* Memory mapped in user space */
 #define TEE_SHM_POOL		BIT(5)  /* Memory allocated from pool */
+#define TEE_SHM_KERNEL_MAPPED	BIT(6)  /* Memory mapped in kernel space */
 
 struct device;
 struct tee_device;

commit 5271b2011e448f1be7433554e4684e91951476fa
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Thu Nov 7 11:42:59 2019 +0100

    tee: remove redundant teedev in struct tee_shm
    
    The ctx element in struct tee_shm is always valid. So remove the now
    redundant teedev element.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 42687f6c546d..1412e9cc79ce 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -167,8 +167,7 @@ void tee_device_unregister(struct tee_device *teedev);
 
 /**
  * struct tee_shm - shared memory object
- * @teedev:	device used to allocate the object
- * @ctx:	context using the object, if NULL the context is gone
+ * @ctx:	context using the object
  * @paddr:	physical address of the shared memory
  * @kaddr:	virtual address of the shared memory
  * @size:	size of shared memory
@@ -183,7 +182,6 @@ void tee_device_unregister(struct tee_device *teedev);
  * subsystem and from drivers that implements their own shm pool manager.
  */
 struct tee_shm {
-	struct tee_device *teedev;
 	struct tee_context *ctx;
 	phys_addr_t paddr;
 	void *kaddr;

commit c180f9bbe29a403459dd76422f435382aec6adaa
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Thu Nov 7 11:42:52 2019 +0100

    tee: remove unused tee_shm_priv_alloc()
    
    tee_shm_priv_alloc() isn't useful in the current state and it's also not
    not used so remove it.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index cbddb883a7f8..42687f6c546d 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -315,18 +315,6 @@ void *tee_get_drvdata(struct tee_device *teedev);
  */
 struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags);
 
-/**
- * tee_shm_priv_alloc() - Allocate shared memory privately
- * @dev:	Device that allocates the shared memory
- * @size:	Requested size of shared memory
- *
- * Allocates shared memory buffer that is not associated with any client
- * context. Such buffers are owned by TEE driver and used for internal calls.
- *
- * @returns a pointer to 'struct tee_shm'
- */
-struct tee_shm *tee_shm_priv_alloc(struct tee_device *teedev, size_t size);
-
 /**
  * tee_shm_register() - Register shared memory buffer
  * @ctx:	Context that registers the shared memory

commit 59a135f6fb669f4f79f43160c7b8c8d6bfb37f75
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Thu Nov 7 11:42:49 2019 +0100

    tee: remove linked list of struct tee_shm
    
    Removes list_shm from struct tee_context since the linked list isn't used
    any longer.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 7a03f68fb982..cbddb883a7f8 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -49,7 +49,6 @@ struct tee_shm_pool;
  */
 struct tee_context {
 	struct tee_device *teedev;
-	struct list_head list_shm;
 	void *data;
 	struct kref refcount;
 	bool releasing;
@@ -170,7 +169,6 @@ void tee_device_unregister(struct tee_device *teedev);
  * struct tee_shm - shared memory object
  * @teedev:	device used to allocate the object
  * @ctx:	context using the object, if NULL the context is gone
- * @link	link element
  * @paddr:	physical address of the shared memory
  * @kaddr:	virtual address of the shared memory
  * @size:	size of shared memory
@@ -187,7 +185,6 @@ void tee_device_unregister(struct tee_device *teedev);
 struct tee_shm {
 	struct tee_device *teedev;
 	struct tee_context *ctx;
-	struct list_head link;
 	phys_addr_t paddr;
 	void *kaddr;
 	size_t size;

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 4a49f80e7f71..7a03f68fb982 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -1,15 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2015-2016, Linaro Limited
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #ifndef __TEE_DRV_H

commit 4f062dc1b759299851939524ff755b20542d8fc1
Author: Igor Opaniuk <igor.opaniuk@linaro.org>
Date:   Thu Jan 24 19:32:31 2019 +0200

    tee: add cancellation support to client interface
    
    Add support of cancellation request to the TEE kernel internal
    client interface. Can be used by software TPM drivers, that leverage
    TEE under the hood (for instance TPM2.0 mobile profile), for requesting
    cancellation of time-consuming operations (RSA key-pair generation etc.).
    
    Signed-off-by: Igor Opaniuk <igor.opaniuk@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 56d7f1b4516d..4a49f80e7f71 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -535,6 +535,18 @@ int tee_client_invoke_func(struct tee_context *ctx,
 			   struct tee_ioctl_invoke_arg *arg,
 			   struct tee_param *param);
 
+/**
+ * tee_client_cancel_req() - Request cancellation of the previous open-session
+ * or invoke-command operations in a Trusted Application
+ * @ctx:       TEE Context
+ * @arg:       Cancellation arguments, see description of
+ *             struct tee_ioctl_cancel_arg
+ *
+ * Returns < 0 on error else 0 if the cancellation was successfully requested.
+ */
+int tee_client_cancel_req(struct tee_context *ctx,
+			  struct tee_ioctl_cancel_arg *arg);
+
 static inline bool tee_param_is_memref(struct tee_param *param)
 {
 	switch (param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {

commit 0fc1db9d105915021260eb241661b8e96f5c0f1a
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Tue Jan 29 11:19:35 2019 +0530

    tee: add bus driver framework for TEE based devices
    
    Introduce a generic TEE bus driver concept for TEE based kernel drivers
    which would like to communicate with TEE based devices/services. Also
    add support in module device table for these new TEE based devices.
    
    In this TEE bus concept, devices/services are identified via Universally
    Unique Identifier (UUID) and drivers register a table of device UUIDs
    which they can support.
    
    So this TEE bus framework registers following apis:
    - match(): Iterates over the driver UUID table to find a corresponding
      match for device UUID. If a match is found, then this particular device
      is probed via corresponding probe api registered by the driver. This
      process happens whenever a device or a driver is registered with TEE
      bus.
    - uevent(): Notifies user-space (udev) whenever a new device is registered
      on this bus for auto-loading of modularized drivers.
    
    Also this framework allows for device enumeration to be specific to
    corresponding TEE implementation like OP-TEE etc.
    
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Reviewed-by: Bhupesh Sharma <bhsharma@redhat.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 5076502c07d7..56d7f1b4516d 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -15,11 +15,14 @@
 #ifndef __TEE_DRV_H
 #define __TEE_DRV_H
 
-#include <linux/types.h>
+#include <linux/device.h>
 #include <linux/idr.h>
 #include <linux/kref.h>
 #include <linux/list.h>
+#include <linux/mod_devicetable.h>
 #include <linux/tee.h>
+#include <linux/types.h>
+#include <linux/uuid.h>
 
 /*
  * The file describes the API provided by the generic TEE driver to the
@@ -544,4 +547,31 @@ static inline bool tee_param_is_memref(struct tee_param *param)
 	}
 }
 
+extern struct bus_type tee_bus_type;
+
+/**
+ * struct tee_client_device - tee based device
+ * @id:			device identifier
+ * @dev:		device structure
+ */
+struct tee_client_device {
+	struct tee_client_device_id id;
+	struct device dev;
+};
+
+#define to_tee_client_device(d) container_of(d, struct tee_client_device, dev)
+
+/**
+ * struct tee_client_driver - tee client driver
+ * @id_table:		device id table supported by this driver
+ * @driver:		driver structure
+ */
+struct tee_client_driver {
+	const struct tee_client_device_id *id_table;
+	struct device_driver driver;
+};
+
+#define to_tee_client_driver(d) \
+		container_of(d, struct tee_client_driver, driver)
+
 #endif /*__TEE_DRV_H*/

commit 42bf4152d8a79f89f5456dee63a1f364fbce2dd6
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Tue Jan 29 11:19:36 2019 +0530

    tee: add supp_nowait flag in tee_context struct
    
    This flag indicates that requests in this context should not wait for
    tee-supplicant daemon to be started if not present and just return
    with an error code. It is needed for requests which should be
    non-blocking in nature like ones arising from TEE based kernel drivers
    or any in kernel api that uses TEE internal client interface.
    
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 6cfe05893a76..5076502c07d7 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -47,6 +47,11 @@ struct tee_shm_pool;
  * @releasing:  flag that indicates if context is being released right now.
  *		It is needed to break circular dependency on context during
  *              shared memory release.
+ * @supp_nowait: flag that indicates that requests in this context should not
+ *              wait for tee-supplicant daemon to be started if not present
+ *              and just return with an error code. It is needed for requests
+ *              that arises from TEE based kernel drivers that should be
+ *              non-blocking in nature.
  */
 struct tee_context {
 	struct tee_device *teedev;
@@ -54,6 +59,7 @@ struct tee_context {
 	void *data;
 	struct kref refcount;
 	bool releasing;
+	bool supp_nowait;
 };
 
 struct tee_param_memref {

commit 25559c22cef879c5cf7119540bfe21fb379d29f3
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Mon Jul 9 08:15:49 2018 +0200

    tee: add kernel internal client interface
    
    Adds a kernel internal TEE client interface to be used by other drivers.
    
    Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
    Tested-by: Sumit Garg <sumit.garg@linaro.org>
    Tested-by: Zeng Tao <prime.zeng@hisilicon.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index a2b3dfcee0b5..6cfe05893a76 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -453,6 +453,79 @@ static inline int tee_shm_get_id(struct tee_shm *shm)
  */
 struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id);
 
+/**
+ * tee_client_open_context() - Open a TEE context
+ * @start:	if not NULL, continue search after this context
+ * @match:	function to check TEE device
+ * @data:	data for match function
+ * @vers:	if not NULL, version data of TEE device of the context returned
+ *
+ * This function does an operation similar to open("/dev/teeX") in user space.
+ * A returned context must be released with tee_client_close_context().
+ *
+ * Returns a TEE context of the first TEE device matched by the match()
+ * callback or an ERR_PTR.
+ */
+struct tee_context *
+tee_client_open_context(struct tee_context *start,
+			int (*match)(struct tee_ioctl_version_data *,
+				     const void *),
+			const void *data, struct tee_ioctl_version_data *vers);
+
+/**
+ * tee_client_close_context() - Close a TEE context
+ * @ctx:	TEE context to close
+ *
+ * Note that all sessions previously opened with this context will be
+ * closed when this function is called.
+ */
+void tee_client_close_context(struct tee_context *ctx);
+
+/**
+ * tee_client_get_version() - Query version of TEE
+ * @ctx:	TEE context to TEE to query
+ * @vers:	Pointer to version data
+ */
+void tee_client_get_version(struct tee_context *ctx,
+			    struct tee_ioctl_version_data *vers);
+
+/**
+ * tee_client_open_session() - Open a session to a Trusted Application
+ * @ctx:	TEE context
+ * @arg:	Open session arguments, see description of
+ *		struct tee_ioctl_open_session_arg
+ * @param:	Parameters passed to the Trusted Application
+ *
+ * Returns < 0 on error else see @arg->ret for result. If @arg->ret
+ * is TEEC_SUCCESS the session identifier is available in @arg->session.
+ */
+int tee_client_open_session(struct tee_context *ctx,
+			    struct tee_ioctl_open_session_arg *arg,
+			    struct tee_param *param);
+
+/**
+ * tee_client_close_session() - Close a session to a Trusted Application
+ * @ctx:	TEE Context
+ * @session:	Session id
+ *
+ * Return < 0 on error else 0, regardless the session will not be
+ * valid after this function has returned.
+ */
+int tee_client_close_session(struct tee_context *ctx, u32 session);
+
+/**
+ * tee_client_invoke_func() - Invoke a function in a Trusted Application
+ * @ctx:	TEE Context
+ * @arg:	Invoke arguments, see description of
+ *		struct tee_ioctl_invoke_arg
+ * @param:	Parameters passed to the Trusted Application
+ *
+ * Returns < 0 on error else see @arg->ret for result.
+ */
+int tee_client_invoke_func(struct tee_context *ctx,
+			   struct tee_ioctl_invoke_arg *arg,
+			   struct tee_param *param);
+
 static inline bool tee_param_is_memref(struct tee_param *param)
 {
 	switch (param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {

commit ffdc98c4f25b1f4fb96cd9190917b53a760f3fec
Merge: be60566ea9b0 2490cdf6435b
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Jan 11 18:05:06 2018 -0800

    Merge tag 'tee-drv-dynamic-shm+fixes-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee into next/drivers
    
    This pull request updates the previous tee-drv-dynamic-shm-for-v4.16 pull
    request with five new patches fixing review comments and errors.
    
    Apart from three small fixes there's two larger patches that in the end
    checks that memory to be registered really is normal cached memory.
    
    * tag 'tee-drv-dynamic-shm+fixes-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee:
      tee: shm: Potential NULL dereference calling tee_shm_register()
      tee: shm: don't put_page on null shm->pages
      tee: shm: make function __tee_shm_alloc static
      tee: optee: check type of registered shared memory
      tee: add start argument to shm_register callback
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 95ffe4ca43877eea176d7e95aa0d38bbdc3d2903
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Thu Dec 28 10:08:00 2017 +0100

    tee: add start argument to shm_register callback
    
    Adds a start argument to the shm_register callback to allow the callback
    to check memory type of the passed pages.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index a1d7f467657c..230a1ebbf3bc 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -108,7 +108,8 @@ struct tee_driver_ops {
 	int (*supp_send)(struct tee_context *ctx, u32 ret, u32 num_params,
 			 struct tee_param *param);
 	int (*shm_register)(struct tee_context *ctx, struct tee_shm *shm,
-			    struct page **pages, size_t num_pages);
+			    struct page **pages, size_t num_pages,
+			    unsigned long start);
 	int (*shm_unregister)(struct tee_context *ctx, struct tee_shm *shm);
 };
 

commit bad19e0d0460564a067f901b6848c0cc0c403c52
Merge: f9988fbb93c8 ef8e08d24ca8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Dec 21 17:23:52 2017 +0100

    Merge tag 'tee-drv-dynamic-shm-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee into next/drivers
    
    Pull "tee dynamic shm for v4.16" from Jens Wiklander:
    
    This pull request enables dynamic shared memory support in the TEE
    subsystem as a whole and in OP-TEE in particular.
    
    Global Platform TEE specification [1] allows client applications
    to register part of own memory as a shared buffer between
    application and TEE. This allows fast zero-copy communication between
    TEE and REE. But current implementation of TEE in Linux does not support
    this feature.
    
    Also, current implementation of OP-TEE transport uses fixed size
    pre-shared buffer for all communications with OP-TEE OS. This is okay
    in the most use cases. But this prevents use of OP-TEE in virtualized
    environments, because:
     a) We can't share the same buffer between different virtual machines
     b) Physically contiguous memory as seen by VM can be non-contiguous
        in reality (and as seen by OP-TEE OS) due to second stage of
        MMU translation.
     c) Size of this pre-shared buffer is limited.
    
    So, first part of this pull request adds generic register/unregister
    interface to tee subsystem. The second part adds necessary features into
    OP-TEE driver, so it can use not only static pre-shared buffer, but
    whole RAM to communicate with OP-TEE OS.
    
    This change is backwards compatible allowing older secure world or
    user space to work with newer kernels and vice versa.
    
    [1] https://www.globalplatform.org/specificationsdevice.asp
    
    * tag 'tee-drv-dynamic-shm-for-v4.16' of https://git.linaro.org/people/jens.wiklander/linux-tee:
      tee: shm: inline tee_shm_get_id()
      tee: use reference counting for tee_context
      tee: optee: enable dynamic SHM support
      tee: optee: add optee-specific shared pool implementation
      tee: optee: store OP-TEE capabilities in private data
      tee: optee: add registered buffers handling into RPC calls
      tee: optee: add registered shared parameters handling
      tee: optee: add shared buffer registration functions
      tee: optee: add page list manipulation functions
      tee: optee: Update protocol definitions
      tee: shm: add page accessor functions
      tee: shm: add accessors for buffer size and page offset
      tee: add register user memory
      tee: flexible shared memory pool creation

commit ef8e08d24ca84846ce639b835ebd2f15a943f42b
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:38 2017 +0200

    tee: shm: inline tee_shm_get_id()
    
    Now, when struct tee_shm is defined in public header,
    we can inline small getter functions like this one.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 157e8d06bf49..a1d7f467657c 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -438,7 +438,10 @@ static inline size_t tee_shm_get_page_offset(struct tee_shm *shm)
  * @shm:	Shared memory handle
  * @returns id
  */
-int tee_shm_get_id(struct tee_shm *shm);
+static inline int tee_shm_get_id(struct tee_shm *shm)
+{
+	return shm->id;
+}
 
 /**
  * tee_shm_get_from_id() - Find shared memory object and increase reference

commit 217e0250cccb9e54d457991446cd3fab413085e1
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:37 2017 +0200

    tee: use reference counting for tee_context
    
    We need to ensure that tee_context is present until last
    shared buffer will be freed.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 0f86a480c204..157e8d06bf49 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -17,6 +17,7 @@
 
 #include <linux/types.h>
 #include <linux/idr.h>
+#include <linux/kref.h>
 #include <linux/list.h>
 #include <linux/tee.h>
 
@@ -42,11 +43,17 @@ struct tee_shm_pool;
  * @teedev:	pointer to this drivers struct tee_device
  * @list_shm:	List of shared memory object owned by this context
  * @data:	driver specific context data, managed by the driver
+ * @refcount:	reference counter for this structure
+ * @releasing:  flag that indicates if context is being released right now.
+ *		It is needed to break circular dependency on context during
+ *              shared memory release.
  */
 struct tee_context {
 	struct tee_device *teedev;
 	struct list_head list_shm;
 	void *data;
+	struct kref refcount;
+	bool releasing;
 };
 
 struct tee_param_memref {

commit e0c69ae8bfb500facebe1fa331f9400c216eaab0
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:28 2017 +0200

    tee: shm: add page accessor functions
    
    In order to register a shared buffer in TEE, we need accessor
    function that return list of pages for that buffer.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 6838f25e1421..0f86a480c204 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -403,6 +403,19 @@ static inline size_t tee_shm_get_size(struct tee_shm *shm)
 	return shm->size;
 }
 
+/**
+ * tee_shm_get_pages() - Get list of pages that hold shared buffer
+ * @shm:	Shared memory handle
+ * @num_pages:	Number of pages will be stored there
+ * @returns pointer to pages array
+ */
+static inline struct page **tee_shm_get_pages(struct tee_shm *shm,
+					      size_t *num_pages)
+{
+	*num_pages = shm->num_pages;
+	return shm->pages;
+}
+
 /**
  * tee_shm_get_page_offset() - Get shared buffer offset from page start
  * @shm:	Shared memory handle

commit b25946ad951c013c31d0a0e82d2017004bdc8fed
Author: Volodymyr Babchuk <vlad.babchuk@gmail.com>
Date:   Wed Nov 29 14:48:27 2017 +0200

    tee: shm: add accessors for buffer size and page offset
    
    These two function will be needed for shared memory registration in OP-TEE
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 7c8495607b99..6838f25e1421 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -393,6 +393,26 @@ void *tee_shm_get_va(struct tee_shm *shm, size_t offs);
  */
 int tee_shm_get_pa(struct tee_shm *shm, size_t offs, phys_addr_t *pa);
 
+/**
+ * tee_shm_get_size() - Get size of shared memory buffer
+ * @shm:	Shared memory handle
+ * @returns size of shared memory
+ */
+static inline size_t tee_shm_get_size(struct tee_shm *shm)
+{
+	return shm->size;
+}
+
+/**
+ * tee_shm_get_page_offset() - Get shared buffer offset from page start
+ * @shm:	Shared memory handle
+ * @returns page offset of shared buffer
+ */
+static inline size_t tee_shm_get_page_offset(struct tee_shm *shm)
+{
+	return shm->offset;
+}
+
 /**
  * tee_shm_get_id() - Get id of a shared memory object
  * @shm:	Shared memory handle

commit 033ddf12bcf5326b93bd604f50a7474a434a35f9
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Wed Nov 29 14:48:26 2017 +0200

    tee: add register user memory
    
    Added new ioctl to allow users register own buffers as a shared memory.
    
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>
    [jw: moved tee_shm_is_registered() declaration]
    [jw: added space after __tee_shm_alloc() implementation]
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index e9be4a45ff3e..7c8495607b99 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -25,8 +25,12 @@
  * specific TEE driver.
  */
 
-#define TEE_SHM_MAPPED		0x1	/* Memory mapped by the kernel */
-#define TEE_SHM_DMA_BUF		0x2	/* Memory with dma-buf handle */
+#define TEE_SHM_MAPPED		BIT(0)	/* Memory mapped by the kernel */
+#define TEE_SHM_DMA_BUF		BIT(1)	/* Memory with dma-buf handle */
+#define TEE_SHM_EXT_DMA_BUF	BIT(2)	/* Memory with dma-buf handle */
+#define TEE_SHM_REGISTER	BIT(3)  /* Memory registered in secure world */
+#define TEE_SHM_USER_MAPPED	BIT(4)  /* Memory mapped in user space */
+#define TEE_SHM_POOL		BIT(5)  /* Memory allocated from pool */
 
 struct device;
 struct tee_device;
@@ -76,6 +80,8 @@ struct tee_param {
  * @cancel_req:		request cancel of an ongoing invoke or open
  * @supp_revc:		called for supplicant to get a command
  * @supp_send:		called for supplicant to send a response
+ * @shm_register:	register shared memory buffer in TEE
+ * @shm_unregister:	unregister shared memory buffer in TEE
  */
 struct tee_driver_ops {
 	void (*get_version)(struct tee_device *teedev,
@@ -94,6 +100,9 @@ struct tee_driver_ops {
 			 struct tee_param *param);
 	int (*supp_send)(struct tee_context *ctx, u32 ret, u32 num_params,
 			 struct tee_param *param);
+	int (*shm_register)(struct tee_context *ctx, struct tee_shm *shm,
+			    struct page **pages, size_t num_pages);
+	int (*shm_unregister)(struct tee_context *ctx, struct tee_shm *shm);
 };
 
 /**
@@ -301,6 +310,40 @@ void *tee_get_drvdata(struct tee_device *teedev);
  */
 struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags);
 
+/**
+ * tee_shm_priv_alloc() - Allocate shared memory privately
+ * @dev:	Device that allocates the shared memory
+ * @size:	Requested size of shared memory
+ *
+ * Allocates shared memory buffer that is not associated with any client
+ * context. Such buffers are owned by TEE driver and used for internal calls.
+ *
+ * @returns a pointer to 'struct tee_shm'
+ */
+struct tee_shm *tee_shm_priv_alloc(struct tee_device *teedev, size_t size);
+
+/**
+ * tee_shm_register() - Register shared memory buffer
+ * @ctx:	Context that registers the shared memory
+ * @addr:	Address is userspace of the shared buffer
+ * @length:	Length of the shared buffer
+ * @flags:	Flags setting properties for the requested shared memory.
+ *
+ * @returns a pointer to 'struct tee_shm'
+ */
+struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
+				 size_t length, u32 flags);
+
+/**
+ * tee_shm_is_registered() - Check if shared memory object in registered in TEE
+ * @shm:	Shared memory handle
+ * @returns true if object is registered in TEE
+ */
+static inline bool tee_shm_is_registered(struct tee_shm *shm)
+{
+	return shm && (shm->flags & TEE_SHM_REGISTER);
+}
+
 /**
  * tee_shm_free() - Free shared memory
  * @shm:	Handle to shared memory to free

commit e2aca5d8928acb9cc9a87802b02102d4f9b9b596
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Wed Nov 29 14:48:25 2017 +0200

    tee: flexible shared memory pool creation
    
    Makes creation of shm pools more flexible by adding new more primitive
    functions to allocate a shm pool. This makes it easier to add driver
    specific shm pool management.
    
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
    Signed-off-by: Volodymyr Babchuk <vlad.babchuk@gmail.com>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index cb889afe576b..e9be4a45ff3e 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -149,6 +149,97 @@ int tee_device_register(struct tee_device *teedev);
  */
 void tee_device_unregister(struct tee_device *teedev);
 
+/**
+ * struct tee_shm - shared memory object
+ * @teedev:	device used to allocate the object
+ * @ctx:	context using the object, if NULL the context is gone
+ * @link	link element
+ * @paddr:	physical address of the shared memory
+ * @kaddr:	virtual address of the shared memory
+ * @size:	size of shared memory
+ * @offset:	offset of buffer in user space
+ * @pages:	locked pages from userspace
+ * @num_pages:	number of locked pages
+ * @dmabuf:	dmabuf used to for exporting to user space
+ * @flags:	defined by TEE_SHM_* in tee_drv.h
+ * @id:		unique id of a shared memory object on this device
+ *
+ * This pool is only supposed to be accessed directly from the TEE
+ * subsystem and from drivers that implements their own shm pool manager.
+ */
+struct tee_shm {
+	struct tee_device *teedev;
+	struct tee_context *ctx;
+	struct list_head link;
+	phys_addr_t paddr;
+	void *kaddr;
+	size_t size;
+	unsigned int offset;
+	struct page **pages;
+	size_t num_pages;
+	struct dma_buf *dmabuf;
+	u32 flags;
+	int id;
+};
+
+/**
+ * struct tee_shm_pool_mgr - shared memory manager
+ * @ops:		operations
+ * @private_data:	private data for the shared memory manager
+ */
+struct tee_shm_pool_mgr {
+	const struct tee_shm_pool_mgr_ops *ops;
+	void *private_data;
+};
+
+/**
+ * struct tee_shm_pool_mgr_ops - shared memory pool manager operations
+ * @alloc:		called when allocating shared memory
+ * @free:		called when freeing shared memory
+ * @destroy_poolmgr:	called when destroying the pool manager
+ */
+struct tee_shm_pool_mgr_ops {
+	int (*alloc)(struct tee_shm_pool_mgr *poolmgr, struct tee_shm *shm,
+		     size_t size);
+	void (*free)(struct tee_shm_pool_mgr *poolmgr, struct tee_shm *shm);
+	void (*destroy_poolmgr)(struct tee_shm_pool_mgr *poolmgr);
+};
+
+/**
+ * tee_shm_pool_alloc() - Create a shared memory pool from shm managers
+ * @priv_mgr:	manager for driver private shared memory allocations
+ * @dmabuf_mgr:	manager for dma-buf shared memory allocations
+ *
+ * Allocation with the flag TEE_SHM_DMA_BUF set will use the range supplied
+ * in @dmabuf, others will use the range provided by @priv.
+ *
+ * @returns pointer to a 'struct tee_shm_pool' or an ERR_PTR on failure.
+ */
+struct tee_shm_pool *tee_shm_pool_alloc(struct tee_shm_pool_mgr *priv_mgr,
+					struct tee_shm_pool_mgr *dmabuf_mgr);
+
+/*
+ * tee_shm_pool_mgr_alloc_res_mem() - Create a shm manager for reserved
+ * memory
+ * @vaddr:	Virtual address of start of pool
+ * @paddr:	Physical address of start of pool
+ * @size:	Size in bytes of the pool
+ *
+ * @returns pointer to a 'struct tee_shm_pool_mgr' or an ERR_PTR on failure.
+ */
+struct tee_shm_pool_mgr *tee_shm_pool_mgr_alloc_res_mem(unsigned long vaddr,
+							phys_addr_t paddr,
+							size_t size,
+							int min_alloc_order);
+
+/**
+ * tee_shm_pool_mgr_destroy() - Free a shared memory manager
+ */
+static inline void tee_shm_pool_mgr_destroy(struct tee_shm_pool_mgr *poolm)
+{
+	poolm->ops->destroy_poolmgr(poolm);
+}
+
 /**
  * struct tee_shm_pool_mem_info - holds information needed to create a shared
  * memory pool

commit 84debcc53533f162bf11f24e6a503d227c175cbe
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Fri Dec 23 13:13:27 2016 +0100

    tee: add tee_param_is_memref() for driver use
    
    Reviewed-by: Etienne Carriere <etienne.carriere@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index cb889afe576b..f4a0ac05ebb4 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -275,4 +275,16 @@ int tee_shm_get_id(struct tee_shm *shm);
  */
 struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id);
 
+static inline bool tee_param_is_memref(struct tee_param *param)
+{
+	switch (param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+		return true;
+	default:
+		return false;
+	}
+}
+
 #endif /*__TEE_DRV_H*/

commit 999616b8536cf3b9a1d0d74d5542ea009df482ff
Author: Jerome Forissier <jerome.forissier@linaro.org>
Date:   Wed May 31 13:21:05 2017 +0200

    tee: add forward declaration for struct device
    
    tee_drv.h references struct device, but does not include device.h nor
    platform_device.h. Therefore, if tee_drv.h is included by some file
    that does not pull device.h nor platform_device.h beforehand, we have a
    compile warning. Fix this by adding a forward declaration.
    
    Signed-off-by: Jerome Forissier <jerome.forissier@linaro.org>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 0f175b8f6456..cb889afe576b 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -28,6 +28,7 @@
 #define TEE_SHM_MAPPED		0x1	/* Memory mapped by the kernel */
 #define TEE_SHM_DMA_BUF		0x2	/* Memory with dma-buf handle */
 
+struct device;
 struct tee_device;
 struct tee_shm;
 struct tee_shm_pool;

commit 967c9cca2cc50569efc65945325c173cecba83bd
Author: Jens Wiklander <jens.wiklander@linaro.org>
Date:   Wed Mar 11 14:39:39 2015 +0100

    tee: generic TEE subsystem
    
    Initial patch for generic TEE subsystem.
    This subsystem provides:
    * Registration/un-registration of TEE drivers.
    * Shared memory between normal world and secure world.
    * Ioctl interface for interaction with user space.
    * Sysfs implementation_id of TEE driver
    
    A TEE (Trusted Execution Environment) driver is a driver that interfaces
    with a trusted OS running in some secure environment, for example,
    TrustZone on ARM cpus, or a separate secure co-processor etc.
    
    The TEE subsystem can serve a TEE driver for a Global Platform compliant
    TEE, but it's not limited to only Global Platform TEEs.
    
    This patch builds on other similar implementations trying to solve
    the same problem:
    * "optee_linuxdriver" by among others
      Jean-michel DELORME<jean-michel.delorme@st.com> and
      Emmanuel MICHEL <emmanuel.michel@st.com>
    * "Generic TrustZone Driver" by Javier González <javier@javigon.com>
    
    Acked-by: Andreas Dannenberg <dannenberg@ti.com>
    Tested-by: Jerome Forissier <jerome.forissier@linaro.org> (HiKey)
    Tested-by: Volodymyr Babchuk <vlad.babchuk@gmail.com> (RCAR H3)
    Tested-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Javier González <javier@javigon.com>
    Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>

diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
new file mode 100644
index 000000000000..0f175b8f6456
--- /dev/null
+++ b/include/linux/tee_drv.h
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __TEE_DRV_H
+#define __TEE_DRV_H
+
+#include <linux/types.h>
+#include <linux/idr.h>
+#include <linux/list.h>
+#include <linux/tee.h>
+
+/*
+ * The file describes the API provided by the generic TEE driver to the
+ * specific TEE driver.
+ */
+
+#define TEE_SHM_MAPPED		0x1	/* Memory mapped by the kernel */
+#define TEE_SHM_DMA_BUF		0x2	/* Memory with dma-buf handle */
+
+struct tee_device;
+struct tee_shm;
+struct tee_shm_pool;
+
+/**
+ * struct tee_context - driver specific context on file pointer data
+ * @teedev:	pointer to this drivers struct tee_device
+ * @list_shm:	List of shared memory object owned by this context
+ * @data:	driver specific context data, managed by the driver
+ */
+struct tee_context {
+	struct tee_device *teedev;
+	struct list_head list_shm;
+	void *data;
+};
+
+struct tee_param_memref {
+	size_t shm_offs;
+	size_t size;
+	struct tee_shm *shm;
+};
+
+struct tee_param_value {
+	u64 a;
+	u64 b;
+	u64 c;
+};
+
+struct tee_param {
+	u64 attr;
+	union {
+		struct tee_param_memref memref;
+		struct tee_param_value value;
+	} u;
+};
+
+/**
+ * struct tee_driver_ops - driver operations vtable
+ * @get_version:	returns version of driver
+ * @open:		called when the device file is opened
+ * @release:		release this open file
+ * @open_session:	open a new session
+ * @close_session:	close a session
+ * @invoke_func:	invoke a trusted function
+ * @cancel_req:		request cancel of an ongoing invoke or open
+ * @supp_revc:		called for supplicant to get a command
+ * @supp_send:		called for supplicant to send a response
+ */
+struct tee_driver_ops {
+	void (*get_version)(struct tee_device *teedev,
+			    struct tee_ioctl_version_data *vers);
+	int (*open)(struct tee_context *ctx);
+	void (*release)(struct tee_context *ctx);
+	int (*open_session)(struct tee_context *ctx,
+			    struct tee_ioctl_open_session_arg *arg,
+			    struct tee_param *param);
+	int (*close_session)(struct tee_context *ctx, u32 session);
+	int (*invoke_func)(struct tee_context *ctx,
+			   struct tee_ioctl_invoke_arg *arg,
+			   struct tee_param *param);
+	int (*cancel_req)(struct tee_context *ctx, u32 cancel_id, u32 session);
+	int (*supp_recv)(struct tee_context *ctx, u32 *func, u32 *num_params,
+			 struct tee_param *param);
+	int (*supp_send)(struct tee_context *ctx, u32 ret, u32 num_params,
+			 struct tee_param *param);
+};
+
+/**
+ * struct tee_desc - Describes the TEE driver to the subsystem
+ * @name:	name of driver
+ * @ops:	driver operations vtable
+ * @owner:	module providing the driver
+ * @flags:	Extra properties of driver, defined by TEE_DESC_* below
+ */
+#define TEE_DESC_PRIVILEGED	0x1
+struct tee_desc {
+	const char *name;
+	const struct tee_driver_ops *ops;
+	struct module *owner;
+	u32 flags;
+};
+
+/**
+ * tee_device_alloc() - Allocate a new struct tee_device instance
+ * @teedesc:	Descriptor for this driver
+ * @dev:	Parent device for this device
+ * @pool:	Shared memory pool, NULL if not used
+ * @driver_data: Private driver data for this device
+ *
+ * Allocates a new struct tee_device instance. The device is
+ * removed by tee_device_unregister().
+ *
+ * @returns a pointer to a 'struct tee_device' or an ERR_PTR on failure
+ */
+struct tee_device *tee_device_alloc(const struct tee_desc *teedesc,
+				    struct device *dev,
+				    struct tee_shm_pool *pool,
+				    void *driver_data);
+
+/**
+ * tee_device_register() - Registers a TEE device
+ * @teedev:	Device to register
+ *
+ * tee_device_unregister() need to be called to remove the @teedev if
+ * this function fails.
+ *
+ * @returns < 0 on failure
+ */
+int tee_device_register(struct tee_device *teedev);
+
+/**
+ * tee_device_unregister() - Removes a TEE device
+ * @teedev:	Device to unregister
+ *
+ * This function should be called to remove the @teedev even if
+ * tee_device_register() hasn't been called yet. Does nothing if
+ * @teedev is NULL.
+ */
+void tee_device_unregister(struct tee_device *teedev);
+
+/**
+ * struct tee_shm_pool_mem_info - holds information needed to create a shared
+ * memory pool
+ * @vaddr:	Virtual address of start of pool
+ * @paddr:	Physical address of start of pool
+ * @size:	Size in bytes of the pool
+ */
+struct tee_shm_pool_mem_info {
+	unsigned long vaddr;
+	phys_addr_t paddr;
+	size_t size;
+};
+
+/**
+ * tee_shm_pool_alloc_res_mem() - Create a shared memory pool from reserved
+ * memory range
+ * @priv_info:	 Information for driver private shared memory pool
+ * @dmabuf_info: Information for dma-buf shared memory pool
+ *
+ * Start and end of pools will must be page aligned.
+ *
+ * Allocation with the flag TEE_SHM_DMA_BUF set will use the range supplied
+ * in @dmabuf, others will use the range provided by @priv.
+ *
+ * @returns pointer to a 'struct tee_shm_pool' or an ERR_PTR on failure.
+ */
+struct tee_shm_pool *
+tee_shm_pool_alloc_res_mem(struct tee_shm_pool_mem_info *priv_info,
+			   struct tee_shm_pool_mem_info *dmabuf_info);
+
+/**
+ * tee_shm_pool_free() - Free a shared memory pool
+ * @pool:	The shared memory pool to free
+ *
+ * The must be no remaining shared memory allocated from this pool when
+ * this function is called.
+ */
+void tee_shm_pool_free(struct tee_shm_pool *pool);
+
+/**
+ * tee_get_drvdata() - Return driver_data pointer
+ * @returns the driver_data pointer supplied to tee_register().
+ */
+void *tee_get_drvdata(struct tee_device *teedev);
+
+/**
+ * tee_shm_alloc() - Allocate shared memory
+ * @ctx:	Context that allocates the shared memory
+ * @size:	Requested size of shared memory
+ * @flags:	Flags setting properties for the requested shared memory.
+ *
+ * Memory allocated as global shared memory is automatically freed when the
+ * TEE file pointer is closed. The @flags field uses the bits defined by
+ * TEE_SHM_* above. TEE_SHM_MAPPED must currently always be set. If
+ * TEE_SHM_DMA_BUF global shared memory will be allocated and associated
+ * with a dma-buf handle, else driver private memory.
+ *
+ * @returns a pointer to 'struct tee_shm'
+ */
+struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags);
+
+/**
+ * tee_shm_free() - Free shared memory
+ * @shm:	Handle to shared memory to free
+ */
+void tee_shm_free(struct tee_shm *shm);
+
+/**
+ * tee_shm_put() - Decrease reference count on a shared memory handle
+ * @shm:	Shared memory handle
+ */
+void tee_shm_put(struct tee_shm *shm);
+
+/**
+ * tee_shm_va2pa() - Get physical address of a virtual address
+ * @shm:	Shared memory handle
+ * @va:		Virtual address to tranlsate
+ * @pa:		Returned physical address
+ * @returns 0 on success and < 0 on failure
+ */
+int tee_shm_va2pa(struct tee_shm *shm, void *va, phys_addr_t *pa);
+
+/**
+ * tee_shm_pa2va() - Get virtual address of a physical address
+ * @shm:	Shared memory handle
+ * @pa:		Physical address to tranlsate
+ * @va:		Returned virtual address
+ * @returns 0 on success and < 0 on failure
+ */
+int tee_shm_pa2va(struct tee_shm *shm, phys_addr_t pa, void **va);
+
+/**
+ * tee_shm_get_va() - Get virtual address of a shared memory plus an offset
+ * @shm:	Shared memory handle
+ * @offs:	Offset from start of this shared memory
+ * @returns virtual address of the shared memory + offs if offs is within
+ *	the bounds of this shared memory, else an ERR_PTR
+ */
+void *tee_shm_get_va(struct tee_shm *shm, size_t offs);
+
+/**
+ * tee_shm_get_pa() - Get physical address of a shared memory plus an offset
+ * @shm:	Shared memory handle
+ * @offs:	Offset from start of this shared memory
+ * @pa:		Physical address to return
+ * @returns 0 if offs is within the bounds of this shared memory, else an
+ *	error code.
+ */
+int tee_shm_get_pa(struct tee_shm *shm, size_t offs, phys_addr_t *pa);
+
+/**
+ * tee_shm_get_id() - Get id of a shared memory object
+ * @shm:	Shared memory handle
+ * @returns id
+ */
+int tee_shm_get_id(struct tee_shm *shm);
+
+/**
+ * tee_shm_get_from_id() - Find shared memory object and increase reference
+ * count
+ * @ctx:	Context owning the shared memory
+ * @id:		Id of shared memory object
+ * @returns a pointer to 'struct tee_shm' on success or an ERR_PTR on failure
+ */
+struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id);
+
+#endif /*__TEE_DRV_H*/
