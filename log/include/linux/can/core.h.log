commit 975987e7015bb12a482df7f14fd524417d2c8e8f
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Thu Nov 7 11:55:42 2019 +0100

    can: af_can: export can_sock_destruct()
    
    In j1939 we need our own struct sock::sk_destruct callback. Export the
    generic af_can can_sock_destruct() that allows us to chain-call it.
    
    Fixes: 9d71dd0c7009 ("can: add support of SAE J1939 protocol")
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 8339071ab08b..e20a0cd09ba5 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -65,5 +65,6 @@ extern void can_rx_unregister(struct net *net, struct net_device *dev,
 			      void *data);
 
 extern int can_send(struct sk_buff *skb, int loop);
+void can_sock_destruct(struct sock *sk);
 
 #endif /* !_CAN_CORE_H */

commit 9868b5d44f3df9dd75247acd23dddff0a42f79be
Author: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
Date:   Mon Oct 8 11:48:33 2018 +0200

    can: introduce CAN_REQUIRED_SIZE macro
    
    The size of this structure will be increased with J1939 support. To stay
    binary compatible, the CAN_REQUIRED_SIZE macro is introduced for
    existing CAN protocols.
    
    Signed-off-by: Kurt Van Dijck <dev.kurt@vandijck-laurijssen.be>
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 708c10d3417a..8339071ab08b 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -41,6 +41,14 @@ struct can_proto {
 	struct proto *prot;
 };
 
+/* required_size
+ * macro to find the minimum size of a struct
+ * that includes a requested member
+ */
+#define CAN_REQUIRED_SIZE(struct_type, member) \
+	(offsetof(typeof(struct_type), member) + \
+	 sizeof(((typeof(struct_type) *)(NULL))->member))
+
 /* function prototypes for the CAN networklayer core (af_can.c) */
 
 extern int  can_proto_register(const struct can_proto *cp);

commit fba76a58452694b9b13c07e48839fa84c75f57af
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Tue Jul 23 15:17:55 2019 +0200

    can: Add SPDX license identifiers for CAN subsystem
    
    Add missing SPDX identifiers for the CAN network layer and correct the SPDX
    license for two of its include files to make sure the BSD-3-Clause applies
    for the entire subsystem.
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index f8284a94a13d..708c10d3417a 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: GPL-2.0 */
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause) */
 /*
  * linux/can/core.h
  *

commit 60649d4e0af6c26b6c423dea9c57f39e823fc0c5
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Tue Jul 23 14:08:47 2019 +0200

    can: remove obsolete empty ioctl() handler
    
    With commit c7cbdbf29f488a ("net: rework SIOCGSTAMP ioctl handling") the only
    ioctl function in can_ioctl() has been removed.
    
    As this SIOCGSTAMP ioctl command is now handled in net/socket.c we can entirely
    remove the CAN specific ioctl functions.
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 6099bc18bd0c..f8284a94a13d 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -57,6 +57,5 @@ extern void can_rx_unregister(struct net *net, struct net_device *dev,
 			      void *data);
 
 extern int can_send(struct sk_buff *skb, int loop);
-extern int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 
 #endif /* !_CAN_CORE_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index c9a17bb1221c..6099bc18bd0c 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * linux/can/core.h
  *

commit cb5635a3677679666e4e81ecbb209d32f13dedcd
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Tue Apr 25 08:19:41 2017 +0200

    can: complete initial namespace support
    
    The statistics and its proc output was not implemented as per-net in the
    initial network namespace support by Mario Kicherer (8e8cda6d737d).
    This patch adds the missing per-net statistics for the CAN subsystem.
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 319a0da827b8..c9a17bb1221c 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -5,7 +5,7 @@
  *
  * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
  *          Urs Thuermann   <urs.thuermann@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * Copyright (c) 2002-2017 Volkswagen Group Electronic Research
  * All rights reserved.
  *
  */
@@ -17,7 +17,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 
-#define CAN_VERSION "20120528"
+#define CAN_VERSION "20170425"
 
 /* increment this number each time you change some user-space interface */
 #define CAN_ABI_VERSION "9"

commit 8e8cda6d737d356054c9eeef642aec0e8ae7e6bc
Author: Mario Kicherer <dev@kicherer.org>
Date:   Tue Feb 21 12:19:47 2017 +0100

    can: initial support for network namespaces
    
    This patch adds initial support for network namespaces. The changes only
    enable support in the CAN raw, proc and af_can code. GW and BCM still
    have their checks that ensure that they are used only from the main
    namespace.
    
    The patch boils down to moving the global structures, i.e. the global
    filter list and their /proc stats, into a per-namespace structure and passing
    around the corresponding "struct net" in a lot of different places.
    
    Changes since v1:
     - rebased on current HEAD (2bfe01e)
     - fixed overlong line
    
    Signed-off-by: Mario Kicherer <dev@kicherer.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index df08a41d5be5..319a0da827b8 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -45,12 +45,13 @@ struct can_proto {
 extern int  can_proto_register(const struct can_proto *cp);
 extern void can_proto_unregister(const struct can_proto *cp);
 
-int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,
+int can_rx_register(struct net *net, struct net_device *dev,
+		    canid_t can_id, canid_t mask,
 		    void (*func)(struct sk_buff *, void *),
 		    void *data, char *ident, struct sock *sk);
 
-extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
-			      canid_t mask,
+extern void can_rx_unregister(struct net *net, struct net_device *dev,
+			      canid_t can_id, canid_t mask,
 			      void (*func)(struct sk_buff *, void *),
 			      void *data);
 

commit f1712c73714088a7252d276a57126d56c7d37e64
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Jan 27 08:11:44 2017 -0800

    can: Fix kernel panic at security_sock_rcv_skb
    
    Zhang Yanmin reported crashes [1] and provided a patch adding a
    synchronize_rcu() call in can_rx_unregister()
    
    The main problem seems that the sockets themselves are not RCU
    protected.
    
    If CAN uses RCU for delivery, then sockets should be freed only after
    one RCU grace period.
    
    Recent kernels could use sock_set_flag(sk, SOCK_RCU_FREE), but let's
    ease stable backports with the following fix instead.
    
    [1]
    BUG: unable to handle kernel NULL pointer dereference at (null)
    IP: [<ffffffff81495e25>] selinux_socket_sock_rcv_skb+0x65/0x2a0
    
    Call Trace:
     <IRQ>
     [<ffffffff81485d8c>] security_sock_rcv_skb+0x4c/0x60
     [<ffffffff81d55771>] sk_filter+0x41/0x210
     [<ffffffff81d12913>] sock_queue_rcv_skb+0x53/0x3a0
     [<ffffffff81f0a2b3>] raw_rcv+0x2a3/0x3c0
     [<ffffffff81f06eab>] can_rcv_filter+0x12b/0x370
     [<ffffffff81f07af9>] can_receive+0xd9/0x120
     [<ffffffff81f07beb>] can_rcv+0xab/0x100
     [<ffffffff81d362ac>] __netif_receive_skb_core+0xd8c/0x11f0
     [<ffffffff81d36734>] __netif_receive_skb+0x24/0xb0
     [<ffffffff81d37f67>] process_backlog+0x127/0x280
     [<ffffffff81d36f7b>] net_rx_action+0x33b/0x4f0
     [<ffffffff810c88d4>] __do_softirq+0x184/0x440
     [<ffffffff81f9e86c>] do_softirq_own_stack+0x1c/0x30
     <EOI>
     [<ffffffff810c76fb>] do_softirq.part.18+0x3b/0x40
     [<ffffffff810c8bed>] do_softirq+0x1d/0x20
     [<ffffffff81d30085>] netif_rx_ni+0xe5/0x110
     [<ffffffff8199cc87>] slcan_receive_buf+0x507/0x520
     [<ffffffff8167ef7c>] flush_to_ldisc+0x21c/0x230
     [<ffffffff810e3baf>] process_one_work+0x24f/0x670
     [<ffffffff810e44ed>] worker_thread+0x9d/0x6f0
     [<ffffffff810e4450>] ? rescuer_thread+0x480/0x480
     [<ffffffff810ebafc>] kthread+0x12c/0x150
     [<ffffffff81f9ccef>] ret_from_fork+0x3f/0x70
    
    Reported-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index a0875001b13c..df08a41d5be5 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -45,10 +45,9 @@ struct can_proto {
 extern int  can_proto_register(const struct can_proto *cp);
 extern void can_proto_unregister(const struct can_proto *cp);
 
-extern int  can_rx_register(struct net_device *dev, canid_t can_id,
-			    canid_t mask,
-			    void (*func)(struct sk_buff *, void *),
-			    void *data, char *ident);
+int can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,
+		    void (*func)(struct sk_buff *, void *),
+		    void *data, char *ident, struct sock *sk);
 
 extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
 			      canid_t mask,

commit 42193e3efb632c84d686acacd7b2327f2b1f8c63
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Thu May 15 20:31:56 2014 +0200

    can: unify identifiers to ensure unique include processing
    
    Armin pointed me to the fact that the identifier which is used to ensure the
    unique include processing in lunux/include/uapi/linux/can.h is CAN_H.
    This clashed with his own source as includes from libraries and APIs should
    use an underscore '_' at the identifier start.
    
    This patch fixes the protection identifiers in all CAN relavant includes.
    
    Reported-by: Armin Burchardt <armin@uni-bremen.de>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 78c6c52073ad..a0875001b13c 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -10,8 +10,8 @@
  *
  */
 
-#ifndef CAN_CORE_H
-#define CAN_CORE_H
+#ifndef _CAN_CORE_H
+#define _CAN_CORE_H
 
 #include <linux/can.h>
 #include <linux/skbuff.h>
@@ -58,4 +58,4 @@ extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
 extern int can_send(struct sk_buff *skb, int loop);
 extern int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 
-#endif /* CAN_CORE_H */
+#endif /* !_CAN_CORE_H */

commit 8b01939f358d680cea971151375268cfdb6b9635
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Wed Jun 13 20:33:02 2012 +0200

    canfd: add support for CAN FD in PF_CAN core
    
    - handle ETH_P_CAN and ETH_P_CANFD skbuffs
    - update sanity checks for CAN and CAN FD
    - make sure the CAN frame can pass the selected CAN netdevice on send
    - bump core version and abi version to indicate the new CAN FD support
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 0ccc1cd28b95..78c6c52073ad 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -17,10 +17,10 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 
-#define CAN_VERSION "20090105"
+#define CAN_VERSION "20120528"
 
 /* increment this number each time you change some user-space interface */
-#define CAN_ABI_VERSION "8"
+#define CAN_ABI_VERSION "9"
 
 #define CAN_VERSION_STRING "rev " CAN_VERSION " abi " CAN_ABI_VERSION
 

commit f861c2b80c45954e1ea04ead24cafcb1806dd536
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Oct 17 09:32:00 2011 +0000

    can: remove references to berlios mailinglist
    
    The BerliOS project, which currently hosts our mailinglist, will
    close with the end of the year. Now take the chance and remove all
    occurrences of the mailinglist address from the source files.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 5ce6b5d62ecc..0ccc1cd28b95 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -8,8 +8,6 @@
  * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
  * All rights reserved.
  *
- * Send feedback to <socketcan-users@lists.berlios.de>
- *
  */
 
 #ifndef CAN_CORE_H

commit 1650629d1800bf05ad775f974e931ca2fa03b0ff
Author: Kurt Van Dijck <kurt.van.dijck@eia.be>
Date:   Tue May 3 18:40:57 2011 +0000

    can: make struct can_proto const
    
    commit 53914b67993c724cec585863755c9ebc8446e83b had the
    same message. That commit did put everything in place but
    did not make can_proto const itself.
    
    Signed-off-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 6f70a6d3a16e..5ce6b5d62ecc 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -44,8 +44,8 @@ struct can_proto {
 
 /* function prototypes for the CAN networklayer core (af_can.c) */
 
-extern int  can_proto_register(struct can_proto *cp);
-extern void can_proto_unregister(struct can_proto *cp);
+extern int  can_proto_register(const struct can_proto *cp);
+extern void can_proto_unregister(const struct can_proto *cp);
 
 extern int  can_rx_register(struct net_device *dev, canid_t can_id,
 			    canid_t mask,

commit 53914b67993c724cec585863755c9ebc8446e83b
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Tue Mar 22 08:27:25 2011 +0000

    can: make struct proto const
    
    can_ioctl is the only reason for struct proto to be non-const.
    script/check-patch.pl suggests struct proto be const.
    
    Setting the reference to the common can_ioctl() in all CAN protocols directly
    removes the need to make the struct proto writable in af_can.c
    
    Signed-off-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 6c507bea275f..6f70a6d3a16e 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -36,10 +36,10 @@
  * @prot:       pointer to struct proto structure.
  */
 struct can_proto {
-	int              type;
-	int              protocol;
-	struct proto_ops *ops;
-	struct proto     *prot;
+	int type;
+	int protocol;
+	const struct proto_ops *ops;
+	struct proto *prot;
 };
 
 /* function prototypes for the CAN networklayer core (af_can.c) */
@@ -58,5 +58,6 @@ extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
 			      void *data);
 
 extern int can_send(struct sk_buff *skb, int loop);
+extern int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 
 #endif /* CAN_CORE_H */

commit 13f18aa05f5abe135f47b6417537ae2b2fedc18c
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Nov 5 20:44:37 2009 -0800

    net: drop capability from protocol definitions
    
    struct can_proto had a capability field which wasn't ever used.  It is
    dropped entirely.
    
    struct inet_protosw had a capability field which can be more clearly
    expressed in the code by just checking if sock->type = SOCK_RAW.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index 25085cbadcfc..6c507bea275f 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -32,14 +32,12 @@
  * struct can_proto - CAN protocol structure
  * @type:       type argument in socket() syscall, e.g. SOCK_DGRAM.
  * @protocol:   protocol number in socket() syscall.
- * @capability: capability needed to open the socket, or -1 for no restriction.
  * @ops:        pointer to struct proto_ops for sock->ops.
  * @prot:       pointer to struct proto structure.
  */
 struct can_proto {
 	int              type;
 	int              protocol;
-	int              capability;
 	struct proto_ops *ops;
 	struct proto     *prot;
 };

commit 1fa17d4ba43d7e5aab5e90777b07da06524f6748
Author: Oliver Hartkopp <oliver@hartkopp.net>
Date:   Tue Jan 6 11:07:54 2009 -0800

    can: omit unneeded skb_clone() calls
    
    The AF_CAN core delivered always cloned sk_buffs to the AF_CAN
    protocols, although this was _only_ needed by the can-raw protocol.
    With this (additionally documented) change, the AF_CAN core calls the
    callback functions of the registered AF_CAN protocols with the original
    (uncloned) sk_buff pointer and let's the can-raw protocol do the
    skb_clone() itself which omits all unneeded skb_clone() calls for other
    AF_CAN protocols.
    
    Signed-off-by: Oliver Hartkopp <oliver@hartkopp.net>
    Signed-off-by: Urs Thuermann <urs.thuermann@volkswagen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index f50785ad4781..25085cbadcfc 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -19,7 +19,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 
-#define CAN_VERSION "20081130"
+#define CAN_VERSION "20090105"
 
 /* increment this number each time you change some user-space interface */
 #define CAN_ABI_VERSION "8"

commit d253eee20195b25e298bf162a6e72f14bf4803e5
Author: Oliver Hartkopp <oliver@hartkopp.net>
Date:   Wed Dec 3 15:52:35 2008 -0800

    can: Fix CAN_(EFF|RTR)_FLAG handling in can_filter
    
    Due to a wrong safety check in af_can.c it was not possible to filter
    for SFF frames with a specific CAN identifier without getting the
    same selected CAN identifier from a received EFF frame also.
    
    This fix has a minimum (but user visible) impact on the CAN filter
    API and therefore the CAN version is set to a new date.
    
    Indeed the 'old' API is still working as-is. But when now setting
    CAN_(EFF|RTR)_FLAG in can_filter.can_mask you might get less traffic
    than before - but still the stuff that you expected to get for your
    defined filter ...
    
    Thanks to Kurt Van Dijck for pointing at this issue and for the review.
    
    Signed-off-by: Oliver Hartkopp <oliver@hartkopp.net>
    Acked-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index e9ca210ffa5b..f50785ad4781 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -19,7 +19,7 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 
-#define CAN_VERSION "20071116"
+#define CAN_VERSION "20081130"
 
 /* increment this number each time you change some user-space interface */
 #define CAN_ABI_VERSION "8"

commit 0d66548a10cbbe0ef256852d63d30603f0f73f9b
Author: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
Date:   Fri Nov 16 15:52:17 2007 -0800

    [CAN]: Add PF_CAN core module
    
    This patch adds the CAN core functionality but no protocols or drivers.
    No protocol implementations are included here.  They come as separate
    patches.  Protocol numbers are already in include/linux/can.h.
    
    Signed-off-by: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
    Signed-off-by: Urs Thuermann <urs.thuermann@volkswagen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/core.h b/include/linux/can/core.h
new file mode 100644
index 000000000000..e9ca210ffa5b
--- /dev/null
+++ b/include/linux/can/core.h
@@ -0,0 +1,64 @@
+/*
+ * linux/can/core.h
+ *
+ * Protoypes and definitions for CAN protocol modules using the PF_CAN core
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ */
+
+#ifndef CAN_CORE_H
+#define CAN_CORE_H
+
+#include <linux/can.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#define CAN_VERSION "20071116"
+
+/* increment this number each time you change some user-space interface */
+#define CAN_ABI_VERSION "8"
+
+#define CAN_VERSION_STRING "rev " CAN_VERSION " abi " CAN_ABI_VERSION
+
+#define DNAME(dev) ((dev) ? (dev)->name : "any")
+
+/**
+ * struct can_proto - CAN protocol structure
+ * @type:       type argument in socket() syscall, e.g. SOCK_DGRAM.
+ * @protocol:   protocol number in socket() syscall.
+ * @capability: capability needed to open the socket, or -1 for no restriction.
+ * @ops:        pointer to struct proto_ops for sock->ops.
+ * @prot:       pointer to struct proto structure.
+ */
+struct can_proto {
+	int              type;
+	int              protocol;
+	int              capability;
+	struct proto_ops *ops;
+	struct proto     *prot;
+};
+
+/* function prototypes for the CAN networklayer core (af_can.c) */
+
+extern int  can_proto_register(struct can_proto *cp);
+extern void can_proto_unregister(struct can_proto *cp);
+
+extern int  can_rx_register(struct net_device *dev, canid_t can_id,
+			    canid_t mask,
+			    void (*func)(struct sk_buff *, void *),
+			    void *data, char *ident);
+
+extern void can_rx_unregister(struct net_device *dev, canid_t can_id,
+			      canid_t mask,
+			      void (*func)(struct sk_buff *, void *),
+			      void *data);
+
+extern int can_send(struct sk_buff *skb, int loop);
+
+#endif /* CAN_CORE_H */
