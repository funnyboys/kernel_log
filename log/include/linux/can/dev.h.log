commit e7153bf70c3496bac00e7e4f395bb8d8394ac0ea
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Sat Dec 7 19:34:18 2019 +0100

    can: can_dropped_invalid_skb(): ensure an initialized headroom in outgoing CAN sk_buffs
    
    KMSAN sysbot detected a read access to an untinitialized value in the
    headroom of an outgoing CAN related sk_buff. When using CAN sockets this
    area is filled appropriately - but when using a packet socket this
    initialization is missing.
    
    The problematic read access occurs in the CAN receive path which can
    only be triggered when the sk_buff is sent through a (virtual) CAN
    interface. So we check in the sending path whether we need to perform
    the missing initializations.
    
    Fixes: d3b58c47d330d ("can: replace timestamp as unique skb attribute")
    Reported-by: syzbot+b02ff0707a97e4e79ebb@syzkaller.appspotmail.com
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Tested-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Cc: linux-stable <stable@vger.kernel.org> # >= v4.1
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 9b3c720a31b1..5e3d45525bd3 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -18,6 +18,7 @@
 #include <linux/can/error.h>
 #include <linux/can/led.h>
 #include <linux/can/netlink.h>
+#include <linux/can/skb.h>
 #include <linux/netdevice.h>
 
 /*
@@ -91,6 +92,36 @@ struct can_priv {
 #define get_can_dlc(i)		(min_t(__u8, (i), CAN_MAX_DLC))
 #define get_canfd_dlc(i)	(min_t(__u8, (i), CANFD_MAX_DLC))
 
+/* Check for outgoing skbs that have not been created by the CAN subsystem */
+static inline bool can_skb_headroom_valid(struct net_device *dev,
+					  struct sk_buff *skb)
+{
+	/* af_packet creates a headroom of HH_DATA_MOD bytes which is fine */
+	if (WARN_ON_ONCE(skb_headroom(skb) < sizeof(struct can_skb_priv)))
+		return false;
+
+	/* af_packet does not apply CAN skb specific settings */
+	if (skb->ip_summed == CHECKSUM_NONE) {
+		/* init headroom */
+		can_skb_prv(skb)->ifindex = dev->ifindex;
+		can_skb_prv(skb)->skbcnt = 0;
+
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+		/* preform proper loopback on capable devices */
+		if (dev->flags & IFF_ECHO)
+			skb->pkt_type = PACKET_LOOPBACK;
+		else
+			skb->pkt_type = PACKET_HOST;
+
+		skb_reset_mac_header(skb);
+		skb_reset_network_header(skb);
+		skb_reset_transport_header(skb);
+	}
+
+	return true;
+}
+
 /* Drop a given socketbuffer if it does not contain a valid CAN frame. */
 static inline bool can_dropped_invalid_skb(struct net_device *dev,
 					  struct sk_buff *skb)
@@ -108,6 +139,9 @@ static inline bool can_dropped_invalid_skb(struct net_device *dev,
 	} else
 		goto inval_skb;
 
+	if (!can_skb_headroom_valid(dev, skb))
+		goto inval_skb;
+
 	return false;
 
 inval_skb:

commit d7bda73070201514d0d254f451c11bcc9b5890f1
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Tue Aug 27 13:53:18 2019 +0200

    can: dev: avoid long lines
    
    This patch fixes long lines in the generic CAN device infrastructure.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index f01623aef2f7..9b3c720a31b1 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -169,7 +169,8 @@ void can_change_state(struct net_device *dev, struct can_frame *cf,
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
-struct sk_buff *__can_get_echo_skb(struct net_device *dev, unsigned int idx, u8 *len_ptr);
+struct sk_buff *__can_get_echo_skb(struct net_device *dev, unsigned int idx,
+				   u8 *len_ptr);
 unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 

commit a4310fa2f24687888ce80fdb0e88583561a23700
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Wed Oct 31 10:37:46 2018 +0100

    can: dev: can_get_echo_skb(): factor out non sending code to __can_get_echo_skb()
    
    This patch factors out all non sending parts of can_get_echo_skb() into
    a seperate function __can_get_echo_skb(), so that it can be re-used in
    an upcoming patch.
    
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index a83e1f632eb7..f01623aef2f7 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -169,6 +169,7 @@ void can_change_state(struct net_device *dev, struct can_frame *cf,
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
+struct sk_buff *__can_get_echo_skb(struct net_device *dev, unsigned int idx, u8 *len_ptr);
 unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 

commit 038709071328ff68a936c6b8c33a24a805eea3c5
Author: Zhu Yi <yi.zhu5@cn.bosch.com>
Date:   Wed Jun 13 16:37:17 2018 +0200

    can: dev: enable multi-queue for SocketCAN devices
    
    The existing SocketCAN implementation provides alloc_candev() to
    allocate a CAN device using a single Tx and Rx queue. This can lead to
    priority inversion in case the single Tx queue is already full with low
    priority messages and a high priority message needs to be sent while the
    bus is fully loaded with medium priority messages.
    
    This problem can be solved by using the existing multi-queue support of
    the network subsytem. The commit makes it possible to use multi-queue in
    the CAN subsystem in the same way it is used in the Ethernet subsystem
    by adding an alloc_candev_mqs() call and accompanying macros. With this
    support a CAN device can use multi-queue qdisc (e.g. mqprio) to avoid
    the aforementioned priority inversion.
    
    The exisiting functionality of alloc_candev() is the same as before.
    
    CAN devices need to have prioritized multiple hardware queues or are
    able to abort waiting for arbitration to make sensible use of
    multi-queues.
    
    Signed-off-by: Zhu Yi <yi.zhu5@cn.bosch.com>
    Signed-off-by: Mark Jonas <mark.jonas@de.bosch.com>
    Reviewed-by: Heiko Schocher <hs@denx.de>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 055aaf5ed9af..a83e1f632eb7 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -143,7 +143,12 @@ u8 can_dlc2len(u8 can_dlc);
 /* map the sanitized data length to an appropriate data length code */
 u8 can_len2dlc(u8 len);
 
-struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
+struct net_device *alloc_candev_mqs(int sizeof_priv, unsigned int echo_skb_max,
+				    unsigned int txqs, unsigned int rxqs);
+#define alloc_candev(sizeof_priv, echo_skb_max) \
+	alloc_candev_mqs(sizeof_priv, echo_skb_max, 1, 1)
+#define alloc_candev_mq(sizeof_priv, echo_skb_max, count) \
+	alloc_candev_mqs(sizeof_priv, echo_skb_max, count, count)
 void free_candev(struct net_device *dev);
 
 /* a candev safe wrapper around netdev_priv */

commit 2290aefa2e90a43af8555ad6431d49de43259aa3
Author: Franklin S Cooper Jr <fcooper@ti.com>
Date:   Wed Jan 10 16:25:18 2018 +0530

    can: dev: Add support for limiting configured bitrate
    
    Various CAN or CAN-FD IP may be able to run at a faster rate than
    what the transceiver the CAN node is connected to. This can lead to
    unexpected errors. However, CAN transceivers typically have fixed
    limitations and provide no means to discover these limitations at
    runtime. Therefore, add support for a can-transceiver node that
    can be reused by other CAN peripheral drivers to determine for both
    CAN and CAN-FD what the max bitrate that can be used. If the user
    tries to configure CAN to pass these maximum bitrates it will throw
    an error.
    
    Also add support for reading bitrate_max via the netlink interface.
    
    Reviewed-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Franklin S Cooper Jr <fcooper@ti.com>
    [nsekhar@ti.com: fix build error with !CONFIG_OF]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Faiz Abbas <faiz_abbas@ti.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 61f1cf2d9f44..055aaf5ed9af 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -46,6 +46,7 @@ struct can_priv {
 	unsigned int bitrate_const_cnt;
 	const u32 *data_bitrate_const;
 	unsigned int data_bitrate_const_cnt;
+	u32 bitrate_max;
 	struct can_clock clock;
 
 	enum can_state state;
@@ -166,6 +167,12 @@ void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
+#ifdef CONFIG_OF
+void of_can_transceiver(struct net_device *dev);
+#else
+static inline void of_can_transceiver(struct net_device *dev) { }
+#endif
+
 struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
 struct sk_buff *alloc_canfd_skb(struct net_device *dev,
 				struct canfd_frame **cfd);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 141b05aade81..61f1cf2d9f44 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * linux/can/dev.h
  *

commit 431af779256cd6cb8328ac23c5696bae63c33a51
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Wed Jan 11 17:05:35 2017 +0100

    can: dev: add CAN interface API for fixed bitrates
    
    Some CAN interfaces only support fixed fixed bitrates. This patch adds a
    netlink interface to get the list of the CAN interface's fixed bitrates and
    data bitrates.
    
    Inside the driver arrays of supported data- bitrate values are defined.
    
    const u32 drvname_bitrate[] = { 20000, 50000, 100000 };
    const u32 drvname_data_bitrate[] = { 200000, 500000, 1000000 };
    
    struct drvname_priv *priv;
    priv = netdev_priv(dev);
    
    priv->bitrate_const = drvname_bitrate;
    priv->bitrate_const_cnt = ARRAY_SIZE(drvname_bitrate);
    priv->data_bitrate_const = drvname_data_bitrate;
    priv->data_bitrate_const_cnt = ARRAY_SIZE(drvname_data_bitrate);
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index f6a57f322f00..141b05aade81 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -41,6 +41,10 @@ struct can_priv {
 	const u16 *termination_const;
 	unsigned int termination_const_cnt;
 	u16 termination;
+	const u32 *bitrate_const;
+	unsigned int bitrate_const_cnt;
+	const u32 *data_bitrate_const;
+	unsigned int data_bitrate_const_cnt;
 	struct can_clock clock;
 
 	enum can_state state;

commit 12a6075cabc0d9ffbc0366b44daa22f278606312
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Tue Jan 10 18:52:06 2017 +0100

    can: dev: add CAN interface termination API
    
    This patch adds a netlink interface to configure the CAN bus termination of
    CAN interfaces.
    
    Inside the driver an array of supported termination values is defined:
    
    const u16 drvname_termination[] = { 60, 120, CAN_TERMINATION_DISABLED };
    
    struct drvname_priv *priv;
    priv = netdev_priv(dev);
    
    priv->termination_const = drvname_termination;
    priv->termination_const_cnt = ARRAY_SIZE(drvname_termination);
    priv->termination = CAN_TERMINATION_DISABLED;
    
    And the funtion to set the value has to be defined:
    
    priv->do_set_termination = drvname_set_termination;
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Reviewed-by: Ramesh Shanmugasundaram <Ramesh.shanmugasundaram@bp.renesas.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 5f5270941ba0..f6a57f322f00 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -38,6 +38,9 @@ struct can_priv {
 	struct can_bittiming bittiming, data_bittiming;
 	const struct can_bittiming_const *bittiming_const,
 		*data_bittiming_const;
+	const u16 *termination_const;
+	unsigned int termination_const_cnt;
+	u16 termination;
 	struct can_clock clock;
 
 	enum can_state state;
@@ -53,6 +56,7 @@ struct can_priv {
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_data_bittiming)(struct net_device *dev);
 	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
+	int (*do_set_termination)(struct net_device *dev, u16 term);
 	int (*do_get_state)(const struct net_device *dev,
 			    enum can_state *state);
 	int (*do_get_berr_counter)(const struct net_device *dev,

commit 9abefcb1aaa58b9d5aa40a8bb12c87d02415e4c8
Author: Sergei Miroshnichenko <sergeimir@emcraft.com>
Date:   Wed Sep 7 16:51:12 2016 +0300

    can: dev: fix deadlock reported after bus-off
    
    A timer was used to restart after the bus-off state, leading to a
    relatively large can_restart() executed in an interrupt context,
    which in turn sets up pinctrl. When this happens during system boot,
    there is a high probability of grabbing the pinctrl_list_mutex,
    which is locked already by the probe() of other device, making the
    kernel suspect a deadlock condition [1].
    
    To resolve this issue, the restart_timer is replaced by a delayed
    work.
    
    [1] https://github.com/victronenergy/venus/issues/24
    
    Signed-off-by: Sergei Miroshnichenko <sergeimir@emcraft.com>
    Cc: linux-stable <stable@vger.kernel.org>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 5261751f6bd4..5f5270941ba0 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -32,6 +32,7 @@ enum can_mode {
  * CAN common private data
  */
 struct can_priv {
+	struct net_device *dev;
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming, data_bittiming;
@@ -47,7 +48,7 @@ struct can_priv {
 	u32 ctrlmode_static;	/* static enabled options for driver/hardware */
 
 	int restart_ms;
-	struct timer_list restart_timer;
+	struct delayed_work restart_work;
 
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_data_bittiming)(struct net_device *dev);

commit bb208f144cf3f59d8f89a09a80efd04389718907
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Mon Mar 21 20:18:21 2016 +0100

    can: fix handling of unmodifiable configuration options
    
    As described in 'can: m_can: tag current CAN FD controllers as non-ISO'
    (6cfda7fbebe) it is possible to define fixed configuration options by
    setting the according bit in 'ctrlmode' and clear it in 'ctrlmode_supported'.
    This leads to the incovenience that the fixed configuration bits can not be
    passed by netlink even when they have the correct values (e.g. non-ISO, FD).
    
    This patch fixes that issue and not only allows fixed set bit values to be set
    again but now requires(!) to provide these fixed values at configuration time.
    A valid CAN FD configuration consists of a nominal/arbitration bittiming, a
    data bittiming and a control mode with CAN_CTRLMODE_FD set - which is now
    enforced by a new can_validate() function. This fix additionally removed the
    inconsistency that was prohibiting the support of 'CANFD-only' controller
    drivers, like the RCar CAN FD.
    
    For this reason a new helper can_set_static_ctrlmode() has been introduced to
    provide a proper interface to handle static enabled CAN controller options.
    
    Reported-by: Ramesh Shanmugasundaram <ramesh.shanmugasundaram@bp.renesas.com>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Reviewed-by: Ramesh Shanmugasundaram  <ramesh.shanmugasundaram@bp.renesas.com>
    Cc: <stable@vger.kernel.org> # >= 3.18
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 735f9f8c4e43..5261751f6bd4 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -40,8 +40,11 @@ struct can_priv {
 	struct can_clock clock;
 
 	enum can_state state;
-	u32 ctrlmode;
-	u32 ctrlmode_supported;
+
+	/* CAN controller features - see include/uapi/linux/can/netlink.h */
+	u32 ctrlmode;		/* current options setting */
+	u32 ctrlmode_supported;	/* options that can be modified by netlink */
+	u32 ctrlmode_static;	/* static enabled options for driver/hardware */
 
 	int restart_ms;
 	struct timer_list restart_timer;
@@ -108,6 +111,21 @@ static inline bool can_is_canfd_skb(const struct sk_buff *skb)
 	return skb->len == CANFD_MTU;
 }
 
+/* helper to define static CAN controller features at device creation time */
+static inline void can_set_static_ctrlmode(struct net_device *dev,
+					   u32 static_mode)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	/* alloc_candev() succeeded => netdev_priv() is valid at this point */
+	priv->ctrlmode = static_mode;
+	priv->ctrlmode_static = static_mode;
+
+	/* override MTU which was set by default in can_setup()? */
+	if (static_mode & CAN_CTRLMODE_FD)
+		dev->mtu = CANFD_MTU;
+}
+
 /* get data length from can_dlc with sanitized can_dlc */
 u8 can_dlc2len(u8 can_dlc);
 

commit d6fbaea5f635216c9861587c4e658086cf3b1b6b
Author: Yaowei Bai <bywxiaobai@163.com>
Date:   Thu Oct 8 21:28:57 2015 +0800

    net/can: can_dropped_invalid_skb can be boolean
    
    This patch makes can_dropped_invalid_skb return bool due to this
    particular function only using either one or zero as its return
    value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <bywxiaobai@163.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 56dcadd83716..735f9f8c4e43 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -78,7 +78,7 @@ struct can_priv {
 #define get_canfd_dlc(i)	(min_t(__u8, (i), CANFD_MAX_DLC))
 
 /* Drop a given socketbuffer if it does not contain a valid CAN frame. */
-static inline int can_dropped_invalid_skb(struct net_device *dev,
+static inline bool can_dropped_invalid_skb(struct net_device *dev,
 					  struct sk_buff *skb)
 {
 	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
@@ -94,12 +94,12 @@ static inline int can_dropped_invalid_skb(struct net_device *dev,
 	} else
 		goto inval_skb;
 
-	return 0;
+	return false;
 
 inval_skb:
 	kfree_skb(skb);
 	dev->stats.tx_dropped++;
-	return 1;
+	return true;
 }
 
 static inline bool can_is_canfd_skb(const struct sk_buff *skb)

commit 2785968cd122b22b289db565b7438f2200984044
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Sat May 9 17:47:52 2015 +0200

    can: headers: make header files self contained
    
    This patch adds the missing #include-s to the dev.h and led.h, so that they can
    be used without including further header files.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index c3a9c8fc60fa..56dcadd83716 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -14,9 +14,10 @@
 #define _CAN_DEV_H
 
 #include <linux/can.h>
-#include <linux/can/netlink.h>
 #include <linux/can/error.h>
 #include <linux/can/led.h>
+#include <linux/can/netlink.h>
+#include <linux/netdevice.h>
 
 /*
  * CAN mode

commit c54eb70e3bb8cd0d7b8564bedab63e834656c567
Author: Yegor Yefremov <yegorslists@googlemail.com>
Date:   Mon Mar 16 09:38:13 2015 +0100

    can: add combined rx/tx LED trigger support
    
    Add <ifname>-rxtx trigger, that will be activated both for tx
    as rx events. This trigger mimics "activity" LED for Ethernet
    devices.
    
    Signed-off-by: Yegor Yefremov <yegorslists@googlemail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index c05ff0f9f9a5..c3a9c8fc60fa 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -61,6 +61,8 @@ struct can_priv {
 	char tx_led_trig_name[CAN_LED_NAME_SZ];
 	struct led_trigger *rx_led_trig;
 	char rx_led_trig_name[CAN_LED_NAME_SZ];
+	struct led_trigger *rxtx_led_trig;
+	char rxtx_led_trig_name[CAN_LED_NAME_SZ];
 #endif
 };
 

commit bac78aabcfece0c493b2ad824c68fbdc20448cbc
Author: Andri Yngvason <andri.yngvason@marel.com>
Date:   Wed Dec 3 17:54:13 2014 +0000

    can: dev: Consolidate and unify state change handling
    
    The handling of can error states is different between platforms.
    This is an attempt to correct that problem.
    
    I've moved this handling into a generic function for changing the
    error state. This ensures that error state changes are handled
    the same way everywhere (where this function is used).
    
    This new mechanism also adds reverse state transitioning in error
    frames, i.e. the user will be notified through the socket interface
    when the state goes down.
    
    Signed-off-by: Andri Yngvason <andri.yngvason@marel.com>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index b37ea95bc348..c05ff0f9f9a5 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -127,6 +127,9 @@ void unregister_candev(struct net_device *dev);
 int can_restart_now(struct net_device *dev);
 void can_bus_off(struct net_device *dev);
 
+void can_change_state(struct net_device *dev, struct can_frame *cf,
+		      enum can_state tx_state, enum can_state rx_state);
+
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
 unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);

commit 98e69016a11b2b9398bea668442193b3b362cd43
Author: Dong Aisheng <b29396@freescale.com>
Date:   Fri Nov 7 16:45:12 2014 +0800

    can: dev: add can_is_canfd_skb() API
    
    The CAN device drivers can use can_is_canfd_skb() to check if the frame to send
    is on CAN FD mode or normal CAN mode.
    
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Dong Aisheng <b29396@freescale.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 6992afc6ba7f..b37ea95bc348 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -99,6 +99,12 @@ static inline int can_dropped_invalid_skb(struct net_device *dev,
 	return 1;
 }
 
+static inline bool can_is_canfd_skb(const struct sk_buff *skb)
+{
+	/* the CAN specific type of skb is identified by its data length */
+	return skb->len == CANFD_MTU;
+}
+
 /* get data length from can_dlc with sanitized can_dlc */
 u8 can_dlc2len(u8 can_dlc);
 

commit 42193e3efb632c84d686acacd7b2327f2b1f8c63
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Thu May 15 20:31:56 2014 +0200

    can: unify identifiers to ensure unique include processing
    
    Armin pointed me to the fact that the identifier which is used to ensure the
    unique include processing in lunux/include/uapi/linux/can.h is CAN_H.
    This clashed with his own source as includes from libraries and APIs should
    use an underscore '_' at the identifier start.
    
    This patch fixes the protection identifiers in all CAN relavant includes.
    
    Reported-by: Armin Burchardt <armin@uni-bremen.de>
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 3ce5e526525f..6992afc6ba7f 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -10,8 +10,8 @@
  *
  */
 
-#ifndef CAN_DEV_H
-#define CAN_DEV_H
+#ifndef _CAN_DEV_H
+#define _CAN_DEV_H
 
 #include <linux/can.h>
 #include <linux/can/netlink.h>
@@ -132,4 +132,4 @@ struct sk_buff *alloc_canfd_skb(struct net_device *dev,
 struct sk_buff *alloc_can_err_skb(struct net_device *dev,
 				  struct can_frame **cf);
 
-#endif /* CAN_DEV_H */
+#endif /* !_CAN_DEV_H */

commit bc05a8944a344acdb81a65de055ca6febbf9657c
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Fri Feb 28 16:36:24 2014 +0100

    can: allow to change the device mtu for CAN FD capable devices
    
    The configuration for CAN FD depends on CAN_CTRLMODE_FD enabled in the driver
    specific ctrlmode_supported capabilities.
    
    The configuration can be done either with the 'fd { on | off }' option in the
    'ip' tool from iproute2 or by setting the CAN netdevice MTU to CAN_MTU (16) or
    to CANFD_MTU (72).
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Acked-by: Stephane Grosjean <s.grosjean@peak-system.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 8adaee96f292..3ce5e526525f 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -113,6 +113,7 @@ struct can_priv *safe_candev_priv(struct net_device *dev);
 
 int open_candev(struct net_device *dev);
 void close_candev(struct net_device *dev);
+int can_change_mtu(struct net_device *dev, int new_mtu);
 
 int register_candev(struct net_device *dev);
 void unregister_candev(struct net_device *dev);

commit 9859ccd2c8be63ce939522e63e265f2b0caa1109
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Fri Feb 28 16:36:23 2014 +0100

    can: introduce the data bitrate configuration for CAN FD
    
    As CAN FD offers a second bitrate for the data section of the CAN frame the
    infrastructure for storing and configuring this second bitrate is introduced.
    Improved the readability of the if-statement by inserting some newlines.
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Acked-by: Stephane Grosjean <s.grosjean@peak-system.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index dc5f9026b67f..8adaee96f292 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -33,8 +33,9 @@ enum can_mode {
 struct can_priv {
 	struct can_device_stats can_stats;
 
-	struct can_bittiming bittiming;
-	const struct can_bittiming_const *bittiming_const;
+	struct can_bittiming bittiming, data_bittiming;
+	const struct can_bittiming_const *bittiming_const,
+		*data_bittiming_const;
 	struct can_clock clock;
 
 	enum can_state state;
@@ -45,6 +46,7 @@ struct can_priv {
 	struct timer_list restart_timer;
 
 	int (*do_set_bittiming)(struct net_device *dev);
+	int (*do_set_data_bittiming)(struct net_device *dev);
 	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
 	int (*do_get_state)(const struct net_device *dev,
 			    enum can_state *state);

commit cb2518ca9f06dfcfa3d175773631bfb1e461bdc7
Author: Stephane Grosjean <s.grosjean@peak-system.com>
Date:   Wed Jan 15 09:50:13 2014 +0100

    can: add ability to allocate CANFD frame in skb data
    
    This patch adds the ability of allocating a CANFD frame data structure in the
    skb data area.
    
    Signed-off-by: Stephane Grosjean <s.grosjean@peak-system.com>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index fb0ab651a041..dc5f9026b67f 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -124,6 +124,8 @@ unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
 struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
+struct sk_buff *alloc_canfd_skb(struct net_device *dev,
+				struct canfd_frame **cfd);
 struct sk_buff *alloc_can_err_skb(struct net_device *dev,
 				  struct can_frame **cf);
 

commit bf03a5379cd3492fbeca42111340581ba9dee0b8
Author: Kurt Van Dijck <kurt.van.dijck@eia.be>
Date:   Tue Dec 18 18:50:56 2012 +0100

    can: export a safe netdev_priv wrapper for candev
    
    In net_device notifier calls, it was impossible to determine
    if a CAN device is based on candev in a safe way.
    This patch adds such test in order to access candev storage
    from within those notifiers.
    
    Signed-off-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@gmail.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 7747d9bcdc84..fb0ab651a041 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -106,6 +106,9 @@ u8 can_len2dlc(u8 len);
 struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
 void free_candev(struct net_device *dev);
 
+/* a candev safe wrapper around netdev_priv */
+struct can_priv *safe_candev_priv(struct net_device *dev);
+
 int open_candev(struct net_device *dev);
 void close_candev(struct net_device *dev);
 

commit 996a953de02ffb852c9ac736f4e892008ed68884
Author: Fabio Baltieri <fabio.baltieri@gmail.com>
Date:   Tue Dec 18 18:50:55 2012 +0100

    can: add tx/rx LED trigger support
    
    This patch implements the functions to add two LED triggers, named
    <ifname>-tx and <ifname>-rx, to a canbus device driver.
    
    Triggers are called from specific handlers by each CAN device driver and
    can be disabled altogether with a Kconfig option.
    
    The implementation keeps the LED on when the interface is UP and blinks
    the LED on network activity at a configurable rate.
    
    This only supports can-dev based drivers, as it uses some support field
    in the can_priv structure.
    
    Supported drivers should call devm_can_led_init() and can_led_event() as
    needed.
    
    Cleanup is handled automatically by devres, so no *_exit function is
    needed.
    
    Supported events are:
    - CAN_LED_EVENT_OPEN: turn on tx/rx LEDs
    - CAN_LED_EVENT_STOP: turn off tx/rx LEDs
    - CAN_LED_EVENT_TX: trigger tx LED blink
    - CAN_LED_EVENT_RX: trigger tx LED blink
    
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@gmail.com>
    Acked-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 2b2fc345afca..7747d9bcdc84 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -16,6 +16,7 @@
 #include <linux/can.h>
 #include <linux/can/netlink.h>
 #include <linux/can/error.h>
+#include <linux/can/led.h>
 
 /*
  * CAN mode
@@ -52,6 +53,13 @@ struct can_priv {
 
 	unsigned int echo_skb_max;
 	struct sk_buff **echo_skb;
+
+#ifdef CONFIG_CAN_LEDS
+	struct led_trigger *tx_led_trig;
+	char tx_led_trig_name[CAN_LED_NAME_SZ];
+	struct led_trigger *rx_led_trig;
+	char rx_led_trig_name[CAN_LED_NAME_SZ];
+#endif
 };
 
 /*

commit 194b9a4cb91713ddb60c9f98f7212f6d8cb8e05f
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Jul 16 12:58:31 2012 +0200

    can: mark bittiming_const pointer in struct can_priv as const
    
    This patch marks the bittiming_const pointer as in the struct can_pric as
    "const". This allows us to mark the struct can_bittiming_const in the CAN
    drivers as "const", too.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index ee5a771fb20d..2b2fc345afca 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -33,7 +33,7 @@ struct can_priv {
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming;
-	struct can_bittiming_const *bittiming_const;
+	const struct can_bittiming_const *bittiming_const;
 	struct can_clock clock;
 
 	enum can_state state;

commit 1e0625facab2e871472472b7df87d8fbe6caf75a
Author: Oliver Hartkopp <socketcan@hartkopp.net>
Date:   Wed Jun 13 20:48:21 2012 +0200

    candev: add/update helpers for CAN FD
    
    - update sanity checks
    - add DLC to length conversion helpers
      - can_dlc2len() - get data length from can_dlc with sanitized can_dlc
      - can_len2dlc() - map the sanitized data length to an appropriate DLC
    
    Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 5d2efe7e3f1b..ee5a771fb20d 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -61,23 +61,40 @@ struct can_priv {
  * To be used in the CAN netdriver receive path to ensure conformance with
  * ISO 11898-1 Chapter 8.4.2.3 (DLC field)
  */
-#define get_can_dlc(i)	(min_t(__u8, (i), 8))
+#define get_can_dlc(i)		(min_t(__u8, (i), CAN_MAX_DLC))
+#define get_canfd_dlc(i)	(min_t(__u8, (i), CANFD_MAX_DLC))
 
 /* Drop a given socketbuffer if it does not contain a valid CAN frame. */
 static inline int can_dropped_invalid_skb(struct net_device *dev,
 					  struct sk_buff *skb)
 {
-	const struct can_frame *cf = (struct can_frame *)skb->data;
-
-	if (unlikely(skb->len != sizeof(*cf) || cf->can_dlc > 8)) {
-		kfree_skb(skb);
-		dev->stats.tx_dropped++;
-		return 1;
-	}
+	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+
+	if (skb->protocol == htons(ETH_P_CAN)) {
+		if (unlikely(skb->len != CAN_MTU ||
+			     cfd->len > CAN_MAX_DLEN))
+			goto inval_skb;
+	} else if (skb->protocol == htons(ETH_P_CANFD)) {
+		if (unlikely(skb->len != CANFD_MTU ||
+			     cfd->len > CANFD_MAX_DLEN))
+			goto inval_skb;
+	} else
+		goto inval_skb;
 
 	return 0;
+
+inval_skb:
+	kfree_skb(skb);
+	dev->stats.tx_dropped++;
+	return 1;
 }
 
+/* get data length from can_dlc with sanitized can_dlc */
+u8 can_dlc2len(u8 can_dlc);
+
+/* map the sanitized data length to an appropriate data length code */
+u8 can_len2dlc(u8 len);
+
 struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
 void free_candev(struct net_device *dev);
 

commit cf5046b309b3a05c444a8edba6b44108510b7d7d
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Oct 10 23:43:53 2011 +0200

    can: dev: let can_get_echo_skb() return dlc of CAN frame
    
    can_get_echo_skb() is usually called in the TX complete handler.
    The stats->tx_packets and stats->tx_bytes should be updated there, too.
    This patch simplifies to figure out the size of the sent CAN frame.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index a0969fcb72b9..5d2efe7e3f1b 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -92,7 +92,7 @@ void can_bus_off(struct net_device *dev);
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 		      unsigned int idx);
-void can_get_echo_skb(struct net_device *dev, unsigned int idx);
+unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
 struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);

commit f861c2b80c45954e1ea04ead24cafcb1806dd536
Author: Marc Kleine-Budde <mkl@pengutronix.de>
Date:   Mon Oct 17 09:32:00 2011 +0000

    can: remove references to berlios mailinglist
    
    The BerliOS project, which currently hosts our mailinglist, will
    close with the end of the year. Now take the chance and remove all
    occurrences of the mailinglist address from the source files.
    
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index cc0bb4961669..a0969fcb72b9 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -8,7 +8,6 @@
  *
  * Copyright (C) 2008 Wolfgang Grandegger <wg@grandegger.com>
  *
- * Send feedback to <socketcan-users@lists.berlios.de>
  */
 
 #ifndef CAN_DEV_H

commit 829e0015431537176e38812f88fffe1d3250083e
Author: Hans J. Koch <hjk@linutronix.de>
Date:   Tue Apr 13 00:03:25 2010 +0000

    Fix some #includes in CAN drivers (rebased for net-next-2.6)
    
    In the current implementation, CAN drivers need to #include <linux/can.h>
    _before_ they #include <linux/can/dev.h>, which is both ugly and
    unnecessary.
    
    Fix this by including <linux/can.h> in <linux/can/dev.h> and remove the
    #include <linux/can.h> lines from drivers.
    
    Signed-off-by: Hans J. Koch <hjk@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 6e5a7f00223d..cc0bb4961669 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -14,6 +14,7 @@
 #ifndef CAN_DEV_H
 #define CAN_DEV_H
 
+#include <linux/can.h>
 #include <linux/can/netlink.h>
 #include <linux/can/error.h>
 

commit 52c793f24054f5dc30d228e37e0e19cc8313f086
Author: Wolfgang Grandegger <wg@grandegger.com>
Date:   Mon Feb 22 22:21:17 2010 +0000

    can: netlink support for bus-error reporting and counters
    
    This patch makes the bus-error reporting configurable and allows to
    retrieve the CAN TX and RX bus error counters via netlink interface.
    I have added support for the SJA1000. The TX and RX bus error counters
    are also copied to the data fields 6..7 of error messages when state
    changes are reported.
    
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index c8c660a79f90..6e5a7f00223d 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -47,6 +47,8 @@ struct can_priv {
 	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
 	int (*do_get_state)(const struct net_device *dev,
 			    enum can_state *state);
+	int (*do_get_berr_counter)(const struct net_device *dev,
+				   struct can_berr_counter *bec);
 
 	unsigned int echo_skb_max;
 	struct sk_buff **echo_skb;

commit ad72c347e56bf3a0231b9d686e17764157d2961c
Author: Christian Pellegrin <chripell@fsfe.org>
Date:   Thu Jan 14 07:08:34 2010 +0000

    can: Proper ctrlmode handling for CAN devices
    
    This patch adds error checking of ctrlmode values for CAN devices. As
    an example all availabe bits are implemented in the mcp251x driver.
    
    Signed-off-by: Christian Pellegrin <chripell@fsfe.org>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 7e7c98a3e908..c8c660a79f90 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -38,6 +38,7 @@ struct can_priv {
 
 	enum can_state state;
 	u32 ctrlmode;
+	u32 ctrlmode_supported;
 
 	int restart_ms;
 	struct timer_list restart_timer;

commit 3ccd4c6167d3b39d52631767ebbf8b5677c5855d
Author: Oliver Hartkopp <oliver@hartkopp.net>
Date:   Tue Jan 12 02:00:46 2010 -0800

    can: Unify droping of invalid tx skbs and netdev stats
    
    To prevent the CAN drivers to operate on invalid socketbuffers the skbs are
    now checked and silently dropped at the xmit-function consistently.
    
    Also the netdev stats are consistently using the CAN data length code (dlc)
    for [rx|tx]_bytes now.
    
    Signed-off-by: Oliver Hartkopp <oliver@hartkopp.net>
    Acked-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 3db7767d2a17..7e7c98a3e908 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -60,6 +60,21 @@ struct can_priv {
  */
 #define get_can_dlc(i)	(min_t(__u8, (i), 8))
 
+/* Drop a given socketbuffer if it does not contain a valid CAN frame. */
+static inline int can_dropped_invalid_skb(struct net_device *dev,
+					  struct sk_buff *skb)
+{
+	const struct can_frame *cf = (struct can_frame *)skb->data;
+
+	if (unlikely(skb->len != sizeof(*cf) || cf->can_dlc > 8)) {
+		kfree_skb(skb);
+		dev->stats.tx_dropped++;
+		return 1;
+	}
+
+	return 0;
+}
+
 struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
 void free_candev(struct net_device *dev);
 

commit c7cd606f60e7679c7f9eee7010f02a6f000209c1
Author: Oliver Hartkopp <oliver@hartkopp.net>
Date:   Sat Dec 12 04:13:21 2009 +0000

    can: Fix data length code handling in rx path
    
    A valid CAN dataframe can have a data length code (DLC) of 0 .. 8 data bytes.
    
    When reading the CAN controllers register the 4-bit value may contain values
    from 0 .. 15 which may exceed the reserved space in the socket buffer!
    
    The ISO 11898-1 Chapter 8.4.2.3 (DLC field) says that register values > 8
    should be reduced to 8 without any error reporting or frame drop.
    
    This patch introduces a new helper macro to cast a given 4-bit data length
    code (dlc) to __u8 and ensure the DLC value to be max. 8 bytes.
    
    The different handlings in the rx path of the CAN netdevice drivers are fixed.
    
    Signed-off-by: Oliver Hartkopp <oliver@hartkopp.net>
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 1ed2a5cc03f5..3db7767d2a17 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -51,6 +51,15 @@ struct can_priv {
 	struct sk_buff **echo_skb;
 };
 
+/*
+ * get_can_dlc(value) - helper macro to cast a given data length code (dlc)
+ * to __u8 and ensure the dlc value to be max. 8 bytes.
+ *
+ * To be used in the CAN netdriver receive path to ensure conformance with
+ * ISO 11898-1 Chapter 8.4.2.3 (DLC field)
+ */
+#define get_can_dlc(i)	(min_t(__u8, (i), 8))
+
 struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
 void free_candev(struct net_device *dev);
 

commit 7b6856a0296a8f187bb88ba31fa83a08abba7966
Author: Wolfgang Grandegger <wg@grandegger.com>
Date:   Tue Oct 20 00:08:01 2009 -0700

    can: provide library functions for skb allocation
    
    This patch makes the private functions alloc_can_skb() and
    alloc_can_err_skb() of the at91_can driver public and adapts all
    drivers to use these. While making the patch I realized, that
    the skb's are *not* setup consistently. It's now done as shown
    below:
    
      skb->protocol = htons(ETH_P_CAN);
      skb->pkt_type = PACKET_BROADCAST;
      skb->ip_summed = CHECKSUM_UNNECESSARY;
      *cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
      memset(*cf, 0, sizeof(struct can_frame));
    
    The frame is zeroed out to avoid uninitialized data to be passed to
    user space. Some drivers or library code did not set "pkt_type" or
    "ip_summed". Also,  "__constant_htons()" should not be used for
    runtime invocations, as pointed out by David Miller.
    
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 1d3f7f00e3af..1ed2a5cc03f5 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -68,4 +68,8 @@ void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
 void can_get_echo_skb(struct net_device *dev, unsigned int idx);
 void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
+struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf);
+struct sk_buff *alloc_can_err_skb(struct net_device *dev,
+				  struct can_frame **cf);
+
 #endif /* CAN_DEV_H */

commit a6e4bc5304033e434fabccabb230b8e9ff55d76f
Author: Wolfgang Grandegger <wg@grandegger.com>
Date:   Thu Oct 8 22:17:11 2009 +0000

    can: make the number of echo skb's configurable
    
    This patch allows the CAN controller driver to define the number of echo
    skb's used for the local loopback (echo), as suggested by Kurt Van
    Dijck, with the function:
    
      struct net_device *alloc_candev(int sizeof_priv,
                                      unsigned int echo_skb_max);
    
    The CAN drivers have been adapted accordingly. For the ems_usb driver,
    as suggested by Sebastian Haas, the number of echo skb's has been
    increased to 10, which improves the transmission performance a lot.
    
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Kurt Van Dijck <kurt.van.dijck@eia.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 5824b20b5fcb..1d3f7f00e3af 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -29,8 +29,6 @@ enum can_mode {
 /*
  * CAN common private data
  */
-#define CAN_ECHO_SKB_MAX  4
-
 struct can_priv {
 	struct can_device_stats can_stats;
 
@@ -44,15 +42,16 @@ struct can_priv {
 	int restart_ms;
 	struct timer_list restart_timer;
 
-	struct sk_buff *echo_skb[CAN_ECHO_SKB_MAX];
-
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
 	int (*do_get_state)(const struct net_device *dev,
 			    enum can_state *state);
+
+	unsigned int echo_skb_max;
+	struct sk_buff **echo_skb;
 };
 
-struct net_device *alloc_candev(int sizeof_priv);
+struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max);
 void free_candev(struct net_device *dev);
 
 int open_candev(struct net_device *dev);
@@ -64,8 +63,9 @@ void unregister_candev(struct net_device *dev);
 int can_restart_now(struct net_device *dev);
 void can_bus_off(struct net_device *dev);
 
-void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev, int idx);
-void can_get_echo_skb(struct net_device *dev, int idx);
-void can_free_echo_skb(struct net_device *dev, int idx);
+void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,
+		      unsigned int idx);
+void can_get_echo_skb(struct net_device *dev, unsigned int idx);
+void can_free_echo_skb(struct net_device *dev, unsigned int idx);
 
 #endif /* CAN_DEV_H */

commit 39e3ab6fded4d7e66e01a878f0cae23ddd480c3b
Author: Wolfgang Grandegger <wg@grandegger.com>
Date:   Tue Sep 1 05:26:12 2009 +0000

    can: add can_free_echo_skb() for upcoming drivers
    
    This patch adds the function can_free_echo_skb to the CAN
    device interface to allow upcoming drivers to release echo
    skb's in case of error.
    
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
index 4a37a56f6cdd..5824b20b5fcb 100644
--- a/include/linux/can/dev.h
+++ b/include/linux/can/dev.h
@@ -66,5 +66,6 @@ void can_bus_off(struct net_device *dev);
 
 void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev, int idx);
 void can_get_echo_skb(struct net_device *dev, int idx);
+void can_free_echo_skb(struct net_device *dev, int idx);
 
 #endif /* CAN_DEV_H */

commit 39549eef3587f1c1e8c65c88a2400d10fd30ea17
Author: Wolfgang Grandegger <wg@grandegger.com>
Date:   Fri May 15 23:39:29 2009 +0000

    can: CAN Network device driver and Netlink interface
    
    The CAN network device driver interface provides a generic interface to
    setup, configure and monitor CAN network devices. It exports a set of
    common data structures and functions, which all real CAN network device
    drivers should use. Please have a look to the SJA1000 or MSCAN driver
    to understand how to use them. The name of the module is can-dev.ko.
    
    Furthermore, it adds a Netlink interface allowing to configure the CAN
    device using the program "ip" from the iproute2 utility suite.
    
    For further information please check "Documentation/networking/can.txt"
    
    Signed-off-by: Wolfgang Grandegger <wg@grandegger.com>
    Signed-off-by: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
new file mode 100644
index 000000000000..4a37a56f6cdd
--- /dev/null
+++ b/include/linux/can/dev.h
@@ -0,0 +1,70 @@
+/*
+ * linux/can/dev.h
+ *
+ * Definitions for the CAN network device driver interface
+ *
+ * Copyright (C) 2006 Andrey Volkov <avolkov@varma-el.com>
+ *               Varma Electronics Oy
+ *
+ * Copyright (C) 2008 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ */
+
+#ifndef CAN_DEV_H
+#define CAN_DEV_H
+
+#include <linux/can/netlink.h>
+#include <linux/can/error.h>
+
+/*
+ * CAN mode
+ */
+enum can_mode {
+	CAN_MODE_STOP = 0,
+	CAN_MODE_START,
+	CAN_MODE_SLEEP
+};
+
+/*
+ * CAN common private data
+ */
+#define CAN_ECHO_SKB_MAX  4
+
+struct can_priv {
+	struct can_device_stats can_stats;
+
+	struct can_bittiming bittiming;
+	struct can_bittiming_const *bittiming_const;
+	struct can_clock clock;
+
+	enum can_state state;
+	u32 ctrlmode;
+
+	int restart_ms;
+	struct timer_list restart_timer;
+
+	struct sk_buff *echo_skb[CAN_ECHO_SKB_MAX];
+
+	int (*do_set_bittiming)(struct net_device *dev);
+	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
+	int (*do_get_state)(const struct net_device *dev,
+			    enum can_state *state);
+};
+
+struct net_device *alloc_candev(int sizeof_priv);
+void free_candev(struct net_device *dev);
+
+int open_candev(struct net_device *dev);
+void close_candev(struct net_device *dev);
+
+int register_candev(struct net_device *dev);
+void unregister_candev(struct net_device *dev);
+
+int can_restart_now(struct net_device *dev);
+void can_bus_off(struct net_device *dev);
+
+void can_put_echo_skb(struct sk_buff *skb, struct net_device *dev, int idx);
+void can_get_echo_skb(struct net_device *dev, int idx);
+
+#endif /* CAN_DEV_H */
