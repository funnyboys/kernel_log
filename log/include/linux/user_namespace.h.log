commit 769071ac9f20b6a447410c7eaa55d1a5233ef40c
Author: Andrei Vagin <avagin@openvz.org>
Date:   Tue Nov 12 01:26:52 2019 +0000

    ns: Introduce Time Namespace
    
    Time Namespace isolates clock values.
    
    The kernel provides access to several clocks CLOCK_REALTIME,
    CLOCK_MONOTONIC, CLOCK_BOOTTIME, etc.
    
    CLOCK_REALTIME
          System-wide clock that measures real (i.e., wall-clock) time.
    
    CLOCK_MONOTONIC
          Clock that cannot be set and represents monotonic time since
          some unspecified starting point.
    
    CLOCK_BOOTTIME
          Identical to CLOCK_MONOTONIC, except it also includes any time
          that the system is suspended.
    
    For many users, the time namespace means the ability to changes date and
    time in a container (CLOCK_REALTIME). Providing per namespace notions of
    CLOCK_REALTIME would be complex with a massive overhead, but has a dubious
    value.
    
    But in the context of checkpoint/restore functionality, monotonic and
    boottime clocks become interesting. Both clocks are monotonic with
    unspecified starting points. These clocks are widely used to measure time
    slices and set timers. After restoring or migrating processes, it has to be
    guaranteed that they never go backward. In an ideal case, the behavior of
    these clocks should be the same as for a case when a whole system is
    suspended. All this means that it is required to set CLOCK_MONOTONIC and
    CLOCK_BOOTTIME clocks, which can be achieved by adding per-namespace
    offsets for clocks.
    
    A time namespace is similar to a pid namespace in the way how it is
    created: unshare(CLONE_NEWTIME) system call creates a new time namespace,
    but doesn't set it to the current process. Then all children of the process
    will be born in the new time namespace, or a process can use the setns()
    system call to join a namespace.
    
    This scheme allows setting clock offsets for a namespace, before any
    processes appear in it.
    
    All available clone flags have been used, so CLONE_NEWTIME uses the highest
    bit of CSIGNAL. It means that it can be used only with the unshare() and
    the clone3() system calls.
    
    [ tglx: Adjusted paragraph about clone3() to reality and massaged the
            changelog a bit. ]
    
    Co-developed-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://criu.org/Time_namespace
    Link: https://lists.openvz.org/pipermail/criu/2018-June/041504.html
    Link: https://lore.kernel.org/r/20191112012724.250792-4-dima@arista.com

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index fb9f4f799554..6ef1c7109fc4 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -45,6 +45,7 @@ enum ucount_type {
 	UCOUNT_NET_NAMESPACES,
 	UCOUNT_MNT_NAMESPACES,
 	UCOUNT_CGROUP_NAMESPACES,
+	UCOUNT_TIME_NAMESPACES,
 #ifdef CONFIG_INOTIFY_USER
 	UCOUNT_INOTIFY_INSTANCES,
 	UCOUNT_INOTIFY_WATCHES,

commit 0f44e4d976f96c6439da0d6717238efa4b91196e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Move the user and user-session keyrings to the user_namespace
    
    Move the user and user-session keyrings to the user_namespace struct rather
    than pinning them from the user_struct struct.  This prevents these
    keyrings from propagating across user-namespaces boundaries with regard to
    the KEY_SPEC_* flags, thereby making them more useful in a containerised
    environment.
    
    The issue is that a single user_struct may be represent UIDs in several
    different namespaces.
    
    The way the patch does this is by attaching a 'register keyring' in each
    user_namespace and then sticking the user and user-session keyrings into
    that.  It can then be searched to retrieve them.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jann Horn <jannh@google.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 90457015fa3f..fb9f4f799554 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -65,14 +65,19 @@ struct user_namespace {
 	unsigned long		flags;
 
 #ifdef CONFIG_KEYS
-	/* List of joinable keyrings in this namespace */
+	/* List of joinable keyrings in this namespace.  Modification access of
+	 * these pointers is controlled by keyring_sem.  Once
+	 * user_keyring_register is set, it won't be changed, so it can be
+	 * accessed directly with READ_ONCE().
+	 */
 	struct list_head	keyring_name_list;
+	struct key		*user_keyring_register;
+	struct rw_semaphore	keyring_sem;
 #endif
 
 	/* Register of per-UID persistent keyrings for this namespace */
 #ifdef CONFIG_PERSISTENT_KEYRINGS
 	struct key		*persistent_keyring_register;
-	struct rw_semaphore	persistent_keyring_register_sem;
 #endif
 	struct work_struct	work;
 #ifdef CONFIG_SYSCTL

commit b206f281d0ee14969878469816a69db22d5838e8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Namespace keyring names
    
    Keyring names are held in a single global list that any process can pick
    from by means of keyctl_join_session_keyring (provided the keyring grants
    Search permission).  This isn't very container friendly, however.
    
    Make the following changes:
    
     (1) Make default session, process and thread keyring names begin with a
         '.' instead of '_'.
    
     (2) Keyrings whose names begin with a '.' aren't added to the list.  Such
         keyrings are system specials.
    
     (3) Replace the global list with per-user_namespace lists.  A keyring adds
         its name to the list for the user_namespace that it is currently in.
    
     (4) When a user_namespace is deleted, it just removes itself from the
         keyring name list.
    
    The global keyring_name_lock is retained for accessing the name lists.
    This allows (4) to work.
    
    This can be tested by:
    
            # keyctl newring foo @s
            995906392
            # unshare -U
            $ keyctl show
            ...
             995906392 --alswrv  65534 65534   \_ keyring: foo
            ...
            $ keyctl session foo
            Joined session keyring: 935622349
    
    As can be seen, a new session keyring was created.
    
    The capability bit KEYCTL_CAPS1_NS_KEYRING_NAME is set if the kernel is
    employing this feature.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index d6b74b91096b..90457015fa3f 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -64,6 +64,11 @@ struct user_namespace {
 	struct ns_common	ns;
 	unsigned long		flags;
 
+#ifdef CONFIG_KEYS
+	/* List of joinable keyrings in this namespace */
+	struct list_head	keyring_name_list;
+#endif
+
 	/* Register of per-UID persistent keyrings for this namespace */
 #ifdef CONFIG_PERSISTENT_KEYRINGS
 	struct key		*persistent_keyring_register;

commit 758f875848d78148cf9a9cdb3ff1ddf29b234056
Merge: a02cd4229e29 3fda0e737e90
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 16 12:20:15 2017 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace update from Eric Biederman:
     "The only change that is production ready this round is the work to
      increase the number of uid and gid mappings a user namespace can
      support from 5 to 340.
    
      This code was carefully benchmarked and it was confirmed that in the
      existing cases the performance remains the same. In the worst case
      with 340 mappings an cache cold stat times go from 158ns to 248ns.
      That is noticable but still quite small, and only the people who are
      doing crazy things pay the cost.
    
      This work uncovered some documentation and cleanup opportunities in
      the mapping code, and patches to make those cleanups and improve the
      documentation will be coming in the next merge window"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      userns: Simplify insert_extent
      userns: Make map_id_down a wrapper for map_id_range_down
      userns: Don't read extents twice in m_start
      userns: Simplify the user and group mapping functions
      userns: Don't special case a count of 0
      userns: bump idmap limits to 340
      userns: use union in {g,u}idmap struct

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index c18e01252346..3fe714da7f5a 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_USER_NAMESPACE_H
 #define _LINUX_USER_NAMESPACE_H
 

commit 6397fac4915ab3002dc15aae751455da1a852f25
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Wed Oct 25 00:04:41 2017 +0200

    userns: bump idmap limits to 340
    
    There are quite some use cases where users run into the current limit for
    {g,u}id mappings. Consider a user requesting us to map everything but 999, and
    1001 for a given range of 1000000000 with a sub{g,u}id layout of:
    
    some-user:100000:1000000000
    some-user:999:1
    some-user:1000:1
    some-user:1001:1
    some-user:1002:1
    
    This translates to:
    
    MAPPING-TYPE | CONTAINER |    HOST |     RANGE |
    -------------|-----------|---------|-----------|
             uid |       999 |     999 |         1 |
             uid |      1001 |    1001 |         1 |
             uid |         0 | 1000000 |       999 |
             uid |      1000 | 1001000 |         1 |
             uid |      1002 | 1001002 | 999998998 |
    ------------------------------------------------
             gid |       999 |     999 |         1 |
             gid |      1001 |    1001 |         1 |
             gid |         0 | 1000000 |       999 |
             gid |      1000 | 1001000 |         1 |
             gid |      1002 | 1001002 | 999998998 |
    
    which is already the current limit.
    
    As discussed at LPC simply bumping the number of limits is not going to work
    since this would mean that struct uid_gid_map won't fit into a single cache-line
    anymore thereby regressing performance for the base-cases. The same problem
    seems to arise when using a single pointer. So the idea is to use
    
    struct uid_gid_extent {
            u32 first;
            u32 lower_first;
            u32 count;
    };
    
    struct uid_gid_map { /* 64 bytes -- 1 cache line */
            u32 nr_extents;
            union {
                    struct uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];
                    struct {
                            struct uid_gid_extent *forward;
                            struct uid_gid_extent *reverse;
                    };
            };
    };
    
    For the base cases we will only use the struct uid_gid_extent extent member. If
    we go over UID_GID_MAP_MAX_BASE_EXTENTS mappings we perform a single 4k
    kmalloc() which means we can have a maximum of 340 mappings
    (340 * size(struct uid_gid_extent) = 4080). For the latter case we use two
    pointers "forward" and "reverse". The forward pointer points to an array sorted
    by "first" and the reverse pointer points to an array sorted by "lower_first".
    We can then perform binary search on those arrays.
    
    Performance Testing:
    When Eric introduced the extent-based struct uid_gid_map approach he measured
    the performanc impact of his idmap changes:
    
    > My benchmark consisted of going to single user mode where nothing else was
    > running. On an ext4 filesystem opening 1,000,000 files and looping through all
    > of the files 1000 times and calling fstat on the individuals files. This was
    > to ensure I was benchmarking stat times where the inodes were in the kernels
    > cache, but the inode values were not in the processors cache. My results:
    
    > v3.4-rc1:         ~= 156ns (unmodified v3.4-rc1 with user namespace support disabled)
    > v3.4-rc1-userns-: ~= 155ns (v3.4-rc1 with my user namespace patches and user namespace support disabled)
    > v3.4-rc1-userns+: ~= 164ns (v3.4-rc1 with my user namespace patches and user namespace support enabled)
    
    I used an identical approach on my laptop. Here's a thorough description of what
    I did. I built a 4.14.0-rc4 mainline kernel with my new idmap patches applied. I
    booted into single user mode and used an ext4 filesystem to open/create
    1,000,000 files. Then I looped through all of the files calling fstat() on each
    of them 1000 times and calculated the mean fstat() time for a single file. (The
    test program can be found below.)
    
    Here are the results. For fun, I compared the first version of my patch which
    scaled linearly with the new version of the patch:
    
    |   # MAPPINGS |   PATCH-V1 | PATCH-NEW |
    |--------------|------------|-----------|
    |   0 mappings |     158 ns |   158 ns  |
    |   1 mappings |     164 ns |   157 ns  |
    |   2 mappings |     170 ns |   158 ns  |
    |   3 mappings |     175 ns |   161 ns  |
    |   5 mappings |     187 ns |   165 ns  |
    |  10 mappings |     218 ns |   199 ns  |
    |  50 mappings |     528 ns |   218 ns  |
    | 100 mappings |     980 ns |   229 ns  |
    | 200 mappings |    1880 ns |   239 ns  |
    | 300 mappings |    2760 ns |   240 ns  |
    | 340 mappings | not tested |   248 ns  |
    
    Here's the test program I used. I asked Eric what he did and this is a more
    "advanced" implementation of the idea. It's pretty straight-forward:
    
     #define __GNU_SOURCE
     #define __STDC_FORMAT_MACROS
     #include <errno.h>
     #include <dirent.h>
     #include <fcntl.h>
     #include <inttypes.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>
     #include <unistd.h>
     #include <sys/stat.h>
     #include <sys/time.h>
     #include <sys/types.h>
    
     int main(int argc, char *argv[])
     {
            int ret;
            size_t i, k;
            int fd[1000000];
            int times[1000];
            char pathname[4096];
            struct stat st;
            struct timeval t1, t2;
            uint64_t time_in_mcs;
            uint64_t sum = 0;
    
            if (argc != 2) {
                    fprintf(stderr, "Please specify a directory where to create "
                                    "the test files\n");
                    exit(EXIT_FAILURE);
            }
    
            for (i = 0; i < sizeof(fd) / sizeof(fd[0]); i++) {
                    sprintf(pathname, "%s/idmap_test_%zu", argv[1], i);
                    fd[i]= open(pathname, O_RDWR | O_CREAT, S_IXUSR | S_IXGRP | S_IXOTH);
                    if (fd[i] < 0) {
                            ssize_t j;
                            for (j = i; j >= 0; j--)
                                    close(fd[j]);
                            exit(EXIT_FAILURE);
                    }
            }
    
            for (k = 0; k < 1000; k++) {
                    ret = gettimeofday(&t1, NULL);
                    if (ret < 0)
                            goto close_all;
    
                    for (i = 0; i < sizeof(fd) / sizeof(fd[0]); i++) {
                            ret = fstat(fd[i], &st);
                            if (ret < 0)
                                    goto close_all;
                    }
    
                    ret = gettimeofday(&t2, NULL);
                    if (ret < 0)
                            goto close_all;
    
                    time_in_mcs = (1000000 * t2.tv_sec + t2.tv_usec) -
                                  (1000000 * t1.tv_sec + t1.tv_usec);
                    printf("Total time in micro seconds:       %" PRIu64 "\n",
                           time_in_mcs);
                    printf("Total time in nanoseconds:         %" PRIu64 "\n",
                           time_in_mcs * 1000);
                    printf("Time per file in nanoseconds:      %" PRIu64 "\n",
                           (time_in_mcs * 1000) / 1000000);
                    times[k] = (time_in_mcs * 1000) / 1000000;
            }
    
     close_all:
            for (i = 0; i < sizeof(fd) / sizeof(fd[0]); i++)
                    close(fd[i]);
    
            if (ret < 0)
                    exit(EXIT_FAILURE);
    
            for (k = 0; k < 1000; k++) {
                    sum += times[k];
            }
    
            printf("Mean time per file in nanoseconds: %" PRIu64 "\n", sum / 1000);
    
            exit(EXIT_SUCCESS);;
     }
    
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    CC: Serge Hallyn <serge@hallyn.com>
    CC: Eric Biederman <ebiederm@xmission.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 7c83d7f6289b..1c1046a60fb4 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -10,7 +10,8 @@
 #include <linux/sysctl.h>
 #include <linux/err.h>
 
-#define UID_GID_MAP_MAX_EXTENTS 5
+#define UID_GID_MAP_MAX_BASE_EXTENTS 5
+#define UID_GID_MAP_MAX_EXTENTS 340
 
 struct uid_gid_extent {
 	u32 first;
@@ -18,10 +19,10 @@ struct uid_gid_extent {
 	u32 count;
 };
 
-struct uid_gid_map {	/* 64 bytes -- 1 cache line */
+struct uid_gid_map { /* 64 bytes -- 1 cache line */
 	u32 nr_extents;
 	union {
-		struct uid_gid_extent extent[UID_GID_MAP_MAX_EXTENTS];
+		struct uid_gid_extent extent[UID_GID_MAP_MAX_BASE_EXTENTS];
 		struct {
 			struct uid_gid_extent *forward;
 			struct uid_gid_extent *reverse;

commit aa4bf44dc851c6bdd4f7b61b5f2c56c84dfe2ff0
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Wed Oct 25 00:04:40 2017 +0200

    userns: use union in {g,u}idmap struct
    
    - Add a struct containing two pointer to extents and wrap both the static extent
      array and the struct into a union. This is done in preparation for bumping the
      {g,u}idmap limits for user namespaces.
    - Add brackets around anonymous union when using designated initializers to
      initialize members in order to please gcc <= 4.4.
    
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index c18e01252346..7c83d7f6289b 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -12,13 +12,21 @@
 
 #define UID_GID_MAP_MAX_EXTENTS 5
 
+struct uid_gid_extent {
+	u32 first;
+	u32 lower_first;
+	u32 count;
+};
+
 struct uid_gid_map {	/* 64 bytes -- 1 cache line */
 	u32 nr_extents;
-	struct uid_gid_extent {
-		u32 first;
-		u32 lower_first;
-		u32 count;
-	} extent[UID_GID_MAP_MAX_EXTENTS];
+	union {
+		struct uid_gid_extent extent[UID_GID_MAP_MAX_EXTENTS];
+		struct {
+			struct uid_gid_extent *forward;
+			struct uid_gid_extent *reverse;
+		};
+	};
 };
 
 #define USERNS_SETGROUPS_ALLOWED 1UL

commit dd198ce7141aa8dd9ffcc9549de422fb055508de
Merge: 89fd915c4021 076a9bcacfc7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 11 18:34:47 2017 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace updates from Eric Biederman:
     "Life has been busy and I have not gotten half as much done this round
      as I would have liked. I delayed it so that a minor conflict
      resolution with the mips tree could spend a little time in linux-next
      before I sent this pull request.
    
      This includes two long delayed user namespace changes from Kirill
      Tkhai. It also includes a very useful change from Serge Hallyn that
      allows the security capability attribute to be used inside of user
      namespaces. The practical effect of this is people can now untar
      tarballs and install rpms in user namespaces. It had been suggested to
      generalize this and encode some of the namespace information
      information in the xattr name. Upon close inspection that makes the
      things that should be hard easy and the things that should be easy
      more expensive.
    
      Then there is my bugfix/cleanup for signal injection that removes the
      magic encoding of the siginfo union member from the kernel internal
      si_code. The mips folks reported the case where I had used FPE_FIXME
      me is impossible so I have remove FPE_FIXME from mips, while at the
      same time including a return statement in that case to keep gcc from
      complaining about unitialized variables.
    
      I almost finished the work to get make copy_siginfo_to_user a trivial
      copy to user. The code is available at:
    
         git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace.git neuter-copy_siginfo_to_user-v3
    
      But I did not have time/energy to get the code posted and reviewed
      before the merge window opened.
    
      I was able to see that the security excuse for just copying fields
      that we know are initialized doesn't work in practice there are buggy
      initializations that don't initialize the proper fields in siginfo. So
      we still sometimes copy unitialized data to userspace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      Introduce v3 namespaced file capabilities
      mips/signal: In force_fcr31_sig return in the impossible case
      signal: Remove kernel interal si_code magic
      fcntl: Don't use ambiguous SIG_POLL si_codes
      prctl: Allow local CAP_SYS_ADMIN changing exe_file
      security: Use user_namespace::level to avoid redundant iterations in cap_capable()
      userns,pidns: Verify the userns for new pid namespaces
      signal/testing: Don't look for __SI_FAULT in userspace
      signal/mips: Document a conflict with SI_USER with SIGFPE
      signal/sparc: Document a conflict with SI_USER with SIGFPE
      signal/ia64: Document a conflict with SI_USER with SIGFPE
      signal/alpha: Document a conflict with SI_USER for SIGTRAP

commit a2b426267c56773201f968fdb5eda6ab9ae94e34
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Apr 29 14:12:15 2017 -0500

    userns,pidns: Verify the userns for new pid namespaces
    
    It is pointless and confusing to allow a pid namespace hierarchy and
    the user namespace hierarchy to get out of sync.  The owner of a child
    pid namespace should be the owner of the parent pid namespace or
    a descendant of the owner of the parent pid namespace.
    
    Otherwise it is possible to construct scenarios where a process has a
    capability over a parent pid namespace but does not have the
    capability over a child pid namespace.  Which confusingly makes
    permission checks non-transitive.
    
    It requires use of setns into a pid namespace (but not into a user
    namespace) to create such a scenario.
    
    Add the function in_userns to help in making this determination.
    
    v2: Optimized in_userns by using level as suggested
        by: Kirill Tkhai <ktkhai@virtuozzo.com>
    
    Ref: 49f4d8b93ccf ("pidns: Capture the user namespace and filter ns_last_pid")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 32354b4b4b2b..4005877bb8b6 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -112,8 +112,9 @@ extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t,
 extern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);
 extern int proc_setgroups_show(struct seq_file *m, void *v);
 extern bool userns_may_setgroups(const struct user_namespace *ns);
+extern bool in_userns(const struct user_namespace *ancestor,
+		       const struct user_namespace *child);
 extern bool current_in_userns(const struct user_namespace *target_ns);
-
 struct ns_common *ns_get_owner(struct ns_common *ns);
 #else
 
@@ -144,6 +145,12 @@ static inline bool userns_may_setgroups(const struct user_namespace *ns)
 	return true;
 }
 
+static inline bool in_userns(const struct user_namespace *ancestor,
+			     const struct user_namespace *child)
+{
+	return true;
+}
+
 static inline bool current_in_userns(const struct user_namespace *target_ns)
 {
 	return true;

commit 3859a271a003aba01e45b85c9d8b355eb7bf25f9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 28 01:22:25 2016 -0700

    randstruct: Mark various structs for randomization
    
    This marks many critical kernel structures for randomization. These are
    structures that have been targeted in the past in security exploits, or
    contain functions pointers, pointers to function pointer tables, lists,
    workqueues, ref-counters, credentials, permissions, or are otherwise
    sensitive. This initial list was extracted from Brad Spengler/PaX Team's
    code in the last public patch of grsecurity/PaX based on my understanding
    of the code. Changes or omissions from the original code are mine and
    don't reflect the original grsecurity/PaX code.
    
    Left out of this list is task_struct, which requires special handling
    and will be covered in a subsequent patch.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 32354b4b4b2b..b3575ce29148 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -66,7 +66,7 @@ struct user_namespace {
 #endif
 	struct ucounts		*ucounts;
 	int ucount_max[UCOUNT_COUNTS];
-};
+} __randomize_layout;
 
 struct ucounts {
 	struct hlist_node node;

commit 040757f738e13caaa9c5078bca79aa97e11dde88
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Mar 5 15:03:22 2017 -0600

    ucount: Remove the atomicity from ucount->count
    
    Always increment/decrement ucount->count under the ucounts_lock.  The
    increments are there already and moving the decrements there means the
    locking logic of the code is simpler.  This simplification in the
    locking logic fixes a race between put_ucounts and get_ucounts that
    could result in a use-after-free because the count could go zero then
    be found by get_ucounts and then be freed by put_ucounts.
    
    A bug presumably this one was found by a combination of syzkaller and
    KASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov
    spotted the race in the code.
    
    Cc: stable@vger.kernel.org
    Fixes: f6b2db1a3e8d ("userns: Make the count of user namespaces per user")
    Reported-by: JongHwan Kim <zzoru007@gmail.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Reviewed-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index be765234c0a2..32354b4b4b2b 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -72,7 +72,7 @@ struct ucounts {
 	struct hlist_node node;
 	struct user_namespace *ns;
 	kuid_t uid;
-	atomic_t count;
+	int count;
 	atomic_t ucount[UCOUNT_COUNTS];
 };
 

commit b2d5bfea2d00a0000da18f7667c2b0e2c2f168d9
Author: Ingo Molnar <mingo@kernel.org>
Date:   Mon Feb 6 09:56:40 2017 +0100

    sched/headers, timers: Remove the <linux/sysctl.h> include from <linux/timer.h>
    
    So we want to simplify <linux/sched.h>'s header dependencies, but one
    roadblock of that is <linux/timer.h>'s inclusion of sysctl.h,
    which brings in other, problematic headers.
    
    Note that timer.h's inclusion of sysctl.h can be avoided if we
    pre-declare ctl_table - so do that.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index faa9bfb827da..be765234c0a2 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -5,6 +5,7 @@
 #include <linux/nsproxy.h>
 #include <linux/ns_common.h>
 #include <linux/sched.h>
+#include <linux/workqueue.h>
 #include <linux/rwsem.h>
 #include <linux/sysctl.h>
 #include <linux/err.h>

commit cd9c513be34ceaae8bf211474b91b6897574efdd
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:58 2017 +0100

    sched/headers: Remove <linux/rwsem.h> from <linux/sched.h>
    
    This is a stray header that is not needed by anything in sched.h,
    so remove it.
    
    Update files that relied on the stray inclusion.
    
    This reduces the size of the header dependency graph.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 08264641b502..faa9bfb827da 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -5,6 +5,7 @@
 #include <linux/nsproxy.h>
 #include <linux/ns_common.h>
 #include <linux/sched.h>
+#include <linux/rwsem.h>
 #include <linux/sysctl.h>
 #include <linux/err.h>
 

commit cc5efc2323a89dcf1a02c17b9b9f255c5a6e0492
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Feb 3 10:06:45 2017 +0100

    sched/headers: Prepare for the removal of various unrelated headers from <linux/sched.h>
    
    We are going to remove the following header inclusions from <linux/sched.h>:
    
            #include <asm/param.h>
            #include <linux/threads.h>
            #include <linux/kernel.h>
            #include <linux/types.h>
            #include <linux/timex.h>
            #include <linux/jiffies.h>
            #include <linux/rbtree.h>
            #include <linux/thread_info.h>
            #include <linux/cpumask.h>
            #include <linux/errno.h>
            #include <linux/nodemask.h>
            #include <linux/preempt.h>
            #include <asm/page.h>
            #include <linux/smp.h>
            #include <linux/compiler.h>
            #include <linux/completion.h>
            #include <linux/percpu.h>
            #include <linux/topology.h>
            #include <linux/rcupdate.h>
            #include <linux/time.h>
            #include <linux/timer.h>
            #include <linux/llist.h>
            #include <linux/uidgid.h>
            #include <asm/processor.h>
    
    Fix up a single .h file that got hold of <linux/sysctl.h> via one of these headers.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 363e0e8082a9..08264641b502 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -5,6 +5,7 @@
 #include <linux/nsproxy.h>
 #include <linux/ns_common.h>
 #include <linux/sched.h>
+#include <linux/sysctl.h>
 #include <linux/err.h>
 
 #define UID_GID_MAP_MAX_EXTENTS 5

commit 1cce1eea0aff51201753fcaca421df825b0813b6
Author: Nikolay Borisov <n.borisov.lkml@gmail.com>
Date:   Wed Dec 14 15:56:33 2016 +0200

    inotify: Convert to using per-namespace limits
    
    This patchset converts inotify to using the newly introduced
    per-userns sysctl infrastructure.
    
    Currently the inotify instances/watches are being accounted in the
    user_struct structure. This means that in setups where multiple
    users in unprivileged containers map to the same underlying
    real user (i.e. pointing to the same user_struct) the inotify limits
    are going to be shared as well, allowing one user(or application) to exhaust
    all others limits.
    
    Fix this by switching the inotify sysctls to using the
    per-namespace/per-user limits. This will allow the server admin to
    set sensible global limits, which can further be tuned inside every
    individual user namespace. Additionally, in order to preserve the
    sysctl ABI make the existing inotify instances/watches sysctls
    modify the values of the initial user namespace.
    
    Signed-off-by: Nikolay Borisov <n.borisov.lkml@gmail.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index eb209d4523f5..363e0e8082a9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -32,6 +32,10 @@ enum ucount_type {
 	UCOUNT_NET_NAMESPACES,
 	UCOUNT_MNT_NAMESPACES,
 	UCOUNT_CGROUP_NAMESPACES,
+#ifdef CONFIG_INOTIFY_USER
+	UCOUNT_INOTIFY_INSTANCES,
+	UCOUNT_INOTIFY_WATCHES,
+#endif
 	UCOUNT_COUNTS,
 };
 

commit 78725596644be0181c46f55c52aadfb8c70bcdb7
Merge: 93f0a88bd4ad 6ad92bf63e45
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Sep 22 20:00:36 2016 -0500

    Merge branch 'nsfs-ioctls' into HEAD
    
    From: Andrey Vagin <avagin@openvz.org>
    
    Each namespace has an owning user namespace and now there is not way
    to discover these relationships.
    
    Pid and user namepaces are hierarchical. There is no way to discover
    parent-child relationships too.
    
    Why we may want to know relationships between namespaces?
    
    One use would be visualization, in order to understand the running
    system.  Another would be to answer the question: what capability does
    process X have to perform operations on a resource governed by namespace
    Y?
    
    One more use-case (which usually called abnormal) is checkpoint/restart.
    In CRIU we are going to dump and restore nested namespaces.
    
    There [1] was a discussion about which interface to choose to determing
    relationships between namespaces.
    
    Eric suggested to add two ioctl-s [2]:
    > Grumble, Grumble.  I think this may actually a case for creating ioctls
    > for these two cases.  Now that random nsfs file descriptors are bind
    > mountable the original reason for using proc files is not as pressing.
    >
    > One ioctl for the user namespace that owns a file descriptor.
    > One ioctl for the parent namespace of a namespace file descriptor.
    
    Here is an implementaions of these ioctl-s.
    
    $ man man7/namespaces.7
    ...
    Since  Linux  4.X,  the  following  ioctl(2)  calls are supported for
    namespace file descriptors.  The correct syntax is:
    
          fd = ioctl(ns_fd, ioctl_type);
    
    where ioctl_type is one of the following:
    
    NS_GET_USERNS
          Returns a file descriptor that refers to an owning user namesâ€
          pace.
    
    NS_GET_PARENT
          Returns  a  file descriptor that refers to a parent namespace.
          This ioctl(2) can be used for pid  and  user  namespaces.  For
          user namespaces, NS_GET_PARENT and NS_GET_USERNS have the same
          meaning.
    
    In addition to generic ioctl(2) errors, the following  specific  ones
    can occur:
    
    EINVAL NS_GET_PARENT was called for a nonhierarchical namespace.
    
    EPERM  The  requested  namespace  is outside of the current namespace
          scope.
    
    [1] https://lkml.org/lkml/2016/7/6/158
    [2] https://lkml.org/lkml/2016/7/9/101
    
    Changes for v2:
    * don't return ENOENT for init_user_ns and init_pid_ns. There is nothing
      outside of the init namespace, so we can return EPERM in this case too.
      > The fewer special cases the easier the code is to get
      > correct, and the easier it is to read. // Eric
    
    Changes for v3:
    * rename ns->get_owner() to ns->owner(). get_* usually means that it
      grabs a reference.
    
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: "Michael Kerrisk (man-pages)" <mtk.manpages@gmail.com>
    Cc: "W. Trevor King" <wking@tremily.us>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Serge Hallyn <serge.hallyn@canonical.com>

commit bcac25a58bfc6bd79191ac5d7afb49bea96da8c9
Author: Andrey Vagin <avagin@openvz.org>
Date:   Tue Sep 6 00:47:13 2016 -0700

    kernel: add a helper to get an owning user namespace for a namespace
    
    Return -EPERM if an owning user namespace is outside of a process
    current user namespace.
    
    v2: In a first version ns_get_owner returned ENOENT for init_user_ns.
        This special cases was removed from this version. There is nothing
        outside of init_user_ns, so we can return EPERM.
    v3: rename ns->get_owner() to ns->owner(). get_* usually means that it
    grabs a reference.
    
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Andrei Vagin <avagin@openvz.org>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 9217169c64cb..190cf0760815 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -73,6 +73,8 @@ extern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t,
 extern int proc_setgroups_show(struct seq_file *m, void *v);
 extern bool userns_may_setgroups(const struct user_namespace *ns);
 extern bool current_in_userns(const struct user_namespace *target_ns);
+
+struct ns_common *ns_get_owner(struct ns_common *ns);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -106,6 +108,11 @@ static inline bool current_in_userns(const struct user_namespace *target_ns)
 {
 	return true;
 }
+
+static inline struct ns_common *ns_get_owner(struct ns_common *ns)
+{
+	return ERR_PTR(-EPERM);
+}
 #endif
 
 #endif /* _LINUX_USER_H */

commit 537f7ccb396804c6d0057b93ba8eb104ba44f851
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:37:37 2016 -0500

    mntns: Add a limit on the number of mount namespaces.
    
    v2: Fixed the very obvious lack of setting ucounts
        on struct mnt_ns reported by Andrei Vagin, and the kbuild
        test report.
    
    Reported-by: Andrei Vagin <avagin@openvz.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index c6bc980b06a9..30ffe10cda18 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -30,6 +30,7 @@ enum ucount_type {
 	UCOUNT_UTS_NAMESPACES,
 	UCOUNT_IPC_NAMESPACES,
 	UCOUNT_NET_NAMESPACES,
+	UCOUNT_MNT_NAMESPACES,
 	UCOUNT_CGROUP_NAMESPACES,
 	UCOUNT_COUNTS,
 };

commit 703286608a220d53584cca5986aad5305eec75ed
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:33:23 2016 -0500

    netns: Add a limit on the number of net namespaces
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index d067f0d3038e..c6bc980b06a9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -29,6 +29,7 @@ enum ucount_type {
 	UCOUNT_PID_NAMESPACES,
 	UCOUNT_UTS_NAMESPACES,
 	UCOUNT_IPC_NAMESPACES,
+	UCOUNT_NET_NAMESPACES,
 	UCOUNT_CGROUP_NAMESPACES,
 	UCOUNT_COUNTS,
 };

commit d08311dd6fd8444e39710dd2fb97562895aed8fa
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:25:30 2016 -0500

    cgroupns: Add a limit on the number of cgroup namespaces
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index e1d672186f00..d067f0d3038e 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -29,6 +29,7 @@ enum ucount_type {
 	UCOUNT_PID_NAMESPACES,
 	UCOUNT_UTS_NAMESPACES,
 	UCOUNT_IPC_NAMESPACES,
+	UCOUNT_CGROUP_NAMESPACES,
 	UCOUNT_COUNTS,
 };
 

commit aba356616386e6e573a34c6d64ed12443686e5c8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:20:23 2016 -0500

    ipcns: Add a  limit on the number of ipc namespaces
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index f9df7dd2609a..e1d672186f00 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -28,6 +28,7 @@ enum ucount_type {
 	UCOUNT_USER_NAMESPACES,
 	UCOUNT_PID_NAMESPACES,
 	UCOUNT_UTS_NAMESPACES,
+	UCOUNT_IPC_NAMESPACES,
 	UCOUNT_COUNTS,
 };
 

commit f7af3d1c03136275b876f58644599b120cf4ffdd
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:11:25 2016 -0500

    utsns: Add a limit on the number of uts namespaces
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 9ee94827728d..f9df7dd2609a 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -27,6 +27,7 @@ struct ucounts;
 enum ucount_type {
 	UCOUNT_USER_NAMESPACES,
 	UCOUNT_PID_NAMESPACES,
+	UCOUNT_UTS_NAMESPACES,
 	UCOUNT_COUNTS,
 };
 

commit f333c700c6100b53050980986be922bb21466e29
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:08:36 2016 -0500

    pidns: Add a limit on the number of pid namespaces
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 9b676ead35c3..9ee94827728d 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -26,6 +26,7 @@ struct ucounts;
 
 enum ucount_type {
 	UCOUNT_USER_NAMESPACES,
+	UCOUNT_PID_NAMESPACES,
 	UCOUNT_COUNTS,
 };
 

commit 25f9c0817c535a728c1088542230fa327c577c9e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 14:41:52 2016 -0500

    userns: Generalize the user namespace count into ucount
    
    The same kind of recursive sane default limit and policy
    countrol that has been implemented for the user namespace
    is desirable for the other namespaces, so generalize
    the user namespace refernce count into a ucount.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 826de7a12a20..9b676ead35c3 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -23,6 +23,12 @@ struct uid_gid_map {	/* 64 bytes -- 1 cache line */
 #define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED
 
 struct ucounts;
+
+enum ucount_type {
+	UCOUNT_USER_NAMESPACES,
+	UCOUNT_COUNTS,
+};
+
 struct user_namespace {
 	struct uid_gid_map	uid_map;
 	struct uid_gid_map	gid_map;
@@ -46,7 +52,7 @@ struct user_namespace {
 	struct ctl_table_header *sysctls;
 #endif
 	struct ucounts		*ucounts;
-	int max_user_namespaces;
+	int ucount_max[UCOUNT_COUNTS];
 };
 
 struct ucounts {
@@ -54,15 +60,15 @@ struct ucounts {
 	struct user_namespace *ns;
 	kuid_t uid;
 	atomic_t count;
-	atomic_t user_namespaces;
+	atomic_t ucount[UCOUNT_COUNTS];
 };
 
 extern struct user_namespace init_user_ns;
 
 bool setup_userns_sysctls(struct user_namespace *ns);
 void retire_userns_sysctls(struct user_namespace *ns);
-struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid);
-void dec_user_namespaces(struct ucounts *ucounts);
+struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid, enum ucount_type type);
+void dec_ucount(struct ucounts *ucounts, enum ucount_type type);
 
 #ifdef CONFIG_USER_NS
 

commit f6b2db1a3e8d141dd144df58900fb0444d5d7c53
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 13:54:50 2016 -0500

    userns: Make the count of user namespaces per user
    
    Add a structure that is per user and per user ns and use it to hold
    the count of user namespaces.  This makes prevents one user from
    creating denying service to another user by creating the maximum
    number of user namespaces.
    
    Rename the sysctl export of the maximum count from
    /proc/sys/userns/max_user_namespaces to /proc/sys/user/max_user_namespaces
    to reflect that the count is now per user.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 6421cca2daa9..826de7a12a20 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -22,6 +22,7 @@ struct uid_gid_map {	/* 64 bytes -- 1 cache line */
 
 #define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED
 
+struct ucounts;
 struct user_namespace {
 	struct uid_gid_map	uid_map;
 	struct uid_gid_map	gid_map;
@@ -44,15 +45,24 @@ struct user_namespace {
 	struct ctl_table_set	set;
 	struct ctl_table_header *sysctls;
 #endif
+	struct ucounts		*ucounts;
 	int max_user_namespaces;
+};
+
+struct ucounts {
+	struct hlist_node node;
+	struct user_namespace *ns;
+	kuid_t uid;
+	atomic_t count;
 	atomic_t user_namespaces;
 };
 
 extern struct user_namespace init_user_ns;
-extern bool setup_userns_sysctls(struct user_namespace *ns);
-extern void retire_userns_sysctls(struct user_namespace *ns);
-extern bool inc_user_namespaces(struct user_namespace *ns);
-extern void dec_user_namespaces(struct user_namespace *ns);
+
+bool setup_userns_sysctls(struct user_namespace *ns);
+void retire_userns_sysctls(struct user_namespace *ns);
+struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid);
+void dec_user_namespaces(struct ucounts *ucounts);
 
 #ifdef CONFIG_USER_NS
 

commit b376c3e1b6770ddcb4f0782be16358095fcea0b6
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 8 13:41:24 2016 -0500

    userns: Add a limit on the number of user namespaces
    
    Export the export the maximum number of user namespaces as
    /proc/sys/userns/max_user_namespaces.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index e5697eaf6bf9..6421cca2daa9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -44,9 +44,15 @@ struct user_namespace {
 	struct ctl_table_set	set;
 	struct ctl_table_header *sysctls;
 #endif
+	int max_user_namespaces;
+	atomic_t user_namespaces;
 };
 
 extern struct user_namespace init_user_ns;
+extern bool setup_userns_sysctls(struct user_namespace *ns);
+extern void retire_userns_sysctls(struct user_namespace *ns);
+extern bool inc_user_namespaces(struct user_namespace *ns);
+extern void dec_user_namespaces(struct user_namespace *ns);
 
 #ifdef CONFIG_USER_NS
 

commit dbec28460a89aa7c02c3301e9e108d98272549d2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jul 30 13:58:49 2016 -0500

    userns: Add per user namespace sysctls.
    
    Limit per userns sysctls to only be opened for write by a holder
    of CAP_SYS_RESOURCE.
    
    Add all of the necessary boilerplate for having per user namespace
    sysctls.
    
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4e79b3c64dee..e5697eaf6bf9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -40,6 +40,10 @@ struct user_namespace {
 	struct rw_semaphore	persistent_keyring_register_sem;
 #endif
 	struct work_struct	work;
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_set	set;
+	struct ctl_table_header *sysctls;
+#endif
 };
 
 extern struct user_namespace init_user_ns;

commit b032132c3c218f4a09e9499b3674299a752581c6
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Jul 30 13:53:37 2016 -0500

    userns: Free user namespaces in process context
    
    Add the necessary boiler plate to move freeing of user namespaces into
    work queue and thus into process context where things can sleep.
    
    This is a necessary precursor to per user namespace sysctls.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 9217169c64cb..4e79b3c64dee 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -39,6 +39,7 @@ struct user_namespace {
 	struct key		*persistent_keyring_register;
 	struct rw_semaphore	persistent_keyring_register_sem;
 #endif
+	struct work_struct	work;
 };
 
 extern struct user_namespace init_user_ns;
@@ -54,12 +55,12 @@ static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 
 extern int create_user_ns(struct cred *new);
 extern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);
-extern void free_user_ns(struct user_namespace *ns);
+extern void __put_user_ns(struct user_namespace *ns);
 
 static inline void put_user_ns(struct user_namespace *ns)
 {
 	if (ns && atomic_dec_and_test(&ns->count))
-		free_user_ns(ns);
+		__put_user_ns(ns);
 }
 
 struct seq_operations;

commit d07b846f6200454c50d791796edb82660192513d
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Wed Sep 23 15:16:04 2015 -0500

    fs: Limit file caps to the user namespace of the super block
    
    Capability sets attached to files must be ignored except in the
    user namespaces where the mounter is privileged, i.e. s_user_ns
    and its descendants. Otherwise a vector exists for gaining
    privileges in namespaces where a user is not already privileged.
    
    Add a new helper function, current_in_user_ns(), to test whether a user
    namespace is the same as or a descendant of another namespace.
    Use this helper to determine whether a file's capability set
    should be applied to the caps constructed during exec.
    
    --EWB Replaced in_userns with the simpler current_in_userns.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 8297e5b341d8..9217169c64cb 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -72,6 +72,7 @@ extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t,
 extern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);
 extern int proc_setgroups_show(struct seq_file *m, void *v);
 extern bool userns_may_setgroups(const struct user_namespace *ns);
+extern bool current_in_userns(const struct user_namespace *target_ns);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -100,6 +101,11 @@ static inline bool userns_may_setgroups(const struct user_namespace *ns)
 {
 	return true;
 }
+
+static inline bool current_in_userns(const struct user_namespace *target_ns)
+{
+	return true;
+}
 #endif
 
 #endif /* _LINUX_USER_H */

commit 87c31b39abcb6fb6bd7d111200c9627a594bf6a9
Merge: f045bbb9fa1b db86da7cb76f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 17 12:31:40 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace related fixes from Eric Biederman:
     "As these are bug fixes almost all of thes changes are marked for
      backporting to stable.
    
      The first change (implicitly adding MNT_NODEV on remount) addresses a
      regression that was created when security issues with unprivileged
      remount were closed.  I go on to update the remount test to make it
      easy to detect if this issue reoccurs.
    
      Then there are a handful of mount and umount related fixes.
    
      Then half of the changes deal with the a recently discovered design
      bug in the permission checks of gid_map.  Unix since the beginning has
      allowed setting group permissions on files to less than the user and
      other permissions (aka ---rwx---rwx).  As the unix permission checks
      stop as soon as a group matches, and setgroups allows setting groups
      that can not later be dropped, results in a situtation where it is
      possible to legitimately use a group to assign fewer privileges to a
      process.  Which means dropping a group can increase a processes
      privileges.
    
      The fix I have adopted is that gid_map is now no longer writable
      without privilege unless the new file /proc/self/setgroups has been
      set to permanently disable setgroups.
    
      The bulk of user namespace using applications even the applications
      using applications using user namespaces without privilege remain
      unaffected by this change.  Unfortunately this ix breaks a couple user
      space applications, that were relying on the problematic behavior (one
      of which was tools/selftests/mount/unprivileged-remount-test.c).
    
      To hopefully prevent needing a regression fix on top of my security
      fix I rounded folks who work with the container implementations mostly
      like to be affected and encouraged them to test the changes.
    
        > So far nothing broke on my libvirt-lxc test bed. :-)
        > Tested with openSUSE 13.2 and libvirt 1.2.9.
        > Tested-by: Richard Weinberger <richard@nod.at>
    
        > Tested on Fedora20 with libvirt 1.2.11, works fine.
        > Tested-by: Chen Hanxiao <chenhanxiao@cn.fujitsu.com>
    
        > Ok, thanks - yes, unprivileged lxc is working fine with your kernels.
        > Just to be sure I was testing the right thing I also tested using
        > my unprivileged nsexec testcases, and they failed on setgroup/setgid
        > as now expected, and succeeded there without your patches.
        > Tested-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    
        > I tested this with Sandstorm.  It breaks as is and it works if I add
        > the setgroups thing.
        > Tested-by: Andy Lutomirski <luto@amacapital.net> # breaks things as designed :("
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      userns: Unbreak the unprivileged remount tests
      userns; Correct the comment in map_write
      userns: Allow setting gid_maps without privilege when setgroups is disabled
      userns: Add a knob to disable setgroups on a per user namespace basis
      userns: Rename id_map_mutex to userns_state_mutex
      userns: Only allow the creator of the userns unprivileged mappings
      userns: Check euid no fsuid when establishing an unprivileged uid mapping
      userns: Don't allow unprivileged creation of gid mappings
      userns: Don't allow setgroups until a gid mapping has been setablished
      userns: Document what the invariant required for safe unprivileged mappings.
      groups: Consolidate the setgroups permission checks
      mnt: Clear mnt_expire during pivot_root
      mnt: Carefully set CL_UNPRIVILEGED in clone_mnt
      mnt: Move the clear of MNT_LOCKED from copy_tree to it's callers.
      umount: Do not allow unmounting rootfs.
      umount: Disallow unprivileged mount force
      mnt: Update unprivileged remount test
      mnt: Implicitly add MNT_NODEV on remount when it was implicitly added by mount

commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Dec 2 12:27:26 2014 -0600

    userns: Add a knob to disable setgroups on a per user namespace basis
    
    - Expose the knob to user space through a proc file /proc/<pid>/setgroups
    
      A value of "deny" means the setgroups system call is disabled in the
      current processes user namespace and can not be enabled in the
      future in this user namespace.
    
      A value of "allow" means the segtoups system call is enabled.
    
    - Descendant user namespaces inherit the value of setgroups from
      their parents.
    
    - A proc file is used (instead of a sysctl) as sysctls currently do
      not allow checking the permissions at open time.
    
    - Writing to the proc file is restricted to before the gid_map
      for the user namespace is set.
    
      This ensures that disabling setgroups at a user namespace
      level will never remove the ability to call setgroups
      from a process that already has that ability.
    
      A process may opt in to the setgroups disable for itself by
      creating, entering and configuring a user namespace or by calling
      setns on an existing user namespace with setgroups disabled.
      Processes without privileges already can not call setgroups so this
      is a noop.  Prodcess with privilege become processes without
      privilege when entering a user namespace and as with any other path
      to dropping privilege they would not have the ability to call
      setgroups.  So this remains within the bounds of what is possible
      without a knob to disable setgroups permanently in a user namespace.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 8d493083486a..9f3579ff543d 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -17,6 +17,10 @@ struct uid_gid_map {	/* 64 bytes -- 1 cache line */
 	} extent[UID_GID_MAP_MAX_EXTENTS];
 };
 
+#define USERNS_SETGROUPS_ALLOWED 1UL
+
+#define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED
+
 struct user_namespace {
 	struct uid_gid_map	uid_map;
 	struct uid_gid_map	gid_map;
@@ -27,6 +31,7 @@ struct user_namespace {
 	kuid_t			owner;
 	kgid_t			group;
 	unsigned int		proc_inum;
+	unsigned long		flags;
 
 	/* Register of per-UID persistent keyrings for this namespace */
 #ifdef CONFIG_PERSISTENT_KEYRINGS
@@ -63,6 +68,8 @@ extern const struct seq_operations proc_projid_seq_operations;
 extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t proc_setgroups_write(struct file *, const char __user *, size_t, loff_t *);
+extern int proc_setgroups_show(struct seq_file *m, void *v);
 extern bool userns_may_setgroups(const struct user_namespace *ns);
 #else
 

commit 273d2c67c3e179adb1e74f403d1e9a06e3f841b5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 18:01:11 2014 -0600

    userns: Don't allow setgroups until a gid mapping has been setablished
    
    setgroups is unique in not needing a valid mapping before it can be called,
    in the case of setgroups(0, NULL) which drops all supplemental groups.
    
    The design of the user namespace assumes that CAP_SETGID can not actually
    be used until a gid mapping is established.  Therefore add a helper function
    to see if the user namespace gid mapping has been established and call
    that function in the setgroups permission check.
    
    This is part of the fix for CVE-2014-8989, being able to drop groups
    without privilege using user namespaces.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index e95372654f09..8d493083486a 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -63,6 +63,7 @@ extern const struct seq_operations proc_projid_seq_operations;
 extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);
+extern bool userns_may_setgroups(const struct user_namespace *ns);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -87,6 +88,10 @@ static inline void put_user_ns(struct user_namespace *ns)
 {
 }
 
+static inline bool userns_may_setgroups(const struct user_namespace *ns)
+{
+	return true;
+}
 #endif
 
 #endif /* _LINUX_USER_H */

commit 435d5f4bb2ccba3b791d9ef61d2590e30b8e806e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 31 22:56:04 2014 -0400

    common object embedded into various struct ....ns
    
    for now - just move corresponding ->proc_inum instances over there
    
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index e95372654f09..4cf06c140e21 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -3,6 +3,7 @@
 
 #include <linux/kref.h>
 #include <linux/nsproxy.h>
+#include <linux/ns_common.h>
 #include <linux/sched.h>
 #include <linux/err.h>
 
@@ -26,7 +27,7 @@ struct user_namespace {
 	int			level;
 	kuid_t			owner;
 	kgid_t			group;
-	unsigned int		proc_inum;
+	struct ns_common	ns;
 
 	/* Register of per-UID persistent keyrings for this namespace */
 #ifdef CONFIG_PERSISTENT_KEYRINGS

commit ccf94f1b4a8560ffdc221840535bae5e5a91a53c
Author: Fabian Frederick <fabf@skynet.be>
Date:   Fri Aug 8 14:21:22 2014 -0700

    proc: constify seq_operations
    
    proc_uid_seq_operations, proc_gid_seq_operations and
    proc_projid_seq_operations are only called in proc_id_map_open with
    seq_open as const struct seq_operations so we can constify the 3
    structures and update proc_id_map_open prototype.
    
       text    data     bss     dec     hex filename
       6817     404    1984    9205    23f5 kernel/user_namespace.o-before
       6913     308    1984    9205    23f5 kernel/user_namespace.o-after
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4836ba3c1cd8..e95372654f09 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -57,9 +57,9 @@ static inline void put_user_ns(struct user_namespace *ns)
 }
 
 struct seq_operations;
-extern struct seq_operations proc_uid_seq_operations;
-extern struct seq_operations proc_gid_seq_operations;
-extern struct seq_operations proc_projid_seq_operations;
+extern const struct seq_operations proc_uid_seq_operations;
+extern const struct seq_operations proc_gid_seq_operations;
+extern const struct seq_operations proc_projid_seq_operations;
 extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);

commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:19 2013 +0100

    KEYS: Add per-user_namespace registers for persistent per-UID kerberos caches
    
    Add support for per-user_namespace registers of persistent per-UID kerberos
    caches held within the kernel.
    
    This allows the kerberos cache to be retained beyond the life of all a user's
    processes so that the user's cron jobs can work.
    
    The kerberos cache is envisioned as a keyring/key tree looking something like:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 big_key     - A ccache blob
                            \___ tkt12345 big_key   - Another ccache blob
    
    Or possibly:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 keyring     - A ccache
                                    \___ krbtgt/REDHAT.COM@REDHAT.COM big_key
                                    \___ http/REDHAT.COM@REDHAT.COM user
                                    \___ afs/REDHAT.COM@REDHAT.COM user
                                    \___ nfs/REDHAT.COM@REDHAT.COM user
                                    \___ krbtgt/KERNEL.ORG@KERNEL.ORG big_key
                                    \___ http/KERNEL.ORG@KERNEL.ORG big_key
    
    What goes into a particular Kerberos cache is entirely up to userspace.  Kernel
    support is limited to giving you the Kerberos cache keyring that you want.
    
    The user asks for their Kerberos cache by:
    
            krb_cache = keyctl_get_krbcache(uid, dest_keyring);
    
    The uid is -1 or the user's own UID for the user's own cache or the uid of some
    other user's cache (requires CAP_SETUID).  This permits rpc.gssd or whatever to
    mess with the cache.
    
    The cache returned is a keyring named "_krb.<uid>" that the possessor can read,
    search, clear, invalidate, unlink from and add links to.  Active LSMs get a
    chance to rule on whether the caller is permitted to make a link.
    
    Each uid's cache keyring is created when it first accessed and is given a
    timeout that is extended each time this function is called so that the keyring
    goes away after a while.  The timeout is configurable by sysctl but defaults to
    three days.
    
    Each user_namespace struct gets a lazily-created keyring that serves as the
    register.  The cache keyrings are added to it.  This means that standard key
    search and garbage collection facilities are available.
    
    The user_namespace struct's register goes away when it does and anything left
    in it is then automatically gc'd.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Simo Sorce <simo@redhat.com>
    cc: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4db29859464f..4836ba3c1cd8 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -27,6 +27,12 @@ struct user_namespace {
 	kuid_t			owner;
 	kgid_t			group;
 	unsigned int		proc_inum;
+
+	/* Register of per-UID persistent keyrings for this namespace */
+#ifdef CONFIG_PERSISTENT_KEYRINGS
+	struct key		*persistent_keyring_register;
+	struct rw_semaphore	persistent_keyring_register_sem;
+#endif
 };
 
 extern struct user_namespace init_user_ns;

commit c7c4591db64dbd1e504bc4e2806d7ef290a3c81b
Merge: 11c7b03d42a8 c7b96acf1456
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 7 14:35:32 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace changes from Eric Biederman:
     "This is an assorted mishmash of small cleanups, enhancements and bug
      fixes.
    
      The major theme is user namespace mount restrictions.  nsown_capable
      is killed as it encourages not thinking about details that need to be
      considered.  A very hard to hit pid namespace exiting bug was finally
      tracked and fixed.  A couple of cleanups to the basic namespace
      infrastructure.
    
      Finally there is an enhancement that makes per user namespace
      capabilities usable as capabilities, and an enhancement that allows
      the per userns root to nice other processes in the user namespace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      userns:  Kill nsown_capable it makes the wrong thing easy
      capabilities: allow nice if we are privileged
      pidns: Don't have unshare(CLONE_NEWPID) imply CLONE_THREAD
      userns: Allow PR_CAPBSET_DROP in a user namespace.
      namespaces: Simplify copy_namespaces so it is clear what is going on.
      pidns: Fix hang in zap_pid_ns_processes by sending a potentially extra wakeup
      sysfs: Restrict mounting sysfs
      userns: Better restrictions on when proc and sysfs can be mounted
      vfs: Don't copy mount bind mounts of /proc/<pid>/ns/mnt between namespaces
      kernel/nsproxy.c: Improving a snippet of code.
      proc: Restrict mounting the proc filesystem
      vfs: Lock in place mounts from more privileged users

commit e51db73532955dc5eaba4235e62b74b460709d5b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 30 19:57:41 2013 -0700

    userns: Better restrictions on when proc and sysfs can be mounted
    
    Rely on the fact that another flavor of the filesystem is already
    mounted and do not rely on state in the user namespace.
    
    Verify that the mounted filesystem is not covered in any significant
    way.  I would love to verify that the previously mounted filesystem
    has no mounts on top but there are at least the directories
    /proc/sys/fs/binfmt_misc and /sys/fs/cgroup/ that exist explicitly
    for other filesystems to mount on top of.
    
    Refactor the test into a function named fs_fully_visible and call that
    function from the mount routines of proc and sysfs.  This makes this
    test local to the filesystems involved and the results current of when
    the mounts take place, removing a weird threading of the user
    namespace, the mount namespace and the filesystems themselves.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index b6b215f13b45..4ce009324933 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -26,8 +26,6 @@ struct user_namespace {
 	kuid_t			owner;
 	kgid_t			group;
 	unsigned int		proc_inum;
-	bool			may_mount_sysfs;
-	bool			may_mount_proc;
 };
 
 extern struct user_namespace init_user_ns;
@@ -84,6 +82,4 @@ static inline void put_user_ns(struct user_namespace *ns)
 
 #endif
 
-void update_mnt_policy(struct user_namespace *userns);
-
 #endif /* _LINUX_USER_H */

commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Thu Aug 8 18:55:32 2013 +0200

    userns: limit the maximum depth of user_namespace->parent chain
    
    Ensure that user_namespace->parent chain can't grow too much.
    Currently we use the hardroded 32 as limit.
    
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index b6b215f13b45..14105c26a836 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -23,6 +23,7 @@ struct user_namespace {
 	struct uid_gid_map	projid_map;
 	atomic_t		count;
 	struct user_namespace	*parent;
+	int			level;
 	kuid_t			owner;
 	kgid_t			group;
 	unsigned int		proc_inum;

commit 87a8ebd637dafc255070f503909a053cf0d98d3f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Mar 24 14:28:27 2013 -0700

    userns: Restrict when proc and sysfs can be mounted
    
    Only allow unprivileged mounts of proc and sysfs if they are already
    mounted when the user namespace is created.
    
    proc and sysfs are interesting because they have content that is
    per namespace, and so fresh mounts are needed when new namespaces
    are created while at the same time proc and sysfs have content that
    is shared between every instance.
    
    Respect the policy of who may see the shared content of proc and sysfs
    by only allowing new mounts if there was an existing mount at the time
    the user namespace was created.
    
    In practice there are only two interesting cases: proc and sysfs are
    mounted at their usual places, proc and sysfs are not mounted at all
    (some form of mount namespace jail).
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4ce009324933..b6b215f13b45 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -26,6 +26,8 @@ struct user_namespace {
 	kuid_t			owner;
 	kgid_t			group;
 	unsigned int		proc_inum;
+	bool			may_mount_sysfs;
+	bool			may_mount_proc;
 };
 
 extern struct user_namespace init_user_ns;
@@ -82,4 +84,6 @@ static inline void put_user_ns(struct user_namespace *ns)
 
 #endif
 
+void update_mnt_policy(struct user_namespace *userns);
+
 #endif /* _LINUX_USER_H */

commit c61a2810a2161986353705b44d9503e6bb079f4f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 28 18:58:39 2012 -0800

    userns: Avoid recursion in put_user_ns
    
    When freeing a deeply nested user namespace free_user_ns calls
    put_user_ns on it's parent which may in turn call free_user_ns again.
    When -fno-optimize-sibling-calls is passed to gcc one stack frame per
    user namespace is left on the stack, potentially overflowing the
    kernel stack.  CONFIG_FRAME_POINTER forces -fno-optimize-sibling-calls
    so we can't count on gcc to optimize this code.
    
    Remove struct kref and use a plain atomic_t.  Making the code more
    flexible and easier to comprehend.  Make the loop in free_user_ns
    explict to guarantee that the stack does not overflow with
    CONFIG_FRAME_POINTER enabled.
    
    I have tested this fix with a simple program that uses unshare to
    create a deeply nested user namespace structure and then calls exit.
    With 1000 nesteuser namespaces before this change running my test
    program causes the kernel to die a horrible death.  With 10,000,000
    nested user namespaces after this change my test program runs to
    completion and causes no harm.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Pointed-out-by: Vasily Kulikov <segoon@openwall.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index b9bd2e6c73cc..4ce009324933 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -21,7 +21,7 @@ struct user_namespace {
 	struct uid_gid_map	uid_map;
 	struct uid_gid_map	gid_map;
 	struct uid_gid_map	projid_map;
-	struct kref		kref;
+	atomic_t		count;
 	struct user_namespace	*parent;
 	kuid_t			owner;
 	kgid_t			group;
@@ -35,18 +35,18 @@ extern struct user_namespace init_user_ns;
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 {
 	if (ns)
-		kref_get(&ns->kref);
+		atomic_inc(&ns->count);
 	return ns;
 }
 
 extern int create_user_ns(struct cred *new);
 extern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);
-extern void free_user_ns(struct kref *kref);
+extern void free_user_ns(struct user_namespace *ns);
 
 static inline void put_user_ns(struct user_namespace *ns)
 {
-	if (ns)
-		kref_put(&ns->kref, free_user_ns);
+	if (ns && atomic_dec_and_test(&ns->count))
+		free_user_ns(ns);
 }
 
 struct seq_operations;

commit 98f842e675f96ffac96e6c50315790912b2812be
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jun 15 10:21:48 2011 -0700

    proc: Usable inode numbers for the namespace file descriptors.
    
    Assign a unique proc inode to each namespace, and use that
    inode number to ensure we only allocate at most one proc
    inode for every namespace in proc.
    
    A single proc inode per namespace allows userspace to test
    to see if two processes are in the same namespace.
    
    This has been a long requested feature and only blocked because
    a naive implementation would put the id in a global space and
    would ultimately require having a namespace for the names of
    namespaces, making migration and certain virtualization tricks
    impossible.
    
    We still don't have per superblock inode numbers for proc, which
    appears necessary for application unaware checkpoint/restart and
    migrations (if the application is using namespace file descriptors)
    but that is now allowd by the design if it becomes important.
    
    I have preallocated the ipc and uts initial proc inode numbers so
    their structures can be statically initialized.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 17651f08d67f..b9bd2e6c73cc 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -25,6 +25,7 @@ struct user_namespace {
 	struct user_namespace	*parent;
 	kuid_t			owner;
 	kgid_t			group;
+	unsigned int		proc_inum;
 };
 
 extern struct user_namespace init_user_ns;

commit b2e0d98705e60e45bbb3c0032c48824ad7ae0704
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 26 05:15:35 2012 -0700

    userns: Implement unshare of the user namespace
    
    - Add CLONE_THREAD to the unshare flags if CLONE_NEWUSER is selected
      As changing user namespaces is only valid if all there is only
      a single thread.
    - Restore the code to add CLONE_VM if CLONE_THREAD is selected and
      the code to addCLONE_SIGHAND if CLONE_VM is selected.
      Making the constraints in the code clear.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 95142cae446a..17651f08d67f 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -39,6 +39,7 @@ static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 }
 
 extern int create_user_ns(struct cred *new);
+extern int unshare_userns(unsigned long unshare_flags, struct cred **new_cred);
 extern void free_user_ns(struct kref *kref);
 
 static inline void put_user_ns(struct user_namespace *ns)
@@ -66,6 +67,14 @@ static inline int create_user_ns(struct cred *new)
 	return -EINVAL;
 }
 
+static inline int unshare_userns(unsigned long unshare_flags,
+				 struct cred **new_cred)
+{
+	if (unshare_flags & CLONE_NEWUSER)
+		return -EINVAL;
+	return 0;
+}
+
 static inline void put_user_ns(struct user_namespace *ns)
 {
 }

commit f76d207a66c3a53defea67e7d36c3eb1b7d6d61d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Aug 30 01:24:05 2012 -0700

    userns: Add kprojid_t and associated infrastructure in projid.h
    
    Implement kprojid_t a cousin of the kuid_t and kgid_t.
    
    The per user namespace mapping of project id values can be set with
    /proc/<pid>/projid_map.
    
    A full compliment of helpers is provided: make_kprojid, from_kprojid,
    from_kprojid_munged, kporjid_has_mapping, projid_valid, projid_eq,
    projid_eq, projid_lt.
    
    Project identifiers are part of the generic disk quota interface,
    although it appears only xfs implements project identifiers currently.
    
    The xfs code allows anyone who has permission to set the project
    identifier on a file to use any project identifier so when
    setting up the user namespace project identifier mappings I do
    not require a capability.
    
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4e72922e5a75..95142cae446a 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -20,6 +20,7 @@ struct uid_gid_map {	/* 64 bytes -- 1 cache line */
 struct user_namespace {
 	struct uid_gid_map	uid_map;
 	struct uid_gid_map	gid_map;
+	struct uid_gid_map	projid_map;
 	struct kref		kref;
 	struct user_namespace	*parent;
 	kuid_t			owner;
@@ -49,8 +50,10 @@ static inline void put_user_ns(struct user_namespace *ns)
 struct seq_operations;
 extern struct seq_operations proc_uid_seq_operations;
 extern struct seq_operations proc_gid_seq_operations;
+extern struct seq_operations proc_projid_seq_operations;
 extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t proc_projid_map_write(struct file *, const char __user *, size_t, loff_t *);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)

commit 76b6db010297d4928ab7b7e7c78dd982f413f0a4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Mar 14 15:24:19 2012 -0700

    userns: Replace user_ns_map_uid and user_ns_map_gid with from_kuid and from_kgid
    
    These function are no longer needed replace them with their more useful equivalents.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index a2c61457cba1..4e72922e5a75 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -69,16 +69,4 @@ static inline void put_user_ns(struct user_namespace *ns)
 
 #endif
 
-static inline uid_t user_ns_map_uid(struct user_namespace *to,
-	const struct cred *cred, kuid_t uid)
-{
-	return from_kuid_munged(to, uid);
-}
-
-static inline gid_t user_ns_map_gid(struct user_namespace *to,
-	const struct cred *cred, kgid_t gid)
-{
-	return from_kgid_munged(to, gid);
-}
-
 #endif /* _LINUX_USER_H */

commit 078de5f706ece36afd73bb4b8283314132d2dfdf
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 8 07:00:08 2012 -0800

    userns: Store uid and gid values in struct cred with kuid_t and kgid_t types
    
    cred.h and a few trivial users of struct cred are changed.  The rest of the users
    of struct cred are left for other patches as there are too many changes to make
    in one go and leave the change reviewable.  If the user namespace is disabled and
    CONFIG_UIDGID_STRICT_TYPE_CHECKS are disabled the code will contiue to compile
    and behave correctly.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 4c9846d90741..a2c61457cba1 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -70,15 +70,15 @@ static inline void put_user_ns(struct user_namespace *ns)
 #endif
 
 static inline uid_t user_ns_map_uid(struct user_namespace *to,
-	const struct cred *cred, uid_t uid)
+	const struct cred *cred, kuid_t uid)
 {
-	return from_kuid_munged(to, make_kuid(cred->user_ns, uid));
+	return from_kuid_munged(to, uid);
 }
 
 static inline gid_t user_ns_map_gid(struct user_namespace *to,
-	const struct cred *cred, gid_t gid)
+	const struct cred *cred, kgid_t gid)
 {
-	return from_kgid_munged(to, make_kgid(cred->user_ns, gid));
+	return from_kgid_munged(to, gid);
 }
 
 #endif /* _LINUX_USER_H */

commit 22d917d80e842829d0ca0a561967d728eb1d6303
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Nov 17 00:11:58 2011 -0800

    userns: Rework the user_namespace adding uid/gid mapping support
    
    - Convert the old uid mapping functions into compatibility wrappers
    - Add a uid/gid mapping layer from user space uid and gids to kernel
      internal uids and gids that is extent based for simplicty and speed.
      * Working with number space after mapping uids/gids into their kernel
        internal version adds only mapping complexity over what we have today,
        leaving the kernel code easy to understand and test.
    - Add proc files /proc/self/uid_map /proc/self/gid_map
      These files display the mapping and allow a mapping to be added
      if a mapping does not exist.
    - Allow entering the user namespace without a uid or gid mapping.
      Since we are starting with an existing user our uids and gids
      still have global mappings so are still valid and useful they just don't
      have local mappings.  The requirement for things to work are global uid
      and gid so it is odd but perfectly fine not to have a local uid
      and gid mapping.
      Not requiring global uid and gid mappings greatly simplifies
      the logic of setting up the uid and gid mappings by allowing
      the mappings to be set after the namespace is created which makes the
      slight weirdness worth it.
    - Make the mappings in the initial user namespace to the global
      uid/gid space explicit.  Today it is an identity mapping
      but in the future we may want to twist this for debugging, similar
      to what we do with jiffies.
    - Document the memory ordering requirements of setting the uid and
      gid mappings.  We only allow the mappings to be set once
      and there are no pointers involved so the requirments are
      trivial but a little atypical.
    
    Performance:
    
    In this scheme for the permission checks the performance is expected to
    stay the same as the actuall machine instructions should remain the same.
    
    The worst case I could think of is ls -l on a large directory where
    all of the stat results need to be translated with from kuids and
    kgids to uids and gids.  So I benchmarked that case on my laptop
    with a dual core hyperthread Intel i5-2520M cpu with 3M of cpu cache.
    
    My benchmark consisted of going to single user mode where nothing else
    was running. On an ext4 filesystem opening 1,000,000 files and looping
    through all of the files 1000 times and calling fstat on the
    individuals files.  This was to ensure I was benchmarking stat times
    where the inodes were in the kernels cache, but the inode values were
    not in the processors cache.  My results:
    
    v3.4-rc1:         ~= 156ns (unmodified v3.4-rc1 with user namespace support disabled)
    v3.4-rc1-userns-: ~= 155ns (v3.4-rc1 with my user namespace patches and user namespace support disabled)
    v3.4-rc1-userns+: ~= 164ns (v3.4-rc1 with my user namespace patches and user namespace support enabled)
    
    All of the configurations ran in roughly 120ns when I performed tests
    that ran in the cpu cache.
    
    So in summary the performance impact is:
    1ns improvement in the worst case with user namespace support compiled out.
    8ns aka 5% slowdown in the worst case with user namespace support compiled in.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 8a391bd53de2..4c9846d90741 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -6,7 +6,20 @@
 #include <linux/sched.h>
 #include <linux/err.h>
 
+#define UID_GID_MAP_MAX_EXTENTS 5
+
+struct uid_gid_map {	/* 64 bytes -- 1 cache line */
+	u32 nr_extents;
+	struct uid_gid_extent {
+		u32 first;
+		u32 lower_first;
+		u32 count;
+	} extent[UID_GID_MAP_MAX_EXTENTS];
+};
+
 struct user_namespace {
+	struct uid_gid_map	uid_map;
+	struct uid_gid_map	gid_map;
 	struct kref		kref;
 	struct user_namespace	*parent;
 	kuid_t			owner;
@@ -33,9 +46,11 @@ static inline void put_user_ns(struct user_namespace *ns)
 		kref_put(&ns->kref, free_user_ns);
 }
 
-uid_t user_ns_map_uid(struct user_namespace *to, const struct cred *cred, uid_t uid);
-gid_t user_ns_map_gid(struct user_namespace *to, const struct cred *cred, gid_t gid);
-
+struct seq_operations;
+extern struct seq_operations proc_uid_seq_operations;
+extern struct seq_operations proc_gid_seq_operations;
+extern ssize_t proc_uid_map_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t proc_gid_map_write(struct file *, const char __user *, size_t, loff_t *);
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -52,17 +67,18 @@ static inline void put_user_ns(struct user_namespace *ns)
 {
 }
 
+#endif
+
 static inline uid_t user_ns_map_uid(struct user_namespace *to,
 	const struct cred *cred, uid_t uid)
 {
-	return uid;
+	return from_kuid_munged(to, make_kuid(cred->user_ns, uid));
 }
+
 static inline gid_t user_ns_map_gid(struct user_namespace *to,
 	const struct cred *cred, gid_t gid)
 {
-	return gid;
+	return from_kgid_munged(to, make_kgid(cred->user_ns, gid));
 }
 
-#endif
-
 #endif /* _LINUX_USER_H */

commit 783291e6900292521a3895583785e0c04a56c5b3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Nov 17 01:32:59 2011 -0800

    userns: Simplify the user_namespace by making userns->creator a kuid.
    
    - Transform userns->creator from a user_struct reference to a simple
      kuid_t, kgid_t pair.
    
      In cap_capable this allows the check to see if we are the creator of
      a namespace to become the classic suser style euid permission check.
    
      This allows us to remove the need for a struct cred in the mapping
      functions and still be able to dispaly the user namespace creators
      uid and gid as 0.
    
    - Remove the now unnecessary delayed_work in free_user_ns.
    
      All that is left for free_user_ns to do is to call kmem_cache_free
      and put_user_ns.  Those functions can be called in any context
      so call them directly from free_user_ns removing the need for delayed work.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index d767508db4f9..8a391bd53de2 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -9,8 +9,8 @@
 struct user_namespace {
 	struct kref		kref;
 	struct user_namespace	*parent;
-	struct user_struct	*creator;
-	struct work_struct	destroyer;
+	kuid_t			owner;
+	kgid_t			group;
 };
 
 extern struct user_namespace init_user_ns;

commit 7b44ab978b77a91b327058a0f4db7e6fcdb90b92
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 16 23:20:58 2011 -0800

    userns: Disassociate user_struct from the user_namespace.
    
    Modify alloc_uid to take a kuid and make the user hash table global.
    Stop holding a reference to the user namespace in struct user_struct.
    
    This simplifies the code and makes the per user accounting not
    care about which user namespace a uid happens to appear in.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index dc2d85a76376..d767508db4f9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -6,12 +6,8 @@
 #include <linux/sched.h>
 #include <linux/err.h>
 
-#define UIDHASH_BITS	(CONFIG_BASE_SMALL ? 3 : 7)
-#define UIDHASH_SZ	(1 << UIDHASH_BITS)
-
 struct user_namespace {
 	struct kref		kref;
-	struct hlist_head	uidhash_table[UIDHASH_SZ];
 	struct user_namespace	*parent;
 	struct user_struct	*creator;
 	struct work_struct	destroyer;

commit aeb3ae9da9b50a386b22af786d19b623e8d9f0fa
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 16 21:59:43 2011 -0800

    userns: Add an explicit reference to the parent user namespace
    
    I am about to remove the struct user_namespace reference from struct user_struct.
    So keep an explicit track of the parent user namespace.
    
    Take advantage of this new reference and replace instances of user_ns->creator->user_ns
    with user_ns->parent.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index faf467944baf..dc2d85a76376 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -12,6 +12,7 @@
 struct user_namespace {
 	struct kref		kref;
 	struct hlist_head	uidhash_table[UIDHASH_SZ];
+	struct user_namespace	*parent;
 	struct user_struct	*creator;
 	struct work_struct	destroyer;
 };

commit 6164281ab7a4d3bd42588d6b25984e960a2e032f
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Jan 12 17:00:46 2011 -0800

    user_ns: improve the user_ns on-the-slab packaging
    
    Currently on 64-bit arch the user_namespace is 2096 and when being
    kmalloc-ed it resides on a 4k slab wasting 2003 bytes.
    
    If we allocate a separate cache for it and reduce the hash size from 128
    to 64 chains the packaging becomes *much* better - the struct is 1072
    bytes and the hole between is 98 bytes.
    
    [akpm@linux-foundation.org: s/__initcall/module_init/]
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: Serge E. Hallyn <serge@hallyn.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 8178156711f9..faf467944baf 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -6,7 +6,7 @@
 #include <linux/sched.h>
 #include <linux/err.h>
 
-#define UIDHASH_BITS	(CONFIG_BASE_SMALL ? 3 : 8)
+#define UIDHASH_BITS	(CONFIG_BASE_SMALL ? 3 : 7)
 #define UIDHASH_SZ	(1 << UIDHASH_BITS)
 
 struct user_namespace {

commit 5c1469de7545a35a16ff2b902e217044a7d2f8a5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Jun 13 03:28:03 2010 +0000

    user_ns: Introduce user_nsmap_uid and user_ns_map_gid.
    
    Define what happens when a we view a uid from one user_namespace
    in another user_namepece.
    
    - If the user namespaces are the same no mapping is necessary.
    
    - For most cases of difference use overflowuid and overflowgid,
      the uid and gid currently used for 16bit apis when we have a 32bit uid
      that does fit in 16bits.  Effectively the situation is the same,
      we want to return a uid or gid that is not assigned to any user.
    
    - For the case when we happen to be mapping the uid or gid of the
      creator of the target user namespace use uid 0 and gid as confusing
      that user with root is not a problem.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index cc4f45361dbb..8178156711f9 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -36,6 +36,9 @@ static inline void put_user_ns(struct user_namespace *ns)
 		kref_put(&ns->kref, free_user_ns);
 }
 
+uid_t user_ns_map_uid(struct user_namespace *to, const struct cred *cred, uid_t uid);
+gid_t user_ns_map_gid(struct user_namespace *to, const struct cred *cred, gid_t gid);
+
 #else
 
 static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
@@ -52,6 +55,17 @@ static inline void put_user_ns(struct user_namespace *ns)
 {
 }
 
+static inline uid_t user_ns_map_uid(struct user_namespace *to,
+	const struct cred *cred, uid_t uid)
+{
+	return uid;
+}
+static inline gid_t user_ns_map_gid(struct user_namespace *to,
+	const struct cred *cred, gid_t gid)
+{
+	return gid;
+}
+
 #endif
 
 #endif /* _LINUX_USER_H */

commit 5170836679185357dc1b7660bad13287b39e1e33
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 27 14:03:03 2009 -0800

    Fix recursive lock in free_uid()/free_user_ns()
    
    free_uid() and free_user_ns() are corecursive when CONFIG_USER_SCHED=n,
    but free_user_ns() is called from free_uid() by way of uid_hash_remove(),
    which requires uidhash_lock to be held.  free_user_ns() then calls
    free_uid() to complete the destruction.
    
    Fix this by deferring the destruction of the user_namespace.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 315bcd375224..cc4f45361dbb 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -13,6 +13,7 @@ struct user_namespace {
 	struct kref		kref;
 	struct hlist_head	uidhash_table[UIDHASH_SZ];
 	struct user_struct	*creator;
+	struct work_struct	destroyer;
 };
 
 extern struct user_namespace init_user_ns;

commit 18b6e0414e42d95183f07d8177e3ff0241abd825
Author: Serge Hallyn <serue@us.ibm.com>
Date:   Wed Oct 15 16:38:45 2008 -0500

    User namespaces: set of cleanups (v2)
    
    The user_ns is moved from nsproxy to user_struct, so that a struct
    cred by itself is sufficient to determine access (which it otherwise
    would not be).  Corresponding ecryptfs fixes (by David Howells) are
    here as well.
    
    Fix refcounting.  The following rules now apply:
            1. The task pins the user struct.
            2. The user struct pins its user namespace.
            3. The user namespace pins the struct user which created it.
    
    User namespaces are cloned during copy_creds().  Unsharing a new user_ns
    is no longer possible.  (We could re-add that, but it'll cause code
    duplication and doesn't seem useful if PAM doesn't need to clone user
    namespaces).
    
    When a user namespace is created, its first user (uid 0) gets empty
    keyrings and a clean group_info.
    
    This incorporates a previous patch by David Howells.  Here
    is his original patch description:
    
    >I suggest adding the attached incremental patch.  It makes the following
    >changes:
    >
    > (1) Provides a current_user_ns() macro to wrap accesses to current's user
    >     namespace.
    >
    > (2) Fixes eCryptFS.
    >
    > (3) Renames create_new_userns() to create_user_ns() to be more consistent
    >     with the other associated functions and because the 'new' in the name is
    >     superfluous.
    >
    > (4) Moves the argument and permission checks made for CLONE_NEWUSER to the
    >     beginning of do_fork() so that they're done prior to making any attempts
    >     at allocation.
    >
    > (5) Calls create_user_ns() after prepare_creds(), and gives it the new creds
    >     to fill in rather than have it return the new root user.  I don't imagine
    >     the new root user being used for anything other than filling in a cred
    >     struct.
    >
    >     This also permits me to get rid of a get_uid() and a free_uid(), as the
    >     reference the creds were holding on the old user_struct can just be
    >     transferred to the new namespace's creator pointer.
    >
    > (6) Makes create_user_ns() reset the UIDs and GIDs of the creds under
    >     preparation rather than doing it in copy_creds().
    >
    >David
    
    >Signed-off-by: David Howells <dhowells@redhat.com>
    
    Changelog:
            Oct 20: integrate dhowells comments
                    1. leave thread_keyring alone
                    2. use current_user_ns() in set_user()
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index b5f41d4c2eec..315bcd375224 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -12,7 +12,7 @@
 struct user_namespace {
 	struct kref		kref;
 	struct hlist_head	uidhash_table[UIDHASH_SZ];
-	struct user_struct	*root_user;
+	struct user_struct	*creator;
 };
 
 extern struct user_namespace init_user_ns;
@@ -26,8 +26,7 @@ static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 	return ns;
 }
 
-extern struct user_namespace *copy_user_ns(int flags,
-					   struct user_namespace *old_ns);
+extern int create_user_ns(struct cred *new);
 extern void free_user_ns(struct kref *kref);
 
 static inline void put_user_ns(struct user_namespace *ns)
@@ -43,13 +42,9 @@ static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 	return &init_user_ns;
 }
 
-static inline struct user_namespace *copy_user_ns(int flags,
-						  struct user_namespace *old_ns)
+static inline int create_user_ns(struct cred *new)
 {
-	if (flags & CLONE_NEWUSER)
-		return ERR_PTR(-EINVAL);
-
-	return old_ns;
+	return -EINVAL;
 }
 
 static inline void put_user_ns(struct user_namespace *ns)

commit 735de2230f09741077a645a913de0a04b10208bf
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Tue Sep 18 22:46:44 2007 -0700

    Convert uid hash to hlist
    
    Surprisingly, but (spotted by Alexey Dobriyan) the uid hash still uses
    list_heads, thus occupying twice as much place as it could.  Convert it to
    hlist_heads.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@openvz.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 1101b0ce878f..b5f41d4c2eec 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -11,7 +11,7 @@
 
 struct user_namespace {
 	struct kref		kref;
-	struct list_head	uidhash_table[UIDHASH_SZ];
+	struct hlist_head	uidhash_table[UIDHASH_SZ];
 	struct user_struct	*root_user;
 };
 

commit 626ac545c12e5f9bffe93086d1d03d26c99987ea
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Tue Jul 17 15:28:17 2007 -0400

    user namespace: fix copy_user_ns return value
    
    When a CONFIG_USER_NS=n and a user tries to unshare some namespace other
    than the user namespace, the dummy copy_user_ns returns NULL rather than
    the old_ns.
    
    This value then gets assigned to task->nsproxy->user_ns, so that a
    subsequent setuid, which uses task->nsproxy->user_ns, causes a NULL
    pointer deref.
    
    Fix this by returning old_ns.
    
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index bb320573bb9e..1101b0ce878f 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -49,7 +49,7 @@ static inline struct user_namespace *copy_user_ns(int flags,
 	if (flags & CLONE_NEWUSER)
 		return ERR_PTR(-EINVAL);
 
-	return NULL;
+	return old_ns;
 }
 
 static inline void put_user_ns(struct user_namespace *ns)

commit 77ec739d8d0979477fc91f530403805afa2581a4
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Sun Jul 15 23:41:01 2007 -0700

    user namespace: add unshare
    
    This patch enables the unshare of user namespaces.
    
    It adds a new clone flag CLONE_NEWUSER and implements copy_user_ns() which
    resets the current user_struct and adds a new root user (uid == 0)
    
    For now, unsharing the user namespace allows a process to reset its
    user_struct accounting and uid 0 in the new user namespace should be contained
    using appropriate means, for instance selinux
    
    The plan, when the full support is complete (all uid checks covered), is to
    keep the original user's rights in the original namespace, and let a process
    become uid 0 in the new namespace, with full capabilities to the new
    namespace.
    
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Acked-by: Pavel Emelianov <xemul@openvz.org>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Kirill Korotaev <dev@sw.ru>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Andrew Morgan <agm@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 92a45867ecfb..bb320573bb9e 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -4,6 +4,7 @@
 #include <linux/kref.h>
 #include <linux/nsproxy.h>
 #include <linux/sched.h>
+#include <linux/err.h>
 
 #define UIDHASH_BITS	(CONFIG_BASE_SMALL ? 3 : 8)
 #define UIDHASH_SZ	(1 << UIDHASH_BITS)
@@ -45,6 +46,9 @@ static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
 static inline struct user_namespace *copy_user_ns(int flags,
 						  struct user_namespace *old_ns)
 {
+	if (flags & CLONE_NEWUSER)
+		return ERR_PTR(-EINVAL);
+
 	return NULL;
 }
 

commit acce292c82d4d82d35553b928df2b0597c3a9c78
Author: Cedric Le Goater <clg@fr.ibm.com>
Date:   Sun Jul 15 23:40:59 2007 -0700

    user namespace: add the framework
    
    Basically, it will allow a process to unshare its user_struct table,
    resetting at the same time its own user_struct and all the associated
    accounting.
    
    A new root user (uid == 0) is added to the user namespace upon creation.
    Such root users have full privileges and it seems that theses privileges
    should be controlled through some means (process capabilities ?)
    
    The unshare is not included in this patch.
    
    Changes since [try #4]:
            - Updated get_user_ns and put_user_ns to accept NULL, and
              get_user_ns to return the namespace.
    
    Changes since [try #3]:
            - moved struct user_namespace to files user_namespace.{c,h}
    
    Changes since [try #2]:
            - removed struct user_namespace* argument from find_user()
    
    Changes since [try #1]:
            - removed struct user_namespace* argument from find_user()
            - added a root_user per user namespace
    
    Signed-off-by: Cedric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Acked-by: Pavel Emelianov <xemul@openvz.org>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Kirill Korotaev <dev@sw.ru>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Andrew Morgan <agm@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
new file mode 100644
index 000000000000..92a45867ecfb
--- /dev/null
+++ b/include/linux/user_namespace.h
@@ -0,0 +1,57 @@
+#ifndef _LINUX_USER_NAMESPACE_H
+#define _LINUX_USER_NAMESPACE_H
+
+#include <linux/kref.h>
+#include <linux/nsproxy.h>
+#include <linux/sched.h>
+
+#define UIDHASH_BITS	(CONFIG_BASE_SMALL ? 3 : 8)
+#define UIDHASH_SZ	(1 << UIDHASH_BITS)
+
+struct user_namespace {
+	struct kref		kref;
+	struct list_head	uidhash_table[UIDHASH_SZ];
+	struct user_struct	*root_user;
+};
+
+extern struct user_namespace init_user_ns;
+
+#ifdef CONFIG_USER_NS
+
+static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
+{
+	if (ns)
+		kref_get(&ns->kref);
+	return ns;
+}
+
+extern struct user_namespace *copy_user_ns(int flags,
+					   struct user_namespace *old_ns);
+extern void free_user_ns(struct kref *kref);
+
+static inline void put_user_ns(struct user_namespace *ns)
+{
+	if (ns)
+		kref_put(&ns->kref, free_user_ns);
+}
+
+#else
+
+static inline struct user_namespace *get_user_ns(struct user_namespace *ns)
+{
+	return &init_user_ns;
+}
+
+static inline struct user_namespace *copy_user_ns(int flags,
+						  struct user_namespace *old_ns)
+{
+	return NULL;
+}
+
+static inline void put_user_ns(struct user_namespace *ns)
+{
+}
+
+#endif
+
+#endif /* _LINUX_USER_H */
