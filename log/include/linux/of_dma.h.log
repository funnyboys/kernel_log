commit af6074fc9aa4b29517375634189ada1869eea598
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 27 12:55:14 2017 -0600

    of: Use SPDX license tag for DT files
    
    Convert remaining DT files to use SPDX-License-Identifier tags.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Reviewed-by: Frank Rowand <frank.rowand@sony.com>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index b90d8ec57c1f..fd706cdf255c 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * OF helpers for DMA request / controller
  *
  * Based on of_gpio.h
  *
  * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __LINUX_OF_DMA_H

commit 500404ebcbd074ca11aa0c3fd9a268aa4054fd8b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Nov 3 12:28:10 2015 +0200

    dmaengine: of_dma: Correct return code for of_dma_request_slave_channel in case !CONFIG_OF
    
    of_dma_request_slave_channel should return either pointer for valid
    dma_chan or ERR_PTR() error code, NULL is not expected to be returned.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 36112cdd665a..b90d8ec57c1f 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -80,7 +80,7 @@ static inline int of_dma_router_register(struct device_node *np,
 static inline struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     const char *name)
 {
-	return NULL;
+	return ERR_PTR(-ENODEV);
 }
 
 static inline struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,

commit 9290a16cf19301224556bc7bcb913c0c2a45bb9a
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Aug 21 11:48:37 2015 +0000

    dmaengine: OF DMAEngine API based on CONFIG_DMA_OF instead of CONFIG_OF
    
    5fa422c ("dmaengine: move drivers/of/dma.c -> drivers/dma/of-dma.c")
    moved OF base DMAEngine code to of-dma.c, then it based on CONFIG_DMA_OF.
    But, OF base DMAEngine API on of_dma.h still based on CONFIG_OF now.
    So, current kernel can't find OF base DMAEngine API if .config has CONFIG_OF,
    but not have CONFIG_DMA_OF. This patch tidyup it.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 98ba7525929e..36112cdd665a 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -34,7 +34,7 @@ struct of_dma_filter_info {
 	dma_filter_fn	filter_fn;
 };
 
-#ifdef CONFIG_OF
+#ifdef CONFIG_DMA_OF
 extern int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
 		(struct of_phandle_args *, struct of_dma *),

commit 56f13c0d9524c5816f5dc9c91b9d766d6b1064ca
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Apr 9 12:35:47 2015 +0300

    dmaengine: of_dma: Support for DMA routers
    
    DMA routers are transparent devices used to mux DMA requests from
    peripherals to DMA controllers. They are used when the SoC integrates more
    devices with DMA requests then their controller can handle.
    DRA7x is one example of such SoC, where the sDMA can hanlde 128 DMA request
    lines, but in SoC level it has 205 DMA requests.
    
    The of_dma_router will be registered as of_dma_controller with special
    xlate function and additional parameters. The driver for the router is
    responsible to craft the dma_spec (in the of_dma_route_allocate callback)
    which can be used to requests a DMA channel from the real DMA controller.
    This way the router can be transparent for the system while remaining generic
    enough to be used in different environments.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 56bc026c143f..98ba7525929e 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -23,6 +23,9 @@ struct of_dma {
 	struct device_node	*of_node;
 	struct dma_chan		*(*of_dma_xlate)
 				(struct of_phandle_args *, struct of_dma *);
+	void			*(*of_dma_route_allocate)
+				(struct of_phandle_args *, struct of_dma *);
+	struct dma_router	*dma_router;
 	void			*of_dma_data;
 };
 
@@ -37,12 +40,20 @@ extern int of_dma_controller_register(struct device_node *np,
 		(struct of_phandle_args *, struct of_dma *),
 		void *data);
 extern void of_dma_controller_free(struct device_node *np);
+
+extern int of_dma_router_register(struct device_node *np,
+		void *(*of_dma_route_allocate)
+		(struct of_phandle_args *, struct of_dma *),
+		struct dma_router *dma_router);
+#define of_dma_router_free of_dma_controller_free
+
 extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     const char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
 extern struct dma_chan *of_dma_xlate_by_chan_id(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
+
 #else
 static inline int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
@@ -56,6 +67,16 @@ static inline void of_dma_controller_free(struct device_node *np)
 {
 }
 
+static inline int of_dma_router_register(struct device_node *np,
+		void *(*of_dma_route_allocate)
+		(struct of_phandle_args *, struct of_dma *),
+		struct dma_router *dma_router)
+{
+	return -ENODEV;
+}
+
+#define of_dma_router_free of_dma_controller_free
+
 static inline struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     const char *name)
 {

commit 16369efb1f6006ec79babe53f388eed431533596
Author: Alexander Popov <a13xp0p0v88@gmail.com>
Date:   Wed Jun 25 14:52:59 2014 +0400

    dmaengine: of: add common xlate function for matching by channel id
    
    This patch adds a new common OF dma xlate callback function which will match a
    channel by it's id. The binding expects one integer argument which it will use to
    lookup the channel by the id.
    
    Unlike of_dma_simple_xlate this function is able to handle a system with
    multiple DMA controllers. When registering the of dma provider with
    of_dma_controller_register a pointer to the dma_device struct which is
    associated with the dt node needs to passed as the data parameter.
    New function will use this pointer to match only channels which belong to the
    specified DMA controller.
    
    Signed-off-by: Alexander Popov <a13xp0p0v88@gmail.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index ae36298ba076..56bc026c143f 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -41,6 +41,8 @@ extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     const char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
+extern struct dma_chan *of_dma_xlate_by_chan_id(struct of_phandle_args *dma_spec,
+		struct of_dma *ofdma);
 #else
 static inline int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
@@ -66,6 +68,8 @@ static inline struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_s
 	return NULL;
 }
 
+#define of_dma_xlate_by_chan_id NULL
+
 #endif
 
 #endif /* __LINUX_OF_DMA_H */

commit 8552bb4f16800d5ebc176a2cf5f2aa55b22731ea
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 22 10:33:33 2013 +0200

    dma: of: Remove check on always true condition
    
    Both of_dma_nbcells field of the of_dma_controller and the args_count field of
    the dma_spec are initialized by parsing the #dma-cells attribute of their device
    tree node. So if the device tree nodes of a DMA controller and the dma_spec
    match this means that of_dma_nbcells and args_count will also match. So the
    second test in the of_dma_find_controller loop is redundant because given the
    first test yields true the second test will also yield true. So we can safely
    remove the test whether of_dma_nbcells matches args_count. Since this was the
    last user of the of_dma_nbcells field we can remove it altogether.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 364dda734877..ae36298ba076 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -21,7 +21,6 @@ struct device_node;
 struct of_dma {
 	struct list_head	of_dma_controllers;
 	struct device_node	*of_node;
-	int			of_dma_nbcells;
 	struct dma_chan		*(*of_dma_xlate)
 				(struct of_phandle_args *, struct of_dma *);
 	void			*of_dma_data;

commit de61608acf89779c8831aaa1428b6975d49d98c0
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Apr 19 11:42:14 2013 +0200

    dma:of: Use a mutex to protect the of_dma_list
    
    Currently the OF DMA code uses a spin lock to protect the of_dma_list from
    concurrent access and a per controller reference count to protect the controller
    from being freed while a request operation is in progress. If
    of_dma_controller_free() is called for a controller who's reference count is not
    zero it will return -EBUSY and not remove the controller. This is fine up until
    here, but leaves the question what the caller of of_dma_controller_free() is
    supposed to do if the controller couldn't be freed.  The only viable solution
    for the caller is to spin on of_dma_controller_free() until it returns success.
    E.g.
    
            do {
                    ret = of_dma_controller_free(dev->of_node)
            } while (ret != -EBUSY);
    
    This is rather ugly and unnecessary and none of the current users of
    of_dma_controller_free() check it's return value anyway. Instead protect the
    list by a mutex. The mutex will be held as long as a request operation is in
    progress. So if of_dma_controller_free() is called while a request operation is
    in progress it will be put to sleep and only wake up once the request operation
    has finished.
    
    This means that it is no longer possible to register or unregister OF DMA
    controllers from a context where it's not possible to sleep. But I doubt that
    we'll ever need this.
    
    Also rename of_dma_get_controller back to of_dma_find_controller.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index ce6a8ab3d2bb..364dda734877 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -25,7 +25,6 @@ struct of_dma {
 	struct dma_chan		*(*of_dma_xlate)
 				(struct of_phandle_args *, struct of_dma *);
 	void			*of_dma_data;
-	int			use_count;
 };
 
 struct of_dma_filter_info {
@@ -38,7 +37,7 @@ extern int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
 		(struct of_phandle_args *, struct of_dma *),
 		void *data);
-extern int of_dma_controller_free(struct device_node *np);
+extern void of_dma_controller_free(struct device_node *np);
 extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     const char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
@@ -52,9 +51,8 @@ static inline int of_dma_controller_register(struct device_node *np,
 	return -ENODEV;
 }
 
-static inline int of_dma_controller_free(struct device_node *np)
+static inline void of_dma_controller_free(struct device_node *np)
 {
-	return -ENODEV;
 }
 
 static inline struct dma_chan *of_dma_request_slave_channel(struct device_node *np,

commit bef29ec508e58bf8b9ec0915de5b0739fb800c91
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Sun Feb 24 16:36:09 2013 +0100

    DMA: of: Constant names
    
    No DMA of-function alters the name, so this patch changes the name arguments
    to be constant. Most drivers will probably request DMA channels using a
    constant name.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index d15073e080dd..ce6a8ab3d2bb 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -40,7 +40,7 @@ extern int of_dma_controller_register(struct device_node *np,
 		void *data);
 extern int of_dma_controller_free(struct device_node *np);
 extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
-						     char *name);
+						     const char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
 #else
@@ -58,7 +58,7 @@ static inline int of_dma_controller_free(struct device_node *np)
 }
 
 static inline struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
-						     char *name)
+						     const char *name)
 {
 	return NULL;
 }

commit 91f8aecc501e456c97a6f49f7ea3797e874d5d89
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Thu Nov 29 12:17:22 2012 +0530

    dmaengine: fix !of_dma compilation warning
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 84b64f857e23..d15073e080dd 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -44,7 +44,7 @@ extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
 #else
-static int of_dma_controller_register(struct device_node *np,
+static inline int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
 		(struct of_phandle_args *, struct of_dma *),
 		void *data)
@@ -52,17 +52,18 @@ static int of_dma_controller_register(struct device_node *np,
 	return -ENODEV;
 }
 
-static int of_dma_controller_free(struct device_node *np)
+static inline int of_dma_controller_free(struct device_node *np)
 {
+	return -ENODEV;
 }
 
-static struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
+static inline struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     char *name)
 {
 	return NULL;
 }
 
-static struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
+static inline struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma)
 {
 	return NULL;

commit 9743a3b62dee8c9d8af1319f8d1c1ff39130267d
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Thu Oct 11 14:43:01 2012 -0500

    of: dma: fix protection of DMA controller data stored by DMA helpers
    
    In the current implementation of the OF DMA helpers, read-copy-update (RCU)
    linked lists are being used for storing and accessing the DMA controller data.
    This part of implementation is based upon V2 of the DMA helpers by Nicolas [1].
    During a recent review of RCU, it became apparent that the code is missing the
    required rcu_read_lock()/unlock() calls as well as synchronisation calls before
    freeing any memory protected by RCU.
    
    Having looked into adding the appropriate RCU calls to protect the DMA data it
    became apparent that with the current DMA helper implementation, using RCU is
    not as attractive as it may have been before. The main reasons being that ...
    
    1. We need to protect the DMA data around calls to the xlate function.
    2. The of_dma_simple_xlate() function calls the DMA engine function
       dma_request_channel() which employs a mutex and so could sleep.
    3. The RCU read-side critical sections must not sleep and so we cannot hold
       an RCU read lock around the xlate function.
    
    Therefore, instead of using RCU, an alternative for this use-case is to employ
    a simple spinlock inconjunction with a usage count variable to keep track of
    how many current users of the DMA data structure there are. With this
    implementation, the DMA data cannot be freed until all current users of the
    DMA data are finished.
    
    This patch is based upon the DMA helpers fix for potential deadlock [2].
    
    [1] http://article.gmane.org/gmane.linux.ports.arm.omap/73622
    [2] http://marc.info/?l=linux-arm-kernel&m=134859982520984&w=2
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 67158ddd1f3e..84b64f857e23 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -25,6 +25,7 @@ struct of_dma {
 	struct dma_chan		*(*of_dma_xlate)
 				(struct of_phandle_args *, struct of_dma *);
 	void			*of_dma_data;
+	int			use_count;
 };
 
 struct of_dma_filter_info {
@@ -37,7 +38,7 @@ extern int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
 		(struct of_phandle_args *, struct of_dma *),
 		void *data);
-extern void of_dma_controller_free(struct device_node *np);
+extern int of_dma_controller_free(struct device_node *np);
 extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
@@ -51,7 +52,7 @@ static int of_dma_controller_register(struct device_node *np,
 	return -ENODEV;
 }
 
-static void of_dma_controller_free(struct device_node *np)
+static int of_dma_controller_free(struct device_node *np)
 {
 }
 

commit 4c26bc601d20fa67eefcb27477feda130c10790e
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Tue Sep 25 09:57:36 2012 +0530

    of: dma- fix build break for !CONFIG_OF
    
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
index 337823dc6b90..67158ddd1f3e 100644
--- a/include/linux/of_dma.h
+++ b/include/linux/of_dma.h
@@ -32,6 +32,7 @@ struct of_dma_filter_info {
 	dma_filter_fn	filter_fn;
 };
 
+#ifdef CONFIG_OF
 extern int of_dma_controller_register(struct device_node *np,
 		struct dma_chan *(*of_dma_xlate)
 		(struct of_phandle_args *, struct of_dma *),
@@ -41,5 +42,31 @@ extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
 						     char *name);
 extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
 		struct of_dma *ofdma);
+#else
+static int of_dma_controller_register(struct device_node *np,
+		struct dma_chan *(*of_dma_xlate)
+		(struct of_phandle_args *, struct of_dma *),
+		void *data)
+{
+	return -ENODEV;
+}
+
+static void of_dma_controller_free(struct device_node *np)
+{
+}
+
+static struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
+						     char *name)
+{
+	return NULL;
+}
+
+static struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
+		struct of_dma *ofdma)
+{
+	return NULL;
+}
+
+#endif
 
 #endif /* __LINUX_OF_DMA_H */

commit aa3da644c76d1c2083d085e453c18f7c51f19bc4
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Sep 14 17:41:56 2012 -0500

    of: Add generic device tree DMA helpers
    
    This is based upon the work by Benoit Cousson [1] and Nicolas Ferre [2]
    to add some basic helpers to retrieve a DMA controller device_node and the
    DMA request/channel information.
    
    Aim of DMA helpers
    - The purpose of device-tree is to describe the capabilites of the hardware.
      Thinking about DMA controllers purely from the context of the hardware to
      begin with, we can describe a device in terms of a DMA controller as
      follows ...
            1. Number of DMA controllers
            2. Number of channels (maybe physical or logical)
            3. Mapping of DMA requests signals to DMA controller
            4. Number of DMA interrupts
            5. Mapping of DMA interrupts to channels
    - With the above in mind the aim of the DT DMA helper functions is to extract
      the above information from the DT and provide to the appropriate driver.
      However, due to the vast number of DMA controllers and not all are using a
      common driver (such as DMA Engine) it has been seen that this is not a
      trivial task. In previous discussions on this topic the following concerns
      have been raised ...
            1. How does the binding support devices with multiple DMA controllers?
            2. How to support both legacy DMA controllers not using DMA Engine as
               well as those that support DMA Engine.
            3. When using with DMA Engine how do we support the various
               implementations where the opaque filter function parameter differs
               between implementations?
            4. How do we handle DMA channels that are identified with a string
               versus a integer?
    - Hence the design of the DMA helpers has to accomodate the above or align on
      an agreement what can be or should be supported.
    
    Design of DMA helpers
    
    1. Registering DMA controllers
    
       In the case of DMA controllers that are using DMA Engine, requesting a
       channel is performed by calling the following function.
    
            struct dma_chan *dma_request_channel(dma_cap_mask_t mask,
                            dma_filter_fn filter_fn,
                            void *filter_param);
    
       The mask variable is used to match a type of the device controller in a list
       of controllers. The filter_fn and filter_param are used to identify the
       required dma channel and return a handle to the dma channel of type dma_chan.
    
       From the examples I have seen, the mask and filter_fn are constant
       for a given DMA controller and therefore, we can specify these as controller
       specific data when registering the DMA controller with the device-tree DMA
       helpers.
    
       The filter_param variable is of an unknown type and is typically specific
       to the DMA engine implementation for a given DMA controller. To allow some
       flexibility in the type and formating of this filter_param we employ an
       xlate to translate the device-tree binding information into the appropriate
       format. The xlate function used for a DMA controller can also be specified
       when registering the DMA controller with the device-tree DMA helpers.
    
       Based upon the above, a function for registering the DMA controller with the
       DMA helpers now looks like the below. The data variable is used to pass a
       pointer to DMA controller specific data used by the xlate function.
    
            int of_dma_controller_register(struct device_node *np,
                    struct dma_chan *(*of_dma_xlate)
                    (struct of_phandle_args *, struct of_dma *),
                    void *data)
    
       For example, in the case where DMA engine is used, we define the following
       structure (that stores the DMA engine capability mask and filter function)
       and pass this to the data variable in the above function.
    
            struct of_dma_filter_info {
                    dma_cap_mask_t  dma_cap;
                    dma_filter_fn   filter_fn;
            };
    
    2. Representing and requesting channel information
    
       Please see the dma binding documentation included in this patch for a
       description of how DMA controllers and client information should be
       represented with device-tree. For more information on how this binding
       came about please see [3]. In addition to this, feedback received from
       the Linux kernel summit showed a consensus (among those who attended) to
       use a name to identify DMA client information [4].
    
       A DMA channel can be requested by calling the following function, where name
       is a required parameter used for identifying a DMA channel. This function
       has been designed to return a structure of type dma_chan to work with the
       DMA engine driver. Note that if DMA engine is used then drivers should be
       using the DMA engine API dma_request_slave_channel() (implemented in part 2
       of this series, "dmaengine: add helper function to request a slave DMA
       channel") which will in turn call the below function if device-tree is
       present. The aim being to have a common DMA engine interface regardless of
       whether device tree is being used.
    
            struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
                                                          char *name)
    
    3. Supporting legacy devices not using DMA Engine
    
       These devices present a problem, as there may not be a uniform way to easily
       support them with regard to device tree. Ideally, these should be migrated
       to DMA engine. However, if this is not possible, then they should still be
       able to use this binding, the only constaint imposed by this implementation
       is that when requesting a DMA channel via of_dma_request_slave_channel(), it
       will return a type of dma_chan.
    
    This implementation has been tested on OMAP4430 using the kernel v3.6-rc5. I
    have validated that MMC is working on the PANDA board with this implementation.
    My development branch for testing on OMAP can be found here [5].
    
    v6: - minor corrections in DMA binding documentation
    v5: - minor update to binding documentation
        - added loop to exhaustively search for a slave channel in the case where
          there could be alternative channels available
    v4: - revert the removal of xlate function from v3
        - update the proposed binding format and APIs based upon discussions [3]
    v3: - avoid passing an xlate function and instead pass DMA engine parameters
        - define number of dma channels and requests in dma-controller node
    v2: - remove of_dma_to_resource API
        - make property #dma-cells required (no fallback anymore)
        - another check in of_dma_xlate_onenumbercell() function
    
    [1] http://article.gmane.org/gmane.linux.drivers.devicetree/12022
    [2] http://article.gmane.org/gmane.linux.ports.arm.omap/73622
    [3] http://marc.info/?l=linux-omap&m=133582085008539&w=2
    [4] http://pad.linaro.org/arm-mini-summit-2012
    [5] https://github.com/jonhunter/linux/tree/dev-dt-dma
    
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Stephen Warren <swarren@nvidia.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Dan Williams <djbw@fb.com>
    
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Reviewed-by: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/include/linux/of_dma.h b/include/linux/of_dma.h
new file mode 100644
index 000000000000..337823dc6b90
--- /dev/null
+++ b/include/linux/of_dma.h
@@ -0,0 +1,45 @@
+/*
+ * OF helpers for DMA request / controller
+ *
+ * Based on of_gpio.h
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_OF_DMA_H
+#define __LINUX_OF_DMA_H
+
+#include <linux/of.h>
+#include <linux/dmaengine.h>
+
+struct device_node;
+
+struct of_dma {
+	struct list_head	of_dma_controllers;
+	struct device_node	*of_node;
+	int			of_dma_nbcells;
+	struct dma_chan		*(*of_dma_xlate)
+				(struct of_phandle_args *, struct of_dma *);
+	void			*of_dma_data;
+};
+
+struct of_dma_filter_info {
+	dma_cap_mask_t	dma_cap;
+	dma_filter_fn	filter_fn;
+};
+
+extern int of_dma_controller_register(struct device_node *np,
+		struct dma_chan *(*of_dma_xlate)
+		(struct of_phandle_args *, struct of_dma *),
+		void *data);
+extern void of_dma_controller_free(struct device_node *np);
+extern struct dma_chan *of_dma_request_slave_channel(struct device_node *np,
+						     char *name);
+extern struct dma_chan *of_dma_simple_xlate(struct of_phandle_args *dma_spec,
+		struct of_dma *ofdma);
+
+#endif /* __LINUX_OF_DMA_H */
