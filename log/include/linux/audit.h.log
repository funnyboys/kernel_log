commit 0090c1edebf464f34629e14ae03d764cca7e0a3b
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:50:41 2020 -0500

    audit: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1a2351508211..3fcd9ee49734 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -19,7 +19,7 @@
 struct audit_sig_info {
 	uid_t		uid;
 	pid_t		pid;
-	char		ctx[0];
+	char		ctx[];
 };
 
 struct audit_buffer;

commit a45d88530b2552ad5ea0da18861600b4ecc9d0c7
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Apr 22 17:39:29 2020 -0400

    netfilter: add audit table unregister actions
    
    Audit the action of unregistering ebtables and x_tables.
    
    See: https://github.com/linux-audit/audit-kernel/issues/44
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5c7f07a9776d..1a2351508211 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -97,6 +97,7 @@ struct audit_ntp_data {};
 enum audit_nfcfgop {
 	AUDIT_XT_OP_REGISTER,
 	AUDIT_XT_OP_REPLACE,
+	AUDIT_XT_OP_UNREGISTER,
 };
 
 extern int is_audit_feature_set(int which);

commit c4dad0aab3fca0c1f0baa4cc84b6ec91b7ebf426
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Apr 22 17:39:28 2020 -0400

    audit: tidy and extend netfilter_cfg x_tables
    
    NETFILTER_CFG record generation was inconsistent for x_tables and
    ebtables configuration changes.  The call was needlessly messy and there
    were supporting records missing at times while they were produced when
    not requested.  Simplify the logging call into a new audit_log_nfcfg
    call.  Honour the audit_enabled setting while more consistently
    recording information including supporting records by tidying up dummy
    checks.
    
    Add an op= field that indicates the operation being performed (register
    or replace).
    
    Here is the enhanced sample record:
      type=NETFILTER_CFG msg=audit(1580905834.919:82970): table=filter family=2 entries=83 op=replace
    
    Generate audit NETFILTER_CFG records on ebtables table registration.
    Previously this was being done for x_tables registration and replacement
    operations and ebtables table replacement only.
    
    See: https://github.com/linux-audit/audit-kernel/issues/25
    See: https://github.com/linux-audit/audit-kernel/issues/35
    See: https://github.com/linux-audit/audit-kernel/issues/43
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f9ceae57ca8d..5c7f07a9776d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -94,6 +94,11 @@ struct audit_ntp_data {
 struct audit_ntp_data {};
 #endif
 
+enum audit_nfcfgop {
+	AUDIT_XT_OP_REGISTER,
+	AUDIT_XT_OP_REPLACE,
+};
+
 extern int is_audit_feature_set(int which);
 
 extern int __init audit_register_class(int class, unsigned *list);
@@ -379,6 +384,8 @@ extern void __audit_log_kern_module(char *name);
 extern void __audit_fanotify(unsigned int response);
 extern void __audit_tk_injoffset(struct timespec64 offset);
 extern void __audit_ntp_log(const struct audit_ntp_data *ad);
+extern void __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,
+			      enum audit_nfcfgop op);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -514,6 +521,14 @@ static inline void audit_ntp_log(const struct audit_ntp_data *ad)
 		__audit_ntp_log(ad);
 }
 
+static inline void audit_log_nfcfg(const char *name, u8 af,
+				   unsigned int nentries,
+				   enum audit_nfcfgop op)
+{
+	if (audit_enabled)
+		__audit_log_nfcfg(name, af, nentries, op);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
@@ -646,6 +661,12 @@ static inline void audit_ntp_log(const struct audit_ntp_data *ad)
 
 static inline void audit_ptrace(struct task_struct *t)
 { }
+
+static inline void audit_log_nfcfg(const char *name, u8 af,
+				   unsigned int nentries,
+				   enum audit_nfcfgop op)
+{ }
+
 #define audit_n_rules 0
 #define audit_signals 0
 #endif /* CONFIG_AUDITSYSCALL */

commit 245d73698ed7abdc7e520dfa38048bb80ce89571
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 2 16:41:58 2019 -0700

    audit: Report suspicious O_CREAT usage
    
    This renames the very specific audit_log_link_denied() to
    audit_log_path_denied() and adds the AUDIT_* type as an argument. This
    allows for the creation of the new AUDIT_ANOM_CREAT that can be used to
    report the fifo/regular file creation restrictions that were introduced
    in commit 30aba6656f61 ("namei: allow restricted O_CREAT of FIFOs and
    regular files").
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index aee3dc9eb378..f9ceae57ca8d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -156,7 +156,8 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const struct path *path);
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
-extern void		    audit_log_link_denied(const char *operation);
+extern void		    audit_log_path_denied(int type,
+						  const char *operation);
 extern void		    audit_log_lost(const char *message);
 
 extern int audit_log_task_context(struct audit_buffer *ab);
@@ -217,7 +218,7 @@ static inline void audit_log_d_path(struct audit_buffer *ab,
 { }
 static inline void audit_log_key(struct audit_buffer *ab, char *key)
 { }
-static inline void audit_log_link_denied(const char *string)
+static inline void audit_log_path_denied(int type, const char *operation)
 { }
 static inline int audit_log_task_context(struct audit_buffer *ab)
 {

commit fbb7d9d56d167247f2eb7261038385cab1073c37
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 14 13:24:54 2019 -0400

    kill LOOKUP_NO_EVAL, don't bother including namei.h from audit.h
    
    The former has no users left; the latter was only to get LOOKUP_...
    values to remapper in audit_inode() and that's an ex-parrot now.
    
    All places that use symbols from namei.h include it either directly
    or (in a few cases) via a local header, like fs/autofs/autofs_i.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 543763ab0354..aee3dc9eb378 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -11,7 +11,6 @@
 
 #include <linux/sched.h>
 #include <linux/ptrace.h>
-#include <linux/namei.h>  /* LOOKUP_* */
 #include <uapi/linux/audit.h>
 
 #define AUDIT_INO_UNSET ((unsigned long)-1)

commit c9b07eab0c8760bdd4cf8624c482ee145a322a3b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 14 13:22:27 2019 -0400

    audit_inode(): switch to passing AUDIT_INODE_...
    
    don't bother with remapping LOOKUP_... values - all callers pass
    constants and we can just as well pass the right ones from the
    very beginning.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 97d0925454df..543763ab0354 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -252,6 +252,10 @@ static inline int audit_signal_info(int sig, struct task_struct *t)
 #define audit_is_compat(arch)  false
 #endif
 
+#define AUDIT_INODE_PARENT	1	/* dentry represents the parent */
+#define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
+#define AUDIT_INODE_NOEVAL	4	/* audit record incomplete */
+
 #ifdef CONFIG_AUDITSYSCALL
 #include <asm/syscall.h> /* for syscall_get_arch() */
 
@@ -265,9 +269,6 @@ extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern struct filename *__audit_reusename(const __user char *uptr);
 extern void __audit_getname(struct filename *name);
 
-#define AUDIT_INODE_PARENT	1	/* dentry represents the parent */
-#define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
-#define AUDIT_INODE_NOEVAL	4	/* audit record incomplete */
 extern void __audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int flags);
 extern void __audit_file(const struct file *);
@@ -328,16 +329,9 @@ static inline void audit_getname(struct filename *name)
 }
 static inline void audit_inode(struct filename *name,
 				const struct dentry *dentry,
-				unsigned int flags) {
-	if (unlikely(!audit_dummy_context())) {
-		unsigned int aflags = 0;
-
-		if (flags & LOOKUP_PARENT)
-			aflags |= AUDIT_INODE_PARENT;
-		if (flags & LOOKUP_NO_EVAL)
-			aflags |= AUDIT_INODE_NOEVAL;
+				unsigned int aflags) {
+	if (unlikely(!audit_dummy_context()))
 		__audit_inode(name, dentry, aflags);
-	}
 }
 static inline void audit_file(struct file *file)
 {
@@ -561,7 +555,7 @@ static inline void __audit_inode_child(struct inode *parent,
 { }
 static inline void audit_inode(struct filename *name,
 				const struct dentry *dentry,
-				unsigned int parent)
+				unsigned int aflags)
 { }
 static inline void audit_file(struct file *file)
 {

commit 61fc5771f5e729a2ce235af42f69c8506725e84a
Merge: 884922591e2b 839d05e41385
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 18:55:42 2019 -0700

    Merge tag 'audit-pr-20190702' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "This pull request is a bit early, but with some vacation time coming
      up I wanted to send this out now just in case the remote Internet Gods
      decide not to smile on me once the merge window opens. The patchset
      for v5.3 is pretty minor this time, the highlights include:
    
       - When the audit daemon is sent a signal, ensure we deliver
         information about the sender even when syscall auditing is not
         enabled/supported.
    
       - Add the ability to filter audit records based on network address
         family.
    
       - Tighten the audit field filtering restrictions on string based
         fields.
    
       - Cleanup the audit field filtering verification code.
    
       - Remove a few BUG() calls from the audit code"
    
    * tag 'audit-pr-20190702' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit:
      audit: remove the BUG() calls in the audit rule comparison functions
      audit: enforce op for string fields
      audit: add saddr_fam filter field
      audit: re-structure audit field valid checks
      audit: deliver signal_info regarless of syscall

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 43a23e28ba23..3a4f2415bb7c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -1,24 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* audit.h -- Auditing support
  *
  * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
  * All Rights Reserved.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  * Written by Rickard E. (Rik) Faith <faith@redhat.com>
- *
  */
 #ifndef _LINUX_AUDIT_H_
 #define _LINUX_AUDIT_H_

commit b48345aafb203803ccda4488cb5409b1ed435c0a
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Fri May 10 12:21:49 2019 -0400

    audit: deliver signal_info regarless of syscall
    
    When a process signals the audit daemon (shutdown, rotate, resume,
    reconfig) but syscall auditing is not enabled, we still want to know the
    identity of the process sending the signal to the audit daemon.
    
    Move audit_signal_info() out of syscall auditing to general auditing but
    create a new function audit_signal_info_syscall() to take care of the
    syscall dependent parts for when syscall auditing is enabled.
    
    Please see the github kernel audit issue
    https://github.com/linux-audit/audit-kernel/issues/111
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 43a23e28ba23..b4078560cb73 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -196,6 +196,9 @@ static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
 }
 
 extern u32 audit_enabled;
+
+extern int audit_signal_info(int sig, struct task_struct *t);
+
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)
 void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
@@ -249,6 +252,12 @@ static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
 }
 
 #define audit_enabled AUDIT_OFF
+
+static inline int audit_signal_info(int sig, struct task_struct *t)
+{
+	return 0;
+}
+
 #endif /* CONFIG_AUDIT */
 
 #ifdef CONFIG_AUDIT_COMPAT_GENERIC

commit 7e8eda734d30de81d06a949c9bf9853c445ede4e
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:20 2019 +0200

    ntp: Audit NTP parameters adjustment
    
    Emit an audit record every time selected NTP parameters are modified
    from userspace (via adjtimex(2) or clock_adjtime(2)). These parameters
    may be used to indirectly change system clock, and thus their
    modifications should be audited.
    
    Such events will now generate records of type AUDIT_TIME_ADJNTPVAL
    containing the following fields:
      - op -- which value was adjusted:
        - offset -- corresponding to the time_offset variable
        - freq   -- corresponding to the time_freq variable
        - status -- corresponding to the time_status variable
        - adjust -- corresponding to the time_adjust variable
        - tick   -- corresponding to the tick_usec variable
        - tai    -- corresponding to the timekeeping's TAI offset
      - old -- the old value
      - new -- the new value
    
    Example records:
    
    type=TIME_ADJNTPVAL msg=audit(1530616044.507:7): op=status old=64 new=8256
    type=TIME_ADJNTPVAL msg=audit(1530616044.511:11): op=freq old=0 new=49180377088000
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    An overview of parameter changes that can be done via do_adjtimex()
    (based on information from Miroslav Lichvar) and whether they are
    audited:
      __timekeeping_set_tai_offset() -- sets the offset from the
                                        International Atomic Time
                                        (AUDITED)
      NTP variables:
        time_offset -- can adjust the clock by up to 0.5 seconds per call
                       and also speed it up or slow down by up to about
                       0.05% (43 seconds per day) (AUDITED)
        time_freq -- can speed up or slow down by up to about 0.05%
                     (AUDITED)
        time_status -- can insert/delete leap seconds and it also enables/
                       disables synchronization of the hardware real-time
                       clock (AUDITED)
        time_maxerror, time_esterror -- change error estimates used to
                                        inform userspace applications
                                        (NOT AUDITED)
        time_constant -- controls the speed of the clock adjustments that
                         are made when time_offset is set (NOT AUDITED)
        time_adjust -- can temporarily speed up or slow down the clock by up
                       to 0.05% (AUDITED)
        tick_usec -- a more extreme version of time_freq; can speed up or
                     slow down the clock by up to 10% (AUDITED)
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2c62c0468888..43a23e28ba23 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -86,6 +86,29 @@ struct audit_field {
 	u32				op;
 };
 
+enum audit_ntp_type {
+	AUDIT_NTP_OFFSET,
+	AUDIT_NTP_FREQ,
+	AUDIT_NTP_STATUS,
+	AUDIT_NTP_TAI,
+	AUDIT_NTP_TICK,
+	AUDIT_NTP_ADJUST,
+
+	AUDIT_NTP_NVALS /* count */
+};
+
+#ifdef CONFIG_AUDITSYSCALL
+struct audit_ntp_val {
+	long long oldval, newval;
+};
+
+struct audit_ntp_data {
+	struct audit_ntp_val vals[AUDIT_NTP_NVALS];
+};
+#else
+struct audit_ntp_data {};
+#endif
+
 extern int is_audit_feature_set(int which);
 
 extern int __init audit_register_class(int class, unsigned *list);
@@ -366,6 +389,7 @@ extern void __audit_mmap_fd(int fd, int flags);
 extern void __audit_log_kern_module(char *name);
 extern void __audit_fanotify(unsigned int response);
 extern void __audit_tk_injoffset(struct timespec64 offset);
+extern void __audit_ntp_log(const struct audit_ntp_data *ad);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -478,6 +502,29 @@ static inline void audit_tk_injoffset(struct timespec64 offset)
 		__audit_tk_injoffset(offset);
 }
 
+static inline void audit_ntp_init(struct audit_ntp_data *ad)
+{
+	memset(ad, 0, sizeof(*ad));
+}
+
+static inline void audit_ntp_set_old(struct audit_ntp_data *ad,
+				     enum audit_ntp_type type, long long val)
+{
+	ad->vals[type].oldval = val;
+}
+
+static inline void audit_ntp_set_new(struct audit_ntp_data *ad,
+				     enum audit_ntp_type type, long long val)
+{
+	ad->vals[type].newval = val;
+}
+
+static inline void audit_ntp_log(const struct audit_ntp_data *ad)
+{
+	if (!audit_dummy_context())
+		__audit_ntp_log(ad);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
@@ -594,6 +641,20 @@ static inline void audit_fanotify(unsigned int response)
 static inline void audit_tk_injoffset(struct timespec64 offset)
 { }
 
+static inline void audit_ntp_init(struct audit_ntp_data *ad)
+{ }
+
+static inline void audit_ntp_set_old(struct audit_ntp_data *ad,
+				     enum audit_ntp_type type, long long val)
+{ }
+
+static inline void audit_ntp_set_new(struct audit_ntp_data *ad,
+				     enum audit_ntp_type type, long long val)
+{ }
+
+static inline void audit_ntp_log(const struct audit_ntp_data *ad)
+{ }
+
 static inline void audit_ptrace(struct task_struct *t)
 { }
 #define audit_n_rules 0

commit 2d87a0674bd60d855e4008e2d84f5b23d7cb9b7d
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 10 11:14:19 2019 +0200

    timekeeping: Audit clock adjustments
    
    Emit an audit record whenever the system clock is changed (i.e. shifted
    by a non-zero offset) by a syscall from userspace. The syscalls than can
    (at the time of writing) trigger such record are:
      - settimeofday(2), stime(2), clock_settime(2) -- via
        do_settimeofday64()
      - adjtimex(2), clock_adjtime(2) -- via do_adjtimex()
    
    The new records have type AUDIT_TIME_INJOFFSET and contain the following
    fields:
      - sec -- the 'seconds' part of the offset
      - nsec -- the 'nanoseconds' part of the offset
    
    Example record (time was shifted backwards by ~15.875 seconds):
    
    type=TIME_INJOFFSET msg=audit(1530616049.652:13): sec=-16 nsec=124887145
    
    The records of this type will be associated with the corresponding
    syscall records.
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    [PM: fixed a line width problem in __audit_tk_injoffset()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1e69d9fe16da..2c62c0468888 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -365,6 +365,7 @@ extern void __audit_log_capset(const struct cred *new, const struct cred *old);
 extern void __audit_mmap_fd(int fd, int flags);
 extern void __audit_log_kern_module(char *name);
 extern void __audit_fanotify(unsigned int response);
+extern void __audit_tk_injoffset(struct timespec64 offset);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -467,6 +468,16 @@ static inline void audit_fanotify(unsigned int response)
 		__audit_fanotify(response);
 }
 
+static inline void audit_tk_injoffset(struct timespec64 offset)
+{
+	/* ignore no-op events */
+	if (offset.tv_sec == 0 && offset.tv_nsec == 0)
+		return;
+
+	if (!audit_dummy_context())
+		__audit_tk_injoffset(offset);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
@@ -580,6 +591,9 @@ static inline void audit_log_kern_module(char *name)
 static inline void audit_fanotify(unsigned int response)
 { }
 
+static inline void audit_tk_injoffset(struct timespec64 offset)
+{ }
+
 static inline void audit_ptrace(struct task_struct *t)
 { }
 #define audit_n_rules 0

commit cd108b5c51db30aa01657322bb89e48c98216ff9
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Feb 5 16:06:30 2019 -0500

    audit: hide auditsc_get_stamp and audit_serial prototypes
    
    auditsc_get_stamp() and audit_serial() are internal audit functions so
    move their prototypes from include/linux/audit.h to kernel/audit.h
    so they are not visible to the rest of the kernel.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 29251b18331a..1e69d9fe16da 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -348,10 +348,6 @@ static inline void audit_ptrace(struct task_struct *t)
 }
 
 				/* Private API (for audit.c only) */
-extern unsigned int audit_serial(void);
-extern int auditsc_get_stamp(struct audit_context *ctx,
-			      struct timespec64 *t, unsigned int *serial);
-
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
 extern void __audit_bprm(struct linux_binprm *bprm);
@@ -531,11 +527,6 @@ static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 static inline void audit_seccomp_actions_logged(const char *names,
 						const char *old_names, int res)
 { }
-static inline int auditsc_get_stamp(struct audit_context *ctx,
-			      struct timespec64 *t, unsigned int *serial)
-{
-	return 0;
-}
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 { }
 static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,

commit 57d4657716aca81ef4d7ec23e8123d26e3d28954
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Jan 23 13:35:00 2019 -0500

    audit: ignore fcaps on umount
    
    Don't fetch fcaps when umount2 is called to avoid a process hang while
    it waits for the missing resource to (possibly never) re-appear.
    
    Note the comment above user_path_mountpoint_at():
     * A umount is a special case for path walking. We're not actually interested
     * in the inode in this situation, and ESTALE errors can be a problem.  We
     * simply want track down the dentry and vfsmount attached at the mountpoint
     * and avoid revalidating the last component.
    
    This can happen on ceph, cifs, 9p, lustre, fuse (gluster) or NFS.
    
    Please see the github issue tracker
    https://github.com/linux-audit/audit-kernel/issues/100
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in audit_log_fcaps()]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index ecb5d317d6a2..29251b18331a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -25,6 +25,7 @@
 
 #include <linux/sched.h>
 #include <linux/ptrace.h>
+#include <linux/namei.h>  /* LOOKUP_* */
 #include <uapi/linux/audit.h>
 
 #define AUDIT_INO_UNSET ((unsigned long)-1)
@@ -248,6 +249,7 @@ extern void __audit_getname(struct filename *name);
 
 #define AUDIT_INODE_PARENT	1	/* dentry represents the parent */
 #define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
+#define AUDIT_INODE_NOEVAL	4	/* audit record incomplete */
 extern void __audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int flags);
 extern void __audit_file(const struct file *);
@@ -308,12 +310,15 @@ static inline void audit_getname(struct filename *name)
 }
 static inline void audit_inode(struct filename *name,
 				const struct dentry *dentry,
-				unsigned int parent) {
+				unsigned int flags) {
 	if (unlikely(!audit_dummy_context())) {
-		unsigned int flags = 0;
-		if (parent)
-			flags |= AUDIT_INODE_PARENT;
-		__audit_inode(name, dentry, flags);
+		unsigned int aflags = 0;
+
+		if (flags & LOOKUP_PARENT)
+			aflags |= AUDIT_INODE_PARENT;
+		if (flags & LOOKUP_NO_EVAL)
+			aflags |= AUDIT_INODE_NOEVAL;
+		__audit_inode(name, dentry, aflags);
 	}
 }
 static inline void audit_file(struct file *file)

commit 4b7d248b3a1de483ffe9d05c1debbf32a544164d
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Jan 22 17:06:39 2019 -0500

    audit: move loginuid and sessionid from CONFIG_AUDITSYSCALL to CONFIG_AUDIT
    
    loginuid and sessionid (and audit_log_session_info) should be part of
    CONFIG_AUDIT scope and not CONFIG_AUDITSYSCALL since it is used in
    CONFIG_CHANGE, ANOM_LINK, FEATURE_CHANGE (and INTEGRITY_RULE), none of
    which are otherwise dependent on AUDITSYSCALL.
    
    Please see github issue
    https://github.com/linux-audit/audit-kernel/issues/104
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: tweaked subject line for better grep'ing]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index a625c29a2ea2..ecb5d317d6a2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -159,6 +159,18 @@ extern int		    audit_update_lsm_rules(void);
 extern int audit_rule_change(int type, int seq, void *data, size_t datasz);
 extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);
 
+extern int audit_set_loginuid(kuid_t loginuid);
+
+static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
+{
+	return tsk->loginuid;
+}
+
+static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
+{
+	return tsk->sessionid;
+}
+
 extern u32 audit_enabled;
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)
@@ -201,6 +213,17 @@ static inline int audit_log_task_context(struct audit_buffer *ab)
 }
 static inline void audit_log_task_info(struct audit_buffer *ab)
 { }
+
+static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
+{
+	return INVALID_UID;
+}
+
+static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
+{
+	return AUDIT_SID_UNSET;
+}
+
 #define audit_enabled AUDIT_OFF
 #endif /* CONFIG_AUDIT */
 
@@ -323,17 +346,6 @@ static inline void audit_ptrace(struct task_struct *t)
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec64 *t, unsigned int *serial);
-extern int audit_set_loginuid(kuid_t loginuid);
-
-static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
-{
-	return tsk->loginuid;
-}
-
-static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
-{
-	return tsk->sessionid;
-}
 
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
@@ -519,14 +531,6 @@ static inline int auditsc_get_stamp(struct audit_context *ctx,
 {
 	return 0;
 }
-static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
-{
-	return INVALID_UID;
-}
-static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
-{
-	return AUDIT_SID_UNSET;
-}
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 { }
 static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,

commit 2a1fe215e7300c7ebd6a7a24afcab71db5107bb0
Author: Paul Moore <paul@paul-moore.com>
Date:   Mon Nov 26 18:40:07 2018 -0500

    audit: use current whenever possible
    
    There are many places, notably audit_log_task_info() and
    audit_log_exit(), that take task_struct pointers but in reality they
    are always working on the current task.  This patch eliminates the
    task_struct arguments and uses current directly which allows a number
    of cleanups as well.
    
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 58cf665f597e..a625c29a2ea2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -151,8 +151,7 @@ extern void		    audit_log_link_denied(const char *operation);
 extern void		    audit_log_lost(const char *message);
 
 extern int audit_log_task_context(struct audit_buffer *ab);
-extern void audit_log_task_info(struct audit_buffer *ab,
-				struct task_struct *tsk);
+extern void audit_log_task_info(struct audit_buffer *ab);
 
 extern int		    audit_update_lsm_rules(void);
 
@@ -200,8 +199,7 @@ static inline int audit_log_task_context(struct audit_buffer *ab)
 {
 	return 0;
 }
-static inline void audit_log_task_info(struct audit_buffer *ab,
-				       struct task_struct *tsk)
+static inline void audit_log_task_info(struct audit_buffer *ab)
 { }
 #define audit_enabled AUDIT_OFF
 #endif /* CONFIG_AUDIT */

commit 0fe3c7fceb500de2d0adfb9dcf292580cd43ea38
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Fri Nov 16 12:16:35 2018 -0500

    audit: localize audit_log_session_info prototype
    
    The audit_log_session_info() function is only used in kernel/audit*, so
    move its prototype to kernel/audit.h
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9334fbef7bae..58cf665f597e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -115,8 +115,6 @@ extern int audit_classify_compat_syscall(int abi, unsigned syscall);
 
 struct filename;
 
-extern void audit_log_session_info(struct audit_buffer *ab);
-
 #define AUDIT_OFF	0
 #define AUDIT_ON	1
 #define AUDIT_LOCKED	2

commit f7859590d97614815b35a755c8213dfb8f2766bd
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Jun 5 19:20:39 2018 -0400

    audit: eliminate audit_enabled magic number comparison
    
    Remove comparison of audit_enabled to magic numbers outside of audit.
    
    Related: https://github.com/linux-audit/audit-kernel/issues/86
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 69c78477590b..9334fbef7bae 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -117,6 +117,9 @@ struct filename;
 
 extern void audit_log_session_info(struct audit_buffer *ab);
 
+#define AUDIT_OFF	0
+#define AUDIT_ON	1
+#define AUDIT_LOCKED	2
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
@@ -202,7 +205,7 @@ static inline int audit_log_task_context(struct audit_buffer *ab)
 static inline void audit_log_task_info(struct audit_buffer *ab,
 				       struct task_struct *tsk)
 { }
-#define audit_enabled 0
+#define audit_enabled AUDIT_OFF
 #endif /* CONFIG_AUDIT */
 
 #ifdef CONFIG_AUDIT_COMPAT_GENERIC

commit c0b0ae8a871bc2ebbe1ff9c9871efcf88994ffec
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat May 12 21:58:21 2018 -0400

    audit: use inline function to set audit context
    
    Recognizing that the audit context is an internal audit value, use an
    access function to set the audit context pointer for the task
    rather than reaching directly into the task struct to set it.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in audit.h]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 831a4684df40..69c78477590b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -237,6 +237,11 @@ extern void audit_seccomp_actions_logged(const char *names,
 					 const char *old_names, int res);
 extern void __audit_ptrace(struct task_struct *t);
 
+static inline void audit_set_context(struct task_struct *task, struct audit_context *ctx)
+{
+	task->audit_context = ctx;
+}
+
 static inline struct audit_context *audit_context(void)
 {
 	return current->audit_context;
@@ -469,6 +474,8 @@ static inline bool audit_dummy_context(void)
 {
 	return true;
 }
+static inline void audit_set_context(struct task_struct *task, struct audit_context *ctx)
+{ }
 static inline struct audit_context *audit_context(void)
 {
 	return NULL;

commit cdfb6b341f0f2409aba24b84f3b4b2bba50be5c5
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat May 12 21:58:20 2018 -0400

    audit: use inline function to get audit context
    
    Recognizing that the audit context is an internal audit value, use an
    access function to retrieve the audit context pointer for the task
    rather than reaching directly into the task struct to get it.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: merge fuzz in auditsc.c and selinuxfs.c, checkpatch.pl fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2d15bce7aa3c..831a4684df40 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -237,9 +237,14 @@ extern void audit_seccomp_actions_logged(const char *names,
 					 const char *old_names, int res);
 extern void __audit_ptrace(struct task_struct *t);
 
+static inline struct audit_context *audit_context(void)
+{
+	return current->audit_context;
+}
+
 static inline bool audit_dummy_context(void)
 {
-	void *p = current->audit_context;
+	void *p = audit_context();
 	return !p || *(int *)p;
 }
 static inline void audit_free(struct task_struct *task)
@@ -251,12 +256,12 @@ static inline void audit_syscall_entry(int major, unsigned long a0,
 				       unsigned long a1, unsigned long a2,
 				       unsigned long a3)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(audit_context()))
 		__audit_syscall_entry(major, a0, a1, a2, a3);
 }
 static inline void audit_syscall_exit(void *pt_regs)
 {
-	if (unlikely(current->audit_context)) {
+	if (unlikely(audit_context())) {
 		int success = is_syscall_success(pt_regs);
 		long return_code = regs_return_value(pt_regs);
 
@@ -464,6 +469,10 @@ static inline bool audit_dummy_context(void)
 {
 	return true;
 }
+static inline struct audit_context *audit_context(void)
+{
+	return NULL;
+}
 static inline struct filename *audit_reusename(const __user char *name)
 {
 	return NULL;

commit f0b752168d7091f38e7d61a80de2542e8b71d266
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat May 12 21:58:19 2018 -0400

    audit: convert sessionid unset to a macro
    
    Use a macro, "AUDIT_SID_UNSET", to replace each instance of
    initialization and comparison to an audit session ID.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b639cf1f55ff..2d15bce7aa3c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -510,7 +510,7 @@ static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
 }
 static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
 {
-	return -1;
+	return AUDIT_SID_UNSET;
 }
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 { }

commit 326bee0286d7f6b0d780f5b75a35ea9fe489a802
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri May 4 01:08:15 2018 +0000

    seccomp: Don't special case audited processes when logging
    
    Seccomp logging for "handled" actions such as RET_TRAP, RET_TRACE, or
    RET_ERRNO can be very noisy for processes that are being audited. This
    patch modifies the seccomp logging behavior to treat processes that are
    being inspected via the audit subsystem the same as processes that
    aren't under inspection. Handled actions will no longer be logged just
    because the process is being inspected. Since v4.14, applications have
    the ability to request logging of handled actions by using the
    SECCOMP_FILTER_FLAG_LOG flag when loading seccomp filters.
    
    With this patch, the logic for deciding if an action will be logged is:
    
      if action == RET_ALLOW:
        do not log
      else if action not in actions_logged:
        do not log
      else if action == RET_KILL:
        log
      else if action == RET_LOG:
        log
      else if filter-requests-logging:
        log
      else:
        do not log
    
    Reported-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d4e35e7a80c0..b639cf1f55ff 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -232,7 +232,7 @@ extern void __audit_file(const struct file *);
 extern void __audit_inode_child(struct inode *parent,
 				const struct dentry *dentry,
 				const unsigned char type);
-extern void __audit_seccomp(unsigned long syscall, long signr, int code);
+extern void audit_seccomp(unsigned long syscall, long signr, int code);
 extern void audit_seccomp_actions_logged(const char *names,
 					 const char *old_names, int res);
 extern void __audit_ptrace(struct task_struct *t);
@@ -304,12 +304,6 @@ static inline void audit_inode_child(struct inode *parent,
 }
 void audit_core_dumps(long signr);
 
-static inline void audit_seccomp(unsigned long syscall, long signr, int code)
-{
-	if (audit_enabled && unlikely(!audit_dummy_context()))
-		__audit_seccomp(syscall, signr, code);
-}
-
 static inline void audit_ptrace(struct task_struct *t)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -500,8 +494,6 @@ static inline void audit_inode_child(struct inode *parent,
 { }
 static inline void audit_core_dumps(long signr)
 { }
-static inline void __audit_seccomp(unsigned long syscall, long signr, int code)
-{ }
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 { }
 static inline void audit_seccomp_actions_logged(const char *names,

commit ea6eca778500b0aaf6e5f10dac4d2cd745c2a50b
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri May 4 01:08:14 2018 +0000

    seccomp: Audit attempts to modify the actions_logged sysctl
    
    The decision to log a seccomp action will always be subject to the
    value of the kernel.seccomp.actions_logged sysctl, even for processes
    that are being inspected via the audit subsystem, in an upcoming patch.
    Therefore, we need to emit an audit record on attempts at writing to the
    actions_logged sysctl when auditing is enabled.
    
    This patch updates the write handler for the actions_logged sysctl to
    emit an audit record on attempts to write to the sysctl. Successful
    writes to the sysctl will result in a record that includes a normalized
    list of logged actions in the "actions" field and a "res" field equal to
    1. Unsuccessful writes to the sysctl will result in a record that
    doesn't include the "actions" field and has a "res" field equal to 0.
    
    Not all unsuccessful writes to the sysctl are audited. For example, an
    audit record will not be emitted if an unprivileged process attempts to
    open the sysctl file for reading since that access control check is not
    part of the sysctl's write handler.
    
    Below are some example audit records when writing various strings to the
    actions_logged sysctl.
    
    Writing "not-a-real-action", when the kernel.seccomp.actions_logged
    sysctl previously was "kill_process kill_thread trap errno trace log",
    emits this audit record:
    
     type=CONFIG_CHANGE msg=audit(1525392371.454:120): op=seccomp-logging
     actions=? old-actions=kill_process,kill_thread,trap,errno,trace,log
     res=0
    
    If you then write "kill_process kill_thread errno trace log", this audit
    record is emitted:
    
     type=CONFIG_CHANGE msg=audit(1525392401.645:126): op=seccomp-logging
     actions=kill_process,kill_thread,errno,trace,log
     old-actions=kill_process,kill_thread,trap,errno,trace,log res=1
    
    If you then write "log log errno trace kill_process kill_thread", which
    is unordered and contains the log action twice, it results in the same
    actions value as the previous record:
    
     type=CONFIG_CHANGE msg=audit(1525392436.354:132): op=seccomp-logging
     actions=kill_process,kill_thread,errno,trace,log
     old-actions=kill_process,kill_thread,errno,trace,log res=1
    
    If you then write an empty string to the sysctl, this audit record is
    emitted:
    
     type=CONFIG_CHANGE msg=audit(1525392494.413:138): op=seccomp-logging
     actions=(none) old-actions=kill_process,kill_thread,errno,trace,log
     res=1
    
    No audit records are generated when reading the actions_logged sysctl.
    
    Suggested-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 75d5b031e802..d4e35e7a80c0 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -233,6 +233,8 @@ extern void __audit_inode_child(struct inode *parent,
 				const struct dentry *dentry,
 				const unsigned char type);
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
+extern void audit_seccomp_actions_logged(const char *names,
+					 const char *old_names, int res);
 extern void __audit_ptrace(struct task_struct *t);
 
 static inline bool audit_dummy_context(void)
@@ -502,6 +504,9 @@ static inline void __audit_seccomp(unsigned long syscall, long signr, int code)
 { }
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 { }
+static inline void audit_seccomp_actions_logged(const char *names,
+						const char *old_names, int res)
+{ }
 static inline int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec64 *t, unsigned int *serial)
 {

commit 94b9d9b7a14cbb1640868d53b27f403ed2e5b4a9
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Mar 21 04:42:20 2018 -0400

    audit: remove path param from link denied function
    
    In commit 45b578fe4c3cade6f4ca1fc934ce199afd857edc
    ("audit: link denied should not directly generate PATH record")
    the need for the struct path *link parameter was removed.
    Remove the now useless struct path argument.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index af410d9fbf2d..75d5b031e802 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -146,8 +146,7 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const struct path *path);
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
-extern void		    audit_log_link_denied(const char *operation,
-						  const struct path *link);
+extern void		    audit_log_link_denied(const char *operation);
 extern void		    audit_log_lost(const char *message);
 
 extern int audit_log_task_context(struct audit_buffer *ab);
@@ -194,8 +193,7 @@ static inline void audit_log_d_path(struct audit_buffer *ab,
 { }
 static inline void audit_log_key(struct audit_buffer *ab, char *key)
 { }
-static inline void audit_log_link_denied(const char *string,
-					 const struct path *link)
+static inline void audit_log_link_denied(const char *string)
 { }
 static inline int audit_log_task_context(struct audit_buffer *ab)
 {

commit f9bab2677ac77622618686b199073978ba263c12
Merge: 373c4557d2aa 42d5e37654e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 13:28:48 2017 -0800

    Merge tag 'audit-pr-20171113' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "Another relatively small pull request for audit, nine patches total.
    
      The only real new bit of functionality is the patch from Richard which
      adds the ability to filter records based on the filesystem type.
    
      The remainder are bug fixes and cleanups; the bug fix highlights
      include:
    
       - ensuring that we properly audit init/PID-1 (me)
    
       - allowing the audit daemon to shutdown the kernel/auditd connection
         cleanly by setting the audit PID to zero (Steve)"
    
    * tag 'audit-pr-20171113' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit:
      audit: filter PATH records keyed on filesystem magic
      Audit: remove unused audit_log_secctx function
      audit: Allow auditd to set pid to 0 to end auditing
      audit: Add new syscalls to the perm=w filter
      audit: use audit_set_enabled() in audit_enable()
      audit: convert audit_ever_enabled to a boolean
      audit: don't use simple_strtol() anymore
      audit: initialize the audit subsystem as early as possible
      audit: ensure that 'audit=1' actually enables audit for PID 1

commit f7b53637c090bd8ce2dc74ad0f3aa1898aff2524
Author: Casey Schaufler <casey@schaufler-ca.com>
Date:   Tue Oct 24 18:52:31 2017 -0700

    Audit: remove unused audit_log_secctx function
    
    The function audit_log_secctx() is unused in the upstream kernel.
    All it does is wrap another function that doesn't need wrapping.
    It claims to give you the SELinux context, but that is not true if
    you are using a different security module.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Reviewed-by: James Morris <james.l.morris@oracle.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2150bdccfbab..fa1b068d911d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -149,12 +149,6 @@ extern void		    audit_log_key(struct audit_buffer *ab,
 extern void		    audit_log_link_denied(const char *operation,
 						  const struct path *link);
 extern void		    audit_log_lost(const char *message);
-#ifdef CONFIG_SECURITY
-extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
-#else
-static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
-{ }
-#endif
 
 extern int audit_log_task_context(struct audit_buffer *ab);
 extern void audit_log_task_info(struct audit_buffer *ab,
@@ -203,8 +197,6 @@ static inline void audit_log_key(struct audit_buffer *ab, char *key)
 static inline void audit_log_link_denied(const char *string,
 					 const struct path *link)
 { }
-static inline void audit_log_secctx(struct audit_buffer *ab, u32 secid)
-{ }
 static inline int audit_log_task_context(struct audit_buffer *ab)
 {
 	return 0;

commit de8cd83e91bc3ee212b3e6ec6e4283af9e4ab269
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Mon Oct 2 20:21:39 2017 -0400

    audit: Record fanotify access control decisions
    
    The fanotify interface allows user space daemons to make access
    control decisions. Under common criteria requirements, we need to
    optionally record decisions based on policy. This patch adds a bit mask,
    FAN_AUDIT, that a user space daemon can 'or' into the response decision
    which will tell the kernel that it made a decision and record it.
    
    It would be used something like this in user space code:
    
      response.response = FAN_DENY | FAN_AUDIT;
      write(fd, &response, sizeof(struct fanotify_response));
    
    When the syscall ends, the audit system will record the decision as a
    AUDIT_FANOTIFY auxiliary record to denote that the reason this event
    occurred is the result of an access control decision from fanotify
    rather than DAC or MAC policy.
    
    A sample event looks like this:
    
    type=PATH msg=audit(1504310584.332:290): item=0 name="./evil-ls"
    inode=1319561 dev=fc:03 mode=0100755 ouid=1000 ogid=1000 rdev=00:00
    obj=unconfined_u:object_r:user_home_t:s0 nametype=NORMAL
    type=CWD msg=audit(1504310584.332:290): cwd="/home/sgrubb"
    type=SYSCALL msg=audit(1504310584.332:290): arch=c000003e syscall=2
    success=no exit=-1 a0=32cb3fca90 a1=0 a2=43 a3=8 items=1 ppid=901
    pid=959 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000
    fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts1 ses=3 comm="bash"
    exe="/usr/bin/bash" subj=unconfined_u:unconfined_r:unconfined_t:
    s0-s0:c0.c1023 key=(null)
    type=FANOTIFY msg=audit(1504310584.332:290): resp=2
    
    Prior to using the audit flag, the developer needs to call
    fanotify_init or'ing in FAN_ENABLE_AUDIT to ensure that the kernel
    supports auditing. The calling process must also have the CAP_AUDIT_WRITE
    capability.
    
    Signed-off-by: sgrubb <sgrubb@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index cb708eb8accc..d66220dac364 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -356,6 +356,7 @@ extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 extern void __audit_log_capset(const struct cred *new, const struct cred *old);
 extern void __audit_mmap_fd(int fd, int flags);
 extern void __audit_log_kern_module(char *name);
+extern void __audit_fanotify(unsigned int response);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -452,6 +453,12 @@ static inline void audit_log_kern_module(char *name)
 		__audit_log_kern_module(name);
 }
 
+static inline void audit_fanotify(unsigned int response)
+{
+	if (!audit_dummy_context())
+		__audit_fanotify(response);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
@@ -568,6 +575,9 @@ static inline void audit_log_kern_module(char *name)
 {
 }
 
+static inline void audit_fanotify(unsigned int response)
+{ }
+
 static inline void audit_ptrace(struct task_struct *t)
 { }
 #define audit_n_rules 0

commit c0a3a64e723324ae6dda53214061a71de63808c3
Merge: 69c902f597c4 6849243bf4c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 22 16:16:41 2017 -1000

    Merge tag 'seccomp-v4.14-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull seccomp updates from Kees Cook:
     "Major additions:
    
       - sysctl and seccomp operation to discover available actions
         (tyhicks)
    
       - new per-filter configurable logging infrastructure and sysctl
         (tyhicks)
    
       - SECCOMP_RET_LOG to log allowed syscalls (tyhicks)
    
       - SECCOMP_RET_KILL_PROCESS as the new strictest possible action
    
       - self-tests for new behaviors"
    
    [ This is the seccomp part of the security pull request during the merge
      window that was nixed due to unrelated problems   - Linus ]
    
    * tag 'seccomp-v4.14-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      samples: Unrename SECCOMP_RET_KILL
      selftests/seccomp: Test thread vs process killing
      seccomp: Implement SECCOMP_RET_KILL_PROCESS action
      seccomp: Introduce SECCOMP_RET_KILL_PROCESS
      seccomp: Rename SECCOMP_RET_KILL to SECCOMP_RET_KILL_THREAD
      seccomp: Action to log before allowing
      seccomp: Filter flag to log all actions except SECCOMP_RET_ALLOW
      seccomp: Selftest for detection of filter flag support
      seccomp: Sysctl to configure actions that are allowed to be logged
      seccomp: Operation for checking if an action is available
      seccomp: Sysctl to display available actions
      seccomp: Provide matching filter for introspection
      selftests/seccomp: Refactor RET_ERRNO tests
      selftests/seccomp: Add simple seccomp overhead benchmark
      selftests/seccomp: Add tests for basic ptrace actions

commit b9047726386bb538cf5e4f52a9f04eb556eebc67
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Aug 2 19:51:11 2017 -0700

    ipc: mqueue: Replace timespec with timespec64
    
    struct timespec is not y2038 safe. Replace
    all uses of timespec by y2038 safe struct timespec64.
    
    Even though timespec is used here to represent timeouts,
    replace these with timespec64 so that it facilitates
    in verification by creating a y2038 safe kernel image
    that is free of timespec.
    
    The syscall interfaces themselves are not changed as part
    of the patch. They will be part of a different series.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2150bdccfbab..74d4d4e8e3db 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -351,7 +351,7 @@ extern int __audit_socketcall(int nargs, unsigned long *args);
 extern int __audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
 extern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);
-extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
+extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec64 *abs_timeout);
 extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
 extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
@@ -412,7 +412,7 @@ static inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
 	if (unlikely(!audit_dummy_context()))
 		__audit_mq_open(oflag, mode, attr);
 }
-static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout)
+static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec64 *abs_timeout)
 {
 	if (unlikely(!audit_dummy_context()))
 		__audit_mq_sendrecv(mqdes, msg_len, msg_prio, abs_timeout);
@@ -549,7 +549,7 @@ static inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
 { }
 static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len,
 				     unsigned int msg_prio,
-				     const struct timespec *abs_timeout)
+				     const struct timespec64 *abs_timeout)
 { }
 static inline void audit_mq_notify(mqd_t mqdes,
 				   const struct sigevent *notification)

commit 0ddec0fc8900201c0897b87b762b7c420436662f
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Aug 11 04:33:54 2017 +0000

    seccomp: Sysctl to configure actions that are allowed to be logged
    
    Adminstrators can write to this sysctl to set the seccomp actions that
    are allowed to be logged. Any actions not found in this sysctl will not
    be logged.
    
    For example, all SECCOMP_RET_KILL, SECCOMP_RET_TRAP, and
    SECCOMP_RET_ERRNO actions would be loggable if "kill trap errno" were
    written to the sysctl. SECCOMP_RET_TRACE actions would not be logged
    since its string representation ("trace") wasn't present in the sysctl
    value.
    
    The path to the sysctl is:
    
     /proc/sys/kernel/seccomp/actions_logged
    
    The actions_avail sysctl can be read to discover the valid action names
    that can be written to the actions_logged sysctl with the exception of
    "allow". SECCOMP_RET_ALLOW actions cannot be configured for logging.
    
    The default setting for the sysctl is to allow all actions to be logged
    except SECCOMP_RET_ALLOW. While only SECCOMP_RET_KILL actions are
    currently logged, an upcoming patch will allow applications to request
    additional actions to be logged.
    
    There's one important exception to this sysctl. If a task is
    specifically being audited, meaning that an audit context has been
    allocated for the task, seccomp will log all actions other than
    SECCOMP_RET_ALLOW despite the value of actions_logged. This exception
    preserves the existing auditing behavior of tasks with an allocated
    audit context.
    
    With this patch, the logic for deciding if an action will be logged is:
    
    if action == RET_ALLOW:
      do not log
    else if action == RET_KILL && RET_KILL in actions_logged:
      log
    else if audit_enabled && task-is-being-audited:
      log
    else:
      do not log
    
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2150bdccfbab..8c30f06d639d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -314,11 +314,7 @@ void audit_core_dumps(long signr);
 
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 {
-	if (!audit_enabled)
-		return;
-
-	/* Force a record to be reported if a signal was delivered. */
-	if (signr || unlikely(!audit_dummy_context()))
+	if (audit_enabled && unlikely(!audit_dummy_context()))
 		__audit_seccomp(syscall, signr, code);
 }
 

commit 2115bb250f260089743e26decfb5f271ba71ca37
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 2 10:16:05 2017 -0400

    audit: Use timespec64 to represent audit timestamps
    
    struct timespec is not y2038 safe.
    Audit timestamps are recorded in string format into
    an audit buffer for a given context.
    These mark the entry timestamps for the syscalls.
    Use y2038 safe struct timespec64 to represent the times.
    The log strings can handle this transition as strings can
    hold upto 1024 characters.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index cc0497c39472..2150bdccfbab 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -331,7 +331,7 @@ static inline void audit_ptrace(struct task_struct *t)
 				/* Private API (for audit.c only) */
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
-			      struct timespec *t, unsigned int *serial);
+			      struct timespec64 *t, unsigned int *serial);
 extern int audit_set_loginuid(kuid_t loginuid);
 
 static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
@@ -510,7 +510,7 @@ static inline void __audit_seccomp(unsigned long syscall, long signr, int code)
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 { }
 static inline int auditsc_get_stamp(struct audit_context *ctx,
-			      struct timespec *t, unsigned int *serial)
+			      struct timespec64 *t, unsigned int *serial)
 {
 	return 0;
 }

commit 45a0642b4d021a2f50d5db9c191b5bfe60bfa1c7
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue May 2 10:16:05 2017 -0400

    audit: kernel generated netlink traffic should have a portid of 0
    
    We were setting the portid incorrectly in the netlink message headers,
    fix that to always be 0 (nlmsg_pid = 0).
    
    Signed-off-by: Paul Moore <paul@paul-moore.com>
    Reviewed-by: Richard Guy Briggs <rgb@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 504e784b7ffa..cc0497c39472 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -163,8 +163,7 @@ extern void audit_log_task_info(struct audit_buffer *ab,
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
-extern int audit_rule_change(int type, __u32 portid, int seq,
-				void *data, size_t datasz);
+extern int audit_rule_change(int type, int seq, void *data, size_t datasz);
 extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);
 
 extern u32 audit_enabled;

commit b8989bccd6a0ad49db4795afca56a733e1c19099
Merge: c9341ee0af4d fe8e52b9b910
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 21 13:25:50 2017 -0800

    Merge branch 'stable-4.11' of git://git.infradead.org/users/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "The audit changes for v4.11 are relatively small compared to what we
      did for v4.10, both in terms of size and impact.
    
       - two patches from Steve tweak the formatting for some of the audit
         records to make them more consistent with other audit records.
    
       - three patches from Richard record the name of a module on module
         load, fix the logging of sockaddr information when using
         socketcall() on 32-bit systems, and add the ability to reset
         audit's lost record counter.
    
       - my lone patch just fixes an annoying style nit that I was reminded
         about by one of Richard's patches.
    
      All these patches pass our test suite"
    
    * 'stable-4.11' of git://git.infradead.org/users/pcmoore/audit:
      audit: remove unnecessary curly braces from switch/case statements
      audit: log module name on init_module
      audit: log 32-bit socketcalls
      audit: add feature audit_lost reset
      audit: Make AUDIT_ANOM_ABEND event normalized
      audit: Make AUDIT_KERNEL event conform to the specification

commit ca86cad7380e373fa17bc0ee8aff121380323e69
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Sat Feb 4 13:10:38 2017 -0500

    audit: log module name on init_module
    
    This adds a new auxiliary record MODULE_INIT to the SYSCALL event.
    
    We get finit_module for free since it made most sense to hook this in to
    load_module().
    
    https://github.com/linux-audit/audit-kernel/issues/7
    https://github.com/linux-audit/audit-kernel/wiki/RFE-Module-Load-Record-Format
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Acked-by: Jessica Yu <jeyu@redhat.com>
    [PM: corrected links in the commit description]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2be99b276d29..aba3a2684300 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -360,6 +360,7 @@ extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *old);
 extern void __audit_log_capset(const struct cred *new, const struct cred *old);
 extern void __audit_mmap_fd(int fd, int flags);
+extern void __audit_log_kern_module(char *name);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -450,6 +451,12 @@ static inline void audit_mmap_fd(int fd, int flags)
 		__audit_mmap_fd(fd, flags);
 }
 
+static inline void audit_log_kern_module(char *name)
+{
+	if (!audit_dummy_context())
+		__audit_log_kern_module(name);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
@@ -561,6 +568,11 @@ static inline void audit_log_capset(const struct cred *new,
 { }
 static inline void audit_mmap_fd(int fd, int flags)
 { }
+
+static inline void audit_log_kern_module(char *name)
+{
+}
+
 static inline void audit_ptrace(struct task_struct *t)
 { }
 #define audit_n_rules 0

commit 62bc306e2083436675e33b5bdeb6a77907d35971
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Jan 17 11:07:15 2017 -0500

    audit: log 32-bit socketcalls
    
    32-bit socketcalls were not being logged by audit on x86_64 systems.
    Log them.  This is basically a duplicate of the call from
    net/socket.c:sys_socketcall(), but it addresses the impedance mismatch
    between 32-bit userspace process and 64-bit kernel audit.
    
    See: https://github.com/linux-audit/audit-kernel/issues/14
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9d4443f93db6..2be99b276d29 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -387,6 +387,20 @@ static inline int audit_socketcall(int nargs, unsigned long *args)
 		return __audit_socketcall(nargs, args);
 	return 0;
 }
+
+static inline int audit_socketcall_compat(int nargs, u32 *args)
+{
+	unsigned long a[AUDITSC_ARGS];
+	int i;
+
+	if (audit_dummy_context())
+		return 0;
+
+	for (i = 0; i < nargs; i++)
+		a[i] = (unsigned long)args[i];
+	return __audit_socketcall(nargs, a);
+}
+
 static inline int audit_sockaddr(int len, void *addr)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -513,6 +527,12 @@ static inline int audit_socketcall(int nargs, unsigned long *args)
 {
 	return 0;
 }
+
+static inline int audit_socketcall_compat(int nargs, u32 *args)
+{
+	return 0;
+}
+
 static inline void audit_fd_pair(int fd1, int fd2)
 { }
 static inline int audit_sockaddr(int len, void *addr)

commit 8bd107633b64195a0748b05236c3d14db0a8bed4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 20 20:36:51 2016 -0500

    audit_log_{name,link_denied}: constify struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9d4443f93db6..f51fca8d0b6f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -147,7 +147,7 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
 extern void		    audit_log_link_denied(const char *operation,
-						  struct path *link);
+						  const struct path *link);
 extern void		    audit_log_lost(const char *message);
 #ifdef CONFIG_SECURITY
 extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);

commit 86b2efbe3a390e07dbba725ef700b0d143e9a385
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Fri Jun 24 16:35:46 2016 -0400

    audit: add fields to exclude filter by reusing user filter
    
    RFE: add additional fields for use in audit filter exclude rules
    https://github.com/linux-audit/audit-kernel/issues/5
    
    Re-factor and combine audit_filter_type() with audit_filter_user() to
    use audit_filter_user_rules() to enable the exclude filter to
    additionally filter on PID, UID, GID, AUID, LOGINUID_SET, SUBJ_*.
    
    The process of combining the similar audit_filter_user() and
    audit_filter_type() functions, required inverting the meaning and
    including the ALWAYS action of the latter.
    
    Include audit_filter_user_rules() into audit_filter(), removing
    unneeded logic in the process.
    
    Keep the check to quit early if the list is empty.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: checkpatch.pl fixes - whitespace damage, wrapped description]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e38e3fc13ea8..9d4443f93db6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -163,8 +163,6 @@ extern void audit_log_task_info(struct audit_buffer *ab,
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
-extern int audit_filter_user(int type);
-extern int audit_filter_type(int type);
 extern int audit_rule_change(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
 extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);

commit 2e28d38ae1d9ced6ac2deb4001aca3f267304cdb
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 9 22:55:33 2016 -0800

    tty: audit: Handle tty audit enable atomically
    
    The audit_tty and audit_tty_log_passwd fields are actually bool
    values, so merge into single memory location to access atomically.
    
    NB: audit log operations may still occur after tty audit is disabled
    which is consistent with the existing functionality
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b40ed5df5542..e38e3fc13ea8 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -109,6 +109,10 @@ extern int audit_classify_compat_syscall(int abi, unsigned syscall);
 /* maximized args number that audit_socketcall can process */
 #define AUDITSC_ARGS		6
 
+/* bit values for ->signal->audit_tty */
+#define AUDIT_TTY_ENABLE	BIT(0)
+#define AUDIT_TTY_LOG_PASSWD	BIT(1)
+
 struct filename;
 
 extern void audit_log_session_info(struct audit_buffer *ab);

commit 5807fcaa9bf7dd87241df739161c119cf78a6bc4
Merge: 2d663b55816e acb2cfdb316d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 17 19:13:15 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
    
     - EVM gains support for loading an x509 cert from the kernel
       (EVM_LOAD_X509), into the EVM trusted kernel keyring.
    
     - Smack implements 'file receive' process-based permission checking for
       sockets, rather than just depending on inode checks.
    
     - Misc enhancments for TPM & TPM2.
    
     - Cleanups and bugfixes for SELinux, Keys, and IMA.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (41 commits)
      selinux: Inode label revalidation performance fix
      KEYS: refcount bug fix
      ima: ima_write_policy() limit locking
      IMA: policy can be updated zero times
      selinux: rate-limit netlink message warnings in selinux_nlmsg_perm()
      selinux: export validatetrans decisions
      gfs2: Invalid security labels of inodes when they go invalid
      selinux: Revalidate invalid inode security labels
      security: Add hook to invalidate inode security labels
      selinux: Add accessor functions for inode->i_security
      security: Make inode argument of inode_getsecid non-const
      security: Make inode argument of inode_getsecurity non-const
      selinux: Remove unused variable in selinux_inode_init_security
      keys, trusted: seal with a TPM2 authorization policy
      keys, trusted: select hash algorithm for TPM2 chips
      keys, trusted: fix: *do not* allow duplicate key options
      tpm_ibmvtpm: properly handle interrupted packet receptions
      tpm_tis: Tighten IRQ auto-probing
      tpm_tis: Refactor the interrupt setup
      tpm_tis: Get rid of the duplicate IRQ probing code
      ...

commit 96368701e1c89057bbf39222e965161c68a85b4b
Author: Paul Moore <pmoore@redhat.com>
Date:   Wed Jan 13 09:18:55 2016 -0500

    audit: force seccomp event logging to honor the audit_enabled flag
    
    Previously we were emitting seccomp audit records regardless of the
    audit_enabled setting, a deparature from the rest of audit.  This
    patch makes seccomp auditing consistent with the rest of the audit
    record generation code in that when audit_enabled=0 nothing is logged
    by the audit subsystem.
    
    The bulk of this patch is moving the CONFIG_AUDIT block ahead of the
    CONFIG_AUDITSYSCALL block in include/linux/audit.h; the only real
    code change was in the audit_seccomp() definition.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 20eba1eb0a3c..476bc1237ec2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -113,6 +113,107 @@ struct filename;
 
 extern void audit_log_session_info(struct audit_buffer *ab);
 
+#ifdef CONFIG_AUDIT
+/* These are defined in audit.c */
+				/* Public API */
+extern __printf(4, 5)
+void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
+	       const char *fmt, ...);
+
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask, int type);
+extern __printf(2, 3)
+void audit_log_format(struct audit_buffer *ab, const char *fmt, ...);
+extern void		    audit_log_end(struct audit_buffer *ab);
+extern bool		    audit_string_contains_control(const char *string,
+							  size_t len);
+extern void		    audit_log_n_hex(struct audit_buffer *ab,
+					  const unsigned char *buf,
+					  size_t len);
+extern void		    audit_log_n_string(struct audit_buffer *ab,
+					       const char *buf,
+					       size_t n);
+extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
+							const char *string,
+							size_t n);
+extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
+						      const char *string);
+extern void		    audit_log_d_path(struct audit_buffer *ab,
+					     const char *prefix,
+					     const struct path *path);
+extern void		    audit_log_key(struct audit_buffer *ab,
+					  char *key);
+extern void		    audit_log_link_denied(const char *operation,
+						  struct path *link);
+extern void		    audit_log_lost(const char *message);
+#ifdef CONFIG_SECURITY
+extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
+#else
+static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
+{ }
+#endif
+
+extern int audit_log_task_context(struct audit_buffer *ab);
+extern void audit_log_task_info(struct audit_buffer *ab,
+				struct task_struct *tsk);
+
+extern int		    audit_update_lsm_rules(void);
+
+				/* Private API (for audit.c only) */
+extern int audit_filter_user(int type);
+extern int audit_filter_type(int type);
+extern int audit_rule_change(int type, __u32 portid, int seq,
+				void *data, size_t datasz);
+extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);
+
+extern u32 audit_enabled;
+#else /* CONFIG_AUDIT */
+static inline __printf(4, 5)
+void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
+	       const char *fmt, ...)
+{ }
+static inline struct audit_buffer *audit_log_start(struct audit_context *ctx,
+						   gfp_t gfp_mask, int type)
+{
+	return NULL;
+}
+static inline __printf(2, 3)
+void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)
+{ }
+static inline void audit_log_end(struct audit_buffer *ab)
+{ }
+static inline void audit_log_n_hex(struct audit_buffer *ab,
+				   const unsigned char *buf, size_t len)
+{ }
+static inline void audit_log_n_string(struct audit_buffer *ab,
+				      const char *buf, size_t n)
+{ }
+static inline void  audit_log_n_untrustedstring(struct audit_buffer *ab,
+						const char *string, size_t n)
+{ }
+static inline void audit_log_untrustedstring(struct audit_buffer *ab,
+					     const char *string)
+{ }
+static inline void audit_log_d_path(struct audit_buffer *ab,
+				    const char *prefix,
+				    const struct path *path)
+{ }
+static inline void audit_log_key(struct audit_buffer *ab, char *key)
+{ }
+static inline void audit_log_link_denied(const char *string,
+					 const struct path *link)
+{ }
+static inline void audit_log_secctx(struct audit_buffer *ab, u32 secid)
+{ }
+static inline int audit_log_task_context(struct audit_buffer *ab)
+{
+	return 0;
+}
+static inline void audit_log_task_info(struct audit_buffer *ab,
+				       struct task_struct *tsk)
+{ }
+#define audit_enabled 0
+#endif /* CONFIG_AUDIT */
+
 #ifdef CONFIG_AUDIT_COMPAT_GENERIC
 #define audit_is_compat(arch)  (!((arch) & __AUDIT_ARCH_64BIT))
 #else
@@ -212,6 +313,9 @@ void audit_core_dumps(long signr);
 
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 {
+	if (!audit_enabled)
+		return;
+
 	/* Force a record to be reported if a signal was delivered. */
 	if (signr || unlikely(!audit_dummy_context()))
 		__audit_seccomp(syscall, signr, code);
@@ -446,106 +550,6 @@ static inline bool audit_loginuid_set(struct task_struct *tsk)
 	return uid_valid(audit_get_loginuid(tsk));
 }
 
-#ifdef CONFIG_AUDIT
-/* These are defined in audit.c */
-				/* Public API */
-extern __printf(4, 5)
-void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
-	       const char *fmt, ...);
-
-extern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask, int type);
-extern __printf(2, 3)
-void audit_log_format(struct audit_buffer *ab, const char *fmt, ...);
-extern void		    audit_log_end(struct audit_buffer *ab);
-extern bool		    audit_string_contains_control(const char *string,
-							  size_t len);
-extern void		    audit_log_n_hex(struct audit_buffer *ab,
-					  const unsigned char *buf,
-					  size_t len);
-extern void		    audit_log_n_string(struct audit_buffer *ab,
-					       const char *buf,
-					       size_t n);
-extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
-							const char *string,
-							size_t n);
-extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
-						      const char *string);
-extern void		    audit_log_d_path(struct audit_buffer *ab,
-					     const char *prefix,
-					     const struct path *path);
-extern void		    audit_log_key(struct audit_buffer *ab,
-					  char *key);
-extern void		    audit_log_link_denied(const char *operation,
-						  struct path *link);
-extern void		    audit_log_lost(const char *message);
-#ifdef CONFIG_SECURITY
-extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
-#else
-static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
-{ }
-#endif
-
-extern int audit_log_task_context(struct audit_buffer *ab);
-extern void audit_log_task_info(struct audit_buffer *ab,
-				struct task_struct *tsk);
-
-extern int		    audit_update_lsm_rules(void);
-
-				/* Private API (for audit.c only) */
-extern int audit_filter_user(int type);
-extern int audit_filter_type(int type);
-extern int audit_rule_change(int type, __u32 portid, int seq,
-				void *data, size_t datasz);
-extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);
-
-extern u32 audit_enabled;
-#else /* CONFIG_AUDIT */
-static inline __printf(4, 5)
-void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
-	       const char *fmt, ...)
-{ }
-static inline struct audit_buffer *audit_log_start(struct audit_context *ctx,
-						   gfp_t gfp_mask, int type)
-{
-	return NULL;
-}
-static inline __printf(2, 3)
-void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)
-{ }
-static inline void audit_log_end(struct audit_buffer *ab)
-{ }
-static inline void audit_log_n_hex(struct audit_buffer *ab,
-				   const unsigned char *buf, size_t len)
-{ }
-static inline void audit_log_n_string(struct audit_buffer *ab,
-				      const char *buf, size_t n)
-{ }
-static inline void  audit_log_n_untrustedstring(struct audit_buffer *ab,
-						const char *string, size_t n)
-{ }
-static inline void audit_log_untrustedstring(struct audit_buffer *ab,
-					     const char *string)
-{ }
-static inline void audit_log_d_path(struct audit_buffer *ab,
-				    const char *prefix,
-				    const struct path *path)
-{ }
-static inline void audit_log_key(struct audit_buffer *ab, char *key)
-{ }
-static inline void audit_log_link_denied(const char *string,
-					 const struct path *link)
-{ }
-static inline void audit_log_secctx(struct audit_buffer *ab, u32 secid)
-{ }
-static inline int audit_log_task_context(struct audit_buffer *ab)
-{
-	return 0;
-}
-static inline void audit_log_task_info(struct audit_buffer *ab,
-				       struct task_struct *tsk)
-{ }
-#define audit_enabled 0
-#endif /* CONFIG_AUDIT */
 static inline void audit_log_string(struct audit_buffer *ab, const char *buf)
 {
 	audit_log_n_string(ab, buf, strlen(buf));

commit d6335d77a7622a88380f3f207cc1f727f878dd21
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Dec 24 11:09:39 2015 -0500

    security: Make inode argument of inode_getsecid non-const
    
    Make the inode argument of the inode_getsecid hook non-const so that we
    can use it to revalidate invalid security labels.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 20eba1eb0a3c..8a2d046e9f6b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -137,7 +137,7 @@ extern void __audit_getname(struct filename *name);
 extern void __audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int flags);
 extern void __audit_file(const struct file *);
-extern void __audit_inode_child(const struct inode *parent,
+extern void __audit_inode_child(struct inode *parent,
 				const struct dentry *dentry,
 				const unsigned char type);
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
@@ -202,7 +202,7 @@ static inline void audit_inode_parent_hidden(struct filename *name,
 		__audit_inode(name, dentry,
 				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
 }
-static inline void audit_inode_child(const struct inode *parent,
+static inline void audit_inode_child(struct inode *parent,
 				     const struct dentry *dentry,
 				     const unsigned char type) {
 	if (unlikely(!audit_dummy_context()))
@@ -359,7 +359,7 @@ static inline void __audit_inode(struct filename *name,
 					const struct dentry *dentry,
 					unsigned int flags)
 { }
-static inline void __audit_inode_child(const struct inode *parent,
+static inline void __audit_inode_child(struct inode *parent,
 					const struct dentry *dentry,
 					const unsigned char type)
 { }
@@ -373,7 +373,7 @@ static inline void audit_file(struct file *file)
 static inline void audit_inode_parent_hidden(struct filename *name,
 				const struct dentry *dentry)
 { }
-static inline void audit_inode_child(const struct inode *parent,
+static inline void audit_inode_child(struct inode *parent,
 				     const struct dentry *dentry,
 				     const unsigned char type)
 { }

commit 9fcf836b215ca5685030ecab3e35ecc14ee3bcfb
Author: Yaowei Bai <bywxiaobai@163.com>
Date:   Wed Nov 4 08:23:51 2015 -0500

    audit: audit_string_contains_control can be boolean
    
    This patch makes audit_string_contains_control return bool to improve
    readability due to this particular function only using either one or
    zero as its return value.
    
    Signed-off-by: Yaowei Bai <bywxiaobai@163.com>
    [PM: tweaked subject line]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 69844b680fcc..20eba1eb0a3c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -457,7 +457,7 @@ extern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp
 extern __printf(2, 3)
 void audit_log_format(struct audit_buffer *ab, const char *fmt, ...);
 extern void		    audit_log_end(struct audit_buffer *ab);
-extern int		    audit_string_contains_control(const char *string,
+extern bool		    audit_string_contains_control(const char *string,
 							  size_t len);
 extern void		    audit_log_n_hex(struct audit_buffer *ab,
 					  const unsigned char *buf,

commit 36734810488e618d48cc14782f7111b3dfaffb83
Author: Yaowei Bai <bywxiaobai@163.com>
Date:   Wed Nov 4 08:23:51 2015 -0500

    audit: audit_dummy_context can be boolean
    
    This patch makes audit_dummy_context return bool due to this
    particular function only using either one or zero as its return
    value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <bywxiaobai@163.com>
    [PM: subject line tweak]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b2abc996c25d..69844b680fcc 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -143,7 +143,7 @@ extern void __audit_inode_child(const struct inode *parent,
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
 extern void __audit_ptrace(struct task_struct *t);
 
-static inline int audit_dummy_context(void)
+static inline bool audit_dummy_context(void)
 {
 	void *p = current->audit_context;
 	return !p || *(int *)p;
@@ -345,9 +345,9 @@ static inline void audit_syscall_entry(int major, unsigned long a0,
 { }
 static inline void audit_syscall_exit(void *pt_regs)
 { }
-static inline int audit_dummy_context(void)
+static inline bool audit_dummy_context(void)
 {
-	return 1;
+	return true;
 }
 static inline struct filename *audit_reusename(const __user char *name)
 {

commit 34d99af52ad40bd498ba66970579a5bc1fb1a3bc
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Aug 5 16:29:37 2015 -0400

    audit: implement audit by executable
    
    This adds the ability audit the actions of a not-yet-running process.
    
    This patch implements the ability to filter on the executable path.  Instead of
    just hard coding the ino and dev of the executable we care about at the moment
    the rule is inserted into the kernel, use the new audit_fsnotify
    infrastructure to manage this dynamically.  This means that if the filename
    does not yet exist but the containing directory does, or if the inode in
    question is unlinked and creat'd (aka updated) the rule will just continue to
    work.  If the containing directory is moved or deleted or the filesystem is
    unmounted, the rule is deleted automatically.  A future enhancement would be to
    have the rule survive across directory disruptions.
    
    This is a heavily modified version of a patch originally submitted by Eric
    Paris with some ideas from Peter Moody.
    
    Cc: Peter Moody <peter@hda3.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: minor whitespace clean to satisfy ./scripts/checkpatch]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 759feb0e9d13..b2abc996c25d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -62,6 +62,7 @@ struct audit_krule {
 	struct audit_field	*inode_f; /* quick access to an inode field */
 	struct audit_watch	*watch;	/* associated watch */
 	struct audit_tree	*tree;	/* associated watched tree */
+	struct audit_fsnotify_mark	*exe;
 	struct list_head	rlist;	/* entry in audit_{watch,tree}.rules list */
 	struct list_head	list;	/* for AUDIT_LIST* purposes only */
 	u64			prio;

commit 84cb777e67814f2e06a99ff228f743409e9617e9
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Aug 5 23:48:20 2015 -0400

    audit: use macros for unset inode and device values
    
    Clean up a number of places were casted magic numbers are used to represent
    unset inode and device numbers in preparation for the audit by executable path
    patch set.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [PM: enclosed the _UNSET macros in parentheses for ./scripts/checkpatch]
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c2e7e3a83965..759feb0e9d13 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -27,6 +27,9 @@
 #include <linux/ptrace.h>
 #include <uapi/linux/audit.h>
 
+#define AUDIT_INO_UNSET ((unsigned long)-1)
+#define AUDIT_DEV_UNSET ((dev_t)-1)
+
 struct audit_sig_info {
 	uid_t		uid;
 	pid_t		pid;

commit 05016b0f0a9d900e976db7f50a7761c0aefe5a1c
Merge: c6b1de1b646f 55422d0bd292
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 15:27:47 2015 -0800

    Merge branch 'getname2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull getname/putname updates from Al Viro:
     "Rework of getname/getname_kernel/etc., mostly from Paul Moore.  Gets
      rid of quite a pile of kludges between namei and audit..."
    
    * 'getname2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      audit: replace getname()/putname() hacks with reference counters
      audit: fix filename matching in __audit_inode() and __audit_inode_child()
      audit: enable filename recording via getname_kernel()
      simpler calling conventions for filename_mountpoint()
      fs: create proper filename objects using getname_kernel()
      fs: rework getname_kernel to handle up to PATH_MAX sized filenames
      cut down the number of do_path_lookup() callers

commit 7184487f14eb7c2fcf8337bb16c6a63b6db1252e
Merge: 59d53737a864 2fded7f44b8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 11 20:07:47 2015 -0800

    Merge branch 'upstream' of git://git.infradead.org/users/pcmoore/audit
    
    Pull audit fix from Paul Moore:
     "Just one patch from the audit tree for v3.20, and a very minor one at
      that.
    
      The patch simply removes an old, unused field from the audit_krule
      structure, a private audit-only struct.  In audit related news, we did
      a proper overhaul of the audit pathname code and removed the nasty
      getname()/putname() hacks for audit, you should see those patches in
      Al's vfs tree if you haven't already.
    
      That's it for audit this time, let's hope for a quiet -rcX series"
    
    * 'upstream' of git://git.infradead.org/users/pcmoore/audit:
      audit: remove vestiges of vers_ops

commit 55422d0bd292f5ad143cc32cb8bb8505257274c4
Author: Paul Moore <pmoore@redhat.com>
Date:   Thu Jan 22 00:00:23 2015 -0500

    audit: replace getname()/putname() hacks with reference counters
    
    In order to ensure that filenames are not released before the audit
    subsystem is done with the strings there are a number of hacks built
    into the fs and audit subsystems around getname() and putname().  To
    say these hacks are "ugly" would be kind.
    
    This patch removes the filename hackery in favor of a more
    conventional reference count based approach.  The diffstat below tells
    most of the story; lots of audit/fs specific code is replaced with a
    traditional reference count based approach that is easily understood,
    even by those not familiar with the audit and/or fs subsystems.
    
    CC: viro@zeniv.linux.org.uk
    CC: linux-fsdevel@vger.kernel.org
    Signed-off-by: Paul Moore <pmoore@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index af84234e1f6e..87c2d347d255 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -128,7 +128,6 @@ extern void __audit_syscall_entry(int major, unsigned long a0, unsigned long a1,
 extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern struct filename *__audit_reusename(const __user char *uptr);
 extern void __audit_getname(struct filename *name);
-extern void audit_putname(struct filename *name);
 
 #define AUDIT_INODE_PARENT	1	/* dentry represents the parent */
 #define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
@@ -353,8 +352,6 @@ static inline struct filename *audit_reusename(const __user char *name)
 }
 static inline void audit_getname(struct filename *name)
 { }
-static inline void audit_putname(struct filename *name)
-{ }
 static inline void __audit_inode(struct filename *name,
 					const struct dentry *dentry,
 					unsigned int flags)

commit 2fded7f44b8fcf79e274c3f0cfbd0298f95308f3
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Dec 23 16:39:54 2014 -0500

    audit: remove vestiges of vers_ops
    
    Should have been removed with commit 18900909 ("audit: remove the old
    depricated kernel interface").
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 93331929d643..b481779a8dee 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -46,7 +46,6 @@ struct audit_tree;
 struct sk_buff;
 
 struct audit_krule {
-	int			vers_ops;
 	u32			pflags;
 	u32			flags;
 	u32			listnr;

commit 66b3f4f0a0fcc197a1e432c3d2134f5c6a5275b9
Merge: 53262d12d165 041d7b98ffe5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 23 18:13:16 2014 -0800

    Merge branch 'upstream' of git://git.infradead.org/users/pcmoore/audit
    
    Pull audit fixes from Paul Moore:
     "Four patches to fix various problems with the audit subsystem, all are
      fairly small and straightforward.
    
      One patch fixes a problem where we weren't using the correct gfp
      allocation flags (GFP_KERNEL regardless of context, oops), one patch
      fixes a problem with old userspace tools (this was broken for a
      while), one patch fixes a problem where we weren't recording pathnames
      correctly, and one fixes a problem with PID based filters.
    
      In general I don't think there is anything controversial with this
      patchset, and it fixes some rather unfortunate bugs; the allocation
      flag one can be particularly scary looking for users"
    
    * 'upstream' of git://git.infradead.org/users/pcmoore/audit:
      audit: restore AUDIT_LOGINUID unset ABI
      audit: correctly record file names with different path name types
      audit: use supplied gfp_mask from audit_buffer in kauditd_send_multicast_skb
      audit: don't attempt to lookup PIDs when changing PID filtering audit rules

commit 041d7b98ffe59c59fdd639931dea7d74f9aa9a59
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Dec 23 13:02:04 2014 -0500

    audit: restore AUDIT_LOGINUID unset ABI
    
    A regression was caused by commit 780a7654cee8:
             audit: Make testing for a valid loginuid explicit.
    (which in turn attempted to fix a regression caused by e1760bd)
    
    When audit_krule_to_data() fills in the rules to get a listing, there was a
    missing clause to convert back from AUDIT_LOGINUID_SET to AUDIT_LOGINUID.
    
    This broke userspace by not returning the same information that was sent and
    expected.
    
    The rule:
            auditctl -a exit,never -F auid=-1
    gives:
            auditctl -l
                    LIST_RULES: exit,never f24=0 syscall=all
    when it should give:
                    LIST_RULES: exit,never auid=-1 (0xffffffff) syscall=all
    
    Tag it so that it is reported the same way it was set.  Create a new
    private flags audit_krule field (pflags) to store it that won't interact with
    the public one from the API.
    
    Cc: stable@vger.kernel.org # v3.10-rc1+
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 36dffeccebdb..93331929d643 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -47,6 +47,7 @@ struct sk_buff;
 
 struct audit_krule {
 	int			vers_ops;
+	u32			pflags;
 	u32			flags;
 	u32			listnr;
 	u32			action;
@@ -64,6 +65,9 @@ struct audit_krule {
 	u64			prio;
 };
 
+/* Flag to indicate legacy AUDIT_LOGINUID unset usage */
+#define AUDIT_LOGINUID_LEGACY		0x1
+
 struct audit_field {
 	u32				type;
 	union {

commit 9f45f5bf302daad6835ce64701fb3c286a2cc6af
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 31 17:44:57 2014 -0400

    new helper: audit_file()
    
    ... for situations when we don't have any candidate in pathnames - basically,
    in descriptor-based syscalls.
    
    [Folded the build fix for !CONFIG_AUDITSYSCALL configs from Chen Gang]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e58fe7df8b9c..0c04917c2f12 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -130,6 +130,7 @@ extern void audit_putname(struct filename *name);
 #define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
 extern void __audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int flags);
+extern void __audit_file(const struct file *);
 extern void __audit_inode_child(const struct inode *parent,
 				const struct dentry *dentry,
 				const unsigned char type);
@@ -183,6 +184,11 @@ static inline void audit_inode(struct filename *name,
 		__audit_inode(name, dentry, flags);
 	}
 }
+static inline void audit_file(struct file *file)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_file(file);
+}
 static inline void audit_inode_parent_hidden(struct filename *name,
 						const struct dentry *dentry)
 {
@@ -357,6 +363,9 @@ static inline void audit_inode(struct filename *name,
 				const struct dentry *dentry,
 				unsigned int parent)
 { }
+static inline void audit_file(struct file *file)
+{
+}
 static inline void audit_inode_parent_hidden(struct filename *name,
 				const struct dentry *dentry)
 { }

commit 9e8beeb79ded25c5c1986f80fb8a7f6815345d5a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 13 18:58:48 2014 -0600

    audit: Remove "weak" from audit_classify_compat_syscall() declaration
    
    There's only one audit_classify_compat_syscall() definition, so it doesn't
    need to be weak.
    
    Remove the "weak" attribute from the audit_classify_compat_syscall()
    declaration.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    CC: AKASHI Takahiro <takahiro.akashi@linaro.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 36dffeccebdb..e58fe7df8b9c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -90,7 +90,7 @@ extern unsigned compat_dir_class[];
 extern unsigned compat_chattr_class[];
 extern unsigned compat_signal_class[];
 
-extern int __weak audit_classify_compat_syscall(int abi, unsigned syscall);
+extern int audit_classify_compat_syscall(int abi, unsigned syscall);
 
 /* audit_names->type values */
 #define	AUDIT_TYPE_UNKNOWN	0	/* we don't know yet */

commit 219ca39427bf6c46c4e1473493e33bc00635e99b
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Mar 26 07:26:47 2014 -0400

    audit: use union for audit_field values since they are mutually exclusive
    
    Since only one of val, uid, gid and lsm* are used at any given time, combine
    them to reduce the size of the struct audit_field.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1ae00891aff9..36dffeccebdb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -66,12 +66,16 @@ struct audit_krule {
 
 struct audit_field {
 	u32				type;
-	u32				val;
-	kuid_t				uid;
-	kgid_t				gid;
+	union {
+		u32			val;
+		kuid_t			uid;
+		kgid_t			gid;
+		struct {
+			char		*lsm_str;
+			void		*lsm_rule;
+		};
+	};
 	u32				op;
-	char				*lsm_str;
-	void				*lsm_rule;
 };
 
 extern int is_audit_feature_set(int which);

commit b4f0d3755c5e9cc86292d5fd78261903b4f23d4a
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Mar 4 10:38:06 2014 -0500

    audit: x86: drop arch from __audit_syscall_entry() interface
    
    Since the arch is found locally in __audit_syscall_entry(), there is no need to
    pass it in as a parameter.  Delete it from the parameter list.
    
    x86* was the only arch to call __audit_syscall_entry() directly and did so from
    assembly code.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-audit@redhat.com
    Signed-off-by: Eric Paris <eparis@redhat.com>
    
    ---
    
    As this patch relies on changes in the audit tree, I think it
    appropriate to send it through my tree rather than the x86 tree.

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 783157b289e8..1ae00891aff9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -115,8 +115,7 @@ extern void audit_log_session_info(struct audit_buffer *ab);
 				/* Public API */
 extern int  audit_alloc(struct task_struct *task);
 extern void __audit_free(struct task_struct *task);
-extern void __audit_syscall_entry(int arch,
-				  int major, unsigned long a0, unsigned long a1,
+extern void __audit_syscall_entry(int major, unsigned long a0, unsigned long a1,
 				  unsigned long a2, unsigned long a3);
 extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern struct filename *__audit_reusename(const __user char *uptr);
@@ -148,7 +147,7 @@ static inline void audit_syscall_entry(int major, unsigned long a0,
 				       unsigned long a3)
 {
 	if (unlikely(current->audit_context))
-		__audit_syscall_entry(syscall_get_arch(), major, a0, a1, a2, a3);
+		__audit_syscall_entry(major, a0, a1, a2, a3);
 }
 static inline void audit_syscall_exit(void *pt_regs)
 {

commit a9ebe0b98896b276a3a1664da5f40d3b7c92f316
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 22 11:46:16 2014 -0400

    audit: fix build error when asm/syscall.h does not exist
    
    avr32 does not have an asm/syscall.h file.  We need the
    syscall_get_arch() definition from that file for all arch's which
    support CONFIG_AUDITSYSCALL.  Obviously avr32 is not one of those
    arch's.  Move the include inside the CONFIG_AUDITSYSCALL such that we
    only do the include if we need the results.
    
    When the syscall_get_arch() call is moved inside __audit_syscall_entry()
    this include can be dropped entirely.  But that is going to require some
    assembly changes on x86* in a patch that is not ready for the tree...
    
    Reported-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bb1c3ab611bf..783157b289e8 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -26,7 +26,6 @@
 #include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <uapi/linux/audit.h>
-#include <asm/syscall.h>
 
 struct audit_sig_info {
 	uid_t		uid;
@@ -110,6 +109,8 @@ extern void audit_log_session_info(struct audit_buffer *ab);
 #endif
 
 #ifdef CONFIG_AUDITSYSCALL
+#include <asm/syscall.h> /* for syscall_get_arch() */
+
 /* These are defined in auditsc.c */
 				/* Public API */
 extern int  audit_alloc(struct task_struct *task);

commit 91397401bb5072f71e8ce8744ad0bdec3e875a91
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Mar 11 13:29:28 2014 -0400

    ARCH: AUDIT: audit_syscall_entry() should not require the arch
    
    We have a function where the arch can be queried, syscall_get_arch().
    So rather than have every single piece of arch specific code use and/or
    duplicate syscall_get_arch(), just have the audit code use the
    syscall_get_arch() code.
    
    Based-on-patch-by: Richard Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-ia64@vger.kernel.org
    Cc: microblaze-uclinux@itee.uq.edu.au
    Cc: linux-mips@linux-mips.org
    Cc: linux@lists.openrisc.net
    Cc: linux-parisc@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: linux-xtensa@linux-xtensa.org
    Cc: x86@kernel.org

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 22cfddb75566..bb1c3ab611bf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -26,6 +26,7 @@
 #include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <uapi/linux/audit.h>
+#include <asm/syscall.h>
 
 struct audit_sig_info {
 	uid_t		uid;
@@ -141,12 +142,12 @@ static inline void audit_free(struct task_struct *task)
 	if (unlikely(task->audit_context))
 		__audit_free(task);
 }
-static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
+static inline void audit_syscall_entry(int major, unsigned long a0,
 				       unsigned long a1, unsigned long a2,
 				       unsigned long a3)
 {
 	if (unlikely(current->audit_context))
-		__audit_syscall_entry(arch, major, a0, a1, a2, a3);
+		__audit_syscall_entry(syscall_get_arch(), major, a0, a1, a2, a3);
 }
 static inline void audit_syscall_exit(void *pt_regs)
 {
@@ -322,7 +323,7 @@ static inline int audit_alloc(struct task_struct *task)
 }
 static inline void audit_free(struct task_struct *task)
 { }
-static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
+static inline void audit_syscall_entry(int major, unsigned long a0,
 				       unsigned long a1, unsigned long a2,
 				       unsigned long a3)
 { }

commit 312103d64d0fcadb332899a2c84b357ddb18f4e3
Author: Chris Metcalf <cmetcalf@tilera.com>
Date:   Tue Mar 25 09:25:41 2014 -0400

    AUDIT: make audit_is_compat depend on CONFIG_AUDIT_COMPAT_GENERIC
    
    On systems with CONFIG_COMPAT we introduced the new requirement that
    audit_classify_compat_syscall() exists.  This wasn't true for everything
    (apparently not for "tilegx", which I know less that nothing about.)
    
    Instead of wrapping the preprocessor optomization with CONFIG_COMPAT we
    should have used the new CONFIG_AUDIT_COMPAT_GENERIC.  This patch uses
    that config option to make sure only arches which intend to implement
    this have the requirement.
    
    This works fine for tilegx according to Chris Metcalf
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 611a59a56f1a..22cfddb75566 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -102,7 +102,7 @@ struct filename;
 
 extern void audit_log_session_info(struct audit_buffer *ab);
 
-#ifdef CONFIG_COMPAT
+#ifdef CONFIG_AUDIT_COMPAT_GENERIC
 #define audit_is_compat(arch)  (!((arch) & __AUDIT_ARCH_64BIT))
 #else
 #define audit_is_compat(arch)  false

commit 356750e35e86485c464704c0a32c1d8dc77590d7
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Mar 24 12:13:48 2014 -0400

    audit: define audit_is_compat in kernel internal header
    
    We were exposing a function based on kernel config options to userspace.
    This is wrong.  Move it to the audit internal header.
    
    Suggested-by: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4b2983e25ce0..611a59a56f1a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -102,6 +102,12 @@ struct filename;
 
 extern void audit_log_session_info(struct audit_buffer *ab);
 
+#ifdef CONFIG_COMPAT
+#define audit_is_compat(arch)  (!((arch) & __AUDIT_ARCH_64BIT))
+#else
+#define audit_is_compat(arch)  false
+#endif
+
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */

commit 4b58841149dcaa500ceba1d5378ae70622fe4899
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Sat Mar 15 14:48:00 2014 +0900

    audit: Add generic compat syscall support
    
    lib/audit.c provides a generic function for auditing system calls.
    This patch extends it for compat syscall support on bi-architectures
    (32/64-bit) by adding lib/compat_audit.c.
    What is required to support this feature are:
     * add asm/unistd32.h for compat system call names
     * select CONFIG_AUDIT_ARCH_COMPAT_GENERIC
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index ec1464df4c60..4b2983e25ce0 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -79,6 +79,14 @@ extern int is_audit_feature_set(int which);
 extern int __init audit_register_class(int class, unsigned *list);
 extern int audit_classify_syscall(int abi, unsigned syscall);
 extern int audit_classify_arch(int arch);
+/* only for compat system calls */
+extern unsigned compat_write_class[];
+extern unsigned compat_read_class[];
+extern unsigned compat_dir_class[];
+extern unsigned compat_chattr_class[];
+extern unsigned compat_signal_class[];
+
+extern int __weak audit_classify_compat_syscall(int abi, unsigned syscall);
 
 /* audit_names->type values */
 #define	AUDIT_TYPE_UNKNOWN	0	/* we don't know yet */

commit 099dd235113700bbb476e572cd191ddb77b9af46
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 28 20:36:55 2014 -0800

    audit: Send replies in the proper network namespace.
    
    In perverse cases of file descriptor passing the current network
    namespace of a process and the network namespace of a socket used by
    that socket may differ.  Therefore use the network namespace of the
    appropiate socket to ensure replies always go to the appropiate
    socket.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index aa865a9a4c4f..ec1464df4c60 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -43,6 +43,7 @@ struct mq_attr;
 struct mqstat;
 struct audit_watch;
 struct audit_tree;
+struct sk_buff;
 
 struct audit_krule {
 	int			vers_ops;
@@ -463,7 +464,7 @@ extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
 extern int audit_rule_change(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
-extern int audit_list_rules_send(__u32 portid, int seq);
+extern int audit_list_rules_send(struct sk_buff *request_skb, int seq);
 
 extern u32 audit_enabled;
 #else /* CONFIG_AUDIT */

commit 3e1d0bb6224f019893d1c498cc3327559d183674
Author: Joe Perches <joe@perches.com>
Date:   Tue Jan 14 10:33:13 2014 -0800

    audit: Convert int limit uses to u32
    
    The equivalent uapi struct uses __u32 so make the kernel
    uses u32 too.
    
    This can prevent some oddities where the limit is
    logged/emitted as a negative value.
    
    Convert kstrtol to kstrtouint to disallow negative values.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    [eparis: do not remove static from audit_default declaration]

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 98fe8a26a601..aa865a9a4c4f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -465,7 +465,7 @@ extern int audit_rule_change(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
 extern int audit_list_rules_send(__u32 portid, int seq);
 
-extern int audit_enabled;
+extern u32 audit_enabled;
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)
 void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,

commit 06bdadd7634551cfe8ce071fe44d0311b3033d9e
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Mon Jan 13 13:33:09 2014 -0800

    audit: correct a type mismatch in audit_syscall_exit()
    
    audit_syscall_exit() saves a result of regs_return_value() in intermediate
    "int" variable and passes it to __audit_syscall_exit(), which expects its
    second argument as a "long" value.  This will result in truncating the
    value returned by a system call and making a wrong audit record.
    
    I don't know why gcc compiler doesn't complain about this, but anyway it
    causes a problem at runtime on arm64 (and probably most 64-bit archs).
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 697621975b8d..98fe8a26a601 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -137,7 +137,7 @@ static inline void audit_syscall_exit(void *pt_regs)
 {
 	if (unlikely(current->audit_context)) {
 		int success = is_syscall_success(pt_regs);
-		int return_code = regs_return_value(pt_regs);
+		long return_code = regs_return_value(pt_regs);
 
 		__audit_syscall_exit(success, return_code);
 	}

commit ce0d9f04699706843e8a494d12cf6c7663d478c7
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Nov 20 14:01:53 2013 -0500

    audit: refactor audit_receive_msg() to clarify AUDIT_*_RULE* cases
    
    audit_receive_msg() needlessly contained a fallthrough case that called
    audit_receive_filter(), containing no common code between the cases.  Separate
    them to make the logic clearer.  Refactor AUDIT_LIST_RULES, AUDIT_ADD_RULE,
    AUDIT_DEL_RULE cases to create audit_rule_change(), audit_list_rules_send()
    functions.  This should not functionally change the logic.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1690f956bff5..697621975b8d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -461,8 +461,10 @@ extern int		    audit_update_lsm_rules(void);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
-extern int  audit_receive_filter(int type, __u32 portid, int seq,
+extern int audit_rule_change(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
+extern int audit_list_rules_send(__u32 portid, int seq);
+
 extern int audit_enabled;
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)

commit b6cfee4cce25d8d2cc06c69f0de2b61d4b2249b3
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Nov 26 18:01:36 2013 -0500

    audit: fix incorrect type of sessionid
    
    The type of task->sessionid is unsigned int, the return
    type of audit_get_sessionid should be consistent with it.
    
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9185bfa1c78b..1690f956bff5 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -202,7 +202,7 @@ static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
 	return tsk->loginuid;
 }
 
-static inline int audit_get_sessionid(struct task_struct *tsk)
+static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
 {
 	return tsk->sessionid;
 }
@@ -359,7 +359,7 @@ static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
 {
 	return INVALID_UID;
 }
-static inline int audit_get_sessionid(struct task_struct *tsk)
+static inline unsigned int audit_get_sessionid(struct task_struct *tsk)
 {
 	return -1;
 }

commit f9441639e6319f0c0e12bd63fa2f58990af0a9d2
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Aug 14 11:32:45 2013 -0400

    audit: fix netlink portid naming and types
    
    Normally, netlink ports use the PID of the userspace process as the port ID.
    If the PID is already in use by a port, the kernel will allocate another port
    ID to avoid conflict.  Re-name all references to netlink ports from pid to
    portid to reflect this reality and avoid confusion with actual PIDs.  Ports
    use the __u32 type, so re-type all portids accordingly.
    
    (This patch is very similar to ebiederman's 5deadd69)
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c9a66c6f1307..9185bfa1c78b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -461,7 +461,7 @@ extern int		    audit_update_lsm_rules(void);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
-extern int  audit_receive_filter(int type, int pid, int seq,
+extern int  audit_receive_filter(int type, __u32 portid, int seq,
 				void *data, size_t datasz);
 extern int audit_enabled;
 #else /* CONFIG_AUDIT */

commit ca24a23ebca17d9d0f2afde4ee49cd810bccc8d7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 19 00:02:25 2013 -0700

    audit: Simplify and correct audit_log_capset
    
    - Always report the current process as capset now always only works on
      the current process.  This prevents reporting 0 or a random pid in
      a random pid namespace.
    
    - Don't bother to pass the pid as is available.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    (cherry picked from commit bcc85f0af31af123e32858069eb2ad8f39f90e67)
    (cherry picked from commit f911cac4556a7a23e0b3ea850233d13b32328692)
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    [eparis: fix build error when audit disabled]
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index a40641954c29..c9a66c6f1307 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -220,7 +220,7 @@ extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *new,
 				  const struct cred *old);
-extern void __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
+extern void __audit_log_capset(const struct cred *new, const struct cred *old);
 extern void __audit_mmap_fd(int fd, int flags);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
@@ -285,11 +285,11 @@ static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
 	return 0;
 }
 
-static inline void audit_log_capset(pid_t pid, const struct cred *new,
+static inline void audit_log_capset(const struct cred *new,
 				   const struct cred *old)
 {
 	if (unlikely(!audit_dummy_context()))
-		__audit_log_capset(pid, new, old);
+		__audit_log_capset(new, old);
 }
 
 static inline void audit_mmap_fd(int fd, int flags)
@@ -397,8 +397,8 @@ static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
 {
 	return 0;
 }
-static inline void audit_log_capset(pid_t pid, const struct cred *new,
-				   const struct cred *old)
+static inline void audit_log_capset(const struct cred *new,
+				    const struct cred *old)
 { }
 static inline void audit_mmap_fd(int fd, int flags)
 { }

commit 9410d228a4cf434305306746bb799fb7acdd8648
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Oct 30 18:05:24 2013 -0400

    audit: call audit_bprm() only once to add AUDIT_EXECVE information
    
    Move the audit_bprm() call from search_binary_handler() to exec_binprm().  This
    allows us to get rid of the mm member of struct audit_aux_data_execve since
    bprm->mm will equal current->mm.
    
    This also mitigates the issue that ->argc could be modified by the
    load_binary() call in search_binary_handler().
    
    audit_bprm() was being called to add an AUDIT_EXECVE record to the audit
    context every time search_binary_handler() was recursively called.  Only one
    reference is necessary.
    
    Reported-by: Oleg Nesterov <onestero@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    ---
    This patch is against 3.11, but was developed on Oleg's post-3.11 patches that
    introduce exec_binprm().

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 08b38bf13eb9..a40641954c29 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -238,11 +238,10 @@ static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_set_perm(qbytes, uid, gid, mode);
 }
-static inline int audit_bprm(struct linux_binprm *bprm)
+static inline void audit_bprm(struct linux_binprm *bprm)
 {
 	if (unlikely(!audit_dummy_context()))
 		__audit_bprm(bprm);
-	return 0;
 }
 static inline int audit_socketcall(int nargs, unsigned long *args)
 {
@@ -369,10 +368,8 @@ static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,
 					gid_t gid, umode_t mode)
 { }
-static inline int audit_bprm(struct linux_binprm *bprm)
-{
-	return 0;
-}
+static inline void audit_bprm(struct linux_binprm *bprm)
+{ }
 static inline int audit_socketcall(int nargs, unsigned long *args)
 {
 	return 0;

commit d9cfea91e97d5d19f9d69beaa844f5fe56a6adc6
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Wed Oct 30 17:56:13 2013 -0400

    audit: move audit_aux_data_execve contents into audit_context union
    
    audit_bprm() was being called to add an AUDIT_EXECVE record to the audit
    context every time search_binary_handler() was recursively called.  Only one
    reference is necessary, so just update it.  Move the the contents of
    audit_aux_data_execve into the union in audit_context, removing dependence on a
    kmalloc along the way.
    
    Reported-by: Oleg Nesterov <onestero@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 7b31bec9bccb..08b38bf13eb9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -209,7 +209,7 @@ static inline int audit_get_sessionid(struct task_struct *tsk)
 
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
-extern int __audit_bprm(struct linux_binprm *bprm);
+extern void __audit_bprm(struct linux_binprm *bprm);
 extern int __audit_socketcall(int nargs, unsigned long *args);
 extern int __audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
@@ -241,7 +241,7 @@ static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid
 static inline int audit_bprm(struct linux_binprm *bprm)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_bprm(bprm);
+		__audit_bprm(bprm);
 	return 0;
 }
 static inline int audit_socketcall(int nargs, unsigned long *args)

commit b0fed40214ce79ef70d97584ebdf13f89786da0e
Author: Eric Paris <eparis@redhat.com>
Date:   Wed May 22 12:54:49 2013 -0400

    audit: implement generic feature setting and retrieving
    
    The audit_status structure was not designed with extensibility in mind.
    Define a new AUDIT_SET_FEATURE message type which takes a new structure
    of bits where things can be enabled/disabled/locked one at a time.  This
    structure should be able to grow in the future while maintaining forward
    and backward compatibility (based loosly on the ideas from capabilities
    and prctl)
    
    This does not actually add any features, but is just infrastructure to
    allow new on/off types of audit system features.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 729a4d165bcc..7b31bec9bccb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -73,6 +73,8 @@ struct audit_field {
 	void				*lsm_rule;
 };
 
+extern int is_audit_feature_set(int which);
+
 extern int __init audit_register_class(int class, unsigned *list);
 extern int audit_classify_syscall(int abi, unsigned syscall);
 extern int audit_classify_arch(int arch);

commit 79f6530cb59e2a0af6953742a33cc29e98ca631c
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jul 8 15:59:36 2013 -0700

    audit: fix mq_open and mq_unlink to add the MQ root as a hidden parent audit_names record
    
    The old audit PATH records for mq_open looked like this:
    
      type=PATH msg=audit(1366282323.982:869): item=1 name=(null) inode=6777
      dev=00:0c mode=041777 ouid=0 ogid=0 rdev=00:00
      obj=system_u:object_r:tmpfs_t:s15:c0.c1023
      type=PATH msg=audit(1366282323.982:869): item=0 name="test_mq" inode=26732
      dev=00:0c mode=0100700 ouid=0 ogid=0 rdev=00:00
      obj=staff_u:object_r:user_tmpfs_t:s15:c0.c1023
    
    ...with the audit related changes that went into 3.7, they now look like this:
    
      type=PATH msg=audit(1366282236.776:3606): item=2 name=(null) inode=66655
      dev=00:0c mode=0100700 ouid=0 ogid=0 rdev=00:00
      obj=staff_u:object_r:user_tmpfs_t:s15:c0.c1023
      type=PATH msg=audit(1366282236.776:3606): item=1 name=(null) inode=6926
      dev=00:0c mode=041777 ouid=0 ogid=0 rdev=00:00
      obj=system_u:object_r:tmpfs_t:s15:c0.c1023
      type=PATH msg=audit(1366282236.776:3606): item=0 name="test_mq"
    
    Both of these look wrong to me.  As Steve Grubb pointed out:
    
     "What we need is 1 PATH record that identifies the MQ.  The other PATH
      records probably should not be there."
    
    Fix it to record the mq root as a parent, and flag it such that it
    should be hidden from view when the names are logged, since the root of
    the mq filesystem isn't terribly interesting.  With this change, we get
    a single PATH record that looks more like this:
    
      type=PATH msg=audit(1368021604.836:484): item=0 name="test_mq" inode=16914
      dev=00:0c mode=0100644 ouid=0 ogid=0 rdev=00:00
      obj=unconfined_u:object_r:user_tmpfs_t:s0
    
    In order to do this, a new audit_inode_parent_hidden() function is
    added.  If we do it this way, then we avoid having the existing callers
    of audit_inode needing to do any sort of flag conversion if auditing is
    inactive.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reported-by: Jiri Jaburek <jjaburek@redhat.com>
    Cc: Steve Grubb <sgrubb@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b20b03852f21..729a4d165bcc 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -103,8 +103,11 @@ extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern struct filename *__audit_reusename(const __user char *uptr);
 extern void __audit_getname(struct filename *name);
 extern void audit_putname(struct filename *name);
+
+#define AUDIT_INODE_PARENT	1	/* dentry represents the parent */
+#define AUDIT_INODE_HIDDEN	2	/* audit record should be hidden */
 extern void __audit_inode(struct filename *name, const struct dentry *dentry,
-				unsigned int parent);
+				unsigned int flags);
 extern void __audit_inode_child(const struct inode *parent,
 				const struct dentry *dentry,
 				const unsigned char type);
@@ -148,10 +151,22 @@ static inline void audit_getname(struct filename *name)
 	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
 }
-static inline void audit_inode(struct filename *name, const struct dentry *dentry,
+static inline void audit_inode(struct filename *name,
+				const struct dentry *dentry,
 				unsigned int parent) {
+	if (unlikely(!audit_dummy_context())) {
+		unsigned int flags = 0;
+		if (parent)
+			flags |= AUDIT_INODE_PARENT;
+		__audit_inode(name, dentry, flags);
+	}
+}
+static inline void audit_inode_parent_hidden(struct filename *name,
+						const struct dentry *dentry)
+{
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode(name, dentry, parent);
+		__audit_inode(name, dentry,
+				AUDIT_INODE_PARENT | AUDIT_INODE_HIDDEN);
 }
 static inline void audit_inode_child(const struct inode *parent,
 				     const struct dentry *dentry,
@@ -311,7 +326,7 @@ static inline void audit_putname(struct filename *name)
 { }
 static inline void __audit_inode(struct filename *name,
 					const struct dentry *dentry,
-					unsigned int parent)
+					unsigned int flags)
 { }
 static inline void __audit_inode_child(const struct inode *parent,
 					const struct dentry *dentry,
@@ -321,6 +336,9 @@ static inline void audit_inode(struct filename *name,
 				const struct dentry *dentry,
 				unsigned int parent)
 { }
+static inline void audit_inode_parent_hidden(struct filename *name,
+				const struct dentry *dentry)
+{ }
 static inline void audit_inode_child(const struct inode *parent,
 				     const struct dentry *dentry,
 				     const unsigned char type)

commit 780a7654cee8d61819512385e778e4827db4bfbc
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Apr 9 02:22:10 2013 -0700

    audit: Make testing for a valid loginuid explicit.
    
    audit rule additions containing "-F auid!=4294967295" were failing
    with EINVAL because of a regression caused by e1760bd.
    
    Apparently some userland audit rule sets want to know if loginuid uid
    has been set and are using a test for auid != 4294967295 to determine
    that.
    
    In practice that is a horrible way to ask if a value has been set,
    because it relies on subtle implementation details and will break
    every time the uid implementation in the kernel changes.
    
    So add a clean way to test if the audit loginuid has been set, and
    silently convert the old idiom to the cleaner and more comprehensible
    new idiom.
    
    Cc: <stable@vger.kernel.org> # 3.7
    Reported-By: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Tested-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 469d11755e46..b20b03852f21 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -391,6 +391,11 @@ static inline void audit_ptrace(struct task_struct *t)
 #define audit_signals 0
 #endif /* CONFIG_AUDITSYSCALL */
 
+static inline bool audit_loginuid_set(struct task_struct *tsk)
+{
+	return uid_valid(audit_get_loginuid(tsk));
+}
+
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */

commit b24a30a7305418ff138ff51776fc555ec57c011a
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 30 15:30:32 2013 -0400

    audit: fix event coverage of AUDIT_ANOM_LINK
    
    The userspace audit tools didn't like the existing formatting of the
    AUDIT_ANOM_LINK event. It needed to be expanded to emit an AUDIT_PATH
    event as well, so this implements the change. The bulk of the patch is
    moving code out of auditsc.c into audit.c and audit.h for general use.
    It expands audit_log_name to include an optional "struct path" argument
    for the simple case of just needing to report a pathname. This also
    makes
    audit_log_task_info available when syscall auditing is not enabled,
    since
    it is needed in either case for process details.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reported-by: Steve Grubb <sgrubb@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b76bfc8efc25..469d11755e46 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -190,8 +190,6 @@ static inline int audit_get_sessionid(struct task_struct *tsk)
 	return tsk->sessionid;
 }
 
-extern int audit_log_task_context(struct audit_buffer *ab);
-extern void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
 extern int __audit_bprm(struct linux_binprm *bprm);
@@ -346,13 +344,6 @@ static inline int audit_get_sessionid(struct task_struct *tsk)
 {
 	return -1;
 }
-static int void audit_log_task_context(struct audit_buffer *ab)
-{
-	return 0;
-}
-static inline void audit_log_task_info(struct audit_buffer *ab,
-				       struct task_struct *tsk)
-{ }
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 { }
 static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,
@@ -439,6 +430,10 @@ static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
 { }
 #endif
 
+extern int audit_log_task_context(struct audit_buffer *ab);
+extern void audit_log_task_info(struct audit_buffer *ab,
+				struct task_struct *tsk);
+
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
@@ -485,6 +480,13 @@ static inline void audit_log_link_denied(const char *string,
 { }
 static inline void audit_log_secctx(struct audit_buffer *ab, u32 secid)
 { }
+static inline int audit_log_task_context(struct audit_buffer *ab)
+{
+	return 0;
+}
+static inline void audit_log_task_info(struct audit_buffer *ab,
+				       struct task_struct *tsk)
+{ }
 #define audit_enabled 0
 #endif /* CONFIG_AUDIT */
 static inline void audit_log_string(struct audit_buffer *ab, const char *buf)

commit 4d3fb709b285ac885c40950a837edbfc90029c5f
Author: Eric Paris <eparis@localhost.localdomain>
Date:   Tue Apr 30 09:53:34 2013 -0400

    helper for some session id stuff

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e2dd9c124140..b76bfc8efc25 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -89,6 +89,8 @@ extern int audit_classify_arch(int arch);
 
 struct filename;
 
+extern void audit_log_session_info(struct audit_buffer *ab);
+
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */

commit b122c3767c1d89763b4babca062c3171a71ed97c
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 19 15:00:33 2013 -0400

    audit: use a consistent audit helper to log lsm information
    
    We have a number of places we were reimplementing the same code to write
    out lsm labels.  Just do it one darn place.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index a3a50cca1efb..e2dd9c124140 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -188,7 +188,7 @@ static inline int audit_get_sessionid(struct task_struct *tsk)
 	return tsk->sessionid;
 }
 
-extern void audit_log_task_context(struct audit_buffer *ab);
+extern int audit_log_task_context(struct audit_buffer *ab);
 extern void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
@@ -344,8 +344,10 @@ static inline int audit_get_sessionid(struct task_struct *tsk)
 {
 	return -1;
 }
-static inline void audit_log_task_context(struct audit_buffer *ab)
-{ }
+static int void audit_log_task_context(struct audit_buffer *ab)
+{
+	return 0;
+}
 static inline void audit_log_task_info(struct audit_buffer *ab,
 				       struct task_struct *tsk)
 { }

commit dc9eb698f441889f2d7926b1cc6f1e14f0787f00
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 19 13:23:09 2013 -0400

    audit: stop pushing loginid, uid, sessionid as arguments
    
    We always use current.  Stop pulling this when the skb comes in and
    pushing it around as arguments.  Just get it at the end when you need
    it.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b26d7f121ac5..a3a50cca1efb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -441,8 +441,7 @@ extern int		    audit_update_lsm_rules(void);
 extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int seq,
-				void *data, size_t datasz, kuid_t loginuid,
-				u32 sessionid, u32 sid);
+				void *data, size_t datasz);
 extern int audit_enabled;
 #else /* CONFIG_AUDIT */
 static inline __printf(4, 5)

commit 62062cf8a3a99a933efdac549da380f230dbe982
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Apr 16 13:08:43 2013 -0400

    audit: allow checking the type of audit message in the user filter
    
    When userspace sends messages to the audit system it includes a type.
    We want to be able to filter messages based on that type without have to
    do the all or nothing option currently available on the
    AUDIT_FILTER_TYPE filter list.  Instead we should be able to use the
    AUDIT_FILTER_USER filter list and just use the message type as one part
    of the matching decision.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8f92e1dea966..b26d7f121ac5 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -438,7 +438,7 @@ static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
-extern int audit_filter_user(void);
+extern int audit_filter_user(int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int seq,
 				void *data, size_t datasz, kuid_t loginuid,

commit 2950fa9d3291b90e9b7663b6a409ea37a97a5e35
Author: Chen Gang <gang.chen@asianux.com>
Date:   Sun Apr 7 16:55:23 2013 +0800

    kernel: audit: beautify code, for extern function, better to check its parameters by itself
    
      __audit_socketcall is an extern function.
      better to check its parameters by itself.
    
        also can return error code, when fail (find invalid parameters).
        also use macro instead of real hard code number
        also give related comments for it.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    [eparis: fix the return value when !CONFIG_AUDIT]
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 37464c592c92..8f92e1dea966 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -84,6 +84,9 @@ extern int audit_classify_arch(int arch);
 #define	AUDIT_TYPE_CHILD_DELETE 3	/* a child being deleted */
 #define	AUDIT_TYPE_CHILD_CREATE 4	/* a child being created */
 
+/* maximized args number that audit_socketcall can process */
+#define AUDITSC_ARGS		6
+
 struct filename;
 
 #ifdef CONFIG_AUDITSYSCALL
@@ -190,7 +193,7 @@ extern void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
 extern int __audit_bprm(struct linux_binprm *bprm);
-extern void __audit_socketcall(int nargs, unsigned long *args);
+extern int __audit_socketcall(int nargs, unsigned long *args);
 extern int __audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
 extern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);
@@ -224,10 +227,11 @@ static inline int audit_bprm(struct linux_binprm *bprm)
 		return __audit_bprm(bprm);
 	return 0;
 }
-static inline void audit_socketcall(int nargs, unsigned long *args)
+static inline int audit_socketcall(int nargs, unsigned long *args)
 {
 	if (unlikely(!audit_dummy_context()))
-		__audit_socketcall(nargs, args);
+		return __audit_socketcall(nargs, args);
+	return 0;
 }
 static inline int audit_sockaddr(int len, void *addr)
 {
@@ -354,8 +358,10 @@ static inline int audit_bprm(struct linux_binprm *bprm)
 {
 	return 0;
 }
-static inline void audit_socketcall(int nargs, unsigned long *args)
-{ }
+static inline int audit_socketcall(int nargs, unsigned long *args)
+{
+	return 0;
+}
 static inline void audit_fd_pair(int fd1, int fd2)
 { }
 static inline int audit_sockaddr(int len, void *addr)

commit cdee3904b4ce7c03d1013ed6dd704b43ae7fc2e9
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Jan 9 10:46:17 2013 +1100

    audit: Syscall rules are not applied to existing processes on non-x86
    
    Commit b05d8447e782 (audit: inline audit_syscall_entry to reduce
    burden on archs) changed audit_syscall_entry to check for a dummy
    context before calling __audit_syscall_entry. Unfortunately the dummy
    context state is maintained in __audit_syscall_entry so once set it
    never gets cleared, even if the audit rules change.
    
    As a result, if there are no auditing rules when a process starts
    then it will never be subject to any rules added later. x86 doesn't
    see this because it has an assembly fast path that calls directly into
    __audit_syscall_entry.
    
    I noticed this issue when working on audit performance optimisations.
    I wrote a set of simple test cases available at:
    
    http://ozlabs.org/~anton/junkcode/audit_tests.tar.gz
    
    02_new_rule.py fails without the patch and passes with it. The
    test case clears all rules, starts a process, adds a rule then
    verifies the process produces a syscall audit record.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Cc: <stable@kernel.org> # 3.3+
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5a6d718adf34..37464c592c92 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -120,7 +120,7 @@ static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
 				       unsigned long a1, unsigned long a2,
 				       unsigned long a3)
 {
-	if (unlikely(!audit_dummy_context()))
+	if (unlikely(current->audit_context))
 		__audit_syscall_entry(arch, major, a0, a1, a2, a3);
 }
 static inline void audit_syscall_exit(void *pt_regs)

commit c0a3a20b6c4b5229ef5d26fd9b1c4b1957632aa7
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Fri Jan 11 14:32:13 2013 -0800

    linux/audit.h: move ptrace.h include to kernel header
    
    While the kernel internals want pt_regs (and so it includes
    linux/ptrace.h), the user version of audit.h does not need it.  So move
    the include out of the uapi version.
    
    This avoids issues where people want the audit defines and userland
    ptrace api.  Including both the kernel ptrace and the userland ptrace
    headers can easily lead to failure.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9d5104d7aba9..5a6d718adf34 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -24,6 +24,7 @@
 #define _LINUX_AUDIT_H_
 
 #include <linux/sched.h>
+#include <linux/ptrace.h>
 #include <uapi/linux/audit.h>
 
 struct audit_sig_info {

commit 7b9205bd775afc4439ed86d617f9042ee9e76a71
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jan 11 14:32:05 2013 -0800

    audit: create explicit AUDIT_SECCOMP event type
    
    The seccomp path was using AUDIT_ANOM_ABEND from when seccomp mode 1
    could only kill a process.  While we still want to make sure an audit
    record is forced on a kill, this should use a separate record type since
    seccomp mode 2 introduces other behaviors.
    
    In the case of "handled" behaviors (process wasn't killed), only emit a
    record if the process is under inspection.  This change also fixes
    userspace examination of seccomp audit events, since it was considered
    malformed due to missing fields of the AUDIT_ANOM_ABEND event type.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Jeff Layton <jlayton@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Julien Tinnes <jln@google.com>
    Acked-by: Will Drewry <wad@chromium.org>
    Acked-by: Steve Grubb <sgrubb@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bce729afbcf9..9d5104d7aba9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -157,7 +157,8 @@ void audit_core_dumps(long signr);
 
 static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 {
-	if (unlikely(!audit_dummy_context()))
+	/* Force a record to be reported if a signal was delivered. */
+	if (signr || unlikely(!audit_dummy_context()))
 		__audit_seccomp(syscall, signr, code);
 }
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b889fa64b0e0..bce729afbcf9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -20,389 +20,11 @@
  * Written by Rickard E. (Rik) Faith <faith@redhat.com>
  *
  */
-
 #ifndef _LINUX_AUDIT_H_
 #define _LINUX_AUDIT_H_
 
-#include <linux/types.h>
-#include <linux/elf-em.h>
-#include <linux/ptrace.h>
-
-/* The netlink messages for the audit system is divided into blocks:
- * 1000 - 1099 are for commanding the audit system
- * 1100 - 1199 user space trusted application messages
- * 1200 - 1299 messages internal to the audit daemon
- * 1300 - 1399 audit event messages
- * 1400 - 1499 SE Linux use
- * 1500 - 1599 kernel LSPP events
- * 1600 - 1699 kernel crypto events
- * 1700 - 1799 kernel anomaly records
- * 1800 - 1899 kernel integrity events
- * 1900 - 1999 future kernel use
- * 2000 is for otherwise unclassified kernel audit messages (legacy)
- * 2001 - 2099 unused (kernel)
- * 2100 - 2199 user space anomaly records
- * 2200 - 2299 user space actions taken in response to anomalies
- * 2300 - 2399 user space generated LSPP events
- * 2400 - 2499 user space crypto events
- * 2500 - 2999 future user space (maybe integrity labels and related events)
- *
- * Messages from 1000-1199 are bi-directional. 1200-1299 & 2100 - 2999 are
- * exclusively user space. 1300-2099 is kernel --> user space 
- * communication.
- */
-#define AUDIT_GET		1000	/* Get status */
-#define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
-#define AUDIT_LIST		1002	/* List syscall rules -- deprecated */
-#define AUDIT_ADD		1003	/* Add syscall rule -- deprecated */
-#define AUDIT_DEL		1004	/* Delete syscall rule -- deprecated */
-#define AUDIT_USER		1005	/* Message from userspace -- deprecated */
-#define AUDIT_LOGIN		1006	/* Define the login id and information */
-#define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
-#define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
-#define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
-#define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
-#define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
-#define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
-#define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
-#define AUDIT_TRIM		1014	/* Trim junk from watched tree */
-#define AUDIT_MAKE_EQUIV	1015	/* Append to watched tree */
-#define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
-#define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
-
-#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
-#define AUDIT_USER_AVC		1107	/* We filter this differently */
-#define AUDIT_USER_TTY		1124	/* Non-ICANON TTY input meaning */
-#define AUDIT_LAST_USER_MSG	1199
-#define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
-#define AUDIT_LAST_USER_MSG2	2999
- 
-#define AUDIT_DAEMON_START      1200    /* Daemon startup record */
-#define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
-#define AUDIT_DAEMON_ABORT      1202    /* Daemon error stop record */
-#define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */
-
-#define AUDIT_SYSCALL		1300	/* Syscall event */
-/* #define AUDIT_FS_WATCH	1301	 * Deprecated */
-#define AUDIT_PATH		1302	/* Filename path information */
-#define AUDIT_IPC		1303	/* IPC record */
-#define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
-#define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
-#define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
-#define AUDIT_CWD		1307	/* Current working directory */
-#define AUDIT_EXECVE		1309	/* execve arguments */
-#define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
-#define AUDIT_MQ_OPEN		1312	/* POSIX MQ open record type */
-#define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
-#define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
-#define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
-#define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
-#define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
-#define AUDIT_OBJ_PID		1318	/* ptrace target */
-#define AUDIT_TTY		1319	/* Input on an administrative TTY */
-#define AUDIT_EOE		1320	/* End of multi-record event */
-#define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
-#define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
-#define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
-#define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
-#define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
-
-#define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
-#define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
-#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
-#define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
-#define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
-#define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
-#define AUDIT_MAC_UNLBL_ALLOW	1406	/* NetLabel: allow unlabeled traffic */
-#define AUDIT_MAC_CIPSOV4_ADD	1407	/* NetLabel: add CIPSOv4 DOI entry */
-#define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
-#define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
-#define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
-#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Not used */
-#define AUDIT_MAC_IPSEC_DELSA	1412	/* Not used  */
-#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
-#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
-#define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
-#define AUDIT_MAC_UNLBL_STCADD	1416	/* NetLabel: add a static label */
-#define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */
-
-#define AUDIT_FIRST_KERN_ANOM_MSG   1700
-#define AUDIT_LAST_KERN_ANOM_MSG    1799
-#define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
-#define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
-#define AUDIT_ANOM_LINK		    1702 /* Suspicious use of file links */
-#define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
-#define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
-#define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
-#define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
-#define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
-#define AUDIT_INTEGRITY_RULE	    1805 /* policy rule */
-
-#define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
-
-/* Rule flags */
-#define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
-#define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
-#define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
-#define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
-#define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
-#define AUDIT_FILTER_TYPE	0x05	/* Apply rule at audit_log_start */
-
-#define AUDIT_NR_FILTERS	6
-
-#define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */
-
-/* Rule actions */
-#define AUDIT_NEVER    0	/* Do not build context if rule matches */
-#define AUDIT_POSSIBLE 1	/* Build context if rule matches  */
-#define AUDIT_ALWAYS   2	/* Generate audit record if rule matches */
-
-/* Rule structure sizes -- if these change, different AUDIT_ADD and
- * AUDIT_LIST commands must be implemented. */
-#define AUDIT_MAX_FIELDS   64
-#define AUDIT_MAX_KEY_LEN  256
-#define AUDIT_BITMASK_SIZE 64
-#define AUDIT_WORD(nr) ((__u32)((nr)/32))
-#define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
-
-#define AUDIT_SYSCALL_CLASSES 16
-#define AUDIT_CLASS_DIR_WRITE 0
-#define AUDIT_CLASS_DIR_WRITE_32 1
-#define AUDIT_CLASS_CHATTR 2
-#define AUDIT_CLASS_CHATTR_32 3
-#define AUDIT_CLASS_READ 4
-#define AUDIT_CLASS_READ_32 5
-#define AUDIT_CLASS_WRITE 6
-#define AUDIT_CLASS_WRITE_32 7
-#define AUDIT_CLASS_SIGNAL 8
-#define AUDIT_CLASS_SIGNAL_32 9
-
-/* This bitmask is used to validate user input.  It represents all bits that
- * are currently used in an audit field constant understood by the kernel.
- * If you are adding a new #define AUDIT_<whatever>, please ensure that
- * AUDIT_UNUSED_BITS is updated if need be. */
-#define AUDIT_UNUSED_BITS	0x07FFFC00
-
-/* AUDIT_FIELD_COMPARE rule list */
-#define AUDIT_COMPARE_UID_TO_OBJ_UID	1
-#define AUDIT_COMPARE_GID_TO_OBJ_GID	2
-#define AUDIT_COMPARE_EUID_TO_OBJ_UID	3
-#define AUDIT_COMPARE_EGID_TO_OBJ_GID	4
-#define AUDIT_COMPARE_AUID_TO_OBJ_UID	5
-#define AUDIT_COMPARE_SUID_TO_OBJ_UID	6
-#define AUDIT_COMPARE_SGID_TO_OBJ_GID	7
-#define AUDIT_COMPARE_FSUID_TO_OBJ_UID	8
-#define AUDIT_COMPARE_FSGID_TO_OBJ_GID	9
-
-#define AUDIT_COMPARE_UID_TO_AUID	10
-#define AUDIT_COMPARE_UID_TO_EUID	11
-#define AUDIT_COMPARE_UID_TO_FSUID	12
-#define AUDIT_COMPARE_UID_TO_SUID	13
-
-#define AUDIT_COMPARE_AUID_TO_FSUID	14
-#define AUDIT_COMPARE_AUID_TO_SUID	15
-#define AUDIT_COMPARE_AUID_TO_EUID	16
-
-#define AUDIT_COMPARE_EUID_TO_SUID	17
-#define AUDIT_COMPARE_EUID_TO_FSUID	18
-
-#define AUDIT_COMPARE_SUID_TO_FSUID	19
-
-#define AUDIT_COMPARE_GID_TO_EGID	20
-#define AUDIT_COMPARE_GID_TO_FSGID	21
-#define AUDIT_COMPARE_GID_TO_SGID	22
-
-#define AUDIT_COMPARE_EGID_TO_FSGID	23
-#define AUDIT_COMPARE_EGID_TO_SGID	24
-#define AUDIT_COMPARE_SGID_TO_FSGID	25
-
-#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_SGID_TO_FSGID
-
-/* Rule fields */
-				/* These are useful when checking the
-				 * task structure at task creation time
-				 * (AUDIT_PER_TASK).  */
-#define AUDIT_PID	0
-#define AUDIT_UID	1
-#define AUDIT_EUID	2
-#define AUDIT_SUID	3
-#define AUDIT_FSUID	4
-#define AUDIT_GID	5
-#define AUDIT_EGID	6
-#define AUDIT_SGID	7
-#define AUDIT_FSGID	8
-#define AUDIT_LOGINUID	9
-#define AUDIT_PERS	10
-#define AUDIT_ARCH	11
-#define AUDIT_MSGTYPE	12
-#define AUDIT_SUBJ_USER	13	/* security label user */
-#define AUDIT_SUBJ_ROLE	14	/* security label role */
-#define AUDIT_SUBJ_TYPE	15	/* security label type */
-#define AUDIT_SUBJ_SEN	16	/* security label sensitivity label */
-#define AUDIT_SUBJ_CLR	17	/* security label clearance label */
-#define AUDIT_PPID	18
-#define AUDIT_OBJ_USER	19
-#define AUDIT_OBJ_ROLE	20
-#define AUDIT_OBJ_TYPE	21
-#define AUDIT_OBJ_LEV_LOW	22
-#define AUDIT_OBJ_LEV_HIGH	23
-
-				/* These are ONLY useful when checking
-				 * at syscall exit time (AUDIT_AT_EXIT). */
-#define AUDIT_DEVMAJOR	100
-#define AUDIT_DEVMINOR	101
-#define AUDIT_INODE	102
-#define AUDIT_EXIT	103
-#define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
-#define AUDIT_WATCH	105
-#define AUDIT_PERM	106
-#define AUDIT_DIR	107
-#define AUDIT_FILETYPE	108
-#define AUDIT_OBJ_UID	109
-#define AUDIT_OBJ_GID	110
-#define AUDIT_FIELD_COMPARE	111
-
-#define AUDIT_ARG0      200
-#define AUDIT_ARG1      (AUDIT_ARG0+1)
-#define AUDIT_ARG2      (AUDIT_ARG0+2)
-#define AUDIT_ARG3      (AUDIT_ARG0+3)
-
-#define AUDIT_FILTERKEY	210
-
-#define AUDIT_NEGATE			0x80000000
-
-/* These are the supported operators.
- *	4  2  1  8
- *	=  >  <  ?
- *	----------
- *	0  0  0	 0	00	nonsense
- *	0  0  0	 1	08	&  bit mask
- *	0  0  1	 0	10	<
- *	0  1  0	 0	20	>
- *	0  1  1	 0	30	!=
- *	1  0  0	 0	40	=
- *	1  0  0	 1	48	&=  bit test
- *	1  0  1	 0	50	<=
- *	1  1  0	 0	60	>=
- *	1  1  1	 1	78	all operators
- */
-#define AUDIT_BIT_MASK			0x08000000
-#define AUDIT_LESS_THAN			0x10000000
-#define AUDIT_GREATER_THAN		0x20000000
-#define AUDIT_NOT_EQUAL			0x30000000
-#define AUDIT_EQUAL			0x40000000
-#define AUDIT_BIT_TEST			(AUDIT_BIT_MASK|AUDIT_EQUAL)
-#define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
-#define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
-#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)
-
-enum {
-	Audit_equal,
-	Audit_not_equal,
-	Audit_bitmask,
-	Audit_bittest,
-	Audit_lt,
-	Audit_gt,
-	Audit_le,
-	Audit_ge,
-	Audit_bad
-};
-
-/* Status symbols */
-				/* Mask values */
-#define AUDIT_STATUS_ENABLED		0x0001
-#define AUDIT_STATUS_FAILURE		0x0002
-#define AUDIT_STATUS_PID		0x0004
-#define AUDIT_STATUS_RATE_LIMIT		0x0008
-#define AUDIT_STATUS_BACKLOG_LIMIT	0x0010
-				/* Failure-to-log actions */
-#define AUDIT_FAIL_SILENT	0
-#define AUDIT_FAIL_PRINTK	1
-#define AUDIT_FAIL_PANIC	2
-
-/* distinguish syscall tables */
-#define __AUDIT_ARCH_64BIT 0x80000000
-#define __AUDIT_ARCH_LE	   0x40000000
-#define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_ARMEB	(EM_ARM)
-#define AUDIT_ARCH_CRIS		(EM_CRIS|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_FRV		(EM_FRV)
-#define AUDIT_ARCH_H8300	(EM_H8_300)
-#define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_M32R		(EM_M32R)
-#define AUDIT_ARCH_M68K		(EM_68K)
-#define AUDIT_ARCH_MIPS		(EM_MIPS)
-#define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_OPENRISC	(EM_OPENRISC)
-#define AUDIT_ARCH_PARISC	(EM_PARISC)
-#define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_PPC		(EM_PPC)
-#define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_S390		(EM_S390)
-#define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_SH		(EM_SH)
-#define AUDIT_ARCH_SHEL		(EM_SH|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-#define AUDIT_ARCH_SPARC	(EM_SPARC)
-#define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
-
-#define AUDIT_PERM_EXEC		1
-#define AUDIT_PERM_WRITE	2
-#define AUDIT_PERM_READ		4
-#define AUDIT_PERM_ATTR		8
-
-struct audit_status {
-	__u32		mask;		/* Bit mask for valid entries */
-	__u32		enabled;	/* 1 = enabled, 0 = disabled */
-	__u32		failure;	/* Failure-to-log action */
-	__u32		pid;		/* pid of auditd process */
-	__u32		rate_limit;	/* messages rate limit (per second) */
-	__u32		backlog_limit;	/* waiting messages limit */
-	__u32		lost;		/* messages lost */
-	__u32		backlog;	/* messages waiting in queue */
-};
-
-struct audit_tty_status {
-	__u32		enabled; /* 1 = enabled, 0 = disabled */
-};
-
-/* audit_rule_data supports filter rules with both integer and string
- * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
- * AUDIT_LIST_RULES requests.
- */
-struct audit_rule_data {
-	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
-	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
-	__u32		field_count;
-	__u32		mask[AUDIT_BITMASK_SIZE]; /* syscall(s) affected */
-	__u32		fields[AUDIT_MAX_FIELDS];
-	__u32		values[AUDIT_MAX_FIELDS];
-	__u32		fieldflags[AUDIT_MAX_FIELDS];
-	__u32		buflen;	/* total length of string fields */
-	char		buf[0];	/* string fields buffer */
-};
-
-/* audit_rule is supported to maintain backward compatibility with
- * userspace.  It supports integer fields only and corresponds to
- * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
- */
-struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
-	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
-	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
-	__u32		field_count;
-	__u32		mask[AUDIT_BITMASK_SIZE];
-	__u32		fields[AUDIT_MAX_FIELDS];
-	__u32		values[AUDIT_MAX_FIELDS];
-};
-
-#ifdef __KERNEL__
 #include <linux/sched.h>
+#include <uapi/linux/audit.h>
 
 struct audit_sig_info {
 	uid_t		uid;
@@ -860,4 +482,3 @@ static inline void audit_log_string(struct audit_buffer *ab, const char *buf)
 }
 
 #endif
-#endif

commit 18a022de47bc11ee20d7d0f4dd72d42d2cfdc51c
Merge: 02a650e2820e d23b5799b608
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 13 11:25:41 2012 +0900

    Merge tag 'for-3.7' of git://openrisc.net/jonas/linux
    
    Pull OpenRISC updates from Jonas Bonn:
     "Fixups for some corner cases, build issues, and some obvious bugs in
      IRQ handling.  No major changes."
    
    * tag 'for-3.7' of git://openrisc.net/jonas/linux:
      openrisc: mask interrupts in irq_mask_ack function
      openrisc: fix typos in comments and warnings
      openrisc: PIC should act on domain-local irqs
      openrisc: Make cpu_relax() invoke barrier()
      audit: define AUDIT_ARCH_OPENRISC
      openrisc: delay: fix handling of counter overflow
      openrisc: delay: fix loops calculation for __const_udelay

commit adb5c2473d3f91526c79db972aafb20a56d3fbb3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 16:43:13 2012 -0400

    audit: make audit_inode take struct filename
    
    Keep a pointer to the audit_names "slot" in struct filename.
    
    Have all of the audit_inode callers pass a struct filename ponter to
    audit_inode instead of a string pointer. If the aname field is already
    populated, then we can skip walking the list altogether and just use it
    directly.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d5d7952ab7d8..e5884f950b4b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -474,7 +474,7 @@ extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern struct filename *__audit_reusename(const __user char *uptr);
 extern void __audit_getname(struct filename *name);
 extern void audit_putname(struct filename *name);
-extern void __audit_inode(const char *name, const struct dentry *dentry,
+extern void __audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int parent);
 extern void __audit_inode_child(const struct inode *parent,
 				const struct dentry *dentry,
@@ -519,7 +519,7 @@ static inline void audit_getname(struct filename *name)
 	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
 }
-static inline void audit_inode(const char *name, const struct dentry *dentry,
+static inline void audit_inode(struct filename *name, const struct dentry *dentry,
 				unsigned int parent) {
 	if (unlikely(!audit_dummy_context()))
 		__audit_inode(name, dentry, parent);
@@ -680,14 +680,16 @@ static inline void audit_getname(struct filename *name)
 { }
 static inline void audit_putname(struct filename *name)
 { }
-static inline void __audit_inode(const char *name, const struct dentry *dentry,
+static inline void __audit_inode(struct filename *name,
+					const struct dentry *dentry,
 					unsigned int parent)
 { }
 static inline void __audit_inode_child(const struct inode *parent,
 					const struct dentry *dentry,
 					const unsigned char type)
 { }
-static inline void audit_inode(const char *name, const struct dentry *dentry,
+static inline void audit_inode(struct filename *name,
+				const struct dentry *dentry,
 				unsigned int parent)
 { }
 static inline void audit_inode_child(const struct inode *parent,

commit 7ac86265dc8f665cc49d6e60a125e608cd2fca14
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:28 2012 -0400

    audit: allow audit code to satisfy getname requests from its names_list
    
    Currently, if we call getname() on a userland string more than once,
    we'll get multiple copies of the string and multiple audit_names
    records.
    
    Add a function that will allow the audit_names code to satisfy getname
    requests using info from the audit_names list, avoiding a new allocation
    and audit_names records.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 94d29164803f..d5d7952ab7d8 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -471,6 +471,7 @@ extern void __audit_syscall_entry(int arch,
 				  int major, unsigned long a0, unsigned long a1,
 				  unsigned long a2, unsigned long a3);
 extern void __audit_syscall_exit(int ret_success, long ret_value);
+extern struct filename *__audit_reusename(const __user char *uptr);
 extern void __audit_getname(struct filename *name);
 extern void audit_putname(struct filename *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry,
@@ -507,6 +508,12 @@ static inline void audit_syscall_exit(void *pt_regs)
 		__audit_syscall_exit(success, return_code);
 	}
 }
+static inline struct filename *audit_reusename(const __user char *name)
+{
+	if (unlikely(!audit_dummy_context()))
+		return __audit_reusename(name);
+	return NULL;
+}
 static inline void audit_getname(struct filename *name)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -665,6 +672,10 @@ static inline int audit_dummy_context(void)
 {
 	return 1;
 }
+static inline struct filename *audit_reusename(const __user char *name)
+{
+	return NULL;
+}
 static inline void audit_getname(struct filename *name)
 { }
 static inline void audit_putname(struct filename *name)

commit 91a27b2a756784714e924e5e854b919273082d26
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:28 2012 -0400

    vfs: define struct filename and have getname() return it
    
    getname() is intended to copy pathname strings from userspace into a
    kernel buffer. The result is just a string in kernel space. It would
    however be quite helpful to be able to attach some ancillary info to
    the string.
    
    For instance, we could attach some audit-related info to reduce the
    amount of audit-related processing needed. When auditing is enabled,
    we could also call getname() on the string more than once and not
    need to recopy it from userspace.
    
    This patchset converts the getname()/putname() interfaces to return
    a struct instead of a string. For now, the struct just tracks the
    string in kernel space and the original userland pointer for it.
    
    Later, we'll add other information to the struct as it becomes
    convenient.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3df643d1ac5b..94d29164803f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -460,6 +460,8 @@ extern int audit_classify_arch(int arch);
 #define	AUDIT_TYPE_CHILD_DELETE 3	/* a child being deleted */
 #define	AUDIT_TYPE_CHILD_CREATE 4	/* a child being created */
 
+struct filename;
+
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */
@@ -469,8 +471,8 @@ extern void __audit_syscall_entry(int arch,
 				  int major, unsigned long a0, unsigned long a1,
 				  unsigned long a2, unsigned long a3);
 extern void __audit_syscall_exit(int ret_success, long ret_value);
-extern void __audit_getname(const char *name);
-extern void audit_putname(const char *name);
+extern void __audit_getname(struct filename *name);
+extern void audit_putname(struct filename *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry,
 				unsigned int parent);
 extern void __audit_inode_child(const struct inode *parent,
@@ -505,7 +507,7 @@ static inline void audit_syscall_exit(void *pt_regs)
 		__audit_syscall_exit(success, return_code);
 	}
 }
-static inline void audit_getname(const char *name)
+static inline void audit_getname(struct filename *name)
 {
 	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
@@ -663,9 +665,9 @@ static inline int audit_dummy_context(void)
 {
 	return 1;
 }
-static inline void audit_getname(const char *name)
+static inline void audit_getname(struct filename *name)
 { }
-static inline void audit_putname(const char *name)
+static inline void audit_putname(struct filename *name)
 { }
 static inline void __audit_inode(const char *name, const struct dentry *dentry,
 					unsigned int parent)

commit 4fa6b5ecbf092c6ee752ece8a55d71f663d23254
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:25 2012 -0400

    audit: overhaul __audit_inode_child to accomodate retrying
    
    In order to accomodate retrying path-based syscalls, we need to add a
    new "type" argument to audit_inode_child. This will tell us whether
    we're looking for a child entry that represents a create or a delete.
    
    If we find a parent, don't automatically assume that we need to create a
    new entry. Instead, use the information we have to try to find an
    existing entry first. Update it if one is found and create a new one if
    not.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b11f517dce04..3df643d1ac5b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -457,6 +457,8 @@ extern int audit_classify_arch(int arch);
 #define	AUDIT_TYPE_UNKNOWN	0	/* we don't know yet */
 #define	AUDIT_TYPE_NORMAL	1	/* a "normal" audit record */
 #define	AUDIT_TYPE_PARENT	2	/* a parent audit record */
+#define	AUDIT_TYPE_CHILD_DELETE 3	/* a child being deleted */
+#define	AUDIT_TYPE_CHILD_CREATE 4	/* a child being created */
 
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
@@ -472,7 +474,8 @@ extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry,
 				unsigned int parent);
 extern void __audit_inode_child(const struct inode *parent,
-				const struct dentry *dentry);
+				const struct dentry *dentry,
+				const unsigned char type);
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
 extern void __audit_ptrace(struct task_struct *t);
 
@@ -513,9 +516,10 @@ static inline void audit_inode(const char *name, const struct dentry *dentry,
 		__audit_inode(name, dentry, parent);
 }
 static inline void audit_inode_child(const struct inode *parent,
-				     const struct dentry *dentry) {
+				     const struct dentry *dentry,
+				     const unsigned char type) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode_child(parent, dentry);
+		__audit_inode_child(parent, dentry, type);
 }
 void audit_core_dumps(long signr);
 
@@ -667,13 +671,15 @@ static inline void __audit_inode(const char *name, const struct dentry *dentry,
 					unsigned int parent)
 { }
 static inline void __audit_inode_child(const struct inode *parent,
-					const struct dentry *dentry)
+					const struct dentry *dentry,
+					const unsigned char type)
 { }
 static inline void audit_inode(const char *name, const struct dentry *dentry,
 				unsigned int parent)
 { }
 static inline void audit_inode_child(const struct inode *parent,
-				     const struct dentry *dentry)
+				     const struct dentry *dentry,
+				     const unsigned char type)
 { }
 static inline void audit_core_dumps(long signr)
 { }

commit bfcec7087458812f575d9022b2d151641f34ee84
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:23 2012 -0400

    audit: set the name_len in audit_inode for parent lookups
    
    Currently, this gets set mostly by happenstance when we call into
    audit_inode_child. While that might be a little more efficient, it seems
    wrong. If the syscall ends up failing before audit_inode_child ever gets
    called, then you'll have an audit_names record that shows the full path
    but has the parent inode info attached.
    
    Fix this by passing in a parent flag when we call audit_inode that gets
    set to the value of LOOKUP_PARENT. We can then fix up the pathname for
    the audit entry correctly from the get-go.
    
    While we're at it, clean up the no-op macro for audit_inode in the
    !CONFIG_AUDITSYSCALL case.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 26408934ef2d..b11f517dce04 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -456,6 +456,7 @@ extern int audit_classify_arch(int arch);
 /* audit_names->type values */
 #define	AUDIT_TYPE_UNKNOWN	0	/* we don't know yet */
 #define	AUDIT_TYPE_NORMAL	1	/* a "normal" audit record */
+#define	AUDIT_TYPE_PARENT	2	/* a parent audit record */
 
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
@@ -468,7 +469,8 @@ extern void __audit_syscall_entry(int arch,
 extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
-extern void __audit_inode(const char *name, const struct dentry *dentry);
+extern void __audit_inode(const char *name, const struct dentry *dentry,
+				unsigned int parent);
 extern void __audit_inode_child(const struct inode *parent,
 				const struct dentry *dentry);
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
@@ -505,9 +507,10 @@ static inline void audit_getname(const char *name)
 	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
 }
-static inline void audit_inode(const char *name, const struct dentry *dentry) {
+static inline void audit_inode(const char *name, const struct dentry *dentry,
+				unsigned int parent) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode(name, dentry);
+		__audit_inode(name, dentry, parent);
 }
 static inline void audit_inode_child(const struct inode *parent,
 				     const struct dentry *dentry) {
@@ -660,12 +663,14 @@ static inline void audit_getname(const char *name)
 { }
 static inline void audit_putname(const char *name)
 { }
-static inline void __audit_inode(const char *name, const struct dentry *dentry)
+static inline void __audit_inode(const char *name, const struct dentry *dentry,
+					unsigned int parent)
 { }
 static inline void __audit_inode_child(const struct inode *parent,
 					const struct dentry *dentry)
 { }
-static inline void audit_inode(const char *name, const struct dentry *dentry)
+static inline void audit_inode(const char *name, const struct dentry *dentry,
+				unsigned int parent)
 { }
 static inline void audit_inode_child(const struct inode *parent,
 				     const struct dentry *dentry)

commit 78e2e802a8519031e5858595070b39713e26340d
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:22 2012 -0400

    audit: add a new "type" field to audit_names struct
    
    For now, we just have two possibilities:
    
    UNKNOWN: for a new audit_names record that we don't know anything about yet
    NORMAL: for everything else
    
    In later patches, we'll add other types so we can distinguish and update
    records created under different circumstances.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8c66fc248c75..26408934ef2d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -452,6 +452,11 @@ struct audit_field {
 extern int __init audit_register_class(int class, unsigned *list);
 extern int audit_classify_syscall(int abi, unsigned syscall);
 extern int audit_classify_arch(int arch);
+
+/* audit_names->type values */
+#define	AUDIT_TYPE_UNKNOWN	0	/* we don't know yet */
+#define	AUDIT_TYPE_NORMAL	1	/* a "normal" audit record */
+
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */

commit c43a25abba97c7d87131e71db6be24b24d7791a5
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:21 2012 -0400

    audit: reverse arguments to audit_inode_child
    
    Most of the callers get called with an inode and dentry in the reverse
    order. The compiler then has to reshuffle the arg registers and/or
    stack in order to pass them on to audit_inode_child.
    
    Reverse those arguments for a micro-optimization.
    
    Reported-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2c83e5f7edb1..8c66fc248c75 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -464,8 +464,8 @@ extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry);
-extern void __audit_inode_child(const struct dentry *dentry,
-				const struct inode *parent);
+extern void __audit_inode_child(const struct inode *parent,
+				const struct dentry *dentry);
 extern void __audit_seccomp(unsigned long syscall, long signr, int code);
 extern void __audit_ptrace(struct task_struct *t);
 
@@ -504,10 +504,10 @@ static inline void audit_inode(const char *name, const struct dentry *dentry) {
 	if (unlikely(!audit_dummy_context()))
 		__audit_inode(name, dentry);
 }
-static inline void audit_inode_child(const struct dentry *dentry,
-				     const struct inode *parent) {
+static inline void audit_inode_child(const struct inode *parent,
+				     const struct dentry *dentry) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode_child(dentry, parent);
+		__audit_inode_child(parent, dentry);
 }
 void audit_core_dumps(long signr);
 
@@ -657,13 +657,13 @@ static inline void audit_putname(const char *name)
 { }
 static inline void __audit_inode(const char *name, const struct dentry *dentry)
 { }
-static inline void __audit_inode_child(const struct dentry *dentry,
-					const struct inode *parent)
+static inline void __audit_inode_child(const struct inode *parent,
+					const struct dentry *dentry)
 { }
 static inline void audit_inode(const char *name, const struct dentry *dentry)
 { }
-static inline void audit_inode_child(const struct dentry *dentry,
-				     const struct inode *parent)
+static inline void audit_inode_child(const struct inode *parent,
+				     const struct dentry *dentry)
 { }
 static inline void audit_core_dumps(long signr)
 { }

commit 9321d526dd731588f09508af48de50041785a26a
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Oct 4 17:11:11 2012 -0700

    audit.h: replace defines with C stubs
    
    Replace the #defines used when CONFIG_AUDIT or CONFIG_AUDIT_SYSCALLS are
    disabled so we get type checking during those builds.
    
    Suggested-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e7c836d961ea..2c83e5f7edb1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -527,9 +527,18 @@ static inline void audit_ptrace(struct task_struct *t)
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
-extern int  audit_set_loginuid(kuid_t loginuid);
-#define audit_get_loginuid(t) ((t)->loginuid)
-#define audit_get_sessionid(t) ((t)->sessionid)
+extern int audit_set_loginuid(kuid_t loginuid);
+
+static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
+{
+	return tsk->loginuid;
+}
+
+static inline int audit_get_sessionid(struct task_struct *tsk)
+{
+	return tsk->sessionid;
+}
+
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
@@ -626,38 +635,101 @@ static inline void audit_mmap_fd(int fd, int flags)
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
-#define audit_alloc(t) ({ 0; })
-#define audit_free(t) do { ; } while (0)
-#define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)
-#define audit_syscall_exit(r) do { ; } while (0)
-#define audit_dummy_context() 1
-#define audit_getname(n) do { ; } while (0)
-#define audit_putname(n) do { ; } while (0)
-#define __audit_inode(n,d) do { ; } while (0)
-#define __audit_inode_child(i,p) do { ; } while (0)
-#define audit_inode(n,d) do { (void)(d); } while (0)
-#define audit_inode_child(i,p) do { ; } while (0)
-#define audit_core_dumps(i) do { ; } while (0)
-#define audit_seccomp(i,s,c) do { ; } while (0)
-#define auditsc_get_stamp(c,t,s) (0)
-#define audit_get_loginuid(t) (INVALID_UID)
-#define audit_get_sessionid(t) (-1)
-#define audit_log_task_context(b) do { ; } while (0)
-#define audit_log_task_info(b, t) do { ; } while (0)
-#define audit_ipc_obj(i) ((void)0)
-#define audit_ipc_set_perm(q,u,g,m) ((void)0)
-#define audit_bprm(p) ({ 0; })
-#define audit_socketcall(n,a) ((void)0)
-#define audit_fd_pair(n,a) ((void)0)
-#define audit_sockaddr(len, addr) ({ 0; })
-#define audit_mq_open(o,m,a) ((void)0)
-#define audit_mq_sendrecv(d,l,p,t) ((void)0)
-#define audit_mq_notify(d,n) ((void)0)
-#define audit_mq_getsetattr(d,s) ((void)0)
-#define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
-#define audit_log_capset(pid, ncr, ocr) ((void)0)
-#define audit_mmap_fd(fd, flags) ((void)0)
-#define audit_ptrace(t) ((void)0)
+static inline int audit_alloc(struct task_struct *task)
+{
+	return 0;
+}
+static inline void audit_free(struct task_struct *task)
+{ }
+static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
+				       unsigned long a1, unsigned long a2,
+				       unsigned long a3)
+{ }
+static inline void audit_syscall_exit(void *pt_regs)
+{ }
+static inline int audit_dummy_context(void)
+{
+	return 1;
+}
+static inline void audit_getname(const char *name)
+{ }
+static inline void audit_putname(const char *name)
+{ }
+static inline void __audit_inode(const char *name, const struct dentry *dentry)
+{ }
+static inline void __audit_inode_child(const struct dentry *dentry,
+					const struct inode *parent)
+{ }
+static inline void audit_inode(const char *name, const struct dentry *dentry)
+{ }
+static inline void audit_inode_child(const struct dentry *dentry,
+				     const struct inode *parent)
+{ }
+static inline void audit_core_dumps(long signr)
+{ }
+static inline void __audit_seccomp(unsigned long syscall, long signr, int code)
+{ }
+static inline void audit_seccomp(unsigned long syscall, long signr, int code)
+{ }
+static inline int auditsc_get_stamp(struct audit_context *ctx,
+			      struct timespec *t, unsigned int *serial)
+{
+	return 0;
+}
+static inline kuid_t audit_get_loginuid(struct task_struct *tsk)
+{
+	return INVALID_UID;
+}
+static inline int audit_get_sessionid(struct task_struct *tsk)
+{
+	return -1;
+}
+static inline void audit_log_task_context(struct audit_buffer *ab)
+{ }
+static inline void audit_log_task_info(struct audit_buffer *ab,
+				       struct task_struct *tsk)
+{ }
+static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
+{ }
+static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid,
+					gid_t gid, umode_t mode)
+{ }
+static inline int audit_bprm(struct linux_binprm *bprm)
+{
+	return 0;
+}
+static inline void audit_socketcall(int nargs, unsigned long *args)
+{ }
+static inline void audit_fd_pair(int fd1, int fd2)
+{ }
+static inline int audit_sockaddr(int len, void *addr)
+{
+	return 0;
+}
+static inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
+{ }
+static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len,
+				     unsigned int msg_prio,
+				     const struct timespec *abs_timeout)
+{ }
+static inline void audit_mq_notify(mqd_t mqdes,
+				   const struct sigevent *notification)
+{ }
+static inline void audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
+{ }
+static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
+				       const struct cred *new,
+				       const struct cred *old)
+{
+	return 0;
+}
+static inline void audit_log_capset(pid_t pid, const struct cred *new,
+				   const struct cred *old)
+{ }
+static inline void audit_mmap_fd(int fd, int flags)
+{ }
+static inline void audit_ptrace(struct task_struct *t)
+{ }
 #define audit_n_rules 0
 #define audit_signals 0
 #endif /* CONFIG_AUDITSYSCALL */
@@ -681,7 +753,6 @@ extern void		    audit_log_n_hex(struct audit_buffer *ab,
 extern void		    audit_log_n_string(struct audit_buffer *ab,
 					       const char *buf,
 					       size_t n);
-#define audit_log_string(a,b) audit_log_n_string(a, b, strlen(b));
 extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
 							const char *string,
 							size_t n);
@@ -698,7 +769,8 @@ extern void		    audit_log_lost(const char *message);
 #ifdef CONFIG_SECURITY
 extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
 #else
-#define audit_log_secctx(b,s) do { ; } while (0)
+static inline void	    audit_log_secctx(struct audit_buffer *ab, u32 secid)
+{ }
 #endif
 
 extern int		    audit_update_lsm_rules(void);
@@ -710,22 +782,50 @@ extern int  audit_receive_filter(int type, int pid, int seq,
 				void *data, size_t datasz, kuid_t loginuid,
 				u32 sessionid, u32 sid);
 extern int audit_enabled;
-#else
-#define audit_log(c,g,t,f,...) do { ; } while (0)
-#define audit_log_start(c,g,t) ({ NULL; })
-#define audit_log_vformat(b,f,a) do { ; } while (0)
-#define audit_log_format(b,f,...) do { ; } while (0)
-#define audit_log_end(b) do { ; } while (0)
-#define audit_log_n_hex(a,b,l) do { ; } while (0)
-#define audit_log_n_string(a,c,l) do { ; } while (0)
-#define audit_log_string(a,c) do { ; } while (0)
-#define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
-#define audit_log_untrustedstring(a,s) do { ; } while (0)
-#define audit_log_d_path(b, p, d) do { ; } while (0)
-#define audit_log_key(b, k) do { ; } while (0)
-#define audit_log_link_denied(o, l) do { ; } while (0)
-#define audit_log_secctx(b,s) do { ; } while (0)
+#else /* CONFIG_AUDIT */
+static inline __printf(4, 5)
+void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
+	       const char *fmt, ...)
+{ }
+static inline struct audit_buffer *audit_log_start(struct audit_context *ctx,
+						   gfp_t gfp_mask, int type)
+{
+	return NULL;
+}
+static inline __printf(2, 3)
+void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)
+{ }
+static inline void audit_log_end(struct audit_buffer *ab)
+{ }
+static inline void audit_log_n_hex(struct audit_buffer *ab,
+				   const unsigned char *buf, size_t len)
+{ }
+static inline void audit_log_n_string(struct audit_buffer *ab,
+				      const char *buf, size_t n)
+{ }
+static inline void  audit_log_n_untrustedstring(struct audit_buffer *ab,
+						const char *string, size_t n)
+{ }
+static inline void audit_log_untrustedstring(struct audit_buffer *ab,
+					     const char *string)
+{ }
+static inline void audit_log_d_path(struct audit_buffer *ab,
+				    const char *prefix,
+				    const struct path *path)
+{ }
+static inline void audit_log_key(struct audit_buffer *ab, char *key)
+{ }
+static inline void audit_log_link_denied(const char *string,
+					 const struct path *link)
+{ }
+static inline void audit_log_secctx(struct audit_buffer *ab, u32 secid)
+{ }
 #define audit_enabled 0
-#endif
+#endif /* CONFIG_AUDIT */
+static inline void audit_log_string(struct audit_buffer *ab, const char *buf)
+{
+	audit_log_n_string(ab, buf, strlen(buf));
+}
+
 #endif
 #endif

commit 88265322c14cce39f7afbc416726ef4fac413298
Merge: 65b99c74fdd3 bf5308344527
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 21:38:48 2012 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
       - Integrity: add local fs integrity verification to detect offline
         attacks
       - Integrity: add digital signature verification
       - Simple stacking of Yama with other LSMs (per LSS discussions)
       - IBM vTPM support on ppc64
       - Add new driver for Infineon I2C TIS TPM
       - Smack: add rule revocation for subject labels"
    
    Fixed conflicts with the user namespace support in kernel/auditsc.c and
    security/integrity/ima/ima_policy.c.
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (39 commits)
      Documentation: Update git repository URL for Smack userland tools
      ima: change flags container data type
      Smack: setprocattr memory leak fix
      Smack: implement revoking all rules for a subject label
      Smack: remove task_wait() hook.
      ima: audit log hashes
      ima: generic IMA action flag handling
      ima: rename ima_must_appraise_or_measure
      audit: export audit_log_task_info
      tpm: fix tpm_acpi sparse warning on different address spaces
      samples/seccomp: fix 31 bit build on s390
      ima: digital signature verification support
      ima: add support for different security.ima data types
      ima: add ima_inode_setxattr/removexattr function and calls
      ima: add inode_post_setattr call
      ima: replace iint spinblock with rwlock/read_lock
      ima: allocating iint improvements
      ima: add appraise action keywords and default rules
      ima: integrity appraisal extension
      vfs: move ima_file_free before releasing the file
      ...

commit e2bebb4ae6d9ac4ffc524db67f7ecb205a173f77
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Sep 20 15:46:06 2012 -0700

    audit: define AUDIT_ARCH_OPENRISC
    
    When using audit on OpenRISC, an audit arch is needed. This defines
    it and fixes a compile-time bug uncovered in linux-next, likely from a
    cut/paste from an arch with 64/32-bit modes that defined arch_arch():
    arch/openrisc/kernel/ptrace.c:190:2: error: implicit declaration of function 'audit_arch'
    
    This replaces it with the newly defined AUDIT_ARCH_OPENRISC, since it
    is only 32-bit, and currently only operates in big-endian mode.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 36abf2aa7e68..95d98308c06e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -337,6 +337,7 @@ enum {
 #define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_OPENRISC	(EM_OPENRISC)
 #define AUDIT_ARCH_PARISC	(EM_PARISC)
 #define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_PPC		(EM_PPC)

commit e1760bd5ffae8cb98cffb030ee8e631eba28f3d8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Sep 10 22:39:43 2012 -0700

    userns: Convert the audit loginuid  to be a kuid
    
    Always store audit loginuids in type kuid_t.
    
    Print loginuids by converting them into uids in the appropriate user
    namespace, and then printing the resulting uid.
    
    Modify audit_get_loginuid to return a kuid_t.
    
    Modify audit_set_loginuid to take a kuid_t.
    
    Modify /proc/<pid>/loginuid on read to convert the loginuid into the
    user namespace of the opener of the file.
    
    Modify /proc/<pid>/loginud on write to convert the loginuid
    rom the user namespace of the opener of the file.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Paul Moore <paul@paul-moore.com> ?
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index ca019bb74da3..12367cbadfe1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -527,7 +527,7 @@ static inline void audit_ptrace(struct task_struct *t)
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
-extern int  audit_set_loginuid(uid_t loginuid);
+extern int  audit_set_loginuid(kuid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
@@ -639,7 +639,7 @@ extern int audit_signals;
 #define audit_core_dumps(i) do { ; } while (0)
 #define audit_seccomp(i,s,c) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) (0)
-#define audit_get_loginuid(t) (-1)
+#define audit_get_loginuid(t) (INVALID_UID)
 #define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
 #define audit_ipc_obj(i) ((void)0)
@@ -705,7 +705,7 @@ extern int		    audit_update_lsm_rules(void);
 extern int audit_filter_user(void);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int seq,
-				void *data, size_t datasz, uid_t loginuid,
+				void *data, size_t datasz, kuid_t loginuid,
 				u32 sessionid, u32 sid);
 extern int audit_enabled;
 #else

commit ca57ec0f00c3f139c41bf6b0a5b9bcc95bbb2ad7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 11 02:18:08 2012 -0700

    audit: Add typespecific uid and gid comparators
    
    The audit filter code guarantees that uid are always compared with
    uids and gids are always compared with gids, as the comparason
    operations are type specific.  Take advantage of this proper to define
    audit_uid_comparator and audit_gid_comparator which use the type safe
    comparasons from uidgid.h.
    
    Build on audit_uid_comparator and audit_gid_comparator and replace
    audit_compare_id with audit_compare_uid and audit_compare_gid.  This
    is one of those odd cases where being type safe and duplicating code
    leads to simpler shorter and more concise code.
    
    Don't allow bitmask operations in uid and gid comparisons in
    audit_data_to_entry.  Bitmask operations are already denined in
    audit_rule_to_entry.
    
    Convert constants in audit_rule_to_entry and audit_data_to_entry into
    kuids and kgids when appropriate.
    
    Convert the uid and gid field in struct audit_names to be of type
    kuid_t and kgid_t respectively, so that the new uid and gid comparators
    can be applied in a type safe manner.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b9c5b22e34a5..ca019bb74da3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -442,6 +442,8 @@ struct audit_krule {
 struct audit_field {
 	u32				type;
 	u32				val;
+	kuid_t				uid;
+	kgid_t				gid;
 	u32				op;
 	char				*lsm_str;
 	void				*lsm_rule;

commit 017143fecb3364e5fed8107d206799899f5dd684
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 11 00:19:06 2012 -0700

    audit: Remove the unused uid parameter from audit_receive_filter
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9c9af0e95f93..b9c5b22e34a5 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -702,7 +702,7 @@ extern int		    audit_update_lsm_rules(void);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(void);
 extern int audit_filter_type(int type);
-extern int  audit_receive_filter(int type, int pid, int uid, int seq,
+extern int  audit_receive_filter(int type, int pid, int seq,
 				void *data, size_t datasz, uid_t loginuid,
 				u32 sessionid, u32 sid);
 extern int audit_enabled;

commit 02276bda4a2bf094fcde89fb5db4d9e86347ebf4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Sep 10 23:10:16 2012 -0700

    audit: Use current instead of NETLINK_CREDS() in audit_filter
    
    Get caller process uid and gid and pid values from the current task
    instead of the NETLINK_CB.  This is simpler than passing NETLINK_CREDS
    from from audit_receive_msg to audit_filter_user_rules and avoid the
    chance of being hit by the occassional bugs in netlink uid/gid
    credential passing.  This is a safe changes because all netlink
    requests are processed in the task of the sending process.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 36abf2aa7e68..9c9af0e95f93 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -700,7 +700,7 @@ extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
-extern int audit_filter_user(struct netlink_skb_parms *cb);
+extern int audit_filter_user(void);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				void *data, size_t datasz, uid_t loginuid,

commit e23eb920b0f3978687c497de2ac3eb9e281dab32
Author: Peter Moody <pmoody@google.com>
Date:   Thu Jun 14 10:04:35 2012 -0700

    audit: export audit_log_task_info
    
    At the suggestion of eparis@redhat.com, move this chunk of task
    logging from audit_log_exit to audit_log_task_info and export this
    function so it's usuable elsewhere in the kernel.
    
    This patch is against
    git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity#next-ima-appraisal
    
    Changelog v2:
     - add empty audit_log_task_info if CONFIG_AUDITSYSCALL isn't set.
    
    Changelog v1:
     - Initial post.
    
    Signed-off-by: Peter Moody <pmoody@google.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 36abf2aa7e68..2a5073cf548a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -529,6 +529,7 @@ extern int  audit_set_loginuid(uid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
+extern void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
 extern int __audit_bprm(struct linux_binprm *bprm);
@@ -640,6 +641,7 @@ extern int audit_signals;
 #define audit_get_loginuid(t) (-1)
 #define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
+#define audit_log_task_info(b, t) do { ; } while (0)
 #define audit_ipc_obj(i) ((void)0)
 #define audit_ipc_set_perm(q,u,g,m) ((void)0)
 #define audit_bprm(p) ({ 0; })

commit a51d9eaa41866ab6b4b6ecad7b621f8b66ece0dc
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 25 17:29:08 2012 -0700

    fs: add link restriction audit reporting
    
    Adds audit messages for unexpected link restriction violations so that
    system owners will have some sort of potentially actionable information
    about misbehaving processes.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 22f292a917a3..36abf2aa7e68 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -130,6 +130,7 @@
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
 #define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
 #define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
+#define AUDIT_ANOM_LINK		    1702 /* Suspicious use of file links */
 #define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
 #define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
 #define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
@@ -687,6 +688,8 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const struct path *path);
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
+extern void		    audit_log_link_denied(const char *operation,
+						  struct path *link);
 extern void		    audit_log_lost(const char *message);
 #ifdef CONFIG_SECURITY
 extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
@@ -716,6 +719,7 @@ extern int audit_enabled;
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b, p, d) do { ; } while (0)
 #define audit_log_key(b, k) do { ; } while (0)
+#define audit_log_link_denied(o, l) do { ; } while (0)
 #define audit_log_secctx(b,s) do { ; } while (0)
 #define audit_enabled 0
 #endif

commit 3dc1c1b2d2ed7507ce8a379814ad75745ff97ebe
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Apr 12 16:47:58 2012 -0500

    seccomp: remove duplicated failure logging
    
    This consolidates the seccomp filter error logging path and adds more
    details to the audit log.
    
    Signed-off-by: Will Drewry <wad@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Eric Paris <eparis@redhat.com>
    
    v18: make compat= permanent in the record
    v15: added a return code to the audit_seccomp path by wad@chromium.org
         (suggested by eparis@redhat.com)
    v*: original by keescook@chromium.org
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index ed3ef1972496..22f292a917a3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -463,7 +463,7 @@ extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry);
 extern void __audit_inode_child(const struct dentry *dentry,
 				const struct inode *parent);
-extern void __audit_seccomp(unsigned long syscall);
+extern void __audit_seccomp(unsigned long syscall, long signr, int code);
 extern void __audit_ptrace(struct task_struct *t);
 
 static inline int audit_dummy_context(void)
@@ -508,10 +508,10 @@ static inline void audit_inode_child(const struct dentry *dentry,
 }
 void audit_core_dumps(long signr);
 
-static inline void audit_seccomp(unsigned long syscall)
+static inline void audit_seccomp(unsigned long syscall, long signr, int code)
 {
 	if (unlikely(!audit_dummy_context()))
-		__audit_seccomp(syscall);
+		__audit_seccomp(syscall, signr, code);
 }
 
 static inline void audit_ptrace(struct task_struct *t)
@@ -634,7 +634,7 @@ extern int audit_signals;
 #define audit_inode(n,d) do { (void)(d); } while (0)
 #define audit_inode_child(i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
-#define audit_seccomp(i) do { ; } while (0)
+#define audit_seccomp(i,s,c) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) (0)
 #define audit_get_loginuid(t) (-1)
 #define audit_get_sessionid(t) (-1)

commit 66b3fad3f4c535c92b6a1184d535a97d6aa5d82a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 14 21:48:20 2012 -0400

    constify path argument of audit_log_d_path()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9ff7a2c48b50..ed3ef1972496 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -684,7 +684,7 @@ extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
 						      const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
-					     struct path *path);
+					     const struct path *path);
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
 extern void		    audit_log_lost(const char *message);

commit 10d68360871657204885371cdf2594412675d2f9
Author: Peter Moody <pmoody@google.com>
Date:   Wed Jan 4 15:24:31 2012 -0500

    audit: comparison on interprocess fields
    
    This allows audit to specify rules in which we compare two fields of a
    process.  Such as is the running process uid != to the running process
    euid?
    
    Signed-off-by: Peter Moody <pmoody@google.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 67113cb4bc15..9ff7a2c48b50 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -193,7 +193,29 @@
 #define AUDIT_COMPARE_FSUID_TO_OBJ_UID	8
 #define AUDIT_COMPARE_FSGID_TO_OBJ_GID	9
 
-#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_FSGID_TO_OBJ_GID
+#define AUDIT_COMPARE_UID_TO_AUID	10
+#define AUDIT_COMPARE_UID_TO_EUID	11
+#define AUDIT_COMPARE_UID_TO_FSUID	12
+#define AUDIT_COMPARE_UID_TO_SUID	13
+
+#define AUDIT_COMPARE_AUID_TO_FSUID	14
+#define AUDIT_COMPARE_AUID_TO_SUID	15
+#define AUDIT_COMPARE_AUID_TO_EUID	16
+
+#define AUDIT_COMPARE_EUID_TO_SUID	17
+#define AUDIT_COMPARE_EUID_TO_FSUID	18
+
+#define AUDIT_COMPARE_SUID_TO_FSUID	19
+
+#define AUDIT_COMPARE_GID_TO_EGID	20
+#define AUDIT_COMPARE_GID_TO_FSGID	21
+#define AUDIT_COMPARE_GID_TO_SGID	22
+
+#define AUDIT_COMPARE_EGID_TO_FSGID	23
+#define AUDIT_COMPARE_EGID_TO_SGID	24
+#define AUDIT_COMPARE_SGID_TO_FSGID	25
+
+#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_SGID_TO_FSGID
 
 /* Rule fields */
 				/* These are useful when checking the

commit 4a6633ed08af5ba67790b4d1adcdeb8ceb55677e
Author: Peter Moody <pmoody@google.com>
Date:   Tue Dec 13 16:17:51 2011 -0800

    audit: implement all object interfield comparisons
    
    This completes the matrix of interfield comparisons between uid/gid
    information for the current task and the uid/gid information for inodes.
    aka I can audit based on differences between the euid of the process and
    the uid of fs objects.
    
    Signed-off-by: Peter Moody <pmoody@google.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fffbc2176ee1..67113cb4bc15 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -185,8 +185,16 @@
 /* AUDIT_FIELD_COMPARE rule list */
 #define AUDIT_COMPARE_UID_TO_OBJ_UID	1
 #define AUDIT_COMPARE_GID_TO_OBJ_GID	2
+#define AUDIT_COMPARE_EUID_TO_OBJ_UID	3
+#define AUDIT_COMPARE_EGID_TO_OBJ_GID	4
+#define AUDIT_COMPARE_AUID_TO_OBJ_UID	5
+#define AUDIT_COMPARE_SUID_TO_OBJ_UID	6
+#define AUDIT_COMPARE_SGID_TO_OBJ_GID	7
+#define AUDIT_COMPARE_FSUID_TO_OBJ_UID	8
+#define AUDIT_COMPARE_FSGID_TO_OBJ_GID	9
+
+#define AUDIT_MAX_FIELD_COMPARE		AUDIT_COMPARE_FSGID_TO_OBJ_GID
 
-#define AUDIT_MAX_FIELD_COMPARE	AUDIT_COMPARE_GID_TO_OBJ_GID
 /* Rule fields */
 				/* These are useful when checking the
 				 * task structure at task creation time

commit c9fe685f7a17a0ee8bf3fbe51e40b1c8b8e65896
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:08 2012 -0500

    audit: allow interfield comparison between gid and ogid
    
    Allow audit rules to compare the gid of the running task to the gid of the
    inode in question.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 838e05fc0582..fffbc2176ee1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -184,8 +184,9 @@
 
 /* AUDIT_FIELD_COMPARE rule list */
 #define AUDIT_COMPARE_UID_TO_OBJ_UID	1
+#define AUDIT_COMPARE_GID_TO_OBJ_GID	2
 
-#define AUDIT_MAX_FIELD_COMPARE	AUDIT_COMPARE_UID_TO_OBJ_UID
+#define AUDIT_MAX_FIELD_COMPARE	AUDIT_COMPARE_GID_TO_OBJ_GID
 /* Rule fields */
 				/* These are useful when checking the
 				 * task structure at task creation time

commit 02d86a568c6d2d335256864451ac8ce781bc5652
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:08 2012 -0500

    audit: allow interfield comparison in audit rules
    
    We wish to be able to audit when a uid=500 task accesses a file which is
    uid=0.  Or vice versa.  This patch introduces a new audit filter type
    AUDIT_FIELD_COMPARE which takes as an 'enum' which indicates which fields
    should be compared.  At this point we only define the task->uid vs
    inode->uid, but other comparisons can be added.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 7cbd6fe41573..838e05fc0582 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -182,7 +182,10 @@
  * AUDIT_UNUSED_BITS is updated if need be. */
 #define AUDIT_UNUSED_BITS	0x07FFFC00
 
+/* AUDIT_FIELD_COMPARE rule list */
+#define AUDIT_COMPARE_UID_TO_OBJ_UID	1
 
+#define AUDIT_MAX_FIELD_COMPARE	AUDIT_COMPARE_UID_TO_OBJ_UID
 /* Rule fields */
 				/* These are useful when checking the
 				 * task structure at task creation time
@@ -225,6 +228,7 @@
 #define AUDIT_FILETYPE	108
 #define AUDIT_OBJ_UID	109
 #define AUDIT_OBJ_GID	110
+#define AUDIT_FIELD_COMPARE	111
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit 0a300be6d5be8f66cd96609334710c268d0bfdce
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:08 2012 -0500

    audit: remove task argument to audit_set_loginuid
    
    The function always deals with current.  Don't expose an option
    pretending one can use it for something.  You can't.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e36aa37c88af..7cbd6fe41573 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -489,7 +489,7 @@ static inline void audit_ptrace(struct task_struct *t)
 extern unsigned int audit_serial(void);
 extern int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
-extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
+extern int  audit_set_loginuid(uid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);

commit 54d3218b31aee5bc9c859ae60fbde933d922448b
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: allow audit matching on inode gid
    
    Much like the ability to filter audit on the uid of an inode collected, we
    should be able to filter on the gid of the inode.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 55cb3daaf474..e36aa37c88af 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -224,6 +224,7 @@
 #define AUDIT_DIR	107
 #define AUDIT_FILETYPE	108
 #define AUDIT_OBJ_UID	109
+#define AUDIT_OBJ_GID	110
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit efaffd6e4417860c67576ac760dd6e8bbd15f006
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: allow matching on obj_uid
    
    Allow syscall exit filter matching based on the uid of the owner of an
    inode used in a syscall.  aka:
    
    auditctl -a always,exit -S open -F obj_uid=0 -F perm=wa
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 67b66c37a254..55cb3daaf474 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -223,6 +223,7 @@
 #define AUDIT_PERM	106
 #define AUDIT_DIR	107
 #define AUDIT_FILETYPE	108
+#define AUDIT_OBJ_UID	109
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit 6422e78de6880c66a82af512d9bd0c85eb62e661
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: remove audit_finish_fork as it can't be called
    
    Audit entry,always rules are not allowed and are automatically changed in
    exit,always rules in userspace.  The kernel refuses to load such rules.
    
    Thus a task in the middle of a syscall (and thus in audit_finish_fork())
    can only be in one of two states: AUDIT_BUILD_CONTEXT or AUDIT_DISABLED.
    Since the current task cannot be in AUDIT_RECORD_CONTEXT we aren't every
    going to actually use the code in audit_finish_fork() since it will
    return without doing anything.  Thus drop the code.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8eb8bda749b3..67b66c37a254 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -415,7 +415,6 @@ extern int audit_classify_arch(int arch);
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */
-extern void audit_finish_fork(struct task_struct *child);
 extern int  audit_alloc(struct task_struct *task);
 extern void __audit_free(struct task_struct *task);
 extern void __audit_syscall_entry(int arch,
@@ -586,7 +585,6 @@ static inline void audit_mmap_fd(int fd, int flags)
 extern int audit_n_rules;
 extern int audit_signals;
 #else /* CONFIG_AUDITSYSCALL */
-#define audit_finish_fork(t)
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
 #define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)

commit a4ff8dba7d8ce5ceb43fb27df66292251cc73bdc
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: inline audit_free to simplify the look of generic code
    
    make the conditional a static inline instead of doing it in generic code.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4f1efe3e8616..8eb8bda749b3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -417,7 +417,7 @@ extern int audit_classify_arch(int arch);
 				/* Public API */
 extern void audit_finish_fork(struct task_struct *child);
 extern int  audit_alloc(struct task_struct *task);
-extern void audit_free(struct task_struct *task);
+extern void __audit_free(struct task_struct *task);
 extern void __audit_syscall_entry(int arch,
 				  int major, unsigned long a0, unsigned long a1,
 				  unsigned long a2, unsigned long a3);
@@ -435,6 +435,11 @@ static inline int audit_dummy_context(void)
 	void *p = current->audit_context;
 	return !p || *(int *)p;
 }
+static inline void audit_free(struct task_struct *task)
+{
+	if (unlikely(task->audit_context))
+		__audit_free(task);
+}
 static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
 				       unsigned long a1, unsigned long a2,
 				       unsigned long a3)

commit 38cdce53daa0408a61fe6d86fe48f31515c9b840
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: drop audit_set_macxattr as it doesn't do anything
    
    unused.  deleted.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index cf16faff6b8a..4f1efe3e8616 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -493,7 +493,6 @@ extern int __audit_bprm(struct linux_binprm *bprm);
 extern void __audit_socketcall(int nargs, unsigned long *args);
 extern int __audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
-extern int audit_set_macxattr(const char *name);
 extern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);
 extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
 extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
@@ -606,7 +605,6 @@ extern int audit_signals;
 #define audit_socketcall(n,a) ((void)0)
 #define audit_fd_pair(n,a) ((void)0)
 #define audit_sockaddr(len, addr) ({ 0; })
-#define audit_set_macxattr(n) do { ; } while (0)
 #define audit_mq_open(o,m,a) ((void)0)
 #define audit_mq_sendrecv(d,l,p,t) ((void)0)
 #define audit_mq_notify(d,n) ((void)0)

commit 07c49417877f8658a6aa0ad9b4e21e4fd4df11b6
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:07 2012 -0500

    audit: inline checks for not needing to collect aux records
    
    A number of audit hooks make function calls before they determine that
    auxilary records do not need to be collected.  Do those checks as static
    inlines since the most common case is going to be that records are not
    needed and we can skip the function call overhead.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f56ce2669b83..cf16faff6b8a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -489,9 +489,9 @@ extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
-extern int audit_bprm(struct linux_binprm *bprm);
-extern void audit_socketcall(int nargs, unsigned long *args);
-extern int audit_sockaddr(int len, void *addr);
+extern int __audit_bprm(struct linux_binprm *bprm);
+extern void __audit_socketcall(int nargs, unsigned long *args);
+extern int __audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
 extern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);
@@ -519,6 +519,23 @@ static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_set_perm(qbytes, uid, gid, mode);
 }
+static inline int audit_bprm(struct linux_binprm *bprm)
+{
+	if (unlikely(!audit_dummy_context()))
+		return __audit_bprm(bprm);
+	return 0;
+}
+static inline void audit_socketcall(int nargs, unsigned long *args)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_socketcall(nargs, args);
+}
+static inline int audit_sockaddr(int len, void *addr)
+{
+	if (unlikely(!audit_dummy_context()))
+		return __audit_sockaddr(len, addr);
+	return 0;
+}
 static inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
 {
 	if (unlikely(!audit_dummy_context()))

commit b05d8447e7821695bc2fa3359431f7a664232743
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:06 2012 -0500

    audit: inline audit_syscall_entry to reduce burden on archs
    
    Every arch calls:
    
    if (unlikely(current->audit_context))
            audit_syscall_entry()
    
    which requires knowledge about audit (the existance of audit_context) in
    the arch code.  Just do it all in static inline in audit.h so that arch's
    can remain blissfully ignorant.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3d65e4b3ba06..f56ce2669b83 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -418,9 +418,9 @@ extern int audit_classify_arch(int arch);
 extern void audit_finish_fork(struct task_struct *child);
 extern int  audit_alloc(struct task_struct *task);
 extern void audit_free(struct task_struct *task);
-extern void audit_syscall_entry(int arch,
-				int major, unsigned long a0, unsigned long a1,
-				unsigned long a2, unsigned long a3);
+extern void __audit_syscall_entry(int arch,
+				  int major, unsigned long a0, unsigned long a1,
+				  unsigned long a2, unsigned long a3);
 extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
@@ -435,6 +435,13 @@ static inline int audit_dummy_context(void)
 	void *p = current->audit_context;
 	return !p || *(int *)p;
 }
+static inline void audit_syscall_entry(int arch, int major, unsigned long a0,
+				       unsigned long a1, unsigned long a2,
+				       unsigned long a3)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_syscall_entry(arch, major, a0, a1, a2, a3);
+}
 static inline void audit_syscall_exit(void *pt_regs)
 {
 	if (unlikely(current->audit_context)) {

commit d7e7528bcd456f5c36ad4a202ccfb43c5aa98bc4
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:06 2012 -0500

    Audit: push audit success and retcode into arch ptrace.h
    
    The audit system previously expected arches calling to audit_syscall_exit to
    supply as arguments if the syscall was a success and what the return code was.
    Audit also provides a helper AUDITSC_RESULT which was supposed to simplify things
    by converting from negative retcodes to an audit internal magic value stating
    success or failure.  This helper was wrong and could indicate that a valid
    pointer returned to userspace was a failed syscall.  The fix is to fix the
    layering foolishness.  We now pass audit_syscall_exit a struct pt_reg and it
    in turns calls back into arch code to collect the return value and to
    determine if the syscall was a success or failure.  We also define a generic
    is_syscall_success() macro which determines success/failure based on if the
    value is < -MAX_ERRNO.  This works for arches like x86 which do not use a
    separate mechanism to indicate syscall failure.
    
    We make both the is_syscall_success() and regs_return_value() static inlines
    instead of macros.  The reason is because the audit function must take a void*
    for the regs.  (uml calls theirs struct uml_pt_regs instead of just struct
    pt_regs so audit_syscall_exit can't take a struct pt_regs).  Since the audit
    function takes a void* we need to use static inlines to cast it back to the
    arch correct structure to dereference it.
    
    The other major change is that on some arches, like ia64, MIPS and ppc, we
    change regs_return_value() to give us the negative value on syscall failure.
    THE only other user of this macro, kretprobe_example.c, won't notice and it
    makes the value signed consistently for the audit functions across all archs.
    
    In arch/sh/kernel/ptrace_64.c I see that we were using regs[9] in the old
    audit code as the return value.  But the ptrace_64.h code defined the macro
    regs_return_value() as regs[3].  I have no idea which one is correct, but this
    patch now uses the regs_return_value() function, so it now uses regs[3].
    
    For powerpc we previously used regs->result but now use the
    regs_return_value() function which uses regs->gprs[3].  regs->gprs[3] is
    always positive so the regs_return_value(), much like ia64 makes it negative
    before calling the audit code when appropriate.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: H. Peter Anvin <hpa@zytor.com> [for x86 portion]
    Acked-by: Tony Luck <tony.luck@intel.com> [for ia64]
    Acked-by: Richard Weinberger <richard@nod.at> [for uml]
    Acked-by: David S. Miller <davem@davemloft.net> [for sparc]
    Acked-by: Ralf Baechle <ralf@linux-mips.org> [for mips]
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org> [for ppc]

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 6e1c533f9b46..3d65e4b3ba06 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -26,6 +26,7 @@
 
 #include <linux/types.h>
 #include <linux/elf-em.h>
+#include <linux/ptrace.h>
 
 /* The netlink messages for the audit system is divided into blocks:
  * 1000 - 1099 are for commanding the audit system
@@ -408,10 +409,6 @@ struct audit_field {
 	void				*lsm_rule;
 };
 
-#define AUDITSC_INVALID 0
-#define AUDITSC_SUCCESS 1
-#define AUDITSC_FAILURE 2
-#define AUDITSC_RESULT(x) ( ((long)(x))<0?AUDITSC_FAILURE:AUDITSC_SUCCESS )
 extern int __init audit_register_class(int class, unsigned *list);
 extern int audit_classify_syscall(int abi, unsigned syscall);
 extern int audit_classify_arch(int arch);
@@ -424,7 +421,7 @@ extern void audit_free(struct task_struct *task);
 extern void audit_syscall_entry(int arch,
 				int major, unsigned long a0, unsigned long a1,
 				unsigned long a2, unsigned long a3);
-extern void audit_syscall_exit(int failed, long return_code);
+extern void __audit_syscall_exit(int ret_success, long ret_value);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry);
@@ -438,6 +435,15 @@ static inline int audit_dummy_context(void)
 	void *p = current->audit_context;
 	return !p || *(int *)p;
 }
+static inline void audit_syscall_exit(void *pt_regs)
+{
+	if (unlikely(current->audit_context)) {
+		int success = is_syscall_success(pt_regs);
+		int return_code = regs_return_value(pt_regs);
+
+		__audit_syscall_exit(success, return_code);
+	}
+}
 static inline void audit_getname(const char *name)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -551,12 +557,12 @@ static inline void audit_mmap_fd(int fd, int flags)
 
 extern int audit_n_rules;
 extern int audit_signals;
-#else
+#else /* CONFIG_AUDITSYSCALL */
 #define audit_finish_fork(t)
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
 #define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)
-#define audit_syscall_exit(f,r) do { ; } while (0)
+#define audit_syscall_exit(r) do { ; } while (0)
 #define audit_dummy_context() 1
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
@@ -587,7 +593,7 @@ extern int audit_signals;
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0
-#endif
+#endif /* CONFIG_AUDITSYSCALL */
 
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */

commit 85e7bac33b8d5edafc4e219c7dfdb3d48e0b4e31
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 3 14:23:05 2012 -0500

    seccomp: audit abnormal end to a process due to seccomp
    
    The audit system likes to collect information about processes that end
    abnormally (SIGSEGV) as this may me useful intrusion detection information.
    This patch adds audit support to collect information when seccomp forces a
    task to exit because of misbehavior in a similar way.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 426ab9f4dd85..6e1c533f9b46 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -430,6 +430,7 @@ extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry);
 extern void __audit_inode_child(const struct dentry *dentry,
 				const struct inode *parent);
+extern void __audit_seccomp(unsigned long syscall);
 extern void __audit_ptrace(struct task_struct *t);
 
 static inline int audit_dummy_context(void)
@@ -453,6 +454,12 @@ static inline void audit_inode_child(const struct dentry *dentry,
 }
 void audit_core_dumps(long signr);
 
+static inline void audit_seccomp(unsigned long syscall)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_seccomp(syscall);
+}
+
 static inline void audit_ptrace(struct task_struct *t)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -558,6 +565,7 @@ extern int audit_signals;
 #define audit_inode(n,d) do { (void)(d); } while (0)
 #define audit_inode_child(i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
+#define audit_seccomp(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) (0)
 #define audit_get_loginuid(t) (-1)
 #define audit_get_sessionid(t) (-1)

commit 2570ebbd1f1ce1ef31f568b0660354fc59424be2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jul 27 14:03:22 2011 -0400

    switch kern_ipc_perm to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 75ed193b11f8..426ab9f4dd85 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -468,7 +468,7 @@ extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
-extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
 extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
@@ -494,7 +494,7 @@ static inline void audit_fd_pair(int fd1, int fd2)
 	if (unlikely(!audit_dummy_context()))
 		__audit_fd_pair(fd1, fd2);
 }
-static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
+static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)
 {
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_set_perm(qbytes, uid, gid, mode);

commit df0a42837b86567a130c44515ab620d23e7f182b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 05:26:10 2011 -0400

    switch mq_open() to umode_t

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2f81c6f3b630..75ed193b11f8 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -474,7 +474,7 @@ extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern void __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
-extern void __audit_mq_open(int oflag, mode_t mode, struct mq_attr *attr);
+extern void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr);
 extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
 extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
 extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
@@ -499,7 +499,7 @@ static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_set_perm(qbytes, uid, gid, mode);
 }
-static inline void audit_mq_open(int oflag, mode_t mode, struct mq_attr *attr)
+static inline void audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)
 {
 	if (unlikely(!audit_dummy_context()))
 		__audit_mq_open(oflag, mode, attr);

commit b9075fa968a0a4347aef35e235e2995c0e57dddd
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 31 17:11:33 2011 -0700

    treewide: use __printf not __attribute__((format(printf,...)))
    
    Standardize the style for compiler based printf format verification.
    Standardized the location of __printf too.
    
    Done via script and a little typing.
    
    $ grep -rPl --include=*.[ch] -w "__attribute__" * | \
      grep -vP "^(tools|scripts|include/linux/compiler-gcc.h)" | \
      xargs perl -n -i -e 'local $/; while (<>) { s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\)/__printf($1, $2)/g ; print; }'
    
    [akpm@linux-foundation.org: revert arch bits]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 0c8006129fb2..2f81c6f3b630 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -584,14 +584,13 @@ extern int audit_signals;
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
-extern void		    audit_log(struct audit_context *ctx, gfp_t gfp_mask,
-				      int type, const char *fmt, ...)
-				      __attribute__((format(printf,4,5)));
+extern __printf(4, 5)
+void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
+	       const char *fmt, ...);
 
 extern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask, int type);
-extern void		    audit_log_format(struct audit_buffer *ab,
-					     const char *fmt, ...)
-			    __attribute__((format(printf,2,3)));
+extern __printf(2, 3)
+void audit_log_format(struct audit_buffer *ab, const char *fmt, ...);
 extern void		    audit_log_end(struct audit_buffer *ab);
 extern int		    audit_string_contains_control(const char *string,
 							  size_t len);

commit 131ad62d8fc06d9d0a5c61d9526876352c2f2bbd
Author: Mr Dash Four <mr.dash.four@googlemail.com>
Date:   Thu Jun 30 13:31:57 2011 +0200

    netfilter: add SELinux context support to AUDIT target
    
    In this revision the conversion of secid to SELinux context and adding it
    to the audit log is moved from xt_AUDIT.c to audit.c with the aid of a
    separate helper function - audit_log_secctx - which does both the conversion
    and logging of SELinux context, thus also preventing internal secid number
    being leaked to userspace. If conversion is not successful an error is raised.
    
    With the introduction of this helper function the work done in xt_AUDIT.c is
    much more simplified. It also opens the possibility of this helper function
    being used by other modules (including auditd itself), if desired. With this
    addition, typical (raw auditd) output after applying the patch would be:
    
    type=NETFILTER_PKT msg=audit(1305852240.082:31012): action=0 hook=1 len=52 inif=? outif=eth0 saddr=10.1.1.7 daddr=10.1.2.1 ipid=16312 proto=6 sport=56150 dport=22 obj=system_u:object_r:ssh_client_packet_t:s0
    type=NETFILTER_PKT msg=audit(1306772064.079:56): action=0 hook=3 len=48 inif=eth0 outif=? smac=00:05:5d:7c:27:0b dmac=00:02:b3:0a:7f:81 macproto=0x0800 saddr=10.1.2.1 daddr=10.1.1.7 ipid=462 proto=6 sport=22 dport=3561 obj=system_u:object_r:ssh_server_packet_t:s0
    
    Acked-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Mr Dash Four <mr.dash.four@googlemail.com>
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9d339eb27881..0c8006129fb2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -613,6 +613,12 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 extern void		    audit_log_key(struct audit_buffer *ab,
 					  char *key);
 extern void		    audit_log_lost(const char *message);
+#ifdef CONFIG_SECURITY
+extern void 		    audit_log_secctx(struct audit_buffer *ab, u32 secid);
+#else
+#define audit_log_secctx(b,s) do { ; } while (0)
+#endif
+
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
@@ -635,6 +641,7 @@ extern int audit_enabled;
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b, p, d) do { ; } while (0)
 #define audit_log_key(b, k) do { ; } while (0)
+#define audit_log_secctx(b,s) do { ; } while (0)
 #define audit_enabled 0
 #endif
 #endif

commit 14f0290ba44de6ed435fea24bba26e7868421c66
Merge: f5c88f56b355 a5db219f4cf9
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Jan 19 23:51:37 2011 +0100

    Merge branch 'master' of /repos/git/net-next-2.6

commit fbabf31e4d482149b5e2704eb0287cf9117bdcf3
Author: Thomas Graf <tgraf@infradead.org>
Date:   Sun Jan 16 18:12:59 2011 +0100

    netfilter: create audit records for x_tables replaces
    
    The setsockopt() syscall to replace tables is already recorded
    in the audit logs. This patch stores additional information
    such as table name and netfilter protocol.
    
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Thomas Graf <tgraf@redhat.com>
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index ae227dfcf9c6..32b5c62a5042 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -104,6 +104,7 @@
 #define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
 #define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
 #define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
+#define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */

commit 43f393caec0362abe03c72799d3f342af3973070
Author: Thomas Graf <tgraf@infradead.org>
Date:   Sun Jan 16 18:10:28 2011 +0100

    netfilter: audit target to record accepted/dropped packets
    
    This patch adds a new netfilter target which creates audit records
    for packets traversing a certain chain.
    
    It can be used to record packets which are rejected administraively
    as follows:
    
      -N AUDIT_DROP
      -A AUDIT_DROP -j AUDIT --type DROP
      -A AUDIT_DROP -j DROP
    
    a rule which would typically drop or reject a packet would then
    invoke the new chain to record packets before dropping them.
    
      -j AUDIT_DROP
    
    The module is protocol independant and works for iptables, ip6tables
    and ebtables.
    
    The following information is logged:
     - netfilter hook
     - packet length
     - incomming/outgoing interface
     - MAC src/dst/proto for ethernet packets
     - src/dst/protocol address for IPv4/IPv6
     - src/dst port for TCP/UDP/UDPLITE
     - icmp type/code
    
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Thomas Graf <tgraf@redhat.com>
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8b5c0620abf9..ae227dfcf9c6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -103,6 +103,7 @@
 #define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
 #define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
 #define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
+#define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */

commit 37721e1b0cf98cb65895f234d8c500d270546529
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jan 10 08:17:10 2011 +0200

    headers: path.h redux
    
    Remove path.h from sched.h and other files.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8b5c0620abf9..359df0487690 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -372,6 +372,7 @@ struct audit_buffer;
 struct audit_context;
 struct inode;
 struct netlink_skb_parms;
+struct path;
 struct linux_binprm;
 struct mq_attr;
 struct mqstat;

commit 120a795da07c9a02221ca23464c28a7c6ad7de1d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 30 02:54:44 2010 -0400

    audit mmap
    
    Normal syscall audit doesn't catch 5th argument of syscall.  It also
    doesn't catch the contents of userland structures pointed to be
    syscall argument, so for both old and new mmap(2) ABI it doesn't
    record the descriptor we are mapping.  For old one it also misses
    flags.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e24afabc548f..8b5c0620abf9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -102,6 +102,7 @@
 #define AUDIT_EOE		1320	/* End of multi-record event */
 #define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
 #define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
+#define AUDIT_MMAP		1323	/* Record showing descriptor and flags in mmap */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -478,6 +479,7 @@ extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *new,
 				  const struct cred *old);
 extern void __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
+extern void __audit_mmap_fd(int fd, int flags);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -531,6 +533,12 @@ static inline void audit_log_capset(pid_t pid, const struct cred *new,
 		__audit_log_capset(pid, new, old);
 }
 
+static inline void audit_mmap_fd(int fd, int flags)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_mmap_fd(fd, flags);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else
@@ -564,6 +572,7 @@ extern int audit_signals;
 #define audit_mq_getsetattr(d,s) ((void)0)
 #define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
 #define audit_log_capset(pid, ncr, ocr) ((void)0)
+#define audit_mmap_fd(fd, flags) ((void)0)
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0

commit 1676effca4cd2a6b32e6e8e0ecaa91522dfda6fa
Author: Andi Kleen <andi@firstfloor.org>
Date:   Mon Jun 21 11:02:48 2010 +0200

    gcc-4.6: fs: fix unused but set warnings
    
    No real bugs I believe, just some dead code, and some
    shut up code.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f391d45c8aea..e24afabc548f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -544,7 +544,7 @@ extern int audit_signals;
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,d) do { ; } while (0)
 #define __audit_inode_child(i,p) do { ; } while (0)
-#define audit_inode(n,d) do { ; } while (0)
+#define audit_inode(n,d) do { (void)(d); } while (0)
 #define audit_inode_child(i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) (0)

commit cccc6bba3f771ef29b33e4f79e70ebc3dba245b0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 25 05:07:33 2009 -0500

    Lose the first argument of audit_inode_child()
    
    it's always equal to ->d_name.name of the second argument
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3c7a358241a7..f391d45c8aea 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -424,7 +424,7 @@ extern void audit_syscall_exit(int failed, long return_code);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct dentry *dentry);
-extern void __audit_inode_child(const char *dname, const struct dentry *dentry,
+extern void __audit_inode_child(const struct dentry *dentry,
 				const struct inode *parent);
 extern void __audit_ptrace(struct task_struct *t);
 
@@ -442,11 +442,10 @@ static inline void audit_inode(const char *name, const struct dentry *dentry) {
 	if (unlikely(!audit_dummy_context()))
 		__audit_inode(name, dentry);
 }
-static inline void audit_inode_child(const char *dname, 
-				     const struct dentry *dentry,
+static inline void audit_inode_child(const struct dentry *dentry,
 				     const struct inode *parent) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode_child(dname, dentry, parent);
+		__audit_inode_child(dentry, parent);
 }
 void audit_core_dumps(long signr);
 
@@ -544,9 +543,9 @@ extern int audit_signals;
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,d) do { ; } while (0)
-#define __audit_inode_child(d,i,p) do { ; } while (0)
+#define __audit_inode_child(i,p) do { ; } while (0)
 #define audit_inode(n,d) do { ; } while (0)
-#define audit_inode_child(d,i,p) do { ; } while (0)
+#define audit_inode_child(i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) (0)
 #define audit_get_loginuid(t) (-1)

commit 9d9609851003ebed15957f0f2ce18492739ee124
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Jun 11 14:31:37 2009 -0400

    Audit: clean up all op= output to include string quoting
    
    A number of places in the audit system we send an op= followed by a string
    that includes spaces.  Somehow this works but it's just wrong.  This patch
    moves all of those that I could find to be quoted.
    
    Example:
    
    Change From: type=CONFIG_CHANGE msg=audit(1244666690.117:31): auid=0 ses=1
    subj=unconfined_u:unconfined_r:auditctl_t:s0-s0:c0.c1023 op=remove rule
    key="number2" list=4 res=0
    
    Change To: type=CONFIG_CHANGE msg=audit(1244666690.117:31): auid=0 ses=1
    subj=unconfined_u:unconfined_r:auditctl_t:s0-s0:c0.c1023 op="remove rule"
    key="number2" list=4 res=0
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4fa2810b675e..3c7a358241a7 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -599,6 +599,8 @@ extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct path *path);
+extern void		    audit_log_key(struct audit_buffer *ab,
+					  char *key);
 extern void		    audit_log_lost(const char *message);
 extern int		    audit_update_lsm_rules(void);
 
@@ -621,6 +623,7 @@ extern int audit_enabled;
 #define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b, p, d) do { ; } while (0)
+#define audit_log_key(b, k) do { ; } while (0)
 #define audit_enabled 0
 #endif
 #endif

commit 523979adfa0b79d4e3aa053220c37a9233294206
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Feb 11 11:12:28 2009 -0500

    integrity: audit update
    
    Based on discussions on linux-audit, as per Steve Grubb's request
    http://lkml.org/lkml/2009/2/6/269, the following changes were made:
    - forced audit result to be either 0 or 1.
    - made template names const
    - Added new stand-alone message type: AUDIT_INTEGRITY_RULE
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 930939abfbc6..4fa2810b675e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -36,7 +36,8 @@
  * 1500 - 1599 kernel LSPP events
  * 1600 - 1699 kernel crypto events
  * 1700 - 1799 kernel anomaly records
- * 1800 - 1999 future kernel use (maybe integrity labels and related events)
+ * 1800 - 1899 kernel integrity events
+ * 1900 - 1999 future kernel use
  * 2000 is for otherwise unclassified kernel audit messages (legacy)
  * 2001 - 2099 unused (kernel)
  * 2100 - 2199 user space anomaly records
@@ -130,6 +131,7 @@
 #define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
 #define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
 #define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
+#define AUDIT_INTEGRITY_RULE	    1805 /* policy rule */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 

commit cb5629b10d64a8006622ce3a52bc887d91057d69
Merge: 8920d5ad6ba7 f01d1d546abb
Author: James Morris <jmorris@namei.org>
Date:   Fri Feb 6 11:01:45 2009 +1100

    Merge branch 'master' into next
    
    Conflicts:
            fs/namei.c
    
    Manually merged per:
    
    diff --cc fs/namei.c
    index 734f2b5,bbc15c2..0000000
    --- a/fs/namei.c
    +++ b/fs/namei.c
    @@@ -860,9 -848,8 +849,10 @@@ static int __link_path_walk(const char
                    nd->flags |= LOOKUP_CONTINUE;
                    err = exec_permission_lite(inode);
                    if (err == -EAGAIN)
    -                       err = vfs_permission(nd, MAY_EXEC);
    +                       err = inode_permission(nd->path.dentry->d_inode,
    +                                              MAY_EXEC);
     +              if (!err)
     +                      err = ima_path_check(&nd->path, MAY_EXEC);
                    if (err)
                            break;
    
    @@@ -1525,14 -1506,9 +1509,14 @@@ int may_open(struct path *path, int acc
                    flag &= ~O_TRUNC;
            }
    
    -       error = vfs_permission(nd, acc_mode);
    +       error = inode_permission(inode, acc_mode);
            if (error)
                    return error;
     +
    -       error = ima_path_check(&nd->path,
    ++      error = ima_path_check(path,
     +                             acc_mode & (MAY_READ | MAY_WRITE | MAY_EXEC));
     +      if (error)
     +              return error;
            /*
             * An append-only file must be opened in append mode for writing.
             */
    
    Signed-off-by: James Morris <jmorris@namei.org>

commit 3323eec921efd815178a23107ab63588c605c0b2
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Feb 4 09:06:58 2009 -0500

    integrity: IMA as an integrity service provider
    
    IMA provides hardware (TPM) based measurement and attestation for
    file measurements. As the Trusted Computing (TPM) model requires,
    IMA measures all files before they are accessed in any way (on the
    integrity_bprm_check, integrity_path_check and integrity_file_mmap
    hooks), and commits the measurements to the TPM. Once added to the
    TPM, measurements can not be removed.
    
    In addition, IMA maintains a list of these file measurements, which
    can be used to validate the aggregate value stored in the TPM.  The
    TPM can sign these measurements, and thus the system can prove, to
    itself and to a third party, the system's integrity in a way that
    cannot be circumvented by malicious or compromised software.
    
    - alloc ima_template_entry before calling ima_store_template()
    - log ima_add_boot_aggregate() failure
    - removed unused IMA_TEMPLATE_NAME_LEN
    - replaced hard coded string length with #define name
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 26c4f6f65a46..8d1f67789b53 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -125,6 +125,11 @@
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
 #define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
 #define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
+#define AUDIT_INTEGRITY_DATA	    1800 /* Data integrity verification */
+#define AUDIT_INTEGRITY_METADATA    1801 /* Metadata integrity verification */
+#define AUDIT_INTEGRITY_STATUS	    1802 /* Integrity enable status */
+#define AUDIT_INTEGRITY_HASH	    1803 /* Integrity HASH type */
+#define AUDIT_INTEGRITY_PCR	    1804 /* PCR invalidation msgs */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 

commit 5af75d8d58d0f9f7b7c0515b35786b22892d5f12
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 16 05:59:26 2008 -0500

    audit: validate comparison operations, store them in sane form
    
    Don't store the field->op in the messy (and very inconvenient for e.g.
    audit_comparator()) form; translate to dense set of values and do full
    validation of userland-submitted value while we are at it.
    
    ->audit_init_rule() and ->audit_match_rule() get new values now; in-tree
    instances updated.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index cc71fdb56ae2..67e5dbfc2961 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -247,6 +247,18 @@
 #define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
 #define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)
 
+enum {
+	Audit_equal,
+	Audit_not_equal,
+	Audit_bitmask,
+	Audit_bittest,
+	Audit_lt,
+	Audit_gt,
+	Audit_le,
+	Audit_ge,
+	Audit_bad
+};
+
 /* Status symbols */
 				/* Mask values */
 #define AUDIT_STATUS_ENABLED		0x0001

commit e45aa212ea81d39b38ba158df344dc3a500153e5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 15 01:17:50 2008 -0500

    audit rules ordering, part 2
    
    Fix the actual rule listing; add per-type lists _not_ used for matching,
    with all exit,... sitting on one such list.  Simplifies "do something
    for all rules" logics, while we are at it...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5b47eeb00d53..cc71fdb56ae2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -373,6 +373,7 @@ struct audit_krule {
 	struct audit_watch	*watch;	/* associated watch */
 	struct audit_tree	*tree;	/* associated watched tree */
 	struct list_head	rlist;	/* entry in audit_{watch,tree}.rules list */
+	struct list_head	list;	/* for AUDIT_LIST* purposes only */
 	u64			prio;
 };
 

commit 0590b9335a1c72a3f0defcc6231287f7817e07c8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 14 23:45:27 2008 -0500

    fixing audit rule ordering mess, part 1
    
    Problem: ordering between the rules on exit chain is currently lost;
    all watch and inode rules are listed after everything else _and_
    exit,never on one kind doesn't stop exit,always on another from
    being matched.
    
    Solution: assign priorities to rules, keep track of the current
    highest-priority matching rule and its result (always/never).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 7ddcb6a29eb1..5b47eeb00d53 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -373,6 +373,7 @@ struct audit_krule {
 	struct audit_watch	*watch;	/* associated watch */
 	struct audit_tree	*tree;	/* associated watched tree */
 	struct list_head	rlist;	/* entry in audit_{watch,tree}.rules list */
+	u64			prio;
 };
 
 struct audit_field {

commit 57f71a0af4244d9ba3c0bce74b1d2e66e8d520bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jan 4 14:52:57 2009 -0500

    sanitize audit_log_capset()
    
    * no allocations
    * return void
    * don't duplicate checked for dummy context
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bd59cd1e3219..7ddcb6a29eb1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -457,7 +457,7 @@ extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *new,
 				  const struct cred *old);
-extern int __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
+extern void __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
 
 static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -504,12 +504,11 @@ static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
 	return 0;
 }
 
-static inline int audit_log_capset(pid_t pid, const struct cred *new,
+static inline void audit_log_capset(pid_t pid, const struct cred *new,
 				   const struct cred *old)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_log_capset(pid, new, old);
-	return 0;
+		__audit_log_capset(pid, new, old);
 }
 
 extern int audit_n_rules;
@@ -544,7 +543,7 @@ extern int audit_signals;
 #define audit_mq_notify(d,n) ((void)0)
 #define audit_mq_getsetattr(d,s) ((void)0)
 #define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
-#define audit_log_capset(pid, ncr, ocr) ({ 0; })
+#define audit_log_capset(pid, ncr, ocr) ((void)0)
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0

commit 157cf649a735a2f7e8dba0ed08e6e38b6c30d886
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 14 04:57:47 2008 -0500

    sanitize audit_fd_pair()
    
    * no allocations
    * return void
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 54978bdd2bd4..bd59cd1e3219 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -448,7 +448,7 @@ extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mod
 extern int audit_bprm(struct linux_binprm *bprm);
 extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
-extern int __audit_fd_pair(int fd1, int fd2);
+extern void __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
 extern void __audit_mq_open(int oflag, mode_t mode, struct mq_attr *attr);
 extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
@@ -464,11 +464,10 @@ static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_obj(ipcp);
 }
-static inline int audit_fd_pair(int fd1, int fd2)
+static inline void audit_fd_pair(int fd1, int fd2)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_fd_pair(fd1, fd2);
-	return 0;
+		__audit_fd_pair(fd1, fd2);
 }
 static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
 {
@@ -537,7 +536,7 @@ extern int audit_signals;
 #define audit_ipc_set_perm(q,u,g,m) ((void)0)
 #define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ((void)0)
-#define audit_fd_pair(n,a) ({ 0; })
+#define audit_fd_pair(n,a) ((void)0)
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)
 #define audit_mq_open(o,m,a) ((void)0)

commit 564f6993ffef656aebaf46cf2f1f6cb4f5c97207
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 14 04:02:26 2008 -0500

    sanitize audit_mq_open()
    
    * don't bother with allocations
    * don't do double copy_from_user()
    * don't duplicate parts of check for audit_dummy_context()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 67f0cdd991ba..54978bdd2bd4 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -450,7 +450,7 @@ extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
-extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
+extern void __audit_mq_open(int oflag, mode_t mode, struct mq_attr *attr);
 extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
 extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
 extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
@@ -475,11 +475,10 @@ static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid
 	if (unlikely(!audit_dummy_context()))
 		__audit_ipc_set_perm(qbytes, uid, gid, mode);
 }
-static inline int audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr)
+static inline void audit_mq_open(int oflag, mode_t mode, struct mq_attr *attr)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_mq_open(oflag, mode, u_attr);
-	return 0;
+		__audit_mq_open(oflag, mode, attr);
 }
 static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout)
 {
@@ -541,7 +540,7 @@ extern int audit_signals;
 #define audit_fd_pair(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)
-#define audit_mq_open(o,m,a) ({ 0; })
+#define audit_mq_open(o,m,a) ((void)0)
 #define audit_mq_sendrecv(d,l,p,t) ((void)0)
 #define audit_mq_notify(d,n) ((void)0)
 #define audit_mq_getsetattr(d,s) ((void)0)

commit c32c8af43b9adde8d6f938d8e6328c13b8de79ac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 14 03:46:48 2008 -0500

    sanitize AUDIT_MQ_SENDRECV
    
    * logging the original value of *msg_prio in mq_timedreceive(2)
      is insane - the argument is write-only (i.e. syscall always
      ignores the original value and only overwrites it).
    * merge __audit_mq_timed{send,receive}
    * don't do copy_from_user() twice
    * don't mess with allocations in auditsc part
    * ... and don't bother checking !audit_enabled and !context in there -
      we'd already checked for audit_dummy_context().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8101d2c4a995..67f0cdd991ba 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -451,8 +451,7 @@ extern int audit_sockaddr(int len, void *addr);
 extern int __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
 extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
-extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout);
-extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
+extern void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout);
 extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
 extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
@@ -482,17 +481,10 @@ static inline int audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u
 		return __audit_mq_open(oflag, mode, u_attr);
 	return 0;
 }
-static inline int audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout)
+static inline void audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_mq_timedsend(mqdes, msg_len, msg_prio, u_abs_timeout);
-	return 0;
-}
-static inline int audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout)
-{
-	if (unlikely(!audit_dummy_context()))
-		return __audit_mq_timedreceive(mqdes, msg_len, u_msg_prio, u_abs_timeout);
-	return 0;
+		__audit_mq_sendrecv(mqdes, msg_len, msg_prio, abs_timeout);
 }
 static inline void audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 {
@@ -550,8 +542,7 @@ extern int audit_signals;
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)
 #define audit_mq_open(o,m,a) ({ 0; })
-#define audit_mq_timedsend(d,l,p,t) ({ 0; })
-#define audit_mq_timedreceive(d,l,p,t) ({ 0; })
+#define audit_mq_sendrecv(d,l,p,t) ((void)0)
 #define audit_mq_notify(d,n) ((void)0)
 #define audit_mq_getsetattr(d,s) ((void)0)
 #define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })

commit 20114f71b27cafeb7c7e41d2b0f0b68c3fbb022b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 07:16:12 2008 -0500

    sanitize audit_mq_notify()
    
    * don't copy_from_user() twice
    * don't bother with allocations
    * don't duplicate parts of audit_dummy_context()
    * make it return void
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b7707e577b80..8101d2c4a995 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -453,7 +453,7 @@ extern int audit_set_macxattr(const char *name);
 extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
 extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout);
 extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
-extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
+extern void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification);
 extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *new,
@@ -494,11 +494,10 @@ static inline int audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned in
 		return __audit_mq_timedreceive(mqdes, msg_len, u_msg_prio, u_abs_timeout);
 	return 0;
 }
-static inline int audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
+static inline void audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_mq_notify(mqdes, u_notification);
-	return 0;
+		__audit_mq_notify(mqdes, notification);
 }
 static inline void audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 {
@@ -553,7 +552,7 @@ extern int audit_signals;
 #define audit_mq_open(o,m,a) ({ 0; })
 #define audit_mq_timedsend(d,l,p,t) ({ 0; })
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
-#define audit_mq_notify(d,n) ({ 0; })
+#define audit_mq_notify(d,n) ((void)0)
 #define audit_mq_getsetattr(d,s) ((void)0)
 #define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
 #define audit_log_capset(pid, ncr, ocr) ({ 0; })

commit 7392906ea915b9a2c14dea32b3604b4e178f82f7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 06:58:59 2008 -0500

    sanitize audit_mq_getsetattr()
    
    * get rid of allocations
    * make it return void
    * don't duplicate parts of audit_dummy_context()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b7abfe0d6737..b7707e577b80 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -454,7 +454,7 @@ extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr
 extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout);
 extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
 extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
-extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
+extern void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *new,
 				  const struct cred *old);
@@ -500,11 +500,10 @@ static inline int audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_n
 		return __audit_mq_notify(mqdes, u_notification);
 	return 0;
 }
-static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
+static inline void audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_mq_getsetattr(mqdes, mqstat);
-	return 0;
+		__audit_mq_getsetattr(mqdes, mqstat);
 }
 
 static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
@@ -555,7 +554,7 @@ extern int audit_signals;
 #define audit_mq_timedsend(d,l,p,t) ({ 0; })
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
 #define audit_mq_notify(d,n) ({ 0; })
-#define audit_mq_getsetattr(d,s) ({ 0; })
+#define audit_mq_getsetattr(d,s) ((void)0)
 #define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
 #define audit_log_capset(pid, ncr, ocr) ({ 0; })
 #define audit_ptrace(t) ((void)0)

commit e816f370cbadd2afea9f1a42f232d0636137d563
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 03:47:15 2008 -0500

    sanitize audit_ipc_set_perm()
    
    * get rid of allocations
    * make it return void
    * simplify callers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f8578b9088e1..b7abfe0d6737 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -444,7 +444,7 @@ extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
-extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
 extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
@@ -471,11 +471,10 @@ static inline int audit_fd_pair(int fd1, int fd2)
 		return __audit_fd_pair(fd1, fd2);
 	return 0;
 }
-static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
+static inline void audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_ipc_set_perm(qbytes, uid, gid, mode);
-	return 0;
+		__audit_ipc_set_perm(qbytes, uid, gid, mode);
 }
 static inline int audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr)
 {
@@ -546,7 +545,7 @@ extern int audit_signals;
 #define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
 #define audit_ipc_obj(i) ((void)0)
-#define audit_ipc_set_perm(q,u,g,m) ({ 0; })
+#define audit_ipc_set_perm(q,u,g,m) ((void)0)
 #define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ((void)0)
 #define audit_fd_pair(n,a) ({ 0; })

commit a33e6751003c5ade603737d828b1519d980ce392
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 03:40:06 2008 -0500

    sanitize audit_ipc_obj()
    
    * get rid of allocations
    * make it return void
    * simplify callers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 466a953d4bf6..f8578b9088e1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -443,7 +443,7 @@ extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
 #define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
-extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
+extern void __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
 extern void audit_socketcall(int nargs, unsigned long *args);
@@ -460,11 +460,10 @@ extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				  const struct cred *old);
 extern int __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
 
-static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
+static inline void audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_ipc_obj(ipcp);
-	return 0;
+		__audit_ipc_obj(ipcp);
 }
 static inline int audit_fd_pair(int fd1, int fd2)
 {
@@ -546,7 +545,7 @@ extern int audit_signals;
 #define audit_get_loginuid(t) (-1)
 #define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
-#define audit_ipc_obj(i) ({ 0; })
+#define audit_ipc_obj(i) ((void)0)
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })
 #define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ((void)0)

commit f3298dc4f2277874d40cb4fc3a6e277317d6603b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 03:16:51 2008 -0500

    sanitize audit_socketcall
    
    * don't bother with allocations
    * now that it can't fail, make it return void
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 26c4f6f65a46..466a953d4bf6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -446,7 +446,7 @@ extern void audit_log_task_context(struct audit_buffer *ab);
 extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
-extern int audit_socketcall(int nargs, unsigned long *args);
+extern void audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int __audit_fd_pair(int fd1, int fd2);
 extern int audit_set_macxattr(const char *name);
@@ -549,7 +549,7 @@ extern int audit_signals;
 #define audit_ipc_obj(i) ({ 0; })
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })
 #define audit_bprm(p) ({ 0; })
-#define audit_socketcall(n,a) ({ 0; })
+#define audit_socketcall(n,a) ((void)0)
 #define audit_fd_pair(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)

commit cbacc2c7f066a1e01b33b0e27ae5efbf534bc2db
Merge: 4a6908a3a050 74192246910f
Author: James Morris <jmorris@namei.org>
Date:   Thu Dec 25 11:40:09 2008 +1100

    Merge branch 'next' into for-linus

commit 48887e63d6e057543067327da6b091297f7fe645
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 6 01:05:50 2008 -0500

    [PATCH] fix broken timestamps in AVC generated by kernel threads
    
    Timestamp in audit_context is valid only if ->in_syscall is set.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1b2a6a5c1876..8f0672d13eb1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -435,7 +435,7 @@ static inline void audit_ptrace(struct task_struct *t)
 
 				/* Private API (for audit.c only) */
 extern unsigned int audit_serial(void);
-extern void auditsc_get_stamp(struct audit_context *ctx,
+extern int auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
@@ -518,7 +518,7 @@ extern int audit_signals;
 #define audit_inode(n,d) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
-#define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
+#define auditsc_get_stamp(c,t,s) (0)
 #define audit_get_loginuid(t) (-1)
 #define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)

commit a64e64944f4b8ce3288519555dbaa0232414b8ac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 12 18:37:41 2008 -0500

    [PATCH] return records for fork() both to child and parent
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 6272a395d43c..1b2a6a5c1876 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -391,6 +391,7 @@ extern int audit_classify_arch(int arch);
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */
+extern void audit_finish_fork(struct task_struct *child);
 extern int  audit_alloc(struct task_struct *task);
 extern void audit_free(struct task_struct *task);
 extern void audit_syscall_entry(int arch,
@@ -504,6 +505,7 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 extern int audit_n_rules;
 extern int audit_signals;
 #else
+#define audit_finish_fork(t)
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
 #define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)

commit a6f76f23d297f70e2a6b3ec607f7aeeea9e37e8d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:24 2008 +1100

    CRED: Make execve() take advantage of copy-on-write credentials
    
    Make execve() take advantage of copy-on-write credentials, allowing it to set
    up the credentials in advance, and then commit the whole lot after the point
    of no return.
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         The credential bits from struct linux_binprm are, for the most part,
         replaced with a single credentials pointer (bprm->cred).  This means that
         all the creds can be calculated in advance and then applied at the point
         of no return with no possibility of failure.
    
         I would like to replace bprm->cap_effective with:
    
            cap_isclear(bprm->cap_effective)
    
         but this seems impossible due to special behaviour for processes of pid 1
         (they always retain their parent's capability masks where normally they'd
         be changed - see cap_bprm_set_creds()).
    
         The following sequence of events now happens:
    
         (a) At the start of do_execve, the current task's cred_exec_mutex is
             locked to prevent PTRACE_ATTACH from obsoleting the calculation of
             creds that we make.
    
         (a) prepare_exec_creds() is then called to make a copy of the current
             task's credentials and prepare it.  This copy is then assigned to
             bprm->cred.
    
             This renders security_bprm_alloc() and security_bprm_free()
             unnecessary, and so they've been removed.
    
         (b) The determination of unsafe execution is now performed immediately
             after (a) rather than later on in the code.  The result is stored in
             bprm->unsafe for future reference.
    
         (c) prepare_binprm() is called, possibly multiple times.
    
             (i) This applies the result of set[ug]id binaries to the new creds
                 attached to bprm->cred.  Personality bit clearance is recorded,
                 but now deferred on the basis that the exec procedure may yet
                 fail.
    
             (ii) This then calls the new security_bprm_set_creds().  This should
                 calculate the new LSM and capability credentials into *bprm->cred.
    
                 This folds together security_bprm_set() and parts of
                 security_bprm_apply_creds() (these two have been removed).
                 Anything that might fail must be done at this point.
    
             (iii) bprm->cred_prepared is set to 1.
    
                 bprm->cred_prepared is 0 on the first pass of the security
                 calculations, and 1 on all subsequent passes.  This allows SELinux
                 in (ii) to base its calculations only on the initial script and
                 not on the interpreter.
    
         (d) flush_old_exec() is called to commit the task to execution.  This
             performs the following steps with regard to credentials:
    
             (i) Clear pdeath_signal and set dumpable on certain circumstances that
                 may not be covered by commit_creds().
    
             (ii) Clear any bits in current->personality that were deferred from
                 (c.i).
    
         (e) install_exec_creds() [compute_creds() as was] is called to install the
             new credentials.  This performs the following steps with regard to
             credentials:
    
             (i) Calls security_bprm_committing_creds() to apply any security
                 requirements, such as flushing unauthorised files in SELinux, that
                 must be done before the credentials are changed.
    
                 This is made up of bits of security_bprm_apply_creds() and
                 security_bprm_post_apply_creds(), both of which have been removed.
                 This function is not allowed to fail; anything that might fail
                 must have been done in (c.ii).
    
             (ii) Calls commit_creds() to apply the new credentials in a single
                 assignment (more or less).  Possibly pdeath_signal and dumpable
                 should be part of struct creds.
    
             (iii) Unlocks the task's cred_replace_mutex, thus allowing
                 PTRACE_ATTACH to take place.
    
             (iv) Clears The bprm->cred pointer as the credentials it was holding
                 are now immutable.
    
             (v) Calls security_bprm_committed_creds() to apply any security
                 alterations that must be done after the creds have been changed.
                 SELinux uses this to flush signals and signal handlers.
    
         (f) If an error occurs before (d.i), bprm_free() will call abort_creds()
             to destroy the proposed new credentials and will then unlock
             cred_replace_mutex.  No changes to the credentials will have been
             made.
    
     (2) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_bprm_alloc(), ->bprm_alloc_security()
         (*) security_bprm_free(), ->bprm_free_security()
    
             Removed in favour of preparing new credentials and modifying those.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
         (*) security_bprm_post_apply_creds(), ->bprm_post_apply_creds()
    
             Removed; split between security_bprm_set_creds(),
             security_bprm_committing_creds() and security_bprm_committed_creds().
    
         (*) security_bprm_set(), ->bprm_set_security()
    
             Removed; folded into security_bprm_set_creds().
    
         (*) security_bprm_set_creds(), ->bprm_set_creds()
    
             New.  The new credentials in bprm->creds should be checked and set up
             as appropriate.  bprm->cred_prepared is 0 on the first call, 1 on the
             second and subsequent calls.
    
         (*) security_bprm_committing_creds(), ->bprm_committing_creds()
         (*) security_bprm_committed_creds(), ->bprm_committed_creds()
    
             New.  Apply the security effects of the new credentials.  This
             includes closing unauthorised files in SELinux.  This function may not
             fail.  When the former is called, the creds haven't yet been applied
             to the process; when the latter is called, they have.
    
             The former may access bprm->cred, the latter may not.
    
     (3) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) The bprm_security_struct struct has been removed in favour of using
             the credentials-under-construction approach.
    
         (c) flush_unauthorized_files() now takes a cred pointer and passes it on
             to inode_has_perm(), file_has_perm() and dentry_open().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 0b2fcb698a63..e8ce2c4c7ac7 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -508,22 +508,6 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 	return 0;
 }
 
-/*
- * ieieeeeee, an audit function without a return code!
- *
- * This function might fail!  I decided that it didn't matter.  We are too late
- * to fail the syscall and the information isn't REQUIRED for any purpose.  It's
- * just nice to have.  We should be able to look at past audit logs to figure
- * out this process's current cap set along with the fcaps from the PATH record
- * and use that to come up with the final set.  Yeah, its ugly, but all the info
- * is still in the audit log.  So I'm not going to bother mentioning we failed
- * if we couldn't allocate memory.
- *
- * If someone changes their mind they could create the aux record earlier and
- * then search here and use that earlier allocation.  But I don't wanna.
- *
- * -Eric
- */
 static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
 				       const struct cred *new,
 				       const struct cred *old)

commit d84f4f992cbd76e8f39c488cf0c5d123843923b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:23 2008 +1100

    CRED: Inaugurate COW credentials
    
    Inaugurate copy-on-write credentials management.  This uses RCU to manage the
    credentials pointer in the task_struct with respect to accesses by other tasks.
    A process may only modify its own credentials, and so does not need locking to
    access or modify its own credentials.
    
    A mutex (cred_replace_mutex) is added to the task_struct to control the effect
    of PTRACE_ATTACHED on credential calculations, particularly with respect to
    execve().
    
    With this patch, the contents of an active credentials struct may not be
    changed directly; rather a new set of credentials must be prepared, modified
    and committed using something like the following sequence of events:
    
            struct cred *new = prepare_creds();
            int ret = blah(new);
            if (ret < 0) {
                    abort_creds(new);
                    return ret;
            }
            return commit_creds(new);
    
    There are some exceptions to this rule: the keyrings pointed to by the active
    credentials may be instantiated - keyrings violate the COW rule as managing
    COW keyrings is tricky, given that it is possible for a task to directly alter
    the keys in a keyring in use by another task.
    
    To help enforce this, various pointers to sets of credentials, such as those in
    the task_struct, are declared const.  The purpose of this is compile-time
    discouragement of altering credentials through those pointers.  Once a set of
    credentials has been made public through one of these pointers, it may not be
    modified, except under special circumstances:
    
      (1) Its reference count may incremented and decremented.
    
      (2) The keyrings to which it points may be modified, but not replaced.
    
    The only safe way to modify anything else is to create a replacement and commit
    using the functions described in Documentation/credentials.txt (which will be
    added by a later patch).
    
    This patch and the preceding patches have been tested with the LTP SELinux
    testsuite.
    
    This patch makes several logical sets of alteration:
    
     (1) execve().
    
         This now prepares and commits credentials in various places in the
         security code rather than altering the current creds directly.
    
     (2) Temporary credential overrides.
    
         do_coredump() and sys_faccessat() now prepare their own credentials and
         temporarily override the ones currently on the acting thread, whilst
         preventing interference from other threads by holding cred_replace_mutex
         on the thread being dumped.
    
         This will be replaced in a future patch by something that hands down the
         credentials directly to the functions being called, rather than altering
         the task's objective credentials.
    
     (3) LSM interface.
    
         A number of functions have been changed, added or removed:
    
         (*) security_capset_check(), ->capset_check()
         (*) security_capset_set(), ->capset_set()
    
             Removed in favour of security_capset().
    
         (*) security_capset(), ->capset()
    
             New.  This is passed a pointer to the new creds, a pointer to the old
             creds and the proposed capability sets.  It should fill in the new
             creds or return an error.  All pointers, barring the pointer to the
             new creds, are now const.
    
         (*) security_bprm_apply_creds(), ->bprm_apply_creds()
    
             Changed; now returns a value, which will cause the process to be
             killed if it's an error.
    
         (*) security_task_alloc(), ->task_alloc_security()
    
             Removed in favour of security_prepare_creds().
    
         (*) security_cred_free(), ->cred_free()
    
             New.  Free security data attached to cred->security.
    
         (*) security_prepare_creds(), ->cred_prepare()
    
             New. Duplicate any security data attached to cred->security.
    
         (*) security_commit_creds(), ->cred_commit()
    
             New. Apply any security effects for the upcoming installation of new
             security by commit_creds().
    
         (*) security_task_post_setuid(), ->task_post_setuid()
    
             Removed in favour of security_task_fix_setuid().
    
         (*) security_task_fix_setuid(), ->task_fix_setuid()
    
             Fix up the proposed new credentials for setuid().  This is used by
             cap_set_fix_setuid() to implicitly adjust capabilities in line with
             setuid() changes.  Changes are made to the new credentials, rather
             than the task itself as in security_task_post_setuid().
    
         (*) security_task_reparent_to_init(), ->task_reparent_to_init()
    
             Removed.  Instead the task being reparented to init is referred
             directly to init's credentials.
    
             NOTE!  This results in the loss of some state: SELinux's osid no
             longer records the sid of the thread that forked it.
    
         (*) security_key_alloc(), ->key_alloc()
         (*) security_key_permission(), ->key_permission()
    
             Changed.  These now take cred pointers rather than task pointers to
             refer to the security context.
    
     (4) sys_capset().
    
         This has been simplified and uses less locking.  The LSM functions it
         calls have been merged.
    
     (5) reparent_to_kthreadd().
    
         This gives the current thread the same credentials as init by simply using
         commit_thread() to point that way.
    
     (6) __sigqueue_alloc() and switch_uid()
    
         __sigqueue_alloc() can't stop the target task from changing its creds
         beneath it, so this function gets a reference to the currently applicable
         user_struct which it then passes into the sigqueue struct it returns if
         successful.
    
         switch_uid() is now called from commit_creds(), and possibly should be
         folded into that.  commit_creds() should take care of protecting
         __sigqueue_alloc().
    
     (7) [sg]et[ug]id() and co and [sg]et_current_groups.
    
         The set functions now all use prepare_creds(), commit_creds() and
         abort_creds() to build and check a new set of credentials before applying
         it.
    
         security_task_set[ug]id() is called inside the prepared section.  This
         guarantees that nothing else will affect the creds until we've finished.
    
         The calling of set_dumpable() has been moved into commit_creds().
    
         Much of the functionality of set_user() has been moved into
         commit_creds().
    
         The get functions all simply access the data directly.
    
     (8) security_task_prctl() and cap_task_prctl().
    
         security_task_prctl() has been modified to return -ENOSYS if it doesn't
         want to handle a function, or otherwise return the return value directly
         rather than through an argument.
    
         Additionally, cap_task_prctl() now prepares a new set of credentials, even
         if it doesn't end up using it.
    
     (9) Keyrings.
    
         A number of changes have been made to the keyrings code:
    
         (a) switch_uid_keyring(), copy_keys(), exit_keys() and suid_keys() have
             all been dropped and built in to the credentials functions directly.
             They may want separating out again later.
    
         (b) key_alloc() and search_process_keyrings() now take a cred pointer
             rather than a task pointer to specify the security context.
    
         (c) copy_creds() gives a new thread within the same thread group a new
             thread keyring if its parent had one, otherwise it discards the thread
             keyring.
    
         (d) The authorisation key now points directly to the credentials to extend
             the search into rather pointing to the task that carries them.
    
         (e) Installing thread, process or session keyrings causes a new set of
             credentials to be created, even though it's not strictly necessary for
             process or session keyrings (they're shared).
    
    (10) Usermode helper.
    
         The usermode helper code now carries a cred struct pointer in its
         subprocess_info struct instead of a new session keyring pointer.  This set
         of credentials is derived from init_cred and installed on the new process
         after it has been cloned.
    
         call_usermodehelper_setup() allocates the new credentials and
         call_usermodehelper_freeinfo() discards them if they haven't been used.  A
         special cred function (prepare_usermodeinfo_creds()) is provided
         specifically for call_usermodehelper_setup() to call.
    
         call_usermodehelper_setkeys() adjusts the credentials to sport the
         supplied keyring as the new session keyring.
    
    (11) SELinux.
    
         SELinux has a number of changes, in addition to those to support the LSM
         interface changes mentioned above:
    
         (a) selinux_setprocattr() no longer does its check for whether the
             current ptracer can access processes with the new SID inside the lock
             that covers getting the ptracer's SID.  Whilst this lock ensures that
             the check is done with the ptracer pinned, the result is only valid
             until the lock is released, so there's no point doing it inside the
             lock.
    
    (12) is_single_threaded().
    
         This function has been extracted from selinux_setprocattr() and put into
         a file of its own in the lib/ directory as join_session_keyring() now
         wants to use it too.
    
         The code in SELinux just checked to see whether a task shared mm_structs
         with other tasks (CLONE_VM), but that isn't good enough.  We really want
         to know if they're part of the same thread group (CLONE_THREAD).
    
    (13) nfsd.
    
         The NFS server daemon now has to use the COW credentials to set the
         credentials it is going to use.  It really needs to pass the credentials
         down to the functions it calls, but it can't do that until other patches
         in this series have been applied.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 6fbebac7b1bf..0b2fcb698a63 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -454,8 +454,10 @@ extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_pr
 extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
 extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
 extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
-extern void __audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t *pP, kernel_cap_t *pE);
-extern int __audit_log_capset(pid_t pid, kernel_cap_t *eff, kernel_cap_t *inh, kernel_cap_t *perm);
+extern int __audit_log_bprm_fcaps(struct linux_binprm *bprm,
+				  const struct cred *new,
+				  const struct cred *old);
+extern int __audit_log_capset(pid_t pid, const struct cred *new, const struct cred *old);
 
 static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -522,16 +524,20 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
  *
  * -Eric
  */
-static inline void audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t *pP, kernel_cap_t *pE)
+static inline int audit_log_bprm_fcaps(struct linux_binprm *bprm,
+				       const struct cred *new,
+				       const struct cred *old)
 {
 	if (unlikely(!audit_dummy_context()))
-		__audit_log_bprm_fcaps(bprm, pP, pE);
+		return __audit_log_bprm_fcaps(bprm, new, old);
+	return 0;
 }
 
-static inline int audit_log_capset(pid_t pid, kernel_cap_t *eff, kernel_cap_t *inh, kernel_cap_t *perm)
+static inline int audit_log_capset(pid_t pid, const struct cred *new,
+				   const struct cred *old)
 {
 	if (unlikely(!audit_dummy_context()))
-		return __audit_log_capset(pid, eff, inh, perm);
+		return __audit_log_capset(pid, new, old);
 	return 0;
 }
 
@@ -566,8 +572,8 @@ extern int audit_signals;
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
 #define audit_mq_notify(d,n) ({ 0; })
 #define audit_mq_getsetattr(d,s) ({ 0; })
-#define audit_log_bprm_fcaps(b, p, e) do { ; } while (0)
-#define audit_log_capset(pid, e, i, p) ({ 0; })
+#define audit_log_bprm_fcaps(b, ncr, ocr) ({ 0; })
+#define audit_log_capset(pid, ncr, ocr) ({ 0; })
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0

commit e68b75a027bb94066576139ee33676264f867b87
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Nov 11 21:48:22 2008 +1100

    When the capset syscall is used it is not possible for audit to record the
    actual capbilities being added/removed.  This patch adds a new record type
    which emits the target pid and the eff, inh, and perm cap sets.
    
    example output if you audit capset syscalls would be:
    
    type=SYSCALL msg=audit(1225743140.465:76): arch=c000003e syscall=126 success=yes exit=0 a0=17f2014 a1=17f201c a2=80000000 a3=7fff2ab7f060 items=0 ppid=2160 pid=2223 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=1 comm="setcap" exe="/usr/sbin/setcap" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)
    type=UNKNOWN[1322] msg=audit(1225743140.465:76): pid=0 cap_pi=ffffffffffffffff cap_pp=ffffffffffffffff cap_pe=ffffffffffffffff
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8cfb9feb2a05..6fbebac7b1bf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -100,6 +100,7 @@
 #define AUDIT_TTY		1319	/* Input on an administrative TTY */
 #define AUDIT_EOE		1320	/* End of multi-record event */
 #define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
+#define AUDIT_CAPSET		1322	/* Record showing argument to sys_capset */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -454,6 +455,7 @@ extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __u
 extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
 extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 extern void __audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t *pP, kernel_cap_t *pE);
+extern int __audit_log_capset(pid_t pid, kernel_cap_t *eff, kernel_cap_t *inh, kernel_cap_t *perm);
 
 static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -526,6 +528,13 @@ static inline void audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t
 		__audit_log_bprm_fcaps(bprm, pP, pE);
 }
 
+static inline int audit_log_capset(pid_t pid, kernel_cap_t *eff, kernel_cap_t *inh, kernel_cap_t *perm)
+{
+	if (unlikely(!audit_dummy_context()))
+		return __audit_log_capset(pid, eff, inh, perm);
+	return 0;
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else
@@ -558,6 +567,7 @@ extern int audit_signals;
 #define audit_mq_notify(d,n) ({ 0; })
 #define audit_mq_getsetattr(d,s) ({ 0; })
 #define audit_log_bprm_fcaps(b, p, e) do { ; } while (0)
+#define audit_log_capset(pid, e, i, p) ({ 0; })
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0

commit 3fc689e96c0c90b6fede5946d6c31075e9464f69
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Nov 11 21:48:18 2008 +1100

    Any time fcaps or a setuid app under SECURE_NOROOT is used to result in a
    non-zero pE we will crate a new audit record which contains the entire set
    of known information about the executable in question, fP, fI, fE, fversion
    and includes the process's pE, pI, pP.  Before and after the bprm capability
    are applied.  This record type will only be emitted from execve syscalls.
    
    an example of making ping use fcaps instead of setuid:
    
    setcap "cat_net_raw+pe" /bin/ping
    
    type=SYSCALL msg=audit(1225742021.015:236): arch=c000003e syscall=59 success=yes exit=0 a0=1457f30 a1=14606b0 a2=1463940 a3=321b770a70 items=2 ppid=2929 pid=2963 auid=0 uid=500 gid=500 euid=500 suid=500 fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=3 comm="ping" exe="/bin/ping" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)
    type=UNKNOWN[1321] msg=audit(1225742021.015:236): fver=2 fp=0000000000002000 fi=0000000000000000 fe=1 old_pp=0000000000000000 old_pi=0000000000000000 old_pe=0000000000000000 new_pp=0000000000002000 new_pi=0000000000000000 new_pe=0000000000002000
    type=EXECVE msg=audit(1225742021.015:236): argc=2 a0="ping" a1="127.0.0.1"
    type=CWD msg=audit(1225742021.015:236):  cwd="/home/test"
    type=PATH msg=audit(1225742021.015:236): item=0 name="/bin/ping" inode=49256 dev=fd:00 mode=0100755 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:ping_exec_t:s0 cap_fp=0000000000002000 cap_fe=1 cap_fver=2
    type=PATH msg=audit(1225742021.015:236): item=1 name=(null) inode=507915 dev=fd:00 mode=0100755 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:ld_so_t:s0
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 6272a395d43c..8cfb9feb2a05 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -99,6 +99,7 @@
 #define AUDIT_OBJ_PID		1318	/* ptrace target */
 #define AUDIT_TTY		1319	/* Input on an administrative TTY */
 #define AUDIT_EOE		1320	/* End of multi-record event */
+#define AUDIT_BPRM_FCAPS	1321	/* Information about fcaps increasing perms */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -452,6 +453,7 @@ extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_pr
 extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
 extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
 extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
+extern void __audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t *pP, kernel_cap_t *pE);
 
 static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -501,6 +503,29 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 		return __audit_mq_getsetattr(mqdes, mqstat);
 	return 0;
 }
+
+/*
+ * ieieeeeee, an audit function without a return code!
+ *
+ * This function might fail!  I decided that it didn't matter.  We are too late
+ * to fail the syscall and the information isn't REQUIRED for any purpose.  It's
+ * just nice to have.  We should be able to look at past audit logs to figure
+ * out this process's current cap set along with the fcaps from the PATH record
+ * and use that to come up with the final set.  Yeah, its ugly, but all the info
+ * is still in the audit log.  So I'm not going to bother mentioning we failed
+ * if we couldn't allocate memory.
+ *
+ * If someone changes their mind they could create the aux record earlier and
+ * then search here and use that earlier allocation.  But I don't wanna.
+ *
+ * -Eric
+ */
+static inline void audit_log_bprm_fcaps(struct linux_binprm *bprm, kernel_cap_t *pP, kernel_cap_t *pE)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_log_bprm_fcaps(bprm, pP, pE);
+}
+
 extern int audit_n_rules;
 extern int audit_signals;
 #else
@@ -532,6 +557,7 @@ extern int audit_signals;
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
 #define audit_mq_notify(d,n) ({ 0; })
 #define audit_mq_getsetattr(d,s) ({ 0; })
+#define audit_log_bprm_fcaps(b, p, e) do { ; } while (0)
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #define audit_signals 0

commit f606ddf42fd4edc558eeb48bfee66d2c591571d2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jul 23 21:28:50 2008 -0700

    remove the v850 port
    
    Trying to compile the v850 port brings many compile errors, one of them exists
    since at least kernel 2.6.19.
    
    There also seems to be noone willing to bring this port back into a usable
    state.
    
    This patch therefore removes the v850 port.
    
    If anyone ever decides to revive the v850 port the code will still be
    available from older kernels, and it wouldn't be impossible for the port to
    reenter the kernel if it would become actively maintained again.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8b82974bdc12..6272a395d43c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -286,7 +286,6 @@
 #define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_SPARC	(EM_SPARC)
 #define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
-#define AUDIT_ARCH_V850		(EM_V850|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 
 #define AUDIT_PERM_EXEC		1

commit d8de72473effd674a3c1fe9621821f406f5587c9
Author: Peng Haitao <penght@cn.fujitsu.com>
Date:   Tue May 20 09:13:02 2008 +0800

    [PATCH] remove useless argument type in audit_filter_user()
    
    The second argument "type" is not used in audit_filter_user(), so I think that type can be removed. If I'm wrong, please tell me.
    
    Signed-off-by: Peng Haitao <penght@cn.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 63c3bb98558f..8b82974bdc12 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -571,7 +571,7 @@ extern void		    audit_log_lost(const char *message);
 extern int		    audit_update_lsm_rules(void);
 
 				/* Private API (for audit.c only) */
-extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
+extern int audit_filter_user(struct netlink_skb_parms *cb);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				void *data, size_t datasz, uid_t loginuid,

commit 8b67dca9420474623709e00d72a066068a502b20
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 28 04:15:49 2008 -0400

    [PATCH] new predicate - AUDIT_FILETYPE
    
    Argument is S_IF... | <index>, where index is normally 0 or 1.
    Triggers if chosen element of ctx->names[] is present and the
    mode of object in question matches the upper bits of argument.
    I.e. for things like "is the argument of that chmod a directory",
    etc.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index dcd5395b400d..63c3bb98558f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -209,6 +209,7 @@
 #define AUDIT_WATCH	105
 #define AUDIT_PERM	106
 #define AUDIT_DIR	107
+#define AUDIT_FILETYPE	108
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit a42da93c8641a0b49405ceb2a2063975c823aa49
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 18 10:36:22 2008 -0400

    Audit: increase the maximum length of the key field
    
    Key lengths were arbitrarily limited to 32 characters.  If userspace is going
    to start using the single kernel key field as multiple virtual key fields
    (example key=key1,key2,key3,key4) we should give them enough room to work.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f938335af75e..dcd5395b400d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -146,7 +146,7 @@
 /* Rule structure sizes -- if these change, different AUDIT_ADD and
  * AUDIT_LIST commands must be implemented. */
 #define AUDIT_MAX_FIELDS   64
-#define AUDIT_MAX_KEY_LEN  32
+#define AUDIT_MAX_KEY_LEN  256
 #define AUDIT_BITMASK_SIZE 64
 #define AUDIT_WORD(nr) ((__u32)((nr)/32))
 #define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))

commit b556f8ad58c6e9f8f485c8cef7546e3fc82c382a
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 18 10:12:59 2008 -0400

    Audit: standardize string audit interfaces
    
    This patch standardized the string auditing interfaces.  No userspace
    changes will be visible and this is all just cleanup and consistancy
    work.  We have the following string audit interfaces to use:
    
    void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf, size_t len);
    
    void audit_log_n_string(struct audit_buffer *ab, const char *buf, size_t n);
    void audit_log_string(struct audit_buffer *ab, const char *buf);
    
    void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string, size_t n);
    void audit_log_untrustedstring(struct audit_buffer *ab, const char *string);
    
    This may be the first step to possibly fixing some of the issues that
    people have with the string output from the kernel audit system.  But we
    still don't have an agreed upon solution to that problem.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 25f6ae30dd4b..f938335af75e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -549,16 +549,20 @@ extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));
 extern void		    audit_log_end(struct audit_buffer *ab);
-extern void		    audit_log_hex(struct audit_buffer *ab,
-					  const unsigned char *buf,
-					  size_t len);
 extern int		    audit_string_contains_control(const char *string,
 							  size_t len);
+extern void		    audit_log_n_hex(struct audit_buffer *ab,
+					  const unsigned char *buf,
+					  size_t len);
+extern void		    audit_log_n_string(struct audit_buffer *ab,
+					       const char *buf,
+					       size_t n);
+#define audit_log_string(a,b) audit_log_n_string(a, b, strlen(b));
+extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
+							const char *string,
+							size_t n);
 extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
 						      const char *string);
-extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
-							size_t n,
-							const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct path *path);
@@ -578,9 +582,11 @@ extern int audit_enabled;
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)
 #define audit_log_end(b) do { ; } while (0)
-#define audit_log_hex(a,b,l) do { ; } while (0)
-#define audit_log_untrustedstring(a,s) do { ; } while (0)
+#define audit_log_n_hex(a,b,l) do { ; } while (0)
+#define audit_log_n_string(a,c,l) do { ; } while (0)
+#define audit_log_string(a,c) do { ; } while (0)
 #define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
+#define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b, p, d) do { ; } while (0)
 #define audit_enabled 0
 #endif

commit 2532386f480eefbdd67b48be55fb4fb3e5a6081c
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 18 10:09:25 2008 -0400

    Audit: collect sessionid in netlink messages
    
    Previously I added sessionid output to all audit messages where it was
    available but we still didn't know the sessionid of the sender of
    netlink messages.  This patch adds that information to netlink messages
    so we can audit who sent netlink messages.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4ccb048cae1d..25f6ae30dd4b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -569,7 +569,8 @@ extern int		    audit_update_lsm_rules(void);
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
-			 void *data, size_t datasz, uid_t loginuid, u32 sid);
+				void *data, size_t datasz, uid_t loginuid,
+				u32 sessionid, u32 sid);
 extern int audit_enabled;
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)

commit 04305e4aff8b0533dc05f9f6f1a34d0796bd985f
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Sat Apr 19 09:59:43 2008 +1000

    Audit: Final renamings and cleanup
    
    Rename the se_str and se_rule audit fields elements to
    lsm_str and lsm_rule to avoid confusion.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 04869c96016b..4ccb048cae1d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -377,8 +377,8 @@ struct audit_field {
 	u32				type;
 	u32				val;
 	u32				op;
-	char				*se_str;
-	void				*se_rule;
+	char				*lsm_str;
+	void				*lsm_rule;
 };
 
 #define AUDITSC_INVALID 0

commit 9d57a7f9e23dc30783d245280fc9907cf2c87837
Author: Ahmed S. Darwish <darwish.07@gmail.com>
Date:   Sat Mar 1 22:03:14 2008 +0200

    SELinux: use new audit hooks, remove redundant exports
    
    Setup the new Audit LSM hooks for SELinux.
    Remove the now redundant exported SELinux Audit interface.
    
    Audit: Export 'audit_krule' and 'audit_field' to the public
    since their internals are needed by the implementation of the
    new LSM hook 'audit_rule_known'.
    
    Signed-off-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Ahmed S. Darwish <darwish.07@gmail.com>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2af9ec025015..04869c96016b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -353,6 +353,33 @@ struct netlink_skb_parms;
 struct linux_binprm;
 struct mq_attr;
 struct mqstat;
+struct audit_watch;
+struct audit_tree;
+
+struct audit_krule {
+	int			vers_ops;
+	u32			flags;
+	u32			listnr;
+	u32			action;
+	u32			mask[AUDIT_BITMASK_SIZE];
+	u32			buflen; /* for data alloc on list rules */
+	u32			field_count;
+	char			*filterkey; /* ties events to rules */
+	struct audit_field	*fields;
+	struct audit_field	*arch_f; /* quick access to arch field */
+	struct audit_field	*inode_f; /* quick access to an inode field */
+	struct audit_watch	*watch;	/* associated watch */
+	struct audit_tree	*tree;	/* associated watched tree */
+	struct list_head	rlist;	/* entry in audit_{watch,tree}.rules list */
+};
+
+struct audit_field {
+	u32				type;
+	u32				val;
+	u32				op;
+	char				*se_str;
+	void				*se_rule;
+};
 
 #define AUDITSC_INVALID 0
 #define AUDITSC_SUCCESS 1
@@ -536,6 +563,8 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct path *path);
 extern void		    audit_log_lost(const char *message);
+extern int		    audit_update_lsm_rules(void);
+
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);

commit 44707fdf5938ad269ea5d6c5744d82f6a7328746
Author: Jan Blunck <jblunck@suse.de>
Date:   Thu Feb 14 19:38:33 2008 -0800

    d_path: Use struct path in struct avc_audit_data
    
    audit_log_d_path() is a d_path() wrapper that is used by the audit code.  To
    use a struct path in audit_log_d_path() I need to embed it into struct
    avc_audit_data.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 97153027207a..2af9ec025015 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -534,8 +534,7 @@ extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
 							const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
-					     struct dentry *dentry,
-					     struct vfsmount *vfsmnt);
+					     struct path *path);
 extern void		    audit_log_lost(const char *message);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
@@ -552,7 +551,7 @@ extern int audit_enabled;
 #define audit_log_hex(a,b,l) do { ; } while (0)
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
-#define audit_log_d_path(b,p,d,v) do { ; } while (0)
+#define audit_log_d_path(b, p, d) do { ; } while (0)
 #define audit_enabled 0
 #endif
 #endif

commit de6bbd1d30e5912620d25dd15e3f180ac7f9fcef
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Jan 7 14:31:58 2008 -0500

    [AUDIT] break large execve argument logging into smaller messages
    
    execve arguments can be quite large.  There is no limit on the number of
    arguments and a 4G limit on the size of an argument.
    
    this patch prints those aruguments in bite sized pieces.  a userspace size
    limitation of 8k was discovered so this keeps messages around 7.5k
    
    single arguments larger than 7.5k in length are split into multiple records
    and can be identified as aX[Y]=
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4d1c2f2fcc1b..97153027207a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -525,9 +525,11 @@ extern void		    audit_log_end(struct audit_buffer *ab);
 extern void		    audit_log_hex(struct audit_buffer *ab,
 					  const unsigned char *buf,
 					  size_t len);
-extern const char *	    audit_log_untrustedstring(struct audit_buffer *ab,
+extern int		    audit_string_contains_control(const char *string,
+							  size_t len);
+extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
 						      const char *string);
-extern const char *	    audit_log_n_untrustedstring(struct audit_buffer *ab,
+extern void		    audit_log_n_untrustedstring(struct audit_buffer *ab,
 							size_t n,
 							const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,

commit c0641f28dcbecb6dc34a4fd003a9947fcd080696
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Jan 7 13:49:15 2008 -0500

    [AUDIT] Add End of Event record
    
    This patch adds an end of event record type. It will be sent by the kernel as
    the last record when a multi-record event is triggered. This will aid realtime
    analysis programs since they will now reliably know they have the last record
    to complete an event. The audit daemon filters this and will not write it to
    disk.
    
    Signed-off-by: Steve Grubb <sgrubb redhat com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 52f1b12505a9..4d1c2f2fcc1b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -98,6 +98,7 @@
 #define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
 #define AUDIT_OBJ_PID		1318	/* ptrace target */
 #define AUDIT_TTY		1319	/* Input on an administrative TTY */
+#define AUDIT_EOE		1320	/* End of multi-record event */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */

commit 4746ec5b01ed07205a91e4f7ed9de9d70f371407
Author: Eric Paris <eparis@redhat.com>
Date:   Tue Jan 8 10:06:53 2008 -0500

    [AUDIT] add session id to audit messages
    
    In order to correlate audit records to an individual login add a session
    id.  This is incremented every time a user logs in and is included in
    almost all messages which currently output the auid.  The field is
    labeled ses=  or oses=
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d7c6a12f4d1c..52f1b12505a9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -410,6 +410,7 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 #define audit_get_loginuid(t) ((t)->loginuid)
+#define audit_get_sessionid(t) ((t)->sessionid)
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
@@ -489,6 +490,7 @@ extern int audit_signals;
 #define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(t) (-1)
+#define audit_get_sessionid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
 #define audit_ipc_obj(i) ({ 0; })
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })

commit bfef93a5d1fb5654fe2025276c55e202d10b5255
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 10 04:53:18 2008 -0500

    [PATCH] get rid of loginuid races
    
    Keeping loginuid in audit_context is racy and results in messier
    code.  Taken to task_struct, out of the way of ->audit_context
    changes.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f63117fab305..d7c6a12f4d1c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -409,7 +409,7 @@ extern unsigned int audit_serial(void);
 extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
-extern uid_t audit_get_loginuid(struct task_struct *task);
+#define audit_get_loginuid(t) ((t)->loginuid)
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);

commit 0c11b9428f619ab377c92eff2f160a834a6585dd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 10 04:20:52 2008 -0500

    [PATCH] switch audit_get_loginuid() to task_struct *
    
    all callers pass something->audit_context
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bdd6f5de5fc4..f63117fab305 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -409,7 +409,7 @@ extern unsigned int audit_serial(void);
 extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
-extern uid_t audit_get_loginuid(struct audit_context *ctx);
+extern uid_t audit_get_loginuid(struct task_struct *task);
 extern void audit_log_task_context(struct audit_buffer *ab);
 extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
@@ -488,7 +488,7 @@ extern int audit_signals;
 #define audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
-#define audit_get_loginuid(c) ({ -1; })
+#define audit_get_loginuid(t) (-1)
 #define audit_log_task_context(b) do { ; } while (0)
 #define audit_ipc_obj(i) ({ 0; })
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })

commit 13541b3adad2dc2f56761c5193c2b88db3597f0e
Author: Paul Moore <paul.moore@hp.com>
Date:   Tue Jan 29 08:44:23 2008 -0500

    NetLabel: Add auditing to the static labeling mechanism
    
    This patch adds auditing support to the NetLabel static labeling mechanism.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c68781692838..bdd6f5de5fc4 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -115,6 +115,8 @@
 #define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
 #define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
 #define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
+#define AUDIT_MAC_UNLBL_STCADD	1416	/* NetLabel: add a static label */
+#define AUDIT_MAC_UNLBL_STCDEL	1417	/* NetLabel: del a static label */
 
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799

commit 74c3cbe33bc077ac1159cadfea608b501e100344
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 22 08:04:18 2007 -0400

    [PATCH] audit: watching subtrees
    
    New kind of audit rule predicates: "object is visible in given subtree".
    The part that can be sanely implemented, that is.  Limitations:
            * if you have hardlink from outside of tree, you'd better watch
    it too (or just watch the object itself, obviously)
            * if you mount something under a watched tree, tell audit
    that new chunk should be added to watched subtrees
            * if you umount something in a watched tree and it's still mounted
    elsewhere, you will get matches on events happening there.  New command
    tells audit to recalculate the trees, trimming such sources of false
    positives.
    
    Note that it's _not_ about path - if something mounted in several places
    (multiple mount, bindings, different namespaces, etc.), the match does
    _not_ depend on which one we are using for access.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 133b81be60a3..c68781692838 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -63,6 +63,8 @@
 #define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
 #define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
 #define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
+#define AUDIT_TRIM		1014	/* Trim junk from watched tree */
+#define AUDIT_MAKE_EQUIV	1015	/* Append to watched tree */
 #define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
 #define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
 
@@ -203,6 +205,7 @@
 #define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
 #define AUDIT_WATCH	105
 #define AUDIT_PERM	106
+#define AUDIT_DIR	107
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit 5a190ae69766da9a34bf31200c5cea4c0667cf94
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 12:19:32 2007 -0400

    [PATCH] pass dentry to audit_inode()/audit_inode_child()
    
    makes caller simpler *and* allows to scan ancestors
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9ae740936a65..133b81be60a3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -366,8 +366,8 @@ extern void audit_syscall_entry(int arch,
 extern void audit_syscall_exit(int failed, long return_code);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
-extern void __audit_inode(const char *name, const struct inode *inode);
-extern void __audit_inode_child(const char *dname, const struct inode *inode,
+extern void __audit_inode(const char *name, const struct dentry *dentry);
+extern void __audit_inode_child(const char *dname, const struct dentry *dentry,
 				const struct inode *parent);
 extern void __audit_ptrace(struct task_struct *t);
 
@@ -381,15 +381,15 @@ static inline void audit_getname(const char *name)
 	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
 }
-static inline void audit_inode(const char *name, const struct inode *inode) {
+static inline void audit_inode(const char *name, const struct dentry *dentry) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode(name, inode);
+		__audit_inode(name, dentry);
 }
 static inline void audit_inode_child(const char *dname, 
-				     const struct inode *inode,
+				     const struct dentry *dentry,
 				     const struct inode *parent) {
 	if (unlikely(!audit_dummy_context()))
-		__audit_inode_child(dname, inode, parent);
+		__audit_inode_child(dname, dentry, parent);
 }
 void audit_core_dumps(long signr);
 
@@ -477,9 +477,9 @@ extern int audit_signals;
 #define audit_dummy_context() 1
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
-#define __audit_inode(n,i) do { ; } while (0)
+#define __audit_inode(n,d) do { ; } while (0)
 #define __audit_inode_child(d,i,p) do { ; } while (0)
-#define audit_inode(n,i) do { ; } while (0)
+#define audit_inode(n,d) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)

commit ab5f5e8b144e4c804ef3aa1ce08a9ca9f01187ce
Author: Joy Latten <latten@austin.ibm.com>
Date:   Mon Sep 17 11:51:22 2007 -0700

    [XFRM]: xfrm audit calls
    
    This patch modifies the current ipsec audit layer
    by breaking it up into purpose driven audit calls.
    
    So far, the only audit calls made are when add/delete
    an SA/policy. It had been discussed to give each
    key manager it's own calls to do this, but I found
    there to be much redundnacy since they did the exact
    same things, except for how they got auid and sid, so I
    combined them. The below audit calls can be made by any
    key manager. Hopefully, this is ok.
    
    Signed-off-by: Joy Latten <latten@austin.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d6579df8dadf..9ae740936a65 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -108,10 +108,11 @@
 #define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
 #define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
 #define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
-#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Add a XFRM state */
-#define AUDIT_MAC_IPSEC_DELSA	1412	/* Delete a XFRM state */
-#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Add a XFRM policy */
-#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Delete a XFRM policy */
+#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSA	1412	/* Not used  */
+#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Not used */
+#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Not used */
+#define AUDIT_MAC_IPSEC_EVENT	1415	/* Audit an IPSec event */
 
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799

commit 6dc2c1b7798ef645213afc82f6d5eac3d61bc18b
Author: Miloslav Trmac <mitr@redhat.com>
Date:   Thu Aug 23 10:19:53 2007 +0100

    Renumber AUDIT_TTY_[GS]ET
    
    Renumber AUDIT_TTY_[GS]ET to avoid a conflict with netlink message types
    already used in the wild.
    
    Signed-off-by: Miloslav Trmac <mitr@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4bbd8601b8f0..d6579df8dadf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -63,8 +63,8 @@
 #define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
 #define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
 #define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
-#define AUDIT_TTY_GET		1014	/* Get TTY auditing status */
-#define AUDIT_TTY_SET		1015	/* Set TTY auditing status */
+#define AUDIT_TTY_GET		1016	/* Get TTY auditing status */
+#define AUDIT_TTY_SET		1017	/* Set TTY auditing status */
 
 #define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
 #define AUDIT_USER_AVC		1107	/* We filter this differently */

commit 4259fa01a2d2aa3e589b34ba7624080232d9c1ff
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 11:13:31 2007 -0400

    [PATCH] get rid of AVC_PATH postponed treatment
    
            Selinux folks had been complaining about the lack of AVC_PATH
    records when audit is disabled.  I must admit my stupidity - I assumed
    that avc_audit() really couldn't use audit_log_d_path() because of
    deadlocks (== could be called with dcache_lock or vfsmount_lock held).
    Shouldn't have made that assumption - it never gets called that way.
    It _is_ called under spinlocks, but not those.
    
            Since audit_log_d_path() uses ab->gfp_mask for allocations,
    kmalloc() in there is not a problem.  IOW, the simple fix is sufficient:
    let's rip AUDIT_AVC_PATH out and simply generate pathname as part of main
    record.  It's trivial to do.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index a35859ab2fdb..4bbd8601b8f0 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -411,7 +411,6 @@ extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int __audit_fd_pair(int fd1, int fd2);
-extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern int audit_set_macxattr(const char *name);
 extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
 extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout);
@@ -491,7 +490,6 @@ extern int audit_signals;
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_fd_pair(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
-#define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)
 #define audit_mq_open(o,m,a) ({ 0; })
 #define audit_mq_timedsend(d,l,p,t) ({ 0; })

commit 74f2345b6be1410f824cb7dd638d2c10a9709379
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Jun 4 17:00:14 2007 -0400

    [PATCH] allow audit filtering on bit & operations
    
    Right now the audit filter can match on = != > < >= blah blah blah.
    This allow the filter to also look at bitwise AND operations, &
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8ca7ca0b47f0..a35859ab2fdb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -161,7 +161,7 @@
  * are currently used in an audit field constant understood by the kernel.
  * If you are adding a new #define AUDIT_<whatever>, please ensure that
  * AUDIT_UNUSED_BITS is updated if need be. */
-#define AUDIT_UNUSED_BITS	0x0FFFFC00
+#define AUDIT_UNUSED_BITS	0x07FFFC00
 
 
 /* Rule fields */
@@ -213,25 +213,29 @@
 #define AUDIT_NEGATE			0x80000000
 
 /* These are the supported operators.
- *	4  2  1
- *	=  >  <
- *	-------
- *	0  0  0		0	nonsense
- *	0  0  1		1	<
- *	0  1  0		2	>
- *	0  1  1		3	!=
- *	1  0  0		4	=
- *	1  0  1		5	<=
- *	1  1  0		6	>=
- *	1  1  1		7	all operators
+ *	4  2  1  8
+ *	=  >  <  ?
+ *	----------
+ *	0  0  0	 0	00	nonsense
+ *	0  0  0	 1	08	&  bit mask
+ *	0  0  1	 0	10	<
+ *	0  1  0	 0	20	>
+ *	0  1  1	 0	30	!=
+ *	1  0  0	 0	40	=
+ *	1  0  0	 1	48	&=  bit test
+ *	1  0  1	 0	50	<=
+ *	1  1  0	 0	60	>=
+ *	1  1  1	 1	78	all operators
  */
+#define AUDIT_BIT_MASK			0x08000000
 #define AUDIT_LESS_THAN			0x10000000
 #define AUDIT_GREATER_THAN		0x20000000
 #define AUDIT_NOT_EQUAL			0x30000000
 #define AUDIT_EQUAL			0x40000000
+#define AUDIT_BIT_TEST			(AUDIT_BIT_MASK|AUDIT_EQUAL)
 #define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
 #define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
-#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL)
+#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL|AUDIT_BIT_MASK)
 
 /* Status symbols */
 				/* Mask values */

commit 522ed7767e800cff6c650ec64b0ee0677303119c
Author: Miloslav Trmac <mitr@redhat.com>
Date:   Sun Jul 15 23:40:56 2007 -0700

    Audit: add TTY input auditing
    
    Add TTY input auditing, used to audit system administrator's actions.  This is
    required by various security standards such as DCID 6/3 and PCI to provide
    non-repudiation of administrator's actions and to allow a review of past
    actions if the administrator seems to overstep their duties or if the system
    becomes misconfigured for unknown reasons.  These requirements do not make it
    necessary to audit TTY output as well.
    
    Compared to an user-space keylogger, this approach records TTY input using the
    audit subsystem, correlated with other audit events, and it is completely
    transparent to the user-space application (e.g.  the console ioctls still
    work).
    
    TTY input auditing works on a higher level than auditing all system calls
    within the session, which would produce an overwhelming amount of mostly
    useless audit events.
    
    Add an "audit_tty" attribute, inherited across fork ().  Data read from TTYs
    by process with the attribute is sent to the audit subsystem by the kernel.
    The audit netlink interface is extended to allow modifying the audit_tty
    attribute, and to allow sending explanatory audit events from user-space (for
    example, a shell might send an event containing the final command, after the
    interactive command-line editing and history expansion is performed, which
    might be difficult to decipher from the TTY input alone).
    
    Because the "audit_tty" attribute is inherited across fork (), it would be set
    e.g.  for sshd restarted within an audited session.  To prevent this, the
    audit_tty attribute is cleared when a process with no open TTY file
    descriptors (e.g.  after daemon startup) opens a TTY.
    
    See https://www.redhat.com/archives/linux-audit/2007-June/msg00000.html for a
    more detailed rationale document for an older version of this patch.
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Miloslav Trmac <mitr@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fccc6e50298a..8ca7ca0b47f0 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -63,9 +63,12 @@
 #define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
 #define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
 #define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
+#define AUDIT_TTY_GET		1014	/* Get TTY auditing status */
+#define AUDIT_TTY_SET		1015	/* Set TTY auditing status */
 
 #define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
 #define AUDIT_USER_AVC		1107	/* We filter this differently */
+#define AUDIT_USER_TTY		1124	/* Non-ICANON TTY input meaning */
 #define AUDIT_LAST_USER_MSG	1199
 #define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
 #define AUDIT_LAST_USER_MSG2	2999
@@ -92,6 +95,7 @@
 #define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
 #define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
 #define AUDIT_OBJ_PID		1318	/* ptrace target */
+#define AUDIT_TTY		1319	/* Input on an administrative TTY */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -289,6 +293,10 @@ struct audit_status {
 	__u32		backlog;	/* messages waiting in queue */
 };
 
+struct audit_tty_status {
+	__u32		enabled; /* 1 = enabled, 0 = disabled */
+};
+
 /* audit_rule_data supports filter rules with both integer and string
  * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
  * AUDIT_LIST_RULES requests.
@@ -515,11 +523,13 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct dentry *dentry,
 					     struct vfsmount *vfsmnt);
+extern void		    audit_log_lost(const char *message);
 				/* Private API (for audit.c only) */
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 			 void *data, size_t datasz, uid_t loginuid, u32 sid);
+extern int audit_enabled;
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)
 #define audit_log_start(c,g,t) ({ NULL; })
@@ -530,6 +540,7 @@ extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
 #define audit_log_d_path(b,p,d,v) do { ; } while (0)
+#define audit_enabled 0
 #endif
 #endif
 #endif

commit 0a4ff8c2598b72f2fa9d50aae9e1809e684dbf41
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Thu Apr 19 10:28:21 2007 -0400

    [PATCH] Abnormal End of Processes
    
    Hi,
    
    I have been working on some code that detects abnormal events based on audit
    system events. One kind of event that we currently have no visibility for is
    when a program terminates due to segfault - which should never happen on a
    production machine. And if it did, you'd want to investigate it. Attached is a
    patch that collects these events and sends them into the audit system.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 22976ddbd264..fccc6e50298a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -112,6 +112,7 @@
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
 #define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
+#define AUDIT_ANOM_ABEND            1701 /* Process ended abnormally */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
@@ -377,6 +378,7 @@ static inline void audit_inode_child(const char *dname,
 	if (unlikely(!audit_dummy_context()))
 		__audit_inode_child(dname, inode, parent);
 }
+void audit_core_dumps(long signr);
 
 static inline void audit_ptrace(struct task_struct *t)
 {
@@ -467,6 +469,7 @@ extern int audit_signals;
 #define __audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
+#define audit_core_dumps(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_log_task_context(b) do { ; } while (0)

commit 4fc03b9beb2314f3adb9e72b7935a80c577954d1
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Tue Feb 13 14:15:01 2007 -0500

    [PATCH] complete message queue auditing
    
    Handle the edge cases for POSIX message queue auditing. Collect inode
    info when opening an existing mq, and for send/receive operations. Remove
    audit_inode_update() as it has really evolved into the equivalent of
    audit_inode().
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fde0f1420cd2..22976ddbd264 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -355,7 +355,6 @@ extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				const struct inode *parent);
-extern void __audit_inode_update(const struct inode *inode);
 extern void __audit_ptrace(struct task_struct *t);
 
 static inline int audit_dummy_context(void)
@@ -378,10 +377,6 @@ static inline void audit_inode_child(const char *dname,
 	if (unlikely(!audit_dummy_context()))
 		__audit_inode_child(dname, inode, parent);
 }
-static inline void audit_inode_update(const struct inode *inode) {
-	if (unlikely(!audit_dummy_context()))
-		__audit_inode_update(inode);
-}
 
 static inline void audit_ptrace(struct task_struct *t)
 {
@@ -470,10 +465,8 @@ extern int audit_signals;
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,i) do { ; } while (0)
 #define __audit_inode_child(d,i,p) do { ; } while (0)
-#define __audit_inode_update(i) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
-#define audit_inode_update(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_log_task_context(b) do { ; } while (0)

commit e54dc2431d740a79a6bd013babade99d71b1714f
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Mar 29 18:01:04 2007 -0400

    [PATCH] audit signal recipients
    
    When auditing syscalls that send signals, log the pid and security
    context for each target process. Optimize the data collection by
    adding a counter for signal-related rules, and avoiding allocating an
    aux struct unless we have more than one target process. For process
    groups, collect pid/context data in blocks of 16. Move the
    audit_signal_info() hook up in check_kill_permission() so we audit
    attempts where permission is denied.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f165308254dc..fde0f1420cd2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -340,6 +340,7 @@ struct mqstat;
 #define AUDITSC_RESULT(x) ( ((long)(x))<0?AUDITSC_FAILURE:AUDITSC_SUCCESS )
 extern int __init audit_register_class(int class, unsigned *list);
 extern int audit_classify_syscall(int abi, unsigned syscall);
+extern int audit_classify_arch(int arch);
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */
@@ -458,6 +459,7 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 	return 0;
 }
 extern int audit_n_rules;
+extern int audit_signals;
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -490,6 +492,7 @@ extern int audit_n_rules;
 #define audit_mq_getsetattr(d,s) ({ 0; })
 #define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
+#define audit_signals 0
 #endif
 
 #ifdef CONFIG_AUDIT

commit 7f13da40e36c84d0d046b7adbd060af7d3717250
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Mar 29 18:00:37 2007 -0400

    [PATCH] add SIGNAL syscall class (v3)
    
    Add a syscall class for sending signals.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f93ce78cecbb..f165308254dc 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -149,6 +149,8 @@
 #define AUDIT_CLASS_READ_32 5
 #define AUDIT_CLASS_WRITE 6
 #define AUDIT_CLASS_WRITE_32 7
+#define AUDIT_CLASS_SIGNAL 8
+#define AUDIT_CLASS_SIGNAL_32 9
 
 /* This bitmask is used to validate user input.  It represents all bits that
  * are currently used in an audit field constant understood by the kernel.

commit a5cb013da773a67ee48d1c19e96436c22a73a7eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 20 13:58:35 2007 -0400

    [PATCH] auditing ptrace
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 773e30df11ee..f93ce78cecbb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -91,6 +91,7 @@
 #define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
 #define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
 #define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
+#define AUDIT_OBJ_PID		1318	/* ptrace target */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -352,6 +353,8 @@ extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				const struct inode *parent);
 extern void __audit_inode_update(const struct inode *inode);
+extern void __audit_ptrace(struct task_struct *t);
+
 static inline int audit_dummy_context(void)
 {
 	void *p = current->audit_context;
@@ -377,6 +380,12 @@ static inline void audit_inode_update(const struct inode *inode) {
 		__audit_inode_update(inode);
 }
 
+static inline void audit_ptrace(struct task_struct *t)
+{
+	if (unlikely(!audit_dummy_context()))
+		__audit_ptrace(t);
+}
+
 				/* Private API (for audit.c only) */
 extern unsigned int audit_serial(void);
 extern void auditsc_get_stamp(struct audit_context *ctx,
@@ -477,6 +486,7 @@ extern int audit_n_rules;
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
 #define audit_mq_notify(d,n) ({ 0; })
 #define audit_mq_getsetattr(d,s) ({ 0; })
+#define audit_ptrace(t) ((void)0)
 #define audit_n_rules 0
 #endif
 

commit 3b46e650165f691a30ddede1a79d2df02f3459d7
Author: Jeff Dike <jdike@addtoit.com>
Date:   Tue Mar 6 01:42:17 2007 -0800

    [PATCH] linux/audit.h needs linux/types.h
    
    Include linux/types.h here because we need a definition of __u32.  This file
    appears not be exported verbatim by libc, so I think this doesn't have any
    userspace consequences.
    
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 229fa012c893..773e30df11ee 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -24,6 +24,7 @@
 #ifndef _LINUX_AUDIT_H_
 #define _LINUX_AUDIT_H_
 
+#include <linux/types.h>
 #include <linux/elf-em.h>
 
 /* The netlink messages for the audit system is divided into blocks:

commit db3495099d3d52854b13874905af6e40a91f4721
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 7 01:48:00 2007 -0500

    [PATCH] AUDIT_FD_PAIR
    
    Provide an audit record of the descriptor pair returned by pipe() and
    socketpair().  Rewritten from the original posted to linux-audit by
    John D. Ramsdell <ramsdell@mitre.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 0e07db6cc0d0..229fa012c893 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -89,6 +89,7 @@
 #define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
 #define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
 #define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
+#define AUDIT_FD_PAIR		1317    /* audit record for pipe/socketpair */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -387,6 +388,7 @@ extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode
 extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
+extern int __audit_fd_pair(int fd1, int fd2);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern int audit_set_macxattr(const char *name);
 extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
@@ -401,6 +403,12 @@ static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 		return __audit_ipc_obj(ipcp);
 	return 0;
 }
+static inline int audit_fd_pair(int fd1, int fd2)
+{
+	if (unlikely(!audit_dummy_context()))
+		return __audit_fd_pair(fd1, fd2);
+	return 0;
+}
 static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
 {
 	if (unlikely(!audit_dummy_context()))
@@ -459,6 +467,7 @@ extern int audit_n_rules;
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })
 #define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
+#define audit_fd_pair(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)

commit 161a09e737f0761ca064ee6a907313402f7a54b6
Author: Joy Latten <latten@austin.ibm.com>
Date:   Mon Nov 27 13:11:54 2006 -0600

    audit: Add auditing to ipsec
    
    An audit message occurs when an ipsec SA
    or ipsec policy is created/deleted.
    
    Signed-off-by: Joy Latten <latten@austin.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b2ca666d9997..0e07db6cc0d0 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -101,6 +101,10 @@
 #define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
 #define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
 #define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
+#define AUDIT_MAC_IPSEC_ADDSA	1411	/* Add a XFRM state */
+#define AUDIT_MAC_IPSEC_DELSA	1412	/* Delete a XFRM state */
+#define AUDIT_MAC_IPSEC_ADDSPD	1413	/* Add a XFRM policy */
+#define AUDIT_MAC_IPSEC_DELSPD	1414	/* Delete a XFRM policy */
 
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799
@@ -377,6 +381,7 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
+extern void audit_log_task_context(struct audit_buffer *ab);
 extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
@@ -449,6 +454,7 @@ extern int audit_n_rules;
 #define audit_inode_update(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
+#define audit_log_task_context(b) do { ; } while (0)
 #define audit_ipc_obj(i) ({ 0; })
 #define audit_ipc_set_perm(q,u,g,m) ({ 0; })
 #define audit_bprm(p) ({ 0; })

commit c8e649ba908954447e9a095677f6a6c8e50a37b2
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri Sep 29 11:56:49 2006 -0400

    [PATCH] message types updated
    
    Hi,
    
    This patch adds a new type for 3rd party module use and cleans up a deprecated
    message type.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c3aa09751814..b2ca666d9997 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -75,7 +75,7 @@
 #define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */
 
 #define AUDIT_SYSCALL		1300	/* Syscall event */
-#define AUDIT_FS_WATCH		1301	/* Filesystem watch event */
+/* #define AUDIT_FS_WATCH	1301	 * Deprecated */
 #define AUDIT_PATH		1302	/* Filename path information */
 #define AUDIT_IPC		1303	/* IPC record */
 #define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
@@ -88,6 +88,7 @@
 #define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
 #define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
 #define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
+#define AUDIT_KERNEL_OTHER	1316	/* For use by 3rd party modules */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */

commit 95d4e6be25a68cd9fbe8c0d356b585504d8db1c7
Author: Paul Moore <paul.moore@hp.com>
Date:   Fri Sep 29 17:05:05 2006 -0700

    [NetLabel]: audit fixups due to delayed feedback
    
    Fix some issues Steve Grubb had with the way NetLabel was using the audit
    subsystem.  This should make NetLabel more consistent with other kernel
    generated audit messages specifying configuration changes.
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 42719d07612a..c3aa09751814 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -95,12 +95,11 @@
 #define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
 #define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
 #define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
-#define AUDIT_MAC_UNLBL_ACCEPT	1406	/* NetLabel: allow unlabeled traffic */
-#define AUDIT_MAC_UNLBL_DENY	1407	/* NetLabel: deny unlabeled traffic */
-#define AUDIT_MAC_CIPSOV4_ADD	1408	/* NetLabel: add CIPSOv4 DOI entry */
-#define AUDIT_MAC_CIPSOV4_DEL	1409	/* NetLabel: del CIPSOv4 DOI entry */
-#define AUDIT_MAC_MAP_ADD	1410	/* NetLabel: add LSM domain mapping */
-#define AUDIT_MAC_MAP_DEL	1411	/* NetLabel: del LSM domain mapping */
+#define AUDIT_MAC_UNLBL_ALLOW	1406	/* NetLabel: allow unlabeled traffic */
+#define AUDIT_MAC_CIPSOV4_ADD	1407	/* NetLabel: add CIPSOv4 DOI entry */
+#define AUDIT_MAC_CIPSOV4_DEL	1408	/* NetLabel: del CIPSOv4 DOI entry */
+#define AUDIT_MAC_MAP_ADD	1409	/* NetLabel: add LSM domain mapping */
+#define AUDIT_MAC_MAP_DEL	1410	/* NetLabel: del LSM domain mapping */
 
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799

commit 32f50cdee666333168b5203c7864bede159f789e
Author: Paul Moore <paul.moore@hp.com>
Date:   Thu Sep 28 14:51:47 2006 -0700

    [NetLabel]: add audit support for configuration changes
    
    This patch adds audit support to NetLabel, including six new audit message
    types shown below.
    
     #define AUDIT_MAC_UNLBL_ACCEPT 1406
     #define AUDIT_MAC_UNLBL_DENY   1407
     #define AUDIT_MAC_CIPSOV4_ADD  1408
     #define AUDIT_MAC_CIPSOV4_DEL  1409
     #define AUDIT_MAC_MAP_ADD      1410
     #define AUDIT_MAC_MAP_DEL      1411
    
    Signed-off-by: Paul Moore <paul.moore@hp.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 40a6c26294ae..42719d07612a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -95,6 +95,12 @@
 #define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
 #define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
 #define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
+#define AUDIT_MAC_UNLBL_ACCEPT	1406	/* NetLabel: allow unlabeled traffic */
+#define AUDIT_MAC_UNLBL_DENY	1407	/* NetLabel: deny unlabeled traffic */
+#define AUDIT_MAC_CIPSOV4_ADD	1408	/* NetLabel: add CIPSOv4 DOI entry */
+#define AUDIT_MAC_CIPSOV4_DEL	1409	/* NetLabel: del CIPSOv4 DOI entry */
+#define AUDIT_MAC_MAP_ADD	1410	/* NetLabel: add LSM domain mapping */
+#define AUDIT_MAC_MAP_DEL	1411	/* NetLabel: del LSM domain mapping */
 
 #define AUDIT_FIRST_KERN_ANOM_MSG   1700
 #define AUDIT_LAST_KERN_ANOM_MSG    1799

commit 55669bfa141b488be865341ed12e188967d11308
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Aug 31 19:26:40 2006 -0400

    [PATCH] audit: AUDIT_PERM support
    
    add support for AUDIT_PERM predicate
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1077362a2efb..40a6c26294ae 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -181,6 +181,7 @@
 #define AUDIT_EXIT	103
 #define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
 #define AUDIT_WATCH	105
+#define AUDIT_PERM	106
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)
@@ -256,6 +257,11 @@
 #define AUDIT_ARCH_V850		(EM_V850|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 
+#define AUDIT_PERM_EXEC		1
+#define AUDIT_PERM_WRITE	2
+#define AUDIT_PERM_READ		4
+#define AUDIT_PERM_ATTR		8
+
 struct audit_status {
 	__u32		mask;		/* Bit mask for valid entries */
 	__u32		enabled;	/* 1 = enabled, 0 = disabled */
@@ -318,6 +324,7 @@ struct mqstat;
 #define AUDITSC_FAILURE 2
 #define AUDITSC_RESULT(x) ( ((long)(x))<0?AUDITSC_FAILURE:AUDITSC_SUCCESS )
 extern int __init audit_register_class(int class, unsigned *list);
+extern int audit_classify_syscall(int abi, unsigned syscall);
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */

commit dc104fb3231f11e95b5a0f09ae3ab27a8fd5b2e8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Aug 31 19:05:56 2006 -0400

    [PATCH] audit: more syscall classes added
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 64f9f9e56ac5..1077362a2efb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -132,6 +132,10 @@
 #define AUDIT_CLASS_DIR_WRITE_32 1
 #define AUDIT_CLASS_CHATTR 2
 #define AUDIT_CLASS_CHATTR_32 3
+#define AUDIT_CLASS_READ 4
+#define AUDIT_CLASS_READ_32 5
+#define AUDIT_CLASS_WRITE 6
+#define AUDIT_CLASS_WRITE_32 7
 
 /* This bitmask is used to validate user input.  It represents all bits that
  * are currently used in an audit field constant understood by the kernel.

commit 5ac3a9c26c1cc4861d9cdd8b293fecbfcdc81afe
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 16 06:38:45 2006 -0400

    [PATCH] don't bother with aux entires for dummy context
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3f736d658218..64f9f9e56ac5 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -336,21 +336,21 @@ static inline int audit_dummy_context(void)
 }
 static inline void audit_getname(const char *name)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		__audit_getname(name);
 }
 static inline void audit_inode(const char *name, const struct inode *inode) {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		__audit_inode(name, inode);
 }
 static inline void audit_inode_child(const char *dname, 
 				     const struct inode *inode,
 				     const struct inode *parent) {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		__audit_inode_child(dname, inode, parent);
 }
 static inline void audit_inode_update(const struct inode *inode) {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		__audit_inode_update(inode);
 }
 
@@ -375,43 +375,43 @@ extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 
 static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_ipc_obj(ipcp);
 	return 0;
 }
 static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_ipc_set_perm(qbytes, uid, gid, mode);
 	return 0;
 }
 static inline int audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_mq_open(oflag, mode, u_attr);
 	return 0;
 }
 static inline int audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_mq_timedsend(mqdes, msg_len, msg_prio, u_abs_timeout);
 	return 0;
 }
 static inline int audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_mq_timedreceive(mqdes, msg_len, u_msg_prio, u_abs_timeout);
 	return 0;
 }
 static inline int audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_mq_notify(mqdes, u_notification);
 	return 0;
 }
 static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 {
-	if (unlikely(current->audit_context))
+	if (unlikely(!audit_dummy_context()))
 		return __audit_mq_getsetattr(mqdes, mqstat);
 	return 0;
 }

commit d51374adf5f2f88155a072d3d801104e3c0c3d7f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Aug 3 10:59:26 2006 -0400

    [PATCH] mark context of syscall entered with no rules as dummy
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index f1bfcff497bf..3f736d658218 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -329,6 +329,11 @@ extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				const struct inode *parent);
 extern void __audit_inode_update(const struct inode *inode);
+static inline int audit_dummy_context(void)
+{
+	void *p = current->audit_context;
+	return !p || *(int *)p;
+}
 static inline void audit_getname(const char *name)
 {
 	if (unlikely(current->audit_context))
@@ -416,6 +421,7 @@ extern int audit_n_rules;
 #define audit_free(t) do { ; } while (0)
 #define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)
 #define audit_syscall_exit(f,r) do { ; } while (0)
+#define audit_dummy_context() 1
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,i) do { ; } while (0)

commit 471a5c7c839114cc8b55876203aeb2817c33e3c5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 10 08:29:24 2006 -0400

    [PATCH] introduce audit rules counter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bf196c05826c..f1bfcff497bf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -410,6 +410,7 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 		return __audit_mq_getsetattr(mqdes, mqstat);
 	return 0;
 }
+extern int audit_n_rules;
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -437,6 +438,7 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 #define audit_mq_timedreceive(d,l,p,t) ({ 0; })
 #define audit_mq_notify(d,n) ({ 0; })
 #define audit_mq_getsetattr(d,s) ({ 0; })
+#define audit_n_rules 0
 #endif
 
 #ifdef CONFIG_AUDIT

commit 73d3ec5abad3f1730ac8530899d2c14d92f3ad63
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jul 13 13:16:39 2006 -0400

    [PATCH] fix missed create event for directory audit
    
    When an object is created via a symlink into an audited directory, audit misses
    the event due to not having collected the inode data for the directory.  Modify
    __audit_inode_child() to copy the parent inode data if a parent wasn't found in
    audit_names[].
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e7e5e5348987..bf196c05826c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -327,7 +327,7 @@ extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
-				unsigned long pino);
+				const struct inode *parent);
 extern void __audit_inode_update(const struct inode *inode);
 static inline void audit_getname(const char *name)
 {
@@ -339,10 +339,10 @@ static inline void audit_inode(const char *name, const struct inode *inode) {
 		__audit_inode(name, inode);
 }
 static inline void audit_inode_child(const char *dname, 
-				     const struct inode *inode, 
-				     unsigned long pino) {
+				     const struct inode *inode,
+				     const struct inode *parent) {
 	if (unlikely(current->audit_context))
-		__audit_inode_child(dname, inode, pino);
+		__audit_inode_child(dname, inode, parent);
 }
 static inline void audit_inode_update(const struct inode *inode) {
 	if (unlikely(current->audit_context))

commit 3e2efce067cec0099f99ae59f28feda99b02b498
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jul 13 13:16:02 2006 -0400

    [PATCH] fix faulty inode data collection for open() with O_CREAT
    
    When the specified path is an existing file or when it is a symlink, audit
    collects the wrong inode number, which causes it to miss the open() event.
    Adding a second hook to the open() path fixes this.
    
    Also add audit_copy_inode() to consolidate some code.
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b27d7debc5a1..e7e5e5348987 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -328,6 +328,7 @@ extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				unsigned long pino);
+extern void __audit_inode_update(const struct inode *inode);
 static inline void audit_getname(const char *name)
 {
 	if (unlikely(current->audit_context))
@@ -343,6 +344,10 @@ static inline void audit_inode_child(const char *dname,
 	if (unlikely(current->audit_context))
 		__audit_inode_child(dname, inode, pino);
 }
+static inline void audit_inode_update(const struct inode *inode) {
+	if (unlikely(current->audit_context))
+		__audit_inode_update(inode);
+}
 
 				/* Private API (for audit.c only) */
 extern unsigned int audit_serial(void);
@@ -414,8 +419,10 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,i) do { ; } while (0)
 #define __audit_inode_child(d,i,p) do { ; } while (0)
+#define __audit_inode_update(i) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
+#define audit_inode_update(i) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_obj(i) ({ 0; })

commit b915543b46a2aa599fdd2169e51bcfd88812a12b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 1 03:56:16 2006 -0400

    [PATCH] audit syscall classes
    
    Allow to tie upper bits of syscall bitmap in audit rules to kernel-defined
    sets of syscalls.  Infrastructure, a couple of classes (with 32bit counterparts
    for biarch targets) and actual tie-in on i386, amd64 and ia64.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c211f0a2abb4..b27d7debc5a1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -127,6 +127,12 @@
 #define AUDIT_WORD(nr) ((__u32)((nr)/32))
 #define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
 
+#define AUDIT_SYSCALL_CLASSES 16
+#define AUDIT_CLASS_DIR_WRITE 0
+#define AUDIT_CLASS_DIR_WRITE_32 1
+#define AUDIT_CLASS_CHATTR 2
+#define AUDIT_CLASS_CHATTR_32 3
+
 /* This bitmask is used to validate user input.  It represents all bits that
  * are currently used in an audit field constant understood by the kernel.
  * If you are adding a new #define AUDIT_<whatever>, please ensure that
@@ -307,6 +313,7 @@ struct mqstat;
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 #define AUDITSC_RESULT(x) ( ((long)(x))<0?AUDITSC_FAILURE:AUDITSC_SUCCESS )
+extern int __init audit_register_class(int class, unsigned *list);
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */

commit 3a6b9f85c641a3b89420b0c8150ed377526a1fe1
Author: Darrel Goeddel <dgoeddel@trustedcs.com>
Date:   Thu Jun 29 16:56:39 2006 -0500

    [PATCH] audit: rename AUDIT_SE_* constants
    
    This patch renames some audit constant definitions and adds
    additional definitions used by the following patch.  The renaming
    avoids ambiguity with respect to the new definitions.
    
    Signed-off-by: Darrel Goeddel <dgoeddel@trustedcs.com>
    
     include/linux/audit.h          |   15 ++++++++----
     kernel/auditfilter.c           |   50 ++++++++++++++++++++---------------------
     kernel/auditsc.c               |   10 ++++----
     security/selinux/ss/services.c |   32 +++++++++++++-------------
     4 files changed, 56 insertions(+), 51 deletions(-)
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index a489104ae3a4..c211f0a2abb4 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -151,12 +151,17 @@
 #define AUDIT_PERS	10
 #define AUDIT_ARCH	11
 #define AUDIT_MSGTYPE	12
-#define AUDIT_SE_USER	13	/* security label user */
-#define AUDIT_SE_ROLE	14	/* security label role */
-#define AUDIT_SE_TYPE	15	/* security label type */
-#define AUDIT_SE_SEN	16	/* security label sensitivity label */
-#define AUDIT_SE_CLR	17	/* security label clearance label */
+#define AUDIT_SUBJ_USER	13	/* security label user */
+#define AUDIT_SUBJ_ROLE	14	/* security label role */
+#define AUDIT_SUBJ_TYPE	15	/* security label type */
+#define AUDIT_SUBJ_SEN	16	/* security label sensitivity label */
+#define AUDIT_SUBJ_CLR	17	/* security label clearance label */
 #define AUDIT_PPID	18
+#define AUDIT_OBJ_USER	19
+#define AUDIT_OBJ_ROLE	20
+#define AUDIT_OBJ_TYPE	21
+#define AUDIT_OBJ_LEV_LOW	22
+#define AUDIT_OBJ_LEV_HIGH	23
 
 				/* These are ONLY useful when checking
 				 * at syscall exit time (AUDIT_AT_EXIT). */

commit 5adc8a6adc91c4c85a64c75a70a619fffc924817
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Wed Jun 14 18:45:21 2006 -0400

    [PATCH] add rule filterkey
    
    Add support for a rule key, which can be used to tie audit records to audit
    rules.  This is useful when a watched file is accessed through a link or
    symlink, as well as for general audit log analysis.
    
    Because this patch uses a string key instead of an integer key, there is a bit
    of extra overhead to do the kstrdup() when a rule fires.  However, we're also
    allocating memory for the audit record buffer, so it's probably not that
    significant.  I went ahead with a string key because it seems more
    user-friendly.
    
    Note that the user must ensure that filterkeys are unique.  The kernel only
    checks for duplicate rules.
    
    Signed-off-by: Amy Griffis <amy.griffis@hpd.com>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e051ff9c5b50..a489104ae3a4 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -122,6 +122,7 @@
 /* Rule structure sizes -- if these change, different AUDIT_ADD and
  * AUDIT_LIST commands must be implemented. */
 #define AUDIT_MAX_FIELDS   64
+#define AUDIT_MAX_KEY_LEN  32
 #define AUDIT_BITMASK_SIZE 64
 #define AUDIT_WORD(nr) ((__u32)((nr)/32))
 #define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
@@ -171,6 +172,8 @@
 #define AUDIT_ARG2      (AUDIT_ARG0+2)
 #define AUDIT_ARG3      (AUDIT_ARG0+3)
 
+#define AUDIT_FILTERKEY	210
+
 #define AUDIT_NEGATE			0x80000000
 
 /* These are the supported operators.

commit d9eaec9e295a84a80b663996d0489fcff3a1dca9
Merge: cee4cca740d2 41757106b9ca
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jun 20 15:37:56 2006 -0700

    Merge branch 'audit.b21' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/audit-current
    
    * 'audit.b21' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/audit-current: (25 commits)
      [PATCH] make set_loginuid obey audit_enabled
      [PATCH] log more info for directory entry change events
      [PATCH] fix AUDIT_FILTER_PREPEND handling
      [PATCH] validate rule fields' types
      [PATCH] audit: path-based rules
      [PATCH] Audit of POSIX Message Queue Syscalls v.2
      [PATCH] fix se_sen audit filter
      [PATCH] deprecate AUDIT_POSSBILE
      [PATCH] inline more audit helpers
      [PATCH] proc_loginuid_write() uses simple_strtoul() on non-terminated array
      [PATCH] update of IPC audit record cleanup
      [PATCH] minor audit updates
      [PATCH] fix audit_krule_to_{rule,data} return values
      [PATCH] add filtering by ppid
      [PATCH] log ppid
      [PATCH] collect sid of those who send signals to auditd
      [PATCH] execve argument logging
      [PATCH] fix deadlocks in AUDIT_LIST/AUDIT_LIST_RULES
      [PATCH] audit_panic() is audit-internal
      [PATCH] inotify (5/5): update kernel documentation
      ...
    
    Manual fixup of conflict in unclude/linux/inotify.h

commit 9c937dcc71021f2dbf78f904f03d962dd9bcc130
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Jun 8 23:19:31 2006 -0400

    [PATCH] log more info for directory entry change events
    
    When an audit event involves changes to a directory entry, include
    a PATH record for the directory itself.  A few other notable changes:
    
        - fixed audit_inode_child() hooks in fsnotify_move()
        - removed unused flags arg from audit_inode()
        - added audit log routines for logging a portion of a string
    
    Here's some sample output.
    
    before patch:
    type=SYSCALL msg=audit(1149821605.320:26): arch=40000003 syscall=39 success=yes exit=0 a0=bf8d3c7c a1=1ff a2=804e1b8 a3=bf8d3c7c items=1 ppid=739 pid=800 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 comm="mkdir" exe="/bin/mkdir" subj=root:system_r:unconfined_t:s0-s0:c0.c255
    type=CWD msg=audit(1149821605.320:26):  cwd="/root"
    type=PATH msg=audit(1149821605.320:26): item=0 name="foo" parent=164068 inode=164010 dev=03:00 mode=040755 ouid=0 ogid=0 rdev=00:00 obj=root:object_r:user_home_t:s0
    
    after patch:
    type=SYSCALL msg=audit(1149822032.332:24): arch=40000003 syscall=39 success=yes exit=0 a0=bfdd9c7c a1=1ff a2=804e1b8 a3=bfdd9c7c items=2 ppid=714 pid=777 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=ttyS0 comm="mkdir" exe="/bin/mkdir" subj=root:system_r:unconfined_t:s0-s0:c0.c255
    type=CWD msg=audit(1149822032.332:24):  cwd="/root"
    type=PATH msg=audit(1149822032.332:24): item=0 name="/root" inode=164068 dev=03:00 mode=040750 ouid=0 ogid=0 rdev=00:00 obj=root:object_r:user_home_dir_t:s0
    type=PATH msg=audit(1149822032.332:24): item=1 name="foo" inode=164010 dev=03:00 mode=040755 ouid=0 ogid=0 rdev=00:00 obj=root:object_r:user_home_t:s0
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c78327507f4e..e1c1dbdf9efb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -310,7 +310,7 @@ extern void audit_syscall_entry(int arch,
 extern void audit_syscall_exit(int failed, long return_code);
 extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
-extern void __audit_inode(const char *name, const struct inode *inode, unsigned flags);
+extern void __audit_inode(const char *name, const struct inode *inode);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				unsigned long pino);
 static inline void audit_getname(const char *name)
@@ -318,10 +318,9 @@ static inline void audit_getname(const char *name)
 	if (unlikely(current->audit_context))
 		__audit_getname(name);
 }
-static inline void audit_inode(const char *name, const struct inode *inode,
-			       unsigned flags) {
+static inline void audit_inode(const char *name, const struct inode *inode) {
 	if (unlikely(current->audit_context))
-		__audit_inode(name, inode, flags);
+		__audit_inode(name, inode);
 }
 static inline void audit_inode_child(const char *dname, 
 				     const struct inode *inode, 
@@ -398,9 +397,9 @@ static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
 #define audit_syscall_exit(f,r) do { ; } while (0)
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
-#define __audit_inode(n,i,f) do { ; } while (0)
+#define __audit_inode(n,i) do { ; } while (0)
 #define __audit_inode_child(d,i,p) do { ; } while (0)
-#define audit_inode(n,i,f) do { ; } while (0)
+#define audit_inode(n,i) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
@@ -435,6 +434,9 @@ extern void		    audit_log_hex(struct audit_buffer *ab,
 					  size_t len);
 extern const char *	    audit_log_untrustedstring(struct audit_buffer *ab,
 						      const char *string);
+extern const char *	    audit_log_n_untrustedstring(struct audit_buffer *ab,
+							size_t n,
+							const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct dentry *dentry,
@@ -452,6 +454,7 @@ extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 #define audit_log_end(b) do { ; } while (0)
 #define audit_log_hex(a,b,l) do { ; } while (0)
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
+#define audit_log_n_untrustedstring(a,n,s) do { ; } while (0)
 #define audit_log_d_path(b,p,d,v) do { ; } while (0)
 #endif
 #endif

commit f368c07d7214a7c41dfceb76c8db473b850f0229
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Fri Apr 7 16:55:56 2006 -0400

    [PATCH] audit: path-based rules
    
    In this implementation, audit registers inotify watches on the parent
    directories of paths specified in audit rules.  When audit's inotify
    event handler is called, it updates any affected rules based on the
    filesystem event.  If the parent directory is renamed, removed, or its
    filesystem is unmounted, audit removes all rules referencing that
    inotify watch.
    
    To keep things simple, this implementation limits location-based
    auditing to the directory entries in an existing directory.  Given
    a path-based rule for /foo/bar/passwd, the following table applies:
    
        passwd modified -- audit event logged
        passwd replaced -- audit event logged, rules list updated
        bar renamed     -- rule removed
        foo renamed     -- untracked, meaning that the rule now applies to
                           the new location
    
    Audit users typically want to have many rules referencing filesystem
    objects, which can significantly impact filtering performance.  This
    patch also adds an inode-number-based rule hash to mitigate this
    situation.
    
    The patch is relative to the audit git tree:
    http://kernel.org/git/?p=linux/kernel/git/viro/audit-current.git;a=summary
    and uses the inotify kernel API:
    http://lkml.org/lkml/2006/6/1/145
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 7c8780b150e6..c78327507f4e 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -165,6 +165,7 @@
 #define AUDIT_INODE	102
 #define AUDIT_EXIT	103
 #define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
+#define AUDIT_WATCH	105
 
 #define AUDIT_ARG0      200
 #define AUDIT_ARG1      (AUDIT_ARG0+1)

commit 20ca73bc792be9625af184cbec36e1372611d1c3
Author: George C. Wilson <ltcgcw@us.ibm.com>
Date:   Wed May 24 16:09:55 2006 -0500

    [PATCH] Audit of POSIX Message Queue Syscalls v.2
    
    This patch adds audit support to POSIX message queues.  It applies cleanly to
    the lspp.b15 branch of Al Viro's git tree.  There are new auxiliary data
    structures, and collection and emission routines in kernel/auditsc.c.  New hooks
    in ipc/mqueue.c collect arguments from the syscalls.
    
    I tested the patch by building the examples from the POSIX MQ library tarball.
    Build them -lrt, not against the old MQ library in the tarball.  Here's the URL:
    http://www.geocities.com/wronski12/posix_ipc/libmqueue-4.41.tar.gz
    Do auditctl -a exit,always -S for mq_open, mq_timedsend, mq_timedreceive,
    mq_notify, mq_getsetattr.  mq_unlink has no new hooks.  Please see the
    corresponding userspace patch to get correct output from auditd for the new
    record types.
    
    [fixes folded]
    
    Signed-off-by: George Wilson <ltcgcw@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4b62743b2e6d..7c8780b150e6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -85,6 +85,10 @@
 #define AUDIT_CWD		1307	/* Current working directory */
 #define AUDIT_EXECVE		1309	/* execve arguments */
 #define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
+#define AUDIT_MQ_OPEN		1312	/* POSIX MQ open record type */
+#define AUDIT_MQ_SENDRECV	1313	/* POSIX MQ send/receive record type */
+#define AUDIT_MQ_NOTIFY		1314	/* POSIX MQ notify record type */
+#define AUDIT_MQ_GETSETATTR	1315	/* POSIX MQ get/set attribute record type */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -287,6 +291,8 @@ struct audit_context;
 struct inode;
 struct netlink_skb_parms;
 struct linux_binprm;
+struct mq_attr;
+struct mqstat;
 
 #define AUDITSC_INVALID 0
 #define AUDITSC_SUCCESS 1
@@ -336,6 +342,11 @@ extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern int audit_set_macxattr(const char *name);
+extern int __audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr);
+extern int __audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout);
+extern int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout);
+extern int __audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification);
+extern int __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat);
 
 static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
 {
@@ -349,6 +360,36 @@ static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid,
 		return __audit_ipc_set_perm(qbytes, uid, gid, mode);
 	return 0;
 }
+static inline int audit_mq_open(int oflag, mode_t mode, struct mq_attr __user *u_attr)
+{
+	if (unlikely(current->audit_context))
+		return __audit_mq_open(oflag, mode, u_attr);
+	return 0;
+}
+static inline int audit_mq_timedsend(mqd_t mqdes, size_t msg_len, unsigned int msg_prio, const struct timespec __user *u_abs_timeout)
+{
+	if (unlikely(current->audit_context))
+		return __audit_mq_timedsend(mqdes, msg_len, msg_prio, u_abs_timeout);
+	return 0;
+}
+static inline int audit_mq_timedreceive(mqd_t mqdes, size_t msg_len, unsigned int __user *u_msg_prio, const struct timespec __user *u_abs_timeout)
+{
+	if (unlikely(current->audit_context))
+		return __audit_mq_timedreceive(mqdes, msg_len, u_msg_prio, u_abs_timeout);
+	return 0;
+}
+static inline int audit_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
+{
+	if (unlikely(current->audit_context))
+		return __audit_mq_notify(mqdes, u_notification);
+	return 0;
+}
+static inline int audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)
+{
+	if (unlikely(current->audit_context))
+		return __audit_mq_getsetattr(mqdes, mqstat);
+	return 0;
+}
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -369,6 +410,11 @@ static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid,
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_set_macxattr(n) do { ; } while (0)
+#define audit_mq_open(o,m,a) ({ 0; })
+#define audit_mq_timedsend(d,l,p,t) ({ 0; })
+#define audit_mq_timedreceive(d,l,p,t) ({ 0; })
+#define audit_mq_notify(d,n) ({ 0; })
+#define audit_mq_getsetattr(d,s) ({ 0; })
 #endif
 
 #ifdef CONFIG_AUDIT

commit d8945bb51a2bb6623cfa36b9ff63594f46d513aa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 18 16:01:30 2006 -0400

    [PATCH] inline more audit helpers
    
    pull checks for ->audit_context into inlined wrappers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index da5f521be04b..4b62743b2e6d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -301,11 +301,16 @@ extern void audit_syscall_entry(int arch,
 				int major, unsigned long a0, unsigned long a1,
 				unsigned long a2, unsigned long a3);
 extern void audit_syscall_exit(int failed, long return_code);
-extern void audit_getname(const char *name);
+extern void __audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct inode *inode, unsigned flags);
 extern void __audit_inode_child(const char *dname, const struct inode *inode,
 				unsigned long pino);
+static inline void audit_getname(const char *name)
+{
+	if (unlikely(current->audit_context))
+		__audit_getname(name);
+}
 static inline void audit_inode(const char *name, const struct inode *inode,
 			       unsigned flags) {
 	if (unlikely(current->audit_context))
@@ -324,13 +329,26 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
-extern int audit_ipc_obj(struct kern_ipc_perm *ipcp);
-extern int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern int __audit_ipc_obj(struct kern_ipc_perm *ipcp);
+extern int __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern int audit_set_macxattr(const char *name);
+
+static inline int audit_ipc_obj(struct kern_ipc_perm *ipcp)
+{
+	if (unlikely(current->audit_context))
+		return __audit_ipc_obj(ipcp);
+	return 0;
+}
+static inline int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode)
+{
+	if (unlikely(current->audit_context))
+		return __audit_ipc_set_perm(qbytes, uid, gid, mode);
+	return 0;
+}
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)

commit ac03221a4fdda9bfdabf99bcd129847f20fc1d80
Author: Linda Knippers <linda.knippers@hp.com>
Date:   Tue May 16 22:03:48 2006 -0400

    [PATCH] update of IPC audit record cleanup
    
    The following patch addresses most of the issues with the IPC_SET_PERM
    records as described in:
    https://www.redhat.com/archives/linux-audit/2006-May/msg00010.html
    and addresses the comments I received on the record field names.
    
    To summarize, I made the following changes:
    
    1. Changed sys_msgctl() and semctl_down() so that an IPC_SET_PERM
       record is emitted in the failure case as well as the success case.
       This matches the behavior in sys_shmctl().  I could simplify the
       code in sys_msgctl() and semctl_down() slightly but it would mean
       that in some error cases we could get an IPC_SET_PERM record
       without an IPC record and that seemed odd.
    
    2. No change to the IPC record type, given no feedback on the backward
       compatibility question.
    
    3. Removed the qbytes field from the IPC record.  It wasn't being
       set and when audit_ipc_obj() is called from ipcperms(), the
       information isn't available.  If we want the information in the IPC
       record, more extensive changes will be necessary.  Since it only
       applies to message queues and it isn't really permission related, it
       doesn't seem worth it.
    
    4. Removed the obj field from the IPC_SET_PERM record.  This means that
       the kern_ipc_perm argument is no longer needed.
    
    5. Removed the spaces and renamed the IPC_SET_PERM field names.  Replaced iuid and
       igid fields with ouid and ogid in the IPC record.
    
    I tested this with the lspp.22 kernel on an x86_64 box.  I believe it
    applies cleanly on the latest kernel.
    
    -- ljk
    
    Signed-off-by: Linda Knippers <linda.knippers@hp.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8f6424f2b604..da5f521be04b 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -325,7 +325,7 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_obj(struct kern_ipc_perm *ipcp);
-extern int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode, struct kern_ipc_perm *ipcp);
+extern int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
@@ -345,7 +345,7 @@ extern int audit_set_macxattr(const char *name);
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_obj(i) ({ 0; })
-#define audit_ipc_set_perm(q,u,g,m,i) ({ 0; })
+#define audit_ipc_set_perm(q,u,g,m) ({ 0; })
 #define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })

commit 3c66251e573219a0532a5a07381b2f60a412d9eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 6 08:26:27 2006 -0400

    [PATCH] add filtering by ppid
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1057e90bd3e3..8f6424f2b604 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -152,6 +152,7 @@
 #define AUDIT_SE_TYPE	15	/* security label type */
 #define AUDIT_SE_SEN	16	/* security label sensitivity label */
 #define AUDIT_SE_CLR	17	/* security label clearance label */
+#define AUDIT_PPID	18
 
 				/* These are ONLY useful when checking
 				 * at syscall exit time (AUDIT_AT_EXIT). */

commit e1396065e0489f98b35021b97907ab4edbfb24e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 25 10:19:47 2006 -0400

    [PATCH] collect sid of those who send signals to auditd
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1a221b65f7b7..1057e90bd3e3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -278,6 +278,7 @@ struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
 struct audit_sig_info {
 	uid_t		uid;
 	pid_t		pid;
+	char		ctx[0];
 };
 
 struct audit_buffer;
@@ -328,7 +329,6 @@ extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
-extern void audit_signal_info(int sig, struct task_struct *t);
 extern int audit_set_macxattr(const char *name);
 #else
 #define audit_alloc(t) ({ 0; })
@@ -349,7 +349,6 @@ extern int audit_set_macxattr(const char *name);
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
-#define audit_signal_info(s,t) do { ; } while (0)
 #define audit_set_macxattr(n) do { ; } while (0)
 #endif
 

commit 473ae30bc7b1dda5c5791c773f95e9424ddfead9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 26 14:04:08 2006 -0400

    [PATCH] execve argument logging
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index e65399bf2710..1a221b65f7b7 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -83,6 +83,7 @@
 #define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
 #define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
 #define AUDIT_CWD		1307	/* Current working directory */
+#define AUDIT_EXECVE		1309	/* execve arguments */
 #define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
@@ -283,6 +284,7 @@ struct audit_buffer;
 struct audit_context;
 struct inode;
 struct netlink_skb_parms;
+struct linux_binprm;
 
 #define AUDITSC_INVALID 0
 #define AUDITSC_SUCCESS 1
@@ -322,6 +324,7 @@ extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_obj(struct kern_ipc_perm *ipcp);
 extern int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode, struct kern_ipc_perm *ipcp);
+extern int audit_bprm(struct linux_binprm *bprm);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
@@ -342,6 +345,7 @@ extern int audit_set_macxattr(const char *name);
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_obj(i) ({ 0; })
 #define audit_ipc_set_perm(q,u,g,m,i) ({ 0; })
+#define audit_bprm(p) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
@@ -364,7 +368,7 @@ extern void		    audit_log_end(struct audit_buffer *ab);
 extern void		    audit_log_hex(struct audit_buffer *ab,
 					  const unsigned char *buf,
 					  size_t len);
-extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
+extern const char *	    audit_log_untrustedstring(struct audit_buffer *ab,
 						      const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,

commit bc0f3b8ebba611291fdaa2864dbffd2d29336c64
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 22 01:36:34 2006 -0400

    [PATCH] audit_panic() is audit-internal
    
    ... no need to provide a stub; note that extern is already gone from
    include/linux/audit.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b74c148f14e3..e65399bf2710 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -384,7 +384,6 @@ extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 #define audit_log_hex(a,b,l) do { ; } while (0)
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b,p,d,v) do { ; } while (0)
-#define audit_panic(m) do { ; } while (0)
 #endif
 #endif
 #endif

commit 5047f09b56d0bc3c21aec9cb16de60283da645c6
Merge: c0f1fe00c392 5528e568a760
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 6 19:59:18 2006 +0100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

commit 073115d6b29c7910feaa08241c6484637f5ca958
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Sun Apr 2 17:07:33 2006 -0400

    [PATCH] Rework of IPC auditing
    
    1) The audit_ipc_perms() function has been split into two different
    functions:
            - audit_ipc_obj()
            - audit_ipc_set_perm()
    
    There's a key shift here...  The audit_ipc_obj() collects the uid, gid,
    mode, and SElinux context label of the current ipc object.  This
    audit_ipc_obj() hook is now found in several places.  Most notably, it
    is hooked in ipcperms(), which is called in various places around the
    ipc code permforming a MAC check.  Additionally there are several places
    where *checkid() is used to validate that an operation is being
    performed on a valid object while not necessarily having a nearby
    ipcperms() call.  In these locations, audit_ipc_obj() is called to
    ensure that the information is captured by the audit system.
    
    The audit_set_new_perm() function is called any time the permissions on
    the ipc object changes.  In this case, the NEW permissions are recorded
    (and note that an audit_ipc_obj() call exists just a few lines before
    each instance).
    
    2) Support for an AUDIT_IPC_SET_PERM audit message type.  This allows
    for separate auxiliary audit records for normal operations on an IPC
    object and permissions changes.  Note that the same struct
    audit_aux_data_ipcctl is used and populated, however there are separate
    audit_log_format statements based on the type of the message.  Finally,
    the AUDIT_IPC block of code in audit_free_aux() was extended to handle
    aux messages of this new type.  No more mem leaks I hope ;-)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d5c40823e166..b74c148f14e3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -83,6 +83,7 @@
 #define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
 #define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
 #define AUDIT_CWD		1307	/* Current working directory */
+#define AUDIT_IPC_SET_PERM	1311	/* IPC new permissions record type */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -319,7 +320,8 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
-extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode, struct kern_ipc_perm *ipcp);
+extern int audit_ipc_obj(struct kern_ipc_perm *ipcp);
+extern int audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode, struct kern_ipc_perm *ipcp);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
@@ -338,7 +340,8 @@ extern int audit_set_macxattr(const char *name);
 #define audit_inode_child(d,i,p) do { ; } while (0)
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
-#define audit_ipc_perms(q,u,g,m,i) ({ 0; })
+#define audit_ipc_obj(i) ({ 0; })
+#define audit_ipc_set_perm(q,u,g,m,i) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })

commit ce29b682e228c70cdc91a1b2935c5adb2087bab8
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Sat Apr 1 18:29:34 2006 -0500

    [PATCH] More user space subject labels
    
    Hi,
    
    The patch below builds upon the patch sent earlier and adds subject label to
    all audit events generated via the netlink interface. It also cleans up a few
    other minor things.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 740f950397b7..d5c40823e166 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -371,7 +371,7 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
-				 void *data, size_t datasz, uid_t loginuid);
+			 void *data, size_t datasz, uid_t loginuid, u32 sid);
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)
 #define audit_log_start(c,g,t) ({ NULL; })

commit 376bd9cb357ec945ac893feaeb63af7370a6e70b
Author: Darrel Goeddel <dgoeddel@trustedcs.com>
Date:   Fri Feb 24 15:44:05 2006 -0600

    [PATCH] support for context based audit filtering
    
    The following patch provides selinux interfaces that will allow the audit
    system to perform filtering based on the process context (user, role, type,
    sensitivity, and clearance).  These interfaces will allow the selinux
    module to perform efficient matches based on lower level selinux constructs,
    rather than relying on context retrievals and string comparisons within
    the audit module.  It also allows for dominance checks on the mls portion
    of the contexts that are impossible with only string comparisons.
    
    Signed-off-by: Darrel Goeddel <dgoeddel@trustedcs.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 39fef6ebb854..740f950397b7 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -145,6 +145,11 @@
 #define AUDIT_PERS	10
 #define AUDIT_ARCH	11
 #define AUDIT_MSGTYPE	12
+#define AUDIT_SE_USER	13	/* security label user */
+#define AUDIT_SE_ROLE	14	/* security label role */
+#define AUDIT_SE_TYPE	15	/* security label type */
+#define AUDIT_SE_SEN	16	/* security label sensitivity label */
+#define AUDIT_SE_CLR	17	/* security label clearance label */
 
 				/* These are ONLY useful when checking
 				 * at syscall exit time (AUDIT_AT_EXIT). */

commit 5411be59db80333039386f3b1ccfe5eb9023a916
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 29 20:23:36 2006 -0500

    [PATCH] drop task argument of audit_syscall_{entry,exit}
    
    ... it's always current, and that's a good thing - allows simpler locking.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1c47c59058c1..39fef6ebb854 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -287,10 +287,10 @@ struct netlink_skb_parms;
 				/* Public API */
 extern int  audit_alloc(struct task_struct *task);
 extern void audit_free(struct task_struct *task);
-extern void audit_syscall_entry(struct task_struct *task, int arch,
+extern void audit_syscall_entry(int arch,
 				int major, unsigned long a0, unsigned long a1,
 				unsigned long a2, unsigned long a3);
-extern void audit_syscall_exit(struct task_struct *task, int failed, long return_code);
+extern void audit_syscall_exit(int failed, long return_code);
 extern void audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void __audit_inode(const char *name, const struct inode *inode, unsigned flags);
@@ -323,8 +323,8 @@ extern int audit_set_macxattr(const char *name);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
-#define audit_syscall_entry(t,ta,a,b,c,d,e) do { ; } while (0)
-#define audit_syscall_exit(t,f,r) do { ; } while (0)
+#define audit_syscall_entry(ta,a,b,c,d,e) do { ; } while (0)
+#define audit_syscall_exit(f,r) do { ; } while (0)
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define __audit_inode(n,i,f) do { ; } while (0)

commit f001e47f83db18a9f202f25c0255b4d11ebe468b
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Apr 27 00:11:01 2006 +0100

    Sanitise linux/audit.h for userspace consumption, split elf-em.h from elf.h
    
    Don't include <linux/sched.h> outside __KERNEL__, and split the EM_xxx
    definitions out of elf.h into elf-em.h so that audit.h can include just
    that and not pollute the namespace any further than it needs to.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1c47c59058c1..319975532943 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -24,8 +24,7 @@
 #ifndef _LINUX_AUDIT_H_
 #define _LINUX_AUDIT_H_
 
-#include <linux/sched.h>
-#include <linux/elf.h>
+#include <linux/elf-em.h>
 
 /* The netlink messages for the audit system is divided into blocks:
  * 1000 - 1099 are for commanding the audit system
@@ -267,6 +266,7 @@ struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
 };
 
 #ifdef __KERNEL__
+#include <linux/sched.h>
 
 struct audit_sig_info {
 	uid_t		uid;

commit 5bdb98868062c1b14025883049551af343233187
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Sat Dec 3 08:39:35 2005 -0500

    [PATCH] promiscuous mode
    
    Hi,
    
    When a network interface goes into promiscuous mode, its an important security
    issue. The attached patch is intended to capture that action and send an
    event to the audit system.
    
    The patch carves out a new block of numbers for kernel detected anomalies.
    These are events that may indicate suspicious activity. Other examples of
    potential kernel anomalies would be: exceeding disk quota, rlimit violations,
    changes to syscall entry table.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index d760430c8de3..1c47c59058c1 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -35,7 +35,8 @@
  * 1400 - 1499 SE Linux use
  * 1500 - 1599 kernel LSPP events
  * 1600 - 1699 kernel crypto events
- * 1700 - 1999 future kernel use (maybe integrity labels and related events)
+ * 1700 - 1799 kernel anomaly records
+ * 1800 - 1999 future kernel use (maybe integrity labels and related events)
  * 2000 is for otherwise unclassified kernel audit messages (legacy)
  * 2001 - 2099 unused (kernel)
  * 2100 - 2199 user space anomaly records
@@ -90,6 +91,10 @@
 #define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
 #define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
 
+#define AUDIT_FIRST_KERN_ANOM_MSG   1700
+#define AUDIT_LAST_KERN_ANOM_MSG    1799
+#define AUDIT_ANOM_PROMISCUOUS      1700 /* Device changed promiscuous mode */
+
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
 /* Rule flags */

commit 5d3301088f7e412992d9e61cc3604cbdff3090ff
Author: Steve Grubb <viro@zeniv.linux.org.uk>
Date:   Mon Jan 9 09:48:17 2006 -0500

    [PATCH] add/remove rule update
    
    Hi,
    
    The following patch adds a little more information to the add/remove rule message emitted
    by the kernel.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8a3b98175c25..d760430c8de3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -240,7 +240,7 @@ struct audit_rule_data {
 	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
 	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
 	__u32		field_count;
-	__u32		mask[AUDIT_BITMASK_SIZE];
+	__u32		mask[AUDIT_BITMASK_SIZE]; /* syscall(s) affected */
 	__u32		fields[AUDIT_MAX_FIELDS];
 	__u32		values[AUDIT_MAX_FIELDS];
 	__u32		fieldflags[AUDIT_MAX_FIELDS];

commit 93315ed6dd12dacfc941f9eb8ca0293aadf99793
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Tue Feb 7 12:05:27 2006 -0500

    [PATCH] audit string fields interface + consumer
    
    Updated patch to dynamically allocate audit rule fields in kernel's
    internal representation.  Added unlikely() calls for testing memory
    allocation result.
    
    Amy Griffis wrote:     [Wed Jan 11 2006, 02:02:31PM EST]
    > Modify audit's kernel-userspace interface to allow the specification
    > of string fields in audit rules.
    >
    > Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    (cherry picked from 5ffc4a863f92351b720fe3e9c5cd647accff9e03 commit)

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8868c96ca8a2..8a3b98175c25 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -50,15 +50,18 @@
  */
 #define AUDIT_GET		1000	/* Get status */
 #define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
-#define AUDIT_LIST		1002	/* List syscall filtering rules */
-#define AUDIT_ADD		1003	/* Add syscall filtering rule */
-#define AUDIT_DEL		1004	/* Delete syscall filtering rule */
+#define AUDIT_LIST		1002	/* List syscall rules -- deprecated */
+#define AUDIT_ADD		1003	/* Add syscall rule -- deprecated */
+#define AUDIT_DEL		1004	/* Delete syscall rule -- deprecated */
 #define AUDIT_USER		1005	/* Message from userspace -- deprecated */
 #define AUDIT_LOGIN		1006	/* Define the login id and information */
 #define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
 #define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
 #define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
 #define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
+#define AUDIT_ADD_RULE		1011	/* Add syscall filtering rule */
+#define AUDIT_DEL_RULE		1012	/* Delete syscall filtering rule */
+#define AUDIT_LIST_RULES	1013	/* List syscall filtering rules */
 
 #define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
 #define AUDIT_USER_AVC		1107	/* We filter this differently */
@@ -229,6 +232,26 @@ struct audit_status {
 	__u32		backlog;	/* messages waiting in queue */
 };
 
+/* audit_rule_data supports filter rules with both integer and string
+ * fields.  It corresponds with AUDIT_ADD_RULE, AUDIT_DEL_RULE and
+ * AUDIT_LIST_RULES requests.
+ */
+struct audit_rule_data {
+	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	__u32		field_count;
+	__u32		mask[AUDIT_BITMASK_SIZE];
+	__u32		fields[AUDIT_MAX_FIELDS];
+	__u32		values[AUDIT_MAX_FIELDS];
+	__u32		fieldflags[AUDIT_MAX_FIELDS];
+	__u32		buflen;	/* total length of string fields */
+	char		buf[0];	/* string fields buffer */
+};
+
+/* audit_rule is supported to maintain backward compatibility with
+ * userspace.  It supports integer fields only and corresponds to
+ * AUDIT_ADD, AUDIT_DEL and AUDIT_LIST requests.
+ */
 struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
 	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
 	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
@@ -338,7 +361,7 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
-				 void *data, uid_t loginuid);
+				 void *data, size_t datasz, uid_t loginuid);
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)
 #define audit_log_start(c,g,t) ({ NULL; })

commit af601e4623d0303bfafa54ec728b7ae8493a8e1b
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Wed Jan 4 14:08:39 2006 +0000

    [PATCH] SE Linux audit events
    
    Attached is a patch that hardwires important SE Linux events to the audit
    system. Please Apply.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fbc21d6267f3..8868c96ca8a2 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -83,6 +83,9 @@
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
 #define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
+#define AUDIT_MAC_POLICY_LOAD	1403	/* Policy file load */
+#define AUDIT_MAC_STATUS	1404	/* Changed enforcing,permissive,off */
+#define AUDIT_MAC_CONFIG_CHANGE	1405	/* Changes to booleans */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 

commit fe7752bab26a9ac0651b695ad4f55659761f68f7
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Dec 15 18:33:52 2005 +0000

    [PATCH] Fix audit record filtering with !CONFIG_AUDITSYSCALL
    
    This fixes the per-user and per-message-type filtering when syscall
    auditing isn't enabled.
    
    [AV: folded followup fix from the same author]
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1912d8e8ae90..fbc21d6267f3 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -278,8 +278,6 @@ static inline void audit_inode_child(const char *dname,
 }
 
 				/* Private API (for audit.c only) */
-extern int  audit_receive_filter(int type, int pid, int uid, int seq,
-				 void *data, uid_t loginuid);
 extern unsigned int audit_serial(void);
 extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
@@ -290,8 +288,6 @@ extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
-extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
-extern int audit_filter_type(int type);
 extern int audit_set_macxattr(const char *name);
 #else
 #define audit_alloc(t) ({ 0; })
@@ -304,7 +300,6 @@ extern int audit_set_macxattr(const char *name);
 #define __audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_inode(n,i,f) do { ; } while (0)
 #define audit_inode_child(d,i,p) do { ; } while (0)
-#define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_perms(q,u,g,m,i) ({ 0; })
@@ -312,7 +307,6 @@ extern int audit_set_macxattr(const char *name);
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
-#define audit_filter_user(cb,t) ({ 1; })
 #define audit_set_macxattr(n) do { ; } while (0)
 #endif
 
@@ -337,13 +331,11 @@ extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct dentry *dentry,
 					     struct vfsmount *vfsmnt);
-				/* Private API (for auditsc.c only) */
-extern void		    audit_send_reply(int pid, int seq, int type,
-					     int done, int multi,
-					     void *payload, int size);
-extern void		    audit_log_lost(const char *message);
-extern void		    audit_panic(const char *message);
-extern struct semaphore audit_netlink_sem;
+				/* Private API (for audit.c only) */
+extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
+extern int audit_filter_type(int type);
+extern int  audit_receive_filter(int type, int pid, int uid, int seq,
+				 void *data, uid_t loginuid);
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)
 #define audit_log_start(c,g,t) ({ NULL; })

commit 8c8570fb8feef2bc166bee75a85748b25cda22d9
Author: Dustin Kirkland <dustin.kirkland@us.ibm.com>
Date:   Thu Nov 3 17:15:16 2005 +0000

    [PATCH] Capture selinux subject/object context information.
    
    This patch extends existing audit records with subject/object context
    information. Audit records associated with filesystem inodes, ipc, and
    tasks now contain SELinux label information in the field "subj" if the
    item is performing the action, or in "obj" if the item is the receiver
    of an action.
    
    These labels are collected via hooks in SELinux and appended to the
    appropriate record in the audit code.
    
    This additional information is required for Common Criteria Labeled
    Security Protection Profile (LSPP).
    
    [AV: fixed kmalloc flags use]
    [folded leak fixes]
    [folded cleanup from akpm (kfree(NULL)]
    [folded audit_inode_context() leak fix]
    [folded akpm's fix for audit_ipc_perm() definition in case of !CONFIG_AUDIT]
    
    Signed-off-by: Dustin Kirkland <dustin.kirkland@us.ibm.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 8fa1a8fbc04d..1912d8e8ae90 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -285,13 +285,14 @@ extern void auditsc_get_stamp(struct audit_context *ctx,
 			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
-extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode, struct kern_ipc_perm *ipcp);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 extern int audit_filter_type(int type);
+extern int audit_set_macxattr(const char *name);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -306,12 +307,13 @@ extern int audit_filter_type(int type);
 #define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
-#define audit_ipc_perms(q,u,g,m) ({ 0; })
+#define audit_ipc_perms(q,u,g,m,i) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
 #define audit_filter_user(cb,t) ({ 1; })
+#define audit_set_macxattr(n) do { ; } while (0)
 #endif
 
 #ifdef CONFIG_AUDIT
@@ -340,6 +342,7 @@ extern void		    audit_send_reply(int pid, int seq, int type,
 					     int done, int multi,
 					     void *payload, int size);
 extern void		    audit_log_lost(const char *message);
+extern void		    audit_panic(const char *message);
 extern struct semaphore audit_netlink_sem;
 #else
 #define audit_log(c,g,t,f,...) do { ; } while (0)
@@ -350,6 +353,7 @@ extern struct semaphore audit_netlink_sem;
 #define audit_log_hex(a,b,l) do { ; } while (0)
 #define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b,p,d,v) do { ; } while (0)
+#define audit_panic(m) do { ; } while (0)
 #endif
 #endif
 #endif

commit c8edc80c8b8c397c53f4f659a05b9ea6208029bf
Author: Dustin Kirkland <dustin.kirkland@us.ibm.com>
Date:   Thu Nov 3 16:12:36 2005 +0000

    [PATCH] Exclude messages by message type
    
        - Add a new, 5th filter called "exclude".
        - And add a new field AUDIT_MSGTYPE.
        - Define a new function audit_filter_exclude() that takes a message type
          as input and examines all rules in the filter.  It returns '1' if the
          message is to be excluded, and '0' otherwise.
        - Call the audit_filter_exclude() function near the top of
          audit_log_start() just after asserting audit_initialized.  If the
          message type is not to be audited, return NULL very early, before
          doing a lot of work.
    [combined with followup fix for bug in original patch, Nov 4, same author]
    [combined with later renaming AUDIT_FILTER_EXCLUDE->AUDIT_FILTER_TYPE
    and audit_filter_exclude() -> audit_filter_type()]
    
    Signed-off-by: Dustin Kirkland <dustin.kirkland@us.ibm.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 739b954cb242..8fa1a8fbc04d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -92,8 +92,9 @@
 #define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
 #define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
 #define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
+#define AUDIT_FILTER_TYPE	0x05	/* Apply rule at audit_log_start */
 
-#define AUDIT_NR_FILTERS	5
+#define AUDIT_NR_FILTERS	6
 
 #define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */
 
@@ -132,6 +133,7 @@
 #define AUDIT_LOGINUID	9
 #define AUDIT_PERS	10
 #define AUDIT_ARCH	11
+#define AUDIT_MSGTYPE	12
 
 				/* These are ONLY useful when checking
 				 * at syscall exit time (AUDIT_AT_EXIT). */
@@ -289,6 +291,7 @@ extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
 extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
+extern int audit_filter_type(int type);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)

commit 73241ccca0f7786933f1d31b3d86f2456549953a
Author: Amy Griffis <amy.griffis@hp.com>
Date:   Thu Nov 3 16:00:25 2005 +0000

    [PATCH] Collect more inode information during syscall processing.
    
    This patch augments the collection of inode info during syscall
    processing. It represents part of the functionality that was provided
    by the auditfs patch included in RHEL4.
    
    Specifically, it:
    
    - Collects information for target inodes created or removed during
      syscalls.  Previous code only collects information for the target
      inode's parent.
    
    - Adds the audit_inode() hook to syscalls that operate on a file
      descriptor (e.g. fchown), enabling audit to do inode filtering for
      these calls.
    
    - Modifies filtering code to check audit context for either an inode #
      or a parent inode # matching a given rule.
    
    - Modifies logging to provide inode # for both parent and child.
    
    - Protect debug info from NULL audit_names.name.
    
    [AV: folded a later typo fix from the same author]
    
    Signed-off-by: Amy Griffis <amy.griffis@hp.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fd65078e794a..739b954cb242 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -260,7 +260,20 @@ extern void audit_syscall_entry(struct task_struct *task, int arch,
 extern void audit_syscall_exit(struct task_struct *task, int failed, long return_code);
 extern void audit_getname(const char *name);
 extern void audit_putname(const char *name);
-extern void audit_inode(const char *name, const struct inode *inode, unsigned flags);
+extern void __audit_inode(const char *name, const struct inode *inode, unsigned flags);
+extern void __audit_inode_child(const char *dname, const struct inode *inode,
+				unsigned long pino);
+static inline void audit_inode(const char *name, const struct inode *inode,
+			       unsigned flags) {
+	if (unlikely(current->audit_context))
+		__audit_inode(name, inode, flags);
+}
+static inline void audit_inode_child(const char *dname, 
+				     const struct inode *inode, 
+				     unsigned long pino) {
+	if (unlikely(current->audit_context))
+		__audit_inode_child(dname, inode, pino);
+}
 
 				/* Private API (for audit.c only) */
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
@@ -283,7 +296,10 @@ extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 #define audit_syscall_exit(t,f,r) do { ; } while (0)
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
+#define __audit_inode(n,i,f) do { ; } while (0)
+#define __audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_inode(n,i,f) do { ; } while (0)
+#define audit_inode_child(d,i,p) do { ; } while (0)
 #define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })

commit 90d526c074ae5db484388da56c399acf892b6c17
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Thu Nov 3 15:48:08 2005 +0000

    [PATCH] Define new range of userspace messages.
    
    The attached patch updates various items for the new user space
    messages. Please apply.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2408cb77899c..fd65078e794a 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -33,11 +33,20 @@
  * 1200 - 1299 messages internal to the audit daemon
  * 1300 - 1399 audit event messages
  * 1400 - 1499 SE Linux use
- * 1500 - 1999 future use
- * 2000 is for otherwise unclassified kernel audit messages
+ * 1500 - 1599 kernel LSPP events
+ * 1600 - 1699 kernel crypto events
+ * 1700 - 1999 future kernel use (maybe integrity labels and related events)
+ * 2000 is for otherwise unclassified kernel audit messages (legacy)
+ * 2001 - 2099 unused (kernel)
+ * 2100 - 2199 user space anomaly records
+ * 2200 - 2299 user space actions taken in response to anomalies
+ * 2300 - 2399 user space generated LSPP events
+ * 2400 - 2499 user space crypto events
+ * 2500 - 2999 future user space (maybe integrity labels and related events)
  *
- * Messages from 1000-1199 are bi-directional. 1200-1299 are exclusively user
- * space. Anything over that is kernel --> user space communication.
+ * Messages from 1000-1199 are bi-directional. 1200-1299 & 2100 - 2999 are
+ * exclusively user space. 1300-2099 is kernel --> user space 
+ * communication.
  */
 #define AUDIT_GET		1000	/* Get status */
 #define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
@@ -54,6 +63,8 @@
 #define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
 #define AUDIT_USER_AVC		1107	/* We filter this differently */
 #define AUDIT_LAST_USER_MSG	1199
+#define AUDIT_FIRST_USER_MSG2	2100	/* More user space messages */
+#define AUDIT_LAST_USER_MSG2	2999
  
 #define AUDIT_DAEMON_START      1200    /* Daemon startup record */
 #define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */

commit b63862f46547487388e582e8ac9083830d34f058
Author: Dustin Kirkland <dustin.kirkland@us.ibm.com>
Date:   Thu Nov 3 15:41:46 2005 +0000

    [PATCH] Filter rule comparators
    
    Currently, audit only supports the "=" and "!=" operators in the -F
    filter rules.
    
    This patch reworks the support for "=" and "!=", and adds support
    for ">", ">=", "<", and "<=".
    
    This turned out to be a pretty clean, and simply process.  I ended up
    using the high order bits of the "field", as suggested by Steve and Amy.
    This allowed for no changes whatsoever to the netlink communications.
    See the documentation within the patch in the include/linux/audit.h
    area, where there is a table that explains the reasoning of the bitmask
    assignments clearly.
    
    The patch adds a new function, audit_comparator(left, op, right).
    This function will perform the specified comparison (op, which defaults
    to "==" for backward compatibility) between two values (left and right).
    If the negate bit is on, it will negate whatever that result was.  This
    value is returned.
    
    Signed-off-by: Dustin Kirkland <dustin.kirkland@us.ibm.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index da3c01955f3d..2408cb77899c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -98,6 +98,13 @@
 #define AUDIT_WORD(nr) ((__u32)((nr)/32))
 #define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
 
+/* This bitmask is used to validate user input.  It represents all bits that
+ * are currently used in an audit field constant understood by the kernel.
+ * If you are adding a new #define AUDIT_<whatever>, please ensure that
+ * AUDIT_UNUSED_BITS is updated if need be. */
+#define AUDIT_UNUSED_BITS	0x0FFFFC00
+
+
 /* Rule fields */
 				/* These are useful when checking the
 				 * task structure at task creation time
@@ -128,8 +135,28 @@
 #define AUDIT_ARG2      (AUDIT_ARG0+2)
 #define AUDIT_ARG3      (AUDIT_ARG0+3)
 
-#define AUDIT_NEGATE    0x80000000
+#define AUDIT_NEGATE			0x80000000
 
+/* These are the supported operators.
+ *	4  2  1
+ *	=  >  <
+ *	-------
+ *	0  0  0		0	nonsense
+ *	0  0  1		1	<
+ *	0  1  0		2	>
+ *	0  1  1		3	!=
+ *	1  0  0		4	=
+ *	1  0  1		5	<=
+ *	1  1  0		6	>=
+ *	1  1  1		7	all operators
+ */
+#define AUDIT_LESS_THAN			0x10000000
+#define AUDIT_GREATER_THAN		0x20000000
+#define AUDIT_NOT_EQUAL			0x30000000
+#define AUDIT_EQUAL			0x40000000
+#define AUDIT_LESS_THAN_OR_EQUAL	(AUDIT_LESS_THAN|AUDIT_EQUAL)
+#define AUDIT_GREATER_THAN_OR_EQUAL	(AUDIT_GREATER_THAN|AUDIT_EQUAL)
+#define AUDIT_OPERATORS			(AUDIT_EQUAL|AUDIT_NOT_EQUAL)
 
 /* Status symbols */
 				/* Mask values */

commit 9796fdd829da626374458e8706daedcc0e432ddd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:22:03 2005 -0400

    [PATCH] gfp_t: kernel/*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b2a2509bd7ea..da3c01955f3d 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -260,11 +260,11 @@ extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
-extern void		    audit_log(struct audit_context *ctx, int gfp_mask,
+extern void		    audit_log(struct audit_context *ctx, gfp_t gfp_mask,
 				      int type, const char *fmt, ...)
 				      __attribute__((format(printf,4,5)));
 
-extern struct audit_buffer *audit_log_start(struct audit_context *ctx, int gfp_mask, int type);
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask, int type);
 extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));

commit 30beab1491f0b96b2f23d3fb68af01fd921a16d8
Merge: 21af6c4f2aa5 c32511e27186
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Wed Jul 13 15:25:59 2005 +0100

    Merge with /shiny/git/linux-2.6/.git

commit f7ceba360cce9af3fbc4e5a5b1bd40b570b7021c
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jul 10 19:29:45 2005 -0700

    [SPARC64]: Add syscall auditing support.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bf2ad3ba72eb..68aba0c02e49 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -165,7 +165,7 @@
 #define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_SPARC	(EM_SPARC)
-#define AUDIT_ARCH_SPARC64	(EM_SPARC64|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SPARC64	(EM_SPARCV9|__AUDIT_ARCH_64BIT)
 #define AUDIT_ARCH_V850		(EM_V850|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 

commit 7b430437c0de81681ecfa8efa8f55823df733529
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Sat Jul 2 13:50:40 2005 +0100

    AUDIT: Fix definition of audit_log() if audit not enabled
    
    audit_log() also takes an extra argument, although it's a vararg
    function so the compiler didn't really notice.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index c22405fc2ddf..d68e85580a53 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -285,7 +285,7 @@ extern void		    audit_send_reply(int pid, int seq, int type,
 extern void		    audit_log_lost(const char *message);
 extern struct semaphore audit_netlink_sem;
 #else
-#define audit_log(c,t,f,...) do { ; } while (0)
+#define audit_log(c,g,t,f,...) do { ; } while (0)
 #define audit_log_start(c,g,t) ({ NULL; })
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)

commit 13774024da8ebdf17212c0f5a83f5b0681a649eb
Author: Badari Pulavarty <pbadari@yahoo.com>
Date:   Sat Jul 2 13:49:07 2005 +0100

    AUDIT: Fix definition of audit_log_start() if audit not enabled
    
    audit_log_start() seems to take 3 arguments, but its defined to take
    only 2 when AUDIT is turned off.
    
    security/selinux/avc.c:553:75: macro "audit_log_start" passed 3 arguments, but takes just 2
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 38999f827a36..c22405fc2ddf 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -286,7 +286,7 @@ extern void		    audit_log_lost(const char *message);
 extern struct semaphore audit_netlink_sem;
 #else
 #define audit_log(c,t,f,...) do { ; } while (0)
-#define audit_log_start(c,t) ({ NULL; })
+#define audit_log_start(c,g,t) ({ NULL; })
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)
 #define audit_log_end(b) do { ; } while (0)

commit 5bb289b5a0becb53ac3e1d60815ff8b779296b73
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Fri Jun 24 14:14:05 2005 +0100

    AUDIT: Clean up user message filtering
    
    Don't look up the task by its pid and then use the syscall filtering
    helper. Just implement our own filter helper which operates solely on
    the information in the netlink_skb_parms.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2f56546eb248..38999f827a36 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -205,6 +205,7 @@ struct audit_sig_info {
 struct audit_buffer;
 struct audit_context;
 struct inode;
+struct netlink_skb_parms;
 
 #define AUDITSC_INVALID 0
 #define AUDITSC_SUCCESS 1
@@ -236,7 +237,7 @@ extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
-extern int audit_filter_user(int pid, int type);
+extern int audit_filter_user(struct netlink_skb_parms *cb, int type);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -253,7 +254,7 @@ extern int audit_filter_user(int pid, int type);
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
-#define audit_filter_user(p,t) ({ 1; })
+#define audit_filter_user(cb,t) ({ 1; })
 #endif
 
 #ifdef CONFIG_AUDIT

commit 9ad9ad385be27fcc7c16d290d972c6173e780a61
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Wed Jun 22 15:04:33 2005 +0100

    AUDIT: Wait for backlog to clear when generating messages.
    
    Add a gfp_mask to audit_log_start() and audit_log(), to reduce the
    amount of GFP_ATOMIC allocation -- most of it doesn't need to be
    GFP_ATOMIC. Also if the mask includes __GFP_WAIT, then wait up to
    60 seconds for the auditd backlog to clear instead of immediately
    abandoning the message.
    
    The timeout should probably be made configurable, but for now it'll
    suffice that it only happens if auditd is actually running.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 77adef640537..2f56546eb248 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -259,11 +259,11 @@ extern int audit_filter_user(int pid, int type);
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
-extern void		    audit_log(struct audit_context *ctx, int type,
-				      const char *fmt, ...)
-			    __attribute__((format(printf,3,4)));
+extern void		    audit_log(struct audit_context *ctx, int gfp_mask,
+				      int type, const char *fmt, ...)
+				      __attribute__((format(printf,4,5)));
 
-extern struct audit_buffer *audit_log_start(struct audit_context *ctx,int type);
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx, int gfp_mask, int type);
 extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));

commit 4a4cd633b575609b741a1de7837223a2d9e1c34c
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Wed Jun 22 14:56:47 2005 +0100

    AUDIT: Optimise the audit-disabled case for discarding user messages
    
    Also exempt USER_AVC message from being discarded to preserve
    existing behaviour for SE Linux.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5d1a9dda5acb..77adef640537 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -51,7 +51,8 @@
 #define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
 #define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
 
-#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages uninteresting to kernel */
+#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages mostly uninteresting to kernel */
+#define AUDIT_USER_AVC		1107	/* We filter this differently */
 #define AUDIT_LAST_USER_MSG	1199
  
 #define AUDIT_DAEMON_START      1200    /* Daemon startup record */
@@ -235,7 +236,7 @@ extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
-extern int audit_filter_user(struct task_struct *tsk, int type);
+extern int audit_filter_user(int pid, int type);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -252,7 +253,7 @@ extern int audit_filter_user(struct task_struct *tsk, int type);
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
-#define audit_filter_user(struct ({ 1; })
+#define audit_filter_user(p,t) ({ 1; })
 #endif
 
 #ifdef CONFIG_AUDIT

commit f6a789d19858a951e7ff9e297a44b377c21b6c33
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Tue Jun 21 16:22:01 2005 +0100

    AUDIT: Spawn kernel thread to list filter rules.
    
    If we have enough rules to fill the netlink buffer space, it'll
    deadlock because auditctl isn't ever actually going to read from the
    socket until we return, and we aren't going to return until it
    reads... so we spawn a kernel thread to spew out the list and then
    exit.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5f812e4d01e4..5d1a9dda5acb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -281,6 +281,7 @@ extern void		    audit_send_reply(int pid, int seq, int type,
 					     int done, int multi,
 					     void *payload, int size);
 extern void		    audit_log_lost(const char *message);
+extern struct semaphore audit_netlink_sem;
 #else
 #define audit_log(c,t,f,...) do { ; } while (0)
 #define audit_log_start(c,t) ({ NULL; })

commit ae7b961b1c943367dfe179411f120d7bf8eaba89
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Mon Jun 20 16:11:05 2005 +0100

    AUDIT: Report lookup flags with path/inode records.
    
    When LOOKUP_PARENT is used, the inode which results is not the inode
    found at the pathname. Report the flags so that this doesn't generate
    misleading audit records.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index b5bda24f7365..5f812e4d01e4 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -220,7 +220,7 @@ extern void audit_syscall_entry(struct task_struct *task, int arch,
 extern void audit_syscall_exit(struct task_struct *task, int failed, long return_code);
 extern void audit_getname(const char *name);
 extern void audit_putname(const char *name);
-extern void audit_inode(const char *name, const struct inode *inode);
+extern void audit_inode(const char *name, const struct inode *inode, unsigned flags);
 
 				/* Private API (for audit.c only) */
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
@@ -243,7 +243,7 @@ extern int audit_filter_user(struct task_struct *tsk, int type);
 #define audit_syscall_exit(t,f,r) do { ; } while (0)
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
-#define audit_inode(n,i) do { ; } while (0)
+#define audit_inode(n,i,f) do { ; } while (0)
 #define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
 #define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })

commit 0f45aa18e65cf3d768082d7d86054a0d2a20bb18
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Sun Jun 19 19:35:50 2005 +0100

    AUDIT: Allow filtering of user messages
    
    Turn the field from a bitmask to an enumeration and add a list to allow
    filtering of messages generated by userspace. We also define a list for
    file system watches in anticipation of that feature.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index bf2ad3ba72eb..b5bda24f7365 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -75,10 +75,15 @@
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
 /* Rule flags */
-#define AUDIT_PER_TASK 0x01	/* Apply rule at task creation (not syscall) */
-#define AUDIT_AT_ENTRY 0x02	/* Apply rule at syscall entry */
-#define AUDIT_AT_EXIT  0x04	/* Apply rule at syscall exit */
-#define AUDIT_PREPEND  0x10	/* Prepend to front of list */
+#define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
+#define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
+#define AUDIT_FILTER_ENTRY	0x02	/* Apply rule at syscall entry */
+#define AUDIT_FILTER_WATCH	0x03	/* Apply rule to file system watches */
+#define AUDIT_FILTER_EXIT	0x04	/* Apply rule at syscall exit */
+
+#define AUDIT_NR_FILTERS	5
+
+#define AUDIT_FILTER_PREPEND	0x10	/* Prepend to front of list */
 
 /* Rule actions */
 #define AUDIT_NEVER    0	/* Do not build context if rule matches */
@@ -230,6 +235,7 @@ extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
 extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
+extern int audit_filter_user(struct task_struct *tsk, int type);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -246,6 +252,7 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #define audit_sockaddr(len, addr) ({ 0; })
 #define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
+#define audit_filter_user(struct ({ 1; })
 #endif
 
 #ifdef CONFIG_AUDIT

commit 8f37d47c9bf74cb48692691086b482e315d07f40
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Fri May 27 12:17:28 2005 +0100

    AUDIT: Record working directory when syscall arguments are pathnames
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3278ddf41ce6..bf2ad3ba72eb 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -61,11 +61,12 @@
 
 #define AUDIT_SYSCALL		1300	/* Syscall event */
 #define AUDIT_FS_WATCH		1301	/* Filesystem watch event */
-#define AUDIT_PATH		1302	/* Filname path information */
+#define AUDIT_PATH		1302	/* Filename path information */
 #define AUDIT_IPC		1303	/* IPC record */
 #define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
 #define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
 #define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
+#define AUDIT_CWD		1307	/* Current working directory */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */

commit bfb4496e7239c9132d732a65cdcf3d6a7431ad1a
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Sat May 21 21:08:09 2005 +0100

    AUDIT: Assign serial number to non-syscall messages
    
    Move audit_serial() into audit.c and use it to generate serial numbers
    on messages even when there is no audit context from syscall auditing.
    This allows us to disambiguate audit records when more than one is
    generated in the same millisecond.
    
    Based on a patch by Steve Grubb after he observed the problem.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 4b7caf0c6e10..3278ddf41ce6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -219,8 +219,9 @@ extern void audit_inode(const char *name, const struct inode *inode);
 				/* Private API (for audit.c only) */
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				 void *data, uid_t loginuid);
-extern int audit_get_stamp(struct audit_context *ctx,
-			    struct timespec *t, unsigned int *serial);
+extern unsigned int audit_serial(void);
+extern void auditsc_get_stamp(struct audit_context *ctx,
+			      struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
@@ -237,7 +238,7 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #define audit_putname(n) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)
 #define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
-#define audit_get_stamp(c,t,s) ({ 0; })
+#define auditsc_get_stamp(c,t,s) do { BUG(); } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_perms(q,u,g,m) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })

commit 011161051bbc25f7f8b7df059dbd934c534443f0
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Sat May 21 00:15:52 2005 +0100

    AUDIT: Avoid sleeping function in SElinux AVC audit.
    
    This patch changes the SELinux AVC to defer logging of paths to the audit
    framework upon syscall exit, by saving a reference to the (dentry,vfsmount)
    pair in an auxiliary audit item on the current audit context for processing
    by audit_log_exit.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 17ea5d522d81..4b7caf0c6e10 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -69,6 +69,7 @@
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
+#define AUDIT_AVC_PATH		1402	/* dentry, vfsmount pair from avc */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
@@ -225,6 +226,7 @@ extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 extern int audit_socketcall(int nargs, unsigned long *args);
 extern int audit_sockaddr(int len, void *addr);
+extern int audit_avc_path(struct dentry *dentry, struct vfsmount *mnt);
 extern void audit_signal_info(int sig, struct task_struct *t);
 #else
 #define audit_alloc(t) ({ 0; })
@@ -240,6 +242,7 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #define audit_ipc_perms(q,u,g,m) ({ 0; })
 #define audit_socketcall(n,a) ({ 0; })
 #define audit_sockaddr(len, addr) ({ 0; })
+#define audit_avc_path(dentry, mnt) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
 #endif
 

commit 209aba03243ee42a22f8df8d08aa9963f62aec64
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Wed May 18 10:21:07 2005 +0100

    AUDIT: Treat all user messages identically.
    
    It's silly to have to add explicit entries for new userspace messages
    as we invent them. Just treat all messages in the user range the same.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 2f5dc60f8bbd..17ea5d522d81 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -51,14 +51,8 @@
 #define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
 #define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
 
-#define AUDIT_USER_AUTH		1100	/* User space authentication */
-#define AUDIT_USER_ACCT		1101	/* User space acct change */
-#define AUDIT_USER_MGMT		1102	/* User space acct management */
-#define AUDIT_CRED_ACQ		1103	/* User space credential acquired */
-#define AUDIT_CRED_DISP		1104	/* User space credential disposed */
-#define AUDIT_USER_START	1105	/* User space session start */ 
-#define AUDIT_USER_END		1106	/* User space session end */
-#define AUDIT_USER_AVC		1107	/* User space avc message */
+#define AUDIT_FIRST_USER_MSG	1100	/* Userspace messages uninteresting to kernel */
+#define AUDIT_LAST_USER_MSG	1199
  
 #define AUDIT_DAEMON_START      1200    /* Daemon startup record */
 #define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
@@ -173,13 +167,6 @@
 #define AUDIT_ARCH_V850		(EM_V850|__AUDIT_ARCH_LE)
 #define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
 
-#ifndef __KERNEL__
-struct audit_message {
-	struct nlmsghdr nlh;
-	char		data[1200];
-};
-#endif
-
 struct audit_status {
 	__u32		mask;		/* Bit mask for valid entries */
 	__u32		enabled;	/* 1 = enabled, 0 = disabled */

commit 3ec3b2fba526ead2fa3f3d7c91924f39a0733749
Author: David Woodhouse <dwmw2@shinybook.infradead.org>
Date:   Tue May 17 12:08:48 2005 +0100

    AUDIT: Capture sys_socketcall arguments and sockaddrs
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 51e5879af7fc..2f5dc60f8bbd 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -69,8 +69,9 @@
 #define AUDIT_FS_WATCH		1301	/* Filesystem watch event */
 #define AUDIT_PATH		1302	/* Filname path information */
 #define AUDIT_IPC		1303	/* IPC record */
-#define AUDIT_SOCKET		1304	/* Socket record */
+#define AUDIT_SOCKETCALL	1304	/* sys_socketcall arguments */
 #define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
+#define AUDIT_SOCKADDR		1306	/* sockaddr copied as syscall arg */
 
 #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
 #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
@@ -235,6 +236,8 @@ extern int audit_get_stamp(struct audit_context *ctx,
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern int audit_socketcall(int nargs, unsigned long *args);
+extern int audit_sockaddr(int len, void *addr);
 extern void audit_signal_info(int sig, struct task_struct *t);
 #else
 #define audit_alloc(t) ({ 0; })
@@ -248,6 +251,8 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #define audit_get_stamp(c,t,s) ({ 0; })
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_perms(q,u,g,m) ({ 0; })
+#define audit_socketcall(n,a) ({ 0; })
+#define audit_sockaddr(len, addr) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)
 #endif
 

commit 23f32d18aa589e228c5a9e12e0d0c67c9b5bcdce
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri May 13 18:35:15 2005 +0100

    AUDIT: Fix some spelling errors
    
    I'm going through the kernel code and have a patch that corrects
    several spelling errors in comments.
    
    From: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 1a15ba38c660..51e5879af7fc 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -181,7 +181,7 @@ struct audit_message {
 
 struct audit_status {
 	__u32		mask;		/* Bit mask for valid entries */
-	__u32		enabled;	/* 1 = enabled, 0 = disbaled */
+	__u32		enabled;	/* 1 = enabled, 0 = disabled */
 	__u32		failure;	/* Failure-to-log action */
 	__u32		pid;		/* pid of auditd process */
 	__u32		rate_limit;	/* messages rate limit (per second) */

commit c04049939f88b29e235d2da217bce6e8ead44f32
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri May 13 18:17:42 2005 +0100

    AUDIT: Add message types to audit records
    
    This patch adds more messages types to the audit subsystem so that audit
    analysis is quicker, intuitive, and more useful.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    ---
    I forgot one type in the big patch. I need to add one for user space
    originating SE Linux avc messages. This is used by dbus and nscd.
    
    -Steve
    ---
    Updated to 2.6.12-rc4-mm1.
    -dwmw2
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 405332ebf3c6..1a15ba38c660 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -27,15 +27,53 @@
 #include <linux/sched.h>
 #include <linux/elf.h>
 
-/* Request and reply types */
+/* The netlink messages for the audit system is divided into blocks:
+ * 1000 - 1099 are for commanding the audit system
+ * 1100 - 1199 user space trusted application messages
+ * 1200 - 1299 messages internal to the audit daemon
+ * 1300 - 1399 audit event messages
+ * 1400 - 1499 SE Linux use
+ * 1500 - 1999 future use
+ * 2000 is for otherwise unclassified kernel audit messages
+ *
+ * Messages from 1000-1199 are bi-directional. 1200-1299 are exclusively user
+ * space. Anything over that is kernel --> user space communication.
+ */
 #define AUDIT_GET		1000	/* Get status */
 #define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
-#define AUDIT_LIST		1002	/* List filtering rules */
-#define AUDIT_ADD		1003	/* Add filtering rule */
-#define AUDIT_DEL		1004	/* Delete filtering rule */
-#define AUDIT_USER		1005	/* Send a message from user-space */
+#define AUDIT_LIST		1002	/* List syscall filtering rules */
+#define AUDIT_ADD		1003	/* Add syscall filtering rule */
+#define AUDIT_DEL		1004	/* Delete syscall filtering rule */
+#define AUDIT_USER		1005	/* Message from userspace -- deprecated */
 #define AUDIT_LOGIN		1006	/* Define the login id and information */
-#define AUDIT_SIGNAL_INFO	1010	/* Get information about sender of signal*/
+#define AUDIT_WATCH_INS		1007	/* Insert file/dir watch entry */
+#define AUDIT_WATCH_REM		1008	/* Remove file/dir watch entry */
+#define AUDIT_WATCH_LIST	1009	/* List all file/dir watches */
+#define AUDIT_SIGNAL_INFO	1010	/* Get info about sender of signal to auditd */
+
+#define AUDIT_USER_AUTH		1100	/* User space authentication */
+#define AUDIT_USER_ACCT		1101	/* User space acct change */
+#define AUDIT_USER_MGMT		1102	/* User space acct management */
+#define AUDIT_CRED_ACQ		1103	/* User space credential acquired */
+#define AUDIT_CRED_DISP		1104	/* User space credential disposed */
+#define AUDIT_USER_START	1105	/* User space session start */ 
+#define AUDIT_USER_END		1106	/* User space session end */
+#define AUDIT_USER_AVC		1107	/* User space avc message */
+ 
+#define AUDIT_DAEMON_START      1200    /* Daemon startup record */
+#define AUDIT_DAEMON_END        1201    /* Daemon normal stop record */
+#define AUDIT_DAEMON_ABORT      1202    /* Daemon error stop record */
+#define AUDIT_DAEMON_CONFIG     1203    /* Daemon config change */
+
+#define AUDIT_SYSCALL		1300	/* Syscall event */
+#define AUDIT_FS_WATCH		1301	/* Filesystem watch event */
+#define AUDIT_PATH		1302	/* Filname path information */
+#define AUDIT_IPC		1303	/* IPC record */
+#define AUDIT_SOCKET		1304	/* Socket record */
+#define AUDIT_CONFIG_CHANGE	1305	/* Audit system configuration change */
+
+#define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
+#define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
@@ -216,14 +254,11 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
-#define audit_log(ctx, fmt, args...) \
-	audit_log_type(ctx, AUDIT_KERNEL, 0, fmt, ##args)
-extern void		    audit_log_type(struct audit_context *ctx, int type,
-				      int pid, const char *fmt, ...)
-			    __attribute__((format(printf,4,5)));
+extern void		    audit_log(struct audit_context *ctx, int type,
+				      const char *fmt, ...)
+			    __attribute__((format(printf,3,4)));
 
-extern struct audit_buffer *audit_log_start(struct audit_context *ctx, int type,
-					    int pid);
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx,int type);
 extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));
@@ -243,9 +278,8 @@ extern void		    audit_send_reply(int pid, int seq, int type,
 					     void *payload, int size);
 extern void		    audit_log_lost(const char *message);
 #else
-#define audit_log(c,f,...) do { ; } while (0)
-#define audit_log_type(c,t,p,f,...) do { ; } while (0)
-#define audit_log_start(c,t,p) ({ NULL; })
+#define audit_log(c,t,f,...) do { ; } while (0)
+#define audit_log_start(c,t) ({ NULL; })
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)
 #define audit_log_end(b) do { ; } while (0)

commit c1b773d87eadc3972d697444127e89a7291769a2
Author: Chris Wright <chrisw@osdl.org>
Date:   Wed May 11 10:55:10 2005 +0100

    Add audit_log_type
    
    Add audit_log_type to allow callers to specify type and pid when logging.
    Convert audit_log to wrapper around audit_log_type.  Could have
    converted all audit_log callers directly, but common case is default
    of type AUDIT_KERNEL and pid 0.  Update audit_log_start to take type
    and pid values when creating a new audit_buffer.  Move sequences that
    did audit_log_start, audit_log_format, audit_set_type, audit_log_end,
    to simply call audit_log_type directly.  This obsoletes audit_set_type
    and audit_set_pid, so remove them.
    
    Signed-off-by: Chris Wright <chrisw@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 58c5589b531f..405332ebf3c6 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -216,11 +216,14 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #ifdef CONFIG_AUDIT
 /* These are defined in audit.c */
 				/* Public API */
-extern void		    audit_log(struct audit_context *ctx,
-				      const char *fmt, ...)
-			    __attribute__((format(printf,2,3)));
+#define audit_log(ctx, fmt, args...) \
+	audit_log_type(ctx, AUDIT_KERNEL, 0, fmt, ##args)
+extern void		    audit_log_type(struct audit_context *ctx, int type,
+				      int pid, const char *fmt, ...)
+			    __attribute__((format(printf,4,5)));
 
-extern struct audit_buffer *audit_log_start(struct audit_context *ctx);
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx, int type,
+					    int pid);
 extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));
@@ -240,8 +243,9 @@ extern void		    audit_send_reply(int pid, int seq, int type,
 					     void *payload, int size);
 extern void		    audit_log_lost(const char *message);
 #else
-#define audit_log(t,f,...) do { ; } while (0)
-#define audit_log_start(t) ({ NULL; })
+#define audit_log(c,f,...) do { ; } while (0)
+#define audit_log_type(c,t,p,f,...) do { ; } while (0)
+#define audit_log_start(c,t,p) ({ NULL; })
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)
 #define audit_log_end(b) do { ; } while (0)

commit 197c69c6afd2deb7eec44040ff533d90d26c6161
Author: Chris Wright <chrisw@osdl.org>
Date:   Wed May 11 10:54:05 2005 +0100

    Move ifdef CONFIG_AUDITSYSCALL to header
    
    Remove code conditionally dependent on CONFIG_AUDITSYSCALL from audit.c.
    Move these dependencies to audit.h with the rest.
    
    Signed-off-by: Chris Wright <chrisw@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index baa80760824c..58c5589b531f 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -192,7 +192,7 @@ extern void audit_inode(const char *name, const struct inode *inode);
 				/* Private API (for audit.c only) */
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				 void *data, uid_t loginuid);
-extern void audit_get_stamp(struct audit_context *ctx,
+extern int audit_get_stamp(struct audit_context *ctx,
 			    struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
@@ -206,6 +206,8 @@ extern void audit_signal_info(int sig, struct task_struct *t);
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)
+#define audit_receive_filter(t,p,u,s,d,l) ({ -EOPNOTSUPP; })
+#define audit_get_stamp(c,t,s) ({ 0; })
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_perms(q,u,g,m) ({ 0; })
 #define audit_signal_info(s,t) do { ; } while (0)

commit c2f0c7c356dc9ae15419f00c725a2fcc58eeff58
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri May 6 12:38:39 2005 +0100

    The attached patch addresses the problem with getting the audit daemon
    shutdown credential information. It creates a new message type
    AUDIT_TERM_INFO, which is used by the audit daemon to query who issued the
    shutdown.
    
    It requires the placement of a hook function that gathers the information. The
    hook is after the DAC & MAC checks and before the function returns. Racing
    threads could overwrite the uid & pid - but they would have to be root and
    have policy that allows signalling the audit daemon. That should be a
    manageable risk.
    
    The userspace component will be released later in audit 0.7.2. When it
    receives the TERM signal, it queries the kernel for shutdown information.
    When it receives it, it writes the message and exits. The message looks
    like this:
    
    type=DAEMON msg=auditd(1114551182.000) auditd normal halt, sending pid=2650
    uid=525, auditd pid=1685
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 19f04b049798..baa80760824c 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -28,14 +28,16 @@
 #include <linux/elf.h>
 
 /* Request and reply types */
-#define AUDIT_GET      1000	/* Get status */
-#define AUDIT_SET      1001	/* Set status (enable/disable/auditd) */
-#define AUDIT_LIST     1002	/* List filtering rules */
-#define AUDIT_ADD      1003	/* Add filtering rule */
-#define AUDIT_DEL      1004	/* Delete filtering rule */
-#define AUDIT_USER     1005	/* Send a message from user-space */
-#define AUDIT_LOGIN    1006     /* Define the login id and informaiton */
-#define AUDIT_KERNEL   2000	/* Asynchronous audit record. NOT A REQUEST. */
+#define AUDIT_GET		1000	/* Get status */
+#define AUDIT_SET		1001	/* Set status (enable/disable/auditd) */
+#define AUDIT_LIST		1002	/* List filtering rules */
+#define AUDIT_ADD		1003	/* Add filtering rule */
+#define AUDIT_DEL		1004	/* Delete filtering rule */
+#define AUDIT_USER		1005	/* Send a message from user-space */
+#define AUDIT_LOGIN		1006	/* Define the login id and information */
+#define AUDIT_SIGNAL_INFO	1010	/* Get information about sender of signal*/
+
+#define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
 /* Rule flags */
 #define AUDIT_PER_TASK 0x01	/* Apply rule at task creation (not syscall) */
@@ -161,6 +163,11 @@ struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
 
 #ifdef __KERNEL__
 
+struct audit_sig_info {
+	uid_t		uid;
+	pid_t		pid;
+};
+
 struct audit_buffer;
 struct audit_context;
 struct inode;
@@ -190,6 +197,7 @@ extern void audit_get_stamp(struct audit_context *ctx,
 extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+extern void audit_signal_info(int sig, struct task_struct *t);
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
@@ -200,6 +208,7 @@ extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mo
 #define audit_inode(n,i) do { ; } while (0)
 #define audit_get_loginuid(c) ({ -1; })
 #define audit_ipc_perms(q,u,g,m) ({ 0; })
+#define audit_signal_info(s,t) do { ; } while (0)
 #endif
 
 #ifdef CONFIG_AUDIT

commit 456be6cd90dbbb9b0ea01d56932d56d110d51cf7
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri Apr 29 17:30:07 2005 +0100

    [AUDIT] LOGIN message credentials
    
    Attached is a new patch that solves the issue of getting valid credentials
    into the LOGIN message. The current code was assuming that the audit context
    had already been copied. This is not always the case for LOGIN messages.
    
    To solve the problem, the patch passes the task struct to the function that
    emits the message where it can get valid credentials.
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 19f214230fec..19f04b049798 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -187,7 +187,7 @@ extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				 void *data, uid_t loginuid);
 extern void audit_get_stamp(struct audit_context *ctx,
 			    struct timespec *t, unsigned int *serial);
-extern int  audit_set_loginuid(struct audit_context *ctx, uid_t loginuid);
+extern int  audit_set_loginuid(struct task_struct *task, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
 #else

commit c94c257c88c517f251da273a15c654224c7b6e21
Author: Serge Hallyn <serue@us.ibm.com>
Date:   Fri Apr 29 16:27:17 2005 +0100

    Add audit uid to netlink credentials
    
    Most audit control messages are sent over netlink.In order to properly
    log the identity of the sender of audit control messages, we would like
    to add the loginuid to the netlink_creds structure, as per the attached
    patch.
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 5fabe8481011..19f214230fec 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -184,7 +184,7 @@ extern void audit_inode(const char *name, const struct inode *inode);
 
 				/* Private API (for audit.c only) */
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
-				 void *data);
+				 void *data, uid_t loginuid);
 extern void audit_get_stamp(struct audit_context *ctx,
 			    struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct audit_context *ctx, uid_t loginuid);

commit 85c8721ff3bc96b702427a440616079e8daf8a2f
Author:  <dwmw2@shinybook.infradead.org>
Date:   Fri Apr 29 16:23:29 2005 +0100

    audit: update pointer to userspace tools, remove emacs mode tags

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 0467f2441b68..5fabe8481011 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -1,4 +1,4 @@
-/* audit.h -- Auditing support -*- linux-c -*-
+/* audit.h -- Auditing support
  *
  * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
  * All Rights Reserved.

commit d812ddbb89e323d054a7d073466225966c8350c8
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Fri Apr 29 16:09:52 2005 +0100

    [AUDIT] Fix signedness of 'serial' in various routines.
    
    Attached is a patch that corrects a signed/unsigned warning. I also noticed
    that we needlessly init serial to 0. That only needs to occur if the kernel
    was compiled without the audit system.
    
    -Steve Grubb
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index fad0c1dc21a9..0467f2441b68 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -186,7 +186,7 @@ extern void audit_inode(const char *name, const struct inode *inode);
 extern int  audit_receive_filter(int type, int pid, int uid, int seq,
 				 void *data);
 extern void audit_get_stamp(struct audit_context *ctx,
-			    struct timespec *t, int *serial);
+			    struct timespec *t, unsigned int *serial);
 extern int  audit_set_loginuid(struct audit_context *ctx, uid_t loginuid);
 extern uid_t audit_get_loginuid(struct audit_context *ctx);
 extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);

commit 2fd6f58ba6efc82ea2c9c2630f7ff5ed9eeaf34a
Author:  <dwmw2@shinybook.infradead.org>
Date:   Fri Apr 29 16:08:28 2005 +0100

    [AUDIT] Don't allow ptrace to fool auditing, log arch of audited syscalls.
    
    We were calling ptrace_notify() after auditing the syscall and arguments,
    but the debugger could have _changed_ them before the syscall was actually
    invoked. Reorder the calls to fix that.
    
    While we're touching ever call to audit_syscall_entry(), we also make it
    take an extra argument: the architecture of the syscall which was made,
    because some architectures allow more than one type of syscall.
    
    Also add an explicit success/failure flag to audit_syscall_exit(), for
    the benefit of architectures which return that in a condition register
    rather than only returning a single register.
    
    Change type of syscall return value to 'long' not 'int'.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 9b77992c4888..fad0c1dc21a9 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -24,6 +24,9 @@
 #ifndef _LINUX_AUDIT_H_
 #define _LINUX_AUDIT_H_
 
+#include <linux/sched.h>
+#include <linux/elf.h>
+
 /* Request and reply types */
 #define AUDIT_GET      1000	/* Get status */
 #define AUDIT_SET      1001	/* Set status (enable/disable/auditd) */
@@ -67,6 +70,7 @@
 #define AUDIT_FSGID	8
 #define AUDIT_LOGINUID	9
 #define AUDIT_PERS	10
+#define AUDIT_ARCH	11
 
 				/* These are ONLY useful when checking
 				 * at syscall exit time (AUDIT_AT_EXIT). */
@@ -96,6 +100,38 @@
 #define AUDIT_FAIL_PRINTK	1
 #define AUDIT_FAIL_PANIC	2
 
+/* distinguish syscall tables */
+#define __AUDIT_ARCH_64BIT 0x80000000
+#define __AUDIT_ARCH_LE	   0x40000000
+#define AUDIT_ARCH_ALPHA	(EM_ALPHA|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARM		(EM_ARM|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_ARMEB	(EM_ARM)
+#define AUDIT_ARCH_CRIS		(EM_CRIS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_FRV		(EM_FRV)
+#define AUDIT_ARCH_H8300	(EM_H8_300)
+#define AUDIT_ARCH_I386		(EM_386|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_IA64		(EM_IA_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_M32R		(EM_M32R)
+#define AUDIT_ARCH_M68K		(EM_68K)
+#define AUDIT_ARCH_MIPS		(EM_MIPS)
+#define AUDIT_ARCH_MIPSEL	(EM_MIPS|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_MIPS64	(EM_MIPS|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_MIPSEL64	(EM_MIPS|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_PARISC	(EM_PARISC)
+#define AUDIT_ARCH_PARISC64	(EM_PARISC|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_PPC		(EM_PPC)
+#define AUDIT_ARCH_PPC64	(EM_PPC64|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_S390		(EM_S390)
+#define AUDIT_ARCH_S390X	(EM_S390|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SH		(EM_SH)
+#define AUDIT_ARCH_SHEL		(EM_SH|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SH64		(EM_SH|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_SHEL64	(EM_SH|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_SPARC	(EM_SPARC)
+#define AUDIT_ARCH_SPARC64	(EM_SPARC64|__AUDIT_ARCH_64BIT)
+#define AUDIT_ARCH_V850		(EM_V850|__AUDIT_ARCH_LE)
+#define AUDIT_ARCH_X86_64	(EM_X86_64|__AUDIT_ARCH_64BIT|__AUDIT_ARCH_LE)
+
 #ifndef __KERNEL__
 struct audit_message {
 	struct nlmsghdr nlh;
@@ -129,15 +165,19 @@ struct audit_buffer;
 struct audit_context;
 struct inode;
 
+#define AUDITSC_INVALID 0
+#define AUDITSC_SUCCESS 1
+#define AUDITSC_FAILURE 2
+#define AUDITSC_RESULT(x) ( ((long)(x))<0?AUDITSC_FAILURE:AUDITSC_SUCCESS )
 #ifdef CONFIG_AUDITSYSCALL
 /* These are defined in auditsc.c */
 				/* Public API */
 extern int  audit_alloc(struct task_struct *task);
 extern void audit_free(struct task_struct *task);
-extern void audit_syscall_entry(struct task_struct *task,
+extern void audit_syscall_entry(struct task_struct *task, int arch,
 				int major, unsigned long a0, unsigned long a1,
 				unsigned long a2, unsigned long a3);
-extern void audit_syscall_exit(struct task_struct *task, int return_code);
+extern void audit_syscall_exit(struct task_struct *task, int failed, long return_code);
 extern void audit_getname(const char *name);
 extern void audit_putname(const char *name);
 extern void audit_inode(const char *name, const struct inode *inode);
@@ -153,8 +193,8 @@ extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mo
 #else
 #define audit_alloc(t) ({ 0; })
 #define audit_free(t) do { ; } while (0)
-#define audit_syscall_entry(t,a,b,c,d,e) do { ; } while (0)
-#define audit_syscall_exit(t,r) do { ; } while (0)
+#define audit_syscall_entry(t,ta,a,b,c,d,e) do { ; } while (0)
+#define audit_syscall_exit(t,f,r) do { ; } while (0)
 #define audit_getname(n) do { ; } while (0)
 #define audit_putname(n) do { ; } while (0)
 #define audit_inode(n,i) do { ; } while (0)

commit 83c7d09173fdb6b06b109e65895392db3e49ac9c
Author:  <dwmw2@shinybook.infradead.org>
Date:   Fri Apr 29 15:54:44 2005 +0100

    AUDIT: Avoid log pollution by untrusted strings.
    
    We log strings from userspace, such as arguments to open(). These could
    be formatted to contain \n followed by fake audit log entries. Provide
    a function for logging such strings, which gives a hex dump when the
    string contains anything but basic printable ASCII characters. Use it
    for logging filenames.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/audit.h b/include/linux/audit.h
index 3628f7cfb178..9b77992c4888 100644
--- a/include/linux/audit.h
+++ b/include/linux/audit.h
@@ -174,11 +174,15 @@ extern void		    audit_log_format(struct audit_buffer *ab,
 					     const char *fmt, ...)
 			    __attribute__((format(printf,2,3)));
 extern void		    audit_log_end(struct audit_buffer *ab);
+extern void		    audit_log_hex(struct audit_buffer *ab,
+					  const unsigned char *buf,
+					  size_t len);
+extern void		    audit_log_untrustedstring(struct audit_buffer *ab,
+						      const char *string);
 extern void		    audit_log_d_path(struct audit_buffer *ab,
 					     const char *prefix,
 					     struct dentry *dentry,
 					     struct vfsmount *vfsmnt);
-
 				/* Private API (for auditsc.c only) */
 extern void		    audit_send_reply(int pid, int seq, int type,
 					     int done, int multi,
@@ -190,6 +194,8 @@ extern void		    audit_log_lost(const char *message);
 #define audit_log_vformat(b,f,a) do { ; } while (0)
 #define audit_log_format(b,f,...) do { ; } while (0)
 #define audit_log_end(b) do { ; } while (0)
+#define audit_log_hex(a,b,l) do { ; } while (0)
+#define audit_log_untrustedstring(a,s) do { ; } while (0)
 #define audit_log_d_path(b,p,d,v) do { ; } while (0)
 #endif
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/audit.h b/include/linux/audit.h
new file mode 100644
index 000000000000..3628f7cfb178
--- /dev/null
+++ b/include/linux/audit.h
@@ -0,0 +1,196 @@
+/* audit.h -- Auditing support -*- linux-c -*-
+ *
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Written by Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+#ifndef _LINUX_AUDIT_H_
+#define _LINUX_AUDIT_H_
+
+/* Request and reply types */
+#define AUDIT_GET      1000	/* Get status */
+#define AUDIT_SET      1001	/* Set status (enable/disable/auditd) */
+#define AUDIT_LIST     1002	/* List filtering rules */
+#define AUDIT_ADD      1003	/* Add filtering rule */
+#define AUDIT_DEL      1004	/* Delete filtering rule */
+#define AUDIT_USER     1005	/* Send a message from user-space */
+#define AUDIT_LOGIN    1006     /* Define the login id and informaiton */
+#define AUDIT_KERNEL   2000	/* Asynchronous audit record. NOT A REQUEST. */
+
+/* Rule flags */
+#define AUDIT_PER_TASK 0x01	/* Apply rule at task creation (not syscall) */
+#define AUDIT_AT_ENTRY 0x02	/* Apply rule at syscall entry */
+#define AUDIT_AT_EXIT  0x04	/* Apply rule at syscall exit */
+#define AUDIT_PREPEND  0x10	/* Prepend to front of list */
+
+/* Rule actions */
+#define AUDIT_NEVER    0	/* Do not build context if rule matches */
+#define AUDIT_POSSIBLE 1	/* Build context if rule matches  */
+#define AUDIT_ALWAYS   2	/* Generate audit record if rule matches */
+
+/* Rule structure sizes -- if these change, different AUDIT_ADD and
+ * AUDIT_LIST commands must be implemented. */
+#define AUDIT_MAX_FIELDS   64
+#define AUDIT_BITMASK_SIZE 64
+#define AUDIT_WORD(nr) ((__u32)((nr)/32))
+#define AUDIT_BIT(nr)  (1 << ((nr) - AUDIT_WORD(nr)*32))
+
+/* Rule fields */
+				/* These are useful when checking the
+				 * task structure at task creation time
+				 * (AUDIT_PER_TASK).  */
+#define AUDIT_PID	0
+#define AUDIT_UID	1
+#define AUDIT_EUID	2
+#define AUDIT_SUID	3
+#define AUDIT_FSUID	4
+#define AUDIT_GID	5
+#define AUDIT_EGID	6
+#define AUDIT_SGID	7
+#define AUDIT_FSGID	8
+#define AUDIT_LOGINUID	9
+#define AUDIT_PERS	10
+
+				/* These are ONLY useful when checking
+				 * at syscall exit time (AUDIT_AT_EXIT). */
+#define AUDIT_DEVMAJOR	100
+#define AUDIT_DEVMINOR	101
+#define AUDIT_INODE	102
+#define AUDIT_EXIT	103
+#define AUDIT_SUCCESS   104	/* exit >= 0; value ignored */
+
+#define AUDIT_ARG0      200
+#define AUDIT_ARG1      (AUDIT_ARG0+1)
+#define AUDIT_ARG2      (AUDIT_ARG0+2)
+#define AUDIT_ARG3      (AUDIT_ARG0+3)
+
+#define AUDIT_NEGATE    0x80000000
+
+
+/* Status symbols */
+				/* Mask values */
+#define AUDIT_STATUS_ENABLED		0x0001
+#define AUDIT_STATUS_FAILURE		0x0002
+#define AUDIT_STATUS_PID		0x0004
+#define AUDIT_STATUS_RATE_LIMIT		0x0008
+#define AUDIT_STATUS_BACKLOG_LIMIT	0x0010
+				/* Failure-to-log actions */
+#define AUDIT_FAIL_SILENT	0
+#define AUDIT_FAIL_PRINTK	1
+#define AUDIT_FAIL_PANIC	2
+
+#ifndef __KERNEL__
+struct audit_message {
+	struct nlmsghdr nlh;
+	char		data[1200];
+};
+#endif
+
+struct audit_status {
+	__u32		mask;		/* Bit mask for valid entries */
+	__u32		enabled;	/* 1 = enabled, 0 = disbaled */
+	__u32		failure;	/* Failure-to-log action */
+	__u32		pid;		/* pid of auditd process */
+	__u32		rate_limit;	/* messages rate limit (per second) */
+	__u32		backlog_limit;	/* waiting messages limit */
+	__u32		lost;		/* messages lost */
+	__u32		backlog;	/* messages waiting in queue */
+};
+
+struct audit_rule {		/* for AUDIT_LIST, AUDIT_ADD, and AUDIT_DEL */
+	__u32		flags;	/* AUDIT_PER_{TASK,CALL}, AUDIT_PREPEND */
+	__u32		action;	/* AUDIT_NEVER, AUDIT_POSSIBLE, AUDIT_ALWAYS */
+	__u32		field_count;
+	__u32		mask[AUDIT_BITMASK_SIZE];
+	__u32		fields[AUDIT_MAX_FIELDS];
+	__u32		values[AUDIT_MAX_FIELDS];
+};
+
+#ifdef __KERNEL__
+
+struct audit_buffer;
+struct audit_context;
+struct inode;
+
+#ifdef CONFIG_AUDITSYSCALL
+/* These are defined in auditsc.c */
+				/* Public API */
+extern int  audit_alloc(struct task_struct *task);
+extern void audit_free(struct task_struct *task);
+extern void audit_syscall_entry(struct task_struct *task,
+				int major, unsigned long a0, unsigned long a1,
+				unsigned long a2, unsigned long a3);
+extern void audit_syscall_exit(struct task_struct *task, int return_code);
+extern void audit_getname(const char *name);
+extern void audit_putname(const char *name);
+extern void audit_inode(const char *name, const struct inode *inode);
+
+				/* Private API (for audit.c only) */
+extern int  audit_receive_filter(int type, int pid, int uid, int seq,
+				 void *data);
+extern void audit_get_stamp(struct audit_context *ctx,
+			    struct timespec *t, int *serial);
+extern int  audit_set_loginuid(struct audit_context *ctx, uid_t loginuid);
+extern uid_t audit_get_loginuid(struct audit_context *ctx);
+extern int audit_ipc_perms(unsigned long qbytes, uid_t uid, gid_t gid, mode_t mode);
+#else
+#define audit_alloc(t) ({ 0; })
+#define audit_free(t) do { ; } while (0)
+#define audit_syscall_entry(t,a,b,c,d,e) do { ; } while (0)
+#define audit_syscall_exit(t,r) do { ; } while (0)
+#define audit_getname(n) do { ; } while (0)
+#define audit_putname(n) do { ; } while (0)
+#define audit_inode(n,i) do { ; } while (0)
+#define audit_get_loginuid(c) ({ -1; })
+#define audit_ipc_perms(q,u,g,m) ({ 0; })
+#endif
+
+#ifdef CONFIG_AUDIT
+/* These are defined in audit.c */
+				/* Public API */
+extern void		    audit_log(struct audit_context *ctx,
+				      const char *fmt, ...)
+			    __attribute__((format(printf,2,3)));
+
+extern struct audit_buffer *audit_log_start(struct audit_context *ctx);
+extern void		    audit_log_format(struct audit_buffer *ab,
+					     const char *fmt, ...)
+			    __attribute__((format(printf,2,3)));
+extern void		    audit_log_end(struct audit_buffer *ab);
+extern void		    audit_log_d_path(struct audit_buffer *ab,
+					     const char *prefix,
+					     struct dentry *dentry,
+					     struct vfsmount *vfsmnt);
+
+				/* Private API (for auditsc.c only) */
+extern void		    audit_send_reply(int pid, int seq, int type,
+					     int done, int multi,
+					     void *payload, int size);
+extern void		    audit_log_lost(const char *message);
+#else
+#define audit_log(t,f,...) do { ; } while (0)
+#define audit_log_start(t) ({ NULL; })
+#define audit_log_vformat(b,f,a) do { ; } while (0)
+#define audit_log_format(b,f,...) do { ; } while (0)
+#define audit_log_end(b) do { ; } while (0)
+#define audit_log_d_path(b,p,d,v) do { ; } while (0)
+#endif
+#endif
+#endif
