commit 2a1ccd31420a7b1acd6ca37b2bec2d723aa093e4
Merge: e0e86b111bca 3a1d24ca9573
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 11:01:13 2019 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "The irq departement provides the usual mixed bag:
    
      Core:
    
       - Further improvements to the irq timings code which aims to predict
         the next interrupt for power state selection to achieve better
         latency/power balance
    
       - Add interrupt statistics to the core NMI handlers
    
       - The usual small fixes and cleanups
    
      Drivers:
    
       - Support for Renesas RZ/A1, Annapurna Labs FIC, Meson-G12A SoC and
         Amazon Gravition AMR/GIC interrupt controllers.
    
       - Rework of the Renesas INTC controller driver
    
       - ACPI support for Socionext SoCs
    
       - Enhancements to the CSKY interrupt controller
    
       - The usual small fixes and cleanups"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (39 commits)
      irq/irqdomain: Fix comment typo
      genirq: Update irq stats from NMI handlers
      irqchip/gic-pm: Remove PM_CLK dependency
      irqchip/al-fic: Introduce Amazon's Annapurna Labs Fabric Interrupt Controller Driver
      dt-bindings: interrupt-controller: Add Amazon's Annapurna Labs FIC
      softirq: Use __this_cpu_write() in takeover_tasklets()
      irqchip/mbigen: Stop printing kernel addresses
      irqchip/gic: Add dependency for ARM_GIC_MAX_NR
      genirq/affinity: Remove unused argument from [__]irq_build_affinity_masks()
      genirq/timings: Add selftest for next event computation
      genirq/timings: Add selftest for irqs circular buffer
      genirq/timings: Add selftest for circular array
      genirq/timings: Encapsulate storing function
      genirq/timings: Encapsulate timings push
      genirq/timings: Optimize the period detection speed
      genirq/timings: Fix timings buffer inspection
      genirq/timings: Fix next event index function
      irqchip/qcom: Use struct_size() in devm_kzalloc()
      irqchip/irq-csky-mpintc: Remove unnecessary loop in interrupt handler
      dt-bindings: interrupt-controller: Update csky mpintc
      ...

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 0f049b384ccd..316087da1d09 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  include/linux/irqchip/arm-gic.h
  *
  *  Copyright (C) 2002 ARM Limited, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef __LINUX_IRQCHIP_ARM_GIC_H
 #define __LINUX_IRQCHIP_ARM_GIC_H

commit 90b4c55586155cf13bbafbd4e55327f89681859d
Author: Zeev Zilberman <zeev@amazon.com>
Date:   Mon Jun 10 13:52:01 2019 +0300

    irqchip/gic-v2m: Add support for Amazon Graviton variant of GICv3+GICv2m
    
    Add support for Amazon Graviton custom variant of GICv2m, where the message
    is encoded using the MSI message address, as opposed to standard
    GICv2m, where the SPI number is encoded in the MSI message data.
    
    In addition, the Graviton flavor of GICv2m is used along GICv3 (and not
    GICv2).
    
    Co-developed-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Zeev Zilberman <zeev@amazon.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 0f049b384ccd..7bd3bc6baa40 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -160,9 +160,6 @@ int gic_of_init_child(struct device *dev, struct gic_chip_data **gic, int irq);
  */
 void gic_init(void __iomem *dist , void __iomem *cpu);
 
-int gicv2m_init(struct fwnode_handle *parent_handle,
-		struct irq_domain *parent);
-
 void gic_send_sgi(unsigned int cpu_id, unsigned int irq);
 int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);

commit b41fdc4a7bf9045e4871c5b15905ea732ffd044f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Mar 11 15:38:10 2019 +0000

    irqchip/gic: Drop support for secondary GIC in non-DT systems
    
    We do not have any in-tree platform with this pathological setup,
    and only a single system (Cavium's cns3xxx) isn't DT aware.
    
    Let's drop the secondary GIC support for now, until we remove
    the above horror altogether.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 626179077bb0..0f049b384ccd 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -158,8 +158,7 @@ int gic_of_init_child(struct device *dev, struct gic_chip_data **gic, int irq);
  * Legacy platforms not converted to DT yet must use this to init
  * their GIC
  */
-void gic_init(unsigned int nr, int start,
-	      void __iomem *dist , void __iomem *cpu);
+void gic_init(void __iomem *dist , void __iomem *cpu);
 
 int gicv2m_init(struct fwnode_handle *parent_handle,
 		struct irq_domain *parent);

commit 2130b789b3ef6a518b9c9c6f245642620e2b0c0c
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Tue Aug 28 16:51:18 2018 +0100

    irqchip/gic: Unify GIC priority definitions
    
    LPIs use the same priority value as other GIC interrupts.
    
    Make the GIC default priority definition visible to ITS implementation
    and use this same definition for LPI priorities.
    
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 6c4aaf04046c..626179077bb0 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -65,11 +65,6 @@
 #define GICD_INT_EN_CLR_X32		0xffffffff
 #define GICD_INT_EN_SET_SGI		0x0000ffff
 #define GICD_INT_EN_CLR_PPI		0xffff0000
-#define GICD_INT_DEF_PRI		0xa0
-#define GICD_INT_DEF_PRI_X4		((GICD_INT_DEF_PRI << 24) |\
-					(GICD_INT_DEF_PRI << 16) |\
-					(GICD_INT_DEF_PRI << 8) |\
-					GICD_INT_DEF_PRI)
 
 #define GICD_IIDR_IMPLEMENTER_SHIFT	0
 #define GICD_IIDR_IMPLEMENTER_MASK	(0xfff << GICD_IIDR_IMPLEMENTER_SHIFT)

commit 87322099052b6a534cecd3d303fc097d4560b7d0
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Jul 16 15:06:22 2018 +0200

    KVM: arm/arm64: vgic: Signal IRQs using their configured group
    
    Now when we have a group configuration on the struct IRQ, use this state
    when populating the LR and signaling interrupts as either group 0 or
    group 1 to the VM.  Depending on the model of the emulated GIC, and the
    guest's configuration of the VMCR, interrupts may be signaled as IRQs or
    FIQs to the VM.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 484f5bfa9f3d..6c4aaf04046c 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -104,6 +104,7 @@
 #define GICH_LR_PENDING_BIT		(1 << 28)
 #define GICH_LR_ACTIVE_BIT		(1 << 29)
 #define GICH_LR_EOI			(1 << 19)
+#define GICH_LR_GROUP1			(1 << 30)
 #define GICH_LR_HW			(1 << 31)
 
 #define GICH_VMCR_ENABLE_GRP0_SHIFT	0

commit a2dca217dae29c4ff6420e8c78d56b3f61ae0797
Author: Christoffer Dall <christoffer.dall@arm.com>
Date:   Mon Jul 16 15:06:18 2018 +0200

    KVM: arm/arm64: vgic: Define GICD_IIDR fields for GICv2 and GIv3
    
    Instead of hardcoding the shifts and masks in the GICD_IIDR register
    emulation, let's add the definition of these fields to the GIC header
    files and use them.
    
    This will make things more obvious when we're going to bump the revision
    in the IIDR when we'll make guest-visible changes to the implementation.
    
    Reviewed-by: Andrew Jones <drjones@redhat.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 68d8b1f73682..484f5bfa9f3d 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -71,6 +71,16 @@
 					(GICD_INT_DEF_PRI << 8) |\
 					GICD_INT_DEF_PRI)
 
+#define GICD_IIDR_IMPLEMENTER_SHIFT	0
+#define GICD_IIDR_IMPLEMENTER_MASK	(0xfff << GICD_IIDR_IMPLEMENTER_SHIFT)
+#define GICD_IIDR_REVISION_SHIFT	12
+#define GICD_IIDR_REVISION_MASK		(0xf << GICD_IIDR_REVISION_SHIFT)
+#define GICD_IIDR_VARIANT_SHIFT		16
+#define GICD_IIDR_VARIANT_MASK		(0xf << GICD_IIDR_VARIANT_SHIFT)
+#define GICD_IIDR_PRODUCT_ID_SHIFT	24
+#define GICD_IIDR_PRODUCT_ID_MASK	(0xff << GICD_IIDR_PRODUCT_ID_SHIFT)
+
+
 #define GICH_HCR			0x0
 #define GICH_VTR			0x4
 #define GICH_VMCR			0x8

commit 16ca6a607d84bef0129698d8d808f501afd08d43
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Mar 6 21:48:01 2018 +0000

    KVM: arm/arm64: vgic: Don't populate multiple LRs with the same vintid
    
    The vgic code is trying to be clever when injecting GICv2 SGIs,
    and will happily populate LRs with the same interrupt number if
    they come from multiple vcpus (after all, they are distinct
    interrupt sources).
    
    Unfortunately, this is against the letter of the architecture,
    and the GICv2 architecture spec says "Each valid interrupt stored
    in the List registers must have a unique VirtualID for that
    virtual CPU interface.". GICv3 has similar (although slightly
    ambiguous) restrictions.
    
    This results in guests locking up when using GICv2-on-GICv3, for
    example. The obvious fix is to stop trying so hard, and inject
    a single vcpu per SGI per guest entry. After all, pending SGIs
    with multiple source vcpus are pretty rare, and are mostly seen
    in scenario where the physical CPUs are severely overcomitted.
    
    But as we now only inject a single instance of a multi-source SGI per
    vcpu entry, we may delay those interrupts for longer than strictly
    necessary, and run the risk of injecting lower priority interrupts
    in the meantime.
    
    In order to address this, we adopt a three stage strategy:
    - If we encounter a multi-source SGI in the AP list while computing
      its depth, we force the list to be sorted
    - When populating the LRs, we prevent the injection of any interrupt
      of lower priority than that of the first multi-source SGI we've
      injected.
    - Finally, the injection of a multi-source SGI triggers the request
      of a maintenance interrupt when there will be no pending interrupt
      in the LRs (HCR_NPIE).
    
    At the point where the last pending interrupt in the LRs switches
    from Pending to Active, the maintenance interrupt will be delivered,
    allowing us to add the remaining SGIs using the same process.
    
    Cc: stable@vger.kernel.org
    Fixes: 0919e84c0fc1 ("KVM: arm/arm64: vgic-new: Add IRQ sync/flush framework")
    Acked-by: Christoffer Dall <cdall@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index d3453ee072fc..68d8b1f73682 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -84,6 +84,7 @@
 
 #define GICH_HCR_EN			(1 << 0)
 #define GICH_HCR_UIE			(1 << 1)
+#define GICH_HCR_NPIE			(1 << 3)
 
 #define GICH_LR_VIRTUALID		(0x3ff << 0)
 #define GICH_LR_PHYSID_CPUID_SHIFT	(10)

commit 28232a4317be7ad615f0f1b69dc8583fd580a8e3
Author: Christoffer Dall <cdall@linaro.org>
Date:   Sat May 20 14:12:34 2017 +0200

    KVM: arm/arm64: Fix isues with GICv2 on GICv3 migration
    
    We have been a little loose with our intermediate VMCR representation
    where we had a 'ctlr' field, but we failed to differentiate between the
    GICv2 GICC_CTLR and ICC_CTLR_EL1 layouts, and therefore ended up mapping
    the wrong bits into the individual fields of the ICH_VMCR_EL2 when
    emulating a GICv2 on a GICv3 system.
    
    Fix this by using explicit fields for the VMCR bits instead.
    
    Cc: Eric Auger <eric.auger@redhat.com>
    Reported-by: wanghaibin <wanghaibin.wang@huawei.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index dc30f3d057eb..d3453ee072fc 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -25,7 +25,18 @@
 #define GICC_ENABLE			0x1
 #define GICC_INT_PRI_THRESHOLD		0xf0
 
-#define GIC_CPU_CTRL_EOImodeNS		(1 << 9)
+#define GIC_CPU_CTRL_EnableGrp0_SHIFT	0
+#define GIC_CPU_CTRL_EnableGrp0		(1 << GIC_CPU_CTRL_EnableGrp0_SHIFT)
+#define GIC_CPU_CTRL_EnableGrp1_SHIFT	1
+#define GIC_CPU_CTRL_EnableGrp1		(1 << GIC_CPU_CTRL_EnableGrp1_SHIFT)
+#define GIC_CPU_CTRL_AckCtl_SHIFT	2
+#define GIC_CPU_CTRL_AckCtl		(1 << GIC_CPU_CTRL_AckCtl_SHIFT)
+#define GIC_CPU_CTRL_FIQEn_SHIFT	3
+#define GIC_CPU_CTRL_FIQEn		(1 << GIC_CPU_CTRL_FIQEn_SHIFT)
+#define GIC_CPU_CTRL_CBPR_SHIFT		4
+#define GIC_CPU_CTRL_CBPR		(1 << GIC_CPU_CTRL_CBPR_SHIFT)
+#define GIC_CPU_CTRL_EOImodeNS_SHIFT	9
+#define GIC_CPU_CTRL_EOImodeNS		(1 << GIC_CPU_CTRL_EOImodeNS_SHIFT)
 
 #define GICC_IAR_INT_ID_MASK		0x3ff
 #define GICC_INT_SPURIOUS		1023
@@ -84,8 +95,19 @@
 #define GICH_LR_EOI			(1 << 19)
 #define GICH_LR_HW			(1 << 31)
 
-#define GICH_VMCR_CTRL_SHIFT		0
-#define GICH_VMCR_CTRL_MASK		(0x21f << GICH_VMCR_CTRL_SHIFT)
+#define GICH_VMCR_ENABLE_GRP0_SHIFT	0
+#define GICH_VMCR_ENABLE_GRP0_MASK	(1 << GICH_VMCR_ENABLE_GRP0_SHIFT)
+#define GICH_VMCR_ENABLE_GRP1_SHIFT	1
+#define GICH_VMCR_ENABLE_GRP1_MASK	(1 << GICH_VMCR_ENABLE_GRP1_SHIFT)
+#define GICH_VMCR_ACK_CTL_SHIFT		2
+#define GICH_VMCR_ACK_CTL_MASK		(1 << GICH_VMCR_ACK_CTL_SHIFT)
+#define GICH_VMCR_FIQ_EN_SHIFT		3
+#define GICH_VMCR_FIQ_EN_MASK		(1 << GICH_VMCR_FIQ_EN_SHIFT)
+#define GICH_VMCR_CBPR_SHIFT		4
+#define GICH_VMCR_CBPR_MASK		(1 << GICH_VMCR_CBPR_SHIFT)
+#define GICH_VMCR_EOI_MODE_SHIFT	9
+#define GICH_VMCR_EOI_MODE_MASK		(1 << GICH_VMCR_EOI_MODE_SHIFT)
+
 #define GICH_VMCR_PRIMASK_SHIFT		27
 #define GICH_VMCR_PRIMASK_MASK		(0x1f << GICH_VMCR_PRIMASK_SHIFT)
 #define GICH_VMCR_BINPOINT_SHIFT	21

commit 6d56111c92d247bb64301029fe88365aa4caf16e
Author: Christoffer Dall <cdall@linaro.org>
Date:   Tue Mar 21 22:05:22 2017 +0100

    KVM: arm/arm64: vgic: Fix GICC_PMR uaccess on GICv3 and clarify ABI
    
    As an oversight, for GICv2, we accidentally export the GICC_PMR register
    in the format of the GICH_VMCR.VMPriMask field in the lower 5 bits of a
    word, meaning that userspace must always use the lower 5 bits to
    communicate with the KVM device and must shift the value left by 3
    places to obtain the actual priority mask level.
    
    Since GICv3 supports the full 8 bits of priority masking in the ICH_VMCR,
    we have to fix the value we export when emulating a GICv2 on top of a
    hardware GICv3 and exporting the emulated GICv2 state to userspace.
    
    Take the chance to clarify this aspect of the ABI.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <cdall@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index eafc965b3eb8..dc30f3d057eb 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -96,6 +96,9 @@
 #define GICH_MISR_EOI			(1 << 0)
 #define GICH_MISR_U			(1 << 1)
 
+#define GICV_PMR_PRIORITY_SHIFT		3
+#define GICV_PMR_PRIORITY_MASK		(0x1f << GICV_PMR_PRIORITY_SHIFT)
+
 #ifndef __ASSEMBLY__
 
 #include <linux/irqdomain.h>

commit 9c8edddfc9924cb473a7570c37ca466db70728f8
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Jun 7 16:12:34 2016 +0100

    irqchip/gic: Add platform driver for non-root GICs that require RPM
    
    Add a platform driver to support non-root GICs that require runtime
    power-management. Currently, only non-root GICs are supported because
    the functions, smp_cross_call() and set_handle_irq(), that need to
    be called for a root controller are located in the __init section and
    so cannot be called by the platform driver.
    
    The GIC platform driver re-uses many functions from the existing GIC
    driver including some functions to save and restore the GIC context
    during power transitions. The functions for saving and restoring the
    GIC context are currently only defined if CONFIG_CPU_PM is enabled and
    to ensure that these functions are always defined when the platform
    driver is enabled, a dependency on CONFIG_ARM_GIC_PM (which selects the
    platform driver) has been added.
    
    In order to re-use the private GIC initialisation code, a new public
    function, gic_of_init_child(), has been added which calls various
    private functions to initialise the GIC. This is different from the
    existing gic_of_init() because it only supports non-root GICs (ie. does
    not call smp_cross_call() is set_handle_irq()) and is not located in
    the __init section (so can be used by platform drivers). Furthermore,
    gic_of_init_child() dynamically allocates memory for the GIC chip data
    which is also different from gic_of_init().
    
    There is no specific suspend handling for GICs registered as platform
    devices. Non-wakeup interrupts will be disabled by the kernel during
    late suspend, however, this alone will not power down the GIC if
    interrupts have been requested and not freed. Therefore, requestors of
    non-wakeup interrupts will need to free them on entering suspend in
    order to power-down the GIC.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index ffcbd8b9a4ff..eafc965b3eb8 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -116,6 +116,12 @@ void gic_dist_restore(struct gic_chip_data *gic);
  */
 int gic_of_init(struct device_node *node, struct device_node *parent);
 
+/*
+ * Initialises and registers a non-root or child GIC chip. Memory for
+ * the gic_chip_data structure is dynamically allocated.
+ */
+int gic_of_init_child(struct device *dev, struct gic_chip_data **gic, int irq);
+
 /*
  * Legacy platforms not converted to DT yet must use this to init
  * their GIC

commit cdbb813db6925f9dcd352841d8ba28f2edd83ff8
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Jun 7 16:12:32 2016 +0100

    irqchip/gic: Prepare for adding platform driver
    
    To support GICs that require runtime power management, it is necessary
    to add a platform driver, so that the probing of the chip can be
    deferred if resources, such as a power-domain, is not yet available.
    
    To prepare for adding a platform driver:
     1. Drop the __init section from the gic_dist_config() so this can be
        re-used by the platform driver.
     2. Add prototypes for functions required by the platform driver to the
        GIC header file so they can be re-used.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index fd051855539b..ffcbd8b9a4ff 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -101,9 +101,14 @@
 #include <linux/irqdomain.h>
 
 struct device_node;
+struct gic_chip_data;
 
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
 int gic_cpu_if_down(unsigned int gic_nr);
+void gic_cpu_save(struct gic_chip_data *gic);
+void gic_cpu_restore(struct gic_chip_data *gic);
+void gic_dist_save(struct gic_chip_data *gic);
+void gic_dist_restore(struct gic_chip_data *gic);
 
 /*
  * Subdrivers that need some preparatory work can initialize their

commit 2b0cda8789654bfcebca397daebc37aff081bd75
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Apr 26 11:06:47 2016 +0100

    KVM: arm/arm64: vgic-new: Add CTLR, TYPER and IIDR handlers
    
    Those three registers are v2 emulation specific, so their implementation
    lives entirely in vgic-mmio-v2.c. Also they are handled in one function,
    as their implementation is pretty simple.
    When the guest enables the distributor, we kick all VCPUs to get
    potentially pending interrupts serviced.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index be0d26f940af..fd051855539b 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -33,6 +33,7 @@
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
+#define GIC_DIST_IIDR			0x008
 #define GIC_DIST_IGROUP			0x080
 #define GIC_DIST_ENABLE_SET		0x100
 #define GIC_DIST_ENABLE_CLEAR		0x180

commit 140b086dd19771410915a924db2e635c2b51a0f4
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Nov 26 17:19:25 2015 +0000

    KVM: arm/arm64: vgic-new: Add GICv2 world switch backend
    
    Processing maintenance interrupts and accessing the list registers
    are dependent on the host's GIC version.
    Introduce vgic-v2.c to contain GICv2 specific functions.
    Implement the GICv2 specific code for syncing the emulation state
    into the VGIC registers.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Eric Auger <eric.auger@linaro.org>
    Signed-off-by: Andre Przywara <andre.przywara@arm.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 9c940263ca23..be0d26f940af 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -76,6 +76,7 @@
 #define GICH_LR_VIRTUALID		(0x3ff << 0)
 #define GICH_LR_PHYSID_CPUID_SHIFT	(10)
 #define GICH_LR_PHYSID_CPUID		(0x3ff << GICH_LR_PHYSID_CPUID_SHIFT)
+#define GICH_LR_PRIORITY_SHIFT		23
 #define GICH_LR_STATE			(3 << 28)
 #define GICH_LR_PENDING_BIT		(1 << 28)
 #define GICH_LR_ACTIVE_BIT		(1 << 29)

commit 92b86f92ed0307efbaea3c0e95520551848d3995
Merge: a4289dc2ec3a 0644b3daca28
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Dec 29 10:08:45 2015 +0100

    Merge branch 'irq/gic-v2m-acpi' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/core
    
    Pull another round of GIC changes from Marc:
    
     ACPI support for GIV-v2m

commit 0644b3daca28dcb320373ae20069c269c9386304
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Thu Dec 10 08:55:30 2015 -0800

    irqchip/gic-v2m: acpi: Introducing GICv2m ACPI support
    
    This patch introduces gicv2m_acpi_init(), which uses information
    in MADT GIC MSI frames structure to initialize GICv2m driver.
    It also exposes gicv2m_init() function, which simplifies callers
    to a single GICv2m init function.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Tested-by: Duc Dang <dhdang@apm.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index bae69e5d693c..febc6c312e37 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -106,7 +106,8 @@ int gic_cpu_if_down(unsigned int gic_nr);
 void gic_init(unsigned int nr, int start,
 	      void __iomem *dist , void __iomem *cpu);
 
-int gicv2m_of_init(struct device_node *node, struct irq_domain *parent);
+int gicv2m_init(struct fwnode_handle *parent_handle,
+		struct irq_domain *parent);
 
 void gic_send_sgi(unsigned int cpu_id, unsigned int irq);
 int gic_get_cpu_id(unsigned int cpu);

commit 8673c1d7e8f0cc69b84c1c3356d869b74385fca7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Oct 24 00:15:52 2015 +0200

    irqchip/gic: Support RealView variant setup
    
    The ARM RealView PB11MPCore reference design has some special
    bits in a system controller register to set up the GIC in one
    of three modes: legacy, new with DCC, new without DCC. The
    register is also used to enable FIQ.
    
    Since the platform will not boot unless this register is set
    up to "new with DCC" mode, we need a special quirk to be
    compiled-in for the RealView platforms.
    
    If we find the right compatible string on the GIC TestChip,
    we enable this quirk by looking up the system controller and
    enabling the special bits.
    
    We depend on the CONFIG_REALVIEW_DT Kconfig symbol as the old
    boardfile code has the same fix hardcoded, and this is only
    needed for the attempts to modernize the RealView code using
    device tree.
    
    After fixing this, the PB11MPCore boots with device tree
    only.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index bae69e5d693c..d0a29db73bc7 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -103,6 +103,16 @@ struct device_node;
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
 int gic_cpu_if_down(unsigned int gic_nr);
 
+/*
+ * Subdrivers that need some preparatory work can initialize their
+ * chips and call this to register their GICs.
+ */
+int gic_of_init(struct device_node *node, struct device_node *parent);
+
+/*
+ * Legacy platforms not converted to DT yet must use this to init
+ * their GIC
+ */
 void gic_init(unsigned int nr, int start,
 	      void __iomem *dist , void __iomem *cpu);
 

commit e81a7cd96bd55bb57d92486c514b7b8f8c8cd8ce
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:39 2015 +0100

    irqchip/gic: Get rid of gic_init_bases()
    
    Since nobody is using gic_init_bases anymore outside of the GIC
    driver itself, let's do a bit of housekeeping and remove the now
    useless entry point.
    
    Only gic_init() is now exposed to the rest of the kernel for the
    benefit of legacy systems.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-12-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index b8901dfd9e95..bae69e5d693c 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -100,16 +100,11 @@
 
 struct device_node;
 
-void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
-		    u32 offset, struct device_node *);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
 int gic_cpu_if_down(unsigned int gic_nr);
 
-static inline void gic_init(unsigned int nr, int start,
-			    void __iomem *dist , void __iomem *cpu)
-{
-	gic_init_bases(nr, start, dist, cpu, 0, NULL);
-}
+void gic_init(unsigned int nr, int start,
+	      void __iomem *dist , void __iomem *cpu);
 
 int gicv2m_of_init(struct device_node *node, struct irq_domain *parent);
 

commit 519f526d391b0ef775aeb04c4b6f632ea6b3ee50
Merge: 06ab838c2024 ba60c41ae392
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 10 16:42:49 2015 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull more kvm updates from Paolo Bonzini:
     "ARM:
       - Full debug support for arm64
       - Active state switching for timer interrupts
       - Lazy FP/SIMD save/restore for arm64
       - Generic ARMv8 target
    
      PPC:
       - Book3S: A few bug fixes
       - Book3S: Allow micro-threading on POWER8
    
      x86:
       - Compiler warnings
    
      Generic:
       - Adaptive polling for guest halt"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (49 commits)
      kvm: irqchip: fix memory leak
      kvm: move new trace event outside #ifdef CONFIG_KVM_ASYNC_PF
      KVM: trace kvm_halt_poll_ns grow/shrink
      KVM: dynamic halt-polling
      KVM: make halt_poll_ns per-vCPU
      Silence compiler warning in arch/x86/kvm/emulate.c
      kvm: compile process_smi_save_seg_64() only for x86_64
      KVM: x86: avoid uninitialized variable warning
      KVM: PPC: Book3S: Fix typo in top comment about locking
      KVM: PPC: Book3S: Fix size of the PSPB register
      KVM: PPC: Book3S HV: Exit on H_DOORBELL if HOST_IPI is set
      KVM: PPC: Book3S HV: Fix race in starting secondary threads
      KVM: PPC: Book3S: correct width in XER handling
      KVM: PPC: Book3S HV: Fix preempted vcore stolen time calculation
      KVM: PPC: Book3S HV: Fix preempted vcore list locking
      KVM: PPC: Book3S HV: Implement H_CLEAR_REF and H_CLEAR_MOD
      KVM: PPC: Book3S HV: Fix bug in dirty page tracking
      KVM: PPC: Book3S HV: Fix race in reading change bit when removing HPTE
      KVM: PPC: Book3S HV: Implement dynamic micro-threading on POWER8
      KVM: PPC: Book3S HV: Make use of unused threads when running guests
      ...

commit 0b996fd35957a30568cddbce05b917c1897966e0
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Aug 26 17:00:44 2015 +0100

    irqchip/GIC: Convert to EOImode == 1
    
    So far, GICv2 has been used with EOImode == 0. The effect of this
    mode is to perform the priority drop and the deactivation of the
    interrupt at the same time.
    
    While this works perfectly for Linux (we only have a single priority),
    it causes issues when an interrupt is forwarded to a guest, and when
    we want the guest to perform the EOI itself.
    
    For this case, the GIC architecture provides EOImode == 1, where:
    - A write to the EOI register drops the priority of the interrupt
      and leaves it active. Other interrupts at the same priority level
      can now be taken, but the active interrupt cannot be taken again
    - A write to the DIR marks the interrupt as inactive, meaning it can
      now be taken again.
    
    We only enable this feature when booted in HYP mode and that
    the device-tree reported a suitable CPU interface. Observable behaviour
    should remain unchanged.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Eric Auger <eric.auger@linaro.org>
    Cc: Christoffer Dall <christoffer.dall@linaro.org>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: kvmarm@lists.cs.columbia.edu
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1440604845-28229-4-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 65da435d01c1..af3d29f70781 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -20,9 +20,13 @@
 #define GIC_CPU_ALIAS_BINPOINT		0x1c
 #define GIC_CPU_ACTIVEPRIO		0xd0
 #define GIC_CPU_IDENT			0xfc
+#define GIC_CPU_DEACTIVATE		0x1000
 
 #define GICC_ENABLE			0x1
 #define GICC_INT_PRI_THRESHOLD		0xf0
+
+#define GIC_CPU_CTRL_EOImodeNS		(1 << 9)
+
 #define GICC_IAR_INT_ID_MASK		0x3ff
 #define GICC_INT_SPURIOUS		1023
 #define GICC_DIS_BYPASS_MASK		0x1e0

commit fb182cf84568cc33ab41121bc8cc999f7aacbd47
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jun 8 15:37:26 2015 +0100

    KVM: arm/arm64: vgic: Allow HW irq to be encoded in LR
    
    Now that struct vgic_lr supports the LR_HW bit and carries a hwirq
    field, we can encode that information into the list registers.
    
    This patch provides implementations for both GICv2 and GICv3.
    
    Reviewed-by: Christoffer Dall <christoffer.dall@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 9de976b4f9a7..ca88dad65260 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -71,11 +71,12 @@
 
 #define GICH_LR_VIRTUALID		(0x3ff << 0)
 #define GICH_LR_PHYSID_CPUID_SHIFT	(10)
-#define GICH_LR_PHYSID_CPUID		(7 << GICH_LR_PHYSID_CPUID_SHIFT)
+#define GICH_LR_PHYSID_CPUID		(0x3ff << GICH_LR_PHYSID_CPUID_SHIFT)
 #define GICH_LR_STATE			(3 << 28)
 #define GICH_LR_PENDING_BIT		(1 << 28)
 #define GICH_LR_ACTIVE_BIT		(1 << 29)
 #define GICH_LR_EOI			(1 << 19)
+#define GICH_LR_HW			(1 << 31)
 
 #define GICH_VMCR_CTRL_SHIFT		0
 #define GICH_VMCR_CTRL_MASK		(0x21f << GICH_VMCR_CTRL_SHIFT)

commit 4c2880b31c700b03f3f115b5ca64be615783aa9c
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Fri Jul 31 09:44:12 2015 +0100

    irqchip/gic: Ensure gic_cpu_if_up/down() programs correct GIC instance
    
    Commit 3228950621d9 ("irqchip: gic: Preserve gic V2 bypass bits in cpu
    ctrl register") added a new function, gic_cpu_if_up(), to program the
    GIC CPU_CTRL register. This function assumes that there is only one GIC
    instance present and hence always uses the chip data for the primary GIC
    controller. Although it is not common for there to be a secondary, some
    devices do support a secondary. Therefore, fix this by passing
    gic_cpu_if_up() a pointer to the appropriate chip data structure.
    
    Similarly, the function gic_cpu_if_down() only assumes that there is a
    single GIC instance present. Update this function so that an instance
    number is passed for the appropriate GIC and return an error code on
    failure. The vexpress TC2 (which has a single GIC) is currently the only
    user of this function and so update it accordingly. Note that because the
    TC2 only has a single GIC, the call to gic_cpu_if_down() should always
    be successful.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438332252-25248-2-git-send-email-jonathanh@nvidia.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 61a2007eb49a..65da435d01c1 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -98,7 +98,7 @@ struct device_node;
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
-void gic_cpu_if_down(void);
+int gic_cpu_if_down(unsigned int gic_nr);
 
 static inline void gic_init(unsigned int nr, int start,
 			    void __iomem *dist , void __iomem *cpu)

commit 0d3f2c92e004c67404fabea19728c1962b777bd6
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jul 15 15:38:29 2015 +0100

    irqchip/gic: Remove redundant gic_set_irqchip_flags
    
    Now that the GIC chip implementation enables IRQCHIP_SKIP_SET_WAKE and
    IRQCHIP_MASK_ON_SUSPEND by default, the platforms requiring them need
    not override the irqchip flags as before.
    
    This patch removes all the users of gic_set_irqchip_flags and the
    function itself.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1436971109-20189-2-git-send-email-sudeep.holla@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 9de976b4f9a7..61a2007eb49a 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -95,7 +95,6 @@
 
 struct device_node;
 
-void gic_set_irqchip_flags(unsigned long flags);
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);

commit 1dcc73d7bb0429994c54d33b40c5fb82b741a791
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Apr 22 18:20:04 2015 +0100

    irqchip: gic: Drop support for gic_arch_extn
    
    Now that the users of gic_arch_extn have been fixed, drop the
    "feature" for good. This leads to the removal of some now useless
    locking.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 36ec4ae74634..9de976b4f9a7 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -95,8 +95,6 @@
 
 struct device_node;
 
-extern struct irq_chip gic_arch_extn;
-
 void gic_set_irqchip_flags(unsigned long flags);
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);

commit a01e7b3258bea93fbf1f028fab1c739d80c61823
Merge: fb414e908b15 008e4d673509
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Fri Apr 10 22:58:19 2015 +0000

    Merge branch 'irqchip/stacked-irq_set_wake' into irqchip/core
    
    Conflicts:
            drivers/irqchip/irq-gic.c

commit 49869be2d9d0e9195706da7050c81bc909f41f4f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 11 15:45:34 2015 +0000

    irqchip: gic: Add an entry point to set up irqchip flags
    
    A common use of gic_arch_extn is to set up additional flags
    to the GIC irqchip. It looks like a benign enough hack that
    doesn't really require the users of that feature to be converted
    to stacked domains.
    
    Add a gic_set_irqchip_flags() function that platform code can
    call instead of using the dreaded gic_arch_extn.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1426088737-15817-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 71d706d5f169..3bca864fd6fc 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -97,6 +97,7 @@ struct device_node;
 
 extern struct irq_chip gic_arch_extn;
 
+void gic_set_irqchip_flags(unsigned long flags);
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);

commit a5561c3e845cae41ae40c15689a7f26e90b000c8
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 11 15:43:46 2015 +0000

    irqchip: gic: Get rid of routable domain
    
    The only user of the so called "routable domain" functionality
    now being fixed, let's clean up the GIC.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1426088629-15377-5-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 71d706d5f169..3978c5be4edc 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -115,11 +115,5 @@ int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);
 unsigned long gic_get_sgir_physaddr(void);
 
-extern const struct irq_domain_ops *gic_routable_irq_domain_ops;
-static inline void __init register_routable_domain_ops
-					(const struct irq_domain_ops *ops)
-{
-	gic_routable_irq_domain_ops = ops;
-}
 #endif /* __ASSEMBLY */
 #endif

commit df870c78848aac4d953f61a8926a792de8133b9e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Nov 27 18:27:49 2014 +0000

    irqchip: gic: Remove warning by including linux/irqdomain.h
    
    Commit
    
      853a33ce6932 irqchip: gic-v2m: Add support for ARM GICv2m MSI(-X) doorbell
    
    Introduced a series of warnings when building ARM multi_v7_defconfig:
    
      include/linux/irqchip/arm-gic.h:109:53: warning: its scope is only this definition or declaration, which is probably not what you want
      In file included from arch/arm/mach-ux500/pm.c:13:0:
      include/linux/irqchip/arm-gic.h:109:53: warning: 'struct irq_domain' declared inside parameter list
       int gicv2m_of_init(struct device_node *node, struct irq_domain *parent);
                                                           ^
    
    Fix this by adding the proper include.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    [ jac merged much more correct version from Marc into this patch ]
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Link: https://lkml.kernel.org/r/1417170975-1163-1-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 60b09ed58cae..71d706d5f169 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -91,6 +91,8 @@
 
 #ifndef __ASSEMBLY__
 
+#include <linux/irqdomain.h>
+
 struct device_node;
 
 extern struct irq_chip gic_arch_extn;

commit 853a33ce6932601030f550653aea91a0e0a71511
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Tue Nov 25 18:47:22 2014 +0000

    irqchip: gic-v2m: Add support for ARM GICv2m MSI(-X) doorbell
    
    ARM GICv2m specification extends GICv2 to support MSI(-X) with
    a new register frame. This allows a GICv2 based system to support
    MSI with minimal changes.
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    [maz: converted the driver to use stacked irq domains,
          updated changelog]
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1416941243-7181-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 13eed92c7d24..60b09ed58cae 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -106,6 +106,8 @@ static inline void gic_init(unsigned int nr, int start,
 	gic_init_bases(nr, start, dist, cpu, 0, NULL);
 }
 
+int gicv2m_of_init(struct device_node *node, struct irq_domain *parent);
+
 void gic_send_sgi(unsigned int cpu_id, unsigned int irq);
 int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);

commit 3228950621d92f0f212378f95a6998ef3a1be0bb
Author: Feng Kan <fkan@apm.com>
Date:   Wed Jul 30 14:56:59 2014 -0700

    irqchip: gic: Preserve gic V2 bypass bits in cpu ctrl register
    
    This change is made to preserve the GIC v2 bypass bits in the
    GIC_CPU_CTRL register (also known as the GICC_CTLR register in spec).
    This code will preserve all bits configured by the bootloader regarding
    v2 bypass group bits. In the X-Gene platform, the bypass functionality
    is not used and bypass bits should not be changed by the kernel gic
    code as it could lead to incorrect behavior.
    
    Signed-off-by: Feng Kan <fkan@apm.com>
    Reviewed-by: Vinayak Kale <vkale@apm.com>
    Reviewed-by: Anup Patel <apatel@apm.com>
    Link: https://lkml.kernel.org/r/1406757419-18729-3-git-send-email-fkan@apm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 5cb9d41af5be..13eed92c7d24 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -25,6 +25,7 @@
 #define GICC_INT_PRI_THRESHOLD		0xf0
 #define GICC_IAR_INT_ID_MASK		0x3ff
 #define GICC_INT_SPURIOUS		1023
+#define GICC_DIS_BYPASS_MASK		0x1e0
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004

commit e5f81539f657af7e9f54ea37986fde8f92acef22
Author: Feng Kan <fkan@apm.com>
Date:   Wed Jul 30 14:56:58 2014 -0700

    irqchip: gic: Replace hex numbers with defines.
    
    This is to cleanup some hex numbers used in the code and replace
    them with defines to make the code cleaner.
    
    Signed-off-by: Feng Kan <fkan@apm.com>
    Reviewed-by: Anup Patel <apatel@apm.com>
    Link: https://lkml.kernel.org/r/1406757419-18729-2-git-send-email-fkan@apm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 45e2d8c15bd2..5cb9d41af5be 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -21,7 +21,10 @@
 #define GIC_CPU_ACTIVEPRIO		0xd0
 #define GIC_CPU_IDENT			0xfc
 
+#define GICC_ENABLE			0x1
+#define GICC_INT_PRI_THRESHOLD		0xf0
 #define GICC_IAR_INT_ID_MASK		0x3ff
+#define GICC_INT_SPURIOUS		1023
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
@@ -39,6 +42,18 @@
 #define GIC_DIST_SGI_PENDING_CLEAR	0xf10
 #define GIC_DIST_SGI_PENDING_SET	0xf20
 
+#define GICD_ENABLE			0x1
+#define GICD_DISABLE			0x0
+#define GICD_INT_ACTLOW_LVLTRIG		0x0
+#define GICD_INT_EN_CLR_X32		0xffffffff
+#define GICD_INT_EN_SET_SGI		0x0000ffff
+#define GICD_INT_EN_CLR_PPI		0xffff0000
+#define GICD_INT_DEF_PRI		0xa0
+#define GICD_INT_DEF_PRI_X4		((GICD_INT_DEF_PRI << 24) |\
+					(GICD_INT_DEF_PRI << 16) |\
+					(GICD_INT_DEF_PRI << 8) |\
+					GICD_INT_DEF_PRI)
+
 #define GICH_HCR			0x0
 #define GICH_VTR			0x4
 #define GICH_VMCR			0x8

commit b8802f76fe473d91886220498aeda157c492f2d1
Author: Haojian Zhuang <haojian.zhuang@linaro.org>
Date:   Sun May 11 16:05:58 2014 +0800

    irqchip: gic: Use mask field in GICC_IAR
    
    Bit[9:0] is interrupt ID field in GICC_IAR. Bit[12:10] is CPU ID field,
    and others are reserved.
    
    So we should use GICC_IAR_INT_ID_MASK to get interrupt ID. It's not a good way
    to use ~0x1c00 (CPU ID field) to get interrupt ID.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Link: https://lkml.kernel.org/r/1399795571-17231-3-git-send-email-haojian.zhuang@linaro.org
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 7ed92d0560d5..45e2d8c15bd2 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -21,6 +21,8 @@
 #define GIC_CPU_ACTIVEPRIO		0xd0
 #define GIC_CPU_IDENT			0xfc
 
+#define GICC_IAR_INT_ID_MASK		0x3ff
+
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
 #define GIC_DIST_IGROUP			0x080

commit 006e983bbc805431c44e2135e13841f66059a045
Author: Sricharan R <r.sricharan@ti.com>
Date:   Tue Dec 3 15:57:22 2013 +0530

    DRIVERS: IRQCHIP: IRQ-GIC: Add support for routable irqs
    
    In some socs the gic can be preceded by a crossbar IP which
    routes the peripheral interrupts to the gic inputs. The peripheral
    interrupts are associated with a fixed crossbar input line and the
    crossbar routes that to one of the free gic input line.
    
    The DT entries for peripherals provides the fixed crossbar input line
    as its interrupt number and the mapping code should associate this with
    a free gic input line. This patch adds the support inside the gic irqchip
    to handle such routable irqs. The routable irqs are registered in a linear
    domain. The registered routable domain's callback should be implemented
    to get a free irq and to configure the IP to route it.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 0ceb389dba6c..7ed92d0560d5 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -93,6 +93,11 @@ int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);
 unsigned long gic_get_sgir_physaddr(void);
 
+extern const struct irq_domain_ops *gic_routable_irq_domain_ops;
+static inline void __init register_routable_domain_ops
+					(const struct irq_domain_ops *ops)
+{
+	gic_routable_irq_domain_ops = ops;
+}
 #endif /* __ASSEMBLY */
-
 #endif

commit 0307e1770fdeff2732cf7a35d0f7f49db67c6621
Author: Christoffer Dall <christoffer.dall@linaro.org>
Date:   Mon Sep 23 14:55:56 2013 -0700

    irqchip: arm-gic: Define additional MMIO offsets and masks
    
    Define CPU interface offsets for the GICC_ABPR, GICC_APR, and GICC_IIDR
    registers.  Define distributor registers for the GICD_SPENDSGIR and the
    GICD_CPENDSGIR.  KVM/ARM needs to know about these definitions to fully
    support save/restore of the VGIC.
    
    Also define some masks and shifts for the various GICH_VMCR fields.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Christoffer Dall <christoffer.dall@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index cac496b1e279..0ceb389dba6c 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -17,6 +17,9 @@
 #define GIC_CPU_EOI			0x10
 #define GIC_CPU_RUNNINGPRI		0x14
 #define GIC_CPU_HIGHPRI			0x18
+#define GIC_CPU_ALIAS_BINPOINT		0x1c
+#define GIC_CPU_ACTIVEPRIO		0xd0
+#define GIC_CPU_IDENT			0xfc
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
@@ -56,6 +59,15 @@
 #define GICH_LR_ACTIVE_BIT		(1 << 29)
 #define GICH_LR_EOI			(1 << 19)
 
+#define GICH_VMCR_CTRL_SHIFT		0
+#define GICH_VMCR_CTRL_MASK		(0x21f << GICH_VMCR_CTRL_SHIFT)
+#define GICH_VMCR_PRIMASK_SHIFT		27
+#define GICH_VMCR_PRIMASK_MASK		(0x1f << GICH_VMCR_PRIMASK_SHIFT)
+#define GICH_VMCR_BINPOINT_SHIFT	21
+#define GICH_VMCR_BINPOINT_MASK		(0x7 << GICH_VMCR_BINPOINT_SHIFT)
+#define GICH_VMCR_ALIAS_BINPOINT_SHIFT	18
+#define GICH_VMCR_ALIAS_BINPOINT_MASK	(0x7 << GICH_VMCR_ALIAS_BINPOINT_SHIFT)
+
 #define GICH_MISR_EOI			(1 << 0)
 #define GICH_MISR_U			(1 << 1)
 

commit 14d2ca615a85e2dbc744c12c296affd35f119fa7
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Nov 28 18:48:19 2012 -0500

    ARM: GIC: interface to send a SGI directly
    
    The regular gic_raise_softirq() takes as input a CPU mask which is not
    adequate when we need to send an IPI to a CPU which is not represented
    in the kernel to GIC mapping.  That is the case with the b.L switcher
    when GIC migration to the inbound CPU has not yet occurred.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index dc30835099e3..cac496b1e279 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -76,6 +76,7 @@ static inline void gic_init(unsigned int nr, int start,
 	gic_init_bases(nr, start, dist, cpu, 0, NULL);
 }
 
+void gic_send_sgi(unsigned int cpu_id, unsigned int irq);
 int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);
 unsigned long gic_get_sgir_physaddr(void);

commit eeb446581ba23a5a36b4f5c7bfa2b1f8f7c9fb66
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Nov 28 18:17:25 2012 -0500

    ARM: GIC: function to retrieve the physical address of the SGIR
    
    In order to have early assembly code signal other CPUs in the system,
    we need to get the physical address for the SGIR register used to
    send IPIs.  Because the register will be used with a precomputed CPU
    interface ID number, there is no need for any locking in the assembly
    code where this register is written to.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 46544e381bf9..dc30835099e3 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -78,6 +78,7 @@ static inline void gic_init(unsigned int nr, int start,
 
 int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);
+unsigned long gic_get_sgir_physaddr(void);
 
 #endif /* __ASSEMBLY */
 

commit 7f63037c8fb204f666367c6469f5a9b9d6888877
Merge: 272b98c6455f b22537c68267
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Sep 17 15:13:38 2013 +0100

    Merge branch 'iks_for_rmk' of git://git.linaro.org/people/nico/linux into devel-stable
    
    Nicolas Pitre writes:
    
    This is the first part of the patch series adding IKS (In-Kernel
    Switcher) support for big.LITTLE system architectures.  This consists of
    the core patches only.  Extra patches to come later will introduce
    various optimizations and tracing support.
    
    Those patches were posted on the list a while ago here:
    
       http://news.gmane.org/group/gmane.linux.ports.arm.kernel/thread=253942

commit 10d9eb8a17cfb697967928bde06f3e7e530b03ac
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Mar 19 23:59:04 2013 -0400

    drivers: irq-chip: irq-gic: introduce gic_cpu_if_down()
    
    When processors are about to hit low power states, the assertion of
    standbywfi signal, triggered by the wfi instruction, is essential to
    entering low power modes. If an IRQ is pending on the processor at the
    time wfi is issued, the wfi instruction completes and the processor
    restarts execution without asserting the standbywfi signal. Depending
    on the platform power controller HW this behaviour can be acceptable or
    not; if this behaviour must be prevented software should be provided
    with a way to disable the routing of interrupts to the core IRQ pins.
    
    On systems where raw GIC distributor interrupts are connected to the power
    controller as wake-up events (hence the power controller still senses
    IRQs and can wake up cores upon IRQ pending), the GIC CPU interface can
    be disabled on power down, so that the GIC CPU IF output is gated and wfi
    cannot complete, thereby preventing the standbywfi issue.
    
    This patch adds a simple function to the GIC driver that allows to
    disable the GIC CPU IF from power down procedures.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [rewrote commit log]
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 3e203eb23cc7..0e5d9ecdb2b6 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -66,6 +66,7 @@ extern struct irq_chip gic_arch_extn;
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
+void gic_cpu_if_down(void);
 
 static inline void gic_init(unsigned int nr, int start,
 			    void __iomem *dist , void __iomem *cpu)

commit ed96762e3241f57aa812977cf1920d3ee0363f4d
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Jul 5 21:33:26 2012 -0400

    ARM: bL_switcher: do not hardcode GIC IDs in the code
    
    Currently, GIC IDs are hardcoded making the code dependent on the 4+4 b.L
    configuration.  Let's allow for GIC IDs to be discovered upon switcher
    initialization to support other b.L configurations such as the 1+1 one,
    or 2+3 as on the VExpress TC2.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 40bfcac95940..2d7d47e8dfaf 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -75,6 +75,7 @@ static inline void gic_init(unsigned int nr, int start,
 	gic_init_bases(nr, start, dist, cpu, 0, NULL);
 }
 
+int gic_get_cpu_id(unsigned int cpu);
 void gic_migrate_target(unsigned int new_cpu_id);
 
 #endif /* __ASSEMBLY */

commit 1a6b69b6548cd0dd82549393f30dd982ceeb79d2
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Apr 12 01:40:31 2012 -0400

    ARM: gic: add CPU migration support
    
    This is required by the big.LITTLE switcher code.
    
    The gic_migrate_target() changes the CPU interface mapping for the
    current CPU to redirect SGIs to the specified interface, and it also
    updates the target CPU for each interrupts to that CPU interface
    if they were targeting the current interface.  Finally, pending
    SGIs for the current CPU are forwarded to the new interface.
    
    Because Linux does not use it, the SGI source information for the
    forwarded SGIs is not preserved.  Neither is the source information
    for the SGIs sent by the current CPU to other CPUs adjusted to match
    the new CPU interface mapping.  The required registers are banked so
    only the target CPU could do it.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 3e203eb23cc7..40bfcac95940 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -31,6 +31,8 @@
 #define GIC_DIST_TARGET			0x800
 #define GIC_DIST_CONFIG			0xc00
 #define GIC_DIST_SOFTINT		0xf00
+#define GIC_DIST_SGI_PENDING_CLEAR	0xf10
+#define GIC_DIST_SGI_PENDING_SET	0xf20
 
 #define GICH_HCR			0x0
 #define GICH_VTR			0x4
@@ -73,6 +75,8 @@ static inline void gic_init(unsigned int nr, int start,
 	gic_init_bases(nr, start, dist, cpu, 0, NULL);
 }
 
+void gic_migrate_target(unsigned int new_cpu_id);
+
 #endif /* __ASSEMBLY */
 
 #endif

commit c0114709ed85a5693eb74acdfa03d94f7f12e5b8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jan 14 18:05:37 2013 +0000

    irqchip: gic: Perform the gic_secondary_init() call via CPU notifier
    
    All the calls to gic_secondary_init() pass 0 as the first argument.
    Since this function is called on each CPU when starting, it can be done
    in a platform-independent way via a CPU notifier registered by the GIC
    code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Tested-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Tested-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Barry Song <baohua.song@csr.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 3fd8e4290a1c..3e203eb23cc7 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -65,7 +65,6 @@ extern struct irq_chip gic_arch_extn;
 
 void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
 		    u32 offset, struct device_node *);
-void gic_secondary_init(unsigned int);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
 
 static inline void gic_init(unsigned int nr, int start,

commit a96ab03917dcf4c9477d03b31e8d74779bca1074
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Jan 24 13:39:43 2013 +0000

    ARM: gic: add __ASSEMBLY__ guard to C definitions
    
    The GIC include file being used by some of the KVM assembly code,
    wrap the C definitions with a #ifdef __ASSEMBLY__ guard.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index ef61d80946be..3fd8e4290a1c 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -57,6 +57,8 @@
 #define GICH_MISR_EOI			(1 << 0)
 #define GICH_MISR_U			(1 << 1)
 
+#ifndef __ASSEMBLY__
+
 struct device_node;
 
 extern struct irq_chip gic_arch_extn;
@@ -72,4 +74,6 @@ static inline void gic_init(unsigned int nr, int start,
 	gic_init_bases(nr, start, dist, cpu, 0, NULL);
 }
 
+#endif /* __ASSEMBLY */
+
 #endif

commit fdf77a72ec110572ac033d499c8be8b389c05740
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Jan 21 19:36:11 2013 -0500

    ARM: gic: define GICH offsets for VGIC support
    
    The GICH_* constants are defined by the GIC HW spec, and even though
    they only be used by KVM to begin with, define them generically in gic.h.
    
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Christoffer Dall <c.dall@virtualopensystems.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 9509e8785cad..ef61d80946be 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -32,6 +32,31 @@
 #define GIC_DIST_CONFIG			0xc00
 #define GIC_DIST_SOFTINT		0xf00
 
+#define GICH_HCR			0x0
+#define GICH_VTR			0x4
+#define GICH_VMCR			0x8
+#define GICH_MISR			0x10
+#define GICH_EISR0 			0x20
+#define GICH_EISR1 			0x24
+#define GICH_ELRSR0 			0x30
+#define GICH_ELRSR1 			0x34
+#define GICH_APR			0xf0
+#define GICH_LR0			0x100
+
+#define GICH_HCR_EN			(1 << 0)
+#define GICH_HCR_UIE			(1 << 1)
+
+#define GICH_LR_VIRTUALID		(0x3ff << 0)
+#define GICH_LR_PHYSID_CPUID_SHIFT	(10)
+#define GICH_LR_PHYSID_CPUID		(7 << GICH_LR_PHYSID_CPUID_SHIFT)
+#define GICH_LR_STATE			(3 << 28)
+#define GICH_LR_PENDING_BIT		(1 << 28)
+#define GICH_LR_ACTIVE_BIT		(1 << 29)
+#define GICH_LR_EOI			(1 << 19)
+
+#define GICH_MISR_EOI			(1 << 0)
+#define GICH_MISR_U			(1 << 1)
+
 struct device_node;
 
 extern struct irq_chip gic_arch_extn;

commit 7c7945a8f971e0b9cbdd7684ee106de768a0e474
Author: Christoffer Dall <c.dall@virtualopensystems.com>
Date:   Wed Jan 23 13:18:03 2013 -0500

    ARM: gic: add missing distributor defintions
    
    Add missing register map offsets for the distributor and rename
    GIC_DIST_ACTIVE_BIT to GIC_DIST_ACTIVE_SET to be consistent.
    
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Christoffer Dall <c.dall@virtualopensystems.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index a67ca55e6f4e..9509e8785cad 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -20,11 +20,13 @@
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
+#define GIC_DIST_IGROUP			0x080
 #define GIC_DIST_ENABLE_SET		0x100
 #define GIC_DIST_ENABLE_CLEAR		0x180
 #define GIC_DIST_PENDING_SET		0x200
 #define GIC_DIST_PENDING_CLEAR		0x280
-#define GIC_DIST_ACTIVE_BIT		0x300
+#define GIC_DIST_ACTIVE_SET		0x300
+#define GIC_DIST_ACTIVE_CLEAR		0x380
 #define GIC_DIST_PRI			0x400
 #define GIC_DIST_TARGET			0x800
 #define GIC_DIST_CONFIG			0xc00

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
new file mode 100644
index 000000000000..a67ca55e6f4e
--- /dev/null
+++ b/include/linux/irqchip/arm-gic.h
@@ -0,0 +1,48 @@
+/*
+ *  include/linux/irqchip/arm-gic.h
+ *
+ *  Copyright (C) 2002 ARM Limited, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __LINUX_IRQCHIP_ARM_GIC_H
+#define __LINUX_IRQCHIP_ARM_GIC_H
+
+#define GIC_CPU_CTRL			0x00
+#define GIC_CPU_PRIMASK			0x04
+#define GIC_CPU_BINPOINT		0x08
+#define GIC_CPU_INTACK			0x0c
+#define GIC_CPU_EOI			0x10
+#define GIC_CPU_RUNNINGPRI		0x14
+#define GIC_CPU_HIGHPRI			0x18
+
+#define GIC_DIST_CTRL			0x000
+#define GIC_DIST_CTR			0x004
+#define GIC_DIST_ENABLE_SET		0x100
+#define GIC_DIST_ENABLE_CLEAR		0x180
+#define GIC_DIST_PENDING_SET		0x200
+#define GIC_DIST_PENDING_CLEAR		0x280
+#define GIC_DIST_ACTIVE_BIT		0x300
+#define GIC_DIST_PRI			0x400
+#define GIC_DIST_TARGET			0x800
+#define GIC_DIST_CONFIG			0xc00
+#define GIC_DIST_SOFTINT		0xf00
+
+struct device_node;
+
+extern struct irq_chip gic_arch_extn;
+
+void gic_init_bases(unsigned int, int, void __iomem *, void __iomem *,
+		    u32 offset, struct device_node *);
+void gic_secondary_init(unsigned int);
+void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
+
+static inline void gic_init(unsigned int nr, int start,
+			    void __iomem *dist , void __iomem *cpu)
+{
+	gic_init_bases(nr, start, dist, cpu, 0, NULL);
+}
+
+#endif
