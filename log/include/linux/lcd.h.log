commit e7642f35851da14b78be7a38b0bb0d4068254859
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jul 25 16:32:24 2019 +0200

    backlight: drop EARLY_EVENT_BLANK support
    
    There was no users left - so drop the code to support EARLY_EVENT_BLANK.
    This patch removes the support in backlight,
    and drop the notifier in fbmem.
    
    That EARLY_EVENT_BLANK is not used can be verified that no driver set any of:
    
        lcd_ops.early_set_power()
        lcd_ops.r_early_set_power()
    
    Noticed while browsing backlight code for other reasons.
    
    v2:
    - Fix changelog to say "EARLY_EVENT_BLANK" (Daniel)
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Jingoo Han <jingoohan1@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: "Michał Mirosław" <mirq-linux@rere.qmqm.pl>
    Cc: Peter Rosin <peda@axentia.se>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-fbdev@vger.kernel.org
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190725143224.GB31803@ravnborg.org

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 851eee8fff25..238fb1dfed98 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -41,16 +41,6 @@ struct lcd_ops {
 	/* Get the LCD panel power status (0: full on, 1..3: controller
 	   power on, flat panel power off, 4: full off), see FB_BLANK_XXX */
 	int (*get_power)(struct lcd_device *);
-	/*
-	 * Enable or disable power to the LCD(0: on; 4: off, see FB_BLANK_XXX)
-	 * and this callback would be called proir to fb driver's callback.
-	 *
-	 * P.S. note that if early_set_power is not NULL then early fb notifier
-	 *	would be registered.
-	 */
-	int (*early_set_power)(struct lcd_device *, int power);
-	/* revert the effects of the early blank event. */
-	int (*r_early_set_power)(struct lcd_device *, int power);
 	/* Enable or disable power to the LCD (0: on; 4: off, see FB_BLANK_XXX) */
 	int (*set_power)(struct lcd_device *, int power);
 	/* Get the current contrast setting (0-max_contrast) */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 504f6246f38f..851eee8fff25 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * LCD Lowlevel Control Abstraction
  *

commit 1d0c48e66b3f1cf40660f69a87f55af3df0b2ae3
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Jul 3 15:05:14 2013 -0700

    lcd: add devm_lcd_device_{register,unregister}()
    
    These functions allow the driver core to automatically clean up any
    allocation made by lcd drivers.  Thus it simplifies the error paths.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index e00c3b0ebc6b..504f6246f38f 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -112,7 +112,12 @@ static inline void lcd_set_power(struct lcd_device *ld, int power)
 
 extern struct lcd_device *lcd_device_register(const char *name,
 	struct device *parent, void *devdata, struct lcd_ops *ops);
+extern struct lcd_device *devm_lcd_device_register(struct device *dev,
+	const char *name, struct device *parent,
+	void *devdata, struct lcd_ops *ops);
 extern void lcd_device_unregister(struct lcd_device *ld);
+extern void devm_lcd_device_unregister(struct device *dev,
+	struct lcd_device *ld);
 
 #define to_lcd_device(obj) container_of(obj, struct lcd_device, dev)
 

commit d54ad83f3d56228a42e1021b97fc52bfbad7d560
Author: Inki Dae <inki.dae@samsung.com>
Date:   Tue May 29 15:07:13 2012 -0700

    lcd: add callbacks for early fb event blank support
    
    This patchset adds early fb blank feature that a callback of lcd panel
    driver is called prior to specific fb driver's one.  In the case of
    MIPI-DSI based video mode LCD Panel, for lcd power off, the power off
    commands should be transferred to lcd panel with display and mipi-dsi
    controller enabled because the commands is set to lcd panel at vsync porch
    period.  and in opposite case, the callback of fb driver should be called
    prior to lcd panel driver's one because of same issue.  Also if fb_blank
    mode is changed to FB_BLANK_POWERDOWN then display controller would be
    off(clock disable) but lcd panel would be still on.  at this time, you
    could see some issue like sparkling on lcd panel because video clock to be
    delivered to ldi module of lcd panel was disabled.  this issue could
    occurs for all lcd panels.
    
    The callback order is as the following:
    
    at fb_blank function of fbmem.c
    -> fb_notifier_call_chain(FB_EARLY_EVENT_BLANK)
           -> lcd panel driver's early_set_power()
    -> info->fbops->fb_blank()
           -> spcefic fb driver's fb_blank()
    -> fb_notifier_call_chain(FB_EVENT_BLANK)
           -> lcd panel driver's set_power()
       -> fb_notifier_call_chain(FB_R_EARLY_EVENT_BLANK) if
    info->fops->fb_blank() was failed.
    
    fb_notifier_call_chain(FB_R_EARLY_EVENT_BLANK) would be called to revert
    the effects of previous FB_EARLY_EVENT_BLANK call.  and note that if
    early_set_power() of lcd_ops is NULL then early fb blank callback would be
    ignored.
    
    This patch:
    
    Add early_set_power and r_early_set_power callbacks.  early_set_power
    callback is called prior to fb_blank() of fbmem.c and r_early_set_power
    callback is called if fb_blank() was failed to revert the effects of the
    early_set_power call of lcd panel driver.
    
    Signed-off-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 8877123f2d6e..e00c3b0ebc6b 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -40,6 +40,16 @@ struct lcd_ops {
 	/* Get the LCD panel power status (0: full on, 1..3: controller
 	   power on, flat panel power off, 4: full off), see FB_BLANK_XXX */
 	int (*get_power)(struct lcd_device *);
+	/*
+	 * Enable or disable power to the LCD(0: on; 4: off, see FB_BLANK_XXX)
+	 * and this callback would be called proir to fb driver's callback.
+	 *
+	 * P.S. note that if early_set_power is not NULL then early fb notifier
+	 *	would be registered.
+	 */
+	int (*early_set_power)(struct lcd_device *, int power);
+	/* revert the effects of the early blank event. */
+	int (*r_early_set_power)(struct lcd_device *, int power);
 	/* Enable or disable power to the LCD (0: on; 4: off, see FB_BLANK_XXX) */
 	int (*set_power)(struct lcd_device *, int power);
 	/* Get the current contrast setting (0-max_contrast) */

commit ee378a5c6550dcbfe6fa9c71b84ca2eb19cb288e
Author: InKi Dae <inki.dae@samsung.com>
Date:   Mon May 24 12:21:36 2010 -0700

    backlight: add S6E63M0 AMOLED LCD Panel driver
    
    This is S6E63M0 AMOLED LCD Panel(480x800) driver using 3-wired SPI
    interface also almost features for lcd panel driver has been implemented
    in here.  and I added new structure common for all the lcd panel drivers
    to include/linux/lcd.h file.
    
    LCD Panel driver needs interfaces for controlling device power such as
    power on/off and reset.  these interfaces are device specific so it should
    be implemented to machine code at this time, we should create new
    structure for registering these functions as callbacks and also a header
    file for that structure and finally registered callback functions would be
    called by lcd panel driver.  such header file(including new structure for
    lcd panel) would be added for all the lcd panel drivers.
    
    If anyone provides common structure for registering such callback
    functions then we could reduce unnecessary header files for lcd panel.  I
    thought that suitable anyone could be include/linux/lcd.h so a new
    lcd_platform_data structure was added there.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [randy.dunlap@oracle.com: fix s6e63m0 kconfig]
    [randy.dunlap@oracle.com: fix device attribute functions return types]
    Signed-off-by: InKi Dae <inki.dae@samsung.com>
    Reviewed-by: KyungMin Park <kyungmin.park.samsung.com>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index c67fecafff90..8877123f2d6e 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -69,6 +69,29 @@ struct lcd_device {
 	struct device dev;
 };
 
+struct lcd_platform_data {
+	/* reset lcd panel device. */
+	int (*reset)(struct lcd_device *ld);
+	/* on or off to lcd panel. if 'enable' is 0 then
+	   lcd power off and 1, lcd power on. */
+	int (*power_on)(struct lcd_device *ld, int enable);
+
+	/* it indicates whether lcd panel was enabled
+	   from bootloader or not. */
+	int lcd_enabled;
+	/* it means delay for stable time when it becomes low to high
+	   or high to low that is dependent on whether reset gpio is
+	   low active or high active. */
+	unsigned int reset_delay;
+	/* stable time needing to become lcd power on. */
+	unsigned int power_on_delay;
+	/* stable time needing to become lcd power off. */
+	unsigned int power_off_delay;
+
+	/* it could be used for any purpose. */
+	void *pdata;
+};
+
 static inline void lcd_set_power(struct lcd_device *ld, int power)
 {
 	mutex_lock(&ld->update_lock);

commit faa312da9cd0b044bdc84483162c6ee10b9c83c0
Author: Eric Miao <eric.miao@marvell.com>
Date:   Fri Aug 29 04:18:43 2008 +0800

    lcd: allow lcd device to handle mode change events
    
    Some LCD panels are capable of different resolutions, and is allowed
    to change at run-time, so to make "struct lcd_device" to be able to
    handle mode change events here.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Acked-by: Krzysztof Helt <krzysztof.h1@wp.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 173febac6656..c67fecafff90 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -11,6 +11,7 @@
 #include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/notifier.h>
+#include <linux/fb.h>
 
 /* Notes on locking:
  *
@@ -45,6 +46,8 @@ struct lcd_ops {
 	int (*get_contrast)(struct lcd_device *);
 	/* Set LCD panel contrast */
         int (*set_contrast)(struct lcd_device *, int contrast);
+	/* Set LCD panel mode (resolutions ...) */
+	int (*set_mode)(struct lcd_device *, struct fb_videomode *);
 	/* Check if given framebuffer device is the one LCD is bound to;
 	   return 0 if not, !=0 if it is. If NULL, lcd always matches the fb. */
 	int (*check_fb)(struct lcd_device *, struct fb_info *);

commit 0c531360ed504aa0ce995fcb8ef08e82b6534d0b
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Jul 23 21:31:38 2008 -0700

    lcd: add lcd_device to check_fb() entry in lcd_ops
    
    Add the lcd_device being checked to the check_fb entry of lcd_ops.  This
    ensures that any driver using this to check against it's own state can do
    so, and also makes all the calls in lcd_ops more orthogonal in their
    arguments.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 1d379787f2e7..173febac6656 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -47,7 +47,7 @@ struct lcd_ops {
         int (*set_contrast)(struct lcd_device *, int contrast);
 	/* Check if given framebuffer device is the one LCD is bound to;
 	   return 0 if not, !=0 if it is. If NULL, lcd always matches the fb. */
-	int (*check_fb)(struct fb_info *);
+	int (*check_fb)(struct lcd_device *, struct fb_info *);
 };
 
 struct lcd_device {

commit 655bfd7aebb12481ab9275284d9500bee5ba3e70
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Mon Jul 9 12:17:24 2007 +0100

    backlight: Convert from struct class_device to struct device
    
    Convert the backlight and LCD classes from struct class_device
    to struct device since class_device is scheduled for removal.
    
    One nasty API break is the backlight power attribute has had to be
    renamed to bl_power and the LCD power attribute has had to be renamed
    to lcd_power since the original names clash with the core. I can't see
    a way around this.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 598793c0745b..1d379787f2e7 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -62,8 +62,8 @@ struct lcd_device {
 	struct mutex update_lock;
 	/* The framebuffer notifier block */
 	struct notifier_block fb_notif;
-	/* The class device structure */
-	struct class_device class_dev;
+
+	struct device dev;
 };
 
 static inline void lcd_set_power(struct lcd_device *ld, int power)
@@ -75,9 +75,15 @@ static inline void lcd_set_power(struct lcd_device *ld, int power)
 }
 
 extern struct lcd_device *lcd_device_register(const char *name,
-	void *devdata, struct lcd_ops *ops);
+	struct device *parent, void *devdata, struct lcd_ops *ops);
 extern void lcd_device_unregister(struct lcd_device *ld);
 
-#define to_lcd_device(obj) container_of(obj, struct lcd_device, class_dev)
+#define to_lcd_device(obj) container_of(obj, struct lcd_device, dev)
+
+static inline void * lcd_get_data(struct lcd_device *ld_dev)
+{
+	return dev_get_drvdata(&ld_dev->dev);
+}
+
 
 #endif

commit 599a52d12629394236d785615808845823875868
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Sat Feb 10 23:07:48 2007 +0000

    backlight: Separate backlight properties from backlight ops pointers
    
    Per device data such as brightness belongs to the indivdual device
    and should therefore be separate from the the backlight operation
    function pointers. This patch splits the two types of data and
    allows simplifcation of some code.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 46970af2ca89..598793c0745b 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -14,7 +14,7 @@
 
 /* Notes on locking:
  *
- * lcd_device->props_lock is an internal backlight lock protecting the props
+ * lcd_device->ops_lock is an internal backlight lock protecting the ops
  * field and no code outside the core should need to touch it.
  *
  * Access to set_power() is serialised by the update_lock mutex since
@@ -30,15 +30,17 @@
 struct lcd_device;
 struct fb_info;
 
-/* This structure defines all the properties of a LCD flat panel. */
 struct lcd_properties {
+	/* The maximum value for contrast (read-only) */
+	int max_contrast;
+};
+
+struct lcd_ops {
 	/* Get the LCD panel power status (0: full on, 1..3: controller
 	   power on, flat panel power off, 4: full off), see FB_BLANK_XXX */
 	int (*get_power)(struct lcd_device *);
 	/* Enable or disable power to the LCD (0: on; 4: off, see FB_BLANK_XXX) */
 	int (*set_power)(struct lcd_device *, int power);
-	/* The maximum value for contrast (read-only) */
-	int max_contrast;
 	/* Get the current contrast setting (0-max_contrast) */
 	int (*get_contrast)(struct lcd_device *);
 	/* Set LCD panel contrast */
@@ -49,12 +51,13 @@ struct lcd_properties {
 };
 
 struct lcd_device {
-	/* This protects the 'props' field. If 'props' is NULL, the driver that
+	struct lcd_properties props;
+	/* This protects the 'ops' field. If 'ops' is NULL, the driver that
 	   registered this device has been unloaded, and if class_get_devdata()
 	   points to something in the body of that driver, it is also invalid. */
-	struct mutex props_lock;
+	struct mutex ops_lock;
 	/* If this is NULL, the backing module is unloaded */
-	struct lcd_properties *props;
+	struct lcd_ops *ops;
 	/* Serialise access to set_power method */
 	struct mutex update_lock;
 	/* The framebuffer notifier block */
@@ -66,13 +69,13 @@ struct lcd_device {
 static inline void lcd_set_power(struct lcd_device *ld, int power)
 {
 	mutex_lock(&ld->update_lock);
-	if (ld->props && ld->props->set_power)
-		ld->props->set_power(ld, power);
+	if (ld->ops && ld->ops->set_power)
+		ld->ops->set_power(ld, power);
 	mutex_unlock(&ld->update_lock);
 }
 
 extern struct lcd_device *lcd_device_register(const char *name,
-	void *devdata, struct lcd_properties *lp);
+	void *devdata, struct lcd_ops *ops);
 extern void lcd_device_unregister(struct lcd_device *ld);
 
 #define to_lcd_device(obj) container_of(obj, struct lcd_device, class_dev)

commit 249040dc7fd391186f420fe23a9b59d357103cac
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Thu Feb 8 22:53:55 2007 +0000

    backlight: Convert semaphore -> mutex
    
    Convert internal semaphore to a mutex
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index bfbf6552eb51..46970af2ca89 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -14,7 +14,7 @@
 
 /* Notes on locking:
  *
- * lcd_device->sem is an internal backlight lock protecting the props
+ * lcd_device->props_lock is an internal backlight lock protecting the props
  * field and no code outside the core should need to touch it.
  *
  * Access to set_power() is serialised by the update_lock mutex since
@@ -52,7 +52,7 @@ struct lcd_device {
 	/* This protects the 'props' field. If 'props' is NULL, the driver that
 	   registered this device has been unloaded, and if class_get_devdata()
 	   points to something in the body of that driver, it is also invalid. */
-	struct semaphore sem;
+	struct mutex props_lock;
 	/* If this is NULL, the backing module is unloaded */
 	struct lcd_properties *props;
 	/* Serialise access to set_power method */

commit 28ee086d5b36aab2931f6740e409bb0fb6c65e5f
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Thu Feb 8 22:25:09 2007 +0000

    backlight: Fix external uses of backlight internal semaphore
    
    backlight_device->sem has a very specific use as documented in the
    header file. The external users of this are using it for a different
    reason, to serialise access to the update_status() method.
    
    backlight users were supposed to implement their own internal
    serialisation of update_status() if needed but everyone is doing
    things differently and incorrectly. Therefore add a global mutex to
    take care of serialisation for everyone, once and for all.
    
    Locking for get_brightness remains optional since most users don't
    need it.
    
    Also update the lcd class in a similar way.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index 8a468f168c45..bfbf6552eb51 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -9,8 +9,24 @@
 #define _LINUX_LCD_H
 
 #include <linux/device.h>
+#include <linux/mutex.h>
 #include <linux/notifier.h>
 
+/* Notes on locking:
+ *
+ * lcd_device->sem is an internal backlight lock protecting the props
+ * field and no code outside the core should need to touch it.
+ *
+ * Access to set_power() is serialised by the update_lock mutex since
+ * most drivers seem to need this and historically get it wrong.
+ *
+ * Most drivers don't need locking on their get_power() method.
+ * If yours does, you need to implement it in the driver. You can use the
+ * update_lock mutex if appropriate.
+ *
+ * Any other use of the locks below is probably wrong.
+ */
+
 struct lcd_device;
 struct fb_info;
 
@@ -39,12 +55,22 @@ struct lcd_device {
 	struct semaphore sem;
 	/* If this is NULL, the backing module is unloaded */
 	struct lcd_properties *props;
+	/* Serialise access to set_power method */
+	struct mutex update_lock;
 	/* The framebuffer notifier block */
 	struct notifier_block fb_notif;
 	/* The class device structure */
 	struct class_device class_dev;
 };
 
+static inline void lcd_set_power(struct lcd_device *ld, int power)
+{
+	mutex_lock(&ld->update_lock);
+	if (ld->props && ld->props->set_power)
+		ld->props->set_power(ld, power);
+	mutex_unlock(&ld->update_lock);
+}
+
 extern struct lcd_device *lcd_device_register(const char *name,
 	void *devdata, struct lcd_properties *lp);
 extern void lcd_device_unregister(struct lcd_device *ld);

commit dfcba200679dc3f62212154b65b40b835ce69ab7
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Thu Feb 8 00:06:32 2007 +0000

    backlight: Remove unneeded owner field
    
    Remove uneeded owner field from backlight_properties structure.
    
    Nothing uses it and it is unlikely that it will ever be used. The
    backlight class uses other means to ensure that nothing references
    unloaded code.
    
    Based on a patch from Dmitry Torokhov <dtor@insightbb.com>
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
index d739b2e7eac2..8a468f168c45 100644
--- a/include/linux/lcd.h
+++ b/include/linux/lcd.h
@@ -16,8 +16,6 @@ struct fb_info;
 
 /* This structure defines all the properties of a LCD flat panel. */
 struct lcd_properties {
-	/* Owner module */
-	struct module *owner;
 	/* Get the LCD panel power status (0: full on, 1..3: controller
 	   power on, flat panel power off, 4: full off), see FB_BLANK_XXX */
 	int (*get_power)(struct lcd_device *);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/lcd.h b/include/linux/lcd.h
new file mode 100644
index 000000000000..d739b2e7eac2
--- /dev/null
+++ b/include/linux/lcd.h
@@ -0,0 +1,56 @@
+/*
+ * LCD Lowlevel Control Abstraction
+ *
+ * Copyright (C) 2003,2004 Hewlett-Packard Company
+ *
+ */
+
+#ifndef _LINUX_LCD_H
+#define _LINUX_LCD_H
+
+#include <linux/device.h>
+#include <linux/notifier.h>
+
+struct lcd_device;
+struct fb_info;
+
+/* This structure defines all the properties of a LCD flat panel. */
+struct lcd_properties {
+	/* Owner module */
+	struct module *owner;
+	/* Get the LCD panel power status (0: full on, 1..3: controller
+	   power on, flat panel power off, 4: full off), see FB_BLANK_XXX */
+	int (*get_power)(struct lcd_device *);
+	/* Enable or disable power to the LCD (0: on; 4: off, see FB_BLANK_XXX) */
+	int (*set_power)(struct lcd_device *, int power);
+	/* The maximum value for contrast (read-only) */
+	int max_contrast;
+	/* Get the current contrast setting (0-max_contrast) */
+	int (*get_contrast)(struct lcd_device *);
+	/* Set LCD panel contrast */
+        int (*set_contrast)(struct lcd_device *, int contrast);
+	/* Check if given framebuffer device is the one LCD is bound to;
+	   return 0 if not, !=0 if it is. If NULL, lcd always matches the fb. */
+	int (*check_fb)(struct fb_info *);
+};
+
+struct lcd_device {
+	/* This protects the 'props' field. If 'props' is NULL, the driver that
+	   registered this device has been unloaded, and if class_get_devdata()
+	   points to something in the body of that driver, it is also invalid. */
+	struct semaphore sem;
+	/* If this is NULL, the backing module is unloaded */
+	struct lcd_properties *props;
+	/* The framebuffer notifier block */
+	struct notifier_block fb_notif;
+	/* The class device structure */
+	struct class_device class_dev;
+};
+
+extern struct lcd_device *lcd_device_register(const char *name,
+	void *devdata, struct lcd_properties *lp);
+extern void lcd_device_unregister(struct lcd_device *ld);
+
+#define to_lcd_device(obj) container_of(obj, struct lcd_device, class_dev)
+
+#endif
