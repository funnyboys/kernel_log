commit 3e04cb60e872b9433e523d62c39addf0bd1a18f1
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Apr 13 10:24:43 2020 +0200

    iio: adis: Support different burst sizes
    
    Add burst_max_len to `adis_burst`. This is useful for devices which
    support different burst modes with different sizes. The buffer to be
    used in the spi transfer is allocated with this variable making sure
    that has space for all burst modes. The spi transfer length should hold
    the "real" burst length depending on the current burst mode configured
    in the device.
    
    Moreover, `extra_len` in `adis_burst` is made const and it should
    contain the smallest extra length necessary for a burst transfer. In
    `struct adis` was added a new `burst_extra_len` that should hold the
    extra bytes needed depending on the device instance being used.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 247fc4c7185c..2df67448f0d1 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -83,6 +83,8 @@ struct adis_data {
  * @trig: IIO trigger object data
  * @data: ADIS chip variant specific data
  * @burst: ADIS burst transfer information
+ * @burst_extra_len: Burst extra length. Should only be used by devices that can
+ *		     dynamically change their burst mode length.
  * @state_lock: Lock used by the device to protect state
  * @msg: SPI message object
  * @xfer: SPI transfer objects to be used for a @msg
@@ -98,7 +100,7 @@ struct adis {
 
 	const struct adis_data	*data;
 	struct adis_burst	*burst;
-
+	unsigned int		burst_extra_len;
 	/**
 	 * The state_lock is meant to be used during operations that require
 	 * a sequence of SPI R/W in order to protect the SPI transfer
@@ -502,11 +504,14 @@ int adis_single_conversion(struct iio_dev *indio_dev,
  * @en			burst mode enabled
  * @reg_cmd		register command that triggers burst
  * @extra_len		extra length to account in the SPI RX buffer
+ * @burst_max_len	holds the maximum burst size when the device supports
+ *			more than one burst mode with different sizes
  */
 struct adis_burst {
 	bool		en;
 	unsigned int	reg_cmd;
-	unsigned int	extra_len;
+	const u32	extra_len;
+	const u32	burst_max_len;
 };
 
 int

commit b9c5eec725d67b548e4dfdc406d6ca2c6d30d1c2
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Apr 13 10:24:42 2020 +0200

    iio: adis: Add adis_update_bits() APIs
    
    This patch adds a `regmap_update_bits()` like API to the ADIS library.
    It provides locked and unlocked variant.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 70e4d1d262f5..247fc4c7185c 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -333,6 +333,65 @@ static inline int adis_read_reg_32(struct adis *adis, unsigned int reg,
 	return ret;
 }
 
+int __adis_update_bits_base(struct adis *adis, unsigned int reg, const u32 mask,
+			    const u32 val, u8 size);
+/**
+ * adis_update_bits_base() - ADIS Update bits function - Locked version
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @mask: Bitmask to change
+ * @val: Value to be written
+ * @size: Size of the register to update
+ *
+ * Updates the desired bits of @reg in accordance with @mask and @val.
+ */
+static inline int adis_update_bits_base(struct adis *adis, unsigned int reg,
+					const u32 mask, const u32 val, u8 size)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_update_bits_base(adis, reg, mask, val, size);
+	mutex_unlock(&adis->state_lock);
+	return ret;
+}
+
+/**
+ * adis_update_bits() - Wrapper macro for adis_update_bits_base - Locked version
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @mask: Bitmask to change
+ * @val: Value to be written
+ *
+ * This macro evaluates the sizeof of @val at compile time and calls
+ * adis_update_bits_base() accordingly. Be aware that using MACROS/DEFINES for
+ * @val can lead to undesired behavior if the register to update is 16bit.
+ */
+#define adis_update_bits(adis, reg, mask, val) ({			\
+	BUILD_BUG_ON(sizeof(val) == 1 || sizeof(val) == 8);		\
+	__builtin_choose_expr(sizeof(val) == 4,				\
+		adis_update_bits_base(adis, reg, mask, val, 4),         \
+		adis_update_bits_base(adis, reg, mask, val, 2));	\
+})
+
+/**
+ * adis_update_bits() - Wrapper macro for adis_update_bits_base
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @mask: Bitmask to change
+ * @val: Value to be written
+ *
+ * This macro evaluates the sizeof of @val at compile time and calls
+ * adis_update_bits_base() accordingly. Be aware that using MACROS/DEFINES for
+ * @val can lead to undesired behavior if the register to update is 16bit.
+ */
+#define __adis_update_bits(adis, reg, mask, val) ({			\
+	BUILD_BUG_ON(sizeof(val) == 1 || sizeof(val) == 8);		\
+	__builtin_choose_expr(sizeof(val) == 4,				\
+		__adis_update_bits_base(adis, reg, mask, val, 4),	\
+		__adis_update_bits_base(adis, reg, mask, val, 2));	\
+})
+
 int adis_enable_irq(struct adis *adis, bool enable);
 int __adis_check_status(struct adis *adis);
 int __adis_initial_startup(struct adis *adis);

commit 698211065d4aa71ce599b38c23452664a5a8e370
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Apr 13 10:24:41 2020 +0200

    iio: imu: adis: Add irq flag variable
    
    There are some ADIS devices that can configure the data ready pin
    polarity. Hence, we cannot hardcode our IRQ mask as IRQF_TRIGGER_RISING
    since we might want to have it as IRQF_TRIGGER_FALLING.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index e70814d96e1c..70e4d1d262f5 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -87,6 +87,7 @@ struct adis_data {
  * @msg: SPI message object
  * @xfer: SPI transfer objects to be used for a @msg
  * @current_page: Some ADIS devices have registers, this selects current page
+ * @irq_flag: IRQ handling flags as passed to request_irq()
  * @buffer: Data buffer for information read from the device
  * @tx: DMA safe TX buffer for SPI transfers
  * @rx: DMA safe RX buffer for SPI transfers
@@ -113,6 +114,7 @@ struct adis {
 	struct spi_message	msg;
 	struct spi_transfer	*xfer;
 	unsigned int		current_page;
+	unsigned long		irq_flag;
 	void			*buffer;
 
 	uint8_t			tx[10] ____cacheline_aligned;

commit fec86c6b8369b5dd8e3a1ad3752578a737163b25
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Apr 13 10:24:40 2020 +0200

    iio: imu: adis: Add Managed device functions
    
    This patch adds support for a managed device version of
    adis_setup_buffer_and_trigger. It works exactly as the original
    one but it calls all the devm_iio_* functions to setup an iio
    buffer and trigger. Hence we do not need to care about cleaning those
    and we do not need to support a remove() callback for every driver using
    the adis library.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index dd8219138c2e..e70814d96e1c 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -448,11 +448,15 @@ struct adis_burst {
 	unsigned int	extra_len;
 };
 
+int
+devm_adis_setup_buffer_and_trigger(struct adis *adis, struct iio_dev *indio_dev,
+				   irq_handler_t trigger_handler);
 int adis_setup_buffer_and_trigger(struct adis *adis,
 	struct iio_dev *indio_dev, irqreturn_t (*trigger_handler)(int, void *));
 void adis_cleanup_buffer_and_trigger(struct adis *adis,
 	struct iio_dev *indio_dev);
 
+int devm_adis_probe_trigger(struct adis *adis, struct iio_dev *indio_dev);
 int adis_probe_trigger(struct adis *adis, struct iio_dev *indio_dev);
 void adis_remove_trigger(struct adis *adis);
 
@@ -461,6 +465,13 @@ int adis_update_scan_mode(struct iio_dev *indio_dev,
 
 #else /* CONFIG_IIO_BUFFER */
 
+static inline int
+devm_adis_setup_buffer_and_trigger(struct adis *adis, struct iio_dev *indio_dev,
+				   irq_handler_t trigger_handler)
+{
+	return 0;
+}
+
 static inline int adis_setup_buffer_and_trigger(struct adis *adis,
 	struct iio_dev *indio_dev, irqreturn_t (*trigger_handler)(int, void *))
 {
@@ -472,6 +483,12 @@ static inline void adis_cleanup_buffer_and_trigger(struct adis *adis,
 {
 }
 
+static inline int devm_adis_probe_trigger(struct adis *adis,
+					  struct iio_dev *indio_dev)
+{
+	return 0;
+}
+
 static inline int adis_probe_trigger(struct adis *adis,
 	struct iio_dev *indio_dev)
 {

commit 2303248b291f537f0414a644a53483c71023136f
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Feb 25 12:33:19 2020 +0200

    iio: imu: adis: add a note better explaining state_lock
    
    The 'state_lock' mutex was renamed from 'txrx_lock' in a previous patch and
    is intended to be used by ADIS drivers to protect the state of devices
    during consecutive R/W ops.
    The initial patch that introduced this change did not do a good [well, any]
    job at explaining this. This patch adds a comment to the 'state_lock'
    better explaining it's use.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 20339025c75f..dd8219138c2e 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -98,6 +98,17 @@ struct adis {
 	const struct adis_data	*data;
 	struct adis_burst	*burst;
 
+	/**
+	 * The state_lock is meant to be used during operations that require
+	 * a sequence of SPI R/W in order to protect the SPI transfer
+	 * information (fields 'xfer', 'msg' & 'current_page') between
+	 * potential concurrent accesses.
+	 * This lock is used by all "adis_{functions}" that have to read/write
+	 * registers. These functions also have unlocked variants
+	 * (see "__adis_{functions}"), which don't hold this lock.
+	 * This allows users of the ADIS library to group SPI R/W into
+	 * the drivers, but they also must manage this lock themselves.
+	 */
 	struct mutex		state_lock;
 	struct spi_message	msg;
 	struct spi_transfer	*xfer;

commit 2dd86ba821330840661e7102e3304309299aa635
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Feb 25 12:33:18 2020 +0200

    iio: imu: adis: update 'adis_data' struct doc-string
    
    The doc-string has been neglected over time.
    This change updates it with all the missing info.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 63e456aa5c8a..20339025c75f 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -43,10 +43,14 @@ struct adis_timeout {
  * @diag_stat_reg: Register address of the DIAG_STAT register
  * @prod_id_reg: Register address of the PROD_ID register
  * @prod_id: Product ID code that should be expected when reading @prod_id_reg
+ * @self_test_mask: Bitmask of supported self-test operations
  * @self_test_reg: Register address to request self test command
+ * @self_test_no_autoclear: True if device's self-test needs clear of ctrl reg
  * @status_error_msgs: Array of error messgaes
- * @status_error_mask:
+ * @status_error_mask: Bitmask of errors supported by the device
  * @timeouts: Chip specific delays
+ * @enable_irq: Hook for ADIS devices that have a special IRQ enable/disable
+ * @has_paging: True if ADIS device has paged registers
  */
 struct adis_data {
 	unsigned int read_delay;

commit 3543b1998dd396c66c7a9bce1a7962c10648de6e
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Feb 25 12:33:17 2020 +0200

    iio: imu: adis: add doc-string for 'adis' struct
    
    This change adds a doc-string for the 'adis' struct. It details the fields
    and their roles.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index ac7cfd073804..63e456aa5c8a 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -73,6 +73,20 @@ struct adis_data {
 	bool has_paging;
 };
 
+/**
+ * struct adis - ADIS device instance data
+ * @spi: Reference to SPI device which owns this ADIS IIO device
+ * @trig: IIO trigger object data
+ * @data: ADIS chip variant specific data
+ * @burst: ADIS burst transfer information
+ * @state_lock: Lock used by the device to protect state
+ * @msg: SPI message object
+ * @xfer: SPI transfer objects to be used for a @msg
+ * @current_page: Some ADIS devices have registers, this selects current page
+ * @buffer: Data buffer for information read from the device
+ * @tx: DMA safe TX buffer for SPI transfers
+ * @rx: DMA safe RX buffer for SPI transfers
+ */
 struct adis {
 	struct spi_device	*spi;
 	struct iio_trigger	*trig;

commit 1fd4567026926d01a94a74d0543e324fc794aa73
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Mon Feb 10 15:26:04 2020 +0200

    iio: imu: adis: add support product ID check in adis_initial_startup
    
    Each driver/chip that wants to validate it's product id, can now
    specify a 'prod_id_reg' and an expected 'prod_id' value.
    The 'prod_id' value is intentionally left 0 (uninitialized). There aren't
    (yet) any product IDs with value 0; this enforces that both 'prod_id_reg'
    and 'prod_id' are specified.
    
    At the very least, this routine validates that the SPI connection to the
    ADIS chip[s] works well.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index b7feca4e5f26..ac7cfd073804 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -41,6 +41,8 @@ struct adis_timeout {
  * @glob_cmd_reg: Register address of the GLOB_CMD register
  * @msc_ctrl_reg: Register address of the MSC_CTRL register
  * @diag_stat_reg: Register address of the DIAG_STAT register
+ * @prod_id_reg: Register address of the PROD_ID register
+ * @prod_id: Product ID code that should be expected when reading @prod_id_reg
  * @self_test_reg: Register address to request self test command
  * @status_error_msgs: Array of error messgaes
  * @status_error_mask:
@@ -54,6 +56,9 @@ struct adis_data {
 	unsigned int glob_cmd_reg;
 	unsigned int msc_ctrl_reg;
 	unsigned int diag_stat_reg;
+	unsigned int prod_id_reg;
+
+	unsigned int prod_id;
 
 	unsigned int self_test_mask;
 	unsigned int self_test_reg;

commit fdcf6bbb4ed388844e74810e117ac87db1347f3a
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Feb 10 15:26:02 2020 +0200

    iio: imu: adis: Add self_test_reg variable
    
    This patch adds a dedicated self_test_reg variable. This is also a step
    to let new drivers make use of `adis_initial_startup()`. Some devices
    use MSG_CTRL reg to request a self_test command while others use the
    GLOB_CMD register.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 15e75670f923..b7feca4e5f26 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -41,6 +41,7 @@ struct adis_timeout {
  * @glob_cmd_reg: Register address of the GLOB_CMD register
  * @msc_ctrl_reg: Register address of the MSC_CTRL register
  * @diag_stat_reg: Register address of the DIAG_STAT register
+ * @self_test_reg: Register address to request self test command
  * @status_error_msgs: Array of error messgaes
  * @status_error_mask:
  * @timeouts: Chip specific delays
@@ -55,6 +56,7 @@ struct adis_data {
 	unsigned int diag_stat_reg;
 
 	unsigned int self_test_mask;
+	unsigned int self_test_reg;
 	bool self_test_no_autoclear;
 	const struct adis_timeout *timeouts;
 

commit 3f17ada8f38c57b6c81d41db6d911932b280d5b5
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Mon Feb 10 15:26:01 2020 +0200

    iio: imu: adis: add unlocked __adis_initial_startup()
    
    This change splits the __adis_initial_startup() away from
    adis_initial_startup(). The unlocked version can be used in certain calls
    during probe, where races won't happen since the ADIS driver may not be
    registered yet with IIO.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index d2fcf45b4cef..15e75670f923 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -297,6 +297,7 @@ static inline int adis_read_reg_32(struct adis *adis, unsigned int reg,
 
 int adis_enable_irq(struct adis *adis, bool enable);
 int __adis_check_status(struct adis *adis);
+int __adis_initial_startup(struct adis *adis);
 
 static inline int adis_check_status(struct adis *adis)
 {
@@ -309,7 +310,17 @@ static inline int adis_check_status(struct adis *adis)
 	return ret;
 }
 
-int adis_initial_startup(struct adis *adis);
+/* locked version of __adis_initial_startup() */
+static inline int adis_initial_startup(struct adis *adis)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_initial_startup(adis);
+	mutex_unlock(&adis->state_lock);
+
+	return ret;
+}
 
 int adis_single_conversion(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, unsigned int error_mask,

commit 77038bd01ce66ae65bcb66266c9747b670b5facd
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Tue Jan 7 13:17:05 2020 +0200

    iio: adis: Remove startup_delay
    
    All timeouts are now handled by a dedicated timeout struct. This
    variable is no longer needed.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 853dc8c8365c..d2fcf45b4cef 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -56,7 +56,6 @@ struct adis_data {
 
 	unsigned int self_test_mask;
 	bool self_test_no_autoclear;
-	unsigned int startup_delay;
 	const struct adis_timeout *timeouts;
 
 	const char * const *status_error_msgs;

commit 380b107bbf9449ddea0637cefe65a6cbf7b6ca84
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Tue Jan 7 13:17:04 2020 +0200

    iio: adis: Introduce timeouts structure
    
    The adis library only allows to define a `startup_delay` which for some
    devices is enough. However, other devices define different timeouts with
    significantly different timings which could lead to devices to not wait
    enough time or to wait a lot more than necessary (which is not
    efficient). This patch introduces a new timeout struct that must be
    passed into `adis_init()`. There are mainly, for now, three timeouts
    used. This is also an introductory patch with the goal of refactoring
    `adis_initial_startup()`. New driver's (eg: adis16480, adis16460) are
    replicating code for the device initial setup. With some changes (being
    this the first one) we can pass this to `adis_initial_startup()`.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 4b5bc0e06e69..853dc8c8365c 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -22,6 +22,17 @@
 struct adis;
 struct adis_burst;
 
+/**
+ * struct adis_timeouts - ADIS chip variant timeouts
+ * @reset_ms - Wait time after rst pin goes inactive
+ * @sw_reset_ms - Wait time after sw reset command
+ * @self_test_ms - Wait time after self test command
+ */
+struct adis_timeout {
+	u16 reset_ms;
+	u16 sw_reset_ms;
+	u16 self_test_ms;
+};
 /**
  * struct adis_data - ADIS chip variant specific data
  * @read_delay: SPI delay for read operations in us
@@ -32,6 +43,7 @@ struct adis_burst;
  * @diag_stat_reg: Register address of the DIAG_STAT register
  * @status_error_msgs: Array of error messgaes
  * @status_error_mask:
+ * @timeouts: Chip specific delays
  */
 struct adis_data {
 	unsigned int read_delay;
@@ -45,6 +57,7 @@ struct adis_data {
 	unsigned int self_test_mask;
 	bool self_test_no_autoclear;
 	unsigned int startup_delay;
+	const struct adis_timeout *timeouts;
 
 	const char * const *status_error_msgs;
 	unsigned int status_error_mask;

commit 762ab093cbe26451175a5a63ea06c971bf973525
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:15 2019 +0200

    iio: imu: adis: create an unlocked version of adis_reset()
    
    The reset routine may also be important to be protected by the state-lock
    and grouped with other operations, so create an unlocked version, so that
    this can be done.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index db759957e1c1..4b5bc0e06e69 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -73,7 +73,24 @@ struct adis {
 
 int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	struct spi_device *spi, const struct adis_data *data);
-int adis_reset(struct adis *adis);
+int __adis_reset(struct adis *adis);
+
+/**
+ * adis_reset() - Reset the device
+ * @adis: The adis device
+ *
+ * Returns 0 on success, a negative error code otherwise
+ */
+static inline int adis_reset(struct adis *adis)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_reset(adis);
+	mutex_unlock(&adis->state_lock);
+
+	return ret;
+}
 
 int __adis_write_reg(struct adis *adis, unsigned int reg,
 	unsigned int val, unsigned int size);

commit 6a4d6a7d6588d8c15501542da786ebff6602475c
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:14 2019 +0200

    iio: imu: adis: create an unlocked version of adis_check_status()
    
    This one also gets re-used in certain operations, so it makes sense to
    have an unlocked version of this to group it with other
    reads/writes/operations to have a single lock for the whole state change.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 38ebe41092e1..db759957e1c1 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -267,7 +267,18 @@ static inline int adis_read_reg_32(struct adis *adis, unsigned int reg,
 }
 
 int adis_enable_irq(struct adis *adis, bool enable);
-int adis_check_status(struct adis *adis);
+int __adis_check_status(struct adis *adis);
+
+static inline int adis_check_status(struct adis *adis)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_check_status(adis);
+	mutex_unlock(&adis->state_lock);
+
+	return ret;
+}
 
 int adis_initial_startup(struct adis *adis);
 

commit 770d465619423a946248018ea39ed9a74c8f2ff4
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:12 2019 +0200

    iio: imu: adis: add unlocked read/write function versions
    
    This will allow more flexible control to group reads & writes into a single
    lock (particularly the state_lock).
    
    The end-goal is to remove the indio_dev->mlock usage, and the simplest fix
    would have been to just add another lock, which would not be a good idea on
    the long-run.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 100b5d1cebf1..38ebe41092e1 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -75,11 +75,123 @@ int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	struct spi_device *spi, const struct adis_data *data);
 int adis_reset(struct adis *adis);
 
-int adis_write_reg(struct adis *adis, unsigned int reg,
+int __adis_write_reg(struct adis *adis, unsigned int reg,
 	unsigned int val, unsigned int size);
-int adis_read_reg(struct adis *adis, unsigned int reg,
+int __adis_read_reg(struct adis *adis, unsigned int reg,
 	unsigned int *val, unsigned int size);
 
+/**
+ * __adis_write_reg_8() - Write single byte to a register (unlocked)
+ * @adis: The adis device
+ * @reg: The address of the register to be written
+ * @value: The value to write
+ */
+static inline int __adis_write_reg_8(struct adis *adis, unsigned int reg,
+	uint8_t val)
+{
+	return __adis_write_reg(adis, reg, val, 1);
+}
+
+/**
+ * __adis_write_reg_16() - Write 2 bytes to a pair of registers (unlocked)
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @value: Value to be written
+ */
+static inline int __adis_write_reg_16(struct adis *adis, unsigned int reg,
+	uint16_t val)
+{
+	return __adis_write_reg(adis, reg, val, 2);
+}
+
+/**
+ * __adis_write_reg_32() - write 4 bytes to four registers (unlocked)
+ * @adis: The adis device
+ * @reg: The address of the lower of the four register
+ * @value: Value to be written
+ */
+static inline int __adis_write_reg_32(struct adis *adis, unsigned int reg,
+	uint32_t val)
+{
+	return __adis_write_reg(adis, reg, val, 4);
+}
+
+/**
+ * __adis_read_reg_16() - read 2 bytes from a 16-bit register (unlocked)
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ */
+static inline int __adis_read_reg_16(struct adis *adis, unsigned int reg,
+	uint16_t *val)
+{
+	unsigned int tmp;
+	int ret;
+
+	ret = __adis_read_reg(adis, reg, &tmp, 2);
+	if (ret == 0)
+		*val = tmp;
+
+	return ret;
+}
+
+/**
+ * __adis_read_reg_32() - read 4 bytes from a 32-bit register (unlocked)
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ */
+static inline int __adis_read_reg_32(struct adis *adis, unsigned int reg,
+	uint32_t *val)
+{
+	unsigned int tmp;
+	int ret;
+
+	ret = __adis_read_reg(adis, reg, &tmp, 4);
+	if (ret == 0)
+		*val = tmp;
+
+	return ret;
+}
+
+/**
+ * adis_write_reg() - write N bytes to register
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @value: The value to write to device (up to 4 bytes)
+ * @size: The size of the @value (in bytes)
+ */
+static inline int adis_write_reg(struct adis *adis, unsigned int reg,
+	unsigned int val, unsigned int size)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_write_reg(adis, reg, val, size);
+	mutex_unlock(&adis->state_lock);
+
+	return ret;
+}
+
+/**
+ * adis_read_reg() - read N bytes from register
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ * @size: The size of the @val buffer
+ */
+static int adis_read_reg(struct adis *adis, unsigned int reg,
+	unsigned int *val, unsigned int size)
+{
+	int ret;
+
+	mutex_lock(&adis->state_lock);
+	ret = __adis_read_reg(adis, reg, val, size);
+	mutex_unlock(&adis->state_lock);
+
+	return ret;
+}
+
 /**
  * adis_write_reg_8() - Write single byte to a register
  * @adis: The adis device

commit 6a9afcb198b4de323485c0ee94ff09f653012d4b
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:11 2019 +0200

    iio: imu: adis: rename txrx_lock -> state_lock
    
    The lock can be extended a bit to protect other elements that are not
    particular to just TX/RX. Another idea would have been to just add a new
    `state_lock`, but that would mean 2 locks which would be redundant, and
    probably cause more potential for dead-locks.
    
    What will be done in the next patches, will be to add some unlocked
    versions for read/write_reg functions.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 92aae14593bf..100b5d1cebf1 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -61,7 +61,7 @@ struct adis {
 	const struct adis_data	*data;
 	struct adis_burst	*burst;
 
-	struct mutex		txrx_lock;
+	struct mutex		state_lock;
 	struct spi_message	msg;
 	struct spi_transfer	*xfer;
 	unsigned int		current_page;

commit c49cfc227e7f49e6011d6b955145814ce13424bc
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 1 11:35:05 2019 +0200

    iio: imu: adis: assign value only if return code zero in read funcs
    
    The inline read functions in the ADIS library don't check the return value
    of the `adis_read_reg()` function and assign the value of `tmp` regardless.
    
    Fix this by checking if return value is zero and only then assigning the
    value of `tmp`.
    
    No known case of the callers of this function incorrectly using the
    value, but best to stop any potential risk here.
    Not suitable for stable due to no known actual bugs caused by this
    issue.
    
    Fixes: 57a1228a06b7a ("iio:imu:adis: Add support for 32bit registers")
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 4c53815bb729..92aae14593bf 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -129,7 +129,8 @@ static inline int adis_read_reg_16(struct adis *adis, unsigned int reg,
 	int ret;
 
 	ret = adis_read_reg(adis, reg, &tmp, 2);
-	*val = tmp;
+	if (ret == 0)
+		*val = tmp;
 
 	return ret;
 }
@@ -147,7 +148,8 @@ static inline int adis_read_reg_32(struct adis *adis, unsigned int reg,
 	int ret;
 
 	ret = adis_read_reg(adis, reg, &tmp, 4);
-	*val = tmp;
+	if (ret == 0)
+		*val = tmp;
 
 	return ret;
 }

commit dca39af8831e65adc13e0f9f8bdca3a746185072
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Jul 23 10:36:38 2019 +0300

    iio: imu: adis: Add support for SPI transfer cs_change_delay
    
    The ADIS16460 requires a higher delay before the next transfer. Since the
    SPI framework supports configuring the delay before the next transfer, this
    driver will become the first user of it.
    
    The support for this functionality in ADIS16460 requires an addition to the
    ADIS lib to support the `cs_change_delay` functionality from the SPI
    subsystem.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 3428d06b2f44..4c53815bb729 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -26,6 +26,7 @@ struct adis_burst;
  * struct adis_data - ADIS chip variant specific data
  * @read_delay: SPI delay for read operations in us
  * @write_delay: SPI delay for write operations in us
+ * @cs_change_delay: SPI delay between CS changes in us
  * @glob_cmd_reg: Register address of the GLOB_CMD register
  * @msc_ctrl_reg: Register address of the MSC_CTRL register
  * @diag_stat_reg: Register address of the DIAG_STAT register
@@ -35,6 +36,7 @@ struct adis_burst;
 struct adis_data {
 	unsigned int read_delay;
 	unsigned int write_delay;
+	unsigned int cs_change_delay;
 
 	unsigned int glob_cmd_reg;
 	unsigned int msc_ctrl_reg;

commit 80503b23b23b5b2228d8750b786eb182f2fa28d2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:09 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 149
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2 or later
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 82 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100845.150836982@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 469a493f7ae0..3428d06b2f44 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -1,10 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Common library for ADIS16XXX devices
  *
  * Copyright 2012 Analog Devices Inc.
  *   Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- * Licensed under the GPL-2 or later.
  */
 
 #ifndef __IIO_ADIS_H__

commit 5075e0720d93a84e059759c5d8c6a78613d0face
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Mar 22 22:44:39 2019 +0200

    iio: imu: adis: generalize burst mode support
    
    Some variants in the ADIS16400 family support burst mode. This mechanism is
    implemented in the `adis16400_buffer.c` file.
    
    Some variants in ADIS16480 are also adding burst mode, which is
    functionally similar to ADIS16400, but with different parameters. To get
    there, a `adis_burst` struct is added to parametrize certain bits of the
    SPI communication to setup: the register that triggers burst-mode, and the
    extra-data-length that needs be accounted for when building the bust-length
    buffer.
    
    The trigger handler cannot be made generic, since it's very specific to
    each ADIS164XX family.
    
    A future enhancement of this `adis_burst` mode will be the possibility to
    enable/disable burst-mode. For the ADIS16400 family it's hard-coded to on
    by default. But for ADIS16480 there will be a need to disable this.
    
    When that will be implemented, both ADIS16400 & ADIS16480 will have the
    burst-mode enable-able/disable-able.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 360da7d18a3d..469a493f7ae0 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -21,6 +21,7 @@
 #define ADIS_REG_PAGE_ID 0x00
 
 struct adis;
+struct adis_burst;
 
 /**
  * struct adis_data - ADIS chip variant specific data
@@ -57,6 +58,7 @@ struct adis {
 	struct iio_trigger	*trig;
 
 	const struct adis_data	*data;
+	struct adis_burst	*burst;
 
 	struct mutex		txrx_lock;
 	struct spi_message	msg;
@@ -232,6 +234,18 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 
 #ifdef CONFIG_IIO_ADIS_LIB_BUFFER
 
+/**
+ * struct adis_burst - ADIS data for burst transfers
+ * @en			burst mode enabled
+ * @reg_cmd		register command that triggers burst
+ * @extra_len		extra length to account in the SPI RX buffer
+ */
+struct adis_burst {
+	bool		en;
+	unsigned int	reg_cmd;
+	unsigned int	extra_len;
+};
+
 int adis_setup_buffer_and_trigger(struct adis *adis,
 	struct iio_dev *indio_dev, irqreturn_t (*trigger_handler)(int, void *));
 void adis_cleanup_buffer_and_trigger(struct adis *adis,

commit af8a41271b56f6d79cb4d7c7f3ca688a2d97a801
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Apr 15 16:59:38 2016 +0200

    iio:adis: Add support for manual self-test flag clear
    
    Some variants of the devices from the ADIS family don't auto-clear the
    self-test bit after the self-test has completed. Instead we have to
    manually clear. Add support for this to the ADIS library.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index fa2d01ef8f55..360da7d18a3d 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -41,6 +41,7 @@ struct adis_data {
 	unsigned int diag_stat_reg;
 
 	unsigned int self_test_mask;
+	bool self_test_no_autoclear;
 	unsigned int startup_delay;
 
 	const char * const *status_error_msgs;

commit 82695ef549b5299d3d9e088d6648289bda8ef3d8
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jun 22 20:59:00 2014 +0100

    iio: adis: Switch sampling frequency attr to core support.
    
    By using the info_mask_shared_by_all element of the channel spec, acce
    to the sampling frequency becomes available to in kernel users of the
    driver.  It also shortens and simplifies the code.
    
    This particular conversion was made more complicated by the shared library
    and the fact that a number of the drivers do not actually have support for
    setting or reading the sampling frequency.  The hardware, in those cases
    investigated supports it. It's just never been implemented.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index b665dc7f017b..fa2d01ef8f55 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -157,13 +157,14 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, unsigned int error_mask,
 	int *val);
 
-#define ADIS_VOLTAGE_CHAN(addr, si, chan, name, bits) { \
+#define ADIS_VOLTAGE_CHAN(addr, si, chan, name, info_all, bits) { \
 	.type = IIO_VOLTAGE, \
 	.indexed = 1, \
 	.channel = (chan), \
 	.extend_name = name, \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
 		BIT(IIO_CHAN_INFO_SCALE), \
+	.info_mask_shared_by_all = info_all, \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -174,19 +175,20 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	}, \
 }
 
-#define ADIS_SUPPLY_CHAN(addr, si, bits) \
-	ADIS_VOLTAGE_CHAN(addr, si, 0, "supply", bits)
+#define ADIS_SUPPLY_CHAN(addr, si, info_all, bits) \
+	ADIS_VOLTAGE_CHAN(addr, si, 0, "supply", info_all, bits)
 
-#define ADIS_AUX_ADC_CHAN(addr, si, bits) \
-	ADIS_VOLTAGE_CHAN(addr, si, 1, NULL, bits)
+#define ADIS_AUX_ADC_CHAN(addr, si, info_all, bits) \
+	ADIS_VOLTAGE_CHAN(addr, si, 1, NULL, info_all, bits)
 
-#define ADIS_TEMP_CHAN(addr, si, bits) { \
+#define ADIS_TEMP_CHAN(addr, si, info_all, bits) { \
 	.type = IIO_TEMP, \
 	.indexed = 1, \
 	.channel = 0, \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
 		BIT(IIO_CHAN_INFO_SCALE) | \
 		BIT(IIO_CHAN_INFO_OFFSET), \
+	.info_mask_shared_by_all = info_all, \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -197,13 +199,14 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	}, \
 }
 
-#define ADIS_MOD_CHAN(_type, mod, addr, si, info_sep, bits) { \
+#define ADIS_MOD_CHAN(_type, mod, addr, si, info_sep, info_all, bits) { \
 	.type = (_type), \
 	.modified = 1, \
 	.channel2 = IIO_MOD_ ## mod, \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
 		 info_sep, \
 	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \
+	.info_mask_shared_by_all = info_all, \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -214,17 +217,17 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	}, \
 }
 
-#define ADIS_ACCEL_CHAN(mod, addr, si, info_sep, bits) \
-	ADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info_sep, bits)
+#define ADIS_ACCEL_CHAN(mod, addr, si, info_sep, info_all, bits) \
+	ADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info_sep, info_all, bits)
 
-#define ADIS_GYRO_CHAN(mod, addr, si, info_sep, bits) \
-	ADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info_sep, bits)
+#define ADIS_GYRO_CHAN(mod, addr, si, info_sep, info_all, bits)		\
+	ADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info_sep, info_all, bits)
 
-#define ADIS_INCLI_CHAN(mod, addr, si, info_sep, bits) \
-	ADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info_sep, bits)
+#define ADIS_INCLI_CHAN(mod, addr, si, info_sep, info_all, bits) \
+	ADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info_sep, info_all, bits)
 
-#define ADIS_ROT_CHAN(mod, addr, si, info_sep, bits) \
-	ADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info_sep, bits)
+#define ADIS_ROT_CHAN(mod, addr, si, info_sep, info_all, bits) \
+	ADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info_sep, info_all, bits)
 
 #ifdef CONFIG_IIO_ADIS_LIB_BUFFER
 

commit b841f8abc27466026ecf4e5590c6c737c2e86e7e
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Feb 27 19:35:55 2013 +0000

    staging:iio:accel:adis move to info_mask_(shared_by_type/separate)
    
    The original info_mask is going away in favour of the broken out versions.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index ff781dca2e9a..b665dc7f017b 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -162,8 +162,8 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	.indexed = 1, \
 	.channel = (chan), \
 	.extend_name = name, \
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
-		IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_SCALE), \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -184,9 +184,9 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	.type = IIO_TEMP, \
 	.indexed = 1, \
 	.channel = 0, \
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
-		IIO_CHAN_INFO_SCALE_SEPARATE_BIT | \
-		IIO_CHAN_INFO_OFFSET_SEPARATE_BIT, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_SCALE) | \
+		BIT(IIO_CHAN_INFO_OFFSET), \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -197,13 +197,13 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	}, \
 }
 
-#define ADIS_MOD_CHAN(_type, mod, addr, si, info, bits) { \
+#define ADIS_MOD_CHAN(_type, mod, addr, si, info_sep, bits) { \
 	.type = (_type), \
 	.modified = 1, \
 	.channel2 = IIO_MOD_ ## mod, \
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
-		 IIO_CHAN_INFO_SCALE_SHARED_BIT | \
-		 info, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		 info_sep, \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \
 	.address = (addr), \
 	.scan_index = (si), \
 	.scan_type = { \
@@ -214,17 +214,17 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	}, \
 }
 
-#define ADIS_ACCEL_CHAN(mod, addr, si, info, bits) \
-	ADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info, bits)
+#define ADIS_ACCEL_CHAN(mod, addr, si, info_sep, bits) \
+	ADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info_sep, bits)
 
-#define ADIS_GYRO_CHAN(mod, addr, si, info, bits) \
-	ADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info, bits)
+#define ADIS_GYRO_CHAN(mod, addr, si, info_sep, bits) \
+	ADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info_sep, bits)
 
-#define ADIS_INCLI_CHAN(mod, addr, si, info, bits) \
-	ADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info, bits)
+#define ADIS_INCLI_CHAN(mod, addr, si, info_sep, bits) \
+	ADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info_sep, bits)
 
-#define ADIS_ROT_CHAN(mod, addr, si, info, bits) \
-	ADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info, bits)
+#define ADIS_ROT_CHAN(mod, addr, si, info_sep, bits) \
+	ADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info_sep, bits)
 
 #ifdef CONFIG_IIO_ADIS_LIB_BUFFER
 

commit 2f3abe6cbb6c963ac790b40936b6761c9f0497b4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu: Add support for the ADIS16480 and similar IMUs
    
    This patch adds support for the ADIS16375, ADIS16480, ADIS16485, ADIS16488 6
    degree to 10 degree of freedom IMUs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index e82cd0827e91..ff781dca2e9a 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -20,6 +20,8 @@
 #define ADIS_PAGE_SIZE 0x80
 #define ADIS_REG_PAGE_ID 0x00
 
+struct adis;
+
 /**
  * struct adis_data - ADIS chip variant specific data
  * @read_delay: SPI delay for read operations in us
@@ -44,6 +46,8 @@ struct adis_data {
 	const char * const *status_error_msgs;
 	unsigned int status_error_mask;
 
+	int (*enable_irq)(struct adis *adis, bool enable);
+
 	bool has_paging;
 };
 

commit 484a0bf091c93c379e6524a17bb037c33c898e01
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add paging support
    
    Some of the newer generation devices from the ADIS16XXX series have more
    registers than what can be supported with the current register addressing
    scheme. These devices implement register paging to support a larger register
    range. Each page is 128 registers large and the currently active page can be
    selected via register 0x00 in each page. This patch implements transparent
    paging inside the common adis library. The register read/write interface stays
    the same and when a register is accessed the library automatically switches to
    the correct page if it is not already selected. The page number is encoded in
    the upper bits of the register number, e.g. register 0x5 of page 1 is 0x85.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 6402a08c0e65..e82cd0827e91 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -14,8 +14,11 @@
 #include <linux/interrupt.h>
 #include <linux/iio/types.h>
 
-#define ADIS_WRITE_REG(reg) (0x80 | (reg))
-#define ADIS_READ_REG(reg) (reg)
+#define ADIS_WRITE_REG(reg) ((0x80 | (reg)))
+#define ADIS_READ_REG(reg) ((reg) & 0x7f)
+
+#define ADIS_PAGE_SIZE 0x80
+#define ADIS_REG_PAGE_ID 0x00
 
 /**
  * struct adis_data - ADIS chip variant specific data
@@ -40,6 +43,8 @@ struct adis_data {
 
 	const char * const *status_error_msgs;
 	unsigned int status_error_mask;
+
+	bool has_paging;
 };
 
 struct adis {
@@ -51,6 +56,7 @@ struct adis {
 	struct mutex		txrx_lock;
 	struct spi_message	msg;
 	struct spi_transfer	*xfer;
+	unsigned int		current_page;
 	void			*buffer;
 
 	uint8_t			tx[10] ____cacheline_aligned;

commit 57a1228a06b7a5939a8b0078a92b44fa30855bcb
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add support for 32bit registers
    
    Some of the newer generation devices from the ADIS16XXX family have 32bit wide
    register which spans two 16bit wide registers. This patch adds support for
    reading and writing a 32bit wide register.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index fce7bc3ba0b5..6402a08c0e65 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -53,7 +53,7 @@ struct adis {
 	struct spi_transfer	*xfer;
 	void			*buffer;
 
-	uint8_t			tx[8] ____cacheline_aligned;
+	uint8_t			tx[10] ____cacheline_aligned;
 	uint8_t			rx[4];
 };
 
@@ -61,9 +61,82 @@ int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	struct spi_device *spi, const struct adis_data *data);
 int adis_reset(struct adis *adis);
 
-int adis_write_reg_8(struct adis *adis, unsigned int reg, uint8_t val);
-int adis_write_reg_16(struct adis *adis, unsigned int reg, uint16_t val);
-int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val);
+int adis_write_reg(struct adis *adis, unsigned int reg,
+	unsigned int val, unsigned int size);
+int adis_read_reg(struct adis *adis, unsigned int reg,
+	unsigned int *val, unsigned int size);
+
+/**
+ * adis_write_reg_8() - Write single byte to a register
+ * @adis: The adis device
+ * @reg: The address of the register to be written
+ * @value: The value to write
+ */
+static inline int adis_write_reg_8(struct adis *adis, unsigned int reg,
+	uint8_t val)
+{
+	return adis_write_reg(adis, reg, val, 1);
+}
+
+/**
+ * adis_write_reg_16() - Write 2 bytes to a pair of registers
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @value: Value to be written
+ */
+static inline int adis_write_reg_16(struct adis *adis, unsigned int reg,
+	uint16_t val)
+{
+	return adis_write_reg(adis, reg, val, 2);
+}
+
+/**
+ * adis_write_reg_32() - write 4 bytes to four registers
+ * @adis: The adis device
+ * @reg: The address of the lower of the four register
+ * @value: Value to be written
+ */
+static inline int adis_write_reg_32(struct adis *adis, unsigned int reg,
+	uint32_t val)
+{
+	return adis_write_reg(adis, reg, val, 4);
+}
+
+/**
+ * adis_read_reg_16() - read 2 bytes from a 16-bit register
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ */
+static inline int adis_read_reg_16(struct adis *adis, unsigned int reg,
+	uint16_t *val)
+{
+	unsigned int tmp;
+	int ret;
+
+	ret = adis_read_reg(adis, reg, &tmp, 2);
+	*val = tmp;
+
+	return ret;
+}
+
+/**
+ * adis_read_reg_32() - read 4 bytes from a 32-bit register
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ */
+static inline int adis_read_reg_32(struct adis *adis, unsigned int reg,
+	uint32_t *val)
+{
+	unsigned int tmp;
+	int ret;
+
+	ret = adis_read_reg(adis, reg, &tmp, 4);
+	*val = tmp;
+
+	return ret;
+}
 
 int adis_enable_irq(struct adis *adis, bool enable);
 int adis_check_status(struct adis *adis);

commit 78026a6fde8f7b0ca77c059da11f476d69dfde3b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add debugfs register access support
    
    Provide a IIO debugfs register access function for the ADIS library. This
    function can be used by individual drivers to allow raw register access via
    debugfs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
index 8c3304d44b97..fce7bc3ba0b5 100644
--- a/include/linux/iio/imu/adis.h
+++ b/include/linux/iio/imu/adis.h
@@ -183,4 +183,15 @@ static inline void adis_remove_trigger(struct adis *adis)
 
 #endif /* CONFIG_IIO_BUFFER */
 
+#ifdef CONFIG_DEBUG_FS
+
+int adis_debugfs_reg_access(struct iio_dev *indio_dev,
+	unsigned int reg, unsigned int writeval, unsigned int *readval);
+
+#else
+
+#define adis_debugfs_reg_access NULL
+
+#endif
+
 #endif

commit ec04cb048d79cd778c06e28f34395a46d774800d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 13 13:28:00 2012 +0000

    staging:iio: Move adis library out of staging
    
    Now that the adis library no longer depends on the sw_ring buffer implementation
    we can move it out of staging.
    
    While we are at it also sort the entries in the iio Kconfig and Makefile to be
    in alphabetical order.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/include/linux/iio/imu/adis.h b/include/linux/iio/imu/adis.h
new file mode 100644
index 000000000000..8c3304d44b97
--- /dev/null
+++ b/include/linux/iio/imu/adis.h
@@ -0,0 +1,186 @@
+/*
+ * Common library for ADIS16XXX devices
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *   Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef __IIO_ADIS_H__
+#define __IIO_ADIS_H__
+
+#include <linux/spi/spi.h>
+#include <linux/interrupt.h>
+#include <linux/iio/types.h>
+
+#define ADIS_WRITE_REG(reg) (0x80 | (reg))
+#define ADIS_READ_REG(reg) (reg)
+
+/**
+ * struct adis_data - ADIS chip variant specific data
+ * @read_delay: SPI delay for read operations in us
+ * @write_delay: SPI delay for write operations in us
+ * @glob_cmd_reg: Register address of the GLOB_CMD register
+ * @msc_ctrl_reg: Register address of the MSC_CTRL register
+ * @diag_stat_reg: Register address of the DIAG_STAT register
+ * @status_error_msgs: Array of error messgaes
+ * @status_error_mask:
+ */
+struct adis_data {
+	unsigned int read_delay;
+	unsigned int write_delay;
+
+	unsigned int glob_cmd_reg;
+	unsigned int msc_ctrl_reg;
+	unsigned int diag_stat_reg;
+
+	unsigned int self_test_mask;
+	unsigned int startup_delay;
+
+	const char * const *status_error_msgs;
+	unsigned int status_error_mask;
+};
+
+struct adis {
+	struct spi_device	*spi;
+	struct iio_trigger	*trig;
+
+	const struct adis_data	*data;
+
+	struct mutex		txrx_lock;
+	struct spi_message	msg;
+	struct spi_transfer	*xfer;
+	void			*buffer;
+
+	uint8_t			tx[8] ____cacheline_aligned;
+	uint8_t			rx[4];
+};
+
+int adis_init(struct adis *adis, struct iio_dev *indio_dev,
+	struct spi_device *spi, const struct adis_data *data);
+int adis_reset(struct adis *adis);
+
+int adis_write_reg_8(struct adis *adis, unsigned int reg, uint8_t val);
+int adis_write_reg_16(struct adis *adis, unsigned int reg, uint16_t val);
+int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val);
+
+int adis_enable_irq(struct adis *adis, bool enable);
+int adis_check_status(struct adis *adis);
+
+int adis_initial_startup(struct adis *adis);
+
+int adis_single_conversion(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, unsigned int error_mask,
+	int *val);
+
+#define ADIS_VOLTAGE_CHAN(addr, si, chan, name, bits) { \
+	.type = IIO_VOLTAGE, \
+	.indexed = 1, \
+	.channel = (chan), \
+	.extend_name = name, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+		IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.address = (addr), \
+	.scan_index = (si), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = (bits), \
+		.storagebits = 16, \
+		.endianness = IIO_BE, \
+	}, \
+}
+
+#define ADIS_SUPPLY_CHAN(addr, si, bits) \
+	ADIS_VOLTAGE_CHAN(addr, si, 0, "supply", bits)
+
+#define ADIS_AUX_ADC_CHAN(addr, si, bits) \
+	ADIS_VOLTAGE_CHAN(addr, si, 1, NULL, bits)
+
+#define ADIS_TEMP_CHAN(addr, si, bits) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.channel = 0, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+		IIO_CHAN_INFO_SCALE_SEPARATE_BIT | \
+		IIO_CHAN_INFO_OFFSET_SEPARATE_BIT, \
+	.address = (addr), \
+	.scan_index = (si), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = (bits), \
+		.storagebits = 16, \
+		.endianness = IIO_BE, \
+	}, \
+}
+
+#define ADIS_MOD_CHAN(_type, mod, addr, si, info, bits) { \
+	.type = (_type), \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## mod, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+		 IIO_CHAN_INFO_SCALE_SHARED_BIT | \
+		 info, \
+	.address = (addr), \
+	.scan_index = (si), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = (bits), \
+		.storagebits = 16, \
+		.endianness = IIO_BE, \
+	}, \
+}
+
+#define ADIS_ACCEL_CHAN(mod, addr, si, info, bits) \
+	ADIS_MOD_CHAN(IIO_ACCEL, mod, addr, si, info, bits)
+
+#define ADIS_GYRO_CHAN(mod, addr, si, info, bits) \
+	ADIS_MOD_CHAN(IIO_ANGL_VEL, mod, addr, si, info, bits)
+
+#define ADIS_INCLI_CHAN(mod, addr, si, info, bits) \
+	ADIS_MOD_CHAN(IIO_INCLI, mod, addr, si, info, bits)
+
+#define ADIS_ROT_CHAN(mod, addr, si, info, bits) \
+	ADIS_MOD_CHAN(IIO_ROT, mod, addr, si, info, bits)
+
+#ifdef CONFIG_IIO_ADIS_LIB_BUFFER
+
+int adis_setup_buffer_and_trigger(struct adis *adis,
+	struct iio_dev *indio_dev, irqreturn_t (*trigger_handler)(int, void *));
+void adis_cleanup_buffer_and_trigger(struct adis *adis,
+	struct iio_dev *indio_dev);
+
+int adis_probe_trigger(struct adis *adis, struct iio_dev *indio_dev);
+void adis_remove_trigger(struct adis *adis);
+
+int adis_update_scan_mode(struct iio_dev *indio_dev,
+	const unsigned long *scan_mask);
+
+#else /* CONFIG_IIO_BUFFER */
+
+static inline int adis_setup_buffer_and_trigger(struct adis *adis,
+	struct iio_dev *indio_dev, irqreturn_t (*trigger_handler)(int, void *))
+{
+	return 0;
+}
+
+static inline void adis_cleanup_buffer_and_trigger(struct adis *adis,
+	struct iio_dev *indio_dev)
+{
+}
+
+static inline int adis_probe_trigger(struct adis *adis,
+	struct iio_dev *indio_dev)
+{
+	return 0;
+}
+
+static inline void adis_remove_trigger(struct adis *adis)
+{
+}
+
+#define adis_update_scan_mode NULL
+
+#endif /* CONFIG_IIO_BUFFER */
+
+#endif
