commit b4941adb24c0676f77ddc25e6d7836b8245c47fc
Author: Ran Wang <ran.wang_1@nxp.com>
Date:   Thu Oct 24 17:26:42 2019 +0800

    PM: wakeup: Add routine to help fetch wakeup source object.
    
    Some user might want to go through all registered wakeup sources
    and doing things accordingly. For example, SoC PM driver might need to
    do HW programming to prevent powering down specific IP which wakeup
    source depending on. So add this API to help walk through all registered
    wakeup source objects on that list and return them one by one.
    
    Signed-off-by: Ran Wang <ran.wang_1@nxp.com>
    Tested-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Li Yang <leoyang.li@nxp.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 661efa029c96..aa3da6611533 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -63,6 +63,11 @@ struct wakeup_source {
 	bool			autosleep_enabled:1;
 };
 
+#define for_each_wakeup_source(ws) \
+	for ((ws) = wakeup_sources_walk_start();	\
+	     (ws);					\
+	     (ws) = wakeup_sources_walk_next((ws)))
+
 #ifdef CONFIG_PM_SLEEP
 
 /*
@@ -92,6 +97,10 @@ extern void wakeup_source_remove(struct wakeup_source *ws);
 extern struct wakeup_source *wakeup_source_register(struct device *dev,
 						    const char *name);
 extern void wakeup_source_unregister(struct wakeup_source *ws);
+extern int wakeup_sources_read_lock(void);
+extern void wakeup_sources_read_unlock(int idx);
+extern struct wakeup_source *wakeup_sources_walk_start(void);
+extern struct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws);
 extern int device_wakeup_enable(struct device *dev);
 extern int device_wakeup_disable(struct device *dev);
 extern void device_set_wakeup_capable(struct device *dev, bool capable);

commit c8377adfa78103be5380200eb9dab764d7ca890e
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:46 2019 -0700

    PM / wakeup: Show wakeup sources stats in sysfs
    
    Add an ID and a device pointer to 'struct wakeup_source'. Use them to to
    expose wakeup sources statistics in sysfs under
    /sys/class/wakeup/wakeup<ID>/*.
    
    Co-developed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Co-developed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Tri Vo <trong@android.com>
    Tested-by: Kalesh Singh <kaleshsingh@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index c0cad2d8f800..661efa029c96 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -21,6 +21,7 @@ struct wake_irq;
  * struct wakeup_source - Representation of wakeup sources
  *
  * @name: Name of the wakeup source
+ * @id: Wakeup source id
  * @entry: Wakeup source list entry
  * @lock: Wakeup source lock
  * @wakeirq: Optional device specific wakeirq
@@ -35,11 +36,13 @@ struct wake_irq;
  * @relax_count: Number of times the wakeup source was deactivated.
  * @expire_count: Number of times the wakeup source's timeout has expired.
  * @wakeup_count: Number of times the wakeup source might abort suspend.
+ * @dev: Struct device for sysfs statistics about the wakeup source.
  * @active: Status of the wakeup source.
  * @autosleep_enabled: Autosleep is active, so update @prevent_sleep_time.
  */
 struct wakeup_source {
 	const char 		*name;
+	int			id;
 	struct list_head	entry;
 	spinlock_t		lock;
 	struct wake_irq		*wakeirq;
@@ -55,6 +58,7 @@ struct wakeup_source {
 	unsigned long		relax_count;
 	unsigned long		expire_count;
 	unsigned long		wakeup_count;
+	struct device		*dev;
 	bool			active:1;
 	bool			autosleep_enabled:1;
 };
@@ -85,7 +89,8 @@ extern struct wakeup_source *wakeup_source_create(const char *name);
 extern void wakeup_source_destroy(struct wakeup_source *ws);
 extern void wakeup_source_add(struct wakeup_source *ws);
 extern void wakeup_source_remove(struct wakeup_source *ws);
-extern struct wakeup_source *wakeup_source_register(const char *name);
+extern struct wakeup_source *wakeup_source_register(struct device *dev,
+						    const char *name);
 extern void wakeup_source_unregister(struct wakeup_source *ws);
 extern int device_wakeup_enable(struct device *dev);
 extern int device_wakeup_disable(struct device *dev);
@@ -122,7 +127,8 @@ static inline void wakeup_source_add(struct wakeup_source *ws) {}
 
 static inline void wakeup_source_remove(struct wakeup_source *ws) {}
 
-static inline struct wakeup_source *wakeup_source_register(const char *name)
+static inline struct wakeup_source *wakeup_source_register(struct device *dev,
+							   const char *name)
 {
 	return NULL;
 }

commit 0d105d0f25386ee5b74603db6d249ebed7590cbc
Author: Tri Vo <trong@android.com>
Date:   Tue Aug 6 18:48:44 2019 -0700

    PM / wakeup: Drop wakeup_source_init(), wakeup_source_prepare()
    
    wakeup_source_init() has no users. Remove it.
    
    As a result, wakeup_source_prepare() is only called from
    wakeup_source_create(). Merge wakeup_source_prepare() into
    wakeup_source_create() and remove it.
    
    Change wakeup_source_create() behavior so that assigning NULL to wakeup
    source's name throws an error.
    
    Signed-off-by: Tri Vo <trong@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 91027602d137..c0cad2d8f800 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -81,7 +81,6 @@ static inline void device_set_wakeup_path(struct device *dev)
 }
 
 /* drivers/base/power/wakeup.c */
-extern void wakeup_source_prepare(struct wakeup_source *ws, const char *name);
 extern struct wakeup_source *wakeup_source_create(const char *name);
 extern void wakeup_source_destroy(struct wakeup_source *ws);
 extern void wakeup_source_add(struct wakeup_source *ws);
@@ -112,9 +111,6 @@ static inline bool device_can_wakeup(struct device *dev)
 	return dev->power.can_wakeup;
 }
 
-static inline void wakeup_source_prepare(struct wakeup_source *ws,
-					 const char *name) {}
-
 static inline struct wakeup_source *wakeup_source_create(const char *name)
 {
 	return NULL;
@@ -181,13 +177,6 @@ static inline void pm_wakeup_dev_event(struct device *dev, unsigned int msec,
 
 #endif /* !CONFIG_PM_SLEEP */
 
-static inline void wakeup_source_init(struct wakeup_source *ws,
-				      const char *name)
-{
-	wakeup_source_prepare(ws, name);
-	wakeup_source_add(ws);
-}
-
 static inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 {
 	return pm_wakeup_ws_event(ws, msec, false);

commit e9bea8f98a539080070e3eff70a1731ce0ffdc8d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 19 00:48:15 2019 +0200

    PM: sleep: Update struct wakeup_source documentation
    
    The kerneldoc comment for struct wakeup_source has become outdated,
    so fix that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index ce57771fab9b..91027602d137 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -36,7 +36,7 @@ struct wake_irq;
  * @expire_count: Number of times the wakeup source's timeout has expired.
  * @wakeup_count: Number of times the wakeup source might abort suspend.
  * @active: Status of the wakeup source.
- * @has_timeout: The wakeup source has been activated with a timeout.
+ * @autosleep_enabled: Autosleep is active, so update @prevent_sleep_time.
  */
 struct wakeup_source {
 	const char 		*name;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 0ff134d6575a..ce57771fab9b 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -1,22 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  pm_wakeup.h - Power management wakeup interface
  *
  *  Copyright (C) 2008 Alan Stern
  *  Copyright (C) 2010 Rafael J. Wysocki, Novell Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef _LINUX_PM_WAKEUP_H

commit 623217a0cc45a6c179303b3bbfdc594806a464cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 11 12:53:59 2019 +0100

    PM / wakeup: Drop wakeup_source_drop()
    
    After commit d856f39ac1cc ("PM / wakeup: Rework wakeup source timer
    cancellation") wakeup_source_drop() is a trivial wrapper around
    __pm_relax() and it has no users except for wakeup_source_destroy()
    and wakeup_source_trash() which also has no users, so drop it along
    with the latter and make wakeup_source_destroy() call __pm_relax()
    directly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 4238dde0aaf0..0ff134d6575a 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -96,7 +96,6 @@ static inline void device_set_wakeup_path(struct device *dev)
 /* drivers/base/power/wakeup.c */
 extern void wakeup_source_prepare(struct wakeup_source *ws, const char *name);
 extern struct wakeup_source *wakeup_source_create(const char *name);
-extern void wakeup_source_drop(struct wakeup_source *ws);
 extern void wakeup_source_destroy(struct wakeup_source *ws);
 extern void wakeup_source_add(struct wakeup_source *ws);
 extern void wakeup_source_remove(struct wakeup_source *ws);
@@ -134,8 +133,6 @@ static inline struct wakeup_source *wakeup_source_create(const char *name)
 	return NULL;
 }
 
-static inline void wakeup_source_drop(struct wakeup_source *ws) {}
-
 static inline void wakeup_source_destroy(struct wakeup_source *ws) {}
 
 static inline void wakeup_source_add(struct wakeup_source *ws) {}
@@ -204,12 +201,6 @@ static inline void wakeup_source_init(struct wakeup_source *ws,
 	wakeup_source_add(ws);
 }
 
-static inline void wakeup_source_trash(struct wakeup_source *ws)
-{
-	wakeup_source_remove(ws);
-	wakeup_source_drop(ws);
-}
-
 static inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
 {
 	return pm_wakeup_ws_event(ws, msec, false);

commit cf04ce7841fabc7af0d6ee273711ec29658bee7b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jan 2 17:08:52 2018 +0100

    PM / wakeup: Add device_set_wakeup_path() helper to control wakeup path
    
    During system suspend, a driver may find that the wakeup setting is
    enabled for its device and therefore configures it to deliver system
    wakeup signals.
    
    Additionally, sometimes the driver and its device, relies on some
    further consumed resource, like an irqchip or a phy for example, to
    stay powered on, as to be able to deliver system wakeup signals.
    
    In general the driver deals with this, via raising an "enable count"
    of the consumed resource or via a subsystem specific API, like
    irq_set_irq_wake() or enable|disable_irq_wake() for an irqchip.
    However, this may not be sufficient in cases when the resource's
    device may be attached to a PM domain (genpd for example) or is
    handled by a non-trivial middle layer (PCI for example).
    
    To address cases like these, the existing ->dev.power.wakeup_path
    status flag is there to help.  As a matter of fact, genpd already
    monitors the flag during system suspend and acts accordingly.
    
    However, so far it has not been clear, if anybody else but the PM
    core is allowed to set the ->dev.power.wakeup_path status flag,
    which is required to make this work.  For this reason, introduce
    a new helper function, device_set_wakeup_path() for that.
    
    Typically, a driver that manages a resource needed in the wakeup path
    should call device_set_wakeup_path() from its ->suspend() or
    ->suspend_late() callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 4c2cba7ec1d4..4238dde0aaf0 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -88,6 +88,11 @@ static inline bool device_may_wakeup(struct device *dev)
 	return dev->power.can_wakeup && !!dev->power.wakeup;
 }
 
+static inline void device_set_wakeup_path(struct device *dev)
+{
+	dev->power.wakeup_path = true;
+}
+
 /* drivers/base/power/wakeup.c */
 extern void wakeup_source_prepare(struct wakeup_source *ws, const char *name);
 extern struct wakeup_source *wakeup_source_create(const char *name);
@@ -174,6 +179,8 @@ static inline bool device_may_wakeup(struct device *dev)
 	return dev->power.can_wakeup && dev->power.should_wakeup;
 }
 
+static inline void device_set_wakeup_path(struct device *dev) {}
+
 static inline void __pm_stay_awake(struct wakeup_source *ws) {}
 
 static inline void pm_stay_awake(struct device *dev) {}

commit 8a537ece3d946227e4afa81eae0e43fa47439c7d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:22:09 2017 +0200

    PM / wakeup: Integrate mechanism to abort transitions in progress
    
    The system wakeup framework is not very consistent with respect to
    the way it handles suspend-to-idle and generally wakeup events
    occurring during transitions to system low-power states.
    
    First off, system transitions in progress are aborted by the event
    reporting helpers like pm_wakeup_event() only if the wakeup_count
    sysfs attribute is in use (as documented), but there are cases in
    which system-wide transitions should be aborted even if that is
    not the case.  For example, a wakeup signal from a designated
    wakeup device during system-wide PM transition, it should cause
    the transition to be aborted right away.
    
    Moreover, there is a freeze_wake() call in wakeup_source_activate(),
    but that really is only effective after suspend_freeze_state has
    been set to FREEZE_STATE_ENTER by freeze_enter().  However, it
    is very unlikely that wakeup_source_activate() will ever be called
    at that time, as it could only be triggered by a IRQF_NO_SUSPEND
    interrupt handler, so wakeups from suspend-to-idle don't really
    occur in wakeup_source_activate().
    
    At the same time there is a way to abort a system suspend in
    progress (or wake up the system from suspend-to-idle), which is by
    calling pm_system_wakeup(), but in turn that doesn't cause any
    wakeup source objects to be activated, so it will not be covered
    by wakeup source statistics and will not prevent the system from
    suspending again immediately (in case autosleep is used, for
    example).  Consequently, if anyone wants to abort system transitions
    in progress and allow the wakeup_count mechanism to work, they need
    to use both pm_system_wakeup() and pm_wakeup_event(), say, at the
    same time which is awkward.
    
    For the above reasons, make it possible to trigger
    pm_system_wakeup() from within wakeup_source_activate() and
    provide a new pm_wakeup_hard_event() helper to do so within the
    wakeup framework.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index a3447932df1f..4c2cba7ec1d4 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -106,8 +106,8 @@ extern void __pm_stay_awake(struct wakeup_source *ws);
 extern void pm_stay_awake(struct device *dev);
 extern void __pm_relax(struct wakeup_source *ws);
 extern void pm_relax(struct device *dev);
-extern void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec);
-extern void pm_wakeup_event(struct device *dev, unsigned int msec);
+extern void pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard);
+extern void pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard);
 
 #else /* !CONFIG_PM_SLEEP */
 
@@ -182,9 +182,11 @@ static inline void __pm_relax(struct wakeup_source *ws) {}
 
 static inline void pm_relax(struct device *dev) {}
 
-static inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec) {}
+static inline void pm_wakeup_ws_event(struct wakeup_source *ws,
+				      unsigned int msec, bool hard) {}
 
-static inline void pm_wakeup_event(struct device *dev, unsigned int msec) {}
+static inline void pm_wakeup_dev_event(struct device *dev, unsigned int msec,
+				       bool hard) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
@@ -201,4 +203,19 @@ static inline void wakeup_source_trash(struct wakeup_source *ws)
 	wakeup_source_drop(ws);
 }
 
+static inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec)
+{
+	return pm_wakeup_ws_event(ws, msec, false);
+}
+
+static inline void pm_wakeup_event(struct device *dev, unsigned int msec)
+{
+	return pm_wakeup_dev_event(dev, msec, false);
+}
+
+static inline void pm_wakeup_hard_event(struct device *dev)
+{
+	return pm_wakeup_dev_event(dev, 0, true);
+}
+
 #endif /* _LINUX_PM_WAKEUP_H */

commit 4990d4fe327b9d9a7a3be7103a82699406fdde69
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 18 15:40:29 2015 -0700

    PM / Wakeirq: Add automated device wake IRQ handling
    
    Turns out we can automate the handling for the device_may_wakeup()
    quite a bit by using the kernel wakeup source list as suggested
    by Rafael J. Wysocki <rjw@rjwysocki.net>.
    
    And as some hardware has separate dedicated wake-up interrupt
    in addition to the IO interrupt, we can automate the handling by
    adding a generic threaded interrupt handler that just calls the
    device PM runtime to wake up the device.
    
    This allows dropping code from device drivers as we currently
    are doing it in multiple ways, and often wrong.
    
    For most drivers, we should be able to drop the following
    boilerplate code from runtime_suspend and runtime_resume
    functions:
    
            ...
            device_init_wakeup(dev, true);
            ...
            if (device_may_wakeup(dev))
                    enable_irq_wake(irq);
            ...
            if (device_may_wakeup(dev))
                    disable_irq_wake(irq);
            ...
            device_init_wakeup(dev, false);
            ...
    
    We can replace it with just the following init and exit
    time code:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    And for hardware with dedicated wake-up interrupts:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_dedicated_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index a0f70808d7f4..a3447932df1f 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -28,9 +28,17 @@
 
 #include <linux/types.h>
 
+struct wake_irq;
+
 /**
  * struct wakeup_source - Representation of wakeup sources
  *
+ * @name: Name of the wakeup source
+ * @entry: Wakeup source list entry
+ * @lock: Wakeup source lock
+ * @wakeirq: Optional device specific wakeirq
+ * @timer: Wakeup timer list
+ * @timer_expires: Wakeup timer expiration
  * @total_time: Total time this wakeup source has been active.
  * @max_time: Maximum time this wakeup source has been continuously active.
  * @last_time: Monotonic clock when the wakeup source's was touched last time.
@@ -47,6 +55,7 @@ struct wakeup_source {
 	const char 		*name;
 	struct list_head	entry;
 	spinlock_t		lock;
+	struct wake_irq		*wakeirq;
 	struct timer_list	timer;
 	unsigned long		timer_expires;
 	ktime_t total_time;

commit 1258ca805f613025ec079d959d4a78acfb1f79d3
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Thu Jul 11 13:55:58 2013 +0900

    PM / Sleep: Fix comment typo in pm_wakeup.h
    
    Fix a comment typo (sorce -> source) in pm_wakeup.h.
    
    [rjw: Changelog]
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 569781faa504..a0f70808d7f4 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -36,8 +36,8 @@
  * @last_time: Monotonic clock when the wakeup source's was touched last time.
  * @prevent_sleep_time: Total time this source has been preventing autosleep.
  * @event_count: Number of signaled wakeup events.
- * @active_count: Number of times the wakeup sorce was activated.
- * @relax_count: Number of times the wakeup sorce was deactivated.
+ * @active_count: Number of times the wakeup source was activated.
+ * @relax_count: Number of times the wakeup source was deactivated.
  * @expire_count: Number of times the wakeup source's timeout has expired.
  * @wakeup_count: Number of times the wakeup source might abort suspend.
  * @active: Status of the wakeup source.

commit 55850945e872531644f31fefd217d61dd15dcab8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:32 2012 +0200

    PM / Sleep: Add "prevent autosleep time" statistics to wakeup sources
    
    Android uses one wakelock statistics that is only necessary for
    opportunistic sleep.  Namely, the prevent_suspend_time field
    accumulates the total time the given wakelock has been locked
    while "automatic suspend" was enabled.  Add an analogous field,
    prevent_sleep_time, to wakeup sources and make it behave in a similar
    way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 5285317a612a..569781faa504 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -34,6 +34,7 @@
  * @total_time: Total time this wakeup source has been active.
  * @max_time: Maximum time this wakeup source has been continuously active.
  * @last_time: Monotonic clock when the wakeup source's was touched last time.
+ * @prevent_sleep_time: Total time this source has been preventing autosleep.
  * @event_count: Number of signaled wakeup events.
  * @active_count: Number of times the wakeup sorce was activated.
  * @relax_count: Number of times the wakeup sorce was deactivated.
@@ -51,12 +52,15 @@ struct wakeup_source {
 	ktime_t total_time;
 	ktime_t max_time;
 	ktime_t last_time;
+	ktime_t start_prevent_time;
+	ktime_t prevent_sleep_time;
 	unsigned long		event_count;
 	unsigned long		active_count;
 	unsigned long		relax_count;
 	unsigned long		expire_count;
 	unsigned long		wakeup_count;
 	bool			active:1;
+	bool			autosleep_enabled:1;
 };
 
 #ifdef CONFIG_PM_SLEEP

commit 30e3ce6dcbe3fc29c343b17e768b07d4a795de21
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:52:52 2012 +0200

    PM / Sleep: Change wakeup source statistics to follow Android
    
    Wakeup statistics used by Android are slightly different from what we
    have in wakeup sources at the moment and there aren't any known
    users of those statistics other than Android, so modify them to make
    it easier for Android to switch to wakeup sources.
    
    This removes the struct wakeup_source's hit_cout field, which is very
    rough and therefore not very useful, and adds two new fields,
    wakeup_count and expire_count.  The first one tracks how many times
    the wakeup source is activated with events_check_enabled set (which
    roughly corresponds to the situations when a system power transition
    to a sleep state is in progress and would be aborted by this wakeup
    source if it were the only active one at that time) and the second
    one is the number of times the wakeup source has been activated with
    a timeout that expired.
    
    Additionally, the last_time field is now updated when the wakeup
    source is deactivated too (previously it was only updated during
    the wakeup source's activation), which seems to be what Android does
    with the analogous counter for wakelocks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index d9f05113e5fb..5285317a612a 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -33,12 +33,14 @@
  *
  * @total_time: Total time this wakeup source has been active.
  * @max_time: Maximum time this wakeup source has been continuously active.
- * @last_time: Monotonic clock when the wakeup source's was activated last time.
+ * @last_time: Monotonic clock when the wakeup source's was touched last time.
  * @event_count: Number of signaled wakeup events.
  * @active_count: Number of times the wakeup sorce was activated.
  * @relax_count: Number of times the wakeup sorce was deactivated.
- * @hit_count: Number of times the wakeup sorce might abort system suspend.
+ * @expire_count: Number of times the wakeup source's timeout has expired.
+ * @wakeup_count: Number of times the wakeup source might abort suspend.
  * @active: Status of the wakeup source.
+ * @has_timeout: The wakeup source has been activated with a timeout.
  */
 struct wakeup_source {
 	const char 		*name;
@@ -52,8 +54,9 @@ struct wakeup_source {
 	unsigned long		event_count;
 	unsigned long		active_count;
 	unsigned long		relax_count;
-	unsigned long		hit_count;
-	unsigned int		active:1;
+	unsigned long		expire_count;
+	unsigned long		wakeup_count;
+	bool			active:1;
 };
 
 #ifdef CONFIG_PM_SLEEP

commit 8671bbc1bd0442ef0eab27f7d56216431c490820
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 21 23:47:56 2012 +0100

    PM / Sleep: Add more wakeup source initialization routines
    
    The existing wakeup source initialization routines are not
    particularly useful for wakeup sources that aren't created by
    wakeup_source_create(), because their users have to open code
    filling the objects with zeros and setting their names.  For this
    reason, introduce routines that can be used for initializing, for
    example, static wakeup source objects.
    
    Requested-by: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index a32da962d693..d9f05113e5fb 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -41,7 +41,7 @@
  * @active: Status of the wakeup source.
  */
 struct wakeup_source {
-	char 			*name;
+	const char 		*name;
 	struct list_head	entry;
 	spinlock_t		lock;
 	struct timer_list	timer;
@@ -73,7 +73,9 @@ static inline bool device_may_wakeup(struct device *dev)
 }
 
 /* drivers/base/power/wakeup.c */
+extern void wakeup_source_prepare(struct wakeup_source *ws, const char *name);
 extern struct wakeup_source *wakeup_source_create(const char *name);
+extern void wakeup_source_drop(struct wakeup_source *ws);
 extern void wakeup_source_destroy(struct wakeup_source *ws);
 extern void wakeup_source_add(struct wakeup_source *ws);
 extern void wakeup_source_remove(struct wakeup_source *ws);
@@ -103,11 +105,16 @@ static inline bool device_can_wakeup(struct device *dev)
 	return dev->power.can_wakeup;
 }
 
+static inline void wakeup_source_prepare(struct wakeup_source *ws,
+					 const char *name) {}
+
 static inline struct wakeup_source *wakeup_source_create(const char *name)
 {
 	return NULL;
 }
 
+static inline void wakeup_source_drop(struct wakeup_source *ws) {}
+
 static inline void wakeup_source_destroy(struct wakeup_source *ws) {}
 
 static inline void wakeup_source_add(struct wakeup_source *ws) {}
@@ -165,4 +172,17 @@ static inline void pm_wakeup_event(struct device *dev, unsigned int msec) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+static inline void wakeup_source_init(struct wakeup_source *ws,
+				      const char *name)
+{
+	wakeup_source_prepare(ws, name);
+	wakeup_source_add(ws);
+}
+
+static inline void wakeup_source_trash(struct wakeup_source *ws)
+{
+	wakeup_source_remove(ws);
+	wakeup_source_drop(ws);
+}
+
 #endif /* _LINUX_PM_WAKEUP_H */

commit cb8f51bdadb7969139c2e39c2defd4cde98c1ea8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:26:02 2011 +0100

    PM: Do not create wakeup sysfs files for devices that cannot wake up
    
    Currently, wakeup sysfs attributes are created for all devices,
    regardless of whether or not they are wakeup-capable.  This is
    excessive and complicates wakeup device identification from user
    space (i.e. to identify wakeup-capable devices user space has to read
    /sys/devices/.../power/wakeup for all devices and see if they are not
    empty).
    
    Fix this issue by avoiding to create wakeup sysfs files for devices
    that cannot wake up the system from sleep states (i.e. whose
    power.can_wakeup flags are unset during registration) and modify
    device_set_wakeup_capable() so that it adds (or removes) the relevant
    sysfs attributes if a device's wakeup capability status is changed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 03a67db03d01..a32da962d693 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -62,18 +62,11 @@ struct wakeup_source {
  * Changes to device_may_wakeup take effect on the next pm state change.
  */
 
-static inline void device_set_wakeup_capable(struct device *dev, bool capable)
-{
-	dev->power.can_wakeup = capable;
-}
-
 static inline bool device_can_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup;
 }
 
-
-
 static inline bool device_may_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup && !!dev->power.wakeup;
@@ -88,6 +81,7 @@ extern struct wakeup_source *wakeup_source_register(const char *name);
 extern void wakeup_source_unregister(struct wakeup_source *ws);
 extern int device_wakeup_enable(struct device *dev);
 extern int device_wakeup_disable(struct device *dev);
+extern void device_set_wakeup_capable(struct device *dev, bool capable);
 extern int device_init_wakeup(struct device *dev, bool val);
 extern int device_set_wakeup_enable(struct device *dev, bool enable);
 extern void __pm_stay_awake(struct wakeup_source *ws);

commit 805bdaec1a44155db35f6ee5410d6bbc365324a8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Feb 24 11:10:01 2011 +0100

    PM: Make ACPI wakeup from S5 work again when CONFIG_PM_SLEEP is unset
    
    Commit 074037e (PM / Wakeup: Introduce wakeup source objects and
    event statistics (v3)) caused ACPI wakeup to only work if
    CONFIG_PM_SLEEP is set, but it also worked for CONFIG_PM_SLEEP unset
    before.  This can be fixed by making device_set_wakeup_enable(),
    device_init_wakeup() and device_may_wakeup() work in the same way
    as before commit 074037e when CONFIG_PM_SLEEP is unset.
    
    Reported-and-tested-by: Justin Maggard <jmaggard10@gmail.com>
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 9cff00dd6b63..03a67db03d01 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -109,11 +109,6 @@ static inline bool device_can_wakeup(struct device *dev)
 	return dev->power.can_wakeup;
 }
 
-static inline bool device_may_wakeup(struct device *dev)
-{
-	return false;
-}
-
 static inline struct wakeup_source *wakeup_source_create(const char *name)
 {
 	return NULL;
@@ -134,24 +129,32 @@ static inline void wakeup_source_unregister(struct wakeup_source *ws) {}
 
 static inline int device_wakeup_enable(struct device *dev)
 {
-	return -EINVAL;
+	dev->power.should_wakeup = true;
+	return 0;
 }
 
 static inline int device_wakeup_disable(struct device *dev)
 {
+	dev->power.should_wakeup = false;
 	return 0;
 }
 
-static inline int device_init_wakeup(struct device *dev, bool val)
+static inline int device_set_wakeup_enable(struct device *dev, bool enable)
 {
-	dev->power.can_wakeup = val;
-	return val ? -EINVAL : 0;
+	dev->power.should_wakeup = enable;
+	return 0;
 }
 
+static inline int device_init_wakeup(struct device *dev, bool val)
+{
+	device_set_wakeup_capable(dev, val);
+	device_set_wakeup_enable(dev, val);
+	return 0;
+}
 
-static inline int device_set_wakeup_enable(struct device *dev, bool enable)
+static inline bool device_may_wakeup(struct device *dev)
 {
-	return -EINVAL;
+	return dev->power.can_wakeup && dev->power.should_wakeup;
 }
 
 static inline void __pm_stay_awake(struct wakeup_source *ws) {}

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 76aca48722ae..9cff00dd6b63 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -2,6 +2,7 @@
  *  pm_wakeup.h - Power management wakeup interface
  *
  *  Copyright (C) 2008 Alan Stern
+ *  Copyright (C) 2010 Rafael J. Wysocki, Novell Inc.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -27,19 +28,77 @@
 
 #include <linux/types.h>
 
-#ifdef CONFIG_PM
-
-/* Changes to device_may_wakeup take effect on the next pm state change.
+/**
+ * struct wakeup_source - Representation of wakeup sources
  *
- * By default, most devices should leave wakeup disabled.  The exceptions
- * are devices that everyone expects to be wakeup sources: keyboards,
- * power buttons, possibly network interfaces, etc.
+ * @total_time: Total time this wakeup source has been active.
+ * @max_time: Maximum time this wakeup source has been continuously active.
+ * @last_time: Monotonic clock when the wakeup source's was activated last time.
+ * @event_count: Number of signaled wakeup events.
+ * @active_count: Number of times the wakeup sorce was activated.
+ * @relax_count: Number of times the wakeup sorce was deactivated.
+ * @hit_count: Number of times the wakeup sorce might abort system suspend.
+ * @active: Status of the wakeup source.
  */
-static inline void device_init_wakeup(struct device *dev, bool val)
+struct wakeup_source {
+	char 			*name;
+	struct list_head	entry;
+	spinlock_t		lock;
+	struct timer_list	timer;
+	unsigned long		timer_expires;
+	ktime_t total_time;
+	ktime_t max_time;
+	ktime_t last_time;
+	unsigned long		event_count;
+	unsigned long		active_count;
+	unsigned long		relax_count;
+	unsigned long		hit_count;
+	unsigned int		active:1;
+};
+
+#ifdef CONFIG_PM_SLEEP
+
+/*
+ * Changes to device_may_wakeup take effect on the next pm state change.
+ */
+
+static inline void device_set_wakeup_capable(struct device *dev, bool capable)
+{
+	dev->power.can_wakeup = capable;
+}
+
+static inline bool device_can_wakeup(struct device *dev)
+{
+	return dev->power.can_wakeup;
+}
+
+
+
+static inline bool device_may_wakeup(struct device *dev)
 {
-	dev->power.can_wakeup = dev->power.should_wakeup = val;
+	return dev->power.can_wakeup && !!dev->power.wakeup;
 }
 
+/* drivers/base/power/wakeup.c */
+extern struct wakeup_source *wakeup_source_create(const char *name);
+extern void wakeup_source_destroy(struct wakeup_source *ws);
+extern void wakeup_source_add(struct wakeup_source *ws);
+extern void wakeup_source_remove(struct wakeup_source *ws);
+extern struct wakeup_source *wakeup_source_register(const char *name);
+extern void wakeup_source_unregister(struct wakeup_source *ws);
+extern int device_wakeup_enable(struct device *dev);
+extern int device_wakeup_disable(struct device *dev);
+extern int device_init_wakeup(struct device *dev, bool val);
+extern int device_set_wakeup_enable(struct device *dev, bool enable);
+extern void __pm_stay_awake(struct wakeup_source *ws);
+extern void pm_stay_awake(struct device *dev);
+extern void __pm_relax(struct wakeup_source *ws);
+extern void pm_relax(struct device *dev);
+extern void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec);
+extern void pm_wakeup_event(struct device *dev, unsigned int msec);
+
+#else /* !CONFIG_PM_SLEEP */
+
 static inline void device_set_wakeup_capable(struct device *dev, bool capable)
 {
 	dev->power.can_wakeup = capable;
@@ -50,43 +109,63 @@ static inline bool device_can_wakeup(struct device *dev)
 	return dev->power.can_wakeup;
 }
 
-static inline void device_set_wakeup_enable(struct device *dev, bool enable)
+static inline bool device_may_wakeup(struct device *dev)
 {
-	dev->power.should_wakeup = enable;
+	return false;
 }
 
-static inline bool device_may_wakeup(struct device *dev)
+static inline struct wakeup_source *wakeup_source_create(const char *name)
 {
-	return dev->power.can_wakeup && dev->power.should_wakeup;
+	return NULL;
 }
 
-#else /* !CONFIG_PM */
+static inline void wakeup_source_destroy(struct wakeup_source *ws) {}
+
+static inline void wakeup_source_add(struct wakeup_source *ws) {}
 
-/* For some reason the following routines work even without CONFIG_PM */
-static inline void device_init_wakeup(struct device *dev, bool val)
+static inline void wakeup_source_remove(struct wakeup_source *ws) {}
+
+static inline struct wakeup_source *wakeup_source_register(const char *name)
 {
-	dev->power.can_wakeup = val;
+	return NULL;
 }
 
-static inline void device_set_wakeup_capable(struct device *dev, bool capable)
+static inline void wakeup_source_unregister(struct wakeup_source *ws) {}
+
+static inline int device_wakeup_enable(struct device *dev)
 {
-	dev->power.can_wakeup = capable;
+	return -EINVAL;
 }
 
-static inline bool device_can_wakeup(struct device *dev)
+static inline int device_wakeup_disable(struct device *dev)
 {
-	return dev->power.can_wakeup;
+	return 0;
 }
 
-static inline void device_set_wakeup_enable(struct device *dev, bool enable)
+static inline int device_init_wakeup(struct device *dev, bool val)
 {
+	dev->power.can_wakeup = val;
+	return val ? -EINVAL : 0;
 }
 
-static inline bool device_may_wakeup(struct device *dev)
+
+static inline int device_set_wakeup_enable(struct device *dev, bool enable)
 {
-	return false;
+	return -EINVAL;
 }
 
-#endif /* !CONFIG_PM */
+static inline void __pm_stay_awake(struct wakeup_source *ws) {}
+
+static inline void pm_stay_awake(struct device *dev) {}
+
+static inline void __pm_relax(struct wakeup_source *ws) {}
+
+static inline void pm_relax(struct device *dev) {}
+
+static inline void __pm_wakeup_event(struct wakeup_source *ws, unsigned int msec) {}
+
+static inline void pm_wakeup_event(struct device *dev, unsigned int msec) {}
+
+#endif /* !CONFIG_PM_SLEEP */
 
 #endif /* _LINUX_PM_WAKEUP_H */

commit 2430d12c94ff2bafcfe4f65edf7ee5f300d2d9c6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun Jun 13 00:36:52 2010 +0200

    PM: describe kernel policy regarding wakeup defaults (v. 2)
    
    This patch (as1381b) updates a comment describing the kernel's policy
    toward enabling wakeup by default.
    
    It also makes device_set_wakeup_capable() actually do something when
    CONFIG_PM isn't enabled.  It's not clear this is necessary; however if
    it isn't then device_init_wakeup() and device_can_wakeup() should also
    be do-nothing routines.  Furthermore, I don't expect this change to
    have any noticeable effect -- but if it does then clearly the old
    behavior was wrong.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 22d64c18056c..76aca48722ae 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -29,8 +29,11 @@
 
 #ifdef CONFIG_PM
 
-/* changes to device_may_wakeup take effect on the next pm state change.
- * by default, devices should wakeup if they can.
+/* Changes to device_may_wakeup take effect on the next pm state change.
+ *
+ * By default, most devices should leave wakeup disabled.  The exceptions
+ * are devices that everyone expects to be wakeup sources: keyboards,
+ * power buttons, possibly network interfaces, etc.
  */
 static inline void device_init_wakeup(struct device *dev, bool val)
 {
@@ -59,7 +62,7 @@ static inline bool device_may_wakeup(struct device *dev)
 
 #else /* !CONFIG_PM */
 
-/* For some reason the next two routines work even without CONFIG_PM */
+/* For some reason the following routines work even without CONFIG_PM */
 static inline void device_init_wakeup(struct device *dev, bool val)
 {
 	dev->power.can_wakeup = val;
@@ -67,6 +70,7 @@ static inline void device_init_wakeup(struct device *dev, bool val)
 
 static inline void device_set_wakeup_capable(struct device *dev, bool capable)
 {
+	dev->power.can_wakeup = capable;
 }
 
 static inline bool device_can_wakeup(struct device *dev)

commit 228c54ef7a028d5a4b6606eb0c8035874d9b6788
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Mar 15 21:44:41 2010 +0100

    PM: pm_wakeup - switch to using bool
    
    Also change couple of stubs implemented as macros in !CONFIG_PM case
    in statinc inline functions to provide proper typechecking of
    arguments regardless of config.
    
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 0aae7776185e..22d64c18056c 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -25,32 +25,34 @@
 # error "please don't include this file directly"
 #endif
 
+#include <linux/types.h>
+
 #ifdef CONFIG_PM
 
 /* changes to device_may_wakeup take effect on the next pm state change.
  * by default, devices should wakeup if they can.
  */
-static inline void device_init_wakeup(struct device *dev, int val)
+static inline void device_init_wakeup(struct device *dev, bool val)
 {
-	dev->power.can_wakeup = dev->power.should_wakeup = !!val;
+	dev->power.can_wakeup = dev->power.should_wakeup = val;
 }
 
-static inline void device_set_wakeup_capable(struct device *dev, int val)
+static inline void device_set_wakeup_capable(struct device *dev, bool capable)
 {
-	dev->power.can_wakeup = !!val;
+	dev->power.can_wakeup = capable;
 }
 
-static inline int device_can_wakeup(struct device *dev)
+static inline bool device_can_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup;
 }
 
-static inline void device_set_wakeup_enable(struct device *dev, int val)
+static inline void device_set_wakeup_enable(struct device *dev, bool enable)
 {
-	dev->power.should_wakeup = !!val;
+	dev->power.should_wakeup = enable;
 }
 
-static inline int device_may_wakeup(struct device *dev)
+static inline bool device_may_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup && dev->power.should_wakeup;
 }
@@ -58,20 +60,28 @@ static inline int device_may_wakeup(struct device *dev)
 #else /* !CONFIG_PM */
 
 /* For some reason the next two routines work even without CONFIG_PM */
-static inline void device_init_wakeup(struct device *dev, int val)
+static inline void device_init_wakeup(struct device *dev, bool val)
 {
-	dev->power.can_wakeup = !!val;
+	dev->power.can_wakeup = val;
 }
 
-static inline void device_set_wakeup_capable(struct device *dev, int val) { }
+static inline void device_set_wakeup_capable(struct device *dev, bool capable)
+{
+}
 
-static inline int device_can_wakeup(struct device *dev)
+static inline bool device_can_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup;
 }
 
-#define device_set_wakeup_enable(dev, val)	do {} while (0)
-#define device_may_wakeup(dev)			0
+static inline void device_set_wakeup_enable(struct device *dev, bool enable)
+{
+}
+
+static inline bool device_may_wakeup(struct device *dev)
+{
+	return false;
+}
 
 #endif /* !CONFIG_PM */
 

commit c300bd2fb583afb6d68804afd38bc90b31310d95
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Jul 10 02:16:44 2008 +0200

    PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
    
    drivers/pci/pci.c needs pm_wakeup.h since it uses device_set_wakup_capable().
    The latter also needs to be stubbed out for !CONFIG_PM.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index 3af0c8d05cdc..0aae7776185e 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -63,6 +63,8 @@ static inline void device_init_wakeup(struct device *dev, int val)
 	dev->power.can_wakeup = !!val;
 }
 
+static inline void device_set_wakeup_capable(struct device *dev, int val) { }
+
 static inline int device_can_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup;

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index f0d0b2cb8d20..3af0c8d05cdc 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -35,6 +35,11 @@ static inline void device_init_wakeup(struct device *dev, int val)
 	dev->power.can_wakeup = dev->power.should_wakeup = !!val;
 }
 
+static inline void device_set_wakeup_capable(struct device *dev, int val)
+{
+	dev->power.can_wakeup = !!val;
+}
+
 static inline int device_can_wakeup(struct device *dev)
 {
 	return dev->power.can_wakeup;
@@ -47,21 +52,7 @@ static inline void device_set_wakeup_enable(struct device *dev, int val)
 
 static inline int device_may_wakeup(struct device *dev)
 {
-	return dev->power.can_wakeup & dev->power.should_wakeup;
-}
-
-/*
- * Platform hook to activate device wakeup capability, if that's not already
- * handled by enable_irq_wake() etc.
- * Returns zero on success, else negative errno
- */
-extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
-
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	if (platform_enable_wakeup)
-		return (*platform_enable_wakeup)(dev, is_on);
-	return 0;
+	return dev->power.can_wakeup && dev->power.should_wakeup;
 }
 
 #else /* !CONFIG_PM */
@@ -80,11 +71,6 @@ static inline int device_can_wakeup(struct device *dev)
 #define device_set_wakeup_enable(dev, val)	do {} while (0)
 #define device_may_wakeup(dev)			0
 
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	return 0;
-}
-
 #endif /* !CONFIG_PM */
 
 #endif /* _LINUX_PM_WAKEUP_H */

commit 9a3df1f7de0ecaf77a1dde86f2a4dc020f37f87e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 19 22:39:13 2008 +0100

    PM: Convert wakeup flag accessors to inline functions
    
    This patch (as1058) improves the wakeup macros in include/linux/pm.h.
    All but the trivial ones are converted to inline routines, which
    requires moving them to a separate header file since they depend on
    the definition of struct device.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
new file mode 100644
index 000000000000..f0d0b2cb8d20
--- /dev/null
+++ b/include/linux/pm_wakeup.h
@@ -0,0 +1,90 @@
+/*
+ *  pm_wakeup.h - Power management wakeup interface
+ *
+ *  Copyright (C) 2008 Alan Stern
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_PM_WAKEUP_H
+#define _LINUX_PM_WAKEUP_H
+
+#ifndef _DEVICE_H_
+# error "please don't include this file directly"
+#endif
+
+#ifdef CONFIG_PM
+
+/* changes to device_may_wakeup take effect on the next pm state change.
+ * by default, devices should wakeup if they can.
+ */
+static inline void device_init_wakeup(struct device *dev, int val)
+{
+	dev->power.can_wakeup = dev->power.should_wakeup = !!val;
+}
+
+static inline int device_can_wakeup(struct device *dev)
+{
+	return dev->power.can_wakeup;
+}
+
+static inline void device_set_wakeup_enable(struct device *dev, int val)
+{
+	dev->power.should_wakeup = !!val;
+}
+
+static inline int device_may_wakeup(struct device *dev)
+{
+	return dev->power.can_wakeup & dev->power.should_wakeup;
+}
+
+/*
+ * Platform hook to activate device wakeup capability, if that's not already
+ * handled by enable_irq_wake() etc.
+ * Returns zero on success, else negative errno
+ */
+extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
+
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	if (platform_enable_wakeup)
+		return (*platform_enable_wakeup)(dev, is_on);
+	return 0;
+}
+
+#else /* !CONFIG_PM */
+
+/* For some reason the next two routines work even without CONFIG_PM */
+static inline void device_init_wakeup(struct device *dev, int val)
+{
+	dev->power.can_wakeup = !!val;
+}
+
+static inline int device_can_wakeup(struct device *dev)
+{
+	return dev->power.can_wakeup;
+}
+
+#define device_set_wakeup_enable(dev, val)	do {} while (0)
+#define device_may_wakeup(dev)			0
+
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	return 0;
+}
+
+#endif /* !CONFIG_PM */
+
+#endif /* _LINUX_PM_WAKEUP_H */
