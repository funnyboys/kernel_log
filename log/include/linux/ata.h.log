commit c82ee6d3beaa489058c1fe1ca710042a07df9d40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:48 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 18
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program see
      the file copying if not write to the free software foundation 675
      mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 52 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154042.342335923@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 40d150ad7e07..6e67aded28f8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -1,29 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 
 /*
  *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
  *  Copyright 2003-2004 Jeff Garzik
  *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
  *  libata documentation is available via 'make {ps|pdf}docs',
  *  as Documentation/driver-api/libata.rst
  *
  *  Hardware documentation available from http://www.t13.org/
- *
  */
 
 #ifndef __LINUX_ATA_H__

commit d5c15c2c22a8d4e0e82ca95eac5a6ccd175c0762
Author: chenxiang <chenxiang66@hisilicon.com>
Date:   Thu Dec 28 18:20:46 2017 +0800

    scsi: ata: enhance the definition of SET MAX feature field value
    
    There are two other values for SET MAX feature field according to ata
    protocol. So definite them.
    
    Signed-off-by: Xiang Chen <chenxiang66@hisilicon.com>
    Signed-off-by: John Garry <john.garry@huawei.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c7a353825450..40d150ad7e07 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -448,6 +448,8 @@ enum {
 	ATA_SET_MAX_LOCK	= 0x02,
 	ATA_SET_MAX_UNLOCK	= 0x03,
 	ATA_SET_MAX_FREEZE_LOCK	= 0x04,
+	ATA_SET_MAX_PASSWD_DMA	= 0x05,
+	ATA_SET_MAX_UNLOCK_DMA	= 0x06,
 
 	/* feature values for DEVICE CONFIGURATION OVERLAY */
 	ATA_DCO_RESTORE		= 0xC0,

commit e8f11db956aa09c1618051a7aaf367d6810d8d8c
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 29 14:42:06 2017 +0200

    libata: check for trusted computing in IDENTIFY DEVICE data
    
    ATA-8 and later mirrors the TRUSTED COMPUTING SUPPORTED bit in word 48 of
    the IDENTIFY DEVICE data.  Check this before issuing a READ LOG PAGE
    command to avoid issues with buggy devices.  The only downside is that
    we can't support Security Send / Receive for a device with an older
    revision due to the conflicting use of this field in earlier
    specifications.
    
    tj: The reason we need this is because some devices which don't
        support READ LOG PAGE lock up after getting issued that command.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e65ae4b2ed48..c7a353825450 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -60,7 +60,8 @@ enum {
 	ATA_ID_FW_REV		= 23,
 	ATA_ID_PROD		= 27,
 	ATA_ID_MAX_MULTSECT	= 47,
-	ATA_ID_DWORD_IO		= 48,
+	ATA_ID_DWORD_IO		= 48,	/* before ATA-8 */
+	ATA_ID_TRUSTED		= 48,	/* ATA-8 and later */
 	ATA_ID_CAPABILITY	= 49,
 	ATA_ID_OLD_PIO_MODES	= 51,
 	ATA_ID_OLD_DMA_MODES	= 52,
@@ -889,6 +890,13 @@ static inline bool ata_id_has_dword_io(const u16 *id)
 	return id[ATA_ID_DWORD_IO] & (1 << 0);
 }
 
+static inline bool ata_id_has_trusted(const u16 *id)
+{
+	if (ata_id_major_version(id) <= 7)
+		return false;
+	return id[ATA_ID_TRUSTED] & (1 << 0);
+}
+
 static inline bool ata_id_has_unload(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&

commit 818831c8b22f75353f59a63a484e20736c0567c9
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 4 14:42:24 2017 +0200

    libata: implement SECURITY PROTOCOL IN/OUT
    
    This allows us to use the generic OPAL code with ATA devices.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c14bdcf31fdb..e65ae4b2ed48 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -341,6 +341,7 @@ enum {
 	ATA_LOG_IDENTIFY_DEVICE	= 0x30,
 
 	/* Identify device log pages: */
+	ATA_LOG_SECURITY	  = 0x06,
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
 	ATA_LOG_ZONED_INFORMATION = 0x09,
 

commit 1d51d5f3907abf86ef0521971bcddf5853564263
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 4 14:42:22 2017 +0200

    libata: clarify log page naming / grouping
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 73fe18edfdaf..c14bdcf31fdb 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -336,11 +336,15 @@ enum {
 	/* READ_LOG_EXT pages */
 	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,
-	ATA_LOG_NCQ_NON_DATA	  = 0x12,
-	ATA_LOG_NCQ_SEND_RECV	  = 0x13,
-	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
+	ATA_LOG_NCQ_NON_DATA	= 0x12,
+	ATA_LOG_NCQ_SEND_RECV	= 0x13,
+	ATA_LOG_IDENTIFY_DEVICE	= 0x30,
+
+	/* Identify device log pages: */
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
 	ATA_LOG_ZONED_INFORMATION = 0x09,
+
+	/* Identify device SATA settings log:*/
 	ATA_LOG_DEVSLP_OFFSET	  = 0x30,
 	ATA_LOG_DEVSLP_SIZE	  = 0x08,
 	ATA_LOG_DEVSLP_MDAT	  = 0x00,

commit 9bb9a39ce51eae886575251e87d9292f679e3e32
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue May 16 09:16:37 2017 -0300

    ata: update references for libata documentation
    
    The libata documentation is now using ReST. Update references
    to it to point to the new place.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ad7d9ee89ff0..73fe18edfdaf 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -20,7 +20,7 @@
  *
  *
  *  libata documentation is available via 'make {ps|pdf}docs',
- *  as Documentation/DocBook/libata.*
+ *  as Documentation/driver-api/libata.rst
  *
  *  Hardware documentation available from http://www.t13.org/
  *

commit 63ccc191649eb0f14a761074291551d0d2f85389
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 25 14:26:52 2017 +0200

    libata: remove SCT WRITE SAME support
    
    This was already disabled a while ago because it caused I/O errors,
    and it's severly getting into the way of the discard / write zeroes
    rework.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index af6859b3a93d..ad7d9ee89ff0 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -817,11 +817,6 @@ static inline bool ata_id_sct_error_recovery_ctrl(const u16 *id)
 	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 3) ? true : false;
 }
 
-static inline bool ata_id_sct_write_same(const u16 *id)
-{
-	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 2) ? true : false;
-}
-
 static inline bool ata_id_sct_long_sector_access(const u16 *id)
 {
 	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 1) ? true : false;

commit 8e061784b51ec4a4efed0deaafb5bd9725bf5b06
Author: Adam Manzanares <adam.manzanares@hgst.com>
Date:   Mon Oct 17 11:27:29 2016 -0700

    ata: Enabling ATA Command Priorities
    
    This patch checks to see if an ATA device supports NCQ command priorities.
    If so and the user has specified an iocontext that indicates
    IO_PRIO_CLASS_RT then we build a tf with a high priority command.
    
    This is done to improve the tail latency of commands that are high
    priority by passing priority to the device.
    
    tj: Removed trivial ata_ncq_prio_enabled() and open-coded the test.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@hgst.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index fdb180367ba1..af6859b3a93d 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -348,6 +348,7 @@ enum {
 	ATA_LOG_DEVSLP_DETO	  = 0x01,
 	ATA_LOG_DEVSLP_VALID	  = 0x07,
 	ATA_LOG_DEVSLP_VALID_MASK = 0x80,
+	ATA_LOG_NCQ_PRIO_OFFSET   = 0x09,
 
 	/* NCQ send and receive log */
 	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET	= 0x00,
@@ -940,6 +941,11 @@ static inline bool ata_id_has_ncq_non_data(const u16 *id)
 	return id[ATA_ID_SATA_CAPABILITY_2] & BIT(5);
 }
 
+static inline bool ata_id_has_ncq_prio(const u16 *id)
+{
+	return id[ATA_ID_SATA_CAPABILITY] & BIT(12);
+}
+
 static inline bool ata_id_has_trim(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&

commit 7b20309428598df00ffeb0b01f5948dea6aaf1f7
Author: Shaun Tancheff <shaun@tancheff.com>
Date:   Sun Aug 21 23:23:19 2016 -0500

    libata: Add support for SCT Write Same
    
    SATA drives may support write same via SCT. This is useful
    for setting the drive contents to a specific pattern (0's).
    
    Translate a SCSI WRITE SAME 16 command to be either a DSM TRIM
    command or an SCT Write Same command.
    
    Based on the UNMAP flag:
      - When set translate to DSM TRIM
      - When not set translate to SCT Write Same
    
    Signed-off-by: Shaun Tancheff <shaun.tancheff@seagate.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 45a1d71c55f1..fdb180367ba1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -105,6 +105,7 @@ enum {
 	ATA_ID_CFA_KEY_MGMT	= 162,
 	ATA_ID_CFA_MODES	= 163,
 	ATA_ID_DATA_SET_MGMT	= 169,
+	ATA_ID_SCT_CMD_XPORT	= 206,
 	ATA_ID_ROT_SPEED	= 217,
 	ATA_ID_PIO4		= (1 << 1),
 
@@ -788,6 +789,48 @@ static inline bool ata_id_sense_reporting_enabled(const u16 *id)
 	return id[ATA_ID_COMMAND_SET_4] & (1 << 6);
 }
 
+/**
+ *
+ * Word: 206 - SCT Command Transport
+ *    15:12 - Vendor Specific
+ *     11:6 - Reserved
+ *        5 - SCT Command Transport Data Tables supported
+ *        4 - SCT Command Transport Features Control supported
+ *        3 - SCT Command Transport Error Recovery Control supported
+ *        2 - SCT Command Transport Write Same supported
+ *        1 - SCT Command Transport Long Sector Access supported
+ *        0 - SCT Command Transport supported
+ */
+static inline bool ata_id_sct_data_tables(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 5) ? true : false;
+}
+
+static inline bool ata_id_sct_features_ctrl(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 4) ? true : false;
+}
+
+static inline bool ata_id_sct_error_recovery_ctrl(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 3) ? true : false;
+}
+
+static inline bool ata_id_sct_write_same(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 2) ? true : false;
+}
+
+static inline bool ata_id_sct_long_sector_access(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 1) ? true : false;
+}
+
+static inline bool ata_id_sct_supported(const u16 *id)
+{
+	return id[ATA_ID_SCT_CMD_XPORT] & (1 << 0) ? true : false;
+}
+
 /**
  *	ata_id_major_version	-	get ATA level of drive
  *	@id: Identify data

commit 9379e6b8e0f995365dc6158a1463c8dab4f2c8da
Author: Shaun Tancheff <shaun@tancheff.com>
Date:   Sun Aug 21 23:23:18 2016 -0500

    libata: Safely overwrite attached page in WRITE SAME xlat
    
    Safely overwriting the attached page to ATA format from the SCSI formatted
    variant.
    
    Signed-off-by: Shaun Tancheff <shaun.tancheff@seagate.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index adbc812c009b..45a1d71c55f1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -1071,32 +1071,6 @@ static inline void ata_id_to_hd_driveid(u16 *id)
 #endif
 }
 
-/*
- * Write LBA Range Entries to the buffer that will cover the extent from
- * sector to sector + count.  This is used for TRIM and for ADD LBA(S)
- * TO NV CACHE PINNED SET.
- */
-static inline unsigned ata_set_lba_range_entries(void *_buffer,
-		unsigned num, u64 sector, unsigned long count)
-{
-	__le64 *buffer = _buffer;
-	unsigned i = 0, used_bytes;
-
-	while (i < num) {
-		u64 entry = sector |
-			((u64)(count > 0xffff ? 0xffff : count) << 48);
-		buffer[i++] = __cpu_to_le64(entry);
-		if (count <= 0xffff)
-			break;
-		count -= 0xffff;
-		sector += 0xffff;
-	}
-
-	used_bytes = ALIGN(i * 8, 512);
-	memset(buffer + i, 0, used_bytes - i * 8);
-	return used_bytes;
-}
-
 static inline bool ata_ok(u8 status)
 {
 	return ((status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR))

commit 37f92d77dc45d1fb74eff8501f26e72a3dcaa3cf
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 16 22:16:43 2016 +0900

    ata: define ATA_PROT_* in terms of ATA_PROT_FLAG_*
    
    This avoid the need to always translate between the two in ata_prot_flags
    and generally cleans up the taskfile protocol usage.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 5b67ff407ec2..adbc812c009b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -523,17 +523,23 @@ enum {
 	SERR_DEV_XCHG		= (1 << 26), /* device exchanged */
 };
 
-enum ata_tf_protocols {
-	/* ATA taskfile protocols */
-	ATA_PROT_UNKNOWN,	/* unknown/invalid */
-	ATA_PROT_NODATA,	/* no data */
-	ATA_PROT_PIO,		/* PIO data xfer */
-	ATA_PROT_DMA,		/* DMA */
-	ATA_PROT_NCQ,		/* NCQ */
-	ATA_PROT_NCQ_NODATA,	/* NCQ no data */
-	ATAPI_PROT_NODATA,	/* packet command, no data */
-	ATAPI_PROT_PIO,		/* packet command, PIO data xfer*/
-	ATAPI_PROT_DMA,		/* packet command with special DMA sauce */
+enum ata_prot_flags {
+	/* protocol flags */
+	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
+	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
+	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
+	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
+
+	/* taskfile protocols */
+	ATA_PROT_UNKNOWN	= (u8)-1,
+	ATA_PROT_NODATA		= 0,
+	ATA_PROT_PIO		= ATA_PROT_FLAG_PIO,
+	ATA_PROT_DMA		= ATA_PROT_FLAG_DMA,
+	ATA_PROT_NCQ_NODATA	= ATA_PROT_FLAG_NCQ,
+	ATA_PROT_NCQ		= ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ,
+	ATAPI_PROT_NODATA	= ATA_PROT_FLAG_ATAPI,
+	ATAPI_PROT_PIO		= ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO,
+	ATAPI_PROT_DMA		= ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA,
 };
 
 enum ata_ioctls {

commit 35303d5c36415754680f953aa6128b8b907d0543
Author: Tom Yan <tom.ty89@gmail.com>
Date:   Fri Jul 15 05:09:02 2016 +0800

    ata: make lba_{28,48}_ok() use ATA_MAX_SECTORS{,_LBA48}
    
    Since we set ATA_MAX_SECTORS_LBA48 to 65535 to avoid the corner case
    in some drives that commands with "count" set to 0000h (which
    reprsents 65536) does not work as expected, lba_48_ok(), which is
    used for number-of-blocks checking when libata pack commands, should
    use the same limit as well. In fact, there is no reason for the two
    functions not to use the macros anyway.
    
    Signed-off-by: Tom Yan <tom.ty89@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 35857d1f15c8..5b67ff407ec2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -46,7 +46,7 @@ enum {
 	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
 	ATA_MAX_SECTORS_1024    = 1024,
-	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
+	ATA_MAX_SECTORS_LBA48	= 65535,/* avoid count to be 0000h */
 	ATA_MAX_SECTORS_TAPE	= 65535,
 	ATA_MAX_TRIM_RNUM	= 64,	/* 512-byte payload / (6-byte LBA + 2-byte range per entry) */
 
@@ -1100,13 +1100,13 @@ static inline bool ata_ok(u8 status)
 static inline bool lba_28_ok(u64 block, u32 n_block)
 {
 	/* check the ending block number: must be LESS THAN 0x0fffffff */
-	return ((block + n_block) < ((1 << 28) - 1)) && (n_block <= 256);
+	return ((block + n_block) < ((1 << 28) - 1)) && (n_block <= ATA_MAX_SECTORS);
 }
 
 static inline bool lba_48_ok(u64 block, u32 n_block)
 {
 	/* check the ending block number */
-	return ((block + n_block - 1) < ((u64)1 << 48)) && (n_block <= 65536);
+	return ((block + n_block - 1) < ((u64)1 << 48)) && (n_block <= ATA_MAX_SECTORS_LBA48);
 }
 
 #define sata_pmp_gscr_vendor(gscr)	((gscr)[SATA_PMP_GSCR_PROD_ID] & 0xffff)

commit 5b844b63ddfb65aef923eaabe0420196fd71dd13
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Jul 14 09:05:48 2016 +0900

    ata: Handle ATA NCQ NO-DATA commands correctly
    
    Add a new taskfile protocol ATA_PROT_NCQ_NODATA to handle
    ATA NCQ NO-DATA commands correctly.
    And fixup ata_scsi_zbc_out_xlat() to use it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d20b1ee127b0..35857d1f15c8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -530,6 +530,7 @@ enum ata_tf_protocols {
 	ATA_PROT_PIO,		/* PIO data xfer */
 	ATA_PROT_DMA,		/* DMA */
 	ATA_PROT_NCQ,		/* NCQ */
+	ATA_PROT_NCQ_NODATA,	/* NCQ no data */
 	ATAPI_PROT_NODATA,	/* packet command, no data */
 	ATAPI_PROT_PIO,		/* packet command, PIO data xfer*/
 	ATAPI_PROT_DMA,		/* packet command with special DMA sauce */

commit 2983860c766870b701c4a34f435c1e18db086244
Author: Tom Yan <tom.ty89@gmail.com>
Date:   Wed Jul 13 04:31:23 2016 +0800

    libata-scsi: avoid repeated calculation of number of TRIM ranges
    
    Currently libata statically allows only 1-block (512-byte) payload
    for each TRIM command. Each payload can carry 64 TRIM ranges since
    each range requires 8 bytes.
    
    It is silly to keep doing the calculation (512 / 8) in different
    places. Hence, define the new ATA_MAX_TRIM_RNUM for the result.
    
    Signed-off-by: Tom Yan <tom.ty89@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 2d6879392ae3..d20b1ee127b0 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -48,6 +48,7 @@ enum {
 	ATA_MAX_SECTORS_1024    = 1024,
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 	ATA_MAX_SECTORS_TAPE	= 65535,
+	ATA_MAX_TRIM_RNUM	= 64,	/* 512-byte payload / (6-byte LBA + 2-byte range per entry) */
 
 	ATA_ID_WORDS		= 256,
 	ATA_ID_CONFIG		= 0,
@@ -1069,12 +1070,12 @@ static inline void ata_id_to_hd_driveid(u16 *id)
  * TO NV CACHE PINNED SET.
  */
 static inline unsigned ata_set_lba_range_entries(void *_buffer,
-		unsigned buf_size, u64 sector, unsigned long count)
+		unsigned num, u64 sector, unsigned long count)
 {
 	__le64 *buffer = _buffer;
 	unsigned i = 0, used_bytes;
 
-	while (i < buf_size / 8 ) { /* 6-byte LBA + 2-byte range per entry */
+	while (i < num) {
 		u64 entry = sector |
 			((u64)(count > 0xffff ? 0xffff : count) << 48);
 		buffer[i++] = __cpu_to_le64(entry);

commit 0c12735e8abf4734b011aec979092db5e63556b0
Author: Tom Yan <tom.ty89@gmail.com>
Date:   Tue Jul 12 21:37:02 2016 +0800

    libata-scsi: fix SET FEATURES "filtering" for ata_msense_caching()
    
    Without this fix, the DRA bit of the caching mode page would not
    be updated when the read look-ahead feature is toggled (e.g. with
    `smartctl --set`), but will only be until, for example, the write
    cache feature is touched.
    
    Signed-off-by: Tom Yan <tom.ty89@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 99346be5a7ca..2d6879392ae3 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -409,6 +409,9 @@ enum {
 	SETFEATURES_WC_ON	= 0x02, /* Enable write cache */
 	SETFEATURES_WC_OFF	= 0x82, /* Disable write cache */
 
+	SETFEATURES_RA_ON	= 0xaa, /* Enable read look-ahead */
+	SETFEATURES_RA_OFF	= 0x55, /* Disable read look-ahead */
+
 	/* Enable/Disable Automatic Acoustic Management */
 	SETFEATURES_AAM_ON	= 0x42,
 	SETFEATURES_AAM_OFF	= 0xC2,

commit e4f7bdc2ec0d0dcc27f7d70db27a620dfdc1f697
Merge: 3159ee58d213 6d1003ae8db2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 17:53:39 2016 -0700

    Merge branch 'for-4.7-zac' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata ZAC support from Tejun Heo:
     "This contains Zone ATA Command support for Shingled Magnetic Recording
      devices.
    
      In addition to sending the new commands down to the device, as ZAC
      commands depend on getting a lot of responses from the device, piping
      up responses is beefed up too.  However, it doesn't involve changes to
      libata core mechanism or its interaction with upper layers, so I'm not
      expecting too many fallouts.
    
      Kudos to Hannes for driving SMR support"
    
    * 'for-4.7-zac' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (28 commits)
      libata: support host-aware and host-managed ZAC devices
      libata: support device-managed ZAC devices
      libata: NCQ encapsulation for ZAC MANAGEMENT OUT
      libata: Implement ZBC OUT translation
      libata: implement ZBC IN translation
      libata: fixup ZAC device disabling
      libata-scsi: Generate sense code for disabled devices
      libata-trace: decode subcommands
      libata: Check log page directory before accessing pages
      libata: Add command definitions for NCQ Encapsulation for READ LOG DMA EXT
      libata: Separate out ata_dev_config_ncq_send_recv()
      libata/libsas: Define ATA_CMD_NCQ_NON_DATA
      libsas: enable FPDMA SEND/RECEIVE
      libata: do not attempt to retrieve sense code twice
      libata-scsi: Set information sense field for invalid parameter
      libata-scsi: set bit pointer for sense code information
      libata-scsi: Set field pointer in sense code
      scsi: add scsi_set_sense_field_pointer()
      libata: Implement control mode page to select sense format
      libata-scsi: generate correct ATA pass-through sense
      ...

commit 6d1003ae8db228b74ef61536364cd2a1bd973dd8
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:56 2016 +0200

    libata: support host-aware and host-managed ZAC devices
    
    Byte 69 bits 0:1 in the IDENTIFY DEVICE data indicate a
    host-aware ZAC device.
    Host-managed ZAC devices have their own individual signature,
    and to not set the bits in the IDENTIFY DEVICE data.
    And whenever we detect a ZAC-compatible device we should
    be displaying the zoned block characteristics VPD page.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ac1cb9310dea..83e2a99866c2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -338,6 +338,7 @@ enum {
 	ATA_LOG_NCQ_SEND_RECV	  = 0x13,
 	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
+	ATA_LOG_ZONED_INFORMATION = 0x09,
 	ATA_LOG_DEVSLP_OFFSET	  = 0x30,
 	ATA_LOG_DEVSLP_SIZE	  = 0x08,
 	ATA_LOG_DEVSLP_MDAT	  = 0x00,

commit 856c4663930988118d9f355aad66811dd6df06de
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:55 2016 +0200

    libata: support device-managed ZAC devices
    
    Device-managed ZAC devices just set the zoned capabilities field
    in INQUIRY byte 69 (cf ACS-4). This corresponds to the 'zoned'
    field in the block device characteristics VPD page.
    As this is only defined in SPC-5/SBC-4 we also need to update
    the supported SCSI version descriptor.
    
    Reviewed-by: Shaun Tancheff <shaun.tancheff@seagate.com>
    Tested-by: Shaun Tancheff <shaun.tancheff@seagate.com>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e62703201e84..ac1cb9310dea 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -935,6 +935,11 @@ static inline bool ata_id_is_ssd(const u16 *id)
 	return id[ATA_ID_ROT_SPEED] == 0x01;
 }
 
+static inline u8 ata_id_zoned_cap(const u16 *id)
+{
+	return (id[ATA_ID_ADDITIONAL_SUPP] & 0x3);
+}
+
 static inline bool ata_id_pio_need_iordy(const u16 *id, const u8 pio)
 {
 	/* CF spec. r4.1 Table 22 says no IORDY on PIO5 and PIO6. */

commit 284b3b77ea883234dadb2cbf97b145c3c30fe4bd
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:54 2016 +0200

    libata: NCQ encapsulation for ZAC MANAGEMENT OUT
    
    Add NCQ encapsulation for ZAC MANAGEMENT OUT and evaluate
    NCQ Non-Data log pages to figure out if NCQ encapsulation
    is supported.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 9d7c47075ebc..e62703201e84 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -320,6 +320,7 @@ enum {
 	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE  = 0x00,
 	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 0x05,
 	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT     = 0x06,
+	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 0x07,
 
 	/* Subcmds for ATA_CMD_ZAC_MGMT_IN */
 	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0x00,
@@ -333,6 +334,7 @@ enum {
 	/* READ_LOG_EXT pages */
 	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,
+	ATA_LOG_NCQ_NON_DATA	  = 0x12,
 	ATA_LOG_NCQ_SEND_RECV	  = 0x13,
 	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
@@ -877,6 +879,11 @@ static inline bool ata_id_has_ncq_send_and_recv(const u16 *id)
 	return id[ATA_ID_SATA_CAPABILITY_2] & BIT(6);
 }
 
+static inline bool ata_id_has_ncq_non_data(const u16 *id)
+{
+	return id[ATA_ID_SATA_CAPABILITY_2] & BIT(5);
+}
+
 static inline bool ata_id_has_trim(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&

commit 27708a9579ee069c6e0ebb6e61ac1114ed1d546c
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:53 2016 +0200

    libata: Implement ZBC OUT translation
    
    ZAC drives implement a 'ZAC Management Out' command template,
    which maps onto the ZBC OUT command.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 255aa0f1c9bc..9d7c47075ebc 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -303,6 +303,7 @@ enum {
 	ATA_CMD_REQ_SENSE_DATA  = 0x0B,
 	ATA_CMD_SANITIZE_DEVICE = 0xB4,
 	ATA_CMD_ZAC_MGMT_IN	= 0x4A,
+	ATA_CMD_ZAC_MGMT_OUT	= 0x9F,
 
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
@@ -323,6 +324,12 @@ enum {
 	/* Subcmds for ATA_CMD_ZAC_MGMT_IN */
 	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0x00,
 
+	/* Subcmds for ATA_CMD_ZAC_MGMT_OUT */
+	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 0x01,
+	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 0x02,
+	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 0x03,
+	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 0x04,
+
 	/* READ_LOG_EXT pages */
 	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,

commit 28a3fc2295a744a0d2ddf86b2ccdf03fbab123f9
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:52 2016 +0200

    libata: implement ZBC IN translation
    
    ZAC drives implement a 'ZAC Management In' command template,
    which maps onto the ZBC IN command.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 032bb223cd8c..255aa0f1c9bc 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -302,12 +302,14 @@ enum {
 	ATA_CMD_CFA_WRITE_MULT_NE = 0xCD,
 	ATA_CMD_REQ_SENSE_DATA  = 0x0B,
 	ATA_CMD_SANITIZE_DEVICE = 0xB4,
+	ATA_CMD_ZAC_MGMT_IN	= 0x4A,
 
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 
 	/* Subcmds for ATA_CMD_FPDMA_RECV */
 	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 0x01,
+	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN    = 0x02,
 
 	/* Subcmds for ATA_CMD_FPDMA_SEND */
 	ATA_SUBCMD_FPDMA_SEND_DSM            = 0x00,
@@ -318,6 +320,9 @@ enum {
 	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 0x05,
 	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT     = 0x06,
 
+	/* Subcmds for ATA_CMD_ZAC_MGMT_IN */
+	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0x00,
+
 	/* READ_LOG_EXT pages */
 	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,
@@ -341,7 +346,10 @@ enum {
 	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED  = (1 << 0),
 	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET	= 0x0C,
 	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED  = (1 << 0),
-	ATA_LOG_NCQ_SEND_RECV_SIZE		= 0x10,
+	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET	= 0x10,
+	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = (1 << 0),
+	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = (1 << 1),
+	ATA_LOG_NCQ_SEND_RECV_SIZE		= 0x14,
 
 	/* NCQ Non-Data log */
 	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET	= 0x00,

commit a57038496422d7d21b7e41ed70d63bf0c6ff6068
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:49 2016 +0200

    libata-trace: decode subcommands
    
    Some commands like FPDMA RECEIVE or NCQ NON DATA can encapsulate
    other commands to NCQ transport. So decode the subcmds, too.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b5be5e85d2d3..032bb223cd8c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -313,6 +313,11 @@ enum {
 	ATA_SUBCMD_FPDMA_SEND_DSM            = 0x00,
 	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 0x02,
 
+	/* Subcmds for ATA_CMD_NCQ_NON_DATA */
+	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE  = 0x00,
+	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 0x05,
+	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT     = 0x06,
+
 	/* READ_LOG_EXT pages */
 	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,
@@ -338,6 +343,18 @@ enum {
 	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED  = (1 << 0),
 	ATA_LOG_NCQ_SEND_RECV_SIZE		= 0x10,
 
+	/* NCQ Non-Data log */
+	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET	= 0x00,
+	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET	= 0x00,
+	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ		= (1 << 0),
+	ATA_LOG_NCQ_NON_DATA_ABORT_ALL		= (1 << 1),
+	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING	= (1 << 2),
+	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = (1 << 3),
+	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED	= (1 << 4),
+	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET	= 0x1C,
+	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT	= (1 << 0),
+	ATA_LOG_NCQ_NON_DATA_SIZE		= 0x40,
+
 	/* READ/WRITE LONG (obsolete) */
 	ATA_CMD_READ_LONG	= 0x22,
 	ATA_CMD_READ_LONG_ONCE	= 0x23,

commit fe5af0cc3029d52e31d282f5d53787d308e9695a
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:48 2016 +0200

    libata: Check log page directory before accessing pages
    
    When reading the NCQ Send/Recv log it might actually not
    supported, thereby causing irritating messages
    'READ LOG DMA EXT failed'.
    Instead we should be reading the log directory first to
    figure out if the log is actually supported before trying
    to access it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 94ccde5ee83c..b5be5e85d2d3 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -314,6 +314,7 @@ enum {
 	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 0x02,
 
 	/* READ_LOG_EXT pages */
+	ATA_LOG_DIRECTORY	= 0x0,
 	ATA_LOG_SATA_NCQ	= 0x10,
 	ATA_LOG_NCQ_SEND_RECV	  = 0x13,
 	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,

commit 5c65d8bb3503beb12864895426a69269c19e6e87
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:47 2016 +0200

    libata: Add command definitions for NCQ Encapsulation for READ LOG DMA EXT
    
    ACS-4 defines an NCQ encapsulation for READ LOG DMA EXT.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b84210a28a00..94ccde5ee83c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -306,6 +306,9 @@ enum {
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 
+	/* Subcmds for ATA_CMD_FPDMA_RECV */
+	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 0x01,
+
 	/* Subcmds for ATA_CMD_FPDMA_SEND */
 	ATA_SUBCMD_FPDMA_SEND_DSM            = 0x00,
 	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 0x02,
@@ -329,7 +332,9 @@ enum {
 	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET	= 0x04,
 	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM		= (1 << 0),
 	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET	= 0x08,
+	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED  = (1 << 0),
 	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET	= 0x0C,
+	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED  = (1 << 0),
 	ATA_LOG_NCQ_SEND_RECV_SIZE		= 0x10,
 
 	/* READ/WRITE LONG (obsolete) */

commit 661ce1f0c4a69f92ad781d8d2c205c90dd9c5833
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 25 12:45:45 2016 +0200

    libata/libsas: Define ATA_CMD_NCQ_NON_DATA
    
    Define the NCQ NON DATA command and update libsas to handle it
    correctly.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 00aebc4c83ad..b84210a28a00 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -243,6 +243,7 @@ enum {
 	ATA_CMD_WRITE_QUEUED_FUA_EXT = 0x3E,
 	ATA_CMD_FPDMA_READ	= 0x60,
 	ATA_CMD_FPDMA_WRITE	= 0x61,
+	ATA_CMD_NCQ_NON_DATA	= 0x63,
 	ATA_CMD_FPDMA_SEND	= 0x64,
 	ATA_CMD_FPDMA_RECV	= 0x65,
 	ATA_CMD_PIO_READ	= 0x20,

commit 974e0a4537f556867483f493c7f67ccdcb7fc504
Author: Damien Le Moal <damien.lemoal@hgst.com>
Date:   Mon Apr 4 12:17:09 2016 -0400

    libata-core: Allow longer timeout for drive spinup from PUIS
    
    When spinning up a drive from powered on standby mode (PUIS),
    SETFEATURES_SPINUP is executed with the default timeout used
    for any SETFEATURES subcommand, that is 5+10 seconds. The
    total 15s is too short for some drives to complete spinup
    (e.g. drives with a large indirection table stored on media),
    resulting in ata_dev_read_id to fail twice on the execution
    of SETFEATURES_SPINUP. For this feature, allow a larger
    default timeout of 30 seconds. However, in the same spirit
    as with the timeout of other feature subcommands, do not
    ignore ata_probe_timeout if it is set).
    
    Signed-off-by: Damien Le Moal <damien.lemoal@hgst.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c1a2f345cbe6..f310ec0f072e 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -371,7 +371,8 @@ enum {
 	SETFEATURES_AAM_ON	= 0x42,
 	SETFEATURES_AAM_OFF	= 0xC2,
 
-	SETFEATURES_SPINUP	= 0x07, /* Spin-up drive */
+	SETFEATURES_SPINUP		= 0x07, /* Spin-up drive */
+	SETFEATURES_SPINUP_TIMEOUT	= 30000, /* 30s timeout for drive spin-up from PUIS */
 
 	SETFEATURES_SATA_ENABLE = 0x10, /* Enable use of SATA feature */
 	SETFEATURES_SATA_DISABLE = 0x90, /* Disable use of SATA feature */

commit e87fd28cf9a2d9018ac4b6dd92f0b417714bc18d
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:43:55 2016 +0200

    libata: Implement support for sense data reporting
    
    ACS-4 defines a sense data reporting feature set.
    This patch implements support for it.
    
    tj: Cosmetic formatting updates.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e797e1b53006..00aebc4c83ad 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -385,6 +385,8 @@ enum {
 	SATA_SSP		= 0x06,	/* Software Settings Preservation */
 	SATA_DEVSLP		= 0x09,	/* Device Sleep */
 
+	SETFEATURE_SENSE_DATA	= 0xC3, /* Sense Data Reporting feature */
+
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,
 	ATA_SET_MAX_PASSWD	= 0x01,
@@ -718,6 +720,20 @@ static inline bool ata_id_has_read_log_dma_ext(const u16 *id)
 	return false;
 }
 
+static inline bool ata_id_has_sense_reporting(const u16 *id)
+{
+	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
+		return false;
+	return id[ATA_ID_COMMAND_SET_3] & (1 << 6);
+}
+
+static inline bool ata_id_sense_reporting_enabled(const u16 *id)
+{
+	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
+		return false;
+	return id[ATA_ID_COMMAND_SET_4] & (1 << 6);
+}
+
 /**
  *	ata_id_major_version	-	get ATA level of drive
  *	@id: Identify data

commit 5b01e4b9efa0b78672cbbea830c9fbcc7f239e29
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:43:54 2016 +0200

    libata: Implement NCQ autosense
    
    Some newer devices support NCQ autosense (cf ACS-4), so we should
    be using it to retrieve the sense code and speed up recovery.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c1a2f345cbe6..e797e1b53006 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -528,6 +528,8 @@ struct ata_bmdma_prd {
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
 #define ata_id_has_da(id)	((id)[ATA_ID_SATA_CAPABILITY_2] & (1 << 4))
 #define ata_id_has_devslp(id)	((id)[ATA_ID_FEATURE_SUPP] & (1 << 8))
+#define ata_id_has_ncq_autosense(id) \
+				((id)[ATA_ID_FEATURE_SUPP] & (1 << 7))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {

commit 287e6611ab1eac76c2c5ebf6e345e04c80ca9c61
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 11 14:16:27 2016 +0100

    libata: fix HDIO_GET_32BIT ioctl
    
    As reported by Soohoon Lee, the HDIO_GET_32BIT ioctl does not
    work correctly in compat mode with libata.
    
    I have investigated the issue further and found multiple problems
    that all appeared with the same commit that originally introduced
    HDIO_GET_32BIT handling in libata back in linux-2.6.8 and presumably
    also linux-2.4, as the code uses "copy_to_user(arg, &val, 1)" to copy
    a 'long' variable containing either 0 or 1 to user space.
    
    The problems with this are:
    
    * On big-endian machines, this will always write a zero because it
      stores the wrong byte into user space.
    
    * In compat mode, the upper three bytes of the variable are updated
      by the compat_hdio_ioctl() function, but they now contain
      uninitialized stack data.
    
    * The hdparm tool calling this ioctl uses a 'static long' variable
      to store the result. This means at least the upper bytes are
      initialized to zero, but calling another ioctl like HDIO_GET_MULTCOUNT
      would fill them with data that remains stale when the low byte
      is overwritten. Fortunately libata doesn't implement any of the
      affected ioctl commands, so this would only happen when we query
      both an IDE and an ATA device in the same command such as
      "hdparm -N -c /dev/hda /dev/sda"
    
    * The libata code for unknown reasons started using ATA_IOC_GET_IO32
      and ATA_IOC_SET_IO32 as aliases for HDIO_GET_32BIT and HDIO_SET_32BIT,
      while the ioctl commands that were added later use the normal
      HDIO_* names. This is harmless but rather confusing.
    
    This addresses all four issues by changing the code to use put_user()
    on an 'unsigned long' variable in HDIO_GET_32BIT, like the IDE subsystem
    does, and by clarifying the names of the ioctl commands.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reported-by: Soohoon Lee <Soohoon.Lee@f5.com>
    Tested-by: Soohoon Lee <Soohoon.Lee@f5.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d2992bfa1706..c1a2f345cbe6 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -487,8 +487,8 @@ enum ata_tf_protocols {
 };
 
 enum ata_ioctls {
-	ATA_IOC_GET_IO32	= 0x309,
-	ATA_IOC_SET_IO32	= 0x324,
+	ATA_IOC_GET_IO32	= 0x309, /* HDIO_GET_32BIT */
+	ATA_IOC_SET_IO32	= 0x324, /* HDIO_SET_32BIT */
 };
 
 /* core structures */

commit 74a80d67b8316eb3fbeb73dafc060a5a0a708587
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 3 11:46:39 2015 -0400

    Revert "libata: Implement NCQ autosense"
    
    This reverts commit 42b966fbf35da9c87f08d98f9b8978edf9e717cf.
    
    As implemented, ACS-4 sense reporting for ATA devices bypasses error
    diagnosis and handling in libata degrading EH behavior significantly.
    Revert the related changes for now.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: stable@vger.kernel.org #v4.1+

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 0e6a782575b5..d2992bfa1706 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -528,8 +528,6 @@ struct ata_bmdma_prd {
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
 #define ata_id_has_da(id)	((id)[ATA_ID_SATA_CAPABILITY_2] & (1 << 4))
 #define ata_id_has_devslp(id)	((id)[ATA_ID_FEATURE_SUPP] & (1 << 8))
-#define ata_id_has_ncq_autosense(id) \
-				((id)[ATA_ID_FEATURE_SUPP] & (1 << 7))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {

commit 84ded2f8e7dda336fc2fb3570726ceb3b3b3590f
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 3 11:45:34 2015 -0400

    Revert "libata: Implement support for sense data reporting"
    
    This reverts commit fe7173c206de63fc28475ee6ae42ff95c05692de.
    
    As implemented, ACS-4 sense reporting for ATA devices bypasses error
    diagnosis and handling in libata degrading EH behavior significantly.
    Revert the related changes for now.
    
    ATA_ID_COMMAND_SET_3/4 constants are not reverted as they're used by
    later changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: stable@vger.kernel.org #v4.1+

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 6c78956aa470..0e6a782575b5 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -385,8 +385,6 @@ enum {
 	SATA_SSP		= 0x06,	/* Software Settings Preservation */
 	SATA_DEVSLP		= 0x09,	/* Device Sleep */
 
-	SETFEATURE_SENSE_DATA = 0xC3, /* Sense Data Reporting feature */
-
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,
 	ATA_SET_MAX_PASSWD	= 0x01,
@@ -720,20 +718,6 @@ static inline bool ata_id_has_read_log_dma_ext(const u16 *id)
 	return false;
 }
 
-static inline bool ata_id_has_sense_reporting(const u16 *id)
-{
-	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
-		return false;
-	return id[ATA_ID_COMMAND_SET_3] & (1 << 6);
-}
-
-static inline bool ata_id_sense_reporting_enabled(const u16 *id)
-{
-	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
-		return false;
-	return id[ATA_ID_COMMAND_SET_4] & (1 << 6);
-}
-
 /**
  *	ata_id_major_version	-	get ATA level of drive
  *	@id: Identify data

commit af34d637637eabaf49406eb35c948cd51ba262a6
Author: David Milburn <dmilburn@redhat.com>
Date:   Mon Jul 13 11:48:23 2015 -0500

    libata: add ATA_HORKAGE_MAX_SEC_1024 to revert back to previous max_sectors limit
    
    Since no longer limiting max_sectors to BLK_DEF_MAX_SECTORS (commit 34b48db66e08),
    data corruption may occur on ST380013AS drive configured on 82801JI (ICH10 Family)
    SATA controller. This patch will allow the driver to limit max_sectors as before
    
     # cat /sys/block/sdb/queue/max_sectors_kb
     512
    
    I was able to double the max_sectors_kb value up to 16384 on linux-4.2.0-rc2
    before seeing corruption, but seems safer to use previous limit. Without this
    patch max_sectors_kb will be 32767.
    
    tj: Minor comment update.
    
    Reported-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: David Milburn <dmilburn@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org # v3.19 and later
    Fixes: 34b48db66e08 ("block: remove artifical max_hw_sectors cap")

diff --git a/include/linux/ata.h b/include/linux/ata.h
index fed36418dd1c..6c78956aa470 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -45,6 +45,7 @@ enum {
 	ATA_SECT_SIZE		= 512,
 	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
+	ATA_MAX_SECTORS_1024    = 1024,
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 	ATA_MAX_SECTORS_TAPE	= 65535,
 

commit 406c057c4e00744453d5b0731eb23629ec14dcdf
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Mon May 4 21:54:20 2015 -0400

    libata: READ LOG DMA EXT support can be in either page 119 or 120
    
    Support for the READ/WRITE LOG DMA EXT commands can be signaled either
    in page 119 or page 120. We should check both pages.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b666b773e111..fed36418dd1c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -704,9 +704,19 @@ static inline bool ata_id_wcache_enabled(const u16 *id)
 
 static inline bool ata_id_has_read_log_dma_ext(const u16 *id)
 {
+	/* Word 86 must have bit 15 set */
 	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
 		return false;
-	return id[ATA_ID_COMMAND_SET_3] & (1 << 3);
+
+	/* READ LOG DMA EXT support can be signaled either from word 119
+	 * or from word 120. The format is the same for both words: Bit
+	 * 15 must be cleared, bit 14 set and bit 3 set.
+	 */
+	if ((id[ATA_ID_COMMAND_SET_3] & 0xC008) == 0x4008 ||
+	    (id[ATA_ID_COMMAND_SET_4] & 0xC008) == 0x4008)
+		return true;
+
+	return false;
 }
 
 static inline bool ata_id_has_sense_reporting(const u16 *id)

commit fe7173c206de63fc28475ee6ae42ff95c05692de
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:36 2015 +0100

    libata: Implement support for sense data reporting
    
    ACS-4 defines a sense data reporting feature set.
    This patch implements support for it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 0c65526e9295..b666b773e111 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -94,6 +94,8 @@ enum {
 	ATA_ID_SECTOR_SIZE	= 106,
 	ATA_ID_WWN		= 108,
 	ATA_ID_LOGICAL_SECTOR_SIZE	= 117,	/* and 118 */
+	ATA_ID_COMMAND_SET_3	= 119,
+	ATA_ID_COMMAND_SET_4	= 120,
 	ATA_ID_LAST_LUN		= 126,
 	ATA_ID_DLF		= 128,
 	ATA_ID_CSFO		= 129,
@@ -382,6 +384,8 @@ enum {
 	SATA_SSP		= 0x06,	/* Software Settings Preservation */
 	SATA_DEVSLP		= 0x09,	/* Device Sleep */
 
+	SETFEATURE_SENSE_DATA = 0xC3, /* Sense Data Reporting feature */
+
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,
 	ATA_SET_MAX_PASSWD	= 0x01,
@@ -705,6 +709,20 @@ static inline bool ata_id_has_read_log_dma_ext(const u16 *id)
 	return id[ATA_ID_COMMAND_SET_3] & (1 << 3);
 }
 
+static inline bool ata_id_has_sense_reporting(const u16 *id)
+{
+	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
+		return false;
+	return id[ATA_ID_COMMAND_SET_3] & (1 << 6);
+}
+
+static inline bool ata_id_sense_reporting_enabled(const u16 *id)
+{
+	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
+		return false;
+	return id[ATA_ID_COMMAND_SET_4] & (1 << 6);
+}
+
 /**
  *	ata_id_major_version	-	get ATA level of drive
  *	@id: Identify data

commit 42b966fbf35da9c87f08d98f9b8978edf9e717cf
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:35 2015 +0100

    libata: Implement NCQ autosense
    
    Some newer devices support NCQ autosense (cf ACS-4), so we should
    be using it to retrieve the sense code and speed up recovery.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e3cb41c17ba7..0c65526e9295 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -525,6 +525,8 @@ struct ata_bmdma_prd {
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
 #define ata_id_has_da(id)	((id)[ATA_ID_SATA_CAPABILITY_2] & (1 << 4))
 #define ata_id_has_devslp(id)	((id)[ATA_ID_FEATURE_SUPP] & (1 << 8))
+#define ata_id_has_ncq_autosense(id) \
+				((id)[ATA_ID_FEATURE_SUPP] & (1 << 7))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {

commit 27f00e53af72702d3a9e6f75590e66fe04914149
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:33 2015 +0100

    ide,ata: Rename ATA_IDX to ATA_SENSE
    
    ATA-8 defines bit 1 as 'ATA_SENSE', not 'ATA_IDX'.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 681520f8a3de..e3cb41c17ba7 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -177,7 +177,7 @@ enum {
 	ATA_DSC			= (1 << 4),	/* drive seek complete */
 	ATA_DRQ			= (1 << 3),	/* data request i/o */
 	ATA_CORR		= (1 << 2),	/* corrected data error */
-	ATA_IDX			= (1 << 1),	/* index */
+	ATA_SENSE		= (1 << 1),	/* sense code available */
 	ATA_ERR			= (1 << 0),	/* have an error */
 	ATA_SRST		= (1 << 2),	/* software reset */
 	ATA_ICRC		= (1 << 7),	/* interface CRC error */

commit 9faa643855df6f673f08543576c759b82dd270d3
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:30 2015 +0100

    libata: use READ_LOG_DMA_EXT
    
    If READ_LOG_DMA_EXT is supported we should try to use it for
    reading the log pages.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 1648026e06b4..681520f8a3de 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -696,6 +696,13 @@ static inline bool ata_id_wcache_enabled(const u16 *id)
 	return id[ATA_ID_CFS_ENABLE_1] & (1 << 5);
 }
 
+static inline bool ata_id_has_read_log_dma_ext(const u16 *id)
+{
+	if (!(id[ATA_ID_CFS_ENABLE_2] & (1 << 15)))
+		return false;
+	return id[ATA_ID_COMMAND_SET_3] & (1 << 3);
+}
+
 /**
  *	ata_id_major_version	-	get ATA level of drive
  *	@id: Identify data

commit 0628ee7c81a8ced9b10f9ee300707f7f79fdecf1
Author: Nicholas Krause <xerofoify@gmail.com>
Date:   Sun Dec 21 22:36:37 2014 -0500

    libata: s/ata_id_removeable()/ata_id_removable()/
    
    Changes the spelling typos of removeable to removable where
    ata_id_removeable is defined in ata.h and called in libata-scsi.c
    respectively.
    
    Signed-off-by: Nicholas Krause <xerofoify@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f2f4d8da97c0..1648026e06b4 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -503,7 +503,7 @@ struct ata_bmdma_prd {
 #define ata_id_has_dma(id)	((id)[ATA_ID_CAPABILITY] & (1 << 8))
 #define ata_id_has_ncq(id)	((id)[ATA_ID_SATA_CAPABILITY] & (1 << 8))
 #define ata_id_queue_depth(id)	(((id)[ATA_ID_QUEUE_DEPTH] & 0x1f) + 1)
-#define ata_id_removeable(id)	((id)[ATA_ID_CONFIG] & (1 << 7))
+#define ata_id_removable(id)	((id)[ATA_ID_CONFIG] & (1 << 7))
 #define ata_id_has_atapi_AN(id)	\
 	((((id)[ATA_ID_SATA_CAPABILITY] != 0x0000) && \
 	  ((id)[ATA_ID_SATA_CAPABILITY] != 0xffff)) && \

commit 3915c3b5b10cd127198c1f9e2aefff7808500d92
Author: Robert Hancock <hancockrwd@gmail.com>
Date:   Mon Oct 21 19:26:30 2013 -0600

    libata: Add some missing command descriptions
    
    Add some missing command enumerations from the ATA-8 ACS-3 spec into
    include/linux/ata.h, and add the corresponding human-readable command
    descriptions in libata-eh.c.
    
    Signed-off-by: Robert Hancock <hancockrwd@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index bf4c69ca76df..f2f4d8da97c0 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -219,6 +219,7 @@ enum {
 	ATA_CMD_IDLE		= 0xE3, /* place in idle power mode */
 	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
 	ATA_CMD_DOWNLOAD_MICRO  = 0x92,
+	ATA_CMD_DOWNLOAD_MICRO_DMA = 0x93,
 	ATA_CMD_NOP		= 0x00,
 	ATA_CMD_FLUSH		= 0xE7,
 	ATA_CMD_FLUSH_EXT	= 0xEA,
@@ -268,12 +269,15 @@ enum {
 	ATA_CMD_WRITE_LOG_EXT	= 0x3F,
 	ATA_CMD_READ_LOG_DMA_EXT = 0x47,
 	ATA_CMD_WRITE_LOG_DMA_EXT = 0x57,
+	ATA_CMD_TRUSTED_NONDATA	= 0x5B,
 	ATA_CMD_TRUSTED_RCV	= 0x5C,
 	ATA_CMD_TRUSTED_RCV_DMA = 0x5D,
 	ATA_CMD_TRUSTED_SND	= 0x5E,
 	ATA_CMD_TRUSTED_SND_DMA = 0x5F,
 	ATA_CMD_PMP_READ	= 0xE4,
+	ATA_CMD_PMP_READ_DMA	= 0xE9,
 	ATA_CMD_PMP_WRITE	= 0xE8,
+	ATA_CMD_PMP_WRITE_DMA	= 0xEB,
 	ATA_CMD_CONF_OVERLAY	= 0xB1,
 	ATA_CMD_SEC_SET_PASS	= 0xF1,
 	ATA_CMD_SEC_UNLOCK	= 0xF2,
@@ -292,6 +296,9 @@ enum {
 	ATA_CMD_CFA_TRANS_SECT	= 0x87,
 	ATA_CMD_CFA_ERASE	= 0xC0,
 	ATA_CMD_CFA_WRITE_MULT_NE = 0xCD,
+	ATA_CMD_REQ_SENSE_DATA  = 0x0B,
+	ATA_CMD_SANITIZE_DEVICE = 0xB4,
+
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 

commit ed36911c747c18525691c0aa0fbe6b918c8eac19
Author: Marc Carino <marc.ceeeee@gmail.com>
Date:   Sat Aug 24 23:22:50 2013 -0700

    libata: Add support for SEND/RECEIVE FPDMA QUEUED
    
    Add support for the following ATA opcodes, which are present
    in SATA 3.1 and T13 ATA ACS-3:
    
            SEND FPDMA QUEUED
            RECEIVE FPDMA QUEUED
    
    Signed-off-by: Marc Carino <marc.ceeeee@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f63fb1afc5cc..bf4c69ca76df 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -239,6 +239,8 @@ enum {
 	ATA_CMD_WRITE_QUEUED_FUA_EXT = 0x3E,
 	ATA_CMD_FPDMA_READ	= 0x60,
 	ATA_CMD_FPDMA_WRITE	= 0x61,
+	ATA_CMD_FPDMA_SEND	= 0x64,
+	ATA_CMD_FPDMA_RECV	= 0x65,
 	ATA_CMD_PIO_READ	= 0x20,
 	ATA_CMD_PIO_READ_EXT	= 0x24,
 	ATA_CMD_PIO_WRITE	= 0x30,
@@ -293,8 +295,13 @@ enum {
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 
+	/* Subcmds for ATA_CMD_FPDMA_SEND */
+	ATA_SUBCMD_FPDMA_SEND_DSM            = 0x00,
+	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 0x02,
+
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
+	ATA_LOG_NCQ_SEND_RECV	  = 0x13,
 	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
 	ATA_LOG_DEVSLP_OFFSET	  = 0x30,
@@ -305,6 +312,15 @@ enum {
 	ATA_LOG_DEVSLP_VALID	  = 0x07,
 	ATA_LOG_DEVSLP_VALID_MASK = 0x80,
 
+	/* NCQ send and receive log */
+	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET	= 0x00,
+	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM	= (1 << 0),
+	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET	= 0x04,
+	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM		= (1 << 0),
+	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET	= 0x08,
+	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET	= 0x0C,
+	ATA_LOG_NCQ_SEND_RECV_SIZE		= 0x10,
+
 	/* READ/WRITE LONG (obsolete) */
 	ATA_CMD_READ_LONG	= 0x22,
 	ATA_CMD_READ_LONG_ONCE	= 0x23,
@@ -772,6 +788,11 @@ static inline int ata_id_rotation_rate(const u16 *id)
 	return val;
 }
 
+static inline bool ata_id_has_ncq_send_and_recv(const u16 *id)
+{
+	return id[ATA_ID_SATA_CAPABILITY_2] & BIT(6);
+}
+
 static inline bool ata_id_has_trim(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&

commit dc34e7e1a701134c2639dc7af78dc91055616477
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Mon Jul 1 00:01:32 2013 +0400

    libata: move 'struct ata_taskfile' and friends from ata.h to libata.h
    
    Move 'struct ata_taskfile', ata_prot_flags() and their friends from
    <linux/ata.h> to <linux/libata.h>. They were misplaced from the beginning,  as
    <linux/ata.h> should cover ATA/ATAPI and related standards only -- to which the
    aforementioned structure and function have only remote relation.
    
    I would have moved 'enum ata_tf_protocols' closely related to 'struct
    ata_taskfile' but it unfortunately gets used by 'drivers/ide/ide-ioctls.c'...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ee0bd9524055..f63fb1afc5cc 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -446,22 +446,6 @@ enum {
 	SERR_TRANS_ST_ERROR	= (1 << 24), /* Transport state trans. error */
 	SERR_UNRECOG_FIS	= (1 << 25), /* Unrecognized FIS */
 	SERR_DEV_XCHG		= (1 << 26), /* device exchanged */
-
-	/* struct ata_taskfile flags */
-	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
-	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
-	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
-	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
-	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
-	ATA_TFLAG_FUA		= (1 << 5), /* enable FUA */
-	ATA_TFLAG_POLLING	= (1 << 6), /* set nIEN to 1 and use polling */
-
-	/* protocol flags */
-	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
-	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
-	ATA_PROT_FLAG_DATA	= ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA,
-	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
-	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
 };
 
 enum ata_tf_protocols {
@@ -488,83 +472,6 @@ struct ata_bmdma_prd {
 	__le32			flags_len;
 };
 
-struct ata_taskfile {
-	unsigned long		flags;		/* ATA_TFLAG_xxx */
-	u8			protocol;	/* ATA_PROT_xxx */
-
-	u8			ctl;		/* control reg */
-
-	u8			hob_feature;	/* additional data */
-	u8			hob_nsect;	/* to support LBA48 */
-	u8			hob_lbal;
-	u8			hob_lbam;
-	u8			hob_lbah;
-
-	u8			feature;
-	u8			nsect;
-	u8			lbal;
-	u8			lbam;
-	u8			lbah;
-
-	u8			device;
-
-	u8			command;	/* IO operation */
-};
-
-/*
- * protocol tests
- */
-static inline unsigned int ata_prot_flags(u8 prot)
-{
-	switch (prot) {
-	case ATA_PROT_NODATA:
-		return 0;
-	case ATA_PROT_PIO:
-		return ATA_PROT_FLAG_PIO;
-	case ATA_PROT_DMA:
-		return ATA_PROT_FLAG_DMA;
-	case ATA_PROT_NCQ:
-		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
-	case ATAPI_PROT_NODATA:
-		return ATA_PROT_FLAG_ATAPI;
-	case ATAPI_PROT_PIO:
-		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO;
-	case ATAPI_PROT_DMA:
-		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA;
-	}
-	return 0;
-}
-
-static inline int ata_is_atapi(u8 prot)
-{
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
-}
-
-static inline int ata_is_nodata(u8 prot)
-{
-	return !(ata_prot_flags(prot) & ATA_PROT_FLAG_DATA);
-}
-
-static inline int ata_is_pio(u8 prot)
-{
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;
-}
-
-static inline int ata_is_dma(u8 prot)
-{
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_DMA;
-}
-
-static inline int ata_is_ncq(u8 prot)
-{
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_NCQ;
-}
-
-static inline int ata_is_data(u8 prot)
-{
-	return ata_prot_flags(prot) & ATA_PROT_FLAG_DATA;
-}
-
 /*
  * id tests
  */
@@ -1060,15 +967,6 @@ static inline unsigned ata_set_lba_range_entries(void *_buffer,
 	return used_bytes;
 }
 
-static inline int is_multi_taskfile(struct ata_taskfile *tf)
-{
-	return (tf->command == ATA_CMD_READ_MULTI) ||
-	       (tf->command == ATA_CMD_WRITE_MULTI) ||
-	       (tf->command == ATA_CMD_READ_MULTI_EXT) ||
-	       (tf->command == ATA_CMD_WRITE_MULTI_EXT) ||
-	       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);
-}
-
 static inline bool ata_ok(u8 status)
 {
 	return ((status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR))

commit d8668fcb0b257d9fdcfbe5c172a99b8d85e1cd82
Author: Shan Hai <shan.hai@windriver.com>
Date:   Mon Mar 18 10:30:43 2013 +0800

    libata: Use integer return value for atapi_command_packet_set
    
    The function returns type of ATAPI drives so it should return integer value.
    The commit 4dce8ba94c7 (libata: Use 'bool' return value for ata_id_XXX) since
    v2.6.39 changed the type of return value from int to bool, the change would
    cause all of the ATAPI class drives to be treated as TYPE_TAPE and the
    max_sectors of the drives to be set to 65535 because of the commit
    f8d8e5799b7(libata: increase 128 KB / cmd limit for ATAPI tape drives), for the
    function would return true for all ATAPI class drives and the TYPE_TAPE is
    defined as 0x01.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Shan Hai <shan.hai@windriver.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8f7a3d68371a..ee0bd9524055 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -954,7 +954,7 @@ static inline int atapi_cdb_len(const u16 *dev_id)
 	}
 }
 
-static inline bool atapi_command_packet_set(const u16 *dev_id)
+static inline int atapi_command_packet_set(const u16 *dev_id)
 {
 	return (dev_id[ATA_ID_CONFIG] >> 8) & 0x1f;
 }

commit 803739d25c2343da6d2f95eebdcbc08bf67097d4
Author: Shane Huang <shane.huang@amd.com>
Date:   Mon Dec 17 23:18:59 2012 +0800

    [libata] replace sata_settings with devslp_timing
    
    NCQ capability was used to check availability of SATA Settings page
    from Identify Device Data Log, which contains DevSlp timing variables.
    It does not work on some HDDs and leads to error messages.
    
    IDENTIFY word 78 bit 5(Hardware Feature Control) can't work either
    because it is only the sufficient condition of Identify Device data
    log, not the necessary condition.
    
    This patch replaced ata_device->sata_settings with ->devslp_timing
    to only save DevSlp timing variables(8 bytes), instead of the whole
    SATA Settings page(512 bytes).
    
    Addresses https://bugzilla.kernel.org/show_bug.cgi?id=51881
    
    Reported-by: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 408da9502177..8f7a3d68371a 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -297,10 +297,12 @@ enum {
 	ATA_LOG_SATA_NCQ	= 0x10,
 	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
 	ATA_LOG_SATA_SETTINGS	  = 0x08,
-	ATA_LOG_DEVSLP_MDAT	  = 0x30,
+	ATA_LOG_DEVSLP_OFFSET	  = 0x30,
+	ATA_LOG_DEVSLP_SIZE	  = 0x08,
+	ATA_LOG_DEVSLP_MDAT	  = 0x00,
 	ATA_LOG_DEVSLP_MDAT_MASK  = 0x1F,
-	ATA_LOG_DEVSLP_DETO	  = 0x31,
-	ATA_LOG_DEVSLP_VALID	  = 0x37,
+	ATA_LOG_DEVSLP_DETO	  = 0x01,
+	ATA_LOG_DEVSLP_VALID	  = 0x07,
 	ATA_LOG_DEVSLP_VALID_MASK = 0x80,
 
 	/* READ/WRITE LONG (obsolete) */

commit 65fe1f0f66a57380229a4ced844188103135f37b
Author: Shane Huang <shane.huang@amd.com>
Date:   Fri Sep 7 22:40:01 2012 +0800

    ahci: implement aggressive SATA device sleep support
    
    Device Sleep is a feature as described in AHCI 1.3.1 Technical Proposal.
    This feature enables an HBA and SATA storage device to enter the DevSleep
    interface state, enabling lower power SATA-based systems.
    
    Aggressive Device Sleep enables the HBA to assert the DEVSLP signal as
    soon as there are no commands outstanding to the device and the port
    specific Device Sleep idle timer has expired. This enables autonomous
    entry into the DevSleep interface state without waiting for software
    in power sensitive systems.
    
    This patch enables Aggressive Device Sleep only if both host controller
    and device support it.
    
    Tested on AMD reference board together with Device Sleep supported device
    sample.
    
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Reviewed-by: Aaron Lu <aaron.lwe@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 47a9dbf02159..408da9502177 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -295,6 +295,13 @@ enum {
 
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
+	ATA_LOG_SATA_ID_DEV_DATA  = 0x30,
+	ATA_LOG_SATA_SETTINGS	  = 0x08,
+	ATA_LOG_DEVSLP_MDAT	  = 0x30,
+	ATA_LOG_DEVSLP_MDAT_MASK  = 0x1F,
+	ATA_LOG_DEVSLP_DETO	  = 0x31,
+	ATA_LOG_DEVSLP_VALID	  = 0x37,
+	ATA_LOG_DEVSLP_VALID_MASK = 0x80,
 
 	/* READ/WRITE LONG (obsolete) */
 	ATA_CMD_READ_LONG	= 0x22,
@@ -348,6 +355,7 @@ enum {
 	SATA_FPDMA_IN_ORDER	= 0x04,	/* FPDMA in-order data delivery */
 	SATA_AN			= 0x05,	/* Asynchronous Notification */
 	SATA_SSP		= 0x06,	/* Software Settings Preservation */
+	SATA_DEVSLP		= 0x09,	/* Device Sleep */
 
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,
@@ -584,6 +592,7 @@ static inline int ata_is_data(u8 prot)
 
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
 #define ata_id_has_da(id)	((id)[ATA_ID_SATA_CAPABILITY_2] & (1 << 4))
+#define ata_id_has_devslp(id)	((id)[ATA_ID_FEATURE_SUPP] & (1 << 8))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {

commit 583661a89ed2e484bd295e7b4606099340478c38
Author: Shane Huang <shane.huang@amd.com>
Date:   Fri Sep 7 22:38:20 2012 +0800

    ata: define enum constants for IDENTIFY DEVICE
    
    Define enumeration constants for IDENTIFY DEVICE words.
    
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 5713d3ac381a..47a9dbf02159 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -77,6 +77,9 @@ enum {
 	ATA_ID_EIDE_PIO_IORDY	= 68,
 	ATA_ID_ADDITIONAL_SUPP	= 69,
 	ATA_ID_QUEUE_DEPTH	= 75,
+	ATA_ID_SATA_CAPABILITY	= 76,
+	ATA_ID_SATA_CAPABILITY_2	= 77,
+	ATA_ID_FEATURE_SUPP	= 78,
 	ATA_ID_MAJOR_VER	= 80,
 	ATA_ID_COMMAND_SET_1	= 82,
 	ATA_ID_COMMAND_SET_2	= 83,
@@ -558,15 +561,17 @@ static inline int ata_is_data(u8 prot)
 #define ata_id_is_ata(id)	(((id)[ATA_ID_CONFIG] & (1 << 15)) == 0)
 #define ata_id_has_lba(id)	((id)[ATA_ID_CAPABILITY] & (1 << 9))
 #define ata_id_has_dma(id)	((id)[ATA_ID_CAPABILITY] & (1 << 8))
-#define ata_id_has_ncq(id)	((id)[76] & (1 << 8))
+#define ata_id_has_ncq(id)	((id)[ATA_ID_SATA_CAPABILITY] & (1 << 8))
 #define ata_id_queue_depth(id)	(((id)[ATA_ID_QUEUE_DEPTH] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[ATA_ID_CONFIG] & (1 << 7))
 #define ata_id_has_atapi_AN(id)	\
-	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
-	  ((id)[78] & (1 << 5)) )
+	((((id)[ATA_ID_SATA_CAPABILITY] != 0x0000) && \
+	  ((id)[ATA_ID_SATA_CAPABILITY] != 0xffff)) && \
+	 ((id)[ATA_ID_FEATURE_SUPP] & (1 << 5)))
 #define ata_id_has_fpdma_aa(id)	\
-	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
-	  ((id)[78] & (1 << 2)) )
+	((((id)[ATA_ID_SATA_CAPABILITY] != 0x0000) && \
+	  ((id)[ATA_ID_SATA_CAPABILITY] != 0xffff)) && \
+	 ((id)[ATA_ID_FEATURE_SUPP] & (1 << 2)))
 #define ata_id_iordy_disable(id) ((id)[ATA_ID_CAPABILITY] & (1 << 10))
 #define ata_id_has_iordy(id) ((id)[ATA_ID_CAPABILITY] & (1 << 11))
 #define ata_id_u32(id,n)	\
@@ -578,11 +583,11 @@ static inline int ata_is_data(u8 prot)
 	  ((u64) (id)[(n) + 0]) )
 
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
-#define ata_id_has_da(id)	((id)[77] & (1 << 4))
+#define ata_id_has_da(id)	((id)[ATA_ID_SATA_CAPABILITY_2] & (1 << 4))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {
-	u16 val = id[76];
+	u16 val = id[ATA_ID_SATA_CAPABILITY];
 
 	if (val == 0 || val == 0xffff)
 		return false;
@@ -592,7 +597,7 @@ static inline bool ata_id_has_hipm(const u16 *id)
 
 static inline bool ata_id_has_dipm(const u16 *id)
 {
-	u16 val = id[78];
+	u16 val = id[ATA_ID_FEATURE_SUPP];
 
 	if (val == 0 || val == 0xffff)
 		return false;

commit b1354cbb5bfce28f2e1ed28d77b362dfdfca638d
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jun 25 16:13:08 2012 +0800

    libata: detect Device Attention support
    
    Add a new flag ATA_DFLAG_DA to indicate that device supports "Device
    Attention".
    
    Acked-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 32df2b6ef0e0..5713d3ac381a 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -578,6 +578,7 @@ static inline int ata_is_data(u8 prot)
 	  ((u64) (id)[(n) + 0]) )
 
 #define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
+#define ata_id_has_da(id)	((id)[77] & (1 << 4))
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {

commit 4dce8ba94c751dd25f1d9b2d35c04312b046e5d6
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Mar 14 08:54:20 2011 +0100

    libata: Use 'bool' return value for ata_id_XXX
    
    Most ata_id_XXX inlines are simple tests, so we should set
    the return value to 'bool' here.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 198e1ea2b2eb..32df2b6ef0e0 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -600,42 +600,42 @@ static inline bool ata_id_has_dipm(const u16 *id)
 }
 
 
-static inline int ata_id_has_fua(const u16 *id)
+static inline bool ata_id_has_fua(const u16 *id)
 {
 	if ((id[ATA_ID_CFSSE] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_CFSSE] & (1 << 6);
 }
 
-static inline int ata_id_has_flush(const u16 *id)
+static inline bool ata_id_has_flush(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 12);
 }
 
-static inline int ata_id_flush_enabled(const u16 *id)
+static inline bool ata_id_flush_enabled(const u16 *id)
 {
 	if (ata_id_has_flush(id) == 0)
-		return 0;
+		return false;
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_CFS_ENABLE_2] & (1 << 12);
 }
 
-static inline int ata_id_has_flush_ext(const u16 *id)
+static inline bool ata_id_has_flush_ext(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 13);
 }
 
-static inline int ata_id_flush_ext_enabled(const u16 *id)
+static inline bool ata_id_flush_ext_enabled(const u16 *id)
 {
 	if (ata_id_has_flush_ext(id) == 0)
-		return 0;
+		return false;
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	/*
 	 * some Maxtor disks have bit 13 defined incorrectly
 	 * so check bit 10 too
@@ -688,64 +688,64 @@ static inline u16 ata_id_logical_sector_offset(const u16 *id,
 	return 0;
 }
 
-static inline int ata_id_has_lba48(const u16 *id)
+static inline bool ata_id_has_lba48(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	if (!ata_id_u64(id, ATA_ID_LBA_CAPACITY_2))
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 10);
 }
 
-static inline int ata_id_lba48_enabled(const u16 *id)
+static inline bool ata_id_lba48_enabled(const u16 *id)
 {
 	if (ata_id_has_lba48(id) == 0)
-		return 0;
+		return false;
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_CFS_ENABLE_2] & (1 << 10);
 }
 
-static inline int ata_id_hpa_enabled(const u16 *id)
+static inline bool ata_id_hpa_enabled(const u16 *id)
 {
 	/* Yes children, word 83 valid bits cover word 82 data */
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	/* And 87 covers 85-87 */
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	/* Check command sets enabled as well as supported */
 	if ((id[ATA_ID_CFS_ENABLE_1] & (1 << 10)) == 0)
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_1] & (1 << 10);
 }
 
-static inline int ata_id_has_wcache(const u16 *id)
+static inline bool ata_id_has_wcache(const u16 *id)
 {
 	/* Yes children, word 83 valid bits cover word 82 data */
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_1] & (1 << 5);
 }
 
-static inline int ata_id_has_pm(const u16 *id)
+static inline bool ata_id_has_pm(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_COMMAND_SET_1] & (1 << 3);
 }
 
-static inline int ata_id_rahead_enabled(const u16 *id)
+static inline bool ata_id_rahead_enabled(const u16 *id)
 {
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_CFS_ENABLE_1] & (1 << 6);
 }
 
-static inline int ata_id_wcache_enabled(const u16 *id)
+static inline bool ata_id_wcache_enabled(const u16 *id)
 {
 	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[ATA_ID_CFS_ENABLE_1] & (1 << 5);
 }
 
@@ -775,7 +775,7 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 	return mver;
 }
 
-static inline int ata_id_is_sata(const u16 *id)
+static inline bool ata_id_is_sata(const u16 *id)
 {
 	/*
 	 * See if word 93 is 0 AND drive is at least ATA-5 compatible
@@ -784,37 +784,35 @@ static inline int ata_id_is_sata(const u16 *id)
 	 * 0x0000 and 0xffff along with the earlier ATA revisions...
 	 */
 	if (id[ATA_ID_HW_CONFIG] == 0 && (short)id[ATA_ID_MAJOR_VER] >= 0x0020)
-		return 1;
-	return 0;
+		return true;
+	return false;
 }
 
-static inline int ata_id_has_tpm(const u16 *id)
+static inline bool ata_id_has_tpm(const u16 *id)
 {
 	/* The TPM bits are only valid on ATA8 */
 	if (ata_id_major_version(id) < 8)
-		return 0;
+		return false;
 	if ((id[48] & 0xC000) != 0x4000)
-		return 0;
+		return false;
 	return id[48] & (1 << 0);
 }
 
-static inline int ata_id_has_dword_io(const u16 *id)
+static inline bool ata_id_has_dword_io(const u16 *id)
 {
 	/* ATA 8 reuses this flag for "trusted" computing */
 	if (ata_id_major_version(id) > 7)
-		return 0;
-	if (id[ATA_ID_DWORD_IO] & (1 << 0))
-		return 1;
-	return 0;
+		return false;
+	return id[ATA_ID_DWORD_IO] & (1 << 0);
 }
 
-static inline int ata_id_has_unload(const u16 *id)
+static inline bool ata_id_has_unload(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&
 	    (id[ATA_ID_CFSSE] & 0xC000) == 0x4000 &&
 	    id[ATA_ID_CFSSE] & (1 << 13))
-		return 1;
-	return 0;
+		return true;
+	return false;
 }
 
 static inline bool ata_id_has_wwn(const u16 *id)
@@ -850,25 +848,25 @@ static inline int ata_id_rotation_rate(const u16 *id)
 	return val;
 }
 
-static inline int ata_id_has_trim(const u16 *id)
+static inline bool ata_id_has_trim(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&
 	    (id[ATA_ID_DATA_SET_MGMT] & 1))
-		return 1;
-	return 0;
+		return true;
+	return false;
 }
 
-static inline int ata_id_has_zero_after_trim(const u16 *id)
+static inline bool ata_id_has_zero_after_trim(const u16 *id)
 {
 	/* DSM supported, deterministic read, and read zero after trim set */
 	if (ata_id_has_trim(id) &&
 	    (id[ATA_ID_ADDITIONAL_SUPP] & 0x4020) == 0x4020)
-		return 1;
+		return true;
 
-	return 0;
+	return false;
 }
 
-static inline int ata_id_current_chs_valid(const u16 *id)
+static inline bool ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
 	   has not been issued to the device then the values of
@@ -880,11 +878,11 @@ static inline int ata_id_current_chs_valid(const u16 *id)
 		id[ATA_ID_CUR_SECTORS];    /* sectors in current translation */
 }
 
-static inline int ata_id_is_cfa(const u16 *id)
+static inline bool ata_id_is_cfa(const u16 *id)
 {
 	if ((id[ATA_ID_CONFIG] == 0x848A) ||	/* Traditional CF */
 	    (id[ATA_ID_CONFIG] == 0x844A))	/* Delkin Devices CF */
-		return 1;
+		return true;
 	/*
 	 * CF specs don't require specific value in the word 0 anymore and yet
 	 * they forbid to report the ATA version in the word 80 and require the
@@ -893,44 +891,40 @@ static inline int ata_id_is_cfa(const u16 *id)
 	 * and while those that don't indicate CFA feature support need some
 	 * sort of quirk list, it seems impractical for the ones that do...
 	 */
-	if ((id[ATA_ID_COMMAND_SET_2] & 0xC004) == 0x4004)
-		return 1;
-	return 0;
+	return (id[ATA_ID_COMMAND_SET_2] & 0xC004) == 0x4004;
 }
 
-static inline int ata_id_is_ssd(const u16 *id)
+static inline bool ata_id_is_ssd(const u16 *id)
 {
 	return id[ATA_ID_ROT_SPEED] == 0x01;
 }
 
-static inline int ata_id_pio_need_iordy(const u16 *id, const u8 pio)
+static inline bool ata_id_pio_need_iordy(const u16 *id, const u8 pio)
 {
 	/* CF spec. r4.1 Table 22 says no IORDY on PIO5 and PIO6. */
 	if (pio > 4 && ata_id_is_cfa(id))
-		return 0;
+		return false;
 	/* For PIO3 and higher it is mandatory. */
 	if (pio > 2)
-		return 1;
+		return true;
 	/* Turn it on when possible. */
-	if (ata_id_has_iordy(id))
-		return 1;
-	return 0;
+	return ata_id_has_iordy(id);
 }
 
-static inline int ata_drive_40wire(const u16 *dev_id)
+static inline bool ata_drive_40wire(const u16 *dev_id)
 {
 	if (ata_id_is_sata(dev_id))
-		return 0;	/* SATA */
+		return false;	/* SATA */
 	if ((dev_id[ATA_ID_HW_CONFIG] & 0xE000) == 0x6000)
-		return 0;	/* 80 wire */
-	return 1;
+		return false;	/* 80 wire */
+	return true;
 }
 
-static inline int ata_drive_40wire_relaxed(const u16 *dev_id)
+static inline bool ata_drive_40wire_relaxed(const u16 *dev_id)
 {
 	if ((dev_id[ATA_ID_HW_CONFIG] & 0x2000) == 0x2000)
-		return 0;	/* 80 wire */
-	return 1;
+		return false;	/* 80 wire */
+	return true;
 }
 
 static inline int atapi_cdb_len(const u16 *dev_id)
@@ -943,12 +937,12 @@ static inline int atapi_cdb_len(const u16 *dev_id)
 	}
 }
 
-static inline int atapi_command_packet_set(const u16 *dev_id)
+static inline bool atapi_command_packet_set(const u16 *dev_id)
 {
 	return (dev_id[ATA_ID_CONFIG] >> 8) & 0x1f;
 }
 
-static inline int atapi_id_dmadir(const u16 *dev_id)
+static inline bool atapi_id_dmadir(const u16 *dev_id)
 {
 	return ata_id_major_version(dev_id) >= 7 && (dev_id[62] & 0x8000);
 }
@@ -961,13 +955,13 @@ static inline int atapi_id_dmadir(const u16 *dev_id)
  *
  * It is called only once for each device.
  */
-static inline int ata_id_is_lba_capacity_ok(u16 *id)
+static inline bool ata_id_is_lba_capacity_ok(u16 *id)
 {
 	unsigned long lba_sects, chs_sects, head, tail;
 
 	/* No non-LBA info .. so valid! */
 	if (id[ATA_ID_CYLS] == 0)
-		return 1;
+		return true;
 
 	lba_sects = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
 
@@ -982,13 +976,13 @@ static inline int ata_id_is_lba_capacity_ok(u16 *id)
 	    id[ATA_ID_SECTORS] == 63 &&
 	    (id[ATA_ID_HEADS] == 15 || id[ATA_ID_HEADS] == 16) &&
 	    (lba_sects >= 16383 * 63 * id[ATA_ID_HEADS]))
-		return 1;
+		return true;
 
 	chs_sects = id[ATA_ID_CYLS] * id[ATA_ID_HEADS] * id[ATA_ID_SECTORS];
 
 	/* perform a rough sanity check on lba_sects: within 10% is OK */
 	if (lba_sects - chs_sects < chs_sects/10)
-		return 1;
+		return true;
 
 	/* some drives have the word order reversed */
 	head = (lba_sects >> 16) & 0xffff;
@@ -997,10 +991,10 @@ static inline int ata_id_is_lba_capacity_ok(u16 *id)
 
 	if (lba_sects - chs_sects < chs_sects/10) {
 		*(__le32 *)&id[ATA_ID_LBA_CAPACITY] = __cpu_to_le32(lba_sects);
-		return 1;	/* LBA capacity is (now) good */
+		return true;	/* LBA capacity is (now) good */
 	}
 
-	return 0;	/* LBA capacity value may be bad */
+	return false;	/* LBA capacity value may be bad */
 }
 
 static inline void ata_id_to_hd_driveid(u16 *id)
@@ -1058,19 +1052,19 @@ static inline int is_multi_taskfile(struct ata_taskfile *tf)
 	       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);
 }
 
-static inline int ata_ok(u8 status)
+static inline bool ata_ok(u8 status)
 {
 	return ((status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR))
 			== ATA_DRDY);
 }
 
-static inline int lba_28_ok(u64 block, u32 n_block)
+static inline bool lba_28_ok(u64 block, u32 n_block)
 {
 	/* check the ending block number: must be LESS THAN 0x0fffffff */
 	return ((block + n_block) < ((1 << 28) - 1)) && (n_block <= 256);
 }
 
-static inline int lba_48_ok(u64 block, u32 n_block)
+static inline bool lba_48_ok(u64 block, u32 n_block)
 {
 	/* check the ending block number */
 	return ((block + n_block - 1) < ((u64)1 << 48)) && (n_block <= 65536);

commit 6b3b9d73e08d8939aaf54f85bb47495171f49e20
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Mar 7 08:56:44 2011 +0100

    libata: Include WWN ID in inquiry VPD emulation
    
    As per SAT-3 the WWN ID should be included in the VPD page 0x83
    (device identification) emulation.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 0c4929fa34d3..198e1ea2b2eb 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -89,6 +89,7 @@ enum {
 	ATA_ID_SPG		= 98,
 	ATA_ID_LBA_CAPACITY_2	= 100,
 	ATA_ID_SECTOR_SIZE	= 106,
+	ATA_ID_WWN		= 108,
 	ATA_ID_LOGICAL_SECTOR_SIZE	= 117,	/* and 118 */
 	ATA_ID_LAST_LUN		= 126,
 	ATA_ID_DLF		= 128,
@@ -103,6 +104,7 @@ enum {
 	ATA_ID_SERNO_LEN	= 20,
 	ATA_ID_FW_REV_LEN	= 8,
 	ATA_ID_PROD_LEN		= 40,
+	ATA_ID_WWN_LEN		= 8,
 
 	ATA_PCI_CTL_OFS		= 2,
 
@@ -815,6 +817,11 @@ static inline int ata_id_has_unload(const u16 *id)
 	return 0;
 }
 
+static inline bool ata_id_has_wwn(const u16 *id)
+{
+	return (id[ATA_ID_CSF_DEFAULT] & 0xC100) == 0x4100;
+}
+
 static inline int ata_id_form_factor(const u16 *id)
 {
 	u16 val = id[168];

commit 295124dce4ddfd40b1f12d3ffd2779673e87c701
Author: Grant Grundler <grundler@google.com>
Date:   Tue Aug 17 10:56:53 2010 -0700

    [libata] support for > 512 byte sectors (e.g. 4K Native)
    
    This change enables my x86 machine to recognize and talk to a
    "Native 4K" SATA device.
    
    When I started working on this, I didn't know Matthew Wilcox had
    posted a similar patch 2 years ago:
      http://git.kernel.org/?p=linux/kernel/git/willy/ata.git;a=shortlog;h=refs/heads/ata-large-sectors
    
    Gwendal Grignou pointed me at the the above code and small portions of
    this patch include Matthew's work. That's why Mathew is first on the
    "Signed-off-by:". I've NOT included his use of a bitmap to determine
    512 vs Native for ATA command block size - just used a simple table.
    And bugs are almost certainly mine.
    
    Lastly, the patch has been tested with a native 4K 'Engineering
    Sample' drive provided by Hitachi GST.
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Signed-off-by: Grant Grundler <grundler@google.com>
    Reviewed-by: Gwendal Grignou <gwendal@google.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index fe6e681a9d74..0c4929fa34d3 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -89,6 +89,7 @@ enum {
 	ATA_ID_SPG		= 98,
 	ATA_ID_LBA_CAPACITY_2	= 100,
 	ATA_ID_SECTOR_SIZE	= 106,
+	ATA_ID_LOGICAL_SECTOR_SIZE	= 117,	/* and 118 */
 	ATA_ID_LAST_LUN		= 126,
 	ATA_ID_DLF		= 128,
 	ATA_ID_CSFO		= 129,
@@ -640,16 +641,49 @@ static inline int ata_id_flush_ext_enabled(const u16 *id)
 	return (id[ATA_ID_CFS_ENABLE_2] & 0x2400) == 0x2400;
 }
 
-static inline int ata_id_has_large_logical_sectors(const u16 *id)
+static inline u32 ata_id_logical_sector_size(const u16 *id)
 {
-	if ((id[ATA_ID_SECTOR_SIZE] & 0xc000) != 0x4000)
-		return 0;
-	return id[ATA_ID_SECTOR_SIZE] & (1 << 13);
+	/* T13/1699-D Revision 6a, Sep 6, 2008. Page 128.
+	 * IDENTIFY DEVICE data, word 117-118.
+	 * 0xd000 ignores bit 13 (logical:physical > 1)
+	 */
+	if ((id[ATA_ID_SECTOR_SIZE] & 0xd000) == 0x5000)
+		return (((id[ATA_ID_LOGICAL_SECTOR_SIZE+1] << 16)
+			 + id[ATA_ID_LOGICAL_SECTOR_SIZE]) * sizeof(u16)) ;
+	return ATA_SECT_SIZE;
+}
+
+static inline u8 ata_id_log2_per_physical_sector(const u16 *id)
+{
+	/* T13/1699-D Revision 6a, Sep 6, 2008. Page 128.
+	 * IDENTIFY DEVICE data, word 106.
+	 * 0xe000 ignores bit 12 (logical sector > 512 bytes)
+	 */
+	if ((id[ATA_ID_SECTOR_SIZE] & 0xe000) == 0x6000)
+		return (id[ATA_ID_SECTOR_SIZE] & 0xf);
+	return 0;
 }
 
-static inline u16 ata_id_logical_per_physical_sectors(const u16 *id)
+/* Offset of logical sectors relative to physical sectors.
+ *
+ * If device has more than one logical sector per physical sector
+ * (aka 512 byte emulation), vendors might offset the "sector 0" address
+ * so sector 63 is "naturally aligned" - e.g. FAT partition table.
+ * This avoids Read/Mod/Write penalties when using FAT partition table
+ * and updating "well aligned" (FS perspective) physical sectors on every
+ * transaction.
+ */
+static inline u16 ata_id_logical_sector_offset(const u16 *id,
+	 u8 log2_per_phys)
 {
-	return 1 << (id[ATA_ID_SECTOR_SIZE] & 0xf);
+	u16 word_209 = id[209];
+
+	if ((log2_per_phys > 1) && (word_209 & 0xc000) == 0x4000) {
+		u16 first = word_209 & 0x3fff;
+		if (first > 0)
+			return (1 << log2_per_phys) - first;
+	}
+	return 0;
 }
 
 static inline int ata_id_has_lba48(const u16 *id)

commit f60d70113fa04e32aee2dedbf304a48469c9c45c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:41 2010 +0200

    libata-sff: prd is BMDMA specific
    
    struct ata_prd and ap->prd are BMDMA specific.  Add bmdma_ prefix to
    them and move them inside CONFIG_ATA_SFF.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 700c5b9b3583..fe6e681a9d74 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -467,7 +467,7 @@ enum ata_ioctls {
 
 /* core structures */
 
-struct ata_prd {
+struct ata_bmdma_prd {
 	__le32			addr;
 	__le32			flags_len;
 };

commit 45c4d015a92f72ec47acd0c7557abdc0c8a6499d
Author: Mark Lord <kernel@teksavvy.com>
Date:   Wed Apr 7 13:52:08 2010 -0400

    libata: Fix accesses at LBA28 boundary (old bug, but nasty) (v2)
    
    Most drives from Seagate, Hitachi, and possibly other brands,
    do not allow LBA28 access to sector number 0x0fffffff (2^28 - 1).
    So instead use LBA48 for such accesses.
    
    This bug could bite a lot of systems, especially when the user has
    taken care to align partitions to 4KB boundaries. On misaligned systems,
    it is less likely to be encountered, since a 4KB read would end at
    0x10000000 rather than at 0x0fffffff.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b4c85e2adef5..700c5b9b3583 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -1025,8 +1025,8 @@ static inline int ata_ok(u8 status)
 
 static inline int lba_28_ok(u64 block, u32 n_block)
 {
-	/* check the ending block number */
-	return ((block + n_block) < ((u64)1 << 28)) && (n_block <= 256);
+	/* check the ending block number: must be LESS THAN 0x0fffffff */
+	return ((block + n_block) < ((1 << 28) - 1)) && (n_block <= 256);
 }
 
 static inline int lba_48_ok(u64 block, u32 n_block)

commit 4b7d1c0509d0d07edc731f990791dc5518e51617
Author: Ben Gardner <gardner.ben@gmail.com>
Date:   Tue Feb 23 12:41:22 2010 -0600

    ata: Detect Delkin Devices compact flash
    
    I have a Delkin Devices compact flash card that isn't being recognized using the
    SATA/PATA drivers.
    The card is recognized and works with the deprecated ATA drivers.
    
    The error I am seeing is:
    ata1.00: failed to IDENTIFY (device reports invalid type, err_mask=0x0)
    
    I tracked it down to ata_id_is_cfa() in include/linux/ata.h.
    The Delkin card has id[0] set to 0x844a and id[83] set to 0.
    This isn't what the kernel expects and is probably incorrect.
    
    The simplest work-around is to add a check for 0x844a to ata_id_is_cfa().
    
    Signed-off-by: Ben Gardner <gardner.ben@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 20f31567ccee..b4c85e2adef5 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -841,7 +841,8 @@ static inline int ata_id_current_chs_valid(const u16 *id)
 
 static inline int ata_id_is_cfa(const u16 *id)
 {
-	if (id[ATA_ID_CONFIG] == 0x848A)	/* Traditional CF */
+	if ((id[ATA_ID_CONFIG] == 0x848A) ||	/* Traditional CF */
+	    (id[ATA_ID_CONFIG] == 0x844A))	/* Delkin Devices CF */
 		return 1;
 	/*
 	 * CF specs don't require specific value in the word 0 anymore and yet

commit f7acede65d6b65919aee5b6a360a17cedb11f2f7
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jan 28 13:30:11 2010 +0100

    libata: fix ata_id_logical_per_physical_sectors
    
    The value we get from the low byte of the ATA_ID_SECTOR_SIZE word is not not
    a plain multiple, but the log of it, so fix the helper to give the correct
    answer.  Without this we'll get an incorrect minimal I/O size in the block
    limits VPD page for 4k sector drives.
    
    Also change the return value of ata_id_logical_per_physical_sectors to u16
    for the unlikely case of very large logical sectors.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 38a6948ce0c2..20f31567ccee 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -647,9 +647,9 @@ static inline int ata_id_has_large_logical_sectors(const u16 *id)
 	return id[ATA_ID_SECTOR_SIZE] & (1 << 13);
 }
 
-static inline u8 ata_id_logical_per_physical_sectors(const u16 *id)
+static inline u16 ata_id_logical_per_physical_sectors(const u16 *id)
 {
-	return id[ATA_ID_SECTOR_SIZE] & 0xf;
+	return 1 << (id[ATA_ID_SECTOR_SIZE] & 0xf);
 }
 
 static inline int ata_id_has_lba48(const u16 *id)

commit d0634c4aea0b80447cbdc4c0db285004b860c455
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Nov 26 12:00:43 2009 -0500

    libata: Clarify ata_set_lba_range_entries function
    
    ata_set_lba_range_entries used the variable max for two different things
    which was confusing.  Make the function take a buffer size in bytes as
    argument and return the used buffer size upon completion.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index dfa2298bf488..38a6948ce0c2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -982,17 +982,17 @@ static inline void ata_id_to_hd_driveid(u16 *id)
 }
 
 /*
- * Write up to 'max' LBA Range Entries to the buffer that will cover the
- * extent from sector to sector + count.  This is used for TRIM and for
- * ADD LBA(S) TO NV CACHE PINNED SET.
+ * Write LBA Range Entries to the buffer that will cover the extent from
+ * sector to sector + count.  This is used for TRIM and for ADD LBA(S)
+ * TO NV CACHE PINNED SET.
  */
-static inline unsigned ata_set_lba_range_entries(void *_buffer, unsigned max,
-						u64 sector, unsigned long count)
+static inline unsigned ata_set_lba_range_entries(void *_buffer,
+		unsigned buf_size, u64 sector, unsigned long count)
 {
 	__le64 *buffer = _buffer;
-	unsigned i = 0;
+	unsigned i = 0, used_bytes;
 
-	while (i < max) {
+	while (i < buf_size / 8 ) { /* 6-byte LBA + 2-byte range per entry */
 		u64 entry = sector |
 			((u64)(count > 0xffff ? 0xffff : count) << 48);
 		buffer[i++] = __cpu_to_le64(entry);
@@ -1002,9 +1002,9 @@ static inline unsigned ata_set_lba_range_entries(void *_buffer, unsigned max,
 		sector += 0xffff;
 	}
 
-	max = ALIGN(i * 8, 512);
-	memset(buffer + i, 0, max - i * 8);
-	return max;
+	used_bytes = ALIGN(i * 8, 512);
+	memset(buffer + i, 0, used_bytes - i * 8);
+	return used_bytes;
 }
 
 static inline int is_multi_taskfile(struct ata_taskfile *tf)

commit e78db4dfb1355a895f7ea50133b702b55b8ed184
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Nov 26 22:46:03 2009 -0500

    libata: Report zeroed read after TRIM and max discard size
    
    Our current TRIM payload is a single sector that can accommodate 64 *
    65535 blocks being unmapped.  Report this value in the Block Limits
    Maximum Unmap LBA count field.
    
    If a storage device supports TRIM and the DRAT and RZAT bits are set,
    report TPRZ=1 in Read Capacity(16).
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e2595e877e44..dfa2298bf488 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -75,6 +75,7 @@ enum {
 	ATA_ID_EIDE_DMA_TIME	= 66,
 	ATA_ID_EIDE_PIO		= 67,
 	ATA_ID_EIDE_PIO_IORDY	= 68,
+	ATA_ID_ADDITIONAL_SUPP	= 69,
 	ATA_ID_QUEUE_DEPTH	= 75,
 	ATA_ID_MAJOR_VER	= 80,
 	ATA_ID_COMMAND_SET_1	= 82,
@@ -816,6 +817,16 @@ static inline int ata_id_has_trim(const u16 *id)
 	return 0;
 }
 
+static inline int ata_id_has_zero_after_trim(const u16 *id)
+{
+	/* DSM supported, deterministic read, and read zero after trim set */
+	if (ata_id_has_trim(id) &&
+	    (id[ATA_ID_ADDITIONAL_SUPP] & 0x4020) == 0x4020)
+		return 1;
+
+	return 0;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command

commit 18f0f97850059303ed73b1f02084f55ca330a80c
Author: Christoph Hellwig <hch@infradead.org>
Date:   Tue Nov 17 10:00:47 2009 -0500

    libata: add translation for SCSI WRITE SAME (aka TRIM support)
    
    Add support for the ATA TRIM command in libata.  We translate a WRITE SAME 16
    command with the unmap bit set into an ATA TRIM command and export enough
    information in READ CAPACITY 16 and the block limits EVPD page so that the new
    SCSI layer discard support will driver this for us.
    
    Note that I hardcode the WRITE_SAME_16 opcode for now as the patch to introduce
    the symbolic is not in 2.6.32 yet but only in the SCSI tree - as soon as it is
    merged we can fix it up to properly use the symbolic name.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 4fb357312b3b..e2595e877e44 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -87,6 +87,7 @@ enum {
 	ATA_ID_HW_CONFIG	= 93,
 	ATA_ID_SPG		= 98,
 	ATA_ID_LBA_CAPACITY_2	= 100,
+	ATA_ID_SECTOR_SIZE	= 106,
 	ATA_ID_LAST_LUN		= 126,
 	ATA_ID_DLF		= 128,
 	ATA_ID_CSFO		= 129,
@@ -638,6 +639,18 @@ static inline int ata_id_flush_ext_enabled(const u16 *id)
 	return (id[ATA_ID_CFS_ENABLE_2] & 0x2400) == 0x2400;
 }
 
+static inline int ata_id_has_large_logical_sectors(const u16 *id)
+{
+	if ((id[ATA_ID_SECTOR_SIZE] & 0xc000) != 0x4000)
+		return 0;
+	return id[ATA_ID_SECTOR_SIZE] & (1 << 13);
+}
+
+static inline u8 ata_id_logical_per_physical_sectors(const u16 *id)
+{
+	return id[ATA_ID_SECTOR_SIZE] & 0xf;
+}
+
 static inline int ata_id_has_lba48(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)

commit fa5b561c4ea170caf9759109acc2e961a7e83bea
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:17:02 2009 +0900

    libata: implement more acpi filtering options
    
    Currently libata-acpi can only filter DIPM among SATA feature enables
    via _GTF.  This patch adds the capability to filter out FPDMA non-zero
    offset, in-order guarantee and auto-activation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 7c5beafa972c..4fb357312b3b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -334,9 +334,12 @@ enum {
 	SETFEATURES_SATA_DISABLE = 0x90, /* Disable use of SATA feature */
 
 	/* SETFEATURE Sector counts for SATA features */
+	SATA_FPDMA_OFFSET	= 0x01,	/* FPDMA non-zero buffer offsets */
 	SATA_FPDMA_AA		= 0x02, /* FPDMA Setup FIS Auto-Activate */
 	SATA_DIPM		= 0x03,	/* Device Initiated Power Management */
+	SATA_FPDMA_IN_ORDER	= 0x04,	/* FPDMA in-order data delivery */
 	SATA_AN			= 0x05,	/* Asynchronous Notification */
+	SATA_SSP		= 0x06,	/* Software Settings Preservation */
 
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,

commit f1bce7f80e3b400cf29787b0afa9c3042b959017
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:16:04 2009 +0900

    libata: cosmetic updates
    
    We're about to add more SATA_* and ATA_ACPI_FILTER_* constants.
    Reformat them in preparation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 6299a259ed19..7c5beafa972c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -334,9 +334,9 @@ enum {
 	SETFEATURES_SATA_DISABLE = 0x90, /* Disable use of SATA feature */
 
 	/* SETFEATURE Sector counts for SATA features */
-	SATA_AN			= 0x05,  /* Asynchronous Notification */
-	SATA_DIPM		= 0x03,  /* Device Initiated Power Management */
-	SATA_FPDMA_AA		= 0x02,  /* DMA Setup FIS Auto-Activate */
+	SATA_FPDMA_AA		= 0x02, /* FPDMA Setup FIS Auto-Activate */
+	SATA_DIPM		= 0x03,	/* Device Initiated Power Management */
+	SATA_AN			= 0x05,	/* Asynchronous Notification */
 
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,

commit 6521148c6449724c3b707820b9c535c7e8b8afcd
Author: Robert Hancock <hancockrwd@gmail.com>
Date:   Tue Jul 14 20:43:39 2009 -0600

    libata: add command name parsing for error output
    
    This patch improve libata's output for error/notification messages
    to allow easier comprehension and debugging:
    
    When ATAPI commands issued through the SCSI layer fail, use SCSI
    functions to print the CDB in human-readable form instead of just
    dumping out the CDB in hex.
    
    Print out the name of the failed command (as defined by the ATA
    specification) in error handling output along with the raw register
    contents.
    
    When reporting status of ACPI taskfile commands executed on resume,
    also output the names of the commands being executed (or not) in
    readable form.
    
    Since the extra data for printing command names increases kernel
    size slightly, a config option has been added to allow disabling
    command name output (as well as some of the error register parsing)
    for those highly sensitive to kernel text size.
    
    Signed-off-by: Robert Hancock <hancockrwd@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f5494050df83..6299a259ed19 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -210,15 +210,25 @@ enum {
 	ATA_CMD_STANDBY		= 0xE2, /* place in standby power mode */
 	ATA_CMD_IDLE		= 0xE3, /* place in idle power mode */
 	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
+	ATA_CMD_DOWNLOAD_MICRO  = 0x92,
+	ATA_CMD_NOP		= 0x00,
 	ATA_CMD_FLUSH		= 0xE7,
 	ATA_CMD_FLUSH_EXT	= 0xEA,
 	ATA_CMD_ID_ATA		= 0xEC,
 	ATA_CMD_ID_ATAPI	= 0xA1,
+	ATA_CMD_SERVICE		= 0xA2,
 	ATA_CMD_READ		= 0xC8,
 	ATA_CMD_READ_EXT	= 0x25,
+	ATA_CMD_READ_QUEUED	= 0x26,
+	ATA_CMD_READ_STREAM_EXT	= 0x2B,
+	ATA_CMD_READ_STREAM_DMA_EXT = 0x2A,
 	ATA_CMD_WRITE		= 0xCA,
 	ATA_CMD_WRITE_EXT	= 0x35,
+	ATA_CMD_WRITE_QUEUED	= 0x36,
+	ATA_CMD_WRITE_STREAM_EXT = 0x3B,
+	ATA_CMD_WRITE_STREAM_DMA_EXT = 0x3A,
 	ATA_CMD_WRITE_FUA_EXT	= 0x3D,
+	ATA_CMD_WRITE_QUEUED_FUA_EXT = 0x3E,
 	ATA_CMD_FPDMA_READ	= 0x60,
 	ATA_CMD_FPDMA_WRITE	= 0x61,
 	ATA_CMD_PIO_READ	= 0x20,
@@ -235,6 +245,7 @@ enum {
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
+	ATA_CMD_WRITE_UNCORR_EXT = 0x45,
 	ATA_CMD_STANDBYNOW1	= 0xE0,
 	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
 	ATA_CMD_SLEEP		= 0xE6,
@@ -243,15 +254,34 @@ enum {
 	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,
 	ATA_CMD_SET_MAX		= 0xF9,
 	ATA_CMD_SET_MAX_EXT	= 0x37,
-	ATA_CMD_READ_LOG_EXT	= 0x2f,
+	ATA_CMD_READ_LOG_EXT	= 0x2F,
+	ATA_CMD_WRITE_LOG_EXT	= 0x3F,
+	ATA_CMD_READ_LOG_DMA_EXT = 0x47,
+	ATA_CMD_WRITE_LOG_DMA_EXT = 0x57,
+	ATA_CMD_TRUSTED_RCV	= 0x5C,
+	ATA_CMD_TRUSTED_RCV_DMA = 0x5D,
+	ATA_CMD_TRUSTED_SND	= 0x5E,
+	ATA_CMD_TRUSTED_SND_DMA = 0x5F,
 	ATA_CMD_PMP_READ	= 0xE4,
 	ATA_CMD_PMP_WRITE	= 0xE8,
 	ATA_CMD_CONF_OVERLAY	= 0xB1,
+	ATA_CMD_SEC_SET_PASS	= 0xF1,
+	ATA_CMD_SEC_UNLOCK	= 0xF2,
+	ATA_CMD_SEC_ERASE_PREP	= 0xF3,
+	ATA_CMD_SEC_ERASE_UNIT	= 0xF4,
 	ATA_CMD_SEC_FREEZE_LOCK	= 0xF5,
+	ATA_CMD_SEC_DISABLE_PASS = 0xF6,
+	ATA_CMD_CONFIG_STREAM	= 0x51,
 	ATA_CMD_SMART		= 0xB0,
 	ATA_CMD_MEDIA_LOCK	= 0xDE,
 	ATA_CMD_MEDIA_UNLOCK	= 0xDF,
 	ATA_CMD_DSM		= 0x06,
+	ATA_CMD_CHK_MED_CRD_TYP = 0xD1,
+	ATA_CMD_CFA_REQ_EXT_ERR = 0x03,
+	ATA_CMD_CFA_WRITE_NE	= 0x38,
+	ATA_CMD_CFA_TRANS_SECT	= 0x87,
+	ATA_CMD_CFA_ERASE	= 0xC0,
+	ATA_CMD_CFA_WRITE_MULT_NE = 0xCD,
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 

commit 388539f3ff0cf1de926b03f94e1eec112358f74d
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Jul 27 09:24:35 2009 +0800

    [libata] add DMA setup FIS auto-activate feature
    
    Hopefully results in fewer on-the-wire FIS's and no breakage.  We'll see!
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 9c75921f0c16..f5494050df83 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -306,6 +306,7 @@ enum {
 	/* SETFEATURE Sector counts for SATA features */
 	SATA_AN			= 0x05,  /* Asynchronous Notification */
 	SATA_DIPM		= 0x03,  /* Device Initiated Power Management */
+	SATA_FPDMA_AA		= 0x02,  /* DMA Setup FIS Auto-Activate */
 
 	/* feature values for SET_MAX */
 	ATA_SET_MAX_ADDR	= 0x00,
@@ -525,6 +526,9 @@ static inline int ata_is_data(u8 prot)
 #define ata_id_has_atapi_AN(id)	\
 	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
 	  ((id)[78] & (1 << 5)) )
+#define ata_id_has_fpdma_aa(id)	\
+	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
+	  ((id)[78] & (1 << 2)) )
 #define ata_id_iordy_disable(id) ((id)[ATA_ID_CAPABILITY] & (1 << 10))
 #define ata_id_has_iordy(id) ((id)[ATA_ID_CAPABILITY] & (1 << 11))
 #define ata_id_u32(id,n)	\

commit 6dae44f9a55f13765c877687602cd2bf1a057cfd
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Jun 15 18:52:52 2009 +0200

    ata: add ata_id_pio_need_iordy() helper (v2)
    
    v2:
    Minor fixes per Sergei's review.
    
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 915da43edee1..9c75921f0c16 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -800,6 +800,20 @@ static inline int ata_id_is_ssd(const u16 *id)
 	return id[ATA_ID_ROT_SPEED] == 0x01;
 }
 
+static inline int ata_id_pio_need_iordy(const u16 *id, const u8 pio)
+{
+	/* CF spec. r4.1 Table 22 says no IORDY on PIO5 and PIO6. */
+	if (pio > 4 && ata_id_is_cfa(id))
+		return 0;
+	/* For PIO3 and higher it is mandatory. */
+	if (pio > 2)
+		return 1;
+	/* Turn it on when possible. */
+	if (ata_id_has_iordy(id))
+		return 1;
+	return 0;
+}
+
 static inline int ata_drive_40wire(const u16 *dev_id)
 {
 	if (ata_id_is_sata(dev_id))

commit 4bca3286433585b5f1c3e7d8ac37a2f4b3def9ca
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri May 15 00:40:35 2009 -0400

    libata: Media rotation rate and form factor heuristics
    
    This patch provides new heuristics for parsing both the form factor and
    media rotation rate ATA IDENFITY words.
    
    The reported ATA version must be 7 or greater and the device must return
    values defined as valid in the standard.  Only then are the
    characteristics reported to SCSI via the VPD B1 page.
    
    This seems like a reasonable compromise to me considering that we have
    been shipping several kernel releases that key off the rotation rate bit
    without any version checking whatsoever.  With no complaints so far.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index cb79b7a208e1..915da43edee1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -730,6 +730,34 @@ static inline int ata_id_has_unload(const u16 *id)
 	return 0;
 }
 
+static inline int ata_id_form_factor(const u16 *id)
+{
+	u16 val = id[168];
+
+	if (ata_id_major_version(id) < 7 || val == 0 || val == 0xffff)
+		return 0;
+
+	val &= 0xf;
+
+	if (val > 5)
+		return 0;
+
+	return val;
+}
+
+static inline int ata_id_rotation_rate(const u16 *id)
+{
+	u16 val = id[217];
+
+	if (ata_id_major_version(id) < 7 || val == 0 || val == 0xffff)
+		return 0;
+
+	if (val > 1 && val < 0x401)
+		return 0;
+
+	return val;
+}
+
 static inline int ata_id_has_trim(const u16 *id)
 {
 	if (ata_id_major_version(id) >= 7 &&

commit 0c659b82d11eaf5e1bee1f2bcb9994b9d09d175c
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Thu Apr 2 10:37:25 2009 -0400

    ata: Add TRIM infrastructure
    
    This is common code shared between the IDE and libata implementations
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 6617c9f8f2ca..cb79b7a208e1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -29,6 +29,8 @@
 #ifndef __LINUX_ATA_H__
 #define __LINUX_ATA_H__
 
+#include <linux/kernel.h>
+#include <linux/string.h>
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
@@ -91,6 +93,7 @@ enum {
 	ATA_ID_CFA_POWER	= 160,
 	ATA_ID_CFA_KEY_MGMT	= 162,
 	ATA_ID_CFA_MODES	= 163,
+	ATA_ID_DATA_SET_MGMT	= 169,
 	ATA_ID_ROT_SPEED	= 217,
 	ATA_ID_PIO4		= (1 << 1),
 
@@ -248,6 +251,7 @@ enum {
 	ATA_CMD_SMART		= 0xB0,
 	ATA_CMD_MEDIA_LOCK	= 0xDE,
 	ATA_CMD_MEDIA_UNLOCK	= 0xDF,
+	ATA_CMD_DSM		= 0x06,
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
 
@@ -321,6 +325,9 @@ enum {
 	ATA_SMART_READ_VALUES	= 0xD0,
 	ATA_SMART_READ_THRESHOLDS = 0xD1,
 
+	/* feature values for Data Set Management */
+	ATA_DSM_TRIM		= 0x01,
+
 	/* password used in LBA Mid / LBA High for executing SMART commands */
 	ATA_SMART_LBAM_PASS	= 0x4F,
 	ATA_SMART_LBAH_PASS	= 0xC2,
@@ -723,6 +730,14 @@ static inline int ata_id_has_unload(const u16 *id)
 	return 0;
 }
 
+static inline int ata_id_has_trim(const u16 *id)
+{
+	if (ata_id_major_version(id) >= 7 &&
+	    (id[ATA_ID_DATA_SET_MGMT] & 1))
+		return 1;
+	return 0;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
@@ -863,6 +878,32 @@ static inline void ata_id_to_hd_driveid(u16 *id)
 #endif
 }
 
+/*
+ * Write up to 'max' LBA Range Entries to the buffer that will cover the
+ * extent from sector to sector + count.  This is used for TRIM and for
+ * ADD LBA(S) TO NV CACHE PINNED SET.
+ */
+static inline unsigned ata_set_lba_range_entries(void *_buffer, unsigned max,
+						u64 sector, unsigned long count)
+{
+	__le64 *buffer = _buffer;
+	unsigned i = 0;
+
+	while (i < max) {
+		u64 entry = sector |
+			((u64)(count > 0xffff ? 0xffff : count) << 48);
+		buffer[i++] = __cpu_to_le64(entry);
+		if (count <= 0xffff)
+			break;
+		count -= 0xffff;
+		sector += 0xffff;
+	}
+
+	max = ALIGN(i * 8, 512);
+	memset(buffer + i, 0, max - i * 8);
+	return max;
+}
+
 static inline int is_multi_taskfile(struct ata_taskfile *tf)
 {
 	return (tf->command == ATA_CMD_READ_MULTI) ||

commit 0384e2959127a56d0640505d004d8dd92f9c29f5
Merge: 61a091827e27 c96f1732e253
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 26 11:20:23 2009 -0700

    Merge branch 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jgarzik/libata-dev
    
    * 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jgarzik/libata-dev: (35 commits)
      [libata] Improve timeout handling
      [libata] Drain data on errors
      pata_sc1200: Activate secondary channel
      pata_artop: Serializing support
      [libata] ahci: correct enclosure LED state save
      [libata] More robust parsing for IDENTIFY DEVICE multi_count field
      sata_mv: fix LED blinking for SoC+NCQ
      sata_mv: optimize IRQ coalescing for 8-port chips
      sata_mv: implement IRQ coalescing (v2)
      sata_mv: cosmetic preparations for IRQ coalescing
      pata-rb532-cf: platform_get_irq() fix ignored failure
      pata_efar: fix *dma_mask
      pata_radisys: fix mwdma_mask to exclude mwdma0
      [libata] convert drivers to use ata.h mode mask defines
      include/linux/ata.h: add some more transfer masks
      ahci: Blacklist HP Compaq 6720s that spins off disks during ACPI power off
      [libata] sata_mv: Implement direct FIS transmission via mv_qc_issue_fis().
      [libata] Export ata_pio_queue_task() so that it can be used from sata_mv.
      [libata] sata_mv: Add a new mv_sff_check_status() function to sata_mv.
      [libata] sata_mv: Tighten up interrupt masking in mv_qc_issue()
      ...

commit 22ddbd1e036ce035c1cccb2496aefafac79aba2c
Author: Erik Inge Bols <knan-lkml@anduin.net>
Date:   Sat Mar 14 21:37:48 2009 +0100

    include/linux/ata.h: add some more transfer masks
    
    Signed-off-by: Erik Inge Bols <knan-lkml@anduin.net>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 9a061accd8b8..3901b0022cda 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -108,6 +108,8 @@ enum {
 	ATA_PIO5		= ATA_PIO4 | (1 << 5),
 	ATA_PIO6		= ATA_PIO5 | (1 << 6),
 
+	ATA_PIO4_ONLY		= (1 << 4),
+
 	ATA_SWDMA0		= (1 << 0),
 	ATA_SWDMA1		= ATA_SWDMA0 | (1 << 1),
 	ATA_SWDMA2		= ATA_SWDMA1 | (1 << 2),
@@ -117,6 +119,8 @@ enum {
 	ATA_MWDMA0		= (1 << 0),
 	ATA_MWDMA1		= ATA_MWDMA0 | (1 << 1),
 	ATA_MWDMA2		= ATA_MWDMA1 | (1 << 2),
+	ATA_MWDMA3		= ATA_MWDMA2 | (1 << 3),
+	ATA_MWDMA4		= ATA_MWDMA3 | (1 << 4),
 
 	ATA_MWDMA12_ONLY	= (1 << 1) | (1 << 2),
 	ATA_MWDMA2_ONLY		= (1 << 2),
@@ -131,6 +135,8 @@ enum {
 	ATA_UDMA7		= ATA_UDMA6 | (1 << 7),
 	/* ATA_UDMA7 is just for completeness... doesn't exist (yet?).  */
 
+	ATA_UDMA24_ONLY		= (1 << 2) | (1 << 4),
+
 	ATA_UDMA_MASK_40C	= ATA_UDMA2,	/* udma0-2 */
 
 	/* DMA-related */

commit 552d3a99bdce8a0d7f9abe3766fb3655ef5757dc
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Tue Mar 24 23:22:58 2009 +0100

    ide: remove broken EXABYTENEST support
    
    do_identify() marks EXABYTENEST device as non-present and frees
    drive->id so enable_nest() has absolutely no chance of working.
    
    The code was like this since at least 2.6.12-rc2 and nobody
    has noticed so just remove broken EXABYTENEST support.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 9a061accd8b8..68132c4a0e91 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -244,8 +244,6 @@ enum {
 	ATA_CMD_MEDIA_UNLOCK	= 0xDF,
 	/* marked obsolete in the ATA/ATAPI-7 spec */
 	ATA_CMD_RESTORE		= 0x10,
-	/* EXABYTE specific */
-	ATA_EXABYTE_ENABLE_NEST	= 0xF0,
 
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,

commit d42ad15b759d05a87f22b484af63987eff38ea88
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Thu Mar 5 17:20:55 2009 +0100

    ata: add CFA specific identify data words
    
    Declare CFA specific identify data words 162 and 163 for future use.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    [bart: update patch summary/description]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 08a86d5cdf1b..9a061accd8b8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -89,6 +89,8 @@ enum {
 	ATA_ID_DLF		= 128,
 	ATA_ID_CSFO		= 129,
 	ATA_ID_CFA_POWER	= 160,
+	ATA_ID_CFA_KEY_MGMT	= 162,
+	ATA_ID_CFA_MODES	= 163,
 	ATA_ID_ROT_SPEED	= 217,
 	ATA_ID_PIO4		= (1 << 1),
 

commit 2999b58b795ad81f10e34bdbbfd2742172f247e4
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Feb 1 20:46:39 2009 +0400

    ide/libata: fix ata_id_is_cfa() (take 4)
    
    When checking for the CFA feature set support, ata_id_is_cfa() tests bit 2 in
    word 82 of the identify data instead the word 83;  it also checks the ATA/PI
    version support in the word 80 (which the CompactFlash specifications have as
    reserved), this having no slightest chance to work on the modern CF cards that
    don't have 0x848A in the word 0...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index a53318b8cbd0..08a86d5cdf1b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -731,12 +731,17 @@ static inline int ata_id_current_chs_valid(const u16 *id)
 
 static inline int ata_id_is_cfa(const u16 *id)
 {
-	if (id[ATA_ID_CONFIG] == 0x848A)	/* Standard CF */
+	if (id[ATA_ID_CONFIG] == 0x848A)	/* Traditional CF */
 		return 1;
-	/* Could be CF hiding as standard ATA */
-	if (ata_id_major_version(id) >= 3 &&
-	    id[ATA_ID_COMMAND_SET_1] != 0xFFFF &&
-	   (id[ATA_ID_COMMAND_SET_1] & (1 << 2)))
+	/*
+	 * CF specs don't require specific value in the word 0 anymore and yet
+	 * they forbid to report the ATA version in the word 80 and require the
+	 * CFA feature set support to be indicated in the word 83 in this case.
+	 * Unfortunately, some cards only follow either of this requirements,
+	 * and while those that don't indicate CFA feature support need some
+	 * sort of quirk list, it seems impractical for the ones that do...
+	 */
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC004) == 0x4004)
 		return 1;
 	return 0;
 }

commit a02227c9774b3bff08c7f557d06247e0a03ac435
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:31 2008 +0200

    ide: lba_capacity_is_ok() -> ata_id_is_lba_capacity_ok()
    
    Rename lba_capacity_is_ok() to ata_id_is_lba_capacity_ok()
    and move it to <linux/ata.h> (remove needless parens while at it).
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 4c3f50070033..a53318b8cbd0 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -782,6 +782,56 @@ static inline int atapi_id_dmadir(const u16 *dev_id)
 	return ata_id_major_version(dev_id) >= 7 && (dev_id[62] & 0x8000);
 }
 
+/*
+ * ata_id_is_lba_capacity_ok() performs a sanity check on
+ * the claimed LBA capacity value for the device.
+ *
+ * Returns 1 if LBA capacity looks sensible, 0 otherwise.
+ *
+ * It is called only once for each device.
+ */
+static inline int ata_id_is_lba_capacity_ok(u16 *id)
+{
+	unsigned long lba_sects, chs_sects, head, tail;
+
+	/* No non-LBA info .. so valid! */
+	if (id[ATA_ID_CYLS] == 0)
+		return 1;
+
+	lba_sects = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
+
+	/*
+	 * The ATA spec tells large drives to return
+	 * C/H/S = 16383/16/63 independent of their size.
+	 * Some drives can be jumpered to use 15 heads instead of 16.
+	 * Some drives can be jumpered to use 4092 cyls instead of 16383.
+	 */
+	if ((id[ATA_ID_CYLS] == 16383 ||
+	     (id[ATA_ID_CYLS] == 4092 && id[ATA_ID_CUR_CYLS] == 16383)) &&
+	    id[ATA_ID_SECTORS] == 63 &&
+	    (id[ATA_ID_HEADS] == 15 || id[ATA_ID_HEADS] == 16) &&
+	    (lba_sects >= 16383 * 63 * id[ATA_ID_HEADS]))
+		return 1;
+
+	chs_sects = id[ATA_ID_CYLS] * id[ATA_ID_HEADS] * id[ATA_ID_SECTORS];
+
+	/* perform a rough sanity check on lba_sects: within 10% is OK */
+	if (lba_sects - chs_sects < chs_sects/10)
+		return 1;
+
+	/* some drives have the word order reversed */
+	head = (lba_sects >> 16) & 0xffff;
+	tail = lba_sects & 0xffff;
+	lba_sects = head | (tail << 16);
+
+	if (lba_sects - chs_sects < chs_sects/10) {
+		*(__le32 *)&id[ATA_ID_LBA_CAPACITY] = __cpu_to_le32(lba_sects);
+		return 1;	/* LBA capacity is (now) good */
+	}
+
+	return 0;	/* LBA capacity value may be bad */
+}
+
 static inline void ata_id_to_hd_driveid(u16 *id)
 {
 #ifdef __BIG_ENDIAN

commit 93734a234447a3c091f76d76f7351af9d4dde518
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:31 2008 +0200

    ide: ide_id_to_hd_driveid() -> ata_id_to_hd_driveid()
    
    Rename ide_id_to_hd_driveid() to ata_id_to_hd_driveid()
    and move it to <linux/ata.h>.
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 81d9adeb819e..4c3f50070033 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -30,6 +30,7 @@
 #define __LINUX_ATA_H__
 
 #include <linux/types.h>
+#include <asm/byteorder.h>
 
 /* defines only for the constants which don't work well as enums */
 #define ATA_DMA_BOUNDARY	0xffffUL
@@ -781,6 +782,26 @@ static inline int atapi_id_dmadir(const u16 *dev_id)
 	return ata_id_major_version(dev_id) >= 7 && (dev_id[62] & 0x8000);
 }
 
+static inline void ata_id_to_hd_driveid(u16 *id)
+{
+#ifdef __BIG_ENDIAN
+	/* accessed in struct hd_driveid as 8-bit values */
+	id[ATA_ID_MAX_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MAX_MULTSECT]);
+	id[ATA_ID_CAPABILITY]	 = __cpu_to_le16(id[ATA_ID_CAPABILITY]);
+	id[ATA_ID_OLD_PIO_MODES] = __cpu_to_le16(id[ATA_ID_OLD_PIO_MODES]);
+	id[ATA_ID_OLD_DMA_MODES] = __cpu_to_le16(id[ATA_ID_OLD_DMA_MODES]);
+	id[ATA_ID_MULTSECT]	 = __cpu_to_le16(id[ATA_ID_MULTSECT]);
+
+	/* as 32-bit values */
+	*(u32 *)&id[ATA_ID_LBA_CAPACITY] = ata_id_u32(id, ATA_ID_LBA_CAPACITY);
+	*(u32 *)&id[ATA_ID_SPG]		 = ata_id_u32(id, ATA_ID_SPG);
+
+	/* as 64-bit value */
+	*(u64 *)&id[ATA_ID_LBA_CAPACITY_2] =
+		ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);
+#endif
+}
+
 static inline int is_multi_taskfile(struct ata_taskfile *tf)
 {
 	return (tf->command == ATA_CMD_READ_MULTI) ||

commit ff2779b568e70822e0ef2cc7afeeefbe7c607652
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:31 2008 +0200

    ide: ide_id_has_flush_cache_ext() -> ata_id_flush_ext_enabled()
    
    * Add ata_id_flush_ext_enabled() inline helper to <linux/ata.h>.
    
    * ide_id_has_flush_cache_ext() -> ata_id_flush_ext_enabled()
    
      The latter one also checks if the command is marked as
      supported in word 83 and validity of words 83 & 86.
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 921cf0fc337f..81d9adeb819e 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -574,6 +574,19 @@ static inline int ata_id_has_flush_ext(const u16 *id)
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 13);
 }
 
+static inline int ata_id_flush_ext_enabled(const u16 *id)
+{
+	if (ata_id_has_flush_ext(id) == 0)
+		return 0;
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
+		return 0;
+	/*
+	 * some Maxtor disks have bit 13 defined incorrectly
+	 * so check bit 10 too
+	 */
+	return (id[ATA_ID_CFS_ENABLE_2] & 0x2400) == 0x2400;
+}
+
 static inline int ata_id_has_lba48(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)

commit 4b58f17d7c45a8e5f4acda641bec388398b9c0fa
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:30 2008 +0200

    ide: ide_id_has_flush_cache() -> ata_id_flush_enabled()
    
    * Add ata_id_flush_enabled() inline helper to <linux/ata.h>.
    
    * ide_id_has_flush_cache() -> ata_id_flush_enabled()
    
      The latter one also checks if the command is marked as
      supported in word 83 and validity of words 83 & 86.
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8162257b474f..921cf0fc337f 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -558,6 +558,15 @@ static inline int ata_id_has_flush(const u16 *id)
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 12);
 }
 
+static inline int ata_id_flush_enabled(const u16 *id)
+{
+	if (ata_id_has_flush(id) == 0)
+		return 0;
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
+		return 0;
+	return id[ATA_ID_CFS_ENABLE_2] & (1 << 12);
+}
+
 static inline int ata_id_has_flush_ext(const u16 *id)
 {
 	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)

commit 942dcd85bf8edf38cdc3745306ca250684d99a61
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:30 2008 +0200

    ide: idedisk_supports_lba48() -> ata_id_lba48_enabled()
    
    * Add ata_id_lba48_enabled() inline helper to <linux/ata.h>.
    
    * idedisk_supports_lba48() -> ata_id_lba48_enabled()
    
      The latter one also checks validity of words 83 & 86.
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d28aad991c75..8162257b474f 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -574,6 +574,15 @@ static inline int ata_id_has_lba48(const u16 *id)
 	return id[ATA_ID_COMMAND_SET_2] & (1 << 10);
 }
 
+static inline int ata_id_lba48_enabled(const u16 *id)
+{
+	if (ata_id_has_lba48(id) == 0)
+		return 0;
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
+		return 0;
+	return id[ATA_ID_CFS_ENABLE_2] & (1 << 10);
+}
+
 static inline int ata_id_hpa_enabled(const u16 *id)
 {
 	/* Yes children, word 83 valid bits cover word 82 data */

commit 367d7e78dd48cf6ad35182a99d97abb5486e040e
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Oct 10 22:39:30 2008 +0200

    ide: ide_dev_is_sata() -> ata_id_is_sata()
    
    * Use optimized ATA version check from Sergei in ata_id_is_sata().
    
    * ide_dev_is_sata() -> ata_id_is_sata()
    
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index be00973d1a8c..d28aad991c75 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -645,7 +645,15 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 
 static inline int ata_id_is_sata(const u16 *id)
 {
-	return ata_id_major_version(id) >= 5 && id[ATA_ID_HW_CONFIG] == 0;
+	/*
+	 * See if word 93 is 0 AND drive is at least ATA-5 compatible
+	 * verifying that word 80 by casting it to a signed type --
+	 * this trick allows us to filter out the reserved values of
+	 * 0x0000 and 0xffff along with the earlier ATA revisions...
+	 */
+	if (id[ATA_ID_HW_CONFIG] == 0 && (short)id[ATA_ID_MAJOR_VER] >= 0x0020)
+		return 1;
+	return 0;
 }
 
 static inline int ata_id_has_tpm(const u16 *id)

commit e26feff647ef34423b048b940540a0059001ddb0
Merge: d403a6484f03 b911e473d246
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 10:52:45 2008 -0700

    Merge branch 'for-2.6.28' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.28' of git://git.kernel.dk/linux-2.6-block: (132 commits)
      doc/cdrom: Trvial documentation error, file not present
      block_dev: fix kernel-doc in new functions
      block: add some comments around the bio read-write flags
      block: mark bio_split_pool static
      block: Find bio sector offset given idx and offset
      block: gendisk integrity wrapper
      block: Switch blk_integrity_compare from bdev to gendisk
      block: Fix double put in blk_integrity_unregister
      block: Introduce integrity data ownership flag
      block: revert part of d7533ad0e132f92e75c1b2eb7c26387b25a583c1
      bio.h: Remove unused conditional code
      block: remove end_{queued|dequeued}_request()
      block: change elevator to use __blk_end_request()
      gdrom: change to use __blk_end_request()
      memstick: change to use __blk_end_request()
      virtio_blk: change to use __blk_end_request()
      blktrace: use BLKTRACE_BDEV_SIZE as the name size for setup structure
      block: add lld busy state exporting interface
      block: Fix blk_start_queueing() to not kick a stopped queue
      include blktrace_api.h in headers_install
      ...

commit 8bff7c6b0f63c7ee9c5e3a076338d74125b8debb
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Sep 24 13:05:10 2008 +0200

    libata: set queue SSD flag for SSD devices
    
    SSD devices should give an RPM setting of 1 in word 217 of the ID
    page. If we see such a device, tell the block layer about it.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8a12d718c169..c1c8b4a4ba26 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -88,6 +88,7 @@ enum {
 	ATA_ID_DLF		= 128,
 	ATA_ID_CSFO		= 129,
 	ATA_ID_CFA_POWER	= 160,
+	ATA_ID_ROT_SPEED	= 217,
 	ATA_ID_PIO4		= (1 << 1),
 
 	ATA_ID_SERNO_LEN	= 20,
@@ -691,6 +692,11 @@ static inline int ata_id_is_cfa(const u16 *id)
 	return 0;
 }
 
+static inline int ata_id_is_ssd(const u16 *id)
+{
+	return id[ATA_ID_ROT_SPEED] == 0x01;
+}
+
 static inline int ata_drive_40wire(const u16 *dev_id)
 {
 	if (ata_id_is_sata(dev_id))

commit ea6ce53cd5d005455ec0a3cc1d45d3af0cb90919
Author: Elias Oltmanns <eo@nebensachen.de>
Date:   Fri Sep 19 23:46:01 2008 +0200

    [libata] Introduce ata_id_has_unload()
    
    Add a function to check an ATA device's id for head unload support as
    specified in ATA-7.
    
    Signed-off-by: Elias Oltmanns <eo@nebensachen.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8a12d718c169..a26ebd25bac1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -667,6 +667,15 @@ static inline int ata_id_has_dword_io(const u16 *id)
 	return 0;
 }
 
+static inline int ata_id_has_unload(const u16 *id)
+{
+	if (ata_id_major_version(id) >= 7 &&
+	    (id[ATA_ID_CFSSE] & 0xC000) == 0x4000 &&
+	    id[ATA_ID_CFSSE] & (1 << 13))
+		return 1;
+	return 0;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command

commit 97b697a11b07e2ebfa69c488132596cc5eb24119
Author: Taisuke Yamada <tai@rakugaki.org>
Date:   Sat Sep 13 16:46:15 2008 -0400

    [libata] LBA28/LBA48 off-by-one bug in ata.h
    
    I recently bought 3 HGST P7K500-series 500GB SATA drives and
    had trouble accessing the block right on the LBA28-LBA48 border.
    Here's how it fails (same for all 3 drives):
    
      # dd if=/dev/sdc bs=512 count=1 skip=268435455 > /dev/null
      dd: reading `/dev/sdc': Input/output error
      0+0 records in
      0+0 records out
      0 bytes (0 B) copied, 0.288033 seconds, 0.0 kB/s
      # dmesg
      ata1.00: exception Emask 0x0 SAct 0x0 SErr 0x0 action 0x0
      ata1.00: BMDMA stat 0x25
      ata1.00: cmd c8/00:08:f8:ff:ff/00:00:00:00:00/ef tag 0 dma 4096 in
      res 51/04:08:f8:ff:ff/00:00:00:00:00/ef Emask 0x1 (device error)
      ata1.00: status: { DRDY ERR }
      ata1.00: error: { ABRT }
      ata1.00: configured for UDMA/33
      ata1: EH complete
      ...
    
    After some investigations, it turned out this seems to be caused
    by misinterpretation of the ATA specification on LBA28 access.
    Following part is the code in question:
    
      === include/linux/ata.h ===
      static inline int lba_28_ok(u64 block, u32 n_block)
      {
        /* check the ending block number */
        return ((block + n_block - 1) < ((u64)1 << 28)) && (n_block <= 256);
      }
    
    HGST drive (sometimes) fails with LBA28 access of {block = 0xfffffff,
    n_block = 1}, and this behavior seems to be comformant. Other drives,
    including other HGST drives are not that strict, through.
    
    >From the ATA specification:
    (http://www.t13.org/Documents/UploadedDocuments/project/d1410r3b-ATA-ATAPI-6.pdf)
    
      8.15.29  Word (61:60): Total number of user addressable sectors
      This field contains a value that is one greater than the total number
      of user addressable sectors (see 6.2). The maximum value that shall
      be placed in this field is 0FFFFFFFh.
    
    So the driver shouldn't use the value of 0xfffffff for LBA28 request
    as this exceeds maximum user addressable sector. The logical maximum
    value for LBA28 is 0xffffffe.
    
    The obvious fix is to cut "- 1" part, and the patch attached just do
    that. I've been using the patched kernel for about a month now, and
    the same fix is also floating on the net for some time. So I believe
    this fix works reliably.
    
    Just FYI, many Windows/Intel platform users also seems to be struck
    by this, and HGST has issued a note pointing to Intel ICH8/9 driver.
    
      "28-bit LBA command is being used to access LBAs 29-bits in length"
    http://www.hitachigst.com/hddt/knowtree.nsf/cffe836ed7c12018862565b000530c74/b531b8bce8745fb78825740f00580e23
    
    Also, *BSDs seems to have similar fix included sometime around ~2004,
    through I have not checked out exact portion of the code.
    
    Signed-off-by: Taisuke Yamada <tai@rakugaki.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 1ce19c1ef0e9..8a12d718c169 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -745,7 +745,7 @@ static inline int ata_ok(u8 status)
 static inline int lba_28_ok(u64 block, u32 n_block)
 {
 	/* check the ending block number */
-	return ((block + n_block - 1) < ((u64)1 << 28)) && (n_block <= 256);
+	return ((block + n_block) < ((u64)1 << 28)) && (n_block <= 256);
 }
 
 static inline int lba_48_ok(u64 block, u32 n_block)

commit b59116205c54c89df9cc80721b59e1e8d14488f1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 18 21:40:05 2008 +0200

    ata: add missing ATA_* defines
    
    Add missing ATA_* defines to <linux/ata.h>.  Also add
    ATAPI_{LFS,EOM,ILI,IO,CODE} defines while at it.
    
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index cf4ef6d915ac..1ce19c1ef0e9 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -153,13 +153,26 @@ enum {
 	ATA_BUSY		= (1 << 7),	/* BSY status bit */
 	ATA_DRDY		= (1 << 6),	/* device ready */
 	ATA_DF			= (1 << 5),	/* device fault */
+	ATA_DSC			= (1 << 4),	/* drive seek complete */
 	ATA_DRQ			= (1 << 3),	/* data request i/o */
+	ATA_CORR		= (1 << 2),	/* corrected data error */
+	ATA_IDX			= (1 << 1),	/* index */
 	ATA_ERR			= (1 << 0),	/* have an error */
 	ATA_SRST		= (1 << 2),	/* software reset */
 	ATA_ICRC		= (1 << 7),	/* interface CRC error */
+	ATA_BBK			= ATA_ICRC,	/* pre-EIDE: block marked bad */
 	ATA_UNC			= (1 << 6),	/* uncorrectable media error */
+	ATA_MC			= (1 << 5),	/* media changed */
 	ATA_IDNF		= (1 << 4),	/* ID not found */
+	ATA_MCR			= (1 << 3),	/* media change requested */
 	ATA_ABORTED		= (1 << 2),	/* command aborted */
+	ATA_TRK0NF		= (1 << 1),	/* track 0 not found */
+	ATA_AMNF		= (1 << 0),	/* address mark not found */
+	ATAPI_LFS		= 0xF0,		/* last failed sense */
+	ATAPI_EOM		= ATA_TRK0NF,	/* end of media */
+	ATAPI_ILI		= ATA_AMNF,	/* illegal length indication */
+	ATAPI_IO		= (1 << 1),
+	ATAPI_COD		= (1 << 0),
 
 	/* ATA command block registers */
 	ATA_REG_DATA		= 0x00,

commit 476d9894dde2da2c2b326d70b5bce5eccc593c8b
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 18 21:40:05 2008 +0200

    ata: add missing ATA_CMD_* defines
    
    Add missing ATA_CMD_* defines to <linux/ata.h>.  Also add
    ATA_EXABYTE_ENABLE_NEST, SETFEATURES_AAM_* and ATA_SMART_*
    defines while at it.
    
    Partially based on earlier work by Chris Wedgwood.
    
    Acked-by: Chris Wedgwood <cw@f00f.org>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 03fff6239b3c..cf4ef6d915ac 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -222,6 +222,13 @@ enum {
 	ATA_CMD_PMP_WRITE	= 0xE8,
 	ATA_CMD_CONF_OVERLAY	= 0xB1,
 	ATA_CMD_SEC_FREEZE_LOCK	= 0xF5,
+	ATA_CMD_SMART		= 0xB0,
+	ATA_CMD_MEDIA_LOCK	= 0xDE,
+	ATA_CMD_MEDIA_UNLOCK	= 0xDF,
+	/* marked obsolete in the ATA/ATAPI-7 spec */
+	ATA_CMD_RESTORE		= 0x10,
+	/* EXABYTE specific */
+	ATA_EXABYTE_ENABLE_NEST	= 0xF0,
 
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
@@ -262,6 +269,10 @@ enum {
 	SETFEATURES_WC_ON	= 0x02, /* Enable write cache */
 	SETFEATURES_WC_OFF	= 0x82, /* Disable write cache */
 
+	/* Enable/Disable Automatic Acoustic Management */
+	SETFEATURES_AAM_ON	= 0x42,
+	SETFEATURES_AAM_OFF	= 0xC2,
+
 	SETFEATURES_SPINUP	= 0x07, /* Spin-up drive */
 
 	SETFEATURES_SATA_ENABLE = 0x10, /* Enable use of SATA feature */
@@ -284,6 +295,15 @@ enum {
 	ATA_DCO_IDENTIFY	= 0xC2,
 	ATA_DCO_SET		= 0xC3,
 
+	/* feature values for SMART */
+	ATA_SMART_ENABLE	= 0xD8,
+	ATA_SMART_READ_VALUES	= 0xD0,
+	ATA_SMART_READ_THRESHOLDS = 0xD1,
+
+	/* password used in LBA Mid / LBA High for executing SMART commands */
+	ATA_SMART_LBAM_PASS	= 0x4F,
+	ATA_SMART_LBAH_PASS	= 0xC2,
+
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
 	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:

commit 37014c64079748c47fd109ef2d91ecd785a8c764
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 18 21:40:05 2008 +0200

    ata: add missing ATA_ID_* defines (take 2)
    
    Add missing ATA_ID_* defines and update {ata,atapi}_*()
    inlines accordingly.  The currently unused defines are
    needed for the forthcoming drivers/ide/ changes.
    
    v2:
    Add ATA_ID_SPG.
    
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 1c622e2b0504..03fff6239b3c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -46,18 +46,48 @@ enum {
 	ATA_MAX_SECTORS_TAPE	= 65535,
 
 	ATA_ID_WORDS		= 256,
+	ATA_ID_CONFIG		= 0,
+	ATA_ID_CYLS		= 1,
+	ATA_ID_HEADS		= 3,
+	ATA_ID_SECTORS		= 6,
 	ATA_ID_SERNO		= 10,
+	ATA_ID_BUF_SIZE		= 21,
 	ATA_ID_FW_REV		= 23,
 	ATA_ID_PROD		= 27,
+	ATA_ID_MAX_MULTSECT	= 47,
+	ATA_ID_DWORD_IO		= 48,
+	ATA_ID_CAPABILITY	= 49,
 	ATA_ID_OLD_PIO_MODES	= 51,
+	ATA_ID_OLD_DMA_MODES	= 52,
 	ATA_ID_FIELD_VALID	= 53,
+	ATA_ID_CUR_CYLS		= 54,
+	ATA_ID_CUR_HEADS	= 55,
+	ATA_ID_CUR_SECTORS	= 56,
+	ATA_ID_MULTSECT		= 59,
+	ATA_ID_LBA_CAPACITY	= 60,
+	ATA_ID_SWDMA_MODES	= 62,
 	ATA_ID_MWDMA_MODES	= 63,
 	ATA_ID_PIO_MODES	= 64,
 	ATA_ID_EIDE_DMA_MIN	= 65,
+	ATA_ID_EIDE_DMA_TIME	= 66,
 	ATA_ID_EIDE_PIO		= 67,
 	ATA_ID_EIDE_PIO_IORDY	= 68,
-	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_QUEUE_DEPTH	= 75,
 	ATA_ID_MAJOR_VER	= 80,
+	ATA_ID_COMMAND_SET_1	= 82,
+	ATA_ID_COMMAND_SET_2	= 83,
+	ATA_ID_CFSSE		= 84,
+	ATA_ID_CFS_ENABLE_1	= 85,
+	ATA_ID_CFS_ENABLE_2	= 86,
+	ATA_ID_CSF_DEFAULT	= 87,
+	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_HW_CONFIG	= 93,
+	ATA_ID_SPG		= 98,
+	ATA_ID_LBA_CAPACITY_2	= 100,
+	ATA_ID_LAST_LUN		= 126,
+	ATA_ID_DLF		= 128,
+	ATA_ID_CSFO		= 129,
+	ATA_ID_CFA_POWER	= 160,
 	ATA_ID_PIO4		= (1 << 1),
 
 	ATA_ID_SERNO_LEN	= 20,
@@ -438,17 +468,17 @@ static inline int ata_is_data(u8 prot)
 /*
  * id tests
  */
-#define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
-#define ata_id_has_lba(id)	((id)[49] & (1 << 9))
-#define ata_id_has_dma(id)	((id)[49] & (1 << 8))
+#define ata_id_is_ata(id)	(((id)[ATA_ID_CONFIG] & (1 << 15)) == 0)
+#define ata_id_has_lba(id)	((id)[ATA_ID_CAPABILITY] & (1 << 9))
+#define ata_id_has_dma(id)	((id)[ATA_ID_CAPABILITY] & (1 << 8))
 #define ata_id_has_ncq(id)	((id)[76] & (1 << 8))
-#define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
-#define ata_id_removeable(id)	((id)[0] & (1 << 7))
+#define ata_id_queue_depth(id)	(((id)[ATA_ID_QUEUE_DEPTH] & 0x1f) + 1)
+#define ata_id_removeable(id)	((id)[ATA_ID_CONFIG] & (1 << 7))
 #define ata_id_has_atapi_AN(id)	\
 	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
 	  ((id)[78] & (1 << 5)) )
-#define ata_id_iordy_disable(id) ((id)[49] & (1 << 10))
-#define ata_id_has_iordy(id) ((id)[49] & (1 << 11))
+#define ata_id_iordy_disable(id) ((id)[ATA_ID_CAPABILITY] & (1 << 10))
+#define ata_id_has_iordy(id) ((id)[ATA_ID_CAPABILITY] & (1 << 11))
 #define ata_id_u32(id,n)	\
 	(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))
 #define ata_id_u64(id,n)	\
@@ -457,7 +487,7 @@ static inline int ata_is_data(u8 prot)
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
-#define ata_id_cdb_intr(id)	(((id)[0] & 0x60) == 0x20)
+#define ata_id_cdb_intr(id)	(((id)[ATA_ID_CONFIG] & 0x60) == 0x20)
 
 static inline bool ata_id_has_hipm(const u16 *id)
 {
@@ -482,75 +512,75 @@ static inline bool ata_id_has_dipm(const u16 *id)
 
 static inline int ata_id_has_fua(const u16 *id)
 {
-	if ((id[84] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_CFSSE] & 0xC000) != 0x4000)
 		return 0;
-	return id[84] & (1 << 6);
+	return id[ATA_ID_CFSSE] & (1 << 6);
 }
 
 static inline int ata_id_has_flush(const u16 *id)
 {
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
-	return id[83] & (1 << 12);
+	return id[ATA_ID_COMMAND_SET_2] & (1 << 12);
 }
 
 static inline int ata_id_has_flush_ext(const u16 *id)
 {
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
-	return id[83] & (1 << 13);
+	return id[ATA_ID_COMMAND_SET_2] & (1 << 13);
 }
 
 static inline int ata_id_has_lba48(const u16 *id)
 {
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
-	if (!ata_id_u64(id, 100))
+	if (!ata_id_u64(id, ATA_ID_LBA_CAPACITY_2))
 		return 0;
-	return id[83] & (1 << 10);
+	return id[ATA_ID_COMMAND_SET_2] & (1 << 10);
 }
 
 static inline int ata_id_hpa_enabled(const u16 *id)
 {
 	/* Yes children, word 83 valid bits cover word 82 data */
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
 	/* And 87 covers 85-87 */
-	if ((id[87] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
 		return 0;
 	/* Check command sets enabled as well as supported */
-	if ((id[85] & ( 1 << 10)) == 0)
+	if ((id[ATA_ID_CFS_ENABLE_1] & (1 << 10)) == 0)
 		return 0;
-	return id[82] & (1 << 10);
+	return id[ATA_ID_COMMAND_SET_1] & (1 << 10);
 }
 
 static inline int ata_id_has_wcache(const u16 *id)
 {
 	/* Yes children, word 83 valid bits cover word 82 data */
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
-	return id[82] & (1 << 5);
+	return id[ATA_ID_COMMAND_SET_1] & (1 << 5);
 }
 
 static inline int ata_id_has_pm(const u16 *id)
 {
-	if ((id[83] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_COMMAND_SET_2] & 0xC000) != 0x4000)
 		return 0;
-	return id[82] & (1 << 3);
+	return id[ATA_ID_COMMAND_SET_1] & (1 << 3);
 }
 
 static inline int ata_id_rahead_enabled(const u16 *id)
 {
-	if ((id[87] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
 		return 0;
-	return id[85] & (1 << 6);
+	return id[ATA_ID_CFS_ENABLE_1] & (1 << 6);
 }
 
 static inline int ata_id_wcache_enabled(const u16 *id)
 {
-	if ((id[87] & 0xC000) != 0x4000)
+	if ((id[ATA_ID_CSF_DEFAULT] & 0xC000) != 0x4000)
 		return 0;
-	return id[85] & (1 << 5);
+	return id[ATA_ID_CFS_ENABLE_1] & (1 << 5);
 }
 
 /**
@@ -581,7 +611,7 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 
 static inline int ata_id_is_sata(const u16 *id)
 {
-	return ata_id_major_version(id) >= 5 && id[93] == 0;
+	return ata_id_major_version(id) >= 5 && id[ATA_ID_HW_CONFIG] == 0;
 }
 
 static inline int ata_id_has_tpm(const u16 *id)
@@ -599,7 +629,7 @@ static inline int ata_id_has_dword_io(const u16 *id)
 	/* ATA 8 reuses this flag for "trusted" computing */
 	if (ata_id_major_version(id) > 7)
 		return 0;
-	if (id[48] & (1 << 0))
+	if (id[ATA_ID_DWORD_IO] & (1 << 0))
 		return 1;
 	return 0;
 }
@@ -608,22 +638,22 @@ static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
 	   has not been issued to the device then the values of
-	   id[54] to id[56] are vendor specific. */
-	return (id[53] & 0x01) && /* Current translation valid */
-		id[54] &&  /* cylinders in current translation */
-		id[55] &&  /* heads in current translation */
-		id[55] <= 16 &&
-		id[56];    /* sectors in current translation */
+	   id[ATA_ID_CUR_CYLS] to id[ATA_ID_CUR_SECTORS] are vendor specific. */
+	return (id[ATA_ID_FIELD_VALID] & 1) && /* Current translation valid */
+		id[ATA_ID_CUR_CYLS] &&  /* cylinders in current translation */
+		id[ATA_ID_CUR_HEADS] &&  /* heads in current translation */
+		id[ATA_ID_CUR_HEADS] <= 16 &&
+		id[ATA_ID_CUR_SECTORS];    /* sectors in current translation */
 }
 
 static inline int ata_id_is_cfa(const u16 *id)
 {
-	u16 v = id[0];
-	if (v == 0x848A)	/* Standard CF */
+	if (id[ATA_ID_CONFIG] == 0x848A)	/* Standard CF */
 		return 1;
 	/* Could be CF hiding as standard ATA */
-	if (ata_id_major_version(id) >= 3 &&  id[82] != 0xFFFF &&
-			(id[82] & ( 1 << 2)))
+	if (ata_id_major_version(id) >= 3 &&
+	    id[ATA_ID_COMMAND_SET_1] != 0xFFFF &&
+	   (id[ATA_ID_COMMAND_SET_1] & (1 << 2)))
 		return 1;
 	return 0;
 }
@@ -632,21 +662,21 @@ static inline int ata_drive_40wire(const u16 *dev_id)
 {
 	if (ata_id_is_sata(dev_id))
 		return 0;	/* SATA */
-	if ((dev_id[93] & 0xE000) == 0x6000)
+	if ((dev_id[ATA_ID_HW_CONFIG] & 0xE000) == 0x6000)
 		return 0;	/* 80 wire */
 	return 1;
 }
 
 static inline int ata_drive_40wire_relaxed(const u16 *dev_id)
 {
-	if ((dev_id[93] & 0x2000) == 0x2000)
+	if ((dev_id[ATA_ID_HW_CONFIG] & 0x2000) == 0x2000)
 		return 0;	/* 80 wire */
 	return 1;
 }
 
 static inline int atapi_cdb_len(const u16 *dev_id)
 {
-	u16 tmp = dev_id[0] & 0x3;
+	u16 tmp = dev_id[ATA_ID_CONFIG] & 0x3;
 	switch (tmp) {
 	case 0:		return 12;
 	case 1:		return 16;
@@ -656,7 +686,7 @@ static inline int atapi_cdb_len(const u16 *dev_id)
 
 static inline int atapi_command_packet_set(const u16 *dev_id)
 {
-	return (dev_id[0] >> 8) & 0x1f;
+	return (dev_id[ATA_ID_CONFIG] >> 8) & 0x1f;
 }
 
 static inline int atapi_id_dmadir(const u16 *dev_id)

commit 9116300634c5c76cfcd0d2af689846e04d172256
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 21 13:25:50 2008 +0900

    libata: automatically use DMADIR if drive/bridge requires it
    
    Back in 2.6.17-rc2, a libata module parameter was added for atapi_dmadir.
    
    That's nice, but most SATA devices which need it will tell us about it
    in their IDENTIFY PACKET response, as bit-15 of word-62 of the
    returned data (as per ATA7, ATA8 specifications).
    
    So for those which specify it, we should automatically use the DMADIR bit.
    Otherwise, disc writing will fail by default on many SATA-ATAPI drives.
    
    This patch adds ATA_DFLAG_DMADIR and make ata_dev_configure() set it
    if atapi_dmadir is set or identify data indicates DMADIR is necessary.
    atapi_xlat() is converted to check ATA_DFLAG_DMADIR before setting
    DMADIR.
    
    Original patch is from Mark Lord.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 78bbacaed8c4..1c622e2b0504 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -659,6 +659,11 @@ static inline int atapi_command_packet_set(const u16 *dev_id)
 	return (dev_id[0] >> 8) & 0x1f;
 }
 
+static inline int atapi_id_dmadir(const u16 *dev_id)
+{
+	return ata_id_major_version(dev_id) >= 7 && (dev_id[62] & 0x8000);
+}
+
 static inline int is_multi_taskfile(struct ata_taskfile *tf)
 {
 	return (tf->command == ATA_CMD_READ_MULTI) ||

commit 4ca4e439640cd1d3659cbcf60e7a73c2ae0450b3
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Dec 30 09:32:22 2007 +0000

    libata annotations and fixes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index bc55471a4b2c..78bbacaed8c4 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -354,8 +354,8 @@ enum ata_ioctls {
 /* core structures */
 
 struct ata_prd {
-	u32			addr;
-	u32			flags_len;
+	__le32			addr;
+	__le32			flags_len;
 };
 
 struct ata_taskfile {

commit 0dc36888d4422140f9eaf50f24953ec109f750a3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Dec 18 16:34:43 2007 -0500

    libata: rename ATA_PROT_ATAPI_* to ATAPI_PROT_*
    
    ATA_PROT_ATAPI_* are ugly and naming schemes between ATA_PROT_* and
    ATA_PROT_ATAPI_* are inconsistent causing confusion.  Rename them to
    ATAPI_PROT_* and make them consistent with ATA counterpart.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c17e9404c88d..bc55471a4b2c 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -341,9 +341,9 @@ enum ata_tf_protocols {
 	ATA_PROT_PIO,		/* PIO data xfer */
 	ATA_PROT_DMA,		/* DMA */
 	ATA_PROT_NCQ,		/* NCQ */
-	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/
-	ATA_PROT_ATAPI_NODATA,	/* packet command, no data */
-	ATA_PROT_ATAPI_DMA,	/* packet command with special DMA sauce */
+	ATAPI_PROT_NODATA,	/* packet command, no data */
+	ATAPI_PROT_PIO,		/* packet command, PIO data xfer*/
+	ATAPI_PROT_DMA,		/* packet command with special DMA sauce */
 };
 
 enum ata_ioctls {
@@ -395,11 +395,11 @@ static inline unsigned int ata_prot_flags(u8 prot)
 		return ATA_PROT_FLAG_DMA;
 	case ATA_PROT_NCQ:
 		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
-	case ATA_PROT_ATAPI_NODATA:
+	case ATAPI_PROT_NODATA:
 		return ATA_PROT_FLAG_ATAPI;
-	case ATA_PROT_ATAPI:
+	case ATAPI_PROT_PIO:
 		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO;
-	case ATA_PROT_ATAPI_DMA:
+	case ATAPI_PROT_DMA:
 		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA;
 	}
 	return 0;

commit c88f90c3779cd5e710f2acdf59ad2bd0380de98d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:48 2007 +0900

    libata: add ATA_CBL_PATA_IGN
    
    ATA_CBL_PATA_UNK indicates that the cable type can't be determined
    from the host side and might be either 80c or 40c.  libata applies
    drive or other generic limit in this case.  However, there are
    controllers where both host and drive side detections are
    misimplemented and the driver has to rely solely on private method -
    peeking BIOS or ACPI configuration or using some other private
    mechanism.
    
    This patch adds ATA_CBL_PATA_IGN which tells libata to ignore the
    cable type completely and just let the LLD determine the transfer mode
    via host transfer mode masks and ->mode_filter().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 43fecf62773a..c17e9404c88d 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -286,9 +286,10 @@ enum {
 	ATA_CBL_NONE		= 0,
 	ATA_CBL_PATA40		= 1,
 	ATA_CBL_PATA80		= 2,
-	ATA_CBL_PATA40_SHORT	= 3,		/* 40 wire cable to high UDMA spec */
-	ATA_CBL_PATA_UNK	= 4,
-	ATA_CBL_SATA		= 5,
+	ATA_CBL_PATA40_SHORT	= 3,	/* 40 wire cable to high UDMA spec */
+	ATA_CBL_PATA_UNK	= 4,	/* don't know, maybe 80c? */
+	ATA_CBL_PATA_IGN	= 5,	/* don't know, ignore cable handling */
+	ATA_CBL_SATA		= 6,
 
 	/* SATA Status and Control Registers */
 	SCR_STATUS		= 0,

commit 405e66b38797875e80669eaf72d313dbb76533c3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:28:53 2007 +0900

    libata: implement protocol tests
    
    Implement protocol tests - ata_is_atapi(), ata_is_nodata(),
    ata_is_pio(), ata_is_dma(), ata_is_ncq() and ata_is_data() and use
    them to replace is_atapi_taskfile() and hard coded protocol tests.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 3fbe6d7784ab..43fecf62773a 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -324,6 +324,13 @@ enum {
 	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
 	ATA_TFLAG_FUA		= (1 << 5), /* enable FUA */
 	ATA_TFLAG_POLLING	= (1 << 6), /* set nIEN to 1 and use polling */
+
+	/* protocol flags */
+	ATA_PROT_FLAG_PIO	= (1 << 0), /* is PIO */
+	ATA_PROT_FLAG_DMA	= (1 << 1), /* is DMA */
+	ATA_PROT_FLAG_DATA	= ATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMA,
+	ATA_PROT_FLAG_NCQ	= (1 << 2), /* is NCQ */
+	ATA_PROT_FLAG_ATAPI	= (1 << 3), /* is ATAPI */
 };
 
 enum ata_tf_protocols {
@@ -373,6 +380,63 @@ struct ata_taskfile {
 	u8			command;	/* IO operation */
 };
 
+/*
+ * protocol tests
+ */
+static inline unsigned int ata_prot_flags(u8 prot)
+{
+	switch (prot) {
+	case ATA_PROT_NODATA:
+		return 0;
+	case ATA_PROT_PIO:
+		return ATA_PROT_FLAG_PIO;
+	case ATA_PROT_DMA:
+		return ATA_PROT_FLAG_DMA;
+	case ATA_PROT_NCQ:
+		return ATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQ;
+	case ATA_PROT_ATAPI_NODATA:
+		return ATA_PROT_FLAG_ATAPI;
+	case ATA_PROT_ATAPI:
+		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIO;
+	case ATA_PROT_ATAPI_DMA:
+		return ATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMA;
+	}
+	return 0;
+}
+
+static inline int ata_is_atapi(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_ATAPI;
+}
+
+static inline int ata_is_nodata(u8 prot)
+{
+	return !(ata_prot_flags(prot) & ATA_PROT_FLAG_DATA);
+}
+
+static inline int ata_is_pio(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_PIO;
+}
+
+static inline int ata_is_dma(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_DMA;
+}
+
+static inline int ata_is_ncq(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_NCQ;
+}
+
+static inline int ata_is_data(u8 prot)
+{
+	return ata_prot_flags(prot) & ATA_PROT_FLAG_DATA;
+}
+
+/*
+ * id tests
+ */
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
 #define ata_id_has_lba(id)	((id)[49] & (1 << 9))
 #define ata_id_has_dma(id)	((id)[49] & (1 << 8))
@@ -594,13 +658,6 @@ static inline int atapi_command_packet_set(const u16 *dev_id)
 	return (dev_id[0] >> 8) & 0x1f;
 }
 
-static inline int is_atapi_taskfile(const struct ata_taskfile *tf)
-{
-	return (tf->protocol == ATA_PROT_ATAPI) ||
-	       (tf->protocol == ATA_PROT_ATAPI_NODATA) ||
-	       (tf->protocol == ATA_PROT_ATAPI_DMA);
-}
-
 static inline int is_multi_taskfile(struct ata_taskfile *tf)
 {
 	return (tf->command == ATA_CMD_READ_MULTI) ||

commit ae8d4ee7ff429136c8b482c3b38ed994c021d3fc
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sun Nov 4 22:05:49 2007 -0500

    libata: Disable ATA8-ACS proposed Trusted Computing features by default
    
    Historically word 48 in the identify data was used to mean 32bit I/O
    was supported for VLB IDE etc. ATA8 reassigns this word to the Trusted
    Computing Group, where it is used for TCG features. This means that
    an ATA8 TCG drive is going to trigger 32bit I/O on some systems which
    will be funny.
    
    Anyway we need to sort this out ready for ATA8 so:
    - Reorder the ata.h header a bit so the ata_version function occurs early
      in it
    - Make dword_io check the ATA version
    - Add an ATA8 version checking TCG presence test
    
    While we are at it the current drafts have a flaw where it may not be
    possible to disable TCG features at boot (and opt out of the trusted
    model) as TCG intends because it relies on presence of a different
    optional feature (DCS). Handle this in software by refusing the TCG
    commands if libata.allow_tpm is not set. (We must make it possible
    as some environments such as proprietary VDR devices will doubtless
    want to use it to lock up content)
    
    Finally as with CPRM print a warning so that the user knows they may
    not be able to full access and use the device.
    
    Signed-off-by: Alan Cox <alan@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e672e80202a8..3fbe6d7784ab 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -379,7 +379,6 @@ struct ata_taskfile {
 #define ata_id_has_ncq(id)	((id)[76] & (1 << 8))
 #define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
-#define ata_id_has_dword_io(id)	((id)[48] & (1 << 0))
 #define ata_id_has_atapi_AN(id)	\
 	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
 	  ((id)[78] & (1 << 5)) )
@@ -415,6 +414,7 @@ static inline bool ata_id_has_dipm(const u16 *id)
 	return val & (1 << 3);
 }
 
+
 static inline int ata_id_has_fua(const u16 *id)
 {
 	if ((id[84] & 0xC000) != 0x4000)
@@ -519,6 +519,26 @@ static inline int ata_id_is_sata(const u16 *id)
 	return ata_id_major_version(id) >= 5 && id[93] == 0;
 }
 
+static inline int ata_id_has_tpm(const u16 *id)
+{
+	/* The TPM bits are only valid on ATA8 */
+	if (ata_id_major_version(id) < 8)
+		return 0;
+	if ((id[48] & 0xC000) != 0x4000)
+		return 0;
+	return id[48] & (1 << 0);
+}
+
+static inline int ata_id_has_dword_io(const u16 *id)
+{
+	/* ATA 8 reuses this flag for "trusted" computing */
+	if (ata_id_major_version(id) > 7)
+		return 0;
+	if (id[48] & (1 << 0))
+		return 1;
+	return 0;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command

commit 121a09e590d54be840289c6feac840453aa999d9
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 14 01:06:40 2008 -0800

    libata: correct handling of TSS DVD
    
    Devices that misreport the validity bit for word 93 look like SATA.  If
    they are on the blacklist then we must not test for SATA but assume 40 wire
    in the 40 wire case (The TSSCorp reports 80 wire on SATA it seems!)
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 72ab80801ef6..e672e80202a8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -554,8 +554,6 @@ static inline int ata_drive_40wire(const u16 *dev_id)
 
 static inline int ata_drive_40wire_relaxed(const u16 *dev_id)
 {
-	if (ata_id_is_sata(dev_id))
-		return 0;	/* SATA */
 	if ((dev_id[93] & 0x2000) == 0x2000)
 		return 0;	/* 80 wire */
 	return 1;

commit ce2e0abbd31b047ac7be740d28ef710f5bbdb105
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:04:59 2007 +0900

    libata: add more opcodes to ata.h
    
    Add constants for DEVICE CONFIGURATION OVERLAY and SET_MAX to
    include/linux/ata.h.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 5c4e54a2a8d6..72ab80801ef6 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -190,6 +190,8 @@ enum {
 	ATA_CMD_READ_LOG_EXT	= 0x2f,
 	ATA_CMD_PMP_READ	= 0xE4,
 	ATA_CMD_PMP_WRITE	= 0xE8,
+	ATA_CMD_CONF_OVERLAY	= 0xB1,
+	ATA_CMD_SEC_FREEZE_LOCK	= 0xF5,
 
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
@@ -239,6 +241,19 @@ enum {
 	SATA_AN			= 0x05,  /* Asynchronous Notification */
 	SATA_DIPM		= 0x03,  /* Device Initiated Power Management */
 
+	/* feature values for SET_MAX */
+	ATA_SET_MAX_ADDR	= 0x00,
+	ATA_SET_MAX_PASSWD	= 0x01,
+	ATA_SET_MAX_LOCK	= 0x02,
+	ATA_SET_MAX_UNLOCK	= 0x03,
+	ATA_SET_MAX_FREEZE_LOCK	= 0x04,
+
+	/* feature values for DEVICE CONFIGURATION OVERLAY */
+	ATA_DCO_RESTORE		= 0xC0,
+	ATA_DCO_FREEZE_LOCK	= 0xC1,
+	ATA_DCO_IDENTIFY	= 0xC2,
+	ATA_DCO_SET		= 0xC3,
+
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
 	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:

commit 6bbfd53d47abd1fb20d7c93a9b19a75970b66f49
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Nov 5 22:58:58 2007 +0000

    libata: handle broken cable reporting
    
    One or two ancient drives predated the cable spec and didn't sent the
    valid bits for the field. I had hoped to leave this out of libata as a
    piece of historical annoyance but a recent CD drive shows the same bug so
    we have to import support for it.
    
    Same concept as Bartlomiej's changes old IDE except that as we have
    centralised blacklists we can avoid keeping another private table of stuff
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 304825b1c977..5c4e54a2a8d6 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -537,6 +537,15 @@ static inline int ata_drive_40wire(const u16 *dev_id)
 	return 1;
 }
 
+static inline int ata_drive_40wire_relaxed(const u16 *dev_id)
+{
+	if (ata_id_is_sata(dev_id))
+		return 0;	/* SATA */
+	if ((dev_id[93] & 0x2000) == 0x2000)
+		return 0;	/* 80 wire */
+	return 1;
+}
+
 static inline int atapi_cdb_len(const u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;

commit 17bd9a2f4c35de29d2539a2ff6851d61be281e25
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 29 21:21:37 2007 +0100

    libata and bogus LBA48 drives
    
    A colleague noticed recent versions of Ubuntu no longer detect his 80 GB
    ST380020ACE drive. This drive is special in that it advertises LBA48 support,
    but has the lba_capacity_2 field set to zero (cfr.
    http://lkml.org/lkml/2004/3/30/163).
    
    Upon closer look, libata indeed doesn't seem to handle this case yet.
    Below is an (untested) fix.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 61535e72834d..304825b1c977 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -425,6 +425,8 @@ static inline int ata_id_has_lba48(const u16 *id)
 {
 	if ((id[83] & 0xC000) != 0x4000)
 		return 0;
+	if (!ata_id_u64(id, 100))
+		return 0;
 	return id[83] & (1 << 10);
 }
 

commit f8d8e5799b75cf7ad530d2bf2a42229bf7360526
Author: Tony Battersby <tonyb@cybernetics.com>
Date:   Tue Oct 30 11:44:35 2007 -0400

    libata: increase 128 KB / cmd limit for ATAPI tape drives
    
    Commands sent to ATAPI tape drives via the SCSI generic (sg) driver are
    limited in the amount of data that they can transfer by the max_sectors
    value.  The max_sectors value is currently calculated according to the
    command set for disk drives, which doesn't apply to tape drives.  The
    default max_sectors value of 256 limits ATAPI tape drive commands to
    128 KB.  This patch against 2.6.24-rc1 increases the max_sectors value
    for tape drives to 65535, which permits tape drive commands to transfer
    just under 32 MB.
    
    Tested with a SuperMicro PDSME motherboard, AHCI, and a Sony SDX-570V
    SATA tape drive.
    
    Note that some of the chipset drivers also set their own max_sectors
    value, which may override the value set in libata-core.  I don't have
    any of these chipsets to test, so I didn't go messing with them.  Also,
    ATAPI devices other than tape drives may benefit from similar changes,
    but I have only tape drives and disk drives to test.
    
    Signed-off-by: Tony Battersby <tonyb@cybernetics.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 128dc7ad4901..61535e72834d 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -43,6 +43,7 @@ enum {
 	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
+	ATA_MAX_SECTORS_TAPE	= 65535,
 
 	ATA_ID_WORDS		= 256,
 	ATA_ID_SERNO		= 10,
@@ -544,6 +545,11 @@ static inline int atapi_cdb_len(const u16 *dev_id)
 	}
 }
 
+static inline int atapi_command_packet_set(const u16 *dev_id)
+{
+	return (dev_id[0] >> 8) & 0x1f;
+}
+
 static inline int is_atapi_taskfile(const struct ata_taskfile *tf)
 {
 	return (tf->protocol == ATA_PROT_ATAPI) ||

commit ca77329fb713b7fea6a307068e0dd0248e7aa640
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Oct 25 00:58:59 2007 -0400

    [libata] Link power management infrastructure
    
    Device Initiated Power Management, which is defined
    in SATA 2.5 can be enabled for disks which support it.
    This patch enables DIPM when the user sets the link
    power management policy to "min_power".
    
    Additionally, libata drivers can define a function
    (enable_pm) that will perform hardware specific actions to
    enable whatever power management policy the user set up
    for Host Initiated Power management (HIPM).
    This power management policy will be activated after all
    disks have been enumerated and intialized.  Drivers should
    also define disable_pm, which will turn off link power
    management, but not change link power management policy.
    
    Documentation/scsi/link_power_management_policy.txt has additional
    information.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index e21c002c3a4a..128dc7ad4901 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -236,6 +236,7 @@ enum {
 
 	/* SETFEATURE Sector counts for SATA features */
 	SATA_AN			= 0x05,  /* Asynchronous Notification */
+	SATA_DIPM		= 0x03,  /* Device Initiated Power Management */
 
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
@@ -378,6 +379,26 @@ struct ata_taskfile {
 
 #define ata_id_cdb_intr(id)	(((id)[0] & 0x60) == 0x20)
 
+static inline bool ata_id_has_hipm(const u16 *id)
+{
+	u16 val = id[76];
+
+	if (val == 0 || val == 0xffff)
+		return false;
+
+	return val & (1 << 9);
+}
+
+static inline bool ata_id_has_dipm(const u16 *id)
+{
+	u16 val = id[78];
+
+	if (val == 0 || val == 0xffff)
+		return false;
+
+	return val & (1 << 3);
+}
+
 static inline int ata_id_has_fua(const u16 *id)
 {
 	if ((id[84] & 0xC000) != 0x4000)

commit 054a5fbaceb2eb3a31ea843c1cf0b8e10b91478c
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Oct 25 18:30:36 2007 +0900

    libata: track SLEEP state and issue SRST to wake it up
    
    ATA devices in SLEEP mode don't respond to any commands.  SRST is
    necessary to wake it up.  Till now, when a command is issued to a
    device in SLEEP mode, the command times out, which makes EH reset the
    device and retry the command after that, causing a long delay.
    
    This patch makes libata track SLEEP state and issue SRST automatically
    if a command is about to be issued to a device in SLEEP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Bruce Allen <ballen@gravity.phys.uwm.edu>
    Cc: Andrew Paprocki <andrew@ishiboo.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8263a7b74d34..e21c002c3a4a 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -180,6 +180,7 @@ enum {
 	ATA_CMD_VERIFY_EXT	= 0x42,
 	ATA_CMD_STANDBYNOW1	= 0xE0,
 	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
+	ATA_CMD_SLEEP		= 0xE6,
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 	ATA_CMD_READ_NATIVE_MAX	= 0xF8,
 	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,

commit 2dcb407e61458ded17503d6bd12b8c064965368b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 06:42:56 2007 -0400

    [libata] checkpatch-inspired cleanups
    
    Tackle the relatively sane complaints of checkpatch --file.
    
    The vast majority is indentation and whitespace changes, the rest are
    
    * #include fixes
    * printk KERN_xxx prefix addition
    * BSS/initializer cleanups
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index a4f373f8b798..8263a7b74d34 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -178,8 +178,8 @@ enum {
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
- 	ATA_CMD_STANDBYNOW1	= 0xE0,
- 	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
+	ATA_CMD_STANDBYNOW1	= 0xE0,
+	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 	ATA_CMD_READ_NATIVE_MAX	= 0xF8,
 	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,
@@ -458,7 +458,7 @@ static inline int ata_id_wcache_enabled(const u16 *id)
  *		ATA-3 introduces word 80 and accurate reporting
  *
  *	The practical impact of this is that ata_id_major_version cannot
- *	reliably report on drives below ATA3. 
+ *	reliably report on drives below ATA3.
  */
 
 static inline unsigned int ata_id_major_version(const u16 *id)

commit 1333e19434da116bc832e1b8925359d1565fedc9
Author: Robert Hancock <hancockr@shaw.ca>
Date:   Tue Oct 2 11:22:02 2007 -0400

    libata: add human-readable error value decoding
    
    This adds human-readable decoding of the ATA status and error registers
    (similar to what drivers/ide does) as well as the SATA Serror register
    to libata error handling output.  This prevents the need to pore
    through standards documents to figure out the meaning of the bits
    in these registers when looking at error reports.  Some bits that
    drivers/ide decoded are not decoded here, since the bits are either
    command-dependent or obsolete, and properly parsing them would add
    too much complexity.
    
    Signed-off-by: Robert Hancock <hancockr@shaw.ca>
    
    [edited slightly to make output a bit more symmetric]
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 21f00a0646d8..a4f373f8b798 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -287,6 +287,15 @@ enum {
 	SERR_PROTOCOL		= (1 << 10), /* protocol violation */
 	SERR_INTERNAL		= (1 << 11), /* host internal error */
 	SERR_PHYRDY_CHG		= (1 << 16), /* PHY RDY changed */
+	SERR_PHY_INT_ERR	= (1 << 17), /* PHY internal error */
+	SERR_COMM_WAKE		= (1 << 18), /* Comm wake */
+	SERR_10B_8B_ERR		= (1 << 19), /* 10b to 8b decode error */
+	SERR_DISPARITY		= (1 << 20), /* Disparity */
+	SERR_CRC		= (1 << 21), /* CRC error */
+	SERR_HANDSHAKE		= (1 << 22), /* Handshake error */
+	SERR_LINK_SEQ_ERR	= (1 << 23), /* Link sequence error */
+	SERR_TRANS_ST_ERROR	= (1 << 24), /* Transport state trans. error */
+	SERR_UNRECOG_FIS	= (1 << 25), /* Unrecognized FIS */
 	SERR_DEV_XCHG		= (1 << 26), /* device exchanged */
 
 	/* struct ata_taskfile flags */

commit 854c73a2f1c3bcc4aa88c25e208dc597e8efb795
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:11 2007 +0900

    libata: misc updates for AN
    
    Update AN support in preparation of PMP support.
    
    * s/ata_id_has_AN/ata_id_has_atapi_AN/
    * add AN enabled reporting during configuration
    * add err_mask to AN configuration failure reporting
    * update LOCKING comment for ata_scsi_media_change_notify()
    * check whether ATA dev is attached to SCSI dev ata_scsi_media_change_notify()
    * set ATA_FLAG_AN in ahci and sata_sil24
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Kriten Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index a749f006387f..21f00a0646d8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -353,7 +353,7 @@ struct ata_taskfile {
 #define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
 #define ata_id_has_dword_io(id)	((id)[48] & (1 << 0))
-#define ata_id_has_AN(id)	\
+#define ata_id_has_atapi_AN(id)	\
 	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
 	  ((id)[78] & (1 << 5)) )
 #define ata_id_iordy_disable(id) ((id)[49] & (1 << 10))

commit c7293870a93a99e9ce0f4d98f3a271539c7c6ad6
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Aug 22 23:31:43 2007 +0100

    libata: Strict checking for identify reporting
    
    The ATA specifications require checks on certain flags before assuming
    the validity of other data. Go through the methods and correct those
    needing extra checks. Also note limits on ata_id_major_version with
    respect to ATA-1 and ATA-2. Correct the 32bit PIO check.
    
    Wants to sit in -mm for a bit in case of a screwup on my part that I
    didn't hit on the test drives and also in case someone, somewhere has
    a drive that gets it wrong.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index fba8e1459832..a749f006387f 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -347,22 +347,12 @@ struct ata_taskfile {
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
-#define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
-#define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
-#define ata_id_hpa_enabled(id)	((id)[85] & (1 << 10))
-#define ata_id_has_fua(id)	((id)[84] & (1 << 6))
-#define ata_id_has_flush(id)	((id)[83] & (1 << 12))
-#define ata_id_has_flush_ext(id) ((id)[83] & (1 << 13))
-#define ata_id_has_lba48(id)	((id)[83] & (1 << 10))
-#define ata_id_has_hpa(id)	((id)[82] & (1 << 10))
-#define ata_id_has_wcache(id)	((id)[82] & (1 << 5))
-#define ata_id_has_pm(id)	((id)[82] & (1 << 3))
 #define ata_id_has_lba(id)	((id)[49] & (1 << 9))
 #define ata_id_has_dma(id)	((id)[49] & (1 << 8))
 #define ata_id_has_ncq(id)	((id)[76] & (1 << 8))
 #define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
-#define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
+#define ata_id_has_dword_io(id)	((id)[48] & (1 << 0))
 #define ata_id_has_AN(id)	\
 	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
 	  ((id)[78] & (1 << 5)) )
@@ -378,6 +368,90 @@ struct ata_taskfile {
 
 #define ata_id_cdb_intr(id)	(((id)[0] & 0x60) == 0x20)
 
+static inline int ata_id_has_fua(const u16 *id)
+{
+	if ((id[84] & 0xC000) != 0x4000)
+		return 0;
+	return id[84] & (1 << 6);
+}
+
+static inline int ata_id_has_flush(const u16 *id)
+{
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	return id[83] & (1 << 12);
+}
+
+static inline int ata_id_has_flush_ext(const u16 *id)
+{
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	return id[83] & (1 << 13);
+}
+
+static inline int ata_id_has_lba48(const u16 *id)
+{
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	return id[83] & (1 << 10);
+}
+
+static inline int ata_id_hpa_enabled(const u16 *id)
+{
+	/* Yes children, word 83 valid bits cover word 82 data */
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	/* And 87 covers 85-87 */
+	if ((id[87] & 0xC000) != 0x4000)
+		return 0;
+	/* Check command sets enabled as well as supported */
+	if ((id[85] & ( 1 << 10)) == 0)
+		return 0;
+	return id[82] & (1 << 10);
+}
+
+static inline int ata_id_has_wcache(const u16 *id)
+{
+	/* Yes children, word 83 valid bits cover word 82 data */
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	return id[82] & (1 << 5);
+}
+
+static inline int ata_id_has_pm(const u16 *id)
+{
+	if ((id[83] & 0xC000) != 0x4000)
+		return 0;
+	return id[82] & (1 << 3);
+}
+
+static inline int ata_id_rahead_enabled(const u16 *id)
+{
+	if ((id[87] & 0xC000) != 0x4000)
+		return 0;
+	return id[85] & (1 << 6);
+}
+
+static inline int ata_id_wcache_enabled(const u16 *id)
+{
+	if ((id[87] & 0xC000) != 0x4000)
+		return 0;
+	return id[85] & (1 << 5);
+}
+
+/**
+ *	ata_id_major_version	-	get ATA level of drive
+ *	@id: Identify data
+ *
+ *	Caveats:
+ *		ATA-1 considers identify optional
+ *		ATA-2 introduces mandatory identify
+ *		ATA-3 introduces word 80 and accurate reporting
+ *
+ *	The practical impact of this is that ata_id_major_version cannot
+ *	reliably report on drives below ATA3. 
+ */
+
 static inline unsigned int ata_id_major_version(const u16 *id)
 {
 	unsigned int mver;

commit 9f45cbd3f0fc597530aaf85cad7fe52cd63f1fd8
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Wed Aug 15 03:57:11 2007 -0400

    [libata] check for SATA async notify support
    
    Check to see if an ATAPI device supports Asynchronous Notification.
    If so, enable it, if the host controller supports AN.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 40c7af05fdb9..fba8e1459832 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -230,6 +230,12 @@ enum {
 
 	SETFEATURES_SPINUP	= 0x07, /* Spin-up drive */
 
+	SETFEATURES_SATA_ENABLE = 0x10, /* Enable use of SATA feature */
+	SETFEATURES_SATA_DISABLE = 0x90, /* Disable use of SATA feature */
+
+	/* SETFEATURE Sector counts for SATA features */
+	SATA_AN			= 0x05,  /* Asynchronous Notification */
+
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
 	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:
@@ -357,6 +363,9 @@ struct ata_taskfile {
 #define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
 #define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
+#define ata_id_has_AN(id)	\
+	( (((id)[76] != 0x0000) && ((id)[76] != 0xffff)) && \
+	  ((id)[78] & (1 << 5)) )
 #define ata_id_iordy_disable(id) ((id)[49] & (1 << 10))
 #define ata_id_has_iordy(id) ((id)[49] & (1 << 11))
 #define ata_id_u32(id,n)	\

commit 0bc2a79a2002e3cc1b514c100b6c576983da6a90
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jul 31 14:01:48 2007 +0100

    libata: Correct IORDY handling
    
    Debugging a report of a problem with an ancient solid state disk showed
    up some problems in the IORDY handling
    
    1.      We check the wrong bit to see if the device has IORDY
    2.      Even then some ancient creaking piles of crap don't support
            SETXFER at all.
    
    The cases it fixes are obscure and the risk of side effects is slight
    but possible. This also moves us slightly closer to supporting original
    MFM/RLL disks with libata.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c043c1ccf1c5..40c7af05fdb9 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -358,7 +358,7 @@ struct ata_taskfile {
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
 #define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
 #define ata_id_iordy_disable(id) ((id)[49] & (1 << 10))
-#define ata_id_has_iordy(id) ((id)[49] & (1 << 9))
+#define ata_id_has_iordy(id) ((id)[49] & (1 << 11))
 #define ata_id_u32(id,n)	\
 	(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))
 #define ata_id_u64(id,n)	\

commit 91a6d4ed333a47003f07636b3bd143521e0bbad1
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Aug 27 19:35:22 2007 +0200

    ata: add ATA_MWDMA* and ATA_SWDMA* defines
    
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 23a22df039d8..c043c1ccf1c5 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -73,6 +73,19 @@ enum {
 	ATA_PIO5		= ATA_PIO4 | (1 << 5),
 	ATA_PIO6		= ATA_PIO5 | (1 << 6),
 
+	ATA_SWDMA0		= (1 << 0),
+	ATA_SWDMA1		= ATA_SWDMA0 | (1 << 1),
+	ATA_SWDMA2		= ATA_SWDMA1 | (1 << 2),
+
+	ATA_SWDMA2_ONLY		= (1 << 2),
+
+	ATA_MWDMA0		= (1 << 0),
+	ATA_MWDMA1		= ATA_MWDMA0 | (1 << 1),
+	ATA_MWDMA2		= ATA_MWDMA1 | (1 << 2),
+
+	ATA_MWDMA12_ONLY	= (1 << 1) | (1 << 2),
+	ATA_MWDMA2_ONLY		= (1 << 2),
+
 	ATA_UDMA0		= (1 << 0),
 	ATA_UDMA1		= ATA_UDMA0 | (1 << 1),
 	ATA_UDMA2		= ATA_UDMA1 | (1 << 2),

commit 4099d14322149c7a467e4997b87be4ba8eb78697
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Jul 20 01:11:59 2007 +0200

    ide: add PIO masks
    
    * Add ATA_PIO[0-6] defines to <linux/ata.h>.
    
    * Add ->pio_mask field to ide_pci_device_t and ide_hwif_t.
    
    * Add PIO masks to host drivers.
    
    <linux/ata.h> change ACK-ed by Jeff Garzik <jeff@garzik.org>.
    
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b5a20162af32..23a22df039d8 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -64,6 +64,15 @@ enum {
 	ATA_ID_PROD_LEN		= 40,
 
 	ATA_PCI_CTL_OFS		= 2,
+
+	ATA_PIO0		= (1 << 0),
+	ATA_PIO1		= ATA_PIO0 | (1 << 1),
+	ATA_PIO2		= ATA_PIO1 | (1 << 2),
+	ATA_PIO3		= ATA_PIO2 | (1 << 3),
+	ATA_PIO4		= ATA_PIO3 | (1 << 4),
+	ATA_PIO5		= ATA_PIO4 | (1 << 5),
+	ATA_PIO6		= ATA_PIO5 | (1 << 6),
+
 	ATA_UDMA0		= (1 << 0),
 	ATA_UDMA1		= ATA_UDMA0 | (1 << 1),
 	ATA_UDMA2		= ATA_UDMA1 | (1 << 2),

commit 814600ee10d3c056ada315cdbdc2ebe48f54c75a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Jul 1 19:05:58 2007 +0900

    libata-link: add PMP related ATA constants
    
    Add Port Multiplier related ATA constants and macros.  Some of these
    will be used by ata_link implementation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 407dc7e098bc..b5a20162af32 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -164,6 +164,8 @@ enum {
 	ATA_CMD_SET_MAX		= 0xF9,
 	ATA_CMD_SET_MAX_EXT	= 0x37,
 	ATA_CMD_READ_LOG_EXT	= 0x2f,
+	ATA_CMD_PMP_READ	= 0xE4,
+	ATA_CMD_PMP_WRITE	= 0xE8,
 
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
@@ -212,6 +214,28 @@ enum {
 						   0=to device, 1=to host */
 	ATAPI_CDB_LEN		= 16,
 
+	/* PMP stuff */
+	SATA_PMP_MAX_PORTS	= 15,
+	SATA_PMP_CTRL_PORT	= 15,
+
+	SATA_PMP_GSCR_DWORDS	= 128,
+	SATA_PMP_GSCR_PROD_ID	= 0,
+	SATA_PMP_GSCR_REV	= 1,
+	SATA_PMP_GSCR_PORT_INFO	= 2,
+	SATA_PMP_GSCR_ERROR	= 32,
+	SATA_PMP_GSCR_ERROR_EN	= 33,
+	SATA_PMP_GSCR_FEAT	= 64,
+	SATA_PMP_GSCR_FEAT_EN	= 96,
+
+	SATA_PMP_PSCR_STATUS	= 0,
+	SATA_PMP_PSCR_ERROR	= 1,
+	SATA_PMP_PSCR_CONTROL	= 2,
+
+	SATA_PMP_FEAT_BIST	= (1 << 0),
+	SATA_PMP_FEAT_PMREQ	= (1 << 1),
+	SATA_PMP_FEAT_DYNSSC	= (1 << 2),
+	SATA_PMP_FEAT_NOTIFY	= (1 << 3),
+
 	/* cable types */
 	ATA_CBL_NONE		= 0,
 	ATA_CBL_PATA40		= 1,
@@ -418,4 +442,9 @@ static inline int lba_48_ok(u64 block, u32 n_block)
 	return ((block + n_block - 1) < ((u64)1 << 48)) && (n_block <= 65536);
 }
 
+#define sata_pmp_gscr_vendor(gscr)	((gscr)[SATA_PMP_GSCR_PROD_ID] & 0xffff)
+#define sata_pmp_gscr_devid(gscr)	((gscr)[SATA_PMP_GSCR_PROD_ID] >> 16)
+#define sata_pmp_gscr_rev(gscr)		(((gscr)[SATA_PMP_GSCR_REV] >> 8) & 0xff)
+#define sata_pmp_gscr_ports(gscr)	((gscr)[SATA_PMP_GSCR_PORT_INFO] & 0xf)
+
 #endif /* __LINUX_ATA_H__ */

commit ab2181cf390902f0371f30e4ebeb407b4aaa7314
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 28 08:30:36 2007 -0400

    [ATA] Add named constant for ATAPI command DEVICE RESET
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 703febb2df31..407dc7e098bc 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -126,6 +126,7 @@ enum {
 	ATA_REG_IRQ		= ATA_REG_NSECT,
 
 	/* ATA device commands */
+	ATA_CMD_DEV_RESET	= 0x08, /* ATAPI device reset */
 	ATA_CMD_CHK_POWER	= 0xE5, /* check power mode */
 	ATA_CMD_STANDBY		= 0xE2, /* place in standby power mode */
 	ATA_CMD_IDLE		= 0xE3, /* place in idle power mode */

commit 2c3d2a46f1ccf591850b20f4fdde12bcf2bf3dfd
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu Jun 7 16:01:17 2007 +0800

    libata passthru: update cached device paramters
    
    INIT_DEV_PARAMS and SET_MULTI_MODE change the device parameters cached
    by libata.  Re-read IDENTIFY DEVICE info and update the cached device
    paramters when seeing these commands.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 3e95e5c402d4..703febb2df31 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -151,6 +151,7 @@ enum {
 	ATA_CMD_WRITE_MULTI_EXT	= 0x39,
 	ATA_CMD_WRITE_MULTI_FUA_EXT = 0xCE,
 	ATA_CMD_SET_FEATURES	= 0xEF,
+	ATA_CMD_SET_MULTI	= 0xC6,
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,

commit 1dce589c38c36ae69614840ee230183f3a7d43c5
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu Jun 7 15:49:22 2007 +0800

    libata passthru: support PIO multi commands
    
      support the pass through of PIO multi commands.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index edb31bfff68f..3e95e5c402d4 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -249,7 +249,7 @@ enum ata_tf_protocols {
 	/* ATA taskfile protocols */
 	ATA_PROT_UNKNOWN,	/* unknown/invalid */
 	ATA_PROT_NODATA,	/* no data */
-	ATA_PROT_PIO,		/* PIO single sector */
+	ATA_PROT_PIO,		/* PIO data xfer */
 	ATA_PROT_DMA,		/* DMA */
 	ATA_PROT_NCQ,		/* NCQ */
 	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/

commit 169439c2e35f01e7832a9b4fc8a7446980c3d593
Author: Mark Lord <liml@rtr.ca>
Date:   Tue Apr 17 18:26:07 2007 -0400

    libata: Handle drives that require a spin-up command before first access
    
    (S)ATA drives can be configured for "power-up in standby",
    a mode whereby a specific "spin up now!" command is required
    before the first media access.
    
    Currently, a drive with this feature enabled can not be used at all
    with libata, and once in this mode, the drive becomes a doorstop.
    
    The older drivers/ide subsystem at least enumerates the drive,
    so that it can be woken up after the fact from a userspace HDIO_*
    command, but not libata.
    
    This patch adds support to libata for the "power-up in standby"
    mode where a "spin up now!" command (SET_FEATURES) is needed.
    With this, libata will recognize such drives, spin them up,
    and then re-IDENTIFY them if necessary to get a full/complete
    set of drive features data.
    
    Drives in this state are determined by looking for
    special values in id[2], as documented in the current ATA specs.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f4dc8dfeadc2..edb31bfff68f 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -202,6 +202,8 @@ enum {
 	SETFEATURES_WC_ON	= 0x02, /* Enable write cache */
 	SETFEATURES_WC_OFF	= 0x82, /* Disable write cache */
 
+	SETFEATURES_SPINUP	= 0x07, /* Spin-up drive */
+
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
 	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:

commit 1e999736cafdffc374f22eed37b291129ef82e4e
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 11 00:23:13 2007 +0100

    libata: HPA support
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    
    Add support for ignoring the BIOS HPA result (off by default) and setting
    the disk to the full available size unless already frozen.
    
    Tested with various platforms/disks and confirmed to work with the
    Macintosh (which broke earlier) and ata_piix (breakage due to the LBA48
    readback that Tejun fixed).
    
    For normal users this brings us, I believe, to feature parity with old IDE
    (and of course more featured in some areas too).
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ffb6cdc5010d..f4dc8dfeadc2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -159,6 +159,8 @@ enum {
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 	ATA_CMD_READ_NATIVE_MAX	= 0xF8,
 	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,
+	ATA_CMD_SET_MAX		= 0xF9,
+	ATA_CMD_SET_MAX_EXT	= 0x37,
 	ATA_CMD_READ_LOG_EXT	= 0x2f,
 
 	/* READ_LOG_EXT pages */

commit 5a5dbd18a7496ed403f6f54bb20c955c65482fa5
Author: Mark Lord <liml@rtr.ca>
Date:   Fri Mar 16 10:22:26 2007 -0400

    libata: add support for READ/WRITE LONG
    
    The READ/WRITE LONG commands are theoretically obsolete,
    but the majority of drives in existance still implement them.
    
    The WRITE_LONG and WRITE_LONG_ONCE commands are of particular
    interest for fault injection testing -- eg. creating "media errors"
    at specific locations on a disk.
    
    The fussy bit is that these commands require a non-standard
    sector size, usually 520 bytes instead of 512.
    
    This patch adds support to libata for READ/WRITE LONG commands
    issued via SG_IO/ATA_16.
    
    Signed-off-by:  Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 6caeb98e29dd..ffb6cdc5010d 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -164,6 +164,12 @@ enum {
 	/* READ_LOG_EXT pages */
 	ATA_LOG_SATA_NCQ	= 0x10,
 
+	/* READ/WRITE LONG (obsolete) */
+	ATA_CMD_READ_LONG	= 0x22,
+	ATA_CMD_READ_LONG_ONCE	= 0x23,
+	ATA_CMD_WRITE_LONG	= 0x32,
+	ATA_CMD_WRITE_LONG_ONCE	= 0x33,
+
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
 	XFER_UDMA_7		= 0x47,

commit 18d6e9d51891f91af4e7351cbab3cb180bb9f430
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Mon Apr 2 11:34:15 2007 +0800

    libata: Limit max sector to 128 for TORiSAN DVD drives (take 3)
    
    patch 3/4:
      The TORiSAN drive locks up when max sector == 256.
      Limit max sector to 128 for the TORiSAN DRD-N216 drives.
      (http://bugzilla.kernel.org/show_bug.cgi?id=6710)
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c331da2da5f7..6caeb98e29dd 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -40,6 +40,7 @@ enum {
 	ATA_MAX_DEVICES		= 2,	/* per bus/port */
 	ATA_MAX_PRD		= 256,	/* we could make these 256/256 */
 	ATA_SECT_SIZE		= 512,
+	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 

commit 32d90911568f67fad3f73623e106667a37c6e7ed
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Feb 21 20:25:08 2007 +0900

    libata: test major version in ata_id_is_sata()
    
    Test major version in ata_id_is_sata() not separately.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 272736e37990..c331da2da5f7 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -282,7 +282,6 @@ struct ata_taskfile {
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
-#define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
 #define ata_id_hpa_enabled(id)	((id)[85] & (1 << 10))
@@ -324,6 +323,11 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 	return mver;
 }
 
+static inline int ata_id_is_sata(const u16 *id)
+{
+	return ata_id_major_version(id) >= 5 && id[93] == 0;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
@@ -350,7 +354,7 @@ static inline int ata_id_is_cfa(const u16 *id)
 
 static inline int ata_drive_40wire(const u16 *dev_id)
 {
-	if (ata_id_major_version(dev_id) >= 5 && ata_id_is_sata(dev_id))
+	if (ata_id_is_sata(dev_id))
 		return 0;	/* SATA */
 	if ((dev_id[93] & 0xE000) == 0x6000)
 		return 0;	/* 80 wire */

commit 61f216c7196e15e56d97c5a75af01e6684f17fa3
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Feb 5 23:21:19 2007 +0900

    libata: fix drive side 80c cable check, take 3
    
    The 80c wire bit is bit 13, not 14.  Bit 14 is always 1 if word93 is
    implemented.  This increases the chance of incorrect wire detection
    especially because host side cable detection is often unreliable and
    we sometimes soley depend on drive side cable detection.  Fix the test
    and add word93 validity check.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 18e401ff7eaf..272736e37990 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -352,7 +352,7 @@ static inline int ata_drive_40wire(const u16 *dev_id)
 {
 	if (ata_id_major_version(dev_id) >= 5 && ata_id_is_sata(dev_id))
 		return 0;	/* SATA */
-	if (dev_id[93] & 0x4000)
+	if ((dev_id[93] & 0xE000) == 0x6000)
 		return 0;	/* 80 wire */
 	return 1;
 }

commit 49554c19569c91d0943b67ca731c9abfc857883f
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Mon Feb 5 16:17:19 2007 +0000

    ata: Add defines for the iordy bits
    
    IORDY and IORDY enable/disable flags.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 3a50739e25a6..18e401ff7eaf 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -299,6 +299,8 @@ struct ata_taskfile {
 #define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
 #define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
+#define ata_id_iordy_disable(id) ((id)[49] & (1 << 10))
+#define ata_id_has_iordy(id) ((id)[49] & (1 << 9))
 #define ata_id_u32(id,n)	\
 	(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))
 #define ata_id_u64(id,n)	\

commit a0cf733b333eeeafb7324e2897448006c693c26c
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 2 20:18:49 2007 +0900

    libata: straighten out ATA_ID_* constants
    
    * Kill _OFS suffixes in ATA_ID_{SERNO|FW_REV|PROD}_OFS for consistency
      with other ATA_ID_* constants.
    
    * Kill ATA_SERNO_LEN
    
    * Add and use ATA_ID_SERNO_LEN, ATA_ID_FW_REV_LEN and ATA_ID_PROD_LEN.
      This change also makes ata_device_blacklisted() use proper length
      for fwrev.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 1df941648a57..3a50739e25a6 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -44,9 +44,9 @@ enum {
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 
 	ATA_ID_WORDS		= 256,
-	ATA_ID_SERNO_OFS	= 10,
-	ATA_ID_FW_REV_OFS	= 23,
-	ATA_ID_PROD_OFS		= 27,
+	ATA_ID_SERNO		= 10,
+	ATA_ID_FW_REV		= 23,
+	ATA_ID_PROD		= 27,
 	ATA_ID_OLD_PIO_MODES	= 51,
 	ATA_ID_FIELD_VALID	= 53,
 	ATA_ID_MWDMA_MODES	= 63,
@@ -58,8 +58,11 @@ enum {
 	ATA_ID_MAJOR_VER	= 80,
 	ATA_ID_PIO4		= (1 << 1),
 
+	ATA_ID_SERNO_LEN	= 20,
+	ATA_ID_FW_REV_LEN	= 8,
+	ATA_ID_PROD_LEN		= 40,
+
 	ATA_PCI_CTL_OFS		= 2,
-	ATA_SERNO_LEN		= 20,
 	ATA_UDMA0		= (1 << 0),
 	ATA_UDMA1		= ATA_UDMA0 | (1 << 1),
 	ATA_UDMA2		= ATA_UDMA1 | (1 << 2),

commit fc085150b491bfc186efbca90a14cf907a3060a9
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Oct 10 14:28:11 2006 -0700

    [PATCH] libata: add 40pin "short" cable support, honour drive side speed detection
    
    [deweerdt@free.fr: build fix]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Frederik Deweerdt <deweerdt@free.fr>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d89441907024..1df941648a57 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -200,8 +200,9 @@ enum {
 	ATA_CBL_NONE		= 0,
 	ATA_CBL_PATA40		= 1,
 	ATA_CBL_PATA80		= 2,
-	ATA_CBL_PATA_UNK	= 3,
-	ATA_CBL_SATA		= 4,
+	ATA_CBL_PATA40_SHORT	= 3,		/* 40 wire cable to high UDMA spec */
+	ATA_CBL_PATA_UNK	= 4,
+	ATA_CBL_SATA		= 5,
 
 	/* SATA Status and Control Registers */
 	SCR_STATUS		= 0,
@@ -342,6 +343,15 @@ static inline int ata_id_is_cfa(const u16 *id)
 	return 0;
 }
 
+static inline int ata_drive_40wire(const u16 *dev_id)
+{
+	if (ata_id_major_version(dev_id) >= 5 && ata_id_is_sata(dev_id))
+		return 0;	/* SATA */
+	if (dev_id[93] & 0x4000)
+		return 0;	/* 80 wire */
+	return 1;
+}
+
 static inline int atapi_cdb_len(const u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;

commit 9bec2e38527a9f2497b3d976715c672d08d6160d
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 31 00:02:15 2006 -0400

    [libata] Trim trailing whitespace.

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 991b858acc30..d89441907024 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -320,8 +320,8 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
-	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command 
-	   has not been issued to the device then the values of 
+	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
+	   has not been issued to the device then the values of
 	   id[54] to id[56] are vendor specific. */
 	return (id[53] & 0x01) && /* Current translation valid */
 		id[54] &&  /* cylinders in current translation */

commit b352e57dc3bb5033996adaa67c2f69b795eddd39
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Aug 10 18:52:12 2006 +0100

    [PATCH] libata: Add CompactFlash support
    
    The CFA world has some additional rules and drive modes we need to support for
    newer expansion cards and on embedded boxes
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 8d708a3d505b..991b858acc30 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -170,12 +170,16 @@ enum {
 	XFER_UDMA_2		= 0x42,
 	XFER_UDMA_1		= 0x41,
 	XFER_UDMA_0		= 0x40,
+	XFER_MW_DMA_4		= 0x24,	/* CFA only */
+	XFER_MW_DMA_3		= 0x23,	/* CFA only */
 	XFER_MW_DMA_2		= 0x22,
 	XFER_MW_DMA_1		= 0x21,
 	XFER_MW_DMA_0		= 0x20,
 	XFER_SW_DMA_2		= 0x12,
 	XFER_SW_DMA_1		= 0x11,
 	XFER_SW_DMA_0		= 0x10,
+	XFER_PIO_6		= 0x0E,	/* CFA only */
+	XFER_PIO_5		= 0x0D,	/* CFA only */
 	XFER_PIO_4		= 0x0C,
 	XFER_PIO_3		= 0x0B,
 	XFER_PIO_2		= 0x0A,
@@ -274,7 +278,6 @@ struct ata_taskfile {
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
-#define ata_id_is_cfa(id)	((id)[0] == 0x848A)
 #define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
@@ -306,6 +309,9 @@ static inline unsigned int ata_id_major_version(const u16 *id)
 {
 	unsigned int mver;
 
+	if (id[ATA_ID_MAJOR_VER] == 0xFFFF)
+		return 0;
+
 	for (mver = 14; mver >= 1; mver--)
 		if (id[ATA_ID_MAJOR_VER] & (1 << mver))
 			break;
@@ -324,6 +330,18 @@ static inline int ata_id_current_chs_valid(const u16 *id)
 		id[56];    /* sectors in current translation */
 }
 
+static inline int ata_id_is_cfa(const u16 *id)
+{
+	u16 v = id[0];
+	if (v == 0x848A)	/* Standard CF */
+		return 1;
+	/* Could be CF hiding as standard ATA */
+	if (ata_id_major_version(id) >= 3 &&  id[82] != 0xFFFF &&
+			(id[82] & ( 1 << 2)))
+		return 1;
+	return 0;
+}
+
 static inline int atapi_cdb_len(const u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;

commit 8b881b0410de0f72a43e814393abf3a4cb29ebb4
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Jun 11 09:59:27 2006 -0400

    [ATA] Increase lba48 max-sectors from 200 to 256.
    
    Also, moved ATA_MAX_SECTORS and ATA_MAX_SECTORS_LBA48 from
    linux/libata.h to linux/ata.h, now that they truly reflect the standard
    (well... mostly; note TODO comment).
    
    This changes the performance profile (and potential bug profile)
    for a bunch of drivers, so be wary.

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 3671af869696..8d708a3d505b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -40,6 +40,8 @@ enum {
 	ATA_MAX_DEVICES		= 2,	/* per bus/port */
 	ATA_MAX_PRD		= 256,	/* we could make these 256/256 */
 	ATA_SECT_SIZE		= 512,
+	ATA_MAX_SECTORS		= 256,
+	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 
 	ATA_ID_WORDS		= 256,
 	ATA_ID_SERNO_OFS	= 10,

commit 3057ac3c1a992ee135cbb7b7d1a12e58d81f0739
Author: zhao, forrest <forrest.zhao@intel.com>
Date:   Mon Jun 12 12:01:34 2006 +0800

    [PATCH] Snoop SET FEATURES - WRITE CACHE ENABLE/DISABLE command(v5)
    
    This patch makes libata snoop 'SET FEATURES - WRITE CACHE
    ENABLE/DISABLE' command, executing requisite revalidation processes
    to update cached data.
    
    Signed-off-by: Forrest Zhao <forrest.zhao@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index c494e1c0531e..3671af869696 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -181,6 +181,9 @@ enum {
 	XFER_PIO_0		= 0x08,
 	XFER_PIO_SLOW		= 0x00,
 
+	SETFEATURES_WC_ON	= 0x02, /* Enable write cache */
+	SETFEATURES_WC_OFF	= 0x82, /* Disable write cache */
+
 	/* ATAPI stuff */
 	ATAPI_PKT_DMA		= (1 << 0),
 	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:

commit 88e490340ea4c3a2ebc0187a4339912e2fc1a081
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 21:03:38 2006 +0900

    [PATCH] libata-ncq: add NCQ related ATA/libata constants and macros
    
    Add NCQ related ATA/libata constants and macros.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 1cbeb434af9a..c494e1c0531e 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -133,6 +133,8 @@ enum {
 	ATA_CMD_WRITE		= 0xCA,
 	ATA_CMD_WRITE_EXT	= 0x35,
 	ATA_CMD_WRITE_FUA_EXT	= 0x3D,
+	ATA_CMD_FPDMA_READ	= 0x60,
+	ATA_CMD_FPDMA_WRITE	= 0x61,
 	ATA_CMD_PIO_READ	= 0x20,
 	ATA_CMD_PIO_READ_EXT	= 0x24,
 	ATA_CMD_PIO_WRITE	= 0x30,
@@ -151,6 +153,10 @@ enum {
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 	ATA_CMD_READ_NATIVE_MAX	= 0xF8,
 	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,
+	ATA_CMD_READ_LOG_EXT	= 0x2f,
+
+	/* READ_LOG_EXT pages */
+	ATA_LOG_SATA_NCQ	= 0x10,
 
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
@@ -221,6 +227,7 @@ enum ata_tf_protocols {
 	ATA_PROT_NODATA,	/* no data */
 	ATA_PROT_PIO,		/* PIO single sector */
 	ATA_PROT_DMA,		/* DMA */
+	ATA_PROT_NCQ,		/* NCQ */
 	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/
 	ATA_PROT_ATAPI_NODATA,	/* packet command, no data */
 	ATA_PROT_ATAPI_DMA,	/* packet command with special DMA sauce */
@@ -276,6 +283,8 @@ struct ata_taskfile {
 #define ata_id_has_pm(id)	((id)[82] & (1 << 3))
 #define ata_id_has_lba(id)	((id)[49] & (1 << 9))
 #define ata_id_has_dma(id)	((id)[49] & (1 << 8))
+#define ata_id_has_ncq(id)	((id)[76] & (1 << 8))
+#define ata_id_queue_depth(id)	(((id)[75] & 0x1f) + 1)
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
 #define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
 #define ata_id_u32(id,n)	\

commit 12436c30f4808e00fa008c6787c609bc6ae216ba
Merge: 88ce7550c38f 7894eaf29123
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:59:15 2006 +0900

    Merge branch 'irq-pio'
    
    Conflicts:
    
            drivers/scsi/libata-core.c
            include/linux/libata.h

commit 9be1e979f2e1e57a091a658fa88dac266f9fd6fe
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon May 15 20:58:17 2006 +0900

    [PATCH] libata-eh: add ATA and libata flags for new EH
    
    Add ATA and libata flags to be used by new EH.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 312a2c0c64e6..a7c41f3df8f4 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -97,6 +97,9 @@ enum {
 	ATA_DRQ			= (1 << 3),	/* data request i/o */
 	ATA_ERR			= (1 << 0),	/* have an error */
 	ATA_SRST		= (1 << 2),	/* software reset */
+	ATA_ICRC		= (1 << 7),	/* interface CRC error */
+	ATA_UNC			= (1 << 6),	/* uncorrectable media error */
+	ATA_IDNF		= (1 << 4),	/* ID not found */
 	ATA_ABORTED		= (1 << 2),	/* command aborted */
 
 	/* ATA command block registers */
@@ -192,6 +195,16 @@ enum {
 	SCR_ACTIVE		= 3,
 	SCR_NOTIFICATION	= 4,
 
+	/* SError bits */
+	SERR_DATA_RECOVERED	= (1 << 0), /* recovered data error */
+	SERR_COMM_RECOVERED	= (1 << 1), /* recovered comm failure */
+	SERR_DATA		= (1 << 8), /* unrecovered data error */
+	SERR_PERSISTENT		= (1 << 9), /* persistent data/comm error */
+	SERR_PROTOCOL		= (1 << 10), /* protocol violation */
+	SERR_INTERNAL		= (1 << 11), /* host internal error */
+	SERR_PHYRDY_CHG		= (1 << 16), /* PHY RDY changed */
+	SERR_DEV_XCHG		= (1 << 26), /* device exchanged */
+
 	/* struct ata_taskfile flags */
 	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
 	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */

commit 11ed56fb7899f9eb9eaef8e5919db1bf08f1b07e
Merge: 54da9a396844 2cc432eed049
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Mar 24 09:24:04 2006 -0500

    Merge branch 'upstream'
    
    Conflicts:
    
            drivers/scsi/sata_vsc.c

commit b6782728d703fa3f0e5478a8b89e49ea10b1fdd0
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Mar 21 15:52:49 2006 +0000

    [PATCH] libata: Add the useful macros/constants needed for merging PATA stuff
    
    HPA presence/enabled
    HPA commands
    
    Also add ata_id_is_cfa() as that is needed to detect and handle CF cards
    which currently we reject.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 6b188b3b61dd..312a2c0c64e6 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -146,6 +146,8 @@ enum {
  	ATA_CMD_STANDBYNOW1	= 0xE0,
  	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
+	ATA_CMD_READ_NATIVE_MAX	= 0xF8,
+	ATA_CMD_READ_NATIVE_MAX_EXT = 0x27,
 
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
@@ -246,18 +248,22 @@ struct ata_taskfile {
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
+#define ata_id_is_cfa(id)	((id)[0] == 0x848A)
 #define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
+#define ata_id_hpa_enabled(id)	((id)[85] & (1 << 10))
 #define ata_id_has_fua(id)	((id)[84] & (1 << 6))
 #define ata_id_has_flush(id)	((id)[83] & (1 << 12))
 #define ata_id_has_flush_ext(id) ((id)[83] & (1 << 13))
 #define ata_id_has_lba48(id)	((id)[83] & (1 << 10))
+#define ata_id_has_hpa(id)	((id)[82] & (1 << 10))
 #define ata_id_has_wcache(id)	((id)[82] & (1 << 5))
 #define ata_id_has_pm(id)	((id)[82] & (1 << 3))
 #define ata_id_has_lba(id)	((id)[49] & (1 << 9))
 #define ata_id_has_dma(id)	((id)[49] & (1 << 8))
 #define ata_id_removeable(id)	((id)[0] & (1 << 7))
+#define ata_id_has_dword_io(id)	((id)[50] & (1 << 0))
 #define ata_id_u32(id,n)	\
 	(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))
 #define ata_id_u64(id,n)	\

commit f59b0cf8a3a39b75e580066c6a9aeabd97ec2743
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu Mar 16 17:59:22 2006 +0800

    [PATCH] libata-dev: Remove ATA_PROT_PIO_MULT
    
    Remove the ATA_PROT_PIO_MULT protocol.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index b02a16c435e7..6b188b3b61dd 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -204,7 +204,6 @@ enum ata_tf_protocols {
 	ATA_PROT_UNKNOWN,	/* unknown/invalid */
 	ATA_PROT_NODATA,	/* no data */
 	ATA_PROT_PIO,		/* PIO single sector */
-	ATA_PROT_PIO_MULT,	/* PIO multiple sector */
 	ATA_PROT_DMA,		/* DMA */
 	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/
 	ATA_PROT_ATAPI_NODATA,	/* packet command, no data */

commit c2956a3b0d1c17b38da369811a6ce93eb7a01a04
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Fri Mar 3 10:34:05 2006 +0800

    [PATCH] libata-dev: recognize WRITE_MULTI_FUA_EXT for r/w multiple
    
    Recognize ATA_CMD_WRITE_MULTI_FUA_EXT as r/w multiple commands.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 469952366ed4..e7b0c21f6cd4 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -314,7 +314,8 @@ static inline int is_multi_taskfile(struct ata_taskfile *tf)
 	return (tf->command == ATA_CMD_READ_MULTI) ||
 	       (tf->command == ATA_CMD_WRITE_MULTI) ||
 	       (tf->command == ATA_CMD_READ_MULTI_EXT) ||
-	       (tf->command == ATA_CMD_WRITE_MULTI_EXT);
+	       (tf->command == ATA_CMD_WRITE_MULTI_EXT) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI_FUA_EXT);
 }
 
 static inline int ata_ok(u8 status)

commit 3875e1945b55f0eb83fe7359614a801eeb716761
Merge: 587005de144a f1b318793dcd
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Feb 13 00:13:48 2006 -0500

    Merge branch 'upstream'

commit 3d2ca91095f8ab6dc0cb925374eec62fa5336764
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Feb 12 22:47:04 2006 +0900

    [PATCH] libata: separate out ata_id_major_version()
    
    Separate out ATA major version calculation from ata_dev_identify()
    into ata_id_major_version().  It's preparation for splitting
    ata_dev_identify().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index a8155ca4947f..b02a16c435e7 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -267,6 +267,16 @@ struct ata_taskfile {
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
+static inline unsigned int ata_id_major_version(const u16 *id)
+{
+	unsigned int mver;
+
+	for (mver = 14; mver >= 1; mver--)
+		if (id[ATA_ID_MAJOR_VER] & (1 << mver))
+			break;
+	return mver;
+}
+
 static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command 

commit 8dd2e3bd57c3b389febba1de6b10372ef507f985
Merge: 2af5920b81a4 71e834f56379
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Jan 27 02:26:46 2006 -0500

    Merge branch 'tmp'

commit ea9b395fe20ac74be788f415af2622ac8f0c35c7
Merge: 61420e147a70 1bc4ccfff867
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Jan 17 10:29:06 2006 -0500

    Merge branch 'upstream'

commit 0825788ff27c7145e9d558cb2a26f3837d1f9be5
Merge: 02f693c7118f 1bc4ccfff867
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Jan 17 10:26:28 2006 -0500

    Merge branch 'upstream'

commit d99cf9d679a520d67f81d805b7cb91c68e1847f0
Merge: 7ed40918a386 e650c305ec31
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Jan 6 09:01:25 2006 -0800

    Merge branch 'post-2.6.15' of git://brick.kernel.dk/data/git/linux-2.6-block
    
    Manual fixup for merge with Jens' "Suspend support for libata", commit
    ID 9b847548663ef1039dd49f0eb4463d001e596bc3.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

commit 9b847548663ef1039dd49f0eb4463d001e596bc3
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jan 6 09:28:07 2006 +0100

    [PATCH] Suspend support for libata
    
    This patch adds suspend patch to libata, and ata_piix in particular. For
    most low level drivers, they should just need to add the 4 hooks to
    work. As I can only test ata_piix, I didn't enable it for more
    though.
    
    Suspend support is the single most important feature on a notebook, and
    most new notebooks have sata drives. It's quite embarrassing that we
    _still_ do not support this. Right now, it's perfectly possible to
    suspend the drive in mid-transfer.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d2873b732bb1..3eb80c391b39 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -141,6 +141,8 @@ enum {
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
+ 	ATA_CMD_STANDBYNOW1	= 0xE0,
+ 	ATA_CMD_IDLEIMMEDIATE	= 0xE1,
 	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 
 	/* SETFEATURES stuff */

commit 9a3dccc42556537a48f39ee9a9e7ab90a933f766
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jan 6 09:56:18 2006 +0100

    [BLOCK] add FUA support to libata
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d2873b732bb1..f63dad4165b1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -129,6 +129,7 @@ enum {
 	ATA_CMD_READ_EXT	= 0x25,
 	ATA_CMD_WRITE		= 0xCA,
 	ATA_CMD_WRITE_EXT	= 0x35,
+	ATA_CMD_WRITE_FUA_EXT	= 0x3D,
 	ATA_CMD_PIO_READ	= 0x20,
 	ATA_CMD_PIO_READ_EXT	= 0x24,
 	ATA_CMD_PIO_WRITE	= 0x30,
@@ -137,6 +138,7 @@ enum {
 	ATA_CMD_READ_MULTI_EXT	= 0x29,
 	ATA_CMD_WRITE_MULTI	= 0xC5,
 	ATA_CMD_WRITE_MULTI_EXT	= 0x39,
+	ATA_CMD_WRITE_MULTI_FUA_EXT = 0xCE,
 	ATA_CMD_SET_FEATURES	= 0xEF,
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
@@ -192,6 +194,7 @@ enum {
 	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
 	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
 	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
+	ATA_TFLAG_FUA		= (1 << 5), /* enable FUA */
 };
 
 enum ata_tf_protocols {
@@ -245,7 +248,8 @@ struct ata_taskfile {
 #define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
-#define ata_id_has_flush(id) ((id)[83] & (1 << 12))
+#define ata_id_has_fua(id)	((id)[84] & (1 << 6))
+#define ata_id_has_flush(id)	((id)[83] & (1 << 12))
 #define ata_id_has_flush_ext(id) ((id)[83] & (1 << 13))
 #define ata_id_has_lba48(id)	((id)[83] & (1 << 10))
 #define ata_id_has_wcache(id)	((id)[82] & (1 << 5))

commit 07f6f7d074e68d56d82e7cc5c65096033ac8dc56
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Nov 1 19:33:20 2005 +0800

    [PATCH] libata irq-pio: add read/write multiple support
    
       - add is_multi_taskfile() to ata.h
       - initialize ata_device->multi_count with device identify data
       - use ata_pio_sectors() to support r/w multiple commands
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    ========
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index d54da3306d2c..f512104a1a3f 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -293,6 +293,14 @@ static inline int is_atapi_taskfile(const struct ata_taskfile *tf)
 	       (tf->protocol == ATA_PROT_ATAPI_DMA);
 }
 
+static inline int is_multi_taskfile(struct ata_taskfile *tf)
+{
+	return (tf->command == ATA_CMD_READ_MULTI) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI) ||
+	       (tf->command == ATA_CMD_READ_MULTI_EXT) ||
+	       (tf->command == ATA_CMD_WRITE_MULTI_EXT);
+}
+
 static inline int ata_ok(u8 status)
 {
 	return ((status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR))

commit 35ebbae2836a361330b784706b7140c90a346a53
Merge: c6a33e2464ed 5fadd053d9bb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Oct 28 12:30:29 2005 -0400

    Merge branch 'master'

commit 15dbb5a3f971a28040ae6cbcd8bbdf19b629fa83
Merge: be697c3f137c 5fadd053d9bb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Fri Oct 28 12:30:16 2005 -0400

    Merge branch 'master'

commit 057ace5e79da9ebf2aa82833cfea825533ac06fb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat Oct 22 14:27:05 2005 -0400

    libata: const-ification bombing run
    
    Enforce access rules where appropriate.
    
    If the compiler is smart enough, this may buy us an optimization or two
    as a side effect.

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 33276d1d05d2..d2873b732bb1 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -261,7 +261,7 @@ struct ata_taskfile {
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
-static inline int ata_id_current_chs_valid(u16 *id)
+static inline int ata_id_current_chs_valid(const u16 *id)
 {
 	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command 
 	   has not been issued to the device then the values of 
@@ -273,7 +273,7 @@ static inline int ata_id_current_chs_valid(u16 *id)
 		id[56];    /* sectors in current translation */
 }
 
-static inline int atapi_cdb_len(u16 *dev_id)
+static inline int atapi_cdb_len(const u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;
 	switch (tmp) {
@@ -283,7 +283,7 @@ static inline int atapi_cdb_len(u16 *dev_id)
 	}
 }
 
-static inline int is_atapi_taskfile(struct ata_taskfile *tf)
+static inline int is_atapi_taskfile(const struct ata_taskfile *tf)
 {
 	return (tf->protocol == ATA_PROT_ATAPI) ||
 	       (tf->protocol == ATA_PROT_ATAPI_NODATA) ||

commit 11e29e21514517f3022a1f30998ac4c7b1197658
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Oct 21 18:46:32 2005 -0400

    libata: handle early device PIO modes correctly

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 630908c9378b..33276d1d05d2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -42,13 +42,18 @@ enum {
 	ATA_SECT_SIZE		= 512,
 
 	ATA_ID_WORDS		= 256,
-	ATA_ID_PROD_OFS		= 27,
-	ATA_ID_FW_REV_OFS	= 23,
 	ATA_ID_SERNO_OFS	= 10,
-	ATA_ID_MAJOR_VER	= 80,
-	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_FW_REV_OFS	= 23,
+	ATA_ID_PROD_OFS		= 27,
+	ATA_ID_OLD_PIO_MODES	= 51,
+	ATA_ID_FIELD_VALID	= 53,
 	ATA_ID_MWDMA_MODES	= 63,
+	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_EIDE_DMA_MIN	= 65,
+	ATA_ID_EIDE_PIO		= 67,
+	ATA_ID_EIDE_PIO_IORDY	= 68,
 	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_MAJOR_VER	= 80,
 	ATA_ID_PIO4		= (1 << 1),
 
 	ATA_PCI_CTL_OFS		= 2,

commit 4e0e329d9a2011f9f7a7c0a378dc3bff7b0a0283
Merge: e33b9dfa3008 59a10b172fcc
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Tue Oct 18 21:23:11 2005 -0400

    Merge branch 'upstream'

commit c6a33e2464edd87f8c12cc2d11369a5b44c65b77
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Wed Oct 12 15:12:26 2005 +0800

    [PATCH] libata CHS: LBA28/LBA48 optimization (revise #6)
    
         - add lba_28_ok() and lba_48_ok() to ata.h.
         - check ending block number instead of staring block number.
         - use lba_28_ok() for CHS range check
         - LBA28/LBA48 optimization
    
    Suggested by Mark Lord and Alan Cox.
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    =====
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 630908c9378b..b7e7e1cb2633 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -291,4 +291,16 @@ static inline int ata_ok(u8 status)
 			== ATA_DRDY);
 }
 
+static inline int lba_28_ok(u64 block, u32 n_block)
+{
+	/* check the ending block number */
+	return ((block + n_block - 1) < ((u64)1 << 28)) && (n_block <= 256);
+}
+
+static inline int lba_48_ok(u64 block, u32 n_block)
+{
+	/* check the ending block number */
+	return ((block + n_block - 1) < ((u64)1 << 48)) && (n_block <= 65536);
+}
+
 #endif /* __LINUX_ATA_H__ */

commit 8cbd6df1f0ce977ab7b61feffa59879bb5e0ed8f
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Wed Oct 12 15:06:27 2005 +0800

    [PATCH] libata CHS: calculate read/write commands and protocol on the fly (revise #6)
    
         - merge ata_prot_to_cmd() and ata_dev_set_protocol() as
           ata_rwcmd_protocol()
         - pave road for read/write multiple support
         - remove usage of pre-cached command and protocol values and call
           ata_rwcmd_protocol() instead
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    
    ==============
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ecb7346d0c16..630908c9378b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -128,6 +128,10 @@ enum {
 	ATA_CMD_PIO_READ_EXT	= 0x24,
 	ATA_CMD_PIO_WRITE	= 0x30,
 	ATA_CMD_PIO_WRITE_EXT	= 0x34,
+	ATA_CMD_READ_MULTI	= 0xC4,
+	ATA_CMD_READ_MULTI_EXT	= 0x29,
+	ATA_CMD_WRITE_MULTI	= 0xC5,
+	ATA_CMD_WRITE_MULTI_EXT	= 0x39,
 	ATA_CMD_SET_FEATURES	= 0xEF,
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,

commit 0fbbbf2bde4da5cb01a949c3d7b21c0627f520a8
Merge: 54f00389563c 2b235826098b
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 3 19:48:49 2005 -0400

    Merge libata upstream (which includes C/H/S support) include irq-pio branch.
    Merge branch 'upstream'

commit b4b52db71529bbe46da914eda772fb574914c94d
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Sep 26 12:48:41 2005 +0100

    [PATCH] ata: re-order speeds sensibly.
    
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index 85169ea9eb01..ecb7346d0c16 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -147,14 +147,14 @@ enum {
 	XFER_MW_DMA_2		= 0x22,
 	XFER_MW_DMA_1		= 0x21,
 	XFER_MW_DMA_0		= 0x20,
+	XFER_SW_DMA_2		= 0x12,
+	XFER_SW_DMA_1		= 0x11,
+	XFER_SW_DMA_0		= 0x10,
 	XFER_PIO_4		= 0x0C,
 	XFER_PIO_3		= 0x0B,
 	XFER_PIO_2		= 0x0A,
 	XFER_PIO_1		= 0x09,
 	XFER_PIO_0		= 0x08,
-	XFER_SW_DMA_2		= 0x12,
-	XFER_SW_DMA_1		= 0x11,
-	XFER_SW_DMA_0		= 0x10,
 	XFER_PIO_SLOW		= 0x00,
 
 	/* ATAPI stuff */

commit 312f7da2824c82800ee78d6190f12854456957af
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Tue Sep 27 17:38:03 2005 +0800

    [PATCH] libata: interrupt driven pio for libata-core
    
    - add PIO_ST_FIRST for the state before sending ATAPI CDB or sending
    "ATA PIO data out" first data block.
    - add ATA_TFLAG_POLLING and ATA_DFLAG_CDB_INTR flags
    - remove the ATA_FLAG_NOINTR flag since the interrupt handler is now
    aware of the states
    - modify ata_pio_sector() and atapi_pio_bytes() to work in the interrupt
    context
    - modify the ata_host_intr() to handle PIO interrupts
    - modify ata_qc_issue_prot() to initialize states
    - atapi_packet_task() changed to handle "ATA PIO data out" first data block
    - support the pre-ATA4 ATAPI device which raise interrupt when ready to
    receive CDB
    
    Signed-off-by: Albert Lee <albertcc@tw.ibm.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index a5b74efab067..6fec2f6f2d59 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -181,6 +181,7 @@ enum {
 	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
 	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
 	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
+	ATA_TFLAG_POLLING	= (1 << 4), /* set nIEN to 1 and use polling */
 };
 
 enum ata_tf_protocols {
@@ -250,6 +251,8 @@ struct ata_taskfile {
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
+#define ata_id_cdb_intr(id)	(((id)[0] & 0x60) == 0x20)
+
 static inline int atapi_cdb_len(u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;

commit 76b2bf9b4dee2fb32ef17f5c84a99ce481a14be2
Merge: 2fca877b68b2 8f3d17fb7bcb
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Aug 29 19:24:43 2005 -0400

    Merge libata branch 'chs-support' to latest upstream kernel.

commit 70d374ea9907036e15574a5ce89219edd5baee10
Merge: aa7e16d6b88b bf4e70e54cf3
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Aug 29 15:59:42 2005 -0400

    Merge /spare/repo/linux-2.6/

commit af36d7f0df56de3e3e4bbfb15d0915097ecb8cab
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Aug 28 20:18:39 2005 -0400

    [libata] license change, other bits
    
    - changes license of all code from OSL+GPL to plain ole GPL
      - except for NVIDIA, who hasn't yet responded about sata_nv
      - copyright holders were already contacted privately
    
    - adds info in each driver about where hardware/protocol docs may be
      obtained
    
    - where I have made major contributions, updated copyright dates

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ca5fcadf9981..19c3e2853f17 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -1,24 +1,29 @@
 
 /*
-   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
-   Copyright 2003-2004 Jeff Garzik
-
-   The contents of this file are subject to the Open
-   Software License version 1.1 that can be found at
-   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
-   by reference.
-
-   Alternatively, the contents of this file may be used under the terms
-   of the GNU General Public License version 2 (the "GPL") as distributed
-   in the kernel source COPYING file, in which case the provisions of
-   the GPL are applicable instead of the above.  If you wish to allow
-   the use of your version of this file only under the terms of the
-   GPL and not to allow others to use your version of this file under
-   the OSL, indicate your decision by deleting the provisions above and
-   replace them with the notice and other provisions required by the GPL.
-   If you do not delete the provisions above, a recipient may use your
-   version of this file under either the OSL or the GPL.
-
+ *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
+ *  Copyright 2003-2004 Jeff Garzik
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
+ *  Hardware documentation available from http://www.t13.org/
+ *
  */
 
 #ifndef __LINUX_ATA_H__

commit 972dcafb6d743a6c7611a2e4681ed814e30d6230
Author: Douglas Gilbert <dougg@torque.net>
Date:   Thu Aug 11 03:35:53 2005 -0400

    [libata scsi] add START STOP UNIT translation

diff --git a/include/linux/ata.h b/include/linux/ata.h
index ca5fcadf9981..9d25e9886d60 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -108,6 +108,8 @@ enum {
 
 	/* ATA device commands */
 	ATA_CMD_CHK_POWER	= 0xE5, /* check power mode */
+	ATA_CMD_STANDBY		= 0xE2, /* place in standby power mode */
+	ATA_CMD_IDLE		= 0xE3, /* place in idle power mode */
 	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
 	ATA_CMD_FLUSH		= 0xE7,
 	ATA_CMD_FLUSH_EXT	= 0xEA,

commit ff40c6d3d1437ecdf295b8e39adcb06c3d6021ef
Merge: 8bf62ecee583 2a5a68b840cb
Author: Jeff Garzik <jgarzik@pretzel.yyz.us>
Date:   Wed Jun 22 13:07:28 2005 -0400

    Merge upstream kernel changes into 'C/H/S support' branch of libata.

commit 8bf62ecee58360749c5f0e68bc97d5e02a6816b1
Author: Albert Lee <albertcc@tw.ibm.com>
Date:   Thu May 12 15:29:42 2005 -0400

    [libata] C/H/S support, for older devices

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f178894edd04..d8981402cd5b 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -125,6 +125,7 @@ enum {
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
+	ATA_CMD_INIT_DEV_PARAMS	= 0x91,
 
 	/* SETFEATURES stuff */
 	SETFEATURES_XFER	= 0x03,
@@ -174,6 +175,7 @@ enum {
 	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
 	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
 	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
+	ATA_TFLAG_LBA		= (1 << 4), /* enable LBA */
 };
 
 enum ata_tf_protocols {
@@ -242,6 +244,18 @@ struct ata_taskfile {
 	  ((u64) (id)[(n) + 1] << 16) |	\
 	  ((u64) (id)[(n) + 0]) )
 
+static inline int ata_id_current_chs_valid(u16 *id)
+{
+	/* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command 
+	   has not been issued to the device then the values of 
+	   id[54] to id[56] are vendor specific. */
+	return (id[53] & 0x01) && /* Current translation valid */
+		id[54] &&  /* cylinders in current translation */
+		id[55] &&  /* heads in current translation */
+		id[55] <= 16 &&
+		id[56];    /* sectors in current translation */
+}
+
 static inline int atapi_cdb_len(u16 *dev_id)
 {
 	u16 tmp = dev_id[0] & 0x3;

commit 6f2f38128170814e151cfedf79532e19cd179567
Author: Brad Campbell <brad@wasp.net.au>
Date:   Thu May 12 15:07:47 2005 -0400

    [PATCH] libata basic detection and errata for PATA->SATA bridges
    
    This patch works around an issue with WD drives (and possibly others)
    over SiL PATA->SATA Bridges on SATA controllers locking up with
    transfers > 200 sectors.
    
    Signed-off-by: Brad Campbell <brad@wasp.net.au>

diff --git a/include/linux/ata.h b/include/linux/ata.h
index f178894edd04..ca5fcadf9981 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -224,6 +224,7 @@ struct ata_taskfile {
 };
 
 #define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
+#define ata_id_is_sata(id)	((id)[93] == 0)
 #define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
 #define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
 #define ata_id_has_flush(id) ((id)[83] & (1 << 12))

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/ata.h b/include/linux/ata.h
new file mode 100644
index 000000000000..f178894edd04
--- /dev/null
+++ b/include/linux/ata.h
@@ -0,0 +1,268 @@
+
+/*
+   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
+   Copyright 2003-2004 Jeff Garzik
+
+   The contents of this file are subject to the Open
+   Software License version 1.1 that can be found at
+   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
+   by reference.
+
+   Alternatively, the contents of this file may be used under the terms
+   of the GNU General Public License version 2 (the "GPL") as distributed
+   in the kernel source COPYING file, in which case the provisions of
+   the GPL are applicable instead of the above.  If you wish to allow
+   the use of your version of this file only under the terms of the
+   GPL and not to allow others to use your version of this file under
+   the OSL, indicate your decision by deleting the provisions above and
+   replace them with the notice and other provisions required by the GPL.
+   If you do not delete the provisions above, a recipient may use your
+   version of this file under either the OSL or the GPL.
+
+ */
+
+#ifndef __LINUX_ATA_H__
+#define __LINUX_ATA_H__
+
+#include <linux/types.h>
+
+/* defines only for the constants which don't work well as enums */
+#define ATA_DMA_BOUNDARY	0xffffUL
+#define ATA_DMA_MASK		0xffffffffULL
+
+enum {
+	/* various global constants */
+	ATA_MAX_DEVICES		= 2,	/* per bus/port */
+	ATA_MAX_PRD		= 256,	/* we could make these 256/256 */
+	ATA_SECT_SIZE		= 512,
+
+	ATA_ID_WORDS		= 256,
+	ATA_ID_PROD_OFS		= 27,
+	ATA_ID_FW_REV_OFS	= 23,
+	ATA_ID_SERNO_OFS	= 10,
+	ATA_ID_MAJOR_VER	= 80,
+	ATA_ID_PIO_MODES	= 64,
+	ATA_ID_MWDMA_MODES	= 63,
+	ATA_ID_UDMA_MODES	= 88,
+	ATA_ID_PIO4		= (1 << 1),
+
+	ATA_PCI_CTL_OFS		= 2,
+	ATA_SERNO_LEN		= 20,
+	ATA_UDMA0		= (1 << 0),
+	ATA_UDMA1		= ATA_UDMA0 | (1 << 1),
+	ATA_UDMA2		= ATA_UDMA1 | (1 << 2),
+	ATA_UDMA3		= ATA_UDMA2 | (1 << 3),
+	ATA_UDMA4		= ATA_UDMA3 | (1 << 4),
+	ATA_UDMA5		= ATA_UDMA4 | (1 << 5),
+	ATA_UDMA6		= ATA_UDMA5 | (1 << 6),
+	ATA_UDMA7		= ATA_UDMA6 | (1 << 7),
+	/* ATA_UDMA7 is just for completeness... doesn't exist (yet?).  */
+
+	ATA_UDMA_MASK_40C	= ATA_UDMA2,	/* udma0-2 */
+
+	/* DMA-related */
+	ATA_PRD_SZ		= 8,
+	ATA_PRD_TBL_SZ		= (ATA_MAX_PRD * ATA_PRD_SZ),
+	ATA_PRD_EOT		= (1 << 31),	/* end-of-table flag */
+
+	ATA_DMA_TABLE_OFS	= 4,
+	ATA_DMA_STATUS		= 2,
+	ATA_DMA_CMD		= 0,
+	ATA_DMA_WR		= (1 << 3),
+	ATA_DMA_START		= (1 << 0),
+	ATA_DMA_INTR		= (1 << 2),
+	ATA_DMA_ERR		= (1 << 1),
+	ATA_DMA_ACTIVE		= (1 << 0),
+
+	/* bits in ATA command block registers */
+	ATA_HOB			= (1 << 7),	/* LBA48 selector */
+	ATA_NIEN		= (1 << 1),	/* disable-irq flag */
+	ATA_LBA			= (1 << 6),	/* LBA28 selector */
+	ATA_DEV1		= (1 << 4),	/* Select Device 1 (slave) */
+	ATA_DEVICE_OBS		= (1 << 7) | (1 << 5), /* obs bits in dev reg */
+	ATA_DEVCTL_OBS		= (1 << 3),	/* obsolete bit in devctl reg */
+	ATA_BUSY		= (1 << 7),	/* BSY status bit */
+	ATA_DRDY		= (1 << 6),	/* device ready */
+	ATA_DF			= (1 << 5),	/* device fault */
+	ATA_DRQ			= (1 << 3),	/* data request i/o */
+	ATA_ERR			= (1 << 0),	/* have an error */
+	ATA_SRST		= (1 << 2),	/* software reset */
+	ATA_ABORTED		= (1 << 2),	/* command aborted */
+
+	/* ATA command block registers */
+	ATA_REG_DATA		= 0x00,
+	ATA_REG_ERR		= 0x01,
+	ATA_REG_NSECT		= 0x02,
+	ATA_REG_LBAL		= 0x03,
+	ATA_REG_LBAM		= 0x04,
+	ATA_REG_LBAH		= 0x05,
+	ATA_REG_DEVICE		= 0x06,
+	ATA_REG_STATUS		= 0x07,
+
+	ATA_REG_FEATURE		= ATA_REG_ERR, /* and their aliases */
+	ATA_REG_CMD		= ATA_REG_STATUS,
+	ATA_REG_BYTEL		= ATA_REG_LBAM,
+	ATA_REG_BYTEH		= ATA_REG_LBAH,
+	ATA_REG_DEVSEL		= ATA_REG_DEVICE,
+	ATA_REG_IRQ		= ATA_REG_NSECT,
+
+	/* ATA device commands */
+	ATA_CMD_CHK_POWER	= 0xE5, /* check power mode */
+	ATA_CMD_EDD		= 0x90,	/* execute device diagnostic */
+	ATA_CMD_FLUSH		= 0xE7,
+	ATA_CMD_FLUSH_EXT	= 0xEA,
+	ATA_CMD_ID_ATA		= 0xEC,
+	ATA_CMD_ID_ATAPI	= 0xA1,
+	ATA_CMD_READ		= 0xC8,
+	ATA_CMD_READ_EXT	= 0x25,
+	ATA_CMD_WRITE		= 0xCA,
+	ATA_CMD_WRITE_EXT	= 0x35,
+	ATA_CMD_PIO_READ	= 0x20,
+	ATA_CMD_PIO_READ_EXT	= 0x24,
+	ATA_CMD_PIO_WRITE	= 0x30,
+	ATA_CMD_PIO_WRITE_EXT	= 0x34,
+	ATA_CMD_SET_FEATURES	= 0xEF,
+	ATA_CMD_PACKET		= 0xA0,
+	ATA_CMD_VERIFY		= 0x40,
+	ATA_CMD_VERIFY_EXT	= 0x42,
+
+	/* SETFEATURES stuff */
+	SETFEATURES_XFER	= 0x03,
+	XFER_UDMA_7		= 0x47,
+	XFER_UDMA_6		= 0x46,
+	XFER_UDMA_5		= 0x45,
+	XFER_UDMA_4		= 0x44,
+	XFER_UDMA_3		= 0x43,
+	XFER_UDMA_2		= 0x42,
+	XFER_UDMA_1		= 0x41,
+	XFER_UDMA_0		= 0x40,
+	XFER_MW_DMA_2		= 0x22,
+	XFER_MW_DMA_1		= 0x21,
+	XFER_MW_DMA_0		= 0x20,
+	XFER_PIO_4		= 0x0C,
+	XFER_PIO_3		= 0x0B,
+	XFER_PIO_2		= 0x0A,
+	XFER_PIO_1		= 0x09,
+	XFER_PIO_0		= 0x08,
+	XFER_SW_DMA_2		= 0x12,
+	XFER_SW_DMA_1		= 0x11,
+	XFER_SW_DMA_0		= 0x10,
+	XFER_PIO_SLOW		= 0x00,
+
+	/* ATAPI stuff */
+	ATAPI_PKT_DMA		= (1 << 0),
+	ATAPI_DMADIR		= (1 << 2),	/* ATAPI data dir:
+						   0=to device, 1=to host */
+	ATAPI_CDB_LEN		= 16,
+
+	/* cable types */
+	ATA_CBL_NONE		= 0,
+	ATA_CBL_PATA40		= 1,
+	ATA_CBL_PATA80		= 2,
+	ATA_CBL_PATA_UNK	= 3,
+	ATA_CBL_SATA		= 4,
+
+	/* SATA Status and Control Registers */
+	SCR_STATUS		= 0,
+	SCR_ERROR		= 1,
+	SCR_CONTROL		= 2,
+	SCR_ACTIVE		= 3,
+	SCR_NOTIFICATION	= 4,
+
+	/* struct ata_taskfile flags */
+	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
+	ATA_TFLAG_ISADDR	= (1 << 1), /* enable r/w to nsect/lba regs */
+	ATA_TFLAG_DEVICE	= (1 << 2), /* enable r/w to device reg */
+	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
+};
+
+enum ata_tf_protocols {
+	/* ATA taskfile protocols */
+	ATA_PROT_UNKNOWN,	/* unknown/invalid */
+	ATA_PROT_NODATA,	/* no data */
+	ATA_PROT_PIO,		/* PIO single sector */
+	ATA_PROT_PIO_MULT,	/* PIO multiple sector */
+	ATA_PROT_DMA,		/* DMA */
+	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/
+	ATA_PROT_ATAPI_NODATA,	/* packet command, no data */
+	ATA_PROT_ATAPI_DMA,	/* packet command with special DMA sauce */
+};
+
+enum ata_ioctls {
+	ATA_IOC_GET_IO32	= 0x309,
+	ATA_IOC_SET_IO32	= 0x324,
+};
+
+/* core structures */
+
+struct ata_prd {
+	u32			addr;
+	u32			flags_len;
+};
+
+struct ata_taskfile {
+	unsigned long		flags;		/* ATA_TFLAG_xxx */
+	u8			protocol;	/* ATA_PROT_xxx */
+
+	u8			ctl;		/* control reg */
+
+	u8			hob_feature;	/* additional data */
+	u8			hob_nsect;	/* to support LBA48 */
+	u8			hob_lbal;
+	u8			hob_lbam;
+	u8			hob_lbah;
+
+	u8			feature;
+	u8			nsect;
+	u8			lbal;
+	u8			lbam;
+	u8			lbah;
+
+	u8			device;
+
+	u8			command;	/* IO operation */
+};
+
+#define ata_id_is_ata(id)	(((id)[0] & (1 << 15)) == 0)
+#define ata_id_rahead_enabled(id) ((id)[85] & (1 << 6))
+#define ata_id_wcache_enabled(id) ((id)[85] & (1 << 5))
+#define ata_id_has_flush(id) ((id)[83] & (1 << 12))
+#define ata_id_has_flush_ext(id) ((id)[83] & (1 << 13))
+#define ata_id_has_lba48(id)	((id)[83] & (1 << 10))
+#define ata_id_has_wcache(id)	((id)[82] & (1 << 5))
+#define ata_id_has_pm(id)	((id)[82] & (1 << 3))
+#define ata_id_has_lba(id)	((id)[49] & (1 << 9))
+#define ata_id_has_dma(id)	((id)[49] & (1 << 8))
+#define ata_id_removeable(id)	((id)[0] & (1 << 7))
+#define ata_id_u32(id,n)	\
+	(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))
+#define ata_id_u64(id,n)	\
+	( ((u64) (id)[(n) + 3] << 48) |	\
+	  ((u64) (id)[(n) + 2] << 32) |	\
+	  ((u64) (id)[(n) + 1] << 16) |	\
+	  ((u64) (id)[(n) + 0]) )
+
+static inline int atapi_cdb_len(u16 *dev_id)
+{
+	u16 tmp = dev_id[0] & 0x3;
+	switch (tmp) {
+	case 0:		return 12;
+	case 1:		return 16;
+	default:	return -1;
+	}
+}
+
+static inline int is_atapi_taskfile(struct ata_taskfile *tf)
+{
+	return (tf->protocol == ATA_PROT_ATAPI) ||
+	       (tf->protocol == ATA_PROT_ATAPI_NODATA) ||
+	       (tf->protocol == ATA_PROT_ATAPI_DMA);
+}
+
+static inline int ata_ok(u8 status)
+{
+	return ((status & (ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR))
+			== ATA_DRDY);
+}
+
+#endif /* __LINUX_ATA_H__ */
