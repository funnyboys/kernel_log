commit 80ebc420ec59a7c9bcf37881b7d80f68c937ed46
Author: Yunfeng Ye <yeyunfeng@huawei.com>
Date:   Wed Sep 18 15:28:33 2019 +0800

    genirq: fix kerneldoc comment for irq_desc
    
    commit 0c6f8a8b917a ("genirq: Remove compat code") deleted the @status
    member of irq_desc, but forgot to update the comment.
    
    Signed-off-by: Yunfeng Ye <yeyunfeng@huawei.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index d6e2ab538ef2..8f2820c5e69e 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -24,7 +24,7 @@ struct pt_regs;
  * @handle_irq:		highlevel irq-events handler
  * @preflow_handler:	handler called before the flow handler (currently used by sparc)
  * @action:		the irq action chain
- * @status:		status information
+ * @status_use_accessors: status information
  * @core_internal_state__do_not_mess_with_it: core internal status information
  * @depth:		disable-depth, for nested irq_disable() calls
  * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers

commit a324ca9cad4736252c33c1e28cffe1d87f262d03
Merge: 4e6b26d23dc1 28528fca4908
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Feb 23 10:53:31 2019 +0100

    Merge tag 'irqchip-5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms into irq/core
    
    Pull irqchip updates from Marc Zyngier
    
    - Core pseudo-NMI handling code
    - Allow the default irq domain to be retrieved
    - A new interrupt controller for the Loongson LS1X platform
    - Affinity support for the SiFive PLIC
    - Better support for the iMX irqsteer driver
    - NUMA aware memory allocations for GICv3
    - A handful of other fixes (i8259, GICv3, PLIC)

commit 030fc443aef663df71cd834331fd8f1ec10c30c0
Author: Waiman Long <longman@redhat.com>
Date:   Tue Feb 12 09:54:13 2019 -0500

    genirq: Add missing documentation for tot_count
    
    Commit:
    
      1136b0728969 ("genirq: Avoid summation loops for /proc/stat")
    
    adds a new irq_desc::tot_count field, without documenting it.
    Add the missing piece of documentation.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Daniel Colascione <dancol@google.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1549983253-19107-1-git-send-email-longman@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 875c41b23f20..1d679feff3f6 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -28,6 +28,7 @@ struct pt_regs;
  * @core_internal_state__do_not_mess_with_it: core internal status information
  * @depth:		disable-depth, for nested irq_disable() calls
  * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers
+ * @tot_count:		stats field for non-percpu irqs
  * @irq_count:		stats field to detect stalled irqs
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts

commit 1136b0728969901a091f0471968b2b76ed14d9ad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 8 14:48:03 2019 +0100

    genirq: Avoid summation loops for /proc/stat
    
    Waiman reported that on large systems with a large amount of interrupts the
    readout of /proc/stat takes a long time to sum up the interrupt
    statistics. In principle this is not a problem. but for unknown reasons
    some enterprise quality software reads /proc/stat with a high frequency.
    
    The reason for this is that interrupt statistics are accounted per cpu. So
    the /proc/stat logic has to sum up the interrupt stats for each interrupt.
    
    This can be largely avoided for interrupts which are not marked as
    'PER_CPU' interrupts by simply adding a per interrupt summation counter
    which is incremented along with the per interrupt per cpu counter.
    
    The PER_CPU interrupts need to avoid that and use only per cpu accounting
    because they share the interrupt number and the interrupt descriptor and
    concurrent updates would conflict or require unwanted synchronization.
    
    Reported-by: Waiman Long <longman@redhat.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Davidlohr Bueso <dbueso@suse.de>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Daniel Colascione <dancol@google.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Link: https://lkml.kernel.org/r/20190208135020.925487496@linutronix.de
    
    
    8<-------------
    
    v2: Undo the unintentional layout change of struct irq_desc.
    
     include/linux/irqdesc.h |    1 +
     kernel/irq/chip.c       |   12 ++++++++++--
     kernel/irq/internals.h  |    8 +++++++-
     kernel/irq/irqdesc.c    |    7 ++++++-
     4 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dd1e40ddac7d..875c41b23f20 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -65,6 +65,7 @@ struct irq_desc {
 	unsigned int		core_internal_state__do_not_mess_with_it;
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		wake_depth;	/* nested wake enables */
+	unsigned int		tot_count;
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	unsigned int		irqs_unhandled;

commit 6e4933a006616343f66c4702dc4fc56bb25e7b02
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Thu Jan 31 14:54:01 2019 +0000

    irqdesc: Add domain handler for NMIs
    
    NMI handling code should be executed between calls to nmi_enter and
    nmi_exit.
    
    Add a separate domain handler to properly setup NMI context when handling
    an interrupt requested as NMI.
    
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dd1e40ddac7d..ba05b0d6401a 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -171,6 +171,11 @@ static inline int handle_domain_irq(struct irq_domain *domain,
 {
 	return __handle_domain_irq(domain, hwirq, true, regs);
 }
+
+#ifdef CONFIG_IRQ_DOMAIN
+int handle_domain_nmi(struct irq_domain *domain, unsigned int hwirq,
+		      struct pt_regs *regs);
+#endif
 #endif
 
 /* Test to see if a driver has successfully requested an irq */

commit bed9df97b39e73a4607189f2c4b9fb89cc3f7f59
Author: John Garry <john.garry@huawei.com>
Date:   Fri Jun 22 19:35:33 2018 +0800

    irqdesc: Delete irq_desc_get_msi_desc()
    
    Function irq_desc_get_msi_desc() is not referenced in the kernel (and does
    not seem to have been referenced since e39758e0ea76, 3 years ago), so
    delete it.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: <marc.zyngier@arm.com>
    Cc: <will.deacon@arm.com>
    Cc: <kstewart@linuxfoundation.org>
    Cc: <julien.thierry@arm.com>
    Cc: <andrew@lunn.ch>
    Cc: <trivial@kernel.org>
    Link: https://lkml.kernel.org/r/1529667333-92959-1-git-send-email-john.garry@huawei.com

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 25b33b664537..dd1e40ddac7d 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -145,11 +145,6 @@ static inline void *irq_desc_get_handler_data(struct irq_desc *desc)
 	return desc->irq_common_data.handler_data;
 }
 
-static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
-{
-	return desc->irq_common_data.msi_desc;
-}
-
 /*
  * Architectures call this to let the generic IRQ layer
  * handle an interrupt.

commit 39c3fd58952d7599d367c84c1330b785d91d6088
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Dec 2 18:11:04 2017 +0100

    kernel/irq: Extend lockdep class for request mutex
    
    The IRQ code already has support for lockdep class for the lock mutex
    in an interrupt descriptor. Extend this to add a second class for the
    request mutex in the descriptor. Not having a class is resulting in
    false positive splats in some code paths.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: linus.walleij@linaro.org
    Cc: grygorii.strashko@ti.com
    Cc: f.fainelli@gmail.com
    Link: https://lkml.kernel.org/r/1512234664-21555-1-git-send-email-andrew@lunn.ch

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 39fb3700f7a9..25b33b664537 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -255,12 +255,15 @@ static inline bool irq_is_percpu_devid(unsigned int irq)
 }
 
 static inline void
-irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)
+irq_set_lockdep_class(unsigned int irq, struct lock_class_key *lock_class,
+		      struct lock_class_key *request_class)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
 
-	if (desc)
-		lockdep_set_class(&desc->lock, class);
+	if (desc) {
+		lockdep_set_class(&desc->lock, lock_class);
+		lockdep_set_class(&desc->request_mutex, request_class);
+	}
 }
 
 #ifdef CONFIG_IRQ_PREFLOW_FASTEOI

commit 4ce413d1840b25b101be3c0559161db8891f3360
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Dec 1 15:29:39 2017 +0000

    irqdesc: Use bool return type instead of int
    
    The irq_balancing_disabled and irq_is_percpu{,_devid} functions are
    clearly intended to return bool like the functions in
    kernel/irq/settings.h, but actually return an int containing a masked
    value of desc->status_use_accessors. This can lead to subtle breakage
    if, for example, the return value is subsequently truncated when
    assigned to a narrower type.
    
    As Linus points out:
    
    | In particular, what can (and _has_ happened) is that people end up
    | using these functions that return true or false, and they assign the
    | result to something like a bitfield (or a char) or whatever.
    |
    | And the code looks *obviously* correct, when you have things like
    |
    |      dev->percpu = irq_is_percpu_devid(dev->irq);
    |
    | and that "percpu" thing is just one status bit among many. It may even
    | *work*, because maybe that "percpu" flag ends up not being all that
    | important, or it just happens to never be set on the particular
    | hardware that people end up testing.
    |
    | But while it looks obviously correct, and might even work, it's really
    | fundamentally broken. Because that "true or false" function didn't
    | actually return 0/1, it returned 0 or 0x20000.
    |
    | And 0x20000 may not fit in a bitmask or a "char" or whatever.
    
    Fix the problem by consistently using bool as the return type for these
    functions.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: marc.zyngier@arm.com
    Link: https://lkml.kernel.org/r/1512142179-24616-1-git-send-email-will.deacon@arm.com

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dd418955962b..39fb3700f7a9 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -230,7 +230,7 @@ irq_set_chip_handler_name_locked(struct irq_data *data, struct irq_chip *chip,
 	data->chip = chip;
 }
 
-static inline int irq_balancing_disabled(unsigned int irq)
+static inline bool irq_balancing_disabled(unsigned int irq)
 {
 	struct irq_desc *desc;
 
@@ -238,7 +238,7 @@ static inline int irq_balancing_disabled(unsigned int irq)
 	return desc->status_use_accessors & IRQ_NO_BALANCING_MASK;
 }
 
-static inline int irq_is_percpu(unsigned int irq)
+static inline bool irq_is_percpu(unsigned int irq)
 {
 	struct irq_desc *desc;
 
@@ -246,7 +246,7 @@ static inline int irq_is_percpu(unsigned int irq)
 	return desc->status_use_accessors & IRQ_PER_CPU;
 }
 
-static inline int irq_is_percpu_devid(unsigned int irq)
+static inline bool irq_is_percpu_devid(unsigned int irq)
 {
 	struct irq_desc *desc;
 

commit c9b012e5f4a1d01dfa8abc6318211a67ba7d5db2
Merge: b293fca43be5 6cfa7cc46b1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 10:56:56 2017 -0800

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Will Deacon:
     "The big highlight is support for the Scalable Vector Extension (SVE)
      which required extensive ABI work to ensure we don't break existing
      applications by blowing away their signal stack with the rather large
      new vector context (<= 2 kbit per vector register). There's further
      work to be done optimising things like exception return, but the ABI
      is solid now.
    
      Much of the line count comes from some new PMU drivers we have, but
      they're pretty self-contained and I suspect we'll have more of them in
      future.
    
      Plenty of acronym soup here:
    
       - initial support for the Scalable Vector Extension (SVE)
    
       - improved handling for SError interrupts (required to handle RAS
         events)
    
       - enable GCC support for 128-bit integer types
    
       - remove kernel text addresses from backtraces and register dumps
    
       - use of WFE to implement long delay()s
    
       - ACPI IORT updates from Lorenzo Pieralisi
    
       - perf PMU driver for the Statistical Profiling Extension (SPE)
    
       - perf PMU driver for Hisilicon's system PMUs
    
       - misc cleanups and non-critical fixes"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (97 commits)
      arm64: Make ARMV8_DEPRECATED depend on SYSCTL
      arm64: Implement __lshrti3 library function
      arm64: support __int128 on gcc 5+
      arm64/sve: Add documentation
      arm64/sve: Detect SVE and activate runtime support
      arm64/sve: KVM: Hide SVE from CPU features exposed to guests
      arm64/sve: KVM: Treat guest SVE use as undefined instruction execution
      arm64/sve: KVM: Prevent guests from using SVE
      arm64/sve: Add sysctl to set the default vector length for new processes
      arm64/sve: Add prctl controls for userspace vector length management
      arm64/sve: ptrace and ELF coredump support
      arm64/sve: Preserve SVE registers around EFI runtime service calls
      arm64/sve: Preserve SVE registers around kernel-mode NEON use
      arm64/sve: Probe SVE capabilities and usable vector lengths
      arm64: cpufeature: Move sys_caps_initialised declarations
      arm64/sve: Backend logic for setting the vector length
      arm64/sve: Signal handling support
      arm64/sve: Support vector length resetting for new processes
      arm64/sve: Core task context handling
      arm64/sve: Low-level CPU setup
      ...

commit 670310dfbae0eefe7318ff6a61e29e67a7a7bbce
Merge: 43ff2f4db9d0 ffc661c99f62
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:33:11 2017 -0800

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq core updates from Thomas Gleixner:
     "A rather large update for the interrupt core code and the irq chip drivers:
    
       - Add a new bitmap matrix allocator and supporting changes, which is
         used to replace the x86 vector allocator which comes with separate
         pull request. This allows to replace the convoluted nested loop
         allocation function in x86 with a facility which supports the
         recently added property of managed interrupts proper and allows to
         switch to a best effort vector reservation scheme, which addresses
         problems with vector exhaustion.
    
       - A large update to the ARM GIC-V3-ITS driver adding support for
         range selectors.
    
       - New interrupt controllers:
           - Meson and Meson8 GPIO
           - BCM7271 L2
           - Socionext EXIU
    
         If you expected that this will stop at some point, I have to
         disappoint you. There are new ones posted already. Sigh!
    
       - STM32 interrupt controller support for new platforms.
    
       - A pile of fixes, cleanups and updates to the MIPS GIC driver
    
       - The usual small fixes, cleanups and updates all over the place.
         Most visible one is to move the irq chip drivers Kconfig switches
         into a separate Kconfig menu"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (70 commits)
      genirq: Fix type of shifting literal 1 in __setup_irq()
      irqdomain: Drop pointless NULL check in virq_debug_show_one
      genirq/proc: Return proper error code when irq_set_affinity() fails
      irq/work: Use llist_for_each_entry_safe
      irqchip: mips-gic: Print warning if inherited GIC base is used
      irqchip/mips-gic: Add pr_fmt and reword pr_* messages
      irqchip/stm32: Move the wakeup on interrupt mask
      irqchip/stm32: Fix initial values
      irqchip/stm32: Add stm32h7 support
      dt-bindings/interrupt-controllers: Add compatible string for stm32h7
      irqchip/stm32: Add multi-bank management
      irqchip/stm32: Select GENERIC_IRQ_CHIP
      irqchip/exiu: Add support for Socionext Synquacer EXIU controller
      dt-bindings: Add description of Socionext EXIU interrupt controller
      irqchip/gic-v3-its: Fix VPE activate callback return value
      irqchip: mips-gic: Make IPI bitmaps static
      irqchip: mips-gic: Share register writes in gic_set_type()
      irqchip: mips-gic: Remove gic_vpes variable
      irqchip: mips-gic: Use num_possible_cpus() to reserve IPIs
      irqchip: mips-gic: Configure EIC when CPUs come online
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 3e90a094798d..b6084898d330 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_IRQDESC_H
 #define _LINUX_IRQDESC_H
 

commit 08395c7f4d9f5808b5754a0dbed969f378bde0c3
Author: Julien Thierry <julien.thierry@arm.com>
Date:   Fri Oct 13 12:26:44 2017 +0100

    irqdesc: Add function to identify percpu_devid irqs
    
    irq_is_percpu indicates whether an irq should only target a single cpu.
    PERCPU_DEVID flag indicates that an irq can be configured differently on
    each cpu it can target.
    
    Provide a function to check whether an irq is PERCPU_DEVID.
    
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Julien Thierry <julien.thierry@arm.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 3e90a094798d..93960cf36e23 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -244,6 +244,14 @@ static inline int irq_is_percpu(unsigned int irq)
 	return desc->status_use_accessors & IRQ_PER_CPU;
 }
 
+static inline int irq_is_percpu_devid(unsigned int irq)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	return desc->status_use_accessors & IRQ_PER_CPU_DEVID;
+}
+
 static inline void
 irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)
 {

commit 07557ccb8c83f315e409ddee181e9ffbf87c6ad1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 13 23:29:05 2017 +0200

    genirq/msi: Capture device name for debugfs
    
    For debugging the allocation of unused or potentially leaked interrupt
    descriptor it's helpful to have some information about the site which
    allocated them. In case of MSI this is simple because the caller hands the
    device struct pointer into the domain allocation function.
    
    Duplicate the device name and show it in the debugfs entry of the interrupt
    descriptor.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Juergen Gross <jgross@suse.com>
    Tested-by: Yu Chen <yu.c.chen@intel.com>
    Acked-by: Juergen Gross <jgross@suse.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Alok Kataria <akataria@vmware.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Rui Zhang <rui.zhang@intel.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: https://lkml.kernel.org/r/20170913213152.433038426@linutronix.de

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 3e90a094798d..b55b113c049b 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -93,6 +93,7 @@ struct irq_desc {
 #endif
 #ifdef CONFIG_GENERIC_IRQ_DEBUGFS
 	struct dentry		*debugfs_file;
+	const char		*dev_name;
 #endif
 #ifdef CONFIG_SPARSE_IRQ
 	struct rcu_head		rcu;

commit 9114014cf4e6df0b22d764380ae1fc54f1a7a8b2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 29 23:33:37 2017 +0200

    genirq: Add mutex to irq desc to serialize request/free_irq()
    
    The irq_request/release_resources() callbacks ar currently invoked under
    desc->lock with interrupts disabled. This is a source of problems on RT and
    conceptually not required.
    
    Add a seperate mutex to struct irq_desc which allows to serialize
    request/free_irq(), which can be used to move the resource functions out of
    the desc->lock held region.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Julia Cartwright <julia@ni.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Brian Norris <briannorris@chromium.org>
    Cc: Doug Anderson <dianders@chromium.org>
    Cc: linux-rockchip@lists.infradead.org
    Cc: John Keeping <john@metanate.com>
    Cc: linux-gpio@vger.kernel.org
    Link: http://lkml.kernel.org/r/20170629214344.039220922@linutronix.de

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index d425a3a09722..3e90a094798d 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -3,6 +3,7 @@
 
 #include <linux/rcupdate.h>
 #include <linux/kobject.h>
+#include <linux/mutex.h>
 
 /*
  * Core internal functions to deal with irq descriptors
@@ -45,6 +46,7 @@ struct pt_regs;
  *			IRQF_FORCE_RESUME set
  * @rcu:		rcu head for delayed free
  * @kobj:		kobject used to represent this struct in sysfs
+ * @request_mutex:	mutex to protect request/free before locking desc->lock
  * @dir:		/proc/irq/ procfs entry
  * @debugfs_file:	dentry for the debugfs file
  * @name:		flow handler name for /proc/interrupts output
@@ -96,6 +98,7 @@ struct irq_desc {
 	struct rcu_head		rcu;
 	struct kobject		kobj;
 #endif
+	struct mutex		request_mutex;
 	int			parent_irq;
 	struct module		*owner;
 	const char		*name;

commit 087cdfb662ae50e3826e7cd2e54b6519d07b60f0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 20 01:37:17 2017 +0200

    genirq/debugfs: Add proper debugfs interface
    
    Debugging (hierarchical) interupt domains is tedious as there is no
    information about the hierarchy and no information about states of
    interrupts in the various domain levels.
    
    Add a debugfs directory 'irq' and subdirectories 'domains' and 'irqs'.
    
    The domains directory contains the domain files. The content is information
    about the domain. If the domain is part of a hierarchy then the parent
    domains are printed as well.
    
    # ls /sys/kernel/debug/irq/domains/
    default     INTEL-IR-2      INTEL-IR-MSI-2  IO-APIC-IR-2  PCI-MSI
    DMAR-MSI    INTEL-IR-3      INTEL-IR-MSI-3  IO-APIC-IR-3  unknown-1
    INTEL-IR-0  INTEL-IR-MSI-0  IO-APIC-IR-0    IO-APIC-IR-4  VECTOR
    INTEL-IR-1  INTEL-IR-MSI-1  IO-APIC-IR-1    PCI-HT
    
    # cat /sys/kernel/debug/irq/domains/VECTOR
    name:   VECTOR
     size:   0
     mapped: 216
     flags:  0x00000041
    
    # cat /sys/kernel/debug/irq/domains/IO-APIC-IR-0
    name:   IO-APIC-IR-0
     size:   24
     mapped: 19
     flags:  0x00000041
     parent: INTEL-IR-3
        name:   INTEL-IR-3
         size:   65536
         mapped: 167
         flags:  0x00000041
         parent: VECTOR
            name:   VECTOR
             size:   0
             mapped: 216
             flags:  0x00000041
    
    Unfortunately there is no per cpu information about the VECTOR domain (yet).
    
    The irqs directory contains detailed information about mapped interrupts.
    
    # cat /sys/kernel/debug/irq/irqs/3
    handler:  handle_edge_irq
    status:   0x00004000
    istate:   0x00000000
    ddepth:   1
    wdepth:   0
    dstate:   0x01018000
                IRQD_IRQ_DISABLED
                IRQD_SINGLE_TARGET
                IRQD_MOVE_PCNTXT
    node:     0
    affinity: 0-143
    effectiv: 0
    pending:
    domain:  IO-APIC-IR-0
     hwirq:   0x3
     chip:    IR-IO-APIC
      flags:   0x10
                 IRQCHIP_SKIP_SET_WAKE
     parent:
        domain:  INTEL-IR-3
         hwirq:   0x20000
         chip:    INTEL-IR
          flags:   0x0
         parent:
            domain:  VECTOR
             hwirq:   0x3
             chip:    APIC
              flags:   0x0
    
    This was developed to simplify the debugging of the managed affinity
    changes.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Link: http://lkml.kernel.org/r/20170619235444.537566163@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index c9be57931b58..d425a3a09722 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -46,6 +46,7 @@ struct pt_regs;
  * @rcu:		rcu head for delayed free
  * @kobj:		kobject used to represent this struct in sysfs
  * @dir:		/proc/irq/ procfs entry
+ * @debugfs_file:	dentry for the debugfs file
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {
@@ -88,6 +89,9 @@ struct irq_desc {
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif
+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
+	struct dentry		*debugfs_file;
+#endif
 #ifdef CONFIG_SPARSE_IRQ
 	struct rcu_head		rcu;
 	struct kobject		kobj;

commit ecb3f394c5dba897d215a5422f1b363e93e2ce4e
Author: Craig Gallek <kraig@google.com>
Date:   Tue Sep 13 12:14:51 2016 -0400

    genirq: Expose interrupt information through sysfs
    
    Information about interrupts is exposed via /proc/interrupts, but the
    format of that file has changed over kernel versions and differs across
    architectures. It also has varying column numbers depending on hardware.
    
    That all makes it hard for tools to parse.
    
    To solve this, expose the information through sysfs so each irq attribute
    is in a separate file in a consistent, machine parsable way.
    
    This feature is only available when both CONFIG_SPARSE_IRQ and
    CONFIG_SYSFS are enabled.
    
    Examples:
      /sys/kernel/irq/18/actions:   i801_smbus,ehci_hcd:usb1,uhci_hcd:usb7
      /sys/kernel/irq/18/chip_name: IR-IO-APIC
      /sys/kernel/irq/18/hwirq:             18
      /sys/kernel/irq/18/name:              fasteoi
      /sys/kernel/irq/18/per_cpu_count:     0,0
      /sys/kernel/irq/18/type:              level
    
      /sys/kernel/irq/25/actions:   ahci0
      /sys/kernel/irq/25/chip_name: IR-PCI-MSI
      /sys/kernel/irq/25/hwirq:             512000
      /sys/kernel/irq/25/name:              edge
      /sys/kernel/irq/25/per_cpu_count:     29036,0
      /sys/kernel/irq/25/type:              edge
    
    [ tglx: Moved kobject_del() under sparse_irq_lock, massaged code comments
            and changelog ]
    
    Signed-off-by: Craig Gallek <kraig@google.com>
    Cc: David Decotigny <decot@google.com>
    Link: http://lkml.kernel.org/r/1473783291-122873-1-git-send-email-kraigatgoog@gmail.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index b51beebf9804..c9be57931b58 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -2,6 +2,7 @@
 #define _LINUX_IRQDESC_H
 
 #include <linux/rcupdate.h>
+#include <linux/kobject.h>
 
 /*
  * Core internal functions to deal with irq descriptors
@@ -43,6 +44,7 @@ struct pt_regs;
  * @force_resume_depth:	number of irqactions on a irq descriptor with
  *			IRQF_FORCE_RESUME set
  * @rcu:		rcu head for delayed free
+ * @kobj:		kobject used to represent this struct in sysfs
  * @dir:		/proc/irq/ procfs entry
  * @name:		flow handler name for /proc/interrupts output
  */
@@ -88,6 +90,7 @@ struct irq_desc {
 #endif
 #ifdef CONFIG_SPARSE_IRQ
 	struct rcu_head		rcu;
+	struct kobject		kobj;
 #endif
 	int			parent_irq;
 	struct module		*owner;

commit 222df54fd8b7641dcc81476f157806bb3144ee1d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Apr 11 09:57:52 2016 +0100

    genirq: Allow the affinity of a percpu interrupt to be set/retrieved
    
    In order to prepare the genirq layer for the concept of partitionned
    percpu interrupts, let's allow an affinity to be associated with
    such an interrupt. We introduce:
    
    - irq_set_percpu_devid_partition: flag an interrupt as a percpu-devid
      interrupt, and associate it with an affinity
    - irq_get_percpu_devid_partition: allow the affinity of that interrupt
      to be retrieved.
    
    This will allow a driver to discover which CPUs the per-cpu interrupt
    can actually fire on.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: devicetree@vger.kernel.org
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Rob Herring <robh+dt@kernel.org>
    Link: http://lkml.kernel.org/r/1460365075-7316-3-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dcca77c4b9d2..b51beebf9804 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -66,6 +66,7 @@ struct irq_desc {
 	int			threads_handled_last;
 	raw_spinlock_t		lock;
 	struct cpumask		*percpu_enabled;
+	const struct cpumask	*percpu_affinity;
 #ifdef CONFIG_SMP
 	const struct cpumask	*affinity_hint;
 	struct irq_affinity_notify *affinity_notify;

commit 425a5072dcd1bd895eea90a6b495392b6358ebd0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 13 18:02:22 2015 +0100

    genirq: Free irq_desc with rcu
    
    The new VMD device driver needs to iterate over a list of
    "demultiplexing" interrupts. Protecting that list with a lock is not
    possible because the list is also required in code pathes which hold
    irq descriptor lock. Therefor the demultiplexing interrupt handler
    would create a lock inversion scenario if it calls a demux handler
    with the list protection lock held.
    
    A solution for this is to free the irq descriptor via RCU, so the
    list can be walked with rcu read lock held.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Keith Busch <keith.busch@intel.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index a587a33363c7..dcca77c4b9d2 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -1,6 +1,8 @@
 #ifndef _LINUX_IRQDESC_H
 #define _LINUX_IRQDESC_H
 
+#include <linux/rcupdate.h>
+
 /*
  * Core internal functions to deal with irq descriptors
  */
@@ -40,6 +42,7 @@ struct pt_regs;
  *			IRQF_NO_SUSPEND set
  * @force_resume_depth:	number of irqactions on a irq descriptor with
  *			IRQF_FORCE_RESUME set
+ * @rcu:		rcu head for delayed free
  * @dir:		/proc/irq/ procfs entry
  * @name:		flow handler name for /proc/interrupts output
  */
@@ -81,6 +84,9 @@ struct irq_desc {
 #endif
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
+#endif
+#ifdef CONFIG_SPARSE_IRQ
+	struct rcu_head		rcu;
 #endif
 	int			parent_irq;
 	struct module		*owner;

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index fbb4d5afc32b..a587a33363c7 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -135,9 +135,9 @@ static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
  * Architectures call this to let the generic IRQ layer
  * handle an interrupt.
  */
-static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
+static inline void generic_handle_irq_desc(struct irq_desc *desc)
 {
-	desc->handle_irq(irq, desc);
+	desc->handle_irq(desc);
 }
 
 int generic_handle_irq(unsigned int irq);

commit b237721c5d95082a803c0be686f56d2dd1de995b
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:43 2015 +0800

    genirq: Move field 'msi_desc' from irq_data into irq_common_data
    
    MSI descriptors are per-irq instead of per irqchip, so move it into
    struct irq_common_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-35-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index c7b3e1cc6d59..fbb4d5afc32b 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -128,7 +128,7 @@ static inline void *irq_desc_get_handler_data(struct irq_desc *desc)
 
 static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
 {
-	return desc->irq_data.msi_desc;
+	return desc->irq_common_data.msi_desc;
 }
 
 /*

commit af7080e040d223b5e7d0a8de28f7cea24ef017c4
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:21 2015 +0800

    genirq: Move field 'handler_data' from irq_data into irq_common_data
    
    Handler data (handler_data) is per-irq instead of per irqchip, so move
    it into struct irq_common_data.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-13-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 1fc5304641a1..c7b3e1cc6d59 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -123,7 +123,7 @@ static inline void *irq_desc_get_chip_data(struct irq_desc *desc)
 
 static inline void *irq_desc_get_handler_data(struct irq_desc *desc)
 {
-	return desc->irq_data.handler_data;
+	return desc->irq_common_data.handler_data;
 }
 
 static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)

commit 755d119a6204974b2005a98549a48a75a7f5010b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 16 14:37:12 2015 +0200

    genirq: Simplify irq_data_to_desc()
    
    Avoid the lookup of irq_desc and use the same mechanism for
    hierarchical and flat irqdomains.
    
    Based-on-a-patch-from: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dce395cd67de..1fc5304641a1 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -98,11 +98,7 @@ extern struct irq_desc irq_desc[NR_IRQS];
 
 static inline struct irq_desc *irq_data_to_desc(struct irq_data *data)
 {
-#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
-	return irq_to_desc(data->irq);
-#else
-	return container_of(data, struct irq_desc, irq_data);
-#endif
+	return container_of(data->common, struct irq_desc, irq_common_data);
 }
 
 static inline unsigned int irq_desc_get_irq(struct irq_desc *desc)

commit 123236ccacc933daac3b39c5eb1f0011c70d41d8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 16 12:54:23 2015 +0200

    genirq: Remove __irq_set_handler_locked()
    
    All users converted to irq_set_handler_locked()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 29741382593c..dce395cd67de 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -174,16 +174,6 @@ static inline int irq_has_action(unsigned int irq)
 	return irq_desc_has_action(irq_to_desc(irq));
 }
 
-/* caller has locked the irq_desc and both params are valid */
-static inline void __irq_set_handler_locked(unsigned int irq,
-					    irq_flow_handler_t handler)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-	desc->handle_irq = handler;
-}
-
 /**
  * irq_set_handler_locked - Set irq handler from a locked region
  * @data:	Pointer to the irq_data structure which identifies the irq

commit e902e14549e04c040fb6e15785efd35f810a223a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 16 12:36:04 2015 +0200

    genirq: Remove __irq_set_chip_handler_name_locked()
    
    All users converted to irq_set_chip_handler_name_locked()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 0593c691d091..29741382593c 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -184,19 +184,6 @@ static inline void __irq_set_handler_locked(unsigned int irq,
 	desc->handle_irq = handler;
 }
 
-/* caller has locked the irq_desc and both params are valid */
-static inline void
-__irq_set_chip_handler_name_locked(unsigned int irq, struct irq_chip *chip,
-				   irq_flow_handler_t handler, const char *name)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-	irq_desc_get_irq_data(desc)->chip = chip;
-	desc->handle_irq = handler;
-	desc->name = name;
-}
-
 /**
  * irq_set_handler_locked - Set irq handler from a locked region
  * @data:	Pointer to the irq_data structure which identifies the irq

commit 6584d84c3e504c76ad291cc2e381bbeed59798ab
Author: Huang Shijie <shijie.huang@arm.com>
Date:   Tue Sep 1 10:35:50 2015 +0800

    genirq: Update the comment for generic_handle_irq_desc
    
    __do_IRQ() was removed by commit 1c77ff2 "genirq: Remove __do_IRQ",
    but the comment referring to __do_IRQ() was left.
    
    Update the comment for generic_handle_irq_desc().
    
    Signed-off-by: Huang Shijie <shijie.huang@arm.com>
    Cc: jiang.liu@linux.intel.com
    Cc: peterz@infradead.org
    Cc: rafael.j.wysocki@intel.com
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Link: http://lkml.kernel.org/r/1441074950-3893-1-git-send-email-shijie.huang@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 5acfa26602e1..0593c691d091 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -137,9 +137,7 @@ static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
 
 /*
  * Architectures call this to let the generic IRQ layer
- * handle an interrupt. If the descriptor is attached to an
- * irqchip-style controller then we call the ->handle_irq() handler,
- * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
+ * handle an interrupt.
  */
 static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
 {

commit f61ae4fb66a4f7ae49e3456003fc4328d6db09c9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 2 20:38:26 2015 +0000

    genirq: Provide irq_desc_has_action
    
    If we have a reference to irq_desc already, there is no point to do
    another lookup.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Link: http://lkml.kernel.org/r/20150802203609.638130301@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index fcea4e48e21f..5acfa26602e1 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -166,12 +166,16 @@ static inline int handle_domain_irq(struct irq_domain *domain,
 #endif
 
 /* Test to see if a driver has successfully requested an irq */
-static inline int irq_has_action(unsigned int irq)
+static inline int irq_desc_has_action(struct irq_desc *desc)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
 	return desc->action != NULL;
 }
 
+static inline int irq_has_action(unsigned int irq)
+{
+	return irq_desc_has_action(irq_to_desc(irq));
+}
+
 /* caller has locked the irq_desc and both params are valid */
 static inline void __irq_set_handler_locked(unsigned int irq,
 					    irq_flow_handler_t handler)

commit a899418167264c7bac574b1a0f1b2c26c5b0995a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 5 17:12:30 2015 +0000

    hotplug: Prevent alloc/free of irq descriptors during cpu up/down
    
    When a cpu goes up some architectures (e.g. x86) have to walk the irq
    space to set up the vector space for the cpu. While this needs extra
    protection at the architecture level we can avoid a few race
    conditions by preventing the concurrent allocation/free of irq
    descriptors and the associated data.
    
    When a cpu goes down it moves the interrupts which are targeted to
    this cpu away by reassigning the affinities. While this happens
    interrupts can be allocated and freed, which opens a can of race
    conditions in the code which reassignes the affinities because
    interrupt descriptors might be freed underneath.
    
    Example:
    
    CPU1                            CPU2
    cpu_up/down
     irq_desc = irq_to_desc(irq);
                                    remove_from_radix_tree(desc);
     raw_spin_lock(&desc->lock);
                                    free(desc);
    
    We could protect the irq descriptors with RCU, but that would require
    a full tree change of all accesses to interrupt descriptors. But
    fortunately these kind of race conditions are rather limited to a few
    things like cpu hotplug. The normal setup/teardown is very well
    serialized. So the simpler and obvious solution is:
    
    Prevent allocation and freeing of interrupt descriptors accross cpu
    hotplug.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: xiao jin <jin.xiao@intel.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Yanmin Zhang <yanmin_zhang@linux.intel.com>
    Link: http://lkml.kernel.org/r/20150705171102.063519515@linutronix.de

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 624a668e61f1..fcea4e48e21f 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -87,7 +87,12 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-#ifndef CONFIG_SPARSE_IRQ
+#ifdef CONFIG_SPARSE_IRQ
+extern void irq_lock_sparse(void);
+extern void irq_unlock_sparse(void);
+#else
+static inline void irq_lock_sparse(void) { }
+static inline void irq_unlock_sparse(void) { }
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 

commit bbc9d21fc0071c245c19077155ea371092ff0db8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 23 15:01:30 2015 +0200

    genirq: Implement irq_set_handler_locked()/irq_set_chip_handler_name_locked()
    
    The main use case for the exisiting __irq_set_*_locked() inlines is to
    replace the handler [,chip and name] of an interrupt from a region
    which has the irq descriptor lock held, e.g. from the irq_set_type()
    callback. The first argument is the irq number, so the functions need
    so perform a pointless lookup of the interrupt descriptor for those
    cases which have the irq_data pointer handy.
    
    Provide new functions which take an irq_data pointer instead of the
    interrupt number, so the lookup of the interrupt descriptor can be
    avoided.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    
    Conflicts:
            include/linux/irqdesc.h

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index a72bfd94ea10..624a668e61f1 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -190,6 +190,47 @@ __irq_set_chip_handler_name_locked(unsigned int irq, struct irq_chip *chip,
 	desc->name = name;
 }
 
+/**
+ * irq_set_handler_locked - Set irq handler from a locked region
+ * @data:	Pointer to the irq_data structure which identifies the irq
+ * @handler:	Flow control handler function for this interrupt
+ *
+ * Sets the handler in the irq descriptor associated to @data.
+ *
+ * Must be called with irq_desc locked and valid parameters. Typical
+ * call site is the irq_set_type() callback.
+ */
+static inline void irq_set_handler_locked(struct irq_data *data,
+					  irq_flow_handler_t handler)
+{
+	struct irq_desc *desc = irq_data_to_desc(data);
+
+	desc->handle_irq = handler;
+}
+
+/**
+ * irq_set_chip_handler_name_locked - Set chip, handler and name from a locked region
+ * @data:	Pointer to the irq_data structure for which the chip is set
+ * @chip:	Pointer to the new irq chip
+ * @handler:	Flow control handler function for this interrupt
+ * @name:	Name of the interrupt
+ *
+ * Replace the irq chip at the proper hierarchy level in @data and
+ * sets the handler and name in the associated irq descriptor.
+ *
+ * Must be called with irq_desc locked and valid parameters.
+ */
+static inline void
+irq_set_chip_handler_name_locked(struct irq_data *data, struct irq_chip *chip,
+				 irq_flow_handler_t handler, const char *name)
+{
+	struct irq_desc *desc = irq_data_to_desc(data);
+
+	desc->handle_irq = handler;
+	desc->name = name;
+	data->chip = chip;
+}
+
 static inline int irq_balancing_disabled(unsigned int irq)
 {
 	struct irq_desc *desc;

commit 304adf8a8fff972f633bf52b3d160682d3f3d5d2
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:26 2015 +0800

    genirq: Introduce helper irq_desc_get_irq()
    
    Introduce helper irq_desc_get_irq() to retrieve the irq number from
    the irq descriptor.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433391238-19471-17-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 66c41b40ca50..a72bfd94ea10 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -100,6 +100,11 @@ static inline struct irq_desc *irq_data_to_desc(struct irq_data *data)
 #endif
 }
 
+static inline unsigned int irq_desc_get_irq(struct irq_desc *desc)
+{
+	return desc->irq_data.irq;
+}
+
 static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
 {
 	return &desc->irq_data;

commit daf7ab7c58ac5f6304b63cca47a06cdc213361d7
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:11 2015 +0800

    genirq: Clean up outdated comments related to include/linux/irqdesc.h
    
    Seems we have little chance to move irqdesc.h from include/linux/ into
    kernel/irq/, so remove the outdated comments.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433391238-19471-2-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index c52d1480f272..66c41b40ca50 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -3,9 +3,6 @@
 
 /*
  * Core internal functions to deal with irq descriptors
- *
- * This include will move to kernel/irq once we cleaned up the tree.
- * For now it's included from <linux/irq.h>
  */
 
 struct irq_affinity_notify;

commit 0d0b4c866bcce647f40d73efe5e90aeeb079050a
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:12 2015 +0800

    genirq: Introduce struct irq_common_data to host shared irq data
    
    With the introduction of hierarchy irqdomain, struct irq_data becomes
    per-chip instead of per-irq and there may be multiple irq_datas
    associated with the same irq. Some per-irq data stored in struct
    irq_data now may get duplicated into multiple irq_datas, and causes
    inconsistent view.
    
    So introduce struct irq_common_data to host per-irq common data and to
    achieve consistent view among irq_chips.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-4-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index a113a8dc7438..c52d1480f272 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -17,7 +17,7 @@ struct pt_regs;
 
 /**
  * struct irq_desc - interrupt descriptor
- * @irq_data:		per irq and chip data passed down to chip functions
+ * @irq_common_data:	per irq and chip data passed down to chip functions
  * @kstat_irqs:		irq stats per cpu
  * @handle_irq:		highlevel irq-events handler
  * @preflow_handler:	handler called before the flow handler (currently used by sparc)
@@ -47,6 +47,7 @@ struct pt_regs;
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {
+	struct irq_common_data	irq_common_data;
 	struct irq_data		irq_data;
 	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;

commit 7bbf1dd24b17b9ec4f47c43ce4e05bf190745553
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Mon Jun 1 16:05:10 2015 +0800

    genirq: Enhance irq_data_to_desc() to support hierarchy irqdomain
    
    For irq associated with hierarchy irqdomains, there will be multiple
    irq_datas for one irq_desc. So enhance irq_data_to_desc() to support
    hierarchy irqdomain. Also export irq_data_to_desc() as an inline
    function for later reuse.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Link: http://lkml.kernel.org/r/1433145945-789-2-git-send-email-jiang.liu@linux.intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index dd1109fb241e..a113a8dc7438 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -93,6 +93,15 @@ struct irq_desc {
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 
+static inline struct irq_desc *irq_data_to_desc(struct irq_data *data)
+{
+#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+	return irq_to_desc(data->irq);
+#else
+	return container_of(data, struct irq_desc, irq_data);
+#endif
+}
+
 static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
 {
 	return &desc->irq_data;

commit 17f480342026e54000731acaa69bf32787ce46cb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 27 00:07:55 2015 +0100

    genirq / PM: Add flag for shared NO_SUSPEND interrupt lines
    
    It currently is required that all users of NO_SUSPEND interrupt
    lines pass the IRQF_NO_SUSPEND flag when requesting the IRQ or the
    WARN_ON_ONCE() in irq_pm_install_action() will trigger.  That is
    done to warn about situations in which unprepared interrupt handlers
    may be run unnecessarily for suspended devices and may attempt to
    access those devices by mistake.  However, it may cause drivers
    that have no technical reasons for using IRQF_NO_SUSPEND to set
    that flag just because they happen to share the interrupt line
    with something like a timer.
    
    Moreover, the generic handling of wakeup interrupts introduced by
    commit 9ce7a25849e8 (genirq: Simplify wakeup mechanism) only works
    for IRQs without any NO_SUSPEND users, so the drivers of wakeup
    devices needing to use shared NO_SUSPEND interrupt lines for
    signaling system wakeup generally have to detect wakeup in their
    interrupt handlers.  Thus if they happen to share an interrupt line
    with a NO_SUSPEND user, they also need to request that their
    interrupt handlers be run after suspend_device_irqs().
    
    In both cases the reason for using IRQF_NO_SUSPEND is not because
    the driver in question has a genuine need to run its interrupt
    handler after suspend_device_irqs(), but because it happens to
    share the line with some other NO_SUSPEND user.  Otherwise, the
    driver would do without IRQF_NO_SUSPEND just fine.
    
    To make it possible to specify that condition explicitly, introduce
    a new IRQ action handler flag for shared IRQs, IRQF_COND_SUSPEND,
    that, when set, will indicate to the IRQ core that the interrupt
    user is generally fine with suspending the IRQ, but it also can
    tolerate handler invocations after suspend_device_irqs() and, in
    particular, it is capable of detecting system wakeup and triggering
    it as appropriate from its interrupt handler.
    
    That will allow us to work around a problem with a shared timer
    interrupt line on at91 platforms.
    
    Link: http://marc.info/?l=linux-kernel&m=142252777602084&w=2
    Link: http://marc.info/?t=142252775300011&r=1&w=2
    Link: https://lkml.org/lkml/2014/12/15/552
    Reported-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Mark Rutland <mark.rutland@arm.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index faf433af425e..dd1109fb241e 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -78,6 +78,7 @@ struct irq_desc {
 #ifdef CONFIG_PM_SLEEP
 	unsigned int		nr_actions;
 	unsigned int		no_suspend_depth;
+	unsigned int		cond_suspend_depth;
 	unsigned int		force_resume_depth;
 #endif
 #ifdef CONFIG_PROC_FS

commit b528392669415dc1e53a047215e5ad6c2de879fc
Merge: 80213c03c415 9f1a05329695
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 16:07:43 2014 -0400

    Merge tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "Features-wise, to me the most important this time is a rework of
      wakeup interrupts handling in the core that makes them work
      consistently across all of the available sleep states, including
      suspend-to-idle.  Many thanks to Thomas Gleixner for his help with
      this work.
    
      Second is an update of the generic PM domains code that has been in
      need of some care for quite a while.  Unused code is being removed, DT
      support is being added and domains are now going to be attached to
      devices in bus type code in analogy with the ACPI PM domain.  The
      majority of work here was done by Ulf Hansson who also has been the
      most active developer this time.
    
      Apart from this we have a traditional ACPICA update, this time to
      upstream version 20140828 and a few ACPI wakeup interrupts handling
      patches on top of the general rework mentioned above.  There also are
      several cpufreq commits including renaming the cpufreq-cpu0 driver to
      cpufreq-dt, as this is what implements generic DT-based cpufreq
      support, and a new DT-based idle states infrastructure for cpuidle.
    
      In addition to that, the ACPI LPSS driver is updated, ACPI support for
      Apple machines is improved, a few bugs are fixed and a few cleanups
      are made all over.
    
      Finally, the Adaptive Voltage Scaling (AVS) subsystem now has a tree
      maintained by Kevin Hilman that will be merged through the PM tree.
    
      Numbers-wise, the generic PM domains update takes the lead this time
      with 32 non-merge commits, second is cpufreq (15 commits) and the 3rd
      place goes to the wakeup interrupts handling rework (13 commits).
    
      Specifics:
    
       - Rework the handling of wakeup IRQs by the IRQ core such that all of
         them will be switched over to "wakeup" mode in suspend_device_irqs()
         and in that mode the first interrupt will abort system suspend in
         progress or wake up the system if already in suspend-to-idle (or
         equivalent) without executing any interrupt handlers.  Among other
         things that eliminates the wakeup-related motivation to use the
         IRQF_NO_SUSPEND interrupt flag with interrupts which don't really
         need it and should not use it (Thomas Gleixner and Rafael Wysocki)
    
       - Switch over ACPI to handling wakeup interrupts with the help of the
         new mechanism introduced by the above IRQ core rework (Rafael Wysocki)
    
       - Rework the core generic PM domains code to eliminate code that's
         not used, add DT support and add a generic mechanism by which
         devices can be added to PM domains automatically during enumeration
         (Ulf Hansson, Geert Uytterhoeven and Tomasz Figa).
    
       - Add debugfs-based mechanics for debugging generic PM domains
         (Maciej Matraszek).
    
       - ACPICA update to upstream version 20140828.  Included are updates
         related to the SRAT and GTDT tables and the _PSx methods are in the
         METHOD_NAME list now (Bob Moore and Hanjun Guo).
    
       - Add _OSI("Darwin") support to the ACPI core (unfortunately, that
         can't really be done in a straightforward way) to prevent
         Thunderbolt from being turned off on Apple systems after boot (or
         after resume from system suspend) and rework the ACPI Smart Battery
         Subsystem (SBS) driver to work correctly with Apple platforms
         (Matthew Garrett and Andreas Noever).
    
       - ACPI LPSS (Low-Power Subsystem) driver update cleaning up the code,
         adding support for 133MHz I2C source clock on Intel Baytrail to it
         and making it avoid using UART RTS override with Auto Flow Control
         (Heikki Krogerus).
    
       - ACPI backlight updates removing the video_set_use_native_backlight
         quirk which is not necessary any more, making the code check the
         list of output devices returned by the _DOD method to avoid
         creating acpi_video interfaces that won't work and adding a quirk
         for Lenovo Ideapad Z570 (Hans de Goede, Aaron Lu and Stepan Bujnak)
    
       - New Win8 ACPI OSI quirks for some Dell laptops (Edward Lin)
    
       - Assorted ACPI code cleanups (Fabian Frederick, Rasmus Villemoes,
         Sudip Mukherjee, Yijing Wang, and Zhang Rui)
    
       - cpufreq core updates and cleanups (Viresh Kumar, Preeti U Murthy,
         Rasmus Villemoes)
    
       - cpufreq driver updates: cpufreq-cpu0/cpufreq-dt (driver name change
         among other things), ppc-corenet, powernv (Viresh Kumar, Preeti U
         Murthy, Shilpasri G Bhat, Lucas Stach)
    
       - cpuidle support for DT-based idle states infrastructure, new ARM64
         cpuidle driver, cpuidle core cleanups (Lorenzo Pieralisi, Rasmus
         Villemoes)
    
       - ARM big.LITTLE cpuidle driver updates: support for DT-based
         initialization and Exynos5800 compatible string (Lorenzo Pieralisi,
         Kevin Hilman)
    
       - Rework of the test_suspend kernel command line argument and a new
         trace event for console resume (Srinivas Pandruvada, Todd E Brandt)
    
       - Second attempt to optimize swsusp_free() (hibernation core) to make
         it avoid going through all PFNs which may be way too slow on some
         systems (Joerg Roedel)
    
       - devfreq updates (Paul Bolle, Punit Agrawal, Ãrjan Eide).
    
       - rockchip-io Adaptive Voltage Scaling (AVS) driver and AVS entry
         update in MAINTAINERS (Heiko Stübner, Kevin Hilman)
    
       - PM core fix related to clock management (Geert Uytterhoeven)
    
       - PM core's sysfs code cleanup (Johannes Berg)"
    
    * tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (105 commits)
      ACPI / fan: printk replacement
      PM / clk: Fix crash in clocks management code if !CONFIG_PM_RUNTIME
      PM / Domains: Rename cpu_data to cpuidle_data
      cpufreq: cpufreq-dt: fix potential double put of cpu OF node
      cpufreq: cpu0: rename driver and internals to 'cpufreq_dt'
      PM / hibernate: Iterate over set bits instead of PFNs in swsusp_free()
      cpufreq: ppc-corenet: remove duplicate update of cpu_data
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
      ACPICA: Introduce acpi_enable_all_wakeup_gpes()
      ACPICA: Clear all non-wakeup GPEs in acpi_hw_enable_wakeup_gpe_block()
      ACPI / video: check _DOD list when creating backlight devices
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      cpufreq: Replace strnicmp with strncasecmp
      cpufreq: powernv: Set the cpus to nominal frequency during reboot/kexec
      cpufreq: powernv: Set the pstate of the last hotplugged out cpu in policy->cpus to minimum
      cpufreq: Allow stop CPU callback to be used by all cpufreq drivers
      PM / devfreq: exynos: Enable building exynos PPMU as module
      PM / devfreq: Export helper functions for drivers
      ...

commit 76ba59f8366f2d9282cb5bda9de75b4b68cbe55f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Aug 26 11:03:16 2014 +0100

    genirq: Add irq_domain-aware core IRQ handler
    
    Calling irq_find_mapping from outside a irq_{enter,exit} section is
    unsafe and produces ugly messages if CONFIG_PROVE_RCU is enabled:
    If coming from the idle state, the rcu_read_lock call in irq_find_mapping
    will generate an unpleasant warning:
    
    <quote>
    ===============================
    [ INFO: suspicious RCU usage. ]
    3.16.0-rc1+ #135 Not tainted
    -------------------------------
    include/linux/rcupdate.h:871 rcu_read_lock() used illegally while idle!
    
    other info that might help us debug this:
    
    RCU used illegally from idle CPU!
    rcu_scheduler_active = 1, debug_locks = 0
    RCU used illegally from extended quiescent state!
    1 lock held by swapper/0/0:
     #0:  (rcu_read_lock){......}, at: [<ffffffc00010206c>]
    irq_find_mapping+0x4c/0x198
    </quote>
    
    As this issue is fairly widespread and involves at least three
    different architectures, a possible solution is to add a new
    handle_domain_irq entry point into the generic IRQ code that
    the interrupt controller code can call.
    
    This new function takes an irq_domain, and calls into irq_find_domain
    inside the irq_{enter,exit} block. An additional "lookup" parameter is
    used to allow non-domain architecture code to be replaced by this as well.
    
    Interrupt controllers can then be updated to use the new mechanism.
    
    This code is sitting behind a new CONFIG_HANDLE_DOMAIN_IRQ, as not all
    architectures implement set_irq_regs (yes, mn10300, I'm looking at you...).
    
    Reported-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1409047421-27649-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 472c021a2d4f..ff24667cd86c 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -12,6 +12,8 @@ struct irq_affinity_notify;
 struct proc_dir_entry;
 struct module;
 struct irq_desc;
+struct irq_domain;
+struct pt_regs;
 
 /**
  * struct irq_desc - interrupt descriptor
@@ -118,6 +120,23 @@ static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *de
 
 int generic_handle_irq(unsigned int irq);
 
+#ifdef CONFIG_HANDLE_DOMAIN_IRQ
+/*
+ * Convert a HW interrupt number to a logical one using a IRQ domain,
+ * and handle the result interrupt number. Return -EINVAL if
+ * conversion failed. Providing a NULL domain indicates that the
+ * conversion has already been done.
+ */
+int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,
+			bool lookup, struct pt_regs *regs);
+
+static inline int handle_domain_irq(struct irq_domain *domain,
+				    unsigned int hwirq, struct pt_regs *regs)
+{
+	return __handle_domain_irq(domain, hwirq, true, regs);
+}
+#endif
+
 /* Test to see if a driver has successfully requested an irq */
 static inline int irq_has_action(unsigned int irq)
 {

commit cab303be91dc47942bc25de33dc1140123540800
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 28 11:44:31 2014 +0200

    genirq: Add sanity checks for PM options on shared interrupt lines
    
    Account the IRQF_NO_SUSPEND and IRQF_RESUME_EARLY actions on shared
    interrupt lines and yell loudly if there is a mismatch.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 472c021a2d4f..cb1a31e448ae 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -36,6 +36,11 @@ struct irq_desc;
  * @threads_oneshot:	bitfield to handle shared oneshot threads
  * @threads_active:	number of irqaction threads currently running
  * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
+ * @nr_actions:		number of installed actions on this descriptor
+ * @no_suspend_depth:	number of irqactions on a irq descriptor with
+ *			IRQF_NO_SUSPEND set
+ * @force_resume_depth:	number of irqactions on a irq descriptor with
+ *			IRQF_FORCE_RESUME set
  * @dir:		/proc/irq/ procfs entry
  * @name:		flow handler name for /proc/interrupts output
  */
@@ -68,6 +73,11 @@ struct irq_desc {
 	unsigned long		threads_oneshot;
 	atomic_t		threads_active;
 	wait_queue_head_t       wait_for_threads;
+#ifdef CONFIG_PM_SLEEP
+	unsigned int		nr_actions;
+	unsigned int		no_suspend_depth;
+	unsigned int		force_resume_depth;
+#endif
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif

commit 1e77d0a1ed7417d2a5a52a7b8d32aea1833faa6c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 7 14:53:45 2013 +0100

    genirq: Sanitize spurious interrupt detection of threaded irqs
    
    Till reported that the spurious interrupt detection of threaded
    interrupts is broken in two ways:
    
    - note_interrupt() is called for each action thread of a shared
      interrupt line. That's wrong as we are only interested whether none
      of the device drivers felt responsible for the interrupt, but by
      calling multiple times for a single interrupt line we account
      IRQ_NONE even if one of the drivers felt responsible.
    
    - note_interrupt() when called from the thread handler is not
      serialized. That leaves the members of irq_desc which are used for
      the spurious detection unprotected.
    
    To solve this we need to defer the spurious detection of a threaded
    interrupt to the next hardware interrupt context where we have
    implicit serialization.
    
    If note_interrupt is called with action_ret == IRQ_WAKE_THREAD, we
    check whether the previous interrupt requested a deferred check. If
    not, we request a deferred check for the next hardware interrupt and
    return.
    
    If set, we check whether one of the interrupt threads signaled
    success. Depending on this information we feed the result into the
    spurious detector.
    
    If one primary handler of a shared interrupt returns IRQ_HANDLED we
    disable the deferred check of irq threads on the same line, as we have
    found at least one device driver who cared.
    
    Reported-by: Till Straumann <strauman@slac.stanford.edu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Austin Schuh <austin@peloton-tech.com>
    Cc: Oliver Hartkopp <socketcan@hartkopp.net>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: Pavel Pisa <pisa@cmp.felk.cvut.cz>
    Cc: Marc Kleine-Budde <mkl@pengutronix.de>
    Cc: linux-can@vger.kernel.org
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1303071450130.22263@ionos

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 26e2661d3935..472c021a2d4f 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -27,6 +27,8 @@ struct irq_desc;
  * @irq_count:		stats field to detect stalled irqs
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
+ * @threads_handled:	stats field for deferred spurious detection of threaded handlers
+ * @threads_handled_last: comparator field for deferred spurious detection of theraded handlers
  * @lock:		locking for SMP
  * @affinity_hint:	hint to user space for preferred irq affinity
  * @affinity_notify:	context for notification of affinity changes
@@ -52,6 +54,8 @@ struct irq_desc {
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	unsigned int		irqs_unhandled;
+	atomic_t		threads_handled;
+	int			threads_handled_last;
 	raw_spinlock_t		lock;
 	struct cpumask		*percpu_enabled;
 #ifdef CONFIG_SMP

commit 7f4a8e7b1943c1fc7e4b08509e308197babdcd5b
Author: Vinayak Kale <vkale@apm.com>
Date:   Wed Dec 4 10:09:50 2013 +0000

    genirq: Add an accessor for IRQ_PER_CPU flag
    
    This patch adds an accessor function for IRQ_PER_CPU flag.
    The accessor function is useful to determine whether an IRQ is percpu or not.
    
    This patch is based on an older patch posted by Chris Smith here [1].
    There is a minor change w.r.t. Chris's original patch: The accessor function
    is renamed as 'irq_is_percpu' instead of 'irq_is_per_cpu'.
    
    [1]: http://lkml.indiana.edu/hypermail/linux/kernel/1207.3/02955.html
    
    Signed-off-by: Chris Smith <chris.smith@st.com>
    Signed-off-by: Vinayak Kale <vkale@apm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 56fb646909dc..26e2661d3935 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -152,6 +152,14 @@ static inline int irq_balancing_disabled(unsigned int irq)
 	return desc->status_use_accessors & IRQ_NO_BALANCING_MASK;
 }
 
+static inline int irq_is_percpu(unsigned int irq)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	return desc->status_use_accessors & IRQ_PER_CPU;
+}
+
 static inline void
 irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)
 {

commit 0244ad004a54e39308d495fee0a2e637f8b5c317
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 30 09:39:53 2013 +0200

    Remove GENERIC_HARDIRQ config option
    
    After the last architecture switched to generic hard irqs the config
    options HAVE_GENERIC_HARDIRQS & GENERIC_HARDIRQS and the related code
    for !CONFIG_GENERIC_HARDIRQS can be removed.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 623325e2ff97..56fb646909dc 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -76,8 +76,6 @@ struct irq_desc {
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-
 static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
 {
 	return &desc->irq_data;
@@ -173,6 +171,5 @@ __irq_set_preflow_handler(unsigned int irq, irq_preflow_handler_t handler)
 	desc->preflow_handler = handler;
 }
 #endif
-#endif
 
 #endif

commit 293a7a0a165c4f8327bbcf396cee9ec672727c98
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 16 15:07:49 2012 -0700

    genirq: Provide means to retrigger parent
    
    Attempts to retrigger nested threaded IRQs currently fail because they
    have no primary handler. In order to support retrigger of nested
    IRQs, the parent IRQ needs to be retriggered.
    
    To fix, when an IRQ needs to be resent, if the interrupt has a parent
    IRQ and runs in the context of the parent IRQ, then resend the parent.
    
    Also, handle_nested_irq() needs to clear the replay flag like the
    other handlers, otherwise check_irq_resend() will set it and it will
    never be cleared.  Without clearing, it results in the first resend
    working fine, but check_irq_resend() returning early on subsequent
    resends because the replay flag is still set.
    
    Problem discovered on ARM/OMAP platforms where a nested IRQ that's
    also a wakeup IRQ happens late in suspend and needed to be retriggered
    during the resume process.
    
    [khilman@ti.com: changelog edits, clear IRQS_REPLAY in handle_nested_irq()]
    
    Reported-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1350425269-11489-1-git-send-email-khilman@deeprootsystems.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 0ba014c55056..623325e2ff97 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -11,6 +11,8 @@
 struct irq_affinity_notify;
 struct proc_dir_entry;
 struct module;
+struct irq_desc;
+
 /**
  * struct irq_desc - interrupt descriptor
  * @irq_data:		per irq and chip data passed down to chip functions
@@ -65,6 +67,7 @@ struct irq_desc {
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif
+	int			parent_irq;
 	struct module		*owner;
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;

commit 99dbb1632f1165c2726056ebfce6edde0e5a0208
Merge: aae6f989c6e9 9c33c512b2d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 09:06:36 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull the trivial tree from Jiri Kosina:
     "Tiny usual fixes all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (34 commits)
      doc: fix old config name of kprobetrace
      fs/fs-writeback.c: cleanup riteback_sb_inodes kerneldoc
      btrfs: fix the commment for the action flags in delayed-ref.h
      btrfs: fix trivial typo for the comment of BTRFS_FREE_INO_OBJECTID
      vfs: fix kerneldoc for generic_fh_to_parent()
      treewide: fix comment/printk/variable typos
      ipr: fix small coding style issues
      doc: fix broken utf8 encoding
      nfs: comment fix
      platform/x86: fix asus_laptop.wled_type module parameter
      mfd: printk/comment fixes
      doc: getdelays.c: remember to close() socket on error in create_nl_socket()
      doc: aliasing-test: close fd on write error
      mmc: fix comment typos
      dma: fix comments
      spi: fix comment/printk typos in spi
      Coccinelle: fix typo in memdup_user.cocci
      tmiofb: missing NULL pointer checks
      tools: perf: Fix typo in tools/perf
      tools/testing: fix comment / output typos
      ...

commit ef706fb55670dfe959b69dde24c2768e4083ef66
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Aug 14 19:32:31 2012 -0400

    irqdesc: delete now orphaned references to timer_rand_state
    
    In commit c5857ccf293 ("random: remove rand_initialize_irq()")
    the timer_rand_state was removed from struct irq_desc.  Hence
    we can also remove the forward declaration of it and the kernel
    doc information now too.
    
    Cc: Jiri Kosina <trivial@kernel.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index f1e2527006bd..3c32b12b3f0a 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -10,12 +10,10 @@
 
 struct irq_affinity_notify;
 struct proc_dir_entry;
-struct timer_rand_state;
 struct module;
 /**
  * struct irq_desc - interrupt descriptor
  * @irq_data:		per irq and chip data passed down to chip functions
- * @timer_rand_state:	pointer to timer rand state struct
  * @kstat_irqs:		irq stats per cpu
  * @handle_irq:		highlevel irq-events handler
  * @preflow_handler:	handler called before the flow handler (currently used by sparc)

commit c5857ccf293968348e5eb4ebedc68074de3dcda6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Jul 14 20:27:52 2012 -0400

    random: remove rand_initialize_irq()
    
    With the new interrupt sampling system, we are no longer using the
    timer_rand_state structure in the irq descriptor, so we can stop
    initializing it now.
    
    [ Merged in fixes from Sedat to find some last missing references to
      rand_initialize_irq() ]
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index f1e2527006bd..9a323d12de1c 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -39,7 +39,6 @@ struct module;
  */
 struct irq_desc {
 	struct irq_data		irq_data;
-	struct timer_rand_state *timer_rand_state;
 	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;
 #ifdef CONFIG_IRQ_PREFLOW_FASTEOI

commit ec53cf23c0ddb0c29950b9a4ac46964c4c6c6c2f
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Sep 19 20:33:19 2011 -0400

    irq: don't put module.h into irq.h for tracking irqgen modules.
    
    Recent commit "irq: Track the  owner of irq descriptor" in
    commit ID b6873807a7143b7 placed module.h into linux/irq.h
    but we are trying to limit module.h inclusion to just C files
    that really need it, due to its size and number of children
    includes.  This targets just reversing that include.
    
    Add in the basic "struct module" since that is all we really need
    to ensure things compile.  In theory, b687380 should have added the
    module.h include to the irqdesc.h header as well, but the implicit
    module.h everywhere presence masked this from showing up.  So give
    it the "struct module" as well.
    
    As for the C files, irqdesc.c is only using THIS_MODULE, so it
    does not need module.h - give it export.h instead.  The C file
    irq/manage.c is now (as of b687380) using try_module_get and
    module_put and so it needs module.h (which it already has).
    
    Also convert the irq_alloc_descs variants to macros, since all
    they really do is is call the __irq_alloc_descs primitive.
    This avoids including export.h and no debug info is lost.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 6b69c2c9dff1..f1e2527006bd 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -11,6 +11,7 @@
 struct irq_affinity_notify;
 struct proc_dir_entry;
 struct timer_rand_state;
+struct module;
 /**
  * struct irq_desc - interrupt descriptor
  * @irq_data:		per irq and chip data passed down to chip functions

commit 31d9d9b6d83030f748d013e61502fa5477e2ac0e
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 23 17:03:06 2011 +0100

    genirq: Add support for per-cpu dev_id interrupts
    
    The ARM GIC interrupt controller offers per CPU interrupts (PPIs),
    which are usually used to connect local timers to each core. Each CPU
    has its own private interface to the GIC, and only sees the PPIs that
    are directly connect to it.
    
    While these timers are separate devices and have a separate interrupt
    line to a core, they all use the same IRQ number.
    
    For these devices, request_irq() is not the right API as it assumes
    that an IRQ number is visible by a number of CPUs (through the
    affinity setting), but makes it very awkward to express that an IRQ
    number can be handled by all CPUs, and yet be a different interrupt
    line on each CPU, requiring a different dev_id cookie to be passed
    back to the handler.
    
    The *_percpu_irq() functions is designed to overcome these
    limitations, by providing a per-cpu dev_id vector:
    
    int request_percpu_irq(unsigned int irq, irq_handler_t handler,
                       const char *devname, void __percpu *percpu_dev_id);
    void free_percpu_irq(unsigned int, void __percpu *);
    int setup_percpu_irq(unsigned int irq, struct irqaction *new);
    void remove_percpu_irq(unsigned int irq, struct irqaction *act);
    void enable_percpu_irq(unsigned int irq);
    void disable_percpu_irq(unsigned int irq);
    
    The API has a number of limitations:
    - no interrupt sharing
    - no threading
    - common handler across all the CPUs
    
    Once the interrupt is requested using setup_percpu_irq() or
    request_percpu_irq(), it must be enabled by each core that wishes its
    local interrupt to be delivered.
    
    Based on an initial patch by Thomas Gleixner.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: http://lkml.kernel.org/r/1316793788-14500-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 150134ac709a..6b69c2c9dff1 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -53,6 +53,7 @@ struct irq_desc {
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	unsigned int		irqs_unhandled;
 	raw_spinlock_t		lock;
+	struct cpumask		*percpu_enabled;
 #ifdef CONFIG_SMP
 	const struct cpumask	*affinity_hint;
 	struct irq_affinity_notify *affinity_notify;

commit b6873807a7143b7d6d8b06809295e559d07d7deb
Author: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date:   Mon Jul 11 12:17:31 2011 +0200

    irq: Track the owner of irq descriptor
    
    Interrupt descriptors can be allocated from modules. The interrupts
    are used by other modules, but we have no refcount on the module which
    provides the interrupts and there is no way to establish one on the
    device level as the interrupt using module is agnostic to the fact
    that the interrupt is provided by a module rather than by some builtin
    interrupt controller.
    
    To prevent removal of the interrupt providing module, we can track the
    owner of the interrupt descriptor, which also provides the relevant
    irq chip functions in the irq descriptor.
    
    request/setup_irq() can now acquire a refcount on the owner module to
    prevent unloading. free_irq() drops the refcount.
    
    Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Link: http://lkml.kernel.org/r/20110711101731.GA13804@Chamillionaire.breakpoint.cc
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 2d921b35212c..150134ac709a 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -66,6 +66,7 @@ struct irq_desc {
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*dir;
 #endif
+	struct module		*owner;
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 

commit fe12bc2c996d3e492b2920e32ac79f7bbae3e15d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 12:48:00 2011 +0200

    genirq: Uninline and sanity check generic_handle_irq()
    
    generic_handle_irq() is missing a NULL pointer check for the result of
    irq_to_desc. This was a not a big problem, but we want to expose it to
    drivers, so we better have sanity checks in place. Add a return value
    as well, which indicates that the irq number was valid and the handler
    was invoked.
    
    Based on the pure code move from Jonathan Cameron.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index c70b1aa4b93a..2d921b35212c 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -111,10 +111,7 @@ static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *de
 	desc->handle_irq(irq, desc);
 }
 
-static inline void generic_handle_irq(unsigned int irq)
-{
-	generic_handle_irq_desc(irq, irq_to_desc(irq));
-}
+int generic_handle_irq(unsigned int irq);
 
 /* Test to see if a driver has successfully requested an irq */
 static inline int irq_has_action(unsigned int irq)

commit 770767787c23040dc152e7ae230597ff55b39470
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 10 11:01:52 2011 +0200

    genirq: irq_desc: Document preflow_handler and affinity_hint
    
    [ tglx: Filled in the FIXME place holders ]
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Link: http://lkml.kernel.org/r/%3C1302426113-13808-2-git-send-email-geert%40linux-m68k.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 8e1dc8ea5471..c70b1aa4b93a 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -16,7 +16,8 @@ struct timer_rand_state;
  * @irq_data:		per irq and chip data passed down to chip functions
  * @timer_rand_state:	pointer to timer rand state struct
  * @kstat_irqs:		irq stats per cpu
- * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
+ * @handle_irq:		highlevel irq-events handler
+ * @preflow_handler:	handler called before the flow handler (currently used by sparc)
  * @action:		the irq action chain
  * @status:		status information
  * @core_internal_state__do_not_mess_with_it: core internal status information
@@ -26,6 +27,7 @@ struct timer_rand_state;
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
+ * @affinity_hint:	hint to user space for preferred irq affinity
  * @affinity_notify:	context for notification of affinity changes
  * @pending_mask:	pending rebalanced interrupts
  * @threads_oneshot:	bitfield to handle shared oneshot threads

commit 0911f124bf55357803d53197cc1ae5479f5e37e2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 10 11:01:51 2011 +0200

    genirq: Forgotten updates/deletions after removal of compat code
    
    commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1 ("genirq: Remove compat code")
    removed the compat code, but forgot to update some references in comments and
    delete some of its documentation.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Link: http://lkml.kernel.org/r/%3C1302426113-13808-1-git-send-email-geert%40linux-m68k.org%3E
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index a082905b5ebe..8e1dc8ea5471 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -21,7 +21,7 @@ struct timer_rand_state;
  * @status:		status information
  * @core_internal_state__do_not_mess_with_it: core internal status information
  * @depth:		disable-depth, for nested irq_disable() calls
- * @wake_depth:		enable depth, for multiple set_irq_wake() callers
+ * @wake_depth:		enable depth, for multiple irq_set_irq_wake() callers
  * @irq_count:		stats field to detect stalled irqs
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts

commit 0c6f8a8b917ad361319c8ace3e9f28e69bfdb4c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 13:32:20 2011 +0200

    genirq: Remove compat code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 15e6c3905f41..a082905b5ebe 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -35,32 +35,7 @@ struct timer_rand_state;
  * @name:		flow handler name for /proc/interrupts output
  */
 struct irq_desc {
-
-#ifdef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
 	struct irq_data		irq_data;
-#else
-	/*
-	 * This union will go away, once we fixed the direct access to
-	 * irq_desc all over the place. The direct fields are a 1:1
-	 * overlay of irq_data.
-	 */
-	union {
-		struct irq_data		irq_data;
-		struct {
-			unsigned int		irq;
-			unsigned int		node;
-			unsigned int		pad_do_not_even_think_about_it;
-			struct irq_chip		*chip;
-			void			*handler_data;
-			void			*chip_data;
-			struct msi_desc		*msi_desc;
-#ifdef CONFIG_SMP
-			cpumask_var_t		affinity;
-#endif
-		};
-	};
-#endif
-
 	struct timer_rand_state *timer_rand_state;
 	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;
@@ -68,11 +43,7 @@ struct irq_desc {
 	irq_preflow_handler_t	preflow_handler;
 #endif
 	struct irqaction	*action;	/* IRQ action list */
-#ifdef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
 	unsigned int		status_use_accessors;
-#else
-	unsigned int		status;		/* IRQ status */
-#endif
 	unsigned int		core_internal_state__do_not_mess_with_it;
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		wake_depth;	/* nested wake enables */
@@ -127,27 +98,6 @@ static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
 	return desc->irq_data.msi_desc;
 }
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-static inline struct irq_chip *get_irq_desc_chip(struct irq_desc *desc)
-{
-	return irq_desc_get_chip(desc);
-}
-static inline void *get_irq_desc_data(struct irq_desc *desc)
-{
-	return irq_desc_get_handler_data(desc);
-}
-
-static inline void *get_irq_desc_chip_data(struct irq_desc *desc)
-{
-	return irq_desc_get_chip_data(desc);
-}
-
-static inline struct msi_desc *get_irq_desc_msi(struct irq_desc *desc)
-{
-	return irq_desc_get_msi_desc(desc);
-}
-#endif
-
 /*
  * Architectures call this to let the generic IRQ layer
  * handle an interrupt. If the descriptor is attached to an
@@ -194,21 +144,13 @@ __irq_set_chip_handler_name_locked(unsigned int irq, struct irq_chip *chip,
 	desc->name = name;
 }
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-static inline void __set_irq_handler_unlocked(int irq,
-					      irq_flow_handler_t handler)
-{
-	__irq_set_handler_locked(irq, handler);
-}
-
 static inline int irq_balancing_disabled(unsigned int irq)
 {
 	struct irq_desc *desc;
 
 	desc = irq_to_desc(irq);
-	return desc->status & IRQ_NO_BALANCING_MASK;
+	return desc->status_use_accessors & IRQ_NO_BALANCING_MASK;
 }
-#endif
 
 static inline void
 irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)

commit a2e8461a2ce5e8140b7374eb68af0d09e36e07ff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 23 13:10:31 2011 +0100

    genirq: Provide locked setter for chip, handler, name
    
    Some irq_set_type() callbacks need to change the chip and the handler
    when the trigger mode changes. We have already a (misnomed) setter
    function for the handler which can be called from irq_set_type().
    
    Provide one which allows to set chip and name as well. Put the
    misnomed function under the COMPAT switch and provide a replacement.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 1595f9176b43..15e6c3905f41 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -171,25 +171,44 @@ static inline int irq_has_action(unsigned int irq)
 	return desc->action != NULL;
 }
 
-#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
-static inline int irq_balancing_disabled(unsigned int irq)
+/* caller has locked the irq_desc and both params are valid */
+static inline void __irq_set_handler_locked(unsigned int irq,
+					    irq_flow_handler_t handler)
 {
 	struct irq_desc *desc;
 
 	desc = irq_to_desc(irq);
-	return desc->status & IRQ_NO_BALANCING_MASK;
+	desc->handle_irq = handler;
 }
-#endif
 
 /* caller has locked the irq_desc and both params are valid */
+static inline void
+__irq_set_chip_handler_name_locked(unsigned int irq, struct irq_chip *chip,
+				   irq_flow_handler_t handler, const char *name)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	irq_desc_get_irq_data(desc)->chip = chip;
+	desc->handle_irq = handler;
+	desc->name = name;
+}
+
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
 static inline void __set_irq_handler_unlocked(int irq,
 					      irq_flow_handler_t handler)
+{
+	__irq_set_handler_locked(irq, handler);
+}
+
+static inline int irq_balancing_disabled(unsigned int irq)
 {
 	struct irq_desc *desc;
 
 	desc = irq_to_desc(irq);
-	desc->handle_irq = handler;
+	return desc->status & IRQ_NO_BALANCING_MASK;
 }
+#endif
 
 static inline void
 irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)

commit d3e17deb1790ee2123e9d11420be6411d1768b47
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Mar 22 17:08:15 2011 +0100

    genirq: Provide a lockdep helper
    
    Some irq chips need to call genirq functions for nested chips from
    their callbacks. That upsets lockdep. So they need to set a different
    lock class for those nested chips. Provide a helper function to avoid
    open access to irq_desc.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 0b30662bc36c..1595f9176b43 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -191,6 +191,15 @@ static inline void __set_irq_handler_unlocked(int irq,
 	desc->handle_irq = handler;
 }
 
+static inline void
+irq_set_lockdep_class(unsigned int irq, struct lock_class_key *class)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	if (desc)
+		lockdep_set_class(&desc->lock, class);
+}
+
 #ifdef CONFIG_IRQ_PREFLOW_FASTEOI
 static inline void
 __irq_set_preflow_handler(unsigned int irq, irq_preflow_handler_t handler)

commit 3b9038912828384e38d82409c281124631c8533b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 23 00:24:11 2011 +0100

    genirq; Remove the last leftovers of the old sparse irq code
    
    All users converted. Get rid of it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 00218371518b..0b30662bc36c 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -100,13 +100,6 @@ struct irq_desc {
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 
-/* Will be removed once the last users in power and sh are gone */
-extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
-static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
-{
-	return desc;
-}
-
 #ifdef CONFIG_GENERIC_HARDIRQS
 
 static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)

commit d9936bb3952a08d701f7b03f8f62d158f94d8085
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 11 14:15:35 2011 +0100

    genirq: Add desc->irq_data accessor
    
    We have accessors for all fields in irq_data based on irq_desc, but
    not for irq_data itself.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 9eb9cd313052..00218371518b 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -109,6 +109,11 @@ static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
+static inline struct irq_data *irq_desc_get_irq_data(struct irq_desc *desc)
+{
+	return &desc->irq_data;
+}
+
 static inline struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)
 {
 	return desc->irq_data.chip;

commit b5faba21a6805c33b40e258d36f57997ee1de131
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 23 23:52:13 2011 +0000

    genirq: Prepare the handling of shared oneshot interrupts
    
    For level type interrupts we need to track how many threads are on
    flight to avoid useless interrupt storms when not all thread handlers
    have finished yet. Keep track of the woken threads and only unmask
    when there are no more threads in flight.
    
    Yes, I'm lazy and using a bitfield. But not only because I'm lazy, the
    main reason is that it's way simpler than using a refcount. A refcount
    based solution would need to keep track of various things like
    crashing the irq thread, spurious interrupts coming in,
    disables/enables, free_irq() and some more. The bitfield keeps the
    tracking simple and makes things just work. It's also nicely confined
    to the thread code pathes and does not require additional checks all
    over the place.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    LKML-Reference: <20110223234956.388095876@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 2f87d6441302..9eb9cd313052 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -28,6 +28,7 @@ struct timer_rand_state;
  * @lock:		locking for SMP
  * @affinity_notify:	context for notification of affinity changes
  * @pending_mask:	pending rebalanced interrupts
+ * @threads_oneshot:	bitfield to handle shared oneshot threads
  * @threads_active:	number of irqaction threads currently running
  * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
  * @dir:		/proc/irq/ procfs entry
@@ -86,6 +87,7 @@ struct irq_desc {
 	cpumask_var_t		pending_mask;
 #endif
 #endif
+	unsigned long		threads_oneshot;
 	atomic_t		threads_active;
 	wait_queue_head_t       wait_for_threads;
 #ifdef CONFIG_PROC_FS

commit 781295762defc709a609efc01d8bb065276cd9a2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 15:14:20 2011 +0100

    genirq: Add preflow handler support
    
    sparc64 needs to call a preflow handler on certain interrupts befor
    calling the action chain. Integrate it into handle_fasteoi_irq. Must
    be enabled via CONFIG_IRQ_FASTEOI_PREFLOW. No impact when disabled.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 36c95f08023d..2f87d6441302 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -63,6 +63,9 @@ struct irq_desc {
 	struct timer_rand_state *timer_rand_state;
 	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;
+#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
+	irq_preflow_handler_t	preflow_handler;
+#endif
 	struct irqaction	*action;	/* IRQ action list */
 #ifdef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
 	unsigned int		status_use_accessors;
@@ -187,6 +190,17 @@ static inline void __set_irq_handler_unlocked(int irq,
 	desc = irq_to_desc(irq);
 	desc->handle_irq = handler;
 }
+
+#ifdef CONFIG_IRQ_PREFLOW_FASTEOI
+static inline void
+__irq_set_preflow_handler(unsigned int irq, irq_preflow_handler_t handler)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	desc->preflow_handler = handler;
+}
+#endif
 #endif
 
 #endif

commit a6967caf00ebbb2d4acdebcb72a25f2e9ba43fd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 22:01:25 2011 +0100

    genirq: Remove desc->status when GENERIC_HARDIRQS_NO_COMPAT=y
    
    If everything uses the right accessors, then enabling
    GENERIC_HARDIRQS_NO_COMPAT should just work. If not it will tell you.
    
    Don't be lazy and use the trick which I use in the core code!
    
    git grep status_use_accessors
    
    will unearth it in a split second. Offenders are tracked down and not
    slapped with stinking trouts. This time we use frozen shark for a
    better educational value.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 581d9665fd38..36c95f08023d 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -64,7 +64,11 @@ struct irq_desc {
 	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;
 	struct irqaction	*action;	/* IRQ action list */
+#ifdef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+	unsigned int		status_use_accessors;
+#else
 	unsigned int		status;		/* IRQ status */
+#endif
 	unsigned int		core_internal_state__do_not_mess_with_it;
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		wake_depth;	/* nested wake enables */
@@ -164,6 +168,7 @@ static inline int irq_has_action(unsigned int irq)
 	return desc->action != NULL;
 }
 
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
 static inline int irq_balancing_disabled(unsigned int irq)
 {
 	struct irq_desc *desc;
@@ -171,6 +176,7 @@ static inline int irq_balancing_disabled(unsigned int irq)
 	desc = irq_to_desc(irq);
 	return desc->status & IRQ_NO_BALANCING_MASK;
 }
+#endif
 
 /* caller has locked the irq_desc and both params are valid */
 static inline void __set_irq_handler_unlocked(int irq,

commit 91c499178139d6597e68db19638e4135510a34b8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 3 20:48:29 2011 +0100

    genirq: Add state field to irq_data
    
    Some chip implementations need to access certain status flags. With
    sparse irqs that requires a lookup of the irq descriptor. Add a state
    field which contains such flags.
    
    Name it in a way which will make coders happy to access it with the
    proper accessor functions. And it's easy to grep for.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 782bf9851a9f..581d9665fd38 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -48,6 +48,7 @@ struct irq_desc {
 		struct {
 			unsigned int		irq;
 			unsigned int		node;
+			unsigned int		pad_do_not_even_think_about_it;
 			struct irq_chip		*chip;
 			void			*handler_data;
 			void			*chip_data;

commit dbec07bac614a61e3392c1e7c08cc6a49ad43f7a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Feb 7 20:19:55 2011 +0100

    genirq: Add internal state field to irq_desc
    
    That field will contain internal state information which is not going
    to be exposed to anything outside the core code - except via accessor
    functions. I'm tired of everyone fiddling in irq_desc.status.
    
    core_internal_state__do_not_mess_with_it is clear enough, annoying to
    type and easy to grep for. Offenders will be tracked down and slapped
    with stinking trouts.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 64794dec93b6..782bf9851a9f 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -19,6 +19,7 @@ struct timer_rand_state;
  * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
  * @action:		the irq action chain
  * @status:		status information
+ * @core_internal_state__do_not_mess_with_it: core internal status information
  * @depth:		disable-depth, for nested irq_disable() calls
  * @wake_depth:		enable depth, for multiple set_irq_wake() callers
  * @irq_count:		stats field to detect stalled irqs
@@ -63,7 +64,7 @@ struct irq_desc {
 	irq_flow_handler_t	handle_irq;
 	struct irqaction	*action;	/* IRQ action list */
 	unsigned int		status;		/* IRQ status */
-
+	unsigned int		core_internal_state__do_not_mess_with_it;
 	unsigned int		depth;		/* nested irq disables */
 	unsigned int		wake_depth;	/* nested wake enables */
 	unsigned int		irq_count;	/* For detecting broken IRQs */

commit a0cd9ca2b907d7ee26575e7b63ac92dad768a75e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Feb 10 11:36:33 2011 +0100

    genirq: Namespace cleanup
    
    The irq namespace has become quite convoluted. My bad.  Clean it up
    and deprecate the old functions. All new functions follow the scheme:
    
    irq number based:
        irq_set/get/xxx/_xxx(unsigned int irq, ...)
    
    irq_data based:
             irq_data_set/get/xxx/_xxx(struct irq_data *d, ....)
    
    irq_desc based:
             irq_desc_get_xxx(struct irq_desc *desc)
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index bfef56dadddb..64794dec93b6 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -98,10 +98,46 @@ static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 
-#define get_irq_desc_chip(desc)		((desc)->irq_data.chip)
-#define get_irq_desc_chip_data(desc)	((desc)->irq_data.chip_data)
-#define get_irq_desc_data(desc)		((desc)->irq_data.handler_data)
-#define get_irq_desc_msi(desc)		((desc)->irq_data.msi_desc)
+static inline struct irq_chip *irq_desc_get_chip(struct irq_desc *desc)
+{
+	return desc->irq_data.chip;
+}
+
+static inline void *irq_desc_get_chip_data(struct irq_desc *desc)
+{
+	return desc->irq_data.chip_data;
+}
+
+static inline void *irq_desc_get_handler_data(struct irq_desc *desc)
+{
+	return desc->irq_data.handler_data;
+}
+
+static inline struct msi_desc *irq_desc_get_msi_desc(struct irq_desc *desc)
+{
+	return desc->irq_data.msi_desc;
+}
+
+#ifndef CONFIG_GENERIC_HARDIRQS_NO_COMPAT
+static inline struct irq_chip *get_irq_desc_chip(struct irq_desc *desc)
+{
+	return irq_desc_get_chip(desc);
+}
+static inline void *get_irq_desc_data(struct irq_desc *desc)
+{
+	return irq_desc_get_handler_data(desc);
+}
+
+static inline void *get_irq_desc_chip_data(struct irq_desc *desc)
+{
+	return irq_desc_get_chip_data(desc);
+}
+
+static inline struct msi_desc *get_irq_desc_msi(struct irq_desc *desc)
+{
+	return irq_desc_get_msi_desc(desc);
+}
+#endif
 
 /*
  * Architectures call this to let the generic IRQ layer

commit cd7eab44e9946c28d595abe3e9a43e945bc49141
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Wed Jan 19 21:01:44 2011 +0000

    genirq: Add IRQ affinity notifiers
    
    When initiating I/O on a multiqueue and multi-IRQ device, we may want
    to select a queue for which the response will be handled on the same
    or a nearby CPU.  This requires a reverse-map of IRQ affinity.  Add a
    notification mechanism to support this.
    
    This is based closely on work by Thomas Gleixner <tglx@linutronix.de>.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Cc: linux-net-drivers@solarflare.com
    Cc: Tom Herbert <therbert@google.com>
    Cc: David Miller <davem@davemloft.net>
    LKML-Reference: <1295470904.11126.84.camel@bwh-desktop>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index c1a95b7b58de..bfef56dadddb 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -8,6 +8,7 @@
  * For now it's included from <linux/irq.h>
  */
 
+struct irq_affinity_notify;
 struct proc_dir_entry;
 struct timer_rand_state;
 /**
@@ -24,6 +25,7 @@ struct timer_rand_state;
  * @last_unhandled:	aging timer for unhandled count
  * @irqs_unhandled:	stats field for spurious unhandled interrupts
  * @lock:		locking for SMP
+ * @affinity_notify:	context for notification of affinity changes
  * @pending_mask:	pending rebalanced interrupts
  * @threads_active:	number of irqaction threads currently running
  * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
@@ -70,6 +72,7 @@ struct irq_desc {
 	raw_spinlock_t		lock;
 #ifdef CONFIG_SMP
 	const struct cpumask	*affinity_hint;
+	struct irq_affinity_notify *affinity_notify;
 #ifdef CONFIG_GENERIC_PENDING_IRQ
 	cpumask_var_t		pending_mask;
 #endif

commit 1c77ff22f539ceaa64ea43d6a26d867e84602cb7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jan 19 19:41:35 2011 +0100

    genirq: Remove __do_IRQ
    
    All architectures are finally converted. Remove the cruft.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Chen Liqin <liqin.chen@sunplusct.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Jeff Dike <jdike@addtoit.com>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 6a64c6fa81af..c1a95b7b58de 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -100,13 +100,6 @@ static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
 #define get_irq_desc_data(desc)		((desc)->irq_data.handler_data)
 #define get_irq_desc_msi(desc)		((desc)->irq_data.msi_desc)
 
-/*
- * Monolithic do_IRQ implementation.
- */
-#ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
-extern unsigned int __do_IRQ(unsigned int irq);
-#endif
-
 /*
  * Architectures call this to let the generic IRQ layer
  * handle an interrupt. If the descriptor is attached to an
@@ -115,14 +108,7 @@ extern unsigned int __do_IRQ(unsigned int irq);
  */
 static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
 {
-#ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
-#else
-	if (likely(desc->handle_irq))
-		desc->handle_irq(irq, desc);
-	else
-		__do_IRQ(irq);
-#endif
 }
 
 static inline void generic_handle_irq(unsigned int irq)

commit 6c9ae009b298753a3baf71298d676a68b5a10c8f
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jan 13 15:45:38 2011 -0800

    irq: use per_cpu kstat_irqs
    
    Use modern per_cpu API to increment {soft|hard}irq counters, and use
    per_cpu allocation for (struct irq_desc)->kstats_irq instead of an array.
    
    This gives better SMP/NUMA locality and saves few instructions per irq.
    
    With small nr_cpuids values (8 for example), kstats_irq was a small array
    (less than L1_CACHE_BYTES), potentially source of false sharing.
    
    In the !CONFIG_SPARSE_IRQ case, remove the huge, NUMA/cache unfriendly
    kstat_irqs_all[NR_IRQS][NR_CPUS] array.
    
    Note: we still populate kstats_irq for all possible irqs in
    early_irq_init().  We probably could use on-demand allocations.  (Code
    included in alloc_descs()).  Problem is not all IRQS are used with a prior
    alloc_descs() call.
    
    kstat_irqs_this_cpu() is not used anymore, remove it.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reviewed-by: Christoph Lameter <cl@linux.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 979c68cc7458..6a64c6fa81af 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -57,7 +57,7 @@ struct irq_desc {
 #endif
 
 	struct timer_rand_state *timer_rand_state;
-	unsigned int		*kstat_irqs;
+	unsigned int __percpu	*kstat_irqs;
 	irq_flow_handler_t	handle_irq;
 	struct irqaction	*action;	/* IRQ action list */
 	unsigned int		status;		/* IRQ status */

commit 78f90d91f395cd0dc1ef3f21e0c5cd6fd50d202c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Sep 29 17:18:47 2010 +0200

    genirq: Remove the now unused sparse irq leftovers
    
    The move_irq_desc() function was only used due to the problem that the
    allocator did not free the old descriptors. So the descriptors had to
    be moved in create_irq_nr(). That's history.
    
    The code would have never been able to move active interrupt
    descriptors on affinity settings. That can be done in a completely
    different way w/o all this horror.
    
    Remove all of it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index f77dc5618d7e..979c68cc7458 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -82,24 +82,16 @@ struct irq_desc {
 	const char		*name;
 } ____cacheline_internodealigned_in_smp;
 
-extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
-					struct irq_desc *desc, int node);
-extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
-
 #ifndef CONFIG_SPARSE_IRQ
 extern struct irq_desc irq_desc[NR_IRQS];
 #endif
 
-#ifdef CONFIG_NUMA_IRQ_DESC
-extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int node);
-#else
+/* Will be removed once the last users in power and sh are gone */
+extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
 static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
 {
 	return desc;
 }
-#endif
-
-extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 

commit 10ba1e0eeef6a3c9453d96364e28cb4d911e1ac3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 11 12:21:18 2010 +0200

    genirq: Remove irq_2_iommu
    
    irq_2_iommu is now in the x86 code where it belongs. Remove all
    leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 22e426fdd301..f77dc5618d7e 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -10,7 +10,6 @@
 
 struct proc_dir_entry;
 struct timer_rand_state;
-struct irq_2_iommu;
 /**
  * struct irq_desc - interrupt descriptor
  * @irq_data:		per irq and chip data passed down to chip functions
@@ -52,9 +51,6 @@ struct irq_desc {
 			struct msi_desc		*msi_desc;
 #ifdef CONFIG_SMP
 			cpumask_var_t		affinity;
-#endif
-#ifdef CONFIG_INTR_REMAP
-			struct irq_2_iommu      *irq_2_iommu;
 #endif
 		};
 	};

commit e144710b302525de5b90b9c3ba43562458d8957f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Oct 1 16:03:45 2010 +0200

    genirq: Distangle irq.h
    
    Move irq_desc and internal functions out of irq.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
new file mode 100644
index 000000000000..22e426fdd301
--- /dev/null
+++ b/include/linux/irqdesc.h
@@ -0,0 +1,171 @@
+#ifndef _LINUX_IRQDESC_H
+#define _LINUX_IRQDESC_H
+
+/*
+ * Core internal functions to deal with irq descriptors
+ *
+ * This include will move to kernel/irq once we cleaned up the tree.
+ * For now it's included from <linux/irq.h>
+ */
+
+struct proc_dir_entry;
+struct timer_rand_state;
+struct irq_2_iommu;
+/**
+ * struct irq_desc - interrupt descriptor
+ * @irq_data:		per irq and chip data passed down to chip functions
+ * @timer_rand_state:	pointer to timer rand state struct
+ * @kstat_irqs:		irq stats per cpu
+ * @handle_irq:		highlevel irq-events handler [if NULL, __do_IRQ()]
+ * @action:		the irq action chain
+ * @status:		status information
+ * @depth:		disable-depth, for nested irq_disable() calls
+ * @wake_depth:		enable depth, for multiple set_irq_wake() callers
+ * @irq_count:		stats field to detect stalled irqs
+ * @last_unhandled:	aging timer for unhandled count
+ * @irqs_unhandled:	stats field for spurious unhandled interrupts
+ * @lock:		locking for SMP
+ * @pending_mask:	pending rebalanced interrupts
+ * @threads_active:	number of irqaction threads currently running
+ * @wait_for_threads:	wait queue for sync_irq to wait for threaded handlers
+ * @dir:		/proc/irq/ procfs entry
+ * @name:		flow handler name for /proc/interrupts output
+ */
+struct irq_desc {
+
+#ifdef CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED
+	struct irq_data		irq_data;
+#else
+	/*
+	 * This union will go away, once we fixed the direct access to
+	 * irq_desc all over the place. The direct fields are a 1:1
+	 * overlay of irq_data.
+	 */
+	union {
+		struct irq_data		irq_data;
+		struct {
+			unsigned int		irq;
+			unsigned int		node;
+			struct irq_chip		*chip;
+			void			*handler_data;
+			void			*chip_data;
+			struct msi_desc		*msi_desc;
+#ifdef CONFIG_SMP
+			cpumask_var_t		affinity;
+#endif
+#ifdef CONFIG_INTR_REMAP
+			struct irq_2_iommu      *irq_2_iommu;
+#endif
+		};
+	};
+#endif
+
+	struct timer_rand_state *timer_rand_state;
+	unsigned int		*kstat_irqs;
+	irq_flow_handler_t	handle_irq;
+	struct irqaction	*action;	/* IRQ action list */
+	unsigned int		status;		/* IRQ status */
+
+	unsigned int		depth;		/* nested irq disables */
+	unsigned int		wake_depth;	/* nested wake enables */
+	unsigned int		irq_count;	/* For detecting broken IRQs */
+	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
+	unsigned int		irqs_unhandled;
+	raw_spinlock_t		lock;
+#ifdef CONFIG_SMP
+	const struct cpumask	*affinity_hint;
+#ifdef CONFIG_GENERIC_PENDING_IRQ
+	cpumask_var_t		pending_mask;
+#endif
+#endif
+	atomic_t		threads_active;
+	wait_queue_head_t       wait_for_threads;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*dir;
+#endif
+	const char		*name;
+} ____cacheline_internodealigned_in_smp;
+
+extern void arch_init_copy_chip_data(struct irq_desc *old_desc,
+					struct irq_desc *desc, int node);
+extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
+
+#ifndef CONFIG_SPARSE_IRQ
+extern struct irq_desc irq_desc[NR_IRQS];
+#endif
+
+#ifdef CONFIG_NUMA_IRQ_DESC
+extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int node);
+#else
+static inline struct irq_desc *move_irq_desc(struct irq_desc *desc, int node)
+{
+	return desc;
+}
+#endif
+
+extern struct irq_desc *irq_to_desc_alloc_node(unsigned int irq, int node);
+
+#ifdef CONFIG_GENERIC_HARDIRQS
+
+#define get_irq_desc_chip(desc)		((desc)->irq_data.chip)
+#define get_irq_desc_chip_data(desc)	((desc)->irq_data.chip_data)
+#define get_irq_desc_data(desc)		((desc)->irq_data.handler_data)
+#define get_irq_desc_msi(desc)		((desc)->irq_data.msi_desc)
+
+/*
+ * Monolithic do_IRQ implementation.
+ */
+#ifndef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
+extern unsigned int __do_IRQ(unsigned int irq);
+#endif
+
+/*
+ * Architectures call this to let the generic IRQ layer
+ * handle an interrupt. If the descriptor is attached to an
+ * irqchip-style controller then we call the ->handle_irq() handler,
+ * and it calls __do_IRQ() if it's attached to an irqtype-style controller.
+ */
+static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
+{
+#ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
+	desc->handle_irq(irq, desc);
+#else
+	if (likely(desc->handle_irq))
+		desc->handle_irq(irq, desc);
+	else
+		__do_IRQ(irq);
+#endif
+}
+
+static inline void generic_handle_irq(unsigned int irq)
+{
+	generic_handle_irq_desc(irq, irq_to_desc(irq));
+}
+
+/* Test to see if a driver has successfully requested an irq */
+static inline int irq_has_action(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	return desc->action != NULL;
+}
+
+static inline int irq_balancing_disabled(unsigned int irq)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	return desc->status & IRQ_NO_BALANCING_MASK;
+}
+
+/* caller has locked the irq_desc and both params are valid */
+static inline void __set_irq_handler_unlocked(int irq,
+					      irq_flow_handler_t handler)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+	desc->handle_irq = handler;
+}
+#endif
+
+#endif
