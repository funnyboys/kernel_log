commit f59aba2f75795e5b6a4f1aa31f3e20d7b71ca804
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Dec 10 21:59:16 2019 +0100

    isdn: capi: dead code removal
    
    The staging isdn drivers are gone, and CONFIG_BT_CMTP is now
    the only user. This means a lot of the code in the subsystem
    has no remaining callers and can be removed.
    
    Change the capi user space front-end to be part of kernelcapi,
    and the combined module to only be compiled if BT_CMTP is
    also enabled, then remove the interfaces that have no remaining
    callers.
    
    As the notifier list and the capi_drivers list have no callers
    outside of kcapi.c, the implementation gets much simpler.
    
    Some definitions from the include/linux/*.h headers are only
    needed internally and are moved to kcapi.h.
    
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lore.kernel.org/r/20191210210455.3475361-2-arnd@arndb.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index 075fab5f92e1..94ba42bf9da1 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -10,46 +10,12 @@
 #ifndef __KERNELCAPI_H__
 #define __KERNELCAPI_H__
 
-
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
 #include <linux/notifier.h>
 #include <uapi/linux/kernelcapi.h>
 
-struct capi20_appl {
-	u16 applid;
-	capi_register_params rparam;
-	void (*recv_message)(struct capi20_appl *ap, struct sk_buff *skb);
-	void *private;
-
-	/* internal to kernelcapi.o */
-	unsigned long nrecvctlpkt;
-	unsigned long nrecvdatapkt;
-	unsigned long nsentctlpkt;
-	unsigned long nsentdatapkt;
-	struct mutex recv_mtx;
-	struct sk_buff_head recv_queue;
-	struct work_struct recv_work;
-	int release_in_progress;
-};
-
-u16 capi20_isinstalled(void);
-u16 capi20_register(struct capi20_appl *ap);
-u16 capi20_release(struct capi20_appl *ap);
-u16 capi20_put_message(struct capi20_appl *ap, struct sk_buff *skb);
-u16 capi20_get_manufacturer(u32 contr, u8 buf[CAPI_MANUFACTURER_LEN]);
-u16 capi20_get_version(u32 contr, struct capi_version *verp);
-u16 capi20_get_serial(u32 contr, u8 serial[CAPI_SERIAL_LEN]);
-u16 capi20_get_profile(u32 contr, struct capi_profile *profp);
-int capi20_manufacturer(unsigned long cmd, void __user *data);
-
-#define CAPICTR_UP			0
-#define CAPICTR_DOWN			1
-
-int register_capictr_notifier(struct notifier_block *nb);
-int unregister_capictr_notifier(struct notifier_block *nb);
-
 #define CAPI_NOERROR                      0x0000
 
 #define CAPI_TOOMANYAPPLS		  0x1001
@@ -76,45 +42,4 @@ int unregister_capictr_notifier(struct notifier_block *nb);
 #define CAPI_MSGCTRLERNOTSUPPORTEXTEQUIP  0x110a
 #define CAPI_MSGCTRLERONLYSUPPORTEXTEQUIP 0x110b
 
-typedef enum {
-        CapiMessageNotSupportedInCurrentState = 0x2001,
-        CapiIllContrPlciNcci                  = 0x2002,
-        CapiNoPlciAvailable                   = 0x2003,
-        CapiNoNcciAvailable                   = 0x2004,
-        CapiNoListenResourcesAvailable        = 0x2005,
-        CapiNoFaxResourcesAvailable           = 0x2006,
-        CapiIllMessageParmCoding              = 0x2007,
-} RESOURCE_CODING_PROBLEM;
-
-typedef enum {
-        CapiB1ProtocolNotSupported                      = 0x3001,
-        CapiB2ProtocolNotSupported                      = 0x3002,
-        CapiB3ProtocolNotSupported                      = 0x3003,
-        CapiB1ProtocolParameterNotSupported             = 0x3004,
-        CapiB2ProtocolParameterNotSupported             = 0x3005,
-        CapiB3ProtocolParameterNotSupported             = 0x3006,
-        CapiBProtocolCombinationNotSupported            = 0x3007,
-        CapiNcpiNotSupported                            = 0x3008,
-        CapiCipValueUnknown                             = 0x3009,
-        CapiFlagsNotSupported                           = 0x300a,
-        CapiFacilityNotSupported                        = 0x300b,
-        CapiDataLengthNotSupportedByCurrentProtocol     = 0x300c,
-        CapiResetProcedureNotSupportedByCurrentProtocol = 0x300d,
-        CapiTeiAssignmentFailed                         = 0x300e,
-} REQUESTED_SERVICES_PROBLEM;
-
-typedef enum {
-	CapiSuccess                                     = 0x0000,
-	CapiSupplementaryServiceNotSupported            = 0x300e,
-	CapiRequestNotAllowedInThisState                = 0x3010,
-} SUPPLEMENTARY_SERVICE_INFO;
-
-typedef enum {
-	CapiProtocolErrorLayer1                         = 0x3301,
-	CapiProtocolErrorLayer2                         = 0x3302,
-	CapiProtocolErrorLayer3                         = 0x3303,
-	CapiTimeOut                                     = 0x3303, // SuppServiceReason
-	CapiCallGivenToOtherApplication                 = 0x3304,
-} CAPI_REASON;
-
 #endif				/* __KERNELCAPI_H__ */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index e985ba679c4a..075fab5f92e1 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * $Id: kernelcapi.h,v 1.8.6.2 2001/02/07 11:31:31 kai Exp $
  * 

commit 9ea8aa8d5087529210553114b7bc4bf4374ace8f
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Sat Oct 11 13:46:30 2014 +0200

    isdn/capi: correct capi20_manufacturer argument type mismatch
    
    Function capi20_manufacturer() is declared with unsigned int cmd
    argument but called with unsigned long.
    Fix by correcting the function prototype since the actual argument
    is part of the user visible API.
    
    Spotted with Coverity.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index 9be37da93680..e985ba679c4a 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -41,7 +41,7 @@ u16 capi20_get_manufacturer(u32 contr, u8 buf[CAPI_MANUFACTURER_LEN]);
 u16 capi20_get_version(u32 contr, struct capi_version *verp);
 u16 capi20_get_serial(u32 contr, u8 serial[CAPI_SERIAL_LEN]);
 u16 capi20_get_profile(u32 contr, struct capi_profile *profp);
-int capi20_manufacturer(unsigned int cmd, void __user *data);
+int capi20_manufacturer(unsigned long cmd, void __user *data);
 
 #define CAPICTR_UP			0
 #define CAPICTR_DOWN			1

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index 9c2683929fd3..9be37da93680 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -6,49 +6,15 @@
  * (c) Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
  * 
  */
-
 #ifndef __KERNELCAPI_H__
 #define __KERNELCAPI_H__
 
-#define CAPI_MAXAPPL	240	/* maximum number of applications  */
-#define CAPI_MAXCONTR	32	/* maximum number of controller    */
-#define CAPI_MAXDATAWINDOW	8
-
-
-typedef struct kcapi_flagdef {
-	int contr;
-	int flag;
-} kcapi_flagdef;
-
-typedef struct kcapi_carddef {
-	char		driver[32];
-	unsigned int	port;
-	unsigned	irq;
-	unsigned int	membase;
-	int		cardnr;
-} kcapi_carddef;
-
-/* new ioctls >= 10 */
-#define KCAPI_CMD_TRACE		10
-#define KCAPI_CMD_ADDCARD	11	/* OBSOLETE */
-
-/* 
- * flag > 2 => trace also data
- * flag & 1 => show trace
- */
-#define KCAPI_TRACE_OFF			0
-#define KCAPI_TRACE_SHORT_NO_DATA	1
-#define KCAPI_TRACE_FULL_NO_DATA	2
-#define KCAPI_TRACE_SHORT		3
-#define KCAPI_TRACE_FULL		4
-
-
-#ifdef __KERNEL__
 
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
 #include <linux/notifier.h>
+#include <uapi/linux/kernelcapi.h>
 
 struct capi20_appl {
 	u16 applid;
@@ -150,6 +116,4 @@ typedef enum {
 	CapiCallGivenToOtherApplication                 = 0x3304,
 } CAPI_REASON;
 
-#endif				/* __KERNEL__ */
-
 #endif				/* __KERNELCAPI_H__ */

commit ef69bb2ec6036945da1d3d3f07b75253f484f693
Author: Jan Kiszka <jan.kiszka@web.de>
Date:   Mon Feb 8 10:12:13 2010 +0000

    CAPI: Rework controller state notifier
    
    Another step towards proper locking: Rework the callback provided to
    capidrv for controller state changes. This is so far attached to an
    application, which would require us to hold the corresponding lock
    across notification calls.
    
    But there is no direct relation between a controller up/down event and
    an application, so let's decouple them and provide a notifier call chain
    for those events instead. This notifier chain is first of all used
    internally. Here we request the highest priority to unsure that
    housekeeping work is done before any other notifications. The chain is
    exported via [un]register_capictr_notifier to our only user, capidrv, to
    replace the racy and unfixable capi20_set_callback.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index a53e932f80fb..9c2683929fd3 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -48,9 +48,7 @@ typedef struct kcapi_carddef {
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
-
-#define	KCI_CONTRUP	0	/* arg: struct capi_profile */
-#define	KCI_CONTRDOWN	1	/* arg: NULL */
+#include <linux/notifier.h>
 
 struct capi20_appl {
 	u16 applid;
@@ -67,11 +65,6 @@ struct capi20_appl {
 	struct sk_buff_head recv_queue;
 	struct work_struct recv_work;
 	int release_in_progress;
-
-	/* ugly hack to allow for notification of added/removed
-	 * controllers. The Right Way (tm) is known. XXX
-	 */
-	void (*callback) (unsigned int cmd, __u32 contr, void *data);
 };
 
 u16 capi20_isinstalled(void);
@@ -84,11 +77,11 @@ u16 capi20_get_serial(u32 contr, u8 serial[CAPI_SERIAL_LEN]);
 u16 capi20_get_profile(u32 contr, struct capi_profile *profp);
 int capi20_manufacturer(unsigned int cmd, void __user *data);
 
-/* temporary hack XXX */
-void capi20_set_callback(struct capi20_appl *ap, 
-			 void (*callback) (unsigned int cmd, __u32 contr, void *data));
-
+#define CAPICTR_UP			0
+#define CAPICTR_DOWN			1
 
+int register_capictr_notifier(struct notifier_block *nb);
+int unregister_capictr_notifier(struct notifier_block *nb);
 
 #define CAPI_NOERROR                      0x0000
 

commit 5a6483feb0c5193519625d0ea8c4254364d423cc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Feb 26 10:00:17 2008 -0500

    include: Remove unnecessary inclusions of asm/semaphore.h
    
    None of these files use any of the functionality promised by
    asm/semaphore.h.  It's possible that they (or some user of them) rely
    on it dragging in some unrelated header file, but I can't build all
    these files, so we'll have to fix any build failures as they come up.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index 8c4350a9ed87..a53e932f80fb 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -48,7 +48,6 @@ typedef struct kcapi_carddef {
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
-#include <asm/semaphore.h>
 
 #define	KCI_CONTRUP	0	/* arg: struct capi_profile */
 #define	KCI_CONTRDOWN	1	/* arg: NULL */

commit 67837f232d6d55be99d6e0dec4ea9bb8112840cd
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Tue Jul 17 04:04:16 2007 -0700

    Use mutex instead of semaphore in CAPI 2.0 driver
    
    The CAPI 2.0 driver uses a semaphore as mutex.  Use the mutex API instead of
    the (binary) semaphore.
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Acked-by: Karsten Keil <kkeil@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index aea34e74c496..8c4350a9ed87 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -64,7 +64,7 @@ struct capi20_appl {
 	unsigned long nrecvdatapkt;
 	unsigned long nsentctlpkt;
 	unsigned long nsentdatapkt;
-	struct semaphore recv_sem;
+	struct mutex recv_mtx;
 	struct sk_buff_head recv_queue;
 	struct work_struct recv_work;
 	int release_in_progress;

commit a80958f4849316a18c06f75b9e850ccecbf20df8
Author: Al Viro <viro@hera.kernel.org>
Date:   Mon Dec 4 20:41:19 2006 +0000

    [PATCH] fix fallout from header dependency trimming
    
    OK, that seems to be enough to deal with the mess.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index f8a0ff86dacc..aea34e74c496 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -48,6 +48,7 @@ typedef struct kcapi_carddef {
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
+#include <asm/semaphore.h>
 
 #define	KCI_CONTRUP	0	/* arg: struct capi_profile */
 #define	KCI_CONTRDOWN	1	/* arg: NULL */

commit d7fe0f241dceade9c8d4af75498765c5ff7f27e6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 3 23:15:30 2006 -0500

    [PATCH] severing skbuff.h -> mm.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
index 891bb2cf0aa8..f8a0ff86dacc 100644
--- a/include/linux/kernelcapi.h
+++ b/include/linux/kernelcapi.h
@@ -47,6 +47,7 @@ typedef struct kcapi_carddef {
 
 #include <linux/list.h>
 #include <linux/skbuff.h>
+#include <linux/workqueue.h>
 
 #define	KCI_CONTRUP	0	/* arg: struct capi_profile */
 #define	KCI_CONTRDOWN	1	/* arg: NULL */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/kernelcapi.h b/include/linux/kernelcapi.h
new file mode 100644
index 000000000000..891bb2cf0aa8
--- /dev/null
+++ b/include/linux/kernelcapi.h
@@ -0,0 +1,161 @@
+/*
+ * $Id: kernelcapi.h,v 1.8.6.2 2001/02/07 11:31:31 kai Exp $
+ * 
+ * Kernel CAPI 2.0 Interface for Linux
+ * 
+ * (c) Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
+ * 
+ */
+
+#ifndef __KERNELCAPI_H__
+#define __KERNELCAPI_H__
+
+#define CAPI_MAXAPPL	240	/* maximum number of applications  */
+#define CAPI_MAXCONTR	32	/* maximum number of controller    */
+#define CAPI_MAXDATAWINDOW	8
+
+
+typedef struct kcapi_flagdef {
+	int contr;
+	int flag;
+} kcapi_flagdef;
+
+typedef struct kcapi_carddef {
+	char		driver[32];
+	unsigned int	port;
+	unsigned	irq;
+	unsigned int	membase;
+	int		cardnr;
+} kcapi_carddef;
+
+/* new ioctls >= 10 */
+#define KCAPI_CMD_TRACE		10
+#define KCAPI_CMD_ADDCARD	11	/* OBSOLETE */
+
+/* 
+ * flag > 2 => trace also data
+ * flag & 1 => show trace
+ */
+#define KCAPI_TRACE_OFF			0
+#define KCAPI_TRACE_SHORT_NO_DATA	1
+#define KCAPI_TRACE_FULL_NO_DATA	2
+#define KCAPI_TRACE_SHORT		3
+#define KCAPI_TRACE_FULL		4
+
+
+#ifdef __KERNEL__
+
+#include <linux/list.h>
+#include <linux/skbuff.h>
+
+#define	KCI_CONTRUP	0	/* arg: struct capi_profile */
+#define	KCI_CONTRDOWN	1	/* arg: NULL */
+
+struct capi20_appl {
+	u16 applid;
+	capi_register_params rparam;
+	void (*recv_message)(struct capi20_appl *ap, struct sk_buff *skb);
+	void *private;
+
+	/* internal to kernelcapi.o */
+	unsigned long nrecvctlpkt;
+	unsigned long nrecvdatapkt;
+	unsigned long nsentctlpkt;
+	unsigned long nsentdatapkt;
+	struct semaphore recv_sem;
+	struct sk_buff_head recv_queue;
+	struct work_struct recv_work;
+	int release_in_progress;
+
+	/* ugly hack to allow for notification of added/removed
+	 * controllers. The Right Way (tm) is known. XXX
+	 */
+	void (*callback) (unsigned int cmd, __u32 contr, void *data);
+};
+
+u16 capi20_isinstalled(void);
+u16 capi20_register(struct capi20_appl *ap);
+u16 capi20_release(struct capi20_appl *ap);
+u16 capi20_put_message(struct capi20_appl *ap, struct sk_buff *skb);
+u16 capi20_get_manufacturer(u32 contr, u8 buf[CAPI_MANUFACTURER_LEN]);
+u16 capi20_get_version(u32 contr, struct capi_version *verp);
+u16 capi20_get_serial(u32 contr, u8 serial[CAPI_SERIAL_LEN]);
+u16 capi20_get_profile(u32 contr, struct capi_profile *profp);
+int capi20_manufacturer(unsigned int cmd, void __user *data);
+
+/* temporary hack XXX */
+void capi20_set_callback(struct capi20_appl *ap, 
+			 void (*callback) (unsigned int cmd, __u32 contr, void *data));
+
+
+
+#define CAPI_NOERROR                      0x0000
+
+#define CAPI_TOOMANYAPPLS		  0x1001
+#define CAPI_LOGBLKSIZETOSMALL	          0x1002
+#define CAPI_BUFFEXECEEDS64K 	          0x1003
+#define CAPI_MSGBUFSIZETOOSMALL	          0x1004
+#define CAPI_ANZLOGCONNNOTSUPPORTED	  0x1005
+#define CAPI_REGRESERVED		  0x1006
+#define CAPI_REGBUSY 		          0x1007
+#define CAPI_REGOSRESOURCEERR	          0x1008
+#define CAPI_REGNOTINSTALLED 	          0x1009
+#define CAPI_REGCTRLERNOTSUPPORTEXTEQUIP  0x100a
+#define CAPI_REGCTRLERONLYSUPPORTEXTEQUIP 0x100b
+
+#define CAPI_ILLAPPNR		          0x1101
+#define CAPI_ILLCMDORSUBCMDORMSGTOSMALL   0x1102
+#define CAPI_SENDQUEUEFULL		  0x1103
+#define CAPI_RECEIVEQUEUEEMPTY	          0x1104
+#define CAPI_RECEIVEOVERFLOW 	          0x1105
+#define CAPI_UNKNOWNNOTPAR		  0x1106
+#define CAPI_MSGBUSY 		          0x1107
+#define CAPI_MSGOSRESOURCEERR	          0x1108
+#define CAPI_MSGNOTINSTALLED 	          0x1109
+#define CAPI_MSGCTRLERNOTSUPPORTEXTEQUIP  0x110a
+#define CAPI_MSGCTRLERONLYSUPPORTEXTEQUIP 0x110b
+
+typedef enum {
+        CapiMessageNotSupportedInCurrentState = 0x2001,
+        CapiIllContrPlciNcci                  = 0x2002,
+        CapiNoPlciAvailable                   = 0x2003,
+        CapiNoNcciAvailable                   = 0x2004,
+        CapiNoListenResourcesAvailable        = 0x2005,
+        CapiNoFaxResourcesAvailable           = 0x2006,
+        CapiIllMessageParmCoding              = 0x2007,
+} RESOURCE_CODING_PROBLEM;
+
+typedef enum {
+        CapiB1ProtocolNotSupported                      = 0x3001,
+        CapiB2ProtocolNotSupported                      = 0x3002,
+        CapiB3ProtocolNotSupported                      = 0x3003,
+        CapiB1ProtocolParameterNotSupported             = 0x3004,
+        CapiB2ProtocolParameterNotSupported             = 0x3005,
+        CapiB3ProtocolParameterNotSupported             = 0x3006,
+        CapiBProtocolCombinationNotSupported            = 0x3007,
+        CapiNcpiNotSupported                            = 0x3008,
+        CapiCipValueUnknown                             = 0x3009,
+        CapiFlagsNotSupported                           = 0x300a,
+        CapiFacilityNotSupported                        = 0x300b,
+        CapiDataLengthNotSupportedByCurrentProtocol     = 0x300c,
+        CapiResetProcedureNotSupportedByCurrentProtocol = 0x300d,
+        CapiTeiAssignmentFailed                         = 0x300e,
+} REQUESTED_SERVICES_PROBLEM;
+
+typedef enum {
+	CapiSuccess                                     = 0x0000,
+	CapiSupplementaryServiceNotSupported            = 0x300e,
+	CapiRequestNotAllowedInThisState                = 0x3010,
+} SUPPLEMENTARY_SERVICE_INFO;
+
+typedef enum {
+	CapiProtocolErrorLayer1                         = 0x3301,
+	CapiProtocolErrorLayer2                         = 0x3302,
+	CapiProtocolErrorLayer3                         = 0x3303,
+	CapiTimeOut                                     = 0x3303, // SuppServiceReason
+	CapiCallGivenToOtherApplication                 = 0x3304,
+} CAPI_REASON;
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __KERNELCAPI_H__ */
