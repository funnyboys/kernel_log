commit 911d137ab027e6dac03695bfe71702e64b6aa161
Merge: fb9bf40cf028 38a2204f5298
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 7 16:56:00 2019 -0800

    Merge tag 'nfsd-5.5' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "This is a relatively quiet cycle for nfsd, mainly various bugfixes.
    
      Possibly most interesting is Trond's fixes for some callback races
      that were due to my incomplete understanding of rpc client shutdown.
      Unfortunately at the last minute I've started noticing a new
      intermittent failure to send callbacks. As the logic seems basically
      correct, I'm leaving Trond's patches in for now, and hope to find a
      fix in the next week so I don't have to revert those patches"
    
    * tag 'nfsd-5.5' of git://linux-nfs.org/~bfields/linux: (24 commits)
      nfsd: depend on CRYPTO_MD5 for legacy client tracking
      NFSD fixing possible null pointer derefering in copy offload
      nfsd: check for EBUSY from vfs_rmdir/vfs_unink.
      nfsd: Ensure CLONE persists data and metadata changes to the target file
      SUNRPC: Fix backchannel latency metrics
      nfsd: restore NFSv3 ACL support
      nfsd: v4 support requires CRYPTO_SHA256
      nfsd: Fix cld_net->cn_tfm initialization
      lockd: remove __KERNEL__ ifdefs
      sunrpc: remove __KERNEL__ ifdefs
      race in exportfs_decode_fh()
      nfsd: Drop LIST_HEAD where the variable it declares is never used.
      nfsd: document callback_wq serialization of callback code
      nfsd: mark cb path down on unknown errors
      nfsd: Fix races between nfsd4_cb_release() and nfsd4_shutdown_callback()
      nfsd: minor 4.1 callback cleanup
      SUNRPC: Fix svcauth_gss_proxy_init()
      SUNRPC: Trace gssproxy upcall results
      sunrpc: fix crash when cache_head become valid before update
      nfsd: remove private bin2hex implementation
      ...

commit d05a0201969045f4c488f7cf1d024089949a68b6
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 12 16:34:22 2019 +0100

    sunrpc: remove __KERNEL__ ifdefs
    
    Remove the __KERNEL__ ifdefs from the non-UAPI sunrpc headers,
    as those can't be included from user space programs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d783e15ba898..874205227778 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -19,8 +19,6 @@
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
 
-#ifdef __KERNEL__
-
 #define RPC_MIN_SLOT_TABLE	(2U)
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE_LIMIT	(65536U)
@@ -505,6 +503,4 @@ static inline void xprt_inject_disconnect(struct rpc_xprt *xprt)
 }
 #endif
 
-#endif /* __KERNEL__*/
-
 #endif /* _LINUX_SUNRPC_XPRT_H */

commit e6237b6feb37582fbd6bd7a8336d1256a6b4b4f9
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Oct 17 11:13:54 2019 -0400

    NFSv4.1: Don't rebind to the same source port when reconnecting to the server
    
    NFSv2, v3 and NFSv4 servers often have duplicate replay caches that look
    at the source port when deciding whether or not an RPC call is a replay
    of a previous call. This requires clients to perform strange TCP gymnastics
    in order to ensure that when they reconnect to the server, they bind
    to the same source port.
    
    NFSv4.1 and NFSv4.2 have sessions that provide proper replay semantics,
    that do not look at the source port of the connection. This patch therefore
    ensures they can ignore the rebind requirement.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d783e15ba898..ccd35cf4fc41 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -207,7 +207,8 @@ struct rpc_xprt {
 	unsigned int		min_reqs;	/* min number of slots */
 	unsigned int		num_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
-	unsigned char		resvport   : 1; /* use a reserved port */
+	unsigned char		resvport   : 1,	/* use a reserved port */
+				reuseport  : 1; /* reuse port on reconnect */
 	atomic_t		swapper;	/* we're swapping over this
 						   transport */
 	unsigned int		bind_index;	/* bind function index */

commit cc204d01262a69218b2d0db5cdea371de85871d9
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Sep 10 13:01:35 2019 -0400

    SUNRPC: Dequeue the request from the receive queue while we're re-encoding
    
    Ensure that we dequeue the request from the transport receive queue
    while we're re-encoding to prevent issues like use-after-free when
    we release the bvec.
    
    Fixes: 7536908982047 ("SUNRPC: Ensure the bvecs are reset when we re-encode...")
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Cc: stable@vger.kernel.org # v4.20+
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 13e108bcc9eb..d783e15ba898 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -352,6 +352,7 @@ bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);
 void			xprt_request_wait_receive(struct rpc_task *task);
+void			xprt_request_dequeue_xprt(struct rpc_task *task);
 bool			xprt_request_need_retransmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);

commit 7402a4fedc2bc448100c2d086406c708451b16dc
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Tue Jul 16 13:51:29 2019 -0400

    SUNRPC: Fix up backchannel slot table accounting
    
    Add a per-transport maximum limit in the socket case, and add
    helpers to allow the NFSv4 code to discover that limit.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ed76e5fb36c1..13e108bcc9eb 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -158,6 +158,7 @@ struct rpc_xprt_ops {
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
 	size_t		(*bc_maxpayload)(struct rpc_xprt *xprt);
+	unsigned int	(*bc_num_slots)(struct rpc_xprt *xprt);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
 	void		(*bc_destroy)(struct rpc_xprt *xprt,
 				      unsigned int max_reqs);
@@ -251,8 +252,9 @@ struct rpc_xprt {
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
 						/* process the callback */
-	int			bc_alloc_count;	/* Total number of preallocs */
-	atomic_t		bc_free_slots;
+	unsigned int		bc_alloc_max;
+	unsigned int		bc_alloc_count;	/* Total number of preallocs */
+	atomic_t		bc_slot_count;	/* Number of allocated slots */
 	spinlock_t		bc_pa_lock;	/* Protects the preallocated
 						 * items */
 	struct list_head	bc_pa_list;	/* List of preallocated

commit 347543e64082782379627cb21162cb859590f3c7
Merge: 80d3c45fd765 62a92ba97a31
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Jul 11 16:52:47 2019 -0400

    Merge tag 'nfs-rdma-for-5.3-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    NFSoRDMA client updates for 5.3
    
    New features:
    - Add a way to place MRs back on the free list
    - Reduce context switching
    - Add new trace events
    
    Bugfixes and cleanups:
    - Fix a BUG when tracing is enabled with NFSv4.1
    - Fix a use-after-free in rpcrdma_post_recvs
    - Replace use of xdr_stream_pos in rpcrdma_marshal_req
    - Fix occasional transport deadlock
    - Fix show_nfs_errors macros, other tracing improvements
    - Remove RPCRDMA_REQ_F_PENDING and fr_state
    - Various simplifications and refactors

commit 675dd90ad0932f2c03912a5252458d792bd7033a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed Jun 19 10:33:42 2019 -0400

    xprtrdma: Modernize ops->connect
    
    Adapt and apply changes that were made to the TCP socket connect
    code. See the following commits for details on the purpose of
    these changes:
    
    Commit 7196dbb02ea0 ("SUNRPC: Allow changing of the TCP timeout parameters on the fly")
    Commit 3851f1cdb2b8 ("SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout")
    Commit 02910177aede ("SUNRPC: Fix reconnection timeouts")
    
    Some common transport code is moved to xprt.c to satisfy the code
    duplication police.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a6d9fce7f20e..cc78fd38ea7d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -334,6 +334,9 @@ struct xprt_class {
  */
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
+unsigned long		xprt_reconnect_delay(const struct rpc_xprt *xprt);
+void			xprt_reconnect_backoff(struct rpc_xprt *xprt,
+					       unsigned long init_to);
 void			xprt_reserve(struct rpc_task *task);
 void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);

commit 21f0ffaff510b0530bfdf77da7133c0b99dee2fe
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Fri Apr 28 10:52:42 2017 -0400

    SUNRPC: Add basic load balancing to the transport switch
    
    For now, just count the queue length. It is less accurate than counting
    number of bytes queued, but easier to implement.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a6d9fce7f20e..15322c1d9c8c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -238,6 +238,7 @@ struct rpc_xprt {
 	/*
 	 * Send stuff
 	 */
+	atomic_long_t		queuelen;
 	spinlock_t		transport_lock;	/* lock transport info */
 	spinlock_t		reserve_lock;	/* lock slot table */
 	spinlock_t		queue_lock;	/* send/receive queue lock */

commit 8ba6a92d0182091e0c2fa15c1a5b5458bac25fc3
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Apr 7 13:58:46 2019 -0400

    SUNRPC: Refactor xprt_request_wait_receive()
    
    Convert the transport callback to actually put the request to sleep
    instead of just setting a timeout. This is in preparation for
    rpc_sleep_on_timeout().
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3a391544299e..a6d9fce7f20e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -143,7 +143,7 @@ struct rpc_xprt_ops {
 	void		(*buf_free)(struct rpc_task *task);
 	void		(*prepare_request)(struct rpc_rqst *req);
 	int		(*send_request)(struct rpc_rqst *req);
-	void		(*set_retrans_timeout)(struct rpc_task *task);
+	void		(*wait_for_reply_request)(struct rpc_task *task);
 	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_request)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
@@ -378,8 +378,8 @@ xprt_disable_swap(struct rpc_xprt *xprt)
 int			xprt_register_transport(struct xprt_class *type);
 int			xprt_unregister_transport(struct xprt_class *type);
 int			xprt_load_transport(const char *);
-void			xprt_set_retrans_timeout_def(struct rpc_task *task);
-void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
+void			xprt_wait_for_reply_request_def(struct rpc_task *task);
+void			xprt_wait_for_reply_request_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_xprt *xprt);
 bool			xprt_write_space(struct rpc_xprt *xprt);

commit 067fb11b12af1448f7bbcacca41e470cb775e9fa
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 11 11:24:37 2019 -0500

    SUNRPC: Remove rpc_xprt::tsh_size
    
    tsh_size was added to accommodate transports that send a pre-amble
    before each RPC message. However, this assumes the pre-amble is
    fixed in size, which isn't true for some transports. That makes
    tsh_size not very generic.
    
    Also I'd like to make the estimation of RPC send and receive
    buffer sizes more precise. tsh_size doesn't currently appear to be
    accounted for at all by call_allocate.
    
    Therefore let's just remove the tsh_size concept, and make the only
    transports that have a non-zero tsh_size employ a direct approach.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ad7e910b119d..3a391544299e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -196,8 +196,6 @@ struct rpc_xprt {
 
 	size_t			max_payload;	/* largest RPC payload size,
 						   in bytes */
-	unsigned int		tsh_size;	/* size of transport specific
-						   header */
 
 	struct rpc_wait_queue	binding;	/* requests waiting on rpcbind */
 	struct rpc_wait_queue	sending;	/* requests waiting to send */
@@ -362,11 +360,6 @@ struct rpc_xprt *	xprt_alloc(struct net *net, size_t size,
 				unsigned int max_req);
 void			xprt_free(struct rpc_xprt *);
 
-static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
-{
-	return p + xprt->tsh_size;
-}
-
 static inline int
 xprt_enable_swap(struct rpc_xprt *xprt)
 {

commit 4aa5cffefa6f8af8f16490df58b8f0d827911b58
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Mon Dec 24 14:45:25 2018 +0300

    sunrpc: remove unused bc_up operation from rpc_xprt_ops
    
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a4ab4f8d9140..ad7e910b119d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -157,7 +157,6 @@ struct rpc_xprt_ops {
 	void		(*inject_disconnect)(struct rpc_xprt *xprt);
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
-	int		(*bc_up)(struct svc_serv *serv, struct net *net);
 	size_t		(*bc_maxpayload)(struct rpc_xprt *xprt);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
 	void		(*bc_destroy)(struct rpc_xprt *xprt,

commit 9d96acbc7f376dc1ffcedca0c349dd3389187a38
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Sep 13 12:22:04 2018 -0400

    SUNRPC: Add a bvec array to struct xdr_buf for use with iovec_iter()
    
    Add a bvec array to struct xdr_buf, and have the client allocate it
    when we need to receive data into pages.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9be399020dab..a4ab4f8d9140 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -141,6 +141,7 @@ struct rpc_xprt_ops {
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
 	int		(*buf_alloc)(struct rpc_task *task);
 	void		(*buf_free)(struct rpc_task *task);
+	void		(*prepare_request)(struct rpc_rqst *req);
 	int		(*send_request)(struct rpc_rqst *req);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);
@@ -343,6 +344,7 @@ int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_free_slot(struct rpc_xprt *xprt,
 				       struct rpc_rqst *req);
+void			xprt_request_prepare(struct rpc_rqst *req);
 bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);

commit 95f7691daa57bbd68caac2bdad79e0b08f4d46c1
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Sep 7 08:35:22 2018 -0400

    SUNRPC: Convert xprt receive queue to use an rbtree
    
    If the server is slow, we can find ourselves with quite a lot of entries
    on the receive queue. Converting the search from an O(n) to O(log(n))
    can make a significant difference, particularly since we have to hold
    a number of locks while searching.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 823860cce0bc..9be399020dab 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -85,7 +85,7 @@ struct rpc_rqst {
 
 	union {
 		struct list_head	rq_list;	/* Slot allocation list */
-		struct list_head	rq_recv;	/* Receive queue */
+		struct rb_node		rq_recv;	/* Receive queue */
 	};
 
 	struct list_head	rq_xmit;	/* Send queue */
@@ -260,7 +260,7 @@ struct rpc_xprt {
 						 * backchannel rpc_rqst's */
 #endif /* CONFIG_SUNRPC_BACKCHANNEL */
 
-	struct list_head	recv_queue;	/* Receive queue */
+	struct rb_root		recv_queue;	/* Receive queue */
 
 	struct {
 		unsigned long		bind_count,	/* total number of binds */

commit adfa71446dd0943ba376eff3e05c7c89582f8038
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Sep 3 23:58:59 2018 -0400

    SUNRPC: Cleanup: remove the unused 'task' argument from the request_send()
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 5600242ccbf9..823860cce0bc 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -141,7 +141,7 @@ struct rpc_xprt_ops {
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
 	int		(*buf_alloc)(struct rpc_task *task);
 	void		(*buf_free)(struct rpc_task *task);
-	int		(*send_request)(struct rpc_rqst *req, struct rpc_task *task);
+	int		(*send_request)(struct rpc_rqst *req);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_request)(struct rpc_task *task);

commit c544577daddb618c7dd5fa7fb98d6a41782f020e
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Sep 3 23:39:27 2018 -0400

    SUNRPC: Clean up transport write space handling
    
    Treat socket write space handling in the same way we now treat transport
    congestion: by denying the XPRT_LOCK until the transport signals that it
    has free buffer space.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 14c9b4d49fb4..5600242ccbf9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -387,8 +387,8 @@ int			xprt_load_transport(const char *);
 void			xprt_set_retrans_timeout_def(struct rpc_task *task);
 void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
-void			xprt_wait_for_buffer_space(struct rpc_task *task, rpc_action action);
-void			xprt_write_space(struct rpc_xprt *xprt);
+void			xprt_wait_for_buffer_space(struct rpc_xprt *xprt);
+bool			xprt_write_space(struct rpc_xprt *xprt);
 void			xprt_adjust_cwnd(struct rpc_xprt *xprt, struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_update_rtt(struct rpc_task *task);
@@ -416,6 +416,7 @@ void			xprt_unlock_connect(struct rpc_xprt *, void *);
 #define XPRT_CLOSING		(6)
 #define XPRT_CONGESTED		(9)
 #define XPRT_CWND_WAIT		(10)
+#define XPRT_WRITE_SPACE	(11)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 36bd7de949f41d586ef7794169af75462b67acbc
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Sep 3 18:41:32 2018 -0400

    SUNRPC: Turn off throttling of RPC slots for TCP sockets
    
    The theory was that we would need to grab the socket lock anyway, so we
    might as well use it to gate the allocation of RPC slots for a TCP
    socket.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 0d0cc127615e..14c9b4d49fb4 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -343,7 +343,6 @@ int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_free_slot(struct rpc_xprt *xprt,
 				       struct rpc_rqst *req);
-void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);

commit 75891f502f5fc70f52a01af5b924384ed4866907
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Sep 3 17:37:36 2018 -0400

    SUNRPC: Support for congestion control when queuing is enabled
    
    Both RDMA and UDP transports require the request to get a "congestion control"
    credit before they can be transmitted. Right now, this is done when
    the request locks the socket. We'd like it to happen when a request attempts
    to be transmitted for the first time.
    In order to support retransmission of requests that already hold such
    credits, we also want to ensure that they get queued first, so that we
    don't deadlock with requests that have yet to obtain a credit.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e377620b9744..0d0cc127615e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -397,6 +397,7 @@ void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_pin_rqst(struct rpc_rqst *req);
 void			xprt_unpin_rqst(struct rpc_rqst *req);
 void			xprt_release_rqst_cong(struct rpc_task *task);
+bool			xprt_request_get_cong(struct rpc_xprt *xprt, struct rpc_rqst *req);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
 void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
@@ -415,6 +416,7 @@ void			xprt_unlock_connect(struct rpc_xprt *, void *);
 #define XPRT_BINDING		(5)
 #define XPRT_CLOSING		(6)
 #define XPRT_CONGESTED		(9)
+#define XPRT_CWND_WAIT		(10)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 918f3c1fe83c5baa4892b943d3f5ac7191d8fb74
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Sun Sep 9 11:37:22 2018 -0400

    SUNRPC: Improve latency for interactive tasks
    
    One of the intentions with the priority queues was to ensure that no
    single process can hog the transport. The field task->tk_owner therefore
    identifies the RPC call's origin, and is intended to allow the RPC layer
    to organise queues for fairness.
    This commit therefore modifies the transmit queue to group requests
    by task->tk_owner, and ensures that we round robin among those groups.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8c2bb078f00c..e377620b9744 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -89,6 +89,7 @@ struct rpc_rqst {
 	};
 
 	struct list_head	rq_xmit;	/* Send queue */
+	struct list_head	rq_xmit2;	/* Send queue */
 
 	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize;

commit 50f484e298218b7271fad8a23bd44c82fb3110e1
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Aug 30 13:27:29 2018 -0400

    SUNRPC: Treat the task and request as separate in the xprt_ops->send_request()
    
    When we shift to using the transmit queue, then the task that holds the
    write lock will not necessarily be the same as the one being transmitted.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index b8a7de161f67..8c2bb078f00c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -140,7 +140,7 @@ struct rpc_xprt_ops {
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
 	int		(*buf_alloc)(struct rpc_task *task);
 	void		(*buf_free)(struct rpc_task *task);
-	int		(*send_request)(struct rpc_task *task);
+	int		(*send_request)(struct rpc_rqst *req, struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_request)(struct rpc_task *task);

commit 762e4e67b356ab7b8fbfc39bc07dc6110121505e
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Aug 24 16:28:28 2018 -0400

    SUNRPC: Refactor RPC call encoding
    
    Move the call encoding so that it occurs before the transport connection
    etc.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 81a6c2c8dfc7..b8a7de161f67 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -347,6 +347,7 @@ bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);
 void			xprt_request_wait_receive(struct rpc_task *task);
+bool			xprt_request_need_retransmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);

commit 944b042921a17d1a4e51bb05f8edf2b93d26e36f
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Aug 9 23:33:21 2018 -0400

    SUNRPC: Add a transmission queue for RPC requests
    
    Add the queue that will enforce the ordering of RPC task transmission.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9cec2d0811f2..81a6c2c8dfc7 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -88,6 +88,8 @@ struct rpc_rqst {
 		struct list_head	rq_recv;	/* Receive queue */
 	};
 
+	struct list_head	rq_xmit;	/* Send queue */
+
 	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize;
 	void			*rq_rbuffer;	/* Reply XDR decode buffer */
@@ -242,6 +244,9 @@ struct rpc_xprt {
 	spinlock_t		queue_lock;	/* send/receive queue lock */
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
+
+	struct list_head	xmit_queue;	/* Send queue */
+
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
@@ -339,6 +344,7 @@ void			xprt_free_slot(struct rpc_xprt *xprt,
 				       struct rpc_rqst *req);
 void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 bool			xprt_prepare_transmit(struct rpc_task *task);
+void			xprt_request_enqueue_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);
 void			xprt_request_wait_receive(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);

commit ef3f54347f690d06649c0d7a1f63d3410b3d08d3
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Aug 8 09:23:32 2018 -0400

    SUNRPC: Distinguish between the slot allocation list and receive queue
    
    When storing a struct rpc_rqst on the slot allocation list, we currently
    use the same field 'rq_list' as we use to store the request on the
    receive queue. Since the structure is never on both lists at the same
    time, this is OK.
    However, for clarity, let's make that a union with different names for
    the different lists so that we can more easily distinguish between
    the two states.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 4fa2af087cff..9cec2d0811f2 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -82,7 +82,11 @@ struct rpc_rqst {
 	struct page		**rq_enc_pages;	/* scratch pages for use by
 						   gss privacy code */
 	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
-	struct list_head	rq_list;
+
+	union {
+		struct list_head	rq_list;	/* Slot allocation list */
+		struct list_head	rq_recv;	/* Receive queue */
+	};
 
 	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize;
@@ -249,7 +253,8 @@ struct rpc_xprt {
 	struct list_head	bc_pa_list;	/* List of preallocated
 						 * backchannel rpc_rqst's */
 #endif /* CONFIG_SUNRPC_BACKCHANNEL */
-	struct list_head	recv;
+
+	struct list_head	recv_queue;	/* Receive queue */
 
 	struct {
 		unsigned long		bind_count,	/* total number of binds */

commit 7f3a1d1e1806a0eb9b200e3aed2a04431f2bcc6a
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Thu Aug 23 00:03:43 2018 -0400

    SUNRPC: Refactor xprt_transmit() to remove wait for reply code
    
    Allow the caller in clnt.c to call into the code to wait for a reply
    after calling xprt_transmit(). Again, the reason is that the backchannel
    code does not need this functionality.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 0250294c904a..4fa2af087cff 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -335,6 +335,7 @@ void			xprt_free_slot(struct rpc_xprt *xprt,
 void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_request_enqueue_receive(struct rpc_task *task);
+void			xprt_request_wait_receive(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);

commit edc81dcd5b7f699c4049042b35c904396642032e
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Aug 22 17:55:46 2018 -0400

    SUNRPC: Refactor xprt_transmit() to remove the reply queue code
    
    Separate out the action of adding a request to the reply queue so that the
    backchannel code can simply skip calling it altogether.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c25d0a5fda69..0250294c904a 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -334,6 +334,7 @@ void			xprt_free_slot(struct rpc_xprt *xprt,
 				       struct rpc_rqst *req);
 void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 bool			xprt_prepare_transmit(struct rpc_task *task);
+void			xprt_request_enqueue_receive(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);

commit 75c84151a9dc7a755c607e6761d8f14a1690dbf0
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Fri Aug 31 10:21:00 2018 -0400

    SUNRPC: Rename xprt->recv_lock to xprt->queue_lock
    
    We will use the same lock to protect both the transmit and receive queues.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bd743c51a865..c25d0a5fda69 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -235,7 +235,7 @@ struct rpc_xprt {
 	 */
 	spinlock_t		transport_lock;	/* lock transport info */
 	spinlock_t		reserve_lock;	/* lock slot table */
-	spinlock_t		recv_lock;	/* lock receive list */
+	spinlock_t		queue_lock;	/* send/receive queue lock */
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */

commit cf9946cd6144410ced00d52586ff5a2cb4868fc5
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Mon Aug 6 12:55:34 2018 -0400

    SUNRPC: Refactor the transport request pinning
    
    We are going to need to pin for both send and receive.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3d80524e92d6..bd743c51a865 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -103,6 +103,7 @@ struct rpc_rqst {
 						/* A cookie used to track the
 						   state of the transport
 						   connection */
+	atomic_t		rq_pin;
 	
 	/*
 	 * Partial send handling

commit 9dc6edcf676fe188430e8b119f91280bbf285163
Author: Trond Myklebust <trond.myklebust@hammerspace.com>
Date:   Wed Aug 22 14:24:16 2018 -0400

    SUNRPC: Clean up initialisation of the struct rpc_rqst
    
    Move the initialisation back into xprt.c.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 336fd1a19cca..3d80524e92d6 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -325,7 +325,6 @@ struct xprt_class {
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
-void			xprt_request_init(struct rpc_task *task);
 void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);

commit edb41e61a54ee75fae31302775e0301fdcb0caaa
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri May 4 15:35:09 2018 -0400

    xprtrdma: Make rpc_rqst part of rpcrdma_req
    
    This simplifies allocation of the generic RPC slot and xprtrdma
    specific per-RPC resources.
    
    It also makes xprtrdma more like the socket-based transports:
    ->buf_alloc and ->buf_free are now responsible only for send and
    receive buffers.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 706eef12bbc0..336fd1a19cca 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -84,7 +84,6 @@ struct rpc_rqst {
 	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
 	struct list_head	rq_list;
 
-	void			*rq_xprtdata;	/* Per-xprt private data */
 	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize;
 	void			*rq_rbuffer;	/* Reply XDR decode buffer */

commit a9cde23ab7cdf5e4e93432dffd0e734267f2b745
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri May 4 15:34:59 2018 -0400

    SUNRPC: Add a ->free_slot transport callout
    
    Refactor: xprtrdma needs to have better control over when RPCs are
    awoken from the backlog queue, so replace xprt_free_slot with a
    transport op callout.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9784e2875e7e..706eef12bbc0 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -127,6 +127,8 @@ struct rpc_xprt_ops {
 	int		(*reserve_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*alloc_slot)(struct rpc_xprt *xprt, struct rpc_task *task);
+	void		(*free_slot)(struct rpc_xprt *xprt,
+				     struct rpc_rqst *req);
 	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
@@ -329,6 +331,8 @@ void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
+void			xprt_free_slot(struct rpc_xprt *xprt,
+				       struct rpc_rqst *req);
 void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);

commit 37ac86c3a76c113619b7d9afe0251bbfc04cb80a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri May 4 15:34:53 2018 -0400

    SUNRPC: Initialize rpc_rqst outside of xprt->reserve_lock
    
    alloc_slot is a transport-specific op, but initializing an rpc_rqst
    is common to all transports. In addition, the only part of initial-
    izing an rpc_rqst that needs serialization is getting a fresh XID.
    
    Move rpc_rqst initialization to common code in preparation for
    adding a transport-specific alloc_slot to xprtrdma.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 5fea0fb420df..9784e2875e7e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -324,6 +324,7 @@ struct xprt_class {
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
+void			xprt_request_init(struct rpc_task *task);
 void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);

commit ff699ea8269a02d977c6ee42d58f76efe83a34f9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Mar 5 15:13:13 2018 -0500

    SUNRPC: Make num_reqs a non-atomic integer
    
    If recording xprt->stat.max_slots is moved into xprt_alloc_slot,
    then xprt->num_reqs is never manipulated outside
    xprt->reserve_lock. There's no longer a need for xprt->num_reqs to
    be atomic.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ad322cec049a..5fea0fb420df 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -197,7 +197,7 @@ struct rpc_xprt {
 	struct list_head	free;		/* free slots */
 	unsigned int		max_reqs;	/* max number of slots */
 	unsigned int		min_reqs;	/* min number of slots */
-	atomic_t		num_reqs;	/* total slots */
+	unsigned int		num_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
 	unsigned char		resvport   : 1; /* use a reserved port */
 	atomic_t		swapper;	/* we're swapping over this

commit ecd465ee88bb6648c06c82b1abae6ec28cf5fccb
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Mar 5 15:12:57 2018 -0500

    SUNRPC: Move xprt_update_rtt callsite
    
    Since commit 33849792cbcd ("xprtrdma: Detect unreachable NFS/RDMA
    servers more reliably"), the xprtrdma transport now has a ->timer
    callout. But xprtrdma does not need to compute RTT data, only UDP
    needs that. Move the xprt_update_rtt call into the UDP transport
    implementation.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7fad83881ce1..ad322cec049a 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -373,6 +373,7 @@ void			xprt_wait_for_buffer_space(struct rpc_task *task, rpc_action action);
 void			xprt_write_space(struct rpc_xprt *xprt);
 void			xprt_adjust_cwnd(struct rpc_xprt *xprt, struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
+void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_pin_rqst(struct rpc_rqst *req);
 void			xprt_unpin_rqst(struct rpc_rqst *req);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 5a7bff41f6b7..7fad83881ce1 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *  linux/include/linux/sunrpc/xprt.h
  *

commit f9773b22a27a4234f436c9570afd62d905e00a13
Merge: 7af7a5963c40 67af6f652f9c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Sep 5 15:16:04 2017 -0400

    Merge tag 'nfs-rdma-for-4.14-1' of git://git.linux-nfs.org/projects/anna/linux-nfs into linux-next
    
    NFS-over-RDMA client updates for Linux 4.14
    
    Bugfixes and cleanups:
    - Constify rpc_xprt_ops
    - Harden RPC call encoding and decoding
    - Clean up rpc call decoding to use xdr_streams
    - Remove unused variables from various structures
    - Refactor code to remove imul instructions
    - Rearrange rx_stats structure for better cacheline sharing

commit ce7c252a8c741aba7c38f817b86e34361f561e42
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Aug 16 15:30:35 2017 -0400

    SUNRPC: Add a separate spinlock to protect the RPC request receive list
    
    This further reduces contention with the transport_lock, and allows us
    to convert to using a non-bh-safe spinlock, since the list is now never
    accessed from a bh context.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 65b9e0224753..a97e6de5f9f2 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -232,6 +232,7 @@ struct rpc_xprt {
 	 */
 	spinlock_t		transport_lock;	/* lock transport info */
 	spinlock_t		reserve_lock;	/* lock slot table */
+	spinlock_t		recv_lock;	/* lock receive list */
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */

commit 729749bb8da186e68d97d1b0439f0b1e0059c41d
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Aug 13 10:03:59 2017 -0400

    SUNRPC: Don't hold the transport lock across socket copy operations
    
    Instead add a mechanism to ensure that the request doesn't disappear
    from underneath us while copying from the socket. We do this by
    preventing xprt_release() from freeing the XDR buffers until the
    flag RPC_TASK_MSG_RECV has been cleared from the request.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index eab1c749e192..65b9e0224753 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -372,6 +372,8 @@ void			xprt_write_space(struct rpc_xprt *xprt);
 void			xprt_adjust_cwnd(struct rpc_xprt *xprt, struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
+void			xprt_pin_rqst(struct rpc_rqst *req);
+void			xprt_unpin_rqst(struct rpc_rqst *req);
 void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);

commit d31ae2548142b7cd12404929ef3a13ae27c9d961
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 1 12:00:39 2017 -0400

    sunrpc: Const-ify all instances of struct rpc_xprt_ops
    
    After transport instance creation, these function pointers never
    change. Mark them as constant to prevent their use as an attack
    vector for code injections.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index eab1c749e192..f60c55ca2e2e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -174,7 +174,7 @@ enum xprt_transports {
 
 struct rpc_xprt {
 	struct kref		kref;		/* Reference count */
-	struct rpc_xprt_ops *	ops;		/* transport methods */
+	const struct rpc_xprt_ops *ops;		/* transport methods */
 
 	const struct rpc_timeout *timeout;	/* timeout parms */
 	struct sockaddr_storage	addr;		/* server address */

commit 7196dbb02ea05835b9ee56910ee82cb55422c7f1
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Wed Feb 8 11:17:54 2017 -0500

    SUNRPC: Allow changing of the TCP timeout parameters on the fly
    
    When the NFSv4 server tells us the lease period, we usually want
    to adjust down the timeout parameters on the TCP connection to
    ensure that we don't miss lease renewals due to a faulty connection.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a5da60b24d83..eab1c749e192 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -137,6 +137,9 @@ struct rpc_xprt_ops {
 	void		(*release_request)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
+	void		(*set_connect_timeout)(struct rpc_xprt *xprt,
+					unsigned long connect_timeout,
+					unsigned long reconnect_timeout);
 	void		(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);
 	int		(*enable_swap)(struct rpc_xprt *xprt);
 	void		(*disable_swap)(struct rpc_xprt *xprt);
@@ -221,6 +224,7 @@ struct rpc_xprt {
 	struct timer_list	timer;
 	unsigned long		last_used,
 				idle_timeout,
+				connect_timeout,
 				max_reconnect_timeout;
 
 	/*

commit 5a6d1db4556940533f1a5b6521e522f3e46508ed
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 15 10:55:45 2016 -0400

    SUNRPC: Add a transport-specific private field in rpc_rqst
    
    Currently there's a hidden and indirect mechanism for finding the
    rpcrdma_req that goes with an rpc_rqst. It depends on getting from
    the rq_buffer pointer in struct rpc_rqst to the struct
    rpcrdma_regbuf that controls that buffer, and then to the struct
    rpcrdma_req it goes with.
    
    This was done back in the day to avoid the need to add a per-rqst
    pointer or to alter the buf_free API when support for RPC-over-RDMA
    was introduced.
    
    I'm about to change the way regbuf's work to support larger inline
    thresholds. Now is a good time to replace this indirect mechanism
    with something that is more straightforward. I guess this should be
    considered a clean up.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 46f069efa056..a5da60b24d83 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -83,6 +83,7 @@ struct rpc_rqst {
 	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
 	struct list_head	rq_list;
 
+	void			*rq_xprtdata;	/* Per-xprt private data */
 	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize;
 	void			*rq_rbuffer;	/* Reply XDR decode buffer */

commit 68778945e46f143ed7974b427a8065f69a4ce944
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 15 10:55:37 2016 -0400

    SUNRPC: Separate buffer pointers for RPC Call and Reply messages
    
    For xprtrdma, the RPC Call and Reply buffers are involved in real
    I/O operations.
    
    To start with, the DMA direction of the I/O for a Call is opposite
    that of a Reply.
    
    In the current arrangement, the Reply buffer address is on a
    four-byte alignment just past the call buffer. Would be friendlier
    on some platforms if that was at a DMA cache alignment instead.
    
    Because the current arrangement allocates a single memory region
    which contains both buffers, the RPC Reply buffer often contains a
    page boundary in it when the Call buffer is large enough (which is
    frequent).
    
    It would be a little nicer for setting up DMA operations (and
    possible registration of the Reply buffer) if the two buffers were
    separated, well-aligned, and contained as few page boundaries as
    possible.
    
    Now, I could just pad out the single memory region used for the pair
    of buffers. But frequently that would mean a lot of unused space to
    ensure the Reply buffer did not have a page boundary.
    
    Add a separate pointer to rpc_rqst that points right to the RPC
    Reply buffer. This makes no difference to xprtsock, but it will help
    xprtrdma in subsequent patches.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 72c2aebc592b..46f069efa056 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -84,8 +84,9 @@ struct rpc_rqst {
 	struct list_head	rq_list;
 
 	void			*rq_buffer;	/* Call XDR encode buffer */
-	size_t			rq_callsize,
-				rq_rcvsize;
+	size_t			rq_callsize;
+	void			*rq_rbuffer;	/* Reply XDR decode buffer */
+	size_t			rq_rcvsize;
 	size_t			rq_xmit_bytes_sent;	/* total bytes sent */
 	size_t			rq_reply_bytes_recvd;	/* total reply bytes */
 							/* received */

commit 3435c74aed2d7b743ccbf34616c523ebee7be943
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 15 10:55:29 2016 -0400

    SUNRPC: Generalize the RPC buffer release API
    
    xprtrdma needs to allocate the Call and Reply buffers separately.
    TBH, the reliance on using a single buffer for the pair of XDR
    buffers is transport implementation-specific.
    
    Instead of passing just the rq_buffer into the buf_free method, pass
    the task structure and let buf_free take care of freeing both
    XDR buffers at once.
    
    There's a micro-optimization here. In the common case, both
    xprt_release and the transport's buf_free method were checking if
    rq_buffer was NULL. Now the check is done only once per RPC.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c01f468fb374..72c2aebc592b 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -128,7 +128,7 @@ struct rpc_xprt_ops {
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
 	int		(*buf_alloc)(struct rpc_task *task);
-	void		(*buf_free)(void *buffer);
+	void		(*buf_free)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);

commit 5fe6eaa1f9a00b9a5927e3b791ecad2f3eaab130
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 15 10:55:20 2016 -0400

    SUNRPC: Generalize the RPC buffer allocation API
    
    xprtrdma needs to allocate the Call and Reply buffers separately.
    TBH, the reliance on using a single buffer for the pair of XDR
    buffers is transport implementation-specific.
    
    Transports that want to allocate separate Call and Reply buffers
    will ignore the "size" argument anyway.  Don't bother passing it.
    
    The buf_alloc method can't return two pointers. Instead, make the
    method's return value an error code, and set the rq_buffer pointer
    in the method itself.
    
    This gives call_allocate an opportunity to terminate an RPC instead
    of looping forever when a permanent problem occurs. If a request is
    just bogus, or the transport is in a state where it can't allocate
    resources for any request, there needs to be a way to kill the RPC
    right there and not loop.
    
    This immediately fixes a rare problem in the backchannel send path,
    which loops if the server happens to send a CB request whose
    call+reply size is larger than a page (which it shouldn't do yet).
    
    One more issue: looks like xprt_inject_disconnect was incorrectly
    placed in the failure path in call_allocate. It needs to be in the
    success path, as it is for other call-sites.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6f1d41b559a3..c01f468fb374 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -127,7 +127,7 @@ struct rpc_xprt_ops {
 	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
-	void *		(*buf_alloc)(struct rpc_task *task, size_t size);
+	int		(*buf_alloc)(struct rpc_task *task);
 	void		(*buf_free)(void *buffer);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);

commit b9c5bc03be6aae41990efd09f83cf70a89ac9f4b
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Sep 15 10:55:12 2016 -0400

    SUNRPC: Refactor rpc_xdr_buf_init()
    
    Clean up: there is some XDR initialization logic that is common
    to the forward channel and backchannel. Move it to an XDR header
    so it can be shared.
    
    rpc_rqst::rq_buffer points to a buffer containing big-endian data.
    Update its annotation as part of the clean up.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a16070dd03ee..6f1d41b559a3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -83,7 +83,7 @@ struct rpc_rqst {
 	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
 	struct list_head	rq_list;
 
-	__u32 *			rq_buffer;	/* XDR encode buffer */
+	void			*rq_buffer;	/* Call XDR encode buffer */
 	size_t			rq_callsize,
 				rq_rcvsize;
 	size_t			rq_xmit_bytes_sent;	/* total bytes sent */

commit 3851f1cdb2b8d507b10395fc110d4c37d6121285
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Aug 4 00:08:45 2016 -0400

    SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout
    
    ...and ensure that we propagate it to new transports on the same
    client.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 5e3e1b63dbb3..a16070dd03ee 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -218,7 +218,8 @@ struct rpc_xprt {
 	struct work_struct	task_cleanup;
 	struct timer_list	timer;
 	unsigned long		last_used,
-				idle_timeout;
+				idle_timeout,
+				max_reconnect_timeout;
 
 	/*
 	 * Send stuff

commit 39a9beab5acb83176e8b9a4f0778749a09341f1f
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue May 17 12:38:21 2016 -0400

    rpc: share one xps between all backchannels
    
    The spec allows backchannels for multiple clients to share the same tcp
    connection.  When that happens, we need to use the same xprt for all of
    them.  Similarly, we need the same xps.
    
    This fixes list corruption introduced by the multipath code.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Acked-by: Trond Myklebust <trondmy@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 5aa3834619a8..5e3e1b63dbb3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -297,6 +297,7 @@ struct xprt_create {
 	size_t			addrlen;
 	const char		*servername;
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
+	struct rpc_xprt_switch	*bc_xps;
 	unsigned int		flags;
 };
 

commit 6b26cc8c8ead3636a18bfd9489984983f4ddd6f4
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 2 14:40:40 2016 -0400

    sunrpc: Advertise maximum backchannel payload size
    
    RPC-over-RDMA transports have a limit on how large a backward
    direction (backchannel) RPC message can be. Ensure that the NFSv4.x
    CREATE_SESSION operation advertises this limit to servers.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Tested-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index fb0d212e0d3a..5aa3834619a8 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -142,6 +142,7 @@ struct rpc_xprt_ops {
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
 	int		(*bc_up)(struct svc_serv *serv, struct net *net);
+	size_t		(*bc_maxpayload)(struct rpc_xprt *xprt);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
 	void		(*bc_destroy)(struct rpc_xprt *xprt,
 				      unsigned int max_reqs);

commit 80b14d5e61ca6d08e46b4fc72baf6e4f738b30ce
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Feb 14 20:31:59 2015 -0500

    SUNRPC: Add a structure to track multiple transports
    
    In order to support multipathing/trunking we will need the ability to
    track multiple transports. This patch sets up a basic structure for
    doing so.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 83218129ff28..fb0d212e0d3a 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -197,6 +197,11 @@ struct rpc_xprt {
 						   transport */
 	unsigned int		bind_index;	/* bind function index */
 
+	/*
+	 * Multipath
+	 */
+	struct list_head	xprt_switch;
+
 	/*
 	 * Connection of transports
 	 */

commit fda1bfef9e465b28260d27cd9e538dd601c4cdc1
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sat Feb 14 17:48:49 2015 -0500

    SUNRPC: Make freeing of struct xprt rcu-safe
    
    Have it call kfree_rcu() to ensure that we can use it on rcu-protected
    lists.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 1bdb59a2efe8..83218129ff28 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -257,6 +257,7 @@ struct rpc_xprt {
 	struct dentry		*debugfs;		/* debugfs directory */
 	atomic_t		inject_disconnect;
 #endif
+	struct rcu_head		rcu;
 };
 
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)

commit 30c5116b113689c87a711a0963753adadd702c04
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Tue Feb 24 20:31:39 2015 -0500

    SUNRPC: Uninline xprt_get(); It isn't performance critical.
    
    Also allow callers to pass NULL arguments to xprt_get() and xprt_put().
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 69ef5b3ab038..1bdb59a2efe8 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -13,6 +13,7 @@
 #include <linux/socket.h>
 #include <linux/in.h>
 #include <linux/ktime.h>
+#include <linux/kref.h>
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
@@ -166,7 +167,7 @@ enum xprt_transports {
 };
 
 struct rpc_xprt {
-	atomic_t		count;		/* Reference count */
+	struct kref		kref;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
 
 	const struct rpc_timeout *timeout;	/* timeout parms */
@@ -318,24 +319,13 @@ int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
+struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
 struct rpc_xprt *	xprt_alloc(struct net *net, size_t size,
 				unsigned int num_prealloc,
 				unsigned int max_req);
 void			xprt_free(struct rpc_xprt *);
 
-/**
- * xprt_get - return a reference to an RPC transport.
- * @xprt: pointer to the transport
- *
- */
-static inline struct rpc_xprt *xprt_get(struct rpc_xprt *xprt)
-{
-	if (atomic_inc_not_zero(&xprt->count))
-		return xprt;
-	return NULL;
-}
-
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
 {
 	return p + xprt->tsh_size;

commit 76566773a1f1c2295ed901b6f1241cfe10d99029
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sat Oct 24 17:28:32 2015 -0400

    NFS: Enable client side NFSv4.1 backchannel to use other transports
    
    Forechannel transports get their own "bc_up" method to create an
    endpoint for the backchannel service.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    [Anna Schumaker: Add forward declaration of struct net to xprt.h]
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 82c083946ef0..69ef5b3ab038 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -54,6 +54,8 @@ enum rpc_display_format_t {
 struct rpc_task;
 struct rpc_xprt;
 struct seq_file;
+struct svc_serv;
+struct net;
 
 /*
  * This describes a complete RPC request
@@ -138,6 +140,7 @@ struct rpc_xprt_ops {
 	void		(*inject_disconnect)(struct rpc_xprt *xprt);
 	int		(*bc_setup)(struct rpc_xprt *xprt,
 				    unsigned int min_reqs);
+	int		(*bc_up)(struct svc_serv *serv, struct net *net);
 	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
 	void		(*bc_destroy)(struct rpc_xprt *xprt,
 				      unsigned int max_reqs);

commit 9468431962616c2449d47c482208a5967e011bf9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sat Oct 24 17:28:16 2015 -0400

    svcrdma: Add backward direction service for RPC/RDMA transport
    
    On NFSv4.1 mount points, the Linux NFS client uses this transport
    endpoint to receive backward direction calls and route replies back
    to the NFSv4.1 server.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3f79c4a4ce74..82c083946ef0 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -158,6 +158,7 @@ enum xprt_transports {
 	XPRT_TRANSPORT_TCP	= IPPROTO_TCP,
 	XPRT_TRANSPORT_BC_TCP	= IPPROTO_TCP | XPRT_TRANSPORT_BC,
 	XPRT_TRANSPORT_RDMA	= 256,
+	XPRT_TRANSPORT_BC_RDMA	= XPRT_TRANSPORT_RDMA | XPRT_TRANSPORT_BC,
 	XPRT_TRANSPORT_LOCAL	= 257,
 };
 

commit 42e5c3e2725ba0c0affc1fc8a6aa1d5cf31ecb75
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sat Oct 24 17:27:35 2015 -0400

    SUNRPC: Abstract backchannel operations
    
    xprt_{setup,destroy}_backchannel() won't be adequate for RPC/RMDA
    bi-direction. In particular, receive buffers have to be pre-
    registered and posted in order to receive incoming backchannel
    requests.
    
    Add a virtual function call to allow the insertion of appropriate
    backchannel setup and destruction methods for each transport.
    
    In addition, freeing a backchannel request is a little different
    for RPC/RDMA. Introduce an rpc_xprt_op to handle the difference.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Tested-By: Devesh Sharma <devesh.sharma@avagotech.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 0fb9acbb4780..3f79c4a4ce74 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -136,6 +136,11 @@ struct rpc_xprt_ops {
 	int		(*enable_swap)(struct rpc_xprt *xprt);
 	void		(*disable_swap)(struct rpc_xprt *xprt);
 	void		(*inject_disconnect)(struct rpc_xprt *xprt);
+	int		(*bc_setup)(struct rpc_xprt *xprt,
+				    unsigned int min_reqs);
+	void		(*bc_free_rqst)(struct rpc_rqst *rqst);
+	void		(*bc_destroy)(struct rpc_xprt *xprt,
+				      unsigned int max_reqs);
 };
 
 /*

commit 4a06825839889cc1756d0dd8a52d6b1071ee0263
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon May 11 14:02:25 2015 -0400

    SUNRPC: Transport fault injection
    
    It has been exceptionally useful to exercise the logic that handles
    local immediate errors and RDMA connection loss.  To enable
    developers to test this regularly and repeatably, add logic to
    simulate connection loss every so often.
    
    Fault injection is disabled by default. It is enabled with
    
      $ sudo echo xxx > /sys/kernel/debug/sunrpc/inject_fault/disconnect
    
    where "xxx" is a large positive number of transport method calls
    before a disconnect. A value of several thousand is usually a good
    number that allows reasonable forward progress while still causing a
    lot of connection drops.
    
    These hooks are disabled when SUNRPC_DEBUG is turned off.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index b6096592b1d4..0fb9acbb4780 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -135,6 +135,7 @@ struct rpc_xprt_ops {
 	void		(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);
 	int		(*enable_swap)(struct rpc_xprt *xprt);
 	void		(*disable_swap)(struct rpc_xprt *xprt);
+	void		(*inject_disconnect)(struct rpc_xprt *xprt);
 };
 
 /*
@@ -244,6 +245,7 @@ struct rpc_xprt {
 	const char		*address_strings[RPC_DISPLAY_MAX];
 #if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
 	struct dentry		*debugfs;		/* debugfs directory */
+	atomic_t		inject_disconnect;
 #endif
 };
 
@@ -445,6 +447,23 @@ static inline int xprt_test_and_set_binding(struct rpc_xprt *xprt)
 	return test_and_set_bit(XPRT_BINDING, &xprt->state);
 }
 
+#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
+extern unsigned int rpc_inject_disconnect;
+static inline void xprt_inject_disconnect(struct rpc_xprt *xprt)
+{
+	if (!rpc_inject_disconnect)
+		return;
+	if (atomic_dec_return(&xprt->inject_disconnect))
+		return;
+	atomic_set(&xprt->inject_disconnect, rpc_inject_disconnect);
+	xprt->ops->inject_disconnect(xprt);
+}
+#else
+static inline void xprt_inject_disconnect(struct rpc_xprt *xprt)
+{
+}
+#endif
+
 #endif /* __KERNEL__*/
 
 #endif /* _LINUX_SUNRPC_XPRT_H */

commit d67fa4d85a2143b46052b2e9ccc6749a4c97b2de
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Wed Jun 3 16:14:29 2015 -0400

    sunrpc: turn swapper_enable/disable functions into rpc_xprt_ops
    
    RDMA xprts don't have a sock_xprt, but an rdma_xprt, so the
    xs_swapper_enable/disable functions will likely oops when fed an RDMA
    xprt. Turn these functions into rpc_xprt_ops so that that doesn't
    occur. For now the RDMA versions are no-ops that just return -EINVAL
    on an attempt to swapon.
    
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9a3308703c15..b6096592b1d4 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -133,6 +133,8 @@ struct rpc_xprt_ops {
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
 	void		(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);
+	int		(*enable_swap)(struct rpc_xprt *xprt);
+	void		(*disable_swap)(struct rpc_xprt *xprt);
 };
 
 /*
@@ -328,6 +330,18 @@ static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *
 	return p + xprt->tsh_size;
 }
 
+static inline int
+xprt_enable_swap(struct rpc_xprt *xprt)
+{
+	return xprt->ops->enable_swap(xprt);
+}
+
+static inline void
+xprt_disable_swap(struct rpc_xprt *xprt)
+{
+	xprt->ops->disable_swap(xprt);
+}
+
 /*
  * Transport switch helper functions
  */
@@ -346,8 +360,6 @@ void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
 void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
-int			xs_swapper_enable(struct rpc_xprt *xprt);
-void			xs_swapper_disable(struct rpc_xprt *xprt);
 
 bool			xprt_lock_connect(struct rpc_xprt *, struct rpc_task *, void *);
 void			xprt_unlock_connect(struct rpc_xprt *, void *);

commit 8e2281330f9930bccf77cf04027ec60b6cc0fb34
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Wed Jun 3 16:14:26 2015 -0400

    sunrpc: make xprt->swapper an atomic_t
    
    Split xs_swapper into enable/disable functions and eliminate the
    "enable" flag.
    
    Currently, it's racy if you have multiple swapon/swapoff operations
    running in parallel over the same xprt. Also fix it so that we only
    set it to a memalloc socket on a 0->1 transition and only clear it
    on a 1->0 transition.
    
    Cc: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bc9c39d6d30d..9a3308703c15 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -180,7 +180,7 @@ struct rpc_xprt {
 	atomic_t		num_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
 	unsigned char		resvport   : 1; /* use a reserved port */
-	unsigned int		swapper;	/* we're swapping over this
+	atomic_t		swapper;	/* we're swapping over this
 						   transport */
 	unsigned int		bind_index;	/* bind function index */
 
@@ -346,7 +346,8 @@ void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
 void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
-int			xs_swapper(struct rpc_xprt *xprt, int enable);
+int			xs_swapper_enable(struct rpc_xprt *xprt);
+void			xs_swapper_disable(struct rpc_xprt *xprt);
 
 bool			xprt_lock_connect(struct rpc_xprt *, struct rpc_task *, void *);
 void			xprt_unlock_connect(struct rpc_xprt *, void *);

commit 0d2a970d0ae55086520e1e58e572a7acd519429c
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Thu Jun 4 15:37:10 2015 -0400

    SUNRPC: Fix a backchannel race
    
    We need to allow the server to send a new request immediately after we've
    replied to the previous one. Right now, there is a window between the
    send and the release of the old request in rpc_put_task(), where the
    server could send us a new backchannel RPC call, and we have no
    request to service it.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8b93ef53df3c..bc9c39d6d30d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -212,7 +212,8 @@ struct rpc_xprt {
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
 						/* process the callback */
-	unsigned int		bc_alloc_count;	/* Total number of preallocs */
+	int			bc_alloc_count;	/* Total number of preallocs */
+	atomic_t		bc_free_slots;
 	spinlock_t		bc_pa_lock;	/* Protects the preallocated
 						 * items */
 	struct list_head	bc_pa_list;	/* List of preallocated

commit 9e2b9f37760e129cee053cc7b6e7288acc2a7134
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Feb 8 19:21:27 2015 -0500

    SUNRPC: Remove the redundant XPRT_CONNECTION_CLOSE flag
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ae39d478a272..8b93ef53df3c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -360,7 +360,6 @@ void			xprt_unlock_connect(struct rpc_xprt *, void *);
 #define XPRT_BOUND		(4)
 #define XPRT_BINDING		(5)
 #define XPRT_CLOSING		(6)
-#define XPRT_CONNECTION_CLOSE	(8)
 #define XPRT_CONGESTED		(9)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)

commit 505936f59f1e4cd0ff92ae5abc7aae64fb74dbdb
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Feb 8 16:00:01 2015 -0500

    SUNRPC: Cleanup to remove remaining uses of XPRT_CONNECTION_ABORT
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 86af854338b5..ae39d478a272 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -360,7 +360,6 @@ void			xprt_unlock_connect(struct rpc_xprt *, void *);
 #define XPRT_BOUND		(4)
 #define XPRT_BINDING		(5)
 #define XPRT_CLOSING		(6)
-#define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
 #define XPRT_CONGESTED		(9)
 

commit 4efdd92c921135175a85452cd41273d9e2788db3
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Feb 8 15:34:28 2015 -0500

    SUNRPC: Remove TCP client connection reset hack
    
    Instead we rely on SO_REUSEPORT to provide the reconnection semantics
    that we need for NFSv2/v3.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 2926e618dbc6..86af854338b5 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -363,7 +363,6 @@ void			xprt_unlock_connect(struct rpc_xprt *, void *);
 #define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
 #define XPRT_CONGESTED		(9)
-#define XPRT_CONNECTION_REUSE	(10)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 718ba5b87343df303017585200ee182e937eabfc
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Sun Feb 8 18:19:25 2015 -0500

    SUNRPC: Add helpers to prevent socket create from racing
    
    The socket lock is currently held by the task that is requesting the
    connection be established. While that is efficient in the case where
    the connection happens quickly, it is racy in the case where it doesn't.
    What we really want is for the connect helper to be able to block access
    to the socket while it is being set up.
    
    This patch does so by arranging to transfer the socket lock from the
    task that is requesting the connect attempt, and then releasing that
    lock once everything is done.
    This scheme also gives us automatic protection against collisions with
    the RPC close code, so we can kill the cancel_delayed_work_sync()
    call in xs_close().
    
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9d27ac45b909..2926e618dbc6 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -347,6 +347,9 @@ void			xprt_force_disconnect(struct rpc_xprt *xprt);
 void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 int			xs_swapper(struct rpc_xprt *xprt, int enable);
 
+bool			xprt_lock_connect(struct rpc_xprt *, struct rpc_task *, void *);
+void			xprt_unlock_connect(struct rpc_xprt *, void *);
+
 /*
  * Reserved bit positions in xprt->state
  */

commit 388f0c776781fe64ce951701bfe712b2182a31f2
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Nov 26 14:44:44 2014 -0500

    sunrpc: add a debugfs rpc_xprt directory with an info file in it
    
    Add a new directory heirarchy under the debugfs sunrpc/ directory:
    
        sunrpc/
            rpc_xprt/
                <xprt id>/
    
    Within that directory, we can put files that give info about the
    xprts. We do have the (minor) problem that there is no succinct,
    unique identifier for rpc_xprts. So we generate them synthetically
    with a static atomic_t counter.
    
    For now, this directory just holds an "info" file, but we may add
    other files to it in the future.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index cf391eef2e6d..9d27ac45b909 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -239,6 +239,9 @@ struct rpc_xprt {
 	struct net		*xprt_net;
 	const char		*servername;
 	const char		*address_strings[RPC_DISPLAY_MAX];
+#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
+	struct dentry		*debugfs;		/* debugfs directory */
+#endif
 };
 
 #if defined(CONFIG_SUNRPC_BACKCHANNEL)

commit a743419f420a64d442280845c0377a915b76644f
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Tue Sep 23 12:26:19 2014 -0400

    SUNRPC: Don't wake tasks during connection abort
    
    When aborting a connection to preserve source ports, don't wake the task in
    xs_error_report.  This allows tasks with RPC_TASK_SOFTCONN to succeed if the
    connection needs to be re-established since it preserves the task's status
    instead of setting it to the status of the aborting kernel_connect().
    
    This may also avoid a potential conflict on the socket's lock.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Cc: stable@vger.kernel.org # 3.14+
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index fcbfe8783243..cf391eef2e6d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -357,6 +357,7 @@ int			xs_swapper(struct rpc_xprt *xprt, int enable);
 #define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
 #define XPRT_CONGESTED		(9)
+#define XPRT_CONNECTION_REUSE	(10)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit d1e1cda862c16252087374ac75949b0e89a5717e
Merge: 07888238f550 a914722f333b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 15:02:42 2014 -0700

    Merge tag 'nfs-for-3.16-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates from Trond Myklebust:
     "Highlights include:
    
       - massive cleanup of the NFS read/write code by Anna and Dros
       - support multiple NFS read/write requests per page in order to deal
         with non-page aligned pNFS striping.  Also cleans up the r/wsize <
         page size code nicely.
       - stable fix for ensuring inode is declared uptodate only after all
         the attributes have been checked.
       - stable fix for a kernel Oops when remounting
       - NFS over RDMA client fixes
       - move the pNFS files layout driver into its own subdirectory"
    
    * tag 'nfs-for-3.16-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (79 commits)
      NFS: populate ->net in mount data when remounting
      pnfs: fix lockup caused by pnfs_generic_pg_test
      NFSv4.1: Fix typo in dprintk
      NFSv4.1: Comment is now wrong and redundant to code
      NFS: Use raw_write_seqcount_begin/end int nfs4_reclaim_open_state
      xprtrdma: Disconnect on registration failure
      xprtrdma: Remove BUG_ON() call sites
      xprtrdma: Avoid deadlock when credit window is reset
      SUNRPC: Move congestion window constants to header file
      xprtrdma: Reset connection timeout after successful reconnect
      xprtrdma: Use macros for reconnection timeout constants
      xprtrdma: Allocate missing pagelist
      xprtrdma: Remove Tavor MTU setting
      xprtrdma: Ensure ia->ri_id->qp is not NULL when reconnecting
      xprtrdma: Reduce the number of hardway buffer allocations
      xprtrdma: Limit work done by completion handler
      xprtrmda: Reduce calls to ib_poll_cq() in completion handlers
      xprtrmda: Reduce lock contention in completion handlers
      xprtrdma: Split the completion queue
      xprtrdma: Make rpcrdma_ep_destroy() return void
      ...

commit 4f4cf5ad6fc1b16dc8dc9d750bb80b35eba5e98d
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Wed May 28 10:34:49 2014 -0400

    SUNRPC: Move congestion window constants to header file
    
    I would like to use one of the RPC client's congestion algorithm
    constants in transport-specific code.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3e5efb2b236e..5903d2c0ab4d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -24,6 +24,12 @@
 #define RPC_MAX_SLOT_TABLE_LIMIT	(65536U)
 #define RPC_MAX_SLOT_TABLE	RPC_MAX_SLOT_TABLE_LIMIT
 
+#define RPC_CWNDSHIFT		(8U)
+#define RPC_CWNDSCALE		(1U << RPC_CWNDSHIFT)
+#define RPC_INITCWND		RPC_CWNDSCALE
+#define RPC_MAXCWND(xprt)	((xprt)->max_reqs << RPC_CWNDSHIFT)
+#define RPCXPRT_CONGESTED(xprt) ((xprt)->cong >= (xprt)->cwnd)
+
 /*
  * This describes a timeout strategy
  */

commit 4e857c58efeb99393cba5a5d0d8ec7117183137c
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 17 18:06:10 2014 +0100

    arch: Mass conversion of smp_mb__*()
    
    Mostly scripted conversion of the smp_mb__* barriers.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-55dhyhocezdw1dg7u19hmh1u@git.kernel.org
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-arch@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3e5efb2b236e..3876f0f1dfd3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -379,9 +379,9 @@ static inline int xprt_test_and_clear_connected(struct rpc_xprt *xprt)
 
 static inline void xprt_clear_connecting(struct rpc_xprt *xprt)
 {
-	smp_mb__before_clear_bit();
+	smp_mb__before_atomic();
 	clear_bit(XPRT_CONNECTING, &xprt->state);
-	smp_mb__after_clear_bit();
+	smp_mb__after_atomic();
 }
 
 static inline int xprt_connecting(struct rpc_xprt *xprt)
@@ -411,9 +411,9 @@ static inline void xprt_clear_bound(struct rpc_xprt *xprt)
 
 static inline void xprt_clear_binding(struct rpc_xprt *xprt)
 {
-	smp_mb__before_clear_bit();
+	smp_mb__before_atomic();
 	clear_bit(XPRT_BINDING, &xprt->state);
-	smp_mb__after_clear_bit();
+	smp_mb__after_atomic();
 }
 
 static inline int xprt_test_and_set_binding(struct rpc_xprt *xprt)

commit d531c008d7d9713456abe3d265fc577bba2e1cef
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Mon Mar 24 11:59:46 2014 +0800

    NFSD/SUNRPC: Check rpc_xprt out of xs_setup_bc_tcp
    
    Besides checking rpc_xprt out of xs_setup_bc_tcp,
    increase it's reference (it's important).
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8097b9df6773..3e5efb2b236e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -295,13 +295,24 @@ int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
-struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
 struct rpc_xprt *	xprt_alloc(struct net *net, size_t size,
 				unsigned int num_prealloc,
 				unsigned int max_req);
 void			xprt_free(struct rpc_xprt *);
 
+/**
+ * xprt_get - return a reference to an RPC transport.
+ * @xprt: pointer to the transport
+ *
+ */
+static inline struct rpc_xprt *xprt_get(struct rpc_xprt *xprt)
+{
+	if (atomic_inc_not_zero(&xprt->count))
+		return xprt;
+	return NULL;
+}
+
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
 {
 	return p + xprt->tsh_size;

commit 90051ea774613ffc6b8aad3dc665c8505d6205a8
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Sep 25 12:17:18 2013 -0400

    SUNRPC: Clean up - convert xprt_prepare_transmit to return a bool
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index cec7b9b5e1bf..8097b9df6773 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -288,7 +288,7 @@ int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
-int			xprt_prepare_transmit(struct rpc_task *task);
+bool			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);

commit 33d90ac0581ce81d1ebfc51918a2757e41a6011c
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Apr 11 15:06:36 2013 -0400

    SUNRPC: allow disabling idle timeout
    
    In the gss-proxy case we don't want to have to reconnect at random--we
    want to connect only on gss-proxy startup when we can steal gss-proxy's
    context to do the connect in the right namespace.
    
    So, provide a flag that allows the rpc_create caller to turn off the
    idle timeout.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ff5392421cb2..cec7b9b5e1bf 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -256,6 +256,7 @@ static inline int bc_prealloc(struct rpc_rqst *req)
 #endif /* CONFIG_SUNRPC_BACKCHANNEL */
 
 #define XPRT_CREATE_INFINITE_SLOTS	(1U)
+#define XPRT_CREATE_NO_IDLE_TIMEOUT	(1U << 1)
 
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */

commit b7993cebb841b0da7a33e9d5ce301a9fd3209165
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Apr 14 11:42:00 2013 -0400

    SUNRPC: Allow rpc_create() to request that TCP slots be unlimited
    
    This is mainly for use by NFSv4.1, where the session negotiation
    ultimately wants to decide how many RPC slots we can fill.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 12815f66a9c4..ff5392421cb2 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -255,6 +255,8 @@ static inline int bc_prealloc(struct rpc_rqst *req)
 }
 #endif /* CONFIG_SUNRPC_BACKCHANNEL */
 
+#define XPRT_CREATE_INFINITE_SLOTS	(1U)
+
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */
 	struct net *		net;
@@ -263,6 +265,7 @@ struct xprt_create {
 	size_t			addrlen;
 	const char		*servername;
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
+	unsigned int		flags;
 };
 
 struct xprt_class {

commit ba60eb25ff6be6f8e60488cdfd454e5c612bce60
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Apr 14 10:49:37 2013 -0400

    SUNRPC: Fix a livelock problem in the xprt->backlog queue
    
    This patch ensures that we throttle new RPC requests if there are
    requests already waiting in the xprt->backlog queue. The reason for
    doing this is to fix livelock issues that can occur when an existing
    (high priority) task is waiting in the backlog queue, gets woken up
    by xprt_free_slot(), but a new task then steals the slot.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 30834be03011..12815f66a9c4 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -279,6 +279,7 @@ struct xprt_class {
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
+void			xprt_retry_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
@@ -334,6 +335,7 @@ int			xs_swapper(struct rpc_xprt *xprt, int enable);
 #define XPRT_CLOSING		(6)
 #define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
+#define XPRT_CONGESTED		(9)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 6a24dfb645dbcb05b34d08b991d082bdaa3ff072
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 8 09:48:15 2013 -0500

    SUNRPC: Pass pointers to struct rpc_xprt to the congestion window
    
    Avoid access to task->tk_xprt
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7dd598a5c9aa..30834be03011 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -122,7 +122,7 @@ struct rpc_xprt_ops {
 	void		(*buf_free)(void *buffer);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
-	void		(*timer)(struct rpc_task *task);
+	void		(*timer)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_request)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
@@ -313,7 +313,7 @@ void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_task *task, rpc_action action);
 void			xprt_write_space(struct rpc_xprt *xprt);
-void			xprt_adjust_cwnd(struct rpc_task *task, int result);
+void			xprt_adjust_cwnd(struct rpc_xprt *xprt, struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);

commit 1b092092bf0e2e8b7af1c2a03f615b4e60b05d47
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 8 09:26:49 2013 -0500

    SUNRPC: Pass a pointer to struct rpc_xprt to the connect callback
    
    Avoid another RCU dereference by passing the pointer to struct rpc_xprt
    from the caller.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 951cb9b7d02b..7dd598a5c9aa 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -117,7 +117,7 @@ struct rpc_xprt_ops {
 	void		(*alloc_slot)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
-	void		(*connect)(struct rpc_task *task);
+	void		(*connect)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void *		(*buf_alloc)(struct rpc_task *task, size_t size);
 	void		(*buf_free)(void *buffer);
 	int		(*send_request)(struct rpc_task *task);

commit d19751e7b9bd8a01d00372325439589886674f79
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Sep 11 17:21:25 2012 -0400

    SUNRPC: Get rid of the redundant xprt->shutdown bit field
    
    It is only set after everyone has dereferenced the transport,
    and serves no useful purpose: setting it is racy, so all the
    socket code, etc still needs to be able to cope with the cases
    where they miss reading it.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bf8c49ff7530..951cb9b7d02b 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -173,8 +173,7 @@ struct rpc_xprt {
 	unsigned int		min_reqs;	/* min number of slots */
 	atomic_t		num_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
-	unsigned char		shutdown   : 1,	/* being shut down */
-				resvport   : 1; /* use a reserved port */
+	unsigned char		resvport   : 1; /* use a reserved port */
 	unsigned int		swapper;	/* we're swapping over this
 						   transport */
 	unsigned int		bind_index;	/* bind function index */

commit f39c1bfb5a03e2d255451bff05be0d7255298fa4
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Sep 7 11:08:50 2012 -0400

    SUNRPC: Fix a UDP transport regression
    
    Commit 43cedbf0e8dfb9c5610eb7985d5f21263e313802 (SUNRPC: Ensure that
    we grab the XPRT_LOCK before calling xprt_alloc_slot) is causing
    hangs in the case of NFS over UDP mounts.
    
    Since neither the UDP or the RDMA transport mechanism use dynamic slot
    allocation, we can skip grabbing the socket lock for those transports.
    Add a new rpc_xprt_op to allow switching between the TCP and UDP/RDMA
    case.
    
    Note that the NFSv4.1 back channel assigns the slot directly
    through rpc_run_bc_task, so we can ignore that case.
    
    Reported-by: Dick Streefland <dick.streefland@altium.nl>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: stable@vger.kernel.org [>= 3.1]

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index cff40aa7db62..bf8c49ff7530 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -114,6 +114,7 @@ struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
 	int		(*reserve_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
+	void		(*alloc_slot)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_task *task);
@@ -281,6 +282,8 @@ void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
+void			xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
+void			xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);

commit a564b8f0398636ba30b07c0eaebdef7ff7837249
Author: Mel Gorman <mgorman@suse.de>
Date:   Tue Jul 31 16:45:12 2012 -0700

    nfs: enable swap on NFS
    
    Implement the new swapfile a_ops for NFS and hook up ->direct_IO.  This
    will set the NFS socket to SOCK_MEMALLOC and run socket reconnect under
    PF_MEMALLOC as well as reset SOCK_MEMALLOC before engaging the protocol
    ->connect() method.
    
    PF_MEMALLOC should allow the allocation of struct socket and related
    objects and the early (re)setting of SOCK_MEMALLOC should allow us to
    receive the packets required for the TCP connection buildup.
    
    [jlayton@redhat.com: Restore PF_MEMALLOC task flags in all cases]
    [dfeng@redhat.com: Fix handling of multiple swap files]
    [a.p.zijlstra@chello.nl: Original patch]
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 77d278defa70..cff40aa7db62 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -174,6 +174,8 @@ struct rpc_xprt {
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
 				resvport   : 1; /* use a reserved port */
+	unsigned int		swapper;	/* we're swapping over this
+						   transport */
 	unsigned int		bind_index;	/* bind function index */
 
 	/*
@@ -316,6 +318,7 @@ void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
 void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
+int			xs_swapper(struct rpc_xprt *xprt, int enable);
 
 /*
  * Reserved bit positions in xprt->state

commit 4e0038b6b246e4145fc4a53dca61a556d17bc52c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 1 17:01:05 2012 -0500

    SUNRPC: Move clnt->cl_server into struct rpc_xprt
    
    When the cl_xprt field is updated, the cl_server field will also have
    to change.  Since the contents of cl_server follow the remote endpoint
    of cl_xprt, just move that field to the rpc_xprt.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    [ cel: simplify check_gss_callback_principal(), whitespace changes ]
    [ cel: forward ported to 3.4 ]
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ea712f97f4a1..77d278defa70 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -229,6 +229,7 @@ struct rpc_xprt {
 	} stat;
 
 	struct net		*xprt_net;
+	const char		*servername;
 	const char		*address_strings[RPC_DISPLAY_MAX];
 };
 
@@ -258,6 +259,7 @@ struct xprt_create {
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;
+	const char		*servername;
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
 };
 

commit 15a4520621824a3c2eb2de2d1f3984bc1663d3c8
Author: Andy Adamson <andros@netapp.com>
Date:   Tue Feb 14 16:19:18 2012 -0500

    SUNRPC: add sending,pending queue and max slot to xprt stats
    
    With static RPC slots, the xprt backlog queue stats were useful in showing
    when the transport (TCP) was starved by lack of RPC slots. The new dynamic
    RPC slot code, commit d9ba131d8f58c0d2ff5029e7002ab43f913b36f9, always
    provides an RPC slot and so only uses the xprt backlog queue when the
    tcp_max_slot_table_entries value has been hit or when an allocation error
    occurs. All requests are now placed on the xprt sending or pending queue which
    need to be monitored for debugging.
    
    The max_slot stat shows the maximum number of dynamic RPC slots reached which is
    useful when debugging performance issues.
    
    Add the new fields at the end of the mountstats xprt stanza so that mountstats
    outputs the previous correct values and ignores the new fields. Bump
    NFS_IOSTATS_VERS.
    
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index b033f366d5f6..ea712f97f4a1 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -219,10 +219,13 @@ struct rpc_xprt {
 					connect_time,	/* jiffies waiting for connect */
 					sends,		/* how many complete requests */
 					recvs,		/* how many complete requests */
-					bad_xids;	/* lookup_rqst didn't find XID */
+					bad_xids,	/* lookup_rqst didn't find XID */
+					max_slots;	/* max rpc_slots used */
 
 		unsigned long long	req_u,		/* average requests on the wire */
-					bklog_u;	/* backlog queue utilization */
+					bklog_u,	/* backlog queue utilization */
+					sending_u,	/* send q utilization */
+					pending_u;	/* pend q utilization */
 	} stat;
 
 	struct net		*xprt_net;

commit 883381246c5ac2c29b849fe619f55fa5961ee76d
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Feb 6 15:18:48 2012 -0500

    SUNRPC: Change the default limit to the number of TCP slots
    
    Since the scheme of limiting the number of TCP slots to whatever will
    fit in the current TCP window seems to be working well (Andy reports
    getting within 20% of the 'iperf' send performance on a 10GigE link)
    we should just let that be the default mode of operation.
    
    Users may still set their own limits using the tcp_max_slot_table_entries
    parameter if they need to.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 15518a152ac3..b033f366d5f6 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -21,8 +21,8 @@
 
 #define RPC_MIN_SLOT_TABLE	(2U)
 #define RPC_DEF_SLOT_TABLE	(16U)
-#define RPC_MAX_SLOT_TABLE	(128U)
 #define RPC_MAX_SLOT_TABLE_LIMIT	(65536U)
+#define RPC_MAX_SLOT_TABLE	RPC_MAX_SLOT_TABLE_LIMIT
 
 /*
  * This describes a timeout strategy

commit 34006cee28f7344f9557a4be3816c7891b1bbab1
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jul 17 18:11:34 2011 -0400

    SUNRPC: Replace xprt->resend and xprt->sending with a priority queue
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d02762d1de27..15518a152ac3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -165,7 +165,6 @@ struct rpc_xprt {
 
 	struct rpc_wait_queue	binding;	/* requests waiting on rpcbind */
 	struct rpc_wait_queue	sending;	/* requests waiting to send */
-	struct rpc_wait_queue	resend;		/* requests waiting to resend */
 	struct rpc_wait_queue	pending;	/* requests in flight */
 	struct rpc_wait_queue	backlog;	/* waiting for slot */
 	struct list_head	free;		/* free slots */

commit d9ba131d8f58c0d2ff5029e7002ab43f913b36f9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jul 17 18:11:30 2011 -0400

    SUNRPC: Support dynamic slot allocation for TCP connections
    
    Allow the number of available slots to grow with the TCP window size.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 05047250f218..d02762d1de27 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -22,6 +22,7 @@
 #define RPC_MIN_SLOT_TABLE	(2U)
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE	(128U)
+#define RPC_MAX_SLOT_TABLE_LIMIT	(65536U)
 
 /*
  * This describes a timeout strategy
@@ -168,7 +169,9 @@ struct rpc_xprt {
 	struct rpc_wait_queue	pending;	/* requests in flight */
 	struct rpc_wait_queue	backlog;	/* waiting for slot */
 	struct list_head	free;		/* free slots */
-	unsigned int		max_reqs;	/* total slots */
+	unsigned int		max_reqs;	/* max number of slots */
+	unsigned int		min_reqs;	/* min number of slots */
+	atomic_t		num_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
 				resvport   : 1; /* use a reserved port */
@@ -281,7 +284,9 @@ void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
 struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
-struct rpc_xprt *	xprt_alloc(struct net *net, int size, int max_req);
+struct rpc_xprt *	xprt_alloc(struct net *net, size_t size,
+				unsigned int num_prealloc,
+				unsigned int max_req);
 void			xprt_free(struct rpc_xprt *);
 
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)

commit 21de0a955f3af29fa1100d96f66e6adade89e77a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jul 17 16:57:32 2011 -0400

    SUNRPC: Clean up the slot table allocation
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a876882fb923..05047250f218 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -168,7 +168,6 @@ struct rpc_xprt {
 	struct rpc_wait_queue	pending;	/* requests in flight */
 	struct rpc_wait_queue	backlog;	/* waiting for slot */
 	struct list_head	free;		/* free slots */
-	struct rpc_rqst *	slot;		/* slot table storage */
 	unsigned int		max_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
@@ -321,7 +320,6 @@ void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 #define XPRT_CLOSING		(6)
 #define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
-#define XPRT_INITIALIZED	(9)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 43cedbf0e8dfb9c5610eb7985d5f21263e313802
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Jul 17 16:01:03 2011 -0400

    SUNRPC: Ensure that we grab the XPRT_LOCK before calling xprt_alloc_slot
    
    This throttles the allocation of new slots when the socket is busy
    reconnecting and/or is out of buffer space.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 217b0206581b..a876882fb923 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -111,7 +111,7 @@ struct rpc_rqst {
 
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
-	int		(*reserve_xprt)(struct rpc_task *task);
+	int		(*reserve_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
@@ -271,8 +271,8 @@ struct xprt_class {
 struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
-int			xprt_reserve_xprt(struct rpc_task *task);
-int			xprt_reserve_xprt_cong(struct rpc_task *task);
+int			xprt_reserve_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
+int			xprt_reserve_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 void			xprt_end_transmit(struct rpc_task *task);

commit 9e00abc3c20904fd6a5d888bb7023925799ec8a5
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jul 13 19:20:49 2011 -0400

    SUNRPC: sunrpc should not explicitly depend on NFS config options
    
    Change explicit references to CONFIG_NFS_V4_1 to implicit ones
    Get rid of the unnecessary defines in backchannel_rqst.c and
    bc_svc.c: the Makefile takes care of those dependency.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 81cce3b3ee66..217b0206581b 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -100,11 +100,11 @@ struct rpc_rqst {
 	ktime_t			rq_xtime;	/* transmit time stamp */
 	int			rq_ntrans;
 
-#if defined(CONFIG_NFS_V4_1)
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	struct list_head	rq_bc_list;	/* Callback service list */
 	unsigned long		rq_bc_pa_state;	/* Backchannel prealloc state */
 	struct list_head	rq_bc_pa_list;	/* Backchannel prealloc list */
-#endif /* CONFIG_NFS_V4_1 */
+#endif /* CONFIG_SUNRPC_BACKCHANEL */
 };
 #define rq_svec			rq_snd_buf.head
 #define rq_slen			rq_snd_buf.len
@@ -200,7 +200,7 @@ struct rpc_xprt {
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
 	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
-#if defined(CONFIG_NFS_V4_1)
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
 						/* process the callback */
 	unsigned int		bc_alloc_count;	/* Total number of preallocs */
@@ -208,7 +208,7 @@ struct rpc_xprt {
 						 * items */
 	struct list_head	bc_pa_list;	/* List of preallocated
 						 * backchannel rpc_rqst's */
-#endif /* CONFIG_NFS_V4_1 */
+#endif /* CONFIG_SUNRPC_BACKCHANNEL */
 	struct list_head	recv;
 
 	struct {
@@ -228,15 +228,15 @@ struct rpc_xprt {
 	const char		*address_strings[RPC_DISPLAY_MAX];
 };
 
-#if defined(CONFIG_NFS_V4_1)
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 /*
  * Backchannel flags
  */
 #define	RPC_BC_PA_IN_USE	0x0001		/* Preallocated backchannel */
 						/* buffer in use */
-#endif /* CONFIG_NFS_V4_1 */
+#endif /* CONFIG_SUNRPC_BACKCHANNEL */
 
-#if defined(CONFIG_NFS_V4_1)
+#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 static inline int bc_prealloc(struct rpc_rqst *req)
 {
 	return test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state);
@@ -246,7 +246,7 @@ static inline int bc_prealloc(struct rpc_rqst *req)
 {
 	return 0;
 }
-#endif /* CONFIG_NFS_V4_1 */
+#endif /* CONFIG_SUNRPC_BACKCHANNEL */
 
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */

commit 176e21ee2ec89cae8d45cf1a850ea45a45428fb8
Author: Chuck Lever <chuck.lever@ORACLE.COM>
Date:   Mon May 9 15:22:44 2011 -0400

    SUNRPC: Support for RPC over AF_LOCAL transports
    
    TI-RPC introduces the capability of performing RPC over AF_LOCAL
    sockets.  It uses this mainly for registering and unregistering
    local RPC services securely with the local rpcbind, but we could
    also conceivably use it as a generic upcall mechanism.
    
    This patch provides a client-side only implementation for the moment.
    We might also consider a server-side implementation to provide
    AF_LOCAL access to NLM (for statd downcalls, and such like).
    
    Autobinding is not supported on kernel AF_LOCAL transports at this
    time.  Kernel ULPs must specify the pathname of the remote endpoint
    when an AF_LOCAL transport is created.  rpcbind supports registering
    services available via AF_LOCAL, so the kernel could handle it with
    some adjustment to ->rpcbind and ->set_port.  But we don't need this
    feature for doing upcalls via well-known named sockets.
    
    This has not been tested with ULPs that move a substantial amount of
    data.  Thus, I can't attest to how robust the write_space and
    congestion management logic is.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a0f998c07c65..81cce3b3ee66 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -141,7 +141,8 @@ enum xprt_transports {
 	XPRT_TRANSPORT_UDP	= IPPROTO_UDP,
 	XPRT_TRANSPORT_TCP	= IPPROTO_TCP,
 	XPRT_TRANSPORT_BC_TCP	= IPPROTO_TCP | XPRT_TRANSPORT_BC,
-	XPRT_TRANSPORT_RDMA	= 256
+	XPRT_TRANSPORT_RDMA	= 256,
+	XPRT_TRANSPORT_LOCAL	= 257,
 };
 
 struct rpc_xprt {

commit a8de240a9074b72b156d9e6d53f00076e6cd5f03
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Mar 15 19:56:30 2011 -0400

    SUNRPC: Convert struct rpc_xprt to use atomic_t counters
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bef0f535f746..a0f998c07c65 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -12,7 +12,6 @@
 #include <linux/uio.h>
 #include <linux/socket.h>
 #include <linux/in.h>
-#include <linux/kref.h>
 #include <linux/ktime.h>
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
@@ -146,7 +145,7 @@ enum xprt_transports {
 };
 
 struct rpc_xprt {
-	struct kref		kref;		/* Reference count */
+	atomic_t		count;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
 
 	const struct rpc_timeout *timeout;	/* timeout parms */

commit f0418aa4b1103f959d64dc18273efa04ee0140e9
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Dec 8 13:48:19 2010 -0500

    rpc: allow xprt_class->setup to return a preexisting xprt
    
    This allows us to reuse the xprt associated with a server connection if
    one has already been set up.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 89d10d279a20..bef0f535f746 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -321,6 +321,7 @@ void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 #define XPRT_CLOSING		(6)
 #define XPRT_CONNECTION_ABORT	(7)
 #define XPRT_CONNECTION_CLOSE	(8)
+#define XPRT_INITIALIZED	(9)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 37aa2133731d9231eb834f700119f0d3f1ed2664
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:05:43 2010 +0400

    sunrpc: Tag rpc_xprt with net
    
    The net is known from the xprt_create and this tagging will also
    give un the context in the conntection workers where real sockets
    are created.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c4f931597d0e..89d10d279a20 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -224,6 +224,7 @@ struct rpc_xprt {
 					bklog_u;	/* backlog queue utilization */
 	} stat;
 
+	struct net		*xprt_net;
 	const char		*address_strings[RPC_DISPLAY_MAX];
 };
 
@@ -281,7 +282,7 @@ void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
 struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
-struct rpc_xprt *	xprt_alloc(int size, int max_req);
+struct rpc_xprt *	xprt_alloc(struct net *net, int size, int max_req);
 void			xprt_free(struct rpc_xprt *);
 
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)

commit 9a23e332ec621d36e52cc7a978abc0917067b1aa
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:05:12 2010 +0400

    sunrpc: Add net to xprt_create
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index af4b560f0794..c4f931597d0e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -249,6 +249,7 @@ static inline int bc_prealloc(struct rpc_rqst *req)
 
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */
+	struct net *		net;
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;

commit e204e621b4160c802315bc2d0fa335337c0d62e8
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:03:13 2010 +0400

    sunrpc: Factor out rpc_xprt freeing
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 00f6e3fe2900..af4b560f0794 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -281,6 +281,7 @@ void			xprt_release(struct rpc_task *task);
 struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
 struct rpc_xprt *	xprt_alloc(int size, int max_req);
+void			xprt_free(struct rpc_xprt *);
 
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
 {

commit bd1722d4316e42a12fe6337ebe34d7e1e2c088b2
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:02:43 2010 +0400

    sunrpc: Factor out rpc_xprt allocation
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ff5a77b28c50..00f6e3fe2900 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -280,6 +280,7 @@ void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
 struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
+struct rpc_xprt *	xprt_alloc(int size, int max_req);
 
 static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
 {

commit a17c2153d2e271b0cbacae9bed83b0eaa41db7e1
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jul 31 14:29:08 2010 -0400

    SUNRPC: Move the bound cred to struct rpc_rqst
    
    This will allow us to save the original generic cred in rpc_message, so
    that if we migrate from one server to another, we can generate a new bound
    cred without having to punt back to the NFS layer.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index b51470302399..ff5a77b28c50 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -64,6 +64,7 @@ struct rpc_rqst {
 	 * This is the private part
 	 */
 	struct rpc_task *	rq_task;	/* RPC task data */
+	struct rpc_cred *	rq_cred;	/* Bound cred */
 	__be32			rq_xid;		/* request XID */
 	int			rq_cong;	/* has incremented xprt->cong */
 	u32			rq_seqno;	/* gss seq no. used on req. */

commit d60dbb20a74c2cfa142be0a34dac3c6547ea086c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu May 13 12:51:49 2010 -0400

    SUNRPC: Move the task->tk_bytes_sent and tk_rtt to struct rpc_rqst
    
    It seems strange to maintain stats for bytes_sent in one structure, and
    bytes received in another. Try to assemble all the RPC request-related
    stats in struct rpc_rqst
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index f8851861b744..b51470302399 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -66,8 +66,6 @@ struct rpc_rqst {
 	struct rpc_task *	rq_task;	/* RPC task data */
 	__be32			rq_xid;		/* request XID */
 	int			rq_cong;	/* has incremented xprt->cong */
-	int			rq_reply_bytes_recvd;	/* number of reply */
-							/* bytes received */
 	u32			rq_seqno;	/* gss seq no. used on req. */
 	int			rq_enc_pages_num;
 	struct page		**rq_enc_pages;	/* scratch pages for use by
@@ -78,12 +76,16 @@ struct rpc_rqst {
 	__u32 *			rq_buffer;	/* XDR encode buffer */
 	size_t			rq_callsize,
 				rq_rcvsize;
+	size_t			rq_xmit_bytes_sent;	/* total bytes sent */
+	size_t			rq_reply_bytes_recvd;	/* total reply bytes */
+							/* received */
 
 	struct xdr_buf		rq_private_buf;		/* The receive buffer
 							 * used in the softirq.
 							 */
 	unsigned long		rq_majortimeo;	/* major timeout alarm */
 	unsigned long		rq_timeout;	/* Current timeout value */
+	ktime_t			rq_rtt;		/* round-trip time */
 	unsigned int		rq_retries;	/* # of retries */
 	unsigned int		rq_connect_cookie;
 						/* A cookie used to track the

commit ff8399709e41bf72b4cb145612a0f9a9f7283c83
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri May 7 13:34:47 2010 -0400

    SUNRPC: Replace jiffies-based metrics with ktime-based metrics
    
    Currently RPC performance metrics that tabulate elapsed time use
    jiffies time values.  This is problematic on systems that use slow
    jiffies (for instance 100HZ systems built for paravirtualized
    environments).  It is also a problem for computing precise latency
    statistics for advanced network transports, such as InfiniBand,
    that can have round-trip latencies significanly faster than a single
    clock tick.
    
    For the RPC client, adopt the high resolution time stamp mechanism
    already used by the network layer and blktrace: ktime.
    
    We use ktime format time stamps for all internal computations, and
    convert to milliseconds for presentation.  As a result, we need only
    addition operations in the performance critical paths; multiply/divide
    is required only for presentation.
    
    We could report RTT metrics in microseconds.  In fact the mountstats
    format is versioned to accomodate exactly this kind of interface
    improvement.
    
    For now, however, we'll stay with millisecond precision for
    presentation to maintain backwards compatibility with the handful of
    currently deployed user space tools.  At a later point, we'll move to
    an API such as BDI_STATS where a finer timestamp precision can be
    reported.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 04fc342d9840..f8851861b744 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -13,6 +13,7 @@
 #include <linux/socket.h>
 #include <linux/in.h>
 #include <linux/kref.h>
+#include <linux/ktime.h>
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
@@ -94,7 +95,7 @@ struct rpc_rqst {
 	 */
 	u32			rq_bytes_sent;	/* Bytes we have sent */
 
-	unsigned long		rq_xtime;	/* when transmitted */
+	ktime_t			rq_xtime;	/* transmit time stamp */
 	int			rq_ntrans;
 
 #if defined(CONFIG_NFS_V4_1)

commit bbc72cea58f671665b6362be0d4e391813ac0eee
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri May 7 13:34:27 2010 -0400

    SUNRPC: RPC metrics and RTT estimator should use same RTT value
    
    Compute an RPC request's RTT once, and use that value both for reporting
    RPC metrics, and for adjusting the RTT context used by the RPC client's RTT
    estimator algorithm.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8263f7aefedf..04fc342d9840 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -293,7 +293,6 @@ void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_task *task, rpc_action action);
 void			xprt_write_space(struct rpc_xprt *xprt);
-void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_adjust_cwnd(struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);

commit a8ce4a8f37fef0a09a1e920c2e09f67a80426c7e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Apr 16 16:42:12 2010 -0400

    SUNRPC: Fail over more quickly on connect errors
    
    We should not allow soft tasks to wait for longer than the major timeout
    period when waiting for a reconnect to occur.
    
    Remove the field xprt->connect_timeout since it has been obsoleted by
    xprt->reestablish_timeout.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6f9457a75b8f..8263f7aefedf 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -174,8 +174,7 @@ struct rpc_xprt {
 	/*
 	 * Connection of transports
 	 */
-	unsigned long		connect_timeout,
-				bind_timeout,
+	unsigned long		bind_timeout,
 				reestablish_timeout;
 	unsigned int		connect_cookie;	/* A cookie that gets bumped
 						   every time the transport

commit f300baba5a1536070d6d77bf0c8c4ca999bb4f0f
Author: Alexandros Batsakis <batsakis@netapp.com>
Date:   Thu Sep 10 17:33:30 2009 +0300

    nfsd41: sunrpc: add new xprt class for nfsv4.1 backchannel
    
    [sunrpc: change idle timeout value for the backchannel]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 228d694dbb90..6f9457a75b8f 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -124,6 +124,23 @@ struct rpc_xprt_ops {
 	void		(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);
 };
 
+/*
+ * RPC transport identifiers
+ *
+ * To preserve compatibility with the historical use of raw IP protocol
+ * id's for transport selection, UDP and TCP identifiers are specified
+ * with the previous values. No such restriction exists for new transports,
+ * except that they may not collide with these values (17 and 6,
+ * respectively).
+ */
+#define XPRT_TRANSPORT_BC       (1 << 31)
+enum xprt_transports {
+	XPRT_TRANSPORT_UDP	= IPPROTO_UDP,
+	XPRT_TRANSPORT_TCP	= IPPROTO_TCP,
+	XPRT_TRANSPORT_BC_TCP	= IPPROTO_TCP | XPRT_TRANSPORT_BC,
+	XPRT_TRANSPORT_RDMA	= 256
+};
+
 struct rpc_xprt {
 	struct kref		kref;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
@@ -232,6 +249,7 @@ struct xprt_create {
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;
+	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
 };
 
 struct xprt_class {

commit 4cfc7e6019caa3e97d2a81c48c8d575d7b38d751
Author: Rahul Iyer <iyer@netapp.com>
Date:   Thu Sep 10 17:32:28 2009 +0300

    nfsd41: sunrpc: Added rpc server-side backchannel handling
    
    When the call direction is a reply, copy the xid and call direction into the
    req->rq_private_buf.head[0].iov_base otherwise rpc_verify_header returns
    rpc_garbage.
    
    Signed-off-by: Rahul Iyer <iyer@netapp.com>
    Signed-off-by: Mike Sager <sager@netapp.com>
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [get rid of CONFIG_NFSD_V4_1]
    [sunrpc: refactoring of svc_tcp_recvfrom]
    [nfsd41: sunrpc: create common send routine for the fore and the back channels]
    [nfsd41: sunrpc: Use free_page() to free server backchannel pages]
    [nfsd41: sunrpc: Document server backchannel locking]
    [nfsd41: sunrpc: remove bc_connect_worker()]
    [nfsd41: sunrpc: Define xprt_server_backchannel()[
    [nfsd41: sunrpc: remove bc_close and bc_init_auto_disconnect dummy functions]
    [nfsd41: sunrpc: eliminate unneeded switch statement in xs_setup_tcp()]
    [nfsd41: sunrpc: Don't auto close the server backchannel connection]
    [nfsd41: sunrpc: Remove unused functions]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfsd41: change bc_sock to bc_xprt]
    [nfsd41: sunrpc: move struct rpc_buffer def into a common header file]
    [nfsd41: sunrpc: use rpc_sleep in bc_send_request so not to block on mutex]
    [removed cosmetic changes]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [sunrpc: add new xprt class for nfsv4.1 backchannel]
    [sunrpc: v2.1 change handling of auto_close and init_auto_disconnect operations for the nfsv4.1 backchannel]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    [reverted more cosmetic leftovers]
    [got rid of xprt_server_backchannel]
    [separated "nfsd41: sunrpc: add new xprt class for nfsv4.1 backchannel"]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Cc: Trond Myklebust <trond.myklebust@netapp.com>
    [sunrpc: change idle timeout value for the backchannel]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Acked-by: Trond Myklebust <trond.myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c090df442572..228d694dbb90 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -179,6 +179,7 @@ struct rpc_xprt {
 	spinlock_t		reserve_lock;	/* lock slot table */
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
+	struct svc_xprt		*bc_xprt;	/* NFSv4.1 backchannel */
 #if defined(CONFIG_NFS_V4_1)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
 						/* process the callback */

commit c740eff84bcfd63c0497ef880e80171931cb8222
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:46 2009 -0400

    SUNRPC: Kill RPC_DISPLAY_ALL
    
    At some point, I recall that rpc_pipe_fs used RPC_DISPLAY_ALL.
    Currently there are no uses of RPC_DISPLAY_ALL outside the transport
    modules themselves, so we can safely get rid of it.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 65fad9534d93..c090df442572 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -38,7 +38,6 @@ enum rpc_display_format_t {
 	RPC_DISPLAY_ADDR = 0,
 	RPC_DISPLAY_PORT,
 	RPC_DISPLAY_PROTO,
-	RPC_DISPLAY_ALL,
 	RPC_DISPLAY_HEX_ADDR,
 	RPC_DISPLAY_HEX_PORT,
 	RPC_DISPLAY_NETID,

commit ba809130bc260fce04141aca01ef9e068d32af2a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Sun Aug 9 15:09:35 2009 -0400

    SUNRPC: Remove duplicate universal address generation
    
    RPC universal address generation is currently done in several places:
    rpcb_clnt.c, nfs4proc.c xprtsock.c, and xprtrdma.c.  Remove the
    redundant cases that convert a socket address to a universal
    address.  The nfs4proc.c case takes a pre-formatted presentation
    address string, not a socket address, so we'll leave that one.
    
    Because the new uaddr constructor uses the recently introduced
    rpc_ntop(), it now supports proper "::" shorthanding for IPv6
    addresses.  This allows the kernel to register properly formed
    universal addresses with the local rpcbind service, in _all_ cases.
    
    The kernel can now also send properly formed universal addresses in
    RPCB_GETADDR requests, and support link-local properly when
    encoding and decoding IPv6 addresses.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 1175d58efc2e..65fad9534d93 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -41,7 +41,6 @@ enum rpc_display_format_t {
 	RPC_DISPLAY_ALL,
 	RPC_DISPLAY_HEX_ADDR,
 	RPC_DISPLAY_HEX_PORT,
-	RPC_DISPLAY_UNIVERSAL_ADDR,
 	RPC_DISPLAY_NETID,
 	RPC_DISPLAY_MAX,
 };

commit dd2b63d049480979016b959abc2d141cdddb1389
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Wed Apr 1 09:23:28 2009 -0400

    nfs41: Rename rq_received to rq_reply_bytes_recvd
    
    The 'rq_received' member of 'struct rpc_rqst' is used to track when we
    have received a reply to our request.  With v4.1, the backchannel
    can now accept callback requests over the existing connection.  Rename
    this field to make it clear that it is only used for tracking reply bytes
    and not all bytes received on the connection.
    
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 55c6c37e249e..1175d58efc2e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -67,7 +67,8 @@ struct rpc_rqst {
 	struct rpc_task *	rq_task;	/* RPC task data */
 	__be32			rq_xid;		/* request XID */
 	int			rq_cong;	/* has incremented xprt->cong */
-	int			rq_received;	/* receive completed */
+	int			rq_reply_bytes_recvd;	/* number of reply */
+							/* bytes received */
 	u32			rq_seqno;	/* gss seq no. used on req. */
 	int			rq_enc_pages_num;
 	struct page		**rq_enc_pages;	/* scratch pages for use by

commit 55ae1aabfb108106dd095de2578ceef1c755a8b8
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Wed Apr 1 09:23:03 2009 -0400

    nfs41: Add backchannel processing support to RPC state machine
    
    Adds rpc_run_bc_task() which is called by the NFS callback service to
    process backchannel requests.  It performs similar work to rpc_run_task()
    though "schedules" the backchannel task to be executed starting at the
    call_trasmit state in the RPC state machine.
    
    It also introduces some miscellaneous updates to the argument validation,
    call_transmit, and transport cleanup functions to take into account
    that there are now forechannel and backchannel tasks.
    
    Backchannel requests do not carry an RPC message structure, since the
    payload has already been XDR encoded using the existing NFSv4 callback
    mechanism.
    
    Introduce a new transmit state for the client to reply on to backchannel
    requests.  This new state simply reserves the transport and issues the
    reply.  In case of a connection related error, disconnects the transport and
    drops the reply.  It requires the forechannel to re-establish the connection
    and the server to retransmit the request, as stated in NFSv4.1 section
    2.9.2 "Client and Server Transport Behavior".
    
    Note: There is no need to loop attempting to reserve the transport.  If EAGAIN
    is returned by xprt_prepare_transmit(), return with tk_status == 0,
    setting tk_action to call_bc_transmit.  rpc_execute() will invoke it again
    after the task is taken off the sleep queue.
    
    [nfs41: rpc_run_bc_task() need not be exported outside RPC module]
    [nfs41: New call_bc_transmit RPC state]
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfs41: Backchannel: No need to loop in call_bc_transmit()]
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [rpc_count_iostats incorrectly exits early]
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Convert rpc_reply_expected() to inline function]
    [Remove unnecessary BUG_ON()]
    [Rename variable]
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index beae030e80b5..55c6c37e249e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -215,6 +215,18 @@ struct rpc_xprt {
 						/* buffer in use */
 #endif /* CONFIG_NFS_V4_1 */
 
+#if defined(CONFIG_NFS_V4_1)
+static inline int bc_prealloc(struct rpc_rqst *req)
+{
+	return test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state);
+}
+#else
+static inline int bc_prealloc(struct rpc_rqst *req)
+{
+	return 0;
+}
+#endif /* CONFIG_NFS_V4_1 */
+
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */
 	struct sockaddr *	srcaddr;	/* optional local address */

commit fb7a0b9addbdbbb13b7bc02abf55ee524ea19ce1
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Wed Apr 1 09:23:00 2009 -0400

    nfs41: New backchannel helper routines
    
    This patch introduces support to setup the callback xprt on the client side.
    It allocates/ destroys the preallocated memory structures used to process
    backchannel requests.
    
    At setup time, xprt_setup_backchannel() is invoked to allocate one or
    more rpc_rqst structures and substructures.  This ensures that they
    are available when an RPC callback arrives.  The rpc_rqst structures
    are maintained in a linked list attached to the rpc_xprt structure.
    We keep track of the number of allocations so that they can be correctly
    removed when the channel is destroyed.
    
    When an RPC callback arrives, xprt_alloc_bc_request() is invoked to
    obtain a preallocated rpc_rqst structure.  An rpc_xprt structure is
    returned, and its RPC_BC_PREALLOC_IN_USE bit is set in
    rpc_xprt->bc_flags.  The structure is removed from the the list
    since it is now in use, and it will be later added back when its
    user is done with it.
    
    After the RPC callback replies, the rpc_rqst structure is returned
    by invoking xprt_free_bc_request().  This clears the
    RPC_BC_PREALLOC_IN_USE bit and adds it back to the list, allowing it
    to be reused by a subsequent RPC callback request.
    
    To be consistent with the reception of RPC messages, the backchannel requests
    should be placed into the 'struct rpc_rqst' rq_rcv_buf, which is then in turn
    copied to the 'struct rpc_rqst' rq_private_buf.
    
    [nfs41: Preallocate rpc_rqst receive buffer for handling callbacks]
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [Update copyright notice and explain page allocation]
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 703af7ebf6cf..beae030e80b5 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -183,6 +183,7 @@ struct rpc_xprt {
 #if defined(CONFIG_NFS_V4_1)
 	struct svc_serv		*bc_serv;       /* The RPC service which will */
 						/* process the callback */
+	unsigned int		bc_alloc_count;	/* Total number of preallocs */
 	spinlock_t		bc_pa_lock;	/* Protects the preallocated
 						 * items */
 	struct list_head	bc_pa_list;	/* List of preallocated

commit 56632b5bff5af10eb12d7e9499b5ffcadcb7a7b2
Author: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
Date:   Wed Apr 1 09:22:58 2009 -0400

    nfs41: client callback structures
    
    Adds new list of rpc_xprt structures, and a readers/writers lock to
    protect the list.  The list is used to preallocate resources for
    the backchannel during backchannel requests.  Callbacks are not
    expected to cause significant latency, so only one callback will
    be allowed at this time.
    
    It also adds a pointer to the NFS callback service so that
    requests can be directed to it for processing.
    
    New callback members added to svc_serv. The NFSv4.1 callback service will
    sleep on the svc_serv->svc_cb_waitq until new callback requests arrive.
    The request will be queued in svc_serv->svc_cb_list. This patch adds this
    list, the sleep queue and spinlock to svc_serv.
    
    [nfs41: NFSv4.1 callback support]
    Signed-off-by: Ricardo Labiaga <ricardo.labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 08afe43118f4..703af7ebf6cf 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -97,6 +97,12 @@ struct rpc_rqst {
 
 	unsigned long		rq_xtime;	/* when transmitted */
 	int			rq_ntrans;
+
+#if defined(CONFIG_NFS_V4_1)
+	struct list_head	rq_bc_list;	/* Callback service list */
+	unsigned long		rq_bc_pa_state;	/* Backchannel prealloc state */
+	struct list_head	rq_bc_pa_list;	/* Backchannel prealloc list */
+#endif /* CONFIG_NFS_V4_1 */
 };
 #define rq_svec			rq_snd_buf.head
 #define rq_slen			rq_snd_buf.len
@@ -174,6 +180,14 @@ struct rpc_xprt {
 	spinlock_t		reserve_lock;	/* lock slot table */
 	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
+#if defined(CONFIG_NFS_V4_1)
+	struct svc_serv		*bc_serv;       /* The RPC service which will */
+						/* process the callback */
+	spinlock_t		bc_pa_lock;	/* Protects the preallocated
+						 * items */
+	struct list_head	bc_pa_list;	/* List of preallocated
+						 * backchannel rpc_rqst's */
+#endif /* CONFIG_NFS_V4_1 */
 	struct list_head	recv;
 
 	struct {
@@ -192,6 +206,14 @@ struct rpc_xprt {
 	const char		*address_strings[RPC_DISPLAY_MAX];
 };
 
+#if defined(CONFIG_NFS_V4_1)
+/*
+ * Backchannel flags
+ */
+#define	RPC_BC_PA_IN_USE	0x0001		/* Preallocated backchannel */
+						/* buffer in use */
+#endif /* CONFIG_NFS_V4_1 */
+
 struct xprt_create {
 	int			ident;		/* XPRT_TRANSPORT identifier */
 	struct sockaddr *	srcaddr;	/* optional local address */

commit f75e6745aa3084124ae1434fd7629853bdaf6798
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Apr 21 17:18:20 2009 -0400

    SUNRPC: Fix the problem of EADDRNOTAVAIL syslog floods on reconnect
    
    See http://bugzilla.kernel.org/show_bug.cgi?id=13034
    
    If the port gets into a TIME_WAIT state, then we cannot reconnect without
    binding to a new port.
    
    Tested-by: Petr Vandrovec <petr@vandrovec.name>
    Tested-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 1758d9f5b5c3..08afe43118f4 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -261,6 +261,7 @@ void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 #define XPRT_BINDING		(5)
 #define XPRT_CLOSING		(6)
 #define XPRT_CONNECTION_ABORT	(7)
+#define XPRT_CONNECTION_CLOSE	(8)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 7d1e8255cf959fba7ee2317550dfde39f0b936ae
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Mar 11 14:38:03 2009 -0400

    SUNRPC: Add the equivalent of the linger and linger2 timeouts to RPC sockets
    
    This fixes a regression against FreeBSD servers as reported by Tomas
    Kasparek. Apparently when using RPC over a TCP socket, the FreeBSD servers
    don't ever react to the client closing the socket, and so commit
    e06799f958bf7f9f8fae15f0c6f519953fb0257c (SUNRPC: Use shutdown() instead of
    close() when disconnecting a TCP socket) causes the setup to hang forever
    whenever the client attempts to close and then reconnect.
    
    We break the deadlock by adding a 'linger2' style timeout to the socket,
    after which, the client will abort the connection using a TCP 'RST'.
    
    The default timeout is set to 15 seconds. A subsequent patch will put it
    under user control by means of a systctl.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 2b0d960603b9..1758d9f5b5c3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -260,6 +260,7 @@ void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 #define XPRT_BOUND		(4)
 #define XPRT_BINDING		(5)
 #define XPRT_CLOSING		(6)
+#define XPRT_CONNECTION_ABORT	(7)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 441e3e242903f9b190d5764bed73edb58f977413
Author: Tom Talpey <tmtalpey@gmail.com>
Date:   Wed Mar 11 14:37:56 2009 -0400

    SUNRPC: dynamically load RPC transport modules on-demand
    
    Provide an api to attempt to load any necessary kernel RPC
    client transport module automatically. By convention, the
    desired module name is "xprt"+"transport name". For example,
    when NFS mounting with "-o proto=rdma", attempt to load the
    "xprtrdma" module.
    
    Signed-off-by: Tom Talpey <tmtalpey@gmail.com>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 11fc71d50c1e..2b0d960603b9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -235,6 +235,7 @@ static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *
  */
 int			xprt_register_transport(struct xprt_class *type);
 int			xprt_unregister_transport(struct xprt_class *type);
+int			xprt_load_transport(const char *);
 void			xprt_set_retrans_timeout_def(struct rpc_task *task);
 void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);

commit c977a2ef40a38c45537ad03823d0a004f06373f0
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Tue Dec 23 16:06:13 2008 -0500

    sunrpc: get rid of rpc_rqst.rq_bufsize
    
    rq_bufsize is not used.
    
    Signed-off-by: Mike Sager <Mike.Sager@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 4d80a118d538..11fc71d50c1e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -76,8 +76,7 @@ struct rpc_rqst {
 	struct list_head	rq_list;
 
 	__u32 *			rq_buffer;	/* XDR encode buffer */
-	size_t			rq_bufsize,
-				rq_callsize,
+	size_t			rq_callsize,
 				rq_rcvsize;
 
 	struct xdr_buf		rq_private_buf;		/* The receive buffer

commit 7c1d71cf56feebfb5b98219b9d11dfc3a2feca62
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Apr 17 16:52:57 2008 -0400

    SUNRPC: Don't disconnect more than once if retransmitting NFSv4 requests
    
    NFSv4 requires us to ensure that we break the TCP connection before we're
    allowed to retransmit a request. However in the case where we're
    retransmitting several requests that have been sent on the same
    connection, we need to ensure that we don't interfere with the attempt to
    reconnect and/or break the connection again once it has been established.
    
    We therefore introduce a 'connection' cookie that is bumped every time a
    connection is broken. This allows requests to track if they need to force a
    disconnection.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8a0629abb86a..4d80a118d538 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -86,6 +86,10 @@ struct rpc_rqst {
 	unsigned long		rq_majortimeo;	/* major timeout alarm */
 	unsigned long		rq_timeout;	/* Current timeout value */
 	unsigned int		rq_retries;	/* # of retries */
+	unsigned int		rq_connect_cookie;
+						/* A cookie used to track the
+						   state of the transport
+						   connection */
 	
 	/*
 	 * Partial send handling
@@ -152,6 +156,9 @@ struct rpc_xprt {
 	unsigned long		connect_timeout,
 				bind_timeout,
 				reestablish_timeout;
+	unsigned int		connect_cookie;	/* A cookie that gets bumped
+						   every time the transport
+						   is reconnected */
 
 	/*
 	 * Disconnection of idle transports
@@ -241,6 +248,7 @@ void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
+void			xprt_conditional_disconnect(struct rpc_xprt *xprt, unsigned int cookie);
 
 /*
  * Reserved bit positions in xprt->state

commit b6ddf64ffe9d59577a9176856bb6fe69a539f573
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Apr 17 18:52:19 2008 -0400

    SUNRPC: Fix up xprt_write_space()
    
    The rest of the networking layer uses SOCK_ASYNC_NOSPACE to signal whether
    or not we have someone waiting for buffer memory. Convert the SUNRPC layer
    to use the same idiom.
    Remove the unlikely()s in xs_udp_write_space and xs_tcp_write_space. In
    fact, the most common case will be that there is nobody waiting for buffer
    space.
    
    SOCK_NOSPACE is there to tell the TCP layer whether or not the cwnd was
    limited by the application window. Ensure that we follow the same idiom as
    the rest of the networking layer here too.
    
    Finally, ensure that we clear SOCK_ASYNC_NOSPACE once we wake up, so that
    write_space() doesn't keep waking things up on xprt->pending.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index b3ff9a815e6f..8a0629abb86a 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -232,7 +232,7 @@ int			xprt_unregister_transport(struct xprt_class *type);
 void			xprt_set_retrans_timeout_def(struct rpc_task *task);
 void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
-void			xprt_wait_for_buffer_space(struct rpc_task *task);
+void			xprt_wait_for_buffer_space(struct rpc_task *task, rpc_action action);
 void			xprt_write_space(struct rpc_xprt *xprt);
 void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_adjust_cwnd(struct rpc_task *task, int result);

commit b454ae906085cf7774fb4756746680c9b03b6f84
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Jan 7 18:34:48 2008 -0500

    SUNRPC: fewer conditionals in the format_ip_address routines
    
    Clean up: have the set up routines explicitly pass the strings to be used
    for the transport name and NETID.  This removes a number of conditionals
    and dependencies on rpc_xprt.prot, which is overloaded.
    
    Tighten up type checking on the address_strings array while we're at it.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c3364d88d83e..b3ff9a815e6f 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -183,7 +183,7 @@ struct rpc_xprt {
 					bklog_u;	/* backlog queue utilization */
 	} stat;
 
-	char *			address_strings[RPC_DISPLAY_MAX];
+	const char		*address_strings[RPC_DISPLAY_MAX];
 };
 
 struct xprt_create {

commit ba7392bb37cb12781890f45d7ddee1618e33a036
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Dec 20 16:03:55 2007 -0500

    SUNRPC: Add support for per-client timeout values
    
    In order to be able to support setting the timeo and retrans parameters on
    a per-mountpoint basis, we move the rpc_timeout structure into the
    rpc_clnt.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a00d4a4ba6ee..c3364d88d83e 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -120,7 +120,7 @@ struct rpc_xprt {
 	struct kref		kref;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
 
-	struct rpc_timeout	timeout;	/* timeout parms */
+	const struct rpc_timeout *timeout;	/* timeout parms */
 	struct sockaddr_storage	addr;		/* server address */
 	size_t			addrlen;	/* size of server address */
 	int			prot;		/* IP protocol */
@@ -191,7 +191,6 @@ struct xprt_create {
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;
-	struct rpc_timeout *	timeout;	/* optional timeout parameters */
 };
 
 struct xprt_class {

commit 2881ae74e68ecfe3b32a90936e5d93a9ba598c3a
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Dec 20 16:03:54 2007 -0500

    SUNRPC: Clean up the transport timeout initialisation
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 2554cd2b016f..a00d4a4ba6ee 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -202,11 +202,6 @@ struct xprt_class {
 	char			name[32];
 };
 
-/*
- * Transport operations used by ULPs
- */
-void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long incr);
-
 /*
  * Generic internal transport functions
  */

commit 62da3b24880bccd4ffc32cf8d9a7e23fab475bdd
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Nov 6 18:44:20 2007 -0500

    SUNRPC: Rename xprt_disconnect()
    
    xprt_disconnect() should really only be called when the transport shutdown
    is completed, and it is time to wake up any pending tasks. Rename it to
    xprt_disconnect_done() in order to reflect the semantical change.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index afb9e6ad7fe0..2554cd2b016f 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -245,7 +245,7 @@ void			xprt_adjust_cwnd(struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);
-void			xprt_disconnect(struct rpc_xprt *xprt);
+void			xprt_disconnect_done(struct rpc_xprt *xprt);
 void			xprt_force_disconnect(struct rpc_xprt *xprt);
 
 /*

commit 3b948ae5be5e22532584113e2e02029519bbad8f
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Nov 5 17:42:39 2007 -0500

    SUNRPC: Allow the client to detect if the TCP connection is closed
    
    Add an xprt->state bit to enable the TCP ->state_change() method to signal
    whether or not the TCP connection is in the process of closing down.
    This will to be used by the reconnection logic in a separate patch.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6f524a9e7fd0..afb9e6ad7fe0 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -257,6 +257,7 @@ void			xprt_force_disconnect(struct rpc_xprt *xprt);
 #define XPRT_CLOSE_WAIT		(3)
 #define XPRT_BOUND		(4)
 #define XPRT_BINDING		(5)
+#define XPRT_CLOSING		(6)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 66af1e558538137080615e7ad6d1f2f80862de01
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Nov 6 10:18:36 2007 -0500

    SUNRPC: Fix a race in xs_tcp_state_change()
    
    When scheduling the autoclose RPC call, we want to ensure that we don't
    race against the test_bit() call in xprt_clear_locked().
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 30b17b3bc1a9..6f524a9e7fd0 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -246,6 +246,7 @@ struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect(struct rpc_xprt *xprt);
+void			xprt_force_disconnect(struct rpc_xprt *xprt);
 
 /*
  * Reserved bit positions in xprt->state

commit 4fa016eb248cac875541fa199af550a8aefa0e90
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:47:57 2007 -0400

    NFS/SUNRPC: support transport protocol naming
    
    To prepare for including non-sockets-based RPC transports, select
    RPC transports by an identifier (to be used in following patches).
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d7b8fcd312cc..30b17b3bc1a9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -187,7 +187,7 @@ struct rpc_xprt {
 };
 
 struct xprt_create {
-	int			proto;		/* IPPROTO_UDP or IPPROTO_TCP */
+	int			ident;		/* XPRT_TRANSPORT identifier */
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;
@@ -196,8 +196,7 @@ struct xprt_create {
 
 struct xprt_class {
 	struct list_head	list;
-	unsigned short		family;
-	int			protocol;
+	int			ident;		/* XPRT_TRANSPORT identifier */
 	struct rpc_xprt *	(*setup)(struct xprt_create *);
 	struct module		*owner;
 	char			name[32];

commit 49c36fcc441baf6a4d698e3645d1adf28edaf57b
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:47:31 2007 -0400

    SUNRPC: rearrange RPC sockets definitions
    
    To prepare for including non-sockets-based RPC transports, move the
    sockets-dependent definitions into their own file.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6992ff02d737..d7b8fcd312cc 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -19,24 +19,10 @@
 
 #ifdef __KERNEL__
 
-extern unsigned int xprt_udp_slot_table_entries;
-extern unsigned int xprt_tcp_slot_table_entries;
-
 #define RPC_MIN_SLOT_TABLE	(2U)
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE	(128U)
 
-/*
- * Parameters for choosing a free port
- */
-extern unsigned int xprt_min_resvport;
-extern unsigned int xprt_max_resvport;
-
-#define RPC_MIN_RESVPORT	(1U)
-#define RPC_MAX_RESVPORT	(65535U)
-#define RPC_DEF_MIN_RESVPORT	(665U)
-#define RPC_DEF_MAX_RESVPORT	(1023U)
-
 /*
  * This describes a timeout strategy
  */
@@ -262,14 +248,6 @@ void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect(struct rpc_xprt *xprt);
 
-/*
- * Socket transport setup operations
- */
-struct rpc_xprt		*xs_setup_udp(struct xprt_create *args);
-struct rpc_xprt		*xs_setup_tcp(struct xprt_create *args);
-int			init_socket_xprt(void);
-void			cleanup_socket_xprt(void);
-
 /*
  * Reserved bit positions in xprt->state
  */

commit 3c341b0b925eee01daae2c594b81e673f659d7cd
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:47:07 2007 -0400

    SUNRPC: rename the rpc_xprtsock_create structure
    
    To prepare for including non-sockets-based RPC transports, change the
    overly suggestive name of the transport creation arguments struct.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7b6b137eca97..6992ff02d737 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -200,7 +200,7 @@ struct rpc_xprt {
 	char *			address_strings[RPC_DISPLAY_MAX];
 };
 
-struct rpc_xprtsock_create {
+struct xprt_create {
 	int			proto;		/* IPPROTO_UDP or IPPROTO_TCP */
 	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
@@ -212,7 +212,7 @@ struct xprt_class {
 	struct list_head	list;
 	unsigned short		family;
 	int			protocol;
-	struct rpc_xprt *	(*setup)(struct rpc_xprtsock_create *);
+	struct rpc_xprt *	(*setup)(struct xprt_create *);
 	struct module		*owner;
 	char			name[32];
 };
@@ -225,7 +225,7 @@ void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long
 /*
  * Generic internal transport functions
  */
-struct rpc_xprt *	xprt_create_transport(struct rpc_xprtsock_create *args);
+struct rpc_xprt		*xprt_create_transport(struct xprt_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_task *task);
@@ -265,8 +265,8 @@ void			xprt_disconnect(struct rpc_xprt *xprt);
 /*
  * Socket transport setup operations
  */
-struct rpc_xprt *	xs_setup_udp(struct rpc_xprtsock_create *args);
-struct rpc_xprt *	xs_setup_tcp(struct rpc_xprtsock_create *args);
+struct rpc_xprt		*xs_setup_udp(struct xprt_create *args);
+struct rpc_xprt		*xs_setup_tcp(struct xprt_create *args);
 int			init_socket_xprt(void);
 void			cleanup_socket_xprt(void);
 

commit 81c098af3da7981902e9f8163aeccc2467c4ba6d
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:46:00 2007 -0400

    SUNRPC: Provide a new API for registering transport implementations
    
    To allow transport capabilities to be loaded dynamically, provide an API
    for registering and unregistering the transports with the RPC client.
    Eventually xprt_create_transport() will be changed to search the list of
    registered transports when initializing a fresh transport.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 513b0657e14d..7b6b137eca97 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -208,6 +208,15 @@ struct rpc_xprtsock_create {
 	struct rpc_timeout *	timeout;	/* optional timeout parameters */
 };
 
+struct xprt_class {
+	struct list_head	list;
+	unsigned short		family;
+	int			protocol;
+	struct rpc_xprt *	(*setup)(struct rpc_xprtsock_create *);
+	struct module		*owner;
+	char			name[32];
+};
+
 /*
  * Transport operations used by ULPs
  */
@@ -239,6 +248,8 @@ static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *
 /*
  * Transport switch helper functions
  */
+int			xprt_register_transport(struct xprt_class *type);
+int			xprt_unregister_transport(struct xprt_class *type);
 void			xprt_set_retrans_timeout_def(struct rpc_task *task);
 void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);

commit 4417c8c41a51a2ae95b2a2fa2811640b368c4151
Author: \"Talpey, Thomas\ <Thomas.Talpey@netapp.com>
Date:   Mon Sep 10 13:43:05 2007 -0400

    SUNRPC: export per-transport rpcbind netid's
    
    The rpcbind (v3+) netid is provided by each RPC client transport. This fixes
    an omission in IPv6 rpcbind client support, and enables future extension.
    
    Signed-off-by: Tom Talpey <tmt@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 902a9c0a2d9a..513b0657e14d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -56,6 +56,7 @@ enum rpc_display_format_t {
 	RPC_DISPLAY_HEX_ADDR,
 	RPC_DISPLAY_HEX_PORT,
 	RPC_DISPLAY_UNIVERSAL_ADDR,
+	RPC_DISPLAY_NETID,
 	RPC_DISPLAY_MAX,
 };
 

commit 756805e7a76bcd2aae07fe31786fe453375e60b1
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Aug 16 16:03:26 2007 -0400

    SUNRPC: Add support for formatted universal addresses
    
    "Universal addresses" are a string representation of an IP address and
    port.  They are described fully in RFC 3530, section 2.2.  Add support
    for generating them in the RPC client's socket transport module.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 4596c26f97aa..902a9c0a2d9a 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -55,6 +55,7 @@ enum rpc_display_format_t {
 	RPC_DISPLAY_ALL,
 	RPC_DISPLAY_HEX_ADDR,
 	RPC_DISPLAY_HEX_PORT,
+	RPC_DISPLAY_UNIVERSAL_ADDR,
 	RPC_DISPLAY_MAX,
 };
 

commit fbfe3cc677c1a62ca6472abf24d03d4bf9f03a55
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Aug 6 11:57:02 2007 -0400

    SUNRPC: Add hex-formatted address support to rpc_peeraddr2str()
    
    Add support for the NFS client's need to export volume information
    with IP addresses formatted in hex instead of decimal.
    
    This isn't used yet, but subsequent patches (not in this series) will
    change the NFS client to use this functionality.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d11cedd14f0f..4596c26f97aa 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -53,6 +53,8 @@ enum rpc_display_format_t {
 	RPC_DISPLAY_PORT,
 	RPC_DISPLAY_PROTO,
 	RPC_DISPLAY_ALL,
+	RPC_DISPLAY_HEX_ADDR,
+	RPC_DISPLAY_HEX_PORT,
 	RPC_DISPLAY_MAX,
 };
 

commit d3bc9a1deb8964d774af8535814cb91bf8f6def0
Author: Frank van Maarseveen <frankvm@frankvm.com>
Date:   Mon Jul 9 22:23:35 2007 +0200

    SUNRPC client: add interface for binding to a local address
    
    In addition to binding to a local privileged port the NFS client should
    allow binding to a specific local address. This is used by the server
    for callbacks. The patch adds the necessary interface.
    
    Signed-off-by: Frank van Maarseveen <frankvm@frankvm.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ea828b09e4ad..d11cedd14f0f 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -198,6 +198,7 @@ struct rpc_xprt {
 
 struct rpc_xprtsock_create {
 	int			proto;		/* IPPROTO_UDP or IPPROTO_TCP */
+	struct sockaddr *	srcaddr;	/* optional local address */
 	struct sockaddr *	dstaddr;	/* remote peer address */
 	size_t			addrlen;
 	struct rpc_timeout *	timeout;	/* optional timeout parameters */

commit 96802a095171f5b35cf0e1e0d4be943e6696a253
Author: Frank van Maarseveen <frankvm@frankvm.com>
Date:   Sun Jul 8 13:08:54 2007 +0200

    SUNRPC: cleanup transport creation argument passing
    
    Cleanup argument passing to functions for creating an RPC transport.
    
    Signed-off-by: Frank van Maarseveen <frankvm@frankvm.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 34f7590506fa..ea828b09e4ad 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -17,6 +17,8 @@
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
 
+#ifdef __KERNEL__
+
 extern unsigned int xprt_udp_slot_table_entries;
 extern unsigned int xprt_tcp_slot_table_entries;
 
@@ -194,7 +196,12 @@ struct rpc_xprt {
 	char *			address_strings[RPC_DISPLAY_MAX];
 };
 
-#ifdef __KERNEL__
+struct rpc_xprtsock_create {
+	int			proto;		/* IPPROTO_UDP or IPPROTO_TCP */
+	struct sockaddr *	dstaddr;	/* remote peer address */
+	size_t			addrlen;
+	struct rpc_timeout *	timeout;	/* optional timeout parameters */
+};
 
 /*
  * Transport operations used by ULPs
@@ -204,7 +211,7 @@ void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long
 /*
  * Generic internal transport functions
  */
-struct rpc_xprt *	xprt_create_transport(int proto, struct sockaddr *addr, size_t size, struct rpc_timeout *toparms);
+struct rpc_xprt *	xprt_create_transport(struct rpc_xprtsock_create *args);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_task *task);
@@ -242,8 +249,8 @@ void			xprt_disconnect(struct rpc_xprt *xprt);
 /*
  * Socket transport setup operations
  */
-struct rpc_xprt *	xs_setup_udp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
-struct rpc_xprt *	xs_setup_tcp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
+struct rpc_xprt *	xs_setup_udp(struct rpc_xprtsock_create *args);
+struct rpc_xprt *	xs_setup_tcp(struct rpc_xprtsock_create *args);
 int			init_socket_xprt(void);
 void			cleanup_socket_xprt(void);
 

commit 7531d692d4174789d583eb50fcb83cefa121b790
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon May 14 17:21:26 2007 -0400

    SUNRPC: Fix sparse warnings
    
     - net/sunrpc/xprtsock.c:1635:5: warning: symbol 'init_socket_xprt' was not
       declared. Should it be static?
     - net/sunrpc/xprtsock.c:1649:6: warning: symbol 'cleanup_socket_xprt' was
       not declared. Should it be static?
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index fa89ce6ce076..34f7590506fa 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -244,6 +244,8 @@ void			xprt_disconnect(struct rpc_xprt *xprt);
  */
 struct rpc_xprt *	xs_setup_udp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
 struct rpc_xprt *	xs_setup_tcp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
+int			init_socket_xprt(void);
+void			cleanup_socket_xprt(void);
 
 /*
  * Reserved bit positions in xprt->state

commit a509050bd3b8e0aa269c2241aa10d74ca7701e2f
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Mar 29 16:48:04 2007 -0400

    SUNRPC: introduce rpcbind: replacement for in-kernel portmapper
    
    Introduce a replacement for the in-kernel portmapper client that supports
    all 3 versions of the rpcbind protocol.  This code is not used yet.
    
    Original code by Groupe Bull updated for the latest kernel, with multiple
    bug fixes.
    
    Note that rpcb_clnt.c does not yet support registering via versions 3 and
    4 of the rpcbind protocol.  That is planned for a later patch.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 745afc1d3068..fa89ce6ce076 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -152,6 +152,7 @@ struct rpc_xprt {
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
 				resvport   : 1; /* use a reserved port */
+	unsigned int		bind_index;	/* bind function index */
 
 	/*
 	 * Connection of transports

commit c5a4dd8b7c15927a8fbff83171b57cad675a79b9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Mar 29 16:47:58 2007 -0400

    SUNRPC: Eliminate side effects from rpc_malloc
    
    Currently rpc_malloc sets req->rq_buffer internally.  Make this a more
    generic interface:  return a pointer to the new buffer (or NULL) and
    make the caller set req->rq_buffer and req->rq_bufsize.  This looks much
    more like kmalloc and eliminates the side effects.
    
    To fix a potential deadlock, this patch also replaces GFP_NOFS with
    GFP_NOWAIT in rpc_malloc.  This prevents async RPCs from sleeping outside
    the RPC's task scheduler while allocating their buffer.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7aa29502b187..745afc1d3068 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -114,7 +114,7 @@ struct rpc_xprt_ops {
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_task *task);
 	void *		(*buf_alloc)(struct rpc_task *task, size_t size);
-	void		(*buf_free)(struct rpc_task *task);
+	void		(*buf_free)(void *buffer);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_task *task);

commit 2bea90d43a050bbc4021d44e59beb34f384438db
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Mar 29 16:47:53 2007 -0400

    SUNRPC: RPC buffer size estimates are too large
    
    The RPC buffer size estimation logic in net/sunrpc/clnt.c always
    significantly overestimates the requirements for the buffer size.
    A little instrumentation demonstrated that in fact rpc_malloc was never
    allocating the buffer from the mempool, but almost always called kmalloc.
    
    To compute the size of the RPC buffer more precisely, split p_bufsiz into
    two fields; one for the argument size, and one for the result size.
    
    Then, compute the sum of the exact call and reply header sizes, and split
    the RPC buffer precisely between the two.  That should keep almost all RPC
    buffers within the 2KiB buffer mempool limit.
    
    And, we can finally be rid of RPC_SLACK_SPACE!
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index f780e72fc417..7aa29502b187 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -84,7 +84,9 @@ struct rpc_rqst {
 	struct list_head	rq_list;
 
 	__u32 *			rq_buffer;	/* XDR encode buffer */
-	size_t			rq_bufsize;
+	size_t			rq_bufsize,
+				rq_callsize,
+				rq_rcvsize;
 
 	struct xdr_buf		rq_private_buf;		/* The receive buffer
 							 * used in the softirq.

commit 7559c7a28fbcaa0bca028eeebd5f251b09befe6b
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:37 2006 -0500

    SUNRPC: Make address format buffers more generic
    
    For now we will assume that all transports will use the address format
    buffers in the rpc_xprt struct to store their addresses.  Change
    rpc_peer2str() to be a generic routine to handle this, and get rid of the
    print_address() op in the rpc_xprt_ops vector.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 17f322794e91..f780e72fc417 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -106,7 +106,6 @@ struct rpc_rqst {
 
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
-	char *		(*print_addr)(struct rpc_xprt *xprt, enum rpc_display_format_t format);
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*rpcbind)(struct rpc_task *task);

commit 314dfd7987c71d7ba0c43ac3bf3d243c102ce025
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:34 2006 -0500

    SUNRPC: move saved socket callback functions to a private data structure
    
    Move the three fields for saving socket callback functions out of the
    rpc_xprt structure and into a private data structure maintained in
    net/sunrpc/xprtsock.c.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 21beb56fb84c..17f322794e91 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -17,8 +17,6 @@
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
 
-#include <net/sock.h>
-
 extern unsigned int xprt_udp_slot_table_entries;
 extern unsigned int xprt_tcp_slot_table_entries;
 
@@ -191,10 +189,6 @@ struct rpc_xprt {
 					bklog_u;	/* backlog queue utilization */
 	} stat;
 
-	void			(*old_data_ready)(struct sock *, int);
-	void			(*old_state_change)(struct sock *);
-	void			(*old_write_space)(struct sock *);
-
 	char *			address_strings[RPC_DISPLAY_MAX];
 };
 

commit 7c6e066ec29290bf062f5bff2984bad9be5809c7
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:30 2006 -0500

    SUNRPC: Move the UDP socket bufsize parameters to a private data structure
    
    Move the socket-specific buffer size parameters for UDP sockets to a
    private data structure maintained in net/sunrpc/xprtsock.c.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 18bf72c06488..21beb56fb84c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -137,9 +137,6 @@ struct rpc_xprt {
 	unsigned long		cong;		/* current congestion */
 	unsigned long		cwnd;		/* congestion window */
 
-	size_t			rcvsize,	/* transport rcv buffer size */
-				sndsize;	/* transport send buffer size */
-
 	size_t			max_payload;	/* largest RPC payload size,
 						   in bytes */
 	unsigned int		tsh_size;	/* size of transport specific

commit c8475461829fd94f30208fbfa4eab7e5584c6495
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:26 2006 -0500

    SUNRPC: Move rpc_xprt socket connect fields into private data structure
    
    Move the socket-specific connection management fields out of the generic
    rpc_xprt structure into a private data structure maintained in
    net/sunrpc/xprtsock.c.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3ff8230c7dd9..18bf72c06488 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -163,8 +163,6 @@ struct rpc_xprt {
 	unsigned long		connect_timeout,
 				bind_timeout,
 				reestablish_timeout;
-	struct work_struct	connect_worker;
-	unsigned short		port;
 
 	/*
 	 * Disconnection of idle transports

commit e136d0926ef6a048f6e65b35263c0a9faae3abbe
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:23 2006 -0500

    SUNRPC: Move TCP state flags into xprtsock.c
    
    Move "XPRT_LAST_FRAG" and friends from xprt.h into xprtsock.c, and rename
    them to use the naming scheme in use in xprtsock.c.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 0a0ad1ce70e4..3ff8230c7dd9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -203,11 +203,6 @@ struct rpc_xprt {
 	char *			address_strings[RPC_DISPLAY_MAX];
 };
 
-#define XPRT_LAST_FRAG		(1 << 0)
-#define XPRT_COPY_RECM		(1 << 1)
-#define XPRT_COPY_XID		(1 << 2)
-#define XPRT_COPY_DATA		(1 << 3)
-
 #ifdef __KERNEL__
 
 /*

commit 51971139b2342fa1005e87bbfcb52305da3fe891
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:19 2006 -0500

    SUNRPC: Move TCP receive state variables into private data structure
    
    Move the TCP receive state variables from the generic rpc_xprt structure to
    a private structure maintained inside net/sunrpc/xprtsock.c.
    
    Also rename a function/variable pair to refer to RPC fragment headers
    instead of record markers, to be consistent with types defined in
    sunrpc/*.h.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 4c074a73670c..0a0ad1ce70e4 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -157,15 +157,6 @@ struct rpc_xprt {
 	unsigned char		shutdown   : 1,	/* being shut down */
 				resvport   : 1; /* use a reserved port */
 
-	/*
-	 * State of TCP reply receive stuff
-	 */
-	__be32			tcp_recm,	/* Fragment header */
-				tcp_xid;	/* Current XID */
-	u32			tcp_reclen,	/* fragment length */
-				tcp_offset;	/* fragment offset */
-	unsigned long		tcp_copied,	/* copied to request */
-				tcp_flags;
 	/*
 	 * Connection of transports
 	 */

commit ee0ac0c227c2a2b6dd1b33c23831100ee895dacf
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Dec 5 16:35:15 2006 -0500

    SUNRPC: Remove sock and inet fields from rpc_xprt
    
    The "sock" and "inet" fields are socket-specific.  Move them to a private
    data structure maintained entirely within net/sunrpc/xprtsock.c
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d7919010863d..4c074a73670c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -17,6 +17,8 @@
 #include <linux/sunrpc/xdr.h>
 #include <linux/sunrpc/msg_prot.h>
 
+#include <net/sock.h>
+
 extern unsigned int xprt_udp_slot_table_entries;
 extern unsigned int xprt_tcp_slot_table_entries;
 
@@ -126,8 +128,6 @@ struct rpc_xprt_ops {
 struct rpc_xprt {
 	struct kref		kref;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
-	struct socket *		sock;		/* BSD socket layer */
-	struct sock *		inet;		/* INET layer */
 
 	struct rpc_timeout	timeout;	/* timeout parms */
 	struct sockaddr_storage	addr;		/* server address */

commit c8541ecdd5692bcfbcb5305cab9a873288d29175
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Oct 17 14:44:27 2006 -0400

    SUNRPC: Make the transport-specific setup routine allocate rpc_xprt
    
    Change the location where the rpc_xprt structure is allocated so each
    transport implementation can allocate a private area from the same
    chunk of memory.
    
    Note also that xprt->ops->destroy, rather than xprt_destroy, is now
    responsible for freeing rpc_xprt when the transport is destroyed.
    
    Test plan:
    Connectathon.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 0321fb53bd02..d7919010863d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -265,8 +265,8 @@ void			xprt_disconnect(struct rpc_xprt *xprt);
 /*
  * Socket transport setup operations
  */
-int			xs_setup_udp(struct rpc_xprt *xprt, struct rpc_timeout *to);
-int			xs_setup_tcp(struct rpc_xprt *xprt, struct rpc_timeout *to);
+struct rpc_xprt *	xs_setup_udp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
+struct rpc_xprt *	xs_setup_tcp(struct sockaddr *addr, size_t addrlen, struct rpc_timeout *to);
 
 /*
  * Reserved bit positions in xprt->state

commit e744cf2e3ab8535a8494a4cf0177de26f94586da
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Oct 17 14:44:24 2006 -0400

    SUNRPC: minor optimization of "xid" field in rpc_xprt
    
    Move the xid field in the rpc_xprt structure to be in the same cache line
    as the reserve_lock, since these are used at the same time.
    
    Test plan:
    None.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 60394fbc4c70..0321fb53bd02 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -157,11 +157,6 @@ struct rpc_xprt {
 	unsigned char		shutdown   : 1,	/* being shut down */
 				resvport   : 1; /* use a reserved port */
 
-	/*
-	 * XID
-	 */
-	__u32			xid;		/* Next XID value to use */
-
 	/*
 	 * State of TCP reply receive stuff
 	 */
@@ -193,8 +188,8 @@ struct rpc_xprt {
 	 */
 	spinlock_t		transport_lock;	/* lock transport info */
 	spinlock_t		reserve_lock;	/* lock slot table */
+	u32			xid;		/* Next XID value to use */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
-
 	struct list_head	recv;
 
 	struct {

commit 7adae489fe794e3e203ff168595f635d0b845e59
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Wed Oct 4 02:15:47 2006 -0700

    [PATCH] knfsd: Prepare knfsd for support of rsize/wsize of up to 1MB, over TCP
    
    The limit over UDP remains at 32K.  Also, make some of the apparently
    arbitrary sizing constants clearer.
    
    The biggest change here involves replacing NFSSVC_MAXBLKSIZE by a function of
    the rqstp.  This allows it to be different for different protocols (udp/tcp)
    and also allows it to depend on the servers declared sv_bufsiz.
    
    Note that we don't actually increase sv_bufsz for nfs yet.  That comes next.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6cf626580752..60394fbc4c70 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -15,6 +15,7 @@
 #include <linux/kref.h>
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
+#include <linux/sunrpc/msg_prot.h>
 
 extern unsigned int xprt_udp_slot_table_entries;
 extern unsigned int xprt_tcp_slot_table_entries;
@@ -23,13 +24,6 @@ extern unsigned int xprt_tcp_slot_table_entries;
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE	(128U)
 
-/*
- * RPC call and reply header size as number of 32bit words (verifier
- * size computed separately)
- */
-#define RPC_CALLHDRSIZE		6
-#define RPC_REPHDRSIZE		4
-
 /*
  * Parameters for choosing a free port
  */

commit d8ed029d6000ba2e2908d9286409e4833c091b4c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Sep 26 22:29:38 2006 -0700

    [SUNRPC]: trivial endianness annotations
    
    pure s/u32/__be32/
    
    [AV: large part based on Alexey's patches]
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bdeba8538c71..6cf626580752 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -79,7 +79,7 @@ struct rpc_rqst {
 	 * This is the private part
 	 */
 	struct rpc_task *	rq_task;	/* RPC task data */
-	__u32			rq_xid;		/* request XID */
+	__be32			rq_xid;		/* request XID */
 	int			rq_cong;	/* has incremented xprt->cong */
 	int			rq_received;	/* receive completed */
 	u32			rq_seqno;	/* gss seq no. used on req. */
@@ -171,9 +171,9 @@ struct rpc_xprt {
 	/*
 	 * State of TCP reply receive stuff
 	 */
-	u32			tcp_recm,	/* Fragment header */
-				tcp_xid,	/* Current XID */
-				tcp_reclen,	/* fragment length */
+	__be32			tcp_recm,	/* Fragment header */
+				tcp_xid;	/* Current XID */
+	u32			tcp_reclen,	/* fragment length */
 				tcp_offset;	/* fragment offset */
 	unsigned long		tcp_copied,	/* copied to request */
 				tcp_flags;
@@ -253,7 +253,7 @@ void			xprt_release(struct rpc_task *task);
 struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
 void			xprt_put(struct rpc_xprt *xprt);
 
-static inline u32 *xprt_skip_transport_header(struct rpc_xprt *xprt, u32 *p)
+static inline __be32 *xprt_skip_transport_header(struct rpc_xprt *xprt, __be32 *p)
 {
 	return p + xprt->tsh_size;
 }
@@ -268,7 +268,7 @@ void			xprt_wait_for_buffer_space(struct rpc_task *task);
 void			xprt_write_space(struct rpc_xprt *xprt);
 void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_adjust_cwnd(struct rpc_task *task, int result);
-struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
+struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, __be32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect(struct rpc_xprt *xprt);

commit 6b6ca86b77b62b798cf9ca2599036420abce7796
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Sep 5 12:55:57 2006 -0400

    SUNRPC: Add refcounting to the struct rpc_xprt
    
    In a subsequent patch, this will allow the portmapper to take a reference
    to the rpc_xprt for which it is updating the port number, fixing an Oops.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index de4efea7c856..bdeba8538c71 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -12,6 +12,7 @@
 #include <linux/uio.h>
 #include <linux/socket.h>
 #include <linux/in.h>
+#include <linux/kref.h>
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
 
@@ -129,6 +130,7 @@ struct rpc_xprt_ops {
 };
 
 struct rpc_xprt {
+	struct kref		kref;		/* Reference count */
 	struct rpc_xprt_ops *	ops;		/* transport methods */
 	struct socket *		sock;		/* BSD socket layer */
 	struct sock *		inet;		/* INET layer */
@@ -248,7 +250,8 @@ int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
-int			xprt_destroy(struct rpc_xprt *xprt);
+struct rpc_xprt *	xprt_get(struct rpc_xprt *xprt);
+void			xprt_put(struct rpc_xprt *xprt);
 
 static inline u32 *xprt_skip_transport_header(struct rpc_xprt *xprt, u32 *p)
 {

commit ff9aa5e56df60cc8565a93cc868fe25ae3f20e49
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:21 2006 -0400

    SUNRPC: Eliminate xprt_create_proto and rpc_create_client
    
    The two function call API for creating a new RPC client is now obsolete.
    Remove it.
    
    Also, remove an unnecessary check to see whether the caller is capable of
    using privileged network services.  The kernel RPC client always uses a
    privileged ephemeral port by default; callers are responsible for checking
    the authority of users to make use of any RPC service, or for specifying
    that a nonprivileged port is acceptable.
    
    Test plan:
    Repeated runs of Connectathon locking suite.  Check network trace to ensure
    correctness of NLM requests and replies.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bc80fcfdd892..de4efea7c856 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -231,7 +231,6 @@ struct rpc_xprt {
 /*
  * Transport operations used by ULPs
  */
-struct rpc_xprt *	xprt_create_proto(int proto, struct sockaddr_in *addr, struct rpc_timeout *to);
 void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long incr);
 
 /*

commit c2866763b4029411d166040306691773c12d4caf
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:20 2006 -0400

    SUNRPC: use sockaddr + size when creating remote transport endpoints
    
    Prepare for more generic transport endpoint handling needed by transports
    that might use different forms of addressing, such as IPv6.
    
    Introduce a single function call to replace the two-call
    xprt_create_proto/rpc_create_client API.  Define a new rpc_create_args
    structure that allows callers to pass in remote endpoint addresses of
    varying length.
    
    Test-plan:
    Compile kernel with CONFIG_NFS enabled.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index fc05cfbd5805..bc80fcfdd892 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -237,6 +237,7 @@ void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long
 /*
  * Generic internal transport functions
  */
+struct rpc_xprt *	xprt_create_transport(int proto, struct sockaddr *addr, size_t size, struct rpc_timeout *toparms);
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
 int			xprt_reserve_xprt(struct rpc_task *task);

commit c4efcb1d3e0bc76aeb9ca6301d19a5079893c6c9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:19 2006 -0400

    SUNRPC: Use "sockaddr_storage" for storing RPC client's remote peer address
    
    IPv6 addresses are big (128 bytes).  Now that no RPC client consumers treat
    the addr field in rpc_xprt structs as an opaque, and access it only via the
    API calls, we can safely widen the field in the rpc_xprt struct to
    accomodate larger addresses.
    
    Test plan:
    Compile kernel with CONFIG_NFS enabled.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 8372ab8fc9b5..fc05cfbd5805 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -134,7 +134,8 @@ struct rpc_xprt {
 	struct sock *		inet;		/* INET layer */
 
 	struct rpc_timeout	timeout;	/* timeout parms */
-	struct sockaddr_in	addr;		/* server address */
+	struct sockaddr_storage	addr;		/* server address */
+	size_t			addrlen;	/* size of server address */
 	int			prot;		/* IP protocol */
 
 	unsigned long		cong;		/* current congestion */

commit edb267a688fcee5335d596752f117a30c7152e44
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:18 2006 -0400

    SUNRPC: add xprt switch API for printing formatted remote peer addresses
    
    Add a new method to the transport switch API to provide a way to convert
    the opaque contents of xprt->addr to a human-readable string.
    
    Test plan:
    Compile kernel with CONFIG_NFS enabled.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 84122559fa17..8372ab8fc9b5 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -51,6 +51,14 @@ struct rpc_timeout {
 	unsigned char		to_exponential;
 };
 
+enum rpc_display_format_t {
+	RPC_DISPLAY_ADDR = 0,
+	RPC_DISPLAY_PORT,
+	RPC_DISPLAY_PROTO,
+	RPC_DISPLAY_ALL,
+	RPC_DISPLAY_MAX,
+};
+
 struct rpc_task;
 struct rpc_xprt;
 struct seq_file;
@@ -103,6 +111,7 @@ struct rpc_rqst {
 
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
+	char *		(*print_addr)(struct rpc_xprt *xprt, enum rpc_display_format_t format);
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*rpcbind)(struct rpc_task *task);
@@ -207,6 +216,8 @@ struct rpc_xprt {
 	void			(*old_data_ready)(struct sock *, int);
 	void			(*old_state_change)(struct sock *);
 	void			(*old_write_space)(struct sock *);
+
+	char *			address_strings[RPC_DISPLAY_MAX];
 };
 
 #define XPRT_LAST_FRAG		(1 << 0)

commit bbf7c1dd2ae2b4040b41b1065ee9b1b6905b1605
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:16 2006 -0400

    SUNRPC: Introduce transport switch callout for pluggable rpcbind
    
    Introduce a clean transport switch API for plugging in different types of
    rpcbind mechanisms.  For instance, rpcbind can cleanly replace the
    existing portmapper client, or a transport can choose to implement RPC
    binding any way it likes.
    
    Test plan:
    Destructive testing (unplugging the network temporarily).  Connectathon
    with UDP and TCP.  NFSv2/3 and NFSv4 mounting should be carefully checked.
    Probably need to rig a server where certain services aren't running, or
    that returns an error for some typical operation.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 4ce82616873d..84122559fa17 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -105,6 +105,7 @@ struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
+	void		(*rpcbind)(struct rpc_task *task);
 	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_task *task);
 	void *		(*buf_alloc)(struct rpc_task *task, size_t size);

commit 4a68179d38874c37be2802442a71b847f5d1a2a9
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:15 2006 -0400

    SUNRPC: Make RPC portmapper use per-transport storage
    
    Move connection and bind state that was maintained in the rpc_clnt
    structure to the rpc_xprt structure.  This will allow the creation of
    a clean API for plugging in different types of bind mechanisms.
    
    This brings improvements such as the elimination of a single spin lock to
    control serialization for all in-kernel RPC binding.  A set of per-xprt
    bitops is used to serialize tasks during RPC binding, just like it now
    works for making RPC transport connections.
    
    Test-plan:
    Destructive testing (unplugging the network temporarily).  Connectathon
    with UDP and TCP.  NFSv2/3 and NFSv4 mounting should be carefully checked.
    Probably need to rig a server where certain services aren't running, or
    that returns an error for some typical operation.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a71106723d71..4ce82616873d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -138,6 +138,7 @@ struct rpc_xprt {
 	unsigned int		tsh_size;	/* size of transport specific
 						   header */
 
+	struct rpc_wait_queue	binding;	/* requests waiting on rpcbind */
 	struct rpc_wait_queue	sending;	/* requests waiting to send */
 	struct rpc_wait_queue	resend;		/* requests waiting to resend */
 	struct rpc_wait_queue	pending;	/* requests in flight */
@@ -270,6 +271,7 @@ int			xs_setup_tcp(struct rpc_xprt *xprt, struct rpc_timeout *to);
 #define XPRT_CONNECTING		(2)
 #define XPRT_CLOSE_WAIT		(3)
 #define XPRT_BOUND		(4)
+#define XPRT_BINDING		(5)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {
@@ -328,6 +330,18 @@ static inline void xprt_clear_bound(struct rpc_xprt *xprt)
 	clear_bit(XPRT_BOUND, &xprt->state);
 }
 
+static inline void xprt_clear_binding(struct rpc_xprt *xprt)
+{
+	smp_mb__before_clear_bit();
+	clear_bit(XPRT_BINDING, &xprt->state);
+	smp_mb__after_clear_bit();
+}
+
+static inline int xprt_test_and_set_binding(struct rpc_xprt *xprt)
+{
+	return test_and_set_bit(XPRT_BINDING, &xprt->state);
+}
+
 #endif /* __KERNEL__*/
 
 #endif /* _LINUX_SUNRPC_XPRT_H */

commit ec739ef03dc926d05051c8c5838971445504470a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:15 2006 -0400

    SUNRPC: Create a helper to tell whether a transport is bound
    
    Hide the contents and format of xprt->addr by eliminating direct uses
    of the xprt->addr.sin_port field.  This change is required to support
    alternate RPC host address formats (eg IPv6).
    
    Test-plan:
    Destructive testing (unplugging the network temporarily).  Repeated runs of
    Connectathon locking suite with UDP and TCP.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3a0cca255b76..a71106723d71 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -269,6 +269,7 @@ int			xs_setup_tcp(struct rpc_xprt *xprt, struct rpc_timeout *to);
 #define XPRT_CONNECTED		(1)
 #define XPRT_CONNECTING		(2)
 #define XPRT_CLOSE_WAIT		(3)
+#define XPRT_BOUND		(4)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {
@@ -312,6 +313,21 @@ static inline int xprt_test_and_set_connecting(struct rpc_xprt *xprt)
 	return test_and_set_bit(XPRT_CONNECTING, &xprt->state);
 }
 
+static inline void xprt_set_bound(struct rpc_xprt *xprt)
+{
+	test_and_set_bit(XPRT_BOUND, &xprt->state);
+}
+
+static inline int xprt_bound(struct rpc_xprt *xprt)
+{
+	return test_bit(XPRT_BOUND, &xprt->state);
+}
+
+static inline void xprt_clear_bound(struct rpc_xprt *xprt)
+{
+	clear_bit(XPRT_BOUND, &xprt->state);
+}
+
 #endif /* __KERNEL__*/
 
 #endif /* _LINUX_SUNRPC_XPRT_H */

commit 8e037094c414172481c5ce903efdab50ce932343
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Aug 22 20:06:15 2006 -0400

    SUNRPC: avoid choosing an IPMI port for RPC traffic
    
    Some hardware uses port 664 for its hardware-based IPMI listener.  Teach
    the RPC client to avoid using that port by raising the default minimum port
    number to 665.
    
    Test plan:
    Find a mainboard known to use port 664 for IPMI; enable IPMI; mount NFS
    servers in a tight loop.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    (cherry picked from 58e8cb3a035d22fc386e1c53a5d98c3f219530fb commit)

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 840e47a4ccc5..3a0cca255b76 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -37,7 +37,7 @@ extern unsigned int xprt_max_resvport;
 
 #define RPC_MIN_RESVPORT	(1U)
 #define RPC_MAX_RESVPORT	(65535U)
-#define RPC_DEF_MIN_RESVPORT	(650U)
+#define RPC_DEF_MIN_RESVPORT	(665U)
 #define RPC_DEF_MAX_RESVPORT	(1023U)
 
 /*

commit e0ab53deaa91293a7958d63d5a2cf4c5645ad6f0
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Jul 27 17:22:50 2006 -0400

    RPC: Ensure that we disconnect TCP socket when client requests error out
    
    If we're part way through transmitting a TCP request, and the client
    errors, then we need to disconnect and reconnect the TCP socket in order to
    avoid confusing the server.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    (cherry picked from 031a50c8b9ea82616abd4a4e18021a25848941ce commit)

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e8bbe8118de8..840e47a4ccc5 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -229,7 +229,7 @@ int			xprt_reserve_xprt(struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
-void			xprt_abort_transmit(struct rpc_task *task);
+void			xprt_end_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);

commit e99170ff3b799a9fd43d538932a9231fac1de9d4
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Apr 18 13:21:42 2006 -0400

    NFS,SUNRPC: Fix compiler warnings if CONFIG_PROC_FS & CONFIG_SYSCTL are unset
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7eebbab7160b..e8bbe8118de8 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -53,6 +53,7 @@ struct rpc_timeout {
 
 struct rpc_task;
 struct rpc_xprt;
+struct seq_file;
 
 /*
  * This describes a complete RPC request

commit 262ca07de4d7f1bff20361c1353bb14b3607afb2
Author: Chuck Lever <cel@netapp.com>
Date:   Mon Mar 20 13:44:16 2006 -0500

    SUNRPC: add a handful of per-xprt counters
    
    Monitor generic transport events.  Add a transport switch callout to
    format transport counters for export to user-land.
    
    Test plan:
    Compile kernel with CONFIG_NFS enabled.
    
    Signed-off-by: Chuck Lever <cel@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 6ef99b14ff09..7eebbab7160b 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -114,6 +114,7 @@ struct rpc_xprt_ops {
 	void		(*release_request)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
+	void		(*print_stats)(struct rpc_xprt *xprt, struct seq_file *seq);
 };
 
 struct rpc_xprt {
@@ -187,6 +188,18 @@ struct rpc_xprt {
 
 	struct list_head	recv;
 
+	struct {
+		unsigned long		bind_count,	/* total number of binds */
+					connect_count,	/* total number of connects */
+					connect_start,	/* connect start timestamp */
+					connect_time,	/* jiffies waiting for connect */
+					sends,		/* how many complete requests */
+					recvs,		/* how many complete requests */
+					bad_xids;	/* lookup_rqst didn't find XID */
+
+		unsigned long long	req_u,		/* average requests on the wire */
+					bklog_u;	/* backlog queue utilization */
+	} stat;
 
 	void			(*old_data_ready)(struct sock *, int);
 	void			(*old_state_change)(struct sock *);

commit 632e3bdc5006334cea894d078660b691685e1075
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jan 3 09:55:55 2006 +0100

    SUNRPC: Ensure client closes the socket when server initiates a close
    
     If the server decides to close the RPC socket, we currently don't actually
     respond until either another RPC call is scheduled, or until xprt_autoclose()
     gets called by the socket expiry timer (which may be up to 5 minutes
     later).
    
     This patch ensures that xprt_autoclose() is called much sooner if the
     server closes the socket.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index dd860128ceda..6ef99b14ff09 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -254,6 +254,7 @@ int			xs_setup_tcp(struct rpc_xprt *xprt, struct rpc_timeout *to);
 #define XPRT_LOCKED		(0)
 #define XPRT_CONNECTED		(1)
 #define XPRT_CONNECTING		(2)
+#define XPRT_CLOSE_WAIT		(3)
 
 static inline void xprt_set_connected(struct rpc_xprt *xprt)
 {

commit 922004120b10dcb0ce04b55014168e8a7a8c1a0e
Author: Chuck Lever <cel@netapp.com>
Date:   Tue Jan 3 09:55:51 2006 +0100

    SUNRPC: transport switch API for setting port number
    
     At some point, transport endpoint addresses will no longer be IPv4.  To hide
     the structure of the rpc_xprt's address field from ULPs and port mappers,
     add an API for setting the port number during an RPC bind operation.
    
     Test-plan:
     Destructive testing (unplugging the network temporarily).  Connectathon
     with UDP and TCP.  NFSv2/3 and NFSv4 mounting should be carefully checked.
     Probably need to rig a server where certain services aren't running, or
     that returns an error for some typical operation.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 7885b9621ce3..dd860128ceda 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -104,6 +104,7 @@ struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
+	void		(*set_port)(struct rpc_xprt *xprt, unsigned short port);
 	void		(*connect)(struct rpc_task *task);
 	void *		(*buf_alloc)(struct rpc_task *task, size_t size);
 	void		(*buf_free)(struct rpc_task *task);

commit 02107148349f31eee7c0fb06fd7a880df73dbd20
Author: Chuck Lever <cel@netapp.com>
Date:   Tue Jan 3 09:55:49 2006 +0100

    SUNRPC: switchable buffer allocation
    
     Add RPC client transport switch support for replacing buffer management
     on a per-transport basis.
    
     In the current IPv4 socket transport implementation, RPC buffers are
     allocated as needed for each RPC message that is sent.  Some transport
     implementations may choose to use pre-allocated buffers for encoding,
     sending, receiving, and unmarshalling RPC messages, however.  For
     transports capable of direct data placement, the buffers can be carved
     out of a pre-registered area of memory rather than from a slab cache.
    
     Test-plan:
     Millions of fsx operations.  Performance characterization with "sio" and
     "iozone".  Use oprofile and other tools to look for significant regression
     in CPU utilization.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 3b8b6e823c70..7885b9621ce3 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -79,21 +79,19 @@ struct rpc_rqst {
 	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
 	struct list_head	rq_list;
 
+	__u32 *			rq_buffer;	/* XDR encode buffer */
+	size_t			rq_bufsize;
+
 	struct xdr_buf		rq_private_buf;		/* The receive buffer
 							 * used in the softirq.
 							 */
 	unsigned long		rq_majortimeo;	/* major timeout alarm */
 	unsigned long		rq_timeout;	/* Current timeout value */
 	unsigned int		rq_retries;	/* # of retries */
-	/*
-	 * For authentication (e.g. auth_des)
-	 */
-	u32			rq_creddata[2];
 	
 	/*
 	 * Partial send handling
 	 */
-	
 	u32			rq_bytes_sent;	/* Bytes we have sent */
 
 	unsigned long		rq_xtime;	/* when transmitted */
@@ -107,6 +105,8 @@ struct rpc_xprt_ops {
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*connect)(struct rpc_task *task);
+	void *		(*buf_alloc)(struct rpc_task *task, size_t size);
+	void		(*buf_free)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_task *task);

commit ead5e1c26fdcd969cf40c49cb0589d56879d240d
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Thu Oct 13 16:54:43 2005 -0400

    SUNRPC: Provide a callback to allow free pages allocated during xdr encoding
    
     For privacy, we need to allocate pages to store the encrypted data (passed
     in pages can't be used without the risk of corrupting data in the page cache).
     So we need a way to free that memory after the request has been transmitted.
    
     Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 068e1fb0868b..3b8b6e823c70 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -73,7 +73,10 @@ struct rpc_rqst {
 	int			rq_cong;	/* has incremented xprt->cong */
 	int			rq_received;	/* receive completed */
 	u32			rq_seqno;	/* gss seq no. used on req. */
-
+	int			rq_enc_pages_num;
+	struct page		**rq_enc_pages;	/* scratch pages for use by
+						   gss privacy code */
+	void (*rq_release_snd_buf)(struct rpc_rqst *); /* release rq_enc_pages */
 	struct list_head	rq_list;
 
 	struct xdr_buf		rq_private_buf;		/* The receive buffer

commit 5e5ce5be6f0161d2a069a4f8a1154fe639c5c02f
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Oct 18 14:20:11 2005 -0700

    RPC: allow call_encode() to delay transmission of an RPC call.
    
     Currently, call_encode will cause the entire RPC call to abort if it returns
     an error. This is unnecessarily rigid, and gets in the way of attempts
     to allow the NFSv4 layer to order RPC calls that carry sequence ids.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 99cad3ead81d..068e1fb0868b 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -211,6 +211,7 @@ int			xprt_reserve_xprt(struct rpc_task *task);
 int			xprt_reserve_xprt_cong(struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
+void			xprt_abort_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);

commit 470056c288334eb0b37be26c9ff8aee37ed1cc7a
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:56 2005 -0700

    [PATCH] RPC: rationalize set_buffer_size
    
     In fact, ->set_buffer_size should be completely functionless for non-UDP.
    
     Test-plan:
     Check socket buffer size on UDP sockets over time.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 2543adf18551..99cad3ead81d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -100,7 +100,7 @@ struct rpc_rqst {
 #define rq_slen			rq_snd_buf.len
 
 struct rpc_xprt_ops {
-	void		(*set_buffer_size)(struct rpc_xprt *xprt);
+	void		(*set_buffer_size)(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize);
 	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*connect)(struct rpc_task *task);
@@ -124,7 +124,7 @@ struct rpc_xprt {
 	unsigned long		cong;		/* current congestion */
 	unsigned long		cwnd;		/* congestion window */
 
-	unsigned int		rcvsize,	/* transport rcv buffer size */
+	size_t			rcvsize,	/* transport rcv buffer size */
 				sndsize;	/* transport send buffer size */
 
 	size_t			max_payload;	/* largest RPC payload size,

commit 03bf4b707eee06706c9db343dd5c905b7ee47ed2
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:55 2005 -0700

    [PATCH] RPC: parametrize various transport connect timeouts
    
     Each transport implementation can now set unique bind, connect,
     reestablishment, and idle timeout values.  These are variables,
     allowing the values to be modified dynamically.  This permits
     exponential backoff of any of these values, for instance.
    
     As an example, we implement exponential backoff for the connection
     reestablishment timeout.
    
     Test-plan:
     Destructive testing (unplugging the network temporarily).  Connectathon
     with UDP and TCP.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 9d9266cf8a36..2543adf18551 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -22,28 +22,6 @@ extern unsigned int xprt_tcp_slot_table_entries;
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE	(128U)
 
-/* Default timeout values */
-#define RPC_MAX_UDP_TIMEOUT	(60*HZ)
-#define RPC_MAX_TCP_TIMEOUT	(600*HZ)
-
-/*
- * Wait duration for an RPC TCP connection to be established.  Solaris
- * NFS over TCP uses 60 seconds, for example, which is in line with how
- * long a server takes to reboot.
- */
-#define RPC_CONNECT_TIMEOUT	(60*HZ)
-
-/*
- * Delay an arbitrary number of seconds before attempting to reconnect
- * after an error.
- */
-#define RPC_REESTABLISH_TIMEOUT	(15*HZ)
-
-/*
- * RPC transport idle timeout.
- */
-#define RPC_IDLE_DISCONNECT_TIMEOUT	(5*60*HZ)
-
 /*
  * RPC call and reply header size as number of 32bit words (verifier
  * size computed separately)
@@ -182,14 +160,19 @@ struct rpc_xprt {
 	/*
 	 * Connection of transports
 	 */
+	unsigned long		connect_timeout,
+				bind_timeout,
+				reestablish_timeout;
 	struct work_struct	connect_worker;
 	unsigned short		port;
+
 	/*
 	 * Disconnection of idle transports
 	 */
 	struct work_struct	task_cleanup;
 	struct timer_list	timer;
-	unsigned long		last_used;
+	unsigned long		last_used,
+				idle_timeout;
 
 	/*
 	 * Send stuff

commit 529b33c6db0120126b1381faa51406dc463acdc9
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:54 2005 -0700

    [PATCH] RPC: allow RPC client's port range to be adjustable
    
     Select an RPC client source port between 650 and 1023 instead of between
     1 and 800.  The old range conflicts with a number of network services.
     Provide sysctls to allow admins to select a different port range.
    
     Note that this doesn't affect user-level RPC library behavior, which
     still uses 1 to 800.
    
     Based on a suggestion by Olaf Kirch <okir@suse.de>.
    
     Test-plan:
     Repeated mount and unmount.  Destructive testing.  Idle timeouts.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index dcf0326bda01..9d9266cf8a36 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -51,6 +51,17 @@ extern unsigned int xprt_tcp_slot_table_entries;
 #define RPC_CALLHDRSIZE		6
 #define RPC_REPHDRSIZE		4
 
+/*
+ * Parameters for choosing a free port
+ */
+extern unsigned int xprt_min_resvport;
+extern unsigned int xprt_max_resvport;
+
+#define RPC_MIN_RESVPORT	(1U)
+#define RPC_MAX_RESVPORT	(65535U)
+#define RPC_DEF_MIN_RESVPORT	(650U)
+#define RPC_DEF_MAX_RESVPORT	(1023U)
+
 /*
  * This describes a timeout strategy
  */
@@ -62,6 +73,9 @@ struct rpc_timeout {
 	unsigned char		to_exponential;
 };
 
+struct rpc_task;
+struct rpc_xprt;
+
 /*
  * This describes a complete RPC request
  */
@@ -107,9 +121,6 @@ struct rpc_rqst {
 #define rq_svec			rq_snd_buf.head
 #define rq_slen			rq_snd_buf.len
 
-struct rpc_task;
-struct rpc_xprt;
-
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt);
 	int		(*reserve_xprt)(struct rpc_task *task);

commit 555ee3af161b037865793bd4bebc06b58daafde6
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:54 2005 -0700

    [PATCH] RPC: clean up after nocong was removed
    
     Clean-up:  Move some macros that are specific to the Van Jacobson
     implementation into xprt.c.  Get rid of the cong_wait field in
     rpc_xprt, which is no longer used.  Get rid of xprt_clear_backlog.
    
     Test-plan:
     Compile with CONFIG_NFS enabled.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 559fb471f6f2..dcf0326bda01 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -15,20 +15,6 @@
 #include <linux/sunrpc/sched.h>
 #include <linux/sunrpc/xdr.h>
 
-/*
- * The transport code maintains an estimate on the maximum number of out-
- * standing RPC requests, using a smoothed version of the congestion
- * avoidance implemented in 44BSD. This is basically the Van Jacobson
- * congestion algorithm: If a retransmit occurs, the congestion window is
- * halved; otherwise, it is incremented by 1/cwnd when
- *
- *	-	a reply is received and
- *	-	a full number of requests are outstanding and
- *	-	the congestion window hasn't been updated recently.
- *
- * Upper procedures may check whether a request would block waiting for
- * a free RPC slot by using the RPC_CONGESTED() macro.
- */
 extern unsigned int xprt_udp_slot_table_entries;
 extern unsigned int xprt_tcp_slot_table_entries;
 
@@ -36,12 +22,6 @@ extern unsigned int xprt_tcp_slot_table_entries;
 #define RPC_DEF_SLOT_TABLE	(16U)
 #define RPC_MAX_SLOT_TABLE	(128U)
 
-#define RPC_CWNDSHIFT		(8U)
-#define RPC_CWNDSCALE		(1U << RPC_CWNDSHIFT)
-#define RPC_INITCWND		RPC_CWNDSCALE
-#define RPC_MAXCWND(xprt)	((xprt)->max_reqs << RPC_CWNDSHIFT)
-#define RPCXPRT_CONGESTED(xprt) ((xprt)->cong >= (xprt)->cwnd)
-
 /* Default timeout values */
 #define RPC_MAX_UDP_TIMEOUT	(60*HZ)
 #define RPC_MAX_TCP_TIMEOUT	(600*HZ)
@@ -213,8 +193,6 @@ struct rpc_xprt {
 	void			(*old_data_ready)(struct sock *, int);
 	void			(*old_state_change)(struct sock *);
 	void			(*old_write_space)(struct sock *);
-
-	wait_queue_head_t	cong_wait;
 };
 
 #define XPRT_LAST_FRAG		(1 << 0)

commit ed63c003701a314c4893c11eceb9d68f8f46c662
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:53 2005 -0700

    [PATCH] RPC: remove xprt->nocong
    
     Get rid of the "xprt->nocong" variable.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss with UDP mounts.
     Look for significant regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 64e77658fa30..559fb471f6f2 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -172,7 +172,6 @@ struct rpc_xprt {
 	unsigned int		max_reqs;	/* total slots */
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
-				nocong	   : 1,	/* no congestion control */
 				resvport   : 1; /* use a reserved port */
 
 	/*

commit a58dd398f5db4f73d5c581069fd70a4304cc4f0a
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:53 2005 -0700

    [PATCH] RPC: add a release_rqst callout to the RPC transport switch
    
     The final place where congestion control state is adjusted is in
     xprt_release, where each request is finally released.  Add a callout
     there to allow transports to perform additional processing when a
     request is about to be released.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for significant
     regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 2e48752d55d9..64e77658fa30 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -138,6 +138,7 @@ struct rpc_xprt_ops {
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*timer)(struct rpc_task *task);
+	void		(*release_request)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
 };
@@ -262,6 +263,7 @@ void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_adjust_cwnd(struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
 void			xprt_complete_rqst(struct rpc_task *task, int copied);
+void			xprt_release_rqst_cong(struct rpc_task *task);
 void			xprt_disconnect(struct rpc_xprt *xprt);
 
 /*

commit 1570c1e41eabf6b7031f3e4322a2cf1cbe319fee
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:52 2005 -0700

    [PATCH] RPC: add generic interface for adjusting the congestion window
    
     A new interface that allows transports to adjust their congestion window
     using the Van Jacobson implementation in xprt.c is provided.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for
     significant regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 443c3f984cf9..2e48752d55d9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -258,9 +258,10 @@ void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_task *task);
 void			xprt_write_space(struct rpc_xprt *xprt);
+void			xprt_update_rtt(struct rpc_task *task);
 void			xprt_adjust_cwnd(struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
-void			xprt_complete_rqst(struct rpc_xprt *xprt, struct rpc_rqst *req, int copied);
+void			xprt_complete_rqst(struct rpc_task *task, int copied);
 void			xprt_disconnect(struct rpc_xprt *xprt);
 
 /*

commit 46c0ee8bc4ad3743de05e8b8b20201df44dcb6d3
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:52 2005 -0700

    [PATCH] RPC: separate xprt_timer implementations
    
     Allow transports to hook the retransmit timer interrupt.  Some transports
     calculate their congestion window here so that a retransmit timeout has
     immediate effect on the congestion window.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for significant
     regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 86833b725bb5..443c3f984cf9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -137,6 +137,7 @@ struct rpc_xprt_ops {
 	void		(*connect)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
+	void		(*timer)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
 };
@@ -257,6 +258,7 @@ void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_task *task);
 void			xprt_write_space(struct rpc_xprt *xprt);
+void			xprt_adjust_cwnd(struct rpc_task *task, int result);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
 void			xprt_complete_rqst(struct rpc_xprt *xprt, struct rpc_rqst *req, int copied);
 void			xprt_disconnect(struct rpc_xprt *xprt);

commit 49e9a89086b3cae784a4868ca852863e4f4ea3fe
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:51 2005 -0700

    [PATCH] RPC: expose API for serializing access to RPC transports
    
     The next method we abstract is the one that releases a transport,
     allowing another task to have access to the transport.
    
     Again, one generic version of this is provided for transports that
     don't need the RPC client to perform congestion control, and one
     version is for transports that can use the original Van Jacobson
     implementation in xprt.c.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for
     significant regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index eee1c6877851..86833b725bb5 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -133,6 +133,7 @@ struct rpc_xprt;
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt);
 	int		(*reserve_xprt)(struct rpc_task *task);
+	void		(*release_xprt)(struct rpc_xprt *xprt, struct rpc_task *task);
 	void		(*connect)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
@@ -238,6 +239,8 @@ int			xprt_reserve_xprt_cong(struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
+void			xprt_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task);
+void			xprt_release_xprt_cong(struct rpc_xprt *xprt, struct rpc_task *task);
 void			xprt_release(struct rpc_task *task);
 int			xprt_destroy(struct rpc_xprt *xprt);
 

commit 12a804698b29d040b7cdd92e8a44b0e75164dae9
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:51 2005 -0700

    [PATCH] RPC: expose API for serializing access to RPC transports
    
     The next several patches introduce an API that allows transports to
     choose whether the RPC client provides congestion control or whether
     the transport itself provides it.
    
     The first method we abstract is the one that serializes access to the
     RPC transport to prevent the bytes from different requests from mingling
     together.  This method provides proper request serialization and the
     opportunity to prevent new requests from being started because the
     transport is congested.
    
     The normal situation is for the transport to handle congestion control
     itself.  Although NFS over UDP was first, it has been recognized after
     years of experience that having the transport provide congestion control
     is much better than doing it in the RPC client.  Thus TCP, and probably
     every future transport implementation, will use the default method,
     xprt_lock_write, provided in xprt.c, which does not provide any kind
     of congestion control.  UDP can continue using the xprt.c-provided
     Van Jacobson congestion avoidance implementation.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for significant
     regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index ac08e99a81cb..eee1c6877851 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -132,6 +132,7 @@ struct rpc_xprt;
 
 struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt);
+	int		(*reserve_xprt)(struct rpc_task *task);
 	void		(*connect)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
 	void		(*set_retrans_timeout)(struct rpc_task *task);
@@ -232,6 +233,8 @@ void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long
  */
 void			xprt_connect(struct rpc_task *task);
 void			xprt_reserve(struct rpc_task *task);
+int			xprt_reserve_xprt(struct rpc_task *task);
+int			xprt_reserve_xprt_cong(struct rpc_task *task);
 int			xprt_prepare_transmit(struct rpc_task *task);
 void			xprt_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);

commit fe3aca290f17ae4978bd73d02aa4029f1c9c024c
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:50 2005 -0700

    [PATCH] RPC: add API to set transport-specific timeouts
    
     Prepare the way to remove the "xprt->nocong" variable by adding a callout
     to the RPC client transport switch API to handle setting RPC retransmit
     timeouts.
    
     Add a pair of generic helper functions that provide the ability to set a
     simple fixed timeout, or to set a timeout based on the state of a round-
     trip estimator.
    
     Test-plan:
     Use WAN simulation to cause sporadic bursty packet loss.  Look for significant
     regression in performance or client stability.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c9477f022efb..ac08e99a81cb 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -134,6 +134,7 @@ struct rpc_xprt_ops {
 	void		(*set_buffer_size)(struct rpc_xprt *xprt);
 	void		(*connect)(struct rpc_task *task);
 	int		(*send_request)(struct rpc_task *task);
+	void		(*set_retrans_timeout)(struct rpc_task *task);
 	void		(*close)(struct rpc_xprt *xprt);
 	void		(*destroy)(struct rpc_xprt *xprt);
 };
@@ -245,6 +246,8 @@ static inline u32 *xprt_skip_transport_header(struct rpc_xprt *xprt, u32 *p)
 /*
  * Transport switch helper functions
  */
+void			xprt_set_retrans_timeout_def(struct rpc_task *task);
+void			xprt_set_retrans_timeout_rtt(struct rpc_task *task);
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
 void			xprt_wait_for_buffer_space(struct rpc_task *task);
 void			xprt_write_space(struct rpc_xprt *xprt);

commit 43118c29dea2b23798bd42a147015cceee7fa885
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:49 2005 -0700

    [PATCH] RPC: get rid of xprt->stream
    
     Now we can fix up the last few places that use the "xprt->stream"
     variable, and get rid of it from the rpc_xprt structure.
    
     Test-plan:
     Destructive testing (unplugging the network temporarily).  Connectathon
     with UDP and TCP.
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 966c456a0f6d..c9477f022efb 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -168,8 +168,7 @@ struct rpc_xprt {
 	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
 				nocong	   : 1,	/* no congestion control */
-				resvport   : 1, /* use a reserved port */
-				stream     : 1;	/* TCP */
+				resvport   : 1; /* use a reserved port */
 
 	/*
 	 * XID

commit 808012fbb23a52ec59352445d2076d175ad4ab26
Author: Chuck Lever <cel@netapp.com>
Date:   Thu Aug 25 16:25:49 2005 -0700

    [PATCH] RPC: skip over transport-specific heads automatically
    
     Add a generic mechanism for skipping over transport-specific headers
     when constructing an RPC request.  This removes another "xprt->stream"
     dependency.
    
     Test-plan:
     Write-intensive workload on a single mount point (try both UDP and
     TCP).
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e73174c7e450..966c456a0f6d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -155,6 +155,8 @@ struct rpc_xprt {
 
 	size_t			max_payload;	/* largest RPC payload size,
 						   in bytes */
+	unsigned int		tsh_size;	/* size of transport specific
+						   header */
 
 	struct rpc_wait_queue	sending;	/* requests waiting to send */
 	struct rpc_wait_queue	resend;		/* requests waiting to resend */
@@ -236,6 +238,11 @@ int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release(struct rpc_task *task);
 int			xprt_destroy(struct rpc_xprt *xprt);
 
+static inline u32 *xprt_skip_transport_header(struct rpc_xprt *xprt, u32 *p)
+{
+	return p + xprt->tsh_size;
+}
+
 /*
  * Transport switch helper functions
  */

commit c7b2cae8a634015b72941ba2fc6c4bc9b8d3a129
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:50 2005 -0400

    [PATCH] RPC: separate TCP and UDP write space callbacks
    
     Split the socket write space callback function into a TCP version and UDP
     version, eliminating one dependence on the "xprt->stream" variable.
    
     Keep the common pieces of this path in xprt.c so other transports can use
     it too.
    
     Test-plan:
     Write-intensive workload on a single mount point.
    
     Version: Thu, 11 Aug 2005 16:07:51 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index bfbc492ae36d..e73174c7e450 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -240,6 +240,8 @@ int			xprt_destroy(struct rpc_xprt *xprt);
  * Transport switch helper functions
  */
 void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
+void			xprt_wait_for_buffer_space(struct rpc_task *task);
+void			xprt_write_space(struct rpc_xprt *xprt);
 struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
 void			xprt_complete_rqst(struct rpc_xprt *xprt, struct rpc_rqst *req, int copied);
 void			xprt_disconnect(struct rpc_xprt *xprt);

commit 55aa4f58aa43dc9a51fb80010630d94b96053a2e
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:47 2005 -0400

    [PATCH] RPC: client-side transport switch cleanup
    
     Clean-up: change some comments to reflect the realities of the new RPC
     transport switch mechanism.  Get rid of unused xprt_receive() prototype.
    
     Also, organize function prototypes in xprt.h by usage and scope.
    
     Test-plan:
     Compile kernel with CONFIG_NFS enabled.
    
     Version: Thu, 11 Aug 2005 16:07:21 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d5223993fca9..bfbc492ae36d 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -1,5 +1,5 @@
 /*
- *  linux/include/linux/sunrpc/clnt_xprt.h
+ *  linux/include/linux/sunrpc/xprt.h
  *
  *  Declarations for the RPC transport interface.
  *
@@ -150,8 +150,8 @@ struct rpc_xprt {
 	unsigned long		cong;		/* current congestion */
 	unsigned long		cwnd;		/* congestion window */
 
-	unsigned int		rcvsize,	/* socket receive buffer size */
-				sndsize;	/* socket send buffer size */
+	unsigned int		rcvsize,	/* transport rcv buffer size */
+				sndsize;	/* transport send buffer size */
 
 	size_t			max_payload;	/* largest RPC payload size,
 						   in bytes */
@@ -184,12 +184,12 @@ struct rpc_xprt {
 	unsigned long		tcp_copied,	/* copied to request */
 				tcp_flags;
 	/*
-	 * Connection of sockets
+	 * Connection of transports
 	 */
-	struct work_struct	sock_connect;
+	struct work_struct	connect_worker;
 	unsigned short		port;
 	/*
-	 * Disconnection of idle sockets
+	 * Disconnection of idle transports
 	 */
 	struct work_struct	task_cleanup;
 	struct timer_list	timer;
@@ -219,27 +219,36 @@ struct rpc_xprt {
 
 #ifdef __KERNEL__
 
-struct rpc_xprt *	xprt_create_proto(int proto, struct sockaddr_in *addr,
-					struct rpc_timeout *toparms);
-void			xprt_disconnect(struct rpc_xprt *);
-int			xprt_destroy(struct rpc_xprt *);
-void			xprt_set_timeout(struct rpc_timeout *, unsigned int,
-					unsigned long);
-struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *, u32);
-void			xprt_complete_rqst(struct rpc_xprt *,
-					struct rpc_rqst *, int);
-void			xprt_reserve(struct rpc_task *);
-int			xprt_prepare_transmit(struct rpc_task *);
-void			xprt_transmit(struct rpc_task *);
-void			xprt_receive(struct rpc_task *);
-void			xprt_wake_pending_tasks(struct rpc_xprt *, int);
+/*
+ * Transport operations used by ULPs
+ */
+struct rpc_xprt *	xprt_create_proto(int proto, struct sockaddr_in *addr, struct rpc_timeout *to);
+void			xprt_set_timeout(struct rpc_timeout *to, unsigned int retr, unsigned long incr);
+
+/*
+ * Generic internal transport functions
+ */
+void			xprt_connect(struct rpc_task *task);
+void			xprt_reserve(struct rpc_task *task);
+int			xprt_prepare_transmit(struct rpc_task *task);
+void			xprt_transmit(struct rpc_task *task);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
-void			xprt_release(struct rpc_task *);
-void			xprt_connect(struct rpc_task *);
-int			xs_setup_udp(struct rpc_xprt *,
-					struct rpc_timeout *);
-int			xs_setup_tcp(struct rpc_xprt *,
-					struct rpc_timeout *);
+void			xprt_release(struct rpc_task *task);
+int			xprt_destroy(struct rpc_xprt *xprt);
+
+/*
+ * Transport switch helper functions
+ */
+void			xprt_wake_pending_tasks(struct rpc_xprt *xprt, int status);
+struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *xprt, u32 xid);
+void			xprt_complete_rqst(struct rpc_xprt *xprt, struct rpc_rqst *req, int copied);
+void			xprt_disconnect(struct rpc_xprt *xprt);
+
+/*
+ * Socket transport setup operations
+ */
+int			xs_setup_udp(struct rpc_xprt *xprt, struct rpc_timeout *to);
+int			xs_setup_tcp(struct rpc_xprt *xprt, struct rpc_timeout *to);
 
 /*
  * Reserved bit positions in xprt->state

commit 44fbac2288dfed6f1963ac00bf922c3bcd779cd1
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:44 2005 -0400

    [PATCH] RPC: Add helper for waking tasks pending on a transport
    
     Clean-up: remove only reference to xprt->pending from the socket transport
     implementation.  This makes a cleaner interface for other transport
     implementations as well.
    
     Test-plan:
     Compile kernel with CONFIG_NFS enabled.
    
     Version: Thu, 11 Aug 2005 16:06:52 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 009a3bb4f997..d5223993fca9 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -232,6 +232,7 @@ void			xprt_reserve(struct rpc_task *);
 int			xprt_prepare_transmit(struct rpc_task *);
 void			xprt_transmit(struct rpc_task *);
 void			xprt_receive(struct rpc_task *);
+void			xprt_wake_pending_tasks(struct rpc_xprt *, int);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release(struct rpc_task *);
 void			xprt_connect(struct rpc_task *);

commit 2226feb6bcd0e5e117a9be3ea3dd3ffc14f3e41e
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:38 2005 -0400

    [PATCH] RPC: rename the sockstate field
    
     Clean-up: get rid of a name reference to sockets in the generic parts of the
     RPC client by renaming the sockstate field in the rpc_xprt structure.
    
     Test-plan:
     Compile kernel with CONFIG_NFS enabled.
    
     Version: Thu, 11 Aug 2005 16:05:53 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index 41ce296dded1..009a3bb4f997 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -163,7 +163,7 @@ struct rpc_xprt {
 	struct list_head	free;		/* free slots */
 	struct rpc_rqst *	slot;		/* slot table storage */
 	unsigned int		max_reqs;	/* total slots */
-	unsigned long		sockstate;	/* Socket state */
+	unsigned long		state;		/* transport state */
 	unsigned char		shutdown   : 1,	/* being shut down */
 				nocong	   : 1,	/* no congestion control */
 				resvport   : 1, /* use a reserved port */
@@ -240,16 +240,54 @@ int			xs_setup_udp(struct rpc_xprt *,
 int			xs_setup_tcp(struct rpc_xprt *,
 					struct rpc_timeout *);
 
-#define XPRT_LOCKED	0
-#define XPRT_CONNECT	1
-#define XPRT_CONNECTING	2
-
-#define xprt_connected(xp)		(test_bit(XPRT_CONNECT, &(xp)->sockstate))
-#define xprt_set_connected(xp)		(set_bit(XPRT_CONNECT, &(xp)->sockstate))
-#define xprt_test_and_set_connected(xp)	(test_and_set_bit(XPRT_CONNECT, &(xp)->sockstate))
-#define xprt_test_and_clear_connected(xp) \
-					(test_and_clear_bit(XPRT_CONNECT, &(xp)->sockstate))
-#define xprt_clear_connected(xp)	(clear_bit(XPRT_CONNECT, &(xp)->sockstate))
+/*
+ * Reserved bit positions in xprt->state
+ */
+#define XPRT_LOCKED		(0)
+#define XPRT_CONNECTED		(1)
+#define XPRT_CONNECTING		(2)
+
+static inline void xprt_set_connected(struct rpc_xprt *xprt)
+{
+	set_bit(XPRT_CONNECTED, &xprt->state);
+}
+
+static inline void xprt_clear_connected(struct rpc_xprt *xprt)
+{
+	clear_bit(XPRT_CONNECTED, &xprt->state);
+}
+
+static inline int xprt_connected(struct rpc_xprt *xprt)
+{
+	return test_bit(XPRT_CONNECTED, &xprt->state);
+}
+
+static inline int xprt_test_and_set_connected(struct rpc_xprt *xprt)
+{
+	return test_and_set_bit(XPRT_CONNECTED, &xprt->state);
+}
+
+static inline int xprt_test_and_clear_connected(struct rpc_xprt *xprt)
+{
+	return test_and_clear_bit(XPRT_CONNECTED, &xprt->state);
+}
+
+static inline void xprt_clear_connecting(struct rpc_xprt *xprt)
+{
+	smp_mb__before_clear_bit();
+	clear_bit(XPRT_CONNECTING, &xprt->state);
+	smp_mb__after_clear_bit();
+}
+
+static inline int xprt_connecting(struct rpc_xprt *xprt)
+{
+	return test_bit(XPRT_CONNECTING, &xprt->state);
+}
+
+static inline int xprt_test_and_set_connecting(struct rpc_xprt *xprt)
+{
+	return test_and_set_bit(XPRT_CONNECTING, &xprt->state);
+}
 
 #endif /* __KERNEL__*/
 

commit 5dc07727f86b25851e95193a0c484ea21b531c47
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:35 2005 -0400

    [PATCH] RPC: Rename xprt_lock
    
     Clean-up: Replace the xprt_lock with something more aptly named.  This lock
     single-threads the XID and request slot reservation process.
    
     Test-plan:
     Compile kernel with CONFIG_NFS enabled.
    
     Version: Thu, 11 Aug 2005 16:05:26 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index c4f903f0e17c..41ce296dded1 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -199,7 +199,7 @@ struct rpc_xprt {
 	 * Send stuff
 	 */
 	spinlock_t		transport_lock;	/* lock transport info */
-	spinlock_t		xprt_lock;	/* lock xprt info */
+	spinlock_t		reserve_lock;	/* lock slot table */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
 
 	struct list_head	recv;

commit 4a0f8c04f2ece949d54a0c4fd7490259cf23a58a
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:32 2005 -0400

    [PATCH] RPC: Rename sock_lock
    
     Clean-up: replace a name reference to sockets in the generic parts of the RPC
     client by renaming sock_lock in the rpc_xprt structure.
    
     Test-plan:
     Compile kernel with CONFIG_NFS enabled.
    
     Version: Thu, 11 Aug 2005 16:05:00 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index d82b47ab73cb..c4f903f0e17c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -198,7 +198,7 @@ struct rpc_xprt {
 	/*
 	 * Send stuff
 	 */
-	spinlock_t		sock_lock;	/* lock socket info */
+	spinlock_t		transport_lock;	/* lock transport info */
 	spinlock_t		xprt_lock;	/* lock xprt info */
 	struct rpc_task *	snd_task;	/* Task blocked in send */
 

commit a246b0105bbd9a70a698f69baae2042996f2a0e9
Author: Chuck Lever <cel@citi.umich.edu>
Date:   Thu Aug 11 16:25:23 2005 -0400

    [PATCH] RPC: introduce client-side transport switch
    
     Move the bulk of client-side socket-specific code into a separate source
     file, net/sunrpc/xprtsock.c.
    
     Test-plan:
     Millions of fsx operations.  Performance characterization such as "sio" or
     "iozone".  Destructive testing (unplugging the network temporarily, server
     reboots).  Connectathon with v2, v3, and v4.
    
     Version: Thu, 11 Aug 2005 16:03:38 -0400
    
     Signed-off-by: Chuck Lever <cel@netapp.com>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index e618c1649814..d82b47ab73cb 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -59,7 +59,13 @@ extern unsigned int xprt_tcp_slot_table_entries;
  */
 #define RPC_REESTABLISH_TIMEOUT	(15*HZ)
 
-/* RPC call and reply header size as number of 32bit words (verifier
+/*
+ * RPC transport idle timeout.
+ */
+#define RPC_IDLE_DISCONNECT_TIMEOUT	(5*60*HZ)
+
+/*
+ * RPC call and reply header size as number of 32bit words (verifier
  * size computed separately)
  */
 #define RPC_CALLHDRSIZE		6
@@ -121,12 +127,19 @@ struct rpc_rqst {
 #define rq_svec			rq_snd_buf.head
 #define rq_slen			rq_snd_buf.len
 
-#define XPRT_LAST_FRAG		(1 << 0)
-#define XPRT_COPY_RECM		(1 << 1)
-#define XPRT_COPY_XID		(1 << 2)
-#define XPRT_COPY_DATA		(1 << 3)
+struct rpc_task;
+struct rpc_xprt;
+
+struct rpc_xprt_ops {
+	void		(*set_buffer_size)(struct rpc_xprt *xprt);
+	void		(*connect)(struct rpc_task *task);
+	int		(*send_request)(struct rpc_task *task);
+	void		(*close)(struct rpc_xprt *xprt);
+	void		(*destroy)(struct rpc_xprt *xprt);
+};
 
 struct rpc_xprt {
+	struct rpc_xprt_ops *	ops;		/* transport methods */
 	struct socket *		sock;		/* BSD socket layer */
 	struct sock *		inet;		/* INET layer */
 
@@ -199,14 +212,22 @@ struct rpc_xprt {
 	wait_queue_head_t	cong_wait;
 };
 
+#define XPRT_LAST_FRAG		(1 << 0)
+#define XPRT_COPY_RECM		(1 << 1)
+#define XPRT_COPY_XID		(1 << 2)
+#define XPRT_COPY_DATA		(1 << 3)
+
 #ifdef __KERNEL__
 
 struct rpc_xprt *	xprt_create_proto(int proto, struct sockaddr_in *addr,
 					struct rpc_timeout *toparms);
+void			xprt_disconnect(struct rpc_xprt *);
 int			xprt_destroy(struct rpc_xprt *);
 void			xprt_set_timeout(struct rpc_timeout *, unsigned int,
 					unsigned long);
-
+struct rpc_rqst *	xprt_lookup_rqst(struct rpc_xprt *, u32);
+void			xprt_complete_rqst(struct rpc_xprt *,
+					struct rpc_rqst *, int);
 void			xprt_reserve(struct rpc_task *);
 int			xprt_prepare_transmit(struct rpc_task *);
 void			xprt_transmit(struct rpc_task *);
@@ -214,7 +235,10 @@ void			xprt_receive(struct rpc_task *);
 int			xprt_adjust_timeout(struct rpc_rqst *req);
 void			xprt_release(struct rpc_task *);
 void			xprt_connect(struct rpc_task *);
-void			xprt_sock_setbufsize(struct rpc_xprt *);
+int			xs_setup_udp(struct rpc_xprt *,
+					struct rpc_timeout *);
+int			xs_setup_tcp(struct rpc_xprt *,
+					struct rpc_timeout *);
 
 #define XPRT_LOCKED	0
 #define XPRT_CONNECT	1

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
new file mode 100644
index 000000000000..e618c1649814
--- /dev/null
+++ b/include/linux/sunrpc/xprt.h
@@ -0,0 +1,232 @@
+/*
+ *  linux/include/linux/sunrpc/clnt_xprt.h
+ *
+ *  Declarations for the RPC transport interface.
+ *
+ *  Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef _LINUX_SUNRPC_XPRT_H
+#define _LINUX_SUNRPC_XPRT_H
+
+#include <linux/uio.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/sunrpc/sched.h>
+#include <linux/sunrpc/xdr.h>
+
+/*
+ * The transport code maintains an estimate on the maximum number of out-
+ * standing RPC requests, using a smoothed version of the congestion
+ * avoidance implemented in 44BSD. This is basically the Van Jacobson
+ * congestion algorithm: If a retransmit occurs, the congestion window is
+ * halved; otherwise, it is incremented by 1/cwnd when
+ *
+ *	-	a reply is received and
+ *	-	a full number of requests are outstanding and
+ *	-	the congestion window hasn't been updated recently.
+ *
+ * Upper procedures may check whether a request would block waiting for
+ * a free RPC slot by using the RPC_CONGESTED() macro.
+ */
+extern unsigned int xprt_udp_slot_table_entries;
+extern unsigned int xprt_tcp_slot_table_entries;
+
+#define RPC_MIN_SLOT_TABLE	(2U)
+#define RPC_DEF_SLOT_TABLE	(16U)
+#define RPC_MAX_SLOT_TABLE	(128U)
+
+#define RPC_CWNDSHIFT		(8U)
+#define RPC_CWNDSCALE		(1U << RPC_CWNDSHIFT)
+#define RPC_INITCWND		RPC_CWNDSCALE
+#define RPC_MAXCWND(xprt)	((xprt)->max_reqs << RPC_CWNDSHIFT)
+#define RPCXPRT_CONGESTED(xprt) ((xprt)->cong >= (xprt)->cwnd)
+
+/* Default timeout values */
+#define RPC_MAX_UDP_TIMEOUT	(60*HZ)
+#define RPC_MAX_TCP_TIMEOUT	(600*HZ)
+
+/*
+ * Wait duration for an RPC TCP connection to be established.  Solaris
+ * NFS over TCP uses 60 seconds, for example, which is in line with how
+ * long a server takes to reboot.
+ */
+#define RPC_CONNECT_TIMEOUT	(60*HZ)
+
+/*
+ * Delay an arbitrary number of seconds before attempting to reconnect
+ * after an error.
+ */
+#define RPC_REESTABLISH_TIMEOUT	(15*HZ)
+
+/* RPC call and reply header size as number of 32bit words (verifier
+ * size computed separately)
+ */
+#define RPC_CALLHDRSIZE		6
+#define RPC_REPHDRSIZE		4
+
+/*
+ * This describes a timeout strategy
+ */
+struct rpc_timeout {
+	unsigned long		to_initval,		/* initial timeout */
+				to_maxval,		/* max timeout */
+				to_increment;		/* if !exponential */
+	unsigned int		to_retries;		/* max # of retries */
+	unsigned char		to_exponential;
+};
+
+/*
+ * This describes a complete RPC request
+ */
+struct rpc_rqst {
+	/*
+	 * This is the user-visible part
+	 */
+	struct rpc_xprt *	rq_xprt;		/* RPC client */
+	struct xdr_buf		rq_snd_buf;		/* send buffer */
+	struct xdr_buf		rq_rcv_buf;		/* recv buffer */
+
+	/*
+	 * This is the private part
+	 */
+	struct rpc_task *	rq_task;	/* RPC task data */
+	__u32			rq_xid;		/* request XID */
+	int			rq_cong;	/* has incremented xprt->cong */
+	int			rq_received;	/* receive completed */
+	u32			rq_seqno;	/* gss seq no. used on req. */
+
+	struct list_head	rq_list;
+
+	struct xdr_buf		rq_private_buf;		/* The receive buffer
+							 * used in the softirq.
+							 */
+	unsigned long		rq_majortimeo;	/* major timeout alarm */
+	unsigned long		rq_timeout;	/* Current timeout value */
+	unsigned int		rq_retries;	/* # of retries */
+	/*
+	 * For authentication (e.g. auth_des)
+	 */
+	u32			rq_creddata[2];
+	
+	/*
+	 * Partial send handling
+	 */
+	
+	u32			rq_bytes_sent;	/* Bytes we have sent */
+
+	unsigned long		rq_xtime;	/* when transmitted */
+	int			rq_ntrans;
+};
+#define rq_svec			rq_snd_buf.head
+#define rq_slen			rq_snd_buf.len
+
+#define XPRT_LAST_FRAG		(1 << 0)
+#define XPRT_COPY_RECM		(1 << 1)
+#define XPRT_COPY_XID		(1 << 2)
+#define XPRT_COPY_DATA		(1 << 3)
+
+struct rpc_xprt {
+	struct socket *		sock;		/* BSD socket layer */
+	struct sock *		inet;		/* INET layer */
+
+	struct rpc_timeout	timeout;	/* timeout parms */
+	struct sockaddr_in	addr;		/* server address */
+	int			prot;		/* IP protocol */
+
+	unsigned long		cong;		/* current congestion */
+	unsigned long		cwnd;		/* congestion window */
+
+	unsigned int		rcvsize,	/* socket receive buffer size */
+				sndsize;	/* socket send buffer size */
+
+	size_t			max_payload;	/* largest RPC payload size,
+						   in bytes */
+
+	struct rpc_wait_queue	sending;	/* requests waiting to send */
+	struct rpc_wait_queue	resend;		/* requests waiting to resend */
+	struct rpc_wait_queue	pending;	/* requests in flight */
+	struct rpc_wait_queue	backlog;	/* waiting for slot */
+	struct list_head	free;		/* free slots */
+	struct rpc_rqst *	slot;		/* slot table storage */
+	unsigned int		max_reqs;	/* total slots */
+	unsigned long		sockstate;	/* Socket state */
+	unsigned char		shutdown   : 1,	/* being shut down */
+				nocong	   : 1,	/* no congestion control */
+				resvport   : 1, /* use a reserved port */
+				stream     : 1;	/* TCP */
+
+	/*
+	 * XID
+	 */
+	__u32			xid;		/* Next XID value to use */
+
+	/*
+	 * State of TCP reply receive stuff
+	 */
+	u32			tcp_recm,	/* Fragment header */
+				tcp_xid,	/* Current XID */
+				tcp_reclen,	/* fragment length */
+				tcp_offset;	/* fragment offset */
+	unsigned long		tcp_copied,	/* copied to request */
+				tcp_flags;
+	/*
+	 * Connection of sockets
+	 */
+	struct work_struct	sock_connect;
+	unsigned short		port;
+	/*
+	 * Disconnection of idle sockets
+	 */
+	struct work_struct	task_cleanup;
+	struct timer_list	timer;
+	unsigned long		last_used;
+
+	/*
+	 * Send stuff
+	 */
+	spinlock_t		sock_lock;	/* lock socket info */
+	spinlock_t		xprt_lock;	/* lock xprt info */
+	struct rpc_task *	snd_task;	/* Task blocked in send */
+
+	struct list_head	recv;
+
+
+	void			(*old_data_ready)(struct sock *, int);
+	void			(*old_state_change)(struct sock *);
+	void			(*old_write_space)(struct sock *);
+
+	wait_queue_head_t	cong_wait;
+};
+
+#ifdef __KERNEL__
+
+struct rpc_xprt *	xprt_create_proto(int proto, struct sockaddr_in *addr,
+					struct rpc_timeout *toparms);
+int			xprt_destroy(struct rpc_xprt *);
+void			xprt_set_timeout(struct rpc_timeout *, unsigned int,
+					unsigned long);
+
+void			xprt_reserve(struct rpc_task *);
+int			xprt_prepare_transmit(struct rpc_task *);
+void			xprt_transmit(struct rpc_task *);
+void			xprt_receive(struct rpc_task *);
+int			xprt_adjust_timeout(struct rpc_rqst *req);
+void			xprt_release(struct rpc_task *);
+void			xprt_connect(struct rpc_task *);
+void			xprt_sock_setbufsize(struct rpc_xprt *);
+
+#define XPRT_LOCKED	0
+#define XPRT_CONNECT	1
+#define XPRT_CONNECTING	2
+
+#define xprt_connected(xp)		(test_bit(XPRT_CONNECT, &(xp)->sockstate))
+#define xprt_set_connected(xp)		(set_bit(XPRT_CONNECT, &(xp)->sockstate))
+#define xprt_test_and_set_connected(xp)	(test_and_set_bit(XPRT_CONNECT, &(xp)->sockstate))
+#define xprt_test_and_clear_connected(xp) \
+					(test_and_clear_bit(XPRT_CONNECT, &(xp)->sockstate))
+#define xprt_clear_connected(xp)	(clear_bit(XPRT_CONNECT, &(xp)->sockstate))
+
+#endif /* __KERNEL__*/
+
+#endif /* _LINUX_SUNRPC_XPRT_H */
