commit 02648908d19a99532b0839959e38ae53d95d2798
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Tue Mar 17 14:12:15 2020 -0400

    SUNRPC: Rename svc_sock::sk_reclen
    
    Clean up. I find the name of the svc_sock::sk_reclen field
    confusing, so I've changed it to better reflect its function. This
    field is not read directly to get the record length. Rather, it is
    a buffer containing a record marker that needs to be decoded.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 771baadaee9d..b7ac7fe68306 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -28,7 +28,7 @@ struct svc_sock {
 
 	/* private TCP part */
 	/* On-the-wire fragment header: */
-	__be32			sk_reclen;
+	__be32			sk_marker;
 	/* As we receive a record, this includes the length received so
 	 * far (including the fragment header): */
 	u32			sk_tcplen;
@@ -41,12 +41,12 @@ struct svc_sock {
 
 static inline u32 svc_sock_reclen(struct svc_sock *svsk)
 {
-	return ntohl(svsk->sk_reclen) & RPC_FRAGMENT_SIZE_MASK;
+	return be32_to_cpu(svsk->sk_marker) & RPC_FRAGMENT_SIZE_MASK;
 }
 
 static inline u32 svc_sock_final_rec(struct svc_sock *svsk)
 {
-	return ntohl(svsk->sk_reclen) & RPC_LAST_STREAM_FRAGMENT;
+	return be32_to_cpu(svsk->sk_marker) & RPC_LAST_STREAM_FRAGMENT;
 }
 
 /*

commit 4df493a260d4c1844437b28009013d5dc408d0df
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Tue Apr 9 12:13:37 2019 -0400

    SUNRPC: Cache the process user cred in the RPC server listener
    
    In order to be able to interpret uids and gids correctly in knfsd, we
    should cache the user namespace of the process that created the RPC
    server's listener. To do so, we refcount the credential of that process.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 119718a922f2..771baadaee9d 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -59,7 +59,8 @@ void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
 bool		svc_alien_sock(struct net *net, int fd);
 int		svc_addsock(struct svc_serv *serv, const int fd,
-					char *name_return, const size_t len);
+					char *name_return, const size_t len,
+					const struct cred *cred);
 void		svc_init_xprt_sock(void);
 void		svc_cleanup_xprt_sock(void);
 struct svc_xprt *svc_sock_create(struct svc_serv *serv, int prot);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 2e780134f449..119718a922f2 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * linux/include/linux/sunrpc/svcsock.h
  *

commit 454fd351f2e2b6baa926d61064aaf70d2a77976e
Merge: fd18f00dd9d4 eda43ce03919
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 12 17:31:22 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull yet more networking updates from David Miller:
    
     1) Various fixes to the new Redpine Signals wireless driver, from
        Fariya Fatima.
    
     2) L2TP PPP connect code takes PMTU from the wrong socket, fix from
        Dmitry Petukhov.
    
     3) UFO and TSO packets differ in whether they include the protocol
        header in gso_size, account for that in skb_gso_transport_seglen().
       From Florian Westphal.
    
     4) If VLAN untagging fails, we double free the SKB in the bridging
        output path.  From Toshiaki Makita.
    
     5) Several call sites of sk->sk_data_ready() were referencing an SKB
        just added to the socket receive queue in order to calculate the
        second argument via skb->len.  This is dangerous because the moment
        the skb is added to the receive queue it can be consumed in another
        context and freed up.
    
        It turns out also that none of the sk->sk_data_ready()
        implementations even care about this second argument.
    
        So just kill it off and thus fix all these use-after-free bugs as a
        side effect.
    
     6) Fix inverted test in tcp_v6_send_response(), from Lorenzo Colitti.
    
     7) pktgen needs to do locking properly for LLTX devices, from Daniel
        Borkmann.
    
     8) xen-netfront driver initializes TX array entries in RX loop :-) From
        Vincenzo Maffione.
    
     9) After refactoring, some tunnel drivers allow a tunnel to be
        configured on top itself.  Fix from Nicolas Dichtel.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (46 commits)
      vti: don't allow to add the same tunnel twice
      gre: don't allow to add the same tunnel twice
      drivers: net: xen-netfront: fix array initialization bug
      pktgen: be friendly to LLTX devices
      r8152: check RTL8152_UNPLUG
      net: sun4i-emac: add promiscuous support
      net/apne: replace IS_ERR and PTR_ERR with PTR_ERR_OR_ZERO
      net: ipv6: Fix oif in TCP SYN+ACK route lookup.
      drivers: net: cpsw: enable interrupts after napi enable and clearing previous interrupts
      drivers: net: cpsw: discard all packets received when interface is down
      net: Fix use after free by removing length arg from sk_data_ready callbacks.
      Drivers: net: hyperv: Address UDP checksum issues
      Drivers: net: hyperv: Negotiate suitable ndis version for offload support
      Drivers: net: hyperv: Allocate memory for all possible per-pecket information
      bridge: Fix double free and memory leak around br_allowed_ingress
      bonding: Remove debug_fs files when module init fails
      i40evf: program RSS LUT correctly
      i40evf: remove open-coded skb_cow_head
      ixgb: remove open-coded skb_cow_head
      igbvf: remove open-coded skb_cow_head
      ...

commit 676d23690fb62b5d51ba5d659935e9f7d9da9f8e
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Apr 11 16:15:36 2014 -0400

    net: Fix use after free by removing length arg from sk_data_ready callbacks.
    
    Several spots in the kernel perform a sequence like:
    
            skb_queue_tail(&sk->s_receive_queue, skb);
            sk->sk_data_ready(sk, skb->len);
    
    But at the moment we place the SKB onto the socket receive queue it
    can be consumed and freed up.  So this skb->len access is potentially
    to freed up memory.
    
    Furthermore, the skb->len can be modified by the consumer so it is
    possible that the value isn't accurate.
    
    And finally, no actual implementation of this callback actually uses
    the length argument.  And since nobody actually cared about it's
    value, lots of call sites pass arbitrary values in such as '0' and
    even '1'.
    
    So just remove the length argument from the callback, that way there
    is no confusion whatsoever and all of these use-after-free cases get
    fixed as a side effect.
    
    Based upon a patch by Eric Dumazet and his suggestion to audit this
    issue tree-wide.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 62fd1b756e99..88f7e1a477fe 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -22,7 +22,7 @@ struct svc_sock {
 
 	/* We keep the old state_change and data_ready CB's here */
 	void			(*sk_ostate)(struct sock *);
-	void			(*sk_odata)(struct sock *, int bytes);
+	void			(*sk_odata)(struct sock *);
 	void			(*sk_owspace)(struct sock *);
 
 	/* private TCP part */

commit 3064639423c48d6e0eb9ecc27c512a58e38c6c57
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Feb 26 16:50:01 2014 +0300

    nfsd: check passed socket's net matches NFSd superblock's one
    
    There could be a case, when NFSd file system is mounted in network, different
    to socket's one, like below:
    
    "ip netns exec" creates new network and mount namespace, which duplicates NFSd
    mount point, created in init_net context. And thus NFS server stop in nested
    network context leads to RPCBIND client destruction in init_net.
    Then, on NFSd start in nested network context, rpc.nfsd process creates socket
    in nested net and passes it into "write_ports", which leads to RPCBIND sockets
    creation in init_net context because of the same reason (NFSd monut point was
    created in init_net context). An attempt to register passed socket in nested
    net leads to panic, because no RPCBIND client present in nexted network
    namespace.
    
    This patch add check that passed socket's net matches NFSd superblock's one.
    And returns -EINVAL error to user psace otherwise.
    
    v2: Put socket on exit.
    
    Reported-by: Weng Meiling <wengmeiling.weng@huawei.com>
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 62fd1b756e99..947009ed5996 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -56,6 +56,7 @@ int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
+bool		svc_alien_sock(struct net *net, int fd);
 int		svc_addsock(struct svc_serv *serv, const int fd,
 					char *name_return, const size_t len);
 void		svc_init_xprt_sock(void);

commit 8af345f58ac9b350bb23c1457c613381d9f00472
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Mon Dec 3 16:45:35 2012 -0500

    svcrpc: track rpc data length separately from sk_tcplen
    
    Keep a separate field, sk_datalen, that tracks only the data contained
    in a fragment, not including the fragment header.
    
    For now, this is always just max(0, sk_tcplen - 4), but after we allow
    multiple fragments sk_datalen will accumulate the total rpc data size
    while sk_tcplen only tracks progress receiving the current fragment.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 613cf42227aa..62fd1b756e99 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -26,8 +26,15 @@ struct svc_sock {
 	void			(*sk_owspace)(struct sock *);
 
 	/* private TCP part */
-	__be32			sk_reclen;	/* length of record */
-	u32			sk_tcplen;	/* current read length */
+	/* On-the-wire fragment header: */
+	__be32			sk_reclen;
+	/* As we receive a record, this includes the length received so
+	 * far (including the fragment header): */
+	u32			sk_tcplen;
+	/* Total length of the data (not including fragment headers)
+	 * received so far in the fragments making up this rpc: */
+	u32			sk_datalen;
+
 	struct page *		sk_pages[RPCSVC_MAXPAGES];	/* received data */
 };
 

commit cc248d4b1ddf05fefc1373d9d7a4dd1df71b6190
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Mon Dec 3 16:11:13 2012 -0500

    svcrpc: don't byte-swap sk_reclen in place
    
    Byte-swapping in place is always a little dubious.
    
    Let's instead define this field to always be big-endian, and do the
    swapping on demand where we need it.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 92ad02f0dcc0..613cf42227aa 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -26,11 +26,21 @@ struct svc_sock {
 	void			(*sk_owspace)(struct sock *);
 
 	/* private TCP part */
-	u32			sk_reclen;	/* length of record */
+	__be32			sk_reclen;	/* length of record */
 	u32			sk_tcplen;	/* current read length */
 	struct page *		sk_pages[RPCSVC_MAXPAGES];	/* received data */
 };
 
+static inline u32 svc_sock_reclen(struct svc_sock *svsk)
+{
+	return ntohl(svsk->sk_reclen) & RPC_FRAGMENT_SIZE_MASK;
+}
+
+static inline u32 svc_sock_final_rec(struct svc_sock *svsk)
+{
+	return ntohl(svsk->sk_reclen) & RPC_LAST_STREAM_FRAGMENT;
+}
+
 /*
  * Function prototypes.
  */

commit eccf50c129686de11358093839749c83f6cae5db
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Aug 15 18:07:43 2012 -0400

    nfsd: remove unused listener-removal interfaces
    
    You can use nfsd/portlist to give nfsd additional sockets to listen on.
    In theory you can also remove listening sockets this way.  But nobody's
    ever done that as far as I can tell.
    
    Also this was partially broken in 2.6.25, by
    a217813f9067b785241cb7f31956e51d2071703a "knfsd: Support adding
    transports by writing portlist file".
    
    (Note that we decide whether to take the "delfd" case by checking for a
    digit--but what's actually expected in that case is something made by
    svc_one_sock_name(), which won't begin with a digit.)
    
    So, let's just rip out this stuff.
    
    Acked-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index cb4ac69e1f33..92ad02f0dcc0 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -39,9 +39,6 @@ int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
-int		svc_sock_names(struct svc_serv *serv, char *buf,
-					const size_t buflen,
-					const char *toclose);
 int		svc_addsock(struct svc_serv *serv, const int fd,
 					char *name_return, const size_t len);
 void		svc_init_xprt_sock(void);

commit 7b147f1ff267d12e0d189ca3d4156ed5a76b8d99
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Tue Jan 31 14:09:17 2012 +0400

    SUNRPC: service destruction in network namespace context
    
    v2: Added comment to BUG_ON's in svc_destroy() to make code looks clearer.
    
    This patch introduces network namespace filter for service destruction
    function.
    Nothing special here - just do exactly the same operations, but only for
    tranports in passed networks namespace context.
    BTW, BUG_ON() checks for empty service transports lists were returned into
    svc_destroy() function. This is because of swithing generic svc_close_all() to
    networks namespace dependable svc_close_net().
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index c84e9741cb2a..cb4ac69e1f33 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -34,7 +34,7 @@ struct svc_sock {
 /*
  * Function prototypes.
  */
-void		svc_close_all(struct svc_serv *);
+void		svc_close_net(struct svc_serv *, struct net *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);

commit 2fefb8a09e7ed251ae8996e0c69066e74c5aa560
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Nov 29 11:35:35 2011 -0500

    svcrpc: destroy server sockets all at once
    
    There's no reason I can see that we need to call sv_shutdown between
    closing the two lists of sockets.
    
    Cc: stable@kernel.org
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 85c50b40759d..c84e9741cb2a 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -34,7 +34,7 @@ struct svc_sock {
 /*
  * Function prototypes.
  */
-void		svc_close_all(struct list_head *);
+void		svc_close_all(struct svc_serv *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);

commit 31d68ef65c7d49def19c1bae4e01b87d66cf5a56
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Feb 24 11:25:33 2011 -0800

    SUNRPC: Don't wait for full record to receive tcp data
    
    Ensure that we immediately read and buffer data from the incoming TCP
    stream so that we grow the receive window quickly, and don't deadlock on
    large READ or WRITE requests.
    
    Also do some minor exit cleanup.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 04dba23c59f2..85c50b40759d 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -28,6 +28,7 @@ struct svc_sock {
 	/* private TCP part */
 	u32			sk_reclen;	/* length of record */
 	u32			sk_tcplen;	/* current read length */
+	struct page *		sk_pages[RPCSVC_MAXPAGES];	/* received data */
 };
 
 /*

commit d75faea330dbd1873c9094e9926ae306590c0998
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Nov 30 19:15:01 2010 -0500

    rpc: move sk_bc_xprt to svc_xprt
    
    This seems obviously transport-level information even if it's currently
    used only by the server socket code.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 1b353a76c304..04dba23c59f2 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -28,7 +28,6 @@ struct svc_sock {
 	/* private TCP part */
 	u32			sk_reclen;	/* length of record */
 	u32			sk_tcplen;	/* current read length */
-	struct rpc_xprt		*sk_bc_xprt;	/* NFSv4.1 backchannel xprt */
 };
 
 /*

commit 4cfc7e6019caa3e97d2a81c48c8d575d7b38d751
Author: Rahul Iyer <iyer@netapp.com>
Date:   Thu Sep 10 17:32:28 2009 +0300

    nfsd41: sunrpc: Added rpc server-side backchannel handling
    
    When the call direction is a reply, copy the xid and call direction into the
    req->rq_private_buf.head[0].iov_base otherwise rpc_verify_header returns
    rpc_garbage.
    
    Signed-off-by: Rahul Iyer <iyer@netapp.com>
    Signed-off-by: Mike Sager <sager@netapp.com>
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [get rid of CONFIG_NFSD_V4_1]
    [sunrpc: refactoring of svc_tcp_recvfrom]
    [nfsd41: sunrpc: create common send routine for the fore and the back channels]
    [nfsd41: sunrpc: Use free_page() to free server backchannel pages]
    [nfsd41: sunrpc: Document server backchannel locking]
    [nfsd41: sunrpc: remove bc_connect_worker()]
    [nfsd41: sunrpc: Define xprt_server_backchannel()[
    [nfsd41: sunrpc: remove bc_close and bc_init_auto_disconnect dummy functions]
    [nfsd41: sunrpc: eliminate unneeded switch statement in xs_setup_tcp()]
    [nfsd41: sunrpc: Don't auto close the server backchannel connection]
    [nfsd41: sunrpc: Remove unused functions]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Ricardo Labiaga <Ricardo.Labiaga@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [nfsd41: change bc_sock to bc_xprt]
    [nfsd41: sunrpc: move struct rpc_buffer def into a common header file]
    [nfsd41: sunrpc: use rpc_sleep in bc_send_request so not to block on mutex]
    [removed cosmetic changes]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    [sunrpc: add new xprt class for nfsv4.1 backchannel]
    [sunrpc: v2.1 change handling of auto_close and init_auto_disconnect operations for the nfsv4.1 backchannel]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    [reverted more cosmetic leftovers]
    [got rid of xprt_server_backchannel]
    [separated "nfsd41: sunrpc: add new xprt class for nfsv4.1 backchannel"]
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Cc: Trond Myklebust <trond.myklebust@netapp.com>
    [sunrpc: change idle timeout value for the backchannel]
    Signed-off-by: Alexandros Batsakis <batsakis@netapp.com>
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>
    Acked-by: Trond Myklebust <trond.myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 04dba23c59f2..1b353a76c304 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -28,6 +28,7 @@ struct svc_sock {
 	/* private TCP part */
 	u32			sk_reclen;	/* length of record */
 	u32			sk_tcplen;	/* current read length */
+	struct rpc_xprt		*sk_bc_xprt;	/* NFSv4.1 backchannel xprt */
 };
 
 /*

commit 7e0338c0de18c50f09aea1fbef45110cf7d64a3c
Merge: df36b439c5fe 47fcb03fefee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 12:55:50 2009 -0700

    Merge branch 'for-2.6.31' of git://fieldses.org/git/linux-nfsd
    
    * 'for-2.6.31' of git://fieldses.org/git/linux-nfsd: (60 commits)
      SUNRPC: Fix the TCP server's send buffer accounting
      nfsd41: Backchannel: minorversion support for the back channel
      nfsd41: Backchannel: cleanup nfs4.0 callback encode routines
      nfsd41: Remove ip address collision detection case
      nfsd: optimise the starting of zero threads when none are running.
      nfsd: don't take nfsd_mutex twice when setting number of threads.
      nfsd41: sanity check client drc maxreqs
      nfsd41: move channel attributes from nfsd4_session to a nfsd4_channel_attr struct
      NFS: kill off complicated macro 'PROC'
      sunrpc: potential memory leak in function rdma_read_xdr
      nfsd: minor nfsd_vfs_write cleanup
      nfsd: Pull write-gathering code out of nfsd_vfs_write
      nfsd: track last inode only in use_wgather case
      sunrpc: align cache_clean work's timer
      nfsd: Use write gathering only with NFSv2
      NFSv4: kill off complicated macro 'PROC'
      NFSv4: do exact check about attribute specified
      knfsd: remove unreported filehandle stats counters
      knfsd: fix reply cache memory corruption
      knfsd: reply cache cleanups
      ...

commit 7652e5a09ba319241607b22d9055ce93fd5b8039
Author: Benny Halevy <bhalevy@panasas.com>
Date:   Wed Apr 1 09:23:09 2009 -0400

    nfs41: sunrpc: provide functions to create and destroy a svc_xprt for backchannel use
    
    For nfs41 callbacks we need an svc_xprt to process requests coming up the
    backchannel socket as rpc_rqst's that are transformed into svc_rqst's that
    need a rq_xprt to be processed.
    
    The svc_{udp,tcp}_create methods are too heavy for this job as svc_create_socket
    creates an actual socket to listen on while for nfs41 we're "reusing" the
    fore channel's socket.
    
    Signed-off-by: Benny Halevy <bhalevy@panasas.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 483e10380aae..6bb1ec4ae310 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -42,6 +42,8 @@ int		svc_sock_names(char *buf, struct svc_serv *serv, char *toclose);
 int		svc_addsock(struct svc_serv *serv, int fd, char *name_return);
 void		svc_init_xprt_sock(void);
 void		svc_cleanup_xprt_sock(void);
+struct svc_xprt *svc_sock_create(struct svc_serv *serv, int prot);
+void		svc_sock_destroy(struct svc_xprt *);
 
 /*
  * svc_makesock socket characteristics

commit 8435d34dbbe75678c3cdad3d53b1e7996a79b3bf
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Apr 23 19:32:40 2009 -0400

    SUNRPC: pass buffer size to svc_sock_names()
    
    Adjust the synopsis of svc_sock_names() to pass in the size of the
    output buffer.  Add a documenting comment.
    
    This is a cosmetic change for now.  A subsequent patch will make sure
    the buffer length is passed to one_sock_name(), where the length will
    actually be useful.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index e23241c53f42..827163138949 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -38,7 +38,9 @@ int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
-int		svc_sock_names(char *buf, struct svc_serv *serv, char *toclose);
+int		svc_sock_names(struct svc_serv *serv, char *buf,
+					const size_t buflen,
+					const char *toclose);
 int		svc_addsock(struct svc_serv *serv, const int fd,
 					char *name_return, const size_t len);
 void		svc_init_xprt_sock(void);

commit bfba9ab4c64f0e5c33930711e6c073c285e01fcf
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Thu Apr 23 19:32:33 2009 -0400

    SUNRPC: pass buffer size to svc_addsock()
    
    Adjust the synopsis of svc_addsock() to pass in the size of the output
    buffer.  Add a documenting comment.
    
    This is a cosmetic change for now.  A subsequent patch will make sure
    the buffer length is passed to one_sock_name(), where the length will
    actually be useful.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 483e10380aae..e23241c53f42 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -39,7 +39,8 @@ int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
 int		svc_sock_names(char *buf, struct svc_serv *serv, char *toclose);
-int		svc_addsock(struct svc_serv *serv, int fd, char *name_return);
+int		svc_addsock(struct svc_serv *serv, const int fd,
+					char *name_return, const size_t len);
 void		svc_init_xprt_sock(void);
 void		svc_cleanup_xprt_sock(void);
 

commit 2937391385807b3da9cd7a39345259caf550b032
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Fri Oct 3 17:15:38 2008 -0400

    NLM: Remove unused argument from svc_addsock() function
    
    Clean up: The svc_addsock() function no longer uses its "proto"
    argument, so remove it.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Neil Brown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 8cff696dedf5..483e10380aae 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -39,10 +39,7 @@ int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
 int		svc_sock_names(char *buf, struct svc_serv *serv, char *toclose);
-int		svc_addsock(struct svc_serv *serv,
-			    int fd,
-			    char *name_return,
-			    int *proto);
+int		svc_addsock(struct svc_serv *serv, int fd, char *name_return);
 void		svc_init_xprt_sock(void);
 void		svc_cleanup_xprt_sock(void);
 

commit c0401ea008fb7c785a93428752d69dccafb127ec
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Apr 14 12:27:30 2008 -0400

    SUNRPC: Update RPC server's TCP record marker decoder
    
    Clean up: Update the RPC server's TCP record marker decoder to match the
    constructs used by the RPC client's TCP socket transport.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 206f092ad4c7..8cff696dedf5 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -26,8 +26,8 @@ struct svc_sock {
 	void			(*sk_owspace)(struct sock *);
 
 	/* private TCP part */
-	int			sk_reclen;	/* length of record */
-	int			sk_tcplen;	/* current read length */
+	u32			sk_reclen;	/* length of record */
+	u32			sk_tcplen;	/* current read length */
 };
 
 /*

commit 9dbc240f199c16c3c0859c255ad52a663d8ee51d
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:12 2007 -0600

    svc: Move the sockaddr information to svc_xprt
    
    This patch moves the transport sockaddr to the svc_xprt
    structure.  Convenience functions are added to set and
    get the local and remote addresses of a transport from
    the transport provider as well as determine the length
    of a sockaddr.
    
    A transport is responsible for setting the xpt_local
    and xpt_remote addresses in the svc_xprt structure as
    part of transport creation and xpo_accept processing. This
    cannot be done in a generic way and in fact varies
    between TCP, UDP and RDMA. A set of xpo_ functions
    (e.g. getlocalname, getremotename) could have been
    added but this would have resulted in additional
    caching and copying of the addresses around.  Note that
    the xpt_local address should also be set on listening
    endpoints; for TCP/RDMA this is done as part of
    endpoint creation.
    
    For connected transports like TCP and RDMA, the addresses
    never change and can be set once and copied into the
    rqstp structure for each request. For UDP, however, the
    local and remote addresses may change for each request. In
    this case, the address information is obtained from the
    UDP recvmsg info and copied into the rqstp structure from
    there.
    
    A svc_xprt_local_port function was also added that returns
    the local port given a transport. This is used by
    svc_create_xprt when returning the port associated with
    a newly created transport, and later when creating a
    generic find transport service to check if a service is
    already listening on a given port.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 96a229e6b9c9..206f092ad4c7 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -28,10 +28,6 @@ struct svc_sock {
 	/* private TCP part */
 	int			sk_reclen;	/* length of record */
 	int			sk_tcplen;	/* current read length */
-
-	struct sockaddr_storage	sk_local;	/* local address */
-	struct sockaddr_storage	sk_remote;	/* remote peer's address */
-	int			sk_remotelen;	/* length of address */
 };
 
 /*

commit 8c7b0172a1db8120d25ecb4eff69664c52ee7639
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:10 2007 -0600

    svc: Make deferral processing xprt independent
    
    This patch moves the transport independent sk_deferred list to the svc_xprt
    structure and updates the svc_deferred_req structure to keep pointers to
    svc_xprt's directly. The deferral processing code is also moved out of the
    transport dependent recvfrom functions and into the generic svc_recv path.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index f2ed6a25a7aa..96a229e6b9c9 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -20,9 +20,6 @@ struct svc_sock {
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
-	struct list_head	sk_deferred;	/* deferred requests that need to
-						 * be revisted */
-
 	/* We keep the old state_change and data_ready CB's here */
 	void			(*sk_ostate)(struct sock *);
 	void			(*sk_odata)(struct sock *, int bytes);

commit def13d7401e9b95bbd34c20057ebeb2972708b1b
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:08 2007 -0600

    svc: Move the authinfo cache to svc_xprt.
    
    Move the authinfo cache to svc_xprt. This allows both the TCP and RDMA
    transports to share this logic. A flag bit is used to determine if
    auth information is to be cached or not. Previously, this code looked
    at the transport protocol.
    
    I've also changed the spin_lock/unlock logic so that a lock is not taken for
    transports that are not caching auth info.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 406d0031b989..f2ed6a25a7aa 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -20,8 +20,6 @@ struct svc_sock {
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
-	spinlock_t		sk_lock;	/* protects sk_deferred and
-						 * sk_info_authunix */
 	struct list_head	sk_deferred;	/* deferred requests that need to
 						 * be revisted */
 
@@ -34,9 +32,6 @@ struct svc_sock {
 	int			sk_reclen;	/* length of record */
 	int			sk_tcplen;	/* current read length */
 
-	/* cache of various info for TCP sockets */
-	void			*sk_info_authunix;
-
 	struct sockaddr_storage	sk_local;	/* local address */
 	struct sockaddr_storage	sk_remote;	/* remote peer's address */
 	int			sk_remotelen;	/* length of address */

commit 4bc6c497b26a7984cac842a09e2e8f8c46242782
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:08:05 2007 -0600

    svc: Remove sk_lastrecv
    
    With the implementation of the new mark and sweep algorithm for shutting
    down old connections, the sk_lastrecv field is no longer needed.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 41c2dfaf7371..406d0031b989 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -33,7 +33,6 @@ struct svc_sock {
 	/* private TCP part */
 	int			sk_reclen;	/* length of record */
 	int			sk_tcplen;	/* current read length */
-	time_t			sk_lastrecv;	/* time of last received request */
 
 	/* cache of various info for TCP sockets */
 	void			*sk_info_authunix;

commit a50fea26b9d2aa7b66fdd6d9579de10827ec086a
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:59 2007 -0600

    svc: Make svc_send transport neutral
    
    Move the sk_mutex field to the transport independent svc_xprt structure.
    Now all the fields that svc_send touches are transport neutral. Change the
    svc_send function to use the transport independent svc_xprt directly instead
    of the transport dependent svc_sock structure.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index ba41f11788f2..41c2dfaf7371 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -24,7 +24,6 @@ struct svc_sock {
 						 * sk_info_authunix */
 	struct list_head	sk_deferred;	/* deferred requests that need to
 						 * be revisted */
-	struct mutex		sk_mutex;	/* to serialize sending data */
 
 	/* We keep the old state_change and data_ready CB's here */
 	void			(*sk_ostate)(struct sock *);

commit 7a90e8cc21ad80529b3a3371dc97acc8832cc592
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:55 2007 -0600

    svc: Move sk_reserved to svc_xprt
    
    This functionally trivial patch moves the sk_reserved field to the
    transport independent svc_xprt structure.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 060508ba358b..ba41f11788f2 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -20,8 +20,6 @@ struct svc_sock {
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
-	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
-
 	spinlock_t		sk_lock;	/* protects sk_deferred and
 						 * sk_info_authunix */
 	struct list_head	sk_deferred;	/* deferred requests that need to

commit 7a18208383ab3f3ce4a1f4e0536acc9372523d81
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:53 2007 -0600

    svc: Make close transport independent
    
    Move sk_list and sk_ready to svc_xprt. This involves close because these
    lists are walked by svcs when closing all their transports. So I combined
    the moving of these lists to svc_xprt with making close transport independent.
    
    The svc_force_sock_close has been changed to svc_close_all and takes a list
    as an argument. This removes some svc internals knowledge from the svcs.
    
    This code races with module removal and transport addition.
    
    Thanks to Simon Holm Thøgersen for a compile fix.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Cc: Simon Holm Thøgersen <odie@cs.aau.dk>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 92d4cc99c60d..060508ba358b 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -17,8 +17,6 @@
  */
 struct svc_sock {
 	struct svc_xprt		sk_xprt;
-	struct list_head	sk_ready;	/* list of ready sockets */
-	struct list_head	sk_list;	/* list of all sockets */
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
@@ -51,7 +49,7 @@ struct svc_sock {
 /*
  * Function prototypes.
  */
-void		svc_force_close_socket(struct svc_sock *);
+void		svc_close_all(struct list_head *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);

commit bb5cf160b282644c4491afbf76fbc66f5dc35030
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:50 2007 -0600

    svc: Move sk_server and sk_pool to svc_xprt
    
    This is another incremental change that moves transport independent
    fields from svc_sock to the svc_xprt structure. The changes
    should be functionally null.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index b8a8496dfc7c..92d4cc99c60d 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -22,8 +22,6 @@ struct svc_sock {
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
-	struct svc_pool *	sk_pool;	/* current pool iff queued */
-	struct svc_serv *	sk_server;	/* service for this socket */
 	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
 
 	spinlock_t		sk_lock;	/* protects sk_deferred and

commit 02fc6c36188be0ad19502cfd39266150ffab7603
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:48 2007 -0600

    svc: Move sk_flags to the svc_xprt structure
    
    This functionally trivial change moves the transport independent sk_flags
    field to the transport independent svc_xprt structure.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index ba07d50cb11b..b8a8496dfc7c 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -24,19 +24,6 @@ struct svc_sock {
 
 	struct svc_pool *	sk_pool;	/* current pool iff queued */
 	struct svc_serv *	sk_server;	/* service for this socket */
-	unsigned long		sk_flags;
-#define	SK_BUSY		0			/* enqueued/receiving */
-#define	SK_CONN		1			/* conn pending */
-#define	SK_CLOSE	2			/* dead or dying */
-#define	SK_DATA		3			/* data pending */
-#define	SK_TEMP		4			/* temp (TCP) socket */
-#define	SK_DEAD		6			/* socket closed */
-#define	SK_CHNGBUF	7			/* need to change snd/rcv buffer sizes */
-#define	SK_DEFERRED	8			/* request on sk_deferred */
-#define	SK_OLD		9			/* used for temp socket aging mark+sweep */
-#define	SK_DETACHED	10			/* detached from tempsocks list */
-#define SK_LISTENER	11			/* listening endpoint */
-
 	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
 
 	spinlock_t		sk_lock;	/* protects sk_deferred and

commit e1b3157f9710622bad6c7747d3b08ed3d2394cf6
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:46 2007 -0600

    svc: Change sk_inuse to a kref
    
    Change the atomic_t reference count to a kref and move it to the
    transport indepenent svc_xprt structure. Change the reference count
    wrapper names to be generic.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 3181d9d4caa0..ba07d50cb11b 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -24,7 +24,6 @@ struct svc_sock {
 
 	struct svc_pool *	sk_pool;	/* current pool iff queued */
 	struct svc_serv *	sk_server;	/* service for this socket */
-	atomic_t		sk_inuse;	/* use count */
 	unsigned long		sk_flags;
 #define	SK_BUSY		0			/* enqueued/receiving */
 #define	SK_CONN		1			/* conn pending */

commit d7c9f1ed972b4a468dd24a2457721704dfe9ca70
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:44 2007 -0600

    svc: Change services to use new svc_create_xprt service
    
    Modify the various kernel RPC svcs to use the svc_create_xprt service.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 9882ce0ee33c..3181d9d4caa0 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -67,7 +67,6 @@ struct svc_sock {
 /*
  * Function prototypes.
  */
-int		svc_makesock(struct svc_serv *, int, unsigned short, int flags);
 void		svc_force_close_socket(struct svc_sock *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);

commit 38a417cc993f4535548e47207f9894e7c27e05e4
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:36 2007 -0600

    svc: Add xpo_accept transport function
    
    Previously, the accept logic looked into the socket state to determine
    whether to call accept or recv when data-ready was indicated on an endpoint.
    Since some transports don't use sockets, this logic now uses a flag
    bit (SK_LISTENER) to identify listening endpoints. A transport function
    (xpo_accept) allows each transport to define its own accept processing.
    A transport's initialization logic is reponsible for setting the
    SK_LISTENER bit. I didn't see any way to do this in transport independent
    logic since the passive side of a UDP connection doesn't listen and
    always recv's.
    
    In the svc_recv function, if the SK_LISTENER bit is set, the transport
    xpo_accept function is called to handle accept processing.
    
    Note that all functions are defined even if they don't make sense
    for a given transport. For example, accept doesn't mean anything for
    UDP. The function is defined anyway and bug checks if called. The
    UDP transport should never set the SK_LISTENER bit.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 08e78d0a364f..9882ce0ee33c 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -36,6 +36,7 @@ struct svc_sock {
 #define	SK_DEFERRED	8			/* request on sk_deferred */
 #define	SK_OLD		9			/* used for temp socket aging mark+sweep */
 #define	SK_DETACHED	10			/* detached from tempsocks list */
+#define SK_LISTENER	11			/* listening endpoint */
 
 	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
 

commit 5d137990f5860451a6e0428e0903f62933d05287
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:23 2007 -0600

    svc: Move sk_sendto and sk_recvfrom to svc_xprt_class
    
    The sk_sendto and sk_recvfrom are function pointers that allow svc_sock
    to be used for both UDP and TCP. Move these function pointers to the
    svc_xprt_ops structure.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 1878cbe1aa4f..08e78d0a364f 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -45,9 +45,6 @@ struct svc_sock {
 						 * be revisted */
 	struct mutex		sk_mutex;	/* to serialize sending data */
 
-	int			(*sk_recvfrom)(struct svc_rqst *rqstp);
-	int			(*sk_sendto)(struct svc_rqst *rqstp);
-
 	/* We keep the old state_change and data_ready CB's here */
 	void			(*sk_ostate)(struct sock *);
 	void			(*sk_odata)(struct sock *, int bytes);

commit 360d873864c8903a650b227758b49dd50e6ecc9f
Author: Tom Tucker <tom@opengridcomputing.com>
Date:   Sun Dec 30 21:07:17 2007 -0600

    svc: Make svc_sock the tcp/udp transport
    
    Make TCP and UDP svc_sock transports, and register them
    with the svc transport core.
    
    A transport type (svc_sock) has an svc_xprt as its first member,
    and calls svc_xprt_init to initialize this field.
    
    Signed-off-by: Tom Tucker <tom@opengridcomputing.com>
    Acked-by: Neil Brown <neilb@suse.de>
    Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
    Reviewed-by: Greg Banks <gnb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index a53e0fa855d2..1878cbe1aa4f 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -10,11 +10,13 @@
 #define SUNRPC_SVCSOCK_H
 
 #include <linux/sunrpc/svc.h>
+#include <linux/sunrpc/svc_xprt.h>
 
 /*
  * RPC server socket.
  */
 struct svc_sock {
+	struct svc_xprt		sk_xprt;
 	struct list_head	sk_ready;	/* list of ready sockets */
 	struct list_head	sk_list;	/* list of all sockets */
 	struct socket *		sk_sock;	/* berkeley socket layer */
@@ -78,6 +80,8 @@ int		svc_addsock(struct svc_serv *serv,
 			    int fd,
 			    char *name_return,
 			    int *proto);
+void		svc_init_xprt_sock(void);
+void		svc_cleanup_xprt_sock(void);
 
 /*
  * svc_makesock socket characteristics

commit a97476926ec061f90b77da478620ea6dc71a3237
Author: Frank van Maarseveen <frankvm@frankvm.com>
Date:   Mon Jul 9 22:21:39 2007 +0200

    SUNRPC server: record the destination address of a request
    
    Save the destination address of an incoming request over TCP like is
    done already for UDP. It is necessary later for callbacks by the server.
    
    Signed-off-by: Frank van Maarseveen <frankvm@frankvm.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index e21dd93ac4b7..a53e0fa855d2 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -59,6 +59,7 @@ struct svc_sock {
 	/* cache of various info for TCP sockets */
 	void			*sk_info_authunix;
 
+	struct sockaddr_storage	sk_local;	/* local address */
 	struct sockaddr_storage	sk_remote;	/* remote peer's address */
 	int			sk_remotelen;	/* length of address */
 };

commit 7ac1bea5507218da03f6005d228789da5a831c3f
Author: NeilBrown <neilb@suse.de>
Date:   Wed May 9 02:34:48 2007 -0700

    knfsd: rename sk_defer_lock to sk_lock
    
    Now that sk_defer_lock protects two different things, make the name more
    generic.
    
    Also don't bother with disabling _bh as the lock is only ever taken from
    process context.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 7909687557bf..e21dd93ac4b7 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -37,7 +37,8 @@ struct svc_sock {
 
 	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
 
-	spinlock_t		sk_defer_lock;	/* protects sk_deferred */
+	spinlock_t		sk_lock;	/* protects sk_deferred and
+						 * sk_info_authunix */
 	struct list_head	sk_deferred;	/* deferred requests that need to
 						 * be revisted */
 	struct mutex		sk_mutex;	/* to serialize sending data */

commit cda1fd4abd773216a888487af0170d0cc3d50454
Author: NeilBrown <neilb@suse.de>
Date:   Tue Mar 6 01:42:22 2007 -0800

    [PATCH] knfsd: fix recently introduced problem with shutting down a busy NFS server
    
    When the last thread of nfsd exits, it shuts down all related sockets.  It
    currently uses svc_close_socket to do this, but that only is immediately
    effective if the socket is not SK_BUSY.
    
    If the socket is busy - i.e.  if a request has arrived that has not yet been
    processes - svc_close_socket is not effective and the shutdown process spins.
    
    So create a new svc_force_close_socket which removes the SK_BUSY flag is set
    and then calls svc_close_socket.
    
    Also change some open-codes loops in svc_destroy to use
    list_for_each_entry_safe.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index cccea0a0feb4..7909687557bf 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -66,7 +66,7 @@ struct svc_sock {
  * Function prototypes.
  */
 int		svc_makesock(struct svc_serv *, int, unsigned short, int flags);
-void		svc_close_socket(struct svc_sock *);
+void		svc_force_close_socket(struct svc_sock *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);

commit 067d7817310569f7b76ca08c4d071ca95ad4c1d3
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 12 00:53:30 2007 -0800

    [PATCH] knfsd: SUNRPC: Cache remote peer's address in svc_sock
    
    The remote peer's address won't change after the socket has been accepted.  We
    don't need to call ->getname on every incoming request.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index f030409d2994..cccea0a0feb4 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -57,6 +57,9 @@ struct svc_sock {
 
 	/* cache of various info for TCP sockets */
 	void			*sk_info_authunix;
+
+	struct sockaddr_storage	sk_remote;	/* remote peer's address */
+	int			sk_remotelen;	/* length of address */
 };
 
 /*

commit 482fb94e1b0c2efe8258334aa2a68d4f4a91de9c
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 12 00:53:29 2007 -0800

    [PATCH] knfsd: SUNRPC: allow creating an RPC service without registering with portmapper
    
    Sometimes we need to create an RPC service but not register it with the local
    portmapper.  NFSv4 delegation callback, for example.
    
    Change the svc_makesock() API to allow optionally creating temporary or
    permanent sockets, optionally registering with the local portmapper, and make
    it return the ephemeral port of the new socket.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index cef11a6e81e9..f030409d2994 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -62,7 +62,7 @@ struct svc_sock {
 /*
  * Function prototypes.
  */
-int		svc_makesock(struct svc_serv *, int, unsigned short);
+int		svc_makesock(struct svc_serv *, int, unsigned short, int flags);
 void		svc_close_socket(struct svc_sock *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);

commit 6b174337e5126de834a971d3edc3681bbfa45e2c
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Feb 12 00:53:28 2007 -0800

    [PATCH] knfsd: SUNRPC: update internal API: separate pmap register and temp sockets
    
    Currently in the RPC server, registering with the local portmapper and
    creating "permanent" sockets are tied together.  Expand the internal APIs to
    allow these two socket characteristics to be separately specified.
    
    This will be externalized in the next patch.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Cc: Aurelien Charbon <aurelien.charbon@ext.bull.net>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index db312a1e2eeb..cef11a6e81e9 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -74,4 +74,11 @@ int		svc_addsock(struct svc_serv *serv,
 			    char *name_return,
 			    int *proto);
 
+/*
+ * svc_makesock socket characteristics
+ */
+#define SVC_SOCK_DEFAULTS	(0U)
+#define SVC_SOCK_ANONYMOUS	(1U << 0)	/* don't register with pmap */
+#define SVC_SOCK_TEMPORARY	(1U << 1)	/* flag socket as temporary */
+
 #endif /* SUNRPC_SVCSOCK_H */

commit aaf68cfbf2241d24d46583423f6bff5c47e088b3
Author: NeilBrown <neilb@suse.de>
Date:   Thu Feb 8 14:20:30 2007 -0800

    [PATCH] knfsd: fix a race in closing NFSd connections
    
    If you lose this race, it can iput a socket inode twice and you get a BUG
    in fs/inode.c
    
    When I added the option for user-space to close a socket, I added some
    cruft to svc_delete_socket so that I could call that function when closing
    a socket per user-space request.
    
    This was the wrong thing to do.  I should have just set SK_CLOSE and let
    normal mechanisms do the work.
    
    Not only wrong, but buggy.  The locking is all wrong and it openned up a
    race where-by a socket could be closed twice.
    
    So this patch:
      Introduces svc_close_socket which sets SK_CLOSE then either leave
      the close up to a thread, or calls svc_delete_socket if it can
      get SK_BUSY.
    
      Adds a bias to sk_busy which is removed when SK_DEAD is set,
      This avoid races around shutting down the socket.
    
      Changes several 'spin_lock' to 'spin_lock_bh' where the _bh
      was missing.
    
    Bugzilla-url: http://bugzilla.kernel.org/show_bug.cgi?id=7916
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 98b21ad370fd..db312a1e2eeb 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -63,7 +63,7 @@ struct svc_sock {
  * Function prototypes.
  */
 int		svc_makesock(struct svc_serv *, int, unsigned short);
-void		svc_delete_socket(struct svc_sock *);
+void		svc_close_socket(struct svc_sock *);
 int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);

commit 7b2b1fee30df7e2165525cd03f7d1d01a3a56794
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Wed Oct 4 02:15:50 2006 -0700

    [PATCH] knfsd: knfsd: cache ipmap per TCP socket
    
    Speed up high call-rate workloads by caching the struct ip_map for the peer on
    the connected struct svc_sock instead of looking it up in the ip_map cache
    hashtable on every call.  This helps workloads using AUTH_SYS authentication
    over TCP.
    
    Testing was on a 4 CPU 4 NIC Altix using 4 IRIX clients, each with 16
    synthetic client threads simulating an rsync (i.e.  recursive directory
    listing) workload reading from an i386 RH9 install image (161480 regular files
    in 10841 directories) on the server.  That tree is small enough to fill in the
    server's RAM so no disk traffic was involved.  This setup gives a sustained
    call rate in excess of 60000 calls/sec before being CPU-bound on the server.
    
    Profiling showed strcmp(), called from ip_map_match(), was taking 4.8% of each
    CPU, and ip_map_lookup() was taking 2.9%.  This patch drops both contribution
    into the profile noise.
    
    Note that the above result overstates this value of this patch for most
    workloads.  The synthetic clients are all using separate IP addresses, so
    there are 64 entries in the ip_map cache hash.  Because the kernel measured
    contained the bug fixed in commit
    
    commit 1f1e030bf75774b6a283518e1534d598e14147d4
    
    and was running on 64bit little-endian machine, probably all of those 64
    entries were on a single chain, thus increasing the cost of ip_map_lookup().
    
    With a modern kernel you would need more clients to see the same amount of
    performance improvement.  This patch has helped to scale knfsd to handle a
    deployment with 2000 NFS clients.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 4c296152cbfa..98b21ad370fd 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -54,6 +54,9 @@ struct svc_sock {
 	int			sk_reclen;	/* length of record */
 	int			sk_tcplen;	/* current read length */
 	time_t			sk_lastrecv;	/* time of last received request */
+
+	/* cache of various info for TCP sockets */
+	void			*sk_info_authunix;
 };
 
 /*

commit 3262c816a3d7fb1eaabce633caa317887ed549ae
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Mon Oct 2 02:17:58 2006 -0700

    [PATCH] knfsd: split svc_serv into pools
    
    Split out the list of idle threads and pending sockets from svc_serv into a
    new svc_pool structure, and allocate a fixed number (in this patch, 1) of
    pools per svc_serv.  The new structure contains a lock which takes over
    several of the duties of svc_serv->sv_lock, which is now relegated to
    protecting only sv_tempsocks, sv_permsocks, and sv_tmpcnt in svc_serv.
    
    The point is to move the hottest fields out of svc_serv and into svc_pool,
    allowing a following patch to arrange for a svc_pool per NUMA node or per CPU.
     This is a major step towards making the NFS server NUMA-friendly.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 7154e71c6d1f..4c296152cbfa 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -20,6 +20,7 @@ struct svc_sock {
 	struct socket *		sk_sock;	/* berkeley socket layer */
 	struct sock *		sk_sk;		/* INET layer */
 
+	struct svc_pool *	sk_pool;	/* current pool iff queued */
 	struct svc_serv *	sk_server;	/* service for this socket */
 	atomic_t		sk_inuse;	/* use count */
 	unsigned long		sk_flags;

commit 5685f0fa1c24b138d041ef129ed419c5effa40e1
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Mon Oct 2 02:17:56 2006 -0700

    [PATCH] knfsd: convert sk_reserved to atomic_t
    
    Convert the svc_sock->sk_reserved variable from an int protected by
    svc_serv->sv_lock, to an atomic.  This reduces (by 1) the number of places we
    need to take the (effectively global) svc_serv->sv_lock.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 7766a1001660..7154e71c6d1f 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -34,7 +34,7 @@ struct svc_sock {
 #define	SK_OLD		9			/* used for temp socket aging mark+sweep */
 #define	SK_DETACHED	10			/* detached from tempsocks list */
 
-	int			sk_reserved;	/* space on outq that is reserved */
+	atomic_t    	    	sk_reserved;	/* space on outq that is reserved */
 
 	spinlock_t		sk_defer_lock;	/* protects sk_deferred */
 	struct list_head	sk_deferred;	/* deferred requests that need to

commit 1a68d952af5f43032012d26dd0d5164c9e9986bc
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Mon Oct 2 02:17:55 2006 -0700

    [PATCH] knfsd: use new lock for svc_sock deferred list
    
    Protect the svc_sock->sk_deferred list with a new lock svc_sock->sk_defer_lock
    instead of svc_serv->sv_lock.  Using the more fine-grained lock reduces the
    number of places we need to take the svc_serv lock.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 17cb834a748c..7766a1001660 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -36,6 +36,7 @@ struct svc_sock {
 
 	int			sk_reserved;	/* space on outq that is reserved */
 
+	spinlock_t		sk_defer_lock;	/* protects sk_deferred */
 	struct list_head	sk_deferred;	/* deferred requests that need to
 						 * be revisted */
 	struct mutex		sk_mutex;	/* to serialize sending data */

commit c45c357d7dbc9e94338f44349e0035149da86b26
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Mon Oct 2 02:17:54 2006 -0700

    [PATCH] knfsd: convert sk_inuse to atomic_t
    
    Convert the svc_sock->sk_inuse counter from an int protected by
    svc_serv->sv_lock, to an atomic.  This reduces the number of places we need to
    take the (effectively global) svc_serv->sv_lock.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 846aee95eec7..17cb834a748c 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -21,7 +21,7 @@ struct svc_sock {
 	struct sock *		sk_sk;		/* INET layer */
 
 	struct svc_serv *	sk_server;	/* service for this socket */
-	unsigned int		sk_inuse;	/* use count */
+	atomic_t		sk_inuse;	/* use count */
 	unsigned long		sk_flags;
 #define	SK_BUSY		0			/* enqueued/receiving */
 #define	SK_CONN		1			/* conn pending */

commit 36bdfc8bae51339aa27ef8e4ce148185293061ae
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Mon Oct 2 02:17:54 2006 -0700

    [PATCH] knfsd: move tempsock aging to a timer
    
    Following are 11 patches from Greg Banks which combine to make knfsd more
    Numa-aware.  They reduce hitting on 'global' data structures, and create some
    data-structures that can be node-local.
    
    knfsd threads are bound to a particular node, and the thread to handle a new
    request is chosen from the threads that are attach to the node that received
    the interrupt.
    
    The distribution of threads across nodes can be controlled by a new file in
    the 'nfsd' filesystem, though the default approach of an even spread is
    probably fine for most sites.
    
    Some (old) numbers that show the efficacy of these patches: N == number of
    NICs == number of CPUs == nmber of clients.  Number of NUMA nodes == N/2
    
    N       Throughput, MiB/s       CPU usage, % (max=N*100)
            Before  After           Before  After
            ---     ------  ----            -----   -----
            4       312     435             350     228
            6       500     656             501     418
            8       562     804             690     589
    
    This patch:
    
    Move the aging of RPC/TCP connection sockets from the main svc_recv() loop to
    a timer which uses a mark-and-sweep algorithm every 6 minutes.  This reduces
    the amount of work that needs to be done in the main RPC loop and the length
    of time we need to hold the (effectively global) svc_serv->sv_lock.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index d5f15e8db929..846aee95eec7 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -31,6 +31,8 @@ struct svc_sock {
 #define	SK_DEAD		6			/* socket closed */
 #define	SK_CHNGBUF	7			/* need to change snd/rcv buffer sizes */
 #define	SK_DEFERRED	8			/* request on sk_deferred */
+#define	SK_OLD		9			/* used for temp socket aging mark+sweep */
+#define	SK_DETACHED	10			/* detached from tempsocks list */
 
 	int			sk_reserved;	/* space on outq that is reserved */
 

commit 6fb2b47fa16c81317ec282248e6cff521cca31c2
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:50 2006 -0700

    [PATCH] knfsd: Drop 'serv' option to svc_recv and svc_process
    
    It isn't needed as it is available in rqstp->rq_server, and dropping it allows
    some local vars to be dropped.
    
    [akpm@osdl.org: build fix]
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index b8a9652b8755..d5f15e8db929 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -57,7 +57,7 @@ struct svc_sock {
  */
 int		svc_makesock(struct svc_serv *, int, unsigned short);
 void		svc_delete_socket(struct svc_sock *);
-int		svc_recv(struct svc_serv *, struct svc_rqst *, long);
+int		svc_recv(struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);

commit b41b66d63c730cc45a1024e1f1e67439e507e40f
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:48 2006 -0700

    [PATCH] knfsd: allow sockets to be passed to nfsd via 'portlist'
    
    Userspace should create and bind a socket (but not connectted) and write the
    'fd' to portlist.  This will cause the nfs server to listen on that socket.
    
    To close a socket, the name of the socket - as read from 'portlist' can be
    written to 'portlist' with a preceding '-'.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index 3caf92d72a81..b8a9652b8755 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -61,6 +61,10 @@ int		svc_recv(struct svc_serv *, struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
-int		svc_sock_names(char *buf, struct svc_serv *serv);
+int		svc_sock_names(char *buf, struct svc_serv *serv, char *toclose);
+int		svc_addsock(struct svc_serv *serv,
+			    int fd,
+			    char *name_return,
+			    int *proto);
 
 #endif /* SUNRPC_SVCSOCK_H */

commit 80212d59e32a8a8e030c2ddc5861d8ff70542c56
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 2 02:17:47 2006 -0700

    [PATCH] knfsd: define new nfsdfs file: portlist - contains list of ports
    
    This file will list all ports that nfsd has open.
    Default when TCP enabled will be
       ipv4 udp 0.0.0.0 2049
       ipv4 tcp 0.0.0.0 2049
    
    Later, the list of ports will be settable.
    
    'portlist' chosen rather than 'ports', to avoid unnecessary confusion with
    non-mainline patches which created 'ports' with different semantics.
    
    [akpm@osdl.org: cleanups, build fix]
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index b4acb3d37c3f..3caf92d72a81 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -61,5 +61,6 @@ int		svc_recv(struct svc_serv *, struct svc_rqst *, long);
 int		svc_send(struct svc_rqst *);
 void		svc_drop(struct svc_rqst *);
 void		svc_sock_update_bufs(struct svc_serv *serv);
+int		svc_sock_names(char *buf, struct svc_serv *serv);
 
 #endif /* SUNRPC_SVCSOCK_H */

commit 57b47a53ec4a67691ba32cff5768e8d78fa6c67f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Mar 20 22:35:41 2006 -0800

    [NET]: sem2mutex part 2
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
index d33c6face032..b4acb3d37c3f 100644
--- a/include/linux/sunrpc/svcsock.h
+++ b/include/linux/sunrpc/svcsock.h
@@ -36,7 +36,7 @@ struct svc_sock {
 
 	struct list_head	sk_deferred;	/* deferred requests that need to
 						 * be revisted */
-	struct semaphore        sk_sem;		/* to serialize sending data */
+	struct mutex		sk_mutex;	/* to serialize sending data */
 
 	int			(*sk_recvfrom)(struct svc_rqst *rqstp);
 	int			(*sk_sendto)(struct svc_rqst *rqstp);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/sunrpc/svcsock.h b/include/linux/sunrpc/svcsock.h
new file mode 100644
index 000000000000..d33c6face032
--- /dev/null
+++ b/include/linux/sunrpc/svcsock.h
@@ -0,0 +1,65 @@
+/*
+ * linux/include/linux/sunrpc/svcsock.h
+ *
+ * RPC server socket I/O.
+ *
+ * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>
+ */
+
+#ifndef SUNRPC_SVCSOCK_H
+#define SUNRPC_SVCSOCK_H
+
+#include <linux/sunrpc/svc.h>
+
+/*
+ * RPC server socket.
+ */
+struct svc_sock {
+	struct list_head	sk_ready;	/* list of ready sockets */
+	struct list_head	sk_list;	/* list of all sockets */
+	struct socket *		sk_sock;	/* berkeley socket layer */
+	struct sock *		sk_sk;		/* INET layer */
+
+	struct svc_serv *	sk_server;	/* service for this socket */
+	unsigned int		sk_inuse;	/* use count */
+	unsigned long		sk_flags;
+#define	SK_BUSY		0			/* enqueued/receiving */
+#define	SK_CONN		1			/* conn pending */
+#define	SK_CLOSE	2			/* dead or dying */
+#define	SK_DATA		3			/* data pending */
+#define	SK_TEMP		4			/* temp (TCP) socket */
+#define	SK_DEAD		6			/* socket closed */
+#define	SK_CHNGBUF	7			/* need to change snd/rcv buffer sizes */
+#define	SK_DEFERRED	8			/* request on sk_deferred */
+
+	int			sk_reserved;	/* space on outq that is reserved */
+
+	struct list_head	sk_deferred;	/* deferred requests that need to
+						 * be revisted */
+	struct semaphore        sk_sem;		/* to serialize sending data */
+
+	int			(*sk_recvfrom)(struct svc_rqst *rqstp);
+	int			(*sk_sendto)(struct svc_rqst *rqstp);
+
+	/* We keep the old state_change and data_ready CB's here */
+	void			(*sk_ostate)(struct sock *);
+	void			(*sk_odata)(struct sock *, int bytes);
+	void			(*sk_owspace)(struct sock *);
+
+	/* private TCP part */
+	int			sk_reclen;	/* length of record */
+	int			sk_tcplen;	/* current read length */
+	time_t			sk_lastrecv;	/* time of last received request */
+};
+
+/*
+ * Function prototypes.
+ */
+int		svc_makesock(struct svc_serv *, int, unsigned short);
+void		svc_delete_socket(struct svc_sock *);
+int		svc_recv(struct svc_serv *, struct svc_rqst *, long);
+int		svc_send(struct svc_rqst *);
+void		svc_drop(struct svc_rqst *);
+void		svc_sock_update_bufs(struct svc_serv *serv);
+
+#endif /* SUNRPC_SVCSOCK_H */
