commit 9a81ef42b238b28829a46ecf13c7aacb79b9b3ac
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Mar 27 11:53:09 2020 -0400

    SUNRPC/cache: don't allow invalid entries to be flushed
    
    Trond points out in commit 277f27e2f277 ("SUNRPC/cache: Allow
    garbage collection of invalid cache entries") that we allow invalid
    cache entries to persist indefinitely. That fix, however,
    reintroduces the problem fixed by Kinglong Mee's commit d6fc8821c2d2
    ("SUNRPC/Cache: Always treat the invalid cache as unexpired"), where
    an invalid cache entry is immediately removed by a flush before
    mountd responds to it. The result is that the server thread that
    should be waiting for mountd to fill in that entry instead gets an
    -ETIMEDOUT return from cache_check(). Symptoms are the server
    becoming unresponsive after a restart, reproduceable by running
    pynfs 4.1 test REBT5.
    
    Instead, take a compromise approach: allow invalid cache entries to
    be removed after they expire, but not to be removed by a cache
    flush.
    
    Fixes: 277f27e2f277 ("SUNRPC/cache: Allow garbage collection ... ")
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 532cdbda43da..10891b70fc7b 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -209,8 +209,11 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 
 static inline bool cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
-	return  (h->expiry_time < seconds_since_boot()) ||
-		(detail->flush_time >= h->last_refresh);
+	if (h->expiry_time < seconds_since_boot())
+		return true;
+	if (!test_bit(CACHE_VALID, &h->flags))
+		return false;
+	return detail->flush_time >= h->last_refresh;
 }
 
 extern int cache_check(struct cache_detail *detail,

commit 277f27e2f27752cd1a7901443d72e908ddea8a2e
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Mar 1 18:21:43 2020 -0500

    SUNRPC/cache: Allow garbage collection of invalid cache entries
    
    If the cache entry never gets initialised, we want the garbage
    collector to be able to evict it. Otherwise if the upcall daemon
    fails to initialise the entry, we end up never expiring it.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    [ cel: resolved a merge conflict ]
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 656882a50991..532cdbda43da 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -209,9 +209,6 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 
 static inline bool cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
-	if (!test_bit(CACHE_VALID, &h->flags))
-		return false;
-
 	return  (h->expiry_time < seconds_since_boot()) ||
 		(detail->flush_time >= h->last_refresh);
 }

commit 65286b883c6de6b30928c837c47c167e82bde0b2
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Sun Mar 1 18:21:42 2020 -0500

    nfsd: export upcalls must not return ESTALE when mountd is down
    
    If the rpc.mountd daemon goes down, then that should not cause all
    exports to start failing with ESTALE errors. Let's explicitly
    distinguish between the cache upcall cases that need to time out,
    and those that do not.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 0f64de7caa39..656882a50991 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -179,6 +179,9 @@ sunrpc_cache_update(struct cache_detail *detail,
 
 extern int
 sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h);
+extern int
+sunrpc_cache_pipe_upcall_timeout(struct cache_detail *detail,
+				 struct cache_head *h);
 
 
 extern void cache_clean_deferred(void *owner);

commit f559935e7ce4e5d448bb6588f7fa82b0cc2cc2c0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Oct 20 16:34:42 2017 +0200

    nfs: use time64_t internally
    
    The timestamps for the cache are all in boottime seconds, so they
    don't overflow 32-bit values, but the use of time_t is deprecated
    because it generally does overflow when used with wall-clock time.
    
    There are multiple possible ways of avoiding it:
    
    - leave time_t, which is safe here, but forces others to
      look into this code to determine that it is over and over.
    
    - use a more generic type, like 'int' or 'long', which is known
      to be sufficient here but loses the documentation of referring
      to timestamps
    
    - use ktime_t everywhere, and convert into seconds in the few
      places where we want realtime-seconds. The conversion is
      sometimes expensive, but not more so than the conversion we
      do today.
    
    - use time64_t to clarify that this code is safe. Nothing would
      change for 64-bit architectures, but it is slightly less
      efficient on 32-bit architectures.
    
    Without a clear winner of the three approaches above, this picks
    the last one, favouring readability over a small performance
    loss on 32-bit architectures.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index f8603724fbee..0f64de7caa39 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -45,8 +45,8 @@
  */
 struct cache_head {
 	struct hlist_node	cache_list;
-	time_t		expiry_time;	/* After time time, don't use the data */
-	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall was
+	time64_t	expiry_time;	/* After time time, don't use the data */
+	time64_t	last_refresh;   /* If CACHE_PENDING, this is when upcall was
 					 * sent, else this is when update was
 					 * received, though it is alway set to
 					 * be *after* ->flush_time.
@@ -95,22 +95,22 @@ struct cache_detail {
 	/* fields below this comment are for internal use
 	 * and should not be touched by cache owners
 	 */
-	time_t			flush_time;		/* flush all cache items with
+	time64_t		flush_time;		/* flush all cache items with
 							 * last_refresh at or earlier
 							 * than this.  last_refresh
 							 * is never set at or earlier
 							 * than this.
 							 */
 	struct list_head	others;
-	time_t			nextcheck;
+	time64_t		nextcheck;
 	int			entries;
 
 	/* fields for communication over channel */
 	struct list_head	queue;
 
 	atomic_t		writers;		/* how many time is /channel open */
-	time_t			last_close;		/* if no writers, when did last close */
-	time_t			last_warn;		/* when we last warned about no writers */
+	time64_t		last_close;		/* if no writers, when did last close */
+	time64_t		last_warn;		/* when we last warned about no writers */
 
 	union {
 		struct proc_dir_entry	*procfs;
@@ -147,18 +147,22 @@ struct cache_deferred_req {
  * timestamps kept in the cache are expressed in seconds
  * since boot.  This is the best for measuring differences in
  * real time.
+ * This reimplemnts ktime_get_boottime_seconds() in a slightly
+ * faster but less accurate way. When we end up converting
+ * back to wallclock (CLOCK_REALTIME), that error often
+ * cancels out during the reverse operation.
  */
-static inline time_t seconds_since_boot(void)
+static inline time64_t seconds_since_boot(void)
 {
-	struct timespec boot;
-	getboottime(&boot);
-	return get_seconds() - boot.tv_sec;
+	struct timespec64 boot;
+	getboottime64(&boot);
+	return ktime_get_real_seconds() - boot.tv_sec;
 }
 
-static inline time_t convert_to_wallclock(time_t sinceboot)
+static inline time64_t convert_to_wallclock(time64_t sinceboot)
 {
-	struct timespec boot;
-	getboottime(&boot);
+	struct timespec64 boot;
+	getboottime64(&boot);
 	return boot.tv_sec + sinceboot;
 }
 
@@ -273,7 +277,7 @@ static inline int get_uint(char **bpp, unsigned int *anint)
 	return 0;
 }
 
-static inline int get_time(char **bpp, time_t *time)
+static inline int get_time(char **bpp, time64_t *time)
 {
 	char buf[50];
 	long long ll;
@@ -287,20 +291,20 @@ static inline int get_time(char **bpp, time_t *time)
 	if (kstrtoll(buf, 0, &ll))
 		return -EINVAL;
 
-	*time = (time_t)ll;
+	*time = ll;
 	return 0;
 }
 
-static inline time_t get_expiry(char **bpp)
+static inline time64_t get_expiry(char **bpp)
 {
-	time_t rv;
-	struct timespec boot;
+	time64_t rv;
+	struct timespec64 boot;
 
 	if (get_time(bpp, &rv))
 		return 0;
 	if (rv < 0)
 		return 0;
-	getboottime(&boot);
+	getboottime64(&boot);
 	return rv - boot.tv_sec;
 }
 

commit f69d6d8eef7807f8d937b81da24bebd2e926e4d2
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Sun Aug 18 14:18:44 2019 -0400

    sunrpc: add a new cache_detail operation for when a cache is flushed
    
    When the exports table is changed, exportfs will usually write a new
    time to the "flush" file in the nfsd.export cache procfile. This tells
    the kernel to flush any entries that are older than that value.
    
    This gives us a mechanism to tell whether an unexport might have
    occurred. Add a new ->flush cache_detail operation that is called after
    flushing the cache whenever someone writes to a "flush" file.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index f7d086b77a21..f8603724fbee 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -87,6 +87,7 @@ struct cache_detail {
 					      int has_died);
 
 	struct cache_head *	(*alloc)(void);
+	void			(*flush)(void);
 	int			(*match)(struct cache_head *orig, struct cache_head *new);
 	void			(*init)(struct cache_head *orig, struct cache_head *new);
 	void			(*update)(struct cache_head *orig, struct cache_head *new);

commit 64a38e840ce5940253208eaba40265c73decc4ee
Author: Dave Wysochanski <dwysocha@redhat.com>
Date:   Fri Jul 26 18:33:01 2019 -0400

    SUNRPC: Track writers of the 'channel' file to improve cache_listeners_exist
    
    The sunrpc cache interface is susceptible to being fooled by a rogue
    process just reading a 'channel' file.  If this happens the kernel
    may think a valid daemon exists to service the cache when it does not.
    For example, the following may fool the kernel:
    cat /proc/net/rpc/auth.unix.gid/channel
    
    Change the tracking of readers to writers when considering whether a
    listener exists as all valid daemon processes either open a channel
    file O_RDWR or O_WRONLY.  While this does not prevent a rogue process
    from "stealing" a message from the kernel, it does at least improve
    the kernels perception of whether a valid process servicing the cache
    exists.
    
    Signed-off-by: Dave Wysochanski <dwysocha@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index c7f38e897174..f7d086b77a21 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -107,9 +107,9 @@ struct cache_detail {
 	/* fields for communication over channel */
 	struct list_head	queue;
 
-	atomic_t		readers;		/* how many time is /chennel open */
-	time_t			last_close;		/* if no readers, when did last close */
-	time_t			last_warn;		/* when we last warned about no readers */
+	atomic_t		writers;		/* how many time is /channel open */
+	time_t			last_close;		/* if no writers, when did last close */
+	time_t			last_warn;		/* when we last warned about no writers */
 
 	union {
 		struct proc_dir_entry	*procfs;

commit ddc64d0ac97814fcc42ed90a2ea0c69658806c67
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:24 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 363
    
    Based on 1 normalized pattern(s):
    
      released under terms in gpl version 2 see copying
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 5 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081035.689962394@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 5a3e95017fc6..c7f38e897174 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * include/linux/sunrpc/cache.h
  *
@@ -5,9 +6,6 @@
  * used by sunrpc clients and servers.
  *
  * Copyright (C) 2002 Neil Brown <neilb@cse.unsw.edu.au>
- *
- * Released under terms in GPL version 2.  See COPYING.
- *
  */
 
 #ifndef _LINUX_SUNRPC_CACHE_H_

commit 1863d77f15da0addcd293a1719fa5d3ef8cde3ca
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Mon Oct 1 10:41:52 2018 -0400

    SUNRPC: Replace the cache_detail->hash_lock with a regular spinlock
    
    Now that the reader functions are all RCU protected, use a regular
    spinlock rather than a reader/writer lock.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index c3d67e893430..5a3e95017fc6 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -67,7 +67,7 @@ struct cache_detail {
 	struct module *		owner;
 	int			hash_size;
 	struct hlist_head *	hash_table;
-	rwlock_t		hash_lock;
+	spinlock_t		hash_lock;
 
 	char			*name;
 	void			(*cache_put)(struct kref *);

commit d48cf356a13073853f19be6ca5ebbecfc2762ebe
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Mon Oct 1 10:41:51 2018 -0400

    SUNRPC: Remove non-RCU protected lookup
    
    Clean up the cache code by removing the non-RCU protected lookup.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index cf3e17ee2786..c3d67e893430 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -171,9 +171,6 @@ extern struct cache_head *
 sunrpc_cache_lookup_rcu(struct cache_detail *detail,
 			struct cache_head *key, int hash);
 extern struct cache_head *
-sunrpc_cache_lookup(struct cache_detail *detail,
-		    struct cache_head *key, int hash);
-extern struct cache_head *
 sunrpc_cache_update(struct cache_detail *detail,
 		    struct cache_head *new, struct cache_head *old, int hash);
 
@@ -233,9 +230,6 @@ extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);
 extern void sunrpc_cache_unhash(struct cache_detail *, struct cache_head *);
 
 /* Must store cache_detail in seq_file->private if using next three functions */
-extern void *cache_seq_start(struct seq_file *file, loff_t *pos);
-extern void *cache_seq_next(struct seq_file *file, void *p, loff_t *pos);
-extern void cache_seq_stop(struct seq_file *file, void *p);
 extern void *cache_seq_start_rcu(struct seq_file *file, loff_t *pos);
 extern void *cache_seq_next_rcu(struct seq_file *file, void *p, loff_t *pos);
 extern void cache_seq_stop_rcu(struct seq_file *file, void *p);

commit ae74136b4bb64440a55117e12065b8c282ab6c1a
Author: Trond Myklebust <trondmy@gmail.com>
Date:   Wed Oct 3 12:01:22 2018 -0400

    SUNRPC: Allow cache lookups to use RCU protection rather than the r/w spinlock
    
    Instead of the reader/writer spinlock, allow cache lookups to use RCU
    for looking up entries. This is more efficient since modifications can
    occur while other entries are being looked up.
    
    Note that for now, we keep the reader/writer spinlock until all users
    have been converted to use RCU-safe freeing of their cache entries.
    
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 40d2822f0e2f..cf3e17ee2786 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -167,6 +167,9 @@ extern const struct file_operations cache_file_operations_pipefs;
 extern const struct file_operations content_file_operations_pipefs;
 extern const struct file_operations cache_flush_operations_pipefs;
 
+extern struct cache_head *
+sunrpc_cache_lookup_rcu(struct cache_detail *detail,
+			struct cache_head *key, int hash);
 extern struct cache_head *
 sunrpc_cache_lookup(struct cache_detail *detail,
 		    struct cache_head *key, int hash);
@@ -186,6 +189,12 @@ static inline struct cache_head  *cache_get(struct cache_head *h)
 	return h;
 }
 
+static inline struct cache_head  *cache_get_rcu(struct cache_head *h)
+{
+	if (kref_get_unless_zero(&h->ref))
+		return h;
+	return NULL;
+}
 
 static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 {
@@ -227,6 +236,9 @@ extern void sunrpc_cache_unhash(struct cache_detail *, struct cache_head *);
 extern void *cache_seq_start(struct seq_file *file, loff_t *pos);
 extern void *cache_seq_next(struct seq_file *file, void *p, loff_t *pos);
 extern void cache_seq_stop(struct seq_file *file, void *p);
+extern void *cache_seq_start_rcu(struct seq_file *file, loff_t *pos);
+extern void *cache_seq_next_rcu(struct seq_file *file, void *p, loff_t *pos);
+extern void cache_seq_stop_rcu(struct seq_file *file, void *p);
 
 extern void qword_add(char **bpp, int *lp, char *str);
 extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);

commit d34971a65b72619508f49cd237283e92f1c329d5
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Oct 17 18:14:23 2017 +0200

    sunrpc: make the function arg as const
    
    Make the struct cache_detail *tmpl argument of the function
    cache_create_net as const as it is only getting passed to kmemup having
    the argument as const void *.
    Add const to the prototype too.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 270bad0e1bed..40d2822f0e2f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -213,7 +213,7 @@ extern void __init cache_initialize(void);
 extern int cache_register_net(struct cache_detail *cd, struct net *net);
 extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
-extern struct cache_detail *cache_create_net(struct cache_detail *tmpl, struct net *net);
+extern struct cache_detail *cache_create_net(const struct cache_detail *tmpl, struct net *net);
 extern void cache_destroy_net(struct cache_detail *cd, struct net *net);
 
 extern void sunrpc_init_cache_detail(struct cache_detail *cd);

commit 8f03cf50bc9443e92d6e54ac4d599357d6cb7cbb
Merge: 25c4e6c3f0c1 ed92d8c137b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 1 16:10:30 2017 -0800

    Merge tag 'nfs-for-4.11-1' of git://git.linux-nfs.org/projects/anna/linux-nfs
    
    Pull NFS client updates from Anna Schumaker:
     "Highlights include:
    
      Stable bugfixes:
       - NFSv4: Fix memory and state leak in _nfs4_open_and_get_state
       - xprtrdma: Fix Read chunk padding
       - xprtrdma: Per-connection pad optimization
       - xprtrdma: Disable pad optimization by default
       - xprtrdma: Reduce required number of send SGEs
       - nlm: Ensure callback code also checks that the files match
       - pNFS/flexfiles: If the layout is invalid, it must be updated before
         retrying
       - NFSv4: Fix reboot recovery in copy offload
       - Revert "NFSv4.1: Handle NFS4ERR_BADSESSION/NFS4ERR_DEADSESSION
         replies to OP_SEQUENCE"
       - NFSv4: fix getacl head length estimation
       - NFSv4: fix getacl ERANGE for sum ACL buffer sizes
    
      Features:
       - Add and use dprintk_cont macros
       - Various cleanups to NFS v4.x to reduce code duplication and
         complexity
       - Remove unused cr_magic related code
       - Improvements to sunrpc "read from buffer" code
       - Clean up sunrpc timeout code and allow changing TCP timeout
         parameters
       - Remove duplicate mw_list management code in xprtrdma
       - Add generic functions for encoding and decoding xdr streams
    
      Bugfixes:
       - Clean up nfs_show_mountd_netid
       - Make layoutreturn_ops static and use NULL instead of 0 to fix
         sparse warnings
       - Properly handle -ERESTARTSYS in nfs_rename()
       - Check if register_shrinker() failed during rpcauth_init()
       - Properly clean up procfs/pipefs entries
       - Various NFS over RDMA related fixes
       - Silence unititialized variable warning in sunrpc"
    
    * tag 'nfs-for-4.11-1' of git://git.linux-nfs.org/projects/anna/linux-nfs: (64 commits)
      NFSv4: fix getacl ERANGE for some ACL buffer sizes
      NFSv4: fix getacl head length estimation
      Revert "NFSv4.1: Handle NFS4ERR_BADSESSION/NFS4ERR_DEADSESSION replies to OP_SEQUENCE"
      NFSv4: Fix reboot recovery in copy offload
      pNFS/flexfiles: If the layout is invalid, it must be updated before retrying
      NFSv4: Clean up owner/group attribute decode
      SUNRPC: Add a helper function xdr_stream_decode_string_dup()
      NFSv4: Remove bogus "struct nfs_client" argument from decode_ace()
      NFSv4: Fix the underestimation of delegation XDR space reservation
      NFSv4: Replace callback string decode function with a generic
      NFSv4: Replace the open coded decode_opaque_inline() with the new generic
      NFSv4: Replace ad-hoc xdr encode/decode helpers with xdr_stream_* generics
      SUNRPC: Add generic helpers for xdr_stream encode/decode
      sunrpc: silence uninitialized variable warning
      nlm: Ensure callback code also checks that the files match
      sunrpc: Allow xprt->ops->timer method to sleep
      xprtrdma: Refactor management of mw_list field
      xprtrdma: Handle stale connection rejection
      xprtrdma: Properly recover FRWRs with in-flight FASTREG WRs
      xprtrdma: Shrink send SGEs array
      ...

commit 8313064c2e75542201e557e2b496668811c2484a
Merge: b2deee2dc06d ff7d11797e72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 28 15:39:09 2017 -0800

    Merge tag 'nfsd-4.11' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "The nfsd update this round is mainly a lot of miscellaneous cleanups
      and bugfixes.
    
      A couple changes could theoretically break working setups on upgrade.
      I don't expect complaints in practice, but they seem worth calling out
      just in case:
    
       - NFS security labels are now off by default; a new security_label
         export flag reenables it per export. But, having them on by default
         is a disaster, as it generally only makes sense if all your clients
         and servers have similar enough selinux policies. Thanks to Jason
         Tibbitts for pointing this out.
    
       - NFSv4/UDP support is off. It was never really supported, and the
         spec explicitly forbids it. We only ever left it on out of
         laziness; thanks to Jeff Layton for finally fixing that"
    
    * tag 'nfsd-4.11' of git://linux-nfs.org/~bfields/linux: (34 commits)
      nfsd: Fix display of the version string
      nfsd: fix configuration of supported minor versions
      sunrpc: don't register UDP port with rpcbind when version needs congestion control
      nfs/nfsd/sunrpc: enforce transport requirements for NFSv4
      sunrpc: flag transports as having congestion control
      sunrpc: turn bitfield flags in svc_version into bools
      nfsd: remove superfluous KERN_INFO
      nfsd: special case truncates some more
      nfsd: minor nfsd_setattr cleanup
      NFSD: Reserve adequate space for LOCKT operation
      NFSD: Get response size before operation for all RPCs
      nfsd/callback: Drop a useless data copy when comparing sessionid
      nfsd/callback: skip the callback tag
      nfsd/callback: Cleanup callback cred on shutdown
      nfsd/idmap: return nfserr_inval for 0-length names
      SUNRPC/Cache: Always treat the invalid cache as unexpired
      SUNRPC: Drop all entries from cache_detail when cache_purge()
      svcrdma: Poll CQs in "workqueue" mode
      svcrdma: Combine list fields in struct svc_rdma_op_ctxt
      svcrdma: Remove unused sc_dto_q field
      ...

commit 863d7d9c2e0cbbde6cd15f87c4431dd806f2d917
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Tue Feb 7 21:47:16 2017 +0800

    sunrpc/nfs: cleanup procfs/pipefs entry in cache_detail
    
    Record flush/channel/content entries is useless, remove them.
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 62a60eeacb0a..bb5c9c80f12e 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -63,15 +63,6 @@ struct cache_head {
 
 #define	CACHE_NEW_EXPIRY 120	/* keep new things pending confirmation for 120 seconds */
 
-struct cache_detail_procfs {
-	struct proc_dir_entry	*proc_ent;
-	struct proc_dir_entry   *flush_ent, *channel_ent, *content_ent;
-};
-
-struct cache_detail_pipefs {
-	struct dentry *dir;
-};
-
 struct cache_detail {
 	struct module *		owner;
 	int			hash_size;
@@ -123,9 +114,9 @@ struct cache_detail {
 	time_t			last_warn;		/* when we last warned about no readers */
 
 	union {
-		struct cache_detail_procfs procfs;
-		struct cache_detail_pipefs pipefs;
-	} u;
+		struct proc_dir_entry	*procfs;
+		struct dentry		*pipefs;
+	};
 	struct net		*net;
 };
 

commit d6fc8821c2d2aba4cc18447a467f543e46e7367d
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Wed Feb 8 09:54:42 2017 +0800

    SUNRPC/Cache: Always treat the invalid cache as unexpired
    
    When the first time pynfs runs after rpc/nfsd startup, always get the warning,
    
    "Got error: Connection closed"
    
    I found the problem is caused by,
    1. A new startup of nfsd, rpc.mountd, etc,
    2. A rpc request from client (pynfs test, or normal mounting),
    3. An ip_map cache is created but invalid, so upcall to rpc.mountd,
    4. rpc.mountd process the ip_map upcall, before write the valid data to nfsd,
       do auth_reload(), and check_useipaddr(),
    5. For the first time, old_use_ipaddr = -1, it causes rpc.mountd do write_flush    that doing cache_clean,
    6. The ip_map cache will be treat as expired and clean,
    7. When rpc.mountd write the valid data to nfsd, a new ip_map is created
       and updated, the cache_check of old ip_map(doing the upcall) will
       return -ETIMEDOUT.
    8. RPC layer return SVC_CLOSE and close the xprt after commit 4d712ef1db05
       "svcauth_gss: Close connection when dropping an incoming message"
    
    NeilBrown suggest in another email,
    
    "If CACHE_VALID is not set, then there is no data in the cache item,
     so there is nothing to expire. So it would be nice if cache items that
     don't have CACHE_VALID are never treated as expired."
    
    v3, change the order of the two patches
    v2, change the checking of CACHE_PENDING to CACHE_VALID
    
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 9dcf2c8fe1c5..70738504d647 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -204,8 +204,11 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 	kref_put(&h->ref, cd->cache_put);
 }
 
-static inline int cache_is_expired(struct cache_detail *detail, struct cache_head *h)
+static inline bool cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
+	if (!test_bit(CACHE_VALID, &h->flags))
+		return false;
+
 	return  (h->expiry_time < seconds_since_boot()) ||
 		(detail->flush_time >= h->last_refresh);
 }

commit 2b477c00f3bd87c3286f5940cb4174d8b01ee0d5
Author: Neil Brown <neilb@suse.com>
Date:   Thu Dec 22 12:38:06 2016 -0500

    svcrpc: free contexts immediately on PROC_DESTROY
    
    We currently handle a client PROC_DESTROY request by turning it
    CACHE_NEGATIVE, setting the expired time to now, and then waiting for
    cache_clean to clean it up later.  Since we forgot to set the cache's
    nextcheck value, that could take up to 30 minutes.  Also, though there's
    probably no real bug in this case, setting CACHE_NEGATIVE directly like
    this probably isn't a great idea in general.
    
    So let's just remove the entry from the cache directly, and move this
    bit of cache manipulation to a helper function.
    
    Signed-off-by: Neil Brown <neilb@suse.com>
    Reported-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: Andy Adamson <andros@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 62a60eeacb0a..9dcf2c8fe1c5 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -227,6 +227,7 @@ extern void sunrpc_destroy_cache_detail(struct cache_detail *cd);
 extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
 					umode_t, struct cache_detail *);
 extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);
+extern void sunrpc_cache_unhash(struct cache_detail *, struct cache_head *);
 
 /* Must store cache_detail in seq_file->private if using next three functions */
 extern void *cache_seq_start(struct seq_file *file, loff_t *pos);

commit 2c935bc57221cc2edc787c72ea0e2d30cdcd3d5e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 14 17:29:48 2016 +0100

    locking/atomic, kref: Add kref_read()
    
    Since we need to change the implementation, stop exposing internals.
    
    Provide kref_read() to read the current reference count; typically
    used for debug messages.
    
    Kills two anti-patterns:
    
            atomic_read(&kref->refcount)
            kref->refcount.counter
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 62a60eeacb0a..8a511c0985aa 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -198,7 +198,7 @@ static inline struct cache_head  *cache_get(struct cache_head *h)
 
 static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 {
-	if (atomic_read(&h->ref.refcount) <= 2 &&
+	if (kref_read(&h->ref) <= 2 &&
 	    h->expiry_time < cd->nextcheck)
 		cd->nextcheck = h->expiry_time;
 	kref_put(&h->ref, cd->cache_put);

commit d8d29138b17c9965484427b34cf8046601aef8c4
Author: NeilBrown <neilb@suse.com>
Date:   Thu Jun 2 16:31:03 2016 +1000

    sunrpc: remove 'inuse' flag from struct cache_detail.
    
    This field is not currently in use.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index ed03c9f7f908..62a60eeacb0a 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -78,8 +78,6 @@ struct cache_detail {
 	struct hlist_head *	hash_table;
 	rwlock_t		hash_lock;
 
-	atomic_t		inuse; /* active user-space update or lookup */
-
 	char			*name;
 	void			(*cache_put)(struct kref *);
 

commit 778620364ef525e83597a6edee4d0a69db67fd3d
Author: Neil Brown <neilb@suse.com>
Date:   Fri Oct 16 08:59:08 2015 +1100

    sunrpc/cache: make cache flushing more reliable.
    
    The caches used to store sunrpc authentication information can be
    flushed by writing a timestamp to a file in /proc.
    
    This timestamp has a one-second resolution and any entry in cache that
    was last_refreshed *before* that time is treated as expired.
    
    This is problematic as it is not possible to reliably flush the cache
    without interrupting NFS service.
    If the current time is written to the "flush" file, any entry that was
    added since the current second started will still be treated as valid.
    If one second beyond than the current time is written to the file
    then no entries can be valid until the second ticks over.  This will
    mean that no NFS request will be handled for up to 1 second.
    
    To resolve this issue we make two changes:
    
    1/ treat an entry as expired if the timestamp when it was last_refreshed
      is before *or the same as* the expiry time.  This means that current
      code which writes out the current time will now flush the cache
      reliably.
    
    2/ when a new entry in added to the cache -  set the last_refresh timestamp
      to 1 second *beyond* the current flush time, when that not in the
      past.
      This ensures that newly added entries will always be valid.
    
    Now that we have a very reliable way to flush the cache, and also
    since we are using "since-boot" timestamps which are monotonic,
    change cache_purge() to set the smallest future flush_time which
    will work, and leave it there: don't revert to '1'.
    
    Also disable the setting of the 'flush_time' far into the future.
    That has never been useful and is now awkward as it would cause
    last_refresh times to be strange.
    Finally: if a request is made to set the 'flush_time' to the current
    second, assume the intent is to flush the cache and advance it, if
    necessary, to 1 second beyond the current 'flush_time' so that all
    active entries will be deemed to be expired.
    
    As part of this we need to add a 'cache_detail' arg to cache_init()
    and cache_fresh_locked() so they can find the current ->flush_time.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Reported-by: Olaf Kirch <okir@suse.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 03d3b4c92d9f..ed03c9f7f908 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -48,8 +48,10 @@
 struct cache_head {
 	struct hlist_node	cache_list;
 	time_t		expiry_time;	/* After time time, don't use the data */
-	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall 
-					 * was sent, else this is when update was received
+	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall was
+					 * sent, else this is when update was
+					 * received, though it is alway set to
+					 * be *after* ->flush_time.
 					 */
 	struct kref	ref;
 	unsigned long	flags;
@@ -105,8 +107,12 @@ struct cache_detail {
 	/* fields below this comment are for internal use
 	 * and should not be touched by cache owners
 	 */
-	time_t			flush_time;		/* flush all cache items with last_refresh
-							 * earlier than this */
+	time_t			flush_time;		/* flush all cache items with
+							 * last_refresh at or earlier
+							 * than this.  last_refresh
+							 * is never set at or earlier
+							 * than this.
+							 */
 	struct list_head	others;
 	time_t			nextcheck;
 	int			entries;
@@ -203,7 +209,7 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 static inline int cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
 	return  (h->expiry_time < seconds_since_boot()) ||
-		(detail->flush_time > h->last_refresh);
+		(detail->flush_time >= h->last_refresh);
 }
 
 extern int cache_check(struct cache_detail *detail,

commit 129e5824cd96d9289679973f0ff7c48e88d569bb
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Mon Jul 27 11:10:15 2015 +0800

    sunrpc: Switch to using hash list instead single list
    
    Switch using list_head for cache_head in cache_detail,
    it is useful of remove an cache_head entry directly from cache_detail.
    
    v8, using hash list, not head list
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 04ee5a284aac..03d3b4c92d9f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -46,7 +46,7 @@
  * 
  */
 struct cache_head {
-	struct cache_head * next;
+	struct hlist_node	cache_list;
 	time_t		expiry_time;	/* After time time, don't use the data */
 	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall 
 					 * was sent, else this is when update was received
@@ -73,7 +73,7 @@ struct cache_detail_pipefs {
 struct cache_detail {
 	struct module *		owner;
 	int			hash_size;
-	struct cache_head **	hash_table;
+	struct hlist_head *	hash_table;
 	rwlock_t		hash_lock;
 
 	atomic_t		inuse; /* active user-space update or lookup */

commit c8c081b70cb563cc4d41ab9933fa3323c6f6ffca
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Mon Jul 27 11:09:42 2015 +0800

    sunrpc/nfsd: Remove redundant code by exports seq_operations functions
    
    Nfsd has implement a site of seq_operations functions as sunrpc's cache.
    Just exports sunrpc's codes, and remove nfsd's redundant codes.
    
    v8, same as v6
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 437ddb6c4aef..04ee5a284aac 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -224,6 +224,11 @@ extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
 					umode_t, struct cache_detail *);
 extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);
 
+/* Must store cache_detail in seq_file->private if using next three functions */
+extern void *cache_seq_start(struct seq_file *file, loff_t *pos);
+extern void *cache_seq_next(struct seq_file *file, void *p, loff_t *pos);
+extern void cache_seq_stop(struct seq_file *file, void *p);
+
 extern void qword_add(char **bpp, int *lp, char *str);
 extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);
 extern int qword_get(char **bpp, char *dest, int bufsize);

commit 2f74f972d4cc7d83408ea0c32d424edcb44887bf
Author: Harshula Jayasuriya <harshula@redhat.com>
Date:   Fri Aug 16 03:46:40 2013 +1000

    sunrpc: prepare NFS for 2038
    
    1) The kernel sunrpc code needs to handle seconds since epoch
    greater than 2147483647. This means functions that parse time
    as an int need to handle it as time_t.
    
    2) The kernel changes must be accompanied by userspace changes
    in nfs-utils.
    
    Signed-off-by: Harshula Jayasuriya <harshula@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6ce690de447f..437ddb6c4aef 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -264,12 +264,30 @@ static inline int get_uint(char **bpp, unsigned int *anint)
 	return 0;
 }
 
+static inline int get_time(char **bpp, time_t *time)
+{
+	char buf[50];
+	long long ll;
+	int len = qword_get(bpp, buf, sizeof(buf));
+
+	if (len < 0)
+		return -EINVAL;
+	if (len == 0)
+		return -ENOENT;
+
+	if (kstrtoll(buf, 0, &ll))
+		return -EINVAL;
+
+	*time = (time_t)ll;
+	return 0;
+}
+
 static inline time_t get_expiry(char **bpp)
 {
-	int rv;
+	time_t rv;
 	struct timespec boot;
 
-	if (get_int(bpp, &rv))
+	if (get_time(bpp, &rv))
 		return 0;
 	if (rv < 0)
 		return 0;

commit 7715cde86857d4bb40f43f1ee971cf906eaf1b9c
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jun 13 12:53:42 2013 +1000

    net/sunrpc: xpt_auth_cache should be ignored when expired.
    
    commit d202cce8963d9268ff355a386e20243e8332b308
        sunrpc: never return expired entries in sunrpc_cache_lookup
    
    moved the 'entry is expired' test from cache_check to
    sunrpc_cache_lookup, so that it happened early and some races could
    safely be ignored.
    
    However the ip_map (in svcauth_unix.c) has a separate single-item
    cache which allows quick lookup without locking.  An entry in this
    case would not be subject to the expiry test and so could be used
    well after it has expired.
    
    This is not normally a big problem because the first time it is used
    after it is expired an up-call will be scheduled to refresh the entry
    (if it hasn't been scheduled already) and the old entry will then
    be invalidated.  So on the second attempt to use it after it has
    expired, ip_map_cached_get will discard it.
    
    However that is subtle and not ideal, so replace the "!cache_valid"
    test with "cache_is_expired".
    In doing this we drop the test on the "CACHE_VALID" bit.  This is
    unnecessary as the bit is never cleared, and an entry will only
    be cached if the bit is set.
    
    Reported-by: Bodo Stroesser <bstroesser@ts.fujitsu.com>
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 8419f7dbdab2..6ce690de447f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -149,6 +149,24 @@ struct cache_deferred_req {
 					   int too_many);
 };
 
+/*
+ * timestamps kept in the cache are expressed in seconds
+ * since boot.  This is the best for measuring differences in
+ * real time.
+ */
+static inline time_t seconds_since_boot(void)
+{
+	struct timespec boot;
+	getboottime(&boot);
+	return get_seconds() - boot.tv_sec;
+}
+
+static inline time_t convert_to_wallclock(time_t sinceboot)
+{
+	struct timespec boot;
+	getboottime(&boot);
+	return boot.tv_sec + sinceboot;
+}
 
 extern const struct file_operations cache_file_operations_pipefs;
 extern const struct file_operations content_file_operations_pipefs;
@@ -182,15 +200,10 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 	kref_put(&h->ref, cd->cache_put);
 }
 
-static inline int cache_valid(struct cache_head *h)
+static inline int cache_is_expired(struct cache_detail *detail, struct cache_head *h)
 {
-	/* If an item has been unhashed pending removal when
-	 * the refcount drops to 0, the expiry_time will be
-	 * set to 0.  We don't want to consider such items
-	 * valid in this context even though CACHE_VALID is
-	 * set.
-	 */
-	return (h->expiry_time != 0 && test_bit(CACHE_VALID, &h->flags));
+	return  (h->expiry_time < seconds_since_boot()) ||
+		(detail->flush_time > h->last_refresh);
 }
 
 extern int cache_check(struct cache_detail *detail,
@@ -251,25 +264,6 @@ static inline int get_uint(char **bpp, unsigned int *anint)
 	return 0;
 }
 
-/*
- * timestamps kept in the cache are expressed in seconds
- * since boot.  This is the best for measuring differences in
- * real time.
- */
-static inline time_t seconds_since_boot(void)
-{
-	struct timespec boot;
-	getboottime(&boot);
-	return get_seconds() - boot.tv_sec;
-}
-
-static inline time_t convert_to_wallclock(time_t sinceboot)
-{
-	struct timespec boot;
-	getboottime(&boot);
-	return boot.tv_sec + sinceboot;
-}
-
 static inline time_t get_expiry(char **bpp)
 {
 	int rv;

commit 013920eb5db97e99a4c30c8400f1c616e2a8b0a2
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jun 13 12:53:42 2013 +1000

    sunrpc/cache: ensure items removed from cache do not have pending upcalls.
    
    It is possible for a race to set CACHE_PENDING after cache_clean()
    has removed a cache entry from the cache.
    If CACHE_PENDING is still set when the entry is finally 'put',
    the cache_dequeue() will never happen and we can leak memory.
    
    So set a new flag 'CACHE_CLEANED' when we remove something from
    the cache, and don't queue any upcall if it is set.
    
    If CACHE_PENDING is set before CACHE_CLEANED, the call that
    cache_clean() makes to cache_fresh_unlocked() will free memory
    as needed.  If CACHE_PENDING is set after CACHE_CLEANED, the
    test in sunrpc_cache_pipe_upcall will ensure that the memory
    is not allocated.
    
    Reported-by: <bstroesser@ts.fujitsu.com>
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 303399b1ba59..8419f7dbdab2 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -57,6 +57,7 @@ struct cache_head {
 #define	CACHE_VALID	0	/* Entry contains valid data */
 #define	CACHE_NEGATIVE	1	/* Negative entry - there is no match for the key */
 #define	CACHE_PENDING	2	/* An upcall has been sent but no reply received yet*/
+#define	CACHE_CLEANED	3	/* Entry has been cleaned from cache */
 
 #define	CACHE_NEW_EXPIRY 120	/* keep new things pending confirmation for 120 seconds */
 

commit 21cd1254d3402a72927ed744e8ac1a7cf532f1ea
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Feb 4 14:02:55 2013 +0300

    SUNRPC: remove "cache_request" argument in sunrpc_cache_pipe_upcall() function
    
    Passing this pointer is redundant since it's stored on cache_detail structure,
    which is also passed to sunrpc_cache_pipe_upcall () function.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 4f1c8582053c..303399b1ba59 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -161,11 +161,7 @@ sunrpc_cache_update(struct cache_detail *detail,
 		    struct cache_head *new, struct cache_head *old, int hash);
 
 extern int
-sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h,
-		void (*cache_request)(struct cache_detail *,
-				      struct cache_head *,
-				      char **,
-				      int *));
+sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h);
 
 
 extern void cache_clean_deferred(void *owner);

commit 73fb847a44224d5708550e4be7baba9da75e00af
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Mon Feb 4 14:02:45 2013 +0300

    SUNRPC: introduce cache_detail->cache_request callback
    
    This callback will allow to simplify upcalls in further patches in this
    series.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 5dc9ee4d616e..4f1c8582053c 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -83,6 +83,10 @@ struct cache_detail {
 	int			(*cache_upcall)(struct cache_detail *,
 						struct cache_head *);
 
+	void			(*cache_request)(struct cache_detail *cd,
+						 struct cache_head *ch,
+						 char **bpp, int *blen);
+
 	int			(*cache_parse)(struct cache_detail *,
 					       char *buf, int len);
 

commit 621eb19ce1ec216e03ad354cb0c4061736b2a436
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Nov 14 10:48:05 2012 -0500

    svcrpc: Revert "sunrpc/cache.h: replace simple_strtoul"
    
    Commit bbf43dc888833ac0539e437dbaeb28bfd4fbab9f "sunrpc/cache.h: replace
    simple_strtoul" introduced new range-checking which could cause get_int
    to fail on unsigned integers too large to be represented as an int.
    
    We could parse them as unsigned instead--but it turns out svcgssd is
    actually passing down "-1" in some cases.  Which is perhaps stupid, but
    there's nothing we can do about it now.
    
    So just revert back to the previous "sloppy" behavior that accepts
    either representation.
    
    Cc: stable@vger.kernel.org
    Reported-by: Sven Geggus <lists@fuchsschwanzdomain.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index f792794f6634..5dc9ee4d616e 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -217,6 +217,8 @@ extern int qword_get(char **bpp, char *dest, int bufsize);
 static inline int get_int(char **bpp, int *anint)
 {
 	char buf[50];
+	char *ep;
+	int rv;
 	int len = qword_get(bpp, buf, sizeof(buf));
 
 	if (len < 0)
@@ -224,9 +226,11 @@ static inline int get_int(char **bpp, int *anint)
 	if (len == 0)
 		return -ENOENT;
 
-	if (kstrtoint(buf, 0, anint))
+	rv = simple_strtol(buf, &ep, 0);
+	if (*ep)
 		return -EINVAL;
 
+	*anint = rv;
 	return 0;
 }
 

commit a007c4c3e943ecc054a806c259d95420a188754b
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Jun 12 16:54:16 2012 -0400

    nfsd: add get_uint for u32's
    
    I don't think there's a practical difference for the range of values
    these interfaces should see, but it would be safer to be unambiguous.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index af42596a82f9..f792794f6634 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -230,6 +230,22 @@ static inline int get_int(char **bpp, int *anint)
 	return 0;
 }
 
+static inline int get_uint(char **bpp, unsigned int *anint)
+{
+	char buf[50];
+	int len = qword_get(bpp, buf, sizeof(buf));
+
+	if (len < 0)
+		return -EINVAL;
+	if (len == 0)
+		return -ENOENT;
+
+	if (kstrtouint(buf, 0, anint))
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * timestamps kept in the cache are expressed in seconds
  * since boot.  This is the best for measuring differences in

commit bbf43dc888833ac0539e437dbaeb28bfd4fbab9f
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Fri Jul 6 21:31:57 2012 +0200

    sunrpc/cache.h: replace simple_strtoul
    
    This patch replaces the usage of simple_strtoul with kstrtoint in
    get_int(), since the simple_str* family doesn't account for overflow
    and is deprecated.
    Also, in this specific case, the long from strtol is silently converted
    to an int by the caller.
    
    As Joe Perches <joe@perches.com> suggested, this patch also removes
    the redundant temporary variable rv, since kstrtoint() will not write to
    anint unless it's successful.
    
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6def1f6cc269..af42596a82f9 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -217,8 +217,6 @@ extern int qword_get(char **bpp, char *dest, int bufsize);
 static inline int get_int(char **bpp, int *anint)
 {
 	char buf[50];
-	char *ep;
-	int rv;
 	int len = qword_get(bpp, buf, sizeof(buf));
 
 	if (len < 0)
@@ -226,11 +224,9 @@ static inline int get_int(char **bpp, int *anint)
 	if (len == 0)
 		return -ENOENT;
 
-	rv = simple_strtol(buf, &ep, 0);
-	if (*ep)
+	if (kstrtoint(buf, 0, anint))
 		return -EINVAL;
 
-	*anint = rv;
 	return 0;
 }
 

commit d9c2ede63c74048dfddbb129c59ac01176b0ab71
Author: Eldad Zack <eldad@fogrefinery.com>
Date:   Fri Jul 6 21:31:56 2012 +0200

    sunrpc/cache.h: fix coding style
    
    Neaten code style in get_int().
    Also use sizeof() instead of hard coded number as suggested by
    Joe Perches <joe@perches.com>.
    
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index f5fd6160dbca..6def1f6cc269 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -219,11 +219,17 @@ static inline int get_int(char **bpp, int *anint)
 	char buf[50];
 	char *ep;
 	int rv;
-	int len = qword_get(bpp, buf, 50);
-	if (len < 0) return -EINVAL;
-	if (len ==0) return -ENOENT;
+	int len = qword_get(bpp, buf, sizeof(buf));
+
+	if (len < 0)
+		return -EINVAL;
+	if (len == 0)
+		return -ENOENT;
+
 	rv = simple_strtol(buf, &ep, 0);
-	if (*ep) return -EINVAL;
+	if (*ep)
+		return -EINVAL;
+
 	*anint = rv;
 	return 0;
 }

commit 2c5f846747526e2b83c5f1b8e69016be0e2e87c0
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Jan 19 21:42:53 2012 +0400

    SUNRPC: generic cache register routines removed
    
    All cache users now uses network-namespace-aware routines, so generic ones
    are obsolete.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 259381ca811b..f5fd6160dbca 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -198,9 +198,7 @@ extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
 extern void __init cache_initialize(void);
-extern int cache_register(struct cache_detail *cd);
 extern int cache_register_net(struct cache_detail *cd, struct net *net);
-extern void cache_unregister(struct cache_detail *cd);
 extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
 extern struct cache_detail *cache_create_net(struct cache_detail *tmpl, struct net *net);

commit 0a402d5a653ee2b613aaba3092a87b1e964622ce
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Thu Jan 19 21:42:21 2012 +0400

    SUNRPC: cache creation and destruction routines introduced
    
    This patch prepares infrastructure for network namespace aware cache detail
    allocation.
    One note about adding network namespace link to cache structure. It's going to
    be used later in NFS DNS cache parsing routine (nfs_dns_parse for rpc_pton()
    call).
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 590a8ab0cec3..259381ca811b 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -117,6 +117,7 @@ struct cache_detail {
 		struct cache_detail_procfs procfs;
 		struct cache_detail_pipefs pipefs;
 	} u;
+	struct net		*net;
 };
 
 
@@ -202,6 +203,9 @@ extern int cache_register_net(struct cache_detail *cd, struct net *net);
 extern void cache_unregister(struct cache_detail *cd);
 extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
+extern struct cache_detail *cache_create_net(struct cache_detail *tmpl, struct net *net);
+extern void cache_destroy_net(struct cache_detail *cd, struct net *net);
+
 extern void sunrpc_init_cache_detail(struct cache_detail *cd);
 extern void sunrpc_destroy_cache_detail(struct cache_detail *cd);
 extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,

commit 820f9442e711a81749e70c40f149fc54c4ce0ca8
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Fri Nov 25 17:12:40 2011 +0300

    SUNRPC: split cache creation and PipeFS registration
    
    This precursor patch splits SUNRPC cache creation and PipeFS registartion.
    It's required for latter split of NFS DNS resolver cache creation per network
    namespace context and PipeFS registration/unregistration on MOUNT/UMOUNT
    events.
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 57531f8e5956..590a8ab0cec3 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -202,6 +202,8 @@ extern int cache_register_net(struct cache_detail *cd, struct net *net);
 extern void cache_unregister(struct cache_detail *cd);
 extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
+extern void sunrpc_init_cache_detail(struct cache_detail *cd);
+extern void sunrpc_destroy_cache_detail(struct cache_detail *cd);
 extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
 					umode_t, struct cache_detail *);
 extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);

commit 64f1426f3c4f8dde9ac9bf3f3b19b88d17f2bae6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 25 00:35:13 2011 -0400

    sunrpc: propagate umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 5efd8cef389e..57531f8e5956 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -203,7 +203,7 @@ extern void cache_unregister(struct cache_detail *cd);
 extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
 extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
-					mode_t, struct cache_detail *);
+					umode_t, struct cache_detail *);
 extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);
 
 extern void qword_add(char **bpp, int *lp, char *str);

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index d1c79a906397..5efd8cef389e 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -15,7 +15,7 @@
 
 #include <linux/kref.h>
 #include <linux/slab.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <linux/proc_fs.h>
 
 /*

commit 49b28684fdba2c84a3b8e54aaa0faa9ce2e4f140
Author: NeilBrown <neilb@suse.de>
Date:   Tue Jun 21 15:27:43 2011 +1000

    nfsd: Remove deprecated nfsctl system call and related code.
    
    As promised in feature-removal-schedule.txt it is time to
    remove the nfsctl system call.
    
    Userspace has perferred to not use this call throughout 2.6 and it has been
    excluded in the default configuration since 2.6.36 (9 months ago).
    
    So this patch removes all the code that was being compiled out.
    
    There are still references to sys_nfsctl in various arch systemcall tables
    and related code.  These should be cleaned out too, probably in the next
    merge window.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 8d2eef1a8582..d1c79a906397 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -256,13 +256,4 @@ static inline time_t get_expiry(char **bpp)
 	return rv - boot.tv_sec;
 }
 
-#ifdef CONFIG_NFSD_DEPRECATED
-static inline void sunrpc_invalidate(struct cache_head *h,
-				     struct cache_detail *detail)
-{
-	h->expiry_time = seconds_since_boot() - 1;
-	detail->nextcheck = seconds_since_boot();
-}
-#endif /* CONFIG_NFSD_DEPRECATED */
-
 #endif /*  _LINUX_SUNRPC_CACHE_H_ */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 7898ea13de70..8d2eef1a8582 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -35,10 +35,10 @@
  * Each cache must be registered so that it can be cleaned regularly.
  * When the cache is unregistered, it is flushed completely.
  *
- * Entries have a ref count and a 'hashed' flag which counts the existance
+ * Entries have a ref count and a 'hashed' flag which counts the existence
  * in the hash table.
  * We only expire entries when refcount is zero.
- * Existance in the cache is counted  the refcount.
+ * Existence in the cache is counted  the refcount.
  */
 
 /* Every cache item has a common header that is used

commit 18bce371ae09af6c20ee62c1092a4d1d0e84dd49
Merge: ec08bdb14876 a8f2800b4f7b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 14 13:17:26 2011 -0800

    Merge branch 'for-2.6.38' of git://linux-nfs.org/~bfields/linux
    
    * 'for-2.6.38' of git://linux-nfs.org/~bfields/linux: (62 commits)
      nfsd4: fix callback restarting
      nfsd: break lease on unlink, link, and rename
      nfsd4: break lease on nfsd setattr
      nfsd: don't support msnfs export option
      nfsd4: initialize cb_per_client
      nfsd4: allow restarting callbacks
      nfsd4: simplify nfsd4_cb_prepare
      nfsd4: give out delegations more quickly in 4.1 case
      nfsd4: add helper function to run callbacks
      nfsd4: make sure sequence flags are set after destroy_session
      nfsd4: re-probe callback on connection loss
      nfsd4: set sequence flag when backchannel is down
      nfsd4: keep finer-grained callback status
      rpc: allow xprt_class->setup to return a preexisting xprt
      rpc: keep backchannel xprt as long as server connection
      rpc: move sk_bc_xprt to svc_xprt
      nfsd4: allow backchannel recovery
      nfsd4: support BIND_CONN_TO_SESSION
      nfsd4: modify session list under cl_lock
      Documentation: fl_mylease no longer exists
      ...
    
    Fix up conflicts in fs/nfsd/vfs.c with the vfs-scale work.  The
    vfs-scale work touched some msnfs cases, and this merge removes support
    for that entirely, so the conflict was trivial to resolve.

commit 57cc7215b70856dc6bae8e55b00ecd7b1d7429b1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jan 10 08:18:25 2011 +0200

    headers: kobject.h redux
    
    Remove kobject.h from files which don't need it, notably,
    sched.h and fs.h.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6950c981882d..78aa104250b7 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -13,6 +13,7 @@
 #ifndef _LINUX_SUNRPC_CACHE_H_
 #define _LINUX_SUNRPC_CACHE_H_
 
+#include <linux/kref.h>
 #include <linux/slab.h>
 #include <asm/atomic.h>
 #include <linux/proc_fs.h>

commit bdd5f05d91e8ae68075b812ce244c918d3d752cd
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Tue Jan 4 13:31:45 2011 -0500

    SUNRPC: Remove more code when NFSD_DEPRECATED is not configured
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    [bfields@redhat.com: moved svcauth_unix_purge outside ifdef's.]
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6950c981882d..c2aebe8eeffd 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -255,10 +255,13 @@ static inline time_t get_expiry(char **bpp)
 	return rv - boot.tv_sec;
 }
 
+#ifdef CONFIG_NFSD_DEPRECATED
 static inline void sunrpc_invalidate(struct cache_head *h,
 				     struct cache_detail *detail)
 {
 	h->expiry_time = seconds_since_boot() - 1;
 	detail->nextcheck = seconds_since_boot();
 }
+#endif /* CONFIG_NFSD_DEPRECATED */
+
 #endif /*  _LINUX_SUNRPC_CACHE_H_ */

commit 593ce16b943ea37d4ec62c377b32d7f3f4085e84
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Mon Sep 27 14:00:15 2010 +0400

    sunrpc: Add routines that allow registering per-net caches
    
    Existing calls do the same, but for the init_net.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 03496357f455..6950c981882d 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -197,7 +197,9 @@ extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
 extern void __init cache_initialize(void);
 extern int cache_register(struct cache_detail *cd);
+extern int cache_register_net(struct cache_detail *cd, struct net *net);
 extern void cache_unregister(struct cache_detail *cd);
+extern void cache_unregister_net(struct cache_detail *cd, struct net *net);
 
 extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
 					mode_t, struct cache_detail *);

commit 1117449276bb909b029ed0b9ba13f53e4784db9d
Author: NeilBrown <neilb@suse.de>
Date:   Thu Aug 12 17:04:08 2010 +1000

    sunrpc/cache: change deferred-request hash table to use hlist.
    
    Being a hash table, hlist is the best option.
    
    There is currently some ugliness were we treat "->next == NULL" as
    a special case to avoid having to initialise the whole array.
    This change nicely gets rid of that case.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 52a7d7224e90..03496357f455 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -133,7 +133,7 @@ struct cache_req {
  * delayed awaiting cache-fill
  */
 struct cache_deferred_req {
-	struct list_head	hash;	/* on hash chain */
+	struct hlist_node	hash;	/* on hash chain */
 	struct list_head	recent; /* on fifo */
 	struct cache_head	*item;  /* cache item we wait on */
 	void			*owner; /* we might need to discard all defered requests

commit f16b6e8d838b2e2bb4561201311c66ac02ad67df
Author: NeilBrown <neilb@suse.de>
Date:   Thu Aug 12 17:04:06 2010 +1000

    sunrpc/cache: allow threads to block while waiting for cache update.
    
    The current practice of waiting for cache updates by queueing the
    whole request to be retried has (at least) two problems.
    
    1/ With NFSv4, requests can be quite complex and re-trying a whole
      request when a later part fails should only be a last-resort, not a
      normal practice.
    
    2/ Large requests, and in particular any 'write' request, will not be
      queued by the current code and doing so would be undesirable.
    
    In many cases only a very sort wait is needed before the cache gets
    valid data.
    
    So, providing the underlying transport permits it by setting
     ->thread_wait,
    arrange to wait briefly for an upcall to be completed (as reflected in
    the clearing of CACHE_PENDING).
    If the short wait was not long enough and CACHE_PENDING is still set,
    fall back on the old approach.
    
    The 'thread_wait' value is set to 5 seconds when there are spare
    threads, and 1 second when there are no spare threads.
    
    These values are probably much higher than needed, but will ensure
    some forward progress.
    
    Note that as we only request an update for a non-valid item, and as
    non-valid items are updated in place it is extremely unlikely that
    cache_check will return -ETIMEDOUT.  Normally cache_defer_req will
    sleep for a short while and then find that the item is_valid.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index ece432b7f87f..52a7d7224e90 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -125,6 +125,9 @@ struct cache_detail {
  */
 struct cache_req {
 	struct cache_deferred_req *(*defer)(struct cache_req *req);
+	int thread_wait;  /* How long (jiffies) we can block the
+			   * current thread to wait for updates.
+			   */
 };
 /* this must be embedded in a deferred_request that is being
  * delayed awaiting cache-fill

commit c5b29f885afe890f953f7f23424045cdad31d3e4
Author: NeilBrown <neilb@suse.de>
Date:   Thu Aug 12 16:55:22 2010 +1000

    sunrpc: use seconds since boot in expiry cache
    
    This protects us from confusion when the wallclock time changes.
    
    We convert to and from wallclock when  setting or reading expiry
    times.
    
    Also use seconds since boot for last_clost time.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 0e1febf4e5bc..ece432b7f87f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -218,20 +218,42 @@ static inline int get_int(char **bpp, int *anint)
 	return 0;
 }
 
+/*
+ * timestamps kept in the cache are expressed in seconds
+ * since boot.  This is the best for measuring differences in
+ * real time.
+ */
+static inline time_t seconds_since_boot(void)
+{
+	struct timespec boot;
+	getboottime(&boot);
+	return get_seconds() - boot.tv_sec;
+}
+
+static inline time_t convert_to_wallclock(time_t sinceboot)
+{
+	struct timespec boot;
+	getboottime(&boot);
+	return boot.tv_sec + sinceboot;
+}
+
 static inline time_t get_expiry(char **bpp)
 {
 	int rv;
+	struct timespec boot;
+
 	if (get_int(bpp, &rv))
 		return 0;
 	if (rv < 0)
 		return 0;
-	return rv;
+	getboottime(&boot);
+	return rv - boot.tv_sec;
 }
 
 static inline void sunrpc_invalidate(struct cache_head *h,
 				     struct cache_detail *detail)
 {
-	h->expiry_time = get_seconds() - 1;
-	detail->nextcheck = get_seconds();
+	h->expiry_time = seconds_since_boot() - 1;
+	detail->nextcheck = seconds_since_boot();
 }
 #endif /*  _LINUX_SUNRPC_CACHE_H_ */

commit 17cebf658e088935d4bdebfc7ad9800e9fc4a0b2
Author: NeilBrown <neilb@suse.de>
Date:   Thu Aug 12 16:55:22 2010 +1000

    sunrpc: extract some common sunrpc_cache code from nfsd
    
    Rather can duplicating this idiom twice, put it in an inline function.
    This reduces the usage of 'expiry_time' out side the sunrpc/cache.c
    code and thus the impact of a change that is about to be made to that
    field.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 7bf3e84b92f4..0e1febf4e5bc 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -228,4 +228,10 @@ static inline time_t get_expiry(char **bpp)
 	return rv;
 }
 
+static inline void sunrpc_invalidate(struct cache_head *h,
+				     struct cache_detail *detail)
+{
+	h->expiry_time = get_seconds() - 1;
+	detail->nextcheck = get_seconds();
+}
 #endif /*  _LINUX_SUNRPC_CACHE_H_ */

commit 8eab945c5616fc984e97b922d6a2559be93f39a1
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Thu Jul 1 18:05:56 2010 +0300

    sunrpc: make the cache cleaner workqueue deferrable
    
    This patch makes the cache_cleaner workqueue deferrable, to prevent
    unnecessary system wake-ups, which is very important for embedded
    battery-powered devices.
    
    do_cache_clean() is called every 30 seconds at the moment, and often
    makes the system wake up from its power-save sleep state. With this
    change, when the workqueue uses a deferrable timer, the
    do_cache_clean() invocation will be delayed and combined with the
    closest "real" wake-up. This improves the power consumption situation.
    
    Note, I tried to create a DECLARE_DELAYED_WORK_DEFERRABLE() helper
    macro, similar to DECLARE_DELAYED_WORK(), but failed because of the
    way the timer wheel core stores the deferrable flag (it is the
    LSBit in the time->base pointer). My attempt to define a static
    variable with this bit set ended up with the "initializer element is
    not constant" error.
    
    Thus, I have to use run-time initialization, so I created a new
    cache_initialize() function which is called once when sunrpc is
    being initialized.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6f52b4d7c447..7bf3e84b92f4 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -192,6 +192,7 @@ extern int cache_check(struct cache_detail *detail,
 extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
+extern void __init cache_initialize(void);
 extern int cache_register(struct cache_detail *cd);
 extern void cache_unregister(struct cache_detail *cd);
 

commit 8854e82d9accc80f43c0bc3ff06b5979ac858185
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Aug 9 15:14:30 2009 -0400

    SUNRPC: Add an rpc_pipefs front end for the sunrpc cache code
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 8e5bf3036652..6f52b4d7c447 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -64,6 +64,10 @@ struct cache_detail_procfs {
 	struct proc_dir_entry   *flush_ent, *channel_ent, *content_ent;
 };
 
+struct cache_detail_pipefs {
+	struct dentry *dir;
+};
+
 struct cache_detail {
 	struct module *		owner;
 	int			hash_size;
@@ -110,6 +114,7 @@ struct cache_detail {
 
 	union {
 		struct cache_detail_procfs procfs;
+		struct cache_detail_pipefs pipefs;
 	} u;
 };
 
@@ -135,6 +140,10 @@ struct cache_deferred_req {
 };
 
 
+extern const struct file_operations cache_file_operations_pipefs;
+extern const struct file_operations content_file_operations_pipefs;
+extern const struct file_operations cache_flush_operations_pipefs;
+
 extern struct cache_head *
 sunrpc_cache_lookup(struct cache_detail *detail,
 		    struct cache_head *key, int hash);
@@ -186,6 +195,10 @@ extern void cache_purge(struct cache_detail *detail);
 extern int cache_register(struct cache_detail *cd);
 extern void cache_unregister(struct cache_detail *cd);
 
+extern int sunrpc_cache_register_pipefs(struct dentry *parent, const char *,
+					mode_t, struct cache_detail *);
+extern void sunrpc_cache_unregister_pipefs(struct cache_detail *);
+
 extern void qword_add(char **bpp, int *lp, char *str);
 extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);
 extern int qword_get(char **bpp, char *dest, int bufsize);

commit 173912a6add00f4715774dcecf9ee53274c5924c
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Aug 9 15:14:29 2009 -0400

    SUNRPC: Move procfs-specific stuff out of the generic sunrpc cache code
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 23ee25981a0c..8e5bf3036652 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -59,6 +59,11 @@ struct cache_head {
 
 #define	CACHE_NEW_EXPIRY 120	/* keep new things pending confirmation for 120 seconds */
 
+struct cache_detail_procfs {
+	struct proc_dir_entry	*proc_ent;
+	struct proc_dir_entry   *flush_ent, *channel_ent, *content_ent;
+};
+
 struct cache_detail {
 	struct module *		owner;
 	int			hash_size;
@@ -98,12 +103,14 @@ struct cache_detail {
 
 	/* fields for communication over channel */
 	struct list_head	queue;
-	struct proc_dir_entry	*proc_ent;
-	struct proc_dir_entry   *flush_ent, *channel_ent, *content_ent;
 
 	atomic_t		readers;		/* how many time is /chennel open */
 	time_t			last_close;		/* if no readers, when did last close */
 	time_t			last_warn;		/* when we last warned about no readers */
+
+	union {
+		struct cache_detail_procfs procfs;
+	} u;
 };
 
 

commit bc74b4f5e63a09fb78e245794a0de1e5a2716bbe
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Aug 9 15:14:29 2009 -0400

    SUNRPC: Allow the cache_detail to specify alternative upcall mechanisms
    
    For events that are rare, such as referral DNS lookups, it makes limited
    sense to have a daemon constantly listening for upcalls on a channel. An
    alternative in those cases might simply be to run the app that fills the
    cache using call_usermodehelper_exec() and friends.
    
    The following patch allows the cache_detail to specify alternative upcall
    mechanisms for these particular cases.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 3d1fad22185a..23ee25981a0c 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -70,9 +70,9 @@ struct cache_detail {
 	char			*name;
 	void			(*cache_put)(struct kref *);
 
-	void			(*cache_request)(struct cache_detail *cd,
-						 struct cache_head *h,
-						 char **bpp, int *blen);
+	int			(*cache_upcall)(struct cache_detail *,
+						struct cache_head *);
+
 	int			(*cache_parse)(struct cache_detail *,
 					       char *buf, int len);
 
@@ -135,6 +135,13 @@ extern struct cache_head *
 sunrpc_cache_update(struct cache_detail *detail,
 		    struct cache_head *new, struct cache_head *old, int hash);
 
+extern int
+sunrpc_cache_pipe_upcall(struct cache_detail *detail, struct cache_head *h,
+		void (*cache_request)(struct cache_detail *,
+				      struct cache_head *,
+				      char **,
+				      int *));
+
 
 extern void cache_clean_deferred(void *owner);
 

commit 2da8ca26c6bfad685bfddf39728eac1c83906aa9
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sun Aug 9 15:14:26 2009 -0400

    NFSD: Clean up the idmapper warning...
    
    What part of 'internal use' is so hard to understand?
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 2d8b211b9324..3d1fad22185a 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -79,6 +79,8 @@ struct cache_detail {
 	int			(*cache_show)(struct seq_file *m,
 					      struct cache_detail *cd,
 					      struct cache_head *h);
+	void			(*warn_no_listener)(struct cache_detail *cd,
+					      int has_died);
 
 	struct cache_head *	(*alloc)(void);
 	int			(*match)(struct cache_head *orig, struct cache_head *new);
@@ -102,7 +104,6 @@ struct cache_detail {
 	atomic_t		readers;		/* how many time is /chennel open */
 	time_t			last_close;		/* if no readers, when did last close */
 	time_t			last_warn;		/* when we last warned about no readers */
-	void			(*warn_no_listener)(struct cache_detail *cd);
 };
 
 

commit 67eb6ff610d50da231a37beb634d6dea4b5025ab
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Jan 31 16:14:54 2008 -0500

    svcrpc: move unused field from cache_deferred_req
    
    This field is set once and never used; probably some artifact of an
    earlier implementation idea.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 03547d6abee5..2d8b211b9324 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -120,7 +120,6 @@ struct cache_deferred_req {
 	struct list_head	hash;	/* on hash chain */
 	struct list_head	recent; /* on fifo */
 	struct cache_head	*item;  /* cache item we wait on */
-	time_t			recv_time;
 	void			*owner; /* we might need to discard all defered requests
 					 * owned by someone */
 	void			(*revisit)(struct cache_deferred_req *req,

commit dbf847ecb6318d3a22c6758fe39696d00f39063a
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Nov 8 17:20:34 2007 -0500

    knfsd: allow cache_register to return error on failure
    
    Newer server features such as nfsv4 and gss depend on proc to work, so a
    failure to initialize the proc files they need should be treated as
    fatal.
    
    Thanks to Andrew Morton for style fix and compile fix in case where
    CONFIG_NFSD_V4 is undefined.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index b683b5ddeea9..03547d6abee5 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -169,7 +169,7 @@ extern int cache_check(struct cache_detail *detail,
 extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
-extern void cache_register(struct cache_detail *cd);
+extern int cache_register(struct cache_detail *cd);
 extern void cache_unregister(struct cache_detail *cd);
 
 extern void qword_add(char **bpp, int *lp, char *str);

commit df95a9d4fb91d819d3fb55dd437056df59e7f15e
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Nov 8 16:09:59 2007 -0500

    knfsd: cache unregistration needn't return error
    
    There's really nothing much the caller can do if cache unregistration
    fails.  And indeed, all any caller does in this case is print an error
    and continue.  So just return void and move the printk's inside
    cache_unregister.
    
    Acked-by: NeilBrown <neilb@suse.de>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index bd7a6b0a87af..b683b5ddeea9 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -170,7 +170,7 @@ extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
 extern void cache_register(struct cache_detail *cd);
-extern int cache_unregister(struct cache_detail *cd);
+extern void cache_unregister(struct cache_detail *cd);
 
 extern void qword_add(char **bpp, int *lp, char *str);
 extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);

commit dca1dd30ce0a6234acc751bb90efba1b49079669
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Jul 12 15:30:32 2007 -0400

    nfsd: remove unused cache_for_each macro
    
    This macro is unused.
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>
    Acked-by:  Neil Brown <neilb@suse.de>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 3699dff7db8f..bd7a6b0a87af 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -136,16 +136,6 @@ sunrpc_cache_update(struct cache_detail *detail,
 		    struct cache_head *new, struct cache_head *old, int hash);
 
 
-#define cache_for_each(pos, detail, index, member) 						\
-	for (({read_lock(&(detail)->hash_lock); index = (detail)->hash_size;}) ;		\
-	     ({if (index==0)read_unlock(&(detail)->hash_lock); index--;});			\
-		)										\
-		for (pos = container_of((detail)->hash_table[index], typeof(*pos), member);	\
-		     &pos->member;								\
-		     pos = container_of(pos->member.next, typeof(*pos), member))
-
-	     
-
 extern void cache_clean_deferred(void *owner);
 
 static inline struct cache_head  *cache_get(struct cache_head *h)

commit 7b2b1fee30df7e2165525cd03f7d1d01a3a56794
Author: Greg Banks <gnb@melbourne.sgi.com>
Date:   Wed Oct 4 02:15:50 2006 -0700

    [PATCH] knfsd: knfsd: cache ipmap per TCP socket
    
    Speed up high call-rate workloads by caching the struct ip_map for the peer on
    the connected struct svc_sock instead of looking it up in the ip_map cache
    hashtable on every call.  This helps workloads using AUTH_SYS authentication
    over TCP.
    
    Testing was on a 4 CPU 4 NIC Altix using 4 IRIX clients, each with 16
    synthetic client threads simulating an rsync (i.e.  recursive directory
    listing) workload reading from an i386 RH9 install image (161480 regular files
    in 10841 directories) on the server.  That tree is small enough to fill in the
    server's RAM so no disk traffic was involved.  This setup gives a sustained
    call rate in excess of 60000 calls/sec before being CPU-bound on the server.
    
    Profiling showed strcmp(), called from ip_map_match(), was taking 4.8% of each
    CPU, and ip_map_lookup() was taking 2.9%.  This patch drops both contribution
    into the profile noise.
    
    Note that the above result overstates this value of this patch for most
    workloads.  The synthetic clients are all using separate IP addresses, so
    there are 64 entries in the ip_map cache hash.  Because the kernel measured
    contained the bug fixed in commit
    
    commit 1f1e030bf75774b6a283518e1534d598e14147d4
    
    and was running on 64bit little-endian machine, probably all of those 64
    entries were on a single chain, thus increasing the cost of ip_map_lookup().
    
    With a modern kernel you would need more clients to see the same amount of
    performance improvement.  This patch has helped to scale knfsd to handle a
    deployment with 2000 NFS clients.
    
    Signed-off-by: Greg Banks <gnb@melbourne.sgi.com>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index b5612c958cce..3699dff7db8f 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -163,6 +163,17 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 	kref_put(&h->ref, cd->cache_put);
 }
 
+static inline int cache_valid(struct cache_head *h)
+{
+	/* If an item has been unhashed pending removal when
+	 * the refcount drops to 0, the expiry_time will be
+	 * set to 0.  We don't want to consider such items
+	 * valid in this context even though CACHE_VALID is
+	 * set.
+	 */
+	return (h->expiry_time != 0 && test_bit(CACHE_VALID, &h->flags));
+}
+
 extern int cache_check(struct cache_detail *detail,
 		       struct cache_head *h, struct cache_req *rqstp);
 extern void cache_flush(void);

commit 74cae61ab45f19a3e8c4d9f53c0e94df129c7915
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Mar 27 01:15:10 2006 -0800

    [PATCH] fs/nfsd/export.c,net/sunrpc/cache.c: make needlessly global code static
    
    We can now make some code static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index ad3f5cbdb770..b5612c958cce 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -163,7 +163,6 @@ static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 	kref_put(&h->ref, cd->cache_put);
 }
 
-extern void cache_init(struct cache_head *h);
 extern int cache_check(struct cache_detail *detail,
 		       struct cache_head *h, struct cache_req *rqstp);
 extern void cache_flush(void);

commit baab935ff3bdac20c558809da0d8e8f761840219
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 27 01:15:09 2006 -0800

    [PATCH] knfsd: Convert sunrpc_cache to use krefs
    
    .. it makes some of the code nicer.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index a37fead1873b..ad3f5cbdb770 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -50,7 +50,7 @@ struct cache_head {
 	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall 
 					 * was sent, else this is when update was received
 					 */
-	atomic_t 	refcnt;
+	struct kref	ref;
 	unsigned long	flags;
 };
 #define	CACHE_VALID	0	/* Entry contains valid data */
@@ -68,8 +68,7 @@ struct cache_detail {
 	atomic_t		inuse; /* active user-space update or lookup */
 
 	char			*name;
-	void			(*cache_put)(struct cache_head *,
-					     struct cache_detail*);
+	void			(*cache_put)(struct kref *);
 
 	void			(*cache_request)(struct cache_detail *cd,
 						 struct cache_head *h,
@@ -151,17 +150,17 @@ extern void cache_clean_deferred(void *owner);
 
 static inline struct cache_head  *cache_get(struct cache_head *h)
 {
-	atomic_inc(&h->refcnt);
+	kref_get(&h->ref);
 	return h;
 }
 
 
-static inline int cache_put(struct cache_head *h, struct cache_detail *cd)
+static inline void cache_put(struct cache_head *h, struct cache_detail *cd)
 {
-	if (atomic_read(&h->refcnt) <= 2 &&
+	if (atomic_read(&h->ref.refcount) <= 2 &&
 	    h->expiry_time < cd->nextcheck)
 		cd->nextcheck = h->expiry_time;
-	return atomic_dec_and_test(&h->refcnt);
+	kref_put(&h->ref, cd->cache_put);
 }
 
 extern void cache_init(struct cache_head *h);

commit ebd0cb1af3be2729cc1f574681dfba01fcf458d9
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 27 01:15:08 2006 -0800

    [PATCH] knfsd: Unexport cache_fresh and fix a small race
    
    Cache_fresh is now only used in cache.c, so unexport it.
    
    Part of cache_fresh (setting CACHE_VALID) should really be done under the
    lock, while part (calling cache_revisit_request etc) must be done outside the
    lock.  So we split it up appropriately.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index afc481dd02dd..a37fead1873b 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -165,8 +165,6 @@ static inline int cache_put(struct cache_head *h, struct cache_detail *cd)
 }
 
 extern void cache_init(struct cache_head *h);
-extern void cache_fresh(struct cache_detail *detail,
-			struct cache_head *head, time_t expiry);
 extern int cache_check(struct cache_detail *detail,
 		       struct cache_head *h, struct cache_req *rqstp);
 extern void cache_flush(void);

commit 4d90452cb23b08a9a9dd001010f0ee6b1ee83a45
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 27 01:15:07 2006 -0800

    [PATCH] knfsd: Remove DefineCacheLookup
    
    This has been replaced by more traditional code.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 3e17a5ff1dea..afc481dd02dd 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -128,119 +128,6 @@ struct cache_deferred_req {
 					   int too_many);
 };
 
-/*
- * just like a template in C++, this macro does cache lookup
- * for us.
- * The function is passed some sort of HANDLE from which a cache_detail
- * structure can be determined (via SETUP, DETAIL), a template
- * cache entry (type RTN*), and a "set" flag.  Using the HASHFN and the 
- * TEST, the function will try to find a matching cache entry in the cache.
- * If "set" == 0 :
- *    If an entry is found, it is returned
- *    If no entry is found, a new non-VALID entry is created.
- * If "set" == 1 :
- *    If no entry is found a new one is inserted with data from "template"
- *    If a non-CACHE_VALID entry is found, it is updated from template using UPDATE
- *    If a CACHE_VALID entry is found, a new entry is swapped in with data
- *       from "template"
- *
- * If the passed handle has the CACHE_NEGATIVE flag set, then UPDATE is not
- * run but insteead CACHE_NEGATIVE is set in any new item.
-
- *  In any case, the new entry is returned with a reference count.
- *
- *    
- * RTN is a struct type for a cache entry
- * MEMBER is the member of the cache which is cache_head, which must be first
- * FNAME is the name for the function	
- * ARGS are arguments to function and must contain RTN *item, int set.  May
- *   also contain something to be usedby SETUP or DETAIL to find cache_detail.
- * SETUP  locates the cache detail and makes it available as...
- * DETAIL identifies the cache detail, possibly set up by SETUP
- * HASHFN returns a hash value of the cache entry "item"
- * TEST  tests if "tmp" matches "item"
- * INIT copies key information from "item" to "new"
- * UPDATE copies content information from "item" to "tmp"
- */
-#define DefineCacheLookup(RTN,MEMBER,FNAME,ARGS,SETUP,DETAIL,HASHFN,TEST,INIT,UPDATE)	\
-RTN *FNAME ARGS										\
-{											\
-	RTN *tmp, *new=NULL;								\
-	struct cache_head **hp, **head;							\
-	SETUP;										\
-	head = &(DETAIL)->hash_table[HASHFN];						\
- retry:											\
-	if (set||new) write_lock(&(DETAIL)->hash_lock);					\
-	else read_lock(&(DETAIL)->hash_lock);						\
-	for(hp=head; *hp != NULL; hp = &tmp->MEMBER.next) {				\
-		tmp = container_of(*hp, RTN, MEMBER);					\
-		if (TEST) { /* found a match */						\
-											\
-			if (set && test_bit(CACHE_VALID, &tmp->MEMBER.flags) && !new)	\
-				break;							\
-											\
-			if (new)							\
-				{INIT;}							\
-			if (set) {							\
-				if (test_bit(CACHE_VALID, &tmp->MEMBER.flags))\
-				{ /* need to swap in new */				\
-					RTN *t2;					\
-											\
-					new->MEMBER.next = tmp->MEMBER.next;		\
-					*hp = &new->MEMBER;				\
-					tmp->MEMBER.next = NULL;			\
-					t2 = tmp; tmp = new; new = t2;			\
-				}							\
-				if (test_bit(CACHE_NEGATIVE,  &item->MEMBER.flags))	\
-					set_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);	\
-				else {							\
-					UPDATE;						\
-					clear_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);	\
-				}							\
-			}								\
-			cache_get(&tmp->MEMBER);					\
-			if (set||new) write_unlock(&(DETAIL)->hash_lock);		\
-			else read_unlock(&(DETAIL)->hash_lock);				\
-			if (set)							\
-				cache_fresh(DETAIL, &tmp->MEMBER, item->MEMBER.expiry_time); \
-			if (set && new) cache_fresh(DETAIL, &new->MEMBER, 0);	\
-			if (new) (DETAIL)->cache_put(&new->MEMBER, DETAIL);		\
-			return tmp;							\
-		}									\
-	}										\
-	/* Didn't find anything */							\
-	if (new) {									\
-		INIT;									\
-		new->MEMBER.next = *head;						\
-		*head = &new->MEMBER;							\
-		(DETAIL)->entries ++;							\
-		cache_get(&new->MEMBER);						\
-		if (set) {								\
-			tmp = new;							\
-			if (test_bit(CACHE_NEGATIVE, &item->MEMBER.flags))		\
-				set_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);		\
-			else {UPDATE;}							\
-		}									\
-	}										\
-	if (set||new) write_unlock(&(DETAIL)->hash_lock);				\
-	else read_unlock(&(DETAIL)->hash_lock);						\
-	if (new && set)									\
-		cache_fresh(DETAIL, &new->MEMBER, item->MEMBER.expiry_time);		\
-	if (new)				       					\
-		return new;								\
-	new = kmalloc(sizeof(*new), GFP_KERNEL);					\
-	if (new) {									\
-		cache_init(&new->MEMBER);						\
-		goto retry;								\
-	}										\
-	return NULL;									\
-}
-
-#define DefineSimpleCacheLookup(STRUCT, FUNC)				\
-        DefineCacheLookup(struct STRUCT, h, FUNC##_lookup,		\
-        (struct STRUCT *item, int set), /*no setup */,			\
-	& FUNC##_cache, FUNC##_hash(item), FUNC##_match(item, tmp),	\
-	STRUCT##_init(new, item), STRUCT##_update(tmp, item))
 
 extern struct cache_head *
 sunrpc_cache_lookup(struct cache_detail *detail,

commit 15a5f6bd23eddd5b3be80366f364be04fb1c1c99
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 27 01:15:02 2006 -0800

    [PATCH] knfsd: Create cache_lookup function instead of using a macro to declare one
    
    The C++-like 'template' approach proves to be too ugly and hard to work with.
    
    The old 'template' won't go away until all users are updated.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 405ac14e509a..3e17a5ff1dea 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -81,6 +81,11 @@ struct cache_detail {
 					      struct cache_detail *cd,
 					      struct cache_head *h);
 
+	struct cache_head *	(*alloc)(void);
+	int			(*match)(struct cache_head *orig, struct cache_head *new);
+	void			(*init)(struct cache_head *orig, struct cache_head *new);
+	void			(*update)(struct cache_head *orig, struct cache_head *new);
+
 	/* fields below this comment are for internal use
 	 * and should not be touched by cache owners
 	 */
@@ -237,6 +242,13 @@ RTN *FNAME ARGS										\
 	& FUNC##_cache, FUNC##_hash(item), FUNC##_match(item, tmp),	\
 	STRUCT##_init(new, item), STRUCT##_update(tmp, item))
 
+extern struct cache_head *
+sunrpc_cache_lookup(struct cache_detail *detail,
+		    struct cache_head *key, int hash);
+extern struct cache_head *
+sunrpc_cache_update(struct cache_detail *detail,
+		    struct cache_head *new, struct cache_head *old, int hash);
+
 
 #define cache_for_each(pos, detail, index, member) 						\
 	for (({read_lock(&(detail)->hash_lock); index = (detail)->hash_size;}) ;		\

commit 7d317f2c9f1e9dcf4f632fa98f91d1d4a36c4cae
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 27 01:15:01 2006 -0800

    [PATCH] knfsd: Get rid of 'inplace' sunrpc caches
    
    These were an unnecessary wart.  Also only have one 'DefineSimpleCache..'
    instead of two.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index c4e3ea7cf154..405ac14e509a 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -133,14 +133,11 @@ struct cache_deferred_req {
  * If "set" == 0 :
  *    If an entry is found, it is returned
  *    If no entry is found, a new non-VALID entry is created.
- * If "set" == 1 and INPLACE == 0 :
+ * If "set" == 1 :
  *    If no entry is found a new one is inserted with data from "template"
  *    If a non-CACHE_VALID entry is found, it is updated from template using UPDATE
  *    If a CACHE_VALID entry is found, a new entry is swapped in with data
  *       from "template"
- * If set == 1, and INPLACE == 1 :
- *    As above, except that if a CACHE_VALID entry is found, we UPDATE in place
- *       instead of swapping in a new entry.
  *
  * If the passed handle has the CACHE_NEGATIVE flag set, then UPDATE is not
  * run but insteead CACHE_NEGATIVE is set in any new item.
@@ -159,13 +156,8 @@ struct cache_deferred_req {
  * TEST  tests if "tmp" matches "item"
  * INIT copies key information from "item" to "new"
  * UPDATE copies content information from "item" to "tmp"
- * INPLACE is true if updates can happen inplace rather than allocating a new structure
- *
- * WARNING: any substantial changes to this must be reflected in
- *   net/sunrpc/svcauth.c(auth_domain_lookup)
- *  which is a similar routine that is open-coded.
  */
-#define DefineCacheLookup(RTN,MEMBER,FNAME,ARGS,SETUP,DETAIL,HASHFN,TEST,INIT,UPDATE,INPLACE)	\
+#define DefineCacheLookup(RTN,MEMBER,FNAME,ARGS,SETUP,DETAIL,HASHFN,TEST,INIT,UPDATE)	\
 RTN *FNAME ARGS										\
 {											\
 	RTN *tmp, *new=NULL;								\
@@ -179,13 +171,13 @@ RTN *FNAME ARGS										\
 		tmp = container_of(*hp, RTN, MEMBER);					\
 		if (TEST) { /* found a match */						\
 											\
-			if (set && !INPLACE && test_bit(CACHE_VALID, &tmp->MEMBER.flags) && !new) \
+			if (set && test_bit(CACHE_VALID, &tmp->MEMBER.flags) && !new)	\
 				break;							\
 											\
 			if (new)							\
 				{INIT;}							\
 			if (set) {							\
-				if (!INPLACE && test_bit(CACHE_VALID, &tmp->MEMBER.flags))\
+				if (test_bit(CACHE_VALID, &tmp->MEMBER.flags))\
 				{ /* need to swap in new */				\
 					RTN *t2;					\
 											\
@@ -206,7 +198,7 @@ RTN *FNAME ARGS										\
 			else read_unlock(&(DETAIL)->hash_lock);				\
 			if (set)							\
 				cache_fresh(DETAIL, &tmp->MEMBER, item->MEMBER.expiry_time); \
-			if (set && !INPLACE && new) cache_fresh(DETAIL, &new->MEMBER, 0);	\
+			if (set && new) cache_fresh(DETAIL, &new->MEMBER, 0);	\
 			if (new) (DETAIL)->cache_put(&new->MEMBER, DETAIL);		\
 			return tmp;							\
 		}									\
@@ -239,10 +231,12 @@ RTN *FNAME ARGS										\
 	return NULL;									\
 }
 
-#define DefineSimpleCacheLookup(STRUCT,INPLACE)	\
-	DefineCacheLookup(struct STRUCT, h, STRUCT##_lookup, (struct STRUCT *item, int set), /*no setup */,	\
-			  & STRUCT##_cache, STRUCT##_hash(item), STRUCT##_match(item, tmp),\
-			  STRUCT##_init(new, item), STRUCT##_update(tmp, item),INPLACE)
+#define DefineSimpleCacheLookup(STRUCT, FUNC)				\
+        DefineCacheLookup(struct STRUCT, h, FUNC##_lookup,		\
+        (struct STRUCT *item, int set), /*no setup */,			\
+	& FUNC##_cache, FUNC##_hash(item), FUNC##_match(item, tmp),	\
+	STRUCT##_init(new, item), STRUCT##_update(tmp, item))
+
 
 #define cache_for_each(pos, detail, index, member) 						\
 	for (({read_lock(&(detail)->hash_lock); index = (detail)->hash_size;}) ;		\

commit f35279d3f713e5c97b98cbdbf47d98f79942c11f
Author: Bruce Allan <bwa@us.ibm.com>
Date:   Tue Sep 6 15:17:08 2005 -0700

    [PATCH] sunrpc: cache_register can use wrong module reference
    
    When registering an RPC cache, cache_register() always sets the owner as the
    sunrpc module.  However, there are RPC caches owned by other modules.  With
    the incorrect owner setting, the real owning module can be removed potentially
    with an open reference to the cache from userspace.
    
    For example, if one were to stop the nfs server and unmount the nfsd
    filesystem, the nfsd module could be removed eventhough rpc.idmapd had
    references to the idtoname and nametoid caches (i.e.
    /proc/net/rpc/nfs4.<cachename>/channel is still open).  This resulted in a
    system panic on one of our machines when attempting to restart the nfs
    services after reloading the nfsd module.
    
    The following patch adds a 'struct module *owner' field in struct
    cache_detail.  The owner is further assigned to the struct proc_dir_entry
    in cache_register() so that the module cannot be unloaded while user-space
    daemons have an open reference on the associated file under /proc.
    
    Signed-off-by: Bruce Allan <bwa@us.ibm.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 6864063d1b9f..c4e3ea7cf154 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -60,6 +60,7 @@ struct cache_head {
 #define	CACHE_NEW_EXPIRY 120	/* keep new things pending confirmation for 120 seconds */
 
 struct cache_detail {
+	struct module *		owner;
 	int			hash_size;
 	struct cache_head **	hash_table;
 	rwlock_t		hash_lock;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
new file mode 100644
index 000000000000..6864063d1b9f
--- /dev/null
+++ b/include/linux/sunrpc/cache.h
@@ -0,0 +1,312 @@
+/*
+ * include/linux/sunrpc/cache.h
+ *
+ * Generic code for various authentication-related caches
+ * used by sunrpc clients and servers.
+ *
+ * Copyright (C) 2002 Neil Brown <neilb@cse.unsw.edu.au>
+ *
+ * Released under terms in GPL version 2.  See COPYING.
+ *
+ */
+
+#ifndef _LINUX_SUNRPC_CACHE_H_
+#define _LINUX_SUNRPC_CACHE_H_
+
+#include <linux/slab.h>
+#include <asm/atomic.h>
+#include <linux/proc_fs.h>
+
+/*
+ * Each cache requires:
+ *  - A 'struct cache_detail' which contains information specific to the cache
+ *    for common code to use.
+ *  - An item structure that must contain a "struct cache_head"
+ *  - A lookup function defined using DefineCacheLookup
+ *  - A 'put' function that can release a cache item. It will only
+ *    be called after cache_put has succeed, so there are guarantee
+ *    to be no references.
+ *  - A function to calculate a hash of an item's key.
+ *
+ * as well as assorted code fragments (e.g. compare keys) and numbers
+ * (e.g. hash size, goal_age, etc).
+ *
+ * Each cache must be registered so that it can be cleaned regularly.
+ * When the cache is unregistered, it is flushed completely.
+ *
+ * Entries have a ref count and a 'hashed' flag which counts the existance
+ * in the hash table.
+ * We only expire entries when refcount is zero.
+ * Existance in the cache is counted  the refcount.
+ */
+
+/* Every cache item has a common header that is used
+ * for expiring and refreshing entries.
+ * 
+ */
+struct cache_head {
+	struct cache_head * next;
+	time_t		expiry_time;	/* After time time, don't use the data */
+	time_t		last_refresh;   /* If CACHE_PENDING, this is when upcall 
+					 * was sent, else this is when update was received
+					 */
+	atomic_t 	refcnt;
+	unsigned long	flags;
+};
+#define	CACHE_VALID	0	/* Entry contains valid data */
+#define	CACHE_NEGATIVE	1	/* Negative entry - there is no match for the key */
+#define	CACHE_PENDING	2	/* An upcall has been sent but no reply received yet*/
+
+#define	CACHE_NEW_EXPIRY 120	/* keep new things pending confirmation for 120 seconds */
+
+struct cache_detail {
+	int			hash_size;
+	struct cache_head **	hash_table;
+	rwlock_t		hash_lock;
+
+	atomic_t		inuse; /* active user-space update or lookup */
+
+	char			*name;
+	void			(*cache_put)(struct cache_head *,
+					     struct cache_detail*);
+
+	void			(*cache_request)(struct cache_detail *cd,
+						 struct cache_head *h,
+						 char **bpp, int *blen);
+	int			(*cache_parse)(struct cache_detail *,
+					       char *buf, int len);
+
+	int			(*cache_show)(struct seq_file *m,
+					      struct cache_detail *cd,
+					      struct cache_head *h);
+
+	/* fields below this comment are for internal use
+	 * and should not be touched by cache owners
+	 */
+	time_t			flush_time;		/* flush all cache items with last_refresh
+							 * earlier than this */
+	struct list_head	others;
+	time_t			nextcheck;
+	int			entries;
+
+	/* fields for communication over channel */
+	struct list_head	queue;
+	struct proc_dir_entry	*proc_ent;
+	struct proc_dir_entry   *flush_ent, *channel_ent, *content_ent;
+
+	atomic_t		readers;		/* how many time is /chennel open */
+	time_t			last_close;		/* if no readers, when did last close */
+	time_t			last_warn;		/* when we last warned about no readers */
+	void			(*warn_no_listener)(struct cache_detail *cd);
+};
+
+
+/* this must be embedded in any request structure that
+ * identifies an object that will want a callback on
+ * a cache fill
+ */
+struct cache_req {
+	struct cache_deferred_req *(*defer)(struct cache_req *req);
+};
+/* this must be embedded in a deferred_request that is being
+ * delayed awaiting cache-fill
+ */
+struct cache_deferred_req {
+	struct list_head	hash;	/* on hash chain */
+	struct list_head	recent; /* on fifo */
+	struct cache_head	*item;  /* cache item we wait on */
+	time_t			recv_time;
+	void			*owner; /* we might need to discard all defered requests
+					 * owned by someone */
+	void			(*revisit)(struct cache_deferred_req *req,
+					   int too_many);
+};
+
+/*
+ * just like a template in C++, this macro does cache lookup
+ * for us.
+ * The function is passed some sort of HANDLE from which a cache_detail
+ * structure can be determined (via SETUP, DETAIL), a template
+ * cache entry (type RTN*), and a "set" flag.  Using the HASHFN and the 
+ * TEST, the function will try to find a matching cache entry in the cache.
+ * If "set" == 0 :
+ *    If an entry is found, it is returned
+ *    If no entry is found, a new non-VALID entry is created.
+ * If "set" == 1 and INPLACE == 0 :
+ *    If no entry is found a new one is inserted with data from "template"
+ *    If a non-CACHE_VALID entry is found, it is updated from template using UPDATE
+ *    If a CACHE_VALID entry is found, a new entry is swapped in with data
+ *       from "template"
+ * If set == 1, and INPLACE == 1 :
+ *    As above, except that if a CACHE_VALID entry is found, we UPDATE in place
+ *       instead of swapping in a new entry.
+ *
+ * If the passed handle has the CACHE_NEGATIVE flag set, then UPDATE is not
+ * run but insteead CACHE_NEGATIVE is set in any new item.
+
+ *  In any case, the new entry is returned with a reference count.
+ *
+ *    
+ * RTN is a struct type for a cache entry
+ * MEMBER is the member of the cache which is cache_head, which must be first
+ * FNAME is the name for the function	
+ * ARGS are arguments to function and must contain RTN *item, int set.  May
+ *   also contain something to be usedby SETUP or DETAIL to find cache_detail.
+ * SETUP  locates the cache detail and makes it available as...
+ * DETAIL identifies the cache detail, possibly set up by SETUP
+ * HASHFN returns a hash value of the cache entry "item"
+ * TEST  tests if "tmp" matches "item"
+ * INIT copies key information from "item" to "new"
+ * UPDATE copies content information from "item" to "tmp"
+ * INPLACE is true if updates can happen inplace rather than allocating a new structure
+ *
+ * WARNING: any substantial changes to this must be reflected in
+ *   net/sunrpc/svcauth.c(auth_domain_lookup)
+ *  which is a similar routine that is open-coded.
+ */
+#define DefineCacheLookup(RTN,MEMBER,FNAME,ARGS,SETUP,DETAIL,HASHFN,TEST,INIT,UPDATE,INPLACE)	\
+RTN *FNAME ARGS										\
+{											\
+	RTN *tmp, *new=NULL;								\
+	struct cache_head **hp, **head;							\
+	SETUP;										\
+	head = &(DETAIL)->hash_table[HASHFN];						\
+ retry:											\
+	if (set||new) write_lock(&(DETAIL)->hash_lock);					\
+	else read_lock(&(DETAIL)->hash_lock);						\
+	for(hp=head; *hp != NULL; hp = &tmp->MEMBER.next) {				\
+		tmp = container_of(*hp, RTN, MEMBER);					\
+		if (TEST) { /* found a match */						\
+											\
+			if (set && !INPLACE && test_bit(CACHE_VALID, &tmp->MEMBER.flags) && !new) \
+				break;							\
+											\
+			if (new)							\
+				{INIT;}							\
+			if (set) {							\
+				if (!INPLACE && test_bit(CACHE_VALID, &tmp->MEMBER.flags))\
+				{ /* need to swap in new */				\
+					RTN *t2;					\
+											\
+					new->MEMBER.next = tmp->MEMBER.next;		\
+					*hp = &new->MEMBER;				\
+					tmp->MEMBER.next = NULL;			\
+					t2 = tmp; tmp = new; new = t2;			\
+				}							\
+				if (test_bit(CACHE_NEGATIVE,  &item->MEMBER.flags))	\
+					set_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);	\
+				else {							\
+					UPDATE;						\
+					clear_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);	\
+				}							\
+			}								\
+			cache_get(&tmp->MEMBER);					\
+			if (set||new) write_unlock(&(DETAIL)->hash_lock);		\
+			else read_unlock(&(DETAIL)->hash_lock);				\
+			if (set)							\
+				cache_fresh(DETAIL, &tmp->MEMBER, item->MEMBER.expiry_time); \
+			if (set && !INPLACE && new) cache_fresh(DETAIL, &new->MEMBER, 0);	\
+			if (new) (DETAIL)->cache_put(&new->MEMBER, DETAIL);		\
+			return tmp;							\
+		}									\
+	}										\
+	/* Didn't find anything */							\
+	if (new) {									\
+		INIT;									\
+		new->MEMBER.next = *head;						\
+		*head = &new->MEMBER;							\
+		(DETAIL)->entries ++;							\
+		cache_get(&new->MEMBER);						\
+		if (set) {								\
+			tmp = new;							\
+			if (test_bit(CACHE_NEGATIVE, &item->MEMBER.flags))		\
+				set_bit(CACHE_NEGATIVE, &tmp->MEMBER.flags);		\
+			else {UPDATE;}							\
+		}									\
+	}										\
+	if (set||new) write_unlock(&(DETAIL)->hash_lock);				\
+	else read_unlock(&(DETAIL)->hash_lock);						\
+	if (new && set)									\
+		cache_fresh(DETAIL, &new->MEMBER, item->MEMBER.expiry_time);		\
+	if (new)				       					\
+		return new;								\
+	new = kmalloc(sizeof(*new), GFP_KERNEL);					\
+	if (new) {									\
+		cache_init(&new->MEMBER);						\
+		goto retry;								\
+	}										\
+	return NULL;									\
+}
+
+#define DefineSimpleCacheLookup(STRUCT,INPLACE)	\
+	DefineCacheLookup(struct STRUCT, h, STRUCT##_lookup, (struct STRUCT *item, int set), /*no setup */,	\
+			  & STRUCT##_cache, STRUCT##_hash(item), STRUCT##_match(item, tmp),\
+			  STRUCT##_init(new, item), STRUCT##_update(tmp, item),INPLACE)
+
+#define cache_for_each(pos, detail, index, member) 						\
+	for (({read_lock(&(detail)->hash_lock); index = (detail)->hash_size;}) ;		\
+	     ({if (index==0)read_unlock(&(detail)->hash_lock); index--;});			\
+		)										\
+		for (pos = container_of((detail)->hash_table[index], typeof(*pos), member);	\
+		     &pos->member;								\
+		     pos = container_of(pos->member.next, typeof(*pos), member))
+
+	     
+
+extern void cache_clean_deferred(void *owner);
+
+static inline struct cache_head  *cache_get(struct cache_head *h)
+{
+	atomic_inc(&h->refcnt);
+	return h;
+}
+
+
+static inline int cache_put(struct cache_head *h, struct cache_detail *cd)
+{
+	if (atomic_read(&h->refcnt) <= 2 &&
+	    h->expiry_time < cd->nextcheck)
+		cd->nextcheck = h->expiry_time;
+	return atomic_dec_and_test(&h->refcnt);
+}
+
+extern void cache_init(struct cache_head *h);
+extern void cache_fresh(struct cache_detail *detail,
+			struct cache_head *head, time_t expiry);
+extern int cache_check(struct cache_detail *detail,
+		       struct cache_head *h, struct cache_req *rqstp);
+extern void cache_flush(void);
+extern void cache_purge(struct cache_detail *detail);
+#define NEVER (0x7FFFFFFF)
+extern void cache_register(struct cache_detail *cd);
+extern int cache_unregister(struct cache_detail *cd);
+
+extern void qword_add(char **bpp, int *lp, char *str);
+extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);
+extern int qword_get(char **bpp, char *dest, int bufsize);
+
+static inline int get_int(char **bpp, int *anint)
+{
+	char buf[50];
+	char *ep;
+	int rv;
+	int len = qword_get(bpp, buf, 50);
+	if (len < 0) return -EINVAL;
+	if (len ==0) return -ENOENT;
+	rv = simple_strtol(buf, &ep, 0);
+	if (*ep) return -EINVAL;
+	*anint = rv;
+	return 0;
+}
+
+static inline time_t get_expiry(char **bpp)
+{
+	int rv;
+	if (get_int(bpp, &rv))
+		return 0;
+	if (rv < 0)
+		return 0;
+	return rv;
+}
+
+#endif /*  _LINUX_SUNRPC_CACHE_H_ */
