commit bdeeed098811b36d1f988521600a89a400830a4b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed May 9 11:04:48 2018 +1000

    nubus: Call bus_register unconditionally
    
    Loading a NuBus driver module on a non-NuBus machine triggers the
    BUG_ON(!drv->bus->p) in driver_register(), because bus_register() was
    not called, because it is conditional on MACH_IS_MAC.
    
    Fix the crash by calling bus_register() unconditionally. Call it from
    a postcore_initcall(), like other busses do.
    
    Hence, the bus type is available for device_register(), which happens
    in a subsys initcall, and for driver_register(), which happens in a
    device or module initcall.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reported-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Fixes: 7f86c765a6a2 ("nubus: Add support for the driver model")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 6e8200215321..eba50b057f6f 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -163,7 +163,7 @@ void nubus_seq_write_rsrc_mem(struct seq_file *m,
 unsigned char *nubus_dirptr(const struct nubus_dirent *nd);
 
 /* Declarations relating to driver model objects */
-int nubus_bus_register(void);
+int nubus_parent_device_register(void);
 int nubus_device_register(struct nubus_board *board);
 int nubus_driver_register(struct nubus_driver *ndrv);
 void nubus_driver_unregister(struct nubus_driver *ndrv);

commit 7f86c765a6a2bb837c45f11526176125ff50e21f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:14 2018 -0500

    nubus: Add support for the driver model
    
    This patch brings basic support for the Linux Driver Model to the
    NuBus subsystem.
    
    For flexibility, the matching of boards with drivers is left up to the
    drivers. This is also the approach taken by NetBSD. A board may have
    many functions, and drivers may have to consider many functional
    resources and board resources in order to match a device.
    
    This implementation does not bind drivers to resources (nor does it bind
    many drivers to the same board). Apple's NuBus declaration ROM design
    is flexible enough to allow that, but I don't see a need to support it
    as we don't use the "slot zero" resources (in the main logic board ROM).
    
    Eliminate the global nubus_boards linked list by rewriting the procfs
    board iterator around bus_for_each_dev(). Hence the nubus device refcount
    can be used to determine the lifespan of board objects.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 2cbc7a199bca..6e8200215321 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -10,6 +10,7 @@
 #ifndef LINUX_NUBUS_H
 #define LINUX_NUBUS_H
 
+#include <linux/device.h>
 #include <asm/nubus.h>
 #include <uapi/linux/nubus.h>
 
@@ -32,7 +33,7 @@ struct nubus_dirent {
 };
 
 struct nubus_board {
-	struct nubus_board *next;
+	struct device dev;
 
 	/* Only 9-E actually exist, though 0-8 are also theoretically
 	   possible, and 0 is a special case which represents the
@@ -81,8 +82,14 @@ struct nubus_rsrc {
 
 /* This is all NuBus functional resources (used to find devices later on) */
 extern struct list_head nubus_func_rsrcs;
-/* This is all NuBus cards */
-extern struct nubus_board *nubus_boards;
+
+struct nubus_driver {
+	struct device_driver driver;
+	int (*probe)(struct nubus_board *board);
+	int (*remove)(struct nubus_board *board);
+};
+
+extern struct bus_type nubus_bus_type;
 
 /* Generic NuBus interface functions, modelled after the PCI interface */
 #ifdef CONFIG_PROC_FS
@@ -119,6 +126,9 @@ struct nubus_rsrc *nubus_next_rsrc_or_null(struct nubus_rsrc *from);
 #define for_each_func_rsrc(f) \
 	for (f = nubus_first_rsrc_or_null(); f; f = nubus_next_rsrc_or_null(f))
 
+#define for_each_board_func_rsrc(b, f) \
+	for_each_func_rsrc(f) if (f->board != b) {} else
+
 /* These are somewhat more NuBus-specific.  They all return 0 for
    success and -1 for failure, as you'd expect. */
 
@@ -152,6 +162,23 @@ void nubus_seq_write_rsrc_mem(struct seq_file *m,
 			      unsigned int len);
 unsigned char *nubus_dirptr(const struct nubus_dirent *nd);
 
+/* Declarations relating to driver model objects */
+int nubus_bus_register(void);
+int nubus_device_register(struct nubus_board *board);
+int nubus_driver_register(struct nubus_driver *ndrv);
+void nubus_driver_unregister(struct nubus_driver *ndrv);
+int nubus_proc_show(struct seq_file *m, void *data);
+
+static inline void nubus_set_drvdata(struct nubus_board *board, void *data)
+{
+	dev_set_drvdata(&board->dev, data);
+}
+
+static inline void *nubus_get_drvdata(struct nubus_board *board)
+{
+	return dev_get_drvdata(&board->dev);
+}
+
 /* Returns a pointer to the "standard" slot space. */
 static inline void *nubus_slot_addr(int slot)
 {

commit 41b848160eabb22957652936b66ccafd95ab5ad8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Adopt standard linked list implementation
    
    This increases code re-use and improves readability.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 4a481610ad38..2cbc7a199bca 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -33,7 +33,6 @@ struct nubus_dirent {
 
 struct nubus_board {
 	struct nubus_board *next;
-	struct nubus_rsrc *first_func_rsrc;
 
 	/* Only 9-E actually exist, though 0-8 are also theoretically
 	   possible, and 0 is a special case which represents the
@@ -63,8 +62,7 @@ struct nubus_board {
 };
 
 struct nubus_rsrc {
-	/* Next link in list */
-	struct nubus_rsrc *next;
+	struct list_head list;
 
 	/* The functional resource ID */
 	unsigned char resid;
@@ -82,7 +80,7 @@ struct nubus_rsrc {
 };
 
 /* This is all NuBus functional resources (used to find devices later on) */
-extern struct nubus_rsrc *nubus_func_rsrcs;
+extern struct list_head nubus_func_rsrcs;
 /* This is all NuBus cards */
 extern struct nubus_board *nubus_boards;
 
@@ -115,12 +113,11 @@ static inline void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
 				       const struct nubus_dirent *ent) {}
 #endif
 
-struct nubus_rsrc *nubus_find_type(unsigned short category,
-				   unsigned short type,
-				   const struct nubus_rsrc *from);
+struct nubus_rsrc *nubus_first_rsrc_or_null(void);
+struct nubus_rsrc *nubus_next_rsrc_or_null(struct nubus_rsrc *from);
 
-struct nubus_rsrc *nubus_find_slot(unsigned int slot,
-				   const struct nubus_rsrc *from);
+#define for_each_func_rsrc(f) \
+	for (f = nubus_first_rsrc_or_null(); f; f = nubus_next_rsrc_or_null(f))
 
 /* These are somewhat more NuBus-specific.  They all return 0 for
    success and -1 for failure, as you'd expect. */

commit 189e19e8cbb49f5bf483e55bdbd1e56d3d6bcf75
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rename struct nubus_dev
    
    It is misleading to call a functional resource a "device". In adopting
    the Linux Driver Model, the struct device will be embedded in struct
    nubus_board. That will compound the terminlogy problem because drivers
    will bind with boards, not with functional resources. Avoid this by
    renaming struct nubus_dev as struct nubus_rsrc. "Functional resource"
    is the vendor's terminology so this helps avoid confusion.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 0a9e08e76606..4a481610ad38 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -33,7 +33,7 @@ struct nubus_dirent {
 
 struct nubus_board {
 	struct nubus_board *next;
-	struct nubus_dev *first_dev;
+	struct nubus_rsrc *first_func_rsrc;
 
 	/* Only 9-E actually exist, though 0-8 are also theoretically
 	   possible, and 0 is a special case which represents the
@@ -62,11 +62,11 @@ struct nubus_board {
 	struct proc_dir_entry *procdir;
 };
 
-struct nubus_dev {
-	/* Next link in device list */
-	struct nubus_dev *next;
+struct nubus_rsrc {
+	/* Next link in list */
+	struct nubus_rsrc *next;
 
-	/* The functional resource ID of this device */
+	/* The functional resource ID */
 	unsigned char resid;
 	/* These are mostly here for convenience; we could always read
 	   them from the ROMs if we wanted to */
@@ -81,8 +81,8 @@ struct nubus_dev {
 	struct nubus_board *board;
 };
 
-/* This is all NuBus devices (used to find devices later on) */
-extern struct nubus_dev *nubus_devices;
+/* This is all NuBus functional resources (used to find devices later on) */
+extern struct nubus_rsrc *nubus_func_rsrcs;
 /* This is all NuBus cards */
 extern struct nubus_board *nubus_boards;
 
@@ -115,13 +115,12 @@ static inline void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
 				       const struct nubus_dirent *ent) {}
 #endif
 
-/* If we need more precision we can add some more of these */
-struct nubus_dev *nubus_find_type(unsigned short category,
-				  unsigned short type,
-				  const struct nubus_dev *from);
-/* Might have more than one device in a slot, you know... */
-struct nubus_dev *nubus_find_slot(unsigned int slot,
-				  const struct nubus_dev *from);
+struct nubus_rsrc *nubus_find_type(unsigned short category,
+				   unsigned short type,
+				   const struct nubus_rsrc *from);
+
+struct nubus_rsrc *nubus_find_slot(unsigned int slot,
+				   const struct nubus_rsrc *from);
 
 /* These are somewhat more NuBus-specific.  They all return 0 for
    success and -1 for failure, as you'd expect. */
@@ -134,8 +133,7 @@ int nubus_get_root_dir(const struct nubus_board *board,
 int nubus_get_board_dir(const struct nubus_board *board,
 			struct nubus_dir *dir);
 /* The functional directory */
-int nubus_get_func_dir(const struct nubus_dev *dev,
-		       struct nubus_dir *dir);
+int nubus_get_func_dir(const struct nubus_rsrc *fres, struct nubus_dir *dir);
 
 /* These work on any directory gotten via the above */
 int nubus_readdir(struct nubus_dir *dir,

commit 2f7dd07ecadac6bdc3d55c217d65efa2834ba1cb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Rework /proc/bus/nubus/s/ implementation
    
    The /proc/bus/nubus/s/ directory tree for any slot s is missing a lot
    of information. The struct file_operations methods have long been left
    unimplemented (hence the familiar compile-time warning, "Need to set
    some I/O handlers here").
    
    Slot resources have a complex structure which varies depending on board
    function. The logic for interpreting these ROM data structures is found
    in nubus.c. Let's not duplicate that logic in proc.c.
    
    Create the /proc/bus/nubus/s/ inodes while scanning slot s. During
    descent through slot resource subdirectories, call the new
    nubus_proc_add_foo() functions to create the procfs inodes.
    
    Also add a new function, nubus_seq_write_rsrc_mem(), to write the
    contents of a particular slot resource to a given seq_file. This is
    used by the procfs file_operations methods, to finally give userspace
    access to slot ROM information, such as the available video modes.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 2d6f04055ebe..0a9e08e76606 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -13,11 +13,15 @@
 #include <asm/nubus.h>
 #include <uapi/linux/nubus.h>
 
+struct proc_dir_entry;
+struct seq_file;
+
 struct nubus_dir {
 	unsigned char *base;
 	unsigned char *ptr;
 	int done;
 	int mask;
+	struct proc_dir_entry *procdir;
 };
 
 struct nubus_dirent {
@@ -84,12 +88,33 @@ extern struct nubus_board *nubus_boards;
 
 /* Generic NuBus interface functions, modelled after the PCI interface */
 #ifdef CONFIG_PROC_FS
-extern void nubus_proc_init(void);
+void nubus_proc_init(void);
+struct proc_dir_entry *nubus_proc_add_board(struct nubus_board *board);
+struct proc_dir_entry *nubus_proc_add_rsrc_dir(struct proc_dir_entry *procdir,
+					       const struct nubus_dirent *ent,
+					       struct nubus_board *board);
+void nubus_proc_add_rsrc_mem(struct proc_dir_entry *procdir,
+			     const struct nubus_dirent *ent,
+			     unsigned int size);
+void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
+			 const struct nubus_dirent *ent);
 #else
 static inline void nubus_proc_init(void) {}
+static inline
+struct proc_dir_entry *nubus_proc_add_board(struct nubus_board *board)
+{ return NULL; }
+static inline
+struct proc_dir_entry *nubus_proc_add_rsrc_dir(struct proc_dir_entry *procdir,
+					       const struct nubus_dirent *ent,
+					       struct nubus_board *board)
+{ return NULL; }
+static inline void nubus_proc_add_rsrc_mem(struct proc_dir_entry *procdir,
+					   const struct nubus_dirent *ent,
+					   unsigned int size) {}
+static inline void nubus_proc_add_rsrc(struct proc_dir_entry *procdir,
+				       const struct nubus_dirent *ent) {}
 #endif
 
-int nubus_proc_attach_device(struct nubus_dev *dev);
 /* If we need more precision we can add some more of these */
 struct nubus_dev *nubus_find_type(unsigned short category,
 				  unsigned short type,
@@ -125,8 +150,12 @@ int nubus_get_subdir(const struct nubus_dirent *ent,
 		     struct nubus_dir *dir);
 void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 			unsigned int len);
-void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
-			unsigned int maxlen);
+unsigned int nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
+				unsigned int len);
+void nubus_seq_write_rsrc_mem(struct seq_file *m,
+			      const struct nubus_dirent *dirent,
+			      unsigned int len);
+unsigned char *nubus_dirptr(const struct nubus_dirent *nd);
 
 /* Returns a pointer to the "standard" slot space. */
 static inline void *nubus_slot_addr(int slot)

commit 4bccc4b629de3af24308a24c41aff6270a6404aa
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Clean up whitespace
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 3c7b236074b3..2d6f04055ebe 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -28,9 +28,9 @@ struct nubus_dirent {
 };
 
 struct nubus_board {
-	struct nubus_board* next;
-	struct nubus_dev* first_dev;
-	
+	struct nubus_board *next;
+	struct nubus_dev *first_dev;
+
 	/* Only 9-E actually exist, though 0-8 are also theoretically
 	   possible, and 0 is a special case which represents the
 	   motherboard and onboard peripherals (Ethernet, video) */
@@ -39,10 +39,10 @@ struct nubus_board {
 	char name[64];
 
 	/* Format block */
-	unsigned char* fblock;
+	unsigned char *fblock;
 	/* Root directory (does *not* always equal fblock + doffset!) */
-	unsigned char* directory;
-	
+	unsigned char *directory;
+
 	unsigned long slot_addr;
 	/* Offset to root directory (sometimes) */
 	unsigned long doffset;
@@ -60,7 +60,7 @@ struct nubus_board {
 
 struct nubus_dev {
 	/* Next link in device list */
-	struct nubus_dev* next;
+	struct nubus_dev *next;
 
 	/* The functional resource ID of this device */
 	unsigned char resid;
@@ -70,17 +70,17 @@ struct nubus_dev {
 	unsigned short type;
 	unsigned short dr_sw;
 	unsigned short dr_hw;
-	
+
 	/* Functional directory */
-	unsigned char* directory;
+	unsigned char *directory;
 	/* Much of our info comes from here */
-	struct nubus_board* board;
+	struct nubus_board *board;
 };
 
 /* This is all NuBus devices (used to find devices later on) */
-extern struct nubus_dev* nubus_devices;
+extern struct nubus_dev *nubus_devices;
 /* This is all NuBus cards */
-extern struct nubus_board* nubus_boards;
+extern struct nubus_board *nubus_boards;
 
 /* Generic NuBus interface functions, modelled after the PCI interface */
 #ifdef CONFIG_PROC_FS
@@ -91,38 +91,38 @@ static inline void nubus_proc_init(void) {}
 
 int nubus_proc_attach_device(struct nubus_dev *dev);
 /* If we need more precision we can add some more of these */
-struct nubus_dev* nubus_find_type(unsigned short category,
+struct nubus_dev *nubus_find_type(unsigned short category,
 				  unsigned short type,
-				  const struct nubus_dev* from);
+				  const struct nubus_dev *from);
 /* Might have more than one device in a slot, you know... */
-struct nubus_dev* nubus_find_slot(unsigned int slot,
-				  const struct nubus_dev* from);
+struct nubus_dev *nubus_find_slot(unsigned int slot,
+				  const struct nubus_dev *from);
 
 /* These are somewhat more NuBus-specific.  They all return 0 for
    success and -1 for failure, as you'd expect. */
 
 /* The root directory which contains the board and functional
    directories */
-int nubus_get_root_dir(const struct nubus_board* board,
-		       struct nubus_dir* dir);
+int nubus_get_root_dir(const struct nubus_board *board,
+		       struct nubus_dir *dir);
 /* The board directory */
-int nubus_get_board_dir(const struct nubus_board* board,
-			struct nubus_dir* dir);
+int nubus_get_board_dir(const struct nubus_board *board,
+			struct nubus_dir *dir);
 /* The functional directory */
-int nubus_get_func_dir(const struct nubus_dev* dev,
-		       struct nubus_dir* dir);
+int nubus_get_func_dir(const struct nubus_dev *dev,
+		       struct nubus_dir *dir);
 
 /* These work on any directory gotten via the above */
-int nubus_readdir(struct nubus_dir* dir,
-		  struct nubus_dirent* ent);
-int nubus_find_rsrc(struct nubus_dir* dir,
+int nubus_readdir(struct nubus_dir *dir,
+		  struct nubus_dirent *ent);
+int nubus_find_rsrc(struct nubus_dir *dir,
 		    unsigned char rsrc_type,
-		    struct nubus_dirent* ent);
-int nubus_rewinddir(struct nubus_dir* dir);
+		    struct nubus_dirent *ent);
+int nubus_rewinddir(struct nubus_dir *dir);
 
 /* Things to do with directory entries */
-int nubus_get_subdir(const struct nubus_dirent* ent,
-		     struct nubus_dir* dir);
+int nubus_get_subdir(const struct nubus_dirent *ent,
+		     struct nubus_dir *dir);
 void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 			unsigned int len);
 void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,

commit 9f97977deb22e602f91047a105b961ffb36adc2b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Remove redundant code
    
    Eliminate unused values from struct nubus_dev to save wasted memory
    (a Radius PrecisionColor 24X card has about 95 functional resources
    and up to six such cards may be fitted). Also remove redundant static
    variable initialization, an unreachable !MACH_IS_MAC conditional,
    the unused nubus_find_device() function, the bogus get_nubus_list()
    prototype and the pointless card_present temporary variable.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 2245430e1357..3c7b236074b3 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -70,16 +70,6 @@ struct nubus_dev {
 	unsigned short type;
 	unsigned short dr_sw;
 	unsigned short dr_hw;
-	/* This is the device's name rather than the board's.
-	   Sometimes they are different.  Usually the board name is
-	   more correct. */
-	char name[64];
-	/* MacOS driver (I kid you not) */
-	unsigned char* driver;
-	/* Actually this is an offset */
-	unsigned long iobase;
-	unsigned long iosize;
-	unsigned char flags, hwdevid;
 	
 	/* Functional directory */
 	unsigned char* directory;
@@ -98,14 +88,9 @@ extern void nubus_proc_init(void);
 #else
 static inline void nubus_proc_init(void) {}
 #endif
-int get_nubus_list(char *buf);
+
 int nubus_proc_attach_device(struct nubus_dev *dev);
 /* If we need more precision we can add some more of these */
-struct nubus_dev* nubus_find_device(unsigned short category,
-				    unsigned short type,
-				    unsigned short dr_hw,
-				    unsigned short dr_sw,
-				    const struct nubus_dev* from);
 struct nubus_dev* nubus_find_type(unsigned short category,
 				  unsigned short type,
 				  const struct nubus_dev* from);

commit 6c8b89ea55c9d53979e2be7977e945edba100359
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Call proc_mkdir() not more than once per slot directory
    
    This patch fixes the following WARNING.
    
    proc_dir_entry 'nubus/a' already registered
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Tainted: G        W       4.13.0-00036-gd57552077387 #1
    Stack from 01c1bd9c:
            01c1bd9c 003c2c8b 01c1bdc0 0001b0fe 00000000 00322f4a 01c43a20 01c43b0c
            01c8c420 01c1bde8 0001b1b8 003a4ac3 00000148 000faa26 00000009 00000000
            01c1bde0 003a4b6c 01c1bdfc 01c1be20 000faa26 003a4ac3 00000148 003a4b6c
            01c43a71 01c8c471 01c10000 00326430 0043d00c 00000005 01c71a00 0020bce0
            00322964 01c1be38 000fac04 01c43a20 01c8c420 01c1bee0 01c8c420 01c1be50
            000fac4c 01c1bee0 00000000 01c43a20 00000000 01c1bee8 0020bd26 01c1bee0
    Call Trace: [<0001b0fe>] __warn+0xae/0xde
     [<00322f4a>] memcmp+0x0/0x5c
     [<0001b1b8>] warn_slowpath_fmt+0x2e/0x36
     [<000faa26>] proc_register+0xbe/0xd8
     [<000faa26>] proc_register+0xbe/0xd8
     [<00326430>] sprintf+0x0/0x20
     [<0020bce0>] nubus_proc_attach_device+0x0/0x1b8
     [<00322964>] strcpy+0x0/0x22
     [<000fac04>] proc_mkdir_data+0x64/0x96
     [<000fac4c>] proc_mkdir+0x16/0x1c
     [<0020bd26>] nubus_proc_attach_device+0x46/0x1b8
     [<0020bce0>] nubus_proc_attach_device+0x0/0x1b8
     [<00322964>] strcpy+0x0/0x22
     [<00001ba6>] kernel_pg_dir+0xba6/0x1000
     [<004339a2>] proc_bus_nubus_add_devices+0x1a/0x2e
     [<000faa40>] proc_create_data+0x0/0xf2
     [<0003297c>] parse_args+0x0/0x2d4
     [<00433a08>] nubus_proc_init+0x52/0x5a
     [<00433944>] nubus_init+0x0/0x44
     [<00433982>] nubus_init+0x3e/0x44
     [<000020dc>] do_one_initcall+0x38/0x196
     [<000020a4>] do_one_initcall+0x0/0x196
     [<0003297c>] parse_args+0x0/0x2d4
     [<00322964>] strcpy+0x0/0x22
     [<00040004>] __up_read+0xe/0x40
     [<004231d4>] repair_env_string+0x0/0x7a
     [<0042312e>] kernel_init_freeable+0xee/0x194
     [<00423146>] kernel_init_freeable+0x106/0x194
     [<00433944>] nubus_init+0x0/0x44
     [<000a6000>] kfree+0x0/0x156
     [<0032768c>] kernel_init+0x0/0xda
     [<00327698>] kernel_init+0xc/0xda
     [<0032768c>] kernel_init+0x0/0xda
     [<00002a90>] ret_from_kernel_thread+0xc/0x14
    ---[ end trace 14a6d619908ea253 ]---
    ------------[ cut here ]------------
    
    This gets repeated with each additional functional reasource.
    
    The problem here is the call to proc_mkdir() when the directory already
    exists. Each nubus_board gets a directory, such as /proc/bus/nubus/s/
    where s is the hex slot number. Therefore, store the 'procdir' pointer
    in struct nubus_board instead of struct nubus_dev.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index e525669f1991..2245430e1357 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -53,13 +53,14 @@ struct nubus_board {
 	unsigned char rev;
 	unsigned char format;
 	unsigned char lanes;
+
+	/* Directory entry in /proc/bus/nubus */
+	struct proc_dir_entry *procdir;
 };
 
 struct nubus_dev {
 	/* Next link in device list */
 	struct nubus_dev* next;
-	/* Directory entry in /proc/bus/nubus */
-	struct proc_dir_entry* procdir;
 
 	/* The functional resource ID of this device */
 	unsigned char resid;

commit 460cf95e8b6cda2823a6432253ae91d3e1e7a021
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Use static functions where possible
    
    This fixes a couple of warnings from 'make W=1':
    drivers/nubus/nubus.c:790: warning: no previous prototype for 'nubus_probe_slot'
    drivers/nubus/nubus.c:824: warning: no previous prototype for 'nubus_scan_bus'
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 55b9a4569a69..e525669f1991 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -92,7 +92,6 @@ extern struct nubus_dev* nubus_devices;
 extern struct nubus_board* nubus_boards;
 
 /* Generic NuBus interface functions, modelled after the PCI interface */
-void nubus_scan_bus(void);
 #ifdef CONFIG_PROC_FS
 extern void nubus_proc_init(void);
 #else

commit 1ff2775a32ef105d9bdbb5f00f20293244a2accc
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Fix up header split
    
    Due to the '#ifdef __KERNEL__' being located in the wrong place, some
    definitions from the kernel API were placed in the UAPI header during
    the scripted header split. Fix this. Also, remove the duplicate comment
    which is only relevant to the UAPI header.
    
    Fixes: 607ca46e97a1 ("UAPI: (Scripted) Disintegrate include/linux")
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index d8d63370a28c..55b9a4569a69 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -5,16 +5,28 @@
   Originally written by Alan Cox.
 
   Hacked to death by C. Scott Ananian and David Huggins-Daines.
-  
-  Some of the constants in here are from the corresponding
-  NetBSD/OpenBSD header file, by Allen Briggs.  We figured out the
-  rest of them on our own. */
+*/
+
 #ifndef LINUX_NUBUS_H
 #define LINUX_NUBUS_H
 
 #include <asm/nubus.h>
 #include <uapi/linux/nubus.h>
 
+struct nubus_dir {
+	unsigned char *base;
+	unsigned char *ptr;
+	int done;
+	int mask;
+};
+
+struct nubus_dirent {
+	unsigned char *base;
+	unsigned char type;
+	__u32 data;	/* Actually 24 bits used */
+	int mask;
+};
+
 struct nubus_board {
 	struct nubus_board* next;
 	struct nubus_dev* first_dev;
@@ -130,4 +142,11 @@ void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
 			unsigned int len);
 void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
 			unsigned int maxlen);
+
+/* Returns a pointer to the "standard" slot space. */
+static inline void *nubus_slot_addr(int slot)
+{
+	return (void *)(0xF0000000 | (slot << 24));
+}
+
 #endif /* LINUX_NUBUS_H */

commit 2f828fb21df42058084b16d5e07cecdc30dbc3a5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Jan 13 17:37:13 2018 -0500

    nubus: Avoid array underflow and overflow
    
    Check array indices. Avoid sprintf. Use buffers of sufficient size.
    Use appropriate types for array length parameters.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 11ce6b1117a8..d8d63370a28c 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -126,10 +126,8 @@ int nubus_rewinddir(struct nubus_dir* dir);
 /* Things to do with directory entries */
 int nubus_get_subdir(const struct nubus_dirent* ent,
 		     struct nubus_dir* dir);
-void nubus_get_rsrc_mem(void* dest,
-			const struct nubus_dirent *dirent,
-			int len);
-void nubus_get_rsrc_str(void* dest,
-			const struct nubus_dirent *dirent,
-			int maxlen);
+void nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,
+			unsigned int len);
+void nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,
+			unsigned int maxlen);
 #endif /* LINUX_NUBUS_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 6165b2c62040..11ce6b1117a8 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
   nubus.h: various definitions and prototypes for NuBus drivers to use.
 

commit e765acb4673f377c53505c01279c040906bd706e
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri May 3 22:20:38 2013 +0200

    nubus: Kill nubus_proc_detach_device()
    
    Commit 59d8053f1e16904d54ed7469d4b36801ea6b8f2c ("proc: Move non-public
    stuff from linux/proc_fs.h to fs/proc/internal.h") broke Apple NuBus
    support:
    
    drivers/nubus/proc.c: In function ‘nubus_proc_detach_device’:
    drivers/nubus/proc.c:156: error: dereferencing pointer to incomplete type
    drivers/nubus/proc.c:158: error: dereferencing pointer to incomplete type
    
    Fortunately nubus_proc_detach_device() is unused, and appears to have never
    been used, so just remove it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index b3740527571a..6165b2c62040 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -87,7 +87,6 @@ static inline void nubus_proc_init(void) {}
 #endif
 int get_nubus_list(char *buf);
 int nubus_proc_attach_device(struct nubus_dev *dev);
-int nubus_proc_detach_device(struct nubus_dev *dev);
 /* If we need more precision we can add some more of these */
 struct nubus_dev* nubus_find_device(unsigned short category,
 				    unsigned short type,

commit 11db656ad462c9aa7aff7e3817214578cfc307b3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 10 15:05:38 2013 +0100

    nubus: Don't use create_proc_read_entry()
    
    Don't use create_proc_read_entry() as that is deprecated, but rather use
    proc_create_data() and seq_file instead.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-m68k@lists.linux-m68k.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index a8696bbdfbc4..b3740527571a 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -80,7 +80,11 @@ extern struct nubus_board* nubus_boards;
 
 /* Generic NuBus interface functions, modelled after the PCI interface */
 void nubus_scan_bus(void);
+#ifdef CONFIG_PROC_FS
 extern void nubus_proc_init(void);
+#else
+static inline void nubus_proc_init(void) {}
+#endif
 int get_nubus_list(char *buf);
 int nubus_proc_attach_device(struct nubus_dev *dev);
 int nubus_proc_detach_device(struct nubus_dev *dev);

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index e137b3c486a7..a8696bbdfbc4 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -8,236 +8,12 @@
   Some of the constants in here are from the corresponding
   NetBSD/OpenBSD header file, by Allen Briggs.  We figured out the
   rest of them on our own. */
-
 #ifndef LINUX_NUBUS_H
 #define LINUX_NUBUS_H
 
-#include <linux/types.h>
-#ifdef __KERNEL__
 #include <asm/nubus.h>
-#endif
-
-enum nubus_category {
-	NUBUS_CAT_BOARD          = 0x0001,
-	NUBUS_CAT_DISPLAY        = 0x0003,
-	NUBUS_CAT_NETWORK        = 0x0004,
-	NUBUS_CAT_COMMUNICATIONS = 0x0006,
-	NUBUS_CAT_FONT           = 0x0009,
-	NUBUS_CAT_CPU            = 0x000A,
-	/* For lack of a better name */
-	NUBUS_CAT_DUODOCK        = 0x0020
-};
-
-enum nubus_type_network {
-	NUBUS_TYPE_ETHERNET      = 0x0001,
-	NUBUS_TYPE_RS232         = 0x0002
-};
-
-enum nubus_type_display {
-	NUBUS_TYPE_VIDEO         = 0x0001
-};
-
-enum nubus_type_cpu {
-	NUBUS_TYPE_68020         = 0x0003,
-	NUBUS_TYPE_68030         = 0x0004,
-	NUBUS_TYPE_68040         = 0x0005
-};
-
-/* Known <Cat,Type,SW,HW> tuples: (according to TattleTech and Slots)
- *  68030 motherboards: <10,4,0,24>
- *  68040 motherboards: <10,5,0,24>
- *  DuoDock Plus: <32,1,1,2>
- *
- *  Toby Frame Buffer card: <3,1,1,1>
- *  RBV built-in video (IIci): <3,1,1,24>
- *  Valkyrie built-in video (Q630): <3,1,1,46>
- *  Macintosh Display Card: <3,1,1,25>
- *  Sonora built-in video (P460): <3,1,1,34>
- *  Jet framebuffer (DuoDock Plus): <3,1,1,41>
- *
- *  SONIC comm-slot/on-board and DuoDock Ethernet: <4,1,1,272>
- *  SONIC LC-PDS Ethernet (Dayna, but like Apple 16-bit, sort of): <4,1,1,271>
- *  Apple SONIC LC-PDS Ethernet ("Apple Ethernet LC Twisted-Pair Card"): <4,1,0,281>
- *  Sonic Systems Ethernet A-Series Card: <4,1,268,256>
- *  Asante MacCon NuBus-A: <4,1,260,256> (alpha-1.0,1.1 revision)
- *   ROM on the above card: <2,1,0,0>
- *  Cabletron ethernet card: <4,1,1,265>
- *  Farallon ethernet card: <4,1,268,256> (identical to Sonic Systems card)
- *  Kinetics EtherPort IIN: <4,1,259,262>
- *  API Engineering EtherRun_LCa PDS enet card: <4,1,282,256>
- *
- *  Add your devices to the list!  You can obtain the "Slots" utility
- *  from Apple's FTP site at:
- *  ftp://dev.apple.com/devworld/Tool_Chest/Devices_-_Hardware/NuBus_Slot_Manager/
- *
- *  Alternately, TattleTech can be found at any Info-Mac mirror site.  
- *  or from its distribution site: ftp://ftp.decismkr.com/dms
- */
-
-/* DrSW: Uniquely identifies the software interface to a board.  This
-   is usually the one you want to look at when writing a driver.  It's
-   not as useful as you think, though, because as we should know by
-   now (duh), "Apple Compatible" can mean a lot of things... */
-
-/* Add known DrSW values here */
-enum nubus_drsw {
-	/* NUBUS_CAT_DISPLAY */
-	NUBUS_DRSW_APPLE        = 0x0001,
-	NUBUS_DRSW_APPLE_HIRES  = 0x0013, /* MacII HiRes card driver */
-	
-	/* NUBUS_CAT_NETWORK */
-	NUBUS_DRSW_3COM         = 0x0000,
-	NUBUS_DRSW_CABLETRON    = 0x0001,
-	NUBUS_DRSW_SONIC_LC     = 0x0001,
-	NUBUS_DRSW_KINETICS     = 0x0103,
-	NUBUS_DRSW_ASANTE       = 0x0104,
-	NUBUS_DRSW_TECHWORKS    = 0x0109,
-	NUBUS_DRSW_DAYNA        = 0x010b,
-	NUBUS_DRSW_FARALLON     = 0x010c,
-	NUBUS_DRSW_APPLE_SN     = 0x010f,
-	NUBUS_DRSW_DAYNA2       = 0x0115,
-	NUBUS_DRSW_FOCUS        = 0x011a,
-	NUBUS_DRSW_ASANTE_CS    = 0x011d, /* use asante SMC9194 driver */
-	NUBUS_DRSW_DAYNA_LC     = 0x011e,
-
-	/* NUBUS_CAT_CPU */
-	NUBUS_DRSW_NONE         = 0x0000,
-};
-
-/* DrHW: Uniquely identifies the hardware interface to a board (or at
-   least, it should...  some video cards are known to incorrectly
-   identify themselves as Toby cards) */
-
-/* Add known DrHW values here */
-enum nubus_drhw {
-	/* NUBUS_CAT_DISPLAY */
-	NUBUS_DRHW_APPLE_TFB      = 0x0001, /* Toby frame buffer card */
-	NUBUS_DRHW_APPLE_WVC      = 0x0006, /* Apple Workstation Video Card */
-	NUBUS_DRHW_SIGMA_CLRMAX   = 0x0007, /* Sigma Design ColorMax */
-	NUBUS_DRHW_APPLE_SE30     = 0x0009, /* Apple SE/30 video */
-	NUBUS_DRHW_APPLE_HRVC     = 0x0013, /* Mac II High-Res Video Card */
-	NUBUS_DRHW_APPLE_PVC      = 0x0017, /* Mac II Portrait Video Card */
-	NUBUS_DRHW_APPLE_RBV1     = 0x0018, /* IIci RBV video */
-	NUBUS_DRHW_APPLE_MDC      = 0x0019, /* Macintosh Display Card */
-	NUBUS_DRHW_APPLE_SONORA   = 0x0022, /* Sonora built-in video */
-	NUBUS_DRHW_APPLE_24AC     = 0x002b, /* Mac 24AC Video Card */
-	NUBUS_DRHW_APPLE_VALKYRIE = 0x002e,
-	NUBUS_DRHW_APPLE_JET      = 0x0029, /* Jet framebuffer (DuoDock) */
-	NUBUS_DRHW_SMAC_GFX       = 0x0105, /* SuperMac GFX */
-	NUBUS_DRHW_RASTER_CB264   = 0x013B, /* RasterOps ColorBoard 264 */
-	NUBUS_DRHW_MICRON_XCEED   = 0x0146, /* Micron Exceed color */
-	NUBUS_DRHW_RDIUS_GSC      = 0x0153, /* Radius GS/C */
-	NUBUS_DRHW_SMAC_SPEC8     = 0x017B, /* SuperMac Spectrum/8 */
-	NUBUS_DRHW_SMAC_SPEC24    = 0x017C, /* SuperMac Spectrum/24 */
-	NUBUS_DRHW_RASTER_CB364   = 0x026F, /* RasterOps ColorBoard 364 */
-	NUBUS_DRHW_RDIUS_DCGX     = 0x027C, /* Radius DirectColor/GX */
-	NUBUS_DRHW_RDIUS_PC8      = 0x0291, /* Radius PrecisionColor 8 */
-	NUBUS_DRHW_LAPIS_PCS8     = 0x0292, /* Lapis ProColorServer 8 */
-	NUBUS_DRHW_RASTER_24XLI   = 0x02A0, /* RasterOps 8/24 XLi */
-	NUBUS_DRHW_RASTER_PBPGT   = 0x02A5, /* RasterOps PaintBoard Prism GT */
-	NUBUS_DRHW_EMACH_FSX      = 0x02AE, /* E-Machines Futura SX */
-	NUBUS_DRHW_RASTER_24XLTV  = 0x02B7, /* RasterOps 24XLTV */
-	NUBUS_DRHW_SMAC_THUND24   = 0x02CB, /* SuperMac Thunder/24 */
-	NUBUS_DRHW_SMAC_THUNDLGHT = 0x03D9, /* SuperMac ThunderLight */
-	NUBUS_DRHW_RDIUS_PC24XP   = 0x0406, /* Radius PrecisionColor 24Xp */
-	NUBUS_DRHW_RDIUS_PC24X    = 0x040A, /* Radius PrecisionColor 24X */
-	NUBUS_DRHW_RDIUS_PC8XJ    = 0x040B, /* Radius PrecisionColor 8XJ */
-	
-	/* NUBUS_CAT_NETWORK */
-	NUBUS_DRHW_INTERLAN       = 0x0100,
-	NUBUS_DRHW_SMC9194        = 0x0101,
-	NUBUS_DRHW_KINETICS       = 0x0106,
-	NUBUS_DRHW_CABLETRON      = 0x0109,
-	NUBUS_DRHW_ASANTE_LC      = 0x010f,
-	NUBUS_DRHW_SONIC          = 0x0110,
-	NUBUS_DRHW_TECHWORKS      = 0x0112,
-	NUBUS_DRHW_APPLE_SONIC_NB = 0x0118,
-	NUBUS_DRHW_APPLE_SONIC_LC = 0x0119,
-	NUBUS_DRHW_FOCUS          = 0x011c,
-	NUBUS_DRHW_SONNET         = 0x011d,
-};
+#include <uapi/linux/nubus.h>
 
-/* Resource IDs: These are the identifiers for the various weird and
-   wonderful tidbits of information that may or may not reside in the
-   NuBus ROM directory. */
-enum nubus_res_id {
-	NUBUS_RESID_TYPE         = 0x0001,
-	NUBUS_RESID_NAME         = 0x0002,
-	NUBUS_RESID_ICON         = 0x0003,
-	NUBUS_RESID_DRVRDIR      = 0x0004,
-	NUBUS_RESID_LOADREC      = 0x0005,
-	NUBUS_RESID_BOOTREC      = 0x0006,
-	NUBUS_RESID_FLAGS        = 0x0007,
-	NUBUS_RESID_HWDEVID      = 0x0008,
-	NUBUS_RESID_MINOR_BASEOS = 0x000a,
-	NUBUS_RESID_MINOR_LENGTH = 0x000b,
-	NUBUS_RESID_MAJOR_BASEOS = 0x000c,
-	NUBUS_RESID_MAJOR_LENGTH = 0x000d,
-	NUBUS_RESID_CICN         = 0x000f,
-	NUBUS_RESID_ICL8         = 0x0010,
-	NUBUS_RESID_ICL4         = 0x0011,
-};
-
-/* Category-specific resources. */
-enum nubus_board_res_id {
-	NUBUS_RESID_BOARDID      = 0x0020,
-	NUBUS_RESID_PRAMINITDATA = 0x0021,
-	NUBUS_RESID_PRIMARYINIT  = 0x0022,
-	NUBUS_RESID_TIMEOUTCONST = 0x0023,
-	NUBUS_RESID_VENDORINFO   = 0x0024,
-	NUBUS_RESID_BOARDFLAGS   = 0x0025,
-	NUBUS_RESID_SECONDINIT   = 0x0026,
-
-	/* Not sure why Apple put these next two in here */
-	NUBUS_RESID_VIDNAMES     = 0x0041,
-	NUBUS_RESID_VIDMODES     = 0x007e
-};
-
-/* Fields within the vendor info directory */
-enum nubus_vendor_res_id {
-	NUBUS_RESID_VEND_ID     = 0x0001,
-	NUBUS_RESID_VEND_SERIAL = 0x0002,
-	NUBUS_RESID_VEND_REV    = 0x0003,
-	NUBUS_RESID_VEND_PART   = 0x0004,
-	NUBUS_RESID_VEND_DATE   = 0x0005
-};
-
-enum nubus_net_res_id {
-	NUBUS_RESID_MAC_ADDRESS  = 0x0080
-};
-
-enum nubus_cpu_res_id {
-	NUBUS_RESID_MEMINFO      = 0x0081,
-	NUBUS_RESID_ROMINFO      = 0x0082
-};
-
-enum nubus_display_res_id {
-	NUBUS_RESID_GAMMADIR    = 0x0040,
-	NUBUS_RESID_FIRSTMODE   = 0x0080,
-	NUBUS_RESID_SECONDMODE  = 0x0081,
-	NUBUS_RESID_THIRDMODE   = 0x0082,
-	NUBUS_RESID_FOURTHMODE  = 0x0083,
-	NUBUS_RESID_FIFTHMODE   = 0x0084,
-	NUBUS_RESID_SIXTHMODE   = 0x0085
-};
-
-struct nubus_dir
-{
-	unsigned char *base;
-	unsigned char *ptr;
-	int done;
-	int mask;
-};
-
-struct nubus_dirent
-{
-	unsigned char *base;
-	unsigned char type;
-	__u32 data;	/* Actually 24bits used */
-	int mask;
-};
-
-#ifdef __KERNEL__
 struct nubus_board {
 	struct nubus_board* next;
 	struct nubus_dev* first_dev;
@@ -352,12 +128,4 @@ void nubus_get_rsrc_mem(void* dest,
 void nubus_get_rsrc_str(void* dest,
 			const struct nubus_dirent *dirent,
 			int maxlen);
-#endif /* __KERNEL__ */
-
-/* We'd like to get rid of this eventually.  Only daynaport.c uses it now. */
-static inline void *nubus_slot_addr(int slot)
-{
-	return (void *)(0xF0000000|(slot<<24));
-}
-
 #endif /* LINUX_NUBUS_H */

commit 5007b1fc4ef2c1b496536b2f026353c1d44d92ef
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Tue Feb 3 19:28:24 2009 +0530

    headers_check fix cleanup: linux/nubus.h
    
    These are only for kernel internals as pointed by Arnd Bergmann:
       struct nubus_board
       struct nubus_dev
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 9be57d992695..e137b3c486a7 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -237,6 +237,7 @@ struct nubus_dirent
 	int mask;
 };
 
+#ifdef __KERNEL__
 struct nubus_board {
 	struct nubus_board* next;
 	struct nubus_dev* first_dev;
@@ -296,7 +297,6 @@ struct nubus_dev {
 	struct nubus_board* board;
 };
 
-#ifdef __KERNEL__
 /* This is all NuBus devices (used to find devices later on) */
 extern struct nubus_dev* nubus_devices;
 /* This is all NuBus cards */

commit 9fe03bc3139503fbad66016bf714f4575babf651
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Mon Feb 2 21:41:41 2009 +0530

    headers_check fix: linux/nubus.h
    
    fix the following 'make headers_check' warnings:
    
      usr/include/linux/nubus.h:297: extern's make no sense in userspace
      usr/include/linux/nubus.h:299: extern's make no sense in userspace
      usr/include/linux/nubus.h:303: extern's make no sense in userspace
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 7382af374731..9be57d992695 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -296,6 +296,7 @@ struct nubus_dev {
 	struct nubus_board* board;
 };
 
+#ifdef __KERNEL__
 /* This is all NuBus devices (used to find devices later on) */
 extern struct nubus_dev* nubus_devices;
 /* This is all NuBus cards */
@@ -351,6 +352,7 @@ void nubus_get_rsrc_mem(void* dest,
 void nubus_get_rsrc_str(void* dest,
 			const struct nubus_dirent *dirent,
 			int maxlen);
+#endif /* __KERNEL__ */
 
 /* We'd like to get rid of this eventually.  Only daynaport.c uses it now. */
 static inline void *nubus_slot_addr(int slot)

commit d5c72d7842c71403bc3d57ca05a8a1f96d81e262
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Fri Jan 30 22:39:17 2009 +0530

    headers_check fix: linux/nubus.h
    
    fix the following 'make headers_check' warning:
    
      usr/include/linux/nubus.h:232: found __[us]{8,16,32,64} type without #include <linux/types.h>
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index c4355076d1a5..7382af374731 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -12,6 +12,7 @@
 #ifndef LINUX_NUBUS_H
 #define LINUX_NUBUS_H
 
+#include <linux/types.h>
 #ifdef __KERNEL__
 #include <asm/nubus.h>
 #endif

commit 57dfee7c3f1fcac24e986b69bdfdccc8ea025813
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Feb 4 22:30:30 2008 -0800

    mac68k: add nubus card definitions and a typo fix
    
    Add some new card definitions and fix a typo (from Eugen Paiuc).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index cdb3e9b8db54..c4355076d1a5 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -132,10 +132,12 @@ enum nubus_drhw {
 	NUBUS_DRHW_RDIUS_DCGX     = 0x027C, /* Radius DirectColor/GX */
 	NUBUS_DRHW_RDIUS_PC8      = 0x0291, /* Radius PrecisionColor 8 */
 	NUBUS_DRHW_LAPIS_PCS8     = 0x0292, /* Lapis ProColorServer 8 */
-	NUBUS_DRHW_RASTER_24LXI   = 0x02A0, /* RasterOps 8/24 XLi */
+	NUBUS_DRHW_RASTER_24XLI   = 0x02A0, /* RasterOps 8/24 XLi */
 	NUBUS_DRHW_RASTER_PBPGT   = 0x02A5, /* RasterOps PaintBoard Prism GT */
 	NUBUS_DRHW_EMACH_FSX      = 0x02AE, /* E-Machines Futura SX */
+	NUBUS_DRHW_RASTER_24XLTV  = 0x02B7, /* RasterOps 24XLTV */
 	NUBUS_DRHW_SMAC_THUND24   = 0x02CB, /* SuperMac Thunder/24 */
+	NUBUS_DRHW_SMAC_THUNDLGHT = 0x03D9, /* SuperMac ThunderLight */
 	NUBUS_DRHW_RDIUS_PC24XP   = 0x0406, /* Radius PrecisionColor 24Xp */
 	NUBUS_DRHW_RDIUS_PC24X    = 0x040A, /* Radius PrecisionColor 24X */
 	NUBUS_DRHW_RDIUS_PC8XJ    = 0x040B, /* Radius PrecisionColor 8XJ */

commit f877958879d413c37bfbeb7517614f3625cdea38
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:53 2007 +0200

    NuBus header update
    
    Sync the nubus defines with the latest code in the mac68k repo. Some of these
    are needed for DP8390 driver update in the next patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
index 870e66a96286..cdb3e9b8db54 100644
--- a/include/linux/nubus.h
+++ b/include/linux/nubus.h
@@ -28,18 +28,18 @@ enum nubus_category {
 };
 
 enum nubus_type_network {
-	NUBUS_TYPE_ETHERNET 	 = 0x0001,
-	NUBUS_TYPE_RS232    	 = 0x0002
+	NUBUS_TYPE_ETHERNET      = 0x0001,
+	NUBUS_TYPE_RS232         = 0x0002
 };
 
 enum nubus_type_display {
-	NUBUS_TYPE_VIDEO 	 = 0x0001
+	NUBUS_TYPE_VIDEO         = 0x0001
 };
 
 enum nubus_type_cpu {
-	NUBUS_TYPE_68020 	 = 0x0003,
-	NUBUS_TYPE_68030 	 = 0x0004,
-	NUBUS_TYPE_68040 	 = 0x0005
+	NUBUS_TYPE_68020         = 0x0003,
+	NUBUS_TYPE_68030         = 0x0004,
+	NUBUS_TYPE_68040         = 0x0005
 };
 
 /* Known <Cat,Type,SW,HW> tuples: (according to TattleTech and Slots)
@@ -56,6 +56,7 @@ enum nubus_type_cpu {
  *
  *  SONIC comm-slot/on-board and DuoDock Ethernet: <4,1,1,272>
  *  SONIC LC-PDS Ethernet (Dayna, but like Apple 16-bit, sort of): <4,1,1,271>
+ *  Apple SONIC LC-PDS Ethernet ("Apple Ethernet LC Twisted-Pair Card"): <4,1,0,281>
  *  Sonic Systems Ethernet A-Series Card: <4,1,268,256>
  *  Asante MacCon NuBus-A: <4,1,260,256> (alpha-1.0,1.1 revision)
  *   ROM on the above card: <2,1,0,0>
@@ -80,24 +81,26 @@ enum nubus_type_cpu {
 /* Add known DrSW values here */
 enum nubus_drsw {
 	/* NUBUS_CAT_DISPLAY */
-	NUBUS_DRSW_APPLE       	= 0x0001,
-	NUBUS_DRSW_APPLE_HIRES 	= 0x0013, /* MacII HiRes card driver */
+	NUBUS_DRSW_APPLE        = 0x0001,
+	NUBUS_DRSW_APPLE_HIRES  = 0x0013, /* MacII HiRes card driver */
 	
 	/* NUBUS_CAT_NETWORK */
-	NUBUS_DRSW_CABLETRON   	= 0x0001,
-	NUBUS_DRSW_SONIC_LC    	= 0x0001,
-	NUBUS_DRSW_KINETICS    	= 0x0103,
-	NUBUS_DRSW_ASANTE      	= 0x0104,
-	NUBUS_DRSW_DAYNA       	= 0x010b,
-	NUBUS_DRSW_FARALLON    	= 0x010c,
-	NUBUS_DRSW_APPLE_SN    	= 0x010f,
-	NUBUS_DRSW_DAYNA2	= 0x0115,
+	NUBUS_DRSW_3COM         = 0x0000,
+	NUBUS_DRSW_CABLETRON    = 0x0001,
+	NUBUS_DRSW_SONIC_LC     = 0x0001,
+	NUBUS_DRSW_KINETICS     = 0x0103,
+	NUBUS_DRSW_ASANTE       = 0x0104,
+	NUBUS_DRSW_TECHWORKS    = 0x0109,
+	NUBUS_DRSW_DAYNA        = 0x010b,
+	NUBUS_DRSW_FARALLON     = 0x010c,
+	NUBUS_DRSW_APPLE_SN     = 0x010f,
+	NUBUS_DRSW_DAYNA2       = 0x0115,
 	NUBUS_DRSW_FOCUS        = 0x011a,
 	NUBUS_DRSW_ASANTE_CS    = 0x011d, /* use asante SMC9194 driver */
-	NUBUS_DRSW_DAYNA_LC	= 0x011e,
+	NUBUS_DRSW_DAYNA_LC     = 0x011e,
 
 	/* NUBUS_CAT_CPU */
-	NUBUS_DRSW_NONE        	= 0x0000,
+	NUBUS_DRSW_NONE         = 0x0000,
 };
 
 /* DrHW: Uniquely identifies the hardware interface to a board (or at
@@ -107,27 +110,48 @@ enum nubus_drsw {
 /* Add known DrHW values here */
 enum nubus_drhw {
 	/* NUBUS_CAT_DISPLAY */
-	NUBUS_DRHW_APPLE_TFB	= 0x0001, /* Toby frame buffer card */
-	NUBUS_DRHW_APPLE_HRVC	= 0x0013, /* Mac II High Res Video card */
-	NUBUS_DRHW_APPLE_RBV1   = 0x0018, /* IIci RBV video */
-	NUBUS_DRHW_APPLE_MDC    = 0x0019, /* Macintosh Display Card */
-	NUBUS_DRHW_APPLE_SONORA = 0x0022, /* Sonora built-in video */
-	NUBUS_DRHW_APPLE_JET 	= 0x0029, /* Jet framebuffer (DuoDock) */
+	NUBUS_DRHW_APPLE_TFB      = 0x0001, /* Toby frame buffer card */
+	NUBUS_DRHW_APPLE_WVC      = 0x0006, /* Apple Workstation Video Card */
+	NUBUS_DRHW_SIGMA_CLRMAX   = 0x0007, /* Sigma Design ColorMax */
+	NUBUS_DRHW_APPLE_SE30     = 0x0009, /* Apple SE/30 video */
+	NUBUS_DRHW_APPLE_HRVC     = 0x0013, /* Mac II High-Res Video Card */
+	NUBUS_DRHW_APPLE_PVC      = 0x0017, /* Mac II Portrait Video Card */
+	NUBUS_DRHW_APPLE_RBV1     = 0x0018, /* IIci RBV video */
+	NUBUS_DRHW_APPLE_MDC      = 0x0019, /* Macintosh Display Card */
+	NUBUS_DRHW_APPLE_SONORA   = 0x0022, /* Sonora built-in video */
+	NUBUS_DRHW_APPLE_24AC     = 0x002b, /* Mac 24AC Video Card */
 	NUBUS_DRHW_APPLE_VALKYRIE = 0x002e,
-	NUBUS_DRHW_THUNDER24	= 0x02cb, /* SuperMac Thunder/24 */
+	NUBUS_DRHW_APPLE_JET      = 0x0029, /* Jet framebuffer (DuoDock) */
+	NUBUS_DRHW_SMAC_GFX       = 0x0105, /* SuperMac GFX */
+	NUBUS_DRHW_RASTER_CB264   = 0x013B, /* RasterOps ColorBoard 264 */
+	NUBUS_DRHW_MICRON_XCEED   = 0x0146, /* Micron Exceed color */
+	NUBUS_DRHW_RDIUS_GSC      = 0x0153, /* Radius GS/C */
+	NUBUS_DRHW_SMAC_SPEC8     = 0x017B, /* SuperMac Spectrum/8 */
+	NUBUS_DRHW_SMAC_SPEC24    = 0x017C, /* SuperMac Spectrum/24 */
+	NUBUS_DRHW_RASTER_CB364   = 0x026F, /* RasterOps ColorBoard 364 */
+	NUBUS_DRHW_RDIUS_DCGX     = 0x027C, /* Radius DirectColor/GX */
+	NUBUS_DRHW_RDIUS_PC8      = 0x0291, /* Radius PrecisionColor 8 */
+	NUBUS_DRHW_LAPIS_PCS8     = 0x0292, /* Lapis ProColorServer 8 */
+	NUBUS_DRHW_RASTER_24LXI   = 0x02A0, /* RasterOps 8/24 XLi */
+	NUBUS_DRHW_RASTER_PBPGT   = 0x02A5, /* RasterOps PaintBoard Prism GT */
+	NUBUS_DRHW_EMACH_FSX      = 0x02AE, /* E-Machines Futura SX */
+	NUBUS_DRHW_SMAC_THUND24   = 0x02CB, /* SuperMac Thunder/24 */
+	NUBUS_DRHW_RDIUS_PC24XP   = 0x0406, /* Radius PrecisionColor 24Xp */
+	NUBUS_DRHW_RDIUS_PC24X    = 0x040A, /* Radius PrecisionColor 24X */
+	NUBUS_DRHW_RDIUS_PC8XJ    = 0x040B, /* Radius PrecisionColor 8XJ */
 	
 	/* NUBUS_CAT_NETWORK */
-	NUBUS_DRHW_INTERLAN     = 0x0100,
-	NUBUS_DRHW_SMC9194      = 0x0101,
-	NUBUS_DRHW_KINETICS     = 0x0106,
-	NUBUS_DRHW_CABLETRON    = 0x0109,
-	NUBUS_DRHW_ASANTE_LC    = 0x010f,
-	NUBUS_DRHW_SONIC        = 0x0110,
-	NUBUS_DRHW_SONIC_NB	= 0x0118,
-	NUBUS_DRHW_SONIC_LC	= 0x0119,
-	
-	/* NUBUS_CAT_COMMUNICATIONS */
-	NUBUS_DRHW_DOVEFAX	= 0x0100,
+	NUBUS_DRHW_INTERLAN       = 0x0100,
+	NUBUS_DRHW_SMC9194        = 0x0101,
+	NUBUS_DRHW_KINETICS       = 0x0106,
+	NUBUS_DRHW_CABLETRON      = 0x0109,
+	NUBUS_DRHW_ASANTE_LC      = 0x010f,
+	NUBUS_DRHW_SONIC          = 0x0110,
+	NUBUS_DRHW_TECHWORKS      = 0x0112,
+	NUBUS_DRHW_APPLE_SONIC_NB = 0x0118,
+	NUBUS_DRHW_APPLE_SONIC_LC = 0x0119,
+	NUBUS_DRHW_FOCUS          = 0x011c,
+	NUBUS_DRHW_SONNET         = 0x011d,
 };
 
 /* Resource IDs: These are the identifiers for the various weird and
@@ -153,17 +177,17 @@ enum nubus_res_id {
 
 /* Category-specific resources. */
 enum nubus_board_res_id {
-	NUBUS_RESID_BOARDID	 = 0x0020,
+	NUBUS_RESID_BOARDID      = 0x0020,
 	NUBUS_RESID_PRAMINITDATA = 0x0021,
-	NUBUS_RESID_PRIMARYINIT	 = 0x0022,
+	NUBUS_RESID_PRIMARYINIT  = 0x0022,
 	NUBUS_RESID_TIMEOUTCONST = 0x0023,
-	NUBUS_RESID_VENDORINFO	 = 0x0024,
-	NUBUS_RESID_BOARDFLAGS	 = 0x0025,
-	NUBUS_RESID_SECONDINIT	 = 0x0026,
+	NUBUS_RESID_VENDORINFO   = 0x0024,
+	NUBUS_RESID_BOARDFLAGS   = 0x0025,
+	NUBUS_RESID_SECONDINIT   = 0x0026,
 
 	/* Not sure why Apple put these next two in here */
-	NUBUS_RESID_VIDNAMES 	 = 0x0041,
-	NUBUS_RESID_VIDMODES 	 = 0x007e
+	NUBUS_RESID_VIDNAMES     = 0x0041,
+	NUBUS_RESID_VIDMODES     = 0x007e
 };
 
 /* Fields within the vendor info directory */
@@ -185,13 +209,13 @@ enum nubus_cpu_res_id {
 };
 
 enum nubus_display_res_id {
-	NUBUS_RESID_GAMMADIR	= 0x0040,
-	NUBUS_RESID_FIRSTMODE	= 0x0080,
-	NUBUS_RESID_SECONDMODE	= 0x0081,
-	NUBUS_RESID_THIRDMODE	= 0x0082,
-	NUBUS_RESID_FOURTHMODE	= 0x0083,
-	NUBUS_RESID_FIFTHMODE	= 0x0084,
-	NUBUS_RESID_SIXTHMODE	= 0x0085
+	NUBUS_RESID_GAMMADIR    = 0x0040,
+	NUBUS_RESID_FIRSTMODE   = 0x0080,
+	NUBUS_RESID_SECONDMODE  = 0x0081,
+	NUBUS_RESID_THIRDMODE   = 0x0082,
+	NUBUS_RESID_FOURTHMODE  = 0x0083,
+	NUBUS_RESID_FIFTHMODE   = 0x0084,
+	NUBUS_RESID_SIXTHMODE   = 0x0085
 };
 
 struct nubus_dir
@@ -214,7 +238,7 @@ struct nubus_board {
 	struct nubus_board* next;
 	struct nubus_dev* first_dev;
 	
-        /* Only 9-E actually exist, though 0-8 are also theoretically
+	/* Only 9-E actually exist, though 0-8 are also theoretically
 	   possible, and 0 is a special case which represents the
 	   motherboard and onboard peripherals (Ethernet, video) */
 	int slot;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/nubus.h b/include/linux/nubus.h
new file mode 100644
index 000000000000..870e66a96286
--- /dev/null
+++ b/include/linux/nubus.h
@@ -0,0 +1,334 @@
+/*
+  nubus.h: various definitions and prototypes for NuBus drivers to use.
+
+  Originally written by Alan Cox.
+
+  Hacked to death by C. Scott Ananian and David Huggins-Daines.
+  
+  Some of the constants in here are from the corresponding
+  NetBSD/OpenBSD header file, by Allen Briggs.  We figured out the
+  rest of them on our own. */
+
+#ifndef LINUX_NUBUS_H
+#define LINUX_NUBUS_H
+
+#ifdef __KERNEL__
+#include <asm/nubus.h>
+#endif
+
+enum nubus_category {
+	NUBUS_CAT_BOARD          = 0x0001,
+	NUBUS_CAT_DISPLAY        = 0x0003,
+	NUBUS_CAT_NETWORK        = 0x0004,
+	NUBUS_CAT_COMMUNICATIONS = 0x0006,
+	NUBUS_CAT_FONT           = 0x0009,
+	NUBUS_CAT_CPU            = 0x000A,
+	/* For lack of a better name */
+	NUBUS_CAT_DUODOCK        = 0x0020
+};
+
+enum nubus_type_network {
+	NUBUS_TYPE_ETHERNET 	 = 0x0001,
+	NUBUS_TYPE_RS232    	 = 0x0002
+};
+
+enum nubus_type_display {
+	NUBUS_TYPE_VIDEO 	 = 0x0001
+};
+
+enum nubus_type_cpu {
+	NUBUS_TYPE_68020 	 = 0x0003,
+	NUBUS_TYPE_68030 	 = 0x0004,
+	NUBUS_TYPE_68040 	 = 0x0005
+};
+
+/* Known <Cat,Type,SW,HW> tuples: (according to TattleTech and Slots)
+ *  68030 motherboards: <10,4,0,24>
+ *  68040 motherboards: <10,5,0,24>
+ *  DuoDock Plus: <32,1,1,2>
+ *
+ *  Toby Frame Buffer card: <3,1,1,1>
+ *  RBV built-in video (IIci): <3,1,1,24>
+ *  Valkyrie built-in video (Q630): <3,1,1,46>
+ *  Macintosh Display Card: <3,1,1,25>
+ *  Sonora built-in video (P460): <3,1,1,34>
+ *  Jet framebuffer (DuoDock Plus): <3,1,1,41>
+ *
+ *  SONIC comm-slot/on-board and DuoDock Ethernet: <4,1,1,272>
+ *  SONIC LC-PDS Ethernet (Dayna, but like Apple 16-bit, sort of): <4,1,1,271>
+ *  Sonic Systems Ethernet A-Series Card: <4,1,268,256>
+ *  Asante MacCon NuBus-A: <4,1,260,256> (alpha-1.0,1.1 revision)
+ *   ROM on the above card: <2,1,0,0>
+ *  Cabletron ethernet card: <4,1,1,265>
+ *  Farallon ethernet card: <4,1,268,256> (identical to Sonic Systems card)
+ *  Kinetics EtherPort IIN: <4,1,259,262>
+ *  API Engineering EtherRun_LCa PDS enet card: <4,1,282,256>
+ *
+ *  Add your devices to the list!  You can obtain the "Slots" utility
+ *  from Apple's FTP site at:
+ *  ftp://dev.apple.com/devworld/Tool_Chest/Devices_-_Hardware/NuBus_Slot_Manager/
+ *
+ *  Alternately, TattleTech can be found at any Info-Mac mirror site.  
+ *  or from its distribution site: ftp://ftp.decismkr.com/dms
+ */
+
+/* DrSW: Uniquely identifies the software interface to a board.  This
+   is usually the one you want to look at when writing a driver.  It's
+   not as useful as you think, though, because as we should know by
+   now (duh), "Apple Compatible" can mean a lot of things... */
+
+/* Add known DrSW values here */
+enum nubus_drsw {
+	/* NUBUS_CAT_DISPLAY */
+	NUBUS_DRSW_APPLE       	= 0x0001,
+	NUBUS_DRSW_APPLE_HIRES 	= 0x0013, /* MacII HiRes card driver */
+	
+	/* NUBUS_CAT_NETWORK */
+	NUBUS_DRSW_CABLETRON   	= 0x0001,
+	NUBUS_DRSW_SONIC_LC    	= 0x0001,
+	NUBUS_DRSW_KINETICS    	= 0x0103,
+	NUBUS_DRSW_ASANTE      	= 0x0104,
+	NUBUS_DRSW_DAYNA       	= 0x010b,
+	NUBUS_DRSW_FARALLON    	= 0x010c,
+	NUBUS_DRSW_APPLE_SN    	= 0x010f,
+	NUBUS_DRSW_DAYNA2	= 0x0115,
+	NUBUS_DRSW_FOCUS        = 0x011a,
+	NUBUS_DRSW_ASANTE_CS    = 0x011d, /* use asante SMC9194 driver */
+	NUBUS_DRSW_DAYNA_LC	= 0x011e,
+
+	/* NUBUS_CAT_CPU */
+	NUBUS_DRSW_NONE        	= 0x0000,
+};
+
+/* DrHW: Uniquely identifies the hardware interface to a board (or at
+   least, it should...  some video cards are known to incorrectly
+   identify themselves as Toby cards) */
+
+/* Add known DrHW values here */
+enum nubus_drhw {
+	/* NUBUS_CAT_DISPLAY */
+	NUBUS_DRHW_APPLE_TFB	= 0x0001, /* Toby frame buffer card */
+	NUBUS_DRHW_APPLE_HRVC	= 0x0013, /* Mac II High Res Video card */
+	NUBUS_DRHW_APPLE_RBV1   = 0x0018, /* IIci RBV video */
+	NUBUS_DRHW_APPLE_MDC    = 0x0019, /* Macintosh Display Card */
+	NUBUS_DRHW_APPLE_SONORA = 0x0022, /* Sonora built-in video */
+	NUBUS_DRHW_APPLE_JET 	= 0x0029, /* Jet framebuffer (DuoDock) */
+	NUBUS_DRHW_APPLE_VALKYRIE = 0x002e,
+	NUBUS_DRHW_THUNDER24	= 0x02cb, /* SuperMac Thunder/24 */
+	
+	/* NUBUS_CAT_NETWORK */
+	NUBUS_DRHW_INTERLAN     = 0x0100,
+	NUBUS_DRHW_SMC9194      = 0x0101,
+	NUBUS_DRHW_KINETICS     = 0x0106,
+	NUBUS_DRHW_CABLETRON    = 0x0109,
+	NUBUS_DRHW_ASANTE_LC    = 0x010f,
+	NUBUS_DRHW_SONIC        = 0x0110,
+	NUBUS_DRHW_SONIC_NB	= 0x0118,
+	NUBUS_DRHW_SONIC_LC	= 0x0119,
+	
+	/* NUBUS_CAT_COMMUNICATIONS */
+	NUBUS_DRHW_DOVEFAX	= 0x0100,
+};
+
+/* Resource IDs: These are the identifiers for the various weird and
+   wonderful tidbits of information that may or may not reside in the
+   NuBus ROM directory. */
+enum nubus_res_id {
+	NUBUS_RESID_TYPE         = 0x0001,
+	NUBUS_RESID_NAME         = 0x0002,
+	NUBUS_RESID_ICON         = 0x0003,
+	NUBUS_RESID_DRVRDIR      = 0x0004,
+	NUBUS_RESID_LOADREC      = 0x0005,
+	NUBUS_RESID_BOOTREC      = 0x0006,
+	NUBUS_RESID_FLAGS        = 0x0007,
+	NUBUS_RESID_HWDEVID      = 0x0008,
+	NUBUS_RESID_MINOR_BASEOS = 0x000a,
+	NUBUS_RESID_MINOR_LENGTH = 0x000b,
+	NUBUS_RESID_MAJOR_BASEOS = 0x000c,
+	NUBUS_RESID_MAJOR_LENGTH = 0x000d,
+	NUBUS_RESID_CICN         = 0x000f,
+	NUBUS_RESID_ICL8         = 0x0010,
+	NUBUS_RESID_ICL4         = 0x0011,
+};
+
+/* Category-specific resources. */
+enum nubus_board_res_id {
+	NUBUS_RESID_BOARDID	 = 0x0020,
+	NUBUS_RESID_PRAMINITDATA = 0x0021,
+	NUBUS_RESID_PRIMARYINIT	 = 0x0022,
+	NUBUS_RESID_TIMEOUTCONST = 0x0023,
+	NUBUS_RESID_VENDORINFO	 = 0x0024,
+	NUBUS_RESID_BOARDFLAGS	 = 0x0025,
+	NUBUS_RESID_SECONDINIT	 = 0x0026,
+
+	/* Not sure why Apple put these next two in here */
+	NUBUS_RESID_VIDNAMES 	 = 0x0041,
+	NUBUS_RESID_VIDMODES 	 = 0x007e
+};
+
+/* Fields within the vendor info directory */
+enum nubus_vendor_res_id {
+	NUBUS_RESID_VEND_ID     = 0x0001,
+	NUBUS_RESID_VEND_SERIAL = 0x0002,
+	NUBUS_RESID_VEND_REV    = 0x0003,
+	NUBUS_RESID_VEND_PART   = 0x0004,
+	NUBUS_RESID_VEND_DATE   = 0x0005
+};
+
+enum nubus_net_res_id {
+	NUBUS_RESID_MAC_ADDRESS  = 0x0080
+};
+
+enum nubus_cpu_res_id {
+	NUBUS_RESID_MEMINFO      = 0x0081,
+	NUBUS_RESID_ROMINFO      = 0x0082
+};
+
+enum nubus_display_res_id {
+	NUBUS_RESID_GAMMADIR	= 0x0040,
+	NUBUS_RESID_FIRSTMODE	= 0x0080,
+	NUBUS_RESID_SECONDMODE	= 0x0081,
+	NUBUS_RESID_THIRDMODE	= 0x0082,
+	NUBUS_RESID_FOURTHMODE	= 0x0083,
+	NUBUS_RESID_FIFTHMODE	= 0x0084,
+	NUBUS_RESID_SIXTHMODE	= 0x0085
+};
+
+struct nubus_dir
+{
+	unsigned char *base;
+	unsigned char *ptr;
+	int done;
+	int mask;
+};
+
+struct nubus_dirent
+{
+	unsigned char *base;
+	unsigned char type;
+	__u32 data;	/* Actually 24bits used */
+	int mask;
+};
+
+struct nubus_board {
+	struct nubus_board* next;
+	struct nubus_dev* first_dev;
+	
+        /* Only 9-E actually exist, though 0-8 are also theoretically
+	   possible, and 0 is a special case which represents the
+	   motherboard and onboard peripherals (Ethernet, video) */
+	int slot;
+	/* For slot 0, this is bogus. */
+	char name[64];
+
+	/* Format block */
+	unsigned char* fblock;
+	/* Root directory (does *not* always equal fblock + doffset!) */
+	unsigned char* directory;
+	
+	unsigned long slot_addr;
+	/* Offset to root directory (sometimes) */
+	unsigned long doffset;
+	/* Length over which to compute the crc */
+	unsigned long rom_length;
+	/* Completely useless most of the time */
+	unsigned long crc;
+	unsigned char rev;
+	unsigned char format;
+	unsigned char lanes;
+};
+
+struct nubus_dev {
+	/* Next link in device list */
+	struct nubus_dev* next;
+	/* Directory entry in /proc/bus/nubus */
+	struct proc_dir_entry* procdir;
+
+	/* The functional resource ID of this device */
+	unsigned char resid;
+	/* These are mostly here for convenience; we could always read
+	   them from the ROMs if we wanted to */
+	unsigned short category;
+	unsigned short type;
+	unsigned short dr_sw;
+	unsigned short dr_hw;
+	/* This is the device's name rather than the board's.
+	   Sometimes they are different.  Usually the board name is
+	   more correct. */
+	char name[64];
+	/* MacOS driver (I kid you not) */
+	unsigned char* driver;
+	/* Actually this is an offset */
+	unsigned long iobase;
+	unsigned long iosize;
+	unsigned char flags, hwdevid;
+	
+	/* Functional directory */
+	unsigned char* directory;
+	/* Much of our info comes from here */
+	struct nubus_board* board;
+};
+
+/* This is all NuBus devices (used to find devices later on) */
+extern struct nubus_dev* nubus_devices;
+/* This is all NuBus cards */
+extern struct nubus_board* nubus_boards;
+
+/* Generic NuBus interface functions, modelled after the PCI interface */
+void nubus_scan_bus(void);
+extern void nubus_proc_init(void);
+int get_nubus_list(char *buf);
+int nubus_proc_attach_device(struct nubus_dev *dev);
+int nubus_proc_detach_device(struct nubus_dev *dev);
+/* If we need more precision we can add some more of these */
+struct nubus_dev* nubus_find_device(unsigned short category,
+				    unsigned short type,
+				    unsigned short dr_hw,
+				    unsigned short dr_sw,
+				    const struct nubus_dev* from);
+struct nubus_dev* nubus_find_type(unsigned short category,
+				  unsigned short type,
+				  const struct nubus_dev* from);
+/* Might have more than one device in a slot, you know... */
+struct nubus_dev* nubus_find_slot(unsigned int slot,
+				  const struct nubus_dev* from);
+
+/* These are somewhat more NuBus-specific.  They all return 0 for
+   success and -1 for failure, as you'd expect. */
+
+/* The root directory which contains the board and functional
+   directories */
+int nubus_get_root_dir(const struct nubus_board* board,
+		       struct nubus_dir* dir);
+/* The board directory */
+int nubus_get_board_dir(const struct nubus_board* board,
+			struct nubus_dir* dir);
+/* The functional directory */
+int nubus_get_func_dir(const struct nubus_dev* dev,
+		       struct nubus_dir* dir);
+
+/* These work on any directory gotten via the above */
+int nubus_readdir(struct nubus_dir* dir,
+		  struct nubus_dirent* ent);
+int nubus_find_rsrc(struct nubus_dir* dir,
+		    unsigned char rsrc_type,
+		    struct nubus_dirent* ent);
+int nubus_rewinddir(struct nubus_dir* dir);
+
+/* Things to do with directory entries */
+int nubus_get_subdir(const struct nubus_dirent* ent,
+		     struct nubus_dir* dir);
+void nubus_get_rsrc_mem(void* dest,
+			const struct nubus_dirent *dirent,
+			int len);
+void nubus_get_rsrc_str(void* dest,
+			const struct nubus_dirent *dirent,
+			int maxlen);
+
+/* We'd like to get rid of this eventually.  Only daynaport.c uses it now. */
+static inline void *nubus_slot_addr(int slot)
+{
+	return (void *)(0xF0000000|(slot<<24));
+}
+
+#endif /* LINUX_NUBUS_H */
