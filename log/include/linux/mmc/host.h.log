commit 1be64c7963f89afbd6f96f27effea20900650dfe
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 13:29:02 2020 +0200

    mmc: host: Drop redundant MMC_CAP_ERASE
    
    The MMC_CAP_ERASE bit is no longer used by the mmc core as erase, discard
    and trim operations are now always supported. Therefore, drop the bit and
    move all mmc hosts away from using it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Link: https://lore.kernel.org/r/20200508112902.23575-1-ulf.hansson@linaro.org
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d4a50e5dc111..7149bab555d7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -321,7 +321,6 @@ struct mmc_host {
 #define MMC_CAP_AGGRESSIVE_PM	(1 << 7)	/* Suspend (e)MMC/SD at idle  */
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
-#define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
 #define MMC_CAP_3_3V_DDR	(1 << 11)	/* Host supports eMMC DDR 3.3V */
 #define MMC_CAP_1_8V_DDR	(1 << 12)	/* Host supports eMMC DDR 1.8V */
 #define MMC_CAP_1_2V_DDR	(1 << 13)	/* Host supports eMMC DDR 1.2V */

commit 6db96e5810e0a6a345b7d78549de7676ae5b2662
Author: Baolin Wang <baolin.wang7@gmail.com>
Date:   Mon Apr 13 10:46:03 2020 +0800

    mmc: host: Introduce the request_atomic() for the host
    
    The SD host controller can process one request in the atomic context if
    the card is nonremovable, which means we can submit next request in the
    irq hard handler when using the MMC host software queue to reduce the
    latency. Thus this patch adds a new API request_atomic() for the host
    controller, as well as adding support for host software queue to submit
    a request by the new request_atomic() API.
    
    Moreover there is an unusual case that the card is busy when trying to
    send a command, and we can not polling the card status in interrupt
    context by using request_atomic() to dispatch requests. Thus we should
    queue a work to try again in the non-atomic context in case the host
    releases the busy signal later.
    
    Suggested-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/a344e27e506cb2329073cbd5cf65e15cc3cbeba9.1586744073.git.baolin.wang7@gmail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c318fb5b6a94..d4a50e5dc111 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -92,6 +92,9 @@ struct mmc_host_ops {
 			    int err);
 	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+	/* Submit one request to host in atomic context. */
+	int	(*request_atomic)(struct mmc_host *host,
+				  struct mmc_request *req);
 
 	/*
 	 * Avoid calling the next three functions too often or in a "fast

commit 1a91a36aba9c232c73e4a5fce038147f5d29e566
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Feb 26 16:31:25 2020 -0600

    mmc: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Link: https://lore.kernel.org/r/20200226223125.GA20630@embeddedor
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f5db24a6a860..c318fb5b6a94 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -468,7 +468,7 @@ struct mmc_host {
 	/* Host Software Queue support */
 	bool			hsq_enabled;
 
-	unsigned long		private[0] ____cacheline_aligned;
+	unsigned long		private[] ____cacheline_aligned;
 };
 
 struct device_node;

commit 8ee5fc0e0b3bed087b38f46f4c272b64c0b33d47
Author: Faiz Abbas <faiz_abbas@ti.com>
Date:   Wed Jan 8 20:39:19 2020 +0530

    mmc: sdhci_am654: Update OTAPDLY writes
    
    According to the latest AM65x Data Manual[1], a different output tap
    delay value is optimum for a given speed mode. Therefore, deprecate the
    ti,otap-del-sel binding and introduce a new binding for each of the
    possible MMC/SD speed modes. If the legacy mode is not found, fall back
    to old binding to maintain dts compatibility.
    
    [1] http://www.ti.com/lit/gpn/am6526
    
    Signed-off-by: Faiz Abbas <faiz_abbas@ti.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Link: https://lore.kernel.org/r/20200108150920.14547-3-faiz_abbas@ti.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 94e3c87c1a58..f5db24a6a860 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -322,6 +322,8 @@ struct mmc_host {
 #define MMC_CAP_3_3V_DDR	(1 << 11)	/* Host supports eMMC DDR 3.3V */
 #define MMC_CAP_1_8V_DDR	(1 << 12)	/* Host supports eMMC DDR 1.8V */
 #define MMC_CAP_1_2V_DDR	(1 << 13)	/* Host supports eMMC DDR 1.2V */
+#define MMC_CAP_DDR		(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR | \
+				 MMC_CAP_1_2V_DDR)
 #define MMC_CAP_POWER_OFF_CARD	(1 << 14)	/* Can power off after boot */
 #define MMC_CAP_BUS_WIDTH_TEST	(1 << 15)	/* CMD14/CMD19 bus width ok */
 #define MMC_CAP_UHS_SDR12	(1 << 16)	/* Host supports UHS SDR12 mode */

commit 511ce378e16f07b66ab78118587b7cc6ac197364
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Wed Feb 12 12:12:56 2020 +0800

    mmc: Add MMC host software queue support
    
    Now the MMC read/write stack will always wait for previous request is
    completed by mmc_blk_rw_wait(), before sending a new request to hardware,
    or queue a work to complete request, that will bring context switching
    overhead and spend some extra time to poll the card for busy completion
    for I/O writes via sending CMD13, especially for high I/O per second
    rates, to affect the IO performance.
    
    Thus this patch introduces MMC software queue interface based on the
    hardware command queue engine's interfaces, which is similar with the
    hardware command queue engine's idea, that can remove the context
    switching. Moreover we set the default queue depth as 64 for software
    queue, which allows more requests to be prepared, merged and inserted
    into IO scheduler to improve performance, but we only allow 2 requests
    in flight, that is enough to let the irq handler always trigger the
    next request without a context switch, as well as avoiding a long latency.
    
    Moreover the host controller should support HW busy detection for I/O
    operations when enabling the host software queue. That means, the host
    controller must not complete a data transfer request, until after the
    card stops signals busy.
    
    From the fio testing data in cover letter, we can see the software
    queue can improve some performance with 4K block size, increasing
    about 16% for random read, increasing about 90% for random write,
    though no obvious improvement for sequential read and write.
    
    Moreover we can expand the software queue interface to support MMC
    packed request or packed command in future.
    
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Baolin Wang <baolin.wang7@gmail.com>
    Link: https://lore.kernel.org/r/4409c1586a9b3ed20d57ad2faf6c262fc3ccb6e2.1581478568.git.baolin.wang7@gmail.com
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4c5eb3aa8e72..94e3c87c1a58 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -463,6 +463,9 @@ struct mmc_host {
 	bool			cqe_enabled;
 	bool			cqe_on;
 
+	/* Host Software Queue support */
+	bool			hsq_enabled;
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 1292e3efb149ee21d8d33d725eeed4e6b1ade963
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 10 12:49:43 2020 +0100

    mmc: core: Allow host controllers to require R1B for CMD6
    
    It has turned out that some host controllers can't use R1B for CMD6 and
    other commands that have R1B associated with them. Therefore invent a new
    host cap, MMC_CAP_NEED_RSP_BUSY to let them specify this.
    
    In __mmc_switch(), let's check the flag and use it to prevent R1B responses
    from being converted into R1. Note that, this also means that the host are
    on its own, when it comes to manage the busy timeout.
    
    Suggested-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Anders Roxell <anders.roxell@linaro.org>
    Tested-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Tested-by: Faiz Abbas <faiz_abbas@ti.com>
    Tested-By: Peter Geis <pgwipeout@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ba703384bea0..4c5eb3aa8e72 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -333,6 +333,7 @@ struct mmc_host {
 				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | \
 				 MMC_CAP_UHS_DDR50)
 #define MMC_CAP_SYNC_RUNTIME_PM	(1 << 21)	/* Synced runtime PM suspends. */
+#define MMC_CAP_NEED_RSP_BUSY	(1 << 22)	/* Commands with R1B can't use R1. */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit 671df189537883f36cf9c7d4f9495bfac0f86627
Merge: c9fe5630dae1 c7d9eccb3c1e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 13:27:23 2019 -0700

    Merge tag 'dma-mapping-5.4' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull dma-mapping updates from Christoph Hellwig:
    
     - add dma-mapping and block layer helpers to take care of IOMMU merging
       for mmc plus subsequent fixups (Yoshihiro Shimoda)
    
     - rework handling of the pgprot bits for remapping (me)
    
     - take care of the dma direct infrastructure for swiotlb-xen (me)
    
     - improve the dma noncoherent remapping infrastructure (me)
    
     - better defaults for ->mmap, ->get_sgtable and ->get_required_mask
       (me)
    
     - cleanup mmaping of coherent DMA allocations (me)
    
     - various misc cleanups (Andy Shevchenko, me)
    
    * tag 'dma-mapping-5.4' of git://git.infradead.org/users/hch/dma-mapping: (41 commits)
      mmc: renesas_sdhi_internal_dmac: Add MMC_CAP2_MERGE_CAPABLE
      mmc: queue: Fix bigger segments usage
      arm64: use asm-generic/dma-mapping.h
      swiotlb-xen: merge xen_unmap_single into xen_swiotlb_unmap_page
      swiotlb-xen: simplify cache maintainance
      swiotlb-xen: use the same foreign page check everywhere
      swiotlb-xen: remove xen_swiotlb_dma_mmap and xen_swiotlb_dma_get_sgtable
      xen: remove the exports for xen_{create,destroy}_contiguous_region
      xen/arm: remove xen_dma_ops
      xen/arm: simplify dma_cache_maint
      xen/arm: use dev_is_dma_coherent
      xen/arm: consolidate page-coherent.h
      xen/arm: use dma-noncoherent.h calls for xen-swiotlb cache maintainance
      arm: remove wrappers for the generic dma remap helpers
      dma-mapping: introduce a dma_common_find_pages helper
      dma-mapping: always use VM_DMA_COHERENT for generic DMA remap
      vmalloc: lift the arm flag for coherent mappings to common code
      dma-mapping: provide a better default ->get_required_mask
      dma-mapping: remove the dma_declare_coherent_memory export
      remoteproc: don't allow modular build
      ...

commit 427b00342c5a3ebcf31fac2ce3b21fb993952816
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Thu Sep 12 13:13:55 2019 +0900

    mmc: queue: Fix bigger segments usage
    
    The commit 38c38cb73223 ("mmc: queue: use bigger segments if DMA MAP
    layer can merge the segments") always enables the bugger segments
    if DMA MAP layer can merge the segments, but some controllers (SDHCI)
    have strictly limitation about the segments size, and then the commit
    breaks on the controllers.
    
    To fix the issue, this patch adds a new flag MMC_CAP2_MERGE_CAPABLE
    into the struct mmc_host and the bigger segments usage is disabled
    as default.
    
    Reported-by: Thierry Reding <treding@nvidia.com>
    Fixes: 38c38cb73223 ("mmc: queue: use bigger segments if DMA MAP layer can merge the segments")
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c5662b3e64db..3becb28210f3 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -367,6 +367,7 @@ struct mmc_host {
 #define MMC_CAP2_CQE		(1 << 23)	/* Has eMMC command queue engine */
 #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
 #define MMC_CAP2_AVOID_3_3V	(1 << 25)	/* Host must negotiate down from 3.3V */
+#define MMC_CAP2_MERGE_CAPABLE	(1 << 26)	/* Host can merge a segment over the segment size */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 

commit 2c32dbbb5fc09a26e3a1c39bbf57537c54ed3e91
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:31 2019 +0200

    mmc: core: Clarify that the ->ack_sdio_irq() callback is mandatory
    
    For the MMC_CAP2_SDIO_IRQ_NOTHREAD case and when using sdio_signal_irq(),
    the ->ack_sdio_irq() is already mandatory, which was not the case for those
    host drivers that called sdio_run_irqs() directly.
    
    As there are no longer any drivers calling sdio_run_irqs(), let's clarify
    the code by dropping the unnecessary check and explicitly state that the
    callback is mandatory in the header file.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cf87c673cbb8..4704b77259ee 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -128,6 +128,7 @@ struct mmc_host_ops {
 	int	(*get_cd)(struct mmc_host *host);
 
 	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);
+	/* Mandatory callback when using MMC_CAP2_SDIO_IRQ_NOTHREAD. */
 	void	(*ack_sdio_irq)(struct mmc_host *host);
 
 	/* optional callback for HC quirks */

commit bd880b00697befb73eff7220ee20bdae4fdd487b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Sun Sep 8 12:12:26 2019 +0200

    mmc: core: Add helper function to indicate if SDIO IRQs is enabled
    
    To avoid each host driver supporting SDIO IRQs, from keeping track
    internally about if SDIO IRQs has been claimed, let's introduce a common
    helper function, sdio_irq_claimed().
    
    The function returns true if SDIO IRQs are claimed, via using the
    information about the number of claimed irqs. This is safe, even without
    any locks, as long as the helper function is called only from
    runtime/system suspend callbacks of the host driver.
    
    Tested-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4a351cb7f20f..cf87c673cbb8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -493,6 +493,15 @@ void mmc_command_done(struct mmc_host *host, struct mmc_request *mrq);
 
 void mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq);
 
+/*
+ * May be called from host driver's system/runtime suspend/resume callbacks,
+ * to know if SDIO IRQs has been claimed.
+ */
+static inline bool sdio_irq_claimed(struct mmc_host *host)
+{
+	return host->sdio_irqs > 0;
+}
+
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);

commit 38c38cb73223218f6eedf485280917af1f8a0af2
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Aug 28 21:35:43 2019 +0900

    mmc: queue: use bigger segments if DMA MAP layer can merge the segments
    
    When the max_segs of a mmc host is smaller than 512, the mmc
    subsystem tries to use 512 segments if DMA MAP layer can merge
    the segments, and then the mmc subsystem exposes such information
    to the block layer by using blk_queue_can_use_dma_map_merging().
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4a351cb7f20f..c5662b3e64db 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -396,6 +396,7 @@ struct mmc_host {
 	unsigned int		retune_paused:1; /* re-tuning is temporarily disabled */
 	unsigned int		use_blk_mq:1;	/* use blk-mq */
 	unsigned int		retune_crc_disable:1; /* don't trigger retune upon crc */
+	unsigned int		can_dma_map_merge:1; /* merging can be used */
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */

commit 8931084c0d017314ad025f19353f7c5c1d3782d8
Merge: 17a20acaf171 59592cc1f593
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 18:11:21 2019 -0700

    Merge tag 'mmc-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc
    
    Pull MMC updates from Ulf Hansson:
     "MMC core:
       - Let the dma map ops deal with bouncing and drop dma_max_pfn() from
         the dma-mapping interface for ARM
       - Convert the generic MMC DT doc to YAML schemas
       - Drop questionable support for powered-on re-init of SDIO cards at
         runtime resume and for SDIO HW reset
       - Prevent questionable re-init of powered-on removable SDIO cards at
         system resume
       - Cleanup and clarify some SDIO core code
    
      MMC host:
       - tmio: Make runtime PM enablement more flexible for variants
       - tmio/renesas_sdhi: Rename DT doc tmio_mmc.txt to renesas,sdhi.txt
         to clarify
       - sdhci-pci: Add support for Intel EHL
       - sdhci-pci-o2micro: Enable support for 8-bit bus
       - sdhci-msm: Prevent acquiring a mutex while holding a spin_lock
       - sdhci-of-esdhc: Improve clock management and tuning
       - sdhci_am654: Enable support for 4 and 8-bit bus on J721E
       - sdhci-sprd: Use pinctrl for a proper signal voltage switch
       - sdhci-sprd: Add support for HS400 enhanced strobe mode
       - sdhci-sprd: Enable PHY DLL and allow delay config to stabilize the
         clock
       - sdhci-sprd: Add support for optional gate clock
       - sunxi-mmc: Convert DT doc to YAML schemas
       - meson-gx: Add support for broken DRAM access for DMA
    
      MEMSTICK core:
       - Fixup error path of memstick_init()"
    
    * tag 'mmc-v5.3' of git://git.kernel.org/pub/scm/linux/kernel/git/ulfh/mmc: (52 commits)
      mmc: sdhci_am654: Add dependency on MMC_SDHCI_AM654
      mmc: alcor: remove a redundant greater or equal to zero comparison
      mmc: sdhci-msm: fix mutex while in spinlock
      mmc: sdhci_am654: Make some symbols static
      dma-mapping: remove dma_max_pfn
      mmc: core: let the dma map ops handle bouncing
      dt-binding: mmc: rename tmio_mmc.txt to renesas,sdhi.txt
      mmc: sdhci-sprd: Add pin control support for voltage switch
      dt-bindings: mmc: sprd: Add pinctrl support
      mmc: sdhci-sprd: Add start_signal_voltage_switch ops
      mmc: sdhci-pci: Add support for Intel EHL
      mmc: tmio: Use dma_max_mapping_size() instead of a workaround
      mmc: sdio: Drop unused in-parameter from mmc_sdio_init_card()
      mmc: sdio: Drop unused in-parameter to mmc_sdio_reinit_card()
      mmc: sdio: Don't re-initialize powered-on removable SDIO cards at resume
      mmc: sdio: Drop powered-on re-init at runtime resume and HW reset
      mmc: sdio: Move comment about re-initialization to mmc_sdio_reinit_card()
      mmc: sdio: Drop mmc_claim|release_host() in mmc_sdio_power_restore()
      mmc: sdio: Turn sdio_run_irqs() into static
      mmc: sdhci: Fix indenting on SDHCI_CTRL_8BITBUS
      ...

commit c884d8ac7ffccc094e9674a3eb3be90d3b296c0a
Merge: 05512b0f4652 c891f3b97964
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 21 09:58:42 2019 -0700

    Merge tag 'spdx-5.2-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx
    
    Pull still more SPDX updates from Greg KH:
     "Another round of SPDX updates for 5.2-rc6
    
      Here is what I am guessing is going to be the last "big" SPDX update
      for 5.2. It contains all of the remaining GPLv2 and GPLv2+ updates
      that were "easy" to determine by pattern matching. The ones after this
      are going to be a bit more difficult and the people on the spdx list
      will be discussing them on a case-by-case basis now.
    
      Another 5000+ files are fixed up, so our overall totals are:
            Files checked:            64545
            Files with SPDX:          45529
    
      Compared to the 5.1 kernel which was:
            Files checked:            63848
            Files with SPDX:          22576
    
      This is a huge improvement.
    
      Also, we deleted another 20000 lines of boilerplate license crud,
      always nice to see in a diffstat"
    
    * tag 'spdx-5.2-rc6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/spdx: (65 commits)
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 507
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 506
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 505
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 504
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 503
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 502
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 501
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 499
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 498
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 497
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 496
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 495
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 491
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 490
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 489
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 488
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 487
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 486
      treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 485
      ...

commit cf4b20ecfa4edc4a0e55d52bc0a735f60bdfe7eb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 18 17:34:42 2019 +0200

    mmc: sdio: Turn sdio_run_irqs() into static
    
    All external users of sdio_run_irqs() have converted into using the
    preferred sdio_signal_irq() interface, thus not calling the function
    directly any more. Avoid further new users of it, by turning it into
    static.
    
    Suggested-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ecb7972e2423..a9b12322c775 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -504,7 +504,6 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 		wake_up_process(host->sdio_irq_thread);
 }
 
-void sdio_run_irqs(struct mmc_host *host);
 void sdio_signal_irq(struct mmc_host *host);
 
 #ifdef CONFIG_REGULATOR

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 43d0f0c496f6..00fe0b3d2039 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/include/linux/mmc/host.h
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  Host driver specific definitions.
  */
 #ifndef LINUX_MMC_HOST_H

commit 0a55f4ab9678413a01e740c86e9367ba0c612b36
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Jun 17 10:56:50 2019 -0700

    mmc: core: API to temporarily disable retuning for SDIO CRC errors
    
    Normally when the MMC core sees an "-EILSEQ" error returned by a host
    controller then it will trigger a retuning of the card.  This is
    generally a good idea.
    
    However, if a command is expected to sometimes cause transfer errors
    then these transfer errors shouldn't cause a re-tuning.  This
    re-tuning will be a needless waste of time.  One example case where a
    transfer is expected to cause errors is when transitioning between
    idle (sometimes referred to as "sleep" in Broadcom code) and active
    state on certain Broadcom WiFi SDIO cards.  Specifically if the card
    was already transitioning between states when the command was sent it
    could cause an error on the SDIO bus.
    
    Let's add an API that the SDIO function drivers can call that will
    temporarily disable the auto-tuning functionality.  Then we can add a
    call to this in the Broadcom WiFi driver and any other driver that
    might have similar needs.
    
    NOTE: this makes the assumption that the card is already tuned well
    enough that it's OK to disable the auto-retuning during one of these
    error-prone situations.  Presumably the driver code performing the
    error-prone transfer knows how to recover / retry from errors.  ...and
    after we can get back to a state where transfers are no longer
    error-prone then we can enable the auto-retuning again.  If we truly
    find ourselves in a case where the card needs to be retuned sometimes
    to handle one of these error-prone transfers then we can always try a
    few transfers first without auto-retuning and then re-try with
    auto-retuning if the first few fail.
    
    Without this change on rk3288-veyron-minnie I periodically see this in
    the logs of a machine just sitting there idle:
      dwmmc_rockchip ff0d0000.dwmmc: Successfully tuned phase to XYZ
    
    Cc: stable@vger.kernel.org #v4.18+
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 43d0f0c496f6..ecb7972e2423 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -398,6 +398,7 @@ struct mmc_host {
 	unsigned int		retune_now:1;	/* do re-tuning at next req */
 	unsigned int		retune_paused:1; /* re-tuning is temporarily disabled */
 	unsigned int		use_blk_mq:1;	/* use blk-mq */
+	unsigned int		retune_crc_disable:1; /* don't trigger retune upon crc */
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */

commit 3958790e673244ec3b0c62197b7372af303f1351
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 13 18:42:06 2019 +0100

    mmc: core: Convert mmc_regulator_get_ocrmask() to static
    
    The only left user of mmc_regulator_get_ocrmask() is the mmc core itself.
    Therefore, let's drop the export and turn it into static.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 7f93747c8cdc..43d0f0c496f6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -507,17 +507,11 @@ void sdio_run_irqs(struct mmc_host *host);
 void sdio_signal_irq(struct mmc_host *host);
 
 #ifdef CONFIG_REGULATOR
-int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			struct regulator *supply,
 			unsigned short vdd_bit);
 int mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios);
 #else
-static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
-{
-	return 0;
-}
-
 static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
 				 struct regulator *supply,
 				 unsigned short vdd_bit)

commit de13d5a44e61366ab5b75c111449ca284b6e3f5d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 13 18:10:37 2019 +0100

    mmc: core: Move regulator helpers to separate file
    
    The mmc regulator helper functions, are placed in the extensive core.c
    file.  In a step towards trying to create a better structure of files,
    avoiding too many lines of code per file, let's move these helpers to a new
    file, regulator.c.
    
    Moreover, this within this context it makes sense to also drop the export
    of mmc_vddrange_to_ocrmask(), but instead let's make it internal to the mmc
    core.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d893902b2f1c..7f93747c8cdc 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -532,7 +532,6 @@ static inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,
 }
 #endif
 
-u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
 int mmc_regulator_get_supply(struct mmc_host *mmc);
 
 static inline int mmc_card_is_removable(struct mmc_host *host)

commit c58ccf2b6de7d52994f9bb93227dfabf8077de24
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Feb 3 09:27:00 2019 +0100

    mmc: bcm2835: Drop pointer to mmc_host from bcm2835_host
    
    The BCM2835 MMC host driver uses a pointer to get from the private
    bcm2835_host structure to the generic mmc_host structure.  However the
    latter is always immediately preceding the former in memory, so compute
    its address with a subtraction (which is cheaper than a dereference) and
    drop the superfluous pointer.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: Frank Pavlic <f.pavlic@kunbus.de>
    Cc: Alexander Graf <agraf@suse.de>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4d35ff36ceff..d893902b2f1c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -478,6 +478,11 @@ static inline void *mmc_priv(struct mmc_host *host)
 	return (void *)host->private;
 }
 
+static inline struct mmc_host *mmc_from_priv(void *priv)
+{
+	return container_of(priv, struct mmc_host, private);
+}
+
 #define mmc_host_is_spi(host)	((host)->caps & MMC_CAP_SPI)
 
 #define mmc_dev(x)	((x)->parent)

commit 7d5ef512575663695cf85f3aeb985a0aeb03e364
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 31 11:40:38 2018 +0200

    mmc: core: Introduce MMC_CAP_SYNC_RUNTIME_PM
    
    To allow mmc host drivers to inform the mmc core about rather using
    pm_runtime_put_sync_suspend() instead of pm_runtime_put_autosuspend(),
    let's introduce MMC_CAP_SYNC_RUNTIME_PM.
    
    This is especially useful for those mmc host drivers that don't benefit
    from using the runtime PM autosuspend feature. Typically this is those that
    relies on parent devices to power the card via runtime PM, like some USB
    host drivers for example.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Oleksandr Natalenko <oleksandr@natalenko.name>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2709c94d9d86..4d35ff36ceff 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -334,7 +334,7 @@ struct mmc_host {
 #define MMC_CAP_UHS		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | \
 				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | \
 				 MMC_CAP_UHS_DDR50)
-/* (1 << 21) is free for reuse */
+#define MMC_CAP_SYNC_RUNTIME_PM	(1 << 21)	/* Synced runtime PM suspends. */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit cc14eec0889bb06abab3d6ea1e0e0676521542c8
Author: Yinbo Zhu <yinbo.zhu@nxp.com>
Date:   Fri Nov 23 11:15:33 2018 +0800

    mmc: core: Add ->hs400_prepare_ddr() callback
    
    Some eMMC controllers need specific settings for HS400 mode before the
    speed mode can be switched to DDR mode, during the HS400 initialization
    sequence. For that reason, let's introduce a new host callback,
    ->hs400_prepare_ddr() and invoked it just before switching to DDR mode.
    
    Signed-off-by: Yinbo Zhu <yinbo.zhu@nxp.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2a5fe75dd082..2709c94d9d86 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -147,6 +147,9 @@ struct mmc_host_ops {
 	/* Prepare HS400 target operating frequency depending host driver */
 	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
 
+	/* Prepare switch to DDR during the HS400 init sequence */
+	int	(*hs400_prepare_ddr)(struct mmc_host *host);
+
 	/* Prepare for switching from HS400 to HS200 */
 	void	(*hs400_downgrade)(struct mmc_host *host);
 

commit cbf6d82cad4a507475d92d380228302fe668dd94
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Thu Aug 30 01:32:05 2018 +0200

    mmc: core: add helper to see if a host is doing a retune
    
    Add a helper to allow host drivers checking if a retune is in progress.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index beed7121c781..2a5fe75dd082 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -569,6 +569,11 @@ static inline bool mmc_can_retune(struct mmc_host *host)
 	return host->can_retune == 1;
 }
 
+static inline bool mmc_doing_retune(struct mmc_host *host)
+{
+	return host->doing_retune == 1;
+}
+
 static inline enum dma_data_direction mmc_get_dma_dir(struct mmc_data *data)
 {
 	return data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE;

commit 29772f8a73d88a5de648177d9d822055ab7d1ba6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 26 16:51:31 2018 +0200

    mmc: core: Drop the unused mmc_power_save|restore_host()
    
    The last user of mmc_power_save|restore_host() APIs is gone, hence let's
    drop them. Drop also the corresponding bus_ops callback,
    ->power_save|restore() as those becomes redundant.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Eyal Reizer <eyalreizer@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a39e2925c84c..beed7121c781 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -481,9 +481,6 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
-int mmc_power_save_host(struct mmc_host *host);
-int mmc_power_restore_host(struct mmc_host *host);
-
 void mmc_detect_change(struct mmc_host *, unsigned long delay);
 void mmc_request_done(struct mmc_host *, struct mmc_request *);
 void mmc_command_done(struct mmc_host *host, struct mmc_request *mrq);

commit ba6c7ac3a2f421635ae4446269526359d8bff721
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Mon Jun 18 14:57:49 2018 +0200

    mmc: core: more fine-grained hooks for HS400 tuning
    
    This adds two new HS400 tuning operations:
    * hs400_downgrade
    * hs400_complete
    
    These supplement the existing HS400 operation:
    * prepare_hs400_tuning
    
    This is motivated by a requirement of Renesas SDHI for the following:
    1. Disabling SCC before selecting to HS if selection of HS400 has occurred.
       This can be done in an implementation of prepare_hs400_tuning_downgrade
    2. Updating registers after switching to HS400
       This can be done in an implementation of complete_hs400_tuning
    
    If hs400_downgrade or hs400_complete are not implemented then they are not
    called. Thus means there should be no affect for existing drivers as none
    implemt these ops.
    
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 64300a48dcce..a39e2925c84c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -146,6 +146,13 @@ struct mmc_host_ops {
 
 	/* Prepare HS400 target operating frequency depending host driver */
 	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
+
+	/* Prepare for switching from HS400 to HS200 */
+	void	(*hs400_downgrade)(struct mmc_host *host);
+
+	/* Complete selection of HS400 */
+	void	(*hs400_complete)(struct mmc_host *host);
+
 	/* Prepare enhanced strobe depending host driver */
 	void	(*hs400_enhanced_strobe)(struct mmc_host *host,
 					 struct mmc_ios *ios);

commit 6d796c68cd15234a33a4bd2ef7231125fea2dc6c
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Tue May 8 09:04:20 2018 +0800

    mmc: core: add tunable delay waiting for power to be stable
    
    The hard-coded 10ms delay in mmc_power_up came from
    commit 79bccc5aefb4 ("mmc: increase power up delay"), which said "The TI
    controller on Toshiba Tecra M5 needs more time to power up or the cards
    will init incorrectly or not at all." But it's too engineering solution
    for a special board but force all platforms to wait for that long time,
    especially painful for mmc_power_up for eMMC when booting.
    
    However, it's added since 2009, and we can't tell if other platforms
    benefit from it. But in practise, the modern hardware are most likely to
    have a stable power supply with 1ms after setting it for no matter PMIC
    or discrete power. And more importnatly, most regulators implement the
    callback of ->set_voltage_time_sel() for regulator core to wait for
    specific period of time for the power supply to be stable, which means
    once regulator_set_voltage_* return, the power should reach the the
    minimum voltage that works for initialization. Of course, if there
    are some other ways for host to power the card, we should allow them
    to argue a suitable delay as well.
    
    With this patch, we could assign the delay from firmware, or we could
    assigne it via ->set_ios() callback from host drivers.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8f1859044db1..64300a48dcce 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -22,6 +22,7 @@
 struct mmc_ios {
 	unsigned int	clock;			/* clock rate */
 	unsigned short	vdd;
+	unsigned int	power_delay_ms;		/* waiting for stable power */
 
 /* vdd stores the bit number of the selected voltage range from below. */
 

commit 5581cfcdccf139466c3a5f2ad5f58a09a1cd76f3
Merge: bfd694d5e21c 3f4028780287
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 3 10:34:06 2018 +0200

    Merge branch 'sdhci_omap' into next
    
    Merge immutable branch for sdhci-omap to add UHS/HS200 mode support.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

commit c16bc9a7678a27ece028dcbfea8df2049a65dbec
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Fri Apr 27 17:17:14 2018 +0530

    mmc: sdhci: Disable 1.8v modes (HS200/HS400/UHS) if controller can't support 1.8v
    
    The SDHCI controller in a SoC might support HS200/HS400 (indicated
    using mmc-hs200-1_8v/mmc-hs400-1_8v dt property), but if the board is
    modeled such that the IO lines are not connected to 1.8v then
    HS200/HS400 cannot be supported. Disable HS200/HS400 if the board
    does not have 1.8v connected to the IO lines. Also Disable DDR/UHS in 1.8v
    if the IO lines are not connected to 1.8v.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 85146235231e..4e80c199c9c2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -320,6 +320,9 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_UHS		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | \
+				 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | \
+				 MMC_CAP_UHS_DDR50)
 /* (1 << 21) is free for reuse */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
@@ -345,6 +348,7 @@ struct mmc_host {
 #define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
 #define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
 				 MMC_CAP2_HS400_1_2V)
+#define MMC_CAP2_HSX00_1_8V	(MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_HS400_1_8V)
 #define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 #define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */

commit 247cfe53557524a94dd1001d19e5aa50bd5aca81
Author: Kyle Roeschley <kyle.roeschley@ni.com>
Date:   Fri Apr 13 16:54:57 2018 -0500

    mmc: core: Add capability to avoid 3.3V signaling
    
    Some SD host controllers cannot handle extended use of 3.3V signaling.
    To accommodate these controllers, add a capability that requires us to
    negotiate the voltage down from 3.3V during card initialization.
    
    Signed-off-by: Kyle Roeschley <kyle.roeschley@ni.com>
    Signed-off-by: Jennifer Dahm <jennifer.dahm@ni.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 85146235231e..7c6eaf63f5ce 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -354,6 +354,7 @@ struct mmc_host {
 #define MMC_CAP2_NO_MMC		(1 << 22)	/* Do not send (e)MMC commands during initialization */
 #define MMC_CAP2_CQE		(1 << 23)	/* Has eMMC command queue engine */
 #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
+#define MMC_CAP2_AVOID_3_3V	(1 << 25)	/* Host must negotiate down from 3.3V */
 
 	int			fixed_drv_type;	/* fixed driver type for non-removable media */
 

commit 126b62700386da782f83579e9b0431ea76c2da3d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:19 2017 +0200

    mmc: core: Remove code no longer needed after the switch to blk-mq
    
    Remove code no longer needed after the switch to blk-mq.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f3e13c50f6b0..85146235231e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -424,9 +424,6 @@ struct mmc_host {
 
 	struct dentry		*debugfs_root;
 
-	struct mmc_async_req	*areq;		/* active async req */
-	struct mmc_context_info	context_info;	/* async synchronization info */
-
 	/* Ongoing data transfer that allows commands during transfer */
 	struct mmc_request	*ongoing_mrq;
 

commit 10f21df4a23540b5da8e88d1030ff8c37818e04f
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:07 2017 +0200

    mmc: block: blk-mq: Add support for direct completion
    
    For blk-mq, add support for completing requests directly in the ->done
    callback. That means that error handling and urgent background operations
    must be handled by recovery_work in that case.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ce2075d6f429..f3e13c50f6b0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -324,6 +324,7 @@ struct mmc_host {
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
+#define MMC_CAP_DONE_COMPLETE	(1 << 27)	/* RW reqs can be completed within mmc_request_done() */
 #define MMC_CAP_CD_WAKE		(1 << 28)	/* Enable card detect wake */
 #define MMC_CAP_CMD_DURING_TFR	(1 << 29)	/* Commands during data transfer */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */

commit c3d53d0da69d127f488dc85638e9440220b268e8
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Nov 29 15:41:02 2017 +0200

    mmc: core: Add parameter use_blk_mq
    
    Until mmc has blk-mq support fully implemented and tested, add a parameter
    use_blk_mq, set to true if config option MMC_MQ_DEFAULT is selected, which
    it is by default.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e7743eca1021..ce2075d6f429 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -380,6 +380,7 @@ struct mmc_host {
 	unsigned int		doing_retune:1;	/* re-tuning in progress */
 	unsigned int		retune_now:1;	/* do re-tuning at next req */
 	unsigned int		retune_paused:1; /* re-tuning is temporarily disabled */
+	unsigned int		use_blk_mq:1;	/* use blk-mq */
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */

commit 6186d06c519e217351fac95b545f334f8582af90
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Sun Oct 15 14:46:14 2017 +0200

    mmc: parse new binding for eMMC fixed driver type
    
    Parse the new binding and store it in the host struct after doing some
    sanity checks. The code is designed to support fixed SD driver type if
    we ever need that.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c296f4351c1d..e7743eca1021 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -354,6 +354,8 @@ struct mmc_host {
 #define MMC_CAP2_CQE		(1 << 23)	/* Has eMMC command queue engine */
 #define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
 
+	int			fixed_drv_type;	/* fixed driver type for non-removable media */
+
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
 	/* host specific block data */

commit 72a5af554df837e373efb0d6c8fc68c568f9a7ac
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:52 2017 +0300

    mmc: core: Add support for handling CQE requests
    
    Add core support for handling CQE requests, including starting, completing
    and recovering.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 443f7a8cdfe5..c296f4351c1d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -474,6 +474,8 @@ void mmc_detect_change(struct mmc_host *, unsigned long delay);
 void mmc_request_done(struct mmc_host *, struct mmc_request *);
 void mmc_command_done(struct mmc_host *host, struct mmc_request *mrq);
 
+void mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq);
+
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);

commit 6c0cedd1ef9527ef13e66875746570e76a3188a7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 22 15:36:51 2017 +0300

    mmc: core: Introduce host claiming by context
    
    Currently the host can be claimed by a task.  Change this so that the host
    can be claimed by a context that may or may not be a task.  This provides
    for the host to be claimed by a block driver queue to support blk-mq, while
    maintaining compatibility with the existing use of mmc_claim_host().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9a43763a68ad..443f7a8cdfe5 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -255,6 +255,10 @@ struct mmc_supply {
 	struct regulator *vqmmc;	/* Optional Vccq supply */
 };
 
+struct mmc_ctx {
+	struct task_struct *task;
+};
+
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -388,8 +392,9 @@ struct mmc_host {
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
-	struct task_struct	*claimer;	/* task that has host claimed */
+	struct mmc_ctx		*claimer;	/* context that has host claimed */
 	int			claim_cnt;	/* "claim" nesting count */
+	struct mmc_ctx		default_ctx;	/* default context */
 
 	struct delayed_work	detect;
 	int			detect_change;	/* card detect flag */

commit de3ee99b097dd51938276e3af388cd4ad0f2750a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 20 10:56:14 2017 +0200

    mmc: Delete bounce buffer handling
    
    In may, Steven sent a patch deleting the bounce buffer handling
    and the CONFIG_MMC_BLOCK_BOUNCE option.
    
    I chose the less invasive path of making it a runtime config
    option, and we merged that successfully for kernel v4.12.
    
    The code is however just standing in the way and taking up
    space for seemingly no gain on any systems in wide use today.
    
    Pierre says the code was there to improve speed on TI SDHCI
    controllers on certain HP laptops and possibly some Ricoh
    controllers as well. Early SDHCI controllers lacked the
    scatter-gather feature, which made software bounce buffers
    a significant speed boost.
    
    We are clearly talking about the list of SDHCI PCI-based
    MMC/SD card readers found in the pci_ids[] list in
    drivers/mmc/host/sdhci-pci-core.c.
    
    The TI SDHCI derivative is not supported by the upstream
    kernel. This leaves the Ricoh.
    
    What we can however notice is that the x86 defconfigs in the
    kernel did not enable CONFIG_MMC_BLOCK_BOUNCE option, which
    means that any such laptop would have to have a custom
    configured kernel to actually take advantage of this
    bounce buffer speed-up. It simply seems like there was
    a speed optimization for the Ricoh controllers that noone
    was using. (I have not checked the distro defconfigs but
    I am pretty sure the situation is the same there.)
    
    Bounce buffers increased performance on the OMAP HSMMC
    at one point, and was part of the original submission in
    commit a45c6cb81647 ("[ARM] 5369/1: omap mmc: Add new
       omap hsmmc controller for 2430 and 34xx, v3")
    
    This optimization was removed in
    commit 0ccd76d4c236 ("omap_hsmmc: Implement scatter-gather
       emulation")
    which found that scatter-gather emulation provided even
    better performance.
    
    The same was introduced for SDHCI in
    commit 2134a922c6e7 ("sdhci: scatter-gather (ADMA) support")
    
    I am pretty positively convinced that software
    scatter-gather emulation will do for any host controller what
    the bounce buffers were doing. Essentially, the bounce buffer
    was a reimplementation of software scatter-gather-emulation in
    the MMC subsystem, and it should be done away with.
    
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Juha Yrjola <juha.yrjola@solidboot.com>
    Cc: Steven J. Hill <Steven.Hill@cavium.com>
    Cc: Shawn Lin <shawn.lin@rock-chips.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Suggested-by: Steven J. Hill <Steven.Hill@cavium.com>
    Suggested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f3f2d07feb2a..9a43763a68ad 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -316,7 +316,7 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
-#define MMC_CAP_NO_BOUNCE_BUFF	(1 << 21)	/* Disable bounce buffers on host */
+/* (1 << 21) is free for reuse */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit d3bf68ae04c7e29ed3c30b7f4b1f0c6a4a11c7f1
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Aug 25 15:43:46 2017 +0300

    mmc: host: Add CQE interface
    
    Add CQE host operations, capabilities, and host members.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e92629518f68..f3f2d07feb2a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -162,6 +162,50 @@ struct mmc_host_ops {
 				  unsigned int direction, int blk_size);
 };
 
+struct mmc_cqe_ops {
+	/* Allocate resources, and make the CQE operational */
+	int	(*cqe_enable)(struct mmc_host *host, struct mmc_card *card);
+	/* Free resources, and make the CQE non-operational */
+	void	(*cqe_disable)(struct mmc_host *host);
+	/*
+	 * Issue a read, write or DCMD request to the CQE. Also deal with the
+	 * effect of ->cqe_off().
+	 */
+	int	(*cqe_request)(struct mmc_host *host, struct mmc_request *mrq);
+	/* Free resources (e.g. DMA mapping) associated with the request */
+	void	(*cqe_post_req)(struct mmc_host *host, struct mmc_request *mrq);
+	/*
+	 * Prepare the CQE and host controller to accept non-CQ commands. There
+	 * is no corresponding ->cqe_on(), instead ->cqe_request() is required
+	 * to deal with that.
+	 */
+	void	(*cqe_off)(struct mmc_host *host);
+	/*
+	 * Wait for all CQE tasks to complete. Return an error if recovery
+	 * becomes necessary.
+	 */
+	int	(*cqe_wait_for_idle)(struct mmc_host *host);
+	/*
+	 * Notify CQE that a request has timed out. Return false if the request
+	 * completed or true if a timeout happened in which case indicate if
+	 * recovery is needed.
+	 */
+	bool	(*cqe_timeout)(struct mmc_host *host, struct mmc_request *mrq,
+			       bool *recovery_needed);
+	/*
+	 * Stop all CQE activity and prepare the CQE and host controller to
+	 * accept recovery commands.
+	 */
+	void	(*cqe_recovery_start)(struct mmc_host *host);
+	/*
+	 * Clear the queue and call mmc_cqe_request_done() on all requests.
+	 * Requests that errored will have the error set on the mmc_request
+	 * (data->error or cmd->error for DCMD).  Requests that did not error
+	 * will have zero data bytes transferred.
+	 */
+	void	(*cqe_recovery_finish)(struct mmc_host *host);
+};
+
 struct mmc_async_req {
 	/* active mmc request */
 	struct mmc_request	*mrq;
@@ -303,6 +347,8 @@ struct mmc_host {
 #define MMC_CAP2_HS400_ES	(1 << 20)	/* Host supports enhanced strobe */
 #define MMC_CAP2_NO_SD		(1 << 21)	/* Do not send SD commands during initialization */
 #define MMC_CAP2_NO_MMC		(1 << 22)	/* Do not send (e)MMC commands during initialization */
+#define MMC_CAP2_CQE		(1 << 23)	/* Has eMMC command queue engine */
+#define MMC_CAP2_CQE_DCMD	(1 << 24)	/* CQE can issue a direct command */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
@@ -386,6 +432,13 @@ struct mmc_host {
 	int			dsr_req;	/* DSR value is valid */
 	u32			dsr;	/* optional driver stage (DSR) value */
 
+	/* Command Queue Engine (CQE) support */
+	const struct mmc_cqe_ops *cqe_ops;
+	void			*cqe_private;
+	int			cqe_qdepth;
+	bool			cqe_enabled;
+	bool			cqe_on;
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit dc8d68bb6c6f7d7fb1aeb3450c0654598e4f4e52
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Aug 10 15:08:11 2017 +0300

    mmc: core: Remove unused MMC_CAP2_PACKED_CMD
    
    Packed commands support was removed but some bits got left behind. Remove
    them.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4617c21f97f7..e92629518f68 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -291,10 +291,6 @@ struct mmc_host {
 				 MMC_CAP2_HS200_1_2V_SDR)
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
-#define MMC_CAP2_PACKED_RD	(1 << 12)	/* Allow packed read */
-#define MMC_CAP2_PACKED_WR	(1 << 13)	/* Allow packed write */
-#define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
-				 MMC_CAP2_PACKED_WR)
 #define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
 #define MMC_CAP2_HS400_1_8V	(1 << 15)	/* Can support HS400 1.8V */
 #define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */

commit 1896f14006b28a7ed6881666d18a244827af0a5b
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Jul 19 15:50:56 2017 +0800

    mmc: core: remove check of host->removed for rescan routine
    
    The intention of this check was to prevent the conflict between
    hotplug and removing driver for whatever reason. Currently it
    doesn't improve anything and the following rescan process could
    still saftly perform the scan flow. So these code seems pointless
    now and let's remove them.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ebd1cebbef0c..4617c21f97f7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -328,9 +328,6 @@ struct mmc_host {
 	unsigned int		use_spi_crc:1;
 	unsigned int		claimed:1;	/* host exclusively claimed */
 	unsigned int		bus_dead:1;	/* bus has been released */
-#ifdef CONFIG_MMC_DEBUG
-	unsigned int		removed:1;	/* host is being removed */
-#endif
 	unsigned int		can_retune:1;	/* re-tuning can be used */
 	unsigned int		doing_retune:1;	/* re-tuning in progress */
 	unsigned int		retune_now:1;	/* do re-tuning at next req */

commit 03dbaa04a2e5bac0ae907a9ed31472bc4bb56fd3
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jun 13 15:07:51 2017 +0300

    mmc: slot-gpio: Add support to enable irq wake on cd_irq
    
    Add host capability MMC_CAP_CD_WAKE to enable irq wake on the card detect
    irq.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c81380a2181f..ebd1cebbef0c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -185,6 +185,7 @@ struct mmc_async_req {
  */
 struct mmc_slot {
 	int cd_irq;
+	bool cd_wake_enabled;
 	void *handler_priv;
 };
 
@@ -275,6 +276,7 @@ struct mmc_host {
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
+#define MMC_CAP_CD_WAKE		(1 << 28)	/* Enable card detect wake */
 #define MMC_CAP_CMD_DURING_TFR	(1 << 29)	/* Commands during data transfer */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */

commit d2a47176a877b1eccd3086a4c8d790d644d594cb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jun 8 15:23:08 2017 +0200

    mmc: core: Remove MMC_CAP2_HC_ERASE_SZ
    
    The MMC_CAP2_HC_ERASE_SZ is used only by a few mmc host drivers. Its intent
    is to enable eMMC's high-capacity erase size, as to improve the behaviour
    of the erase operations.
    
    We should strive to avoid software configuration options that aren't
    necessary, but instead deploy common behaviours. For these reasons, let's
    remove the capability bit for MMC_CAP2_HC_ERASE_SZ and make it the default
    behaviour.
    
    Note that this change doesn't affect eMMCs supporting trim/discard, because
    these commands operates on sectors and takes precedence over erase
    commands.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9209f95a5106..c81380a2181f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -287,7 +287,6 @@ struct mmc_host {
 #define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
 				 MMC_CAP2_HS200_1_2V_SDR)
-#define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
 #define MMC_CAP2_PACKED_RD	(1 << 12)	/* Allow packed read */

commit c3dccb74be28a345a2ebcc224e41b774529b8b8f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:31 2017 +0200

    mmc: core: Delete bounce buffer Kconfig option
    
    This option is activated by all multiplatform configs and what
    not so we almost always have it turned on, and the memory it
    saves is negligible, even more so moving forward. The actual
    bounce buffer only gets allocated only when used, the only
    thing the ifdefs are saving is a little bit of code.
    
    It is highly improper to have this as a Kconfig option that
    get turned on by Kconfig, make this a pure runtime-thing and
    let the host decide whether we use bounce buffers. We add a
    new property "disable_bounce" to the host struct.
    
    Notice that mmc_queue_calc_bouncesz() already disables the
    bounce buffers if host->max_segs != 1, so any arch that has a
    maximum number of segments higher than 1 will have bounce
    buffers disabled.
    
    The option CONFIG_MMC_BLOCK_BOUNCE is default y so the
    majority of platforms in the kernel already have it on, and
    it then gets turned off at runtime since most of these have
    a host->max_segs > 1. The few exceptions that have
    host->max_segs == 1 and still turn off the bounce buffering
    are those that disable it in their defconfig.
    
    Those are the following:
    
    arch/arm/configs/colibri_pxa300_defconfig
    arch/arm/configs/zeus_defconfig
    - Uses MMC_PXA, drivers/mmc/host/pxamci.c
    - Sets host->max_segs = NR_SG, which is 1
    - This needs its bounce buffer deactivated so we set
      host->disable_bounce to true in the host driver
    
    arch/arm/configs/davinci_all_defconfig
    - Uses MMC_DAVINCI, drivers/mmc/host/davinci_mmc.c
    - This driver sets host->max_segs to MAX_NR_SG, which is 16
    - That means this driver anyways disabled bounce buffers
    - No special action needed for this platform
    
    arch/arm/configs/lpc32xx_defconfig
    arch/arm/configs/nhk8815_defconfig
    arch/arm/configs/u300_defconfig
    - Uses MMC_ARMMMCI, drivers/mmc/host/mmci.[c|h]
    - This driver by default sets host->max_segs to NR_SG,
      which is 128, unless a DMA engine is used, and in that case
      the number of segments are also > 1
    - That means this driver already disables bounce buffers
    - No special action needed for these platforms
    
    arch/arm/configs/sama5_defconfig
    - Uses MMC_SDHCI, MMC_SDHCI_PLTFM, MMC_SDHCI_OF_AT91, MMC_ATMELMCI
    - Uses drivers/mmc/host/sdhci.c
    - Normally sets host->max_segs to SDHCI_MAX_SEGS which is 128 and
      thus disables bounce buffers
    - Sets host->max_segs to 1 if SDHCI_USE_SDMA is set
    - SDHCI_USE_SDMA is only set by SDHCI on PCI adapers
    - That means that for this platform bounce buffers are already
      disabled at runtime
    - No special action needed for this platform
    
    arch/blackfin/configs/CM-BF533_defconfig
    arch/blackfin/configs/CM-BF537E_defconfig
    - Uses MMC_SPI (a simple MMC card connected on SPI pins)
    - Uses drivers/mmc/host/mmc_spi.c
    - Sets host->max_segs to MMC_SPI_BLOCKSATONCE which is 128
    - That means this platform already disables bounce buffers at
      runtime
    - No special action needed for these platforms
    
    arch/mips/configs/cavium_octeon_defconfig
    - Uses MMC_CAVIUM_OCTEON, drivers/mmc/host/cavium.c
    - Sets host->max_segs to 16 or 1
    - Setting host->disable_bounce to be sure for the 1 case
    
    arch/mips/configs/qi_lb60_defconfig
    - Uses MMC_JZ4740, drivers/mmc/host/jz4740_mmc.c
    - This sets host->max_segs to 128 so bounce buffers are
      already runtime disabled
    - No action needed for this platform
    
    It would be interesting to come up with a list of the platforms
    that actually end up using bounce buffers. I have not been
    able to infer such a list, but it occurs when
    host->max_segs == 1 and the bounce buffering is not explicitly
    disabled.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f186b26c05a4..9209f95a5106 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -271,6 +271,7 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_NO_BOUNCE_BUFF	(1 << 21)	/* Disable bounce buffers on host */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit 682696605c7093d2800c498c04166831e5aedf87
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 13 16:48:11 2017 +0200

    mmc: sdio: Add API to manage SDIO IRQs from a workqueue
    
    For hosts not supporting MMC_CAP2_SDIO_IRQ_NOTHREAD but MMC_CAP_SDIO_IRQ,
    the SDIO IRQs are processed from a dedicated kernel thread. For these
    cases, the host calls mmc_signal_sdio_irq() from its ISR to signal a new
    SDIO IRQ.
    
    Signaling an SDIO IRQ makes the host's ->enable_sdio_irq() callback to be
    invoked to temporary disable the IRQs, before the kernel thread is woken up
    to process it. When processing of the IRQs are completed, they are
    re-enabled by the kernel thread, again via invoking the host's
    ->enable_sdio_irq().
    
    The observation from this, is that the execution path is being unnecessary
    complex, as the host driver already knows that it needs to temporary
    disable the IRQs before signaling a new one. Moreover, replacing the kernel
    thread with a work/workqueue would not only greatly simplify the code, but
    also make it more robust.
    
    To address the above problems, let's continue to build upon the support for
    MMC_CAP2_SDIO_IRQ_NOTHREAD, as it already implements SDIO IRQs to be
    processed without using the clumsy kernel thread and without the ping-pong
    calls of the host's ->enable_sdio_irq() callback for each processed IRQ.
    
    Therefore, let's add new API sdio_signal_irq(), which enables hosts to
    signal/process SDIO IRQs by using a work/workqueue, rather than using the
    kernel thread.
    
    Add also a new host callback ->ack_sdio_irq(), which the work invokes when
    the SDIO IRQs have been processed. This informs the host about when it
    shall re-enable the SDIO IRQs. Potentially, we could re-use the existing
    ->enable_sdio_irq() callback instead of adding a new one, however it has
    turned out that it's more convenient for hosts to get this information via
    a separate callback.
    
    Hosts that wants to use this new method to signal/process SDIO IRQs, must
    enable MMC_CAP2_SDIO_IRQ_NOTHREAD and implement the ->ack_sdio_irq()
    callback.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 21385ac0c9b1..f186b26c05a4 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -130,6 +130,7 @@ struct mmc_host_ops {
 	int	(*get_cd)(struct mmc_host *host);
 
 	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);
+	void	(*ack_sdio_irq)(struct mmc_host *host);
 
 	/* optional callback for HC quirks */
 	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
@@ -358,6 +359,7 @@ struct mmc_host {
 
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
+	struct delayed_work	sdio_irq_work;
 	bool			sdio_irq_pending;
 	atomic_t		sdio_irq_thread_abort;
 
@@ -428,6 +430,7 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 }
 
 void sdio_run_irqs(struct mmc_host *host);
+void sdio_signal_irq(struct mmc_host *host);
 
 #ifdef CONFIG_REGULATOR
 int mmc_regulator_get_ocrmask(struct regulator *supply);

commit 6335d68349a85382cc55a5260d5bfda85f8e24a8
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Mar 26 20:41:32 2017 +0200

    mmc: core: add mmc_get_dma_dir
    
    Add function for determining DMA direction to core.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 83f1c4a9f03b..21385ac0c9b1 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -17,6 +17,7 @@
 #include <linux/mmc/core.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/pm.h>
+#include <linux/dma-direction.h>
 
 struct mmc_ios {
 	unsigned int	clock;			/* clock rate */
@@ -499,6 +500,11 @@ static inline bool mmc_can_retune(struct mmc_host *host)
 	return host->can_retune == 1;
 }
 
+static inline enum dma_data_direction mmc_get_dma_dir(struct mmc_data *data)
+{
+	return data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+}
+
 int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
 int mmc_abort_tuning(struct mmc_host *host, u32 opcode);
 

commit 20f921bb01140207983e9fc3af4bb60f1f9fc0d5
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Jan 25 12:04:17 2017 +0100

    mmc: core: Invent MMC_CAP_3_3V_DDR
    
    According the JEDEC specification an eMMC card supporting 1.8V vccq in DDR
    mode should also be capable of 3.3V. However, it's been reported that some
    mmc hosts supports 3.3V, but not 1.8V.
    
    Currently the mmc core implements an error handling when the host fails to
    set 1.8V for vccq, by falling back to 3.3V. Unfortunate, this seems to be
    insufficient for some mmc hosts. To enable these to use eMMC DDR mode let's
    invent a new mmc cap, MMC_CAP_3_3V_DDR, which tells whether they support
    the eMMC 3.3V DDR mode.
    
    In case MMC_CAP_3_3V_DDR is set, but not MMC_CAP_1_8V_DDR, let's change to
    remain on the 3.3V, as it's the default voltage level for vccq, set by the
    earlier power up sequence.
    
    As this change introduces MMC_CAP_3_3V_DDR, let's take the opportunity to
    do some re-formatting of the related defines in the header file.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Jan Glauber <jglauber@cavium.com>
    Tested-by: Stefan Wahren <stefan.wahren@i2se.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 97699d55b2ae..83f1c4a9f03b 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -259,17 +259,16 @@ struct mmc_host {
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 #define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
-#define MMC_CAP_1_8V_DDR	(1 << 11)	/* can support */
-						/* DDR mode at 1.8V */
-#define MMC_CAP_1_2V_DDR	(1 << 12)	/* can support */
-						/* DDR mode at 1.2V */
-#define MMC_CAP_POWER_OFF_CARD	(1 << 13)	/* Can power off after boot */
-#define MMC_CAP_BUS_WIDTH_TEST	(1 << 14)	/* CMD14/CMD19 bus width ok */
-#define MMC_CAP_UHS_SDR12	(1 << 15)	/* Host supports UHS SDR12 mode */
-#define MMC_CAP_UHS_SDR25	(1 << 16)	/* Host supports UHS SDR25 mode */
-#define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
-#define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
-#define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_3_3V_DDR	(1 << 11)	/* Host supports eMMC DDR 3.3V */
+#define MMC_CAP_1_8V_DDR	(1 << 12)	/* Host supports eMMC DDR 1.8V */
+#define MMC_CAP_1_2V_DDR	(1 << 13)	/* Host supports eMMC DDR 1.2V */
+#define MMC_CAP_POWER_OFF_CARD	(1 << 14)	/* Can power off after boot */
+#define MMC_CAP_BUS_WIDTH_TEST	(1 << 15)	/* CMD14/CMD19 bus width ok */
+#define MMC_CAP_UHS_SDR12	(1 << 16)	/* Host supports UHS SDR12 mode */
+#define MMC_CAP_UHS_SDR25	(1 << 17)	/* Host supports UHS SDR25 mode */
+#define MMC_CAP_UHS_SDR50	(1 << 18)	/* Host supports UHS SDR50 mode */
+#define MMC_CAP_UHS_SDR104	(1 << 19)	/* Host supports UHS SDR104 mode */
+#define MMC_CAP_UHS_DDR50	(1 << 20)	/* Host supports UHS DDR50 mode */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit 5857b29b96dcf208e4903ec6f20d132e6a77cac2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:15 2017 +0100

    mmc: core: Move public functions from host.h to private headers
    
    A significant amount of functions are available through the public mmc
    host.h header file. Let's slim down this public mmc interface, as to
    prevent users from abusing it, by moving some of the functions to private
    mmc host.h header file.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 7de05195bff6..97699d55b2ae 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -473,56 +473,20 @@ static inline int mmc_card_wake_sdio_irq(struct mmc_host *host)
 	return host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;
 }
 
-static inline int mmc_host_cmd23(struct mmc_host *host)
-{
-	return host->caps & MMC_CAP_CMD23;
-}
-
-static inline int mmc_boot_partition_access(struct mmc_host *host)
-{
-	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
-}
-
-static inline int mmc_host_uhs(struct mmc_host *host)
-{
-	return host->caps &
-		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
-		 MMC_CAP_UHS_DDR50);
-}
-
+/* TODO: Move to private header */
 static inline int mmc_card_hs(struct mmc_card *card)
 {
 	return card->host->ios.timing == MMC_TIMING_SD_HS ||
 		card->host->ios.timing == MMC_TIMING_MMC_HS;
 }
 
+/* TODO: Move to private header */
 static inline int mmc_card_uhs(struct mmc_card *card)
 {
 	return card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
 		card->host->ios.timing <= MMC_TIMING_UHS_DDR50;
 }
 
-static inline bool mmc_card_hs200(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
-}
-
-static inline bool mmc_card_ddr52(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
-}
-
-static inline bool mmc_card_hs400(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
-}
-
-static inline bool mmc_card_hs400es(struct mmc_card *card)
-{
-	return card->host->ios.enhanced_strobe;
-}
-
 void mmc_retune_timer_stop(struct mmc_host *host);
 
 static inline void mmc_retune_needed(struct mmc_host *host)
@@ -531,12 +495,6 @@ static inline void mmc_retune_needed(struct mmc_host *host)
 		host->need_retune = 1;
 }
 
-static inline void mmc_retune_recheck(struct mmc_host *host)
-{
-	if (host->hold_retune <= 1)
-		host->retune_now = 1;
-}
-
 static inline bool mmc_can_retune(struct mmc_host *host)
 {
 	return host->can_retune == 1;
@@ -544,7 +502,5 @@ static inline bool mmc_can_retune(struct mmc_host *host)
 
 int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
 int mmc_abort_tuning(struct mmc_host *host, u32 opcode);
-void mmc_retune_pause(struct mmc_host *host);
-void mmc_retune_unpause(struct mmc_host *host);
 
 #endif /* LINUX_MMC_HOST_H */

commit 9e1bbc72727506c173cc6ed1d704cb2d7911d9d5
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:09 2017 +0100

    mmc: core: Move some host specific public functions to host.h
    
    Ideally the public mmc header file, core.h, shouldn't contain interfaces
    particularly intended to be used by host drivers. Instead those should
    remain in the host.h header file. Therefore, let's move a couple functions
    from core.h to host.h.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8d38c76b06d6..7de05195bff6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -392,11 +392,14 @@ struct mmc_host {
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
+struct device_node;
+
 struct mmc_host *mmc_alloc_host(int extra, struct device *);
 int mmc_add_host(struct mmc_host *);
 void mmc_remove_host(struct mmc_host *);
 void mmc_free_host(struct mmc_host *);
 int mmc_of_parse(struct mmc_host *host);
+int mmc_of_parse_voltage(struct device_node *np, u32 *mask);
 
 static inline void *mmc_priv(struct mmc_host *host)
 {
@@ -452,6 +455,7 @@ static inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,
 }
 #endif
 
+u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
 int mmc_regulator_get_supply(struct mmc_host *mmc);
 
 static inline int mmc_card_is_removable(struct mmc_host *host)
@@ -538,6 +542,8 @@ static inline bool mmc_can_retune(struct mmc_host *host)
 	return host->can_retune == 1;
 }
 
+int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
+int mmc_abort_tuning(struct mmc_host *host, u32 opcode);
 void mmc_retune_pause(struct mmc_host *host);
 void mmc_retune_unpause(struct mmc_host *host);
 

commit 8da007348bf52a91e5137d27d7dcd528edbb80ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:06 2017 +0100

    mmc: core: First step in cleaning up public mmc header files
    
    This is the first step in cleaning up the public mmc header files. In this
    change we makes sure each header file builds standalone, as that helps to
    resolve dependencies.
    
    While changing this, it also seems reasonable to stop including other
    headers from inside a header itself which it don't depend upon.
    Additionally, in some cases such dependencies are better resolved by
    forward declaring the needed struct.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8bc884121465..8d38c76b06d6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -10,16 +10,12 @@
 #ifndef LINUX_MMC_HOST_H
 #define LINUX_MMC_HOST_H
 
-#include <linux/leds.h>
-#include <linux/mutex.h>
-#include <linux/timer.h>
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/card.h>
-#include <linux/mmc/mmc.h>
 #include <linux/mmc/pm.h>
 
 struct mmc_ios {
@@ -82,6 +78,8 @@ struct mmc_ios {
 	bool enhanced_strobe;			/* hs400es selection */
 };
 
+struct mmc_host;
+
 struct mmc_host_ops {
 	/*
 	 * It is optional for the host to implement pre_req and post_req in
@@ -162,9 +160,6 @@ struct mmc_host_ops {
 				  unsigned int direction, int blk_size);
 };
 
-struct mmc_card;
-struct device;
-
 struct mmc_async_req {
 	/* active mmc request */
 	struct mmc_request	*mrq;

commit e0097cf5f2f1b7b8a594beaa32a604776d3ca6ce
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Nov 29 12:09:10 2016 +0200

    mmc: queue: Fix queue thread wake-up
    
    The only time the driver sleeps expecting to be woken upon the arrival of
    a new request, is when the dispatch queue is empty. The only time that it
    is known whether the dispatch queue is empty is after NULL is returned
    from blk_fetch_request() while under the queue lock.
    
    Recognizing those facts, simplify the synchronization between the queue
    thread and the request function. A couple of flags tell the request
    function what to do, and the queue lock and barriers associated with
    wake-ups ensure synchronization.
    
    The result is simpler and allows the removal of the context_info lock.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Harjani Ritesh <riteshh@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2ce32fefb41c..8bc884121465 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -197,14 +197,12 @@ struct mmc_slot {
  * @is_new_req		wake up reason was new request
  * @is_waiting_last_req	mmc context waiting for single running request
  * @wait		wait queue
- * @lock		lock to protect data fields
  */
 struct mmc_context_info {
 	bool			is_done_rcv;
 	bool			is_new_req;
 	bool			is_waiting_last_req;
 	wait_queue_head_t	wait;
-	spinlock_t		lock;
 };
 
 struct regulator;

commit 03d640ae1f9b24b1d2a11f747143a1ecc0745019
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 25 10:35:00 2016 +0100

    mmc: block: delete packed command support
    
    I've had it with this code now.
    
    The packed command support is a complex hurdle in the MMC/SD block
    layer, around 500+ lines of code which was introduced in 2013 in
    
    commit ce39f9d17c14 ("mmc: support packed write command for eMMC4.5
    devices")
    commit abd9ac144947 ("mmc: add packed command feature of eMMC4.5")
    
    ...and since then it has been rotting. The original author of the
    code has disappeared from the community and the mail address is
    bouncing.
    
    For the code to be exercised the host must flag that it supports
    packed commands, so in mmc_blk_prep_packed_list() which is called for
    every single request, the following construction appears:
    
    u8 max_packed_rw = 0;
    
    if ((rq_data_dir(cur) == WRITE) &&
        mmc_host_packed_wr(card->host))
            max_packed_rw = card->ext_csd.max_packed_writes;
    
    if (max_packed_rw == 0)
        goto no_packed;
    
    This has the following logical deductions:
    
    - Only WRITE commands can really be packed, so the solution is
      only half-done: we support packed WRITE but not packed READ.
      The packed command support has not been finalized by supporting
      reads in three years!
    
    - mmc_host_packed_wr() is just a static inline that checks
      host->caps2 & MMC_CAP2_PACKED_WR. The problem with this is
      that NO upstream host sets this capability flag! No driver
      in the kernel is using it, and we can't test it. Packed
      command may be supported in out-of-tree code, but I doubt
      it. I doubt that the code is even working anymore due to
      other refactorings in the MMC block layer, who would
      notice if patches affecting it broke packed commands?
      No one.
    
    - There is no Device Tree binding or code to mark a host as
      supporting packed read or write commands, just this flag
      in caps2, so for sure there are not any DT systems using
      it either.
    
    It has other problems as well: mmc_blk_prep_packed_list() is
    speculatively picking requests out of the request queue with
    blk_fetch_request() making the MMC/SD stack harder to convert
    to the multiqueue block layer. By this we get rid of an
    obstacle.
    
    The way I see it this is just cruft littering the MMC/SD
    stack.
    
    Cc: Namjae Jeon <namjae.jeon@samsung.com>
    Cc: Maya Erez <qca_merez@qca.qualcomm.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2a6418d0c343..2ce32fefb41c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -494,11 +494,6 @@ static inline int mmc_host_uhs(struct mmc_host *host)
 		 MMC_CAP_UHS_DDR50);
 }
 
-static inline int mmc_host_packed_wr(struct mmc_host *host)
-{
-	return host->caps2 & MMC_CAP2_PACKED_WR;
-}
-
 static inline int mmc_card_hs(struct mmc_card *card)
 {
 	return card->host->ios.timing == MMC_TIMING_SD_HS ||

commit d3c6aac3bdfe97b8b44db6a8aba59786cb9531dc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 23 11:02:24 2016 +0100

    mmc: delete is_first_req parameter from pre-request callback
    
    The void (*pre_req) callback in the struct mmc_host_ops vtable
    is passing an argument "is_first_req" indicating whether this is
    the first request or not.
    
    None of the in-kernel users use this parameter: instead, since
    they all just do variants of dma_map* they use the DMA cookie
    to indicate whether a pre* callback has already been done for
    a request when they decide how to handle it.
    
    Delete the parameter from the callback and all users, as it is
    just pointless cruft.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 68639295148d..2a6418d0c343 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -93,8 +93,7 @@ struct mmc_host_ops {
 	 */
 	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
 			    int err);
-	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
-			   bool is_first_req);
+	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 
 	/*

commit c820af5f18ec248b3cb61a9a9ce47ef0f2e9ec63
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Thu Nov 3 15:15:59 2016 +0100

    mmc: core: Add helper to see if a host can be retuned
    
    This is in preparation for restoring saved tuning parameters
    when resuming the TMIO driver.
    
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Tested-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 5310f94be0ab..68639295148d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -546,6 +546,11 @@ static inline void mmc_retune_recheck(struct mmc_host *host)
 		host->retune_now = 1;
 }
 
+static inline bool mmc_can_retune(struct mmc_host *host)
+{
+	return host->can_retune == 1;
+}
+
 void mmc_retune_pause(struct mmc_host *host);
 void mmc_retune_unpause(struct mmc_host *host);
 

commit 8e8b3f514c12a3b800bba8a7766c71139ad75b89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 4 11:05:19 2016 +0100

    mmc: core: use enum mmc_blk_status properly
    
    There were several instances of code using the
    enum mmc_blk_status by arbitrarily converting it to an int and
    throwing it around to different functions. This makes the code
    hard to understand to may give rise to strange errors.
    
    Especially the function prototype mmc_start_req() had to be
    modified to take a pointer to an enum mmc_blk_status and the
    function pointer .err_check() inside struct mmc_async_req
    needed to return an enum mmc_blk_status.
    
    In every case: instead of assigning the block layer error code
    to an int, use the enum, also change the signature of all
    functions actually passing this enum to use the enum.
    
    To make it possible to use the enum everywhere applicable, move
    it to <linux/mmc/core.h> so that all code actually using it can
    also see it.
    
    An interesting case was encountered in the MMC test code which
    did not return a enum mmc_blk_status at all in the .err_check
    function supposed to check whether asynchronous requests worked
    or not: instead it returned a normal -ERROR or even the test
    frameworks internal error codes.
    
    The test code would also pass on enum mmc_blk_status codes as
    error codes inside the test code instead of converting them
    to the local RESULT_* codes.
    
    I have tried to fix all instances properly and run some tests
    on the result.
    
    Cc: Chunyan Zhang <zhang.chunyan@linaro.org>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0b2439441cc8..5310f94be0ab 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -173,7 +173,7 @@ struct mmc_async_req {
 	 * Check error status of completed mmc request.
 	 * Returns 0 if success otherwise non zero.
 	 */
-	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
+	enum mmc_blk_status (*err_check)(struct mmc_card *, struct mmc_async_req *);
 };
 
 /**

commit 5163af5a5e2e69c9a5a854b92ffa7e2f7672dbf7
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Aug 16 13:44:11 2016 +0300

    mmc: core: Add support for sending commands during data transfer
    
    A host controller driver exposes its capability using caps flag
    MMC_CAP_CMD_DURING_TFR. A driver with that capability can accept requests
    that are marked mrq->cap_cmd_during_tfr = true. Then the driver informs the
    upper layers when the command line is available for further commands by
    calling mmc_command_done(). Because of that, the driver will not then
    automatically send STOP commands, and it is the responsibility of the upper
    layer to send a STOP command if it is required.
    
    For requests submitted through the mmc_wait_for_req() interface, the caller
    sets mrq->cap_cmd_during_tfr = true which causes mmc_wait_for_req() in fact
    not to wait. The caller can then send commands that do not use the data
    lines. Finally the caller can wait for the transfer to complete by calling
    mmc_wait_for_req_done() which is now exported.
    
    For requests submitted through the mmc_start_req() interface, the caller
    again sets mrq->cap_cmd_during_tfr = true, but mmc_start_req() anyway does
    not wait. The caller can then send commands that do not use the data
    lines. Finally the caller can wait for the transfer to complete in the
    normal way i.e. calling mmc_start_req() again.
    
    Irrespective of how a cap_cmd_during_tfr request is started,
    mmc_is_req_done() can be called if the upper layer needs to determine if
    the request is done. However the appropriate waiting function (either
    mmc_wait_for_req_done() or mmc_start_req()) must still be called.
    
    The implementation consists primarily of a new completion
    mrq->cmd_completion which notifies when the command line is available for
    further commands. That completion is completed by mmc_command_done().
    When there is an ongoing data transfer, calls to mmc_wait_for_req() will
    automatically wait on that completion, so the caller does not have to do
    anything special.
    
    Note, in the case of errors, the driver may call mmc_request_done() without
    calling mmc_command_done() because mmc_request_done() always calls
    mmc_command_done().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index aa4bfbf129e4..0b2439441cc8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -281,6 +281,7 @@ struct mmc_host {
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
+#define MMC_CAP_CMD_DURING_TFR	(1 << 29)	/* Commands during data transfer */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 
@@ -382,6 +383,9 @@ struct mmc_host {
 	struct mmc_async_req	*areq;		/* active async req */
 	struct mmc_context_info	context_info;	/* async synchronization info */
 
+	/* Ongoing data transfer that allows commands during transfer */
+	struct mmc_request	*ongoing_mrq;
+
 #ifdef CONFIG_FAIL_MMC_REQUEST
 	struct fault_attr	fail_mmc_request;
 #endif
@@ -418,6 +422,7 @@ int mmc_power_restore_host(struct mmc_host *host);
 
 void mmc_detect_change(struct mmc_host *, unsigned long delay);
 void mmc_request_done(struct mmc_host *, struct mmc_request *);
+void mmc_command_done(struct mmc_host *host, struct mmc_request *mrq);
 
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {

commit a0c3b68c72a355f5dab33c3ddcd257e5a718de0c
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Fri Jul 1 15:45:28 2016 +0800

    mmc: core: Allow hosts to specify non-support for MMC commands
    
    Host drivers which needs to valdiate for non-supported MMC
    commands and returnn error code for such requests.
    
    To improve and simplify the behaviour, let's invent MMC_CAP2_NO_MMC
    which these host drivers can set to tell the mmc core to skip sending MMC
    commands during card initialization.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c22476d23b84..aa4bfbf129e4 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -310,6 +310,7 @@ struct mmc_host {
 #define MMC_CAP2_NO_SDIO	(1 << 19)	/* Do not send SDIO commands during initialization */
 #define MMC_CAP2_HS400_ES	(1 << 20)	/* Host supports enhanced strobe */
 #define MMC_CAP2_NO_SD		(1 << 21)	/* Do not send SD commands during initialization */
+#define MMC_CAP2_NO_MMC		(1 << 22)	/* Do not send (e)MMC commands during initialization */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 1b8d79c5494484d140f2a19101412b51e2d5f6b5
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Jun 21 15:12:46 2016 +0200

    mmc: core: Allow hosts to specify non-support for SD commands
    
    There are host drivers which needs to valdiate for non-supported SD
    commands and returnn error code for such requests.
    
    To improve and simplify the behaviour, let's invent MMC_CAP2_NO_SD
    which these host drivers can set to tell the mmc core to skip sending SD
    commands during card initialization.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d72c0c34c21d..c22476d23b84 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -309,6 +309,7 @@ struct mmc_host {
 #define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */
 #define MMC_CAP2_NO_SDIO	(1 << 19)	/* Do not send SDIO commands during initialization */
 #define MMC_CAP2_HS400_ES	(1 << 20)	/* Host supports enhanced strobe */
+#define MMC_CAP2_NO_SD		(1 << 21)	/* Do not send SD commands during initialization */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 81ac2af65793ecfbd79875d45043ff4adc0982b8
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu May 26 09:56:22 2016 +0800

    mmc: core: implement enhanced strobe support
    
    Controllers use data strobe line to latch data from devices
    under hs400 mode, but not for cmd line. So since emmc 5.1, JEDEC
    introduces enhanced strobe mode for latching cmd response from
    emmc devices to host controllers. This new feature is optional,
    so it depends both on device's cap and host's cap to decide
    whether to use it or not.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b836a271e2df..d72c0c34c21d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -19,6 +19,7 @@
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
 #include <linux/mmc/pm.h>
 
 struct mmc_ios {
@@ -77,6 +78,8 @@ struct mmc_ios {
 #define MMC_SET_DRIVER_TYPE_A	1
 #define MMC_SET_DRIVER_TYPE_C	2
 #define MMC_SET_DRIVER_TYPE_D	3
+
+	bool enhanced_strobe;			/* hs400es selection */
 };
 
 struct mmc_host_ops {
@@ -143,6 +146,9 @@ struct mmc_host_ops {
 
 	/* Prepare HS400 target operating frequency depending host driver */
 	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
+	/* Prepare enhanced strobe depending host driver */
+	void	(*hs400_enhanced_strobe)(struct mmc_host *host,
+					 struct mmc_ios *ios);
 	int	(*select_drive_strength)(struct mmc_card *card,
 					 unsigned int max_dtr, int host_drv,
 					 int card_drv, int *drv_type);
@@ -514,6 +520,11 @@ static inline bool mmc_card_hs400(struct mmc_card *card)
 	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
 }
 
+static inline bool mmc_card_hs400es(struct mmc_card *card)
+{
+	return card->host->ios.enhanced_strobe;
+}
+
 void mmc_retune_timer_stop(struct mmc_host *host);
 
 static inline void mmc_retune_needed(struct mmc_host *host)

commit ef29c0e273b874018f1802d12957d22008138240
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu May 26 09:56:12 2016 +0800

    mmc: core: add mmc-hs400-enhanced-strobe support
    
    This patch introduce mmc-hs400-enhanced-strobe for platforms
    which want to enable enhanced strobe function from DT if the
    mmc host controller claims to support enhanced strobe.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 45cde8cd39f2..b836a271e2df 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -302,6 +302,7 @@ struct mmc_host {
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 #define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */
 #define MMC_CAP2_NO_SDIO	(1 << 19)	/* Do not send SDIO commands during initialization */
+#define MMC_CAP2_HS400_ES	(1 << 20)	/* Host supports enhanced strobe */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 7ff2760999a86e4d2b1af93dcf0f0d336c309571
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon May 16 15:35:24 2016 +0300

    mmc: core: Add a facility to "pause" re-tuning
    
    Re-tuning is not possible when switched to the RPMB
    partition.  However re-tuning should not be needed
    if re-tuning is done immediately before switching,
    a small set of operations is done, and then we
    immediately switch back to the main partition.
    
    To ensure that re-tuning can't be done for a short
    while, add a facility to "pause" re-tuning.
    
    The existing facility to hold / release re-tuning
    is used but it also flags re-tuning as needed to cause
    re-tuning before the next command (which will be the
    switch to RPMB).
    
    We also need to "unpause" in the recovery path, which
    is catered for by adding it to mmc_retune_disable().
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 85800b48241f..45cde8cd39f2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -329,6 +329,7 @@ struct mmc_host {
 	unsigned int		can_retune:1;	/* re-tuning can be used */
 	unsigned int		doing_retune:1;	/* re-tuning in progress */
 	unsigned int		retune_now:1;	/* do re-tuning at next req */
+	unsigned int		retune_paused:1; /* re-tuning is temporarily disabled */
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
@@ -526,4 +527,7 @@ static inline void mmc_retune_recheck(struct mmc_host *host)
 		host->retune_now = 1;
 }
 
+void mmc_retune_pause(struct mmc_host *host);
+void mmc_retune_unpause(struct mmc_host *host);
+
 #endif /* LINUX_MMC_HOST_H */

commit 93b6911ac1ffc1fc9aba92c9e19063d47e7cf236
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Apr 1 17:44:36 2016 +0200

    mmc: host: add note that set_ios needs to handle 0Hz properly
    
    While here, refactor the comments so that they are before the
    declaration they are referring to.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8dd4d290ab0d..85800b48241f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -93,28 +93,39 @@ struct mmc_host_ops {
 	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
 			   bool is_first_req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+
+	/*
+	 * Avoid calling the next three functions too often or in a "fast
+	 * path", since underlaying controller might implement them in an
+	 * expensive and/or slow way. Also note that these functions might
+	 * sleep, so don't call them in the atomic contexts!
+	 */
+
+	/*
+	 * Notes to the set_ios callback:
+	 * ios->clock might be 0. For some controllers, setting 0Hz
+	 * as any other frequency works. However, some controllers
+	 * explicitly need to disable the clock. Otherwise e.g. voltage
+	 * switching might fail because the SDCLK is not really quiet.
+	 */
+	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
+
 	/*
-	 * Avoid calling these three functions too often or in a "fast path",
-	 * since underlaying controller might implement them in an expensive
-	 * and/or slow way.
-	 *
-	 * Also note that these functions might sleep, so don't call them
-	 * in the atomic contexts!
-	 *
 	 * Return values for the get_ro callback should be:
 	 *   0 for a read/write card
 	 *   1 for a read-only card
 	 *   -ENOSYS when not supported (equal to NULL callback)
 	 *   or a negative errno value when something bad happened
-	 *
+	 */
+	int	(*get_ro)(struct mmc_host *host);
+
+	/*
 	 * Return values for the get_cd callback should be:
 	 *   0 for a absent card
 	 *   1 for a present card
 	 *   -ENOSYS when not supported (equal to NULL callback)
 	 *   or a negative errno value when something bad happened
 	 */
-	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
-	int	(*get_ro)(struct mmc_host *host);
 	int	(*get_cd)(struct mmc_host *host);
 
 	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);

commit 100a606d54a087cfec54efbedba72f36e5a9cdf0
Author: Carlo Caione <carlo@endlessm.com>
Date:   Wed Nov 25 15:39:51 2015 +0100

    mmc: core: Introduce MMC_CAP2_NO_SDIO cap
    
    This patch introduce a new MMC_CAP2_NO_SDIO cap used to tell the mmc
    core to not send SDIO specific commands.
    
    Signed-off-by: Carlo Caione <carlo@endlessm.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f39888cf5017..8dd4d290ab0d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -290,6 +290,7 @@ struct mmc_host {
 #define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 #define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */
+#define MMC_CAP2_NO_SDIO	(1 << 19)	/* Do not send SDIO commands during initialization */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 8dede18e2e86c8e272cd74e66b0e86872cbe7e02
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:11:12 2015 +0100

    mmc: core: Refactor code to register the MMC PM notifier
    
    Instead of checking for "#ifdef" directly in the code, let's invent a pair
    of mmc core functions to deal with register/unregister the MMC PM notifier
    block. Implement stubs for these functions when CONFIG_PM_SLEEP is unset,
    as in that case the PM notifiers isn't used.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9b04e717bb86..f39888cf5017 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -212,7 +212,9 @@ struct mmc_host {
 	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
+#ifdef CONFIG_PM_SLEEP
 	struct notifier_block	pm_notify;
+#endif
 	u32			max_current_330;
 	u32			max_current_300;
 	u32			max_current_180;
@@ -433,8 +435,6 @@ static inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,
 
 int mmc_regulator_get_supply(struct mmc_host *mmc);
 
-int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
-
 static inline int mmc_card_is_removable(struct mmc_host *host)
 {
 	return !(host->caps & MMC_CAP_NONREMOVABLE);

commit 7b6471a968bf95e8d526393de125df3bc0c6a73a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Nov 5 16:01:33 2015 +0100

    mmc: core: Remove MMC_CAP_RUNTIME_RESUME as it's redundant
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8673ffe3d86e..9b04e717bb86 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -259,7 +259,6 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
-#define MMC_CAP_RUNTIME_RESUME	(1 << 20)	/* Resume at runtime_resume. */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit 2086f801cb2a796279e817e68255654c4cfd3be3
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Oct 12 14:48:25 2015 +0200

    mmc: core: Add mmc_regulator_set_vqmmc()
    
    This adds logic to the MMC core to set VQMMC.  This is expected to be
    called by MMC drivers like dw_mmc as part of (or instead of) their
    start_signal_voltage_switch() callback.
    
    A few notes:
    
    * When setting the signal voltage to 3.3V we do our best to make VQMMC
      and VMMC match.  It's been reported that this makes some old cards
      happy since they were tested back in the day before UHS when VQMMC
      and VMMC were provided by the same regulator.  A nice side effect of
      this is that we don't end up on the hairy edge of VQMMC (2.7V),
      which some EEs claim is a little too close to the minimum for
      comfort.
      This is done in two steps. At first we try to find a VQMMC within
      a 0.3V tolerance of VMMC and if this is not supported by the
      supplying regulator we try to find a suitable voltage within the
      whole 2.7V-3.6V area of the spec.
    
    * The two step approach is currently necessary, as the used
      regulator_set_voltage_triplet(min, target, max) uses a simple
      implementation that just tries two basic steps:
            regulator_set_voltage(target, max);
            regulator_set_voltage(min, target);
      So with only one step with 2.7-3.6V borders, if a suitable voltage
      is a bit below VMMC, we would directly get the lowest 2.7V
      which some boards (like Rockchips) don't like at all.
    
    * When setting the signal voltage to 1.8V or 1.2V we aim for that
      specific voltage instead of picking the lowest one in the range.
    
    * We very purposely don't print errors in mmc_regulator_set_vqmmc().
      There are cases where the MMC core will try several different
      voltages and we don't want to pollute the logs.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cfb3c99a6b4b..8673ffe3d86e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -411,6 +411,7 @@ int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			struct regulator *supply,
 			unsigned short vdd_bit);
+int mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios);
 #else
 static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
 {
@@ -423,6 +424,12 @@ static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
 {
 	return 0;
 }
+
+static inline int mmc_regulator_set_vqmmc(struct mmc_host *mmc,
+					  struct mmc_ios *ios)
+{
+	return -EINVAL;
+}
 #endif
 
 int mmc_regulator_get_supply(struct mmc_host *mmc);

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 83b81fd865f3..cfb3c99a6b4b 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -292,18 +292,6 @@ struct mmc_host {
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
-#ifdef CONFIG_MMC_CLKGATE
-	int			clk_requests;	/* internal reference counter */
-	unsigned int		clk_delay;	/* number of MCI clk hold cycles */
-	bool			clk_gated;	/* clock gated */
-	struct delayed_work	clk_gate_work; /* delayed clock gate */
-	unsigned int		clk_old;	/* old clock value cache */
-	spinlock_t		clk_lock;	/* lock for clk fields */
-	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
-	struct device_attribute clkgate_delay_attr;
-	unsigned long           clkgate_delay;
-#endif
-
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_segs;	/* see blk_queue_max_segments */
@@ -479,26 +467,6 @@ static inline int mmc_host_packed_wr(struct mmc_host *host)
 	return host->caps2 & MMC_CAP2_PACKED_WR;
 }
 
-#ifdef CONFIG_MMC_CLKGATE
-void mmc_host_clk_hold(struct mmc_host *host);
-void mmc_host_clk_release(struct mmc_host *host);
-unsigned int mmc_host_clk_rate(struct mmc_host *host);
-
-#else
-static inline void mmc_host_clk_hold(struct mmc_host *host)
-{
-}
-
-static inline void mmc_host_clk_release(struct mmc_host *host)
-{
-}
-
-static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
-{
-	return host->ios.clock;
-}
-#endif
-
 static inline int mmc_card_hs(struct mmc_card *card)
 {
 	return card->host->ios.timing == MMC_TIMING_SD_HS ||

commit f13e5b9f3c625916d7658ba526574a5d24e4d664
Author: Yangbo Lu <yangbo.lu@freescale.com>
Date:   Fri Jul 10 11:36:45 2015 +0800

    mmc: sdio: avoid using NULL sdio_irq_thread pointer
    
    For Freescale QorIQ LS1021AQDS board, there is a SDIO interrupt
    in the process of resume without inserting SD adapter because of
    some unknown issue. But the driver doesn't assign sdio_irq_thread
    pointer. This will block the resume of kernel. This patch is used
    to avoid using NULL sdio_irq_thread pointer.
    
    Signed-off-by: Yangbo Lu <yangbo.lu@freescale.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 1369e54faeb7..83b81fd865f3 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -412,7 +412,8 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);
 	host->sdio_irq_pending = true;
-	wake_up_process(host->sdio_irq_thread);
+	if (host->sdio_irq_thread)
+		wake_up_process(host->sdio_irq_thread);
 }
 
 void sdio_run_irqs(struct mmc_host *host);

commit f168359efbb99d6f8591bb666d6510bb78df2d07
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:54 2015 +0200

    mmc: core: Add 'card' to drive strength selection callback
    
    In preparation for supporting also eMMC drive strength,
    add the 'card' as a parameter so that the callback can
    distinguish different types of cards if necessary.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index da33d18c66c8..1369e54faeb7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -132,7 +132,8 @@ struct mmc_host_ops {
 
 	/* Prepare HS400 target operating frequency depending host driver */
 	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
-	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv,
+	int	(*select_drive_strength)(struct mmc_card *card,
+					 unsigned int max_dtr, int host_drv,
 					 int card_drv, int *drv_type);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);

commit b4f30a174e1fda8118eda038b5d8d5260db36ad5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:52 2015 +0200

    mmc: core: Allow card drive strength to be different to host
    
    Initialization of UHS-I modes for SD and SDIO cards
    employs a callback to allow the host driver to
    choose a drive strength value. Currently that
    assumes the card drive strength and host driver
    type must be the same value. Change to let the
    callback make that decision and return both the
    card drive strength and host driver type.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 433eccb50838..da33d18c66c8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -132,7 +132,8 @@ struct mmc_host_ops {
 
 	/* Prepare HS400 target operating frequency depending host driver */
 	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
-	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
+	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv,
+					 int card_drv, int *drv_type);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);
 

commit 9f6e0bff2afb52a4c29f5ca8a4db01810357974e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed May 6 20:31:19 2015 +0200

    mmc: Add support for disabling write-protect detection
    
    It is not uncommon to see systems where there is no physical write-protect
    signal (e.g. when using eMMC or microSD card slots). For some controllers,
    which have a dedicated write-protection detection logic (like SDHCI
    controllers), the get_ro() callback can return bogus data in such a case.
    
    Instead of handling this on a per controller basis this patch adds a new
    capability flag to the MMC core that can be set to specify that the result
    of get_ro() is invalid. When the flag is set the core will not call
    get_ro() and assume that the card is always read-write.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f471193ef6d6..433eccb50838 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -286,6 +286,7 @@ struct mmc_host {
 				 MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
+#define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit dfa13ebbe3340e538b988f5608efd9ff2ca7fc35
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu May 7 13:10:12 2015 +0300

    mmc: host: Add facility to support re-tuning
    
    Currently, there is core support for tuning during
    initialization. There can also be a need to re-tune
    periodically (e.g. sdhci) or to re-tune after the
    host controller is powered off (e.g. after PM
    runtime suspend / resume) or to re-tune in response
    to CRC errors.
    
    The main requirements for re-tuning are:
      - ability to enable / disable re-tuning
      - ability to flag that re-tuning is needed
      - ability to re-tune before any request
      - ability to hold off re-tuning if the card is busy
      - ability to hold off re-tuning if re-tuning is in
      progress
      - ability to run a re-tuning timer
    
    To support those requirements 7 members are added to struct
    mmc_host:
    
      unsigned int          can_retune:1;   /* re-tuning can be used */
      unsigned int          doing_retune:1; /* re-tuning in progress */
      unsigned int          retune_now:1;   /* do re-tuning at next req */
      int                   need_retune;    /* re-tuning is needed */
      int                   hold_retune;    /* hold off re-tuning */
      unsigned int          retune_period;  /* re-tuning period in secs */
      struct timer_list     retune_timer;   /* for periodic re-tuning */
    
    need_retune is an integer so it can be set without needing
    synchronization. hold_retune is a integer to allow nesting.
    
    Various simple functions are provided to set / clear those
    variables.
    
    Subsequent patches take those functions into use.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b5bedaec6223..f471193ef6d6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -12,6 +12,7 @@
 
 #include <linux/leds.h>
 #include <linux/mutex.h>
+#include <linux/timer.h>
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
@@ -321,10 +322,18 @@ struct mmc_host {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int		removed:1;	/* host is being removed */
 #endif
+	unsigned int		can_retune:1;	/* re-tuning can be used */
+	unsigned int		doing_retune:1;	/* re-tuning in progress */
+	unsigned int		retune_now:1;	/* do re-tuning at next req */
 
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
 
+	int			need_retune;	/* re-tuning is needed */
+	int			hold_retune;	/* hold off re-tuning */
+	unsigned int		retune_period;	/* re-tuning period in secs */
+	struct timer_list	retune_timer;	/* for periodic re-tuning */
+
 	bool			trigger_card_event; /* card_event necessary */
 
 	struct mmc_card		*card;		/* device attached to this host */
@@ -513,4 +522,18 @@ static inline bool mmc_card_hs400(struct mmc_card *card)
 	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
 }
 
+void mmc_retune_timer_stop(struct mmc_host *host);
+
+static inline void mmc_retune_needed(struct mmc_host *host)
+{
+	if (host->can_retune)
+		host->need_retune = 1;
+}
+
+static inline void mmc_retune_recheck(struct mmc_host *host)
+{
+	if (host->hold_retune <= 1)
+		host->retune_now = 1;
+}
+
 #endif /* LINUX_MMC_HOST_H */

commit 40433267331bc6b9d70d5cdd14bfa2c8e3e5f0ec
Author: NeilBrown <neil@brown.name>
Date:   Thu Mar 26 08:43:37 2015 +1100

    mmc: core: Remove the ->enable|disable() callbacks
    
    These callbacks have been set to deprecated for some time. The last
    user (omap_hsmmc) has moved away from using them, which thus enables
    us to completely remove them.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0c8cbe5d1550..b5bedaec6223 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -79,12 +79,6 @@ struct mmc_ios {
 };
 
 struct mmc_host_ops {
-	/*
-	 * 'enable' is called when the host is claimed and 'disable' is called
-	 * when the host is released. 'enable' and 'disable' are deprecated.
-	 */
-	int (*enable)(struct mmc_host *host);
-	int (*disable)(struct mmc_host *host);
 	/*
 	 * It is optional for the host to implement pre_req and post_req in
 	 * order to support double buffering of requests (prepare one

commit 3aa8793f751d4cfcaca886e75ab30dfb00cf1d88
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Nov 28 14:38:36 2014 +0100

    mmc: core: Initial support for MMC power sequences
    
    System on chip designs may specify a specific MMC power sequence. To
    successfully detect an (e)MMC/SD/SDIO card, that power sequence must
    be followed while initializing the card.
    
    To be able to handle these SOC specific power sequences, let's add a
    MMC power sequence interface. It provides the following functions to
    help the mmc core to deal with these power sequences.
    
    mmc_pwrseq_alloc() - Invoked from mmc_of_parse(), to initialize data.
    mmc_pwrseq_pre_power_on()- Invoked in the beginning of mmc_power_up().
    mmc_pwrseq_post_power_on()- Invoked at the end in mmc_power_up().
    mmc_pwrseq_power_off()- Invoked from mmc_power_off().
    mmc_pwrseq_free() - Invoked from mmc_free_host(), to free data.
    
    Each MMC power sequence provider will be responsible to implement a set
    of callbacks. These callbacks mirrors the functions above.
    
    This patch adds the skeleton, following patches will extend the core of
    the MMC power sequence and add support for a specific simple MMC power
    sequence.
    
    Do note, since the mmc_pwrseq_alloc() is invoked from mmc_of_parse(),
    host drivers needs to make use of this API to enable the support for
    MMC power sequences. Moreover the MMC power sequence support depends on
    CONFIG_OF.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b6bf718c3498..0c8cbe5d1550 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -195,6 +195,7 @@ struct mmc_context_info {
 };
 
 struct regulator;
+struct mmc_pwrseq;
 
 struct mmc_supply {
 	struct regulator *vmmc;		/* Card power supply */
@@ -206,6 +207,7 @@ struct mmc_host {
 	struct device		class_dev;
 	int			index;
 	const struct mmc_host_ops *ops;
+	struct mmc_pwrseq	*pwrseq;
 	unsigned int		f_min;
 	unsigned int		f_max;
 	unsigned int		f_init;

commit df8aca162e5ff2b20c7a4de3e64e5b96ff838ab0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Dec 18 15:44:36 2014 +0100

    mmc: slot-gpio: Rework how to handle allocation of slot-gpio data
    
    By moving the allocation of the slot-gpio data into mmc_alloc_host(),
    we can remove the slot-gpio internal calls to mmc_gpio_alloc().
    
    This means mmc_gpio_alloc() has now only one caller left, which
    consequence allow us to simplify and remove some of the slot-gpio code.
    
    Additionally, this makes the slot-gpio mutex redundant, so let's remove
    it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9f322706f7cb..b6bf718c3498 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -166,7 +166,6 @@ struct mmc_async_req {
  * struct mmc_slot - MMC slot functions
  *
  * @cd_irq:		MMC/SD-card slot hotplug detection IRQ or -EINVAL
- * @lock:		protect the @handler_priv pointer
  * @handler_priv:	MMC/SD-card slot context
  *
  * Some MMC/SD host controllers implement slot-functions like card and
@@ -176,7 +175,6 @@ struct mmc_async_req {
  */
 struct mmc_slot {
 	int cd_irq;
-	struct mutex lock;
 	void *handler_priv;
 };
 

commit 549c0b18485d10bb419a81b24efe719df75089bd
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Nov 6 15:19:05 2014 +0200

    mmc: sdhci: Clear also HS400 1.2V capability if 1.2V is not supported
    
    1.2V HS200 mode capability is cleared if there is not a voltage
    regulator that supports 1.2V.  Do the same for 1.2V HS400 mode.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index df0c15396bbf..9f322706f7cb 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -289,6 +289,7 @@ struct mmc_host {
 #define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
 #define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
 				 MMC_CAP2_HS400_1_2V)
+#define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */

commit 8af465db967bf25a4617416c0cbaaaa506d444f5
Author: Roger Tseng <rogerable@realtek.com>
Date:   Wed Sep 24 17:07:13 2014 +0800

    mmc: core: Add new power_mode MMC_POWER_UNDEFINED
    
    Add MMC_POWER_UNDEFINED for power_mode in struct mmc_ios and use it as
    the initial value of host->ios.power_mode.
    
    For hosts with MMC_CAP2_NO_PRESCAN_POWERUP, this makes the later
    mmc_power_off() do real power-off things instead of NOP, and further
    prevents state messed up in cards that was already initialized (eg. by
    BIOS of UEFI driver).
    
    Signed-off-by: Roger Tseng <rogerable@realtek.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 797ae657dc3d..df0c15396bbf 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -42,6 +42,7 @@ struct mmc_ios {
 #define MMC_POWER_OFF		0
 #define MMC_POWER_UP		1
 #define MMC_POWER_ON		2
+#define MMC_POWER_UNDEFINED	3
 
 	unsigned char	bus_width;		/* data bus width */
 

commit 0abb71feb228ddbd17e0dfa13216541e036bb549
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Sep 8 23:46:49 2014 -0700

    mmc: remove MMC_CAP2_NO_MULTI_READ flags
    
    Now, mmc framework uses multi_io_quirk
    for I/O HW bug workaround.
    MMC_CAP2_NO_MULTI_READ flag is no longer needed
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 10e2bd6985ae..797ae657dc3d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -272,7 +272,6 @@ struct mmc_host {
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
 #define MMC_CAP2_FULL_PWR_CYCLE	(1 << 2)	/* Can do full power cycle */
-#define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
 #define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */
 #define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \

commit 2e47e84245adcb1b3872210678b6146f674fb3ff
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Sep 2 19:08:53 2014 -0700

    mmc: Add .multi_io_quirk callback for multi I/O HW bug
    
    Historically, we have been using MMC_CAP* to handle host HW issues and
    currently the block layer uses MMC_CAP2_NO_MULTI_READ flag for a multi
    I/O HW bug workaround.
    
    There are a few tweaks needed to make MMC_CAP2_NO_MULTI_READ suite all
    situations. Therefore let's add an optional host ops callback to enable
    host drivers to return the number of blocks it allows per request.
    
    In a future patch and when host drivers have converted to the new
    callback, MMC_CAP2_NO_MULTI_READ shall be removed.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4cbf61476999..10e2bd6985ae 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -139,6 +139,13 @@ struct mmc_host_ops {
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);
+
+	/*
+	 * Optional callback to support controllers with HW issues for multiple
+	 * I/O. Returns the number of supported blocks for the request.
+	 */
+	int	(*multi_io_quirk)(struct mmc_card *card,
+				  unsigned int direction, int blk_size);
 };
 
 struct mmc_card;

commit 3d705d14fe4c72be83bae1610680e209ee226b9d
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Aug 19 10:45:51 2014 +0200

    mmc: implement Driver Stage Register handling
    
    Some eMMC and SD cards implement a DSR register that allows to tune
    raise/fall times and drive strength of the CMD and DATA outputs.
    The values to use depend on the card in use and the host.
    It might be needed to reduce the drive strength to prevent voltage peaks
    above the host's specification.
    
    Implement a 'dsr' devicetree property that allows to specify the value
    to set the DSR to. For non-dt setups the new members of mmc_host can be
    set by board code.
    
    This patch was initially authored by Sascha Hauer. It contains
    improvements authored by Markus Niebel and Uwe Kleine-König.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 7960424d0bc0..4cbf61476999 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -365,6 +365,9 @@ struct mmc_host {
 
 	unsigned int		slotno;	/* used for sdio acpi binding */
 
+	int			dsr_req;	/* DSR value is valid */
+	u32			dsr;	/* optional driver stage (DSR) value */
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit bf3b5ec66bd03d66e9ea729aaca013ea1047a797
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 25 12:55:30 2014 +0100

    mmc: sdio_irq: rework sdio irq handling
    
    Rather than the SDIO support spawning it's own thread for handling card
    interrupts, use the generic IRQ infrastructure for this, triggering it
    from the host interface's interrupt handling directly.
    
    This avoids a race between the parent thread waiting to receive an
    interrupt response from the card, and the slow startup from the sdio
    irq thread, which can occur as a result of high system load (eg, while
    udev is running.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Markus Pargmann <mpa@pengutronix.de>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    [Ulf Hansson] Resolved conflict
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cd595275e118..7960424d0bc0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -282,6 +282,7 @@ struct mmc_host {
 #define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
 #define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
 				 MMC_CAP2_HS400_1_2V)
+#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
@@ -397,6 +398,8 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 	wake_up_process(host->sdio_irq_thread);
 }
 
+void sdio_run_irqs(struct mmc_host *host);
+
 #ifdef CONFIG_REGULATOR
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,

commit 4d1f52f9a9f9a63371dba589093b3ae90fc80c3d
Author: Tim Kryger <tim.kryger@linaro.org>
Date:   Tue May 6 15:57:01 2014 -0700

    mmc: core: Improve support for deferred regulators
    
    Callers of mmc_regulator_get_supply could benefit from knowing if either
    of the regulators are present but not yet available.  Since callers do
    not currently examine the return value, modify this function to return
    zero or -EPROBE_DEFER if either regulator get returns the same.
    
    Furthermore, since callers check vmmc/vqmmc using IS_ERR and can deal
    with absent regulators, switch to devm_regulator_get_optional. This has
    the added benefit of allowing this function to behave correctly even in
    the !CONFIG_REGULATOR case such that the stub can be removed.
    
    Signed-off-by: Tim Kryger <tim.kryger@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 183087374215..cd595275e118 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -402,7 +402,6 @@ int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			struct regulator *supply,
 			unsigned short vdd_bit);
-int mmc_regulator_get_supply(struct mmc_host *mmc);
 #else
 static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
 {
@@ -415,13 +414,10 @@ static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
 {
 	return 0;
 }
-
-static inline int mmc_regulator_get_supply(struct mmc_host *mmc)
-{
-	return 0;
-}
 #endif
 
+int mmc_regulator_get_supply(struct mmc_host *mmc);
+
 int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
 static inline int mmc_card_is_removable(struct mmc_host *host)

commit 0a5b6438ee482696360bb013e67b8488f63d3e9e
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:14:58 2014 +0900

    mmc: add support for HS400 mode of eMMC5.0
    
    This patch adds HS400 mode support for eMMC5.0 device.  HS400 mode is high
    speed DDR interface timing from HS200.  Clock frequency is up to 200MHz
    and only 8-bit bus width is supported. In addition, tuning process of
    HS200 is required to synchronize the command response on the CMD line
    because CMD input timing for HS400 mode is the same as HS200 mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Jackey Shen <jackey.shen@amd.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6b1e9ee6ca10..183087374215 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -61,6 +61,7 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_DDR50	7
 #define MMC_TIMING_MMC_DDR52	8
 #define MMC_TIMING_MMC_HS200	9
+#define MMC_TIMING_MMC_HS400	10
 
 	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
@@ -132,6 +133,9 @@ struct mmc_host_ops {
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
+
+	/* Prepare HS400 target operating frequency depending host driver */
+	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);
@@ -274,6 +278,10 @@ struct mmc_host {
 #define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
 				 MMC_CAP2_PACKED_WR)
 #define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
+#define MMC_CAP2_HS400_1_8V	(1 << 15)	/* Can support HS400 1.8V */
+#define MMC_CAP2_HS400_1_2V	(1 << 16)	/* Can support HS400 1.2V */
+#define MMC_CAP2_HS400		(MMC_CAP2_HS400_1_8V | \
+				 MMC_CAP2_HS400_1_2V)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
@@ -495,4 +503,10 @@ static inline bool mmc_card_ddr52(struct mmc_card *card)
 {
 	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
 }
+
+static inline bool mmc_card_hs400(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
+}
+
 #endif /* LINUX_MMC_HOST_H */

commit 2415c0ef618b3cd95581c7f633cbab78b29b7ab0
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:58 2014 +0900

    mmc: identify available device type to select
    
    Device types which are supported by both host and device can be
    identified when EXT_CSD is read. There is no need to check host's
    capability anymore.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a43853779799..6b1e9ee6ca10 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -62,12 +62,6 @@ struct mmc_ios {
 #define MMC_TIMING_MMC_DDR52	8
 #define MMC_TIMING_MMC_HS200	9
 
-#define MMC_SDR_MODE		0
-#define MMC_1_2V_DDR_MODE	1
-#define MMC_1_8V_DDR_MODE	2
-#define MMC_1_2V_SDR_MODE	3
-#define MMC_1_8V_SDR_MODE	4
-
 	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
 #define MMC_SIGNAL_VOLTAGE_330	0

commit cdc991790c51c693d0c347a5286af017826a5d01
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:35 2014 +0900

    mmc: drop the speed mode of card's state
    
    Timing mode identifier has same role and can take the place
    of speed mode. This change removes all related speed mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0cf705c83998..a43853779799 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -17,6 +17,7 @@
 #include <linux/fault-inject.h>
 
 #include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
 #include <linux/mmc/pm.h>
 
 struct mmc_ios {
@@ -478,4 +479,26 @@ static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
 	return host->ios.clock;
 }
 #endif
+
+static inline int mmc_card_hs(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_SD_HS ||
+		card->host->ios.timing == MMC_TIMING_MMC_HS;
+}
+
+static inline int mmc_card_uhs(struct mmc_card *card)
+{
+	return card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
+		card->host->ios.timing <= MMC_TIMING_UHS_DDR50;
+}
+
+static inline bool mmc_card_hs200(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
+}
+
+static inline bool mmc_card_ddr52(struct mmc_card *card)
+{
+	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
+}
 #endif /* LINUX_MMC_HOST_H */

commit fa372a51cb5f93800f711473e5a36e0e0c9a8f00
Author: Markus Mayer <markus.mayer@linaro.org>
Date:   Tue Apr 8 15:19:43 2014 -0700

    mmc: Delay the card_event callback into the mmc_rescan worker
    
    This change removes the callback from atomic context which it doesn't
    need to be in, and puts it in line with the debounced rescan.
    
    This code is based on these e-mail threads with Christian Daudt:
    
      https://lkml.org/lkml/2013/8/19/539
      https://lkml.org/lkml/2014/3/19/79
    
    Signed-off-by: Markus Mayer <markus.mayer@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 35354207e71f..0cf705c83998 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -319,6 +319,8 @@ struct mmc_host {
 	int			rescan_disable;	/* disable card detection */
 	int			rescan_entered;	/* used with nonremovable devices */
 
+	bool			trigger_card_event; /* card_event necessary */
+
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;

commit 79f7ae7c45a6ccf04e2908337461dee615f6afb0
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Mar 14 21:11:56 2014 +0900

    mmc: clarify DDR timing mode between SD-UHS and eMMC
    
    This change distinguishes DDR timing mode of current
    mixed usage to clarify device type.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cb61ea4d6945..35354207e71f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -58,7 +58,8 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_SDR50	5
 #define MMC_TIMING_UHS_SDR104	6
 #define MMC_TIMING_UHS_DDR50	7
-#define MMC_TIMING_MMC_HS200	8
+#define MMC_TIMING_MMC_DDR52	8
+#define MMC_TIMING_MMC_HS200	9
 
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1

commit 68eb80e06bfa06035d0304686124974780308fae
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Dec 18 09:57:38 2013 +0100

    mmc: core: Rename max_discard_to to max_busy_timeout
    
    Rename host->max_discard_to to host->max_busy_timeout, to reflect that
    it tells the mmc core layer about the maximum supported busy detection
    timeout by the host.
    
    This timeout is at the moment only applicable to erase/trim/discard
    commands. By the renaming we provide the option of make use of it for
    other commands that cares about busy detection. In other words, those
    commands that wants an R1B response, like for example the mmc switch
    command.
    
    Do note that the max_busy_timeout is supposed to be specified only by
    hosts supporting MMC_CAP_WAIT_WHILE_BUSY.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 719db89ef134..cb61ea4d6945 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -300,7 +300,7 @@ struct mmc_host {
 	unsigned int		max_req_size;	/* maximum number of bytes in one req */
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */
 	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
-	unsigned int		max_discard_to;	/* max. discard timeout in ms */
+	unsigned int		max_busy_timeout; /* max busy timeout in ms */
 
 	/* private data */
 	spinlock_t		lock;		/* lock for claim and bus ops */

commit 7536d3f83aa42ba1a3b1c6b30c2b6d94a820cbb2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Dec 18 11:59:17 2013 +0100

    mmc: core: Enable MMC_CAP2_CACHE_CTRL as default
    
    There are no reason to why the use of a non-volatile internal eMMC
    cache should be controlled by a host cap. Instead let's just enable it
    if the eMMC card supports it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f69bd70b1046..719db89ef134 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -264,7 +264,6 @@ struct mmc_host {
 	u32			caps2;		/* More host capabilities */
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
-#define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
 #define MMC_CAP2_FULL_PWR_CYCLE	(1 << 2)	/* Can do full power cycle */
 #define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
 #define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */

commit 10e5d9652499a8bc0a99ffc2a96a3030fee576cb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 16 16:23:22 2013 +0100

    mmc: core: Use mmc_flush_cache() during mmc suspend
    
    Earlier we disabled the cache during suspend, which meant a flush was
    internally at the eMMC performed as well.
    
    To simplify code we can make use of the mmc_flush_cache(), during mmc
    suspend, which makes the mmc_cache_ctrl() redundant so then we can
    remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4c0176a8e474..f69bd70b1046 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -385,8 +385,6 @@ int mmc_power_restore_host(struct mmc_host *host);
 void mmc_detect_change(struct mmc_host *, unsigned long delay);
 void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
-int mmc_cache_ctrl(struct mmc_host *, u8);
-
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);

commit 469a00b017a9b2c630bff962ffd64ba626977830
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 16 14:46:00 2013 +0100

    mmc: core: Remove support for MMC_CAP2_NO_SLEEP_CMD
    
    There are no active users of this host capability. The primary reason
    for adding this cap was due to a bug in ux500 boot loader code, which
    is not a relevant issue any more. So, let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 461c69f19425..4c0176a8e474 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -267,7 +267,6 @@ struct mmc_host {
 #define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
 #define MMC_CAP2_FULL_PWR_CYCLE	(1 << 2)	/* Can do full power cycle */
 #define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
-#define MMC_CAP2_NO_SLEEP_CMD	(1 << 4)	/* Don't allow sleep command */
 #define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */
 #define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \

commit 325e2f96b926ae852fa2aa5e64d1040ed9518ae1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 16 14:43:51 2013 +0100

    mmc: core: Remove unused host cap MMC_CAP2_BROKEN_VOLTAGE
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 40f832e5db40..461c69f19425 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -272,7 +272,6 @@ struct mmc_host {
 #define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
 				 MMC_CAP2_HS200_1_2V_SDR)
-#define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */

commit a2d1086de6cc3ae2378d9db8b92712911c9e5fef
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 16 14:37:26 2013 +0100

    mmc: card: Remove host cap MMC_CAP2_SANITIZE
    
    There is no need for keeping a host cap for MMC_CAP2_SANITIZE, instead
    we just make the feature default available.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2a139b2bdb9e..40f832e5db40 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -281,7 +281,6 @@ struct mmc_host {
 #define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
 				 MMC_CAP2_PACKED_WR)
 #define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
-#define MMC_CAP2_SANITIZE	(1 << 15)		/* Support Sanitize */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 2501c9179dff2add6aadd3898cd729e94e777d3a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 30 01:00:18 2013 +0100

    mmc: core: Use MMC_UNSAFE_RESUME as default behavior
    
    Invoking system suspend or shutdown without using the Kconfig option
    MMC_UNSAFE_RESUME, did trigger an ungraceful power cut of the card.
    
    To improve the situation, change the behavior to always make use of the
    available bus_ops callbacks that handles system suspend and shutdown
    properly.
    
    By changing the behavior MMC_UNSAFE_RESUME becomes redundant, so lets's
    remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 99f5709ac343..2a139b2bdb9e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -424,12 +424,9 @@ static inline int mmc_regulator_get_supply(struct mmc_host *mmc)
 
 int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
-/* Module parameter */
-extern bool mmc_assume_removable;
-
 static inline int mmc_card_is_removable(struct mmc_host *host)
 {
-	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
+	return !(host->caps & MMC_CAP_NONREMOVABLE);
 }
 
 static inline int mmc_card_keep_power(struct mmc_host *host)

commit 4d22378221bd0ed69c2e99408d31c108d72aeb80
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 10 17:22:23 2013 +0200

    mmc: core: Add MMC_CAP_RUNTIME_RESUME to resume at runtime_resume
    
    In some environments it is to prefer to postpone the resume of the card
    device until runtime_resume is being carried out, since it will mean a
    signficant decrease of the total system resume time.
    
    The reason of the decreased resume time is simply because of the actual
    re-initalization of the card, which typically takes hundreds of
    milliseconds, is performed outside the resume sequence and wont thus
    affect it.
    
    For removable card, the detect work tries to re-detect the card to make
    sure it is still present, as a part of that sequence the card will also
    be runtime_resumed and thus also fully resumed.
    
    For a non-removable card, typically a mmc blk request will trigger a
    runtime_resume and thus fully resume the card. This also means the
    first request will likely suffer from an inital latency since the
    re-initialization of the card needs to be performed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f18669e15d4d..99f5709ac343 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -254,6 +254,7 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_RUNTIME_RESUME	(1 << 20)	/* Resume at runtime_resume. */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */

commit 3c0d22e8180b98eea412b84aa0f0c42c16159679
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Sep 26 11:01:18 2013 +0200

    mmc: core: Remove deprecated mmc_suspend|resume_host APIs
    
    The are no more users of the deprecated mmc_suspend|resume_host API,
    so let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 1c91bbbb01c3..f18669e15d4d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -381,9 +381,6 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
-int mmc_suspend_host(struct mmc_host *);
-int mmc_resume_host(struct mmc_host *);
-
 int mmc_power_save_host(struct mmc_host *host);
 int mmc_power_restore_host(struct mmc_host *host);
 

commit 6904115095ad60ced638eb1e36e0e4e5e7de00b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 11:31:33 2013 +0200

    mmc: core: Move cached value of the negotiated ocr mask to card struct
    
    The negotiated ocr mask is directly related to the card. Once a card
    gets removed, the mask shall be dropped. By moving the cache of the ocr
    mask from the host struct to the card struct we have accomplished this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3b0c33ae13e1..1c91bbbb01c3 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -309,7 +309,6 @@ struct mmc_host {
 	spinlock_t		lock;		/* lock for claim and bus ops */
 
 	struct mmc_ios		ios;		/* current io bus settings */
-	u32			ocr;		/* the current OCR setting */
 
 	/* group bitfields together to minimize padding */
 	unsigned int		use_spi_crc:1;

commit 53275c2136cc76b6ff26f8bec268c4bef9bab837
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:46 2013 +0200

    mmc: core: Invent MMC_CAP2_FULL_PWR_CYCLE
    
    MMC_CAP2_FULL_PWR_CYCLE shall be set by host drivers which are able to
    do a complete power cycle of the card. In the eMMC case that includes
    both vcc and vccq.
    
    This CAP is providing the protocol layer with important information,
    needed to take optimized decisions during card initialization and in
    the suspend/resume sequence.
    
    MMC_CAP2_POWEROFF_NOTIFY is replaced by MMC_CAP2_FULL_PWR_CYCLE, since
    it makes sense to use a wider scope for it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index eb2e6e1e5a3e..3b0c33ae13e1 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -264,7 +264,7 @@ struct mmc_host {
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
 #define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
-#define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
+#define MMC_CAP2_FULL_PWR_CYCLE	(1 << 2)	/* Can do full power cycle */
 #define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
 #define MMC_CAP2_NO_SLEEP_CMD	(1 << 4)	/* Don't allow sleep command */
 #define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */

commit ec0a7517dc25b4cca8a694fd61e09771bffba022
Author: Simon Baatz <gmbnomis@gmail.com>
Date:   Sun Jun 9 22:14:11 2013 +0200

    mmc: return mmc_of_parse() errors to caller
    
    In addition to just logging errors encountered during DT parsing or
    allocating GPIO slots for CD/WP, mmc_of_parse() now returns with an error.
    
    In particular, this is needed if the GPIO allocation may return
    EPROBE_DEFER.
    
    Signed-off-by: Simon Baatz <gmbnomis@gmail.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2e34ee5cefce..eb2e6e1e5a3e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -369,7 +369,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *);
 int mmc_add_host(struct mmc_host *);
 void mmc_remove_host(struct mmc_host *);
 void mmc_free_host(struct mmc_host *);
-void mmc_of_parse(struct mmc_host *host);
+int mmc_of_parse(struct mmc_host *host);
 
 static inline void *mmc_priv(struct mmc_host *host)
 {

commit 07a682160866e302d696f5c76d74024d575fb79d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Apr 19 15:12:11 2013 +0200

    mmc: core: Restructure and simplify code for mmc sleep|awake
    
    The mmc_card_sleep|awake APIs are not being used since the support is
    already properly encapsulated within the suspend sequence. Sleep|awake
    command is also specific for eMMC.
    
    We remove the sleep|awake bus_ops, the mmc_card_sleep|awake APIs and
    move the code into the mmc specific core instead. This also includes
    the mmc ops function, mmc_sleepawake. All releated functions have then
    become static and we have got far less code to maintain.
    
    Additionally this patch also simplifies the code from mmc_sleepawake,
    since it is only used to put the card to sleep and not awake.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 374098bae831..2e34ee5cefce 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -425,10 +425,6 @@ static inline int mmc_regulator_get_supply(struct mmc_host *mmc)
 }
 #endif
 
-int mmc_card_awake(struct mmc_host *host);
-int mmc_card_sleep(struct mmc_host *host);
-int mmc_card_can_sleep(struct mmc_host *host);
-
 int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
 /* Module parameter */

commit c4d770d72492df510077b277f21ac5f0dad9e5eb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu May 2 14:02:39 2013 +0200

    mmc: core: Support aggressive power management for (e)MMC/SD
    
    Aggressive power management is suitable when saving power is
    essential. At request inactivity timeout, aka pm runtime
    autosuspend timeout, the card will be suspended.
    
    Once a new request arrives, the card will be re-initalized and
    thus the first request will suffer from a latency. This latency
    is card-specific, experiments has shown in general that SD-cards
    has quite poor initialization time, around 300ms-1100ms. eMMC is
    not surprisingly far better but still a couple of hundreds of ms
    has been observed.
    
    Except for the request latency, it is important to know that
    suspending the card will also prevent the card from executing
    internal house-keeping operations in idle mode. This could mean
    degradation in performance.
    
    To use this feature make sure the request inactivity timeout is
    chosen carefully. This has not been done as a part of this patch.
    
    Enable this feature by using host cap MMC_CAP_AGGRESSIVE_PM and
    by setting CONFIG_MMC_UNSAFE_RESUME.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6f3851533de0..374098bae831 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -239,7 +239,7 @@ struct mmc_host {
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
-
+#define MMC_CAP_AGGRESSIVE_PM	(1 << 7)	/* Suspend (e)MMC/SD at idle  */
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 #define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */

commit 775a9362b5d7e006ff6bbec5cb9c9c9d5a751696
Author: Maya Erez <merez@codeaurora.org>
Date:   Thu Apr 18 15:41:55 2013 +0300

    mmc: card: Adding support for sanitize in eMMC 4.5
    
    The sanitize support is added as a user-app ioctl call, and
    was removed from the block-device request, since its purpose is
    to be invoked not via File-System but by a user.
    
    This feature deletes the unmap memory region of the eMMC card,
    by writing to a specific register in the EXT_CSD.
    
    unmap region is the memory region that was previously deleted
    (by erase, trim or discard operation).
    
    In order to avoid timeout when sanitizing large-scale cards,
    the timeout for sanitize operation is 240 seconds.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 38f60a97b218..6f3851533de0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -280,6 +280,7 @@ struct mmc_host {
 #define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
 				 MMC_CAP2_PACKED_WR)
 #define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
+#define MMC_CAP2_SANITIZE	(1 << 15)		/* Support Sanitize */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit b689167984bc14ed06c8bcff52ef5eb1fd9cf83b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 18 11:02:07 2013 +0200

    mmc: core: Re-use code for MMC_CAP2_DETECT_ON_ERR in polling mode
    
    Previously the MMC_CAP2_DETECT_ON_ERR was invented for detecting
    slow card removal. In was never a realy good solution and a proper
    fix has been merged using gpio debouncing instead. We remove this
    cap in this patch.
    
    Although when using polling card detect mode, the code invented for
    MMC_CAP2_DETECT_ON_ERR is re-used to complete card removal in an
    earlier phase. There are no need waiting for the polling timeout to
    elapse in this case.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Liu <kliu5@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e326ae2882a0..38f60a97b218 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -272,7 +272,6 @@ struct mmc_host {
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
 				 MMC_CAP2_HS200_1_2V_SDR)
 #define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
-#define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */

commit 2b69703fea185bb0ae1af78ca2da41af677b9dff
Merge: 30c67e93c526 df92d5ff5e70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 6 15:41:42 2013 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds
    
    Pull LED subsystem updates from Bryan Wu:
     - move LED trigger drivers into a new directory
     - lp55xx common driver updates
     - other led drivers updates and bug fixing
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds:
      leds: leds-asic3: switch to using SIMPLE_DEV_PM_OPS
      leds: leds-bd2802: add CONFIG_PM_SLEEP to suspend/resume functions
      leds: lp55xx: configure the clock detection
      leds: lp55xx: use common clock framework when external clock is used
      leds: leds-ns2: fix oops at module removal
      leds: leds-pwm: Defer led_pwm_set() if PWM can sleep
      leds: lp55xx: fix the sysfs read operation
      leds: lm355x, lm3642: support camera LED triggers for flash and torch
      leds: add camera LED triggers
      leds: trigger: use inline functions instead of macros
      leds: tca6507: Use of_match_ptr() macro
      leds: wm8350: Complain if we fail to reenable DCDC
      leds: renesas: set gpio_request_one() flags param correctly
      leds: leds-ns2: set devm_gpio_request_one() flags param correctly
      leds: leds-lt3593: set devm_gpio_request_one() flags param correctly
      leds: leds-bd2802: remove erroneous __exit annotation
      leds: atmel-pwm: remove erroneous __exit annotation
      leds: move LED trigger drivers into new subdirectory
      leds: add new LP5562 LED driver

commit 0d3e3350d5871c53464be4c92d57198744247005
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Thu Apr 4 16:41:06 2013 +0300

    mmc: core: fix performance regression initializing MMC host controllers
    
    Commit fa5501890d8974301042e0202d342a6cbe8609f4 introduced a performance
    regression by adding mmc_power_up() to mmc_start_host().  mmc_power_up()
    is not necessary to host controller initialization, it is part of card
    initialization and is performed anyway asynchronously.
    
    This patch allows a driver to leave the power up in asynchronous code
    (as it was before).
    
    On my current target platform this reduces driver initialization from:
    
    [    1.313220] initcall sdhci_acpi_driver_init+0x0/0x12 returned 0 after 102008 usecs
    
    to this:
    
    [    1.217209] initcall sdhci_acpi_driver_init+0x0/0x12 returned 0 after 8331 usecs
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 17d714801e94..8873e8349597 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -280,6 +280,7 @@ struct mmc_host {
 #define MMC_CAP2_PACKED_WR	(1 << 13)	/* Allow packed write */
 #define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
 				 MMC_CAP2_PACKED_WR)
+#define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 39f7e08af3fd9ca1cb94a8270354afb2ea5cfcd3
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Thu Mar 14 04:29:19 2013 -0700

    leds: trigger: use inline functions instead of macros
    
    Macros are used in case that an inline function doesn't work.
    Otherwise, use an empty inline function.
    
    (a) Case of !CONFIG_LEDS_TRIGGERS
    Following macros are replaced with inline functions.
      led_trigger_register_simple()
      led_trigger_unregister_simple()
      led_trigger_event()
    To make inline types, the structure, 'led_trigger' should be defined.
    This structure has no member at all.
    
    (b) Case of !CONFIG_LEDS_TRIGGER_IDE_DISK
    ledtrig_ide_activity() macro is replaced with an inline function as well.
    
    (c) DEFINE_LED_TRIGGER() and DEFINE_LED_TRIGGER_GLOBAL()
    Struct 'led_trigger' is defined both cases, with CONFIG_LEDS_TRIGGERS and
    without CONFIG_LEDS_TRIGGERS.
    Those macros are moved out of CONFIG_LED_TRIGGERS because of no-dependency
    on CONFIG_LEDS_TRIGGERS.
    
    (d) Fix build errors in mmc-core driver
    After replacing macros with inline functions, following build errors occur.
    (condition: CONFIG_LEDS_TRIGGERS is not set)
    
      drivers/mmc/core/core.c: In function 'mmc_request_done':
      drivers/mmc/core/core.c:164:25: error: 'struct mmc_host' has no member named 'led'
      drivers/mmc/core/core.c: In function 'mmc_start_request':
      drivers/mmc/core/core.c:254:24: error: 'struct mmc_host' has no member named 'led'
      make[3]: *** [drivers/mmc/core/core.o] Error 1
    
    The reason of these errors is non-existent member variable, 'led'.
    It is only valid when CONFIG_LEDS_TRIGGERS is set.
    But now, it can be used without this dependency.
    To fix build errors, member 'led' is always used without its config option in
    'include/linux/mmc/host.h'.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d6f20cc6415e..357e80efcde0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -341,9 +341,7 @@ struct mmc_host {
 
 	mmc_pm_flag_t		pm_flags;	/* requested pm features */
 
-#ifdef CONFIG_LEDS_TRIGGERS
 	struct led_trigger	*led;		/* activity led */
-#endif
 
 #ifdef CONFIG_REGULATOR
 	bool			regulator_enabled; /* regulator state */

commit eed222aca8d077af3600b651176f6fd04d95cce1
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Mar 5 11:24:52 2013 +0800

    mmc: sdio: bind acpi with sdio function device
    
    ACPI spec 5 defined the _ADR encoding for sdio bus as:
    High word - slot number (0 based)
    Low word  - function number
    
    This patch adds support for binding sdio function device with acpi node,
    and if successful, involve acpi into its power management.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Reviewed-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d6f20cc6415e..17d714801e94 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -361,6 +361,8 @@ struct mmc_host {
 
 	unsigned int		actual_clock;	/* Actual HC clock rate */
 
+	unsigned int		slotno;	/* used for sdio acpi binding */
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 8c9beb117bf31cdb757bc80992281004be8a177b
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Fri Feb 15 16:13:53 2013 +0100

    mmc: (cosmetic) remove "extern" from function declarations
    
    The "extern" keyword isn't required in function declarations, remove it.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bf93c9a6d729..d6f20cc6415e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -364,10 +364,10 @@ struct mmc_host {
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
-extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
-extern int mmc_add_host(struct mmc_host *);
-extern void mmc_remove_host(struct mmc_host *);
-extern void mmc_free_host(struct mmc_host *);
+struct mmc_host *mmc_alloc_host(int extra, struct device *);
+int mmc_add_host(struct mmc_host *);
+void mmc_remove_host(struct mmc_host *);
+void mmc_free_host(struct mmc_host *);
 void mmc_of_parse(struct mmc_host *host);
 
 static inline void *mmc_priv(struct mmc_host *host)
@@ -381,16 +381,16 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
-extern int mmc_suspend_host(struct mmc_host *);
-extern int mmc_resume_host(struct mmc_host *);
+int mmc_suspend_host(struct mmc_host *);
+int mmc_resume_host(struct mmc_host *);
 
-extern int mmc_power_save_host(struct mmc_host *host);
-extern int mmc_power_restore_host(struct mmc_host *host);
+int mmc_power_save_host(struct mmc_host *host);
+int mmc_power_restore_host(struct mmc_host *host);
 
-extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
-extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
+void mmc_detect_change(struct mmc_host *, unsigned long delay);
+void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
-extern int mmc_cache_ctrl(struct mmc_host *, u8);
+int mmc_cache_ctrl(struct mmc_host *, u8);
 
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {

commit 6c56e7a0fff166904ce2715f7ab1746460c1f11b
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Sat Feb 16 16:21:16 2013 +0100

    mmc: provide a standard MMC device-tree binding parser centrally
    
    MMC defines a number of standard DT bindings. Having each driver parse
    them individually adds code redundancy and is error prone. Provide a
    standard function to unify the parsing. After all drivers are converted
    to using it instead of their own parsers, this function can be integrated
    into mmc_alloc_host().
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index fd5fd5a6026f..bf93c9a6d729 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -368,6 +368,7 @@ extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
 extern int mmc_add_host(struct mmc_host *);
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
+void mmc_of_parse(struct mmc_host *host);
 
 static inline void *mmc_priv(struct mmc_host *host)
 {

commit ce39f9d17c14e56ea6772aa84393e6e0cc8499c4
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Feb 6 17:02:46 2013 +0900

    mmc: support packed write command for eMMC4.5 devices
    
    This patch supports packed write command of eMMC4.5 devices.  Several
    writes can be grouped in packed command and all data of the individual
    commands can be sent in a single transfer on the bus. Large amounts of
    data in one transfer rather than several data of small size are
    effective for eMMC write internally.  As a result, packed command help
    write throughput be improved.  The following tables show the results
    of packed write.
    
    Type A:
    test     none |  packed
    iozone   25.8 |  31
    tiotest  27.6 |  31.2
    lmdd     31.2 |  35.4
    
    Type B:
    test     none |  packed
    iozone   44.1 |  51.1
    tiotest  47.9 |  52.5
    lmdd     51.6 |  59.2
    
    Type C:
    test     none |  packed
    iozone   19.5 |  32
    tiotest  19.9 |  34.5
    lmdd     22.8 |  40.7
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a0466c03f5e1..fd5fd5a6026f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -465,6 +465,11 @@ static inline int mmc_host_uhs(struct mmc_host *host)
 		 MMC_CAP_UHS_DDR50);
 }
 
+static inline int mmc_host_packed_wr(struct mmc_host *host)
+{
+	return host->caps2 & MMC_CAP2_PACKED_WR;
+}
+
 #ifdef CONFIG_MMC_CLKGATE
 void mmc_host_clk_hold(struct mmc_host *host);
 void mmc_host_clk_release(struct mmc_host *host);

commit abd9ac144947d9a604beb763339e2f77ce8bec79
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Feb 6 17:01:43 2013 +0900

    mmc: add packed command feature of eMMC4.5
    
    This patch adds packed command feature of eMMC4.5.  The maximum number
    for packing read (or write) is offered and exception event relevant to
    packed command which is used for error handling is enabled. If host
    wants to use this feature, MMC_CAP2_PACKED_CMD should be set.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6c235e03de29..a0466c03f5e1 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -276,6 +276,10 @@ struct mmc_host {
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
+#define MMC_CAP2_PACKED_RD	(1 << 12)	/* Allow packed read */
+#define MMC_CAP2_PACKED_WR	(1 << 13)	/* Allow packed write */
+#define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
+				 MMC_CAP2_PACKED_WR)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 52983382c74f59a3953e622d7661a24e1bc4388a
Author: Kevin Liu <kliu5@marvell.com>
Date:   Thu Jan 31 11:31:37 2013 +0800

    mmc: sdhci: enhance preset value function
    
    4d55c5a1 ("mmc: sdhci: enable preset value after uhs initialization")
    added preset value support and enabled it by default during sd card init.
    
    Below are the enhancements introduced by this patch:
    
    1. In current code, preset value is enabled after setting clock finished,
    which means the clock is manually set by driver firstly and then suddenly
    switched to preset value at this point. So the first setting is useless
    and unnecessary. What's more, the first clock setting may differ from the
    preset one.  The better way is enable preset value just after switch to
    UHS mode so the preset value can take effect immediately. So move preset
    value enable from mmc_sd_init_card to sdhci_set_ios which will be called
    during set timing.
    
    2. In current code, preset value is disabled at the beginning of
    mmc_attach_sd.  It's too late since low freq (400khz) should be set in
    mmc_power_up.  So move preset value disable to sdhci_set_ios which will
    be called during power up.
    
    3. host->clock and ios->drv_type should also be updated according to the
    preset value if it's enabled. Current code missed this.
    
    4. This patch also introduce a quirk to disable preset value in case
    preset value doesn't work.
    
    This patch has been verified on sdhci-pxav3 platform with both preset
    enabled and disabled.
    
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0373b0a6daac..6c235e03de29 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -136,7 +136,6 @@ struct mmc_host_ops {
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
-	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);

commit d887874e0ead6a0b86b6046b872730c81c121352
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Mon Jan 28 15:08:26 2013 +0100

    mmc: core: Add card_busy to host_ops
    
    This host_ops member is used to test if the card is signaling busy by
    pulling dat[0:3] low.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Wei WANG <wei_wang@realsil.com.cn>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 523d570f58ad..0373b0a6daac 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -131,6 +131,9 @@ struct mmc_host_ops {
 
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
 
+	/* Check if the card is pulling dat[0:3] low */
+	int	(*card_busy)(struct mmc_host *host);
+
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);

commit 2220eedfd7aea69008173a224975e10284fbe854
Author: Konstantin Dorfman <kdorfman@codeaurora.org>
Date:   Mon Jan 14 14:28:17 2013 -0500

    mmc: fix async request mechanism for sequential read scenarios
    
    When current request is running on the bus and if next request fetched
    by mmcqd is NULL, mmc context (mmcqd thread) gets blocked until the
    current request completes. This means that if new request comes in while
    the mmcqd thread is blocked, this new request can not be prepared in
    parallel to current ongoing request. This may result in delaying the new
    request execution and increase it's latency.
    
    This change allows to wake up the MMC thread on new request arrival.
    Now once the MMC thread is woken up, a new request can be fetched and
    prepared in parallel to the current running request which means this new
    request can be started immediately after the current running request
    completes.
    
    With this change read throughput is improved by 16%.
    
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c89a1bb87fa5..523d570f58ad 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -170,6 +170,22 @@ struct mmc_slot {
 	void *handler_priv;
 };
 
+/**
+ * mmc_context_info - synchronization details for mmc context
+ * @is_done_rcv		wake up reason was done request
+ * @is_new_req		wake up reason was new request
+ * @is_waiting_last_req	mmc context waiting for single running request
+ * @wait		wait queue
+ * @lock		lock to protect data fields
+ */
+struct mmc_context_info {
+	bool			is_done_rcv;
+	bool			is_new_req;
+	bool			is_waiting_last_req;
+	wait_queue_head_t	wait;
+	spinlock_t		lock;
+};
+
 struct regulator;
 
 struct mmc_supply {
@@ -331,6 +347,7 @@ struct mmc_host {
 	struct dentry		*debugfs_root;
 
 	struct mmc_async_req	*areq;		/* active async req */
+	struct mmc_context_info	context_info;	/* async synchronization info */
 
 #ifdef CONFIG_FAIL_MMC_REQUEST
 	struct fault_attr	fail_mmc_request;

commit 41875e388401ad97c33252d5fa39d52e0b70ee9b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Tue Dec 4 17:06:19 2012 +0530

    mmc: sdio: Fix SDIO 3.0 UHS-I initialization sequence
    
    According to UHS-I initialization sequence for SDIO 3.0 cards,
    the host must set bit[24] (S18R) of OCR register during OCR
    handshake to know whether the SDIO card is capable of doing
    1.8V I/O.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 61a10c17aabd..c89a1bb87fa5 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -434,6 +434,14 @@ static inline int mmc_boot_partition_access(struct mmc_host *host)
 	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
 }
 
+static inline int mmc_host_uhs(struct mmc_host *host)
+{
+	return host->caps &
+		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
+		 MMC_CAP_UHS_DDR50);
+}
+
 #ifdef CONFIG_MMC_CLKGATE
 void mmc_host_clk_hold(struct mmc_host *host);
 void mmc_host_clk_release(struct mmc_host *host);

commit 9f1fb60a2338aa2202ca94d67f84c582f31dbf5a
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Dec 4 16:51:32 2012 +0100

    mmc: add a card-event host operation
    
    Some hosts need to perform additional actions upon card insertion or
    ejection. Add a host operation to be called from card detection handlers.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 23df21e5826b..61a10c17aabd 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -136,6 +136,7 @@ struct mmc_host_ops {
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
+	void	(*card_event)(struct mmc_host *host);
 };
 
 struct mmc_card;

commit ed9dbb6effc3516a1211a936be9bd67c03fdf858
Author: Kevin Liu <kliu5@marvell.com>
Date:   Wed Oct 17 19:04:46 2012 +0800

    mmc: host: Make UHS timing values fully unique
    
    Both of MMC_TIMING_LEGACY and MMC_TIMING_UHS_SDR12 are defined
    to 0. And ios->timing is set to MMC_TIMING_LEGACY during power up.
    But set_ios can't distinguish these two timing if host support
    spec 3.0. Just adjust timing values to be different can resolve
    this issue without any other impact.
    
    Reviewed-by: Girish K S <girish.shivananjappa@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 37442b288ee8..23df21e5826b 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -53,12 +53,12 @@ struct mmc_ios {
 #define MMC_TIMING_LEGACY	0
 #define MMC_TIMING_MMC_HS	1
 #define MMC_TIMING_SD_HS	2
-#define MMC_TIMING_UHS_SDR12	MMC_TIMING_LEGACY
-#define MMC_TIMING_UHS_SDR25	MMC_TIMING_SD_HS
-#define MMC_TIMING_UHS_SDR50	3
-#define MMC_TIMING_UHS_SDR104	4
-#define MMC_TIMING_UHS_DDR50	5
-#define MMC_TIMING_MMC_HS200	6
+#define MMC_TIMING_UHS_SDR12	3
+#define MMC_TIMING_UHS_SDR25	4
+#define MMC_TIMING_UHS_SDR50	5
+#define MMC_TIMING_UHS_SDR104	6
+#define MMC_TIMING_UHS_DDR50	7
+#define MMC_TIMING_MMC_HS200	8
 
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1

commit 5f1a4dd0372038f2490afa4540cd66b8d092839e
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Nov 14 12:35:51 2012 +0000

    mmc: Standardise capability type
    
    There are discrepancies with regards to how MMC capabilities
    are carried throughout the subsystem. Let's standardise them
    to eliminate any confusion.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 7abb0e1f7bda..37442b288ee8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -211,7 +211,7 @@ struct mmc_host {
 #define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
 #define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */
 
-	unsigned long		caps;		/* Host capabilities */
+	u32			caps;		/* Host capabilities */
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
 #define MMC_CAP_MMC_HIGHSPEED	(1 << 1)	/* Can do MMC high-speed timing */
@@ -241,7 +241,7 @@ struct mmc_host {
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 
-	unsigned int		caps2;		/* More host capabilities */
+	u32			caps2;		/* More host capabilities */
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
 #define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */

commit e6c085863f97f0a8f009753e1baaf83e4aac7b42
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 5 12:45:39 2012 -0400

    mmc: core: Fixup broken suspend and eMMC4.5 power off notify
    
    This patch fixes up the broken suspend sequence for eMMC with sleep
    support. Additionally it reworks the eMMC4.5 Power Off Notification
    feature so it fits together with the existing sleep feature.
    
    The CMD0 based re-initialization of the eMMC at resume is re-introduced
    to maintain compatiblity for devices using sleep.
    
    A host shall use MMC_CAP2_POWEROFF_NOTIFY to enable the Power Off
    Notification feature. We might be able to remove this cap later on,
    if we think that Power Off Notification always is preferred over
    sleep, even if the host is not able to cut the eMMC VCCQ power.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Saugata Das <saugata.das@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d5d9bd4c5aa8..7abb0e1f7bda 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -259,10 +259,6 @@ struct mmc_host {
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
-	unsigned int        power_notify_type;
-#define MMC_HOST_PW_NOTIFY_NONE		0
-#define MMC_HOST_PW_NOTIFY_SHORT	1
-#define MMC_HOST_PW_NOTIFY_LONG		2
 
 #ifdef CONFIG_MMC_CLKGATE
 	int			clk_requests;	/* internal reference counter */

commit 3339d1e33185798a45dbdb5ea6c0bec1c27ca5fd
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Thu Aug 23 13:40:55 2012 +0200

    mmc: core: Do not rescan non-removable devices
    
    If MMC_CAP_NONREMOVABLE is set, only issue a detect job on init.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f578a71d82a6..d5d9bd4c5aa8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -300,6 +300,7 @@ struct mmc_host {
 #endif
 
 	int			rescan_disable;	/* disable card detection */
+	int			rescan_entered;	/* used with nonremovable devices */
 
 	struct mmc_card		*card;		/* device attached to this host */
 

commit 55c4665ea0a42fd6427826bfce96eb4b0389262a
Author: Aaron Lu <aaron.lu@amd.com>
Date:   Wed Jul 4 13:31:48 2012 +0800

    mmc: sd: Fix sd current limit setting
    
    Host has different current capabilities at different voltages, we need
    to record these settings seperately. The defined voltages are 1.8/3.0/3.3.
    For other voltages, we do not touch current limit setting.
    
    Before we set the current limit for the sd card, find out the host's
    operating voltage first and then find out the current capabilities of
    the host at that voltage to set the current limit.
    
    Signed-off-by: Aaron Lu <aaron.lu@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 65c64ee578a7..f578a71d82a6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -189,6 +189,9 @@ struct mmc_host {
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct notifier_block	pm_notify;
+	u32			max_current_330;
+	u32			max_current_300;
+	u32			max_current_180;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -232,16 +235,9 @@ struct mmc_host {
 #define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
 #define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
 #define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
-#define MMC_CAP_SET_XPC_330	(1 << 20)	/* Host supports >150mA current at 3.3V */
-#define MMC_CAP_SET_XPC_300	(1 << 21)	/* Host supports >150mA current at 3.0V */
-#define MMC_CAP_SET_XPC_180	(1 << 22)	/* Host supports >150mA current at 1.8V */
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
-#define MMC_CAP_MAX_CURRENT_200	(1 << 26)	/* Host max current limit is 200mA */
-#define MMC_CAP_MAX_CURRENT_400	(1 << 27)	/* Host max current limit is 400mA */
-#define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
-#define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 

commit a7d1a1ebd8f5858a812ac3d5fbbc178b4959a63b
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue May 1 16:51:38 2012 +0200

    mmc: core: convert slot functions to managed allocation
    
    This prepares for the addition of further slot functions.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c1a03eed1d17..65c64ee578a7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -11,6 +11,7 @@
 #define LINUX_MMC_HOST_H
 
 #include <linux/leds.h>
+#include <linux/mutex.h>
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
@@ -154,6 +155,7 @@ struct mmc_async_req {
  * struct mmc_slot - MMC slot functions
  *
  * @cd_irq:		MMC/SD-card slot hotplug detection IRQ or -EINVAL
+ * @lock:		protect the @handler_priv pointer
  * @handler_priv:	MMC/SD-card slot context
  *
  * Some MMC/SD host controllers implement slot-functions like card and
@@ -163,6 +165,7 @@ struct mmc_async_req {
  */
 struct mmc_slot {
 	int cd_irq;
+	struct mutex lock;
 	void *handler_priv;
 };
 

commit 5c08d7fae0815cd163a98e05c8d94fc0de77ff67
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue May 1 15:49:52 2012 +0200

    mmc: add two capability flags for CD and WP signal polarity
    
    To handle CD and WP SD/MMC slot pins we need generic flags to specify their
    polarity.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 90b6a38b0374..c1a03eed1d17 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -256,6 +256,8 @@ struct mmc_host {
 #define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
 #define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
+#define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
+#define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit 27410ee7e391ce650d6d0242805f080599be7ad7
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue May 1 15:40:15 2012 +0200

    mmc: core: use a more generic name for slot function types and fields
    
    struct mmc_host::hotplug is becoming a generic hook for slot functions.
    Rename it accordingly.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9deb725799e7..90b6a38b0374 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -150,8 +150,19 @@ struct mmc_async_req {
 	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
 };
 
-struct mmc_hotplug {
-	unsigned int irq;
+/**
+ * struct mmc_slot - MMC slot functions
+ *
+ * @cd_irq:		MMC/SD-card slot hotplug detection IRQ or -EINVAL
+ * @handler_priv:	MMC/SD-card slot context
+ *
+ * Some MMC/SD host controllers implement slot-functions like card and
+ * write-protect detection natively. However, a large number of controllers
+ * leave these functions to the CPU. This struct provides a hook to attach
+ * such slot-function drivers.
+ */
+struct mmc_slot {
+	int cd_irq;
 	void *handler_priv;
 };
 
@@ -297,7 +308,7 @@ struct mmc_host {
 
 	struct delayed_work	detect;
 	int			detect_change;	/* card detect flag */
-	struct mmc_hotplug	hotplug;
+	struct mmc_slot		slot;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */

commit e137788dd115dd9d21759a768dba5fff9685e587
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jun 20 02:28:43 2012 -0400

    mmc: add a function to get regulators, supplying card's power
    
    Add a function to get regulators, supplying card's Vdd and Vccq on a
    specific host. If a Vdd supplying regulator is found, the function checks,
    whether a valid OCR mask can be obtained from it. The Vccq regulator is
    optional. A failure to get it is not fatal.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Reviwed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0707d228d7f1..9deb725799e7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -155,6 +155,13 @@ struct mmc_hotplug {
 	void *handler_priv;
 };
 
+struct regulator;
+
+struct mmc_supply {
+	struct regulator *vmmc;		/* Card power supply */
+	struct regulator *vqmmc;	/* Optional Vccq supply */
+};
+
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -309,6 +316,7 @@ struct mmc_host {
 #ifdef CONFIG_REGULATOR
 	bool			regulator_enabled; /* regulator state */
 #endif
+	struct mmc_supply	supply;
 
 	struct dentry		*debugfs_root;
 
@@ -357,13 +365,12 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 	wake_up_process(host->sdio_irq_thread);
 }
 
-struct regulator;
-
 #ifdef CONFIG_REGULATOR
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct mmc_host *mmc,
 			struct regulator *supply,
 			unsigned short vdd_bit);
+int mmc_regulator_get_supply(struct mmc_host *mmc);
 #else
 static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
 {
@@ -376,6 +383,11 @@ static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
 {
 	return 0;
 }
+
+static inline int mmc_regulator_get_supply(struct mmc_host *mmc)
+{
+	return 0;
+}
 #endif
 
 int mmc_card_awake(struct mmc_host *host);

commit bbbc4c4d8c5face097d695f9bf3a39647ba6b7e7
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Apr 16 19:16:54 2012 -0400

    mmc: sdio: avoid spurious calls to interrupt handlers
    
    Commit 06e8935feb ("optimized SDIO IRQ handling for single irq")
    introduced some spurious calls to SDIO function interrupt handlers,
    such as when the SDIO IRQ thread is started, or the safety check
    performed upon a system resume.  Let's add a flag to perform the
    optimization only when a real interrupt is signaled by the host
    driver and we know there is no point confirming it.
    
    Reported-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cbde4b7e675e..0707d228d7f1 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -297,6 +297,7 @@ struct mmc_host {
 
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
+	bool			sdio_irq_pending;
 	atomic_t		sdio_irq_thread_abort;
 
 	mmc_pm_flag_t		pm_flags;	/* requested pm features */
@@ -352,6 +353,7 @@ extern int mmc_cache_ctrl(struct mmc_host *, u8);
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);
+	host->sdio_irq_pending = true;
 	wake_up_process(host->sdio_irq_thread);
 }
 

commit b5174fa3a7f4f8f150bfa3b917c92608953dfa0f
Merge: afb9bd704c71 135111cc5595
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 20:59:45 2012 -0700

    Merge tag 'mmc-merge-for-3.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    Pull MMC updates from Chris Ball:
    
    Core:
     * Support for MMC 4.5 Data Tag feature -- we tag REQ_META, so devices
       that support Data Tag will provide increased throughput for metadata.
     * Faster detection of card removal on I/O errors.
    
    Drivers:
     * dw_mmc now supports eMMC Power Off Notify, has PCI support, and
       implements pre_req and post_req for asynchronous requests.
     * omap_hsmmc now supports device tree.
     * esdhc now has power management support.
     * sdhci-tegra now supports Tegra30 devices.
     * sdhci-spear now supports hibernation.
     * tmio_mmc now supports using a GPIO for card detection.
     * Intel PCH now supports 8-bit bus transfers.
    
    * tag 'mmc-merge-for-3.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (53 commits)
      mmc: sh_mmcif: simplify bitmask macros
      mmc: sh_mobile_sdhi: support modular mmc-core with non-standard hotplug
      mmc: sh_mobile_sdhi: add a callback for board specific init code
      mmc: tmio: cosmetic: prettify the tmio_mmc_set_ios() function
      mmc: sh_mobile_sdhi: do not manage PM clocks manually
      mmc: tmio_mmc: remove unused sdio_irq_enabled flag
      mmc: tmio_mmc: power status flag doesn't have to be exposed in platform data
      mmc: sh_mobile_sdhi: pass card hotplug GPIO number to TMIO MMC
      mmc: tmio_mmc: support the generic MMC GPIO card hotplug helper
      mmc: tmio: calculate the native hotplug condition only once
      mmc: simplify mmc_cd_gpio_request() by removing two parameters
      mmc: sdhci-pci: allow 8-bit bus width for Intel PCH
      mmc: sdhci: check interrupt flags in ISR again
      mmc: sdhci-pci: Add MSI support
      mmc: core: warn when card doesn't support HPI
      mmc: davinci: Poll status for small size transfers
      mmc: davinci: Eliminate spurious interrupts
      mmc: omap_hsmmc: Avoid a regulator voltage change with dt
      mmc: omap_hsmmc: Convert hsmmc driver to use device tree
      mmc: sdhci-pci: add SDHCI_QUIRK2_HOST_OFF_CARD_ON for Medfield SDIO
      ...

commit 83bb24aaa4af2ec7c127cc2a5fa7ca9f64cdd13d
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 13 05:19:13 2012 -0400

    mmc: core: add high-capacity erase size capability flag
    
    Let drivers specify the use of high-capacity erase size.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e05bd241c676..33a4d08d810e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -236,6 +236,7 @@ struct mmc_host {
 				 MMC_CAP2_HS200_1_2V_SDR)
 #define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
 #define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
+#define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit 907d2e7cc7ebba4ab398422a7f0435e1802be65b
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Wed Feb 29 09:17:21 2012 +0200

    mmc: start removing enable / disable API
    
    Most parts of the enable / disable API are no longer used and
    can be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index d1d3743fde90..e05bd241c676 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -80,34 +80,11 @@ struct mmc_ios {
 
 struct mmc_host_ops {
 	/*
-	 * Hosts that support power saving can use the 'enable' and 'disable'
-	 * methods to exit and enter power saving states. 'enable' is called
-	 * when the host is claimed and 'disable' is called (or scheduled with
-	 * a delay) when the host is released. The 'disable' is scheduled if
-	 * the disable delay set by 'mmc_set_disable_delay()' is non-zero,
-	 * otherwise 'disable' is called immediately. 'disable' may be
-	 * scheduled repeatedly, to permit ever greater power saving at the
-	 * expense of ever greater latency to re-enable. Rescheduling is
-	 * determined by the return value of the 'disable' method. A positive
-	 * value gives the delay in milliseconds.
-	 *
-	 * In the case where a host function (like set_ios) may be called
-	 * with or without the host claimed, enabling and disabling can be
-	 * done directly and will nest correctly. Call 'mmc_host_enable()' and
-	 * 'mmc_host_lazy_disable()' for this purpose, but note that these
-	 * functions must be paired.
-	 *
-	 * Alternatively, 'mmc_host_enable()' may be paired with
-	 * 'mmc_host_disable()' which calls 'disable' immediately.  In this
-	 * case the 'disable' method will be called with 'lazy' set to 0.
-	 * This is mainly useful for error paths.
-	 *
-	 * Because lazy disable may be called from a work queue, the 'disable'
-	 * method must claim the host when 'lazy' != 0, which will work
-	 * correctly because recursion is detected and handled.
+	 * 'enable' is called when the host is claimed and 'disable' is called
+	 * when the host is released. 'enable' and 'disable' are deprecated.
 	 */
 	int (*enable)(struct mmc_host *host);
-	int (*disable)(struct mmc_host *host, int lazy);
+	int (*disable)(struct mmc_host *host);
 	/*
 	 * It is optional for the host to implement pre_req and post_req in
 	 * order to support double buffering of requests (prepare one
@@ -218,7 +195,7 @@ struct mmc_host {
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
-#define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
+
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 #define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
@@ -301,13 +278,7 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
-	/* Only used with MMC_CAP_DISABLE */
-	int			enabled;	/* host is enabled */
 	int			rescan_disable;	/* disable card detection */
-	int			nesting_cnt;	/* "enable" nesting count */
-	int			en_dis_recurs;	/* detect recursion */
-	unsigned int		disable_delay;	/* disable delay in msecs */
-	struct delayed_work	disable;	/* disabling work */
 
 	struct mmc_card		*card;		/* device attached to this host */
 
@@ -407,17 +378,8 @@ int mmc_card_awake(struct mmc_host *host);
 int mmc_card_sleep(struct mmc_host *host);
 int mmc_card_can_sleep(struct mmc_host *host);
 
-int mmc_host_enable(struct mmc_host *host);
-int mmc_host_disable(struct mmc_host *host);
-int mmc_host_lazy_disable(struct mmc_host *host);
 int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
-static inline void mmc_set_disable_delay(struct mmc_host *host,
-					 unsigned int disable_delay)
-{
-	host->disable_delay = disable_delay;
-}
-
 /* Module parameter */
 extern bool mmc_assume_removable;
 

commit f0cc9cf99326926fd76f77645c48d16d647802eb
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Mon Feb 6 10:42:39 2012 +0100

    mmc: core: Detect card removal on I/O error
    
    To prevent I/O as soon as possible at card removal, a new detect work is
    re-scheduled without a delay to let a rescan remove the card device as
    soon as possible.
    
    Additionally, MMC_CAP2_DETECT_ON_ERR can now be used to handle "slowly"
    removed cards that a scheduled detect work did not detect as removed.
    To prevent further I/O requests for these lingering removed cards,
    check if card has been removed and then schedule a detect work to
    properly remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ee2b0363c040..d1d3743fde90 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -258,6 +258,7 @@ struct mmc_host {
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
 				 MMC_CAP2_HS200_1_2V_SDR)
 #define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
+#define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0beba1e5e1ed..68558d743da5 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -12,6 +12,7 @@
 
 #include <linux/leds.h>
 #include <linux/sched.h>
+#include <linux/device.h>
 #include <linux/fault-inject.h>
 
 #include <linux/mmc/core.h>

commit 6e8201f57c9359c9c5dc8f9805c15a4392492a10
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Jan 16 17:49:01 2012 +0900

    mmc: core: add the capability for broken voltage
    
    There is an understood mismatch between the voltage the host controller is
    set to and the voltage supplied to the card by a fixed voltage regulator.
    Teaching the driver to accept the mismatch is overly complicated.  Instead
    just accept the regulator's voltage.
    
    This patch adds MMC_CAP2_BROKEN_VOLTAGE.
    
    If the voltage didn't satisfy between min_uV and max_uV, try to change
    the voltage in core.c.  When changing the voltage, maybe use
    regulator_set_voltage().
    
    In regulator_set_voltage(), check the below condition.
    
            /* sanity check */
            if (!rdev->desc->ops->set_voltage &&
                !rdev->desc->ops->set_voltage_sel) {
                    ret = -EINVAL;
                    goto out;
            }
    
    If some board should use the fixed-regulator, always return -EINVAL.
    Then, eMMC didn't initialize always.
    
    So if use a fixed-regulator, we need to add the MMC_CAP2_BROKEN_VOLTAGE.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 73e5ee8e9ca2..ee2b0363c040 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -257,6 +257,7 @@ struct mmc_host {
 #define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
 #define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
 				 MMC_CAP2_HS200_1_2V_SDR)
+#define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit 2c4967f741e87cdd63de7271b97807041dccbf3b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Sat Feb 4 16:14:50 2012 -0500

    mmc: core: Ensure clocks are always enabled before host interaction
    
    Ensure clocks are always enabled before any interaction with the
    host controller driver. This makes sure that there is no race
    between host execution and the core layer turning off clocks
    in different context with clock gating framework.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Per Forlin <per.forlin@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0beba1e5e1ed..73e5ee8e9ca2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -444,4 +444,23 @@ static inline int mmc_boot_partition_access(struct mmc_host *host)
 	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
 }
 
+#ifdef CONFIG_MMC_CLKGATE
+void mmc_host_clk_hold(struct mmc_host *host);
+void mmc_host_clk_release(struct mmc_host *host);
+unsigned int mmc_host_clk_rate(struct mmc_host *host);
+
+#else
+static inline void mmc_host_clk_hold(struct mmc_host *host)
+{
+}
+
+static inline void mmc_host_clk_release(struct mmc_host *host)
+{
+}
+
+static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
+{
+	return host->ios.clock;
+}
+#endif
 #endif /* LINUX_MMC_HOST_H */

commit 0a80939b3e6af4b0dc93bf88ec02fd7e90a16f1b
Merge: 0b48d42235ca 72db395ffadb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 12:32:16 2012 -0800

    Merge tag 'for-linus' of git://github.com/rustyrussell/linux
    
    Autogenerated GPG tag for Rusty D1ADB8F1: 15EE 8D6C AB0E 7F0C F999  BFCB D920 0E6C D1AD B8F1
    
    * tag 'for-linus' of git://github.com/rustyrussell/linux:
      module_param: check that bool parameters really are bool.
      intelfbdrv.c: bailearly is an int module_param
      paride/pcd: fix bool verbose module parameter.
      module_param: make bool parameters really bool (drivers & misc)
      module_param: make bool parameters really bool (arch)
      module_param: make bool parameters really bool (core code)
      kernel/async: remove redundant declaration.
      printk: fix unnecessary module_param_name.
      lirc_parallel: fix module parameter description.
      module_param: avoid bool abuse, add bint for special cases.
      module_param: check type correctness for module_param_array
      modpost: use linker section to generate table.
      modpost: use a table rather than a giant if/else statement.
      modules: sysfs - export: taint, coresize, initsize
      kernel/params: replace DEBUGP with pr_debug
      module: replace DEBUGP with pr_debug
      module: struct module_ref should contains long fields
      module: Fix performance regression on modules with large symbol tables
      module: Add comments describing how the "strmap" logic works
    
    Fix up conflicts in scripts/mod/file2alias.c due to the new linker-
    generated table approach to adding __mod_*_device_table entries.  The
    ARM sa11x0 mcp bus needed to be converted to that too.

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a3ac9c48e5de..8ef7894a48d0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -396,7 +396,7 @@ static inline void mmc_set_disable_delay(struct mmc_host *host,
 }
 
 /* Module parameter */
-extern int mmc_assume_removable;
+extern bool mmc_assume_removable;
 
 static inline int mmc_card_is_removable(struct mmc_host *host)
 {

commit a4924c71aa43d4f8a3f342b1f71788349472e684
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Wed Jan 11 14:04:52 2012 -0500

    mmc: core: HS200 mode support for eMMC 4.5
    
    This patch adds the support of the HS200 bus speed for eMMC 4.5 devices.
    The eMMC 4.5 devices have support for 200MHz bus speed. The function
    prototype of the tuning function is modified to handle the tuning
    command number which is different in sd and mmc case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 031d865167a2..dd13e0539092 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -56,10 +56,13 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_SDR50	3
 #define MMC_TIMING_UHS_SDR104	4
 #define MMC_TIMING_UHS_DDR50	5
+#define MMC_TIMING_MMC_HS200	6
 
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1
 #define MMC_1_8V_DDR_MODE	2
+#define MMC_1_2V_SDR_MODE	3
+#define MMC_1_8V_SDR_MODE	4
 
 	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
@@ -148,7 +151,9 @@ struct mmc_host_ops {
 	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
 
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
-	int	(*execute_tuning)(struct mmc_host *host);
+
+	/* The tuning command opcode value is different for SD and eMMC cards */
+	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
@@ -248,6 +253,10 @@ struct mmc_host {
 #define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
 #define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
 #define MMC_CAP2_NO_SLEEP_CMD	(1 << 4)	/* Don't allow sleep command */
+#define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */
+#define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
+#define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
+				 MMC_CAP2_HS200_1_2V_SDR)
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit aa9df4fb2adcc73d36fa41e23059519be770aaa5
Author: Ulf Hansson <ulf.hansson@stericsson.com>
Date:   Mon Dec 19 16:24:19 2011 +0100

    mmc: core: Add option to prevent eMMC sleep command
    
    Host may now use MMC_CAP2_NO_SLEEP_CMD to disable the use
    of eMMC sleep/awake command.
    
    This option can be used when your platform has a buggy
    kernel crash dump software, which is supposed to store
    the dump on the eMMC, but is not able to wake up the eMMC
    from sleep state.
    
    In particular, failures have been seen with u-boot; even if
    it is fixed there, platforms will be slow to update their
    bootloader binaries.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Hanumath Prasad <hanumath.prasad@stericsson.com>
    Reviewed-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 742f0e102e1e..031d865167a2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -247,6 +247,7 @@ struct mmc_host {
 #define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
 #define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
 #define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
+#define MMC_CAP2_NO_SLEEP_CMD	(1 << 4)	/* Don't allow sleep command */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit b67e198073b2d2f16572f5fa77553fec14775f69
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Sun Dec 25 20:40:03 2011 -0500

    mmc: add a card hotplug handler context
    
    SD/MMC controllers provide different card insertion and removal detection
    methods. On some of them the controller itself issues an interrupt, on
    others polling is used, on yet others auxiliary means are used for this
    purpose, e.g., a GPIO IRQ. Further, on some systems one of those methods
    can be chosen at driver probing time and configured in software. E.g., on
    some systems the SD/MMC controller card hot-plug detection pin can be
    configured either as a respective controller functions, or an IRQ-capable
    GPIO. To support such flexible configurations a card hot-plug context
    is added by this patch.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9a03d0335745..742f0e102e1e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -167,6 +167,11 @@ struct mmc_async_req {
 	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
 };
 
+struct mmc_hotplug {
+	unsigned int irq;
+	void *handler_priv;
+};
+
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -300,6 +305,7 @@ struct mmc_host {
 
 	struct delayed_work	detect;
 	int			detect_change;	/* card detect flag */
+	struct mmc_hotplug	hotplug;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */

commit d30495048892980e5d453328d1cc9343b3f7e917
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Nov 28 16:22:00 2011 +0200

    mmc: allow upper layers to know immediately if card has been removed
    
    Add a function mmc_detect_card_removed() which upper layers can use to
    determine immediately if a card has been removed. This function should
    be called after an I/O request fails so that all queued I/O requests
    can be errored out immediately instead of waiting for the card device
    to be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 706f72279a17..9a03d0335745 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -299,6 +299,7 @@ struct mmc_host {
 	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
+	int			detect_change;	/* card detect flag */
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */

commit 597dd9d79cfbbb1636d00a7fd0880355d9b20c41
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Mon Nov 14 13:53:29 2011 +0530

    mmc: core: Use delayed work in clock gating framework
    
    Current clock gating framework disables the MCI clock as soon as the
    request is completed and enables it when a request arrives. This aggressive
    clock gating framework, when enabled, cause following issues:
    
    When there are back-to-back requests from the Queue layer, we unnecessarily
    end up disabling and enabling the clocks between these requests since 8MCLK
    clock cycles is a very short duration compared to the time delay between
    back to back requests reaching the MMC layer. This overhead can effect the
    overall performance depending on how long the clock enable and disable
    calls take which is platform dependent. For example on some platforms we
    can have clock control not on the local processor, but on a different
    subsystem and the time taken to perform the clock enable/disable can add
    significant overhead.
    
    Also if the host controller driver decides to disable the host clock too
    when mmc_set_ios function is called with ios.clock=0, it adds additional
    delay and it is highly possible that the next request had already arrived
    and unnecessarily blocked in enabling the clocks. This is seen frequently
    when the processor is executing at high speeds and in multi-core platforms
    thus reduces the overall throughput compared to if clock gating is
    disabled.
    
    Fix this by delaying turning off the clocks by posting request on
    delayed workqueue. Also cancel the unscheduled pending work, if any,
    when there is access to card.
    
    sysfs entry is provided to tune the delay as needed, default
    value set to 200ms.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cea064f73514..706f72279a17 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -253,10 +253,12 @@ struct mmc_host {
 	int			clk_requests;	/* internal reference counter */
 	unsigned int		clk_delay;	/* number of MCI clk hold cycles */
 	bool			clk_gated;	/* clock gated */
-	struct work_struct	clk_gate_work; /* delayed clock gate */
+	struct delayed_work	clk_gate_work; /* delayed clock gate */
 	unsigned int		clk_old;	/* old clock value cache */
 	spinlock_t		clk_lock;	/* lock for clk fields */
 	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
+	struct device_attribute clkgate_delay_attr;
+	unsigned long           clkgate_delay;
 #endif
 
 	/* host specific block data */

commit df16219f365f7f5a2d88a6e123251d57255cca3f
Author: Giuseppe CAVALLARO <peppe.cavallaro@st.com>
Date:   Fri Nov 4 13:53:19 2011 +0100

    mmc: debugfs: expose the SDCLK frq in sys ios
    
    This patch is to expose the actual SDCLK frequency in
    /sys/kernel/debug/mmcX/ios entry.
    
    For example, if the max clk for a normal speed card is 20MHz this
    is reported in /sys/kernel/debug/mmcX/ios.  Unfortunately the actual
    SDCLK frequency (i.e. Baseclock / divisor) is not reported at all:
    for example, in that case, on Arasan HC, it should be 48/4=12 (MHz).
    
    Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a3ac9c48e5de..cea064f73514 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -323,6 +323,8 @@ struct mmc_host {
 	struct fault_attr	fail_mmc_request;
 #endif
 
+	unsigned int		actual_clock;	/* Actual HC clock rate */
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 2bf22b39823c1d173dda31111a4eb2ce36daaf39
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Oct 6 14:50:33 2011 -0600

    mmc: core: add workaround for controllers with broken multiblock reads
    
    Due to hardware bugs, some MMC host controllers don't support
    multiple-block reads[1].  To resolve, add a new MMC capability flag,
    MMC_CAP2_NO_MULTI_READ, which can be set by affected host controller
    drivers.  When this capability is set, all reads will be issued one
    sector at a time.
    
    1. See for example Advisory 2.1.1.128 "MMC: Multiple Block Read
    Operation Issue" in _OMAP3530/3525/3515/3503 Silicon Errata_
    Revision F (October 2010) (SPRZ278F), available from
    http://focus.ti.com/lit/er/sprz278f/sprz278f.pdf
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Dave Hylands <dhylands@gmail.com>
    Tested-by: Steve Sakoman <sakoman@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 16e9338944e8..a3ac9c48e5de 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -241,6 +241,7 @@ struct mmc_host {
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
 #define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
 #define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
+#define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;

commit 881d1c25f765938a95def5afe39486ce39f9fc96
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Oct 14 14:03:21 2011 +0900

    mmc: core: Add cache control for eMMC4.5 device
    
    This patch adds cache feature of eMMC4.5 Spec.
    If device supports cache capability, host can utilize some specific
    operations.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index cd10208d9a06..16e9338944e8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -239,6 +239,7 @@ struct mmc_host {
 	unsigned int		caps2;		/* More host capabilities */
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
+#define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
 #define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
@@ -349,6 +350,8 @@ extern int mmc_power_restore_host(struct mmc_host *host);
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
+extern int mmc_cache_ctrl(struct mmc_host *, u8);
+
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
 	host->ops->enable_sdio_irq(host, 0);

commit bec8726abc72bf30d2743a722aa37cd69e7a0580
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Thu Oct 13 12:04:16 2011 +0530

    mmc: core: Add Power Off Notify Feature eMMC 4.5
    
    This patch adds support for the power off notify feature, available in
    eMMC 4.5 devices. If the host has support for this feature, then the
    mmc core will notify the device by setting the POWER_OFF_NOTIFICATION
    byte in the extended csd register with a value of 1 (POWER_ON).
    
    For suspend mode short timeout is used, whereas for the normal poweroff
    long timeout is used.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index aed5bc7245f7..cd10208d9a06 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -239,8 +239,13 @@ struct mmc_host {
 	unsigned int		caps2;		/* More host capabilities */
 
 #define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
+#define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
+	unsigned int        power_notify_type;
+#define MMC_HOST_PW_NOTIFY_NONE		0
+#define MMC_HOST_PW_NOTIFY_SHORT	1
+#define MMC_HOST_PW_NOTIFY_LONG		2
 
 #ifdef CONFIG_MMC_CLKGATE
 	int			clk_requests;	/* internal reference counter */

commit f7c56ef2af5ae7e4c24c3c79427b38d18ba1d294
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Sep 23 12:48:21 2011 +0300

    mmc: block: support no access to boot partitions
    
    Intel Medfield platform blocks access to eMMC boot partitions which
    results in switch errors.  Since there is no access, mmcboot0/1
    devices should not be created.  Add a host capability to reflect that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b2aefea97048..aed5bc7245f7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -236,6 +236,10 @@ struct mmc_host {
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 #define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 
+	unsigned int		caps2;		/* More host capabilities */
+
+#define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
+
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
 #ifdef CONFIG_MMC_CLKGATE
@@ -404,4 +408,10 @@ static inline int mmc_host_cmd23(struct mmc_host *host)
 {
 	return host->caps & MMC_CAP_CMD23;
 }
+
+static inline int mmc_boot_partition_access(struct mmc_host *host)
+{
+	return !(host->caps2 & MMC_CAP2_BOOTPART_NOACC);
+}
+
 #endif /* LINUX_MMC_HOST_H */

commit b2499518b5ad7e28bb3ed348fd3f370eeb1e36c0
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Aug 29 16:42:11 2011 +0300

    mmc: core: add eMMC hardware reset support
    
    eMMC's may have a hardware reset line.  This patch provides a
    host controller operation to implement hardware reset and
    a function to reset and reinitialize the card.  Also, for MMC,
    the reset is always performed before initialization.
    
    The host must set the new host capability MMC_CAP_HW_RESET
    to enable hardware reset.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 340cc0c9409f..b2aefea97048 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -151,6 +151,7 @@ struct mmc_host_ops {
 	int	(*execute_tuning)(struct mmc_host *host);
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
+	void	(*hw_reset)(struct mmc_host *host);
 };
 
 struct mmc_card;
@@ -233,6 +234,7 @@ struct mmc_host {
 #define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
 #define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
+#define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 7c8a2829c22a270acadc6aa3a937e2e7956b19f5
Author: Per Forlin <per.forlin@linaro.org>
Date:   Mon Aug 29 15:35:58 2011 +0200

    mmc: core: clarify how to use post_req in case of errors
    
    The err condition in post_req() is set to undo a call made to pre_req()
    that hasn't been started yet.  The err condition is not set if an MMC
    request returns an error.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4c4bddf5ef61..340cc0c9409f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -109,6 +109,9 @@ struct mmc_host_ops {
 	 * It is optional for the host to implement pre_req and post_req in
 	 * order to support double buffering of requests (prepare one
 	 * request while another request is active).
+	 * pre_req() must always be followed by a post_req().
+	 * To undo a call made to pre_req(), call post_req() with
+	 * a nonzero err condition.
 	 */
 	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
 			    int err);

commit 1b676f70c108cda90cf9d114d16c677584400efc
Author: Per Forlin <per.forlin@linaro.org>
Date:   Fri Aug 19 14:52:37 2011 +0200

    mmc: core: add random fault injection
    
    This adds support to inject data errors after a completed host transfer.
    The mmc core will return error even though the host transfer is successful.
    This simple fault injection proved to be very useful to test the
    non-blocking error handling in the mmc_blk_issue_rw_rq().
    Random faults can also test how the host driver handles pre_req()
    and post_req() in case of errors.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 1d09562ccf73..4c4bddf5ef61 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -12,6 +12,7 @@
 
 #include <linux/leds.h>
 #include <linux/sched.h>
+#include <linux/fault-inject.h>
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/pm.h>
@@ -302,6 +303,10 @@ struct mmc_host {
 
 	struct mmc_async_req	*areq;		/* active async req */
 
+#ifdef CONFIG_FAIL_MMC_REQUEST
+	struct fault_attr	fail_mmc_request;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 7fd781e8f9b72544a1c7f04456eb33d5ffaed592
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Aug 8 18:10:52 2011 +0900

    mmc: remove unused "ddr" parameter in struct mmc_ios
    
    "mmc: dw_mmc: Fix DDR mode support" removed the last user.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0f83858147a6..1d09562ccf73 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -56,8 +56,6 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_SDR104	4
 #define MMC_TIMING_UHS_DDR50	5
 
-	unsigned char	ddr;			/* dual data rate used */
-
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1
 #define MMC_1_8V_DDR_MODE	2

commit ca8e99b32e3863c98ac958617cc157a00bf445b8
Author: Philip Rakity <prakity@marvell.com>
Date:   Wed Jul 6 08:51:32 2011 -0700

    mmc: core: Set non-default Drive Strength via platform hook
    
    Non default Drive Strength cannot be set automatically.  It is a function
    of the board design and only if there is a specific platform handler can
    it be set.  The platform handler needs to take into account the board
    design.  Pass to the platform code the necessary information.
    
    For example:  The card and host controller may indicate they support HIGH
    and LOW drive strength.  There is no way to know what should be chosen
    without specific board knowledge.  Setting HIGH may lead to reflections
    and setting LOW may not suffice.  There is no mechanism (like ethernet
    duplex or speed pulses) to determine what should be done automatically.
    
    If no platform handler is defined -- use the default value.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9f9a4c64cde7..0f83858147a6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -148,6 +148,7 @@ struct mmc_host_ops {
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*execute_tuning)(struct mmc_host *host);
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
+	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 };
 
 struct mmc_card;

commit aa8b683a7d392271ed349c6ab9f36b8c313794b7
Author: Per Forlin <per.forlin@linaro.org>
Date:   Fri Jul 1 18:55:22 2011 +0200

    mmc: core: add non-blocking mmc request function
    
    Previously there has only been one function mmc_wait_for_req()
    to start and wait for a request. This patch adds:
    
     * mmc_start_req() - starts a request wihtout waiting
       If there is on ongoing request wait for completion
       of that request and start the new one and return.
       Does not wait for the new command to complete.
    
    This patch also adds new function members in struct mmc_host_ops
    only called from core.c:
    
     * pre_req - asks the host driver to prepare for the next job
     * post_req - asks the host driver to clean up after a completed job
    
    The intention is to use pre_req() and post_req() to do cache maintenance
    while a request is active. pre_req() can be called while a request is
    active to minimize latency to start next job. post_req() can be used after
    the next job is started to clean up the request. This will minimize the
    host driver request end latency. post_req() is typically used before
    ending the block request and handing over the buffer to the block layer.
    
    Add a host-private member in mmc_data to be used by pre_req to mark the
    data. The host driver will then check this mark to see if the data is
    prepared or not.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Venkatraman S <svenkatr@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c67d19b5542a..9f9a4c64cde7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -106,6 +106,15 @@ struct mmc_host_ops {
 	 */
 	int (*enable)(struct mmc_host *host);
 	int (*disable)(struct mmc_host *host, int lazy);
+	/*
+	 * It is optional for the host to implement pre_req and post_req in
+	 * order to support double buffering of requests (prepare one
+	 * request while another request is active).
+	 */
+	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
+			    int err);
+	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
+			   bool is_first_req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	/*
 	 * Avoid calling these three functions too often or in a "fast path",
@@ -144,6 +153,16 @@ struct mmc_host_ops {
 struct mmc_card;
 struct device;
 
+struct mmc_async_req {
+	/* active mmc request */
+	struct mmc_request	*mrq;
+	/*
+	 * Check error status of completed mmc request.
+	 * Returns 0 if success otherwise non zero.
+	 */
+	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
+};
+
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -282,6 +301,8 @@ struct mmc_host {
 
 	struct dentry		*debugfs_root;
 
+	struct mmc_async_req	*areq;		/* active async req */
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit e056a1b5b67b4e4bfad00bf143ab14f634777705
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Jun 28 17:16:02 2011 +0300

    mmc: queue: let host controllers specify maximum discard timeout
    
    Some host controllers will not operate without a hardware
    timeout that is limited in value.  However large discards
    require large timeouts, so there needs to be a way to
    specify the maximum discard size.
    
    A host controller driver may now specify the maximum discard
    timeout possible so that max_discard_sectors can be calculated.
    
    However, for eMMC when the High Capacity Erase Group Size
    is not in use, the timeout calculation depends on clock
    rate which may change.  For that case Preferred Erase Size
    is used instead.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index fc24b38b48cb..c67d19b5542a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -231,6 +231,7 @@ struct mmc_host {
 	unsigned int		max_req_size;	/* maximum number of bytes in one req */
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */
 	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
+	unsigned int		max_discard_to;	/* max. discard timeout in ms */
 
 	/* private data */
 	spinlock_t		lock;		/* lock for claim and bus ops */

commit 100e918610b7487fa18db97b3879cd8d1fdd5974
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri May 27 16:04:03 2011 -0400

    mmc: Standardize header file inclusion checks.
    
    Standardize the checks for multiple MMC header file inclusion,
    including adding comments to terminating #endif's, and fixing
    one incorrect comment.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 1ee4424462eb..fc24b38b48cb 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -373,5 +373,4 @@ static inline int mmc_host_cmd23(struct mmc_host *host)
 {
 	return host->caps & MMC_CAP_CMD23;
 }
-#endif
-
+#endif /* LINUX_MMC_HOST_H */

commit 8c1c77ff9be27137fa7cbbf51efedef1a2ae915b
Merge: f3ae1c752035 08ee80cc397a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 25 16:55:55 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (75 commits)
      mmc: core: eMMC bus width may not work on all platforms
      mmc: sdhci: Auto-CMD23 fixes.
      mmc: sdhci: Auto-CMD23 support.
      mmc: core: Block CMD23 support for UHS104/SDXC cards.
      mmc: sdhci: Implement MMC_CAP_CMD23 for SDHCI.
      mmc: core: Use CMD23 for multiblock transfers when we can.
      mmc: quirks: Add/remove quirks conditional support.
      mmc: Add new VUB300 USB-to-SD/SDIO/MMC driver
      mmc: sdhci-pxa: Add quirks for DMA/ADMA to match h/w
      mmc: core: duplicated trial with same freq in mmc_rescan_try_freq()
      mmc: core: add support for eMMC Dual Data Rate
      mmc: core: eMMC signal voltage does not use CMD11
      mmc: sdhci-pxa: add platform code for UHS signaling
      mmc: sdhci: add hooks for setting UHS in platform specific code
      mmc: core: clear MMC_PM_KEEP_POWER flag on resume
      mmc: dw_mmc: fixed wrong regulator_enable in suspend/resume
      mmc: sdhi: allow powering down controller with no card inserted
      mmc: tmio: runtime suspend the controller, where possible
      mmc: sdhi: support up to 3 interrupt sources
      mmc: sdhi: print physical base address and clock rate
      ...

commit d0c97cfb81ebc5b416c0f92fa2fc18d2773e3023
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:36 2011 -0500

    mmc: core: Use CMD23 for multiblock transfers when we can.
    
    CMD23-prefixed instead of open-ended multiblock transfers
    have a performance advantage on some MMC cards.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index de32e6aa018a..e946bd10fe3f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -210,6 +210,7 @@ struct mmc_host {
 #define MMC_CAP_MAX_CURRENT_400	(1 << 27)	/* Host max current limit is 400mA */
 #define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
 #define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
+#define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
@@ -366,5 +367,10 @@ static inline int mmc_card_wake_sdio_irq(struct mmc_host *host)
 {
 	return host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;
 }
+
+static inline int mmc_host_cmd23(struct mmc_host *host)
+{
+	return host->caps & MMC_CAP_CMD23;
+}
 #endif
 

commit 4c4cb171054230c2e58ed6574d7faa1871c75bbe
Author: Philip Rakity <prakity@marvell.com>
Date:   Fri May 13 11:17:18 2011 +0530

    mmc: core: add support for eMMC Dual Data Rate
    
    eMMC voltage change not required for 1.8V.  3.3V and 1.8V vcc
    are capable of doing DDR. vccq of 1.8v is not required.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6716bd12eccd..de32e6aa018a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -66,6 +66,7 @@ struct mmc_ios {
 
 #define MMC_SIGNAL_VOLTAGE_330	0
 #define MMC_SIGNAL_VOLTAGE_180	1
+#define MMC_SIGNAL_VOLTAGE_120	2
 
 	unsigned char	drv_type;		/* driver type (A, B, C, D) */
 

commit 4d55c5a13a189a80d40383f02c8026f9a87d7c87
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:05 2011 +0530

    mmc: sdhci: enable preset value after uhs initialization
    
    According to the Host Controller spec v3.00, setting Preset Value Enable
    in the Host Control2 register lets SDCLK Frequency Select, Clock Generator
    Select and Driver Strength Select to be set automatically by the Host
    Controller based on the UHS-I mode set. This patch enables this feature.
    Since Preset Value Enable makes sense only for UHS-I cards, we enable this
    feature after successfull UHS-I initialization. We also reset Preset Value
    Enable next time before initialization.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ca7007fdb399..6716bd12eccd 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -137,6 +137,7 @@ struct mmc_host_ops {
 
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*execute_tuning)(struct mmc_host *host);
+	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 };
 
 struct mmc_card;

commit b513ea250eb7c36a8afb3df938d632ca6b4df7cd
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:04 2011 +0530

    mmc: sd: add support for tuning during uhs initialization
    
    Host Controller needs tuning during initialization to operate SDR50
    and SDR104 UHS-I cards. Whether SDR50 mode actually needs tuning is
    indicated by bit 45 of the Host Controller Capabilities register.
    A new command CMD19 has been defined in the Physical Layer spec
    v3.01 to request the card to send tuning pattern.
    
    We enable Buffer Read Ready interrupt at the very begining of tuning
    procedure, because that is the only interrupt generated by the Host
    Controller during tuning. We program the block size to 64 in the
    Block Size register. We make sure that DMA Enable and Multi Block
    Select in the Transfer Mode register are set to 0 before actually
    sending CMD19. The tuning block is sent by the card to the Host
    Controller using DAT lines, so we set Data Present Select (bit 5) in
    the Command register. The Host Controller is responsible for doing
    the verfication of tuning block sent by the card at the hardware
    level. After sending CMD19, we wait for Buffer Read Ready interrupt.
    In case we don't receive an interrupt after the specified timeout
    value, we fall back on fixed sampling clock by setting Execute
    Tuning (bit 6) and Sampling Clock Select (bit 7) of Host Control2
    register to 0. Before exiting the tuning procedure, we disable Buffer
    Read Ready interrupt and re-enable other interrupts.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 52b5dc914a8c..ca7007fdb399 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -136,6 +136,7 @@ struct mmc_host_ops {
 	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
 
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
+	int	(*execute_tuning)(struct mmc_host *host);
 };
 
 struct mmc_card;

commit 5371c927bcd06a5c9dd6785bab2d452b87d9abc6
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:02 2011 +0530

    mmc: sd: set current limit for uhs cards
    
    We decide on the current limit to be set for the card based on the
    Capability of Host Controller to provide current at 1.8V signalling,
    and the maximum current limit of the card as indicated by CMD6
    mode 0. We then set the current limit for the card using CMD6 mode 1.
    As per the Physical Layer Spec v3.01, the current limit switch is
    only applicable for SDR50, SDR104, and DDR50 bus speed modes. For
    other UHS-I modes, we set the default current limit of 200mA.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 62375992bdd6..52b5dc914a8c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -203,6 +203,10 @@ struct mmc_host {
 #define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
 #define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
 #define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
+#define MMC_CAP_MAX_CURRENT_200	(1 << 26)	/* Host max current limit is 200mA */
+#define MMC_CAP_MAX_CURRENT_400	(1 << 27)	/* Host max current limit is 400mA */
+#define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
+#define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 49c468fcf878d2c86e31920cf54aa90c88418a66
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:01 2011 +0530

    mmc: sd: add support for uhs bus speed mode selection
    
    This patch adds support for setting UHS-I bus speed mode during UHS-I
    initialization procedure. Since both the host and card can support
    more than one bus speed, we select the highest speed based on both of
    their capabilities. First we set the bus speed mode for the card using
    CMD6 mode 1, and then we program the host controller to support the
    required speed mode. We also set High Speed Enable in case one of the
    UHS-I modes is selected. We take care to reset SD clock before setting
    UHS mode in the Host Control2 register, and then re-enable it as per
    the Host Controller spec v3.00. We then set the clock frequency for
    the UHS-I mode selected.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 949e4d525989..62375992bdd6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -50,6 +50,11 @@ struct mmc_ios {
 #define MMC_TIMING_LEGACY	0
 #define MMC_TIMING_MMC_HS	1
 #define MMC_TIMING_SD_HS	2
+#define MMC_TIMING_UHS_SDR12	MMC_TIMING_LEGACY
+#define MMC_TIMING_UHS_SDR25	MMC_TIMING_SD_HS
+#define MMC_TIMING_UHS_SDR50	3
+#define MMC_TIMING_UHS_SDR104	4
+#define MMC_TIMING_UHS_DDR50	5
 
 	unsigned char	ddr;			/* dual data rate used */
 

commit d6d50a15a2897d4133d536dd4343b5cf21163db3
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:59 2011 +0530

    mmc: sd: add support for driver type selection
    
    This patch adds support for setting driver strength during UHS-I
    initialization procedure. Since UHS-I cards set S18A (bit 24) in
    response to ACMD41, we use this as a base for UHS-I initialization.
    We modify the parameter list of mmc_sd_get_cid() so that we can
    save the ROCR from ACMD41 to check whether bit 24 is set.
    
    We decide whether the Host Controller supports A, C, or D driver
    type depending on the Capabilities register. Driver type B is
    suported by default. We then set the appropriate driver type for
    the card using CMD6 mode 1. As per Host Controller spec v3.00, we
    set driver type for the host only if Preset Value Enable in the
    Host Control2 register is not set. SDHCI_HOST_CONTROL has been
    renamed to SDHCI_HOST_CONTROL1 to conform to the spec.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bde5a0b1c47e..949e4d525989 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -61,6 +61,13 @@ struct mmc_ios {
 
 #define MMC_SIGNAL_VOLTAGE_330	0
 #define MMC_SIGNAL_VOLTAGE_180	1
+
+	unsigned char	drv_type;		/* driver type (A, B, C, D) */
+
+#define MMC_SET_DRIVER_TYPE_B	0
+#define MMC_SET_DRIVER_TYPE_A	1
+#define MMC_SET_DRIVER_TYPE_C	2
+#define MMC_SET_DRIVER_TYPE_D	3
 };
 
 struct mmc_host_ops {
@@ -188,6 +195,9 @@ struct mmc_host {
 #define MMC_CAP_SET_XPC_330	(1 << 20)	/* Host supports >150mA current at 3.3V */
 #define MMC_CAP_SET_XPC_300	(1 << 21)	/* Host supports >150mA current at 3.0V */
 #define MMC_CAP_SET_XPC_180	(1 << 22)	/* Host supports >150mA current at 1.8V */
+#define MMC_CAP_DRIVER_TYPE_A	(1 << 23)	/* Host supports Driver Type A */
+#define MMC_CAP_DRIVER_TYPE_C	(1 << 24)	/* Host supports Driver Type C */
+#define MMC_CAP_DRIVER_TYPE_D	(1 << 25)	/* Host supports Driver Type D */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit f2119df6b764609af4baceb68caf1e848c1c8aa7
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:57 2011 +0530

    mmc: sd: add support for signal voltage switch procedure
    
    Host Controller v3.00 adds another Capabilities register. Apart
    from other things, this new register indicates whether the Host
    Controller supports SDR50, SDR104, and DDR50 UHS-I modes. The spec
    doesn't mention about explicit support for SDR12 and SDR25 UHS-I
    modes, so the Host Controller v3.00 should support them by default.
    Also if the controller supports SDR104 mode, it will also support
    SDR50 mode as well. So depending on the host support, we set the
    corresponding MMC_CAP_* flags. One more new register. Host Control2
    is added in v3.00, which is used during Signal Voltage Switch
    procedure described below.
    
    Since as per v3.00 spec, UHS-I supported hosts should set S18R
    to 1, we set S18R (bit 24) of OCR before sending ACMD41. We also
    need to set XPC (bit 28) of OCR in case the host can supply >150mA.
    This support is indicated by the Maximum Current Capabilities
    register of the Host Controller.
    
    If the response of ACMD41 has both CCS and S18A set, we start the
    signal voltage switch procedure, which if successfull, will switch
    the card from 3.3V signalling to 1.8V signalling. Signal voltage
    switch procedure adds support for a new command CMD11 in the
    Physical Layer Spec v3.01. As part of this procedure, we need to
    set 1.8V Signalling Enable (bit 3) of Host Control2 register, which
    if remains set after 5ms, means the switch to 1.8V signalling is
    successfull. Otherwise, we clear bit 24 of OCR and retry the
    initialization sequence. When we remove the card, and insert the
    same or another card, we need to make sure that we start with 3.3V
    signalling voltage. So we call mmc_set_signal_voltage() with
    MMC_SIGNAL_VOLTAGE_330 set so that we are back to 3.3V signalling
    voltage before we actually start initializing the card.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0fffa5cdc183..bde5a0b1c47e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -56,6 +56,11 @@ struct mmc_ios {
 #define MMC_SDR_MODE		0
 #define MMC_1_2V_DDR_MODE	1
 #define MMC_1_8V_DDR_MODE	2
+
+	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
+
+#define MMC_SIGNAL_VOLTAGE_330	0
+#define MMC_SIGNAL_VOLTAGE_180	1
 };
 
 struct mmc_host_ops {
@@ -117,6 +122,8 @@ struct mmc_host_ops {
 
 	/* optional callback for HC quirks */
 	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
+
+	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
 };
 
 struct mmc_card;
@@ -173,6 +180,14 @@ struct mmc_host {
 						/* DDR mode at 1.2V */
 #define MMC_CAP_POWER_OFF_CARD	(1 << 13)	/* Can power off after boot */
 #define MMC_CAP_BUS_WIDTH_TEST	(1 << 14)	/* CMD14/CMD19 bus width ok */
+#define MMC_CAP_UHS_SDR12	(1 << 15)	/* Host supports UHS SDR12 mode */
+#define MMC_CAP_UHS_SDR25	(1 << 16)	/* Host supports UHS SDR25 mode */
+#define MMC_CAP_UHS_SDR50	(1 << 17)	/* Host supports UHS SDR50 mode */
+#define MMC_CAP_UHS_SDR104	(1 << 18)	/* Host supports UHS SDR104 mode */
+#define MMC_CAP_UHS_DDR50	(1 << 19)	/* Host supports UHS DDR50 mode */
+#define MMC_CAP_SET_XPC_330	(1 << 20)	/* Host supports >150mA current at 3.3V */
+#define MMC_CAP_SET_XPC_300	(1 << 21)	/* Host supports >150mA current at 3.0V */
+#define MMC_CAP_SET_XPC_180	(1 << 22)	/* Host supports >150mA current at 1.8V */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 6b93d01fe5971951911a070f51f412d50e9536dc
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:43:21 2011 +0300

    mmc: do not switch to 1-bit mode if not required
    
    6b5eda36 followed SDIO spec part E1 section 8, which states that
    in case SDIO interrupts are being used to wake up a suspended host,
    then it is required to switch to 1-bit mode before stopping the clock.
    
    Before switching to 1-bit mode (or back to 4-bit mode on resume),
    make sure that SDIO interrupts are really being used to wake the host.
    
    This is helpful for devices which have an external irq line (e.g.
    wl1271), and do not use SDIO interrupts to wake up the host.
    
    In this case, switching to 1-bit mode (and back to 4-bit mode on resume)
    is not necessary.
    
    Reported-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8ad3a9c6f495..0fffa5cdc183 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -325,5 +325,9 @@ static inline int mmc_card_keep_power(struct mmc_host *host)
 	return host->pm_flags & MMC_PM_KEEP_POWER;
 }
 
+static inline int mmc_card_wake_sdio_irq(struct mmc_host *host)
+{
+	return host->pm_flags & MMC_PM_WAKE_SDIO_IRQ;
+}
 #endif
 

commit a5e9425d2010978c5f85986cc70a9fa0c0d5b912
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:43:20 2011 +0300

    mmc: mmc_card_keep_power cleanups
    
    mmc_card_is_powered_resumed is a mouthful; instead, simply use
    mmc_card_keep_power, which also better explains the purpose of
    the macro.
    
    Employ mmc_card_keep_power() where possible.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index eb792cb6d745..8ad3a9c6f495 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -320,7 +320,7 @@ static inline int mmc_card_is_removable(struct mmc_host *host)
 	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
 }
 
-static inline int mmc_card_is_powered_resumed(struct mmc_host *host)
+static inline int mmc_card_keep_power(struct mmc_host *host)
 {
 	return host->pm_flags & MMC_PM_KEEP_POWER;
 }

commit 86f315bbb2374f1f077500ad131dd9b71856e697
Author: Chris Ball <cjb@laptop.org>
Date:   Mon May 16 11:32:26 2011 -0400

    Revert "mmc: fix a race between card-detect rescan and clock-gate work instances"
    
    This reverts commit 26fc8775b51484d8c0a671198639c6d5ae60533e, which has
    been reported to cause boot/resume-time crashes for some users:
    
    https://bbs.archlinux.org/viewtopic.php?id=118751.
    
    Signed-off-by: Chris Ball <cjb@laptop.org>
    Cc: <stable@kernel.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index eb792cb6d745..bcb793ec7374 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -183,6 +183,7 @@ struct mmc_host {
 	struct work_struct	clk_gate_work; /* delayed clock gate */
 	unsigned int		clk_old;	/* old clock value cache */
 	spinlock_t		clk_lock;	/* lock for clk fields */
+	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
 #endif
 
 	/* host specific block data */

commit 26fc8775b51484d8c0a671198639c6d5ae60533e
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Fri Apr 15 20:08:19 2011 +0200

    mmc: fix a race between card-detect rescan and clock-gate work instances
    
    Currently there is a race in the MMC core between a card-detect
    rescan work and the clock-gating work, scheduled from a command
    completion. Fix it by removing the dedicated clock-gating mutex
    and using the MMC standard locking mechanism instead.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <damm@opensource.se>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bcb793ec7374..eb792cb6d745 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -183,7 +183,6 @@ struct mmc_host {
 	struct work_struct	clk_gate_work; /* delayed clock gate */
 	unsigned int		clk_old;	/* old clock value cache */
 	spinlock_t		clk_lock;	/* lock for clk fields */
-	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
 #endif
 
 	/* host specific block data */

commit 22113efd00491310da802f3b1a9a66cfcf415fac
Author: Aries Lee <arieslee@jmicron.com>
Date:   Wed Dec 15 08:14:24 2010 +0100

    mmc: Test bus-width for old MMC devices
    
    Some old MMC devices fail with the 4/8 bits the driver tries to use
    exclusively.  This patch adds a test for the given bus setup and falls
    back to the lower bit mode (until 1-bit mode) when the test fails.
    
    [Major rework and refactoring by tiwai]
    [Quirk addition and many fixes by prakity]
    
    Signed-off-by: Aries Lee <arieslee@jmicron.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3a85e73a38a9..bcb793ec7374 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -172,6 +172,7 @@ struct mmc_host {
 #define MMC_CAP_1_2V_DDR	(1 << 12)	/* can support */
 						/* DDR mode at 1.2V */
 #define MMC_CAP_POWER_OFF_CARD	(1 << 13)	/* Can power off after boot */
+#define MMC_CAP_BUS_WIDTH_TEST	(1 << 14)	/* CMD14/CMD19 bus width ok */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 080bc9774b6f1e3866747b18631bad26f47c22ce
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sun Nov 28 07:21:29 2010 +0200

    mmc: sdio: don't reinitialize nonremovable powered-resumed cards
    
    Upon system resume, SDIO core must reinitialize cards that were
    powered off during suspend.
    
    If the card had its power kept during suspend (and thus it is
    'powered-resumed'), SDIO core performs only a limited reinitializing,
    mainly needed to make sure that the card wasn't removed/replaced.
    
    If a __nonremovable__ card is powered-resumed, we can safely skip the
    reinitializing phase.
    
    Note: 9b966aa (mmc: sdio: fully reconfigure oldcard on resume) removed
    the bus width reconfiguration since mmc_sdio_init_card already does it.
    It is brought back now in case mmc_sdio_init_card is skipped.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4a9d9d2589c7..3a85e73a38a9 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -320,5 +320,10 @@ static inline int mmc_card_is_removable(struct mmc_host *host)
 	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
 }
 
+static inline int mmc_card_is_powered_resumed(struct mmc_host *host)
+{
+	return host->pm_flags & MMC_PM_KEEP_POWER;
+}
+
 #endif
 

commit 8f230f454fe04ba326ffaead3a6b88dcf44eaf4b
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Dec 8 10:04:30 2010 +0100

    mmc: Add support for JMicron 388 SD/MMC controller
    
    JMicron 388 SD/MMC combo controller supports the 1.8V low-voltage for
    SD, but MMC doesn't work with the low-voltage, resulting in an error
    at probing.
    
    This patch adds the support for multiple voltage mask per device type,
    so that SD works with 1.8V while MMC forces 3.3V.  Here new ocr_avail_*
    fields for each device are introduced, so that the actual OCR mask is
    switched dynamically.
    
    Also, the restriction of low-voltage in core/sd.c is removed when the
    bit is allowed explicitly via ocr_avail_sd mask.
    
    This patch was rewritten from scratch based on Aries' original code.
    
    Signed-off-by: Aries Lee <arieslee@jmicron.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 381c77fd4dca..4a9d9d2589c7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -131,6 +131,9 @@ struct mmc_host {
 	unsigned int		f_max;
 	unsigned int		f_init;
 	u32			ocr_avail;
+	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
+	u32			ocr_avail_sd;	/* SD-specific OCR */
+	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct notifier_block	pm_notify;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */

commit 04566831a703ae3ef4b49a2deae261c9ed26e020
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Mon Nov 8 21:36:50 2010 -0500

    mmc: Aggressive clock gating framework
    
    This patch modifies the MMC core code to optionally call the set_ios()
    operation on the driver with the clock frequency set to 0 (gate) after
    a grace period of at least 8 MCLK cycles, then restore it (ungate)
    before any new request. This gives the driver the option to shut down
    the MCI clock to the MMC/SD card when the clock frequency is 0, i.e.
    the core has stated that the MCI clock does not need to be generated.
    
    It is inspired by existing clock gating code found in the OMAP and
    Atmel drivers and brings this up to the host abstraction.  Gating is
    performed before and after any MMC request.
    
    This patchset implements this for the MMCI/PL180 MMC/SD host controller,
    but it should be simple to switch OMAP/Atmel over to using this instead.
    
    mmc_set_{gated,ungated}() add variable protection to the state holders
    for the clock gating code.  This is particularly important when ordinary
    .set_ios() calls would race with the .set_ios() call resulting from a
    delayed gate operation.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Tested-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 30f6fad99a58..381c77fd4dca 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -172,6 +172,16 @@ struct mmc_host {
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
+#ifdef CONFIG_MMC_CLKGATE
+	int			clk_requests;	/* internal reference counter */
+	unsigned int		clk_delay;	/* number of MCI clk hold cycles */
+	bool			clk_gated;	/* clock gated */
+	struct work_struct	clk_gate_work; /* delayed clock gate */
+	unsigned int		clk_old;	/* old clock value cache */
+	spinlock_t		clk_lock;	/* lock for clk fields */
+	struct mutex		clk_gate_mutex;	/* mutex for clock gating */
+#endif
+
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_segs;	/* see blk_queue_max_segments */

commit ed919b0125b26dcc052e44836f66e7e1f5c49c7e
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Fri Nov 19 09:29:09 2010 +0200

    mmc: sdio: fix runtime PM anomalies by introducing MMC_CAP_POWER_OFF_CARD
    
    Some board/card/host configurations are not capable of powering off the
    card after boot.
    
    To support such configurations, and to allow smoother transition to
    runtime PM behavior, MMC_CAP_POWER_OFF_CARD is added, so hosts need to
    explicitly indicate whether it's OK to power off their cards after boot.
    
    SDIO core will enable runtime PM for a card only if that cap is set.
    As a result, the card will be powered down after boot, and will only
    be powered up again when a driver is loaded (and then it's up to the
    driver to decide whether power will be kept or not).
    
    This will prevent sdio_bus_probe() failures with setups that do not
    support powering off the card.
    
    Reported-and-tested-by: Daniel Drake <dsd@laptop.org>
    Reported-and-tested-by: Arnd Hannemann <arnd@arndnet.de>
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6d87f68ce4b6..30f6fad99a58 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -168,6 +168,7 @@ struct mmc_host {
 						/* DDR mode at 1.8V */
 #define MMC_CAP_1_2V_DDR	(1 << 12)	/* can support */
 						/* DDR mode at 1.2V */
+#define MMC_CAP_POWER_OFF_CARD	(1 << 13)	/* Can power off after boot */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 12ae637f081a7a05144af65802a7b492b9162660
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Sat Oct 2 13:54:06 2010 +0200

    mmc: propagate power save/restore ops return value
    
    Allow power save/restore and their relevant mmc_bus_ops handlers
    exit with a return value.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 69ee1ebe4302..6d87f68ce4b6 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -250,8 +250,8 @@ static inline void *mmc_priv(struct mmc_host *host)
 extern int mmc_suspend_host(struct mmc_host *);
 extern int mmc_resume_host(struct mmc_host *);
 
-extern void mmc_power_save_host(struct mmc_host *host);
-extern void mmc_power_restore_host(struct mmc_host *host);
+extern int mmc_power_save_host(struct mmc_host *host);
+extern int mmc_power_restore_host(struct mmc_host *host);
 
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);

commit 49e3b5a44f8abd33c8693edc575c6d06a210d778
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Mon Oct 11 12:43:50 2010 +0300

    mmc: refine DDR support
    
    One flaw with DDR support is that MMC core does not inform the driver
    which DDR mode it has selected.  This patch expands the ios->ddr flag
    to do that.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c4fb1c5efc44..69ee1ebe4302 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -54,7 +54,8 @@ struct mmc_ios {
 	unsigned char	ddr;			/* dual data rate used */
 
 #define MMC_SDR_MODE		0
-#define MMC_DDR_MODE		1
+#define MMC_1_2V_DDR_MODE	1
+#define MMC_1_8V_DDR_MODE	2
 };
 
 struct mmc_host_ops {

commit 0f8d8ea64ec7c77ca5beb59534d386fe0235961a
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Aug 24 13:20:26 2010 +0300

    mmc: Fixes for Dual Data Rate (DDR) support
    
    The DDR support patch needs the following fixes:
    
    - The block driver does not need to know about DDR, any more
      than it needs to know about bus width.
    - Not only the card must be switched to DDR mode.  The host
      controller must also be configured, which is done through
      the 'set_ios()' function.
    - Do not set the DDR mode state until after the switch command
      is successful.
    - Setting block length is not supported in DDR mode.  Make that
      a core function and change the other place it is used (mmc_test)
      also.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6711eb8715ba..c4fb1c5efc44 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -50,6 +50,11 @@ struct mmc_ios {
 #define MMC_TIMING_LEGACY	0
 #define MMC_TIMING_MMC_HS	1
 #define MMC_TIMING_SD_HS	2
+
+	unsigned char	ddr;			/* dual data rate used */
+
+#define MMC_SDR_MODE		0
+#define MMC_DDR_MODE		1
 };
 
 struct mmc_host_ops {

commit dfc13e8402c75e7c2e0a52e123c0500a3259866b
Author: Hanumath Prasad <hanumath.prasad@stericsson.com>
Date:   Thu Sep 30 17:37:23 2010 -0400

    mmc: MMC 4.4 DDR support
    
    Add support for Dual Data Rate MMC cards as defined in the 4.4
    specification.
    
    Signed-off-by: Hanumath Prasad <hanumath.prasad@stericsson.com>
    Cc: linux-mmc@vger.kernel.org
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Tested-by Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ccac56ae1286..6711eb8715ba 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -158,6 +158,10 @@ struct mmc_host {
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 #define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
+#define MMC_CAP_1_8V_DDR	(1 << 11)	/* can support */
+						/* DDR mode at 1.8V */
+#define MMC_CAP_1_2V_DDR	(1 << 12)	/* can support */
+						/* DDR mode at 1.2V */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 99fc5131018cbdc3cf42ce09fb394a4e8b053c74
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Sep 29 01:08:27 2010 -0400

    mmc: Move regulator handling closer to core
    
    After discovering a problem in regulator reference counting I took Mark
    Brown's advice to move the reference count into the MMC core by making the
    regulator status a member of struct mmc_host.
    
    I took this opportunity to also implement NULL versions of
    the regulator functions so as to rid the driver code from
    some ugly #ifdef CONFIG_REGULATOR clauses.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Sundar Iyer <sundar.iyer@stericsson.com>
    Cc: Daniel Mack <daniel@caiaq.de>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Cliff Brake <cbrake@bec-systems.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 20be040649a9..ccac56ae1286 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -212,6 +212,10 @@ struct mmc_host {
 	struct led_trigger	*led;		/* activity led */
 #endif
 
+#ifdef CONFIG_REGULATOR
+	bool			regulator_enabled; /* regulator state */
+#endif
+
 	struct dentry		*debugfs_root;
 
 	unsigned long		private[0] ____cacheline_aligned;
@@ -250,8 +254,24 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 
 struct regulator;
 
+#ifdef CONFIG_REGULATOR
 int mmc_regulator_get_ocrmask(struct regulator *supply);
-int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
+int mmc_regulator_set_ocr(struct mmc_host *mmc,
+			struct regulator *supply,
+			unsigned short vdd_bit);
+#else
+static inline int mmc_regulator_get_ocrmask(struct regulator *supply)
+{
+	return 0;
+}
+
+static inline int mmc_regulator_set_ocr(struct mmc_host *mmc,
+				 struct regulator *supply,
+				 unsigned short vdd_bit)
+{
+	return 0;
+}
+#endif
 
 int mmc_card_awake(struct mmc_host *host);
 int mmc_card_sleep(struct mmc_host *host);

commit 88ae8b866488031b0e2fc05a27440fefec5e6927
Author: Hein Tibosch <hein_tibosch@yahoo.es>
Date:   Mon Sep 6 09:37:19 2010 +0800

    mmc: Make ID freq configurable
    
    In the latest releases of the mmc driver, the freq during initialization
    is set to a fixed 400 Khz.  This was reportedly too fast for several
    users.  As there doesn't seem to be an ideal frequency
    which-works-for-all, Pierre suggested to let the driver try several
    frequencies.
    
    This patch implements that idea. It will try mmc-initialization using
    several frequencies from an array 400, 300, 200 and 100.
    
    In case SDIO is broken, it'll still try to detect SDMEM, also at different
    freqs.
    
    Signed-off-by: Hein Tibosch <hein_tibosch@yahoo.es>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Tested-by: Chris Ball <cjb@laptop.org>
    Cc: Ben Nizette <bn@niasdigital.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2e0fe623df90..20be040649a9 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -123,6 +123,7 @@ struct mmc_host {
 	const struct mmc_host_ops *ops;
 	unsigned int		f_min;
 	unsigned int		f_max;
+	unsigned int		f_init;
 	u32			ocr_avail;
 	struct notifier_block	pm_notify;
 

commit 71d7d3d190fe77588269a8febf93cd739bd91eb3
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 09:42:19 2010 +0100

    mmc: Add helper function to check if a card is removable
    
    There are two checks that need to be made when determining whether a
    card is removable. A host controller may set MMC_CAP_NONREMOVABLE if the
    controller does not support removing cards (e.g. eMMC), in which case
    the card is physically non-removable. Also the 'mmc_assume_removable'
    module parameter can be configured at module load time, in which case
    the card may be logically non-removable.
    
    A helper function keeps the logic in one place so that code always
    checks both conditions.
    
    Because this new function is likely to be called from modules we now
    need to export the mmc_assume_removable symbol.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ded401703762..2e0fe623df90 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -267,5 +267,13 @@ static inline void mmc_set_disable_delay(struct mmc_host *host,
 	host->disable_delay = disable_delay;
 }
 
+/* Module parameter */
+extern int mmc_assume_removable;
+
+static inline int mmc_card_is_removable(struct mmc_host *host)
+{
+	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
+}
+
 #endif
 

commit a36274e0184193e393fb82957925c3981a6b0477
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Sep 10 01:33:59 2010 -0400

    mmc: Remove distinction between hw and phys segments
    
    We have deprecated the distinction between hardware and physical
    segments in the block layer.  Consolidate the two limits into one in
    drivers/mmc/.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 1575b52c3bfa..ded401703762 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -162,8 +162,7 @@ struct mmc_host {
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
-	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */
-	unsigned short		max_phys_segs;	/* see blk_queue_max_phys_segments */
+	unsigned short		max_segs;	/* see blk_queue_max_segments */
 	unsigned short		unused;
 	unsigned int		max_req_size;	/* maximum number of bytes in one req */
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */

commit dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:46 2010 -0700

    mmc: add erase, secure erase, trim and secure trim operations
    
    SD/MMC cards tend to support an erase operation.  In addition, eMMC v4.4
    cards can support secure erase, trim and secure trim operations that are
    all variants of the basic erase command.
    
    SD/MMC device attributes "erase_size" and "preferred_erase_size" have been
    added.
    
    "erase_size" is the minimum size, in bytes, of an erase operation.  For
    MMC, "erase_size" is the erase group size reported by the card.  Note that
    "erase_size" does not apply to trim or secure trim operations where the
    minimum size is always one 512 byte sector.  For SD, "erase_size" is 512
    if the card is block-addressed, 0 otherwise.
    
    SD/MMC cards can erase an arbitrarily large area up to and
    including the whole card.  When erasing a large area it may
    be desirable to do it in smaller chunks for three reasons:
    
        1. A single erase command will make all other I/O on the card
           wait.  This is not a problem if the whole card is being erased, but
           erasing one partition will make I/O for another partition on the
           same card wait for the duration of the erase - which could be a
           several minutes.
    
        2. To be able to inform the user of erase progress.
    
        3. The erase timeout becomes too large to be very useful.
           Because the erase timeout contains a margin which is multiplied by
           the size of the erase area, the value can end up being several
           minutes for large areas.
    
    "erase_size" is not the most efficient unit to erase (especially for SD
    where it is just one sector), hence "preferred_erase_size" provides a good
    chunk size for erasing large areas.
    
    For MMC, "preferred_erase_size" is the high-capacity erase size if a card
    specifies one, otherwise it is based on the capacity of the card.
    
    For SD, "preferred_erase_size" is the allocation unit size specified by
    the card.
    
    "preferred_erase_size" is in bytes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 513ff0376b09..1575b52c3bfa 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -156,6 +156,7 @@ struct mmc_host {
 #define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
+#define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 

commit 4c2ef25fe0b847d2ae818f74758ddb0be1c27d8e
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Tue Aug 10 18:01:41 2010 -0700

    mmc: fix all hangs related to mmc/sd card insert/removal during suspend/resume
    
    If you don't use CONFIG_MMC_UNSAFE_RESUME, as soon as you attempt to
    suspend, the card will be removed, therefore this patch doesn't change the
    behavior of this option.
    
    However the removal will be done by pm notifier, which runs while
    userspace is still not frozen and thus can freely use del_gendisk, without
    the risk of deadlock which would happen otherwise.
    
    Card detect workqueue is now disabled while userspace is frozen, Therefore
    if you do use CONFIG_MMC_UNSAFE_RESUME, and remove the card during
    suspend, the removal will be detected as soon as userspace is unfrozen,
    again at the moment it is safe to call del_gendisk.
    
    Tested with and without CONFIG_MMC_UNSAFE_RESUME with suspend and hibernate.
    
    [akpm@linux-foundation.org: clean up function prototype]
    [akpm@linux-foundation.org: fix CONFIG_PM-n linkage, small cleanups]
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f65913c9f5a4..513ff0376b09 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -124,6 +124,7 @@ struct mmc_host {
 	unsigned int		f_min;
 	unsigned int		f_max;
 	u32			ocr_avail;
+	struct notifier_block	pm_notify;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -183,6 +184,7 @@ struct mmc_host {
 
 	/* Only used with MMC_CAP_DISABLE */
 	int			enabled;	/* host is enabled */
+	int			rescan_disable;	/* disable card detection */
 	int			nesting_cnt;	/* "enable" nesting count */
 	int			en_dis_recurs;	/* detect recursion */
 	unsigned int		disable_delay;	/* disable delay in msecs */
@@ -257,6 +259,7 @@ int mmc_card_can_sleep(struct mmc_host *host);
 int mmc_host_enable(struct mmc_host *host);
 int mmc_host_disable(struct mmc_host *host);
 int mmc_host_lazy_disable(struct mmc_host *host);
+int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
 static inline void mmc_set_disable_delay(struct mmc_host *host,
 					 unsigned int disable_delay)

commit 1a13f8fa76c880be41d6b1e6a2b44404bcbfdf9e
Author: Matt Fleming <matt@console-pimps.org>
Date:   Wed May 26 14:42:08 2010 -0700

    mmc: remove the "state" argument to mmc_suspend_host()
    
    Even though many mmc host drivers pass a pm_message_t argument to
    mmc_suspend_host() that argument isn't used the by MMC core.  As host
    drivers are converted to dev_pm_ops they'll have to construct
    pm_message_t's (as they won't be passed by the PM subsystem any more) just
    to appease the mmc suspend interface.
    
    We might as well just delete the unused paramter.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>ZZ
    Acked-by: Sascha Sommer <saschasommer@freenet.de>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3196c84cc630..f65913c9f5a4 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -230,7 +230,7 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
-extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
+extern int mmc_suspend_host(struct mmc_host *);
 extern int mmc_resume_host(struct mmc_host *);
 
 extern void mmc_power_save_host(struct mmc_host *host);

commit 3fcb027d7fd749569665d34a79ce2a8e00bc2ed6
Author: Daniel Mack <daniel@caiaq.de>
Date:   Thu Apr 1 10:03:25 2010 +0200

    ARM: MXC: mxcmmc: work around a bug in the SDHC busy line handling
    
    MX3 SoCs have a silicon bug which corrupts CRC calculation of
    multi-block transfers when connected SDIO peripheral doesn't drive the
    BUSY line as required by the specs.
    
    One way to prevent this is to only allow 1-bit transfers.
    
    Another way is playing tricks with the DMA engine, but this isn't
    mainline yet. So for now, we live with the performance drawback of 1-bit
    transfers until a nicer solution is found.
    
    This patch introduces a new host controller callback 'init_card' which
    is for now only called from mmc_sdio_init_card().
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Volker Ernst <volker.ernst@txtr.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Michał Mirosław <mirqus@gmail.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 43eaf5ca5848..3196c84cc630 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -108,6 +108,9 @@ struct mmc_host_ops {
 	int	(*get_cd)(struct mmc_host *host);
 
 	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);
+
+	/* optional callback for HC quirks */
+	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
 };
 
 struct mmc_card;

commit da68c4eb258cd9f3f0b8aeb7e46b8118bb6358b6
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Mar 5 13:43:31 2010 -0800

    sdio: introduce API for special power management features
    
    This patch series provides the core changes needed to allow SDIO cards to
    remain powered and active while the host system is suspended, and let them
    wake up the host system when needed.  This is used to implement
    wake-on-lan with SDIO wireless cards at the moment.  Patches to add that
    support to the libertas driver will be posted separately.
    
    This patch:
    
    Some SDIO cards have the ability to keep on running autonomously when the
    host system is suspended, and wake it up when needed.  This however
    requires that the host controller preserve power to the card, and
    configure itself appropriately for wake-up.
    
    There is however 4 layers of abstractions involved: the host controller
    driver, the MMC core code, the SDIO card management code, and the actual
    SDIO function driver.  To make things simple and manageable, host drivers
    must advertise their PM capabilities with a feature bitmask, then function
    drivers can query and set those features from their suspend method.  Then
    each layer in the suspend call chain is expected to act upon those bits
    accordingly.
    
    [akpm@linux-foundation.org: fix typo in comment]
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index eaf36364b7d4..43eaf5ca5848 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 
 #include <linux/mmc/core.h>
+#include <linux/mmc/pm.h>
 
 struct mmc_ios {
 	unsigned int	clock;			/* clock rate */
@@ -152,6 +153,8 @@ struct mmc_host {
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 
+	mmc_pm_flag_t		pm_caps;	/* supported pm features */
+
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */
@@ -197,6 +200,8 @@ struct mmc_host {
 	struct task_struct	*sdio_irq_thread;
 	atomic_t		sdio_irq_thread_abort;
 
+	mmc_pm_flag_t		pm_flags;	/* requested pm features */
+
 #ifdef CONFIG_LEDS_TRIGGERS
 	struct led_trigger	*led;		/* activity led */
 #endif

commit d43c36dc6b357fa1806800f18aa30123c747a6d1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Oct 7 17:09:06 2009 +0400

    headers: remove sched.h from interrupt.h
    
    After m68k's task_thread_info() doesn't refer to current,
    it's possible to remove sched.h from interrupt.h and not break m68k!
    Many thanks to Heiko Carstens for allowing this.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 81bb42358595..eaf36364b7d4 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -11,6 +11,7 @@
 #define LINUX_MMC_HOST_H
 
 #include <linux/leds.h>
+#include <linux/sched.h>
 
 #include <linux/mmc/core.h>
 

commit b1ebe38456f7fe61a88af2844361e763ac6ea5ae
Author: Jarkko Lavinen <jarkko.lavinen@nokia.com>
Date:   Tue Sep 22 16:44:34 2009 -0700

    mmc: add mmc card sleep and awake support
    
    Add support for the new MMC command SLEEP_AWAKE.
    
    Signed-off-by: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c1cbe598d470..81bb42358595 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -149,6 +149,7 @@ struct mmc_host {
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
 #define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
+#define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -240,6 +241,10 @@ struct regulator;
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
 
+int mmc_card_awake(struct mmc_host *host);
+int mmc_card_sleep(struct mmc_host *host);
+int mmc_card_can_sleep(struct mmc_host *host);
+
 int mmc_host_enable(struct mmc_host *host);
 int mmc_host_disable(struct mmc_host *host);
 int mmc_host_lazy_disable(struct mmc_host *host);

commit eae1aeeed852aae37621b82a9e7f6c05096a18fd
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:33 2009 -0700

    mmc: add ability to save power by powering off cards
    
    Power can be saved by powering off cards that are not in use.  This is
    similar to suspend / resume except it is under the control of the driver,
    and does not require any power management support.  It can only be used
    when the driver can monitor whether the card is removed, otherwise it is
    unsafe.  This is possible because, unlike suspend, the driver still
    receives card detect and / or cover switch interrupts.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bb867d2c26bd..c1cbe598d470 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -223,6 +223,9 @@ static inline void *mmc_priv(struct mmc_host *host)
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
 
+extern void mmc_power_save_host(struct mmc_host *host);
+extern void mmc_power_restore_host(struct mmc_host *host);
+
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 

commit 9feae246963c648b212abad0f0eb8938de5f5fe5
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:32 2009 -0700

    mmc: add MMC_CAP_NONREMOVABLE host capability
    
    eMMC's are not removable, so unsafe resume is OK always.
    
    To permit this a new host capability MMC_CAP_NONREMOVABLE has been added
    and suspend / resume updated accordingly.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 631a2fea5264..bb867d2c26bd 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -148,6 +148,7 @@ struct mmc_host {
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
 #define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
+#define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit 319a3f1429c91147058ac26c5f5bac8ec1730bc6
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:30 2009 -0700

    mmc: allow host claim / release nesting
    
    This change allows the MMC host to be claimed in situations where the host
    may or may not have already been claimed.  Also 'mmc_try_claim_host()' is
    now exported.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 338a9b3d51e4..631a2fea5264 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -182,6 +182,8 @@ struct mmc_host {
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
+	struct task_struct	*claimer;	/* task that has host claimed */
+	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
 

commit 8ea926b22e2d13238e4d65d8f61c48fe424e6f4f
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:29 2009 -0700

    mmc: add 'enable' and 'disable' methods to mmc host
    
    MMC hosts that support power saving can use the 'enable' and 'disable'
    methods to exit and enter power saving states.  An explanation of their
    use is provided in the comments added to include/linux/mmc/host.h.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3e7615e9087e..338a9b3d51e4 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -51,6 +51,35 @@ struct mmc_ios {
 };
 
 struct mmc_host_ops {
+	/*
+	 * Hosts that support power saving can use the 'enable' and 'disable'
+	 * methods to exit and enter power saving states. 'enable' is called
+	 * when the host is claimed and 'disable' is called (or scheduled with
+	 * a delay) when the host is released. The 'disable' is scheduled if
+	 * the disable delay set by 'mmc_set_disable_delay()' is non-zero,
+	 * otherwise 'disable' is called immediately. 'disable' may be
+	 * scheduled repeatedly, to permit ever greater power saving at the
+	 * expense of ever greater latency to re-enable. Rescheduling is
+	 * determined by the return value of the 'disable' method. A positive
+	 * value gives the delay in milliseconds.
+	 *
+	 * In the case where a host function (like set_ios) may be called
+	 * with or without the host claimed, enabling and disabling can be
+	 * done directly and will nest correctly. Call 'mmc_host_enable()' and
+	 * 'mmc_host_lazy_disable()' for this purpose, but note that these
+	 * functions must be paired.
+	 *
+	 * Alternatively, 'mmc_host_enable()' may be paired with
+	 * 'mmc_host_disable()' which calls 'disable' immediately.  In this
+	 * case the 'disable' method will be called with 'lazy' set to 0.
+	 * This is mainly useful for error paths.
+	 *
+	 * Because lazy disable may be called from a work queue, the 'disable'
+	 * method must claim the host when 'lazy' != 0, which will work
+	 * correctly because recursion is detected and handled.
+	 */
+	int (*enable)(struct mmc_host *host);
+	int (*disable)(struct mmc_host *host, int lazy);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	/*
 	 * Avoid calling these three functions too often or in a "fast path",
@@ -118,6 +147,7 @@ struct mmc_host {
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
+#define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -142,6 +172,13 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
+	/* Only used with MMC_CAP_DISABLE */
+	int			enabled;	/* host is enabled */
+	int			nesting_cnt;	/* "enable" nesting count */
+	int			en_dis_recurs;	/* detect recursion */
+	unsigned int		disable_delay;	/* disable delay in msecs */
+	struct delayed_work	disable;	/* disabling work */
+
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
@@ -197,5 +234,15 @@ struct regulator;
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
 
+int mmc_host_enable(struct mmc_host *host);
+int mmc_host_disable(struct mmc_host *host);
+int mmc_host_lazy_disable(struct mmc_host *host);
+
+static inline void mmc_set_disable_delay(struct mmc_host *host,
+					 unsigned int disable_delay)
+{
+	host->disable_delay = disable_delay;
+}
+
 #endif
 

commit 5c13941acc513669c7d07b28789c3f9ba66ddddf
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Mar 11 03:30:43 2009 -0800

    MMC: regulator utilities
    
    Glue between MMC and regulator stacks ... verified with
    some OMAP3 boards using adjustable and configured-as-fixed
    regulators on several MMC controllers.
    
    These calls are intended to be used by MMC host adapters
    using at least one regulator per host.  Examples include
    slots with regulators supporting multiple voltages and
    ones using multiple voltage rails (e.g. DAT4..DAT7 using a
    separate supply, or a split rail chip like certain SDIO
    WLAN or eMMC solutions).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4e457256bd33..3e7615e9087e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -192,5 +192,10 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 	wake_up_process(host->sdio_irq_thread);
 }
 
+struct regulator;
+
+int mmc_regulator_get_ocrmask(struct regulator *supply);
+int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
+
 #endif
 

commit b30f8af3358b5c66be223e3a9f3d11b3d02b4a8f
Author: Jarkko Lavinen <jarkko.lavinen@nokia.com>
Date:   Mon Nov 17 14:35:21 2008 +0200

    mmc: Add 8-bit bus width support
    
    Signed-off-by: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f842f234e44f..4e457256bd33 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -41,6 +41,7 @@ struct mmc_ios {
 
 #define MMC_BUS_WIDTH_1		0
 #define MMC_BUS_WIDTH_4		2
+#define MMC_BUS_WIDTH_8		3
 
 	unsigned char	timing;			/* timing specification used */
 
@@ -116,6 +117,7 @@ struct mmc_host {
 #define MMC_CAP_SDIO_IRQ	(1 << 3)	/* Can signal pending SDIO IRQs */
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
+#define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit d1b268630875a7713b5d468a0c03403c5b721c8e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Nov 8 21:37:46 2008 +0100

    mmc: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bde891f64591..f842f234e44f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -176,7 +176,7 @@ static inline void *mmc_priv(struct mmc_host *host)
 
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
-#define mmc_hostname(x)	((x)->class_dev.bus_id)
+#define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);

commit ee63a7d2287c677ed022bf3f584f5a187b6c402f
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 2 10:14:13 2008 +0200

    Fix comment in include/linux/mmc/host.h
    
    In include/linux/mmc/host.h, it is mentionned that the callback to
    know if a card is present or not is get_ro(). But it's get_cd().
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9c288c909878..bde891f64591 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -65,7 +65,7 @@ struct mmc_host_ops {
 	 *   -ENOSYS when not supported (equal to NULL callback)
 	 *   or a negative errno value when something bad happened
 	 *
-	 * Return values for the get_ro callback should be:
+	 * Return values for the get_cd callback should be:
 	 *   0 for a absent card
 	 *   1 for a present card
 	 *   -ENOSYS when not supported (equal to NULL callback)

commit 6edd8ee60ac9b974bd6ec3b1bcb2aab02762fa8c
Author: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
Date:   Thu Jul 24 14:18:57 2008 +0200

    mmc: Export internal host state through debugfs
    
    When CONFIG_DEBUG_FS is set, create a few files under /sys/kernel/debug
    containing information about an mmc host's internal state. Currently,
    just a single file is created, "ios", which contains information about
    the current operating parameters for the bus (clock speed, bus width,
    etc.)
    
    Host drivers can add additional files and directories under the host's
    root directory by passing the debugfs_root field in struct mmc_host as
    the 'parent' parameter to debugfs_create_*.
    
    Signed-off-by: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 10a2080086ca..9c288c909878 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -157,6 +157,8 @@ struct mmc_host {
 	struct led_trigger	*led;		/* activity led */
 #endif
 
+	struct dentry		*debugfs_root;
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 23af60398af2f5033e2f53665538a09f498dbc03
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jul 6 01:10:27 2008 +0200

    mmc: remove multiwrite capability
    
    Relax requirements on host controllers and only require that they do not
    report a transfer count than is larger than the actual one (i.e. a lower
    value is okay). This is how many other parts of the kernel behaves so
    upper layers should already be prepared to handle that scenario. This
    gives us a performance boost on MMC cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 753b7231b887..10a2080086ca 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -111,12 +111,11 @@ struct mmc_host {
 	unsigned long		caps;		/* Host capabilities */
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
-#define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
-#define MMC_CAP_MMC_HIGHSPEED	(1 << 2)	/* Can do MMC high-speed timing */
-#define MMC_CAP_SD_HIGHSPEED	(1 << 3)	/* Can do SD high-speed timing */
-#define MMC_CAP_SDIO_IRQ	(1 << 4)	/* Can signal pending SDIO IRQs */
-#define MMC_CAP_SPI		(1 << 5)	/* Talks only SPI protocols */
-#define MMC_CAP_NEEDS_POLL	(1 << 6)	/* Needs polling for card-detection */
+#define MMC_CAP_MMC_HIGHSPEED	(1 << 1)	/* Can do MMC high-speed timing */
+#define MMC_CAP_SD_HIGHSPEED	(1 << 2)	/* Can do SD high-speed timing */
+#define MMC_CAP_SDIO_IRQ	(1 << 3)	/* Can signal pending SDIO IRQs */
+#define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
+#define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit 08f80bb5196517a0dfe50dc7c10f234c0ff2f0e8
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jun 17 18:17:39 2008 +0400

    mmc: change .get_ro() callback semantics
    
    Now get_ro() callback must return 0/1 values for its logical states, and
    negative errno values in case of error. If particular host instance doesn't
    support RO/WP switch, it should return -ENOSYS.
    
    This patch changes some hosts in two ways:
    
    1. Now functions should be smart to not return negative values in
       "RO asserted" case (particularly gpio_ calls could return negative
       values for the outermost GPIOs).
    
       Also, board code usually passes get_ro() callbacks that directly return
       gpioreg & bit result, so at91_mci, imxmmc, pxamci and mmc_spi's get_ro()
       handlers need take special care when returning platform's values to the
       mmc core.
    
    2. In case of host instance didn't implement get_ro() callback, it should
       really return -ENOSYS and let the mmc core decide what to do about it
       (mmc core thinks the same way as the hosts, so it isn't functional
       change).
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6188e19d2331..753b7231b887 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -58,6 +58,18 @@ struct mmc_host_ops {
 	 *
 	 * Also note that these functions might sleep, so don't call them
 	 * in the atomic contexts!
+	 *
+	 * Return values for the get_ro callback should be:
+	 *   0 for a read/write card
+	 *   1 for a read-only card
+	 *   -ENOSYS when not supported (equal to NULL callback)
+	 *   or a negative errno value when something bad happened
+	 *
+	 * Return values for the get_ro callback should be:
+	 *   0 for a absent card
+	 *   1 for a present card
+	 *   -ENOSYS when not supported (equal to NULL callback)
+	 *   or a negative errno value when something bad happened
 	 */
 	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*get_ro)(struct mmc_host *host);

commit 28f52482b41edc88cdf575aa6ed414c6e116ce10
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jun 17 18:17:15 2008 +0400

    mmc: add support for card-detection polling
    
    Some hosts (and boards that use mmc_spi) do not use interrupts on the CD
    line, so they can't trigger mmc_detect_change. We want to poll the card
    and see if there was a change. 1 second poll interval seems resonable.
    
    This patch also implements .get_cd() host operation, that could be used
    by the hosts that are able to report card-detect status without need to
    talk MMC.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 7ab962fa1d73..6188e19d2331 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -51,8 +51,18 @@ struct mmc_ios {
 
 struct mmc_host_ops {
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+	/*
+	 * Avoid calling these three functions too often or in a "fast path",
+	 * since underlaying controller might implement them in an expensive
+	 * and/or slow way.
+	 *
+	 * Also note that these functions might sleep, so don't call them
+	 * in the atomic contexts!
+	 */
 	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*get_ro)(struct mmc_host *host);
+	int	(*get_cd)(struct mmc_host *host);
+
 	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);
 };
 
@@ -94,6 +104,7 @@ struct mmc_host {
 #define MMC_CAP_SD_HIGHSPEED	(1 << 3)	/* Can do SD high-speed timing */
 #define MMC_CAP_SDIO_IRQ	(1 << 4)	/* Can signal pending SDIO IRQs */
 #define MMC_CAP_SPI		(1 << 5)	/* Talks only SPI protocols */
+#define MMC_CAP_NEEDS_POLL	(1 << 6)	/* Needs polling for card-detection */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit cc3000e4ef13fa9f388f5a37f11c0fa3cc68112b
Author: Nicolas Pitre <nico@cam.org>
Date:   Thu Dec 6 23:12:46 2007 -0500

    mmc: remove unused 'mode' from the mmc_host structure
    
    This field and corresponding defines are simply never used anywhere
    in the code.  But its mere presence is enough to confuse some host
    driver authors who attempt to rely on it.  Let's eliminate the
    possibility for confusion and remove it entirely.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 125eee1407ff..7ab962fa1d73 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -118,10 +118,6 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
-	unsigned int		mode;		/* current card mode of host */
-#define MMC_MODE_MMC		0
-#define MMC_MODE_SD		1
-
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;

commit af8350c756cb48a738474738f7bf8c0e572fa057
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Sep 24 07:15:48 2007 +0200

    mmc: add led trigger
    
    Add a led trigger for each host controller that indicates if there
    is a request active on the controller.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 76eef94782f8..125eee1407ff 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -10,6 +10,8 @@
 #ifndef LINUX_MMC_HOST_H
 #define LINUX_MMC_HOST_H
 
+#include <linux/leds.h>
+
 #include <linux/mmc/core.h>
 
 struct mmc_ios {
@@ -133,6 +135,10 @@ struct mmc_host {
 	struct task_struct	*sdio_irq_thread;
 	atomic_t		sdio_irq_thread_abort;
 
+#ifdef CONFIG_LEDS_TRIGGERS
+	struct led_trigger	*led;		/* activity led */
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 97018580c40c8a31dd7ae744da3378c787a2066d
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 8 09:09:01 2007 -0700

    MMC headers learn about SPI
    
    Teach the MMC/SD/SDIO system headers that some hosts use SPI mode
    
     - New host capabilities and status bits
        * MMC_CAP_SPI, with mmc_host_is_spi() test
        * mmc_host.use_spi_crc flag
    
     - SPI-specific declarations:
        * Response types, MMC_RSP_SPI_R*
        * Two SPI-only commands
        * Status bits used native to SPI:  R1_SPI_*, R2_SPI_*
    
     - Fix a few (unrelated) whitespace bugs in the headers.
    
     - Reorder a few mmc_host fields, removing several bytes of padding
    
    None of these changes affect current code.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 3fd197962f73..76eef94782f8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -91,6 +91,7 @@ struct mmc_host {
 #define MMC_CAP_MMC_HIGHSPEED	(1 << 2)	/* Can do MMC high-speed timing */
 #define MMC_CAP_SD_HIGHSPEED	(1 << 3)	/* Can do SD high-speed timing */
 #define MMC_CAP_SDIO_IRQ	(1 << 4)	/* Can signal pending SDIO IRQs */
+#define MMC_CAP_SPI		(1 << 5)	/* Talks only SPI protocols */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -107,6 +108,14 @@ struct mmc_host {
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
 
+	/* group bitfields together to minimize padding */
+	unsigned int		use_spi_crc:1;
+	unsigned int		claimed:1;	/* host exclusively claimed */
+	unsigned int		bus_dead:1;	/* bus has been released */
+#ifdef CONFIG_MMC_DEBUG
+	unsigned int		removed:1;	/* host is being removed */
+#endif
+
 	unsigned int		mode;		/* current card mode of host */
 #define MMC_MODE_MMC		0
 #define MMC_MODE_SD		1
@@ -114,16 +123,11 @@ struct mmc_host {
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
-	unsigned int		claimed:1;	/* host exclusively claimed */
 
 	struct delayed_work	detect;
-#ifdef CONFIG_MMC_DEBUG
-	unsigned int		removed:1;	/* host is being removed */
-#endif
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
-	unsigned int		bus_dead:1;	/* bus has been released */
 
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
@@ -142,6 +146,8 @@ static inline void *mmc_priv(struct mmc_host *host)
 	return (void *)host->private;
 }
 
+#define mmc_host_is_spi(host)	((host)->caps & MMC_CAP_SPI)
+
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	((x)->class_dev.bus_id)

commit 17b759aff916b4d02721e75ce5ed82b1903e5bd6
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Jul 24 02:09:39 2007 -0400

    sdio: add interface for host side SDIO interrupt reporting
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 00dc1809494c..3fd197962f73 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -51,6 +51,7 @@ struct mmc_host_ops {
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*get_ro)(struct mmc_host *host);
+	void	(*enable_sdio_irq)(struct mmc_host *host, int enable);
 };
 
 struct mmc_card;
@@ -89,6 +90,7 @@ struct mmc_host {
 #define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
 #define MMC_CAP_MMC_HIGHSPEED	(1 << 2)	/* Can do MMC high-speed timing */
 #define MMC_CAP_SD_HIGHSPEED	(1 << 3)	/* Can do SD high-speed timing */
+#define MMC_CAP_SDIO_IRQ	(1 << 4)	/* Can signal pending SDIO IRQs */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -150,5 +152,11 @@ extern int mmc_resume_host(struct mmc_host *);
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
+static inline void mmc_signal_sdio_irq(struct mmc_host *host)
+{
+	host->ops->enable_sdio_irq(host, 0);
+	wake_up_process(host->sdio_irq_thread);
+}
+
 #endif
 

commit d1496c39e500857b8949cdb91af24e0eb8aae4d0
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Jun 30 16:29:41 2007 +0200

    sdio: core support for SDIO function interrupt
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8e2642ebf02f..00dc1809494c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -123,6 +123,10 @@ struct mmc_host {
 	unsigned int		bus_refs;	/* reference counter */
 	unsigned int		bus_dead:1;	/* bus has been released */
 
+	unsigned int		sdio_irqs;
+	struct task_struct	*sdio_irq_thread;
+	atomic_t		sdio_irq_thread_abort;
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit 255d01af9a990fd5166f04ed0cc0b30b7b67e81e
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Jul 24 20:38:53 2007 +0200

    mmc: remove BYTEBLOCK capability
    
    Remove the BYTEBLOCK capability and let the broken hosts fail the
    requests with -EINVAL instead.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b1350dfd3e91..8e2642ebf02f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -87,9 +87,8 @@ struct mmc_host {
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
 #define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
-#define MMC_CAP_BYTEBLOCK	(1 << 2)	/* Can do non-log2 block sizes */
-#define MMC_CAP_MMC_HIGHSPEED	(1 << 3)	/* Can do MMC high-speed timing */
-#define MMC_CAP_SD_HIGHSPEED	(1 << 4)	/* Can do SD high-speed timing */
+#define MMC_CAP_MMC_HIGHSPEED	(1 << 2)	/* Can do MMC high-speed timing */
+#define MMC_CAP_SD_HIGHSPEED	(1 << 3)	/* Can do SD high-speed timing */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit 55556da01284af8c2174b786b3eca8e11301b656
Author: Philip Langdale <philipl@overt.org>
Date:   Fri Mar 16 19:39:00 2007 -0700

    MMC: Fix handling of low-voltage cards
    
    Fix handling of low voltage MMC cards.
    
    The latest MMC and SD specs both agree that support for
    low-voltage operations is indicated by bit 7 in the OCR.
    The MMC spec states that the low voltage range is
    1.65-1.95V while the SD spec leaves the actual voltage
    range undefined - meaning that there is still no such
    thing as a low voltage SD card.
    
    However, an old Sandisk spec implied that bits 7.0
    represented voltages below 2.0V in 1V or 0.5V increments,
    and the code was accordingly written with that expectation.
    
    This confusion meant that host drivers attempting to support
    the typical low voltage (1.8V) would set the wrong bits in
    the host OCR mask (usually bits 5 and/or 6) resulting in the
    the low voltage mode never being used.
    
    This change corrects the low voltage range and adds sanity
    checks on the reserved bits (0-6) and for SD cards that
    claim to support low-voltage operations.
    
    Signed-off-by: Philip Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 5a66d8a2bf17..b1350dfd3e91 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -65,14 +65,7 @@ struct mmc_host {
 	unsigned int		f_max;
 	u32			ocr_avail;
 
-#define MMC_VDD_145_150		0x00000001	/* VDD voltage 1.45 - 1.50 */
-#define MMC_VDD_150_155		0x00000002	/* VDD voltage 1.50 - 1.55 */
-#define MMC_VDD_155_160		0x00000004	/* VDD voltage 1.55 - 1.60 */
-#define MMC_VDD_160_165		0x00000008	/* VDD voltage 1.60 - 1.65 */
-#define MMC_VDD_165_170		0x00000010	/* VDD voltage 1.65 - 1.70 */
-#define MMC_VDD_17_18		0x00000020	/* VDD voltage 1.7 - 1.8 */
-#define MMC_VDD_18_19		0x00000040	/* VDD voltage 1.8 - 1.9 */
-#define MMC_VDD_19_20		0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
 #define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
 #define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */

commit 4be34c99a2f3aa90fa42e62c0918f07afb8a645b
Author: Philip Langdale <philipl@overt.org>
Date:   Sun Mar 11 17:15:15 2007 -0700

    MMC: Consolidate voltage definitions
    
    Consolidate the list of available voltages.
    
    Up until now, a separate set of defines has been
    used for host->vdd than that used for the OCR
    voltage mask values. Having two sets of defines
    allows them to get out of sync and the current
    sets are already inconsistent with one claiming
    to describe ranges and the other specific voltages.
    
    Only the SDHCI driver uses the host->vdd defines and
    it is easily fixed to use the OCR defines.
    
    Signed-off-by: Philip Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index efae87b5c4e7..5a66d8a2bf17 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -16,30 +16,7 @@ struct mmc_ios {
 	unsigned int	clock;			/* clock rate */
 	unsigned short	vdd;
 
-#define	MMC_VDD_150	0
-#define	MMC_VDD_155	1
-#define	MMC_VDD_160	2
-#define	MMC_VDD_165	3
-#define	MMC_VDD_170	4
-#define	MMC_VDD_180	5
-#define	MMC_VDD_190	6
-#define	MMC_VDD_200	7
-#define	MMC_VDD_210	8
-#define	MMC_VDD_220	9
-#define	MMC_VDD_230	10
-#define	MMC_VDD_240	11
-#define	MMC_VDD_250	12
-#define	MMC_VDD_260	13
-#define	MMC_VDD_270	14
-#define	MMC_VDD_280	15
-#define	MMC_VDD_290	16
-#define	MMC_VDD_300	17
-#define	MMC_VDD_310	18
-#define	MMC_VDD_320	19
-#define	MMC_VDD_330	20
-#define	MMC_VDD_340	21
-#define	MMC_VDD_350	22
-#define	MMC_VDD_360	23
+/* vdd stores the bit number of the selected voltage range from below. */
 
 	unsigned char	bus_mode;		/* command output mode */
 

commit 7ea239d9e6d6993469a6a8ca83ff23834dfc3fce
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Dec 31 00:11:32 2006 +0100

    mmc: add bus handler
    
    Delegate protocol handling to "bus handlers". This allows the core to
    just handle the task of arbitrating the bus. Initialisation and
    pampering of cards is now done by the different bus handlers.
    
    This design also allows MMC and SD (and later SDIO) to be more cleanly
    separated, allowing easier maintenance.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 43bf6a5c398d..efae87b5c4e7 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -131,6 +131,8 @@ struct mmc_host {
 	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
 
 	/* private data */
+	spinlock_t		lock;		/* lock for claim and bus ops */
+
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
 
@@ -141,7 +143,6 @@ struct mmc_host {
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
-	spinlock_t		lock;		/* claimed lock */
 	unsigned int		claimed:1;	/* host exclusively claimed */
 
 	struct delayed_work	detect;
@@ -149,6 +150,10 @@ struct mmc_host {
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
+	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
+	unsigned int		bus_refs;	/* reference counter */
+	unsigned int		bus_dead:1;	/* bus has been released */
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 

commit aaac1b470bd0dccb30912356617069dc6199cc80
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Feb 28 15:33:10 2007 +0100

    mmc: Move core functions to subdir
    
    Create a "core" subdirectory to house the central bus handling
    functions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6ea3c0ea3e15..43bf6a5c398d 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -10,7 +10,7 @@
 #ifndef LINUX_MMC_HOST_H
 #define LINUX_MMC_HOST_H
 
-#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
 
 struct mmc_ios {
 	unsigned int	clock;			/* clock rate */

commit b855885e3b60cf6f9452848712a62517b94583eb
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jan 3 19:47:29 2007 +0100

    mmc: deprecate mmc bus topology
    
    The classic MMC bus was defined as multi card bus
    system, which is reflected in the design in the MMC
    layer.
    
    When SD showed up, the bus topology was abandoned
    and a star topology (one card per host) was mandated.
    MMC version 4 has followed this, officially deprecating
    the bus topology.
    
    As we do not have any known users of the bus
    topology we can remove support for it. This will
    simplify the code and rectify some incorrect
    assumptions in the newer additions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 92efe8e5be7e..6ea3c0ea3e15 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -138,14 +138,12 @@ struct mmc_host {
 #define MMC_MODE_MMC		0
 #define MMC_MODE_SD		1
 
-	struct list_head	cards;		/* devices attached to this host */
+	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
 	spinlock_t		lock;		/* claimed lock */
 	unsigned int		claimed:1;	/* host exclusively claimed */
 
-	struct mmc_card		*card_selected;	/* the selected MMC card */
-
 	struct delayed_work	detect;
 #ifdef CONFIG_MMC_DEBUG
 	unsigned int		removed:1;	/* host is being removed */

commit 3b91e5507cddaca53bccf1524ff11a0ac5c85531
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Feb 11 20:43:19 2007 +0100

    mmc: Flush pending detects on host removal
    
    Make sure we kill of any pending detection runs when the host
    is removed instead of when it is freed. Also add some debugging
    to make sure the driver doesn't queue up more detection after it
    has removed the host.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c89f41091304..92efe8e5be7e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -147,6 +147,9 @@ struct mmc_host {
 	struct mmc_card		*card_selected;	/* the selected MMC card */
 
 	struct delayed_work	detect;
+#ifdef CONFIG_MMC_DEBUG
+	unsigned int		removed:1;	/* host is being removed */
+#endif
 
 	unsigned long		private[0] ____cacheline_aligned;
 };

commit f74d132cec60b686bce1f284822c1a496700bd3c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Fri Feb 9 22:49:31 2007 +0100

    mmc: Move OCR bit defines
    
    All host drivers were #include:ing mmc/protocol.h just to
    get access to the OCR bit defines. Move these to host.h instead.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index bfcef8a1ad8b..c89f41091304 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -88,6 +88,31 @@ struct mmc_host {
 	unsigned int		f_max;
 	u32			ocr_avail;
 
+#define MMC_VDD_145_150		0x00000001	/* VDD voltage 1.45 - 1.50 */
+#define MMC_VDD_150_155		0x00000002	/* VDD voltage 1.50 - 1.55 */
+#define MMC_VDD_155_160		0x00000004	/* VDD voltage 1.55 - 1.60 */
+#define MMC_VDD_160_165		0x00000008	/* VDD voltage 1.60 - 1.65 */
+#define MMC_VDD_165_170		0x00000010	/* VDD voltage 1.65 - 1.70 */
+#define MMC_VDD_17_18		0x00000020	/* VDD voltage 1.7 - 1.8 */
+#define MMC_VDD_18_19		0x00000040	/* VDD voltage 1.8 - 1.9 */
+#define MMC_VDD_19_20		0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24		0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25		0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26		0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27		0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28		0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29		0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30		0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31		0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32		0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33		0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34		0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+
 	unsigned long		caps;		/* Host capabilities */
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */

commit cd9277c011a99769fa371521b460ed57f6d280b1
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Feb 18 12:07:47 2007 +0100

    mmc: require explicit support for high-speed
    
    The new high-speed timings are similar to each other and the old
    system, but not identical. And although things "just work" most of
    the time, sometimes it does not. So we need to start marking which
    hosts are known to fully comply with the new timings.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 913e5752569f..bfcef8a1ad8b 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -62,6 +62,12 @@ struct mmc_ios {
 
 #define MMC_BUS_WIDTH_1		0
 #define MMC_BUS_WIDTH_4		2
+
+	unsigned char	timing;			/* timing specification used */
+
+#define MMC_TIMING_LEGACY	0
+#define MMC_TIMING_MMC_HS	1
+#define MMC_TIMING_SD_HS	2
 };
 
 struct mmc_host_ops {
@@ -87,6 +93,8 @@ struct mmc_host {
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
 #define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
 #define MMC_CAP_BYTEBLOCK	(1 << 2)	/* Can do non-log2 block sizes */
+#define MMC_CAP_MMC_HIGHSPEED	(1 << 3)	/* Can do MMC high-speed timing */
+#define MMC_CAP_SD_HIGHSPEED	(1 << 4)	/* Can do SD high-speed timing */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit 55db890a838c7b37256241b1fc53d6344aa79cc0
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Nov 21 17:55:45 2006 +0100

    mmc: Allow host drivers to specify max block count
    
    Many controllers have an upper limit on the number of blocks that can be
    transferred in one request. Allow the host drivers to specify this and make
    sure we avoid hitting this limit.
    
    Also change the max_sectors field to avoid confusion. This makes it map
    less directly to the block layer limits, but as they didn't apply directly
    on MMC cards anyway, this isn't a great loss.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 2da0c918a8cc..913e5752569f 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -92,9 +92,10 @@ struct mmc_host {
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */
 	unsigned short		max_phys_segs;	/* see blk_queue_max_phys_segments */
-	unsigned short		max_sectors;	/* see blk_queue_max_sectors */
 	unsigned short		unused;
+	unsigned int		max_req_size;	/* maximum number of bytes in one req */
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */
+	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
 
 	/* private data */
 	struct mmc_ios		ios;		/* current io bus settings */

commit fe4a3c7a20f14d86022a8132adbf6ddb98e7197c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Nov 21 17:54:23 2006 +0100

    mmc: Allow host drivers to specify a max block size
    
    Most controllers have an upper limit on the block size. Allow the host
    drivers to specify this and make sure we avoid hitting this limit.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ae98d6766bdd..2da0c918a8cc 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -94,6 +94,7 @@ struct mmc_host {
 	unsigned short		max_phys_segs;	/* see blk_queue_max_phys_segments */
 	unsigned short		max_sectors;	/* see blk_queue_max_sectors */
 	unsigned short		unused;
+	unsigned int		max_blk_size;	/* maximum size of one mmc block */
 
 	/* private data */
 	struct mmc_ios		ios;		/* current io bus settings */

commit 11354d03afe9dd0d114e078057158baad4b4eee9
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Jan 14 01:41:45 2007 +0100

    mmc: let host be parent of cards
    
    Change the parent of cards to be a specific host (a class
    device), not the physical controller. This is particularly
    useful when the hardware has multiple slots, meaning
    multiple hosts.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index dc4c6e395198..ae98d6766bdd 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -127,6 +127,7 @@ static inline void *mmc_priv(struct mmc_host *host)
 }
 
 #define mmc_dev(x)	((x)->parent)
+#define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	((x)->class_dev.bus_id)
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);

commit f22ee4edf63e7480511112d9965c71e07be3f8b7
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Dec 26 15:11:23 2006 +0100

    mmc: replace host->card_busy
    
    As card_busy was only used to indicate if the host was exclusively
    claimed and not really used to identify a particular card, replacing
    it with just a boolean makes things a lot more easily understandable.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c15ae1986b98..dc4c6e395198 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -106,8 +106,9 @@ struct mmc_host {
 	struct list_head	cards;		/* devices attached to this host */
 
 	wait_queue_head_t	wq;
-	spinlock_t		lock;		/* card_busy lock */
-	struct mmc_card		*card_busy;	/* the MMC card claiming host */
+	spinlock_t		lock;		/* claimed lock */
+	unsigned int		claimed:1;	/* host exclusively claimed */
+
 	struct mmc_card		*card_selected;	/* the selected MMC card */
 
 	struct delayed_work	detect;

commit 4c1ac1b49122b805adfa4efc620592f68dccf5db
Merge: c4028958b6ec d916faace3ef
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 14:37:56 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/infiniband/core/iwcm.c
            drivers/net/chelsio/cxgb2.c
            drivers/net/wireless/bcm43xx/bcm43xx_main.c
            drivers/net/wireless/prism54/islpci_eth.c
            drivers/usb/core/hub.h
            drivers/usb/input/hid-core.c
            net/core/netpoll.c
    
    Fix up merge failures with Linus's head and fix new compilation failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit fcaf71fd51f9cfc504455d3e19ec242e4b2073ed
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Sep 12 17:00:10 2006 +0200

    Driver core: convert mmc code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 587264a58d56..528e7d3fecb1 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -74,8 +74,8 @@ struct mmc_card;
 struct device;
 
 struct mmc_host {
-	struct device		*dev;
-	struct class_device	class_dev;
+	struct device		*parent;
+	struct device		class_dev;
 	int			index;
 	const struct mmc_host_ops *ops;
 	unsigned int		f_min;
@@ -125,8 +125,8 @@ static inline void *mmc_priv(struct mmc_host *host)
 	return (void *)host->private;
 }
 
-#define mmc_dev(x)	((x)->dev)
-#define mmc_hostname(x)	((x)->class_dev.class_id)
+#define mmc_dev(x)	((x)->parent)
+#define mmc_hostname(x)	((x)->class_dev.bus_id)
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 587264a58d56..8b08ef3820f2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -110,7 +110,7 @@ struct mmc_host {
 	struct mmc_card		*card_busy;	/* the MMC card claiming host */
 	struct mmc_card		*card_selected;	/* the selected MMC card */
 
-	struct work_struct	detect;
+	struct delayed_work	detect;
 
 	unsigned long		private[0] ____cacheline_aligned;
 };

commit 42431acbac43eb47c774c29d370f5c59136805bf
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Sep 24 10:44:09 2006 +0100

    [MMC] MMC_CAP_BYTEBLOCK flag for non-log2 block sizes capable hosts
    
    Some MMC hosts can only handle log2 block sizes.  Unfortunately,
    the MMC password support needs to be able to send non-log2 block
    sizes.  Provide a capability so that the MMC password support can
    decide whether it should use this support or not.
    
    The unfortunate side effect of this host limitation is that any
    MMC card protected by a password which is not a log2 block size
    can not be accessed on a host which only allows a log2 block size.
    
    This change just adds the flag.  The MMC password support code
    needs updating to use it (if and when it is finally submitted.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index b282ec9bba08..587264a58d56 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -86,6 +86,7 @@ struct mmc_host {
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
 #define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
+#define MMC_CAP_BYTEBLOCK	(1 << 2)	/* Can do non-log2 block sizes */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit db53f28b3a6d9338cca1b7e917dc063ac99e1871
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Aug 30 15:14:56 2006 +0100

    [MMC] Add multi block-write capability
    
    Add a capability flag for drivers to set when they can perform multi-
    block transfers to cards _and_ correctly report the number of bytes
    transferred should an error occur.
    
    The last point is very important - if a driver reports more bytes than
    were actually accepted by the card and an error occurs, there is the
    possibility for data loss.
    
    Pierre Ossman provided the patch for wbsd and sdhci.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index ba095aebedff..b282ec9bba08 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -85,6 +85,7 @@ struct mmc_host {
 	unsigned long		caps;		/* Host capabilities */
 
 #define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
+#define MMC_CAP_MULTIWRITE	(1 << 1)	/* Can accurately report bytes sent to card on error */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */

commit f57b225e432d80ee46f48536cc55ea6cf62c5570
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Sep 3 06:43:33 2006 -0700

    [MMC] constify mmc_host_ops
    
    Let drivers constify MMC host method operations tables,
    moving them from ".data" to ".rodata".
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c1f021eddffa..ba095aebedff 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -77,7 +77,7 @@ struct mmc_host {
 	struct device		*dev;
 	struct class_device	class_dev;
 	int			index;
-	struct mmc_host_ops	*ops;
+	const struct mmc_host_ops *ops;
 	unsigned int		f_min;
 	unsigned int		f_max;
 	u32			ocr_avail;

commit 01357dcac62ac028de65a1c315eb75c530c8a5d6
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 8 22:46:00 2005 +0100

    [MMC] Ensure correct mmc_priv() behaviour
    
    mmc_priv() has some nasty effects if the wrong pointer type is
    passed to it.  Introduce type checking, which also means we get
    the right type.  Also add an additional member to mmc_host which
    is used to align host-private data appropriately.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index c5d73c0cf6bb..c1f021eddffa 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -109,6 +109,8 @@ struct mmc_host {
 	struct mmc_card		*card_selected;	/* the selected MMC card */
 
 	struct work_struct	detect;
+
+	unsigned long		private[0] ____cacheline_aligned;
 };
 
 extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
@@ -116,7 +118,11 @@ extern int mmc_add_host(struct mmc_host *);
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
 
-#define mmc_priv(x)	((void *)((x) + 1))
+static inline void *mmc_priv(struct mmc_host *host)
+{
+	return (void *)host->private;
+}
+
 #define mmc_dev(x)	((x)->dev)
 #define mmc_hostname(x)	((x)->class_dev.class_id)
 

commit 8dc003359cc3996abad9e53a7b2280b272610283
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Thu Sep 8 17:53:01 2005 +0100

    [MMC] Allow detection/removal to be delayed
    
    Change mmc_detect_change() to take a delay argument such that
    the detection of card insertions and removals can be delayed
    according to the requirements of the host driver or platform.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 6014160d9c06..c5d73c0cf6bb 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -123,7 +123,7 @@ extern void mmc_free_host(struct mmc_host *);
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
 
-extern void mmc_detect_change(struct mmc_host *);
+extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
 #endif

commit f218278a456b3c272b480443c89004c3d2a49f18
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:55 2005 -0700

    [PATCH] sd: SD 4-bit bus
    
    Infrastructure for 4-bit bus transfers with SD cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 8c5f71376e41..6014160d9c06 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -57,6 +57,11 @@ struct mmc_ios {
 #define MMC_POWER_OFF		0
 #define MMC_POWER_UP		1
 #define MMC_POWER_ON		2
+
+	unsigned char	bus_width;		/* data bus width */
+
+#define MMC_BUS_WIDTH_1		0
+#define MMC_BUS_WIDTH_4		2
 };
 
 struct mmc_host_ops {
@@ -77,6 +82,10 @@ struct mmc_host {
 	unsigned int		f_max;
 	u32			ocr_avail;
 
+	unsigned long		caps;		/* Host capabilities */
+
+#define MMC_CAP_4_BIT_DATA	(1 << 0)	/* Can the host do 4 bit transfers */
+
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
 	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */

commit a00fc09029f02ca833cf90e5d5625f08c4ac4f51
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:52 2005 -0700

    [PATCH] sd: read-only switch
    
    Support for the read-only switch on SD cards which must be enforced by the
    host.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 845020d90c60..8c5f71376e41 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -62,6 +62,7 @@ struct mmc_ios {
 struct mmc_host_ops {
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
+	int	(*get_ro)(struct mmc_host *host);
 };
 
 struct mmc_card;

commit 335eadf2ef6a1122a720aea98e758e5d431da87d
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:50 2005 -0700

    [PATCH] sd: initialize SD cards
    
    Support for the Secure Digital protocol in the MMC layer.
    
    A summary of the legal issues surrounding SD cards, as understood by yours
    truly:
    
    Members of the Secure Digital Association, hereafter SDA, are required to sign
    a NDA[1] before given access to any specifications.  It has been speculated
    that including an SD implementation would forbid these members to redistribute
    Linux.  This is the basic problem with SD support so it is unclear if it even
    is a problem since it has no effect on those of us that aren't members.
    
    The SDA doesn't seem to enforce these rules though since the patches included
    here are based on documentation made public by some of the members.  The most
    complete specs[2] are actually released by Sandisk, one of the founding
    companies of the SDA.
    
    Because of this the NDA is considered a non-issue by most involved in the
    discussions concerning these patches.  It might be that the SDA is only
    interested in protecting the so called "secure" bits of SD, which so far
    hasn't been found in any public spec.  (The card is split into two sections,
    one "normal" and one "secure" which has an access scheme similar to TPM:s).
    
    (As a side note, Microsoft is working to make things easier for us since they
    want to be able to include the source code for a SD driver in one of their
    development kits.  HP is making sure that the new NDA will allow a Linux
    implementation.  So far only the SDIO specs have been opened up[3].  More will
    hopefully follow.)
    
     [1] http://www.sdcard.org/membership/images/ippolicy.pdf
     [2] http://www.sandisk.com/pdf/oem/ProdManualSDCardv1.9.pdf
     [3] http://www.sdcard.org/sdio/Simplified%20SDIO%20Card%20Specification.pdf
    
    This patch contains the central parts of the SD support.  If no MMC cards are
    found on a bus then the MMC layer proceeds looking for SD cards.  Helper
    functions are extended to handle the special needs of SD cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 30f68c0c8c6e..845020d90c60 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -87,6 +87,10 @@ struct mmc_host {
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
 
+	unsigned int		mode;		/* current card mode of host */
+#define MMC_MODE_MMC		0
+#define MMC_MODE_SD		1
+
 	struct list_head	cards;		/* devices attached to this host */
 
 	wait_queue_head_t	wq;

commit 865e9f13c94891daed4f6a5f69c5d6ec04d4932f
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat Sep 3 16:45:02 2005 +0100

    [MMC] ios for mmc chip select
    
    Adds a new ios for setting the chip select pin on MMC cards. Needed on
    SD controllers which use this pin for other things and therefore cannot
    have it pulled high at all times.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 9a0893f3249e..30f68c0c8c6e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -46,6 +46,12 @@ struct mmc_ios {
 #define MMC_BUSMODE_OPENDRAIN	1
 #define MMC_BUSMODE_PUSHPULL	2
 
+	unsigned char	chip_select;		/* SPI chip select */
+
+#define MMC_CS_DONTCARE		0
+#define MMC_CS_HIGH		1
+#define MMC_CS_LOW		2
+
 	unsigned char	power_mode;		/* power supply mode */
 
 #define MMC_POWER_OFF		0

commit dce773771834221817e2d359a7e07a618ba08807
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Aug 19 09:42:52 2005 +0100

    [MMC] Use an IDR for host name indicies
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 113cc27865f0..9a0893f3249e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -64,6 +64,7 @@ struct device;
 struct mmc_host {
 	struct device		*dev;
 	struct class_device	class_dev;
+	int			index;
 	struct mmc_host_ops	*ops;
 	unsigned int		f_min;
 	unsigned int		f_max;

commit 1ad434d7cf5f490c71cfbbb2fb91076c01c8704e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Aug 19 09:42:21 2005 +0100

    [MMC] Use class device name for mmc host name
    
    There's no point in having the host name duplicated between
    the mmc_host structure and the encapsulated class device
    structure.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index a74a810a1302..113cc27865f0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -68,7 +68,6 @@ struct mmc_host {
 	unsigned int		f_min;
 	unsigned int		f_max;
 	u32			ocr_avail;
-	char			host_name[8];
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -98,7 +97,7 @@ extern void mmc_free_host(struct mmc_host *);
 
 #define mmc_priv(x)	((void *)((x) + 1))
 #define mmc_dev(x)	((x)->dev)
-#define mmc_hostname(x)	((x)->host_name)
+#define mmc_hostname(x)	((x)->class_dev.class_id)
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);

commit 00b137cfda5276b3d2c87d44236fe4c5ee68b405
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Aug 19 09:41:24 2005 +0100

    [MMC] Add MMC class devices
    
    Create a mmc_host class to allow enumeration of MMC host controllers
    even though they have no card(s) inserted.
    
    Patch based on work by Pierre Ossman.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 307862308596..a74a810a1302 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -63,6 +63,7 @@ struct device;
 
 struct mmc_host {
 	struct device		*dev;
+	struct class_device	class_dev;
 	struct mmc_host_ops	*ops;
 	unsigned int		f_min;
 	unsigned int		f_max;

commit d366b6436386875b1310ce8f70e3f9dea4647bac
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Aug 19 09:40:08 2005 +0100

    [MMC] Add mmc_hostname() macro
    
    mmc_hostname() returns a pointer to the hostname for the mmc_host.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f90f674eb3b0..307862308596 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -97,6 +97,7 @@ extern void mmc_free_host(struct mmc_host *);
 
 #define mmc_priv(x)	((void *)((x) + 1))
 #define mmc_dev(x)	((x)->dev)
+#define mmc_hostname(x)	((x)->host_name)
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);

commit 3bfffd97ef913045080861d1898286ac8975c22a
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Apr 16 15:25:37 2005 -0700

    [PATCH] fix u32 vs. pm_message_t in rest of the tree
    
    This fixes u32 vs.  pm_message_t confusion in remaining places.  Fortunately
    there's few of them.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index f67686cef62a..f90f674eb3b0 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -98,7 +98,7 @@ extern void mmc_free_host(struct mmc_host *);
 #define mmc_priv(x)	((void *)((x) + 1))
 #define mmc_dev(x)	((x)->dev)
 
-extern int mmc_suspend_host(struct mmc_host *, u32);
+extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
 
 extern void mmc_detect_change(struct mmc_host *);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
new file mode 100644
index 000000000000..f67686cef62a
--- /dev/null
+++ b/include/linux/mmc/host.h
@@ -0,0 +1,108 @@
+/*
+ *  linux/include/linux/mmc/host.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Host driver specific definitions.
+ */
+#ifndef LINUX_MMC_HOST_H
+#define LINUX_MMC_HOST_H
+
+#include <linux/mmc/mmc.h>
+
+struct mmc_ios {
+	unsigned int	clock;			/* clock rate */
+	unsigned short	vdd;
+
+#define	MMC_VDD_150	0
+#define	MMC_VDD_155	1
+#define	MMC_VDD_160	2
+#define	MMC_VDD_165	3
+#define	MMC_VDD_170	4
+#define	MMC_VDD_180	5
+#define	MMC_VDD_190	6
+#define	MMC_VDD_200	7
+#define	MMC_VDD_210	8
+#define	MMC_VDD_220	9
+#define	MMC_VDD_230	10
+#define	MMC_VDD_240	11
+#define	MMC_VDD_250	12
+#define	MMC_VDD_260	13
+#define	MMC_VDD_270	14
+#define	MMC_VDD_280	15
+#define	MMC_VDD_290	16
+#define	MMC_VDD_300	17
+#define	MMC_VDD_310	18
+#define	MMC_VDD_320	19
+#define	MMC_VDD_330	20
+#define	MMC_VDD_340	21
+#define	MMC_VDD_350	22
+#define	MMC_VDD_360	23
+
+	unsigned char	bus_mode;		/* command output mode */
+
+#define MMC_BUSMODE_OPENDRAIN	1
+#define MMC_BUSMODE_PUSHPULL	2
+
+	unsigned char	power_mode;		/* power supply mode */
+
+#define MMC_POWER_OFF		0
+#define MMC_POWER_UP		1
+#define MMC_POWER_ON		2
+};
+
+struct mmc_host_ops {
+	void	(*request)(struct mmc_host *host, struct mmc_request *req);
+	void	(*set_ios)(struct mmc_host *host, struct mmc_ios *ios);
+};
+
+struct mmc_card;
+struct device;
+
+struct mmc_host {
+	struct device		*dev;
+	struct mmc_host_ops	*ops;
+	unsigned int		f_min;
+	unsigned int		f_max;
+	u32			ocr_avail;
+	char			host_name[8];
+
+	/* host specific block data */
+	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
+	unsigned short		max_hw_segs;	/* see blk_queue_max_hw_segments */
+	unsigned short		max_phys_segs;	/* see blk_queue_max_phys_segments */
+	unsigned short		max_sectors;	/* see blk_queue_max_sectors */
+	unsigned short		unused;
+
+	/* private data */
+	struct mmc_ios		ios;		/* current io bus settings */
+	u32			ocr;		/* the current OCR setting */
+
+	struct list_head	cards;		/* devices attached to this host */
+
+	wait_queue_head_t	wq;
+	spinlock_t		lock;		/* card_busy lock */
+	struct mmc_card		*card_busy;	/* the MMC card claiming host */
+	struct mmc_card		*card_selected;	/* the selected MMC card */
+
+	struct work_struct	detect;
+};
+
+extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
+extern int mmc_add_host(struct mmc_host *);
+extern void mmc_remove_host(struct mmc_host *);
+extern void mmc_free_host(struct mmc_host *);
+
+#define mmc_priv(x)	((void *)((x) + 1))
+#define mmc_dev(x)	((x)->dev)
+
+extern int mmc_suspend_host(struct mmc_host *, u32);
+extern int mmc_resume_host(struct mmc_host *);
+
+extern void mmc_detect_change(struct mmc_host *);
+extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
+
+#endif
+
