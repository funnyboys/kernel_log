commit 064f7e58ee42372be05ec87fdf57864c7475ba93
Author: Krishna Konda <kkonda@codeaurora.org>
Date:   Fri May 1 19:23:01 2020 +0530

    mmc: core: expose info about enhanced rpmb support
    
    Following eMMC JEDEC JESD84-B51 standard, an enhanced form of
    rpmb is supported. What this enhanced mode supports is in addition
    to be able to write one rpmb or two rpmb frames at a time,
    32 frames can be written at a time.
    
    Expose this information present in ext csd field so that the
    user space application that wants to make use of this can do so.
    
    Signed-off-by: Krishna Konda <kkonda@codeaurora.org>
    Signed-off-by: Veerabhadrarao Badiganti <vbadigan@codeaurora.org>
    Link: https://lore.kernel.org/r/1588341189-4371-1-git-send-email-vbadigan@codeaurora.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 4b85ef05a906..d9a65c6a8816 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -325,6 +325,7 @@ static inline bool mmc_ready_for_data(u32 status)
  */
 
 #define EXT_CSD_WR_REL_PARAM_EN		(1<<2)
+#define EXT_CSD_WR_REL_PARAM_EN_RPMB_REL_WR	(1<<4)
 
 #define EXT_CSD_BOOT_WP_B_PWR_WP_DIS	(0x40)
 #define EXT_CSD_BOOT_WP_B_PERM_WP_DIS	(0x10)

commit 40c96853fef1bdef13d2cd05b21d4f06b2de6321
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Feb 4 09:54:43 2020 +0100

    mmc: core: Enable re-use of mmc_blk_in_tran_state()
    
    To allow subsequent changes to re-use the code from the static function
    mmc_blk_in_tran_state(), let's move it to a public header. While at it,
    let's also rename it to mmc_ready_for_data(), as to try to better describe
    its purpose.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Baolin Wang <baolin.wang7@gmail.com>
    Tested-by: Ludovic Barre <ludovic.barre@st.com>
    Reviewed-by: Ludovic Barre <ludovic.barre@st.com>
    Link: https://lore.kernel.org/r/20200204085449.32585-7-ulf.hansson@linaro.org

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 897a87c4c827..4b85ef05a906 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -161,6 +161,16 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_STATE_PRG	7
 #define R1_STATE_DIS	8
 
+static inline bool mmc_ready_for_data(u32 status)
+{
+	/*
+	 * Some cards mishandle the status bits, so make sure to check both the
+	 * busy indication and the card state.
+	 */
+	return status & R1_READY_FOR_DATA &&
+	       R1_CURRENT_STATE(status) == R1_STATE_TRAN;
+}
+
 /*
  * MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
  * R1 is the low order byte; R2 is the next highest byte, when present.

commit a94a7483a91cb6a0d15a4413e8fc853f33a4e1b9
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed May 30 10:11:43 2018 +0800

    mmc: core: Adjust and reuse the macro of R1_STATUS(x)
    
    R1_STATUS(x) now is only used by ioctl_rpmb_card_status_poll(),
    which checks all bits as possible. But according to the spec,
    bit 17 and bit 18 should be ignored, as well bit 14 which is
    reserved(must be set to 0) quoting from the spec and these rule
    apply to all places checking the device status. So change
    its checking from 0xFFFFE000 to 0xFFF9A000.
    
    As a bonus, we reuse it for mmc_do_erase() as well as
    mmc_switch_status_error().
    (1) Currently mmc_switch_status_error() doesn't check bit 25, but
    it means device is locked but not unlocked by CMD42 prior to any
    operations which need check busy, which is also not allowed.
    (2) mmc_do_erase() also forgot to to check bit 15, WP_ERASE_SKIP.
    The spec says "Only partial address space was erased due to existing
    write protected blocks.", which obviously means we should fail this I/O.
    Otherwise, the partial erased data stored in nonvalatile flash violates
    the data integrity from the view of I/O owner, which probably confuse
    it when further used.
    
    So reusing R1_STATUS for them not only improve the readability but also
    slove real problems.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 3ffc27aaeeaf..897a87c4c827 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -144,7 +144,7 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
 #define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
 #define R1_ERASE_RESET		(1 << 13)	/* sr, c */
-#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_STATUS(x)            (x & 0xFFF9A000)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */

commit efff8e7879b8b7f8a077f495262f0bb9cfaa0b06
Author: Uri Yanai <uri.yanai@sandisk.com>
Date:   Tue Feb 7 18:00:01 2017 +0200

    mmc: Adding AUTO_BKOPS_EN bit set for Auto BKOPS support
    
    Adding dedicated flag for AUTO_BKOPS in card->ext_csd structure.
    Read AUTO_BKOPS bit value from the device EXT_CSD and set to the
    card->ext_csd structure.
    In mmc_decode_ext_csd() add a print message in case the AUTO_BKOPS
    is enabled
    
    Signed-off-by: Uri Yanai <uri.yanai@sandisk.com>
    Signed-off-by: Alex Lemberg <alex.lemberg@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 7406d9badda0..3ffc27aaeeaf 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -407,6 +407,7 @@ static inline bool mmc_op_multi(u32 opcode)
  * BKOPS modes
  */
 #define EXT_CSD_MANUAL_BKOPS_MASK	0x01
+#define EXT_CSD_AUTO_BKOPS_MASK		0x02
 
 /*
  * Command Queue

commit 009b0fcea5dfe77663f7ec3927c7c50a97a7675c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:11 2017 +0100

    mmc: core: Remove unused struct _mmc_csd from public mmc.h header
    
    The struct _mmc_csd isn't being used and has been lurking around for a
    while. Let's kill it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 8f7854324d2b..7406d9badda0 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -184,50 +184,6 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R2_SPI_OUT_OF_RANGE	(1 << 15)	/* or CSD overwrite */
 #define R2_SPI_CSD_OVERWRITE	R2_SPI_OUT_OF_RANGE
 
-/* These are unpacked versions of the actual responses */
-
-struct _mmc_csd {
-	u8  csd_structure;
-	u8  spec_vers;
-	u8  taac;
-	u8  nsac;
-	u8  tran_speed;
-	u16 ccc;
-	u8  read_bl_len;
-	u8  read_bl_partial;
-	u8  write_blk_misalign;
-	u8  read_blk_misalign;
-	u8  dsr_imp;
-	u16 c_size;
-	u8  vdd_r_curr_min;
-	u8  vdd_r_curr_max;
-	u8  vdd_w_curr_min;
-	u8  vdd_w_curr_max;
-	u8  c_size_mult;
-	union {
-		struct { /* MMC system specification version 3.1 */
-			u8  erase_grp_size;
-			u8  erase_grp_mult;
-		} v31;
-		struct { /* MMC system specification version 2.2 */
-			u8  sector_size;
-			u8  erase_grp_size;
-		} v22;
-	} erase;
-	u8  wp_grp_size;
-	u8  wp_grp_enable;
-	u8  default_ecc;
-	u8  r2w_factor;
-	u8  write_bl_len;
-	u8  write_bl_partial;
-	u8  file_format_grp;
-	u8  copy;
-	u8  perm_write_protect;
-	u8  tmp_write_protect;
-	u8  file_format;
-	u8  ecc;
-};
-
 /*
  * OCR bits are mostly in host.h
  */

commit c0a3e080f9294117a7d510a4f01a0b7c6dbcadae
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:10 2017 +0100

    mmc: core: Move erase/trim/discard defines from public core.h to mmc.h
    
    As the public mmc.h header already contains similar defines for other mmc
    commands and arguments, let's move those for erase/trim/discard into here
    as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 261772e3effe..8f7854324d2b 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -462,12 +462,23 @@ struct _mmc_csd {
 /*
  * MMC_SWITCH access modes
  */
-
 #define MMC_SWITCH_MODE_CMD_SET		0x00	/* Change the command set */
 #define MMC_SWITCH_MODE_SET_BITS	0x01	/* Set bits which are 1 in value */
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
+/*
+ * Erase/trim/discard
+ */
+#define MMC_ERASE_ARG			0x00000000
+#define MMC_SECURE_ERASE_ARG		0x80000000
+#define MMC_TRIM_ARG			0x00000001
+#define MMC_DISCARD_ARG			0x00000003
+#define MMC_SECURE_TRIM1_ARG		0x80000001
+#define MMC_SECURE_TRIM2_ARG		0x80008000
+#define MMC_SECURE_ARGS			0x80000000
+#define MMC_TRIM_ARGS			0x00008001
+
 #define mmc_driver_type_mask(n)		(1 << (n))
 
 #endif /* LINUX_MMC_MMC_H */

commit 8da007348bf52a91e5137d27d7dcd528edbb80ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:06 2017 +0100

    mmc: core: First step in cleaning up public mmc header files
    
    This is the first step in cleaning up the public mmc header files. In this
    change we makes sure each header file builds standalone, as that helps to
    resolve dependencies.
    
    While changing this, it also seems reasonable to stop including other
    headers from inside a header itself which it don't depend upon.
    Additionally, in some cases such dependencies are better resolved by
    forward declaring the needed struct.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index a0740829ff00..261772e3effe 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -24,6 +24,8 @@
 #ifndef LINUX_MMC_MMC_H
 #define LINUX_MMC_MMC_H
 
+#include <linux/types.h>
+
 /* Standard MMC commands (4.1)           type  argument     response */
    /* class 1 */
 #define MMC_GO_IDLE_STATE         0   /* bc                          */

commit 46bc5c408e4e325efbfff26609c76099979180a7
Author: Jungseung Lee <js07.lee@samsung.com>
Date:   Thu Dec 22 12:37:34 2016 +0900

    mmc: core: Export device lifetime information through sysfs
    
    In the eMMC 5.0 version of the spec, several EXT_CSD fields about
    device lifetime are added.
    
     - Two types of estimated indications reflected by averaged wear out of memory
     - An indication reflected by average reserved blocks
    
    Export the information through sysfs.
    
    Signed-off-by: Jungseung Lee <js07.lee@samsung.com>
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 672730acc705..a0740829ff00 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -339,6 +339,9 @@ struct _mmc_csd {
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
 #define EXT_CSD_FIRMWARE_VERSION	254	/* RO, 8 bytes */
+#define EXT_CSD_PRE_EOL_INFO		267	/* RO */
+#define EXT_CSD_DEVICE_LIFE_TIME_EST_TYP_A	268	/* RO */
+#define EXT_CSD_DEVICE_LIFE_TIME_EST_TYP_B	269	/* RO */
 #define EXT_CSD_CMDQ_DEPTH		307	/* RO */
 #define EXT_CSD_CMDQ_SUPPORT		308	/* RO */
 #define EXT_CSD_SUPPORTED_MODE		493	/* RO */

commit 925ff3a7a334b3fe968ae15f07d22df21addad26
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Nov 29 12:09:16 2016 +0200

    mmc: mmc: Add Command Queue definitions
    
    Add definitions relating to Command Queuing.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index c376209c70ef..672730acc705 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -84,6 +84,13 @@
 #define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
 #define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
 
+  /* class 11 */
+#define MMC_QUE_TASK_PARAMS      44   /* ac   [20:16] task id    R1  */
+#define MMC_QUE_TASK_ADDR        45   /* ac   [31:0] data addr   R1  */
+#define MMC_EXECUTE_READ_TASK    46   /* adtc [20:16] task id    R1  */
+#define MMC_EXECUTE_WRITE_TASK   47   /* adtc [20:16] task id    R1  */
+#define MMC_CMDQ_TASK_MGMT       48   /* ac   [20:16] task id    R1b */
+
 static inline bool mmc_op_multi(u32 opcode)
 {
 	return opcode == MMC_WRITE_MULTIPLE_BLOCK ||
@@ -272,6 +279,7 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
+#define EXT_CSD_CMDQ_MODE_EN		15	/* R/W */
 #define EXT_CSD_FLUSH_CACHE		32      /* W */
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
@@ -331,6 +339,8 @@ struct _mmc_csd {
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
 #define EXT_CSD_FIRMWARE_VERSION	254	/* RO, 8 bytes */
+#define EXT_CSD_CMDQ_DEPTH		307	/* RO */
+#define EXT_CSD_CMDQ_SUPPORT		308	/* RO */
 #define EXT_CSD_SUPPORTED_MODE		493	/* RO */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
@@ -437,6 +447,13 @@ struct _mmc_csd {
  */
 #define EXT_CSD_MANUAL_BKOPS_MASK	0x01
 
+/*
+ * Command Queue
+ */
+#define EXT_CSD_CMDQ_MODE_ENABLED	BIT(0)
+#define EXT_CSD_CMDQ_DEPTH_MASK		GENMASK(4, 0)
+#define EXT_CSD_CMDQ_SUPPORTED		BIT(0)
+
 /*
  * MMC_SWITCH access modes
  */

commit 81ac2af65793ecfbd79875d45043ff4adc0982b8
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu May 26 09:56:22 2016 +0800

    mmc: core: implement enhanced strobe support
    
    Controllers use data strobe line to latch data from devices
    under hs400 mode, but not for cmd line. So since emmc 5.1, JEDEC
    introduces enhanced strobe mode for latching cmd response from
    emmc devices to host controllers. This new feature is optional,
    so it depends both on device's cap and host's cap to decide
    whether to use it or not.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 15f2c4a0a62c..c376209c70ef 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -297,6 +297,7 @@ struct _mmc_csd {
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
+#define EXT_CSD_STROBE_SUPPORT		184	/* RO */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
 #define EXT_CSD_POWER_CLASS		187	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
@@ -380,12 +381,14 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE_HS400_1_2V	(1<<7)	/* Card can run at 200MHz DDR, 1.2V */
 #define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
 					 EXT_CSD_CARD_TYPE_HS400_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400ES	(1<<8)	/* Card can run at HS400ES */
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
+#define EXT_CSD_BUS_WIDTH_STROBE BIT(7)	/* Enhanced strobe mode */
 
 #define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
 #define EXT_CSD_TIMING_HS	1	/* High speed */

commit cc4f414c885cd04f7227ad9bcd6b18fd78d718d9
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:58 2015 +0200

    mmc: mmc: Add driver strength selection
    
    Add the ability to set eMMC driver strength
    for HS200 and HS400.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 4819cfbc3795..15f2c4a0a62c 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -391,6 +391,7 @@ struct _mmc_csd {
 #define EXT_CSD_TIMING_HS	1	/* High speed */
 #define EXT_CSD_TIMING_HS200	2	/* HS200 */
 #define EXT_CSD_TIMING_HS400	3	/* HS400 */
+#define EXT_CSD_DRV_STR_SHIFT	4	/* Driver Strength shift */
 
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
@@ -442,4 +443,6 @@ struct _mmc_csd {
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
+#define mmc_driver_type_mask(n)		(1 << (n))
+
 #endif /* LINUX_MMC_MMC_H */

commit b097e07f57930eda774c83aa46e8e401686d01dc
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:57 2015 +0200

    mmc: mmc: Read card's valid driver strength mask
    
    In preparation for supporing drive strength selection
    for eMMC, read the card's valid driver strengths.
    
    Note that though the SD spec uses the term "drive strength",
    the JEDEC eMMC spec uses the term "driver strength".
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 124f562118b8..4819cfbc3795 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -302,6 +302,7 @@ struct _mmc_csd {
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_STRUCTURE		194	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_DRIVER_STRENGTH		197	/* RO */
 #define EXT_CSD_OUT_OF_INTERRUPT_TIME	198	/* RO */
 #define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
 #define EXT_CSD_PWR_CL_52_195		200	/* RO */

commit 0501be6429e4eb02f417ad83eacd84b8c57b0283
Author: Alexey Skidanov <alexey.skidanov@sandisk.com>
Date:   Thu Jan 29 10:49:43 2015 +0200

    mmc: Resolve BKOPS compatability issue
    
    This patch is coming to fix compatibility issue of BKOPS_EN  field of EXT_CSD.
    In eMMC-5.1, BKOPS_EN was changed, and now it has two operational bits:
    Bit 0 - MANUAL_EN
    Bit 1 - AUTO_EN
    In previous eMMC revisions, only Bit 0 was supported.
    
    Signed-off-by: Alexey Skidanov <alexey.skidanov@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index fb97b5cc91cd..124f562118b8 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -427,6 +427,11 @@ struct _mmc_csd {
  */
 #define EXT_CSD_BKOPS_LEVEL_2		0x2
 
+/*
+ * BKOPS modes
+ */
+#define EXT_CSD_MANUAL_BKOPS_MASK	0x01
+
 /*
  * MMC_SWITCH access modes
  */

commit 04cdbbfa73ebac57a30ec2ebebfd7e9342bbdc44
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 1 16:53:34 2014 +0100

    mmc: core: Make tuning block patterns static
    
    Since previous patches removed the need for the tuning block patterns
    to be exported, let's move them close to the mmc_send_tuning() API.
    
    Those are now intended to be used only by the mmc core.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 49ad7a943638..fb97b5cc91cd 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -53,11 +53,6 @@
 #define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
 #define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */
 
-#define MMC_TUNING_BLK_PATTERN_4BIT_SIZE	 64
-#define MMC_TUNING_BLK_PATTERN_8BIT_SIZE	128
-extern const u8 tuning_blk_pattern_4bit[MMC_TUNING_BLK_PATTERN_4BIT_SIZE];
-extern const u8 tuning_blk_pattern_8bit[MMC_TUNING_BLK_PATTERN_8BIT_SIZE];
-
   /* class 3 */
 #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
 

commit 0f762426769a517d5b278e4e5d579fcea6801734
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Thu Oct 16 11:27:16 2014 -0700

    mmc: core: Report firmware version for eMMC 5.0 devices.
    
    For eMMC 5.0 compliant device, firmware version is stored in ext_csd.
    Report firmware as a 64bit hexa decimal. Vendor can use hexa or ascii
    string to report firmware version.
    Also add FFU related EXT_CSD register and note if the device is FFU capable.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 1cd00b3a75b9..49ad7a943638 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -296,6 +296,7 @@ struct _mmc_csd {
 #define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_RPMB_MULT		168	/* RO */
+#define EXT_CSD_FW_CONFIG		169	/* R/W */
 #define EXT_CSD_BOOT_WP			173	/* R/W */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
@@ -332,6 +333,8 @@ struct _mmc_csd {
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
+#define EXT_CSD_FIRMWARE_VERSION	254	/* RO, 8 bytes */
+#define EXT_CSD_SUPPORTED_MODE		493	/* RO */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
 #define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */

commit 48d11e067fc90ec9fc9c8f7ab982e5a83bf1887b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Sep 22 12:26:10 2014 -0700

    mmc: Consolidate emmc tuning blocks
    
    The same tuning block exists in the dw_mmc h.c and sdhci-msm.c
    files. Move these into mmc.c so that they can be shared across
    drivers.
    
    Reported-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 78753bc90a87..1cd00b3a75b9 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -53,6 +53,11 @@
 #define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
 #define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */
 
+#define MMC_TUNING_BLK_PATTERN_4BIT_SIZE	 64
+#define MMC_TUNING_BLK_PATTERN_8BIT_SIZE	128
+extern const u8 tuning_blk_pattern_4bit[MMC_TUNING_BLK_PATTERN_4BIT_SIZE];
+extern const u8 tuning_blk_pattern_8bit[MMC_TUNING_BLK_PATTERN_8BIT_SIZE];
+
   /* class 3 */
 #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
 

commit 69803d4f487fc60ce740f1fe1f0d2092d97277b6
Author: Grégory Soutadé <gsoutade@neotion.com>
Date:   Mon Sep 15 17:47:09 2014 +0200

    mmc: Replace "enhanced_area_en" attribute by "partition_setting_completed"
    
    Replace ext_csd "enhanced_area_en" attribute by
     "partition_setting_completed". It was used whether or
     not enhanced user area is defined and without checks of
     EXT_CSD_PARTITION_SETTING_COMPLETED bit.
    
    Signed-off-by: Grégory Soutadé <gsoutade@neotion.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 64ec963ed347..78753bc90a87 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -281,6 +281,7 @@ struct _mmc_csd {
 #define EXT_CSD_EXP_EVENTS_CTRL		56	/* R/W, 2 bytes */
 #define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
+#define EXT_CSD_PARTITION_SETTING_COMPLETED 155	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_HPI_MGMT		161	/* R/W */
@@ -349,6 +350,7 @@ struct _mmc_csd {
 #define EXT_CSD_PART_CONFIG_ACC_RPMB	(0x3)
 #define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)
 
+#define EXT_CSD_PART_SETTING_COMPLETED	(0x1)
 #define EXT_CSD_PART_SUPPORT_PART_EN	(0x1)
 
 #define EXT_CSD_CMD_SET_NORMAL		(1<<0)

commit 0a5b6438ee482696360bb013e67b8488f63d3e9e
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:14:58 2014 +0900

    mmc: add support for HS400 mode of eMMC5.0
    
    This patch adds HS400 mode support for eMMC5.0 device.  HS400 mode is high
    speed DDR interface timing from HS200.  Clock frequency is up to 200MHz
    and only 8-bit bus width is supported. In addition, tuning process of
    HS200 is required to synchronize the command response on the CMD line
    because CMD input timing for HS400 mode is the same as HS200 mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Jackey Shen <jackey.shen@amd.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index f429f13be433..64ec963ed347 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -325,6 +325,7 @@ struct _mmc_csd {
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
+#define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
 #define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */
@@ -354,7 +355,6 @@ struct _mmc_csd {
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
 
-#define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
 #define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
 #define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
@@ -370,6 +370,10 @@ struct _mmc_csd {
 						/* SDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
 					 EXT_CSD_CARD_TYPE_HS200_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400_1_8V	(1<<6)	/* Card can run at 200MHz DDR, 1.8V */
+#define EXT_CSD_CARD_TYPE_HS400_1_2V	(1<<7)	/* Card can run at 200MHz DDR, 1.2V */
+#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS400_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@ -380,6 +384,7 @@ struct _mmc_csd {
 #define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
 #define EXT_CSD_TIMING_HS	1	/* High speed */
 #define EXT_CSD_TIMING_HS200	2	/* HS200 */
+#define EXT_CSD_TIMING_HS400	3	/* HS400 */
 
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)

commit 577fb13199b11d8cd75609183649be4b5561243f
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:08:44 2014 +0900

    mmc: rework selection of bus speed mode
    
    Current implementation for bus speed mode selection is too
    complicated. This patch is to simplify the codes and remove
    some duplicate parts.
    
    The following changes are including:
    * Adds functions for each mode selection(HS, HS-DDR, HS200 and etc)
    * Rearranged the mode selection sequence with supported device type
    * Adds maximum speed for HS200 mode(hs200_max_dtr)
    * Adds field definition for HS_TIMING of EXT_CSD
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index f734c0c64575..f429f13be433 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -377,6 +377,10 @@ struct _mmc_csd {
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
+#define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
+#define EXT_CSD_TIMING_HS	1	/* High speed */
+#define EXT_CSD_TIMING_HS200	2	/* HS200 */
+
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)

commit 2415c0ef618b3cd95581c7f633cbab78b29b7ab0
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:58 2014 +0900

    mmc: identify available device type to select
    
    Device types which are supported by both host and device can be
    identified when EXT_CSD is read. There is no need to check host's
    capability anymore.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 50bcde3677ca..f734c0c64575 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -354,18 +354,22 @@ struct _mmc_csd {
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
 
-#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
-#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
 #define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
+#define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
+				 EXT_CSD_CARD_TYPE_HS_52)
 #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
 					     /* DDR mode @1.8V or 3V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
 					     /* DDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
-#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
-#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
 						/* SDR mode @1.2V I/O */
+#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS200_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */

commit abd9ac144947d9a604beb763339e2f77ce8bec79
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Feb 6 17:01:43 2013 +0900

    mmc: add packed command feature of eMMC4.5
    
    This patch adds packed command feature of eMMC4.5.  The maximum number
    for packing read (or write) is offered and exception event relevant to
    packed command which is used for error handling is enabled. If host
    wants to use this feature, MMC_CAP2_PACKED_CMD should be set.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 94d532e41c61..50bcde3677ca 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -139,7 +139,7 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
-#define R1_EXCEPTION_EVENT	(1 << 6)	/* sx, a */
+#define R1_EXCEPTION_EVENT	(1 << 6)	/* sr, a */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
 #define R1_STATE_IDLE	0
@@ -275,7 +275,10 @@ struct _mmc_csd {
 #define EXT_CSD_FLUSH_CACHE		32      /* W */
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
-#define EXT_CSD_EXP_EVENTS_STATUS	54	/* RO */
+#define EXT_CSD_PACKED_FAILURE_INDEX	35	/* RO */
+#define EXT_CSD_PACKED_CMD_STATUS	36	/* RO */
+#define EXT_CSD_EXP_EVENTS_STATUS	54	/* RO, 2 bytes */
+#define EXT_CSD_EXP_EVENTS_CTRL		56	/* R/W, 2 bytes */
 #define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
@@ -324,6 +327,8 @@ struct _mmc_csd {
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
+#define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */
+#define EXT_CSD_MAX_PACKED_READS	501	/* RO */
 #define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
 #define EXT_CSD_HPI_FEATURES		503	/* RO */
 
@@ -385,6 +390,9 @@ struct _mmc_csd {
 #define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
 #define EXT_CSD_PWR_CL_8BIT_SHIFT	4
 #define EXT_CSD_PWR_CL_4BIT_SHIFT	0
+
+#define EXT_CSD_PACKED_EVENT_EN	BIT(3)
+
 /*
  * EXCEPTION_EVENT_STATUS field
  */
@@ -393,6 +401,9 @@ struct _mmc_csd {
 #define EXT_CSD_SYSPOOL_EXHAUSTED	BIT(2)
 #define EXT_CSD_PACKED_FAILURE		BIT(3)
 
+#define EXT_CSD_PACKED_GENERIC_ERROR	BIT(0)
+#define EXT_CSD_PACKED_INDEXED_ERROR	BIT(1)
+
 /*
  * BKOPS status level
  */

commit 090d25fe224c0933d2b261aad91532e725c1d889
Author: Loic Pallardy <loic.pallardy-ext@stericsson.com>
Date:   Sat Nov 17 18:08:24 2012 -0500

    mmc: core: Expose access to RPMB partition
    
    Following JEDEC standard, if the mmc supports RPMB partition,
    a new interface is created and exposed via /dev/block.
    Users will be able to access RPMB partition using standard
    mmc IOCTL commands.
    
    Signed-off-by: Alex Macro <alex.macro@stericsson.com>
    Signed-off-by: Loic Pallardy <loic.pallardy@stericsson.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Krishna Konda <kkonda@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 01e4b394029b..94d532e41c61 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -286,6 +286,7 @@ struct _mmc_csd {
 #define EXT_CSD_BKOPS_START		164	/* W */
 #define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
+#define EXT_CSD_RPMB_MULT		168	/* RO */
 #define EXT_CSD_BOOT_WP			173	/* R/W */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
@@ -339,6 +340,7 @@ struct _mmc_csd {
 
 #define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
 #define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
+#define EXT_CSD_PART_CONFIG_ACC_RPMB	(0x3)
 #define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)
 
 #define EXT_CSD_PART_SUPPORT_PART_EN	(0x1)

commit 950d56acce5d401f477b91d0177605b543d63d07
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Sep 17 08:42:02 2012 +0000

    mmc: support BKOPS feature for eMMC
    
    Enable eMMC background operations (BKOPS) feature.
    
    If URGENT_BKOPS is set after a response, note that BKOPS are required.
    Immediately run BKOPS if required.  Read/write operations should be
    requested during BKOPS(LEVEL-1), then issue HPI to interrupt the
    ongoing BKOPS and service the foreground operation.
    (This patch only controls the LEVEL2/3.)
    
    When repeating the writing 1GB data, at a certain time, performance is
    decreased.  At that time, card triggers the Level-3 or Level-2.  After
    running bkops, performance is recovered.
    
    Future considerations:
     * Check BKOPS_LEVEL=1 and start BKOPS in a preventive manner.
     * Interrupt ongoing BKOPS before powering off the card.
     * How do we get BKOPS_STATUS value (periodically send ext_csd command)?
     * If using periodic bkops, also consider runtime_pm control.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index d425cab144d9..01e4b394029b 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -139,6 +139,7 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
+#define R1_EXCEPTION_EVENT	(1 << 6)	/* sx, a */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
 #define R1_STATE_IDLE	0
@@ -274,12 +275,15 @@ struct _mmc_csd {
 #define EXT_CSD_FLUSH_CACHE		32      /* W */
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
+#define EXT_CSD_EXP_EVENTS_STATUS	54	/* RO */
 #define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_HPI_MGMT		161	/* R/W */
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
+#define EXT_CSD_BKOPS_EN		163	/* R/W */
+#define EXT_CSD_BKOPS_START		164	/* W */
 #define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_BOOT_WP			173	/* R/W */
@@ -313,11 +317,13 @@ struct _mmc_csd {
 #define EXT_CSD_PWR_CL_200_360		237	/* RO */
 #define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
 #define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
+#define EXT_CSD_BKOPS_STATUS		246	/* RO */
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
+#define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
 #define EXT_CSD_HPI_FEATURES		503	/* RO */
 
 /*
@@ -377,6 +383,19 @@ struct _mmc_csd {
 #define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
 #define EXT_CSD_PWR_CL_8BIT_SHIFT	4
 #define EXT_CSD_PWR_CL_4BIT_SHIFT	0
+/*
+ * EXCEPTION_EVENT_STATUS field
+ */
+#define EXT_CSD_URGENT_BKOPS		BIT(0)
+#define EXT_CSD_DYNCAP_NEEDED		BIT(1)
+#define EXT_CSD_SYSPOOL_EXHAUSTED	BIT(2)
+#define EXT_CSD_PACKED_FAILURE		BIT(3)
+
+/*
+ * BKOPS status level
+ */
+#define EXT_CSD_BKOPS_LEVEL_2		0x2
+
 /*
  * MMC_SWITCH access modes
  */

commit 96cf5f02aee8bbeff38824b18b9ec583d687f846
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 25 16:17:37 2012 +0900

    mmc: core: fix the decision of HS200/DDR card-type
    
    Current implementation decides the card type exclusively. Even though
    eMMC device can support both HS200 and DDR mode, card type will be
    set only for HS200. If the host doesn't support HS200 but has DDR
    capability, then DDR mode can't be selected.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b822a2cb6008..d425cab144d9 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -354,66 +354,6 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
 						/* SDR mode @1.2V I/O */
 
-#define EXT_CSD_CARD_TYPE_SDR_200	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-					 EXT_CSD_CARD_TYPE_SDR_1_2V)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL	(EXT_CSD_CARD_TYPE_SDR_200 | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define	EXT_CSD_CARD_TYPE_SDR_1_2V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define	EXT_CSD_CARD_TYPE_SDR_1_8V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-					 EXT_CSD_CARD_TYPE_52 | \
-					 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
-#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_52	(EXT_CSD_CARD_TYPE_SDR_200 | \
-						 EXT_CSD_CARD_TYPE_DDR_52 | \
-						 EXT_CSD_CARD_TYPE_52 | \
-						 EXT_CSD_CARD_TYPE_26)
-
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */

commit 4265900e0be653f5b78baf2816857ef57cf1332f
Author: Saugata Das <saugata.das@linaro.org>
Date:   Wed Dec 21 13:09:17 2011 +0530

    mmc: MMC-4.5 Data Tag Support
    
    MMC-4.5 data tag feature will be used to store the file system meta-data
    in the tagged region of eMMC. This will improve the write and subsequent
    read transfer time for the meta data.
    
    Signed-off-by: Saugata Das <saugata.das@linaro.org>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index fb9f6e116e1c..b822a2cb6008 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -274,6 +274,7 @@ struct _mmc_csd {
 #define EXT_CSD_FLUSH_CACHE		32      /* W */
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
+#define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
@@ -315,6 +316,8 @@ struct _mmc_csd {
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
+#define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
+#define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
 #define EXT_CSD_HPI_FEATURES		503	/* RO */
 
 /*

commit a4924c71aa43d4f8a3f342b1f71788349472e684
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Wed Jan 11 14:04:52 2012 -0500

    mmc: core: HS200 mode support for eMMC 4.5
    
    This patch adds the support of the HS200 bus speed for eMMC 4.5 devices.
    The eMMC 4.5 devices have support for 200MHz bus speed. The function
    prototype of the tuning function is modified to handle the tuning
    command number which is different in sd and mmc case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 665548e639e8..fb9f6e116e1c 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -51,6 +51,7 @@
 #define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
 #define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
 #define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
+#define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */
 
   /* class 3 */
 #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
@@ -339,13 +340,76 @@ struct _mmc_csd {
 
 #define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
-#define EXT_CSD_CARD_TYPE_MASK	0xF	/* Mask out reserved bits */
+#define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
 #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
 					     /* DDR mode @1.8V or 3V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
 					     /* DDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
+#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
+						/* SDR mode @1.2V I/O */
+
+#define EXT_CSD_CARD_TYPE_SDR_200	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
+					 EXT_CSD_CARD_TYPE_SDR_1_2V)
+
+#define EXT_CSD_CARD_TYPE_SDR_ALL	(EXT_CSD_CARD_TYPE_SDR_200 | \
+					 EXT_CSD_CARD_TYPE_52 | \
+					 EXT_CSD_CARD_TYPE_26)
+
+#define	EXT_CSD_CARD_TYPE_SDR_1_2V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
+					 EXT_CSD_CARD_TYPE_52 | \
+					 EXT_CSD_CARD_TYPE_26)
+
+#define	EXT_CSD_CARD_TYPE_SDR_1_8V_ALL	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
+					 EXT_CSD_CARD_TYPE_52 | \
+					 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_2V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_DDR_52 | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_1_8V_DDR_52	(EXT_CSD_CARD_TYPE_SDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_DDR_52 | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_8V	(EXT_CSD_CARD_TYPE_SDR_200 | \
+						 EXT_CSD_CARD_TYPE_DDR_1_8V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_1_2V	(EXT_CSD_CARD_TYPE_SDR_200 | \
+						 EXT_CSD_CARD_TYPE_DDR_1_2V | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
+
+#define EXT_CSD_CARD_TYPE_SDR_ALL_DDR_52	(EXT_CSD_CARD_TYPE_SDR_200 | \
+						 EXT_CSD_CARD_TYPE_DDR_52 | \
+						 EXT_CSD_CARD_TYPE_52 | \
+						 EXT_CSD_CARD_TYPE_26)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */

commit add710eaa88606de8ba98a014d37178579e6dbaf
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Fri Dec 2 08:51:06 2011 +0100

    mmc: boot partition ro lock support
    
    Enable boot partitions to be read-only locked until next power on via
    a sysfs entry. There will be one sysfs entry for each boot partition:
    
    /sys/block/mmcblkXbootY/ro_lock_until_next_power_on
    
    Each boot partition is locked by writing 1 to its file.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Signed-off-by: John Beckett <john.beckett@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 0e7135697d11..665548e639e8 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -280,6 +280,7 @@ struct _mmc_csd {
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
 #define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
+#define EXT_CSD_BOOT_WP			173	/* R/W */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
@@ -321,6 +322,11 @@ struct _mmc_csd {
 
 #define EXT_CSD_WR_REL_PARAM_EN		(1<<2)
 
+#define EXT_CSD_BOOT_WP_B_PWR_WP_DIS	(0x40)
+#define EXT_CSD_BOOT_WP_B_PERM_WP_DIS	(0x10)
+#define EXT_CSD_BOOT_WP_B_PERM_WP_EN	(0x04)
+#define EXT_CSD_BOOT_WP_B_PWR_WP_EN	(0x01)
+
 #define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
 #define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
 #define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)

commit eb0d8f135b6730d6d0324a064664d121334290e7
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Tue Oct 18 01:26:42 2011 -0400

    mmc: core: support HPI send command
    
    HPI command is defined in eMMC4.41.
    This feature is important for eMMC4.5 devices.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 160e4c5bdae0..0e7135697d11 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -276,6 +276,7 @@ struct _mmc_csd {
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
+#define EXT_CSD_HPI_MGMT		161	/* R/W */
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
 #define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
@@ -288,6 +289,7 @@ struct _mmc_csd {
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_STRUCTURE		194	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_OUT_OF_INTERRUPT_TIME	198	/* RO */
 #define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
 #define EXT_CSD_PWR_CL_52_195		200	/* RO */
 #define EXT_CSD_PWR_CL_26_195		201	/* RO */
@@ -311,6 +313,7 @@ struct _mmc_csd {
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
+#define EXT_CSD_HPI_FEATURES		503	/* RO */
 
 /*
  * EXT_CSD field definitions

commit 881d1c25f765938a95def5afe39486ce39f9fc96
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Oct 14 14:03:21 2011 +0900

    mmc: core: Add cache control for eMMC4.5 device
    
    This patch adds cache feature of eMMC4.5 Spec.
    If device supports cache capability, host can utilize some specific
    operations.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 8a05a21fc7c3..160e4c5bdae0 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -270,6 +270,8 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
+#define EXT_CSD_FLUSH_CACHE		32      /* W */
+#define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
@@ -308,6 +310,7 @@ struct _mmc_csd {
 #define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
+#define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
 
 /*
  * EXT_CSD field definitions

commit d9ddd62943ee07a75d0428ffcf52f1a747a28c39
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri Oct 14 14:15:48 2011 +0900

    mmc: core: mmc sanitize feature support for v4.5
    
    In the v4.5, there's no secure erase & trim support.
    Instead it supports the sanitize feature.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 02e9e3de9609..8a05a21fc7c3 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -275,6 +275,7 @@ struct _mmc_csd {
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
+#define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
@@ -343,6 +344,7 @@ struct _mmc_csd {
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
+#define EXT_CSD_SEC_SANITIZE	BIT(6)  /* v4.5 only */
 
 #define EXT_CSD_RST_N_EN_MASK	0x3
 #define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */

commit bec8726abc72bf30d2743a722aa37cd69e7a0580
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Thu Oct 13 12:04:16 2011 +0530

    mmc: core: Add Power Off Notify Feature eMMC 4.5
    
    This patch adds support for the power off notify feature, available in
    eMMC 4.5 devices. If the host has support for this feature, then the
    mmc core will notify the device by setting the POWER_OFF_NOTIFICATION
    byte in the extended csd register with a value of 1 (POWER_ON).
    
    For suspend mode short timeout is used, whereas for the normal poweroff
    long timeout is used.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index cd63c2dc95cc..02e9e3de9609 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -270,6 +270,7 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
+#define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
@@ -346,6 +347,11 @@ struct _mmc_csd {
 #define EXT_CSD_RST_N_EN_MASK	0x3
 #define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */
 
+#define EXT_CSD_NO_POWER_NOTIFICATION	0
+#define EXT_CSD_POWER_ON		1
+#define EXT_CSD_POWER_OFF_SHORT		2
+#define EXT_CSD_POWER_OFF_LONG		3
+
 #define EXT_CSD_PWR_CL_8BIT_MASK	0xF0	/* 8 bit PWR CLS */
 #define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
 #define EXT_CSD_PWR_CL_8BIT_SHIFT	4

commit b23cf0bd55b0c6b703982446f679e00d6d929524
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Sep 23 14:15:29 2011 +0900

    mmc: core: Add default timeout value for CMD6
    
    EXT_CSD[248] includes the default maximum timeout for CMD6.
    This field is added at eMMC4.5 Spec. And it can be used for default
    timeout except for some operations which don't define the timeout
    (i.e. background operation, sanitize, flush cache) in eMMC4.5 Spec.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index ea558eb44c79..cd63c2dc95cc 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -305,6 +305,7 @@ struct _mmc_csd {
 #define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
 #define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
+#define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 
 /*
  * EXT_CSD field definitions

commit e0c368d571d946ff40f068344b5c2df90c93dd2e
Author: Namjae Jeon <linkinjeon@gmail.com>
Date:   Thu Oct 6 23:41:38 2011 +0900

    mmc: core: general purpose MMC partition support.
    
    It allows gerneral purpose partitions in MMC Device.  And I try to simply
    make mmc_blk_alloc_parts using mmc_part structure suggested by Andrei
    Warkentin.  After patching, we see general purpose partitions like this:
    > cat /proc/partitions
              179 0 847872 mmcblk0
              179 192 4096 mmcblk0gp3
              179 160 4096 mmcblk0gp2
              179 128 4096 mmcblk0gp1
              179 96  1052672 mmcblk0gp0
              179 64  1024 mmcblk0boot1
              179 32  1024 mmcblk0boot0
    
    Signed-off-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Andrei Warkentin <awarkentin@vmware.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 50af22730c74..ea558eb44c79 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -270,6 +270,7 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
+#define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
@@ -313,7 +314,9 @@ struct _mmc_csd {
 
 #define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
 #define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
-#define EXT_CSD_PART_CONFIG_ACC_BOOT1	(0x2)
+#define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)
+
+#define EXT_CSD_PART_SUPPORT_PART_EN	(0x1)
 
 #define EXT_CSD_CMD_SET_NORMAL		(1<<0)
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)

commit b87d8dbf6c410b5f2d9b6893c85baa06aa131c7c
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Fri Sep 23 20:41:47 2011 +0530

    mmc: core: eMMC 4.5 Power Class Selection Feature
    
    This patch adds the power class selection feature available for mmc
    versions 4.0 and above.  During the enumeration stage before switching
    to the lower data bus, check if the power class is supported for the
    current bus width. If the power class is available then switch to the
    power class and use the higher data bus. If power class is not supported
    then switch to the lower data bus in a worst case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index ed8fca890ee2..50af22730c74 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -279,10 +279,15 @@ struct _mmc_csd {
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
+#define EXT_CSD_POWER_CLASS		187	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_STRUCTURE		194	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
 #define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
+#define EXT_CSD_PWR_CL_52_195		200	/* RO */
+#define EXT_CSD_PWR_CL_26_195		201	/* RO */
+#define EXT_CSD_PWR_CL_52_360		202	/* RO */
+#define EXT_CSD_PWR_CL_26_360		203	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT		217	/* RO */
 #define EXT_CSD_REL_WR_SEC_C		222	/* RO */
@@ -294,6 +299,11 @@ struct _mmc_csd {
 #define EXT_CSD_SEC_ERASE_MULT		230	/* RO */
 #define EXT_CSD_SEC_FEATURE_SUPPORT	231	/* RO */
 #define EXT_CSD_TRIM_MULT		232	/* RO */
+#define EXT_CSD_PWR_CL_200_195		236	/* RO */
+#define EXT_CSD_PWR_CL_200_360		237	/* RO */
+#define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
+#define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
+#define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 
 /*
  * EXT_CSD field definitions
@@ -332,6 +342,10 @@ struct _mmc_csd {
 #define EXT_CSD_RST_N_EN_MASK	0x3
 #define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */
 
+#define EXT_CSD_PWR_CL_8BIT_MASK	0xF0	/* 8 bit PWR CLS */
+#define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
+#define EXT_CSD_PWR_CL_8BIT_SHIFT	4
+#define EXT_CSD_PWR_CL_4BIT_SHIFT	0
 /*
  * MMC_SWITCH access modes
  */

commit b2499518b5ad7e28bb3ed348fd3f370eeb1e36c0
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Aug 29 16:42:11 2011 +0300

    mmc: core: add eMMC hardware reset support
    
    eMMC's may have a hardware reset line.  This patch provides a
    host controller operation to implement hardware reset and
    a function to reset and reinitialize the card.  Also, for MMC,
    the reset is always performed before initialization.
    
    The host must set the new host capability MMC_CAP_HW_RESET
    to enable hardware reset.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 5a794cb503ea..ed8fca890ee2 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -272,6 +272,7 @@ struct _mmc_csd {
 
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
+#define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
@@ -328,6 +329,9 @@ struct _mmc_csd {
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
 
+#define EXT_CSD_RST_N_EN_MASK	0x3
+#define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */
+
 /*
  * MMC_SWITCH access modes
  */

commit 0a2d4048a22079d7e79d6654bbacbef57bd5728a
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Mon Jun 20 20:10:08 2011 +0100

    mmc: block: allow get_card_status() to return error status
    
    If the MMC_SEND_STATUS command is not successful, we should not return
    a zero status word, but instead allow the caller to know positively
    that an error occurred.
    
    Convert the open-coded get_card_status() to use the helper function,
    and provide definitions for the card state field.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 5bade0605641..5a794cb503ea 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -140,6 +140,16 @@ static inline bool mmc_op_multi(u32 opcode)
 #define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
+#define R1_STATE_IDLE	0
+#define R1_STATE_READY	1
+#define R1_STATE_IDENT	2
+#define R1_STATE_STBY	3
+#define R1_STATE_TRAN	4
+#define R1_STATE_DATA	5
+#define R1_STATE_RCV	6
+#define R1_STATE_PRG	7
+#define R1_STATE_DIS	8
+
 /*
  * MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
  * R1 is the low order byte; R2 is the next highest byte, when present.

commit 100e918610b7487fa18db97b3879cd8d1fdd5974
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri May 27 16:04:03 2011 -0400

    mmc: Standardize header file inclusion checks.
    
    Standardize the checks for multiple MMC header file inclusion,
    including adding comments to terminating #endif's, and fixing
    one incorrect comment.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index ac26a685cca8..5bade0605641 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -21,8 +21,8 @@
  *          15 May 2002
  */
 
-#ifndef MMC_MMC_H
-#define MMC_MMC_H
+#ifndef LINUX_MMC_MMC_H
+#define LINUX_MMC_MMC_H
 
 /* Standard MMC commands (4.1)           type  argument     response */
    /* class 1 */
@@ -327,5 +327,4 @@ struct _mmc_csd {
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
-#endif  /* MMC_MMC_PROTOCOL_H */
-
+#endif /* LINUX_MMC_MMC_H */

commit d0c97cfb81ebc5b416c0f92fa2fc18d2773e3023
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:36 2011 -0500

    mmc: core: Use CMD23 for multiblock transfers when we can.
    
    CMD23-prefixed instead of open-ended multiblock transfers
    have a performance advantage on some MMC cards.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 9fa5a73f393d..ac26a685cca8 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -83,6 +83,12 @@
 #define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
 #define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
 
+static inline bool mmc_op_multi(u32 opcode)
+{
+	return opcode == MMC_WRITE_MULTIPLE_BLOCK ||
+	       opcode == MMC_READ_MULTIPLE_BLOCK;
+}
+
 /*
  * MMC_SWITCH argument format:
  *

commit b513ea250eb7c36a8afb3df938d632ca6b4df7cd
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:04 2011 +0530

    mmc: sd: add support for tuning during uhs initialization
    
    Host Controller needs tuning during initialization to operate SDR50
    and SDR104 UHS-I cards. Whether SDR50 mode actually needs tuning is
    indicated by bit 45 of the Host Controller Capabilities register.
    A new command CMD19 has been defined in the Physical Layer spec
    v3.01 to request the card to send tuning pattern.
    
    We enable Buffer Read Ready interrupt at the very begining of tuning
    procedure, because that is the only interrupt generated by the Host
    Controller during tuning. We program the block size to 64 in the
    Block Size register. We make sure that DMA Enable and Multi Block
    Select in the Transfer Mode register are set to 0 before actually
    sending CMD19. The tuning block is sent by the card to the Host
    Controller using DAT lines, so we set Data Present Select (bit 5) in
    the Command register. The Host Controller is responsible for doing
    the verfication of tuning block sent by the card at the hardware
    level. After sending CMD19, we wait for Buffer Read Ready interrupt.
    In case we don't receive an interrupt after the specified timeout
    value, we fall back on fixed sampling clock by setting Execute
    Tuning (bit 6) and Sampling Clock Select (bit 7) of Host Control2
    register to 0. Before exiting the tuning procedure, we disable Buffer
    Read Ready interrupt and re-enable other interrupts.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 373b2bf5e5b5..9fa5a73f393d 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -50,6 +50,7 @@
 #define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
 #define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
 #define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+#define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
 
   /* class 3 */
 #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */

commit 371a689f64b0da140c3bcd3f55305ffa1c3a58ef
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon Apr 11 18:10:25 2011 -0500

    mmc: MMC boot partitions support.
    
    Allows device MMC boot partitions to be accessed. MMC partitions are
    treated effectively as separate block devices on the same MMC card.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 390aa6eef676..373b2bf5e5b5 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -257,19 +257,21 @@ struct _mmc_csd {
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
-#define EXT_CSD_BOOT_CONFIG		179	/* R/W */
+#define EXT_CSD_PART_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_STRUCTURE		194	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT		217	/* RO */
 #define EXT_CSD_REL_WR_SEC_C		222	/* RO */
 #define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_ERASE_TIMEOUT_MULT	223	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
+#define EXT_CSD_BOOT_MULT		226	/* RO */
 #define EXT_CSD_SEC_TRIM_MULT		229	/* RO */
 #define EXT_CSD_SEC_ERASE_MULT		230	/* RO */
 #define EXT_CSD_SEC_FEATURE_SUPPORT	231	/* RO */
@@ -281,6 +283,10 @@ struct _mmc_csd {
 
 #define EXT_CSD_WR_REL_PARAM_EN		(1<<2)
 
+#define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
+#define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
+#define EXT_CSD_PART_CONFIG_ACC_BOOT1	(0x2)
+
 #define EXT_CSD_CMD_SET_NORMAL		(1<<0)
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)

commit f4c5522b0a8827f39f83f928961d87e081bfe71c
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Thu Mar 31 18:40:00 2011 -0500

    mmc: Reliable write support.
    
    Allows reliable writes to be used for MMC writes. Reliable writes are used
    to service write REQ_FUA/REQ_META requests. Handles both the legacy and
    the enhanced reliable write support in MMC cards.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b5ec88fd1352..390aa6eef676 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -255,6 +255,7 @@ struct _mmc_csd {
 
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
+#define EXT_CSD_WR_REL_PARAM		166	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_BOOT_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
@@ -265,6 +266,7 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE		196	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT		217	/* RO */
+#define EXT_CSD_REL_WR_SEC_C		222	/* RO */
 #define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_ERASE_TIMEOUT_MULT	223	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
@@ -277,6 +279,8 @@ struct _mmc_csd {
  * EXT_CSD field definitions
  */
 
+#define EXT_CSD_WR_REL_PARAM_EN		(1<<2)
+
 #define EXT_CSD_CMD_SET_NORMAL		(1<<0)
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)

commit 41e2a4893566ced3c46af15df5b727326881e47d
Author: Philip Rakity <prakity@marvell.com>
Date:   Sat Mar 19 14:10:33 2011 -0400

    mmc: Ensure linux starts in eMMC user partition
    
    uBoot sometimes leaves eMMC pointing to the private boot partition.
    Ensure we always start looking at the user partition.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Bruce Clemens <bpclemens@marvell.com>
    Signed-off-by: Mark F. Brown <markb@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 264ba5451e3b..b5ec88fd1352 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -256,6 +256,7 @@ struct _mmc_csd {
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
+#define EXT_CSD_BOOT_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
 #define EXT_CSD_HS_TIMING		185	/* R/W */

commit 709de99df0ecf3102e7728fbd876a3591859f423
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Sat Jan 22 04:09:41 2011 +0800

    mmc: export eMMC4.4 enhanced area details to sysfs
    
    Enhanced area feature is a new feature defined in eMMC4.4 standard. This
    user data area provides higher performance/reliability, at the expense
    of using twice the effective media space due to the area using SLC.
    
    The MMC driver now reads out the enhanced area offset and size and adds
    them to the device attributes in sysfs. Enabling the enhanced area can
    only be done once, and should be done in manufacturing. To use this
    feature, bit ERASE_GRP_DEF should also be set.
    
    Documentation/ABI/testing/sysfs-devices-mmc describes the two new
    attributes.
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 612301f85d14..264ba5451e3b 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -253,6 +253,8 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
+#define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
+#define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
@@ -262,6 +264,7 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE		196	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT		217	/* RO */
+#define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_ERASE_TIMEOUT_MULT	223	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
 #define EXT_CSD_SEC_TRIM_MULT		229	/* RO */

commit 22113efd00491310da802f3b1a9a66cfcf415fac
Author: Aries Lee <arieslee@jmicron.com>
Date:   Wed Dec 15 08:14:24 2010 +0100

    mmc: Test bus-width for old MMC devices
    
    Some old MMC devices fail with the 4/8 bits the driver tries to use
    exclusively.  This patch adds a test for the given bus setup and falls
    back to the lower bit mode (until 1-bit mode) when the test fails.
    
    [Major rework and refactoring by tiwai]
    [Quirk addition and many fixes by prakity]
    
    Signed-off-by: Aries Lee <arieslee@jmicron.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 956fbd877692..612301f85d14 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -40,7 +40,9 @@
 #define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
 #define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
 #define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
+#define MMC_BUS_TEST_R           14   /* adtc                    R1  */
 #define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+#define MMC_BUS_TEST_W           19   /* adtc                    R1  */
 #define MMC_SPI_READ_OCR         58   /* spi                  spi_R3 */
 #define MMC_SPI_CRC_ON_OFF       59   /* spi  [0:0] flag      spi_R1 */
 

commit dfc13e8402c75e7c2e0a52e123c0500a3259866b
Author: Hanumath Prasad <hanumath.prasad@stericsson.com>
Date:   Thu Sep 30 17:37:23 2010 -0400

    mmc: MMC 4.4 DDR support
    
    Add support for Dual Data Rate MMC cards as defined in the 4.4
    specification.
    
    Signed-off-by: Hanumath Prasad <hanumath.prasad@stericsson.com>
    Cc: linux-mmc@vger.kernel.org
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Tested-by Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index dd11ae51fb68..956fbd877692 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -277,11 +277,19 @@ struct _mmc_csd {
 
 #define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
-#define EXT_CSD_CARD_TYPE_MASK	0x3	/* Mask out reserved and DDR bits */
+#define EXT_CSD_CARD_TYPE_MASK	0xF	/* Mask out reserved bits */
+#define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
+					     /* DDR mode @1.8V or 3V I/O */
+#define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
+					     /* DDR mode @1.2V I/O */
+#define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
+					| EXT_CSD_CARD_TYPE_DDR_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
+#define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
+#define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)

commit dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:46 2010 -0700

    mmc: add erase, secure erase, trim and secure trim operations
    
    SD/MMC cards tend to support an erase operation.  In addition, eMMC v4.4
    cards can support secure erase, trim and secure trim operations that are
    all variants of the basic erase command.
    
    SD/MMC device attributes "erase_size" and "preferred_erase_size" have been
    added.
    
    "erase_size" is the minimum size, in bytes, of an erase operation.  For
    MMC, "erase_size" is the erase group size reported by the card.  Note that
    "erase_size" does not apply to trim or secure trim operations where the
    minimum size is always one 512 byte sector.  For SD, "erase_size" is 512
    if the card is block-addressed, 0 otherwise.
    
    SD/MMC cards can erase an arbitrarily large area up to and
    including the whole card.  When erasing a large area it may
    be desirable to do it in smaller chunks for three reasons:
    
        1. A single erase command will make all other I/O on the card
           wait.  This is not a problem if the whole card is being erased, but
           erasing one partition will make I/O for another partition on the
           same card wait for the duration of the erase - which could be a
           several minutes.
    
        2. To be able to inform the user of erase progress.
    
        3. The erase timeout becomes too large to be very useful.
           Because the erase timeout contains a margin which is multiplied by
           the size of the erase area, the value can end up being several
           minutes for large areas.
    
    "erase_size" is not the most efficient unit to erase (especially for SD
    where it is just one sector), hence "preferred_erase_size" provides a good
    chunk size for erasing large areas.
    
    For MMC, "preferred_erase_size" is the high-capacity erase size if a card
    specifies one, otherwise it is based on the capacity of the card.
    
    For SD, "preferred_erase_size" is the allocation unit size specified by
    the card.
    
    "preferred_erase_size" is in bytes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 52ce98866287..dd11ae51fb68 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -251,13 +251,21 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
-#define EXT_CSD_BUS_WIDTH	183	/* R/W */
-#define EXT_CSD_HS_TIMING	185	/* R/W */
-#define EXT_CSD_CARD_TYPE	196	/* RO */
-#define EXT_CSD_STRUCTURE	194	/* RO */
-#define EXT_CSD_REV		192	/* RO */
-#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
-#define EXT_CSD_S_A_TIMEOUT	217
+#define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
+#define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
+#define EXT_CSD_BUS_WIDTH		183	/* R/W */
+#define EXT_CSD_HS_TIMING		185	/* R/W */
+#define EXT_CSD_REV			192	/* RO */
+#define EXT_CSD_STRUCTURE		194	/* RO */
+#define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
+#define EXT_CSD_S_A_TIMEOUT		217	/* RO */
+#define EXT_CSD_ERASE_TIMEOUT_MULT	223	/* RO */
+#define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
+#define EXT_CSD_SEC_TRIM_MULT		229	/* RO */
+#define EXT_CSD_SEC_ERASE_MULT		230	/* RO */
+#define EXT_CSD_SEC_FEATURE_SUPPORT	231	/* RO */
+#define EXT_CSD_TRIM_MULT		232	/* RO */
 
 /*
  * EXT_CSD field definitions
@@ -275,6 +283,10 @@ struct _mmc_csd {
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
 
+#define EXT_CSD_SEC_ER_EN	BIT(0)
+#define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
+#define EXT_CSD_SEC_GB_CL_EN	BIT(4)
+
 /*
  * MMC_SWITCH access modes
  */

commit 6da24b786ed1963a7f872c1899627968c76d17d7
Author: Kyungmin Park <kmpark@infradead.org>
Date:   Tue Aug 10 18:01:36 2010 -0700

    mmc: recognize CSD structure
    
    The eMMC spec 4.4 and 4.3 + additional feature chips has CSD structure
    version 3 and version 3 have to check the CSD_STRUCTURE byte in the
    EXT_CSD register.
    
    Also fix EXT_CSD revision message.
    
    [akpm@linux-foundation.org: fix comment, per Chris Ball]
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 8a49cbf0376d..52ce98866287 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -254,6 +254,7 @@ struct _mmc_csd {
 #define EXT_CSD_BUS_WIDTH	183	/* R/W */
 #define EXT_CSD_HS_TIMING	185	/* R/W */
 #define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_STRUCTURE	194	/* RO */
 #define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT	217

commit 7198f3c9b13c7aa1e5d9f7ff74c0ea303174feff
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Mar 23 13:35:40 2010 -0700

    mmc: fix incorrect interpretation of card type bits
    
    In the extended CSD register the CARD_TYPE is an 8-bit value of which the
    upper 6 bits were reserved in JEDEC specifications prior to version 4.4.
    In version 4.4 two of the reserved bits were designated for identifying
    support for the newly added High-Speed Dual Data Rate.  Unfortunately the
    mmc_read_ext_csd() function required that the reserved bits be zero
    instead of ignoring them as it should.
    
    This patch makes mmc_read_ext_csd() ignore the CARD_TYPE bits that are
    reserved or not yet supported.  It also stops the function jumping to the
    end as though an error occurred, when it is only warns that the CARD_TYPE
    bits (that it does interpret) are invalid.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index c02c8db73701..8a49cbf0376d 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -268,6 +268,7 @@ struct _mmc_csd {
 
 #define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_MASK	0x3	/* Mask out reserved and DDR bits */
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */

commit ef0b27d4ccacac32afc3d1c0e8a95e4091dfbc8c
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Tue Sep 22 16:44:37 2009 -0700

    mmc: check status after MMC SWITCH command
    
    According to the standard, the SWITCH command should be followed by a
    SEND_STATUS command to check for errors.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b2b40951c16c..c02c8db73701 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -128,6 +128,7 @@
 #define R1_STATUS(x)            (x & 0xFFFFE000)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
 /*

commit b1ebe38456f7fe61a88af2844361e763ac6ea5ae
Author: Jarkko Lavinen <jarkko.lavinen@nokia.com>
Date:   Tue Sep 22 16:44:34 2009 -0700

    mmc: add mmc card sleep and awake support
    
    Add support for the new MMC command SLEEP_AWAKE.
    
    Signed-off-by: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 14b81f3e5232..b2b40951c16c 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -31,6 +31,7 @@
 #define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
 #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
 #define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SLEEP_AWAKE		  5   /* ac   [31:16] RCA 15:flg R1b */
 #define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
 #define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
 #define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
@@ -254,6 +255,7 @@ struct _mmc_csd {
 #define EXT_CSD_CARD_TYPE	196	/* RO */
 #define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+#define EXT_CSD_S_A_TIMEOUT	217
 
 /*
  * EXT_CSD field definitions

commit 150a55683b6b0ccb66aae75a10a3a514340c7c03
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 00:57:27 2008 +0300

    include/linux/mmc/mmc.h: remove CVS tags
    
    This patch removes a CVS tag that wasn't updated for a long time.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 4236fbf0b6fb..14b81f3e5232 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -16,7 +16,6 @@
  * Based strongly on code by:
  *
  * Author: Yong-iL Joh <tolkien@mizi.com>
- * Date  : $Date: 2002/06/18 12:37:30 $
  *
  * Author:  Andrew Christian
  *          15 May 2002

commit 97018580c40c8a31dd7ae744da3378c787a2066d
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Aug 8 09:09:01 2007 -0700

    MMC headers learn about SPI
    
    Teach the MMC/SD/SDIO system headers that some hosts use SPI mode
    
     - New host capabilities and status bits
        * MMC_CAP_SPI, with mmc_host_is_spi() test
        * mmc_host.use_spi_crc flag
    
     - SPI-specific declarations:
        * Response types, MMC_RSP_SPI_R*
        * Two SPI-only commands
        * Status bits used native to SPI:  R1_SPI_*, R2_SPI_*
    
     - Fix a few (unrelated) whitespace bugs in the headers.
    
     - Reorder a few mmc_host fields, removing several bytes of padding
    
    None of these changes affect current code.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index d1d6cbcc1514..4236fbf0b6fb 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -27,7 +27,7 @@
 
 /* Standard MMC commands (4.1)           type  argument     response */
    /* class 1 */
-#define	MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_GO_IDLE_STATE         0   /* bc                          */
 #define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
 #define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
 #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
@@ -39,8 +39,10 @@
 #define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
 #define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
 #define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
-#define MMC_SEND_STATUS	         13   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
 #define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+#define MMC_SPI_READ_OCR         58   /* spi                  spi_R3 */
+#define MMC_SPI_CRC_ON_OFF       59   /* spi  [0:0] flag      spi_R1 */
 
   /* class 2 */
 #define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
@@ -90,15 +92,15 @@
  */
 
 /*
-  MMC status in R1
+  MMC status in R1, for native mode (SPI bits are different)
   Type
-  	e : error bit
+	e : error bit
 	s : status bit
 	r : detected and set for the actual command response
 	x : detected and set during command execution. the host must poll
             the card by sending status command in order to read these bits.
   Clear condition
-  	a : according to the card state
+	a : according to the card state
 	b : always related to the previous command. Reception of
             a valid command will clear it (with a delay of one command)
 	c : clear by read
@@ -124,10 +126,33 @@
 #define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
 #define R1_ERASE_RESET		(1 << 13)	/* sr, c */
 #define R1_STATUS(x)            (x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)    	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
+/*
+ * MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
+ * R1 is the low order byte; R2 is the next highest byte, when present.
+ */
+#define R1_SPI_IDLE		(1 << 0)
+#define R1_SPI_ERASE_RESET	(1 << 1)
+#define R1_SPI_ILLEGAL_COMMAND	(1 << 2)
+#define R1_SPI_COM_CRC		(1 << 3)
+#define R1_SPI_ERASE_SEQ	(1 << 4)
+#define R1_SPI_ADDRESS		(1 << 5)
+#define R1_SPI_PARAMETER	(1 << 6)
+/* R1 bit 7 is always zero */
+#define R2_SPI_CARD_LOCKED	(1 << 8)
+#define R2_SPI_WP_ERASE_SKIP	(1 << 9)	/* or lock/unlock fail */
+#define R2_SPI_LOCK_UNLOCK_FAIL	R2_SPI_WP_ERASE_SKIP
+#define R2_SPI_ERROR		(1 << 10)
+#define R2_SPI_CC_ERROR		(1 << 11)
+#define R2_SPI_CARD_ECC_ERROR	(1 << 12)
+#define R2_SPI_WP_VIOLATION	(1 << 13)
+#define R2_SPI_ERASE_PARAM	(1 << 14)
+#define R2_SPI_OUT_OF_RANGE	(1 << 15)	/* or CSD overwrite */
+#define R2_SPI_CSD_OVERWRITE	R2_SPI_OUT_OF_RANGE
+
 /* These are unpacked versions of the actual responses */
 
 struct _mmc_csd {
@@ -182,6 +207,7 @@ struct _mmc_csd {
  */
 #define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
 					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
+					/* (and for SPI, CMD58,59) */
 #define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
 					/* (CMD11) */
 #define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */

commit d7604d76351f7745d0e62d9f2bbcbb917c9013f3
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 23 00:34:07 2007 +0200

    mmc: read ext_csd version number
    
    Make sure we do not try to parse a structure we do not
    understand.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index e3ed9b95040e..d1d6cbcc1514 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -227,6 +227,7 @@ struct _mmc_csd {
 #define EXT_CSD_BUS_WIDTH	183	/* R/W */
 #define EXT_CSD_HS_TIMING	185	/* R/W */
 #define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
 
 /*

commit da7fbe58d2d347e95af699ddf04d885be6362bbe
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sun Dec 24 22:46:55 2006 +0100

    mmc: Separate out protocol ops
    
    Move protocol operations and definitions into their own files
    in an effort to separate protocol handling and bus
    arbitration more clearly.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
new file mode 100644
index 000000000000..e3ed9b95040e
--- /dev/null
+++ b/include/linux/mmc/mmc.h
@@ -0,0 +1,257 @@
+/*
+ * Header for MultiMediaCard (MMC)
+ *
+ * Copyright 2002 Hewlett-Packard Company
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * HEWLETT-PACKARD COMPANY MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
+ * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
+ * FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ * Many thanks to Alessandro Rubini and Jonathan Corbet!
+ *
+ * Based strongly on code by:
+ *
+ * Author: Yong-iL Joh <tolkien@mizi.com>
+ * Date  : $Date: 2002/06/18 12:37:30 $
+ *
+ * Author:  Andrew Christian
+ *          15 May 2002
+ */
+
+#ifndef MMC_MMC_H
+#define MMC_MMC_H
+
+/* Standard MMC commands (4.1)           type  argument     response */
+   /* class 1 */
+#define	MMC_GO_IDLE_STATE         0   /* bc                          */
+#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
+#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
+#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
+#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
+#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
+#define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
+#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
+#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
+#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
+#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
+#define MMC_SEND_STATUS	         13   /* ac   [31:16] RCA        R1  */
+#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
+
+  /* class 2 */
+#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
+#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
+#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
+
+  /* class 3 */
+#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
+
+  /* class 4 */
+#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
+#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
+#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
+#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
+
+  /* class 6 */
+#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
+#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
+#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
+
+  /* class 5 */
+#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
+#define MMC_ERASE                38   /* ac                      R1b */
+
+  /* class 9 */
+#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
+#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
+
+  /* class 7 */
+#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
+
+  /* class 8 */
+#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
+#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
+
+/*
+ * MMC_SWITCH argument format:
+ *
+ *	[31:26] Always 0
+ *	[25:24] Access Mode
+ *	[23:16] Location of target Byte in EXT_CSD
+ *	[15:08] Value Byte
+ *	[07:03] Always 0
+ *	[02:00] Command Set
+ */
+
+/*
+  MMC status in R1
+  Type
+  	e : error bit
+	s : status bit
+	r : detected and set for the actual command response
+	x : detected and set during command execution. the host must poll
+            the card by sending status command in order to read these bits.
+  Clear condition
+  	a : according to the card state
+	b : always related to the previous command. Reception of
+            a valid command will clear it (with a delay of one command)
+	c : clear by read
+ */
+
+#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
+#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
+#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
+#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
+#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
+#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
+#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
+#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
+#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
+#define R1_CC_ERROR		(1 << 20)	/* erx, c */
+#define R1_ERROR		(1 << 19)	/* erx, c */
+#define R1_UNDERRUN		(1 << 18)	/* ex, c */
+#define R1_OVERRUN		(1 << 17)	/* ex, c */
+#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
+#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
+#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)    	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_APP_CMD		(1 << 5)	/* sr, c */
+
+/* These are unpacked versions of the actual responses */
+
+struct _mmc_csd {
+	u8  csd_structure;
+	u8  spec_vers;
+	u8  taac;
+	u8  nsac;
+	u8  tran_speed;
+	u16 ccc;
+	u8  read_bl_len;
+	u8  read_bl_partial;
+	u8  write_blk_misalign;
+	u8  read_blk_misalign;
+	u8  dsr_imp;
+	u16 c_size;
+	u8  vdd_r_curr_min;
+	u8  vdd_r_curr_max;
+	u8  vdd_w_curr_min;
+	u8  vdd_w_curr_max;
+	u8  c_size_mult;
+	union {
+		struct { /* MMC system specification version 3.1 */
+			u8  erase_grp_size;
+			u8  erase_grp_mult;
+		} v31;
+		struct { /* MMC system specification version 2.2 */
+			u8  sector_size;
+			u8  erase_grp_size;
+		} v22;
+	} erase;
+	u8  wp_grp_size;
+	u8  wp_grp_enable;
+	u8  default_ecc;
+	u8  r2w_factor;
+	u8  write_bl_len;
+	u8  write_bl_partial;
+	u8  file_format_grp;
+	u8  copy;
+	u8  perm_write_protect;
+	u8  tmp_write_protect;
+	u8  file_format;
+	u8  ecc;
+};
+
+/*
+ * OCR bits are mostly in host.h
+ */
+#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */
+
+/*
+ * Card Command Classes (CCC)
+ */
+#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
+					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
+#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
+					/* (CMD11) */
+#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
+					/* (CMD16,17,18) */
+#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
+					/* (CMD20) */
+#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
+					/* (CMD16,24,25,26,27) */
+#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
+					/* (CMD32,33,34,35,36,37,38,39) */
+#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
+					/* (CMD28,29,30) */
+#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
+					/* (CMD16,CMD42) */
+#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
+					/* (CMD55,56,57,ACMD*) */
+#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
+					/* (CMD5,39,40,52,53) */
+#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
+					/* (CMD6,34,35,36,37,50) */
+					/* (11) Reserved */
+					/* (CMD?) */
+
+/*
+ * CSD field definitions
+ */
+
+#define CSD_STRUCT_VER_1_0  0           /* Valid for system specification 1.0 - 1.2 */
+#define CSD_STRUCT_VER_1_1  1           /* Valid for system specification 1.4 - 2.2 */
+#define CSD_STRUCT_VER_1_2  2           /* Valid for system specification 3.1 - 3.2 - 3.31 - 4.0 - 4.1 */
+#define CSD_STRUCT_EXT_CSD  3           /* Version is coded in CSD_STRUCTURE in EXT_CSD */
+
+#define CSD_SPEC_VER_0      0           /* Implements system specification 1.0 - 1.2 */
+#define CSD_SPEC_VER_1      1           /* Implements system specification 1.4 */
+#define CSD_SPEC_VER_2      2           /* Implements system specification 2.0 - 2.2 */
+#define CSD_SPEC_VER_3      3           /* Implements system specification 3.1 - 3.2 - 3.31 */
+#define CSD_SPEC_VER_4      4           /* Implements system specification 4.0 - 4.1 */
+
+/*
+ * EXT_CSD fields
+ */
+
+#define EXT_CSD_BUS_WIDTH	183	/* R/W */
+#define EXT_CSD_HS_TIMING	185	/* R/W */
+#define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+
+/*
+ * EXT_CSD field definitions
+ */
+
+#define EXT_CSD_CMD_SET_NORMAL		(1<<0)
+#define EXT_CSD_CMD_SET_SECURE		(1<<1)
+#define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
+
+#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
+
+#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
+
+/*
+ * MMC_SWITCH access modes
+ */
+
+#define MMC_SWITCH_MODE_CMD_SET		0x00	/* Change the command set */
+#define MMC_SWITCH_MODE_SET_BITS	0x01	/* Set bits which are 1 in value */
+#define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
+#define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
+
+#endif  /* MMC_MMC_PROTOCOL_H */
+

commit aaac1b470bd0dccb30912356617069dc6199cc80
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Feb 28 15:33:10 2007 +0100

    mmc: Move core functions to subdir
    
    Create a "core" subdirectory to house the central bus handling
    functions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
deleted file mode 100644
index b3d80efc6434..000000000000
--- a/include/linux/mmc/mmc.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- *  linux/include/linux/mmc/mmc.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef MMC_H
-#define MMC_H
-
-#include <linux/interrupt.h>
-#include <linux/device.h>
-
-struct request;
-struct mmc_data;
-struct mmc_request;
-
-struct mmc_command {
-	u32			opcode;
-	u32			arg;
-	u32			resp[4];
-	unsigned int		flags;		/* expected response type */
-#define MMC_RSP_PRESENT	(1 << 0)
-#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
-#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
-#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
-#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
-#define MMC_CMD_MASK	(3 << 5)		/* command type */
-#define MMC_CMD_AC	(0 << 5)
-#define MMC_CMD_ADTC	(1 << 5)
-#define MMC_CMD_BC	(2 << 5)
-#define MMC_CMD_BCR	(3 << 5)
-
-/*
- * These are the response types, and correspond to valid bit
- * patterns of the above flags.  One additional valid pattern
- * is all zeros, which means we don't expect a response.
- */
-#define MMC_RSP_NONE	(0)
-#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
-#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
-#define MMC_RSP_R3	(MMC_RSP_PRESENT)
-#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-
-#define mmc_resp_type(cmd)	((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))
-
-/*
- * These are the command types.
- */
-#define mmc_cmd_type(cmd)	((cmd)->flags & MMC_CMD_MASK)
-
-	unsigned int		retries;	/* max number of retries */
-	unsigned int		error;		/* command error */
-
-#define MMC_ERR_NONE	0
-#define MMC_ERR_TIMEOUT	1
-#define MMC_ERR_BADCRC	2
-#define MMC_ERR_FIFO	3
-#define MMC_ERR_FAILED	4
-#define MMC_ERR_INVALID	5
-
-	struct mmc_data		*data;		/* data segment associated with cmd */
-	struct mmc_request	*mrq;		/* associated request */
-};
-
-struct mmc_data {
-	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
-	unsigned int		timeout_clks;	/* data timeout (in clocks) */
-	unsigned int		blksz;		/* data block size */
-	unsigned int		blocks;		/* number of blocks */
-	unsigned int		error;		/* data error */
-	unsigned int		flags;
-
-#define MMC_DATA_WRITE	(1 << 8)
-#define MMC_DATA_READ	(1 << 9)
-#define MMC_DATA_STREAM	(1 << 10)
-#define MMC_DATA_MULTI	(1 << 11)
-
-	unsigned int		bytes_xfered;
-
-	struct mmc_command	*stop;		/* stop command */
-	struct mmc_request	*mrq;		/* associated request */
-
-	unsigned int		sg_len;		/* size of scatter list */
-	struct scatterlist	*sg;		/* I/O scatter list */
-};
-
-struct mmc_request {
-	struct mmc_command	*cmd;
-	struct mmc_data		*data;
-	struct mmc_command	*stop;
-
-	void			*done_data;	/* completion data */
-	void			(*done)(struct mmc_request *);/* completion function */
-};
-
-struct mmc_host;
-struct mmc_card;
-
-extern int mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
-extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
-extern int mmc_wait_for_app_cmd(struct mmc_host *, unsigned int,
-	struct mmc_command *, int);
-
-extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *, int);
-
-extern void mmc_claim_host(struct mmc_host *host);
-extern void mmc_release_host(struct mmc_host *host);
-
-#endif

commit b855885e3b60cf6f9452848712a62517b94583eb
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jan 3 19:47:29 2007 +0100

    mmc: deprecate mmc bus topology
    
    The classic MMC bus was defined as multi card bus
    system, which is reflected in the design in the MMC
    layer.
    
    When SD showed up, the bus topology was abandoned
    and a star topology (one card per host) was mandated.
    MMC version 4 has followed this, officially deprecating
    the bus topology.
    
    As we do not have any known users of the bus
    topology we can remove support for it. This will
    simplify the code and rectify some incorrect
    assumptions in the newer additions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index cdc54be804f1..b3d80efc6434 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -8,7 +8,6 @@
 #ifndef MMC_H
 #define MMC_H
 
-#include <linux/list.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
 
@@ -107,13 +106,7 @@ extern int mmc_wait_for_app_cmd(struct mmc_host *, unsigned int,
 
 extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *, int);
 
-extern int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card);
-
-static inline void mmc_claim_host(struct mmc_host *host)
-{
-	__mmc_claim_host(host, (struct mmc_card *)-1);
-}
-
+extern void mmc_claim_host(struct mmc_host *host);
 extern void mmc_release_host(struct mmc_host *host);
 
 #endif

commit fba68bd2dab1ac99af3c5a963ec9581cfa9f1725
Author: Philip Langdale <philipl@overt.org>
Date:   Thu Jan 4 06:57:32 2007 -0800

    mmc: Add support for SDHC cards
    
    Thanks to the generous donation of an SDHC card by John Gilmore, and
    the surprisingly enlightened decision by the SD Card Association to
    publish useful specs, I've been able to bash out support for SDHC. The
    changes are not too profound:
    
    i) Add a card flag indicating the card uses block level addressing and
    check it in the block driver. As we never took advantage of byte-level
    addressing, this simply involves skipping the block -> byte
    translation when sending commands.
    
    ii) The layout of the CSD is changed - a set of fields are discarded
    to make space for a larger C_SIZE. We did not reference any of the
    discarded fields except those related to the C_SIZE.
    
    iii) Read and write timeouts are fixed values and not calculated from
    CSD values.
    
    iv) Before invoking SEND_APP_OP_COND, we must invoke the new
    SEND_IF_COND to inform the card we support SDHC.
    
    Signed-off-by: Philipl Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index bcf24909d677..cdc54be804f1 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -43,6 +43,7 @@ struct mmc_command {
 #define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
 #define MMC_RSP_R3	(MMC_RSP_PRESENT)
 #define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 
 #define mmc_resp_type(cmd)	((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))
 

commit 6f949909e8f9e5d7e5584dc48d9a5e060c52aed1
Author: Philip Langdale <philipl@overt.org>
Date:   Thu Jan 4 07:04:47 2007 -0800

    mmc: Correct definition of R6
    
    During development of SDHC support, it was discovered that the definition
    for R6 was incorrect. This patch fixes that and patches the drivers that
    do switch on the response type.
    
    Signed-off-by: Philip Langdale <philipl@overt.org>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: Pavel Pisa <ppisa@pikron.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index a3594dfd6963..bcf24909d677 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -42,7 +42,7 @@ struct mmc_command {
 #define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
 #define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
 #define MMC_RSP_R3	(MMC_RSP_PRESENT)
-#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC)
+#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
 
 #define mmc_resp_type(cmd)	((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))
 

commit 132919ba80ad207755fe271277bfefff865a54fe
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 27 13:56:52 2006 +0100

    [MMC] Remove data->blksz_bits member
    
    data->blksz_bits is unused now - remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 627e2c08ce41..a3594dfd6963 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -68,7 +68,6 @@ struct mmc_command {
 struct mmc_data {
 	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
 	unsigned int		timeout_clks;	/* data timeout (in clocks) */
-	unsigned int		blksz_bits;	/* data block size */
 	unsigned int		blksz;		/* data block size */
 	unsigned int		blocks;		/* number of blocks */
 	unsigned int		error;		/* data error */

commit d773d7255199a6c8934e197756f54a1115dd127b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 7 15:57:12 2006 +0100

    [MMC] Cleanup 385e3227d4d83ab13d7767c4bb3593b0256bf246
    
    Rather than having two places which independently calculate the
    timeout for data transfers, make it a library function instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 03a14a30c46a..627e2c08ce41 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -105,6 +105,8 @@ extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
 extern int mmc_wait_for_app_cmd(struct mmc_host *, unsigned int,
 	struct mmc_command *, int);
 
+extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *, int);
+
 extern int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card);
 
 static inline void mmc_claim_host(struct mmc_host *host)

commit 2c171bf13423dc5293188cea7f6c2da1720926e2
Author: Pavel Pisa <ppisa@pikron.com>
Date:   Fri May 19 21:48:03 2006 +0100

    [ARM] 3531/1: i.MX/MX1 SD/MMC ensure, that clock are stopped before new command and cleanups
    
    Patch from Pavel Pisa
    
    There has been problems that for some paths that clock are not stopped
    during new command programming and initiation. Result is issuing
    of incorrect command to the card. Some other problems are cleaned too.
    Noisy report of known ERRATUM #4 has been suppressed.
    
    Signed-off-by: Pavel Pisa <pisa@cmp.felk.cvut.cz>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index bdc556d88498..03a14a30c46a 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -69,6 +69,7 @@ struct mmc_data {
 	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
 	unsigned int		timeout_clks;	/* data timeout (in clocks) */
 	unsigned int		blksz_bits;	/* data block size */
+	unsigned int		blksz;		/* data block size */
 	unsigned int		blocks;		/* number of blocks */
 	unsigned int		error;		/* data error */
 	unsigned int		flags;

commit 5bd546aa78b5d74f3162815e41940f862215d9e3
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Feb 17 20:23:29 2006 +0000

    [MMC] Fix mmc_cmd_type() mask
    
    It's MMC_CMD_MASK not MMC_CMD_TYPE.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index f38872abc126..bdc556d88498 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -49,7 +49,7 @@ struct mmc_command {
 /*
  * These are the command types.
  */
-#define mmc_cmd_type(cmd)	((cmd)->flags & MMC_CMD_TYPE)
+#define mmc_cmd_type(cmd)	((cmd)->flags & MMC_CMD_MASK)
 
 	unsigned int		retries;	/* max number of retries */
 	unsigned int		error;		/* command error */

commit e92251762d02a46177d4105d1744041e3f8bc465
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Feb 2 12:23:12 2006 +0000

    [MMC] Add MMC command type flags
    
    Some hosts need to know the command type, so pass it via a set of
    flags in cmd->flags.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index ccd3e13de1e8..f38872abc126 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -21,24 +21,35 @@ struct mmc_command {
 	u32			arg;
 	u32			resp[4];
 	unsigned int		flags;		/* expected response type */
-#define MMC_RSP_NONE	(0 << 0)
-#define MMC_RSP_SHORT	(1 << 0)
-#define MMC_RSP_LONG	(2 << 0)
-#define MMC_RSP_MASK	(3 << 0)
-#define MMC_RSP_CRC	(1 << 3)		/* expect valid crc */
-#define MMC_RSP_BUSY	(1 << 4)		/* card may send busy */
-#define MMC_RSP_OPCODE	(1 << 5)		/* response contains opcode */
+#define MMC_RSP_PRESENT	(1 << 0)
+#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
+#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
+#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
+#define MMC_CMD_MASK	(3 << 5)		/* command type */
+#define MMC_CMD_AC	(0 << 5)
+#define MMC_CMD_ADTC	(1 << 5)
+#define MMC_CMD_BC	(2 << 5)
+#define MMC_CMD_BCR	(3 << 5)
 
 /*
  * These are the response types, and correspond to valid bit
  * patterns of the above flags.  One additional valid pattern
  * is all zeros, which means we don't expect a response.
  */
-#define MMC_RSP_R1	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R1B	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
-#define MMC_RSP_R2	(MMC_RSP_LONG|MMC_RSP_CRC)
-#define MMC_RSP_R3	(MMC_RSP_SHORT)
-#define MMC_RSP_R6	(MMC_RSP_SHORT|MMC_RSP_CRC)
+#define MMC_RSP_NONE	(0)
+#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1B	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
+#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3	(MMC_RSP_PRESENT)
+#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC)
+
+#define mmc_resp_type(cmd)	((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))
+
+/*
+ * These are the command types.
+ */
+#define mmc_cmd_type(cmd)	((cmd)->flags & MMC_CMD_TYPE)
 
 	unsigned int		retries;	/* max number of retries */
 	unsigned int		error;		/* command error */

commit 7225b3fd0b6e224235fc50a69f70479ff96d5602
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jan 9 22:51:46 2006 +0000

    [MMC] Indicate that R1/R1b contains command opcode
    
    Some controllers actually check the first byte of the response (most
    don't).  This byte contains the command opcode for R1/R1b and all 1:s
    for other types. The difference must be indicated to the controller
    so it knows which reply to expect.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 86d491b3b73f..ccd3e13de1e8 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -27,14 +27,15 @@ struct mmc_command {
 #define MMC_RSP_MASK	(3 << 0)
 #define MMC_RSP_CRC	(1 << 3)		/* expect valid crc */
 #define MMC_RSP_BUSY	(1 << 4)		/* card may send busy */
+#define MMC_RSP_OPCODE	(1 << 5)		/* response contains opcode */
 
 /*
  * These are the response types, and correspond to valid bit
  * patterns of the above flags.  One additional valid pattern
  * is all zeros, which means we don't expect a response.
  */
-#define MMC_RSP_R1	(MMC_RSP_SHORT|MMC_RSP_CRC)
-#define MMC_RSP_R1B	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_BUSY)
+#define MMC_RSP_R1	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1B	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
 #define MMC_RSP_R2	(MMC_RSP_LONG|MMC_RSP_CRC)
 #define MMC_RSP_R3	(MMC_RSP_SHORT)
 #define MMC_RSP_R6	(MMC_RSP_SHORT|MMC_RSP_CRC)

commit 788ee7b09883515f3a72a8f2a980df5e94f37e2c
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jan 9 21:12:17 2006 +0000

    [MMC] Add DATA_MULTI flag
    
    Some hosts need to know that a transfer will be multi-block.
    Add a data flag to indicate multiple data block transfers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index aef6042f8f0b..86d491b3b73f 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -64,6 +64,7 @@ struct mmc_data {
 #define MMC_DATA_WRITE	(1 << 8)
 #define MMC_DATA_READ	(1 << 9)
 #define MMC_DATA_STREAM	(1 << 10)
+#define MMC_DATA_MULTI	(1 << 11)
 
 	unsigned int		bytes_xfered;
 

commit 8573b80f020dce7aefa3237f1e932d562b65323d
Author: Erik Hovland <erik@hovland.org>
Date:   Fri Oct 28 16:28:04 2005 +0100

    [ARM] 3031/1: fix typos in comments of mmc.h
    
    Patch from Erik Hovland
    
    I noticed that the same typo (i before c in associated) showed up twice
    in the file kernel/include/linux/mmc/mmc.h.
    
    This patch fixes both of the instances I found with this mistake. The
    typos are in comments and should have no affect on working code.
    
    E
    
    Signed-off-by: Erik Hovland <erik@hovland.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 1ab78e8d6c53..aef6042f8f0b 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -50,7 +50,7 @@ struct mmc_command {
 #define MMC_ERR_INVALID	5
 
 	struct mmc_data		*data;		/* data segment associated with cmd */
-	struct mmc_request	*mrq;		/* assoicated request */
+	struct mmc_request	*mrq;		/* associated request */
 };
 
 struct mmc_data {
@@ -68,7 +68,7 @@ struct mmc_data {
 	unsigned int		bytes_xfered;
 
 	struct mmc_command	*stop;		/* stop command */
-	struct mmc_request	*mrq;		/* assoicated request */
+	struct mmc_request	*mrq;		/* associated request */
 
 	unsigned int		sg_len;		/* size of scatter list */
 	struct scatterlist	*sg;		/* I/O scatter list */

commit 335eadf2ef6a1122a720aea98e758e5d431da87d
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:50 2005 -0700

    [PATCH] sd: initialize SD cards
    
    Support for the Secure Digital protocol in the MMC layer.
    
    A summary of the legal issues surrounding SD cards, as understood by yours
    truly:
    
    Members of the Secure Digital Association, hereafter SDA, are required to sign
    a NDA[1] before given access to any specifications.  It has been speculated
    that including an SD implementation would forbid these members to redistribute
    Linux.  This is the basic problem with SD support so it is unclear if it even
    is a problem since it has no effect on those of us that aren't members.
    
    The SDA doesn't seem to enforce these rules though since the patches included
    here are based on documentation made public by some of the members.  The most
    complete specs[2] are actually released by Sandisk, one of the founding
    companies of the SDA.
    
    Because of this the NDA is considered a non-issue by most involved in the
    discussions concerning these patches.  It might be that the SDA is only
    interested in protecting the so called "secure" bits of SD, which so far
    hasn't been found in any public spec.  (The card is split into two sections,
    one "normal" and one "secure" which has an access scheme similar to TPM:s).
    
    (As a side note, Microsoft is working to make things easier for us since they
    want to be able to include the source code for a SD driver in one of their
    development kits.  HP is making sure that the new NDA will allow a Linux
    implementation.  So far only the SDIO specs have been opened up[3].  More will
    hopefully follow.)
    
     [1] http://www.sdcard.org/membership/images/ippolicy.pdf
     [2] http://www.sandisk.com/pdf/oem/ProdManualSDCardv1.9.pdf
     [3] http://www.sdcard.org/sdio/Simplified%20SDIO%20Card%20Specification.pdf
    
    This patch contains the central parts of the SD support.  If no MMC cards are
    found on a bus then the MMC layer proceeds looking for SD cards.  Helper
    functions are extended to handle the special needs of SD cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 0d35d4ffb360..1ab78e8d6c53 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -88,6 +88,8 @@ struct mmc_card;
 
 extern int mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
 extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
+extern int mmc_wait_for_app_cmd(struct mmc_host *, unsigned int,
+	struct mmc_command *, int);
 
 extern int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card);
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
new file mode 100644
index 000000000000..0d35d4ffb360
--- /dev/null
+++ b/include/linux/mmc/mmc.h
@@ -0,0 +1,101 @@
+/*
+ *  linux/include/linux/mmc/mmc.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef MMC_H
+#define MMC_H
+
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+struct request;
+struct mmc_data;
+struct mmc_request;
+
+struct mmc_command {
+	u32			opcode;
+	u32			arg;
+	u32			resp[4];
+	unsigned int		flags;		/* expected response type */
+#define MMC_RSP_NONE	(0 << 0)
+#define MMC_RSP_SHORT	(1 << 0)
+#define MMC_RSP_LONG	(2 << 0)
+#define MMC_RSP_MASK	(3 << 0)
+#define MMC_RSP_CRC	(1 << 3)		/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 4)		/* card may send busy */
+
+/*
+ * These are the response types, and correspond to valid bit
+ * patterns of the above flags.  One additional valid pattern
+ * is all zeros, which means we don't expect a response.
+ */
+#define MMC_RSP_R1	(MMC_RSP_SHORT|MMC_RSP_CRC)
+#define MMC_RSP_R1B	(MMC_RSP_SHORT|MMC_RSP_CRC|MMC_RSP_BUSY)
+#define MMC_RSP_R2	(MMC_RSP_LONG|MMC_RSP_CRC)
+#define MMC_RSP_R3	(MMC_RSP_SHORT)
+#define MMC_RSP_R6	(MMC_RSP_SHORT|MMC_RSP_CRC)
+
+	unsigned int		retries;	/* max number of retries */
+	unsigned int		error;		/* command error */
+
+#define MMC_ERR_NONE	0
+#define MMC_ERR_TIMEOUT	1
+#define MMC_ERR_BADCRC	2
+#define MMC_ERR_FIFO	3
+#define MMC_ERR_FAILED	4
+#define MMC_ERR_INVALID	5
+
+	struct mmc_data		*data;		/* data segment associated with cmd */
+	struct mmc_request	*mrq;		/* assoicated request */
+};
+
+struct mmc_data {
+	unsigned int		timeout_ns;	/* data timeout (in ns, max 80ms) */
+	unsigned int		timeout_clks;	/* data timeout (in clocks) */
+	unsigned int		blksz_bits;	/* data block size */
+	unsigned int		blocks;		/* number of blocks */
+	unsigned int		error;		/* data error */
+	unsigned int		flags;
+
+#define MMC_DATA_WRITE	(1 << 8)
+#define MMC_DATA_READ	(1 << 9)
+#define MMC_DATA_STREAM	(1 << 10)
+
+	unsigned int		bytes_xfered;
+
+	struct mmc_command	*stop;		/* stop command */
+	struct mmc_request	*mrq;		/* assoicated request */
+
+	unsigned int		sg_len;		/* size of scatter list */
+	struct scatterlist	*sg;		/* I/O scatter list */
+};
+
+struct mmc_request {
+	struct mmc_command	*cmd;
+	struct mmc_data		*data;
+	struct mmc_command	*stop;
+
+	void			*done_data;	/* completion data */
+	void			(*done)(struct mmc_request *);/* completion function */
+};
+
+struct mmc_host;
+struct mmc_card;
+
+extern int mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
+extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
+
+extern int __mmc_claim_host(struct mmc_host *host, struct mmc_card *card);
+
+static inline void mmc_claim_host(struct mmc_host *host)
+{
+	__mmc_claim_host(host, (struct mmc_card *)-1);
+}
+
+extern void mmc_release_host(struct mmc_host *host);
+
+#endif
