commit 064f7e58ee42372be05ec87fdf57864c7475ba93
Author: Krishna Konda <kkonda@codeaurora.org>
Date:   Fri May 1 19:23:01 2020 +0530

    mmc: core: expose info about enhanced rpmb support
    
    Following eMMC JEDEC JESD84-B51 standard, an enhanced form of
    rpmb is supported. What this enhanced mode supports is in addition
    to be able to write one rpmb or two rpmb frames at a time,
    32 frames can be written at a time.
    
    Expose this information present in ext csd field so that the
    user space application that wants to make use of this can do so.
    
    Signed-off-by: Krishna Konda <kkonda@codeaurora.org>
    Signed-off-by: Veerabhadrarao Badiganti <vbadigan@codeaurora.org>
    Link: https://lore.kernel.org/r/1588341189-4371-1-git-send-email-vbadigan@codeaurora.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index cf3780a6ccc4..7d46411ffaa2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -48,6 +48,7 @@ struct mmc_ext_csd {
 	u8			sec_feature_support;
 	u8			rel_sectors;
 	u8			rel_param;
+	bool			enhanced_rpmb_supported;
 	u8			part_config;
 	u8			cache_ctrl;
 	u8			rst_n_function;

commit f3d7c2292d104519195fdb11192daec13229c219
Author: Bradley Bolen <bradleybolen@gmail.com>
Date:   Sat Nov 16 20:00:45 2019 -0500

    mmc: core: Fix size overflow for mmc partitions
    
    With large eMMC cards, it is possible to create general purpose
    partitions that are bigger than 4GB.  The size member of the mmc_part
    struct is only an unsigned int which overflows for gp partitions larger
    than 4GB.  Change this to a u64 to handle the overflow.
    
    Signed-off-by: Bradley Bolen <bradleybolen@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e459b38ef33c..cf3780a6ccc4 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -226,7 +226,7 @@ struct mmc_queue_req;
  * MMC Physical partitions
  */
 struct mmc_part {
-	unsigned int	size;	/* partition size (in bytes) */
+	u64		size;	/* partition size (in bytes) */
 	unsigned int	part_cfg;	/* partition type */
 	char	name[MAX_MMC_PART_NAME_LEN];
 	bool	force_ro;	/* to make boot parts RO by default */

commit 2ac55d5e5ec9ad0a07e194f0eaca865fe5aa3c40
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Oct 17 15:25:36 2019 +0200

    mmc: core: Re-work HW reset for SDIO cards
    
    It have turned out that it's not a good idea to unconditionally do a power
    cycle and then to re-initialize the SDIO card, as currently done through
    mmc_hw_reset() -> mmc_sdio_hw_reset(). This because there may be multiple
    SDIO func drivers probed, who also shares the same SDIO card.
    
    To address these scenarios, one may be tempted to use a notification
    mechanism, as to allow the core to inform each of the probed func drivers,
    about an ongoing HW reset. However, supporting such an operation from the
    func driver point of view, may not be entirely trivial.
    
    Therefore, let's use a more simplistic approach to solve the problem, by
    instead forcing the card to be removed and re-detected, via scheduling a
    rescan-work. In this way, we can rely on existing infrastructure, as the
    func driver's ->remove() and ->probe() callbacks, becomes invoked to deal
    with the cleanup and the re-initialization.
    
    This solution may be considered as rather heavy, especially if a func
    driver doesn't share its card with other func drivers. To address this,
    let's keep the current immediate HW reset option as well, but run it only
    when there is one func driver probed for the card.
    
    Finally, to allow the caller of mmc_hw_reset(), to understand if the reset
    is being asynchronously managed from a scheduled work, it returns 1
    (propagated from mmc_sdio_hw_reset()). If the HW reset is executed
    successfully and synchronously it returns 0, which maintains the existing
    behaviour.
    
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Cc: stable@vger.kernel.org # v5.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 9b6336ad3266..e459b38ef33c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -291,6 +291,7 @@ struct mmc_card {
 	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
 
 	unsigned int		sdio_funcs;	/* number of SDIO functions */
+	atomic_t		sdio_funcs_probed; /* number of probed SDIO funcs */
 	struct sdio_cccr	cccr;		/* common card info */
 	struct sdio_cis		cis;		/* common tuple info */
 	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 19566ab9decb..9b6336ad3266 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *  linux/include/linux/mmc/card.h
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  Card driver specific definitions.
  */
 #ifndef LINUX_MMC_CARD_H

commit 68539e2bc34437d8c5fbcc234dddcc40bd6bb1cb
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 6 13:28:06 2019 +0200

    mmc: core: Indicate SD specs higher than 4.0
    
    SD specs version 4.x and 5.x have a dedicated slices in the SCR register.
    Higher versions will rely on a combination of the existing fields.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e2bbceb80725..19566ab9decb 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -133,6 +133,8 @@ struct mmc_ext_csd {
 struct sd_scr {
 	unsigned char		sda_vsn;
 	unsigned char		sda_spec3;
+	unsigned char		sda_spec4;
+	unsigned char		sda_specx;
 	unsigned char		bus_widths;
 #define SD_SCR_BUS_WIDTH_1	(1<<0)
 #define SD_SCR_BUS_WIDTH_4	(1<<2)

commit 01904ff77676ca6c88e972906ed204a2dfbabab6
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 6 13:28:05 2019 +0200

    mmc: core: Calculate the discard arg only once
    
    In MMC, the discard arg is a read-only ext_csd parameter - set it once
    on card init. To be consistent, do that for SD as well even though its
    discard arg is always 0x0.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 8ef330027b13..e2bbceb80725 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -277,6 +277,7 @@ struct mmc_card {
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
  	unsigned int		pref_erase;	/* in sectors */
 	unsigned int		eg_boundary;	/* don't cross erase-group boundaries */
+	unsigned int		erase_arg;	/* erase / trim / discard */
  	u8			erased_byte;	/* value of erased bytes */
 
 	u32			raw_cid[4];	/* raw card CID */

commit dcf6e2e38a1c7ccbc535de5e1d9b14998847499d
Author: Zachary Hays <zhays@lexmark.com>
Date:   Thu Feb 7 10:03:08 2019 -0500

    mmc: block: handle complete_work on separate workqueue
    
    The kblockd workqueue is created with the WQ_MEM_RECLAIM flag set.
    This generates a rescuer thread for that queue that will trigger when
    the CPU is under heavy load and collect the uncompleted work.
    
    In the case of mmc, this creates the possibility of a deadlock when
    there are multiple partitions on the device as other blk-mq work is
    also run on the same queue. For example:
    
    - worker 0 claims the mmc host to work on partition 1
    - worker 1 attempts to claim the host for partition 2 but has to wait
      for worker 0 to finish
    - worker 0 schedules complete_work to release the host
    - rescuer thread is triggered after time-out and collects the dangling
      work
    - rescuer thread attempts to complete the work in order starting with
      claim host
    - the task to release host is now blocked by a task to claim it and
      will never be called
    
    The above results in multiple hung tasks that lead to failures to
    mount partitions.
    
    Handling complete_work on a separate workqueue avoids this by keeping
    the work completion tasks separate from the other blk-mq work. This
    allows the host to be released without getting blocked by other tasks
    attempting to claim the host.
    
    Signed-off-by: Zachary Hays <zhays@lexmark.com>
    Fixes: 81196976ed94 ("mmc: block: Add blk-mq support")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index de7377815b6b..8ef330027b13 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -308,6 +308,7 @@ struct mmc_card {
 	unsigned int    nr_parts;
 
 	unsigned int		bouncesz;	/* Bounce buffer size */
+	struct workqueue_struct *complete_wq;	/* Private workqueue */
 };
 
 static inline bool mmc_large_sector(struct mmc_card *card)

commit a0d476654a2b222567710ab13f3660a39c5641c8
Author: yinbo.zhu <yinbo.zhu@nxp.com>
Date:   Thu May 24 11:38:25 2018 +0800

    mmc: sd: Define name for default speed dtr
    
    Add a new define for the sd default speed 25MHz case
    
    Signed-off-by: Yinbo Zhu <yinbo.zhu@nxp.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 5ebc47855721..de7377815b6b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -156,6 +156,7 @@ struct sd_switch_caps {
 #define UHS_DDR50_MAX_DTR	50000000
 #define UHS_SDR25_MAX_DTR	UHS_DDR50_MAX_DTR
 #define UHS_SDR12_MAX_DTR	25000000
+#define DEFAULT_SPEED_MAX_DTR	UHS_SDR12_MAX_DTR
 	unsigned int		sd3_bus_mode;
 #define UHS_SDR12_BUS_SPEED	0
 #define HIGH_SPEED_BUS_SPEED	1

commit ebc5a1bf4f2afc2f2b348320dcfb45a8c0ac3de5
Author: harish_kandiga@mentor.com <harish_kandiga@mentor.com>
Date:   Tue Apr 10 12:30:31 2018 +0530

    mmc: core: Add a new quirk for limiting clock rate
    
    This patch adds a quirk to limit clock rate which
    can be used to reduce the SDIO clock rate for some
    chips with broken UHS.
    
    Signed-off-by: Harish Jenny K N <harish_kandiga@mentor.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 279b39008a33..5ebc47855721 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -252,6 +252,7 @@ struct mmc_card {
 #define MMC_TYPE_SD_COMBO	3		/* SD combo (IO+mem) card */
 	unsigned int		state;		/* (our) card state */
 	unsigned int		quirks; 	/* card quirks */
+	unsigned int		quirk_max_rate;	/* max rate set by quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
 						/* for byte mode */

commit 4406ae215b5a1dd59d941c1323b9f40d241357ac
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Aug 2 11:12:42 2017 +0800

    mmc: core: correct taac parameter according to the specification
    
    Per the spec of JESD84-B51, section 7.3, replace tacc with taac to
    fix the obvious typo.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 46c73e97e61f..279b39008a33 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -29,8 +29,8 @@ struct mmc_csd {
 	unsigned char		structure;
 	unsigned char		mmca_vsn;
 	unsigned short		cmdclass;
-	unsigned short		tacc_clks;
-	unsigned int		tacc_ns;
+	unsigned short		taac_clks;
+	unsigned int		taac_ns;
 	unsigned int		c_size;
 	unsigned int		r2w_factor;
 	unsigned int		max_dtr;

commit 304419d8a7e9204c5d19b704467b814df8c8f5b1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 18 11:29:32 2017 +0200

    mmc: core: Allocate per-request data using the block layer core
    
    The mmc_queue_req is a per-request state container the MMC core uses
    to carry bounce buffers, pointers to asynchronous requests and so on.
    Currently allocated as a static array of objects, then as a request
    comes in, a mmc_queue_req is assigned to it, and used during the
    lifetime of the request.
    
    This is backwards compared to how other block layer drivers work:
    they usally let the block core provide a per-request struct that get
    allocated right beind the struct request, and which can be obtained
    using the blk_mq_rq_to_pdu() helper. (The _mq_ infix in this function
    name is misleading: it is used by both the old and the MQ block
    layer.)
    
    The per-request struct gets allocated to the size stored in the queue
    variable .cmd_size initialized using the .init_rq_fn() and
    cleaned up using .exit_rq_fn().
    
    The block layer code makes the MMC core rely on this mechanism to
    allocate the per-request mmc_queue_req state container.
    
    Doing this make a lot of complicated queue handling go away. We only
    need to keep the .qnct that keeps count of how many request are
    currently being processed by the MMC layer. The MQ block layer will
    replace also this once we transition to it.
    
    Doing this refactoring is necessary to move the ioctl() operations
    into custom block layer requests tagged with REQ_OP_DRV_[IN|OUT]
    instead of the custom code using the BigMMCHostLock that we have
    today: those require that per-request data be obtainable easily from
    a request after creating a custom request with e.g.:
    
    struct request *rq = blk_get_request(q, REQ_OP_DRV_IN, __GFP_RECLAIM);
    struct mmc_queue_req *mq_rq = req_to_mq_rq(rq);
    
    And this is not possible with the current construction, as the request
    is not immediately assigned the per-request state container, but
    instead it gets assigned when the request finally enters the MMC
    queue, which is way too late for custom requests.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [Ulf: Folded in the fix to drop a call to blk_cleanup_queue()]
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Heiner Kallweit <hkallweit1@gmail.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aad015e0152b..46c73e97e61f 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -305,9 +305,7 @@ struct mmc_card {
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
 
-	struct mmc_queue_req	*mqrq;		/* Shared queue structure */
 	unsigned int		bouncesz;	/* Bounce buffer size */
-	int			qdepth;		/* Shared queue depth */
 };
 
 static inline bool mmc_large_sector(struct mmc_card *card)

commit 33e6d74d65c358270f00d228877178964aab84b3
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Apr 24 13:41:55 2017 -0500

    mmc: core: Export API to allow hosts to get the card address
    
    Some hosts controllers, like Cavium, needs to know whether the card
    operates in byte- or block-address mode. Therefore export a new API,
    mmc_card_is_blockaddr(), which provides this information.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Steven J. Hill <Steven.Hill@cavium.com>
    Acked-by: David Daney <david.daney@cavium.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 85b5f2bc8bb9..aad015e0152b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -315,6 +315,8 @@ static inline bool mmc_large_sector(struct mmc_card *card)
 	return card->ext_csd.data_sector_size == 4096;
 }
 
+bool mmc_card_is_blockaddr(struct mmc_card *card);
+
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
 #define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)

commit 9d4579a85c84340044b10ffa6cd576397f59dc93
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:38 2017 +0200

    mmc: mmc_test: Disable Command Queue while mmc_test is used
    
    Normal read and write commands may not be used while the command queue is
    enabled. Disable the Command Queue when mmc_test is probed and re-enable it
    when it is removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Harjani Ritesh <riteshh@codeaurora.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 94637796b99c..85b5f2bc8bb9 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -269,6 +269,8 @@ struct mmc_card {
 #define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
 #define MMC_QUIRK_BROKEN_HPI	(1<<13)		/* Disable broken HPI support */
 
+	bool			reenable_cmdq;	/* Re-enable Command Queue */
+
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
  	unsigned int		pref_erase;	/* in sectors */

commit b658af718465cd1e8011c8da281befdfc2debefd
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:37 2017 +0200

    mmc: mmc: Add functions to enable / disable the Command Queue
    
    Add helper functions to enable or disable the Command Queue.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 119ef8f0155c..94637796b99c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -89,6 +89,7 @@ struct mmc_ext_csd {
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
 	bool			ffu_capable;	/* Firmware upgrade support */
+	bool			cmdq_en;	/* Command Queue enabled */
 	bool			cmdq_support;	/* Command Queue supported */
 	unsigned int		cmdq_depth;	/* Command Queue depth */
 #define MMC_FIRMWARE_LEN 8

commit 7b410d074b253a44624497a18e73f666a9574f37
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Mar 13 14:36:36 2017 +0200

    mmc: queue: Share mmc request array between partitions
    
    eMMC can have multiple internal partitions that are represented as separate
    disks / queues. However switching between partitions is only done when the
    queue is empty. Consequently the array of mmc requests that are queued can
    be shared between partitions saving memory.
    
    Keep a pointer to the mmc request queue on the card, and use that instead
    of allocating a new one for each partition.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 77e61e0a216a..119ef8f0155c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -208,6 +208,7 @@ struct sdio_cis {
 struct mmc_host;
 struct sdio_func;
 struct sdio_func_tuple;
+struct mmc_queue_req;
 
 #define SDIO_MAX_FUNCS		7
 
@@ -300,6 +301,10 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
+
+	struct mmc_queue_req	*mqrq;		/* Shared queue structure */
+	unsigned int		bouncesz;	/* Bounce buffer size */
+	int			qdepth;		/* Shared queue depth */
 };
 
 static inline bool mmc_large_sector(struct mmc_card *card)

commit efff8e7879b8b7f8a077f495262f0bb9cfaa0b06
Author: Uri Yanai <uri.yanai@sandisk.com>
Date:   Tue Feb 7 18:00:01 2017 +0200

    mmc: Adding AUTO_BKOPS_EN bit set for Auto BKOPS support
    
    Adding dedicated flag for AUTO_BKOPS in card->ext_csd structure.
    Read AUTO_BKOPS bit value from the device EXT_CSD and set to the
    card->ext_csd structure.
    In mmc_decode_ext_csd() add a print message in case the AUTO_BKOPS
    is enabled
    
    Signed-off-by: Uri Yanai <uri.yanai@sandisk.com>
    Signed-off-by: Alex Lemberg <alex.lemberg@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 29d00c91c25c..77e61e0a216a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -83,6 +83,7 @@ struct mmc_ext_csd {
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
 	bool			bkops;		/* background support bit */
 	bool			man_bkops_en;	/* manual bkops enable bit */
+	bool			auto_bkops_en;	/* auto bkops enable bit */
 	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */

commit 4facdde11394d44b3869807841042d059f074a07
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:14 2017 +0100

    mmc: core: Move public functions from card.h to private headers
    
    A significant amount of functions and other definitions are available
    through the public mmc card.h header file. Let's slim down this public mmc
    interface, as to prevent users from abusing it, by moving some of the
    functions/definitions to private mmc header files.
    
    This change concentrates on moving the functions into private mmc headers,
    following changes may continue with additional clean-ups.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ca64f5b67983..29d00c91c25c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -248,13 +248,6 @@ struct mmc_card {
 #define MMC_TYPE_SDIO		2		/* SDIO card */
 #define MMC_TYPE_SD_COMBO	3		/* SD combo (IO+mem) card */
 	unsigned int		state;		/* (our) card state */
-#define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
-#define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
-#define MMC_STATE_BLOCKADDR	(1<<2)		/* card uses block-addressing */
-#define MMC_CARD_SDXC		(1<<3)		/* card is SDXC */
-#define MMC_CARD_REMOVED	(1<<4)		/* card has been removed */
-#define MMC_STATE_DOING_BKOPS	(1<<5)		/* card is doing BKOPS */
-#define MMC_STATE_SUSPENDED	(1<<6)		/* card is suspended */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -273,7 +266,6 @@ struct mmc_card {
 #define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
 #define MMC_QUIRK_BROKEN_HPI	(1<<13)		/* Disable broken HPI support */
 
-
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
  	unsigned int		pref_erase;	/* in sectors */
@@ -309,245 +301,13 @@ struct mmc_card {
 	unsigned int    nr_parts;
 };
 
-/*
- * This function fill contents in mmc_part.
- */
-static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
-			unsigned int part_cfg, char *name, int idx, bool ro,
-			int area_type)
-{
-	card->part[card->nr_parts].size = size;
-	card->part[card->nr_parts].part_cfg = part_cfg;
-	sprintf(card->part[card->nr_parts].name, name, idx);
-	card->part[card->nr_parts].force_ro = ro;
-	card->part[card->nr_parts].area_type = area_type;
-	card->nr_parts++;
-}
-
 static inline bool mmc_large_sector(struct mmc_card *card)
 {
 	return card->ext_csd.data_sector_size == 4096;
 }
 
-/*
- *  The world is not perfect and supplies us with broken mmc/sdio devices.
- *  For at least some of these bugs we need a work-around.
- */
-
-struct mmc_fixup {
-	/* CID-specific fields. */
-	const char *name;
-
-	/* Valid revision range */
-	u64 rev_start, rev_end;
-
-	unsigned int manfid;
-	unsigned short oemid;
-
-	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
-	u16 cis_vendor, cis_device;
-
-	/* for MMC cards */
-	unsigned int ext_csd_rev;
-
-	void (*vendor_fixup)(struct mmc_card *card, int data);
-	int data;
-};
-
-#define CID_MANFID_ANY (-1u)
-#define CID_OEMID_ANY ((unsigned short) -1)
-#define CID_NAME_ANY (NULL)
-
-#define EXT_CSD_REV_ANY (-1u)
-
-#define CID_MANFID_SANDISK      0x2
-#define CID_MANFID_TOSHIBA      0x11
-#define CID_MANFID_MICRON       0x13
-#define CID_MANFID_SAMSUNG      0x15
-#define CID_MANFID_KINGSTON     0x70
-#define CID_MANFID_HYNIX	0x90
-
-#define END_FIXUP { NULL }
-
-#define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
-		   _cis_vendor, _cis_device,				\
-		   _fixup, _data, _ext_csd_rev)				\
-	{						   \
-		.name = (_name),			   \
-		.manfid = (_manfid),			   \
-		.oemid = (_oemid),			   \
-		.rev_start = (_rev_start),		   \
-		.rev_end = (_rev_end),			   \
-		.cis_vendor = (_cis_vendor),		   \
-		.cis_device = (_cis_device),		   \
-		.vendor_fixup = (_fixup),		   \
-		.data = (_data),			   \
-		.ext_csd_rev = (_ext_csd_rev),		   \
-	 }
-
-#define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
-		      _fixup, _data, _ext_csd_rev)			\
-	_FIXUP_EXT(_name, _manfid,					\
-		   _oemid, _rev_start, _rev_end,			\
-		   SDIO_ANY_ID, SDIO_ANY_ID,				\
-		   _fixup, _data, _ext_csd_rev)				\
-
-#define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
-	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
-		      EXT_CSD_REV_ANY)
-
-#define MMC_FIXUP_EXT_CSD_REV(_name, _manfid, _oemid, _fixup, _data,	\
-			      _ext_csd_rev)				\
-	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
-		      _ext_csd_rev)
-
-#define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
-	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
-		    CID_OEMID_ANY, 0, -1ull,				\
-		   _vendor, _device,					\
-		   _fixup, _data, EXT_CSD_REV_ANY)			\
-
-#define cid_rev(hwrev, fwrev, year, month)	\
-	(((u64) hwrev) << 40 |                  \
-	 ((u64) fwrev) << 32 |                  \
-	 ((u64) year) << 16 |                   \
-	 ((u64) month))
-
-#define cid_rev_card(card)		  \
-	cid_rev(card->cid.hwrev,	  \
-		    card->cid.fwrev,      \
-		    card->cid.year,	  \
-		    card->cid.month)
-
-/*
- * Unconditionally quirk add/remove.
- */
-
-static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
-{
-	card->quirks |= data;
-}
-
-static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
-{
-	card->quirks &= ~data;
-}
-
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
 #define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)
 
-#define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
-#define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
-#define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
-#define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
-#define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
-#define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
-#define mmc_card_suspended(c)	((c)->state & MMC_STATE_SUSPENDED)
-
-#define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
-#define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
-#define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
-#define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
-#define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
-#define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
-#define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
-#define mmc_card_set_suspended(c) ((c)->state |= MMC_STATE_SUSPENDED)
-#define mmc_card_clr_suspended(c) ((c)->state &= ~MMC_STATE_SUSPENDED)
-
-/*
- * Quirk add/remove for MMC products.
- */
-
-static inline void __maybe_unused add_quirk_mmc(struct mmc_card *card, int data)
-{
-	if (mmc_card_mmc(card))
-		card->quirks |= data;
-}
-
-static inline void __maybe_unused remove_quirk_mmc(struct mmc_card *card,
-						   int data)
-{
-	if (mmc_card_mmc(card))
-		card->quirks &= ~data;
-}
-
-/*
- * Quirk add/remove for SD products.
- */
-
-static inline void __maybe_unused add_quirk_sd(struct mmc_card *card, int data)
-{
-	if (mmc_card_sd(card))
-		card->quirks |= data;
-}
-
-static inline void __maybe_unused remove_quirk_sd(struct mmc_card *card,
-						   int data)
-{
-	if (mmc_card_sd(card))
-		card->quirks &= ~data;
-}
-
-static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_LENIENT_FN0;
-}
-
-static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
-}
-
-static inline int mmc_card_disable_cd(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_DISABLE_CD;
-}
-
-static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;
-}
-
-static inline int mmc_card_broken_byte_mode_512(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
-}
-
-static inline int mmc_card_long_read_time(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
-}
-
-static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
-}
-
-static inline int mmc_card_broken_hpi(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_BROKEN_HPI;
-}
-
-#define mmc_card_name(c)	((c)->cid.prod_name)
-#define mmc_card_id(c)		(dev_name(&(c)->dev))
-
-#define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)
-
-/*
- * MMC device driver (e.g., Flash card, I/O card...)
- */
-struct mmc_driver {
-	struct device_driver drv;
-	int (*probe)(struct mmc_card *);
-	void (*remove)(struct mmc_card *);
-	void (*shutdown)(struct mmc_card *);
-};
-
-extern int mmc_register_driver(struct mmc_driver *);
-extern void mmc_unregister_driver(struct mmc_driver *);
-
-extern void mmc_fixup_device(struct mmc_card *card,
-			     const struct mmc_fixup *table);
-
 #endif /* LINUX_MMC_CARD_H */

commit 8da007348bf52a91e5137d27d7dcd528edbb80ce
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 13 14:14:06 2017 +0100

    mmc: core: First step in cleaning up public mmc header files
    
    This is the first step in cleaning up the public mmc header files. In this
    change we makes sure each header file builds standalone, as that helps to
    resolve dependencies.
    
    While changing this, it also seems reasonable to stop including other
    headers from inside a header itself which it don't depend upon.
    Additionally, in some cases such dependencies are better resolved by
    forward declaring the needed struct.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 00449e51838a..ca64f5b67983 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -11,7 +11,6 @@
 #define LINUX_MMC_CARD_H
 
 #include <linux/device.h>
-#include <linux/mmc/core.h>
 #include <linux/mod_devicetable.h>
 
 struct mmc_cid {
@@ -206,7 +205,6 @@ struct sdio_cis {
 };
 
 struct mmc_host;
-struct mmc_ios;
 struct sdio_func;
 struct sdio_func_tuple;
 

commit 46bc5c408e4e325efbfff26609c76099979180a7
Author: Jungseung Lee <js07.lee@samsung.com>
Date:   Thu Dec 22 12:37:34 2016 +0900

    mmc: core: Export device lifetime information through sysfs
    
    In the eMMC 5.0 version of the spec, several EXT_CSD fields about
    device lifetime are added.
    
     - Two types of estimated indications reflected by averaged wear out of memory
     - An indication reflected by average reserved blocks
    
    Export the information through sysfs.
    
    Signed-off-by: Jungseung Lee <js07.lee@samsung.com>
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 95d69d498296..00449e51838a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -121,6 +121,9 @@ struct mmc_ext_csd {
 	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
 	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
+	u8			pre_eol_info;		/* 267 */
+	u8			device_life_time_est_typ_a;	/* 268 */
+	u8			device_life_time_est_typ_b;	/* 269 */
 
 	unsigned int            feature_support;
 #define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */

commit 925ff3a7a334b3fe968ae15f07d22df21addad26
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Nov 29 12:09:16 2016 +0200

    mmc: mmc: Add Command Queue definitions
    
    Add definitions relating to Command Queuing.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e49a3ff9d0e0..95d69d498296 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -89,6 +89,8 @@ struct mmc_ext_csd {
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
 	bool			ffu_capable;	/* Firmware upgrade support */
+	bool			cmdq_support;	/* Command Queue supported */
+	unsigned int		cmdq_depth;	/* Command Queue depth */
 #define MMC_FIRMWARE_LEN 8
 	u8			fwrev[MMC_FIRMWARE_LEN];  /* FW version */
 	u8			raw_exception_status;	/* 54 */

commit 8e8b3f514c12a3b800bba8a7766c71139ad75b89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 4 11:05:19 2016 +0100

    mmc: core: use enum mmc_blk_status properly
    
    There were several instances of code using the
    enum mmc_blk_status by arbitrarily converting it to an int and
    throwing it around to different functions. This makes the code
    hard to understand to may give rise to strange errors.
    
    Especially the function prototype mmc_start_req() had to be
    modified to take a pointer to an enum mmc_blk_status and the
    function pointer .err_check() inside struct mmc_async_req
    needed to return an enum mmc_blk_status.
    
    In every case: instead of assigning the block layer error code
    to an int, use the enum, also change the signature of all
    functions actually passing this enum to use the enum.
    
    To make it possible to use the enum everywhere applicable, move
    it to <linux/mmc/core.h> so that all code actually using it can
    also see it.
    
    An interesting case was encountered in the MMC test code which
    did not return a enum mmc_blk_status at all in the .err_check
    function supposed to check whether asynchronous requests worked
    or not: instead it returned a normal -ERROR or even the test
    frameworks internal error codes.
    
    The test code would also pass on enum mmc_blk_status codes as
    error codes inside the test code instead of converting them
    to the local RESULT_* codes.
    
    I have tried to fix all instances properly and run some tests
    on the result.
    
    Cc: Chunyan Zhang <zhang.chunyan@linaro.org>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 73fad83acbcb..e49a3ff9d0e0 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -207,18 +207,6 @@ struct sdio_func_tuple;
 
 #define SDIO_MAX_FUNCS		7
 
-enum mmc_blk_status {
-	MMC_BLK_SUCCESS = 0,
-	MMC_BLK_PARTIAL,
-	MMC_BLK_CMD_ERR,
-	MMC_BLK_RETRY,
-	MMC_BLK_ABORT,
-	MMC_BLK_DATA_ERR,
-	MMC_BLK_ECC_ERR,
-	MMC_BLK_NOMEDIUM,
-	MMC_BLK_NEW_REQUEST,
-};
-
 /* The number of MMC physical partitions.  These consist of:
  * boot partitions (2), general purpose partitions (4) and
  * RPMB partition (1) in MMC v4.4.

commit 5275a652d296711aaf7f2f4173c8db153e5777c3
Author: Uri Yanai <uri.yanai@sandisk.com>
Date:   Sun Aug 14 11:46:36 2016 +0300

    mmc: sd: Export SD Status via “ssr” device attribute
    
    The SD Status register contains several important fields related to the
    SD Card proprietary features.
    Those fields may be used by user space applications for vendor specific
    usage.
    None of those fields are exported today by the driver to user space.
    In this patch, we are reading the SD Status register and exporting
    (using MMC_DEV_ATTR) the SD Status register to the user space.
    
    Signed-off-by: Uri Yanai <uri.yanai@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d8673ca968ba..73fad83acbcb 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -292,6 +292,7 @@ struct mmc_card {
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
+	u32			raw_ssr[16];	/* raw card SSR */
 	struct mmc_cid		cid;		/* card identification */
 	struct mmc_csd		csd;		/* card specific */
 	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */

commit 5320226a051248b50cc2d80f2cb9599dfb56d422
Author: Pratibhasagar V <pratibha@codeaurora.org>
Date:   Thu Jun 9 18:09:31 2016 -0400

    mmc: core: Disable HPI for certain Hynix eMMC cards
    
    Certain Hynix eMMC 4.41 cards might get broken when HPI feature is used
    and hence this patch disables the HPI feature for such buggy cards.
    
    As some of the other features like BKOPs/Cache/Sanitize are dependent on
    HPI feature, those features would also get disabled if HPI is disabled.
    
    Signed-off-by: Pratibhasagar V <pratibha@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    [gdavis: Forward port and cleanup]
    Signed-off-by: George G. Davis <george_davis@mentor.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 22defc2a83b7..d8673ca968ba 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -280,6 +280,7 @@ struct mmc_card {
 #define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
 #define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
 #define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
+#define MMC_QUIRK_BROKEN_HPI	(1<<13)		/* Disable broken HPI support */
 
 
 	unsigned int		erase_size;	/* erase size in sectors */
@@ -354,6 +355,9 @@ struct mmc_fixup {
 	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
 	u16 cis_vendor, cis_device;
 
+	/* for MMC cards */
+	unsigned int ext_csd_rev;
+
 	void (*vendor_fixup)(struct mmc_card *card, int data);
 	int data;
 };
@@ -362,11 +366,20 @@ struct mmc_fixup {
 #define CID_OEMID_ANY ((unsigned short) -1)
 #define CID_NAME_ANY (NULL)
 
+#define EXT_CSD_REV_ANY (-1u)
+
+#define CID_MANFID_SANDISK      0x2
+#define CID_MANFID_TOSHIBA      0x11
+#define CID_MANFID_MICRON       0x13
+#define CID_MANFID_SAMSUNG      0x15
+#define CID_MANFID_KINGSTON     0x70
+#define CID_MANFID_HYNIX	0x90
+
 #define END_FIXUP { NULL }
 
 #define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
 		   _cis_vendor, _cis_device,				\
-		   _fixup, _data)					\
+		   _fixup, _data, _ext_csd_rev)				\
 	{						   \
 		.name = (_name),			   \
 		.manfid = (_manfid),			   \
@@ -377,23 +390,30 @@ struct mmc_fixup {
 		.cis_device = (_cis_device),		   \
 		.vendor_fixup = (_fixup),		   \
 		.data = (_data),			   \
+		.ext_csd_rev = (_ext_csd_rev),		   \
 	 }
 
 #define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
-		      _fixup, _data)					\
+		      _fixup, _data, _ext_csd_rev)			\
 	_FIXUP_EXT(_name, _manfid,					\
 		   _oemid, _rev_start, _rev_end,			\
 		   SDIO_ANY_ID, SDIO_ANY_ID,				\
-		   _fixup, _data)					\
+		   _fixup, _data, _ext_csd_rev)				\
 
 #define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
-	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data)
+	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
+		      EXT_CSD_REV_ANY)
+
+#define MMC_FIXUP_EXT_CSD_REV(_name, _manfid, _oemid, _fixup, _data,	\
+			      _ext_csd_rev)				\
+	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data,	\
+		      _ext_csd_rev)
 
 #define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
 	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
 		    CID_OEMID_ANY, 0, -1ull,				\
 		   _vendor, _device,					\
-		   _fixup, _data)					\
+		   _fixup, _data, EXT_CSD_REV_ANY)			\
 
 #define cid_rev(hwrev, fwrev, year, month)	\
 	(((u64) hwrev) << 40 |                  \
@@ -512,6 +532,11 @@ static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
 }
 
+static inline int mmc_card_broken_hpi(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BROKEN_HPI;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit 81ac2af65793ecfbd79875d45043ff4adc0982b8
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu May 26 09:56:22 2016 +0800

    mmc: core: implement enhanced strobe support
    
    Controllers use data strobe line to latch data from devices
    under hs400 mode, but not for cmd line. So since emmc 5.1, JEDEC
    introduces enhanced strobe mode for latching cmd response from
    emmc devices to host controllers. This new feature is optional,
    so it depends both on device's cap and host's cap to decide
    whether to use it or not.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    
    Reviewed-by: Jaehoon Chung <jh80.chung@samsung.com>
    Tested-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index eb0151bac50c..22defc2a83b7 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -95,6 +95,7 @@ struct mmc_ext_csd {
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_rpmb_size_mult;	/* 168 */
 	u8			raw_erased_mem_count;	/* 181 */
+	u8			strobe_support;		/* 184 */
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
 	u8			raw_driver_strength;	/* 197 */

commit 9eadcc0581a8ccaf4c2378aa1c193fb164304f1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 2 10:56:11 2015 +0200

    mmc: core: Remove MMC_CLKGATE
    
    MMC_CLKGATE was once invented to save power by gating the bus clock at
    request inactivity. At that time it served its purpose. The modern way to
    deal with power saving for these scenarios, is by using runtime PM.
    
    Nowadays, several host drivers have deployed runtime PM, but for those
    that haven't and which still cares power saving at request inactivity,
    it's certainly time to deploy runtime PM as it has been around for several
    years now.
    
    To simplify code to mmc core and thus decrease maintenance efforts, this
    patch removes all code related to MMC_CLKGATE.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index fdd0779ccdfa..eb0151bac50c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -269,7 +269,6 @@ struct mmc_card {
 						/* for byte mode */
 #define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
 						/* (missing CIA registers) */
-#define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
 #define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
 #define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */

commit b5b4ff0a633910b2b9dca7915fd6ab17aa10dc3e
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Wed Aug 12 13:08:32 2015 +0800

    mmc: block: skip trim for some kingston eMMCs
    
    For some mass production of kingston eMMCs which adopt Phison's
    firmware will meet an unrecoverable data conrruption occasionally
    if performing trim due to a firmware bug confirmed by vendor. We
    found it on Intel-C3230RK platform. So we add fixup of broken trim
    for it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 8fcbcd13218f..fdd0779ccdfa 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -279,6 +279,8 @@ struct mmc_card {
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
 #define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
 #define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
+#define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
+
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */

commit 642c28ab86f7666d2ac62a0dc391b4c3121f1d6e
Author: David Jander <david@protonic.nl>
Date:   Tue Jun 23 11:43:52 2015 +0200

    mmc: core: Optimize case for exactly one erase-group budget
    
    In the (not so unlikely) case that the mmc controller timeout budget is
    enough for exactly one erase-group, the simplification of allowing one
    sector has an enormous performance penalty. We optimize this special case
    by introducing a flag that prohibits erase-group boundary crossing, so
    that we can allow trimming more than one sector at a time.
    
    Signed-off-by: David Jander <david@protonic.nl>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4d3776d25925..8fcbcd13218f 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -283,6 +283,7 @@ struct mmc_card {
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
  	unsigned int		pref_erase;	/* in sectors */
+	unsigned int		eg_boundary;	/* don't cross erase-group boundaries */
  	u8			erased_byte;	/* value of erased bytes */
 
 	u32			raw_cid[4];	/* raw card CID */

commit b097e07f57930eda774c83aa46e8e401686d01dc
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:57 2015 +0200

    mmc: mmc: Read card's valid driver strength mask
    
    In preparation for supporing drive strength selection
    for eMMC, read the card's valid driver strengths.
    
    Note that though the SD spec uses the term "drive strength",
    the JEDEC eMMC spec uses the term "driver strength".
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 2f073d555793..4d3776d25925 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -97,6 +97,7 @@ struct mmc_ext_csd {
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
+	u8			raw_driver_strength;	/* 197 */
 	u8			out_of_int_time;	/* 198 */
 	u8			raw_pwr_cl_52_195;	/* 200 */
 	u8			raw_pwr_cl_26_195;	/* 201 */

commit 3853a042325e8f497c199020979c4fc824528c6e
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Fri Feb 6 14:12:56 2015 +0200

    mmc: core: Record card drive strength
    
    In preparation for adding drive strength support
    for eMMC, add drive_strength to struct mmc_card
    to record the card drive strength for UHS-I modes
    and HS200 / HS400. For eMMC this will be needed
    when switching between HS200 and HS400.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 19f0175c0afa..2f073d555793 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -305,6 +305,7 @@ struct mmc_card {
 
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
 	unsigned int		mmc_avail_type;	/* supported device type by both host and card */
+	unsigned int		drive_strength;	/* for UHS-I, HS200 or HS400 */
 
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */

commit 96541bac0b4e62efa42e7900d9b32e6baa9a214c
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 13:06:12 2015 +0200

    Revert "mmc: core: Convert mmc_driver to device_driver"
    
    This reverts commit 6685ac62b2f0 ("mmc: core: Convert mmc_driver to
    device_driver")
    
    The reverted commit went too far in simplifing the device driver parts
    for mmc.
    
    Let's restore the old mmc_driver to enable driver core to sooner
    or later to remove the ->probe(), ->remove() and ->shutdown() callbacks
    from the struct device_driver.
    
    Note that, the old ->suspend|resume() callbacks in the struct
    mmc_driver don't need to be restored, since the mmc block layer has
    converted to the modern system PM ops.
    
    Fixes: 6685ac62b2f0 ("mmc: core: Convert mmc_driver to device_driver")
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index a6cf4c063e4e..19f0175c0afa 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -512,8 +512,18 @@ static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 
 #define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)
 
-extern int mmc_register_driver(struct device_driver *);
-extern void mmc_unregister_driver(struct device_driver *);
+/*
+ * MMC device driver (e.g., Flash card, I/O card...)
+ */
+struct mmc_driver {
+	struct device_driver drv;
+	int (*probe)(struct mmc_card *);
+	void (*remove)(struct mmc_card *);
+	void (*shutdown)(struct mmc_card *);
+};
+
+extern int mmc_register_driver(struct mmc_driver *);
+extern void mmc_unregister_driver(struct mmc_driver *);
 
 extern void mmc_fixup_device(struct mmc_card *card,
 			     const struct mmc_fixup *table);

commit 0501be6429e4eb02f417ad83eacd84b8c57b0283
Author: Alexey Skidanov <alexey.skidanov@sandisk.com>
Date:   Thu Jan 29 10:49:43 2015 +0200

    mmc: Resolve BKOPS compatability issue
    
    This patch is coming to fix compatibility issue of BKOPS_EN  field of EXT_CSD.
    In eMMC-5.1, BKOPS_EN was changed, and now it has two operational bits:
    Bit 0 - MANUAL_EN
    Bit 1 - AUTO_EN
    In previous eMMC revisions, only Bit 0 was supported.
    
    Signed-off-by: Alexey Skidanov <alexey.skidanov@sandisk.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4d69c00497bd..a6cf4c063e4e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -83,7 +83,7 @@ struct mmc_ext_csd {
 	bool			hpi;			/* HPI support bit */
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
 	bool			bkops;		/* background support bit */
-	bool			bkops_en;	/* background enable bit */
+	bool			man_bkops_en;	/* manual bkops enable bit */
 	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */

commit 0f762426769a517d5b278e4e5d579fcea6801734
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Thu Oct 16 11:27:16 2014 -0700

    mmc: core: Report firmware version for eMMC 5.0 devices.
    
    For eMMC 5.0 compliant device, firmware version is stored in ext_csd.
    Report firmware as a 64bit hexa decimal. Vendor can use hexa or ascii
    string to report firmware version.
    Also add FFU related EXT_CSD register and note if the device is FFU capable.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0ba8f251f8ef..4d69c00497bd 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -88,6 +88,9 @@ struct mmc_ext_csd {
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
+	bool			ffu_capable;	/* Firmware upgrade support */
+#define MMC_FIRMWARE_LEN 8
+	u8			fwrev[MMC_FIRMWARE_LEN];  /* FW version */
 	u8			raw_exception_status;	/* 54 */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_rpmb_size_mult;	/* 168 */

commit 390e316c606de2f839389698f4531004cfe1bafd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 6 14:39:03 2014 +0200

    mmc: core: Remove unused mmc_list_to_card() macro
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 64f413676410..0ba8f251f8ef 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -509,8 +509,6 @@ static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 
 #define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)
 
-#define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
-
 extern int mmc_register_driver(struct device_driver *);
 extern void mmc_unregister_driver(struct device_driver *);
 

commit fc95e30ba33b9f4faa8630d0762af2548031dc00
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 6 14:34:09 2014 +0200

    mmc: block: Use dev_set|get_drvdata()
    
    In most of the cases mmc_get|set_drvdata() didn't simplify code, which
    should be the primary reason for such macros.
    
    Let's remove them and convert to the common device_driver macros,
    dev_set|get_drvdata() instead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index cf54afe5d863..64f413676410 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -510,8 +510,6 @@ static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 #define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)
 
 #define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
-#define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
-#define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)
 
 extern int mmc_register_driver(struct device_driver *);
 extern void mmc_unregister_driver(struct device_driver *);

commit 6685ac62b2f08fcff77dc35c6b8bff1b74aaa408
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Oct 6 13:51:40 2014 +0200

    mmc: core: Convert mmc_driver to device_driver
    
    The struct mmc_driver adds an extra layer on top of the struct
    device_driver. That would be fine, if there were a good reason, but
    that's not the case.
    
    Let's simplify code by converting to the common struct device_driver
    instead and thus also removing superfluous overhead.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index b0692d28f8e6..cf54afe5d863 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -513,20 +513,8 @@ static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 #define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
 #define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)
 
-/*
- * MMC device driver (e.g., Flash card, I/O card...)
- */
-struct mmc_driver {
-	struct device_driver drv;
-	int (*probe)(struct mmc_card *);
-	void (*remove)(struct mmc_card *);
-	int (*suspend)(struct mmc_card *);
-	int (*resume)(struct mmc_card *);
-	void (*shutdown)(struct mmc_card *);
-};
-
-extern int mmc_register_driver(struct mmc_driver *);
-extern void mmc_unregister_driver(struct mmc_driver *);
+extern int mmc_register_driver(struct device_driver *);
+extern void mmc_unregister_driver(struct device_driver *);
 
 extern void mmc_fixup_device(struct mmc_card *card,
 			     const struct mmc_fixup *table);

commit 69803d4f487fc60ce740f1fe1f0d2092d97277b6
Author: Grégory Soutadé <gsoutade@neotion.com>
Date:   Mon Sep 15 17:47:09 2014 +0200

    mmc: Replace "enhanced_area_en" attribute by "partition_setting_completed"
    
    Replace ext_csd "enhanced_area_en" attribute by
     "partition_setting_completed". It was used whether or
     not enhanced user area is defined and without checks of
     EXT_CSD_PARTITION_SETTING_COMPLETED bit.
    
    Signed-off-by: Grégory Soutadé <gsoutade@neotion.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0ea795f5feb9..b0692d28f8e6 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -75,7 +75,7 @@ struct mmc_ext_csd {
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
 	unsigned int		sec_erase_mult;	/* Secure erase multiplier */
 	unsigned int		trim_timeout;		/* In milliseconds */
-	bool			enhanced_area_en;	/* enable bit */
+	bool			partition_setting_completed;	/* enable bit */
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
 	unsigned int		cache_size;		/* Units: KB */

commit 3d705d14fe4c72be83bae1610680e209ee226b9d
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Aug 19 10:45:51 2014 +0200

    mmc: implement Driver Stage Register handling
    
    Some eMMC and SD cards implement a DSR register that allows to tune
    raise/fall times and drive strength of the CMD and DATA outputs.
    The values to use depend on the card in use and the host.
    It might be needed to reduce the drive strength to prevent voltage peaks
    above the host's specification.
    
    Implement a 'dsr' devicetree property that allows to specify the value
    to set the DSR to. For non-dt setups the new members of mmc_host can be
    set by board code.
    
    This patch was initially authored by Sascha Hauer. It contains
    improvements authored by Markus Niebel and Uwe Kleine-König.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Markus Niebel <Markus.Niebel@tq-group.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index bde5147a4221..0ea795f5feb9 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -42,7 +42,8 @@ struct mmc_csd {
 	unsigned int		read_partial:1,
 				read_misalign:1,
 				write_partial:1,
-				write_misalign:1;
+				write_misalign:1,
+				dsr_imp:1;
 };
 
 struct mmc_ext_csd {

commit b3683994843a0ede0e19daccd1ac32a46b21eb39
Author: Yi Sun <yi.y.sun@intel.com>
Date:   Wed Aug 13 13:34:01 2014 +0800

    mmc: Correct the value of MMC_NUM_PHY_PARTITION
    
    eMMC card can support up to 7 physical partitions, including 2 boot,
    1 RPMB and 4 GPs. Change MMC_NUM_PHY_PARTITION from 6 to 7, which is
    the correct value.
    
    Signed-off-by: Yi Sun <yi.y.sun@intel.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d424b9de3aff..bde5147a4221 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -214,11 +214,12 @@ enum mmc_blk_status {
 };
 
 /* The number of MMC physical partitions.  These consist of:
- * boot partitions (2), general purpose partitions (4) in MMC v4.4.
+ * boot partitions (2), general purpose partitions (4) and
+ * RPMB partition (1) in MMC v4.4.
  */
 #define MMC_NUM_BOOT_PARTITION	2
 #define MMC_NUM_GP_PARTITION	4
-#define MMC_NUM_PHY_PARTITION	6
+#define MMC_NUM_PHY_PARTITION	7
 #define MAX_MMC_PART_NAME_LEN	20
 
 /*

commit 0a5b6438ee482696360bb013e67b8488f63d3e9e
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:14:58 2014 +0900

    mmc: add support for HS400 mode of eMMC5.0
    
    This patch adds HS400 mode support for eMMC5.0 device.  HS400 mode is high
    speed DDR interface timing from HS200.  Clock frequency is up to 200MHz
    and only 8-bit bus width is supported. In addition, tuning process of
    HS200 is required to synchronize the command response on the CMD line
    because CMD input timing for HS400 mode is the same as HS200 mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Jackey Shen <jackey.shen@amd.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 176073692872..d424b9de3aff 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -110,6 +110,7 @@ struct mmc_ext_csd {
 	u8			raw_pwr_cl_200_360;	/* 237 */
 	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
 	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
+	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
 	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
 

commit 577fb13199b11d8cd75609183649be4b5561243f
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:08:44 2014 +0900

    mmc: rework selection of bus speed mode
    
    Current implementation for bus speed mode selection is too
    complicated. This patch is to simplify the codes and remove
    some duplicate parts.
    
    The following changes are including:
    * Adds functions for each mode selection(HS, HS-DDR, HS200 and etc)
    * Rearranged the mode selection sequence with supported device type
    * Adds maximum speed for HS200 mode(hs200_max_dtr)
    * Adds field definition for HS_TIMING of EXT_CSD
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index fe31f8d89a03..176073692872 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -63,6 +63,7 @@ struct mmc_ext_csd {
 	unsigned int            power_off_longtime;     /* Units: ms */
 	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
+	unsigned int		hs200_max_dtr;
 #define MMC_HIGH_26_MAX_DTR	26000000
 #define MMC_HIGH_52_MAX_DTR	52000000
 #define MMC_HIGH_DDR_MAX_DTR	52000000

commit 2415c0ef618b3cd95581c7f633cbab78b29b7ab0
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:58 2014 +0900

    mmc: identify available device type to select
    
    Device types which are supported by both host and device can be
    identified when EXT_CSD is read. There is no need to check host's
    capability anymore.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aadeaf155d0e..fe31f8d89a03 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -68,7 +68,6 @@ struct mmc_ext_csd {
 #define MMC_HIGH_DDR_MAX_DTR	52000000
 #define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
-	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
 	unsigned int		hc_erase_timeout;	/* In milliseconds */
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
@@ -298,6 +297,7 @@ struct mmc_card {
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
+	unsigned int		mmc_avail_type;	/* supported device type by both host and card */
 
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */

commit cdc991790c51c693d0c347a5286af017826a5d01
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 23 17:07:35 2014 +0900

    mmc: drop the speed mode of card's state
    
    Timing mode identifier has same role and can take the place
    of speed mode. This change removes all related speed mode.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aa7e57f60fb2..aadeaf155d0e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -194,6 +194,7 @@ struct sdio_cis {
 };
 
 struct mmc_host;
+struct mmc_ios;
 struct sdio_func;
 struct sdio_func_tuple;
 
@@ -250,15 +251,11 @@ struct mmc_card {
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
-#define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
-#define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
-#define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
-#define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
-#define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
-#define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
-#define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
-#define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
-#define MMC_STATE_SUSPENDED	(1<<11)		/* card is suspended */
+#define MMC_STATE_BLOCKADDR	(1<<2)		/* card uses block-addressing */
+#define MMC_CARD_SDXC		(1<<3)		/* card is SDXC */
+#define MMC_CARD_REMOVED	(1<<4)		/* card has been removed */
+#define MMC_STATE_DOING_BKOPS	(1<<5)		/* card is doing BKOPS */
+#define MMC_STATE_SUSPENDED	(1<<6)		/* card is suspended */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -418,11 +415,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
-#define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
-#define mmc_card_hs200(c)	((c)->state & MMC_STATE_HIGHSPEED_200)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
-#define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
-#define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
@@ -430,11 +423,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
-#define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
-#define mmc_card_set_hs200(c)	((c)->state |= MMC_STATE_HIGHSPEED_200)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
-#define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
-#define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)

commit 297d40560bc8f474adbb43178e3118321fa702ea
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Fri Apr 4 22:42:48 2014 -0300

    mmc: card.h: Use NULL instead of 0 for END_FIXUP
    
    Fix the following sparse warnings:
    
    drivers/mmc/card/block.c:2421:9: warning: Using plain integer as NULL pointer
    
    drivers/mmc/core/quirks.c:69:9: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index b73027298b3a..aa7e57f60fb2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -353,7 +353,7 @@ struct mmc_fixup {
 #define CID_OEMID_ANY ((unsigned short) -1)
 #define CID_NAME_ANY (NULL)
 
-#define END_FIXUP { 0 }
+#define END_FIXUP { NULL }
 
 #define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
 		   _cis_vendor, _cis_device,				\

commit e5624054c1726a16c13a89c08b2792aba3df06eb
Author: Bing Zhao <bzhao@marvell.com>
Date:   Tue Nov 26 15:39:20 2013 -0800

    mmc: sdio: add a quirk for broken SDIO_CCCR_INTx polling
    
    Polling SDIO_CCCR_INTx could create a fake interrupt with Marvell
    SD8797 card. Add a quirk to handle this case. The fixup here is
    to issue a dummy CMD52 read to function 0 register 0xff, and this
    dummy read must be right after SDIO_CCCR_INTx is read.
    
    Patch has been verified on a dw_mmc controller (Samsung Chromebook)
    with MMC_CAP_SDIO_IRQ disabled.
    
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    Reviewed-by: Paul Stewart <pstew@chromium.org>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 176fdf824b14..b73027298b3a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -271,9 +271,10 @@ struct mmc_card {
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
+						/* byte mode */
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
 #define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
-						/* byte mode */
+#define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -505,6 +506,11 @@ static inline int mmc_card_long_read_time(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
 }
 
+static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit 9ec775f7efd6d17084b4f361804d2030d50fca0e
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 2 17:37:09 2013 +0200

    mmc: Don't force card to active state when entering suspend/shutdown
    
    By adding a card state that records if it is suspended or resumed, we
    can accept asyncronus suspend/resume requests for the mmc and sd
    bus_ops.
    
    MMC_CAP_AGGRESSIVE_PM, will at request inactivity through the runtime
    bus_ops callbacks, execute a suspend of the the card. In the state were
    this has been done, we can receive a suspend request for the mmc bus,
    which for sd and mmc forced the card to active state by a
    pm_runtime_get_sync. In other words, the card was resumed and then
    immediately suspended again, completely unnecessary.
    
    Since the suspend/resume bus_ops callbacks for sd and mmc are now
    capable of handling asynchronous requests, we no longer need to force
    the card to active state before executing suspend. Evidently preventing
    the above sequence for MMC_CAP_AGGRESSIVE_PM.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 33d9a74f92e6..176fdf824b14 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -258,6 +258,7 @@ struct mmc_card {
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
 #define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
+#define MMC_STATE_SUSPENDED	(1<<11)		/* card is suspended */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -424,6 +425,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
+#define mmc_card_suspended(c)	((c)->state & MMC_STATE_SUSPENDED)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -436,6 +438,8 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
 #define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
+#define mmc_card_set_suspended(c) ((c)->state |= MMC_STATE_SUSPENDED)
+#define mmc_card_clr_suspended(c) ((c)->state &= ~MMC_STATE_SUSPENDED)
 
 /*
  * Quirk add/remove for MMC products.

commit 6904115095ad60ced638eb1e36e0e4e5e7de00b0
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 13 11:31:33 2013 +0200

    mmc: core: Move cached value of the negotiated ocr mask to card struct
    
    The negotiated ocr mask is directly related to the card. Once a card
    gets removed, the mask shall be dropped. By moving the cache of the ocr
    mask from the host struct to the card struct we have accomplished this.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index f42cdbd8ac21..33d9a74f92e6 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -240,6 +240,7 @@ struct mmc_part {
 struct mmc_card {
 	struct mmc_host		*host;		/* the host this device belongs to */
 	struct device		dev;		/* the device */
+	u32			ocr;		/* the current OCR setting */
 	unsigned int		rca;		/* relative card address of device */
 	unsigned int		type;		/* card type */
 #define MMC_TYPE_MMC		0		/* MMC card */

commit 71ef1ea418ee45a4f939d53a02410627b394c336
Author: Jackey Shen <jackey.shen@amd.com>
Date:   Fri May 17 17:17:43 2013 +0800

    mmc: core: clean up duplicate macros
    
    Clean up the duplicate macros:
    mmc_sd_card_uhs -> mmc_card_uhs
    mmc_sd_card_set_uhs -> mmc_card_set_uhs
    
    Signed-off-by: Jackey Shen <jackey.shen@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 842de3e21e70..f42cdbd8ac21 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -420,7 +420,6 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 #define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
 #define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
-#define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
@@ -432,7 +431,6 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 #define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
 #define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
-#define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)

commit 7628774851751e55362ec7d9d57c9334e656a655
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Jun 10 17:03:40 2013 +0200

    mmc: core: Handle card shutdown from mmc_bus
    
    Considering shutdown of the card, the responsibility to initate this
    sequence shall be driven from the mmc_bus.
    
    This patch enables the mmc_bus to handle this sequence properly. A new
    .shutdown callback is added in the mmc_driver struct which is used to
    shutdown the blk device.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6a98f32670b8..842de3e21e70 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -520,6 +520,7 @@ struct mmc_driver {
 	void (*remove)(struct mmc_card *);
 	int (*suspend)(struct mmc_card *);
 	int (*resume)(struct mmc_card *);
+	void (*shutdown)(struct mmc_card *);
 };
 
 extern int mmc_register_driver(struct mmc_driver *);

commit 60443712195bbcbbff9af189bdd9d2c1ef0a5cae
Author: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
Date:   Tue Apr 23 16:27:07 2013 +0200

    mmc: core: Fix select power class after resume
    
    Use the saved values in card->ext_csd when selecting power class.
    By doing this the power class will be selected even if mmc_init_card
    is called with oldcard != NULL, which is the case after a suspend/resume.
    
    Today ext_csd is NULL if mmc_init_card is called with oldcard != NULL
    and power class will not be selected.
    
    According to the eMMC specification the POWER_CLASS value is reset after
    power failure, H/W reset assertion and any CMD0 reset.
    
    Signed-off-by: Fredrik Soderstedt <fredrik.soderstedt@stericsson.com>
    Reviewed-by: Johan Rudholm <jrudholm@gmail.com>
    Acked By: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index f31725ba49f3..6a98f32670b8 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -94,7 +94,11 @@ struct mmc_ext_csd {
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
 	u8			out_of_int_time;	/* 198 */
-	u8			raw_s_a_timeout;		/* 217 */
+	u8			raw_pwr_cl_52_195;	/* 200 */
+	u8			raw_pwr_cl_26_195;	/* 201 */
+	u8			raw_pwr_cl_52_360;	/* 202 */
+	u8			raw_pwr_cl_26_360;	/* 203 */
+	u8			raw_s_a_timeout;	/* 217 */
 	u8			raw_hc_erase_gap_size;	/* 221 */
 	u8			raw_erase_timeout_mult;	/* 223 */
 	u8			raw_hc_erase_grp_size;	/* 224 */
@@ -102,6 +106,10 @@ struct mmc_ext_csd {
 	u8			raw_sec_erase_mult;	/* 230 */
 	u8			raw_sec_feature_support;/* 231 */
 	u8			raw_trim_mult;		/* 232 */
+	u8			raw_pwr_cl_200_195;	/* 236 */
+	u8			raw_pwr_cl_200_360;	/* 237 */
+	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
+	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
 	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
 

commit 51e7e8b632d8e564ba494dfa61358ac1a97e4ceb
Author: Bernie Thompson <bhthompson@chromium.org>
Date:   Wed Feb 27 12:19:17 2013 -0800

    mmc: core: Add in support to expose PRV for v4 MMCs
    
    The JEDEC MMC v4 spec defines a new PRV value in place of the original
    fwrev and hwrev specified in v1. We can expose this in the kernel to enable
    user space to more easily determine the product revision of a given MMC.
    
    Signed-off-by: Bernie Thompson <bhthompson@chromium.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 61b2c30c903b..f31725ba49f3 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -17,6 +17,7 @@
 struct mmc_cid {
 	unsigned int		manfid;
 	char			prod_name[8];
+	unsigned char		prv;
 	unsigned int		serial;
 	unsigned short		oemid;
 	unsigned short		year;

commit ce39f9d17c14e56ea6772aa84393e6e0cc8499c4
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Feb 6 17:02:46 2013 +0900

    mmc: support packed write command for eMMC4.5 devices
    
    This patch supports packed write command of eMMC4.5 devices.  Several
    writes can be grouped in packed command and all data of the individual
    commands can be sent in a single transfer on the bus. Large amounts of
    data in one transfer rather than several data of small size are
    effective for eMMC write internally.  As a result, packed command help
    write throughput be improved.  The following tables show the results
    of packed write.
    
    Type A:
    test     none |  packed
    iozone   25.8 |  31
    tiotest  27.6 |  31.2
    lmdd     31.2 |  35.4
    
    Type B:
    test     none |  packed
    iozone   44.1 |  51.1
    tiotest  47.9 |  52.5
    lmdd     51.6 |  59.2
    
    Type C:
    test     none |  packed
    iozone   19.5 |  32
    tiotest  19.9 |  34.5
    lmdd     22.8 |  40.7
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 237f253f2fe0..61b2c30c903b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -310,6 +310,11 @@ static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
 	card->nr_parts++;
 }
 
+static inline bool mmc_large_sector(struct mmc_card *card)
+{
+	return card->ext_csd.data_sector_size == 4096;
+}
+
 /*
  *  The world is not perfect and supplies us with broken mmc/sdio devices.
  *  For at least some of these bugs we need a work-around.

commit abd9ac144947d9a604beb763339e2f77ce8bec79
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Feb 6 17:01:43 2013 +0900

    mmc: add packed command feature of eMMC4.5
    
    This patch adds packed command feature of eMMC4.5.  The maximum number
    for packing read (or write) is offered and exception event relevant to
    packed command which is used for error handling is enabled. If host
    wants to use this feature, MMC_CAP2_PACKED_CMD should be set.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7069dcea27c5..237f253f2fe0 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -53,6 +53,9 @@ struct mmc_ext_csd {
 	u8			part_config;
 	u8			cache_ctrl;
 	u8			rst_n_function;
+	u8			max_packed_writes;
+	u8			max_packed_reads;
+	u8			packed_event_en;
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		generic_cmd6_time;	/* Units: 10ms */

commit c148e9ff4bd45f26d3f0253c20efc497672c3c84
Author: Zhang, YiX X <yix.x.zhang@intel.com>
Date:   Tue Jan 8 06:07:39 2013 +0000

    mmc: correct the EXCEPTION_EVENTS_STATUS value in comment
    
    The right value is 54 according to eMMC 4.5 specification.
    
    Signed-off-by: ZhangYi <yix.x.zhang@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index be2500a49925..7069dcea27c5 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -83,7 +83,7 @@ struct mmc_ext_csd {
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
-	u8			raw_exception_status;	/* 53 */
+	u8			raw_exception_status;	/* 54 */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_rpmb_size_mult;	/* 168 */
 	u8			raw_erased_mem_count;	/* 181 */

commit 2220eedfd7aea69008173a224975e10284fbe854
Author: Konstantin Dorfman <kdorfman@codeaurora.org>
Date:   Mon Jan 14 14:28:17 2013 -0500

    mmc: fix async request mechanism for sequential read scenarios
    
    When current request is running on the bus and if next request fetched
    by mmcqd is NULL, mmc context (mmcqd thread) gets blocked until the
    current request completes. This means that if new request comes in while
    the mmcqd thread is blocked, this new request can not be prepared in
    parallel to current ongoing request. This may result in delaying the new
    request execution and increase it's latency.
    
    This change allows to wake up the MMC thread on new request arrival.
    Now once the MMC thread is woken up, a new request can be fetched and
    prepared in parallel to the current running request which means this new
    request can be started immediately after the current running request
    completes.
    
    With this change read throughput is improved by 16%.
    
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 5c69315d60cc..be2500a49925 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -187,6 +187,18 @@ struct sdio_func_tuple;
 
 #define SDIO_MAX_FUNCS		7
 
+enum mmc_blk_status {
+	MMC_BLK_SUCCESS = 0,
+	MMC_BLK_PARTIAL,
+	MMC_BLK_CMD_ERR,
+	MMC_BLK_RETRY,
+	MMC_BLK_ABORT,
+	MMC_BLK_DATA_ERR,
+	MMC_BLK_ECC_ERR,
+	MMC_BLK_NOMEDIUM,
+	MMC_BLK_NEW_REQUEST,
+};
+
 /* The number of MMC physical partitions.  These consist of:
  * boot partitions (2), general purpose partitions (4) in MMC v4.4.
  */

commit 090d25fe224c0933d2b261aad91532e725c1d889
Author: Loic Pallardy <loic.pallardy-ext@stericsson.com>
Date:   Sat Nov 17 18:08:24 2012 -0500

    mmc: core: Expose access to RPMB partition
    
    Following JEDEC standard, if the mmc supports RPMB partition,
    a new interface is created and exposed via /dev/block.
    Users will be able to access RPMB partition using standard
    mmc IOCTL commands.
    
    Signed-off-by: Alex Macro <alex.macro@stericsson.com>
    Signed-off-by: Loic Pallardy <loic.pallardy@stericsson.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Acked-by: Krishna Konda <kkonda@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 943550dfe9ea..5c69315d60cc 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -85,6 +85,7 @@ struct mmc_ext_csd {
 	bool			boot_ro_lockable;
 	u8			raw_exception_status;	/* 53 */
 	u8			raw_partition_support;	/* 160 */
+	u8			raw_rpmb_size_mult;	/* 168 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
@@ -206,6 +207,7 @@ struct mmc_part {
 #define MMC_BLK_DATA_AREA_MAIN	(1<<0)
 #define MMC_BLK_DATA_AREA_BOOT	(1<<1)
 #define MMC_BLK_DATA_AREA_GP	(1<<2)
+#define MMC_BLK_DATA_AREA_RPMB	(1<<3)
 };
 
 /*

commit e6c085863f97f0a8f009753e1baaf83e4aac7b42
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Oct 5 12:45:39 2012 -0400

    mmc: core: Fixup broken suspend and eMMC4.5 power off notify
    
    This patch fixes up the broken suspend sequence for eMMC with sleep
    support. Additionally it reworks the eMMC4.5 Power Off Notification
    feature so it fits together with the existing sleep feature.
    
    The CMD0 based re-initialization of the eMMC at resume is re-introduced
    to maintain compatiblity for devices using sleep.
    
    A host shall use MMC_CAP2_POWEROFF_NOTIFY to enable the Power Off
    Notification feature. We might be able to remove this cap later on,
    if we think that Power Off Notification always is preferred over
    sleep, even if the host is not able to cut the eMMC VCCQ power.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Saugata Das <saugata.das@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 78cc3be85391..943550dfe9ea 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -57,6 +57,7 @@ struct mmc_ext_csd {
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		generic_cmd6_time;	/* Units: 10ms */
 	unsigned int            power_off_longtime;     /* Units: ms */
+	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
 #define MMC_HIGH_26_MAX_DTR	26000000
 #define MMC_HIGH_52_MAX_DTR	52000000
@@ -229,7 +230,6 @@ struct mmc_card {
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
-#define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
 #define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
@@ -246,11 +246,6 @@ struct mmc_card {
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
 #define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
 						/* byte mode */
-	unsigned int    poweroff_notify_state;	/* eMMC4.5 notify feature */
-#define MMC_NO_POWER_NOTIFICATION	0
-#define MMC_POWERED_ON			1
-#define MMC_POWEROFF_SHORT		2
-#define MMC_POWEROFF_LONG		3
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -397,7 +392,6 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
-#define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
 #define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
@@ -410,11 +404,9 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
-#define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
 #define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
-
 #define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
-#define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
+
 /*
  * Quirk add/remove for MMC products.
  */

commit 950d56acce5d401f477b91d0177605b543d63d07
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Mon Sep 17 08:42:02 2012 +0000

    mmc: support BKOPS feature for eMMC
    
    Enable eMMC background operations (BKOPS) feature.
    
    If URGENT_BKOPS is set after a response, note that BKOPS are required.
    Immediately run BKOPS if required.  Read/write operations should be
    requested during BKOPS(LEVEL-1), then issue HPI to interrupt the
    ongoing BKOPS and service the foreground operation.
    (This patch only controls the LEVEL2/3.)
    
    When repeating the writing 1GB data, at a certain time, performance is
    decreased.  At that time, card triggers the Level-3 or Level-2.  After
    running bkops, performance is recovered.
    
    Future considerations:
     * Check BKOPS_LEVEL=1 and start BKOPS in a preventive manner.
     * Interrupt ongoing BKOPS before powering off the card.
     * How do we get BKOPS_STATUS value (periodically send ext_csd command)?
     * If using periodic bkops, also consider runtime_pm control.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Konstantin Dorfman <kdorfman@codeaurora.org>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4b27f9f503e4..78cc3be85391 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -76,10 +76,13 @@ struct mmc_ext_csd {
 	bool			hpi_en;			/* HPI enablebit */
 	bool			hpi;			/* HPI support bit */
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
+	bool			bkops;		/* background support bit */
+	bool			bkops_en;	/* background enable bit */
 	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
+	u8			raw_exception_status;	/* 53 */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
@@ -93,6 +96,7 @@ struct mmc_ext_csd {
 	u8			raw_sec_erase_mult;	/* 230 */
 	u8			raw_sec_feature_support;/* 231 */
 	u8			raw_trim_mult;		/* 232 */
+	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
 
 	unsigned int            feature_support;
@@ -226,6 +230,7 @@ struct mmc_card {
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
 #define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
+#define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -393,6 +398,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
+#define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -405,7 +411,9 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
+#define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
 
+#define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
 #define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
 /*
  * Quirk add/remove for MMC products.

commit 3550ccdb9d8d350e526b809bf3dd92b550a74fe1
Author: Ian Chen <ian.cy.chen@samsung.com>
Date:   Wed Aug 29 15:05:36 2012 +0900

    mmc: card: Skip secure erase on MoviNAND; causes unrecoverable corruption.
    
    For several MoviNAND eMMC parts, there are known issues with secure
    erase and secure trim.  For these specific MoviNAND devices, we skip
    these operations.
    
    Specifically, there is a bug in the eMMC firmware that causes
    unrecoverable corruption when the MMC is erased with MMC_CAP_ERASE
    enabled.
    
    References:
    
    http://forum.xda-developers.com/showthread.php?t=1644364
    https://plus.google.com/111398485184813224730/posts/21pTYfTsCkB#111398485184813224730/posts/21pTYfTsCkB
    
    Signed-off-by: Ian Chen <ian.cy.chen@samsung.com>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Jaehoon Chung <jh80.chung@samsung.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: stable <stable@vger.kernel.org> [3.0+]
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 111aca5e97f3..4b27f9f503e4 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -239,6 +239,7 @@ struct mmc_card {
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
+#define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
 						/* byte mode */
 	unsigned int    poweroff_notify_state;	/* eMMC4.5 notify feature */
 #define MMC_NO_POWER_NOTIFICATION	0

commit 0aa6770000bafa65c17cf44b6619d328d4fc79b3
Author: Philip Rakity <prakity@marvell.com>
Date:   Sun May 27 18:36:33 2012 -0700

    mmc: sdhci: only set 200mA support for 1.8v if 200mA is available
    
    max_current_caps can return 0 if not available from the sd controller.
    If no regulator is present or the regulator specifies a current
    less then 200ma, we no longer still set the 200mA caps bit anyway.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Reviewed-by: Aaron Lu <aaron_lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d76513b5b263..111aca5e97f3 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -149,6 +149,7 @@ struct sd_switch_caps {
 #define SD_SET_CURRENT_LIMIT_400	1
 #define SD_SET_CURRENT_LIMIT_600	2
 #define SD_SET_CURRENT_LIMIT_800	3
+#define SD_SET_CURRENT_NO_CHANGE	(-1)
 
 #define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
 #define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)

commit 96cf5f02aee8bbeff38824b18b9ec583d687f846
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Apr 25 16:17:37 2012 +0900

    mmc: core: fix the decision of HS200/DDR card-type
    
    Current implementation decides the card type exclusively. Even though
    eMMC device can support both HS200 and DDR mode, card type will be
    set only for HS200. If the host doesn't support HS200 but has DDR
    capability, then DDR mode can't be selected.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 629b823f8836..d76513b5b263 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -58,6 +58,10 @@ struct mmc_ext_csd {
 	unsigned int		generic_cmd6_time;	/* Units: 10ms */
 	unsigned int            power_off_longtime;     /* Units: ms */
 	unsigned int		hs_max_dtr;
+#define MMC_HIGH_26_MAX_DTR	26000000
+#define MMC_HIGH_52_MAX_DTR	52000000
+#define MMC_HIGH_DDR_MAX_DTR	52000000
+#define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
 	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */

commit 32d317c60e56c2a34463b51fc0336cc96b3e1735
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Wed Apr 11 19:54:38 2012 +0800

    mmc: remove MMC bus legacy suspend/resume method
    
    MMC bus is using legacy suspend/resume method, which is not compatible if
    runtime pm callbacks are used. In this scenario, MMC bus suspend/resume
    callbacks cannot be called when system entering S3. So change to use the
    new defined dev_pm_ops for system sleeping mode.
    
    Tested on AM335x Platform. Solves major issue/crash reported at
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg65425.html
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Tested-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 01beae78f079..629b823f8836 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -481,7 +481,7 @@ struct mmc_driver {
 	struct device_driver drv;
 	int (*probe)(struct mmc_card *);
 	void (*remove)(struct mmc_card *);
-	int (*suspend)(struct mmc_card *, pm_message_t);
+	int (*suspend)(struct mmc_card *);
 	int (*resume)(struct mmc_card *);
 };
 

commit b5174fa3a7f4f8f150bfa3b917c92608953dfa0f
Merge: afb9bd704c71 135111cc5595
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 20:59:45 2012 -0700

    Merge tag 'mmc-merge-for-3.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc
    
    Pull MMC updates from Chris Ball:
    
    Core:
     * Support for MMC 4.5 Data Tag feature -- we tag REQ_META, so devices
       that support Data Tag will provide increased throughput for metadata.
     * Faster detection of card removal on I/O errors.
    
    Drivers:
     * dw_mmc now supports eMMC Power Off Notify, has PCI support, and
       implements pre_req and post_req for asynchronous requests.
     * omap_hsmmc now supports device tree.
     * esdhc now has power management support.
     * sdhci-tegra now supports Tegra30 devices.
     * sdhci-spear now supports hibernation.
     * tmio_mmc now supports using a GPIO for card detection.
     * Intel PCH now supports 8-bit bus transfers.
    
    * tag 'mmc-merge-for-3.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/cjb/mmc: (53 commits)
      mmc: sh_mmcif: simplify bitmask macros
      mmc: sh_mobile_sdhi: support modular mmc-core with non-standard hotplug
      mmc: sh_mobile_sdhi: add a callback for board specific init code
      mmc: tmio: cosmetic: prettify the tmio_mmc_set_ios() function
      mmc: sh_mobile_sdhi: do not manage PM clocks manually
      mmc: tmio_mmc: remove unused sdio_irq_enabled flag
      mmc: tmio_mmc: power status flag doesn't have to be exposed in platform data
      mmc: sh_mobile_sdhi: pass card hotplug GPIO number to TMIO MMC
      mmc: tmio_mmc: support the generic MMC GPIO card hotplug helper
      mmc: tmio: calculate the native hotplug condition only once
      mmc: simplify mmc_cd_gpio_request() by removing two parameters
      mmc: sdhci-pci: allow 8-bit bus width for Intel PCH
      mmc: sdhci: check interrupt flags in ISR again
      mmc: sdhci-pci: Add MSI support
      mmc: core: warn when card doesn't support HPI
      mmc: davinci: Poll status for small size transfers
      mmc: davinci: Eliminate spurious interrupts
      mmc: omap_hsmmc: Avoid a regulator voltage change with dt
      mmc: omap_hsmmc: Convert hsmmc driver to use device tree
      mmc: sdhci-pci: add SDHCI_QUIRK2_HOST_OFF_CARD_ON for Medfield SDIO
      ...

commit 4265900e0be653f5b78baf2816857ef57cf1332f
Author: Saugata Das <saugata.das@linaro.org>
Date:   Wed Dec 21 13:09:17 2011 +0530

    mmc: MMC-4.5 Data Tag Support
    
    MMC-4.5 data tag feature will be used to store the file system meta-data
    in the tagged region of eMMC. This will improve the write and subsequent
    read transfer time for the meta data.
    
    Signed-off-by: Saugata Das <saugata.das@linaro.org>
    Tested-by: Venkatraman S <svenkatr@ti.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 19a41d1737af..1a1ca7169834 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -71,6 +71,8 @@ struct mmc_ext_csd {
 	bool			hpi_en;			/* HPI enablebit */
 	bool			hpi;			/* HPI support bit */
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
+	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
+	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
 	u8			raw_partition_support;	/* 160 */

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 9f22ba572de0..895978c9a16b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -10,6 +10,7 @@
 #ifndef LINUX_MMC_CARD_H
 #define LINUX_MMC_CARD_H
 
+#include <linux/device.h>
 #include <linux/mmc/core.h>
 #include <linux/mod_devicetable.h>
 

commit 3e73c36b4dc224529d0b0c0d5d69c0dacd793c42
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Tue Jan 31 15:44:03 2012 +0530

    mmc: core: Fix PowerOff Notify suspend/resume
    
    Modified the mmc_poweroff to resume before sending the poweroff
    notification command. In sleep mode only AWAKE and RESET commands are
    allowed, so before sending the poweroff notification command resume from
    sleep mode and then send the notification command.
    
    PowerOff Notify is tested on a Synopsis Designware Host Controller
    (eMMC 4.5). The suspend to RAM and resume works fine.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Tested-by: Girish K S <girish.shivananjappa@linaro.org>
    Reviewed-by: Saugata Das <saugata.das@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 9f22ba572de0..19a41d1737af 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -217,6 +217,7 @@ struct mmc_card {
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
+#define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -382,6 +383,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
+#define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -393,7 +395,9 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
+#define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
 
+#define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
 /*
  * Quirk add/remove for MMC products.
  */

commit a4924c71aa43d4f8a3f342b1f71788349472e684
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Wed Jan 11 14:04:52 2012 -0500

    mmc: core: HS200 mode support for eMMC 4.5
    
    This patch adds the support of the HS200 bus speed for eMMC 4.5 devices.
    The eMMC 4.5 devices have support for 200MHz bus speed. The function
    prototype of the tuning function is modified to handle the tuning
    command number which is different in sd and mmc case.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 9478a6bf1bb1..9f22ba572de0 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -216,6 +216,7 @@ struct mmc_card {
 #define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
+#define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -374,6 +375,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
+#define mmc_card_hs200(c)	((c)->state & MMC_STATE_HIGHSPEED_200)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 #define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
 #define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
@@ -384,6 +386,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
+#define mmc_card_set_hs200(c)	((c)->state |= MMC_STATE_HIGHSPEED_200)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 #define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
 #define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)

commit add710eaa88606de8ba98a014d37178579e6dbaf
Author: Johan Rudholm <johan.rudholm@stericsson.com>
Date:   Fri Dec 2 08:51:06 2011 +0100

    mmc: boot partition ro lock support
    
    Enable boot partitions to be read-only locked until next power on via
    a sysfs entry. There will be one sysfs entry for each boot partition:
    
    /sys/block/mmcblkXbootY/ro_lock_until_next_power_on
    
    Each boot partition is locked by writing 1 to its file.
    
    Signed-off-by: Johan Rudholm <johan.rudholm@stericsson.com>
    Signed-off-by: John Beckett <john.beckett@stericsson.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6402d9224d6a..9478a6bf1bb1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -71,6 +71,8 @@ struct mmc_ext_csd {
 	bool			hpi_en;			/* HPI enablebit */
 	bool			hpi;			/* HPI support bit */
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
+	unsigned int		boot_ro_lock;		/* ro lock support */
+	bool			boot_ro_lockable;
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
@@ -187,6 +189,10 @@ struct mmc_part {
 	unsigned int	part_cfg;	/* partition type */
 	char	name[MAX_MMC_PART_NAME_LEN];
 	bool	force_ro;	/* to make boot parts RO by default */
+	unsigned int	area_type;
+#define MMC_BLK_DATA_AREA_MAIN	(1<<0)
+#define MMC_BLK_DATA_AREA_BOOT	(1<<1)
+#define MMC_BLK_DATA_AREA_GP	(1<<2)
 };
 
 /*
@@ -265,12 +271,14 @@ struct mmc_card {
  * This function fill contents in mmc_part.
  */
 static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
-			unsigned int part_cfg, char *name, int idx, bool ro)
+			unsigned int part_cfg, char *name, int idx, bool ro,
+			int area_type)
 {
 	card->part[card->nr_parts].size = size;
 	card->part[card->nr_parts].part_cfg = part_cfg;
 	sprintf(card->part[card->nr_parts].name, name, idx);
 	card->part[card->nr_parts].force_ro = ro;
+	card->part[card->nr_parts].area_type = area_type;
 	card->nr_parts++;
 }
 

commit d30495048892980e5d453328d1cc9343b3f7e917
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Nov 28 16:22:00 2011 +0200

    mmc: allow upper layers to know immediately if card has been removed
    
    Add a function mmc_detect_card_removed() which upper layers can use to
    determine immediately if a card has been removed. This function should
    be called after an I/O request fails so that all queued I/O requests
    can be errored out immediately instead of waiting for the card device
    to be removed.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 534974c3ef0c..6402d9224d6a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -209,6 +209,7 @@ struct mmc_card {
 #define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
 #define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
+#define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -370,6 +371,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
+#define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -379,6 +381,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
+#define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 
 /*
  * Quirk add/remove for MMC products.

commit a303c5319c8e6ab0e744ebca118da8420043b2c3
Author: Philip Rakity <prakity@marvell.com>
Date:   Mon Nov 14 19:14:38 2011 -0800

    mmc: sdio: support SDIO UHS cards
    
    This patch adds support for sdio UHS cards per the version 3.0
    spec.
    
    UHS mode is only enabled for version 3.0 cards when both the
    host and the controller support UHS modes.
    
    1.8v signaling support is removed if both the card and the
    host do not support UHS.  This is done to maintain
    compatibility and some system/card combinations break when
    1.8v signaling is enabled when the host does not support UHS.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Aaron Lu <Aaron.lu@amd.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Tested-by: Bing Zhao <bzhao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 2c9be29684cf..534974c3ef0c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -367,7 +367,8 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 #define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
-#define mmc_sd_card_uhs(c) ((c)->state & MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
@@ -375,6 +376,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 #define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
+#define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 

commit fffe5d5aa05b4e69f79bc75a51c5ee0fc6203fa5
Author: Qiang Liu <qiang.liu@freescale.com>
Date:   Tue Nov 8 08:43:08 2011 -0500

    mmc: sd: Macro name cleanup for high speed dtr
    
    Add new macros for the high speed 50MHz case, rather than having
    a confusing reuse of the value for UHS SDR50, which is 100MHz.
    
    Reported-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index c8ef9bc54d50..2c9be29684cf 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -110,6 +110,7 @@ struct sd_ssr {
 struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
 	unsigned int		uhs_max_dtr;
+#define HIGH_SPEED_MAX_DTR	50000000
 #define UHS_SDR104_MAX_DTR	208000000
 #define UHS_SDR50_MAX_DTR	100000000
 #define UHS_DDR50_MAX_DTR	50000000
@@ -117,11 +118,13 @@ struct sd_switch_caps {
 #define UHS_SDR12_MAX_DTR	25000000
 	unsigned int		sd3_bus_mode;
 #define UHS_SDR12_BUS_SPEED	0
+#define HIGH_SPEED_BUS_SPEED	1
 #define UHS_SDR25_BUS_SPEED	1
 #define UHS_SDR50_BUS_SPEED	2
 #define UHS_SDR104_BUS_SPEED	3
 #define UHS_DDR50_BUS_SPEED	4
 
+#define SD_MODE_HIGH_SPEED	(1 << HIGH_SPEED_BUS_SPEED)
 #define SD_MODE_UHS_SDR12	(1 << UHS_SDR12_BUS_SPEED)
 #define SD_MODE_UHS_SDR25	(1 << UHS_SDR25_BUS_SPEED)
 #define SD_MODE_UHS_SDR50	(1 << UHS_SDR50_BUS_SPEED)

commit 6de5fc9cf7de334912de4cfd2d06eb2d744d2afe
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Nov 3 09:44:12 2011 +0100

    mmc: core: Add quirk for long data read time
    
    Adds a quirk that sets the data read timeout to a fixed value instead
    of relying on the information in the CSD. The timeout value chosen
    is 300ms since that has proven enough for the problematic cards found,
    but could be increased if other cards require this.
    
    This patch also enables this quirk for certain Micron cards known to
    have this problem.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 415f2db414e1..c8ef9bc54d50 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -218,6 +218,7 @@ struct mmc_card {
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
+#define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
 						/* byte mode */
 	unsigned int    poweroff_notify_state;	/* eMMC4.5 notify feature */
 #define MMC_NO_POWER_NOTIFICATION	0
@@ -433,6 +434,11 @@ static inline int mmc_card_broken_byte_mode_512(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
 }
 
+static inline int mmc_card_long_read_time(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit a6029e1f75bb484c1f5bc68b6a8572e4024795bc
Author: Namjae Jeon <linkinjeon@gmail.com>
Date:   Thu Oct 13 00:43:14 2011 +0900

    mmc: fix compile error when CONFIG_BLOCK is not enabled
    
    'DISK_NAME_LEN' is undeclared when CONFIG_BLOCK is disabled; its use was
    introduced via genhd.h by the general purpose partition patch.
    
    To fix, we just add our own MAX_MMC_PART_NAME_LEN macro instead of using
    DISK_NAME_LEN.
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Andrei Warkentin <andreiw@vmware.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 1684d92a8015..415f2db414e1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -12,7 +12,6 @@
 
 #include <linux/mmc/core.h>
 #include <linux/mod_devicetable.h>
-#include <linux/genhd.h>
 
 struct mmc_cid {
 	unsigned int		manfid;
@@ -175,6 +174,7 @@ struct sdio_func_tuple;
 #define MMC_NUM_BOOT_PARTITION	2
 #define MMC_NUM_GP_PARTITION	4
 #define MMC_NUM_PHY_PARTITION	6
+#define MAX_MMC_PART_NAME_LEN	20
 
 /*
  * MMC Physical partitions
@@ -182,7 +182,7 @@ struct sdio_func_tuple;
 struct mmc_part {
 	unsigned int	size;	/* partition size (in bytes) */
 	unsigned int	part_cfg;	/* partition type */
-	char	name[DISK_NAME_LEN];
+	char	name[MAX_MMC_PART_NAME_LEN];
 	bool	force_ro;	/* to make boot parts RO by default */
 };
 

commit eb0d8f135b6730d6d0324a064664d121334290e7
Author: Jaehoon Chung <jh80.chung@samsung.com>
Date:   Tue Oct 18 01:26:42 2011 -0400

    mmc: core: support HPI send command
    
    HPI command is defined in eMMC4.41.
    This feature is important for eMMC4.5 devices.
    
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 32492b78aed6..1684d92a8015 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -69,10 +69,14 @@ struct mmc_ext_csd {
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
 	unsigned int		cache_size;		/* Units: KB */
+	bool			hpi_en;			/* HPI enablebit */
+	bool			hpi;			/* HPI support bit */
+	unsigned int		hpi_cmd;		/* cmd used as HPI */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
+	u8			out_of_int_time;	/* 198 */
 	u8			raw_s_a_timeout;		/* 217 */
 	u8			raw_hc_erase_gap_size;	/* 221 */
 	u8			raw_erase_timeout_mult;	/* 223 */

commit 881d1c25f765938a95def5afe39486ce39f9fc96
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Oct 14 14:03:21 2011 +0900

    mmc: core: Add cache control for eMMC4.5 device
    
    This patch adds cache feature of eMMC4.5 Spec.
    If device supports cache capability, host can utilize some specific
    operations.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 551378508784..32492b78aed6 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -51,6 +51,7 @@ struct mmc_ext_csd {
 	u8			rel_sectors;
 	u8			rel_param;
 	u8			part_config;
+	u8			cache_ctrl;
 	u8			rst_n_function;
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
@@ -67,6 +68,7 @@ struct mmc_ext_csd {
 	bool			enhanced_area_en;	/* enable bit */
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
+	unsigned int		cache_size;		/* Units: KB */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */

commit b3bf915308ca2b50f3beec6cc824083870f0f4b5
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Tue Oct 18 09:34:04 2011 +0900

    mmc: core: new discard feature support at eMMC v4.5
    
    MMC v4.5 supports the DISCARD feature (CMD38).  It's different from
    trim and there's no check bit.  Currently it's only supported at v4.5.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 711c3f8bfabd..551378508784 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -80,6 +80,9 @@ struct mmc_ext_csd {
 	u8			raw_sec_feature_support;/* 231 */
 	u8			raw_trim_mult;		/* 232 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
+
+	unsigned int            feature_support;
+#define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */
 };
 
 struct sd_scr {

commit bec8726abc72bf30d2743a722aa37cd69e7a0580
Author: Girish K S <girish.shivananjappa@linaro.org>
Date:   Thu Oct 13 12:04:16 2011 +0530

    mmc: core: Add Power Off Notify Feature eMMC 4.5
    
    This patch adds support for the power off notify feature, available in
    eMMC 4.5 devices. If the host has support for this feature, then the
    mmc core will notify the device by setting the POWER_OFF_NOTIFICATION
    byte in the extended csd register with a value of 1 (POWER_ON).
    
    For suspend mode short timeout is used, whereas for the normal poweroff
    long timeout is used.
    
    Signed-off-by: Girish K S <girish.shivananjappa@linaro.org>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 2fcd24ccd38c..711c3f8bfabd 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -55,6 +55,7 @@ struct mmc_ext_csd {
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		generic_cmd6_time;	/* Units: 10ms */
+	unsigned int            power_off_longtime;     /* Units: ms */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 	unsigned int		card_type;
@@ -209,6 +210,11 @@ struct mmc_card {
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
 						/* byte mode */
+	unsigned int    poweroff_notify_state;	/* eMMC4.5 notify feature */
+#define MMC_NO_POWER_NOTIFICATION	0
+#define MMC_POWERED_ON			1
+#define MMC_POWEROFF_SHORT		2
+#define MMC_POWEROFF_LONG		3
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */

commit b23cf0bd55b0c6b703982446f679e00d6d929524
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Fri Sep 23 14:15:29 2011 +0900

    mmc: core: Add default timeout value for CMD6
    
    EXT_CSD[248] includes the default maximum timeout for CMD6.
    This field is added at eMMC4.5 Spec. And it can be used for default
    timeout except for some operations which don't define the timeout
    (i.e. background operation, sanitize, flush cache) in eMMC4.5 Spec.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 92762865f7e0..2fcd24ccd38c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -54,6 +54,7 @@ struct mmc_ext_csd {
 	u8			rst_n_function;
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
+	unsigned int		generic_cmd6_time;	/* Units: 10ms */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 	unsigned int		card_type;

commit e0c368d571d946ff40f068344b5c2df90c93dd2e
Author: Namjae Jeon <linkinjeon@gmail.com>
Date:   Thu Oct 6 23:41:38 2011 +0900

    mmc: core: general purpose MMC partition support.
    
    It allows gerneral purpose partitions in MMC Device.  And I try to simply
    make mmc_blk_alloc_parts using mmc_part structure suggested by Andrei
    Warkentin.  After patching, we see general purpose partitions like this:
    > cat /proc/partitions
              179 0 847872 mmcblk0
              179 192 4096 mmcblk0gp3
              179 160 4096 mmcblk0gp2
              179 128 4096 mmcblk0gp1
              179 96  1052672 mmcblk0gp0
              179 64  1024 mmcblk0boot1
              179 32  1024 mmcblk0boot0
    
    Signed-off-by: Namjae Jeon <linkinjeon@gmail.com>
    Acked-by: Andrei Warkentin <awarkentin@vmware.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 5294ddf382ae..92762865f7e0 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -12,6 +12,7 @@
 
 #include <linux/mmc/core.h>
 #include <linux/mod_devicetable.h>
+#include <linux/genhd.h>
 
 struct mmc_cid {
 	unsigned int		manfid;
@@ -64,7 +65,6 @@ struct mmc_ext_csd {
 	bool			enhanced_area_en;	/* enable bit */
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
-	unsigned int		boot_size;		/* in bytes */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
@@ -158,6 +158,23 @@ struct sdio_func_tuple;
 
 #define SDIO_MAX_FUNCS		7
 
+/* The number of MMC physical partitions.  These consist of:
+ * boot partitions (2), general purpose partitions (4) in MMC v4.4.
+ */
+#define MMC_NUM_BOOT_PARTITION	2
+#define MMC_NUM_GP_PARTITION	4
+#define MMC_NUM_PHY_PARTITION	6
+
+/*
+ * MMC Physical partitions
+ */
+struct mmc_part {
+	unsigned int	size;	/* partition size (in bytes) */
+	unsigned int	part_cfg;	/* partition type */
+	char	name[DISK_NAME_LEN];
+	bool	force_ro;	/* to make boot parts RO by default */
+};
+
 /*
  * MMC device
  */
@@ -219,8 +236,23 @@ struct mmc_card {
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
 
 	struct dentry		*debugfs_root;
+	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
+	unsigned int    nr_parts;
 };
 
+/*
+ * This function fill contents in mmc_part.
+ */
+static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
+			unsigned int part_cfg, char *name, int idx, bool ro)
+{
+	card->part[card->nr_parts].size = size;
+	card->part[card->nr_parts].part_cfg = part_cfg;
+	sprintf(card->part[card->nr_parts].name, name, idx);
+	card->part[card->nr_parts].force_ro = ro;
+	card->nr_parts++;
+}
+
 /*
  *  The world is not perfect and supplies us with broken mmc/sdio devices.
  *  For at least some of these bugs we need a work-around.

commit b2499518b5ad7e28bb3ed348fd3f370eeb1e36c0
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Mon Aug 29 16:42:11 2011 +0300

    mmc: core: add eMMC hardware reset support
    
    eMMC's may have a hardware reset line.  This patch provides a
    host controller operation to implement hardware reset and
    a function to reset and reinitialize the card.  Also, for MMC,
    the reset is always performed before initialization.
    
    The host must set the new host capability MMC_CAP_HW_RESET
    to enable hardware reset.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6dfb293326e2..5294ddf382ae 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -50,6 +50,7 @@ struct mmc_ext_csd {
 	u8			rel_sectors;
 	u8			rel_param;
 	u8			part_config;
+	u8			rst_n_function;
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;

commit 9a0da648ff3a5020406ac7784eb3b519014f66f6
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Thu Sep 15 17:43:04 2011 +0200

    mmc: sdio: Workaround for dev with broken CMD53
    
    Adds a quirk which can be turned on for SDIO devices that do not support
    512 byte requests in byte mode during CMD53. These requests will always
    be sent in block mode instead.
    
    This patch also enables this quirk for ST-Ericsson CW1200 WLAN device.
    
    Signed-off-by: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
    Signed-off-by: Ulf HANSSON <ulf.hansson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index b460fc2af8a1..6dfb293326e2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -188,6 +188,8 @@ struct mmc_card {
 #define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
+#define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
+						/* byte mode */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -377,6 +379,11 @@ static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;
 }
 
+static inline int mmc_card_broken_byte_mode_512(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit 100e918610b7487fa18db97b3879cd8d1fdd5974
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri May 27 16:04:03 2011 -0400

    mmc: Standardize header file inclusion checks.
    
    Standardize the checks for multiple MMC header file inclusion,
    including adding comments to terminating #endif's, and fixing
    one incorrect comment.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6ad43554ac05..b460fc2af8a1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -403,4 +403,4 @@ extern void mmc_unregister_driver(struct mmc_driver *);
 extern void mmc_fixup_device(struct mmc_card *card,
 			     const struct mmc_fixup *table);
 
-#endif
+#endif /* LINUX_MMC_CARD_H */

commit f39b2dd9d065151a04f5996656d1f27a7eb32d45
Author: Philip Rakity <prakity@marvell.com>
Date:   Thu Jul 7 09:04:55 2011 -0700

    mmc: core: Bus width testing needs to handle suspend/resume
    
    On reading the ext_csd for the first time (in 1 bit mode), save the
    ext_csd information needed for bus width compare.
    
    On every pass we make re-reading the ext_csd, compare the data
    against the saved ext_csd data.
    
    This fixes a regression introduced in 3.0-rc1 by 08ee80cc397ac1a3
    ("mmc: core: eMMC bus width may not work on all platforms"), which
    incorrectly assumed we would be re-reading the ext_csd at resume-
    time.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index c6927a4d157f..6ad43554ac05 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -64,6 +64,19 @@ struct mmc_ext_csd {
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
 	unsigned int		boot_size;		/* in bytes */
+	u8			raw_partition_support;	/* 160 */
+	u8			raw_erased_mem_count;	/* 181 */
+	u8			raw_ext_csd_structure;	/* 194 */
+	u8			raw_card_type;		/* 196 */
+	u8			raw_s_a_timeout;		/* 217 */
+	u8			raw_hc_erase_gap_size;	/* 221 */
+	u8			raw_erase_timeout_mult;	/* 223 */
+	u8			raw_hc_erase_grp_size;	/* 224 */
+	u8			raw_sec_trim_mult;	/* 229 */
+	u8			raw_sec_erase_mult;	/* 230 */
+	u8			raw_sec_feature_support;/* 231 */
+	u8			raw_trim_mult;		/* 232 */
+	u8			raw_sectors[4];		/* 212 - 4 bytes */
 };
 
 struct sd_scr {

commit f0d89972b01798cf9d245dfa1cacfa0ee78a3593
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:38 2011 -0500

    mmc: core: Block CMD23 support for UHS104/SDXC cards.
    
    SD cards operating at UHS104 or better support SET_BLOCK_COUNT.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Reviewed-by: Arindam Nath <arindam.nath@amd.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4a0e27baaea0..c6927a4d157f 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -72,6 +72,9 @@ struct sd_scr {
 	unsigned char		bus_widths;
 #define SD_SCR_BUS_WIDTH_1	(1<<0)
 #define SD_SCR_BUS_WIDTH_4	(1<<2)
+	unsigned char		cmds;
+#define SD_SCR_CMD20_SUPPORT   (1<<0)
+#define SD_SCR_CMD23_SUPPORT   (1<<1)
 };
 
 struct sd_ssr {

commit d0c97cfb81ebc5b416c0f92fa2fc18d2773e3023
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:36 2011 -0500

    mmc: core: Use CMD23 for multiblock transfers when we can.
    
    CMD23-prefixed instead of open-ended multiblock transfers
    have a performance advantage on some MMC cards.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7190aa2096f7..4a0e27baaea0 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -171,6 +171,7 @@ struct mmc_card {
 #define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
 #define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
+#define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */

commit c59de9287993b5c36f9005f745a3ce0b1008131d
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon May 23 15:06:35 2011 -0500

    mmc: quirks: Add/remove quirks conditional support.
    
    Conditional add/remove quirks for MMC and SD.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4910dec47bb7..7190aa2096f7 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -273,16 +273,14 @@ struct mmc_fixup {
 		    card->cid.month)
 
 /*
- * This hook just adds a quirk unconditionally.
+ * Unconditionally quirk add/remove.
  */
+
 static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
 {
 	card->quirks |= data;
 }
 
-/*
- * This hook just removes a quirk unconditionally.
- */
 static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 {
 	card->quirks &= ~data;
@@ -308,6 +306,40 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 
+/*
+ * Quirk add/remove for MMC products.
+ */
+
+static inline void __maybe_unused add_quirk_mmc(struct mmc_card *card, int data)
+{
+	if (mmc_card_mmc(card))
+		card->quirks |= data;
+}
+
+static inline void __maybe_unused remove_quirk_mmc(struct mmc_card *card,
+						   int data)
+{
+	if (mmc_card_mmc(card))
+		card->quirks &= ~data;
+}
+
+/*
+ * Quirk add/remove for SD products.
+ */
+
+static inline void __maybe_unused add_quirk_sd(struct mmc_card *card, int data)
+{
+	if (mmc_card_sd(card))
+		card->quirks |= data;
+}
+
+static inline void __maybe_unused remove_quirk_sd(struct mmc_card *card,
+						   int data)
+{
+	if (mmc_card_sd(card))
+		card->quirks &= ~data;
+}
+
 static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
 {
 	return c->quirks & MMC_QUIRK_LENIENT_FN0;

commit 06e8935febe687e2a561707d4c7ca4245d261dbe
Author: Stefan Nilsson XK <stefan.xk.nilsson@stericsson.com>
Date:   Wed May 11 17:48:05 2011 +0200

    mmc: sdio: optimized SDIO IRQ handling for single irq
    
    If there is only 1 function interrupt registered it is possible to
    improve performance by directly calling the irq handler and avoiding
    the overhead of reading the CCCR registers.
    
    Signed-off-by: Per Forlin <per.forlin@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@stericsson.com>
    Reviewed-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d8dffc992ce2..4910dec47bb7 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -191,6 +191,7 @@ struct mmc_card {
 	struct sdio_cccr	cccr;		/* common card info */
 	struct sdio_cis		cis;		/* common tuple info */
 	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
+	struct sdio_func	*sdio_single_irq; /* SDIO function when only one IRQ active */
 	unsigned		num_info;	/* number of info strings */
 	const char		**info;		/* info strings */
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */

commit 3a3035114307cd55e024662bb295a87b849f0bd4
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:03 2011 +0530

    mmc: sd: report correct speed and capacity of uhs cards
    
    Since only UHS-I cards respond with S18A set in response to ACMD41,
    we set the card as ultra-high-speed after successfull initialization.
    We need to decide whether a card is SDXC based on the C_SIZE field
    of CSDv2.0 register. According to Physical Layer spec v3.01, the
    minimum value of C_SIZE for SDXC card is 00FFFFh.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 47b5ad3960b7..d8dffc992ce2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -30,6 +30,7 @@ struct mmc_csd {
 	unsigned short		cmdclass;
 	unsigned short		tacc_clks;
 	unsigned int		tacc_ns;
+	unsigned int		c_size;
 	unsigned int		r2w_factor;
 	unsigned int		max_dtr;
 	unsigned int		erase_size;		/* In sectors */
@@ -158,6 +159,8 @@ struct mmc_card {
 #define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
 #define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
+#define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
+#define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -293,12 +296,16 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 #define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
+#define mmc_sd_card_uhs(c) ((c)->state & MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 #define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
+#define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 
 static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
 {

commit 5371c927bcd06a5c9dd6785bab2d452b87d9abc6
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:02 2011 +0530

    mmc: sd: set current limit for uhs cards
    
    We decide on the current limit to be set for the card based on the
    Capability of Host Controller to provide current at 1.8V signalling,
    and the maximum current limit of the card as indicated by CMD6
    mode 0. We then set the current limit for the card using CMD6 mode 1.
    As per the Physical Layer Spec v3.01, the current limit switch is
    only applicable for SDR50, SDR104, and DDR50 bus speed modes. For
    other UHS-I modes, we set the default current limit of 200mA.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4ef6ded6347d..47b5ad3960b7 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -105,6 +105,15 @@ struct sd_switch_caps {
 #define SD_DRIVER_TYPE_C	0x04
 #define SD_DRIVER_TYPE_D	0x08
 	unsigned int		sd3_curr_limit;
+#define SD_SET_CURRENT_LIMIT_200	0
+#define SD_SET_CURRENT_LIMIT_400	1
+#define SD_SET_CURRENT_LIMIT_600	2
+#define SD_SET_CURRENT_LIMIT_800	3
+
+#define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
+#define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)
+#define SD_MAX_CURRENT_600	(1 << SD_SET_CURRENT_LIMIT_600)
+#define SD_MAX_CURRENT_800	(1 << SD_SET_CURRENT_LIMIT_800)
 };
 
 struct sdio_cccr {

commit 49c468fcf878d2c86e31920cf54aa90c88418a66
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:19:01 2011 +0530

    mmc: sd: add support for uhs bus speed mode selection
    
    This patch adds support for setting UHS-I bus speed mode during UHS-I
    initialization procedure. Since both the host and card can support
    more than one bus speed, we select the highest speed based on both of
    their capabilities. First we set the bus speed mode for the card using
    CMD6 mode 1, and then we program the host controller to support the
    required speed mode. We also set High Speed Enable in case one of the
    UHS-I modes is selected. We take care to reset SD clock before setting
    UHS mode in the Host Control2 register, and then re-enable it as per
    the Host Controller spec v3.00. We then set the clock frequency for
    the UHS-I mode selected.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 539327260dc1..4ef6ded6347d 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -81,7 +81,24 @@ struct sd_ssr {
 
 struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
+	unsigned int		uhs_max_dtr;
+#define UHS_SDR104_MAX_DTR	208000000
+#define UHS_SDR50_MAX_DTR	100000000
+#define UHS_DDR50_MAX_DTR	50000000
+#define UHS_SDR25_MAX_DTR	UHS_DDR50_MAX_DTR
+#define UHS_SDR12_MAX_DTR	25000000
 	unsigned int		sd3_bus_mode;
+#define UHS_SDR12_BUS_SPEED	0
+#define UHS_SDR25_BUS_SPEED	1
+#define UHS_SDR50_BUS_SPEED	2
+#define UHS_SDR104_BUS_SPEED	3
+#define UHS_DDR50_BUS_SPEED	4
+
+#define SD_MODE_UHS_SDR12	(1 << UHS_SDR12_BUS_SPEED)
+#define SD_MODE_UHS_SDR25	(1 << UHS_SDR25_BUS_SPEED)
+#define SD_MODE_UHS_SDR50	(1 << UHS_SDR50_BUS_SPEED)
+#define SD_MODE_UHS_SDR104	(1 << UHS_SDR104_BUS_SPEED)
+#define SD_MODE_UHS_DDR50	(1 << UHS_DDR50_BUS_SPEED)
 	unsigned int		sd3_drv_type;
 #define SD_DRIVER_TYPE_B	0x01
 #define SD_DRIVER_TYPE_A	0x02
@@ -166,6 +183,8 @@ struct mmc_card {
 	const char		**info;		/* info strings */
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 
+	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
+
 	struct dentry		*debugfs_root;
 };
 

commit d6d50a15a2897d4133d536dd4343b5cf21163db3
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:59 2011 +0530

    mmc: sd: add support for driver type selection
    
    This patch adds support for setting driver strength during UHS-I
    initialization procedure. Since UHS-I cards set S18A (bit 24) in
    response to ACMD41, we use this as a base for UHS-I initialization.
    We modify the parameter list of mmc_sd_get_cid() so that we can
    save the ROCR from ACMD41 to check whether bit 24 is set.
    
    We decide whether the Host Controller supports A, C, or D driver
    type depending on the Capabilities register. Driver type B is
    suported by default. We then set the appropriate driver type for
    the card using CMD6 mode 1. As per Host Controller spec v3.00, we
    set driver type for the host only if Preset Value Enable in the
    Host Control2 register is not set. SDHCI_HOST_CONTROL has been
    renamed to SDHCI_HOST_CONTROL1 to conform to the spec.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 56f4d9234a66..539327260dc1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -83,6 +83,10 @@ struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
 	unsigned int		sd3_bus_mode;
 	unsigned int		sd3_drv_type;
+#define SD_DRIVER_TYPE_B	0x01
+#define SD_DRIVER_TYPE_A	0x02
+#define SD_DRIVER_TYPE_C	0x04
+#define SD_DRIVER_TYPE_D	0x08
 	unsigned int		sd3_curr_limit;
 };
 

commit 013909c4ffd16ded4895528b856fd8782df04dc6
Author: Arindam Nath <arindam.nath@amd.com>
Date:   Thu May 5 12:18:58 2011 +0530

    mmc: sd: query function modes for uhs cards
    
    SD cards which conform to Physical Layer Spec v3.01 can support
    additional Bus Speed Modes, Driver Strength, and Current Limit
    other than the default values. We use CMD6 mode 0 to read these
    additional card functions. The values read here will be used
    during UHS-I initialization steps.
    
    Tested by Zhangfei Gao with a Toshiba uhs card and general hs card,
    on mmp2 in SDMA mode.
    
    Signed-off-by: Arindam Nath <arindam.nath@amd.com>
    Reviewed-by: Philip Rakity <prakity@marvell.com>
    Tested-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 72a98681ef47..56f4d9234a66 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -67,6 +67,7 @@ struct mmc_ext_csd {
 
 struct sd_scr {
 	unsigned char		sda_vsn;
+	unsigned char		sda_spec3;
 	unsigned char		bus_widths;
 #define SD_SCR_BUS_WIDTH_1	(1<<0)
 #define SD_SCR_BUS_WIDTH_4	(1<<2)
@@ -80,6 +81,9 @@ struct sd_ssr {
 
 struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
+	unsigned int		sd3_bus_mode;
+	unsigned int		sd3_drv_type;
+	unsigned int		sd3_curr_limit;
 };
 
 struct sdio_cccr {

commit 6a7a6b45f454686a1549729bfbae31f0b3b595d6
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Tue Apr 12 15:06:53 2011 -0500

    mmc: quirks: Fix erase/trim for certain SanDisk cards.
    
    CMD38 argument is passed through EXT_CSD[113].
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0c7a58b14343..72a98681ef47 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -133,6 +133,7 @@ struct mmc_card {
 #define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
 #define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
 #define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
+#define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */

commit 371a689f64b0da140c3bcd3f55305ffa1c3a58ef
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon Apr 11 18:10:25 2011 -0500

    mmc: MMC boot partitions support.
    
    Allows device MMC boot partitions to be accessed. MMC partitions are
    treated effectively as separate block devices on the same MMC card.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 937f852cf01e..0c7a58b14343 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -48,7 +48,8 @@ struct mmc_ext_csd {
 	u8			sec_feature_support;
 	u8			rel_sectors;
 	u8			rel_param;
-	u8			bootconfig;
+	u8			part_config;
+	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
@@ -61,6 +62,7 @@ struct mmc_ext_csd {
 	bool			enhanced_area_en;	/* enable bit */
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
+	unsigned int		boot_size;		/* in bytes */
 };
 
 struct sd_scr {

commit 853c6cac0dc0d9d330deb5b48c19eebafaed1841
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Apr 12 12:59:09 2011 -0400

    mmc: quirks: fix truncation warnings
    
    Fix data truncation warnings: .manfid is not unsigned long:
    
    drivers/mmc/core/quirks.c:36: warning: large integer implicitly truncated to unsigned type
    drivers/mmc/core/quirks.c:40: warning: large integer implicitly truncated to unsigned type
    drivers/mmc/core/quirks.c:43: warning: large integer implicitly truncated to unsigned type
    drivers/mmc/core/quirks.c:46: warning: large integer implicitly truncated to unsigned type
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index c6513175f7f1..937f852cf01e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -180,7 +180,7 @@ struct mmc_fixup {
 	int data;
 };
 
-#define CID_MANFID_ANY (-1ul)
+#define CID_MANFID_ANY (-1u)
 #define CID_OEMID_ANY ((unsigned short) -1)
 #define CID_NAME_ANY (NULL)
 

commit 32780cd1350e651e68bdf33b7f5b009d21d5b794
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Mon Apr 11 17:02:15 2011 -0500

    mmc: quirks: Extends card quirks with MMC/SD quirks matching the CID.
    
    The current mechanism is SDIO-only. This allows us to create
    function-specific quirks, without creating messy Kconfig dependencies,
    or polluting core/ with function-specific code.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 2a7e54970c93..c6513175f7f1 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -11,6 +11,7 @@
 #define LINUX_MMC_CARD_H
 
 #include <linux/mmc/core.h>
+#include <linux/mod_devicetable.h>
 
 struct mmc_cid {
 	unsigned int		manfid;
@@ -157,7 +158,92 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 };
 
-void mmc_fixup_device(struct mmc_card *dev);
+/*
+ *  The world is not perfect and supplies us with broken mmc/sdio devices.
+ *  For at least some of these bugs we need a work-around.
+ */
+
+struct mmc_fixup {
+	/* CID-specific fields. */
+	const char *name;
+
+	/* Valid revision range */
+	u64 rev_start, rev_end;
+
+	unsigned int manfid;
+	unsigned short oemid;
+
+	/* SDIO-specfic fields. You can use SDIO_ANY_ID here of course */
+	u16 cis_vendor, cis_device;
+
+	void (*vendor_fixup)(struct mmc_card *card, int data);
+	int data;
+};
+
+#define CID_MANFID_ANY (-1ul)
+#define CID_OEMID_ANY ((unsigned short) -1)
+#define CID_NAME_ANY (NULL)
+
+#define END_FIXUP { 0 }
+
+#define _FIXUP_EXT(_name, _manfid, _oemid, _rev_start, _rev_end,	\
+		   _cis_vendor, _cis_device,				\
+		   _fixup, _data)					\
+	{						   \
+		.name = (_name),			   \
+		.manfid = (_manfid),			   \
+		.oemid = (_oemid),			   \
+		.rev_start = (_rev_start),		   \
+		.rev_end = (_rev_end),			   \
+		.cis_vendor = (_cis_vendor),		   \
+		.cis_device = (_cis_device),		   \
+		.vendor_fixup = (_fixup),		   \
+		.data = (_data),			   \
+	 }
+
+#define MMC_FIXUP_REV(_name, _manfid, _oemid, _rev_start, _rev_end,	\
+		      _fixup, _data)					\
+	_FIXUP_EXT(_name, _manfid,					\
+		   _oemid, _rev_start, _rev_end,			\
+		   SDIO_ANY_ID, SDIO_ANY_ID,				\
+		   _fixup, _data)					\
+
+#define MMC_FIXUP(_name, _manfid, _oemid, _fixup, _data) \
+	MMC_FIXUP_REV(_name, _manfid, _oemid, 0, -1ull, _fixup, _data)
+
+#define SDIO_FIXUP(_vendor, _device, _fixup, _data)			\
+	_FIXUP_EXT(CID_NAME_ANY, CID_MANFID_ANY,			\
+		    CID_OEMID_ANY, 0, -1ull,				\
+		   _vendor, _device,					\
+		   _fixup, _data)					\
+
+#define cid_rev(hwrev, fwrev, year, month)	\
+	(((u64) hwrev) << 40 |                  \
+	 ((u64) fwrev) << 32 |                  \
+	 ((u64) year) << 16 |                   \
+	 ((u64) month))
+
+#define cid_rev_card(card)		  \
+	cid_rev(card->cid.hwrev,	  \
+		    card->cid.fwrev,      \
+		    card->cid.year,	  \
+		    card->cid.month)
+
+/*
+ * This hook just adds a quirk unconditionally.
+ */
+static inline void __maybe_unused add_quirk(struct mmc_card *card, int data)
+{
+	card->quirks |= data;
+}
+
+/*
+ * This hook just removes a quirk unconditionally.
+ */
+static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
+{
+	card->quirks &= ~data;
+}
 
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
@@ -218,4 +304,7 @@ struct mmc_driver {
 extern int mmc_register_driver(struct mmc_driver *);
 extern void mmc_unregister_driver(struct mmc_driver *);
 
+extern void mmc_fixup_device(struct mmc_card *card,
+			     const struct mmc_fixup *table);
+
 #endif

commit 2059a02dcb84236f9db9197fa9b00418d7b8465b
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 18:02:25 2011 +0300

    mmc: add MMC_QUIRK_DISABLE_CD
    
    006ebd5d introduced sdio_disable_cd(), which disconnects the pull-up
    resistor on CD/DAT[3] (pin 1) of the card.
    
    Make it possible to start using sdio_disable_cd() by introducing
    MMC_QUIRK_DISABLE_CD.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 317a0029e7d7..2a7e54970c93 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -129,6 +129,7 @@ struct mmc_card {
 						/* (missing CIA registers) */
 #define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
 #define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
+#define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -184,6 +185,11 @@ static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
 }
 
+static inline int mmc_card_disable_cd(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_DISABLE_CD;
+}
+
 static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
 {
 	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;

commit eab4068795d670b065164096805cbf15a19e9690
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Apr 5 17:50:14 2011 +0300

    mmc: add MMC_QUIRK_NONSTD_FUNC_IF
    
    Introduce MMC_QUIRK_NONSTD_FUNC_IF to ignore the "SDIO Standard Function
    interface code" as indicated by the card's FBR, and instead treat all
    functions as non-standard interfaces.
    
    This is required to prevent standard drivers from facing
    errors when trying to communicate with SDIO cards that erroneously
    indicate standard function interface codes.
    
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index c4e96fa5fb2b..317a0029e7d7 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -128,6 +128,7 @@ struct mmc_card {
 #define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
 						/* (missing CIA registers) */
 #define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
+#define MMC_QUIRK_NONSTD_FUNC_IF (1<<4)		/* SDIO card has nonstd function interfaces */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -183,6 +184,11 @@ static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
 }
 
+static inline int mmc_card_nonstd_func_interface(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_NONSTD_FUNC_IF;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit f4c5522b0a8827f39f83f928961d87e081bfe71c
Author: Andrei Warkentin <andreiw@motorola.com>
Date:   Thu Mar 31 18:40:00 2011 -0500

    mmc: Reliable write support.
    
    Allows reliable writes to be used for MMC writes. Reliable writes are used
    to service write REQ_FUA/REQ_META requests. Handles both the legacy and
    the enhanced reliable write support in MMC cards.
    
    Signed-off-by: Andrei Warkentin <andreiw@motorola.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 557b73263390..c4e96fa5fb2b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -45,6 +45,8 @@ struct mmc_ext_csd {
 	u8			rev;
 	u8			erase_group_def;
 	u8			sec_feature_support;
+	u8			rel_sectors;
+	u8			rel_param;
 	u8			bootconfig;
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;

commit 41e2a4893566ced3c46af15df5b727326881e47d
Author: Philip Rakity <prakity@marvell.com>
Date:   Sat Mar 19 14:10:33 2011 -0400

    mmc: Ensure linux starts in eMMC user partition
    
    uBoot sometimes leaves eMMC pointing to the private boot partition.
    Ensure we always start looking at the user partition.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Bruce Clemens <bpclemens@marvell.com>
    Signed-off-by: Mark F. Brown <markb@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index adb4888248be..557b73263390 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -45,6 +45,7 @@ struct mmc_ext_csd {
 	u8			rev;
 	u8			erase_group_def;
 	u8			sec_feature_support;
+	u8			bootconfig;
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;

commit db9935000d95ae3f9702b7ff6ac0eef2319d8772
Author: Pierre Tardy <tardyp@gmail.com>
Date:   Sun Feb 6 19:03:47 2011 +0100

    mmc: add MMC_QUIRK_BROKEN_CLK_GATING
    
    Some sdio card are not following sdio standard, and do not work
    when the sdio bus's clock is gated.
    
    To keep functionnality for all legacy driver, we turn this quirk on
    for every sdio card.
    Drivers needs to disable the quirk manually when someone verifies that
    their supported card works with clock gating.
    
    Signed-off-by: Pierre Tardy <tardyp@gmail.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ad7413854f79..adb4888248be 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -124,6 +124,7 @@ struct mmc_card {
 						/* for byte mode */
 #define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
 						/* (missing CIA registers) */
+#define MMC_QUIRK_BROKEN_CLK_GATING (1<<3)	/* clock gating the sdio bus will make card fail */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */

commit 57f0adc7eaaf4315d568e72069dbe48aa7e20995
Author: Pierre Tardy <pierre.tardy@intel.com>
Date:   Sun Feb 6 19:03:46 2011 +0100

    mmc: add per device quirk placeholder
    
    Some cards have quirks valid for every platforms using current
    platform quirk hooks leads to a lot of code and debug duplication.
    
    So we inspire a bit from what exists in PCI subsystem and do our own
    per vendorid/deviceid quirk.  We still drop the complexity of the pci
    quirk system (with special section tables, and so on).
    That can be added later if needed.
    
    Signed-off-by: Pierre Tardy <pierre.tardy@intel.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4652cf9c5442..ad7413854f79 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -151,6 +151,8 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 };
 
+void mmc_fixup_device(struct mmc_card *dev);
+
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
 #define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)

commit 709de99df0ecf3102e7728fbd876a3591859f423
Author: Chuanxiao Dong <chuanxiao.dong@intel.com>
Date:   Sat Jan 22 04:09:41 2011 +0800

    mmc: export eMMC4.4 enhanced area details to sysfs
    
    Enhanced area feature is a new feature defined in eMMC4.4 standard. This
    user data area provides higher performance/reliability, at the expense
    of using twice the effective media space due to the area using SLC.
    
    The MMC driver now reads out the enhanced area offset and size and adds
    them to the device attributes in sysfs. Enabling the enhanced area can
    only be done once, and should be done in manufacturing. To use this
    feature, bit ERASE_GRP_DEF should also be set.
    
    Documentation/ABI/testing/sysfs-devices-mmc describes the two new
    attributes.
    
    Signed-off-by: Chuanxiao Dong <chuanxiao.dong@intel.com>
    Reviewed-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 8ce082781ccb..4652cf9c5442 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -54,6 +54,9 @@ struct mmc_ext_csd {
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
 	unsigned int		sec_erase_mult;	/* Secure erase multiplier */
 	unsigned int		trim_timeout;		/* In milliseconds */
+	bool			enhanced_area_en;	/* enable bit */
+	unsigned long long	enhanced_area_offset;	/* Units: Byte */
+	unsigned int		enhanced_area_size;	/* Units: KB */
 };
 
 struct sd_scr {

commit dfc13e8402c75e7c2e0a52e123c0500a3259866b
Author: Hanumath Prasad <hanumath.prasad@stericsson.com>
Date:   Thu Sep 30 17:37:23 2010 -0400

    mmc: MMC 4.4 DDR support
    
    Add support for Dual Data Rate MMC cards as defined in the 4.4
    specification.
    
    Signed-off-by: Hanumath Prasad <hanumath.prasad@stericsson.com>
    Cc: linux-mmc@vger.kernel.org
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Tested-by Zhangfei Gao <zhangfei.gao@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7bd49234cd88..8ce082781ccb 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -48,6 +48,7 @@ struct mmc_ext_csd {
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
+	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
 	unsigned int		hc_erase_timeout;	/* In milliseconds */
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
@@ -113,6 +114,7 @@ struct mmc_card {
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
+#define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -154,11 +156,13 @@ struct mmc_card {
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
+#define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
+#define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
 
 static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
 {

commit 265cdc900ce93c0cd2465d751fe75ff2e55e126e
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Fri Sep 17 20:32:25 2010 -0400

    mmc: rename dev_to_mmc_card() to mmc_dev_to_card()
    
    Global symbols should use their subsystem name in a prefixed fashion.
    
    Signed-off-by: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 71acf19ecaf3..7bd49234cd88 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -173,7 +173,7 @@ static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 
-#define dev_to_mmc_card(d)	container_of(d, struct mmc_card, dev)
+#define mmc_dev_to_card(d)	container_of(d, struct mmc_card, dev)
 
 #define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
 #define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)

commit 453722b9f7366e5b8b46101358dd7bcaef62b59d
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Fri Aug 20 10:46:46 2010 +0300

    mmc: make mmc_dev_to_card() macro public
    
    Conversion from struct device to struct mmc_card is used more than in one
    place.  Due to this it's better to have public macro for such thing.
    
    Signed-off-by: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 6b7525099e56..71acf19ecaf3 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -173,6 +173,8 @@ static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 
+#define dev_to_mmc_card(d)	container_of(d, struct mmc_card, dev)
+
 #define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
 #define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
 #define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)

commit dfe86cba7676d58db8de7e623f5e72f1b0d3ca35
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:46 2010 -0700

    mmc: add erase, secure erase, trim and secure trim operations
    
    SD/MMC cards tend to support an erase operation.  In addition, eMMC v4.4
    cards can support secure erase, trim and secure trim operations that are
    all variants of the basic erase command.
    
    SD/MMC device attributes "erase_size" and "preferred_erase_size" have been
    added.
    
    "erase_size" is the minimum size, in bytes, of an erase operation.  For
    MMC, "erase_size" is the erase group size reported by the card.  Note that
    "erase_size" does not apply to trim or secure trim operations where the
    minimum size is always one 512 byte sector.  For SD, "erase_size" is 512
    if the card is block-addressed, 0 otherwise.
    
    SD/MMC cards can erase an arbitrarily large area up to and
    including the whole card.  When erasing a large area it may
    be desirable to do it in smaller chunks for three reasons:
    
        1. A single erase command will make all other I/O on the card
           wait.  This is not a problem if the whole card is being erased, but
           erasing one partition will make I/O for another partition on the
           same card wait for the duration of the erase - which could be a
           several minutes.
    
        2. To be able to inform the user of erase progress.
    
        3. The erase timeout becomes too large to be very useful.
           Because the erase timeout contains a margin which is multiplied by
           the size of the erase area, the value can end up being several
           minutes for large areas.
    
    "erase_size" is not the most efficient unit to erase (especially for SD
    where it is just one sector), hence "preferred_erase_size" provides a good
    chunk size for erasing large areas.
    
    For MMC, "preferred_erase_size" is the high-capacity erase size if a card
    specifies one, otherwise it is based on the capacity of the card.
    
    For SD, "preferred_erase_size" is the allocation unit size specified by
    the card.
    
    "preferred_erase_size" is in bytes.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4d893eaf8174..6b7525099e56 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -31,6 +31,7 @@ struct mmc_csd {
 	unsigned int		tacc_ns;
 	unsigned int		r2w_factor;
 	unsigned int		max_dtr;
+	unsigned int		erase_size;		/* In sectors */
 	unsigned int		read_blkbits;
 	unsigned int		write_blkbits;
 	unsigned int		capacity;
@@ -42,9 +43,16 @@ struct mmc_csd {
 
 struct mmc_ext_csd {
 	u8			rev;
+	u8			erase_group_def;
+	u8			sec_feature_support;
 	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
+	unsigned int		hc_erase_size;		/* In sectors */
+	unsigned int		hc_erase_timeout;	/* In milliseconds */
+	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
+	unsigned int		sec_erase_mult;	/* Secure erase multiplier */
+	unsigned int		trim_timeout;		/* In milliseconds */
 };
 
 struct sd_scr {
@@ -54,6 +62,12 @@ struct sd_scr {
 #define SD_SCR_BUS_WIDTH_4	(1<<2)
 };
 
+struct sd_ssr {
+	unsigned int		au;			/* In sectors */
+	unsigned int		erase_timeout;		/* In milliseconds */
+	unsigned int		erase_offset;		/* In milliseconds */
+};
+
 struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
 };
@@ -106,6 +120,11 @@ struct mmc_card {
 #define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
 						/* (missing CIA registers) */
 
+	unsigned int		erase_size;	/* erase size in sectors */
+ 	unsigned int		erase_shift;	/* if erase unit is power 2 */
+ 	unsigned int		pref_erase;	/* in sectors */
+ 	u8			erased_byte;	/* value of erased bytes */
+
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -113,6 +132,7 @@ struct mmc_card {
 	struct mmc_csd		csd;		/* card specific */
 	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
 	struct sd_scr		scr;		/* extra SD information */
+	struct sd_ssr		ssr;		/* yet more SD information */
 	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
 
 	unsigned int		sdio_funcs;	/* number of SDIO functions */

commit 6f51be3d37dff73cf8db771df4169f4c2f1cbf66
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Tue Aug 10 18:01:50 2010 -0700

    sdio: allow non-standard SDIO cards
    
    There are some chips (like TI WL12xx series) that can be interfaced over
    SDIO but don't support the SDIO specification, meaning that they are
    missing CIA (Common I/O Area) with all it's registers.  Current Linux SDIO
    implementation relies on those registers to identify and configure the
    card, so non-standard cards can not function and cause lots of warnings
    from the core when it reads invalid data from non-existent registers.
    
    After this patch, init_card() host callback can now set new quirk
    MMC_QUIRK_NONSTD_SDIO, which means that SDIO core should not try to access
    any standard SDIO registers and rely on init_card() to fill all SDIO
    structures instead.  As those cards are usually embedded chips, all the
    required information can be obtained from machine board files by the host
    driver when it's called through init_card() callback.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Bob Copeland <me@bobcopeland.com>
    Cc: Kalle Valo <kvalo@adurom.com>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Kishore Kadiyala <kishore.kadiyala@ti.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 340d391aecbb..4d893eaf8174 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -103,6 +103,8 @@ struct mmc_card {
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
 						/* for byte mode */
+#define MMC_QUIRK_NONSTD_SDIO	(1<<2)		/* non-standard SDIO card attached */
+						/* (missing CIA registers) */
 
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */

commit 7310ece86ad7da027f85a37a0638164118a5d12f
Author: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Aug 10 18:01:40 2010 -0700

    mmc: implement SD-combo (IO+mem) support
    
    Signed-off-by: Michal Miroslaw <mirq-linux@rere.qmqm.pl>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index c83c7a7303fd..340d391aecbb 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -93,6 +93,7 @@ struct mmc_card {
 #define MMC_TYPE_MMC		0		/* MMC card */
 #define MMC_TYPE_SD		1		/* SD card */
 #define MMC_TYPE_SDIO		2		/* SDIO card */
+#define MMC_TYPE_SD_COMBO	3		/* SD combo (IO+mem) card */
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */

commit 6da24b786ed1963a7f872c1899627968c76d17d7
Author: Kyungmin Park <kmpark@infradead.org>
Date:   Tue Aug 10 18:01:36 2010 -0700

    mmc: recognize CSD structure
    
    The eMMC spec 4.4 and 4.3 + additional feature chips has CSD structure
    version 3 and version 3 have to check the CSD_STRUCTURE byte in the
    EXT_CSD register.
    
    Also fix EXT_CSD revision message.
    
    [akpm@linux-foundation.org: fix comment, per Chris Ball]
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Adrian Hunter <adrian.hunter@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d02d2c6e0cfe..c83c7a7303fd 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -24,6 +24,7 @@ struct mmc_cid {
 };
 
 struct mmc_csd {
+	unsigned char		structure;
 	unsigned char		mmca_vsn;
 	unsigned short		cmdclass;
 	unsigned short		tacc_clks;

commit 3fb7fb4a01d09f81d1daaf65e52d929734bd691f
Author: Bing Zhao <bzhao@marvell.com>
Date:   Fri Mar 5 13:43:25 2010 -0800

    sdio: add quirk to clamp byte mode transfer
    
    Some SDIO cards expect byte transfers not to exceed the configured block
    transfer size.  Add a quirk to that effect.
    
    Patches to make use of this quirk will be sent separately.
    
    Signed-off-by: Bing Zhao <bzhao@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 2ee22e8af110..d02d2c6e0cfe 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -99,6 +99,8 @@ struct mmc_card {
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
+#define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
+						/* for byte mode */
 
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
@@ -139,6 +141,11 @@ static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_LENIENT_FN0;
 }
 
+static inline int mmc_blksz_for_byte_mode(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit 7c979ec7135d96bbff34790bf4b85a8508ede7fc
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Sep 22 16:45:18 2009 -0700

    sdio: add MMC_QUIRK_LENIENT_FN0
    
    Normally writes to SDIO function 0 outside the vendor specific CCCR
    registers are prohibited.
    
    To support embedded devices that require writes to SDIO function 0 outside
    this range (e.g.  TI WL127x embedded sdio wifi device),
    MMC_QUIRK_LENIENT_FN0 is introduced.
    
    A card quirks field is added to `struct mmc_card' to support non-standard
    devices (e.g.  embedded sdio devices).
    
    [akpm@linux-foundation.org: code in C, not cpp!]
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 00db39cceadc..2ee22e8af110 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -97,6 +97,8 @@ struct mmc_card {
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
+	unsigned int		quirks; 	/* card quirks */
+#define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
@@ -132,6 +134,11 @@ struct mmc_card {
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 
+static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_LENIENT_FN0;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 

commit 006ebd5de13854d6250eecc76866bbfad1ff7daf
Author: Ohad Ben-Cohen <ohad@wizery.com>
Date:   Tue Sep 22 16:45:07 2009 -0700

    sdio: add CD disable support
    
    Add support to disconnect the pull-up resistor on CD/DAT[3] (pin 1)
    of the card. This may be desired on certain setups of boards,
    controllers and embedded sdio devices which do not need the card's
    pull-up. As a result, card detection is disabled and power is saved.
    
    [akpm@linux-foundation.org: simplify sdio_disable_cd() a bit]
    Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 58f59174c64b..00db39cceadc 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -64,7 +64,8 @@ struct sdio_cccr {
 				low_speed:1,
 				wide_bus:1,
 				high_power:1,
-				high_speed:1;
+				high_speed:1,
+				disable_cd:1;
 };
 
 struct sdio_cis {

commit b1ebe38456f7fe61a88af2844361e763ac6ea5ae
Author: Jarkko Lavinen <jarkko.lavinen@nokia.com>
Date:   Tue Sep 22 16:44:34 2009 -0700

    mmc: add mmc card sleep and awake support
    
    Add support for the new MMC command SLEEP_AWAKE.
    
    Signed-off-by: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Matt Fleming <matt@console-pimps.org>
    Cc: Ian Molton <ian@mnementh.co.uk>
    Cc: "Roberto A. Foglietta" <roberto.foglietta@gmail.com>
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Denis Karpov <ext-denis.2.karpov@nokia.com>
    Cc: Pierre Ossman <pierre@ossman.eu>
    Cc: Philip Langdale <philipl@overt.org>
    Cc: "Madhusudhan" <madhu.cr@ti.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 403aa505f27e..58f59174c64b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -40,6 +40,8 @@ struct mmc_csd {
 };
 
 struct mmc_ext_csd {
+	u8			rev;
+	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 };

commit d1b268630875a7713b5d468a0c03403c5b721c8e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Nov 8 21:37:46 2008 +0100

    mmc: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ee6e822d5994..403aa505f27e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -130,7 +130,7 @@ struct mmc_card {
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 
 #define mmc_card_name(c)	((c)->cid.prod_name)
-#define mmc_card_id(c)		((c)->dev.bus_id)
+#define mmc_card_id(c)		(dev_name(&(c)->dev))
 
 #define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
 #define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)

commit f4b7f927b531ca350cfc4ca1bdc3377dac7f9a32
Author: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
Date:   Thu Jul 24 14:18:58 2008 +0200

    mmc: Add per-card debugfs support
    
    For each card successfully added to the bus, create a subdirectory under
    the host's debugfs root with information about the card.
    
    At the moment, only a single file is added to the card directory for
    all cards: "state". It reflects the "state" field in struct mmc_card,
    indicating whether the card is present, readonly, etc.
    
    For MMC and SD cards (not SDIO), another file is added: "status".
    Reading this file will ask the card about its current status and
    return it. This can be useful if the card just refuses to respond to
    any commands, which might indicate that the card state is not what the
    MMC core thinks it is (due to a missing stop command, for example.)
    
    Signed-off-by: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0d508ac17d64..ee6e822d5994 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -111,6 +111,8 @@ struct mmc_card {
 	unsigned		num_info;	/* number of info strings */
 	const char		**info;		/* info strings */
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
+
+	struct dentry		*debugfs_root;
 };
 
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)

commit 759bdc7af450404382e937c76722ae8736daef92
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Sep 19 18:42:16 2007 +0200

    sdio: store vendor strings
    
    Store vendor strings found in CISTPL_VERS_1 so that function drivers
    can access them.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index a444431e28bd..0d508ac17d64 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -108,6 +108,8 @@ struct mmc_card {
 	struct sdio_cccr	cccr;		/* common card info */
 	struct sdio_cis		cis;		/* common tuple info */
 	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
+	unsigned		num_info;	/* number of info strings */
+	const char		**info;		/* info strings */
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 };
 

commit 1a632f8cdc33e7f8edca352164f0c96a75d08f08
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jul 30 15:15:30 2007 +0200

    sdio: split up common and function CIS parsing
    
    Add a more clean separation between global, common CIS information
    and the function specific one as we need the common information in
    places where no specific function is specified.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 520d9d29b3b2..a444431e28bd 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -65,8 +65,16 @@ struct sdio_cccr {
 				high_speed:1;
 };
 
+struct sdio_cis {
+	unsigned short		vendor;
+	unsigned short		device;
+	unsigned short		blksize;
+	unsigned int		max_dtr;
+};
+
 struct mmc_host;
 struct sdio_func;
+struct sdio_func_tuple;
 
 #define SDIO_MAX_FUNCS		7
 
@@ -98,7 +106,9 @@ struct mmc_card {
 
 	unsigned int		sdio_funcs;	/* number of SDIO functions */
 	struct sdio_cccr	cccr;		/* common card info */
+	struct sdio_cis		cis;		/* common tuple info */
 	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
+	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 };
 
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)

commit 35c66c19088bddb11110c124bad8abd4441a8421
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon Jun 11 20:25:43 2007 +0200

    sdio: read and decode interesting parts of the CCCR
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 9f5f74482d98..520d9d29b3b2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -55,6 +55,16 @@ struct sd_switch_caps {
 	unsigned int		hs_max_dtr;
 };
 
+struct sdio_cccr {
+	unsigned int		sdio_vsn;
+	unsigned int		sd_vsn;
+	unsigned int		multi_block:1,
+				low_speed:1,
+				wide_bus:1,
+				high_power:1,
+				high_speed:1;
+};
+
 struct mmc_host;
 struct sdio_func;
 
@@ -87,6 +97,7 @@ struct mmc_card {
 	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
 
 	unsigned int		sdio_funcs;	/* number of SDIO functions */
+	struct sdio_cccr	cccr;		/* common card info */
 	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
 };
 

commit e29a7d73f4277eb92aa64e17017dea33460828ef
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat May 26 13:48:18 2007 +0200

    mmc: basic SDIO device model
    
    Add the sdio bus type and basic device handling.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 43480ebebf9a..9f5f74482d98 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -56,6 +56,9 @@ struct sd_switch_caps {
 };
 
 struct mmc_host;
+struct sdio_func;
+
+#define SDIO_MAX_FUNCS		7
 
 /*
  * MMC device
@@ -73,6 +76,7 @@ struct mmc_card {
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
+
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -81,6 +85,9 @@ struct mmc_card {
 	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
 	struct sd_scr		scr;		/* extra SD information */
 	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
+
+	unsigned int		sdio_funcs;	/* number of SDIO functions */
+	struct sdio_func	*sdio_func[SDIO_MAX_FUNCS]; /* SDIO functions (devices) */
 };
 
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)

commit 5c4e6f1301649d5b29dd0f70e6da83e728ab5ca5
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Mon May 21 20:23:20 2007 +0200

    mmc: detect SDIO cards
    
    Really basic init sequence for SDIO cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index badf702fcff4..43480ebebf9a 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -67,6 +67,7 @@ struct mmc_card {
 	unsigned int		type;		/* card type */
 #define MMC_TYPE_MMC		0		/* MMC card */
 #define MMC_TYPE_SD		1		/* SD card */
+#define MMC_TYPE_SDIO		2		/* SDIO card */
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
@@ -84,6 +85,7 @@ struct mmc_card {
 
 #define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
+#define mmc_card_sdio(c)	((c)->type == MMC_TYPE_SDIO)
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)

commit bd766312618d2ecc85bce663f95faec601447ecb
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue May 1 16:11:57 2007 +0200

    mmc: remove old card states
    
    Remove card states that no longer make any sense.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 800425e05165..badf702fcff4 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -69,11 +69,9 @@ struct mmc_card {
 #define MMC_TYPE_SD		1		/* SD card */
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
-#define MMC_STATE_DEAD		(1<<1)		/* device no longer in stack */
-#define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
-#define MMC_STATE_READONLY	(1<<3)		/* card is read-only */
-#define MMC_STATE_HIGHSPEED	(1<<4)		/* card is in high speed mode */
-#define MMC_STATE_BLOCKADDR	(1<<5)		/* card uses block-addressing */
+#define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
+#define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
+#define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -88,15 +86,11 @@ struct mmc_card {
 #define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
-#define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
-#define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
-#define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
-#define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)

commit aaac1b470bd0dccb30912356617069dc6199cc80
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Feb 28 15:33:10 2007 +0100

    mmc: Move core functions to subdir
    
    Create a "core" subdirectory to house the central bus handling
    functions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7d98990ac94e..800425e05165 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -10,7 +10,7 @@
 #ifndef LINUX_MMC_CARD_H
 #define LINUX_MMC_CARD_H
 
-#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
 
 struct mmc_cid {
 	unsigned int		manfid;

commit b855885e3b60cf6f9452848712a62517b94583eb
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Jan 3 19:47:29 2007 +0100

    mmc: deprecate mmc bus topology
    
    The classic MMC bus was defined as multi card bus
    system, which is reflected in the design in the MMC
    layer.
    
    When SD showed up, the bus topology was abandoned
    and a star topology (one card per host) was mandated.
    MMC version 4 has followed this, officially deprecating
    the bus topology.
    
    As we do not have any known users of the bus
    topology we can remove support for it. This will
    simplify the code and rectify some incorrect
    assumptions in the newer additions.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 1ca50542ce19..7d98990ac94e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -61,7 +61,6 @@ struct mmc_host;
  * MMC device
  */
 struct mmc_card {
-	struct list_head	node;		/* node in hosts devices list */
 	struct mmc_host		*host;		/* the host this device belongs to */
 	struct device		dev;		/* the device */
 	unsigned int		rca;		/* relative card address of device */
@@ -123,11 +122,4 @@ struct mmc_driver {
 extern int mmc_register_driver(struct mmc_driver *);
 extern void mmc_unregister_driver(struct mmc_driver *);
 
-static inline int mmc_card_claim_host(struct mmc_card *card)
-{
-	return __mmc_claim_host(card->host, card);
-}
-
-#define mmc_card_release_host(c)	mmc_release_host((c)->host)
-
 #endif

commit 9c2c0af950345e63ef86f28eca44333a1e1e709b
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Tue Dec 26 15:25:58 2006 +0100

    mmc: add type field to cards
    
    Split out the type of card into its own field as it hardly
    qualifies as a state.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 5d9896c260a2..1ca50542ce19 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -65,14 +65,16 @@ struct mmc_card {
 	struct mmc_host		*host;		/* the host this device belongs to */
 	struct device		dev;		/* the device */
 	unsigned int		rca;		/* relative card address of device */
+	unsigned int		type;		/* card type */
+#define MMC_TYPE_MMC		0		/* MMC card */
+#define MMC_TYPE_SD		1		/* SD card */
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_DEAD		(1<<1)		/* device no longer in stack */
 #define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
-#define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
-#define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
-#define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in high speed mode */
-#define MMC_STATE_BLOCKADDR	(1<<6)		/* card uses block-addressing */
+#define MMC_STATE_READONLY	(1<<3)		/* card is read-only */
+#define MMC_STATE_HIGHSPEED	(1<<4)		/* card is in high speed mode */
+#define MMC_STATE_BLOCKADDR	(1<<5)		/* card uses block-addressing */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -83,10 +85,12 @@ struct mmc_card {
 	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
 };
 
+#define mmc_card_mmc(c)		((c)->type == MMC_TYPE_MMC)
+#define mmc_card_sd(c)		((c)->type == MMC_TYPE_SD)
+
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
 #define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
-#define mmc_card_sd(c)		((c)->state & MMC_STATE_SDCARD)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
@@ -94,7 +98,6 @@ struct mmc_card {
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
 #define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
-#define mmc_card_set_sd(c)	((c)->state |= MMC_STATE_SDCARD)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)

commit 85a18ad93ec66888d85758630019b10a84257f3c
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Sat Feb 17 22:15:27 2007 +0100

    mmc: MMC sector based cards
    
    Support for MMC 4.2 sector based cards. This tweaks the init a
    bit and reads a new field out of the EXT_CSD.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e45712acfac5..5d9896c260a2 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -41,6 +41,7 @@ struct mmc_csd {
 
 struct mmc_ext_csd {
 	unsigned int		hs_max_dtr;
+	unsigned int		sectors;
 };
 
 struct sd_scr {

commit fba68bd2dab1ac99af3c5a963ec9581cfa9f1725
Author: Philip Langdale <philipl@overt.org>
Date:   Thu Jan 4 06:57:32 2007 -0800

    mmc: Add support for SDHC cards
    
    Thanks to the generous donation of an SDHC card by John Gilmore, and
    the surprisingly enlightened decision by the SD Card Association to
    publish useful specs, I've been able to bash out support for SDHC. The
    changes are not too profound:
    
    i) Add a card flag indicating the card uses block level addressing and
    check it in the block driver. As we never took advantage of byte-level
    addressing, this simply involves skipping the block -> byte
    translation when sending commands.
    
    ii) The layout of the CSD is changed - a set of fields are discarded
    to make space for a larger C_SIZE. We did not reference any of the
    discarded fields except those related to the C_SIZE.
    
    iii) Read and write timeouts are fixed values and not calculated from
    CSD values.
    
    iv) Before invoking SEND_APP_OP_COND, we must invoke the new
    SEND_IF_COND to inform the card we support SDHC.
    
    Signed-off-by: Philipl Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index d0e6a5497614..e45712acfac5 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -71,6 +71,7 @@ struct mmc_card {
 #define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
 #define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in high speed mode */
+#define MMC_STATE_BLOCKADDR	(1<<6)		/* card uses block-addressing */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -87,6 +88,7 @@ struct mmc_card {
 #define mmc_card_sd(c)		((c)->state & MMC_STATE_SDCARD)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
+#define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
@@ -94,6 +96,7 @@ struct mmc_card {
 #define mmc_card_set_sd(c)	((c)->state |= MMC_STATE_SDCARD)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
+#define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		((c)->dev.bus_id)

commit 7ccd266e676a3f0c6f8f897f58b684cac3dd1650
Author: Pierre Ossman <drzeus@drzeus.cx>
Date:   Wed Nov 8 23:03:10 2006 +0100

    mmc: Support for high speed SD cards
    
    Modern SD cards support a clock speed of 50 MHz. Make sure we test for
    this capability and do the song and dance required to activate it.
    
    Activating high speed support actually modifies the TRAN_SPEED field
    of the CSD. But as the spec says that the cards must report 50 MHz,
    we might as well skip re-reading the CSD.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ce25256f80d5..d0e6a5497614 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -50,6 +50,10 @@ struct sd_scr {
 #define SD_SCR_BUS_WIDTH_4	(1<<2)
 };
 
+struct sd_switch_caps {
+	unsigned int		hs_max_dtr;
+};
+
 struct mmc_host;
 
 /*
@@ -66,7 +70,7 @@ struct mmc_card {
 #define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
 #define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
 #define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
-#define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in mmc4 highspeed mode */
+#define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in high speed mode */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
@@ -74,6 +78,7 @@ struct mmc_card {
 	struct mmc_csd		csd;		/* card specific */
 	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
 	struct sd_scr		scr;		/* extra SD information */
+	struct sd_switch_caps	sw_caps;	/* switch (CMD6) caps */
 };
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)

commit bce40a36de574376f41f1ff3c4d212a7da2a3c90
Author: Philip Langdale <philipl@overt.org>
Date:   Sat Oct 21 12:35:02 2006 +0200

    [PATCH] mmc: Add support for mmc v4 high speed mode
    
    This adds support for the high-speed modes defined by mmc v4
    (assuming the host controller is up to it). On a TI sdhci controller,
    it improves read speed from 1.3MBps to 2.3MBps. The TI controller can
    only go up to 24MHz, but everything helps. Another person has taken
    this basic patch and used it on a Nokia 770 to get a bigger boost
    because that controller can run at 48MHZ.
    
    Signed-off-by: Philip Langdale <philipl@overt.org>
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 991a37382a22..ce25256f80d5 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -39,6 +39,10 @@ struct mmc_csd {
 				write_misalign:1;
 };
 
+struct mmc_ext_csd {
+	unsigned int		hs_max_dtr;
+};
+
 struct sd_scr {
 	unsigned char		sda_vsn;
 	unsigned char		bus_widths;
@@ -62,11 +66,13 @@ struct mmc_card {
 #define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
 #define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
 #define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
+#define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in mmc4 highspeed mode */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
 	struct mmc_cid		cid;		/* card identification */
 	struct mmc_csd		csd;		/* card specific */
+	struct mmc_ext_csd	ext_csd;	/* mmc v4 extended card specific */
 	struct sd_scr		scr;		/* extra SD information */
 };
 
@@ -75,12 +81,14 @@ struct mmc_card {
 #define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
 #define mmc_card_sd(c)		((c)->state & MMC_STATE_SDCARD)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
+#define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
 #define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
 #define mmc_card_set_sd(c)	((c)->state |= MMC_STATE_SDCARD)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
+#define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		((c)->dev.bus_id)

commit 37be4e7809e0581db85387e126ae4da68c3d6286
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 2 17:24:59 2006 +0100

    [MMC] extend data timeout for writes
    
    The CSD contains a "read2write factor" which determines the multiplier to
    be applied to the read timeout to obtain the write timeout.  We were
    ignoring this parameter, resulting in the possibility for writes being
    timed out too early.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 30dd978c1ec8..991a37382a22 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -28,6 +28,7 @@ struct mmc_csd {
 	unsigned short		cmdclass;
 	unsigned short		tacc_clks;
 	unsigned int		tacc_ns;
+	unsigned int		r2w_factor;
 	unsigned int		max_dtr;
 	unsigned int		read_blkbits;
 	unsigned int		write_blkbits;

commit ce11a161c11868f268964274edc7a26a3e063e08
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 12:40:39 2006 +0000

    [MMC] Fix missing ','
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7f7d40684288..30dd978c1ec8 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -34,7 +34,7 @@ struct mmc_csd {
 	unsigned int		capacity;
 	unsigned int		read_partial:1,
 				read_misalign:1,
-				write_partial:1
+				write_partial:1,
 				write_misalign:1;
 };
 

commit a6f6c96b65d7f65a7a7bf5cbe874eda182a6b2cc
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Jan 3 22:38:44 2006 +0000

    [MMC] Improve MMC card block size selection
    
    Select a block size for IO based on the read and write block size
    combinations, and whether the card supports partial block reads
    and/or partial block writes.
    
    If we are able to satisfy block reads but not block writes, mark
    the device read only.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 18fc77f682de..7f7d40684288 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -30,7 +30,12 @@ struct mmc_csd {
 	unsigned int		tacc_ns;
 	unsigned int		max_dtr;
 	unsigned int		read_blkbits;
+	unsigned int		write_blkbits;
 	unsigned int		capacity;
+	unsigned int		read_partial:1,
+				read_misalign:1,
+				write_partial:1
+				write_misalign:1;
 };
 
 struct sd_scr {

commit b57c43ad81602589afca3948a5a7121e40026e17
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:53 2005 -0700

    [PATCH] sd: SCR register
    
    Read the SD specific SCR register from the card.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 0e9ec01b9c5b..18fc77f682de 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -33,6 +33,13 @@ struct mmc_csd {
 	unsigned int		capacity;
 };
 
+struct sd_scr {
+	unsigned char		sda_vsn;
+	unsigned char		bus_widths;
+#define SD_SCR_BUS_WIDTH_1	(1<<0)
+#define SD_SCR_BUS_WIDTH_4	(1<<2)
+};
+
 struct mmc_host;
 
 /*
@@ -51,8 +58,10 @@ struct mmc_card {
 #define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
+	u32			raw_scr[2];	/* raw card SCR */
 	struct mmc_cid		cid;		/* card identification */
 	struct mmc_csd		csd;		/* card specific */
+	struct sd_scr		scr;		/* extra SD information */
 };
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)

commit a00fc09029f02ca833cf90e5d5625f08c4ac4f51
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:52 2005 -0700

    [PATCH] sd: read-only switch
    
    Support for the read-only switch on SD cards which must be enforced by the
    host.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 538e8c86336c..0e9ec01b9c5b 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -48,6 +48,7 @@ struct mmc_card {
 #define MMC_STATE_DEAD		(1<<1)		/* device no longer in stack */
 #define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
 #define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
+#define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	struct mmc_cid		cid;		/* card identification */
@@ -58,11 +59,13 @@ struct mmc_card {
 #define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
 #define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
 #define mmc_card_sd(c)		((c)->state & MMC_STATE_SDCARD)
+#define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
 #define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
 #define mmc_card_set_sd(c)	((c)->state |= MMC_STATE_SDCARD)
+#define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		((c)->dev.bus_id)

commit 335eadf2ef6a1122a720aea98e758e5d431da87d
Author: Pierre Ossman <drzeus-list@drzeus.cx>
Date:   Tue Sep 6 15:18:50 2005 -0700

    [PATCH] sd: initialize SD cards
    
    Support for the Secure Digital protocol in the MMC layer.
    
    A summary of the legal issues surrounding SD cards, as understood by yours
    truly:
    
    Members of the Secure Digital Association, hereafter SDA, are required to sign
    a NDA[1] before given access to any specifications.  It has been speculated
    that including an SD implementation would forbid these members to redistribute
    Linux.  This is the basic problem with SD support so it is unclear if it even
    is a problem since it has no effect on those of us that aren't members.
    
    The SDA doesn't seem to enforce these rules though since the patches included
    here are based on documentation made public by some of the members.  The most
    complete specs[2] are actually released by Sandisk, one of the founding
    companies of the SDA.
    
    Because of this the NDA is considered a non-issue by most involved in the
    discussions concerning these patches.  It might be that the SDA is only
    interested in protecting the so called "secure" bits of SD, which so far
    hasn't been found in any public spec.  (The card is split into two sections,
    one "normal" and one "secure" which has an access scheme similar to TPM:s).
    
    (As a side note, Microsoft is working to make things easier for us since they
    want to be able to include the source code for a SD driver in one of their
    development kits.  HP is making sure that the new NDA will allow a Linux
    implementation.  So far only the SDIO specs have been opened up[3].  More will
    hopefully follow.)
    
     [1] http://www.sdcard.org/membership/images/ippolicy.pdf
     [2] http://www.sandisk.com/pdf/oem/ProdManualSDCardv1.9.pdf
     [3] http://www.sdcard.org/sdio/Simplified%20SDIO%20Card%20Specification.pdf
    
    This patch contains the central parts of the SD support.  If no MMC cards are
    found on a bus then the MMC layer proceeds looking for SD cards.  Helper
    functions are extended to handle the special needs of SD cards.
    
    Signed-off-by: Pierre Ossman <drzeus@drzeus.cx>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index aefedf04b9bb..538e8c86336c 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -47,6 +47,7 @@ struct mmc_card {
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_DEAD		(1<<1)		/* device no longer in stack */
 #define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
+#define MMC_STATE_SDCARD	(1<<3)		/* is an SD card */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	struct mmc_cid		cid;		/* card identification */
@@ -56,10 +57,12 @@ struct mmc_card {
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
 #define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
+#define mmc_card_sd(c)		((c)->state & MMC_STATE_SDCARD)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
 #define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
+#define mmc_card_set_sd(c)	((c)->state |= MMC_STATE_SDCARD)
 
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		((c)->dev.bus_id)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
new file mode 100644
index 000000000000..aefedf04b9bb
--- /dev/null
+++ b/include/linux/mmc/card.h
@@ -0,0 +1,92 @@
+/*
+ *  linux/include/linux/mmc/card.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Card driver specific definitions.
+ */
+#ifndef LINUX_MMC_CARD_H
+#define LINUX_MMC_CARD_H
+
+#include <linux/mmc/mmc.h>
+
+struct mmc_cid {
+	unsigned int		manfid;
+	char			prod_name[8];
+	unsigned int		serial;
+	unsigned short		oemid;
+	unsigned short		year;
+	unsigned char		hwrev;
+	unsigned char		fwrev;
+	unsigned char		month;
+};
+
+struct mmc_csd {
+	unsigned char		mmca_vsn;
+	unsigned short		cmdclass;
+	unsigned short		tacc_clks;
+	unsigned int		tacc_ns;
+	unsigned int		max_dtr;
+	unsigned int		read_blkbits;
+	unsigned int		capacity;
+};
+
+struct mmc_host;
+
+/*
+ * MMC device
+ */
+struct mmc_card {
+	struct list_head	node;		/* node in hosts devices list */
+	struct mmc_host		*host;		/* the host this device belongs to */
+	struct device		dev;		/* the device */
+	unsigned int		rca;		/* relative card address of device */
+	unsigned int		state;		/* (our) card state */
+#define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
+#define MMC_STATE_DEAD		(1<<1)		/* device no longer in stack */
+#define MMC_STATE_BAD		(1<<2)		/* unrecognised device */
+	u32			raw_cid[4];	/* raw card CID */
+	u32			raw_csd[4];	/* raw card CSD */
+	struct mmc_cid		cid;		/* card identification */
+	struct mmc_csd		csd;		/* card specific */
+};
+
+#define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
+#define mmc_card_dead(c)	((c)->state & MMC_STATE_DEAD)
+#define mmc_card_bad(c)		((c)->state & MMC_STATE_BAD)
+
+#define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
+#define mmc_card_set_dead(c)	((c)->state |= MMC_STATE_DEAD)
+#define mmc_card_set_bad(c)	((c)->state |= MMC_STATE_BAD)
+
+#define mmc_card_name(c)	((c)->cid.prod_name)
+#define mmc_card_id(c)		((c)->dev.bus_id)
+
+#define mmc_list_to_card(l)	container_of(l, struct mmc_card, node)
+#define mmc_get_drvdata(c)	dev_get_drvdata(&(c)->dev)
+#define mmc_set_drvdata(c,d)	dev_set_drvdata(&(c)->dev, d)
+
+/*
+ * MMC device driver (e.g., Flash card, I/O card...)
+ */
+struct mmc_driver {
+	struct device_driver drv;
+	int (*probe)(struct mmc_card *);
+	void (*remove)(struct mmc_card *);
+	int (*suspend)(struct mmc_card *, pm_message_t);
+	int (*resume)(struct mmc_card *);
+};
+
+extern int mmc_register_driver(struct mmc_driver *);
+extern void mmc_unregister_driver(struct mmc_driver *);
+
+static inline int mmc_card_claim_host(struct mmc_card *card)
+{
+	return __mmc_claim_host(card->host, card);
+}
+
+#define mmc_card_release_host(c)	mmc_release_host((c)->host)
+
+#endif
