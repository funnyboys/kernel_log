commit 84a14ae8c44fb4828a05f363a09c3261472de00e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:07 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 178
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 24 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170026.162703968@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index a7baa29484c3..e25533b95d9f 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -1,14 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * include/linux/mmc/sh_mmcif.h
  *
  * platform data for eMMC driver
  *
  * Copyright (C) 2010 Renesas Solutions Corp.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License.
- *
  */
 
 #ifndef LINUX_MMC_SH_MMCIF_H

commit dba4bb484e9e495478f2bcf474393d33f7e0ec27
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 30 13:47:19 2016 +0100

    mmc: sh_mmcif: Remove unused clk_ctrl2_present from the platform data
    
    There are currently no users of the clk_ctrl2_present member from the
    platform data, so let's remove it.
    
    Note, as some of the sh_mmcif variants may support clk_ctrl2, let's keep
    the current code in the driver, which deals with this. For future support,
    we should invent a DT binding instead, but let's leave that until it's
    needed.
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 384b86b90473..a7baa29484c3 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -34,7 +34,6 @@
 struct sh_mmcif_plat_data {
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
-	bool			clk_ctrl2_present : 1;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;
 	u32			ocr;

commit 8020f71117042ed82287e4f51c48b57ce4c783df
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 30 13:47:18 2016 +0100

    mmc: sh_mmcif: Remove unused ccs_unsupported from the platform data
    
    There are currently no users of the ccs_unsupported member from the
    platform data, so let's remove it.
    
    Note, as some of the sh_mmcif variants may not support ccs, let's keep the
    current code in the driver, which deals with this. For future support, we
    should invent a DT binding instead, but let's leave that until it's needed.
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 7cafc95a2b4e..384b86b90473 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -34,7 +34,6 @@
 struct sh_mmcif_plat_data {
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
-	bool			ccs_unsupported : 1;
 	bool			clk_ctrl2_present : 1;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;

commit 5957eeba530747e9d77daf2f300a186758be51d9
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 30 13:47:17 2016 +0100

    mmc: sh_mmcif: Remove unused ->get_cd() platform callback
    
    Removing the callback also enables us to remove the sh_mmcif_get_cd()
    altogether, as we convert to use mmc_gpio_get_cd() to the same kind of
    work.
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 5ce5a2c1a1f5..7cafc95a2b4e 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -32,7 +32,6 @@
  */
 
 struct sh_mmcif_plat_data {
-	int (*get_cd)(struct platform_device *pdef);
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
 	bool			ccs_unsupported : 1;

commit 95cc4df716a210a19f0611215c49484d460250fd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 30 13:47:16 2016 +0100

    mmc: sh_mmcif: Remove unused use_cd_gpio/cd_gpio from platform data
    
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index ccd8fb2cad52..5ce5a2c1a1f5 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -35,10 +35,8 @@ struct sh_mmcif_plat_data {
 	int (*get_cd)(struct platform_device *pdef);
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
-	bool			use_cd_gpio : 1;
 	bool			ccs_unsupported : 1;
 	bool			clk_ctrl2_present : 1;
-	unsigned int		cd_gpio;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;
 	u32			ocr;

commit 6d6fd3674259d16b735c961743ff28870c46cedc
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jul 10 21:21:13 2013 +0200

    mmc: sh_mmcif: revision-specific CLK_CTRL2 handling
    
    Some newer MMCIF IP revisions contain a CE_CLK_CTRL2 register, that has to
    be set for proper operation. Support for this feature is added in a way to
    preserve the current behaviour by default, i.e. when it is not enabled
    in platform data. Patch is based on work by Nobuyuki HIRAI.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski+renesas@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 197ed91f6a0c..ccd8fb2cad52 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -37,6 +37,7 @@ struct sh_mmcif_plat_data {
 	unsigned int		slave_id_rx;
 	bool			use_cd_gpio : 1;
 	bool			ccs_unsupported : 1;
+	bool			clk_ctrl2_present : 1;
 	unsigned int		cd_gpio;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;
@@ -60,6 +61,7 @@ struct sh_mmcif_plat_data {
 #define MMCIF_CE_INT_MASK	0x00000044
 #define MMCIF_CE_HOST_STS1	0x00000048
 #define MMCIF_CE_HOST_STS2	0x0000004C
+#define MMCIF_CE_CLK_CTRL2	0x00000070
 #define MMCIF_CE_VERSION	0x0000007C
 
 /* CE_BUF_ACC */

commit 967bcb77177cda1a426fdb2350e6ec61bcf5b5eb
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jul 10 21:21:12 2013 +0200

    mmc: sh_mmcif: revision-specific Command Completion Signal handling
    
    Some earlier MMCIF IP revisions contained Command Completion Signal
    support, which has been dropped again in modern versions. Sopport for
    this feature is added in a way to preserve the current behaviour by
    default, i.e. when it is not enabled in platform data. Patch is based
    on work by Nobuyuki HIRAI.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski+renesas@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index c4880ffb6cce..197ed91f6a0c 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -36,6 +36,7 @@ struct sh_mmcif_plat_data {
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
 	bool			use_cd_gpio : 1;
+	bool			ccs_unsupported : 1;
 	unsigned int		cd_gpio;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;

commit d00cadacbe47d4883b0d5e38aa73a3f4e171d37e
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Fri Aug 2 14:48:02 2013 +0200

    mmc: sh_mmcif: move header include from header into .c
    
    sh_dma.h isn't needed in sh_mmcif.h, move it into sh_mmcif.c.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski+renesas@gmail.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 767fac5a7d93..c4880ffb6cce 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -16,7 +16,6 @@
 
 #include <linux/io.h>
 #include <linux/platform_device.h>
-#include <linux/sh_dma.h>
 
 /*
  * MMCIF : CE_CLK_CTRL [19:16]

commit 83a0c7797e96e103bb3b6fcf8afb7b65dc7fc68e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Aug 8 12:38:40 2013 +0200

    mmc: sh_mmcif: Remove .set_pwr() callback from platform data
    
    The .set_pwr() callback isn't used anymore as all platforms register
    GPIO-controlled regulators. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 39011eb42930..767fac5a7d93 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -33,7 +33,6 @@
  */
 
 struct sh_mmcif_plat_data {
-	void (*set_pwr)(struct platform_device *pdev, int state);
 	int (*get_cd)(struct platform_device *pdef);
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;

commit dcbfaf36c1933d88565501ff13feb0f4b2d38735
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Thu Aug 8 12:38:39 2013 +0200

    mmc: sh_mmcif: Remove .down_pwr() callback from platform data
    
    The callback isn't used by the driver and isn't initialized by board
    code. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index e7d5dd67bb74..39011eb42930 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -34,7 +34,6 @@
 
 struct sh_mmcif_plat_data {
 	void (*set_pwr)(struct platform_device *pdev, int state);
-	void (*down_pwr)(struct platform_device *pdev);
 	int (*get_cd)(struct platform_device *pdef);
 	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;

commit c511dc1fb6bee58363eb203d53393784f2589d02
Merge: 9161c3b796a2 634332502366
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 17:12:54 2012 -0700

    Merge branch 'next' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull slave-dmaengine update from Vinod Koul:
     "This time we have a new dmaengine driver from the tegra folks.  Also
      we have Guennadi's cleanup of sh drivers which incudes a library for
      sh drivers.  And the usual odd fixes in bunch of drivers and some nice
      cleanup of dw_dmac from Andy."
    
    Fix up conflicts in drivers/mmc/host/sh_mmcif.c
    
    * 'next' of git://git.infradead.org/users/vkoul/slave-dma: (46 commits)
      dmaengine: Cleanup logging messages
      mmc: sh_mmcif: switch to the new DMA channel allocation and configuration
      dma: sh: provide a migration path for slave drivers to stop using .private
      dma: sh: use an integer slave ID to improve API compatibility
      dmaengine: shdma: prepare to stop using struct dma_chan::private
      sh: remove unused DMA device pointer from SIU platform data
      ASoC: siu: don't use DMA device for channel filtering
      dmaengine: shdma: (cosmetic) simplify a static function
      dmaengine: at_hdmac: add a few const qualifiers
      dw_dmac: use 'u32' for LLI structure members, not dma_addr_t
      dw_dmac: mark dwc_dump_lli inline
      dma: mxs-dma: Export missing symbols from mxs-dma.c
      dma: shdma: convert to the shdma base library
      ASoC: fsi: prepare for conversion to the shdma base library
      usb: renesas_usbhs: prepare for conversion to the shdma base library
      ASoC: siu: prepare for conversion to the shdma base library
      serial: sh-sci: prepare for conversion to the shdma base library
      mmc: sh_mobile_sdhi: prepare for conversion to the shdma base library
      mmc: sh_mmcif: remove unneeded struct sh_mmcif_dma, prepare to shdma conversion
      dma: shdma: prepare for conversion to the shdma base library
      ...

commit e480606ad43bb72fd82a9bd99cdcf21829a6e9c0
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Jun 14 14:24:35 2012 +0200

    mmc: sh_mmcif: support generic card-detection
    
    Extend the sh_mmcif driver to support GPIO card detection, provided by the
    slot function module. The original .get_cd() platform callback is also
    preserved for now.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 05f0e3db1c12..c2f73cbb4d5c 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -44,6 +44,8 @@ struct sh_mmcif_plat_data {
 	struct sh_mmcif_dma	*dma;		/* Deprecated. Instead */
 	unsigned int		slave_id_tx;	/* use embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
+	bool			use_cd_gpio : 1;
+	unsigned int		cd_gpio;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;
 	u32			ocr;

commit 916001fe33b7b4dc797f7b29ec8bc346c4369fa6
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed May 9 17:09:15 2012 +0200

    mmc: sh_mmcif: remove unneeded struct sh_mmcif_dma, prepare to shdma conversion
    
    Now that all users have been updated to use the embedded in struct
    sh_mmcif_plat_data DMA slave IDs, struct sh_mmcif_dma is no longer needed
    and can be removed. This also makes preparation to the shdma base library
    conversion easier.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Chris Ball <cjb@laptop.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 05f0e3db1c12..c37956ccf02e 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -32,17 +32,11 @@
  * 1111 : Peripheral clock (sup_pclk set '1')
  */
 
-struct sh_mmcif_dma {
-	struct sh_dmae_slave chan_priv_tx;
-	struct sh_dmae_slave chan_priv_rx;
-};
-
 struct sh_mmcif_plat_data {
 	void (*set_pwr)(struct platform_device *pdev, int state);
 	void (*down_pwr)(struct platform_device *pdev);
 	int (*get_cd)(struct platform_device *pdef);
-	struct sh_mmcif_dma	*dma;		/* Deprecated. Instead */
-	unsigned int		slave_id_tx;	/* use embedded slave_id_[tr]x */
+	unsigned int		slave_id_tx;	/* embedded slave_id_[tr]x */
 	unsigned int		slave_id_rx;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;

commit 135111cc5595c6a24dd826d503e2d2bae92da1c4
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Fri Mar 16 12:49:04 2012 +0100

    mmc: sh_mmcif: simplify bitmask macros
    
    Purely cosmetic readability improvement, no functional change.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 04ff452bf5c3..05f0e3db1c12 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -77,18 +77,15 @@ struct sh_mmcif_plat_data {
 
 /* CE_CLK_CTRL */
 #define CLK_ENABLE		(1 << 24) /* 1: output mmc clock */
-#define CLK_CLEAR		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
-#define CLK_SUP_PCLK		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
-#define CLKDIV_4		(1<<16) /* mmc clock frequency.
-					 * n: bus clock/(2^(n+1)) */
-#define CLKDIV_256		(7<<16) /* mmc clock frequency. (see above) */
-#define SRSPTO_256		((1 << 13) | (0 << 12)) /* resp timeout */
-#define SRBSYTO_29		((1 << 11) | (1 << 10) |	\
-				 (1 << 9) | (1 << 8)) /* resp busy timeout */
-#define SRWDTO_29		((1 << 7) | (1 << 6) |		\
-				 (1 << 5) | (1 << 4)) /* read/write timeout */
-#define SCCSTO_29		((1 << 3) | (1 << 2) |		\
-				 (1 << 1) | (1 << 0)) /* ccs timeout */
+#define CLK_CLEAR		(0xf << 16)
+#define CLK_SUP_PCLK		(0xf << 16)
+#define CLKDIV_4		(1 << 16) /* mmc clock frequency.
+					   * n: bus clock/(2^(n+1)) */
+#define CLKDIV_256		(7 << 16) /* mmc clock frequency. (see above) */
+#define SRSPTO_256		(2 << 12) /* resp timeout */
+#define SRBSYTO_29		(0xf << 8) /* resp busy timeout */
+#define SRWDTO_29		(0xf << 4) /* read/write timeout */
+#define SCCSTO_29		(0xf << 0) /* ccs timeout */
 
 /* CE_VERSION */
 #define SOFT_RST_ON		(1 << 31)

commit 714c4a6e3a0f730834ec8a8bc83b2a6da33f54dc
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Aug 30 18:26:39 2011 +0200

    mmc: sh_mmcif: simplify platform data
    
    Provide platforms with a simplified way to specify MMCIF DMA slave IDs in
    a way, similar to SDHI and other sh_dma clients.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 0222cd8ebe76..04ff452bf5c3 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -41,7 +41,9 @@ struct sh_mmcif_plat_data {
 	void (*set_pwr)(struct platform_device *pdev, int state);
 	void (*down_pwr)(struct platform_device *pdev);
 	int (*get_cd)(struct platform_device *pdef);
-	struct sh_mmcif_dma	*dma;
+	struct sh_mmcif_dma	*dma;		/* Deprecated. Instead */
+	unsigned int		slave_id_tx;	/* use embedded slave_id_[tr]x */
+	unsigned int		slave_id_rx;
 	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long		caps;
 	u32			ocr;

commit 100e918610b7487fa18db97b3879cd8d1fdd5974
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Fri May 27 16:04:03 2011 -0400

    mmc: Standardize header file inclusion checks.
    
    Standardize the checks for multiple MMC header file inclusion,
    including adding comments to terminating #endif's, and fixing
    one incorrect comment.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 9eb9b4b96f55..0222cd8ebe76 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -11,8 +11,8 @@
  *
  */
 
-#ifndef __SH_MMCIF_H__
-#define __SH_MMCIF_H__
+#ifndef LINUX_MMC_SH_MMCIF_H
+#define LINUX_MMC_SH_MMCIF_H
 
 #include <linux/io.h>
 #include <linux/platform_device.h>
@@ -220,4 +220,4 @@ static inline void sh_mmcif_boot_init(void __iomem *base)
 	sh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);
 }
 
-#endif /* __SH_MMCIF_H__ */
+#endif /* LINUX_MMC_SH_MMCIF_H */

commit 9d9659b6c0ebf7dde65ebada4c67980818245913
Author: Simon Horman <horms@verge.net.au>
Date:   Thu Mar 24 07:04:38 2011 +0000

    mmc: Add MMC_PROGRESS_*
    
    This is my second attempt to make this enum generally available.
    The first attempt added MMCIF_PROGRESS_* to include/linux/mmc/sh_mmcif.h.
    However this is not sufficiently generic as the enum will be
    used by SDHI boot code.
    
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 38d393092812..9eb9b4b96f55 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -104,9 +104,6 @@ static inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
 
 #define SH_MMCIF_BBS 512 /* boot block size */
 
-enum { MMCIF_PROGRESS_ENTER, MMCIF_PROGRESS_INIT,
-       MMCIF_PROGRESS_LOAD, MMCIF_PROGRESS_DONE };
-
 static inline void sh_mmcif_boot_cmd_send(void __iomem *base,
 					  unsigned long cmd, unsigned long arg)
 {

commit bba958783b1b4cb0a9420f4e11082467132a334c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 14 15:57:47 2011 +0900

    mmc: sh_mmcif: Convert to __raw_xxx() I/O accessors.
    
    When using the I/O accessors in raw mode from the boot stubs we don't
    want to bother with any of the complexity associated with readl/writel
    and friends. Furthermore, utilization within the context of the host
    driver itself is all performed on an ioremapped window, so using the
    __raw variants there doesn't pose any problem either.
    
    If and when barriers need to be added in the future, these will need to
    be explicitly written out, but this is so far not a concern for any of
    the affected CPUs in question.
    
    This fixes up the link error introduced by the ARM tree via its barrier
    refactoring:
    
            arch/arm/boot/compressed/mmcif-sh7372.o: In function `mmcif_loader':
            mmcif-sh7372.c:(.text+0x9e8): undefined reference to `outer_cache
    
    Following the change in:
    
            http://www.arm.linux.org.uk/developer/patches/viewpatch.php?id=6275/1
    
    Reported-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index bf173502d744..38d393092812 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -94,12 +94,12 @@ struct sh_mmcif_plat_data {
 
 static inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
 {
-	return readl(addr + reg);
+	return __raw_readl(addr + reg);
 }
 
 static inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
 {
-	writel(val, addr + reg);
+	__raw_writel(val, addr + reg);
 }
 
 #define SH_MMCIF_BBS 512 /* boot block size */

commit 89e9fd32c6f4ed58cd6f6e3c3cf5b536a3f36100
Merge: 239f6dcbab35 2f5998610ae3 54b384634f70
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 11 13:05:15 2011 +0900

    Merge branches 'sh/memchunk' and 'common/mmcif' into sh-latest

commit 54b384634f7083bcacf9a9ed2e6f4c3d0a246e49
Author: Simon Horman <horms@verge.net.au>
Date:   Mon Dec 6 00:12:45 2010 +0000

    mmc, sh: Remove sh_mmcif_boot_slurp()
    
    As the only caller of sh_mmcif_boot_do_read() is
    sh_mmcif_boot_slurp() the configuration portion of
    sh_mmcif_boot_slurp() can be merged into sh_mmcif_boot_do_read().
    
    Once this is done sh_mmcif_boot_slurp() is only a call
    to sh_mmcif_boot_do_read() with platform specific information -
    the offset that images are stored on MMC. So make the
    sh_mmcif_boot_do_read() call directly from platform code
    and remove sh_mmcif_boot_slurp() altogether.
    
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 6a98e97c49f8..cfcc6e320e2f 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -162,6 +162,17 @@ static inline int sh_mmcif_boot_do_read(void __iomem *base,
 	unsigned long k;
 	int ret = 0;
 
+	/* In data transfer mode: Set clock to Bus clock/4 (about 20Mhz) */
+	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
+			CLK_ENABLE | CLKDIV_4 | SRSPTO_256 |
+			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);
+
+	/* CMD9 - Get CSD */
+	sh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);
+
+	/* CMD7 - Select the card */
+	sh_mmcif_boot_cmd(base, 0x07400000, 0x00010000);
+
 	/* CMD16 - Set the block size */
 	sh_mmcif_boot_cmd(base, 0x10400000, SH_MMCIF_BBS);
 
@@ -205,27 +216,4 @@ static inline void sh_mmcif_boot_init(void __iomem *base)
 	sh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);
 }
 
-static inline void sh_mmcif_boot_slurp(void __iomem *base,
-				       unsigned char *buf,
-				       unsigned long no_bytes)
-{
-	unsigned long tmp;
-
-	/* In data transfer mode: Set clock to Bus clock/4 (about 20Mhz) */
-	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
-			CLK_ENABLE | CLKDIV_4 | SRSPTO_256 |
-			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);
-
-	/* CMD9 - Get CSD */
-	sh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);
-
-	/* CMD7 - Select the card */
-	sh_mmcif_boot_cmd(base, 0x07400000, 0x00010000);
-
-	tmp = no_bytes / SH_MMCIF_BBS;
-	tmp += (no_bytes % SH_MMCIF_BBS) ? 1 : 0;
-
-	sh_mmcif_boot_do_read(base, 512, tmp, buf);
-}
-
 #endif /* __SH_MMCIF_H__ */

commit 9f843706bb87837b823228467f4f83973fd110e9
Author: Simon Horman <horms@verge.net.au>
Date:   Mon Dec 6 00:12:44 2010 +0000

    mmc, sh: Move MMCIF_PROGRESS_* into sh_mmcif.h
    
    Allow MMCIF_PROGRESS_* to be shared.
    
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index ffabf8c0a531..6a98e97c49f8 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -97,6 +97,9 @@ static inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
 
 #define SH_MMCIF_BBS 512 /* boot block size */
 
+enum { MMCIF_PROGRESS_ENTER, MMCIF_PROGRESS_INIT,
+       MMCIF_PROGRESS_LOAD, MMCIF_PROGRESS_DONE };
+
 static inline void sh_mmcif_boot_cmd_send(void __iomem *base,
 					  unsigned long cmd, unsigned long arg)
 {

commit d8e7943d821d8ee7f48ff38f6f7c509297c88402
Merge: df73af86b6e7 22efa0fee32d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Nov 30 14:42:55 2010 +0900

    Merge branch 'common/mmcif' into rmobile/mmcif

commit 22efa0fee32d9e7f6f6fbc396a872b5708d86048
Author: Simon Horman <horms@verge.net.au>
Date:   Sat Nov 27 00:11:55 2010 +0000

    sh, mmc: Use defines when setting CE_CLK_CTRL
    
    The 16-19th bits of CE_CLK_CTRL set the
    MMC clock frequency.
    
    Cc: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 342ec1a38684..ffabf8c0a531 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -70,6 +70,9 @@ struct sh_mmcif_plat_data {
 #define CLK_ENABLE		(1 << 24) /* 1: output mmc clock */
 #define CLK_CLEAR		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
 #define CLK_SUP_PCLK		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
+#define CLKDIV_4		(1<<16) /* mmc clock frequency.
+					 * n: bus clock/(2^(n+1)) */
+#define CLKDIV_256		(7<<16) /* mmc clock frequency. (see above) */
 #define SRSPTO_256		((1 << 13) | (0 << 12)) /* resp timeout */
 #define SRBSYTO_29		((1 << 11) | (1 << 10) |	\
 				 (1 << 9) | (1 << 8)) /* resp busy timeout */
@@ -178,14 +181,10 @@ static inline void sh_mmcif_boot_init(void __iomem *base)
 	/* Set block size in MMCIF hardware */
 	sh_mmcif_writel(base, MMCIF_CE_BLOCK_SET, SH_MMCIF_BBS);
 
-	/* Enable the clock, set it to Bus clock/256 (about 325Khz).
-	 * It is unclear where 0x70000 comes from or if it is even needed.
-	 * It is there for byte-compatibility with code that is known to
-	 * work.
-	 */
+	/* Enable the clock, set it to Bus clock/256 (about 325Khz). */
 	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
-			CLK_ENABLE | SRSPTO_256 | SRBSYTO_29 | SRWDTO_29 |
-			SCCSTO_29 | 0x70000);
+			CLK_ENABLE | CLKDIV_256 | SRSPTO_256 |
+			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);
 
 	/* CMD0 */
 	sh_mmcif_boot_cmd(base, 0x00000040, 0);
@@ -210,7 +209,9 @@ static inline void sh_mmcif_boot_slurp(void __iomem *base,
 	unsigned long tmp;
 
 	/* In data transfer mode: Set clock to Bus clock/4 (about 20Mhz) */
-	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL, 0x01012fff);
+	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
+			CLK_ENABLE | CLKDIV_4 | SRSPTO_256 |
+			SRBSYTO_29 | SRWDTO_29 | SCCSTO_29);
 
 	/* CMD9 - Get CSD */
 	sh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);

commit 1ae0affedce1d3e401991fbe7f2674753f0a7641
Author: Simon Horman <horms@verge.net.au>
Date:   Fri Nov 26 23:02:58 2010 +0000

    mmc, sh: Correct value for reset
    
    This resolves a regression that I introduced in
    "mmc, sh: Move constants to sh_mmcif.h". Having
    examined the manual and tested the code on an AP4EVB board
    it seems that the correct sequence is.
    
    1) Write 1 to bit 31 and zeros to all other bits
    2) Write zero to all bits
    
    Cc: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index a6bfa5296495..342ec1a38684 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -80,7 +80,7 @@ struct sh_mmcif_plat_data {
 
 /* CE_VERSION */
 #define SOFT_RST_ON		(1 << 31)
-#define SOFT_RST_OFF		~SOFT_RST_ON
+#define SOFT_RST_OFF		0
 
 static inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
 {
@@ -168,12 +168,9 @@ static inline int sh_mmcif_boot_do_read(void __iomem *base,
 
 static inline void sh_mmcif_boot_init(void __iomem *base)
 {
-	unsigned long tmp;
-
 	/* reset */
-	tmp = sh_mmcif_readl(base, MMCIF_CE_VERSION);
-	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp | SOFT_RST_ON);
-	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp & SOFT_RST_OFF);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_ON);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, SOFT_RST_OFF);
 
 	/* byte swap */
 	sh_mmcif_writel(base, MMCIF_CE_BUF_ACC, BUF_ACC_ATYP);

commit a782d688e9c6f9ca9a7a9a28e8e2876969ddef53
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Nov 24 10:05:22 2010 +0000

    mmc: sh_mmcif: add DMA support
    
    The MMCIF controller on sh-mobile platforms can use the DMA controller for data
    transfers. Interface to the SH dmaengine driver to enable DMA. We also have to
    lower the maximum number of segments to match with the number od DMA
    descriptors on SuperH, this doesn't significantly affect driver's PIO
    performance.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index a6bfa5296495..f216a8879b58 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -14,8 +14,9 @@
 #ifndef __SH_MMCIF_H__
 #define __SH_MMCIF_H__
 
-#include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/sh_dma.h>
 
 /*
  * MMCIF : CE_CLK_CTRL [19:16]
@@ -31,13 +32,19 @@
  * 1111 : Peripheral clock (sup_pclk set '1')
  */
 
+struct sh_mmcif_dma {
+	struct sh_dmae_slave chan_priv_tx;
+	struct sh_dmae_slave chan_priv_rx;
+};
+
 struct sh_mmcif_plat_data {
 	void (*set_pwr)(struct platform_device *pdev, int state);
 	void (*down_pwr)(struct platform_device *pdev);
 	int (*get_cd)(struct platform_device *pdef);
-	u8	sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
-	unsigned long caps;
-	u32	ocr;
+	struct sh_mmcif_dma	*dma;
+	u8			sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
+	unsigned long		caps;
+	u32			ocr;
 };
 
 #define MMCIF_CE_CMD_SET	0x00000000

commit da1d39e3903bc35be2b5e8d2116fdd5d337244d4
Author: Simon Horman <horms@verge.net.au>
Date:   Tue Nov 9 17:47:02 2010 +0900

    mmc, sh: Move constants to sh_mmcif.h
    
    This moves some constants from sh_mmcif.c to sh_mmcif.h
    so that they can be used in sh_mmcif_boot_init().
    
    It also alters the definition of SOFT_RST_OFF from (0 << 31) to
    ~SOFT_RST_ON (= ~(1 << 31)). The former seems bogus.  The latter is
    consistent with the code in sh_mmcif_boot_init().
    
    Cc: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index 5c99da1078aa..a6bfa5296495 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -59,6 +59,29 @@ struct sh_mmcif_plat_data {
 #define MMCIF_CE_HOST_STS2	0x0000004C
 #define MMCIF_CE_VERSION	0x0000007C
 
+/* CE_BUF_ACC */
+#define BUF_ACC_DMAWEN		(1 << 25)
+#define BUF_ACC_DMAREN		(1 << 24)
+#define BUF_ACC_BUSW_32		(0 << 17)
+#define BUF_ACC_BUSW_16		(1 << 17)
+#define BUF_ACC_ATYP		(1 << 16)
+
+/* CE_CLK_CTRL */
+#define CLK_ENABLE		(1 << 24) /* 1: output mmc clock */
+#define CLK_CLEAR		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
+#define CLK_SUP_PCLK		((1 << 19) | (1 << 18) | (1 << 17) | (1 << 16))
+#define SRSPTO_256		((1 << 13) | (0 << 12)) /* resp timeout */
+#define SRBSYTO_29		((1 << 11) | (1 << 10) |	\
+				 (1 << 9) | (1 << 8)) /* resp busy timeout */
+#define SRWDTO_29		((1 << 7) | (1 << 6) |		\
+				 (1 << 5) | (1 << 4)) /* read/write timeout */
+#define SCCSTO_29		((1 << 3) | (1 << 2) |		\
+				 (1 << 1) | (1 << 0)) /* ccs timeout */
+
+/* CE_VERSION */
+#define SOFT_RST_ON		(1 << 31)
+#define SOFT_RST_OFF		~SOFT_RST_ON
+
 static inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
 {
 	return readl(addr + reg);
@@ -149,17 +172,23 @@ static inline void sh_mmcif_boot_init(void __iomem *base)
 
 	/* reset */
 	tmp = sh_mmcif_readl(base, MMCIF_CE_VERSION);
-	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp | 0x80000000);
-	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp & ~0x80000000);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp | SOFT_RST_ON);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp & SOFT_RST_OFF);
 
 	/* byte swap */
-	sh_mmcif_writel(base, MMCIF_CE_BUF_ACC, 0x00010000);
+	sh_mmcif_writel(base, MMCIF_CE_BUF_ACC, BUF_ACC_ATYP);
 
 	/* Set block size in MMCIF hardware */
 	sh_mmcif_writel(base, MMCIF_CE_BLOCK_SET, SH_MMCIF_BBS);
 
-	/* Enable the clock, set it to Bus clock/256 (about 325Khz)*/
-	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL, 0x01072fff);
+	/* Enable the clock, set it to Bus clock/256 (about 325Khz).
+	 * It is unclear where 0x70000 comes from or if it is even needed.
+	 * It is there for byte-compatibility with code that is known to
+	 * work.
+	 */
+	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL,
+			CLK_ENABLE | SRSPTO_256 | SRBSYTO_29 | SRWDTO_29 |
+			SCCSTO_29 | 0x70000);
 
 	/* CMD0 */
 	sh_mmcif_boot_cmd(base, 0x00000040, 0);

commit 2f6ba5792ce9e4a731baeb976ccc72e0cf43d20b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Nov 4 12:21:25 2010 +0900

    mmc: sh_mmcif: Convert extern inline to static inline.
    
    Presently the extern inline case results in a compiler warning on ARM due
    to the memory barrier definition used in the I/O routines. These
    ultimately all want to be static inline anyways, so just convert them all
    in place.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index d19e2114fd86..5c99da1078aa 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -59,19 +59,19 @@ struct sh_mmcif_plat_data {
 #define MMCIF_CE_HOST_STS2	0x0000004C
 #define MMCIF_CE_VERSION	0x0000007C
 
-extern inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
+static inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
 {
 	return readl(addr + reg);
 }
 
-extern inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
+static inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
 {
 	writel(val, addr + reg);
 }
 
 #define SH_MMCIF_BBS 512 /* boot block size */
 
-extern inline void sh_mmcif_boot_cmd_send(void __iomem *base,
+static inline void sh_mmcif_boot_cmd_send(void __iomem *base,
 					  unsigned long cmd, unsigned long arg)
 {
 	sh_mmcif_writel(base, MMCIF_CE_INT, 0);
@@ -79,7 +79,7 @@ extern inline void sh_mmcif_boot_cmd_send(void __iomem *base,
 	sh_mmcif_writel(base, MMCIF_CE_CMD_SET, cmd);
 }
 
-extern inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)
+static inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)
 {
 	unsigned long tmp;
 	int cnt;
@@ -95,14 +95,14 @@ extern inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)
 	return -1;
 }
 
-extern inline int sh_mmcif_boot_cmd(void __iomem *base,
+static inline int sh_mmcif_boot_cmd(void __iomem *base,
 				    unsigned long cmd, unsigned long arg)
 {
 	sh_mmcif_boot_cmd_send(base, cmd, arg);
 	return sh_mmcif_boot_cmd_poll(base, 0x00010000);
 }
 
-extern inline int sh_mmcif_boot_do_read_single(void __iomem *base,
+static inline int sh_mmcif_boot_do_read_single(void __iomem *base,
 					       unsigned int block_nr,
 					       unsigned long *buf)
 {
@@ -125,7 +125,7 @@ extern inline int sh_mmcif_boot_do_read_single(void __iomem *base,
 	return 0;
 }
 
-extern inline int sh_mmcif_boot_do_read(void __iomem *base,
+static inline int sh_mmcif_boot_do_read(void __iomem *base,
 					unsigned long first_block,
 					unsigned long nr_blocks,
 					void *buf)
@@ -143,7 +143,7 @@ extern inline int sh_mmcif_boot_do_read(void __iomem *base,
 	return ret;
 }
 
-extern inline void sh_mmcif_boot_init(void __iomem *base)
+static inline void sh_mmcif_boot_init(void __iomem *base)
 {
 	unsigned long tmp;
 
@@ -177,7 +177,7 @@ extern inline void sh_mmcif_boot_init(void __iomem *base)
 	sh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);
 }
 
-extern inline void sh_mmcif_boot_slurp(void __iomem *base,
+static inline void sh_mmcif_boot_slurp(void __iomem *base,
 				       unsigned char *buf,
 				       unsigned long no_bytes)
 {

commit 777271d0f33da306575ef776c75f66fc27246bf0
Author: Arnd Hannemann <arnd@arndnet.de>
Date:   Tue Aug 24 17:27:01 2010 +0200

    mmc: Allow the platform to specify the sh_mmcif get_cd handler
    
    In some platforms (e.g. AP4EVB) the card detect pin of a slot is not
    directly connected to the sh_mmcif controller, so that polling needs
    to be used. To overcome the overhead induced by querying the controller
    on each poll cycle, card detection can be handled in the platform code
    more efficiently.
    This patch exposes a get_cd hook for that purpose.
    
    Signed-off-by: Arnd Hannemann <arnd@arndnet.de>
    Tested-by: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index d4a2ebbdab4b..d19e2114fd86 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -34,6 +34,7 @@
 struct sh_mmcif_plat_data {
 	void (*set_pwr)(struct platform_device *pdev, int state);
 	void (*down_pwr)(struct platform_device *pdev);
+	int (*get_cd)(struct platform_device *pdef);
 	u8	sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
 	unsigned long caps;
 	u32	ocr;

commit 8a768952ca8cb5cad98cfa343e6fb131e3bbdc3e
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 18 14:43:04 2010 +0000

    sh: add boot code to MMCIF driver header
    
    This patch adds a set of MMCIF functions for the romImage
    boot loader that allows the kernel to be booted directly
    from an MMC card.
    
    Thanks to Jeremy Baker for the initial prototype.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index e079c6beeb98..d4a2ebbdab4b 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -68,4 +68,133 @@ extern inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
 	writel(val, addr + reg);
 }
 
+#define SH_MMCIF_BBS 512 /* boot block size */
+
+extern inline void sh_mmcif_boot_cmd_send(void __iomem *base,
+					  unsigned long cmd, unsigned long arg)
+{
+	sh_mmcif_writel(base, MMCIF_CE_INT, 0);
+	sh_mmcif_writel(base, MMCIF_CE_ARG, arg);
+	sh_mmcif_writel(base, MMCIF_CE_CMD_SET, cmd);
+}
+
+extern inline int sh_mmcif_boot_cmd_poll(void __iomem *base, unsigned long mask)
+{
+	unsigned long tmp;
+	int cnt;
+
+	for (cnt = 0; cnt < 1000000; cnt++) {
+		tmp = sh_mmcif_readl(base, MMCIF_CE_INT);
+		if (tmp & mask) {
+			sh_mmcif_writel(base, MMCIF_CE_INT, tmp & ~mask);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+extern inline int sh_mmcif_boot_cmd(void __iomem *base,
+				    unsigned long cmd, unsigned long arg)
+{
+	sh_mmcif_boot_cmd_send(base, cmd, arg);
+	return sh_mmcif_boot_cmd_poll(base, 0x00010000);
+}
+
+extern inline int sh_mmcif_boot_do_read_single(void __iomem *base,
+					       unsigned int block_nr,
+					       unsigned long *buf)
+{
+	int k;
+
+	/* CMD13 - Status */
+	sh_mmcif_boot_cmd(base, 0x0d400000, 0x00010000);
+
+	if (sh_mmcif_readl(base, MMCIF_CE_RESP0) != 0x0900)
+		return -1;
+
+	/* CMD17 - Read */
+	sh_mmcif_boot_cmd(base, 0x11480000, block_nr * SH_MMCIF_BBS);
+	if (sh_mmcif_boot_cmd_poll(base, 0x00100000) < 0)
+		return -1;
+
+	for (k = 0; k < (SH_MMCIF_BBS / 4); k++)
+		buf[k] = sh_mmcif_readl(base, MMCIF_CE_DATA);
+
+	return 0;
+}
+
+extern inline int sh_mmcif_boot_do_read(void __iomem *base,
+					unsigned long first_block,
+					unsigned long nr_blocks,
+					void *buf)
+{
+	unsigned long k;
+	int ret = 0;
+
+	/* CMD16 - Set the block size */
+	sh_mmcif_boot_cmd(base, 0x10400000, SH_MMCIF_BBS);
+
+	for (k = 0; !ret && k < nr_blocks; k++)
+		ret = sh_mmcif_boot_do_read_single(base, first_block + k,
+						   buf + (k * SH_MMCIF_BBS));
+
+	return ret;
+}
+
+extern inline void sh_mmcif_boot_init(void __iomem *base)
+{
+	unsigned long tmp;
+
+	/* reset */
+	tmp = sh_mmcif_readl(base, MMCIF_CE_VERSION);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp | 0x80000000);
+	sh_mmcif_writel(base, MMCIF_CE_VERSION, tmp & ~0x80000000);
+
+	/* byte swap */
+	sh_mmcif_writel(base, MMCIF_CE_BUF_ACC, 0x00010000);
+
+	/* Set block size in MMCIF hardware */
+	sh_mmcif_writel(base, MMCIF_CE_BLOCK_SET, SH_MMCIF_BBS);
+
+	/* Enable the clock, set it to Bus clock/256 (about 325Khz)*/
+	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL, 0x01072fff);
+
+	/* CMD0 */
+	sh_mmcif_boot_cmd(base, 0x00000040, 0);
+
+	/* CMD1 - Get OCR */
+	do {
+		sh_mmcif_boot_cmd(base, 0x01405040, 0x40300000); /* CMD1 */
+	} while ((sh_mmcif_readl(base, MMCIF_CE_RESP0) & 0x80000000)
+		 != 0x80000000);
+
+	/* CMD2 - Get CID */
+	sh_mmcif_boot_cmd(base, 0x02806040, 0);
+
+	/* CMD3 - Set card relative address */
+	sh_mmcif_boot_cmd(base, 0x03400040, 0x00010000);
+}
+
+extern inline void sh_mmcif_boot_slurp(void __iomem *base,
+				       unsigned char *buf,
+				       unsigned long no_bytes)
+{
+	unsigned long tmp;
+
+	/* In data transfer mode: Set clock to Bus clock/4 (about 20Mhz) */
+	sh_mmcif_writel(base, MMCIF_CE_CLK_CTRL, 0x01012fff);
+
+	/* CMD9 - Get CSD */
+	sh_mmcif_boot_cmd(base, 0x09806000, 0x00010000);
+
+	/* CMD7 - Select the card */
+	sh_mmcif_boot_cmd(base, 0x07400000, 0x00010000);
+
+	tmp = no_bytes / SH_MMCIF_BBS;
+	tmp += (no_bytes % SH_MMCIF_BBS) ? 1 : 0;
+
+	sh_mmcif_boot_do_read(base, 512, tmp, buf);
+}
+
 #endif /* __SH_MMCIF_H__ */

commit 487d9fc5016529d7d77dfe35b666fd3a090e2953
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 18 14:42:51 2010 +0000

    sh: prepare MMCIF driver header file
    
    Update the MMCIF driver to include register information
    and register access functions in the header file.
    The MMCIF boot code builds on top of this.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
index aafe832f18aa..e079c6beeb98 100644
--- a/include/linux/mmc/sh_mmcif.h
+++ b/include/linux/mmc/sh_mmcif.h
@@ -14,6 +14,9 @@
 #ifndef __SH_MMCIF_H__
 #define __SH_MMCIF_H__
 
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
 /*
  * MMCIF : CE_CLK_CTRL [19:16]
  * 1000 : Peripheral clock / 512
@@ -36,4 +39,33 @@ struct sh_mmcif_plat_data {
 	u32	ocr;
 };
 
+#define MMCIF_CE_CMD_SET	0x00000000
+#define MMCIF_CE_ARG		0x00000008
+#define MMCIF_CE_ARG_CMD12	0x0000000C
+#define MMCIF_CE_CMD_CTRL	0x00000010
+#define MMCIF_CE_BLOCK_SET	0x00000014
+#define MMCIF_CE_CLK_CTRL	0x00000018
+#define MMCIF_CE_BUF_ACC	0x0000001C
+#define MMCIF_CE_RESP3		0x00000020
+#define MMCIF_CE_RESP2		0x00000024
+#define MMCIF_CE_RESP1		0x00000028
+#define MMCIF_CE_RESP0		0x0000002C
+#define MMCIF_CE_RESP_CMD12	0x00000030
+#define MMCIF_CE_DATA		0x00000034
+#define MMCIF_CE_INT		0x00000040
+#define MMCIF_CE_INT_MASK	0x00000044
+#define MMCIF_CE_HOST_STS1	0x00000048
+#define MMCIF_CE_HOST_STS2	0x0000004C
+#define MMCIF_CE_VERSION	0x0000007C
+
+extern inline u32 sh_mmcif_readl(void __iomem *addr, int reg)
+{
+	return readl(addr + reg);
+}
+
+extern inline void sh_mmcif_writel(void __iomem *addr, int reg, u32 val)
+{
+	writel(val, addr + reg);
+}
+
 #endif /* __SH_MMCIF_H__ */

commit fdc50a9444b9781f4dd5aa5f7453300d2688cc5f
Author: Yusuke Goda <yusuke.goda.sx@renesas.com>
Date:   Wed May 26 14:41:59 2010 -0700

    mmc: add support MMCIF for SuperH
    
    MMCIF is the MMC Host Interface in SuperH.
    
    Signed-off-by: Yusuke Goda <yusuke.goda.sx@renesas.com>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mmc/sh_mmcif.h b/include/linux/mmc/sh_mmcif.h
new file mode 100644
index 000000000000..aafe832f18aa
--- /dev/null
+++ b/include/linux/mmc/sh_mmcif.h
@@ -0,0 +1,39 @@
+/*
+ * include/linux/mmc/sh_mmcif.h
+ *
+ * platform data for eMMC driver
+ *
+ * Copyright (C) 2010 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ */
+
+#ifndef __SH_MMCIF_H__
+#define __SH_MMCIF_H__
+
+/*
+ * MMCIF : CE_CLK_CTRL [19:16]
+ * 1000 : Peripheral clock / 512
+ * 0111 : Peripheral clock / 256
+ * 0110 : Peripheral clock / 128
+ * 0101 : Peripheral clock / 64
+ * 0100 : Peripheral clock / 32
+ * 0011 : Peripheral clock / 16
+ * 0010 : Peripheral clock / 8
+ * 0001 : Peripheral clock / 4
+ * 0000 : Peripheral clock / 2
+ * 1111 : Peripheral clock (sup_pclk set '1')
+ */
+
+struct sh_mmcif_plat_data {
+	void (*set_pwr)(struct platform_device *pdev, int state);
+	void (*down_pwr)(struct platform_device *pdev);
+	u8	sup_pclk;	/* 1 :SH7757, 0: SH7724/SH7372 */
+	unsigned long caps;
+	u32	ocr;
+};
+
+#endif /* __SH_MMCIF_H__ */
