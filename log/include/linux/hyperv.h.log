commit afaa33da08abd10be8978781d7c99a9e67d2bbff
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Fri May 22 19:19:01 2020 +0200

    Drivers: hv: vmbus: Resolve more races involving init_vp_index()
    
    init_vp_index() uses the (per-node) hv_numa_map[] masks to record the
    CPUs allocated for channel interrupts at a given time, and distribute
    the performance-critical channels across the available CPUs: in part.,
    the mask of "candidate" target CPUs in a given NUMA node, for a newly
    offered channel, is determined by XOR-ing the node's CPU mask and the
    node's hv_numa_map.  This operation/mechanism assumes that no offline
    CPUs is set in the hv_numa_map mask, an assumption that does not hold
    since such mask is currently not updated when a channel is removed or
    assigned to a different CPU.
    
    To address the issues described above, this adds hooks in the channel
    removal path (hv_process_channel_removal()) and in target_cpu_store()
    in order to clear, resp. to update, the hv_numa_map[] masks as needed.
    This also adds a (missed) update of the masks in init_vp_index() (cf.,
    e.g., the memory-allocation failure path in this function).
    
    Like in the case of init_vp_index(), such hooks require to determine
    if the given channel is performance critical.  init_vp_index() does
    this by parsing the channel's offer, it can not rely on the device
    data structure (device_obj) to retrieve such information because the
    device data structure has not been allocated/linked with the channel
    by the time that init_vp_index() executes.  A similar situation may
    hold in hv_is_alloced_cpu() (defined below); the adopted approach is
    to "cache" the device type of the channel, as computed by parsing the
    channel's offer, in the channel structure itself.
    
    Fixes: 7527810573436f ("Drivers: hv: vmbus: Introduce the CHANNELMSG_MODIFYCHANNEL message type")
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Link: https://lore.kernel.org/r/20200522171901.204127-3-parri.andrea@gmail.com
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index d783847d8cb4..40df3103e890 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -901,6 +901,13 @@ struct vmbus_channel {
 
 	bool probe_done;
 
+	/*
+	 * Cache the device ID here for easy access; this is useful, in
+	 * particular, in situations where the channel's device_obj has
+	 * not been allocated/initialized yet.
+	 */
+	u16 device_id;
+
 	/*
 	 * We must offload the handling of the primary/sub channels
 	 * from the single-threaded vmbus_connection.work_queue to

commit db5871e85533f06ffe1795c1cb9b9153860d1e4f
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:53:23 2020 -0500

    vmbus: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Link: https://lore.kernel.org/r/20200507185323.GA14416@embeddedor
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index cd64ab7bb3b7..d783847d8cb4 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -117,7 +117,7 @@ struct hv_ring_buffer {
 	 * Ring data starts here + RingDataStartOffset
 	 * !!! DO NOT place any fields below this !!!
 	 */
-	u8 buffer[0];
+	u8 buffer[];
 } __packed;
 
 struct hv_ring_buffer_info {
@@ -313,7 +313,7 @@ struct vmadd_remove_transfer_page_set {
 struct gpa_range {
 	u32 byte_count;
 	u32 byte_offset;
-	u64 pfn_array[0];
+	u64 pfn_array[];
 };
 
 /*
@@ -563,7 +563,7 @@ struct vmbus_channel_gpadl_header {
 	u32 gpadl;
 	u16 range_buflen;
 	u16 rangecount;
-	struct gpa_range range[0];
+	struct gpa_range range[];
 } __packed;
 
 /* This is the followup packet that contains more PFNs. */
@@ -571,7 +571,7 @@ struct vmbus_channel_gpadl_body {
 	struct vmbus_channel_message_header header;
 	u32 msgnumber;
 	u32 gpadl;
-	u64 pfn[0];
+	u64 pfn[];
 } __packed;
 
 struct vmbus_channel_gpadl_created {
@@ -679,7 +679,7 @@ struct vmbus_channel_msginfo {
 	 * The channel message that goes out on the "wire".
 	 * It will contain at minimum the VMBUS_CHANNEL_MESSAGE_HEADER header
 	 */
-	unsigned char msg[0];
+	unsigned char msg[];
 };
 
 struct vmbus_close_msg {

commit 7769e18c201aa88eade5556faf9da7f2bc15bb8a
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:14 2020 +0200

    scsi: storvsc: Re-init stor_chns when a channel interrupt is re-assigned
    
    For each storvsc_device, storvsc keeps track of the channel target CPUs
    associated to the device (alloced_cpus) and it uses this information to
    fill a "cache" (stor_chns) mapping CPU->channel according to a certain
    heuristic.  Update the alloced_cpus mask and the stor_chns array when a
    channel of the storvsc device is re-assigned to a different CPU.
    
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: <linux-scsi@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200406001514.19876-12-parri.andrea@gmail.com
    Reviewed-by; Long Li <longli@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    [ wei: fix a small issue reported by kbuild test robot <lkp@intel.com> ]
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b85d7580f2c1..cd64ab7bb3b7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -773,6 +773,9 @@ struct vmbus_channel {
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
 
+	void (*change_target_cpu_callback)(struct vmbus_channel *channel,
+			u32 old, u32 new);
+
 	/*
 	 * Synchronize channel scheduling and channel removal; see the inline
 	 * comments in vmbus_chan_sched() and vmbus_reset_channel_cb().

commit 7527810573436f00e582d3d5ef2eb3c027c98d7d
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:13 2020 +0200

    Drivers: hv: vmbus: Introduce the CHANNELMSG_MODIFYCHANNEL message type
    
    VMBus version 4.1 and later support the CHANNELMSG_MODIFYCHANNEL(22)
    message type which can be used to request Hyper-V to change the vCPU
    that a channel will interrupt.
    
    Introduce the CHANNELMSG_MODIFYCHANNEL message type, and define the
    vmbus_send_modifychannel() function to send CHANNELMSG_MODIFYCHANNEL
    requests to the host via a hypercall.  The function is then used to
    define a sysfs "store" operation, which allows to change the (v)CPU
    the channel will interrupt by using the sysfs interface.  The feature
    can be used for load balancing or other purposes.
    
    One interesting catch here is that Hyper-V can *not* currently ACK
    CHANNELMSG_MODIFYCHANNEL messages with the promise that (after the ACK
    is sent) the channel won't send any more interrupts to the "old" CPU.
    
    The peculiarity of the CHANNELMSG_MODIFYCHANNEL messages is problematic
    if the user want to take a CPU offline, since we don't want to take a
    CPU offline (and, potentially, "lose" channel interrupts on such CPU)
    if the host is still processing a CHANNELMSG_MODIFYCHANNEL message
    associated to that CPU.
    
    It is worth mentioning, however, that we have been unable to observe
    the above mentioned "race": in all our tests, CHANNELMSG_MODIFYCHANNEL
    requests appeared *as if* they were processed synchronously by the host.
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-11-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    [ wei: fix conflict in channel_mgmt.c ]
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 247356dbd742..b85d7580f2c1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -425,7 +425,7 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_19				= 19,
 	CHANNELMSG_20				= 20,
 	CHANNELMSG_TL_CONNECT_REQUEST		= 21,
-	CHANNELMSG_22				= 22,
+	CHANNELMSG_MODIFYCHANNEL		= 22,
 	CHANNELMSG_TL_CONNECT_RESULT		= 23,
 	CHANNELMSG_COUNT
 };
@@ -620,6 +620,13 @@ struct vmbus_channel_tl_connect_request {
 	guid_t host_service_id;
 } __packed;
 
+/* Modify Channel parameters, cf. vmbus_send_modifychannel() */
+struct vmbus_channel_modifychannel {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+	u32 target_vp;
+} __packed;
+
 struct vmbus_channel_version_response {
 	struct vmbus_channel_message_header header;
 	u8 version_supported;
@@ -1505,6 +1512,7 @@ extern __u32 vmbus_proto_version;
 
 int vmbus_send_tl_connect_request(const guid_t *shv_guest_servie_id,
 				  const guid_t *shv_host_servie_id);
+int vmbus_send_modifychannel(u32 child_relid, u32 target_vp);
 void vmbus_set_event(struct vmbus_channel *channel);
 
 /* Get the start of the ring buffer. */

commit 8ef4c4abbbcdcd9d4bc0fd9454df03e6dac24b73
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:11 2020 +0200

    Drivers: hv: vmbus: Remove the unused HV_LOCALIZED channel affinity logic
    
    The logic is unused since commit 509879bdb30b8 ("Drivers: hv: Introduce
    a policy for controlling channel affinity").
    
    This logic assumes that a channel target_cpu doesn't change during the
    lifetime of a channel, but this assumption is incompatible with the new
    functionality that allows changing the vCPU a channel will interrupt.
    
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-9-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62b2c11d0875..247356dbd742 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -689,11 +689,6 @@ union hv_connection_id {
 	} u;
 };
 
-enum hv_numa_policy {
-	HV_BALANCED = 0,
-	HV_LOCALIZED,
-};
-
 enum vmbus_device_type {
 	HV_IDE = 0,
 	HV_SCSI,
@@ -808,10 +803,6 @@ struct vmbus_channel {
 	u32 target_vp;
 	/* The corresponding CPUID in the guest */
 	u32 target_cpu;
-	/*
-	 * State to manage the CPU affiliation of channels.
-	 */
-	struct cpumask alloced_cpus_in_node;
 	int numa_node;
 	/*
 	 * Support for sub-channels. For high performance devices,
@@ -898,18 +889,6 @@ struct vmbus_channel {
 	 */
 	bool low_latency;
 
-	/*
-	 * NUMA distribution policy:
-	 * We support two policies:
-	 * 1) Balanced: Here all performance critical channels are
-	 *    distributed evenly amongst all the NUMA nodes.
-	 *    This policy will be the default policy.
-	 * 2) Localized: All channels of a given instance of a
-	 *    performance critical service will be assigned CPUs
-	 *    within a selected NUMA node.
-	 */
-	enum hv_numa_policy affinity_policy;
-
 	bool probe_done;
 
 	/*
@@ -965,12 +944,6 @@ static inline bool is_sub_channel(const struct vmbus_channel *c)
 	return c->offermsg.offer.sub_channel_index != 0;
 }
 
-static inline void set_channel_affinity_state(struct vmbus_channel *c,
-					      enum hv_numa_policy policy)
-{
-	c->affinity_policy = policy;
-}
-
 static inline void set_channel_read_mode(struct vmbus_channel *c,
 					enum hv_callback_mode mode)
 {

commit 9403b66e6161130ebae7e55a97491c84c1ad6f9f
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:09 2020 +0200

    Drivers: hv: vmbus: Use a spin lock for synchronizing channel scheduling vs. channel removal
    
    Since vmbus_chan_sched() dereferences the ring buffer pointer, we have
    to make sure that the ring buffer data structures don't get freed while
    such dereferencing is happening.  Current code does this by sending an
    IPI to the CPU that is allowed to access that ring buffer from interrupt
    level, cf., vmbus_reset_channel_cb().  But with the new functionality
    to allow changing the CPU that a channel will interrupt, we can't be
    sure what CPU will be running the vmbus_chan_sched() function for a
    particular channel, so the current IPI mechanism is infeasible.
    
    Instead synchronize vmbus_chan_sched() and vmbus_reset_channel_cb() by
    using the (newly introduced) per-channel spin lock "sched_lock".  Move
    the test for onchannel_callback being NULL before the "switch" control
    statement in vmbus_chan_sched(), in order to not access the ring buffer
    if the vmbus_reset_channel_cb() has been completed on the channel.
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-7-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f5b3f008c55a..62b2c11d0875 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -771,6 +771,12 @@ struct vmbus_channel {
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
 
+	/*
+	 * Synchronize channel scheduling and channel removal; see the inline
+	 * comments in vmbus_chan_sched() and vmbus_reset_channel_cb().
+	 */
+	spinlock_t sched_lock;
+
 	/*
 	 * A channel can be marked for one of three modes of reading:
 	 *   BATCHED - callback called from taslket and should read

commit 8b6a877c060ed6b86878fe66c7c6493a6054cf23
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:06 2020 +0200

    Drivers: hv: vmbus: Replace the per-CPU channel lists with a global array of channels
    
    When Hyper-V sends an interrupt to the guest, the guest has to figure
    out which channel the interrupt is associated with.  Hyper-V sets a bit
    in a memory page that is shared with the guest, indicating a particular
    "relid" that the interrupt is associated with.  The current Linux code
    then uses a set of per-CPU linked lists to map a given "relid" to a
    pointer to a channel structure.
    
    This design introduces a synchronization problem if the CPU that Hyper-V
    will interrupt for a certain channel is changed.  If the interrupt comes
    on the "old CPU" and the channel was already moved to the per-CPU list
    of the "new CPU", then the relid -> channel mapping will fail and the
    interrupt is dropped.  Similarly, if the interrupt comes on the new CPU
    but the channel was not moved to the per-CPU list of the new CPU, then
    the mapping will fail and the interrupt is dropped.
    
    Relids are integers ranging from 0 to 2047.  The mapping from relids to
    channel structures can be done by setting up an array with 2048 entries,
    each entry being a pointer to a channel structure (hence total size ~16K
    bytes, which is not a problem).  The array is global, so there are no
    per-CPU linked lists to update.  The array can be searched and updated
    by loading from/storing to the array at the specified index.  With no
    per-CPU data structures, the above mentioned synchronization problem is
    avoided and the relid2channel() function gets simpler.
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-4-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index cbd24f4e68d1..f5b3f008c55a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -854,11 +854,6 @@ struct vmbus_channel {
 	 * Support per-channel state for use by vmbus drivers.
 	 */
 	void *per_channel_state;
-	/*
-	 * To support per-cpu lookup mapping of relid to channel,
-	 * link up channels based on their CPU affinity.
-	 */
-	struct list_head percpu_list;
 
 	/*
 	 * Defer freeing channel until after all cpu's have

commit 5cc415001bca8fe0e3f0ee6d58a953a314dd9751
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Apr 6 12:41:52 2020 +0200

    Drivers: hv: avoid passing opaque pointer to vmbus_onmessage()
    
    vmbus_onmessage() doesn't need the header of the message, it only
    uses it to get to the payload, we can pass the pointer to the
    payload directly.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Link: https://lore.kernel.org/r/20200406104154.45010-4-vkuznets@redhat.com
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 692c89ccf5df..cbd24f4e68d1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1017,7 +1017,7 @@ static inline void clear_low_latency_mode(struct vmbus_channel *c)
 	c->low_latency = false;
 }
 
-void vmbus_onmessage(void *context);
+void vmbus_onmessage(struct vmbus_channel_message_header *hdr);
 
 int vmbus_request_offers(void);
 

commit 54e19d34011fea26d39aa74781131de0ce642a01
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 25 21:49:44 2020 -0800

    hv_utils: Add the support of hibernation
    
    Add util_pre_suspend() and util_pre_resume() for some hv_utils devices
    (e.g. kvp/vss/fcopy), because they need special handling before
    util_suspend() calls vmbus_close().
    
    For kvp, all the possible pending work items should be cancelled.
    
    For vss and fcopy, some extra clean-up needs to be done, i.e. fake a
    THAW message for hv_vss_daemon and fake a CANCEL_FCOPY message for
    hv_fcopy_daemon, otherwise when the VM resums back, the daemons
    can end up in an inconsistent state (i.e. the file systems are
    frozen but will never be thawed; the file transmitted via fcopy
    may not be complete). Note: there is an extra patch for the daemons:
    "Tools: hv: Reopen the devices if read() or write() returns errors",
    because the hv_utils driver can not guarantee the whole transaction
    finishes completely once util_suspend() starts to run (at this time,
    all the userspace processes are frozen).
    
    util_probe() disables channel->callback_event to avoid the race with
    the channel callback.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 41c58011431e..692c89ccf5df 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1435,6 +1435,8 @@ struct hv_util_service {
 	void (*util_cb)(void *);
 	int (*util_init)(struct hv_util_service *);
 	void (*util_deinit)(void);
+	int (*util_pre_suspend)(void);
+	int (*util_pre_resume)(void);
 };
 
 struct vmbuspipe_hdr {

commit ddc9d357b991838c2d975e8d7e4e9db26f37a7ff
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sun Jan 19 15:29:22 2020 -0800

    Drivers: hv: vmbus: Ignore CHANNELMSG_TL_CONNECT_RESULT(23)
    
    When a Linux hv_sock app tries to connect to a Service GUID on which no
    host app is listening, a recent host (RS3+) sends a
    CHANNELMSG_TL_CONNECT_RESULT (23) message to Linux and this triggers such
    a warning:
    
    unknown msgtype=23
    WARNING: CPU: 2 PID: 0 at drivers/hv/vmbus_drv.c:1031 vmbus_on_msg_dpc
    
    Actually Linux can safely ignore the message because the Linux app's
    connect() will time out in 2 seconds: see VSOCK_DEFAULT_CONNECT_TIMEOUT
    and vsock_stream_connect(). We don't bother to make use of the message
    because: 1) it's only supported on recent hosts; 2) a non-trivial effort
    is required to use the message in Linux, but the benefit is small.
    
    So, let's not see the warning by silently ignoring the message.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 26f3aeeae1ca..41c58011431e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -425,6 +425,8 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_19				= 19,
 	CHANNELMSG_20				= 20,
 	CHANNELMSG_TL_CONNECT_REQUEST		= 21,
+	CHANNELMSG_22				= 22,
+	CHANNELMSG_TL_CONNECT_RESULT		= 23,
 	CHANNELMSG_COUNT
 };
 

commit af9ca6f9bb16e446a44393a797d0ae74d356a5c7
Author: Branden Bonaby <brandonbonaby94@gmail.com>
Date:   Thu Oct 3 17:01:49 2019 -0400

    drivers: hv: vmbus: Introduce latency testing
    
    Introduce user specified latency in the packet reception path
    By exposing the test parameters as part of the debugfs channel
    attributes. We will control the testing state via these attributes.
    
    Signed-off-by: Branden Bonaby <brandonbonaby94@gmail.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f17f2cd22e39..26f3aeeae1ca 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -934,6 +934,21 @@ struct vmbus_channel {
 	 * full outbound ring buffer.
 	 */
 	u64 out_full_first;
+
+	/* enabling/disabling fuzz testing on the channel (default is false)*/
+	bool fuzz_testing_state;
+
+	/*
+	 * Interrupt delay will delay the guest from emptying the ring buffer
+	 * for a specific amount of time. The delay is in microseconds and will
+	 * be between 1 to a maximum of 1000, its default is 0 (no delay).
+	 * The  Message delay will delay guest reading on a per message basis
+	 * in microseconds between 1 to 1000 with the default being 0
+	 * (no delay).
+	 */
+	u32 fuzz_testing_interrupt_delay;
+	u32 fuzz_testing_message_delay;
+
 };
 
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)
@@ -1182,6 +1197,10 @@ struct hv_device {
 
 	struct vmbus_channel *channel;
 	struct kset	     *channels_kset;
+
+	/* place holder to keep track of the dir for hv device in debugfs */
+	struct dentry *debug_dir;
+
 };
 
 

commit 2d4f49b3e1e3a24ce16dfeeb2235688c8aba57ef
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Tue Oct 15 13:46:45 2019 +0200

    Drivers: hv: vmbus: Enable VMBus protocol versions 4.1, 5.1 and 5.2
    
    Hyper-V has added VMBus protocol versions 5.1 and 5.2 in recent release
    versions.  Allow Linux guests to negotiate these new protocol versions
    on versions of Hyper-V that support them.  While on this, also allow
    guests to negotiate the VMBus protocol version 4.1 (which was missing).
    
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c08b62dbd151..f17f2cd22e39 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -182,15 +182,21 @@ static inline u32 hv_get_avail_to_write_percent(
  * 2 . 4  (Windows 8)
  * 3 . 0  (Windows 8 R2)
  * 4 . 0  (Windows 10)
+ * 4 . 1  (Windows 10 RS3)
  * 5 . 0  (Newer Windows 10)
+ * 5 . 1  (Windows 10 RS4)
+ * 5 . 2  (Windows Server 2019, RS5)
  */
 
 #define VERSION_WS2008  ((0 << 16) | (13))
 #define VERSION_WIN7    ((1 << 16) | (1))
 #define VERSION_WIN8    ((2 << 16) | (4))
 #define VERSION_WIN8_1    ((3 << 16) | (0))
-#define VERSION_WIN10	((4 << 16) | (0))
+#define VERSION_WIN10 ((4 << 16) | (0))
+#define VERSION_WIN10_V4_1 ((4 << 16) | (1))
 #define VERSION_WIN10_V5 ((5 << 16) | (0))
+#define VERSION_WIN10_V5_1 ((5 << 16) | (1))
+#define VERSION_WIN10_V5_2 ((5 << 16) | (2))
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)

commit bedc61a922f9dbbe3bfb26ec2745f8cd63b57637
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Tue Oct 15 13:46:44 2019 +0200

    Drivers: hv: vmbus: Introduce table of VMBus protocol versions
    
    The technique used to get the next VMBus version seems increasisly
    clumsy as the number of VMBus versions increases.  Performance is
    not a concern since this is only done once during system boot; it's
    just that we'll end up with more lines of code than is really needed.
    
    As an alternative, introduce a table with the version numbers listed
    in order (from the most recent to the oldest).  vmbus_connect() loops
    through the versions listed in the table until it gets an accepted
    connection or gets to the end of the table (invalid version).
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b4a017093b69..c08b62dbd151 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -192,10 +192,6 @@ static inline u32 hv_get_avail_to_write_percent(
 #define VERSION_WIN10	((4 << 16) | (0))
 #define VERSION_WIN10_V5 ((5 << 16) | (0))
 
-#define VERSION_INVAL -1
-
-#define VERSION_CURRENT VERSION_WIN10_V5
-
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)
 

commit af5a7e99cce2a24e98487e70f99c8716643cc445
Merge: 0b36c9eed232 d8bd2d442bb2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 24 12:36:31 2019 -0700

    Merge tag 'hyperv-next-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/hyperv/linux
    
    Pull Hyper-V updates from Sasha Levin:
    
     - first round of vmbus hibernation support (Dexuan Cui)
    
     - remove dependencies on PAGE_SIZE (Maya Nakamura)
    
     - move the hyper-v tools/ code into the tools build system (Andy
       Shevchenko)
    
     - hyper-v balloon cleanups (Dexuan Cui)
    
    * tag 'hyperv-next-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/hyperv/linux:
      Drivers: hv: vmbus: Resume after fixing up old primary channels
      Drivers: hv: vmbus: Suspend after cleaning up hv_sock and sub channels
      Drivers: hv: vmbus: Clean up hv_sock channels by force upon suspend
      Drivers: hv: vmbus: Suspend/resume the vmbus itself for hibernation
      Drivers: hv: vmbus: Ignore the offers when resuming from hibernation
      Drivers: hv: vmbus: Implement suspend/resume for VSC drivers for hibernation
      Drivers: hv: vmbus: Add a helper function is_sub_channel()
      Drivers: hv: vmbus: Suspend/resume the synic for hibernation
      Drivers: hv: vmbus: Break out synic enable and disable operations
      HID: hv: Remove dependencies on PAGE_SIZE for ring buffer
      Tools: hv: move to tools buildsystem
      hv_balloon: Reorganize the probe function
      hv_balloon: Use a static page for the balloon_up send buffer

commit d8bd2d442bb2688b428ac7164e5dc6d95d4fa65b
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:22 2019 +0000

    Drivers: hv: vmbus: Resume after fixing up old primary channels
    
    When the host re-offers the primary channels upon resume, the host only
    guarantees the Instance GUID  doesn't change, so vmbus_bus_suspend()
    should invalidate channel->offermsg.child_relid and figure out the
    number of primary channels that need to be fixed up upon resume.
    
    Upon resume, vmbus_onoffer() finds the old channel structs, and maps
    the new offers to the old channels, and fixes up the old structs,
    and finally the resume callbacks of the VSC drivers will re-open
    the channels.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8a60e7766037..a3aa9e9ef6f2 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -426,6 +426,9 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_COUNT
 };
 
+/* Hyper-V supports about 2048 channels, and the RELIDs start with 1. */
+#define INVALID_RELID	U32_MAX
+
 struct vmbus_channel_message_header {
 	enum vmbus_channel_message_type msgtype;
 	u32 padding;

commit 271b2224d42f88870e6b060924ee374871c131fc
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:17 2019 +0000

    Drivers: hv: vmbus: Implement suspend/resume for VSC drivers for hibernation
    
    The high-level VSC drivers will implement device-specific callbacks.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2d39248cff96..8a60e7766037 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1157,6 +1157,9 @@ struct hv_driver {
 	int (*remove)(struct hv_device *);
 	void (*shutdown)(struct hv_device *);
 
+	int (*suspend)(struct hv_device *);
+	int (*resume)(struct hv_device *);
+
 };
 
 /* Base device object */

commit ed56ef675ae6ef0e6f7d42b9c42dae61172f0960
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:16 2019 +0000

    Drivers: hv: vmbus: Add a helper function is_sub_channel()
    
    The existing method of telling if a channel is sub-channel in
    vmbus_process_offer() is cumbersome. This new simple helper function
    is preferred in future.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6256cc34c4a6..2d39248cff96 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -245,7 +245,10 @@ struct vmbus_channel_offer {
 		} pipe;
 	} u;
 	/*
-	 * The sub_channel_index is defined in win8.
+	 * The sub_channel_index is defined in Win8: a value of zero means a
+	 * primary channel and a value of non-zero means a sub-channel.
+	 *
+	 * Before Win8, the field is reserved, meaning it's always zero.
 	 */
 	u16 sub_channel_index;
 	u16 reserved3;
@@ -934,6 +937,11 @@ static inline bool is_hvsock_channel(const struct vmbus_channel *c)
 		  VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER);
 }
 
+static inline bool is_sub_channel(const struct vmbus_channel *c)
+{
+	return c->offermsg.offer.sub_channel_index != 0;
+}
+
 static inline void set_channel_affinity_state(struct vmbus_channel *c,
 					      enum hv_numa_policy policy)
 {

commit 348dd93e40c112afda3cd07daa6f470e474d29dc
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Thu Aug 22 05:05:41 2019 +0000

    PCI: hv: Add a Hyper-V PCI interface driver for software backchannel interface
    
    This interface driver is a helper driver allows other drivers to
    have a common interface with the Hyper-V PCI frontend driver.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 9d37f8cf1245..2afe6fdc1dda 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1579,18 +1579,32 @@ hv_pkt_iter_next(struct vmbus_channel *channel,
 	    pkt = hv_pkt_iter_next(channel, pkt))
 
 /*
- * Functions for passing data between SR-IOV PF and VF drivers.  The VF driver
+ * Interface for passing data between SR-IOV PF and VF drivers. The VF driver
  * sends requests to read and write blocks. Each block must be 128 bytes or
  * smaller. Optionally, the VF driver can register a callback function which
  * will be invoked when the host says that one or more of the first 64 block
  * IDs is "invalid" which means that the VF driver should reread them.
  */
 #define HV_CONFIG_BLOCK_SIZE_MAX 128
-int hv_read_config_block(struct pci_dev *dev, void *buf, unsigned int buf_len,
-			 unsigned int block_id, unsigned int *bytes_returned);
-int hv_write_config_block(struct pci_dev *dev, void *buf, unsigned int len,
-			  unsigned int block_id);
-int hv_register_block_invalidate(struct pci_dev *dev, void *context,
-				 void (*block_invalidate)(void *context,
-							  u64 block_mask));
+
+int hyperv_read_cfg_blk(struct pci_dev *dev, void *buf, unsigned int buf_len,
+			unsigned int block_id, unsigned int *bytes_returned);
+int hyperv_write_cfg_blk(struct pci_dev *dev, void *buf, unsigned int len,
+			 unsigned int block_id);
+int hyperv_reg_block_invalidate(struct pci_dev *dev, void *context,
+				void (*block_invalidate)(void *context,
+							 u64 block_mask));
+
+struct hyperv_pci_block_ops {
+	int (*read_block)(struct pci_dev *dev, void *buf, unsigned int buf_len,
+			  unsigned int block_id, unsigned int *bytes_returned);
+	int (*write_block)(struct pci_dev *dev, void *buf, unsigned int len,
+			   unsigned int block_id);
+	int (*reg_blk_invalidate)(struct pci_dev *dev, void *context,
+				  void (*block_invalidate)(void *context,
+							   u64 block_mask));
+};
+
+extern struct hyperv_pci_block_ops hvpci_block_ops;
+
 #endif /* _HYPERV_H */

commit e5d2f910cfeca852f6e2dc19dfa8dab264ce0cde
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Aug 22 05:05:37 2019 +0000

    PCI: hv: Add a paravirtual backchannel in software
    
    Windows SR-IOV provides a backchannel mechanism in software for communication
    between a VF driver and a PF driver.  These "configuration blocks" are
    similar in concept to PCI configuration space, but instead of doing reads and
    writes in 32-bit chunks through a very slow path, packets of up to 128 bytes
    can be sent or received asynchronously.
    
    Nearly every SR-IOV device contains just such a communications channel in
    hardware, so using this one in software is usually optional.  Using the
    software channel, however, allows driver implementers to leverage software
    tools that fuzz the communications channel looking for vulnerabilities.
    
    The usage model for these packets puts the responsibility for reading or
    writing on the VF driver.  The VF driver sends a read or a write packet,
    indicating which "block" is being referred to by number.
    
    If the PF driver wishes to initiate communication, it can "invalidate" one or
    more of the first 64 blocks.  This invalidation is delivered via a callback
    supplied by the VF driver by this driver.
    
    No protocol is implied, except that supplied by the PF and VF drivers.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6256cc34c4a6..9d37f8cf1245 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1578,4 +1578,19 @@ hv_pkt_iter_next(struct vmbus_channel *channel,
 	for (pkt = hv_pkt_iter_first(channel); pkt; \
 	    pkt = hv_pkt_iter_next(channel, pkt))
 
+/*
+ * Functions for passing data between SR-IOV PF and VF drivers.  The VF driver
+ * sends requests to read and write blocks. Each block must be 128 bytes or
+ * smaller. Optionally, the VF driver can register a callback function which
+ * will be invoked when the host says that one or more of the first 64 block
+ * IDs is "invalid" which means that the VF driver should reread them.
+ */
+#define HV_CONFIG_BLOCK_SIZE_MAX 128
+int hv_read_config_block(struct pci_dev *dev, void *buf, unsigned int buf_len,
+			 unsigned int block_id, unsigned int *bytes_returned);
+int hv_write_config_block(struct pci_dev *dev, void *buf, unsigned int len,
+			  unsigned int block_id);
+int hv_register_block_invalidate(struct pci_dev *dev, void *context,
+				 void (*block_invalidate)(void *context,
+							  u64 block_mask));
 #endif /* _HYPERV_H */

commit 3b20eb23724d493eca79f02b1e062bd5432e29d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:35 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 320
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.254582722@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8b9a93c99c9b..6256cc34c4a6 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1,25 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *
  * Copyright (c) 2011, Microsoft Corporation.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
- *
  * Authors:
  *   Haiyang Zhang <haiyangz@microsoft.com>
  *   Hank Janssen  <hjanssen@microsoft.com>
  *   K. Y. Srinivasan <kys@microsoft.com>
- *
  */
 
 #ifndef _HYPERV_H

commit 14948e39445db674516ccabdf01090586ecfdc9b
Author: Kimberly Brown <kimbrownkd@gmail.com>
Date:   Thu Mar 14 16:05:15 2019 -0400

    Drivers: hv: vmbus: Fix race condition with new ring_buffer_info mutex
    
    Fix a race condition that can result in a ring buffer pointer being set
    to null while a "_show" function is reading the ring buffer's data. This
    problem was discussed here: https://lkml.org/lkml/2018/10/18/779
    
    To fix the race condition, add a new mutex lock to the
    "hv_ring_buffer_info" struct. Add a new function,
    "hv_ringbuffer_pre_init()", where a channel's inbound and outbound
    ring_buffer_info mutex locks are initialized.
    
    Acquire/release the locks in the "hv_ringbuffer_cleanup()" function,
    which is where the ring buffer pointers are set to null.
    
    Acquire/release the locks in the four channel-level "_show" functions
    that access ring buffer data. Remove the "const" qualifier from the
    "vmbus_channel" parameter and the "rbi" variable of the channel-level
    "_show" functions so that the locks can be acquired/released in these
    functions.
    
    Acquire/release the locks in hv_ringbuffer_get_debuginfo(). Remove the
    "const" qualifier from the "hv_ring_buffer_info" parameter so that the
    locks can be acquired/released in this function.
    
    Signed-off-by: Kimberly Brown <kimbrownkd@gmail.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 64698ec8f2ac..8b9a93c99c9b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -141,6 +141,11 @@ struct hv_ring_buffer_info {
 
 	u32 ring_datasize;		/* < ring_size */
 	u32 priv_read_index;
+	/*
+	 * The ring buffer mutex lock. This lock prevents the ring buffer from
+	 * being freed while the ring buffer is being accessed.
+	 */
+	struct mutex ring_buffer_mutex;
 };
 
 
@@ -1206,7 +1211,7 @@ struct hv_ring_buffer_debug_info {
 };
 
 
-int hv_ringbuffer_get_debuginfo(const struct hv_ring_buffer_info *ring_info,
+int hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,
 				struct hv_ring_buffer_debug_info *debug_info);
 
 /* Vmbus interface */

commit 396ae57ef1ef978d1d21cdb7586ba184a3f22453
Author: Kimberly Brown <kimbrownkd@gmail.com>
Date:   Mon Feb 4 02:13:09 2019 -0500

    Drivers: hv: vmbus: Expose counters for interrupts and full conditions
    
    Counter values for per-channel interrupts and ring buffer full
    conditions are useful for investigating performance.
    
    Expose counters in sysfs for 2 types of guest to host interrupts:
    1) Interrupts caused by the channel's outbound ring buffer transitioning
    from empty to not empty
    2) Interrupts caused by the channel's inbound ring buffer transitioning
    from full to not full while a packet is waiting for enough buffer space to
    become available
    
    Expose 2 counters in sysfs for the number of times that write operations
    encountered a full outbound ring buffer:
    1) The total number of write operations that encountered a full
    condition
    2) The number of write operations that were the first to encounter a
    full condition
    
    Increment the outbound full condition counters in the
    hv_ringbuffer_write() function because, for most drivers, a full
    outbound ring buffer is detected in that function. Also increment the
    outbound full condition counters in the set_channel_pending_send_size()
    function. In the hv_sock driver, a full outbound ring buffer is detected
    and set_channel_pending_send_size() is called before
    hv_ringbuffer_write() is called.
    
    I tested this patch by confirming that the sysfs files were created and
    observing the counter values. The values seemed to increase by a
    reasonable amount when the Hyper-v related drivers were in use.
    
    Signed-off-by: Kimberly Brown <kimbrownkd@gmail.com>
    Reviewed-by:  Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index d5678a0fe598..64698ec8f2ac 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -751,6 +751,19 @@ struct vmbus_channel {
 	u64	interrupts;	/* Host to Guest interrupts */
 	u64	sig_events;	/* Guest to Host events */
 
+	/*
+	 * Guest to host interrupts caused by the outbound ring buffer changing
+	 * from empty to not empty.
+	 */
+	u64 intr_out_empty;
+
+	/*
+	 * Indicates that a full outbound ring buffer was encountered. The flag
+	 * is set to true when a full outbound ring buffer is encountered and
+	 * set to false when a write to the outbound ring buffer is completed.
+	 */
+	bool out_full_flag;
+
 	/* Channel callback's invoked in softirq context */
 	struct tasklet_struct callback_event;
 	void (*onchannel_callback)(void *context);
@@ -903,6 +916,24 @@ struct vmbus_channel {
 	 * vmbus_connection.work_queue and hang: see vmbus_process_offer().
 	 */
 	struct work_struct add_channel_work;
+
+	/*
+	 * Guest to host interrupts caused by the inbound ring buffer changing
+	 * from full to not full while a packet is waiting.
+	 */
+	u64 intr_in_full;
+
+	/*
+	 * The total number of write operations that encountered a full
+	 * outbound ring buffer.
+	 */
+	u64 out_full_total;
+
+	/*
+	 * The number of write operations that were the first to encounter a
+	 * full outbound ring buffer.
+	 */
+	u64 out_full_first;
 };
 
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)
@@ -936,6 +967,21 @@ static inline void *get_per_channel_state(struct vmbus_channel *c)
 static inline void set_channel_pending_send_size(struct vmbus_channel *c,
 						 u32 size)
 {
+	unsigned long flags;
+
+	if (size) {
+		spin_lock_irqsave(&c->outbound.ring_lock, flags);
+		++c->out_full_total;
+
+		if (!c->out_full_flag) {
+			++c->out_full_first;
+			c->out_full_flag = true;
+		}
+		spin_unlock_irqrestore(&c->outbound.ring_lock, flags);
+	} else {
+		c->out_full_flag = false;
+	}
+
 	c->outbound.ring_buffer->pending_send_sz = size;
 }
 

commit 593db80390cf40f1b9dcc790020d2edae87183fb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Jan 10 16:25:32 2019 +0200

    vmbus: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: devel@linuxdriverproject.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by:  Michael Kelley <mikelley@microsoft.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index dcb6977afce9..d5678a0fe598 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -222,8 +222,8 @@ static inline u32 hv_get_avail_to_write_percent(
  * struct contains the fundamental information about an offer.
  */
 struct vmbus_channel_offer {
-	uuid_le if_type;
-	uuid_le if_instance;
+	guid_t if_type;
+	guid_t if_instance;
 
 	/*
 	 * These two fields are not currently used.
@@ -614,8 +614,8 @@ struct vmbus_channel_initiate_contact {
 /* Hyper-V socket: guest's connect()-ing to host */
 struct vmbus_channel_tl_connect_request {
 	struct vmbus_channel_message_header header;
-	uuid_le guest_endpoint_id;
-	uuid_le host_service_id;
+	guid_t guest_endpoint_id;
+	guid_t host_service_id;
 } __packed;
 
 struct vmbus_channel_version_response {
@@ -714,7 +714,7 @@ enum vmbus_device_type {
 
 struct vmbus_device {
 	u16  dev_type;
-	uuid_le guid;
+	guid_t guid;
 	bool perf_device;
 };
 
@@ -1096,7 +1096,7 @@ struct hv_driver {
 	bool hvsock;
 
 	/* the device type supported by this driver */
-	uuid_le dev_type;
+	guid_t dev_type;
 	const struct hv_vmbus_device_id *id_table;
 
 	struct device_driver driver;
@@ -1116,10 +1116,10 @@ struct hv_driver {
 /* Base device object */
 struct hv_device {
 	/* the device type id of this device */
-	uuid_le dev_type;
+	guid_t dev_type;
 
 	/* the device instance id of this device */
-	uuid_le dev_instance;
+	guid_t dev_instance;
 	u16 vendor_id;
 	u16 device_id;
 
@@ -1188,102 +1188,102 @@ void vmbus_free_mmio(resource_size_t start, resource_size_t size);
  * {f8615163-df3e-46c5-913f-f2d2f965ed0e}
  */
 #define HV_NIC_GUID \
-	.guid = UUID_LE(0xf8615163, 0xdf3e, 0x46c5, 0x91, 0x3f, \
-			0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e)
+	.guid = GUID_INIT(0xf8615163, 0xdf3e, 0x46c5, 0x91, 0x3f, \
+			  0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e)
 
 /*
  * IDE GUID
  * {32412632-86cb-44a2-9b5c-50d1417354f5}
  */
 #define HV_IDE_GUID \
-	.guid = UUID_LE(0x32412632, 0x86cb, 0x44a2, 0x9b, 0x5c, \
-			0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5)
+	.guid = GUID_INIT(0x32412632, 0x86cb, 0x44a2, 0x9b, 0x5c, \
+			  0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5)
 
 /*
  * SCSI GUID
  * {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f}
  */
 #define HV_SCSI_GUID \
-	.guid = UUID_LE(0xba6163d9, 0x04a1, 0x4d29, 0xb6, 0x05, \
-			0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f)
+	.guid = GUID_INIT(0xba6163d9, 0x04a1, 0x4d29, 0xb6, 0x05, \
+			  0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f)
 
 /*
  * Shutdown GUID
  * {0e0b6031-5213-4934-818b-38d90ced39db}
  */
 #define HV_SHUTDOWN_GUID \
-	.guid = UUID_LE(0x0e0b6031, 0x5213, 0x4934, 0x81, 0x8b, \
-			0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb)
+	.guid = GUID_INIT(0x0e0b6031, 0x5213, 0x4934, 0x81, 0x8b, \
+			  0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb)
 
 /*
  * Time Synch GUID
  * {9527E630-D0AE-497b-ADCE-E80AB0175CAF}
  */
 #define HV_TS_GUID \
-	.guid = UUID_LE(0x9527e630, 0xd0ae, 0x497b, 0xad, 0xce, \
-			0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf)
+	.guid = GUID_INIT(0x9527e630, 0xd0ae, 0x497b, 0xad, 0xce, \
+			  0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf)
 
 /*
  * Heartbeat GUID
  * {57164f39-9115-4e78-ab55-382f3bd5422d}
  */
 #define HV_HEART_BEAT_GUID \
-	.guid = UUID_LE(0x57164f39, 0x9115, 0x4e78, 0xab, 0x55, \
-			0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d)
+	.guid = GUID_INIT(0x57164f39, 0x9115, 0x4e78, 0xab, 0x55, \
+			  0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d)
 
 /*
  * KVP GUID
  * {a9a0f4e7-5a45-4d96-b827-8a841e8c03e6}
  */
 #define HV_KVP_GUID \
-	.guid = UUID_LE(0xa9a0f4e7, 0x5a45, 0x4d96, 0xb8, 0x27, \
-			0x8a, 0x84, 0x1e, 0x8c, 0x03, 0xe6)
+	.guid = GUID_INIT(0xa9a0f4e7, 0x5a45, 0x4d96, 0xb8, 0x27, \
+			  0x8a, 0x84, 0x1e, 0x8c, 0x03, 0xe6)
 
 /*
  * Dynamic memory GUID
  * {525074dc-8985-46e2-8057-a307dc18a502}
  */
 #define HV_DM_GUID \
-	.guid = UUID_LE(0x525074dc, 0x8985, 0x46e2, 0x80, 0x57, \
-			0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02)
+	.guid = GUID_INIT(0x525074dc, 0x8985, 0x46e2, 0x80, 0x57, \
+			  0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02)
 
 /*
  * Mouse GUID
  * {cfa8b69e-5b4a-4cc0-b98b-8ba1a1f3f95a}
  */
 #define HV_MOUSE_GUID \
-	.guid = UUID_LE(0xcfa8b69e, 0x5b4a, 0x4cc0, 0xb9, 0x8b, \
-			0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a)
+	.guid = GUID_INIT(0xcfa8b69e, 0x5b4a, 0x4cc0, 0xb9, 0x8b, \
+			  0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a)
 
 /*
  * Keyboard GUID
  * {f912ad6d-2b17-48ea-bd65-f927a61c7684}
  */
 #define HV_KBD_GUID \
-	.guid = UUID_LE(0xf912ad6d, 0x2b17, 0x48ea, 0xbd, 0x65, \
-			0xf9, 0x27, 0xa6, 0x1c, 0x76, 0x84)
+	.guid = GUID_INIT(0xf912ad6d, 0x2b17, 0x48ea, 0xbd, 0x65, \
+			  0xf9, 0x27, 0xa6, 0x1c, 0x76, 0x84)
 
 /*
  * VSS (Backup/Restore) GUID
  */
 #define HV_VSS_GUID \
-	.guid = UUID_LE(0x35fa2e29, 0xea23, 0x4236, 0x96, 0xae, \
-			0x3a, 0x6e, 0xba, 0xcb, 0xa4, 0x40)
+	.guid = GUID_INIT(0x35fa2e29, 0xea23, 0x4236, 0x96, 0xae, \
+			  0x3a, 0x6e, 0xba, 0xcb, 0xa4, 0x40)
 /*
  * Synthetic Video GUID
  * {DA0A7802-E377-4aac-8E77-0558EB1073F8}
  */
 #define HV_SYNTHVID_GUID \
-	.guid = UUID_LE(0xda0a7802, 0xe377, 0x4aac, 0x8e, 0x77, \
-			0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8)
+	.guid = GUID_INIT(0xda0a7802, 0xe377, 0x4aac, 0x8e, 0x77, \
+			  0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8)
 
 /*
  * Synthetic FC GUID
  * {2f9bcc4a-0069-4af3-b76b-6fd0be528cda}
  */
 #define HV_SYNTHFC_GUID \
-	.guid = UUID_LE(0x2f9bcc4a, 0x0069, 0x4af3, 0xb7, 0x6b, \
-			0x6f, 0xd0, 0xbe, 0x52, 0x8c, 0xda)
+	.guid = GUID_INIT(0x2f9bcc4a, 0x0069, 0x4af3, 0xb7, 0x6b, \
+			  0x6f, 0xd0, 0xbe, 0x52, 0x8c, 0xda)
 
 /*
  * Guest File Copy Service
@@ -1291,16 +1291,16 @@ void vmbus_free_mmio(resource_size_t start, resource_size_t size);
  */
 
 #define HV_FCOPY_GUID \
-	.guid = UUID_LE(0x34d14be3, 0xdee4, 0x41c8, 0x9a, 0xe7, \
-			0x6b, 0x17, 0x49, 0x77, 0xc1, 0x92)
+	.guid = GUID_INIT(0x34d14be3, 0xdee4, 0x41c8, 0x9a, 0xe7, \
+			  0x6b, 0x17, 0x49, 0x77, 0xc1, 0x92)
 
 /*
  * NetworkDirect. This is the guest RDMA service.
  * {8c2eaf3d-32a7-4b09-ab99-bd1f1c86b501}
  */
 #define HV_ND_GUID \
-	.guid = UUID_LE(0x8c2eaf3d, 0x32a7, 0x4b09, 0xab, 0x99, \
-			0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01)
+	.guid = GUID_INIT(0x8c2eaf3d, 0x32a7, 0x4b09, 0xab, 0x99, \
+			  0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01)
 
 /*
  * PCI Express Pass Through
@@ -1308,8 +1308,8 @@ void vmbus_free_mmio(resource_size_t start, resource_size_t size);
  */
 
 #define HV_PCIE_GUID \
-	.guid = UUID_LE(0x44c4f61d, 0x4444, 0x4400, 0x9d, 0x52, \
-			0x80, 0x2e, 0x27, 0xed, 0xe1, 0x9f)
+	.guid = GUID_INIT(0x44c4f61d, 0x4444, 0x4400, 0x9d, 0x52, \
+			  0x80, 0x2e, 0x27, 0xed, 0xe1, 0x9f)
 
 /*
  * Linux doesn't support the 3 devices: the first two are for
@@ -1321,16 +1321,16 @@ void vmbus_free_mmio(resource_size_t start, resource_size_t size);
  */
 
 #define HV_AVMA1_GUID \
-	.guid = UUID_LE(0xf8e65716, 0x3cb3, 0x4a06, 0x9a, 0x60, \
-			0x18, 0x89, 0xc5, 0xcc, 0xca, 0xb5)
+	.guid = GUID_INIT(0xf8e65716, 0x3cb3, 0x4a06, 0x9a, 0x60, \
+			  0x18, 0x89, 0xc5, 0xcc, 0xca, 0xb5)
 
 #define HV_AVMA2_GUID \
-	.guid = UUID_LE(0x3375baf4, 0x9e15, 0x4b30, 0xb7, 0x65, \
-			0x67, 0xac, 0xb1, 0x0d, 0x60, 0x7b)
+	.guid = GUID_INIT(0x3375baf4, 0x9e15, 0x4b30, 0xb7, 0x65, \
+			  0x67, 0xac, 0xb1, 0x0d, 0x60, 0x7b)
 
 #define HV_RDV_GUID \
-	.guid = UUID_LE(0x276aacf4, 0xac15, 0x426c, 0x98, 0xdd, \
-			0x75, 0x21, 0xad, 0x3f, 0x01, 0xfe)
+	.guid = GUID_INIT(0x276aacf4, 0xac15, 0x426c, 0x98, 0xdd, \
+			  0x75, 0x21, 0xad, 0x3f, 0x01, 0xfe)
 
 /*
  * Common header for Hyper-V ICs
@@ -1432,7 +1432,7 @@ struct ictimesync_ref_data {
 struct hyperv_service_callback {
 	u8 msg_type;
 	char *log_msg;
-	uuid_le data;
+	guid_t data;
 	struct vmbus_channel *channel;
 	void (*callback)(void *context);
 };
@@ -1452,8 +1452,8 @@ void vmbus_setevent(struct vmbus_channel *channel);
 
 extern __u32 vmbus_proto_version;
 
-int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,
-				  const uuid_le *shv_host_servie_id);
+int vmbus_send_tl_connect_request(const guid_t *shv_guest_servie_id,
+				  const guid_t *shv_host_servie_id);
 void vmbus_set_event(struct vmbus_channel *channel);
 
 /* Get the start of the ring buffer. */

commit ba50bf1ce9a51fc97db58b96d01306aa70bc3979
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 17 20:16:09 2018 +0000

    Drivers: hv: vmbus: Check for ring when getting debug info
    
    fc96df16a1ce is good and can already fix the "return stack garbage" issue,
    but let's also improve hv_ringbuffer_get_debuginfo(), which would silently
    return stack garbage, if people forget to check channel->state or
    ring_info->ring_buffer, when using the function in the future.
    
    Having an error check in the function would eliminate the potential risk.
    
    Add a Fixes tag to indicate the patch depdendency.
    
    Fixes: fc96df16a1ce ("Drivers: hv: vmbus: Return -EINVAL for the sys files for unopened channels")
    Cc: stable@vger.kernel.org
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f0885cc01db6..dcb6977afce9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1159,8 +1159,9 @@ struct hv_ring_buffer_debug_info {
 	u32 bytes_avail_towrite;
 };
 
-void hv_ringbuffer_get_debuginfo(const struct hv_ring_buffer_info *ring_info,
-			    struct hv_ring_buffer_debug_info *debug_info);
+
+int hv_ringbuffer_get_debuginfo(const struct hv_ring_buffer_info *ring_info,
+				struct hv_ring_buffer_debug_info *debug_info);
 
 /* Vmbus interface */
 #define vmbus_driver_register(driver)	\

commit c4aa8b2a8b63a269d63acafc0358a7b9f5d9e563
Merge: 48d365de7746 40e020c129cf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 10 09:22:34 2018 +0100

    Merge 4.20-rc6 into char-misc-next
    
    This should resolve the hv driver merge conflict.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37c2578c0c40e286bc0d30bdc05290b2058cf66e
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 3 00:54:35 2018 +0000

    Drivers: hv: vmbus: Offload the handling of channels to two workqueues
    
    vmbus_process_offer() mustn't call channel->sc_creation_callback()
    directly for sub-channels, because sc_creation_callback() ->
    vmbus_open() may never get the host's response to the
    OPEN_CHANNEL message (the host may rescind a channel at any time,
    e.g. in the case of hot removing a NIC), and vmbus_onoffer_rescind()
    may not wake up the vmbus_open() as it's blocked due to a non-zero
    vmbus_connection.offer_in_progress, and finally we have a deadlock.
    
    The above is also true for primary channels, if the related device
    drivers use sync probing mode by default.
    
    And, usually the handling of primary channels and sub-channels can
    depend on each other, so we should offload them to different
    workqueues to avoid possible deadlock, e.g. in sync-probing mode,
    NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->
    rtnl_lock(), and causes deadlock: the former gets the rtnl_lock
    and waits for all the sub-channels to appear, but the latter
    can't get the rtnl_lock and this blocks the handling of sub-channels.
    
    The patch can fix the multiple-NIC deadlock described above for
    v3.x kernels (e.g. RHEL 7.x) which don't support async-probing
    of devices, and v4.4, v4.9, v4.14 and v4.18 which support async-probing
    but don't enable async-probing for Hyper-V drivers (yet).
    
    The patch can also fix the hang issue in sub-channel's handling described
    above for all versions of kernels, including v4.19 and v4.20-rc4.
    
    So actually the patch should be applied to all the existing kernels,
    not only the kernels that have 8195b1396ec8.
    
    Fixes: 8195b1396ec8 ("hv_netvsc: fix deadlock on hotplug")
    Cc: stable@vger.kernel.org
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b3e24368930a..14131b6fae68 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -905,6 +905,13 @@ struct vmbus_channel {
 
 	bool probe_done;
 
+	/*
+	 * We must offload the handling of the primary/sub channels
+	 * from the single-threaded vmbus_connection.work_queue to
+	 * two different workqueue, otherwise we can block
+	 * vmbus_connection.work_queue and hang: see vmbus_process_offer().
+	 */
+	struct work_struct add_channel_work;
 };
 
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)

commit 4d3c5c69191f98c7f7e699ff08d2fd96d7070ddb
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Nov 26 02:17:56 2018 +0000

    Drivers: hv: vmbus: Remove the useless API vmbus_get_outgoing_channel()
    
    Commit d86adf482b84 ("scsi: storvsc: Enable multi-queue support") removed
    the usage of the API in Jan 2017, and the API is not used since then.
    
    netvsc and storvsc have their own algorithms to determine the outgoing
    channel, so this API is useless.
    
    And the API is potentially unsafe, because it reads primary->num_sc without
    any lock held. This can be risky considering the RESCIND-OFFER message.
    
    Let's remove the API.
    
    Cc: Long Li <longli@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b3e24368930a..07a367f5e22f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -830,15 +830,6 @@ struct vmbus_channel {
 	 * All Sub-channels of a primary channel are linked here.
 	 */
 	struct list_head sc_list;
-	/*
-	 * Current number of sub-channels.
-	 */
-	int num_sc;
-	/*
-	 * Number of a sub-channel (position within sc_list) which is supposed
-	 * to be used as the next outgoing channel.
-	 */
-	int next_oc;
 	/*
 	 * The primary channel this sub-channel belongs to.
 	 * This will be NULL for the primary channel.
@@ -965,14 +956,6 @@ void vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,
 void vmbus_set_chn_rescind_callback(struct vmbus_channel *channel,
 		void (*chn_rescind_cb)(struct vmbus_channel *));
 
-/*
- * Retrieve the (sub) channel on which to send an outgoing request.
- * When a primary channel has multiple sub-channels, we choose a
- * channel whose VCPU binding is closest to the VCPU on which
- * this call is being made.
- */
-struct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary);
-
 /*
  * Check if sub-channels have already been offerred. This API will be useful
  * when the driver is unloaded after establishing sub-channels. In this case,

commit ae6935ed7d424ffa74d634da00767e7b03c98fd3
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Sep 14 09:10:17 2018 -0700

    vmbus: split ring buffer allocation from open
    
    The UIO driver needs the ring buffer to be persistent(reused)
    across open/close. Split the allocation and setup of ring buffer
    out of vmbus_open. For normal usage vmbus_open/vmbus_close there
    are no changes; only impacts uio_hv_generic which needs to keep
    ring buffer memory and reuse when application restarts.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a6c32d2d090b..b3e24368930a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -741,6 +741,7 @@ struct vmbus_channel {
 	/* Allocated memory for ring buffer */
 	struct page *ringbuffer_page;
 	u32 ringbuffer_pagecount;
+	u32 ringbuffer_send_offset;
 	struct hv_ring_buffer_info outbound;	/* send to parent */
 	struct hv_ring_buffer_info inbound;	/* receive from parent */
 
@@ -1021,6 +1022,14 @@ struct vmbus_packet_mpb_array {
 	struct hv_mpb_array range;
 } __packed;
 
+int vmbus_alloc_ring(struct vmbus_channel *channel,
+		     u32 send_size, u32 recv_size);
+void vmbus_free_ring(struct vmbus_channel *channel);
+
+int vmbus_connect_ring(struct vmbus_channel *channel,
+		       void (*onchannel_callback)(void *context),
+		       void *context);
+int vmbus_disconnect_ring(struct vmbus_channel *channel);
 
 extern int vmbus_open(struct vmbus_channel *channel,
 			    u32 send_ringbuffersize,

commit 52a42c2a90226dc61c99bbd0cb096deeb52c334b
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Sep 14 09:10:16 2018 -0700

    vmbus: keep pointer to ring buffer page
    
    Avoid going from struct page to virt address (and back) by just
    keeping pointer to the allocated pages instead of virt address.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6c4575c7f46b..a6c32d2d090b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -739,7 +739,7 @@ struct vmbus_channel {
 	u32 ringbuffer_gpadlhandle;
 
 	/* Allocated memory for ring buffer */
-	void *ringbuffer_pages;
+	struct page *ringbuffer_page;
 	u32 ringbuffer_pagecount;
 	struct hv_ring_buffer_info outbound;	/* send to parent */
 	struct hv_ring_buffer_info inbound;	/* receive from parent */

commit 800b932969c53c4044ff9f9fd1ee793a87fa8ef0
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Sep 14 09:10:15 2018 -0700

    vmbus: pass channel to hv_process_channel_removal
    
    Rather than passing relid and then looking up the channel.
    Pass the channel directly, since caller already knows it.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2c3798bcb01c..6c4575c7f46b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1443,7 +1443,7 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp, u8 *buf,
 				const int *srv_version, int srv_vercnt,
 				int *nego_fw_version, int *nego_srv_version);
 
-void hv_process_channel_removal(u32 relid);
+void hv_process_channel_removal(struct vmbus_channel *channel);
 
 void vmbus_setevent(struct vmbus_channel *channel);
 /*

commit d765edbb301c0e196015a59b17420558088ea33f
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Aug 10 23:06:08 2018 +0000

    vmbus: add driver_override support
    
    Add support for overriding the default driver for a VMBus device
    in the same way that it can be done for PCI devices. This patch
    adds the /sys/bus/vmbus/devices/.../driver_override file
    and the logic for matching.
    
    This is used by driverctl tool to do driver override.
    https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgitlab.com%2Fdriverctl%2Fdriverctl&amp;data=02%7C01%7Ckys%40microsoft.com%7C42e803feb2c544ef6ea908d5fd538878%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636693457619960040&amp;sdata=kEyYHRIjNZCk%2B37moCSqbrZL426YccNQrsWpENcrZdw%3D&amp;reserved=0
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index efda23cf32c7..2c3798bcb01c 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1125,6 +1125,7 @@ struct hv_device {
 	u16 device_id;
 
 	struct device device;
+	char *driver_override; /* Driver name to force a match */
 
 	struct vmbus_channel *channel;
 	struct kset	     *channels_kset;

commit d3b26dd7cb0e3433bfd3c1d4dcf74c6039bb49fb
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Aug 2 03:08:23 2018 +0000

    Drivers: hv: vmbus: Reset the channel callback in vmbus_onoffer_rescind()
    
    Before setting channel->rescind in vmbus_rescind_cleanup(), we should make
    sure the channel callback won't run any more, otherwise a high-level
    driver like pci_hyperv, which may be infinitely waiting for the host VSP's
    response and notices the channel has been rescinded, can't safely give
    up: e.g., in hv_pci_protocol_negotiation() -> wait_for_response(), it's
    unsafe to exit from wait_for_response() and proceed with the on-stack
    variable "comp_pkt" popped. The issue was originally spotted by
    Michael Kelley <mikelley@microsoft.com>.
    
    In vmbus_close_internal(), the patch also minimizes the range protected by
    disabling/enabling channel->callback_event: we don't really need that for
    the whole function.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Cc: stable@vger.kernel.org
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2330f08062c7..efda23cf32c7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1061,6 +1061,8 @@ extern int vmbus_establish_gpadl(struct vmbus_channel *channel,
 extern int vmbus_teardown_gpadl(struct vmbus_channel *channel,
 				     u32 gpadl_handle);
 
+void vmbus_reset_channel_cb(struct vmbus_channel *channel);
+
 extern int vmbus_recvpacket(struct vmbus_channel *channel,
 				  void *buffer,
 				  u32 bufferlen,

commit 71b38245acb05a38d2d861792bdd99cd9f6a0f78
Author: Michael Kelley <mikelley@microsoft.com>
Date:   Tue Jun 5 13:37:51 2018 -0700

    Drivers: hv: vmbus: Add comments on ring buffer signaling
    
    Add comments describing intricacies of Hyper-V ring buffer
    signaling code.  This information is not in Hyper-V public
    documents, so include here to capture the knowledge for
    future coders.
    
    There are no code changes in this commit.
    
    Signed-off-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 3a3012f57be4..2330f08062c7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -89,18 +89,33 @@ struct hv_ring_buffer {
 	u32 interrupt_mask;
 
 	/*
-	 * Win8 uses some of the reserved bits to implement
-	 * interrupt driven flow management. On the send side
-	 * we can request that the receiver interrupt the sender
-	 * when the ring transitions from being full to being able
-	 * to handle a message of size "pending_send_sz".
+	 * WS2012/Win8 and later versions of Hyper-V implement interrupt
+	 * driven flow management. The feature bit feat_pending_send_sz
+	 * is set by the host on the host->guest ring buffer, and by the
+	 * guest on the guest->host ring buffer.
 	 *
-	 * Add necessary state for this enhancement.
+	 * The meaning of the feature bit is a bit complex in that it has
+	 * semantics that apply to both ring buffers.  If the guest sets
+	 * the feature bit in the guest->host ring buffer, the guest is
+	 * telling the host that:
+	 * 1) It will set the pending_send_sz field in the guest->host ring
+	 *    buffer when it is waiting for space to become available, and
+	 * 2) It will read the pending_send_sz field in the host->guest
+	 *    ring buffer and interrupt the host when it frees enough space
+	 *
+	 * Similarly, if the host sets the feature bit in the host->guest
+	 * ring buffer, the host is telling the guest that:
+	 * 1) It will set the pending_send_sz field in the host->guest ring
+	 *    buffer when it is waiting for space to become available, and
+	 * 2) It will read the pending_send_sz field in the guest->host
+	 *    ring buffer and interrupt the guest when it frees enough space
+	 *
+	 * If either the guest or host does not set the feature bit that it
+	 * owns, that guest or host must do polling if it encounters a full
+	 * ring buffer, and not signal the other end with an interrupt.
 	 */
 	u32 pending_send_sz;
-
 	u32 reserved1[12];
-
 	union {
 		struct {
 			u32 feat_pending_send_sz:1;

commit 5f85942c2ea2ed59d8f19c954bbb0f5c1a2ebdd1
Merge: 0c14e43a42e4 1b5c2cb19668
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 13:01:12 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: ufs, qedf, mpt3sas, lpfc,
      xfcp, hisi_sas, cxlflash, qla2xxx.
    
      In the absence of Nic, we're also taking target updates which are
      mostly minor except for the tcmu refactor.
    
      The only real core change to worry about is the removal of high page
      bouncing (in sas, storvsc and iscsi). This has been well tested and no
      problems have shown up so far"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (268 commits)
      scsi: lpfc: update driver version to 12.0.0.4
      scsi: lpfc: Fix port initialization failure.
      scsi: lpfc: Fix 16gb hbas failing cq create.
      scsi: lpfc: Fix crash in blk_mq layer when executing modprobe -r lpfc
      scsi: lpfc: correct oversubscription of nvme io requests for an adapter
      scsi: lpfc: Fix MDS diagnostics failure (Rx < Tx)
      scsi: hisi_sas: Mark PHY as in reset for nexus reset
      scsi: hisi_sas: Fix return value when get_free_slot() failed
      scsi: hisi_sas: Terminate STP reject quickly for v2 hw
      scsi: hisi_sas: Add v2 hw force PHY function for internal ATA command
      scsi: hisi_sas: Include TMF elements in struct hisi_sas_slot
      scsi: hisi_sas: Try wait commands before before controller reset
      scsi: hisi_sas: Init disks after controller reset
      scsi: hisi_sas: Create a scsi_host_template per HW module
      scsi: hisi_sas: Reset disks when discovered
      scsi: hisi_sas: Add LED feature for v3 hw
      scsi: hisi_sas: Change common allocation mode of device id
      scsi: hisi_sas: change slot index allocation mode
      scsi: hisi_sas: Introduce hisi_sas_phy_set_linkrate()
      scsi: hisi_sas: fix a typo in hisi_sas_task_prep()
      ...

commit ae20b254306a6a47054ea0eb8444e0bd8e71fe12
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat May 12 02:30:33 2018 -0700

    Drivers: hv: vmbus: enable VMBus protocol version 5.0
    
    With VMBus protocol 5.0, we're able to better support new features, e.g.
    running two or more VMBus drivers simultaneously in a single VM -- note:
    we can't simply load the current VMBus driver twice, instead, a secondary
    VMBus driver must be implemented.
    
    This patch adds the support for the new VMBus protocol, which is available
    on new Windows hosts, by:
    
    1) We still use SINT2 for compatibility;
    2) We must use Connection ID 4 for the Initiate Contact Message, and for
    subsequent messages, we must use the Message Connection ID field in
    the host-returned VersionResponse Message.
    
    Notes for developers of the secondary VMBus driver:
    1) Must use VMBus protocol 5.0 as well;
    2) Must use a different SINT number that is not in use.
    3) Must use Connection ID 4 for the Initiate Contact Message, and for
    subsequent messages, must use the Message Connection ID field in
    the host-returned VersionResponse Message.
    4) It's possible that the primary VMBus driver using protocol version 4.0
    can work with a secondary VMBus driver using protocol version 5.0, but it's
    recommended that both should use 5.0 for new Hyper-V features in the future.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 192ed8fbc403..11b5612dc066 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -163,6 +163,7 @@ static inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)
  * 2 . 4  (Windows 8)
  * 3 . 0  (Windows 8 R2)
  * 4 . 0  (Windows 10)
+ * 5 . 0  (Newer Windows 10)
  */
 
 #define VERSION_WS2008  ((0 << 16) | (13))
@@ -170,10 +171,11 @@ static inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)
 #define VERSION_WIN8    ((2 << 16) | (4))
 #define VERSION_WIN8_1    ((3 << 16) | (0))
 #define VERSION_WIN10	((4 << 16) | (0))
+#define VERSION_WIN10_V5 ((5 << 16) | (0))
 
 #define VERSION_INVAL -1
 
-#define VERSION_CURRENT VERSION_WIN10
+#define VERSION_CURRENT VERSION_WIN10_V5
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)
@@ -570,7 +572,14 @@ struct vmbus_channel_initiate_contact {
 	struct vmbus_channel_message_header header;
 	u32 vmbus_version_requested;
 	u32 target_vcpu; /* The VCPU the host should respond to */
-	u64 interrupt_page;
+	union {
+		u64 interrupt_page;
+		struct {
+			u8	msg_sint;
+			u8	padding1[3];
+			u32	padding2;
+		};
+	};
 	u64 monitor_page1;
 	u64 monitor_page2;
 } __packed;
@@ -585,6 +594,19 @@ struct vmbus_channel_tl_connect_request {
 struct vmbus_channel_version_response {
 	struct vmbus_channel_message_header header;
 	u8 version_supported;
+
+	u8 connection_state;
+	u16 padding;
+
+	/*
+	 * On new hosts that support VMBus protocol 5.0, we must use
+	 * VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate Contact Message,
+	 * and for subsequent messages, we must use the Message Connection ID
+	 * field in the host-returned Version Response Message.
+	 *
+	 * On old hosts, we should always use VMBUS_MESSAGE_CONNECTION_ID (1).
+	 */
+	u32 msg_conn_id;
 } __packed;
 
 enum vmbus_channel_state {

commit 63273cb40101b6f303a5493f1bdf629d4ab3746b
Author: Long Li <longli@microsoft.com>
Date:   Tue Mar 27 17:48:38 2018 -0700

    scsi: vmbus: Add function to report available ring buffer to write in total ring size percentage
    
    Netvsc has a function to calculate how much ring buffer in percentage is
    available to write. This function is also useful for storvsc and other
    vmbus devices.
    
    Define a similar function in vmbus to be used by other vmbus devices.
    
    Signed-off-by: Long Li <longli@microsoft.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 192ed8fbc403..9ac954ee577e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,6 +35,7 @@
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
 #include <linux/interrupt.h>
+#include <linux/reciprocal_div.h>
 
 #define MAX_PAGE_BUFFER_COUNT				32
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
@@ -120,6 +121,7 @@ struct hv_ring_buffer {
 struct hv_ring_buffer_info {
 	struct hv_ring_buffer *ring_buffer;
 	u32 ring_size;			/* Include the shared header */
+	struct reciprocal_value ring_size_div10_reciprocal;
 	spinlock_t ring_lock;
 
 	u32 ring_datasize;		/* < ring_size */
@@ -154,6 +156,16 @@ static inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)
 	return write;
 }
 
+static inline u32 hv_get_avail_to_write_percent(
+		const struct hv_ring_buffer_info *rbi)
+{
+	u32 avail_write = hv_get_bytes_to_write(rbi);
+
+	return reciprocal_divide(
+			(avail_write  << 3) + (avail_write << 1),
+			rbi->ring_size_div10_reciprocal);
+}
+
 /*
  * VMBUS version is 32 bit entity broken up into
  * two 16 bit quantities: major_number. minor_number.

commit d8312a3f61024352f1c7cb967571fd53631b0d6c
Merge: e9092d0d9796 e01bca2fc698
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 9 11:42:31 2018 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm
    
    Pull kvm updates from Paolo Bonzini:
     "ARM:
       - VHE optimizations
    
       - EL2 address space randomization
    
       - speculative execution mitigations ("variant 3a", aka execution past
         invalid privilege register access)
    
       - bugfixes and cleanups
    
      PPC:
       - improvements for the radix page fault handler for HV KVM on POWER9
    
      s390:
       - more kvm stat counters
    
       - virtio gpu plumbing
    
       - documentation
    
       - facilities improvements
    
      x86:
       - support for VMware magic I/O port and pseudo-PMCs
    
       - AMD pause loop exiting
    
       - support for AMD core performance extensions
    
       - support for synchronous register access
    
       - expose nVMX capabilities to userspace
    
       - support for Hyper-V signaling via eventfd
    
       - use Enlightened VMCS when running on Hyper-V
    
       - allow userspace to disable MWAIT/HLT/PAUSE vmexits
    
       - usual roundup of optimizations and nested virtualization bugfixes
    
      Generic:
       - API selftest infrastructure (though the only tests are for x86 as
         of now)"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/virt/kvm/kvm: (174 commits)
      kvm: x86: fix a prototype warning
      kvm: selftests: add sync_regs_test
      kvm: selftests: add API testing infrastructure
      kvm: x86: fix a compile warning
      KVM: X86: Add Force Emulation Prefix for "emulate the next instruction"
      KVM: X86: Introduce handle_ud()
      KVM: vmx: unify adjacent #ifdefs
      x86: kvm: hide the unused 'cpu' variable
      KVM: VMX: remove bogus WARN_ON in handle_ept_misconfig
      Revert "KVM: X86: Fix SMRAM accessing even if VM is shutdown"
      kvm: Add emulation for movups/movupd
      KVM: VMX: raise internal error for exception during invalid protected mode state
      KVM: nVMX: Optimization: Dont set KVM_REQ_EVENT when VMExit with nested_run_pending
      KVM: nVMX: Require immediate-exit when event reinjected to L2 and L1 event pending
      KVM: x86: Fix misleading comments on handling pending exceptions
      KVM: x86: Rename interrupt.pending to interrupt.injected
      KVM: VMX: No need to clear pending NMI/interrupt on inject realmode interrupt
      x86/kvm: use Enlightened VMCS when running on Hyper-V
      x86/hyper-v: detect nested features
      x86/hyper-v: define struct hv_enlightened_vmcs and clean field bits
      ...

commit 5a485803221777013944cbd1a7cd5c62efba3ffa
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue Mar 20 15:02:05 2018 +0100

    x86/hyper-v: move hyperv.h out of uapi
    
    hyperv.h is not part of uapi, there are no (known) users outside of kernel.
    We are making changes to this file to match current Hyper-V Hypervisor
    Top-Level Functional Specification (TLFS, see:
    https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs)
    and we don't want to maintain backwards compatibility.
    
    Move the file renaming to hyperv-tlfs.h to avoid confusing it with
    mshyperv.h. In future, all definitions from TLFS should go to it and
    all kernel objects should go to mshyperv.h or include/linux/hyperv.h.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Radim Krm <rkrcmar@redhat.com>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 93bd6fcd6e62..eed8b33b0173 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -26,7 +26,6 @@
 #define _HYPERV_H
 
 #include <uapi/linux/hyperv.h>
-#include <uapi/asm/hyperv.h>
 
 #include <linux/types.h>
 #include <linux/scatterlist.h>

commit ce767047b1b731a1899a528338644f2bfdab8b36
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Sun Mar 4 22:17:17 2018 -0700

    hv_vmbus: Correct the stale comments regarding cpu affinity
    
    The comments doesn't match what the current code does, also have a
    typo. This patch corrects them.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 93bd6fcd6e62..2048f3c3b68a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -844,7 +844,7 @@ struct vmbus_channel {
 
 	/*
 	 * NUMA distribution policy:
-	 * We support teo policies:
+	 * We support two policies:
 	 * 1) Balanced: Here all performance critical channels are
 	 *    distributed evenly amongst all the NUMA nodes.
 	 *    This policy will be the default policy.

commit 51e18a453f5f59a40c721d4aeab082b4e2e9fac6
Merge: 5e54b3c12027 f335195adf04
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Dec 9 22:09:55 2017 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflict was two parallel additions of include files to sch_generic.c,
    no biggie.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0487426fedf7cf800115bac7ea391de1e2e0fa5f
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Dec 1 11:01:49 2017 -0800

    vmbus: make hv_get_ringbuffer_availbytes local
    
    The last use of hv_get_ringbuffer_availbytes in drivers is now
    gone. Only used by the debug info routine so make it static. Also, add
    READ_ONCE() to avoid any possible issues with potentially volatile
    index values.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f3e97c5f94c9..5f8bd0cebddf 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -127,28 +127,6 @@ struct hv_ring_buffer_info {
 	u32 priv_read_index;
 };
 
-/*
- *
- * hv_get_ringbuffer_availbytes()
- *
- * Get number of bytes available to read and to write to
- * for the specified ring buffer
- */
-static inline void
-hv_get_ringbuffer_availbytes(const struct hv_ring_buffer_info *rbi,
-			     u32 *read, u32 *write)
-{
-	u32 read_loc, write_loc, dsize;
-
-	/* Capture the read/write indices before they changed */
-	read_loc = rbi->ring_buffer->read_index;
-	write_loc = rbi->ring_buffer->write_index;
-	dsize = rbi->ring_datasize;
-
-	*write = write_loc >= read_loc ? dsize - (write_loc - read_loc) :
-		read_loc - write_loc;
-	*read = dsize - *write;
-}
 
 static inline u32 hv_get_bytes_to_read(const struct hv_ring_buffer_info *rbi)
 {

commit 7fa32e5ec28b1609abc0b797b58267f725fc3964
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Nov 14 06:53:33 2017 -0700

    Drivers: hv: vmbus: Fix a rescind issue
    
    The current rescind processing code will not correctly handle
    the case where the host immediately rescinds a channel that has
    been offerred. In this case, we could be blocked in the open call and
    since the channel is rescinded, the host will not respond and we could
    be blocked forever in the vmbus open call.i Fix this problem.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f3e97c5f94c9..6c9336626592 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -708,6 +708,7 @@ struct vmbus_channel {
 	u8 monitor_bit;
 
 	bool rescind; /* got rescind msg */
+	struct completion rescind_event;
 
 	u32 ringbuffer_gpadlhandle;
 

commit 6981fbf3780366093858c5d2dcdaadcd1fbb04be
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Oct 29 11:33:40 2017 -0700

    Drivers: hv: vmbus: Expose per-channel interrupts and events counters
    
    When investigating performance, it is useful to be able to look at
    the number of host and guest events per-channel. This is equivalent
    to per-device interrupt statistics.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index ea6b5586ad77..f3e97c5f94c9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -719,6 +719,10 @@ struct vmbus_channel {
 
 	struct vmbus_close_msg close_msg;
 
+	/* Statistics */
+	u64	interrupts;	/* Host to Guest interrupts */
+	u64	sig_events;	/* Guest to Host events */
+
 	/* Channel callback's invoked in softirq context */
 	struct tasklet_struct callback_event;
 	void (*onchannel_callback)(void *context);

commit 58f2c391cc0560231d7636c39d31b1b26c9396b7
Merge: c2e5df616e1a 33d930e59a98
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 16 09:22:22 2017 +0200

    Merge 4.14-rc5 into char-misc-next
    
    We need the fixes in here to resolve merge issues and for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 192b2d78722ffea188e5ec6ae5d55010dce05a4b
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Sep 29 21:09:36 2017 -0700

    Drivers: hv: vmbus: Fix bugs in rescind handling
    
    This patch addresses the following bugs in the current rescind handling code:
    
    1. Fixes a race condition where we may be invoking hv_process_channel_removal()
    on an already freed channel.
    
    2. Prevents indefinite wait when rescinding sub-channels by correctly setting
    the probe_complete state.
    
    I would like to thank Dexuan for patiently reviewing earlier versions of this
    patch and identifying many of the issues fixed here.
    
    Greg, please apply this to 4.14-final.
    
    Fixes: '54a66265d675 ("Drivers: hv: vmbus: Fix rescind handling")'
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Dexuan Cui <decui@microsoft.com>
    Cc: stable@vger.kernel.org # (4.13 and above)
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c458d7b7ad19..6431087816ba 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1403,7 +1403,7 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp, u8 *buf,
 				const int *srv_version, int srv_vercnt,
 				int *nego_fw_version, int *nego_srv_version);
 
-void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
+void hv_process_channel_removal(u32 relid);
 
 void vmbus_setevent(struct vmbus_channel *channel);
 /*

commit c2e5df616e1ae6c2a074cb241ebb65a318ebaf7c
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Thu Sep 21 20:58:49 2017 -0700

    vmbus: add per-channel sysfs info
    
    This extends existing vmbus related sysfs structure to provide per-channel
    state information. This is useful when diagnosing issues with multiple
    queues in networking and storage.
    
    The existing sysfs only displayed information about the primary
    channel. The one place it reported multiple channels was the
    channel_vp_mapping file which violated the sysfs convention
    of one value per file.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c458d7b7ad19..ef16ee039850 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -828,6 +828,11 @@ struct vmbus_channel {
 	 */
 	struct rcu_head rcu;
 
+	/*
+	 * For sysfs per-channel properties.
+	 */
+	struct kobject			kobj;
+
 	/*
 	 * For performance critical channels (storage, networking
 	 * etc,), Hyper-V has a mechanism to enhance the throughput
@@ -1089,6 +1094,7 @@ struct hv_device {
 	struct device device;
 
 	struct vmbus_channel *channel;
+	struct kset	     *channels_kset;
 };
 
 

commit 57e88b43b81301d9b28f124a5576ac43a1cf9e8d
Merge: 3b9f8ed25dbe 773b79f7a7c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 09:25:15 2017 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 platform updates from Ingo Molnar:
     "The main changes include various Hyper-V optimizations such as faster
      hypercalls and faster/better TLB flushes - and there's also some
      Intel-MID cleanups"
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      tracing/hyper-v: Trace hyperv_mmu_flush_tlb_others()
      x86/hyper-v: Support extended CPU ranges for TLB flush hypercalls
      x86/platform/intel-mid: Make several arrays static, to make code smaller
      MAINTAINERS: Add missed file for Hyper-V
      x86/hyper-v: Use hypercall for remote TLB flush
      hyper-v: Globalize vp_index
      x86/hyper-v: Implement rep hypercalls
      hyper-v: Use fast hypercall for HVCALL_SIGNAL_EVENT
      x86/hyper-v: Introduce fast hypercall implementation
      x86/hyper-v: Make hv_do_hypercall() inline
      x86/hyper-v: Include hyperv/ only when CONFIG_HYPERV is set
      x86/platform/intel-mid: Make 'bt_sfi_data' const
      x86/platform/intel-mid: Make IRQ allocation a bit more flexible
      x86/platform/intel-mid: Group timers callbacks together

commit aae3dbb4776e7916b6cd442d00159bea27a695c1
Merge: ec3604c7a5aa 66bed8465a80
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 14:45:08 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
    
     1) Support ipv6 checksum offload in sunvnet driver, from Shannon
        Nelson.
    
     2) Move to RB-tree instead of custom AVL code in inetpeer, from Eric
        Dumazet.
    
     3) Allow generic XDP to work on virtual devices, from John Fastabend.
    
     4) Add bpf device maps and XDP_REDIRECT, which can be used to build
        arbitrary switching frameworks using XDP. From John Fastabend.
    
     5) Remove UFO offloads from the tree, gave us little other than bugs.
    
     6) Remove the IPSEC flow cache, from Florian Westphal.
    
     7) Support ipv6 route offload in mlxsw driver.
    
     8) Support VF representors in bnxt_en, from Sathya Perla.
    
     9) Add support for forward error correction modes to ethtool, from
        Vidya Sagar Ravipati.
    
    10) Add time filter for packet scheduler action dumping, from Jamal Hadi
        Salim.
    
    11) Extend the zerocopy sendmsg() used by virtio and tap to regular
        sockets via MSG_ZEROCOPY. From Willem de Bruijn.
    
    12) Significantly rework value tracking in the BPF verifier, from Edward
        Cree.
    
    13) Add new jump instructions to eBPF, from Daniel Borkmann.
    
    14) Rework rtnetlink plumbing so that operations can be run without
        taking the RTNL semaphore. From Florian Westphal.
    
    15) Support XDP in tap driver, from Jason Wang.
    
    16) Add 32-bit eBPF JIT for ARM, from Shubham Bansal.
    
    17) Add Huawei hinic ethernet driver.
    
    18) Allow to report MD5 keys in TCP inet_diag dumps, from Ivan
        Delalande.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1780 commits)
      i40e: point wb_desc at the nvm_wb_desc during i40e_read_nvm_aq
      i40e: avoid NVM acquire deadlock during NVM update
      drivers: net: xgene: Remove return statement from void function
      drivers: net: xgene: Configure tx/rx delay for ACPI
      drivers: net: xgene: Read tx/rx delay for ACPI
      rocker: fix kcalloc parameter order
      rds: Fix non-atomic operation on shared flag variable
      net: sched: don't use GFP_KERNEL under spin lock
      vhost_net: correctly check tx avail during rx busy polling
      net: mdio-mux: add mdio_mux parameter to mdio_mux_init()
      rxrpc: Make service connection lookup always check for retry
      net: stmmac: Delete dead code for MDIO registration
      gianfar: Fix Tx flow control deactivation
      cxgb4: Ignore MPS_TX_INT_CAUSE[Bubble] for T6
      cxgb4: Fix pause frame count in t4_get_port_stats
      cxgb4: fix memory leak
      tun: rename generic_xdp to skb_xdp
      tun: reserve extra headroom only when XDP is set
      net: dsa: bcm_sf2: Configure IMP port TC2QOS mapping
      net: dsa: bcm_sf2: Advertise number of egress queues
      ...

commit 5dd0fb9b9ffc0ef9b312d05604f4ad0fffc50505
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Aug 16 08:56:26 2017 -0700

    vmbus: remove unused vmbus_sendpacket_ctl
    
    The only usage of vmbus_sendpacket_ctl was by vmbus_sendpacket.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 9692592d43a3..a5f961c4149e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1030,13 +1030,6 @@ extern int vmbus_sendpacket(struct vmbus_channel *channel,
 				  enum vmbus_packet_type type,
 				  u32 flags);
 
-extern int vmbus_sendpacket_ctl(struct vmbus_channel *channel,
-				  void *buffer,
-				  u32 bufferLen,
-				  u64 requestid,
-				  enum vmbus_packet_type type,
-				  u32 flags);
-
 extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
 					    struct hv_page_buffer pagebuffers[],
 					    u32 pagecount,

commit 5a668d8cddbe8bf14379ce110c49ca088a1e9fae
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Aug 16 08:56:25 2017 -0700

    vmbus: remove unused vmubs_sendpacket_pagebuffer_ctl
    
    The function vmbus_sendpacket_pagebuffer_ctl was never used directly.
    Just have vmbus_send_pagebuffer
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 39a080ce17da..9692592d43a3 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1044,14 +1044,6 @@ extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
 					    u32 bufferlen,
 					    u64 requestid);
 
-extern int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
-					   struct hv_page_buffer pagebuffers[],
-					   u32 pagecount,
-					   void *buffer,
-					   u32 bufferlen,
-					   u64 requestid,
-					   u32 flags);
-
 extern int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,
 				     struct vmbus_packet_mpb_array *mpb,
 				     u32 desc_size,

commit 9a603b8e1136f2b55f780fefbcbf84d31844ff2b
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Aug 16 08:56:24 2017 -0700

    vmbus: remove unused vmbus_sendpacket_multipagebuffer
    
    This function is not used anywhere in current code.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b7d7bbec74e0..39a080ce17da 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1052,12 +1052,6 @@ extern int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
 					   u64 requestid,
 					   u32 flags);
 
-extern int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
-					struct hv_multipage_buffer *mpb,
-					void *buffer,
-					u32 bufferlen,
-					u64 requestid);
-
 extern int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,
 				     struct vmbus_packet_mpb_array *mpb,
 				     u32 desc_size,

commit 6f3d791f300618caf82a2be0c27456edd76d5164
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Aug 11 10:03:59 2017 -0700

    Drivers: hv: vmbus: Fix rescind handling issues
    
    This patch handles the following issues that were observed when we are
    handling racing channel offer message and rescind message for the same
    offer:
    
    1. Since the host does not respond to messages on a rescinded channel,
    in the current code, we could be indefinitely blocked on the vmbus_open() call.
    
    2. When a rescinded channel is being closed, if there is a pending interrupt on the
    channel, we could end up freeing the channel that the interrupt handler would run on.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Dexuan Cui <decui@microsoft.com>
    Tested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 27db4e650b8c..07650d0232cc 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -879,6 +879,8 @@ struct vmbus_channel {
 	 */
 	enum hv_numa_policy affinity_policy;
 
+	bool probe_done;
+
 };
 
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)

commit 7415aea6072bab15969b6c3c5b2a193d88095326
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:18 2017 +0200

    hyper-v: Globalize vp_index
    
    To support implementing remote TLB flushing on Hyper-V with a hypercall
    we need to make vp_index available outside of vmbus module. Rename and
    globalize.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-7-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c472bd43bdd7..e2a4fa57f110 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1173,7 +1173,6 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			resource_size_t size, resource_size_t align,
 			bool fb_overlap_ok);
 void vmbus_free_mmio(resource_size_t start, resource_size_t size);
-int vmbus_cpu_number_to_vp_number(int cpu_number);
 
 /*
  * GUID definitions of various offer types - services offered to the guest.

commit 057841713cfff62b4485cdd2b245f05b7ea3ba16
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:16 2017 +0200

    hyper-v: Use fast hypercall for HVCALL_SIGNAL_EVENT
    
    We need to pass only 8 bytes of input for HvSignalEvent which makes it a
    perfect fit for fast hypercall. hv_input_signal_event_buffer is not needed
    any more and hv_input_signal_event is converted to union for convenience.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-5-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6608a71e7d79..c472bd43bdd7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -677,18 +677,6 @@ union hv_connection_id {
 	} u;
 };
 
-/* Definition of the hv_signal_event hypercall input structure. */
-struct hv_input_signal_event {
-	union hv_connection_id connectionid;
-	u16 flag_number;
-	u16 rsvdz;
-};
-
-struct hv_input_signal_event_buffer {
-	u64 align8;
-	struct hv_input_signal_event event;
-};
-
 enum hv_numa_policy {
 	HV_BALANCED = 0,
 	HV_LOCALIZED,
@@ -770,8 +758,7 @@ struct vmbus_channel {
 	} callback_mode;
 
 	bool is_dedicated_interrupt;
-	struct hv_input_signal_event_buffer sig_buf;
-	struct hv_input_signal_event *sig_event;
+	u64 sig_event;
 
 	/*
 	 * Starting with win8, this field will be used to specify

commit fc53662f13b889a5a1c069e79ee1e3d4534df132
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:14 2017 +0200

    x86/hyper-v: Make hv_do_hypercall() inline
    
    We have only three call sites for hv_do_hypercall() and we're going to
    change HVCALL_SIGNAL_EVENT to doing fast hypercall so we can inline this
    function for optimization.
    
    Hyper-V top level functional specification states that r9-r11 registers
    and flags may be clobbered by the hypervisor during hypercall and with
    inlining this is somewhat important, add the clobbers.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-3-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b7d7bbec74e0..6608a71e7d79 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1187,7 +1187,6 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			bool fb_overlap_ok);
 void vmbus_free_mmio(resource_size_t start, resource_size_t size);
 int vmbus_cpu_number_to_vp_number(int cpu_number);
-u64 hv_do_hypercall(u64 control, void *input, void *output);
 
 /*
  * GUID definitions of various offer types - services offered to the guest.

commit 05d00bc94ac27d220d8a78e365d7fa3a26dcca17
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Jun 25 12:30:27 2017 -0700

    vmbus: eliminate duplicate cached index
    
    Don't need cached read index anymore now that packet iterator
    is used. The iterator has the original read index until the
    visible read_index is updated.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 308e1f9706bb..27db4e650b8c 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -125,7 +125,6 @@ struct hv_ring_buffer_info {
 
 	u32 ring_datasize;		/* < ring_size */
 	u32 priv_read_index;
-	u32 cached_read_index;
 };
 
 /*
@@ -178,19 +177,6 @@ static inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)
 	return write;
 }
 
-static inline u32 hv_get_cached_bytes_to_write(
-	const struct hv_ring_buffer_info *rbi)
-{
-	u32 read_loc, write_loc, dsize, write;
-
-	dsize = rbi->ring_datasize;
-	read_loc = rbi->cached_read_index;
-	write_loc = rbi->ring_buffer->write_index;
-
-	write = write_loc >= read_loc ? dsize - (write_loc - read_loc) :
-		read_loc - write_loc;
-	return write;
-}
 /*
  * VMBUS version is 32 bit entity broken up into
  * two 16 bit quantities: major_number. minor_number.

commit 8dd45f2ab005a1f3301296059b23b03ec3dbf79b
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Jun 25 12:30:26 2017 -0700

    vmbus: refactor hv_signal_on_read
    
    The function hv_signal_on_read was defined in hyperv.h and
    only used in one place in ring_buffer code. Clearer to just
    move it inline there.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5e5f966bf37f..308e1f9706bb 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1471,55 +1471,6 @@ hv_get_ring_buffer(const struct hv_ring_buffer_info *ring_info)
 	return ring_info->ring_buffer->buffer;
 }
 
-/*
- * To optimize the flow management on the send-side,
- * when the sender is blocked because of lack of
- * sufficient space in the ring buffer, potential the
- * consumer of the ring buffer can signal the producer.
- * This is controlled by the following parameters:
- *
- * 1. pending_send_sz: This is the size in bytes that the
- *    producer is trying to send.
- * 2. The feature bit feat_pending_send_sz set to indicate if
- *    the consumer of the ring will signal when the ring
- *    state transitions from being full to a state where
- *    there is room for the producer to send the pending packet.
- */
-
-static inline  void hv_signal_on_read(struct vmbus_channel *channel)
-{
-	u32 cur_write_sz, cached_write_sz;
-	u32 pending_sz;
-	struct hv_ring_buffer_info *rbi = &channel->inbound;
-
-	/*
-	 * Issue a full memory barrier before making the signaling decision.
-	 * Here is the reason for having this barrier:
-	 * If the reading of the pend_sz (in this function)
-	 * were to be reordered and read before we commit the new read
-	 * index (in the calling function)  we could
-	 * have a problem. If the host were to set the pending_sz after we
-	 * have sampled pending_sz and go to sleep before we commit the
-	 * read index, we could miss sending the interrupt. Issue a full
-	 * memory barrier to address this.
-	 */
-	virt_mb();
-
-	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
-	/* If the other end is not blocked on write don't bother. */
-	if (pending_sz == 0)
-		return;
-
-	cur_write_sz = hv_get_bytes_to_write(rbi);
-
-	if (cur_write_sz < pending_sz)
-		return;
-
-	cached_write_sz = hv_get_cached_bytes_to_write(rbi);
-	if (cached_write_sz < pending_sz)
-		vmbus_setevent(channel);
-}
-
 /*
  * Mask off host interrupt callback notifications
  */

commit 95c40f41cfaf34e1c07812e93aa4b3263f9953f3
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Jun 25 12:30:25 2017 -0700

    vmbus: drop unused ring_buffer_info elements
    
    The elements ring_data_start_offset and priv_write_index
    are not used.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b7d7bbec74e0..5e5f966bf37f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -124,8 +124,6 @@ struct hv_ring_buffer_info {
 	spinlock_t ring_lock;
 
 	u32 ring_datasize;		/* < ring_size */
-	u32 ring_data_startoffset;
-	u32 priv_write_index;
 	u32 priv_read_index;
 	u32 cached_read_index;
 };

commit 2371cd90abe3fa1b88e15111abf2cc0a26db6e52
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Thu May 18 09:18:12 2017 -0700

    scsi: storvsc: remove unnecessary channel inbound lock
    
    In storvsc driver, inbound messages do not go through inbound lock.  The
    only effect of this lock was is to provide a barrier for connect and
    remove logic.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e09fc8290c2f..b7d7bbec74e0 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -744,7 +744,6 @@ struct vmbus_channel {
 	u32 ringbuffer_pagecount;
 	struct hv_ring_buffer_info outbound;	/* send to parent */
 	struct hv_ring_buffer_info inbound;	/* receive from parent */
-	spinlock_t inbound_lock;
 
 	struct vmbus_close_msg close_msg;
 

commit af82455f7dbd9dc20244d80d033721b30d22c065
Merge: 0be75179df5e 2a76f89fa58c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 19:07:10 2017 -0700

    Merge tag 'char-misc-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the big set of new char/misc driver drivers and features for
      4.12-rc1.
    
      There's lots of new drivers added this time around, new firmware
      drivers from Google, more auxdisplay drivers, extcon drivers, fpga
      drivers, and a bunch of other driver updates. Nothing major, except if
      you happen to have the hardware for these drivers, and then you will
      be happy :)
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'char-misc-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (136 commits)
      firmware: google memconsole: Fix return value check in platform_memconsole_init()
      firmware: Google VPD: Fix return value check in vpd_platform_init()
      goldfish_pipe: fix build warning about using too much stack.
      goldfish_pipe: An implementation of more parallel pipe
      fpga fr br: update supported version numbers
      fpga: region: release FPGA region reference in error path
      fpga altera-hps2fpga: disable/unprepare clock on error in alt_fpga_bridge_probe()
      mei: drop the TODO from samples
      firmware: Google VPD sysfs driver
      firmware: Google VPD: import lib_vpd source files
      misc: lkdtm: Add volatile to intentional NULL pointer reference
      eeprom: idt_89hpesx: Add OF device ID table
      misc: ds1682: Add OF device ID table
      misc: tsl2550: Add OF device ID table
      w1: Remove unneeded use of assert() and remove w1_log.h
      w1: Use kernel common min() implementation
      uio_mf624: Align memory regions to page size and set correct offsets
      uio_mf624: Refactor memory info initialization
      uio: Allow handling of non page-aligned memory regions
      hangcheck-timer: Fix typo in comment
      ...

commit 6f14f443d3e773439fb9cc6f2685ba90d5d026c5
Merge: faeeb317a561 ea6b1720ce25
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 6 07:25:07 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Mostly simple cases of overlapping changes (adding code nearby,
    a function whose name changes, for example).
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 57c0eabbd57e1a0872122525f6eeefe1f6529c33
Merge: 392910cf3f8a c02ed2e75ef4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 27 09:13:04 2017 +0200

    Merge 4.11-rc4 into char-misc-next
    
    We want the char-misc fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4827ee1dca5691c9fc568883170a568db94f9b38
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Mar 4 18:27:18 2017 -0700

    vmbus: expose debug info for drivers
    
    Allow driver to get debug information about state of the ring.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index de9b80ff6698..1fa727fe5f93 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -491,6 +491,12 @@ struct vmbus_channel_rescind_offer {
 	u32 child_relid;
 } __packed;
 
+static inline u32
+hv_ringbuffer_pending_size(const struct hv_ring_buffer_info *rbi)
+{
+	return rbi->ring_buffer->pending_send_sz;
+}
+
 /*
  * Request Offer -- no parameters, SynIC message contains the partition ID
  * Set Snoop -- no parameters, SynIC message contains the partition ID
@@ -1148,6 +1154,17 @@ static inline void *hv_get_drvdata(struct hv_device *dev)
 	return dev_get_drvdata(&dev->device);
 }
 
+struct hv_ring_buffer_debug_info {
+	u32 current_interrupt_mask;
+	u32 current_read_index;
+	u32 current_write_index;
+	u32 bytes_avail_toread;
+	u32 bytes_avail_towrite;
+};
+
+void hv_ringbuffer_get_debuginfo(const struct hv_ring_buffer_info *ring_info,
+			    struct hv_ring_buffer_debug_info *debug_info);
+
 /* Vmbus interface */
 #define vmbus_driver_register(driver)	\
 	__vmbus_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)

commit 2a9d7de2038e87bb2a1085ac73c4246c260263f0
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Mar 4 18:27:17 2017 -0700

    vmbus: cleanup header file style
    
    Minor changes to align hyper-v vmbus include files with current
    linux kernel style.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2b1ed66824be..de9b80ff6698 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -524,10 +524,10 @@ struct vmbus_channel_open_channel {
 	u32 target_vp;
 
 	/*
-	* The upstream ring buffer begins at offset zero in the memory
-	* described by RingBufferGpadlHandle. The downstream ring buffer
-	* follows it at this offset (in pages).
-	*/
+	 * The upstream ring buffer begins at offset zero in the memory
+	 * described by RingBufferGpadlHandle. The downstream ring buffer
+	 * follows it at this offset (in pages).
+	 */
 	u32 downstream_ringbuffer_pageoffset;
 
 	/* User-specific data to be passed along to the server endpoint. */
@@ -1006,7 +1006,7 @@ extern int vmbus_open(struct vmbus_channel *channel,
 			    u32 recv_ringbuffersize,
 			    void *userdata,
 			    u32 userdatalen,
-			    void(*onchannel_callback)(void *context),
+			    void (*onchannel_callback)(void *context),
 			    void *context);
 
 extern void vmbus_close(struct vmbus_channel *channel);
@@ -1421,7 +1421,7 @@ struct hyperv_service_callback {
 	char *log_msg;
 	uuid_le data;
 	struct vmbus_channel *channel;
-	void (*callback) (void *context);
+	void (*callback)(void *context);
 };
 
 #define MAX_SRV_VER	0x7ffffff

commit 8b1f91fb4c1a8a860b8edc0c383821b2ff8a1ece
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Mar 4 18:27:12 2017 -0700

    vmbus: remove useless return's
    
    No need for empty return at end of void function
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62bbf3c1aa4a..2b1ed66824be 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1500,8 +1500,6 @@ static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 	cached_write_sz = hv_get_cached_bytes_to_write(rbi);
 	if (cached_write_sz < pending_sz)
 		vmbus_setevent(channel);
-
-	return;
 }
 
 static inline void

commit dad72a1d28442b03aac86836a42de2d00a1014ab
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Mar 4 18:13:58 2017 -0700

    vmbus: remove hv_event_tasklet_disable/enable
    
    With the recent introduction of per-channel tasklet, we need to update
    the way we handle the 3 concurrency issues:
    
    1. hv_process_channel_removal -> percpu_channel_deq vs.
       vmbus_chan_sched -> list_for_each_entry(..., percpu_list);
    
    2. vmbus_process_offer -> percpu_channel_enq/deq vs. vmbus_chan_sched.
    
    3. vmbus_close_internal vs. the per-channel tasklet vmbus_on_event;
    
    The first 2 issues can be handled by Stephen's recent patch
    "vmbus: use rcu for per-cpu channel list", and the third issue
    can be handled by calling tasklet_disable in vmbus_close_internal here.
    
    We don't need the original hv_event_tasklet_disable/enable since we
    now use per-channel tasklet instead of the previous per-CPU tasklet,
    and actually we must remove them due to the side effect now:
    vmbus_process_offer -> hv_event_tasklet_enable -> tasklet_schedule will
    start the per-channel callback prematurely, cauing NULL dereferencing
    (the channel may haven't been properly configured to run the callback yet).
    
    Fixes: 631e63a9f346 ("vmbus: change to per channel tasklet")
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Tested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c4c7ae91f9d1..970771a5f739 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1437,9 +1437,6 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp, u8 *buf,
 				const int *srv_version, int srv_vercnt,
 				int *nego_fw_version, int *nego_srv_version);
 
-void hv_event_tasklet_disable(struct vmbus_channel *channel);
-void hv_event_tasklet_enable(struct vmbus_channel *channel);
-
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
 void vmbus_setevent(struct vmbus_channel *channel);

commit 8200f2085abe7f29a016381f3122000cc7b2a760
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Mar 4 18:13:57 2017 -0700

    vmbus: use rcu for per-cpu channel list
    
    The per-cpu channel list is now referred to in the interrupt
    routine. This is mostly safe since the host will not normally generate
    an interrupt when channel is being deleted but if it did then there
    would be a use after free problem.
    
    To solve, this use RCU protection on ther per-cpu list.
    
    Fixes: 631e63a9f346 ("vmbus: change to per channel tasklet")
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62bbf3c1aa4a..c4c7ae91f9d1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -845,6 +845,13 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
+
+	/*
+	 * Defer freeing channel until after all cpu's have
+	 * gone through grace period.
+	 */
+	struct rcu_head rcu;
+
 	/*
 	 * For performance critical channels (storage, networking
 	 * etc,), Hyper-V has a mechanism to enhance the throughput

commit f3dd3f4797652c311df9c074436d420f1ad3566e
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Mon Feb 27 10:26:48 2017 -0800

    vmbus: introduce in-place packet iterator
    
    This is mostly just a refactoring of previous functions
    (get_pkt_next_raw, put_pkt_raw and commit_rd_index) to make it easier
    to use for other drivers and NAPI.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62bbf3c1aa4a..36162485d663 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1504,14 +1504,6 @@ static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 	return;
 }
 
-static inline void
-init_cached_read_index(struct vmbus_channel *channel)
-{
-	struct hv_ring_buffer_info *rbi = &channel->inbound;
-
-	rbi->cached_read_index = rbi->ring_buffer->read_index;
-}
-
 /*
  * Mask off host interrupt callback notifications
  */
@@ -1545,76 +1537,48 @@ static inline u32 hv_end_read(struct hv_ring_buffer_info *rbi)
 /*
  * An API to support in-place processing of incoming VMBUS packets.
  */
-#define VMBUS_PKT_TRAILER	8
 
-static inline struct vmpacket_descriptor *
-get_next_pkt_raw(struct vmbus_channel *channel)
+/* Get data payload associated with descriptor */
+static inline void *hv_pkt_data(const struct vmpacket_descriptor *desc)
 {
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 priv_read_loc = ring_info->priv_read_index;
-	void *ring_buffer = hv_get_ring_buffer(ring_info);
-	u32 dsize = ring_info->ring_datasize;
-	/*
-	 * delta is the difference between what is available to read and
-	 * what was already consumed in place. We commit read index after
-	 * the whole batch is processed.
-	 */
-	u32 delta = priv_read_loc >= ring_info->ring_buffer->read_index ?
-		priv_read_loc - ring_info->ring_buffer->read_index :
-		(dsize - ring_info->ring_buffer->read_index) + priv_read_loc;
-	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
-
-	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
-		return NULL;
-
-	return ring_buffer + priv_read_loc;
+	return (void *)((unsigned long)desc + (desc->offset8 << 3));
 }
 
-/*
- * A helper function to step through packets "in-place"
- * This API is to be called after each successful call
- * get_next_pkt_raw().
- */
-static inline void put_pkt_raw(struct vmbus_channel *channel,
-				struct vmpacket_descriptor *desc)
+/* Get data size associated with descriptor */
+static inline u32 hv_pkt_datalen(const struct vmpacket_descriptor *desc)
 {
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 packetlen = desc->len8 << 3;
-	u32 dsize = ring_info->ring_datasize;
-
-	/*
-	 * Include the packet trailer.
-	 */
-	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
-	ring_info->priv_read_index %= dsize;
+	return (desc->len8 << 3) - (desc->offset8 << 3);
 }
 
+
+struct vmpacket_descriptor *
+hv_pkt_iter_first(struct vmbus_channel *channel);
+
+struct vmpacket_descriptor *
+__hv_pkt_iter_next(struct vmbus_channel *channel,
+		   const struct vmpacket_descriptor *pkt);
+
+void hv_pkt_iter_close(struct vmbus_channel *channel);
+
 /*
- * This call commits the read index and potentially signals the host.
- * Here is the pattern for using the "in-place" consumption APIs:
- *
- * init_cached_read_index();
- *
- * while (get_next_pkt_raw() {
- *	process the packet "in-place";
- *	put_pkt_raw();
- * }
- * if (packets processed in place)
- *	commit_rd_index();
+ * Get next packet descriptor from iterator
+ * If at end of list, return NULL and update host.
  */
-static inline void commit_rd_index(struct vmbus_channel *channel)
+static inline struct vmpacket_descriptor *
+hv_pkt_iter_next(struct vmbus_channel *channel,
+		 const struct vmpacket_descriptor *pkt)
 {
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	/*
-	 * Make sure all reads are done before we update the read index since
-	 * the writer may start writing to the read area once the read index
-	 * is updated.
-	 */
-	virt_rmb();
-	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
+	struct vmpacket_descriptor *nxt;
+
+	nxt = __hv_pkt_iter_next(channel, pkt);
+	if (!nxt)
+		hv_pkt_iter_close(channel);
 
-	hv_signal_on_read(channel);
+	return nxt;
 }
 
+#define foreach_vmbus_pkt(pkt, channel) \
+	for (pkt = hv_pkt_iter_first(channel); pkt; \
+	    pkt = hv_pkt_iter_next(channel, pkt))
 
 #endif /* _HYPERV_H */

commit e4165a0fad0963bf8b4a59f54d3360ccb6a6d1ea
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:24 2017 -0700

    vmbus: constify parameters where possible
    
    Functions that just query state of ring buffer can have parameters
    marked const.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 08eb71a22c14..62bbf3c1aa4a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -138,8 +138,8 @@ struct hv_ring_buffer_info {
  * for the specified ring buffer
  */
 static inline void
-hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
-			  u32 *read, u32 *write)
+hv_get_ringbuffer_availbytes(const struct hv_ring_buffer_info *rbi,
+			     u32 *read, u32 *write)
 {
 	u32 read_loc, write_loc, dsize;
 
@@ -153,7 +153,7 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 	*read = dsize - *write;
 }
 
-static inline u32 hv_get_bytes_to_read(struct hv_ring_buffer_info *rbi)
+static inline u32 hv_get_bytes_to_read(const struct hv_ring_buffer_info *rbi)
 {
 	u32 read_loc, write_loc, dsize, read;
 
@@ -167,7 +167,7 @@ static inline u32 hv_get_bytes_to_read(struct hv_ring_buffer_info *rbi)
 	return read;
 }
 
-static inline u32 hv_get_bytes_to_write(struct hv_ring_buffer_info *rbi)
+static inline u32 hv_get_bytes_to_write(const struct hv_ring_buffer_info *rbi)
 {
 	u32 read_loc, write_loc, dsize, write;
 
@@ -1448,9 +1448,9 @@ void vmbus_set_event(struct vmbus_channel *channel);
 
 /* Get the start of the ring buffer. */
 static inline void *
-hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
+hv_get_ring_buffer(const struct hv_ring_buffer_info *ring_info)
 {
-	return (void *)ring_info->ring_buffer->buffer;
+	return ring_info->ring_buffer->buffer;
 }
 
 /*

commit 6e47dd3e2938f41d75045bbcb64aa9df3a463b2a
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:23 2017 -0700

    vmbus: expose hv_begin/end_read
    
    In order to implement NAPI in netvsc, the driver needs access to
    control host interrupt mask.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 466374dbc98f..08eb71a22c14 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1512,6 +1512,36 @@ init_cached_read_index(struct vmbus_channel *channel)
 	rbi->cached_read_index = rbi->ring_buffer->read_index;
 }
 
+/*
+ * Mask off host interrupt callback notifications
+ */
+static inline void hv_begin_read(struct hv_ring_buffer_info *rbi)
+{
+	rbi->ring_buffer->interrupt_mask = 1;
+
+	/* make sure mask update is not reordered */
+	virt_mb();
+}
+
+/*
+ * Re-enable host callback and return number of outstanding bytes
+ */
+static inline u32 hv_end_read(struct hv_ring_buffer_info *rbi)
+{
+
+	rbi->ring_buffer->interrupt_mask = 0;
+
+	/* make sure mask update is not reordered */
+	virt_mb();
+
+	/*
+	 * Now check to see if the ring buffer is still empty.
+	 * If it is not, we raced and we need to process new
+	 * incoming messages.
+	 */
+	return hv_get_bytes_to_read(rbi);
+}
+
 /*
  * An API to support in-place processing of incoming VMBUS packets.
  */

commit 5529eaf6e79a61e0ca7ade257f31d2ababc7f6c9
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:22 2017 -0700

    vmbus: remove conditional locking of vmbus_write
    
    All current usage of vmbus write uses the acquire_lock flag, therefore
    having it be optional is unnecessary. This also fixes a sparse warning
    since sparse doesn't like when a function has conditional locking.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e5aac5c051f7..466374dbc98f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -845,16 +845,6 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
-	/*
-	 * On the channel send side, many of the VMBUS
-	 * device drivers explicity serialize access to the
-	 * outgoing ring buffer. Give more control to the
-	 * VMBUS device drivers in terms how to serialize
-	 * accesss to the outgoing ring buffer.
-	 * The default behavior will be to aquire the
-	 * ring lock to preserve the current behavior.
-	 */
-	bool acquire_ring_lock;
 	/*
 	 * For performance critical channels (storage, networking
 	 * etc,), Hyper-V has a mechanism to enhance the throughput
@@ -895,11 +885,6 @@ struct vmbus_channel {
 
 };
 
-static inline void set_channel_lock_state(struct vmbus_channel *c, bool state)
-{
-	c->acquire_ring_lock = state;
-}
-
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)
 {
 	return !!(c->offermsg.offer.chn_flags &

commit b71e328297a3a578c482fb4814e737a0ec185839
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:21 2017 -0700

    vmbus: add direct isr callback mode
    
    Change the simple boolean batched_reading into a tri-value.
    For future NAPI support in netvsc driver, the callback needs to
    occur directly in interrupt handler.
    
    Batched mode is also changed to disable host interrupts immediately
    in interrupt routine (to avoid unnecessary host signals), and the
    tasklet is rescheduled if more data is detected.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 69afc9337c0d..e5aac5c051f7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -748,19 +748,21 @@ struct vmbus_channel {
 	void *channel_callback_context;
 
 	/*
-	 * A channel can be marked for efficient (batched)
-	 * reading:
-	 * If batched_reading is set to "true", we read until the
-	 * channel is empty and hold off interrupts from the host
-	 * during the entire read process.
-	 * If batched_reading is set to "false", the client is not
-	 * going to perform batched reading.
-	 *
-	 * By default we will enable batched reading; specific
-	 * drivers that don't want this behavior can turn it off.
+	 * A channel can be marked for one of three modes of reading:
+	 *   BATCHED - callback called from taslket and should read
+	 *            channel until empty. Interrupts from the host
+	 *            are masked while read is in process (default).
+	 *   DIRECT - callback called from tasklet (softirq).
+	 *   ISR - callback called in interrupt context and must
+	 *         invoke its own deferred processing.
+	 *         Host interrupts are disabled and must be re-enabled
+	 *         when ring is empty.
 	 */
-
-	bool batched_reading;
+	enum hv_callback_mode {
+		HV_CALL_BATCHED,
+		HV_CALL_DIRECT,
+		HV_CALL_ISR
+	} callback_mode;
 
 	bool is_dedicated_interrupt;
 	struct hv_input_signal_event_buffer sig_buf;
@@ -910,9 +912,10 @@ static inline void set_channel_affinity_state(struct vmbus_channel *c,
 	c->affinity_policy = policy;
 }
 
-static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
+static inline void set_channel_read_mode(struct vmbus_channel *c,
+					enum hv_callback_mode mode)
 {
-	c->batched_reading = state;
+	c->callback_mode = mode;
 }
 
 static inline void set_per_channel_state(struct vmbus_channel *c, void *s)

commit 631e63a9f346cb657761ae22138f294718696501
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:20 2017 -0700

    vmbus: change to per channel tasklet
    
    Make the event handling tasklet per channel rather than per-cpu.
    This allows for better fairness when getting lots of data on the same
    cpu.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c9b6d533958f..69afc9337c0d 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,7 +35,7 @@
 #include <linux/completion.h>
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
-
+#include <linux/interrupt.h>
 
 #define MAX_PAGE_BUFFER_COUNT				32
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
@@ -743,6 +743,7 @@ struct vmbus_channel {
 	struct vmbus_close_msg close_msg;
 
 	/* Channel callback's invoked in softirq context */
+	struct tasklet_struct callback_event;
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
 

commit 51c6ce2ae35980c755af33461c3138570ded615e
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:18 2017 -0700

    vmbus: callback is in softirq not workqueue
    
    The callback is done via tasklet not workqueue.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e208e6437f5b..c9b6d533958f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -32,7 +32,6 @@
 #include <linux/scatterlist.h>
 #include <linux/list.h>
 #include <linux/timer.h>
-#include <linux/workqueue.h>
 #include <linux/completion.h>
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
@@ -743,9 +742,7 @@ struct vmbus_channel {
 
 	struct vmbus_close_msg close_msg;
 
-	/* Channel callback are invoked in this workqueue context */
-	/* HANDLE dataWorkQueue; */
-
+	/* Channel callback's invoked in softirq context */
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
 

commit 3454323c954775098871559b5c23d877c3e23f77
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Feb 5 17:20:34 2017 -0700

    vmbus: remove unused kickq argument to sendpacket
    
    Since sendpacket no longer uses kickq argument remove it.
    Remove it no longer used xmit_more in sendpacket in netvsc as well.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7795966af0f9..e208e6437f5b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1037,8 +1037,7 @@ extern int vmbus_sendpacket_ctl(struct vmbus_channel *channel,
 				  u32 bufferLen,
 				  u64 requestid,
 				  enum vmbus_packet_type type,
-				  u32 flags,
-				  bool kick_q);
+				  u32 flags);
 
 extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
 					    struct hv_page_buffer pagebuffers[],
@@ -1053,8 +1052,7 @@ extern int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
 					   void *buffer,
 					   u32 bufferlen,
 					   u64 requestid,
-					   u32 flags,
-					   bool kick_q);
+					   u32 flags);
 
 extern int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
 					struct hv_multipage_buffer *mpb,

commit f6c4391553573d592212e6624cfba5e2752cd5c8
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Feb 5 17:20:33 2017 -0700

    vmbus: remove no longer used signal_policy
    
    The explicit signal policy is no longer used. A different mechanism
    will be added later when xmit_more is supported.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c37a4a145036..7795966af0f9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -684,11 +684,6 @@ struct hv_input_signal_event_buffer {
 	struct hv_input_signal_event event;
 };
 
-enum hv_signal_policy {
-	HV_SIGNAL_POLICY_DEFAULT = 0,
-	HV_SIGNAL_POLICY_EXPLICIT,
-};
-
 enum hv_numa_policy {
 	HV_BALANCED = 0,
 	HV_LOCALIZED,
@@ -850,13 +845,6 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
-	/*
-	 * Host signaling policy: The default policy will be
-	 * based on the ring buffer state. We will also support
-	 * a policy where the client driver can have explicit
-	 * signaling control.
-	 */
-	enum hv_signal_policy  signal_policy;
 	/*
 	 * On the channel send side, many of the VMBUS
 	 * device drivers explicity serialize access to the
@@ -918,12 +906,6 @@ static inline bool is_hvsock_channel(const struct vmbus_channel *c)
 		  VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER);
 }
 
-static inline void set_channel_signal_state(struct vmbus_channel *c,
-					    enum hv_signal_policy policy)
-{
-	c->signal_policy = policy;
-}
-
 static inline void set_channel_affinity_state(struct vmbus_channel *c,
 					      enum hv_numa_policy policy)
 {

commit 17fa87fe5a5141d3c082c5c91e950aca9e0ec701
Merge: 3b28f4f2c2c7 d5adbfcd5f7b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 6 09:39:13 2017 +0100

    Merge 4.10-rc7 into char-misc-next
    
    We want the hv and other fixes in here as well to handle merge and
    testing issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a1656454131880980bc3a5313c8bf66ef5990c91
Author: Alex Ng <alexng@messages.microsoft.com>
Date:   Sat Jan 28 12:37:17 2017 -0700

    Drivers: hv: vmbus: Use all supported IC versions to negotiate
    
    Previously, we were assuming that each IC protocol version was tied to a
    specific host version. For example, some Windows 10 preview hosts only
    support v3 TimeSync even though driver assumes v4 is supported by all
    Windows 10 hosts.
    
    The guest will stop trying to negotiate even though older supported
    versions may still be offered by the host.
    
    Make IC version negotiation more robust by going through all versions
    that are supported by the guest.
    
    Fixes: 3da0401b4d0e ("Drivers: hv: utils: Fix the mapping between host
    version and protocol to use")
    
    Reported-by: Rolf Neugebauer <rolf.neugebauer@docker.com>
    Signed-off-by: Alex Ng <alexng@messages.microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7ea20bd7cdd1..85b26f06e172 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1445,9 +1445,10 @@ struct hyperv_service_callback {
 };
 
 #define MAX_SRV_VER	0x7ffffff
-extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
-					struct icmsg_negotiate *, u8 *, int,
-					int);
+extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp, u8 *buf,
+				const int *fw_version, int fw_vercnt,
+				const int *srv_version, int srv_vercnt,
+				int *nego_fw_version, int *nego_srv_version);
 
 void hv_event_tasklet_disable(struct vmbus_channel *channel);
 void hv_event_tasklet_enable(struct vmbus_channel *channel);

commit 433e19cf33d34bb6751c874a9c00980552fe508c
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat Jan 28 11:46:02 2017 -0700

    Drivers: hv: vmbus: finally fix hv_need_to_signal_on_read()
    
    Commit a389fcfd2cb5 ("Drivers: hv: vmbus: Fix signaling logic in
    hv_need_to_signal_on_read()")
    added the proper mb(), but removed the test "prev_write_sz < pending_sz"
    when making the signal decision.
    
    As a result, the guest can signal the host unnecessarily,
    and then the host can throttle the guest because the host
    thinks the guest is buggy or malicious; finally the user
    running stress test can perceive intermittent freeze of
    the guest.
    
    This patch brings back the test, and properly handles the
    in-place consumption APIs used by NetVSC (see get_next_pkt_raw(),
    put_pkt_raw() and commit_rd_index()).
    
    Fixes: a389fcfd2cb5 ("Drivers: hv: vmbus: Fix signaling logic in
    hv_need_to_signal_on_read()")
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reported-by: Rolf Neugebauer <rolf.neugebauer@docker.com>
    Tested-by: Rolf Neugebauer <rolf.neugebauer@docker.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 42fe43fb0c80..183efde54269 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -128,6 +128,7 @@ struct hv_ring_buffer_info {
 	u32 ring_data_startoffset;
 	u32 priv_write_index;
 	u32 priv_read_index;
+	u32 cached_read_index;
 };
 
 /*
@@ -180,6 +181,19 @@ static inline u32 hv_get_bytes_to_write(struct hv_ring_buffer_info *rbi)
 	return write;
 }
 
+static inline u32 hv_get_cached_bytes_to_write(
+	const struct hv_ring_buffer_info *rbi)
+{
+	u32 read_loc, write_loc, dsize, write;
+
+	dsize = rbi->ring_datasize;
+	read_loc = rbi->cached_read_index;
+	write_loc = rbi->ring_buffer->write_index;
+
+	write = write_loc >= read_loc ? dsize - (write_loc - read_loc) :
+		read_loc - write_loc;
+	return write;
+}
 /*
  * VMBUS version is 32 bit entity broken up into
  * two 16 bit quantities: major_number. minor_number.
@@ -1488,7 +1502,7 @@ hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
 
 static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 {
-	u32 cur_write_sz;
+	u32 cur_write_sz, cached_write_sz;
 	u32 pending_sz;
 	struct hv_ring_buffer_info *rbi = &channel->inbound;
 
@@ -1512,12 +1526,24 @@ static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 
 	cur_write_sz = hv_get_bytes_to_write(rbi);
 
-	if (cur_write_sz >= pending_sz)
+	if (cur_write_sz < pending_sz)
+		return;
+
+	cached_write_sz = hv_get_cached_bytes_to_write(rbi);
+	if (cached_write_sz < pending_sz)
 		vmbus_setevent(channel);
 
 	return;
 }
 
+static inline void
+init_cached_read_index(struct vmbus_channel *channel)
+{
+	struct hv_ring_buffer_info *rbi = &channel->inbound;
+
+	rbi->cached_read_index = rbi->ring_buffer->read_index;
+}
+
 /*
  * An API to support in-place processing of incoming VMBUS packets.
  */
@@ -1569,6 +1595,8 @@ static inline void put_pkt_raw(struct vmbus_channel *channel,
  * This call commits the read index and potentially signals the host.
  * Here is the pattern for using the "in-place" consumption APIs:
  *
+ * init_cached_read_index();
+ *
  * while (get_next_pkt_raw() {
  *	process the packet "in-place";
  *	put_pkt_raw();

commit ccb61f8a99e6c29df4fb96a65dad4fad740d5be9
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Dec 22 16:54:00 2016 -0800

    Drivers: hv: vmbus: Fix a rescind handling bug
    
    The host can rescind a channel that has been offered to the
    guest and once the channel is rescinded, the host does not
    respond to any requests on that channel. Deal with the case where
    the guest may be blocked waiting for a response from the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 42fe43fb0c80..7ea20bd7cdd1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -627,6 +627,7 @@ struct vmbus_channel_msginfo {
 
 	/* Synchronize the request/response if needed */
 	struct completion  waitevent;
+	struct vmbus_channel *waiting_channel;
 	union {
 		struct vmbus_channel_version_supported version_supported;
 		struct vmbus_channel_open_result open_result;

commit fc76936d3ea5720a6e0948a08381b803a68deb28
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Sat Dec 3 12:34:39 2016 -0800

    vmbus: add support for dynamic device id's
    
    This patch adds sysfs interface to dynamically bind new UUID values
    to existing VMBus device. This is useful for generic UIO driver to
    act similar to uio_pci_generic.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 35053f99522b..42fe43fb0c80 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1119,6 +1119,12 @@ struct hv_driver {
 
 	struct device_driver driver;
 
+	/* dynamic device GUID's */
+	struct  {
+		spinlock_t lock;
+		struct list_head list;
+	} dynids;
+
 	int (*probe)(struct hv_device *, const struct hv_vmbus_device_id *);
 	int (*remove)(struct hv_device *);
 	void (*shutdown)(struct hv_device *);

commit f45be72c8ec0b85263d1fe1e6c681d8c87e198e6
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Sat Dec 3 12:34:29 2016 -0800

    hyperv: Fix spelling of HV_UNKOWN
    
    Changed it to HV_UNKNOWN
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2a52d9abb305..35053f99522b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -696,7 +696,7 @@ enum vmbus_device_type {
 	HV_FCOPY,
 	HV_BACKUP,
 	HV_DM,
-	HV_UNKOWN,
+	HV_UNKNOWN,
 };
 
 struct vmbus_device {

commit b7d91c915290ab0bfbab84a0fb9c9eae57816982
Merge: f2ed287bcc90 a25f0944ba9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 14 16:39:47 2016 +0100

    Merge 4.9-rc5 into char-misc-next
    
    We want those fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3372592a140db69fd63837e81f048ab4abf8111e
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Nov 6 13:14:18 2016 -0800

    Drivers: hv: vmbus: On the read path cleanup the logic to interrupt the host
    
    Signal the host when we determine the host is to be signaled -
    on th read path. The currrent code determines the need to signal in the
    ringbuffer code and actually issues the signal elsewhere. This can result
    in the host viewing this interrupt as spurious since the host may also
    poll the channel. Make the necessary adjustments.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8cf78ed96747..fdb0a87323f3 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1487,10 +1487,11 @@ hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
  *    there is room for the producer to send the pending packet.
  */
 
-static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
+static inline  void hv_signal_on_read(struct vmbus_channel *channel)
 {
 	u32 cur_write_sz;
 	u32 pending_sz;
+	struct hv_ring_buffer_info *rbi = &channel->inbound;
 
 	/*
 	 * Issue a full memory barrier before making the signaling decision.
@@ -1508,14 +1509,14 @@ static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
 	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
 	/* If the other end is not blocked on write don't bother. */
 	if (pending_sz == 0)
-		return false;
+		return;
 
 	cur_write_sz = hv_get_bytes_to_write(rbi);
 
 	if (cur_write_sz >= pending_sz)
-		return true;
+		vmbus_setevent(channel);
 
-	return false;
+	return;
 }
 
 /*
@@ -1587,8 +1588,7 @@ static inline void commit_rd_index(struct vmbus_channel *channel)
 	virt_rmb();
 	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
 
-	if (hv_need_to_signal_on_read(ring_info))
-		vmbus_set_event(channel);
+	hv_signal_on_read(channel);
 }
 
 

commit 1f6ee4e7d83586c8b10bd4f2f4346353d04ce884
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Nov 6 13:14:17 2016 -0800

    Drivers: hv: vmbus: On write cleanup the logic to interrupt the host
    
    Signal the host when we determine the host is to be signaled.
    The currrent code determines the need to signal in the ringbuffer
    code and actually issues the signal elsewhere. This can result
    in the host viewing this interrupt as spurious since the host may also
    poll the channel. Make the necessary adjustments.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 42ae6a5a2538..8cf78ed96747 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1454,6 +1454,7 @@ void hv_event_tasklet_enable(struct vmbus_channel *channel);
 
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
+void vmbus_setevent(struct vmbus_channel *channel);
 /*
  * Negotiated version with the Host.
  */

commit fa32ff6576623616c1751562edaed8c164ca5199
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sun Nov 6 13:14:05 2016 -0800

    Drivers: hv: ring_buffer: count on wrap around mappings in get_next_pkt_raw() (v2)
    
    With wrap around mappings in place we can always provide drivers with
    direct links to packets on the ring buffer, even when they wrap around.
    Do the required updates to get_next_pkt_raw()/put_pkt_raw()
    
    The first version of this commit was reverted (65a532f3d50a) to deal with
    cross-tree merge issues which are (hopefully) resolved now.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Tested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6824556d37ed..42ae6a5a2538 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1526,31 +1526,23 @@ static inline struct vmpacket_descriptor *
 get_next_pkt_raw(struct vmbus_channel *channel)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
+	u32 priv_read_loc = ring_info->priv_read_index;
 	void *ring_buffer = hv_get_ring_buffer(ring_info);
-	struct vmpacket_descriptor *cur_desc;
-	u32 packetlen;
 	u32 dsize = ring_info->ring_datasize;
-	u32 delta = read_loc - ring_info->ring_buffer->read_index;
+	/*
+	 * delta is the difference between what is available to read and
+	 * what was already consumed in place. We commit read index after
+	 * the whole batch is processed.
+	 */
+	u32 delta = priv_read_loc >= ring_info->ring_buffer->read_index ?
+		priv_read_loc - ring_info->ring_buffer->read_index :
+		(dsize - ring_info->ring_buffer->read_index) + priv_read_loc;
 	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
 
 	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
 		return NULL;
 
-	if ((read_loc + sizeof(*cur_desc)) > dsize)
-		return NULL;
-
-	cur_desc = ring_buffer + read_loc;
-	packetlen = cur_desc->len8 << 3;
-
-	/*
-	 * If the packet under consideration is wrapping around,
-	 * return failure.
-	 */
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
-		return NULL;
-
-	return cur_desc;
+	return ring_buffer + priv_read_loc;
 }
 
 /*
@@ -1562,16 +1554,14 @@ static inline void put_pkt_raw(struct vmbus_channel *channel,
 				struct vmpacket_descriptor *desc)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
 	u32 packetlen = desc->len8 << 3;
 	u32 dsize = ring_info->ring_datasize;
 
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
-		BUG();
 	/*
 	 * Include the packet trailer.
 	 */
 	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
+	ring_info->priv_read_index %= dsize;
 }
 
 /*

commit e934f684856393a0b2aecc7fdd8357a48b79c535
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Wed Oct 26 08:30:29 2016 -0700

    Revert "hv_netvsc: report vmbus name in ethtool"
    
    This reverts commit e3f74b841d48
    ("hv_netvsc: report vmbus name in ethtool")'
    because of problem introduced by commit f9a56e5d6a0ba
    ("Drivers: hv: make VMBus bus ids persistent").
    This changed the format of the vmbus name and this new format is too
    long to fit in the bus_info field of ethtool.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6824556d37ed..cd184bdca58f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1169,13 +1169,6 @@ int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
 					 const char *mod_name);
 void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
-static inline const char *vmbus_dev_name(const struct hv_device *device_obj)
-{
-	const struct kobject *kobj = &device_obj->device.kobj;
-
-	return kobj->name;
-}
-
 void vmbus_hvsock_device_unregister(struct vmbus_channel *channel);
 
 int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,

commit 687ee0ad4e897e29f4b41f7a20c866d74c5e0660
Merge: 3ddf40e8c319 03a1eabc3f54
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 5 10:11:24 2016 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
    
     1) BBR TCP congestion control, from Neal Cardwell, Yuchung Cheng and
        co. at Google. https://lwn.net/Articles/701165/
    
     2) Do TCP Small Queues for retransmits, from Eric Dumazet.
    
     3) Support collect_md mode for all IPV4 and IPV6 tunnels, from Alexei
        Starovoitov.
    
     4) Allow cls_flower to classify packets in ip tunnels, from Amir Vadai.
    
     5) Support DSA tagging in older mv88e6xxx switches, from Andrew Lunn.
    
     6) Support GMAC protocol in iwlwifi mwm, from Ayala Beker.
    
     7) Support ndo_poll_controller in mlx5, from Calvin Owens.
    
     8) Move VRF processing to an output hook and allow l3mdev to be
        loopback, from David Ahern.
    
     9) Support SOCK_DESTROY for UDP sockets. Also from David Ahern.
    
    10) Congestion control in RXRPC, from David Howells.
    
    11) Support geneve RX offload in ixgbe, from Emil Tantilov.
    
    12) When hitting pressure for new incoming TCP data SKBs, perform a
        partial rathern than a full purge of the OFO queue (which could be
        huge). From Eric Dumazet.
    
    13) Convert XFRM state and policy lookups to RCU, from Florian Westphal.
    
    14) Support RX network flow classification to igb, from Gangfeng Huang.
    
    15) Hardware offloading of eBPF in nfp driver, from Jakub Kicinski.
    
    16) New skbmod packet action, from Jamal Hadi Salim.
    
    17) Remove some inefficiencies in snmp proc output, from Jia He.
    
    18) Add FIB notifications to properly propagate route changes to
        hardware which is doing forwarding offloading. From Jiri Pirko.
    
    19) New dsa driver for qca8xxx chips, from John Crispin.
    
    20) Implement RFC7559 ipv6 router solicitation backoff, from Maciej
        enczykowski.
    
    21) Add L3 mode to ipvlan, from Mahesh Bandewar.
    
    22) Support 802.1ad in mlx4, from Moshe Shemesh.
    
    23) Support hardware LRO in mediatek driver, from Nelson Chang.
    
    24) Add TC offloading to mlx5, from Or Gerlitz.
    
    25) Convert various drivers to ethtool ksettings interfaces, from
        Philippe Reynes.
    
    26) TX max rate limiting for cxgb4, from Rahul Lakkireddy.
    
    27) NAPI support for ath10k, from Rajkumar Manoharan.
    
    28) Support XDP in mlx5, from Rana Shahout and Saeed Mahameed.
    
    29) UDP replicast support in TIPC, from Richard Alpe.
    
    30) Per-queue statistics for qed driver, from Sudarsana Reddy Kalluru.
    
    31) Support BQL in thunderx driver, from Sunil Goutham.
    
    32) TSO support in alx driver, from Tobias Regnery.
    
    33) Add stream parser engine and use it in kcm.
    
    34) Support async DHCP replies in ipconfig module, from Uwe
        Kleine-Knig.
    
    35) DSA port fast aging for mv88e6xxx driver, from Vivien Didelot.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1715 commits)
      mlxsw: switchx2: Fix misuse of hard_header_len
      mlxsw: spectrum: Fix misuse of hard_header_len
      net/faraday: Stop NCSI device on shutdown
      net/ncsi: Introduce ncsi_stop_dev()
      net/ncsi: Rework the channel monitoring
      net/ncsi: Allow to extend NCSI request properties
      net/ncsi: Rework request index allocation
      net/ncsi: Don't probe on the reserved channel ID (0x1f)
      net/ncsi: Introduce NCSI_RESERVED_CHANNEL
      net/ncsi: Avoid unused-value build warning from ia64-linux-gcc
      net: Add netdev all_adj_list refcnt propagation to fix panic
      net: phy: Add Edge-rate driver for Microsemi PHYs.
      vmxnet3: Wake queue from reset work
      i40e: avoid NULL pointer dereference and recursive errors on early PCI error
      qed: Add RoCE ll2 & GSI support
      qed: Add support for memory registeration verbs
      qed: Add support for QP verbs
      qed: PD,PKEY and CQ verb support
      qed: Add support for RoCE hw init
      qede: Add qedr framework
      ...

commit e7fca5d860aeeb1e606448f5191cea8d925cc7a3
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Sep 16 09:01:18 2016 -0700

    Drivers: hv: get rid of id in struct vmbus_channel
    
    The auto incremented counter is not being used anymore, get rid of it.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7d7cbff33bda..cd184bdca58f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -706,9 +706,6 @@ struct vmbus_device {
 };
 
 struct vmbus_channel {
-	/* Unique channel id */
-	int id;
-
 	struct list_head listentry;
 
 	struct hv_device *device_obj;

commit 3a8963acc70e69606729404713cfa9a03b58b18c
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Fri Sep 9 12:45:24 2016 -0700

    Revert "hv_netvsc: make inline functions static"
    
    These functions are used by other code misc-next tree.
    
    This reverts commit 30d1de08c87ddde6f73936c3350e7e153988fe02.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b01c8c3dd531..5df444b1ac18 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1429,4 +1429,88 @@ static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
 	return false;
 }
 
+/*
+ * An API to support in-place processing of incoming VMBUS packets.
+ */
+#define VMBUS_PKT_TRAILER	8
+
+static inline struct vmpacket_descriptor *
+get_next_pkt_raw(struct vmbus_channel *channel)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	u32 read_loc = ring_info->priv_read_index;
+	void *ring_buffer = hv_get_ring_buffer(ring_info);
+	struct vmpacket_descriptor *cur_desc;
+	u32 packetlen;
+	u32 dsize = ring_info->ring_datasize;
+	u32 delta = read_loc - ring_info->ring_buffer->read_index;
+	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
+
+	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
+		return NULL;
+
+	if ((read_loc + sizeof(*cur_desc)) > dsize)
+		return NULL;
+
+	cur_desc = ring_buffer + read_loc;
+	packetlen = cur_desc->len8 << 3;
+
+	/*
+	 * If the packet under consideration is wrapping around,
+	 * return failure.
+	 */
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
+		return NULL;
+
+	return cur_desc;
+}
+
+/*
+ * A helper function to step through packets "in-place"
+ * This API is to be called after each successful call
+ * get_next_pkt_raw().
+ */
+static inline void put_pkt_raw(struct vmbus_channel *channel,
+				struct vmpacket_descriptor *desc)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	u32 read_loc = ring_info->priv_read_index;
+	u32 packetlen = desc->len8 << 3;
+	u32 dsize = ring_info->ring_datasize;
+
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
+		BUG();
+	/*
+	 * Include the packet trailer.
+	 */
+	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
+}
+
+/*
+ * This call commits the read index and potentially signals the host.
+ * Here is the pattern for using the "in-place" consumption APIs:
+ *
+ * while (get_next_pkt_raw() {
+ *	process the packet "in-place";
+ *	put_pkt_raw();
+ * }
+ * if (packets processed in place)
+ *	commit_rd_index();
+ */
+static inline void commit_rd_index(struct vmbus_channel *channel)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	/*
+	 * Make sure all reads are done before we update the read index since
+	 * the writer may start writing to the read area once the read index
+	 * is updated.
+	 */
+	virt_rmb();
+	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
+
+	if (hv_need_to_signal_on_read(ring_info))
+		vmbus_set_event(channel);
+}
+
+
 #endif /* _HYPERV_H */

commit 8e1d260738ca89bc7c87444f95f04a026d12b496
Author: Alex Ng <alexng@messages.microsoft.com>
Date:   Thu Sep 8 05:24:14 2016 -0700

    Drivers: hv: utils: Support TimeSync version 4.0 protocol samples.
    
    This enables support for more accurate TimeSync v4 samples when hosted
    under Windows Server 2016 and newer hosts.
    
    The new time samples include a "vmreferencetime" field that represents
    the guest's TSC value when the host generated its time sample. This value
    lets the guest calculate the latency in receiving the time sample. The
    latency is added to the sample host time prior to updating the clock.
    
    Signed-off-by: Alex Ng <alexng@messages.microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 430619a92d3b..7d7cbff33bda 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1423,6 +1423,15 @@ struct ictimesync_data {
 	u8 flags;
 } __packed;
 
+struct ictimesync_ref_data {
+	u64 parenttime;
+	u64 vmreferencetime;
+	u8 flags;
+	char leapflags;
+	char stratum;
+	u8 reserved[3];
+} __packed;
+
 struct hyperv_service_callback {
 	u8 msg_type;
 	char *log_msg;

commit 0f98829a99850836cf7c2cc9fbf1d7ce0f795780
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Sep 7 05:39:34 2016 -0700

    Drivers: hv: vmbus: suppress some "hv_vmbus: Unknown GUID" warnings
    
    Some VMBus devices are not needed by Linux guest[1][2], and, VMBus channels
    of Hyper-V Sockets don't really mean usual synthetic devices, so let's
    suppress the warnings for them.
    
    [1] https://support.microsoft.com/en-us/kb/2925727
    [2] https://msdn.microsoft.com/en-us/library/jj980180(v=winembedded.81).aspx
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 613074ef1ce9..430619a92d3b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1314,6 +1314,27 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
 	.guid = UUID_LE(0x44c4f61d, 0x4444, 0x4400, 0x9d, 0x52, \
 			0x80, 0x2e, 0x27, 0xed, 0xe1, 0x9f)
 
+/*
+ * Linux doesn't support the 3 devices: the first two are for
+ * Automatic Virtual Machine Activation, and the third is for
+ * Remote Desktop Virtualization.
+ * {f8e65716-3cb3-4a06-9a60-1889c5cccab5}
+ * {3375baf4-9e15-4b30-b765-67acb10d607b}
+ * {276aacf4-ac15-426c-98dd-7521ad3f01fe}
+ */
+
+#define HV_AVMA1_GUID \
+	.guid = UUID_LE(0xf8e65716, 0x3cb3, 0x4a06, 0x9a, 0x60, \
+			0x18, 0x89, 0xc5, 0xcc, 0xca, 0xb5)
+
+#define HV_AVMA2_GUID \
+	.guid = UUID_LE(0x3375baf4, 0x9e15, 0x4b30, 0xb7, 0x65, \
+			0x67, 0xac, 0xb1, 0x0d, 0x60, 0x7b)
+
+#define HV_RDV_GUID \
+	.guid = UUID_LE(0x276aacf4, 0xac15, 0x426c, 0x98, 0xdd, \
+			0x75, 0x21, 0xad, 0x3f, 0x01, 0xfe)
+
 /*
  * Common header for Hyper-V ICs
  */

commit 65a532f3d50a266bcc5e9c7efc636006565e8e7e
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Sep 6 12:23:21 2016 -0700

    Revert "Drivers: hv: ring_buffer: count on wrap around mappings in get_next_pkt_raw()"
    
    To deal with the merge conflict between net-next and char-misc trees,
    revert commit bb08d431a914 from char-misc tree. This commit can be rebased
    and applied once net-next picks up char-misc changes.
    
    Here is the commit log of the reverted patch:
    "With wrap around mappings in place we can always provide drivers with
    direct links to packets on the ring buffer, even when they wrap around.
    Do the required updates to get_next_pkt_raw()/put_pkt_raw()"
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c877e7980585..613074ef1ce9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1492,23 +1492,31 @@ static inline struct vmpacket_descriptor *
 get_next_pkt_raw(struct vmbus_channel *channel)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 priv_read_loc = ring_info->priv_read_index;
+	u32 read_loc = ring_info->priv_read_index;
 	void *ring_buffer = hv_get_ring_buffer(ring_info);
+	struct vmpacket_descriptor *cur_desc;
+	u32 packetlen;
 	u32 dsize = ring_info->ring_datasize;
-	/*
-	 * delta is the difference between what is available to read and
-	 * what was already consumed in place. We commit read index after
-	 * the whole batch is processed.
-	 */
-	u32 delta = priv_read_loc >= ring_info->ring_buffer->read_index ?
-		priv_read_loc - ring_info->ring_buffer->read_index :
-		(dsize - ring_info->ring_buffer->read_index) + priv_read_loc;
+	u32 delta = read_loc - ring_info->ring_buffer->read_index;
 	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
 
 	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
 		return NULL;
 
-	return ring_buffer + priv_read_loc;
+	if ((read_loc + sizeof(*cur_desc)) > dsize)
+		return NULL;
+
+	cur_desc = ring_buffer + read_loc;
+	packetlen = cur_desc->len8 << 3;
+
+	/*
+	 * If the packet under consideration is wrapping around,
+	 * return failure.
+	 */
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
+		return NULL;
+
+	return cur_desc;
 }
 
 /*
@@ -1520,14 +1528,16 @@ static inline void put_pkt_raw(struct vmbus_channel *channel,
 				struct vmpacket_descriptor *desc)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	u32 read_loc = ring_info->priv_read_index;
 	u32 packetlen = desc->len8 << 3;
 	u32 dsize = ring_info->ring_datasize;
 
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
+		BUG();
 	/*
 	 * Include the packet trailer.
 	 */
 	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
-	ring_info->priv_read_index %= dsize;
 }
 
 /*

commit 509879bdb30b8e12bd0b3cb0bc8429f01478df4b
Author: K. Y. Srinivasan <kys@exchange.microsoft.com>
Date:   Fri Sep 2 05:58:23 2016 -0700

    Drivers: hv: Introduce a policy for controlling channel affinity
    
    Introduce a mechanism to control how channels will be affinitized. We will
    support two policies:
    
    1. HV_BALANCED: All performance critical channels will be dstributed
    evenly amongst all the available NUMA nodes. Once the Node is assigned,
    we will assign the CPU based on a simple round robin scheme.
    
    2. HV_LOCALIZED: Only the primary channels are distributed across all
    NUMA nodes. Sub-channels will be in the same NUMA node as the primary
    channel. This is the current behaviour.
    
    The default policy will be the HV_BALANCED as it can minimize the remote
    memory access on NUMA machines with applications that span NUMA nodes.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e6ef571e6100..c877e7980585 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -674,6 +674,11 @@ enum hv_signal_policy {
 	HV_SIGNAL_POLICY_EXPLICIT,
 };
 
+enum hv_numa_policy {
+	HV_BALANCED = 0,
+	HV_LOCALIZED,
+};
+
 enum vmbus_device_type {
 	HV_IDE = 0,
 	HV_SCSI,
@@ -876,6 +881,18 @@ struct vmbus_channel {
 	 */
 	bool low_latency;
 
+	/*
+	 * NUMA distribution policy:
+	 * We support teo policies:
+	 * 1) Balanced: Here all performance critical channels are
+	 *    distributed evenly amongst all the NUMA nodes.
+	 *    This policy will be the default policy.
+	 * 2) Localized: All channels of a given instance of a
+	 *    performance critical service will be assigned CPUs
+	 *    within a selected NUMA node.
+	 */
+	enum hv_numa_policy affinity_policy;
+
 };
 
 static inline void set_channel_lock_state(struct vmbus_channel *c, bool state)
@@ -895,6 +912,12 @@ static inline void set_channel_signal_state(struct vmbus_channel *c,
 	c->signal_policy = policy;
 }
 
+static inline void set_channel_affinity_state(struct vmbus_channel *c,
+					      enum hv_numa_policy policy)
+{
+	c->affinity_policy = policy;
+}
+
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
 {
 	c->batched_reading = state;

commit bb08d431a914984dee278e0e0482a2e6d620a482
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Sep 2 05:58:22 2016 -0700

    Drivers: hv: ring_buffer: count on wrap around mappings in get_next_pkt_raw()
    
    With wrap around mappings in place we can always provide drivers with
    direct links to packets on the ring buffer, even when they wrap around.
    Do the required updates to get_next_pkt_raw()/put_pkt_raw()
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Tested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 755e8f566a47..e6ef571e6100 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1469,31 +1469,23 @@ static inline struct vmpacket_descriptor *
 get_next_pkt_raw(struct vmbus_channel *channel)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
+	u32 priv_read_loc = ring_info->priv_read_index;
 	void *ring_buffer = hv_get_ring_buffer(ring_info);
-	struct vmpacket_descriptor *cur_desc;
-	u32 packetlen;
 	u32 dsize = ring_info->ring_datasize;
-	u32 delta = read_loc - ring_info->ring_buffer->read_index;
+	/*
+	 * delta is the difference between what is available to read and
+	 * what was already consumed in place. We commit read index after
+	 * the whole batch is processed.
+	 */
+	u32 delta = priv_read_loc >= ring_info->ring_buffer->read_index ?
+		priv_read_loc - ring_info->ring_buffer->read_index :
+		(dsize - ring_info->ring_buffer->read_index) + priv_read_loc;
 	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
 
 	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
 		return NULL;
 
-	if ((read_loc + sizeof(*cur_desc)) > dsize)
-		return NULL;
-
-	cur_desc = ring_buffer + read_loc;
-	packetlen = cur_desc->len8 << 3;
-
-	/*
-	 * If the packet under consideration is wrapping around,
-	 * return failure.
-	 */
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
-		return NULL;
-
-	return cur_desc;
+	return ring_buffer + priv_read_loc;
 }
 
 /*
@@ -1505,16 +1497,14 @@ static inline void put_pkt_raw(struct vmbus_channel *channel,
 				struct vmpacket_descriptor *desc)
 {
 	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
 	u32 packetlen = desc->len8 << 3;
 	u32 dsize = ring_info->ring_datasize;
 
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
-		BUG();
 	/*
 	 * Include the packet trailer.
 	 */
 	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
+	ring_info->priv_read_index %= dsize;
 }
 
 /*

commit 3724287c0ec472815ebe5ae3790f77965c6aa557
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Jul 1 16:26:37 2016 -0700

    Drivers: hv: vmbus: Implement a mechanism to tag the channel for low latency
    
    On Hyper-V, performance critical channels use the monitor
    mechanism to signal the host when the guest posts mesages
    for the host. This mechanism minimizes the hypervisor intercepts
    and also makes the host more efficient in that each time the
    host is woken up, it processes a batch of messages as opposed to
    just one. The goal here is improve the throughput and this is at
    the expense of increased latency.
    Implement a mechanism to let the client driver decide if latency
    is important.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 50f493eedeb5..755e8f566a47 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -850,6 +850,31 @@ struct vmbus_channel {
 	 * ring lock to preserve the current behavior.
 	 */
 	bool acquire_ring_lock;
+	/*
+	 * For performance critical channels (storage, networking
+	 * etc,), Hyper-V has a mechanism to enhance the throughput
+	 * at the expense of latency:
+	 * When the host is to be signaled, we just set a bit in a shared page
+	 * and this bit will be inspected by the hypervisor within a certain
+	 * window and if the bit is set, the host will be signaled. The window
+	 * of time is the monitor latency - currently around 100 usecs. This
+	 * mechanism improves throughput by:
+	 *
+	 * A) Making the host more efficient - each time it wakes up,
+	 *    potentially it will process morev number of packets. The
+	 *    monitor latency allows a batch to build up.
+	 * B) By deferring the hypercall to signal, we will also minimize
+	 *    the interrupts.
+	 *
+	 * Clearly, these optimizations improve throughput at the expense of
+	 * latency. Furthermore, since the channel is shared for both
+	 * control and data messages, control messages currently suffer
+	 * unnecessary latency adversley impacting performance and boot
+	 * time. To fix this issue, permit tagging the channel as being
+	 * in "low latency" mode. In this mode, we will bypass the monitor
+	 * mechanism.
+	 */
+	bool low_latency;
 
 };
 
@@ -891,6 +916,16 @@ static inline void set_channel_pending_send_size(struct vmbus_channel *c,
 	c->outbound.ring_buffer->pending_send_sz = size;
 }
 
+static inline void set_low_latency_mode(struct vmbus_channel *c)
+{
+	c->low_latency = true;
+}
+
+static inline void clear_low_latency_mode(struct vmbus_channel *c)
+{
+	c->low_latency = false;
+}
+
 void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);

commit 638fea33aee858cc665297a76f0039e95a28ce0c
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Jun 9 18:47:24 2016 -0700

    Drivers: hv: vmbus: fix the race when querying & updating the percpu list
    
    There is a rare race when we remove an entry from the global list
    hv_context.percpu_list[cpu] in hv_process_channel_removal() ->
    percpu_channel_deq() -> list_del(): at this time, if vmbus_on_event() ->
    process_chn_event() -> pcpu_relid2channel() is trying to query the list,
    we can get the kernel fault.
    
    Similarly, we also have the issue in the code path: vmbus_process_offer() ->
    percpu_channel_enq().
    
    We can resolve the issue by disabling the tasklet when updating the list.
    
    The patch also moves vmbus_release_relid() to a later place where
    the channel has been removed from the per-cpu and the global lists.
    
    Reported-by: Rolf Neugebauer <rolf.neugebauer@docker.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b10954a66939..50f493eedeb5 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1357,6 +1357,9 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 					struct icmsg_negotiate *, u8 *, int,
 					int);
 
+void hv_event_tasklet_disable(struct vmbus_channel *channel);
+void hv_event_tasklet_enable(struct vmbus_channel *channel);
+
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
 /*

commit e3f74b841d482e962b9f5a907eeb25eeeb09aa60
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Tue Aug 23 12:17:56 2016 -0700

    hv_netvsc: report vmbus name in ethtool
    
    Make netvsc on vmbus behave more like PCI.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a6bc974def8f..b01c8c3dd531 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1114,6 +1114,13 @@ int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
 					 const char *mod_name);
 void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
+static inline const char *vmbus_dev_name(const struct hv_device *device_obj)
+{
+	const struct kobject *kobj = &device_obj->device.kobj;
+
+	return kobj->name;
+}
+
 void vmbus_hvsock_device_unregister(struct vmbus_channel *channel);
 
 int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,

commit 30d1de08c87ddde6f73936c3350e7e153988fe02
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Tue Aug 23 12:17:48 2016 -0700

    hv_netvsc: make inline functions static
    
    Several new functions were introduced into hyperv.h but only used in one file.
    Move them and let compiler decide on inline.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b10954a66939..a6bc974def8f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1422,88 +1422,4 @@ static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
 	return false;
 }
 
-/*
- * An API to support in-place processing of incoming VMBUS packets.
- */
-#define VMBUS_PKT_TRAILER	8
-
-static inline struct vmpacket_descriptor *
-get_next_pkt_raw(struct vmbus_channel *channel)
-{
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
-	void *ring_buffer = hv_get_ring_buffer(ring_info);
-	struct vmpacket_descriptor *cur_desc;
-	u32 packetlen;
-	u32 dsize = ring_info->ring_datasize;
-	u32 delta = read_loc - ring_info->ring_buffer->read_index;
-	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
-
-	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
-		return NULL;
-
-	if ((read_loc + sizeof(*cur_desc)) > dsize)
-		return NULL;
-
-	cur_desc = ring_buffer + read_loc;
-	packetlen = cur_desc->len8 << 3;
-
-	/*
-	 * If the packet under consideration is wrapping around,
-	 * return failure.
-	 */
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
-		return NULL;
-
-	return cur_desc;
-}
-
-/*
- * A helper function to step through packets "in-place"
- * This API is to be called after each successful call
- * get_next_pkt_raw().
- */
-static inline void put_pkt_raw(struct vmbus_channel *channel,
-				struct vmpacket_descriptor *desc)
-{
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	u32 read_loc = ring_info->priv_read_index;
-	u32 packetlen = desc->len8 << 3;
-	u32 dsize = ring_info->ring_datasize;
-
-	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
-		BUG();
-	/*
-	 * Include the packet trailer.
-	 */
-	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
-}
-
-/*
- * This call commits the read index and potentially signals the host.
- * Here is the pattern for using the "in-place" consumption APIs:
- *
- * while (get_next_pkt_raw() {
- *	process the packet "in-place";
- *	put_pkt_raw();
- * }
- * if (packets processed in place)
- *	commit_rd_index();
- */
-static inline void commit_rd_index(struct vmbus_channel *channel)
-{
-	struct hv_ring_buffer_info *ring_info = &channel->inbound;
-	/*
-	 * Make sure all reads are done before we update the read index since
-	 * the writer may start writing to the read area once the read index
-	 * is updated.
-	 */
-	virt_rmb();
-	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
-
-	if (hv_need_to_signal_on_read(ring_info))
-		vmbus_set_event(channel);
-}
-
-
 #endif /* _HYPERV_H */

commit 97fb77dc87582300fa3c141b63699f853576cab1
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Tue Apr 5 10:22:51 2016 -0700

    drivers:hv: Make a function to free mmio regions through vmbus
    
    This patch introduces a function that reverses everything
    done by vmbus_allocate_mmio().  Existing code just called
    release_mem_region().  Future patches in this series
    require a more complex sequence of actions, so this function
    is introduced to wrap those actions.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 590fee6a2e6f..b10954a66939 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1120,7 +1120,7 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			resource_size_t min, resource_size_t max,
 			resource_size_t size, resource_size_t align,
 			bool fb_overlap_ok);
-
+void vmbus_free_mmio(resource_size_t start, resource_size_t size);
 int vmbus_cpu_number_to_vp_number(int cpu_number);
 u64 hv_do_hypercall(u64 control, void *input, void *output);
 

commit ab028db41ca9174caab7f9e3fc0a2e7f4a418410
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Apr 2 17:59:51 2016 -0700

    Drivers: hv: vmbus: Implement APIs to support "in place" consumption of vmbus packets
    
    Implement APIs for in-place consumption of vmbus packets. Currently, each
    packet is copied and processed one at a time and as part of processing
    each packet we potentially may signal the host (if it is waiting for
    room to produce a packet).
    
    These APIs help batched in-place processing of vmbus packets.
    We also optimize host signaling by having a separate API to signal
    the end of in-place consumption. With netvsc using these APIs,
    on an iperf run on average I see about 20X reduction in checks to
    signal the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index eb7c0b215ba4..590fee6a2e6f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -126,6 +126,8 @@ struct hv_ring_buffer_info {
 
 	u32 ring_datasize;		/* < ring_size */
 	u32 ring_data_startoffset;
+	u32 priv_write_index;
+	u32 priv_read_index;
 };
 
 /*
@@ -1420,4 +1422,88 @@ static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
 	return false;
 }
 
+/*
+ * An API to support in-place processing of incoming VMBUS packets.
+ */
+#define VMBUS_PKT_TRAILER	8
+
+static inline struct vmpacket_descriptor *
+get_next_pkt_raw(struct vmbus_channel *channel)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	u32 read_loc = ring_info->priv_read_index;
+	void *ring_buffer = hv_get_ring_buffer(ring_info);
+	struct vmpacket_descriptor *cur_desc;
+	u32 packetlen;
+	u32 dsize = ring_info->ring_datasize;
+	u32 delta = read_loc - ring_info->ring_buffer->read_index;
+	u32 bytes_avail_toread = (hv_get_bytes_to_read(ring_info) - delta);
+
+	if (bytes_avail_toread < sizeof(struct vmpacket_descriptor))
+		return NULL;
+
+	if ((read_loc + sizeof(*cur_desc)) > dsize)
+		return NULL;
+
+	cur_desc = ring_buffer + read_loc;
+	packetlen = cur_desc->len8 << 3;
+
+	/*
+	 * If the packet under consideration is wrapping around,
+	 * return failure.
+	 */
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > (dsize - 1))
+		return NULL;
+
+	return cur_desc;
+}
+
+/*
+ * A helper function to step through packets "in-place"
+ * This API is to be called after each successful call
+ * get_next_pkt_raw().
+ */
+static inline void put_pkt_raw(struct vmbus_channel *channel,
+				struct vmpacket_descriptor *desc)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	u32 read_loc = ring_info->priv_read_index;
+	u32 packetlen = desc->len8 << 3;
+	u32 dsize = ring_info->ring_datasize;
+
+	if ((read_loc + packetlen + VMBUS_PKT_TRAILER) > dsize)
+		BUG();
+	/*
+	 * Include the packet trailer.
+	 */
+	ring_info->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
+}
+
+/*
+ * This call commits the read index and potentially signals the host.
+ * Here is the pattern for using the "in-place" consumption APIs:
+ *
+ * while (get_next_pkt_raw() {
+ *	process the packet "in-place";
+ *	put_pkt_raw();
+ * }
+ * if (packets processed in place)
+ *	commit_rd_index();
+ */
+static inline void commit_rd_index(struct vmbus_channel *channel)
+{
+	struct hv_ring_buffer_info *ring_info = &channel->inbound;
+	/*
+	 * Make sure all reads are done before we update the read index since
+	 * the writer may start writing to the read area once the read index
+	 * is updated.
+	 */
+	virt_rmb();
+	ring_info->ring_buffer->read_index = ring_info->priv_read_index;
+
+	if (hv_need_to_signal_on_read(ring_info))
+		vmbus_set_event(channel);
+}
+
+
 #endif /* _HYPERV_H */

commit 687f32e6d9bd1d63c5e557e877809eb446f1a6e8
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Apr 2 17:59:50 2016 -0700

    Drivers: hv: vmbus: Move some ring buffer functions to hyperv.h
    
    In preparation for implementing APIs for in-place consumption of VMBUS
    packets, movve some ring buffer functionality into hyperv.h
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 40fd608475f7..eb7c0b215ba4 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1366,4 +1366,58 @@ extern __u32 vmbus_proto_version;
 int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,
 				  const uuid_le *shv_host_servie_id);
 void vmbus_set_event(struct vmbus_channel *channel);
+
+/* Get the start of the ring buffer. */
+static inline void *
+hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
+{
+	return (void *)ring_info->ring_buffer->buffer;
+}
+
+/*
+ * To optimize the flow management on the send-side,
+ * when the sender is blocked because of lack of
+ * sufficient space in the ring buffer, potential the
+ * consumer of the ring buffer can signal the producer.
+ * This is controlled by the following parameters:
+ *
+ * 1. pending_send_sz: This is the size in bytes that the
+ *    producer is trying to send.
+ * 2. The feature bit feat_pending_send_sz set to indicate if
+ *    the consumer of the ring will signal when the ring
+ *    state transitions from being full to a state where
+ *    there is room for the producer to send the pending packet.
+ */
+
+static inline  bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)
+{
+	u32 cur_write_sz;
+	u32 pending_sz;
+
+	/*
+	 * Issue a full memory barrier before making the signaling decision.
+	 * Here is the reason for having this barrier:
+	 * If the reading of the pend_sz (in this function)
+	 * were to be reordered and read before we commit the new read
+	 * index (in the calling function)  we could
+	 * have a problem. If the host were to set the pending_sz after we
+	 * have sampled pending_sz and go to sleep before we commit the
+	 * read index, we could miss sending the interrupt. Issue a full
+	 * memory barrier to address this.
+	 */
+	virt_mb();
+
+	pending_sz = READ_ONCE(rbi->ring_buffer->pending_send_sz);
+	/* If the other end is not blocked on write don't bother. */
+	if (pending_sz == 0)
+		return false;
+
+	cur_write_sz = hv_get_bytes_to_write(rbi);
+
+	if (cur_write_sz >= pending_sz)
+		return true;
+
+	return false;
+}
+
 #endif /* _HYPERV_H */

commit 5cc472477f928fb8584eb8e08245c9cf9002d74a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Apr 2 17:59:49 2016 -0700

    Drivers: hv: vmbus: Export the vmbus_set_event() API
    
    In preparation for moving some ring buffer functionality out of the
    vmbus driver, export the API for signaling the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 66226ceade37..40fd608475f7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1365,4 +1365,5 @@ extern __u32 vmbus_proto_version;
 
 int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,
 				  const uuid_le *shv_host_servie_id);
+void vmbus_set_event(struct vmbus_channel *channel);
 #endif /* _HYPERV_H */

commit a6341f000024cdf1ec14dc26743a409a17378db5
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Apr 2 17:59:46 2016 -0700

    Drivers: hv: vmbus: Introduce functions for estimating room in the ring buffer
    
    Introduce separate functions for estimating how much can be read from
    and written to the ring buffer.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index aa0fadce9308..66226ceade37 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -151,6 +151,33 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 	*read = dsize - *write;
 }
 
+static inline u32 hv_get_bytes_to_read(struct hv_ring_buffer_info *rbi)
+{
+	u32 read_loc, write_loc, dsize, read;
+
+	dsize = rbi->ring_datasize;
+	read_loc = rbi->ring_buffer->read_index;
+	write_loc = READ_ONCE(rbi->ring_buffer->write_index);
+
+	read = write_loc >= read_loc ? (write_loc - read_loc) :
+		(dsize - read_loc) + write_loc;
+
+	return read;
+}
+
+static inline u32 hv_get_bytes_to_write(struct hv_ring_buffer_info *rbi)
+{
+	u32 read_loc, write_loc, dsize, write;
+
+	dsize = rbi->ring_datasize;
+	read_loc = READ_ONCE(rbi->ring_buffer->read_index);
+	write_loc = rbi->ring_buffer->write_index;
+
+	write = write_loc >= read_loc ? dsize - (write_loc - read_loc) :
+		read_loc - write_loc;
+	return write;
+}
+
 /*
  * VMBUS version is 32 bit entity broken up into
  * two 16 bit quantities: major_number. minor_number.

commit b9830d120cbe155863399f25eaef6aa8353e767f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Feb 26 15:13:19 2016 -0800

    Drivers: hv: util: Pass the channel information during the init call
    
    Pass the channel information to the util drivers that need to defer
    reading the channel while they are processing a request. This would address
    the following issue reported by Vitaly:
    
    Commit 3cace4a61610 ("Drivers: hv: utils: run polling callback always in
    interrupt context") removed direct *_transaction.state = HVUTIL_READY
    assignments from *_handle_handshake() functions introducing the following
    race: if a userspace daemon connects before we get first non-negotiation
    request from the server hv_poll_channel() won't set transaction state to
    HVUTIL_READY as (!channel) condition will fail, we set it to non-NULL on
    the first real request from the server.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reported-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index d23dab0d770b..aa0fadce9308 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1251,6 +1251,7 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
 
 struct hv_util_service {
 	u8 *recv_buffer;
+	void *channel;
 	void (*util_cb)(void *);
 	int (*util_init)(struct hv_util_service *);
 	void (*util_deinit)(void);

commit fe760e4d64fe5c17c39e86c410d41f6587ee88bc
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Jan 27 22:29:45 2016 -0800

    Drivers: hv: vmbus: Give control over how the ring access is serialized
    
    On the channel send side, many of the VMBUS
    device drivers explicity serialize access to the
    outgoing ring buffer. Give more control to the
    VMBUS device drivers in terms how to serialize
    accesss to the outgoing ring buffer.
    The default behavior will be to aquire the
    ring lock to preserve the current behavior.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c056f058dcf8..d23dab0d770b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -811,8 +811,24 @@ struct vmbus_channel {
 	 * signaling control.
 	 */
 	enum hv_signal_policy  signal_policy;
+	/*
+	 * On the channel send side, many of the VMBUS
+	 * device drivers explicity serialize access to the
+	 * outgoing ring buffer. Give more control to the
+	 * VMBUS device drivers in terms how to serialize
+	 * accesss to the outgoing ring buffer.
+	 * The default behavior will be to aquire the
+	 * ring lock to preserve the current behavior.
+	 */
+	bool acquire_ring_lock;
+
 };
 
+static inline void set_channel_lock_state(struct vmbus_channel *c, bool state)
+{
+	c->acquire_ring_lock = state;
+}
+
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)
 {
 	return !!(c->offermsg.offer.chn_flags &

commit 85d9aa705184a4504d0330017e3956fcdae8a9d6
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:43 2016 -0800

    Drivers: hv: vmbus: add an API vmbus_hvsock_device_unregister()
    
    The hvsock driver needs this API to release all the resources related
    to the channel.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2e54e34e5feb..c056f058dcf8 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1069,6 +1069,8 @@ int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
 					 const char *mod_name);
 void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
+void vmbus_hvsock_device_unregister(struct vmbus_channel *channel);
+
 int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			resource_size_t min, resource_size_t max,
 			resource_size_t size, resource_size_t align,

commit 499e8401a515d04daa986b995da710d2b9737764
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:42 2016 -0800

    Drivers: hv: vmbus: add a per-channel rescind callback
    
    This will be used by the coming hv_sock driver.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f636f91f104b..2e54e34e5feb 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -765,6 +765,12 @@ struct vmbus_channel {
 	 */
 	void (*sc_creation_callback)(struct vmbus_channel *new_sc);
 
+	/*
+	 * Channel rescind callback. Some channels (the hvsock ones), need to
+	 * register a callback which is invoked in vmbus_onoffer_rescind().
+	 */
+	void (*chn_rescind_callback)(struct vmbus_channel *channel);
+
 	/*
 	 * The spinlock to protect the structure. It is being used to protect
 	 * test-and-set access to various attributes of the structure as well
@@ -851,6 +857,9 @@ int vmbus_request_offers(void);
 void vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,
 			void (*sc_cr_cb)(struct vmbus_channel *new_sc));
 
+void vmbus_set_chn_rescind_callback(struct vmbus_channel *channel,
+		void (*chn_rescind_cb)(struct vmbus_channel *));
+
 /*
  * Retrieve the (sub) channel on which to send an outgoing request.
  * When a primary channel has multiple sub-channels, we choose a

commit 8981da320a11217589aa3c50f9e891bcdef07ece
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:41 2016 -0800

    Drivers: hv: vmbus: add a hvsock flag in struct hv_driver
    
    Only the coming hv_sock driver has a "true" value for this flag.
    
    We treat the hvsock offers/channels as special VMBus devices.
    Since the hv_sock driver handles all the hvsock offers/channels, we need to
    tweak vmbus_match() for hv_sock driver, so we introduce this flag.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 898eac9e8c13..f636f91f104b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -990,6 +990,20 @@ extern void vmbus_ontimer(unsigned long data);
 struct hv_driver {
 	const char *name;
 
+	/*
+	 * A hvsock offer, which has a VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER
+	 * channel flag, actually doesn't mean a synthetic device because the
+	 * offer's if_type/if_instance can change for every new hvsock
+	 * connection.
+	 *
+	 * However, to facilitate the notification of new-offer/rescind-offer
+	 * from vmbus driver to hvsock driver, we can handle hvsock offer as
+	 * a special vmbus device, and hence we need the below flag to
+	 * indicate if the driver is the hvsock driver or not: we need to
+	 * specially treat the hvosck offer & driver in vmbus_match().
+	 */
+	bool hvsock;
+
 	/* the device type supported by this driver */
 	uuid_le dev_type;
 	const struct hv_vmbus_device_id *id_table;

commit 5c23a1a5c60b0f472cfa61cd7d8279f8aaeb5b64
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:40 2016 -0800

    Drivers: hv: vmbus: define a new VMBus message type for hvsock
    
    A function to send the type of message is also added.
    
    The coming net/hvsock driver will use this function to proactively request
    the host to offer a VMBus channel for a new hvsock connection.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 79c4aa70eff3..898eac9e8c13 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -392,6 +392,10 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_VERSION_RESPONSE		= 15,
 	CHANNELMSG_UNLOAD			= 16,
 	CHANNELMSG_UNLOAD_RESPONSE		= 17,
+	CHANNELMSG_18				= 18,
+	CHANNELMSG_19				= 19,
+	CHANNELMSG_20				= 20,
+	CHANNELMSG_TL_CONNECT_REQUEST		= 21,
 	CHANNELMSG_COUNT
 };
 
@@ -562,6 +566,13 @@ struct vmbus_channel_initiate_contact {
 	u64 monitor_page2;
 } __packed;
 
+/* Hyper-V socket: guest's connect()-ing to host */
+struct vmbus_channel_tl_connect_request {
+	struct vmbus_channel_message_header header;
+	uuid_le guest_endpoint_id;
+	uuid_le host_service_id;
+} __packed;
+
 struct vmbus_channel_version_response {
 	struct vmbus_channel_message_header header;
 	u8 version_supported;
@@ -1283,4 +1294,6 @@ void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
 extern __u32 vmbus_proto_version;
 
+int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,
+				  const uuid_le *shv_host_servie_id);
 #endif /* _HYPERV_H */

commit e8d6ca023efce3bd80050dcd9e708ee3cf8babd4
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:38 2016 -0800

    Drivers: hv: vmbus: define the new offer type for Hyper-V socket (hvsock)
    
    A helper function is also added.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 4af51a3f98d9..79c4aa70eff3 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -235,6 +235,7 @@ struct vmbus_channel_offer {
 #define VMBUS_CHANNEL_LOOPBACK_OFFER			0x100
 #define VMBUS_CHANNEL_PARENT_OFFER			0x200
 #define VMBUS_CHANNEL_REQUEST_MONITORED_NOTIFICATION	0x400
+#define VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER		0x2000
 
 struct vmpacket_descriptor {
 	u16 type;
@@ -795,6 +796,12 @@ struct vmbus_channel {
 	enum hv_signal_policy  signal_policy;
 };
 
+static inline bool is_hvsock_channel(const struct vmbus_channel *c)
+{
+	return !!(c->offermsg.offer.chn_flags &
+		  VMBUS_CHANNEL_TLNPI_PROVIDER_OFFER);
+}
+
 static inline void set_channel_signal_state(struct vmbus_channel *c,
 					    enum hv_signal_policy policy)
 {

commit 3c75354d043ad546148d6992e40033ecaefc5ea5
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:37 2016 -0800

    Drivers: hv: vmbus: add a helper function to set a channel's pending send size
    
    This will be used by the coming net/hvsock driver.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 3172521df805..4af51a3f98d9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -816,6 +816,12 @@ static inline void *get_per_channel_state(struct vmbus_channel *c)
 	return c->per_channel_state;
 }
 
+static inline void set_channel_pending_send_size(struct vmbus_channel *c,
+						 u32 size)
+{
+	c->outbound.ring_buffer->pending_send_sz = size;
+}
+
 void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);

commit 7047f17d70fc0599563d30d0791692cb5fe42ae6
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Dec 25 20:00:30 2015 -0800

    Drivers: hv: vmbus: Add vendor and device atttributes
    
    Add vendor and device attributes to VMBUS devices. These will be used
    by Hyper-V tools as well user-level RDMA libraries that will use the
    vendor/device tuple to discover the RDMA device.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 753dbad0bf94..3172521df805 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -633,6 +633,32 @@ enum hv_signal_policy {
 	HV_SIGNAL_POLICY_EXPLICIT,
 };
 
+enum vmbus_device_type {
+	HV_IDE = 0,
+	HV_SCSI,
+	HV_FC,
+	HV_NIC,
+	HV_ND,
+	HV_PCIE,
+	HV_FB,
+	HV_KBD,
+	HV_MOUSE,
+	HV_KVP,
+	HV_TS,
+	HV_HB,
+	HV_SHUTDOWN,
+	HV_FCOPY,
+	HV_BACKUP,
+	HV_DM,
+	HV_UNKOWN,
+};
+
+struct vmbus_device {
+	u16  dev_type;
+	uuid_le guid;
+	bool perf_device;
+};
+
 struct vmbus_channel {
 	/* Unique channel id */
 	int id;
@@ -959,6 +985,8 @@ struct hv_device {
 
 	/* the device instance id of this device */
 	uuid_le dev_instance;
+	u16 vendor_id;
+	u16 device_id;
 
 	struct device device;
 

commit 2048157ad02e65f6327118dd4a7b9c9f1fd12f77
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 21 12:21:22 2015 -0800

    Drivers: hv: vmbus: fix the building warning with hyperv-keyboard
    
    With the recent change af3ff643ea91ba64dd8d0b1cbed54d44512f96cd
    (Drivers: hv: vmbus: Use uuid_le type consistently), we always get this
    warning:
    
      CC [M]  drivers/input/serio/hyperv-keyboard.o
    drivers/input/serio/hyperv-keyboard.c:427:2: warning: missing braces around
            initializer [-Wmissing-braces]
      { HV_KBD_GUID, },
      ^
    drivers/input/serio/hyperv-keyboard.c:427:2: warning: (near initialization
            for .id_table[0].guid.b.) [-Wmissing-braces]
    
    The patch fixes the warning.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 179ff330af59..753dbad0bf94 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1078,6 +1078,14 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
 	.guid = UUID_LE(0xcfa8b69e, 0x5b4a, 0x4cc0, 0xb9, 0x8b, \
 			0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a)
 
+/*
+ * Keyboard GUID
+ * {f912ad6d-2b17-48ea-bd65-f927a61c7684}
+ */
+#define HV_KBD_GUID \
+	.guid = UUID_LE(0xf912ad6d, 0x2b17, 0x48ea, 0xbd, 0x65, \
+			0xf9, 0x27, 0xa6, 0x1c, 0x76, 0x84)
+
 /*
  * VSS (Backup/Restore) GUID
  */

commit 45870a441361d1c05a5f767c4ece2f6e30e0da9c
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Dec 14 19:01:58 2015 -0800

    Drivers: hv: ring_buffer: remove stray smp_read_barrier_depends()
    
    smp_read_barrier_depends() does nothing on almost all arcitectures
    including x86 and having it in the beginning of
    hv_get_ringbuffer_availbytes() does not provide any guarantees anyway.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index acd995b81c6b..179ff330af59 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -141,8 +141,6 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 {
 	u32 read_loc, write_loc, dsize;
 
-	smp_read_barrier_depends();
-
 	/* Capture the read/write indices before they changed */
 	read_loc = rbi->ring_buffer->read_index;
 	write_loc = rbi->ring_buffer->write_index;

commit 8599846d73997cdbccf63f23394d871cfad1e5e6
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Dec 14 16:01:54 2015 -0800

    Drivers: hv: vmbus: Fix a Host signaling bug
    
    Currently we have two policies for deciding when to signal the host:
    One based on the ring buffer state and the other based on what the
    VMBUS client driver wants to do. Consider the case when the client
    wants to explicitly control when to signal the host. In this case,
    if the client were to defer signaling, we will not be able to signal
    the host subsequently when the client does want to signal since the
    ring buffer state will prevent the signaling. Implement logic to
    have only one signaling policy in force for a given channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Tested-by: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f773a6871f4c..acd995b81c6b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -630,6 +630,11 @@ struct hv_input_signal_event_buffer {
 	struct hv_input_signal_event event;
 };
 
+enum hv_signal_policy {
+	HV_SIGNAL_POLICY_DEFAULT = 0,
+	HV_SIGNAL_POLICY_EXPLICIT,
+};
+
 struct vmbus_channel {
 	/* Unique channel id */
 	int id;
@@ -757,8 +762,21 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
+	/*
+	 * Host signaling policy: The default policy will be
+	 * based on the ring buffer state. We will also support
+	 * a policy where the client driver can have explicit
+	 * signaling control.
+	 */
+	enum hv_signal_policy  signal_policy;
 };
 
+static inline void set_channel_signal_state(struct vmbus_channel *c,
+					    enum hv_signal_policy policy)
+{
+	c->signal_policy = policy;
+}
+
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
 {
 	c->batched_reading = state;

commit 90e031fa06ad6b660a8e9bebbb80bd30e555a2a5
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Dec 14 16:01:45 2015 -0800

    Drivers: hv: vmbus: Get rid of the unused macro
    
    The macro VMBUS_DEVICE() is unused; get rid of it.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b9f3bb25d8b4..f773a6871f4c 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -986,19 +986,6 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 int vmbus_cpu_number_to_vp_number(int cpu_number);
 u64 hv_do_hypercall(u64 control, void *input, void *output);
 
-/**
- * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
- *
- * This macro is used to create a struct hv_vmbus_device_id that matches a
- * specific device.
- */
-#define VMBUS_DEVICE(g0, g1, g2, g3, g4, g5, g6, g7,	\
-		     g8, g9, ga, gb, gc, gd, ge, gf)	\
-	.guid = { g0, g1, g2, g3, g4, g5, g6, g7,	\
-		  g8, g9, ga, gb, gc, gd, ge, gf },
-
-
-
 /*
  * GUID definitions of various offer types - services offered to the guest.
  */

commit af3ff643ea91ba64dd8d0b1cbed54d44512f96cd
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Dec 14 16:01:43 2015 -0800

    Drivers: hv: vmbus: Use uuid_le type consistently
    
    Consistently use uuid_le type in the Hyper-V driver code.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c9a9eed89af2..b9f3bb25d8b4 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -997,6 +997,8 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
 	.guid = { g0, g1, g2, g3, g4, g5, g6, g7,	\
 		  g8, g9, ga, gb, gc, gd, ge, gf },
 
+
+
 /*
  * GUID definitions of various offer types - services offered to the guest.
  */
@@ -1006,118 +1008,94 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
  * {f8615163-df3e-46c5-913f-f2d2f965ed0e}
  */
 #define HV_NIC_GUID \
-	.guid = { \
-			0x63, 0x51, 0x61, 0xf8, 0x3e, 0xdf, 0xc5, 0x46, \
-			0x91, 0x3f, 0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e \
-		}
+	.guid = UUID_LE(0xf8615163, 0xdf3e, 0x46c5, 0x91, 0x3f, \
+			0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e)
 
 /*
  * IDE GUID
  * {32412632-86cb-44a2-9b5c-50d1417354f5}
  */
 #define HV_IDE_GUID \
-	.guid = { \
-			0x32, 0x26, 0x41, 0x32, 0xcb, 0x86, 0xa2, 0x44, \
-			0x9b, 0x5c, 0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5 \
-		}
+	.guid = UUID_LE(0x32412632, 0x86cb, 0x44a2, 0x9b, 0x5c, \
+			0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5)
 
 /*
  * SCSI GUID
  * {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f}
  */
 #define HV_SCSI_GUID \
-	.guid = { \
-			0xd9, 0x63, 0x61, 0xba, 0xa1, 0x04, 0x29, 0x4d, \
-			0xb6, 0x05, 0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f \
-		}
+	.guid = UUID_LE(0xba6163d9, 0x04a1, 0x4d29, 0xb6, 0x05, \
+			0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f)
 
 /*
  * Shutdown GUID
  * {0e0b6031-5213-4934-818b-38d90ced39db}
  */
 #define HV_SHUTDOWN_GUID \
-	.guid = { \
-			0x31, 0x60, 0x0b, 0x0e, 0x13, 0x52, 0x34, 0x49, \
-			0x81, 0x8b, 0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb \
-		}
+	.guid = UUID_LE(0x0e0b6031, 0x5213, 0x4934, 0x81, 0x8b, \
+			0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb)
 
 /*
  * Time Synch GUID
  * {9527E630-D0AE-497b-ADCE-E80AB0175CAF}
  */
 #define HV_TS_GUID \
-	.guid = { \
-			0x30, 0xe6, 0x27, 0x95, 0xae, 0xd0, 0x7b, 0x49, \
-			0xad, 0xce, 0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf \
-		}
+	.guid = UUID_LE(0x9527e630, 0xd0ae, 0x497b, 0xad, 0xce, \
+			0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf)
 
 /*
  * Heartbeat GUID
  * {57164f39-9115-4e78-ab55-382f3bd5422d}
  */
 #define HV_HEART_BEAT_GUID \
-	.guid = { \
-			0x39, 0x4f, 0x16, 0x57, 0x15, 0x91, 0x78, 0x4e, \
-			0xab, 0x55, 0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d \
-		}
+	.guid = UUID_LE(0x57164f39, 0x9115, 0x4e78, 0xab, 0x55, \
+			0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d)
 
 /*
  * KVP GUID
  * {a9a0f4e7-5a45-4d96-b827-8a841e8c03e6}
  */
 #define HV_KVP_GUID \
-	.guid = { \
-			0xe7, 0xf4, 0xa0, 0xa9, 0x45, 0x5a, 0x96, 0x4d, \
-			0xb8, 0x27, 0x8a, 0x84, 0x1e, 0x8c, 0x3,  0xe6 \
-		}
+	.guid = UUID_LE(0xa9a0f4e7, 0x5a45, 0x4d96, 0xb8, 0x27, \
+			0x8a, 0x84, 0x1e, 0x8c, 0x03, 0xe6)
 
 /*
  * Dynamic memory GUID
  * {525074dc-8985-46e2-8057-a307dc18a502}
  */
 #define HV_DM_GUID \
-	.guid = { \
-			0xdc, 0x74, 0x50, 0X52, 0x85, 0x89, 0xe2, 0x46, \
-			0x80, 0x57, 0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02 \
-		}
+	.guid = UUID_LE(0x525074dc, 0x8985, 0x46e2, 0x80, 0x57, \
+			0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02)
 
 /*
  * Mouse GUID
  * {cfa8b69e-5b4a-4cc0-b98b-8ba1a1f3f95a}
  */
 #define HV_MOUSE_GUID \
-	.guid = { \
-			0x9e, 0xb6, 0xa8, 0xcf, 0x4a, 0x5b, 0xc0, 0x4c, \
-			0xb9, 0x8b, 0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a \
-		}
+	.guid = UUID_LE(0xcfa8b69e, 0x5b4a, 0x4cc0, 0xb9, 0x8b, \
+			0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a)
 
 /*
  * VSS (Backup/Restore) GUID
  */
 #define HV_VSS_GUID \
-	.guid = { \
-			0x29, 0x2e, 0xfa, 0x35, 0x23, 0xea, 0x36, 0x42, \
-			0x96, 0xae, 0x3a, 0x6e, 0xba, 0xcb, 0xa4,  0x40 \
-		}
+	.guid = UUID_LE(0x35fa2e29, 0xea23, 0x4236, 0x96, 0xae, \
+			0x3a, 0x6e, 0xba, 0xcb, 0xa4, 0x40)
 /*
  * Synthetic Video GUID
  * {DA0A7802-E377-4aac-8E77-0558EB1073F8}
  */
 #define HV_SYNTHVID_GUID \
-	.guid = { \
-			0x02, 0x78, 0x0a, 0xda, 0x77, 0xe3, 0xac, 0x4a, \
-			0x8e, 0x77, 0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8 \
-		}
+	.guid = UUID_LE(0xda0a7802, 0xe377, 0x4aac, 0x8e, 0x77, \
+			0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8)
 
 /*
  * Synthetic FC GUID
  * {2f9bcc4a-0069-4af3-b76b-6fd0be528cda}
  */
 #define HV_SYNTHFC_GUID \
-	.guid = { \
-			0x4A, 0xCC, 0x9B, 0x2F, 0x69, 0x00, 0xF3, 0x4A, \
-			0xB7, 0x6B, 0x6F, 0xD0, 0xBE, 0x52, 0x8C, 0xDA \
-		}
+	.guid = UUID_LE(0x2f9bcc4a, 0x0069, 0x4af3, 0xb7, 0x6b, \
+			0x6f, 0xd0, 0xbe, 0x52, 0x8c, 0xda)
 
 /*
  * Guest File Copy Service
@@ -1125,20 +1103,16 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
  */
 
 #define HV_FCOPY_GUID \
-	.guid = { \
-			0xE3, 0x4B, 0xD1, 0x34, 0xE4, 0xDE, 0xC8, 0x41, \
-			0x9A, 0xE7, 0x6B, 0x17, 0x49, 0x77, 0xC1, 0x92 \
-		}
+	.guid = UUID_LE(0x34d14be3, 0xdee4, 0x41c8, 0x9a, 0xe7, \
+			0x6b, 0x17, 0x49, 0x77, 0xc1, 0x92)
 
 /*
  * NetworkDirect. This is the guest RDMA service.
  * {8c2eaf3d-32a7-4b09-ab99-bd1f1c86b501}
  */
 #define HV_ND_GUID \
-	.guid = { \
-			0x3d, 0xaf, 0x2e, 0x8c, 0xa7, 0x32, 0x09, 0x4b, \
-			0xab, 0x99, 0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01 \
-		}
+	.guid = UUID_LE(0x8c2eaf3d, 0x32a7, 0x4b09, 0xab, 0x99, \
+			0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01)
 
 /*
  * PCI Express Pass Through
@@ -1146,10 +1120,8 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
  */
 
 #define HV_PCIE_GUID \
-	.guid = { \
-			0x1D, 0xF6, 0xC4, 0x44, 0x44, 0x44, 0x00, 0x44, \
-			0x9D, 0x52, 0x80, 0x2E, 0x27, 0xED, 0xE1, 0x9F \
-		}
+	.guid = UUID_LE(0x44c4f61d, 0x4444, 0x4400, 0x9d, 0x52, \
+			0x80, 0x2e, 0x27, 0xed, 0xe1, 0x9f)
 
 /*
  * Common header for Hyper-V ICs

commit 3053c762444a83ec6a8777f9476668b23b8ab180
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Mon Dec 14 16:01:41 2015 -0800

    drivers:hv: Define the channel type for Hyper-V PCI Express pass-through
    
    This defines the channel type for PCI front-ends in Hyper-V VMs.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 24d0b656e6e7..c9a9eed89af2 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1140,6 +1140,17 @@ u64 hv_do_hypercall(u64 control, void *input, void *output);
 			0xab, 0x99, 0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01 \
 		}
 
+/*
+ * PCI Express Pass Through
+ * {44C4F61D-4444-4400-9D52-802E27EDE19F}
+ */
+
+#define HV_PCIE_GUID \
+	.guid = { \
+			0x1D, 0xF6, 0xC4, 0x44, 0x44, 0x44, 0x00, 0x44, \
+			0x9D, 0x52, 0x80, 0x2E, 0x27, 0xED, 0xE1, 0x9F \
+		}
+
 /*
  * Common header for Hyper-V ICs
  */

commit a108393dbf764efb2405f21ca759806c65b8bc16
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Mon Dec 14 16:01:40 2015 -0800

    drivers:hv: Export the API to invoke a hypercall on Hyper-V
    
    This patch exposes the function that hv_vmbus.ko uses to make hypercalls.  This
    is necessary for retargeting an interrupt when it is given a new affinity.
    
    Since we are exporting this API, rename the API as it will be visible outside
    the hv.c file.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index fddb3e0e8feb..24d0b656e6e7 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -984,6 +984,7 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			bool fb_overlap_ok);
 
 int vmbus_cpu_number_to_vp_number(int cpu_number);
+u64 hv_do_hypercall(u64 control, void *input, void *output);
 
 /**
  * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device

commit 619848bd074343ff2bdeeafca0be39748f6da372
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Mon Dec 14 16:01:39 2015 -0800

    drivers:hv: Export a function that maps Linux CPU num onto Hyper-V proc num
    
    This patch exposes the mapping between Linux CPU number and Hyper-V virtual
    processor number.  This is necessary because the hypervisor needs to know which
    virtual processors to target when making a mapping in the Interrupt Redirection
    Table in the I/O MMU.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8fdc17b84739..fddb3e0e8feb 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -983,6 +983,8 @@ int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			resource_size_t size, resource_size_t align,
 			bool fb_overlap_ok);
 
+int vmbus_cpu_number_to_vp_number(int cpu_number);
+
 /**
  * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
  *

commit c75efa974e013640496620f26f0b532cb5cb17f9
Author: Andrey Smetanin <asmetanin@virtuozzo.com>
Date:   Fri Oct 16 10:07:50 2015 +0300

    drivers/hv: share Hyper-V SynIC constants with userspace
    
    Moved Hyper-V synic contants from guest Hyper-V drivers private
    header into x86 arch uapi Hyper-V header.
    
    Added Hyper-V synic msr's flags into x86 arch uapi Hyper-V header.
    
    Signed-off-by: Andrey Smetanin <asmetanin@virtuozzo.com>
    Reviewed-by: Roman Kagan <rkagan@virtuozzo.com>
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    CC: Vitaly Kuznetsov <vkuznets@redhat.com>
    CC: "K. Y. Srinivasan" <kys@microsoft.com>
    CC: Gleb Natapov <gleb@kernel.org>
    CC: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 54733d5b503e..8fdc17b84739 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -26,6 +26,7 @@
 #define _HYPERV_H
 
 #include <uapi/linux/hyperv.h>
+#include <uapi/asm/hyperv.h>
 
 #include <linux/types.h>
 #include <linux/scatterlist.h>

commit 3b71107d73b16074afa7658f3f0fcf837aabfe24
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Aug 5 00:52:39 2015 -0700

    Drivers: hv: vmbus: Further improve CPU affiliation logic
    
    Keep track of CPU affiliations of sub-channels within the scope of the primary
    channel. This will allow us to better distribute the load amongst available
    CPUs.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5a3df5a47c8f..54733d5b503e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -699,6 +699,7 @@ struct vmbus_channel {
 	/*
 	 * State to manage the CPU affiliation of channels.
 	 */
+	struct cpumask alloced_cpus_in_node;
 	int numa_node;
 	/*
 	 * Support for sub-channels. For high performance devices,

commit 9f01ec53458d9e9b68f1c555e773b5d1a1f66e94
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Aug 5 00:52:38 2015 -0700

    Drivers: hv: vmbus: Improve the CPU affiliation for channels
    
    The current code tracks the assigned CPUs within a NUMA node in the context of
    the primary channel. So, if we have a VM with a single NUMA node with 8 VCPUs, we may
    end up unevenly distributing the channel load. Fix the issue by tracking affiliations
    globally.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 54733d5b503e..5a3df5a47c8f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -699,7 +699,6 @@ struct vmbus_channel {
 	/*
 	 * State to manage the CPU affiliation of channels.
 	 */
-	struct cpumask alloced_cpus_in_node;
 	int numa_node;
 	/*
 	 * Support for sub-channels. For high performance devices,

commit 3546448338e76a52d4f86eb3680cb2934e22d89b
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Wed Aug 5 00:52:37 2015 -0700

    drivers:hv: Move MMIO range picking from hyper_fb to hv_vmbus
    
    This patch deletes the logic from hyperv_fb which picked a range of MMIO space
    for the frame buffer and adds new logic to hv_vmbus which picks ranges for
    child drivers.  The new logic isn't quite the same as the old, as it considers
    more possible ranges.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 217e14be77b9..54733d5b503e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -977,6 +977,11 @@ int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
 					 const char *mod_name);
 void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
+int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
+			resource_size_t min, resource_size_t max,
+			resource_size_t size, resource_size_t align,
+			bool fb_overlap_ok);
+
 /**
  * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
  *
@@ -1233,8 +1238,6 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
-extern struct resource *hyperv_mmio;
-
 /*
  * Negotiated version with the Host.
  */

commit 7f163a6fd957a85f7f66a129db1ad243a44399ee
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Wed Aug 5 00:52:36 2015 -0700

    drivers:hv: Modify hv_vmbus to search for all MMIO ranges available.
    
    This patch changes the logic in hv_vmbus to record all of the ranges in the
    VM's firmware (BIOS or UEFI) that offer regions of memory-mapped I/O space for
    use by paravirtual front-end drivers.  The old logic just found one range
    above 4GB and called it good.  This logic will find any ranges above 1MB.
    
    It would have been possible with this patch to just use existing resource
    allocation functions, rather than keep track of the entire set of Hyper-V
    related MMIO regions in VMBus.  This strategy, however, is not sufficient
    when the resource allocator needs to be aware of the constraints of a
    Hyper-V virtual machine, which is what happens in the next patch in the series.
    So this first patch exists to show the first steps in reworking the MMIO
    allocation paths for Hyper-V front-end drivers.
    
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 30d3a1f79450..217e14be77b9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1233,7 +1233,7 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
-extern struct resource hyperv_mmio;
+extern struct resource *hyperv_mmio;
 
 /*
  * Negotiated version with the Host.

commit 1f656ff3fdddc2f59649cc84b633b799908f1f7b
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat May 30 23:37:48 2015 -0700

    Drivers: hv: vmbus: Implement NUMA aware CPU affinity for channels
    
    Channels/sub-channels can be affinitized to VCPUs in the guest. Implement
    this affinity in a way that is NUMA aware. The current protocol distributed
    the primary channels uniformly across all available CPUs. The new protocol
    is NUMA aware: primary channels are distributed across the available NUMA
    nodes while the sub-channels within a primary channel are distributed amongst
    CPUs within the NUMA node assigned to the primary channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 4317cd1b69ed..30d3a1f79450 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -696,6 +696,11 @@ struct vmbus_channel {
 	u32 target_vp;
 	/* The corresponding CPUID in the guest */
 	u32 target_cpu;
+	/*
+	 * State to manage the CPU affiliation of channels.
+	 */
+	struct cpumask alloced_cpus_in_node;
+	int numa_node;
 	/*
 	 * Support for sub-channels. For high performance devices,
 	 * it will be useful to have multiple sub-channels to support

commit 6c4e5f9c9ff41ea997fd0f345b3b2b88c113eb68
Author: Keith Mange <keith.mange@microsoft.com>
Date:   Tue May 26 14:23:01 2015 -0700

    Drivers: hv: vmbus:Update preferred vmbus protocol version to windows 10.
    
    Add support for Windows 10.
    
    Signed-off-by: Keith Mange <keith.mange@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 3932a993ff5a..4317cd1b69ed 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -160,16 +160,18 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
  * 1 . 1  (Windows 7)
  * 2 . 4  (Windows 8)
  * 3 . 0  (Windows 8 R2)
+ * 4 . 0  (Windows 10)
  */
 
 #define VERSION_WS2008  ((0 << 16) | (13))
 #define VERSION_WIN7    ((1 << 16) | (1))
 #define VERSION_WIN8    ((2 << 16) | (4))
 #define VERSION_WIN8_1    ((3 << 16) | (0))
+#define VERSION_WIN10	((4 << 16) | (0))
 
 #define VERSION_INVAL -1
 
-#define VERSION_CURRENT VERSION_WIN8_1
+#define VERSION_CURRENT VERSION_WIN10
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)

commit fea844a2b0edd6540d5cde2cd54a8a3c86e9c53f
Author: Vitaly Kuznetsov <[mailto:vkuznets@redhat.com]>
Date:   Wed May 6 17:47:43 2015 -0700

    Drivers: hv: vmbus: briefly comment num_sc and next_oc
    
    next_oc and num_sc fields of struct vmbus_channel deserve a description. Move
    them closer to sc_list as these fields are related to it.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index ea934864293d..3932a993ff5a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -726,6 +726,15 @@ struct vmbus_channel {
 	 * All Sub-channels of a primary channel are linked here.
 	 */
 	struct list_head sc_list;
+	/*
+	 * Current number of sub-channels.
+	 */
+	int num_sc;
+	/*
+	 * Number of a sub-channel (position within sc_list) which is supposed
+	 * to be used as the next outgoing channel.
+	 */
+	int next_oc;
 	/*
 	 * The primary channel this sub-channel belongs to.
 	 * This will be NULL for the primary channel.
@@ -740,9 +749,6 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
-
-	int num_sc;
-	int next_oc;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)

commit 2db84eff127e3f4b3635edc589cd6a56db8755a3
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 22 21:31:32 2015 -0700

    Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state
    
    Implement the protocol for tearing down the monitor state established with
    the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Tested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e29ccddc6300..ea934864293d 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -389,6 +389,7 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_INITIATE_CONTACT		= 14,
 	CHANNELMSG_VERSION_RESPONSE		= 15,
 	CHANNELMSG_UNLOAD			= 16,
+	CHANNELMSG_UNLOAD_RESPONSE		= 17,
 	CHANNELMSG_COUNT
 };
 

commit db9ba2088f6507fee370904f02db1eb9b49bd088
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 22 21:31:31 2015 -0700

    drivers: hv: vmbus: Get rid of some unused definitions
    
    Get rid of some unused definitions.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 1744148a39f9..e29ccddc6300 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -389,10 +389,6 @@ enum vmbus_channel_message_type {
 	CHANNELMSG_INITIATE_CONTACT		= 14,
 	CHANNELMSG_VERSION_RESPONSE		= 15,
 	CHANNELMSG_UNLOAD			= 16,
-#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
-	CHANNELMSG_VIEWRANGE_ADD		= 17,
-	CHANNELMSG_VIEWRANGE_REMOVE		= 18,
-#endif
 	CHANNELMSG_COUNT
 };
 
@@ -549,21 +545,6 @@ struct vmbus_channel_gpadl_torndown {
 	u32 gpadl;
 } __packed;
 
-#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
-struct vmbus_channel_view_range_add {
-	struct vmbus_channel_message_header header;
-	PHYSICAL_ADDRESS viewrange_base;
-	u64 viewrange_length;
-	u32 child_relid;
-} __packed;
-
-struct vmbus_channel_view_range_remove {
-	struct vmbus_channel_message_header header;
-	PHYSICAL_ADDRESS viewrange_base;
-	u32 child_relid;
-} __packed;
-#endif
-
 struct vmbus_channel_relid_released {
 	struct vmbus_channel_message_header header;
 	u32 child_relid;

commit 3647a83d9dcf00b8e17777ec8aa1e48f1ed4fe06
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Apr 11 18:07:39 2015 -0700

    Drivers: hv: util: move kvp/vss function declarations to hyperv_vmbus.h
    
    These declarations are internal to hv_util module and hv_fcopy_* declarations
    already reside there.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Tested-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 902c37aef67e..1744148a39f9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1236,13 +1236,6 @@ extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 					struct icmsg_negotiate *, u8 *, int,
 					int);
 
-int hv_kvp_init(struct hv_util_service *);
-void hv_kvp_deinit(void);
-void hv_kvp_onchannelcallback(void *);
-
-int hv_vss_init(struct hv_util_service *);
-void hv_vss_deinit(void);
-void hv_vss_onchannelcallback(void *);
 void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
 extern struct resource hyperv_mmio;

commit aadc3780f31865edc84c587ab718a33a8eeeb09d
Author: Dexuan Cui <decui@microsoft.com>
Date:   Fri Mar 27 09:10:10 2015 -0700

    hv: remove the per-channel workqueue
    
    It's not necessary any longer, since we can safely run the blocking
    message handlers in vmbus_connection.work_queue now.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 80e444bfc9dc..902c37aef67e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -653,8 +653,6 @@ struct vmbus_channel {
 
 	struct hv_device *device_obj;
 
-	struct work_struct work;
-
 	enum vmbus_channel_state state;
 
 	struct vmbus_channel_offer_channel offermsg;
@@ -675,7 +673,6 @@ struct vmbus_channel {
 	struct hv_ring_buffer_info outbound;	/* send to parent */
 	struct hv_ring_buffer_info inbound;	/* receive from parent */
 	spinlock_t inbound_lock;
-	struct workqueue_struct *controlwq;
 
 	struct vmbus_close_msg close_msg;
 

commit e9395e3f8952110bda60b54ad03ec52c6e9c7dbd
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 28 11:39:04 2015 -0800

    Drivers: hv: vmbus: Suport an API to send packet with additional control
    
    Implement an API that gives additional control on the what VMBUS flags will be
    set as well as if the host needs to be signalled. This API will be
    useful for clients that want to batch up requests to the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 86e1a7a46af3..80e444bfc9dc 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -867,6 +867,14 @@ extern int vmbus_sendpacket(struct vmbus_channel *channel,
 				  enum vmbus_packet_type type,
 				  u32 flags);
 
+extern int vmbus_sendpacket_ctl(struct vmbus_channel *channel,
+				  void *buffer,
+				  u32 bufferLen,
+				  u64 requestid,
+				  enum vmbus_packet_type type,
+				  u32 flags,
+				  bool kick_q);
+
 extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
 					    struct hv_page_buffer pagebuffers[],
 					    u32 pagecount,

commit 87e93d61708fe2c44875d1ecdb174aad070dbd08
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 28 11:39:03 2015 -0800

    Drivers: hv: vmbus: Suport an API to send pagebuffers with additional control
    
    Implement an API for sending pagebuffers that gives more control to the client
    in terms of setting the vmbus flags as well as deciding when to
    notify the host. This will be useful for enabling batch processing.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 1ca582457076..86e1a7a46af3 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -874,6 +874,15 @@ extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
 					    u32 bufferlen,
 					    u64 requestid);
 
+extern int vmbus_sendpacket_pagebuffer_ctl(struct vmbus_channel *channel,
+					   struct hv_page_buffer pagebuffers[],
+					   u32 pagecount,
+					   void *buffer,
+					   u32 bufferlen,
+					   u64 requestid,
+					   u32 flags,
+					   bool kick_q);
+
 extern int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
 					struct hv_multipage_buffer *mpb,
 					void *buffer,

commit a13e8bbe851a96a0e78c2bd599bc34082fa697cd
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 28 11:39:02 2015 -0800

    Drivers: hv: vmbus: Use a round-robin algorithm for picking the outgoing channel
    
    The current algorithm for picking an outgoing channel was not distributing
    the load well. Implement a simple round-robin scheme to ensure good
    distribution of the outgoing traffic.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Long Li <longli@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index dd92a854c700..1ca582457076 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -761,6 +761,9 @@ struct vmbus_channel {
 	 * link up channels based on their CPU affinity.
 	 */
 	struct list_head percpu_list;
+
+	int num_sc;
+	int next_oc;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)

commit ed6cfcc5fdf2ebca320b6f74c836e555e18216e1
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 28 11:18:17 2015 -0800

    Drivers: hv: vmbus: Introduce a function to remove a rescinded offer
    
    In response to a rescind message, we need to remove the channel and the
    corresponding device. Cleanup this code path by factoring out the code
    to remove a channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7d976ac01fac..dd92a854c700 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1226,6 +1226,7 @@ void hv_kvp_onchannelcallback(void *);
 int hv_vss_init(struct hv_util_service *);
 void hv_vss_deinit(void);
 void hv_vss_onchannelcallback(void *);
+void hv_process_channel_removal(struct vmbus_channel *channel, u32 relid);
 
 extern struct resource hyperv_mmio;
 

commit 04653a009a63d6a91c60a5449ea97e3ed5e1dc29
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Feb 27 11:26:05 2015 -0800

    Drivers: hv: vmbus: Add support for the NetworkDirect GUID
    
    NetworkDirect is a service that supports guest RDMA.
    Define the GUID for this service.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 26a32b771ee5..7d976ac01fac 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1109,6 +1109,16 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0x9A, 0xE7, 0x6B, 0x17, 0x49, 0x77, 0xC1, 0x92 \
 		}
 
+/*
+ * NetworkDirect. This is the guest RDMA service.
+ * {8c2eaf3d-32a7-4b09-ab99-bd1f1c86b501}
+ */
+#define HV_ND_GUID \
+	.guid = { \
+			0x3d, 0xaf, 0x2e, 0x8c, 0xa7, 0x32, 0x09, 0x4b, \
+			0xab, 0x99, 0xbd, 0x1f, 0x1c, 0x86, 0xb5, 0x01 \
+		}
+
 /*
  * Common header for Hyper-V ICs
  */

commit bc63b6f634d91a0b2a7f3ba4f266e55fec369de3
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 27 11:25:52 2015 -0800

    Drivers: hv: vmbus: rename channel work queues
    
    All channel work queues are named 'hv_vmbus_ctl', this makes them
    indistinguishable in ps output and makes it hard to link to the corresponding
    vmbus device. Rename them to hv_vmbus_ctl/N and make vmbus device names match,
    e.g. now vmbus_1 device is served by hv_vmbus_ctl/1 work queue.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5a2ba674795e..26a32b771ee5 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -646,6 +646,9 @@ struct hv_input_signal_event_buffer {
 };
 
 struct vmbus_channel {
+	/* Unique channel id */
+	int id;
+
 	struct list_head listentry;
 
 	struct hv_device *device_obj;

commit 67fae053bfc6e84144150e4c6c62670abb215c33
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue Jan 20 16:45:05 2015 +0100

    Drivers: hv: rename sc_lock to the more generic lock
    
    sc_lock spinlock in struct vmbus_channel is being used to not only protect the
    sc_list field, e.g. vmbus_open() function uses it to implement test-and-set
    access to the state field. Rename it to the more generic 'lock' and add the
    description.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 259023a34bec..5a2ba674795e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -734,7 +734,12 @@ struct vmbus_channel {
 	 */
 	void (*sc_creation_callback)(struct vmbus_channel *new_sc);
 
-	spinlock_t sc_lock;
+	/*
+	 * The spinlock to protect the structure. It is being used to protect
+	 * test-and-set access to various attributes of the structure as well
+	 * as all sc_list operations.
+	 */
+	spinlock_t lock;
 	/*
 	 * All Sub-channels of a primary channel are linked here.
 	 */

commit d61031ee8df6214d58371a1cc36a0591e242fba0
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Jan 9 23:54:34 2015 -0800

    Drivers: hv: vmbus: Support a vmbus API for efficiently sending page arrays
    
    Currently, the API for sending a multi-page buffer over VMBUS is limited to
    a maximum pfn array of MAX_MULTIPAGE_BUFFER_COUNT. This limitation is
    not imposed by the host and unnecessarily limits the maximum payload
    that can be sent. Implement an API that does not have this restriction.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 476c685ca6f9..259023a34bec 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -57,6 +57,18 @@ struct hv_multipage_buffer {
 	u64 pfn_array[MAX_MULTIPAGE_BUFFER_COUNT];
 };
 
+/*
+ * Multiple-page buffer array; the pfn array is variable size:
+ * The number of entries in the PFN array is determined by
+ * "len" and "offset".
+ */
+struct hv_mpb_array {
+	/* Length and Offset determines the # of pfns in the array */
+	u32 len;
+	u32 offset;
+	u64 pfn_array[];
+};
+
 /* 0x18 includes the proprietary packet header */
 #define MAX_PAGE_BUFFER_PACKET		(0x18 +			\
 					(sizeof(struct hv_page_buffer) * \
@@ -814,6 +826,18 @@ struct vmbus_channel_packet_multipage_buffer {
 	struct hv_multipage_buffer range;
 } __packed;
 
+/* The format must be the same as struct vmdata_gpa_direct */
+struct vmbus_packet_mpb_array {
+	u16 type;
+	u16 dataoffset8;
+	u16 length8;
+	u16 flags;
+	u64 transactionid;
+	u32 reserved;
+	u32 rangecount;         /* Always 1 in this case */
+	struct hv_mpb_array range;
+} __packed;
+
 
 extern int vmbus_open(struct vmbus_channel *channel,
 			    u32 send_ringbuffersize,
@@ -845,6 +869,13 @@ extern int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
 					u32 bufferlen,
 					u64 requestid);
 
+extern int vmbus_sendpacket_mpb_desc(struct vmbus_channel *channel,
+				     struct vmbus_packet_mpb_array *mpb,
+				     u32 desc_size,
+				     void *buffer,
+				     u32 bufferlen,
+				     u64 requestid);
+
 extern int vmbus_establish_gpadl(struct vmbus_channel *channel,
 				      void *kbuffer,
 				      u32 size,

commit c3582a2c4d0baf1fa3955c8b3d3d61308df474c7
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Mon Dec 1 13:28:39 2014 -0800

    hyperv: Add support for vNIC hot removal
    
    This patch adds proper handling of the vNIC hot removal event, which includes
    a rescind-channel-offer message from the host side that triggers vNIC close and
    removal. In this case, the notices to the host during close and removal is not
    necessary because the channel is rescinded. This patch blocks these unnecessary
    messages, and lets vNIC removal process complete normally.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 08cfaff8a072..476c685ca6f9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -650,6 +650,8 @@ struct vmbus_channel {
 	u8 monitor_grp;
 	u8 monitor_bit;
 
+	bool rescind; /* got rescind msg */
+
 	u32 ringbuffer_gpadlhandle;
 
 	/* Allocated memory for ring buffer */

commit 3a28fa35d6658703cd26f9c16aaea0eae06afd40
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Apr 8 18:45:54 2014 -0700

    Drivers: hv: vmbus: Implement per-CPU mapping of relid to channel
    
    Currently the mapping of the relID to channel is done under the protection of a
    single spin lock. Starting with ws2012, each channel is bound to a specific VCPU
    in the guest. Use this binding to eliminate the spin lock by setting up
    per-cpu state for mapping relId to the channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a274e089df78..08cfaff8a072 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -734,6 +734,11 @@ struct vmbus_channel {
 	 * Support per-channel state for use by vmbus drivers.
 	 */
 	void *per_channel_state;
+	/*
+	 * To support per-cpu lookup mapping of relid to channel,
+	 * link up channels based on their CPU affinity.
+	 */
+	struct list_head percpu_list;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)

commit d3ba720dd58cdf6630fee4b89482c465d5ad0d0f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Apr 8 18:45:53 2014 -0700

    Drivers: hv: Eliminate the channel spinlock in the callback path
    
    By ensuring that we set the callback handler to NULL in the channel close
    path on the same CPU that the channel is bound to, we can eliminate this lock
    acquisition and release in a performance critical path.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2d7b4f139c32..a274e089df78 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -696,6 +696,8 @@ struct vmbus_channel {
 	 * preserve the earlier behavior.
 	 */
 	u32 target_vp;
+	/* The corresponding CPUID in the guest */
+	u32 target_cpu;
 	/*
 	 * Support for sub-channels. For high performance devices,
 	 * it will be useful to have multiple sub-channels to support

commit 03367ef5ea811475187a0732aada068919e14d61
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Apr 3 18:02:45 2014 -0700

    Drivers: hv: vmbus: Negotiate version 3.0 when running on ws2012r2 hosts
    
    Only ws2012r2 hosts support the ability to reconnect to the host on VMBUS. This functionality
    is needed by kexec in Linux. To use this functionality we need to negotiate version 3.0 of the
    VMBUS protocol.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>        [3.9+]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index ab7359fde987..2d7b4f139c32 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -147,15 +147,17 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
  * 0 . 13 (Windows Server 2008)
  * 1 . 1  (Windows 7)
  * 2 . 4  (Windows 8)
+ * 3 . 0  (Windows 8 R2)
  */
 
 #define VERSION_WS2008  ((0 << 16) | (13))
 #define VERSION_WIN7    ((1 << 16) | (1))
 #define VERSION_WIN8    ((2 << 16) | (4))
+#define VERSION_WIN8_1    ((3 << 16) | (0))
 
 #define VERSION_INVAL -1
 
-#define VERSION_CURRENT VERSION_WIN8
+#define VERSION_CURRENT VERSION_WIN8_1
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)

commit 7e5ec36834a5752304dc0751dfab42ba6ad64a85
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Mar 7 00:10:34 2014 -0800

    Drivers: hv: vmbus: Increase the limit on the number of pfns we can handle
    
    Increase the number of PFNs we can handle in a single vmbus packet.
    Some network packets may have more PFNs than the current limit we have.
    This is not a bug and this patch can be applied to the *next tree.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 330ec44de575..ab7359fde987 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -37,7 +37,7 @@
 #include <linux/mod_devicetable.h>
 
 
-#define MAX_PAGE_BUFFER_COUNT				19
+#define MAX_PAGE_BUFFER_COUNT				32
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
 
 #pragma pack(push, 1)

commit 90eedf0cbe4ba2a316633d6547d331c8b30517e7
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Mon Feb 24 14:17:09 2014 +0100

    vmbus: use resource for hyperv mmio region
    
    Use a resource for the hyperv mmio region instead of start/size
    variables.  Register the region properly so it shows up in
    /proc/iomem.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62ea1a06836a..330ec44de575 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1167,8 +1167,7 @@ int hv_vss_init(struct hv_util_service *);
 void hv_vss_deinit(void);
 void hv_vss_onchannelcallback(void *);
 
-extern u64 hyperv_mmio_start;
-extern u64 hyperv_mmio_size;
+extern struct resource hyperv_mmio;
 
 /*
  * Negotiated version with the Host.

commit 01325476d6e46185031be4a9bc6443832dbc807c
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Feb 16 11:34:30 2014 -0800

    Drivers: hv: Implement the file copy service
    
    Implement the file copy service for Linux guests on Hyper-V. This permits the
    host to copy a file (over VMBUS) into the guest. This facility is part of
    "guest integration services" supported on the Windows platform.
    Here is a link that provides additional details on this functionality:
    
    http://technet.microsoft.com/en-us/library/dn464282.aspx
    
    In V1 version of the patch I have addressed comments from
    Olaf Hering <olaf@aepfle.de> and Dan Carpenter <dan.carpenter@oracle.com>
    
    In V2 version of this patch I did some minor cleanup (making some globals
    static). In V4 version of the patch I have addressed all of Olaf's
    most recent set of comments/concerns.
    
    In V5 version of the patch I had addressed Greg's most recent comments.
    I would like to thank Greg for suggesting that I use misc device; it has
    significantly simplified the code.
    
    In V6 version of the patch I have cleaned up error message based on Olaf's
    comments. I have also rebased the patch based on the current tip.
    
    In this version of the patch, I have addressed the latest comments from Greg.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index fb66fba368d7..62ea1a06836a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -30,7 +30,6 @@
 #include <linux/types.h>
 #include <linux/scatterlist.h>
 #include <linux/list.h>
-#include <linux/uuid.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/completion.h>
@@ -1049,6 +1048,17 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0xB7, 0x6B, 0x6F, 0xD0, 0xBE, 0x52, 0x8C, 0xDA \
 		}
 
+/*
+ * Guest File Copy Service
+ * {34D14BE3-DEE4-41c8-9AE7-6B174977C192}
+ */
+
+#define HV_FCOPY_GUID \
+	.guid = { \
+			0xE3, 0x4B, 0xD1, 0x34, 0xE4, 0xDE, 0xC8, 0x41, \
+			0x9A, 0xE7, 0x6B, 0x17, 0x49, 0x77, 0xC1, 0x92 \
+		}
+
 /*
  * Common header for Hyper-V ICs
  */

commit ba4b60e85d6c5fc2242fd24e131a47fb922e5d89
Merge: 5dba4c56dfa6 6d0abeca3242
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Feb 18 08:09:40 2014 -0800

    Merge 3.14-rc3 into char-misc-next
    
    We need the fixes here for future mei and other patches.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8a7206a89f85c8439561b0eff85bb9440a2e97a9
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Feb 3 12:42:45 2014 -0800

    Drivers: hv: vmbus: Support per-channel driver state
    
    As we implement Virtual Receive Side Scaling on the networking side
    (the VRSS patches are currently under review), it will be useful to have
    per-channel state that vmbus drivers can manage. Add support for
    managing per-channel state.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 9b07e1f070ac..d47bab9e7a18 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -727,6 +727,10 @@ struct vmbus_channel {
 	 * This will be NULL for the primary channel.
 	 */
 	struct vmbus_channel *primary_channel;
+	/*
+	 * Support per-channel state for use by vmbus drivers.
+	 */
+	void *per_channel_state;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
@@ -734,6 +738,16 @@ static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
 	c->batched_reading = state;
 }
 
+static inline void set_per_channel_state(struct vmbus_channel *c, void *s)
+{
+	c->per_channel_state = s;
+}
+
+static inline void *get_per_channel_state(struct vmbus_channel *c)
+{
+	return c->per_channel_state;
+}
+
 void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);

commit 011a7c3cc3aa60c7ea6bb49d847e80a299ba7b36
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 1 19:02:20 2014 -0800

    Drivers: hv: vmbus: Cleanup the packet send path
    
    The current channel code is using scatterlist abstraction to pass data to the
    ringbuffer API on the send path. This causes unnecessary translations
    between virtual and physical addresses. Fix this.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6b862dadbb7a..9b07e1f070ac 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -802,7 +802,7 @@ extern int vmbus_open(struct vmbus_channel *channel,
 extern void vmbus_close(struct vmbus_channel *channel);
 
 extern int vmbus_sendpacket(struct vmbus_channel *channel,
-				  const void *buffer,
+				  void *buffer,
 				  u32 bufferLen,
 				  u64 requestid,
 				  enum vmbus_packet_type type,

commit 90f3453585479d5beb75058da46eb573ced0e6ac
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Jan 29 18:14:39 2014 -0800

    Drivers: hv: vmbus: Extract the mmio information from DSDT
    
    On Gen2 firmware, Hyper-V does not emulate the PCI bus. However, the MMIO
    information is packaged up in DSDT. Extract this information and export it
    for use by the synthetic framebuffer driver. This is the only driver that
    needs this currently.
    
    In this version of the patch mmio, I have updated the hyperv header file
    (linux/hyperv.h) with mmio definitions.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 167ef47e3d6e..6b862dadbb7a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1143,6 +1143,9 @@ int hv_vss_init(struct hv_util_service *);
 void hv_vss_deinit(void);
 void hv_vss_onchannelcallback(void *);
 
+extern u64 hyperv_mmio_start;
+extern u64 hyperv_mmio_size;
+
 /*
  * Negotiated version with the Host.
  */

commit 5267cf02c7794953d89e9593a0d497bf43e3790d
Author: Bjarke Istrup Pedersen <gurligebis@gentoo.org>
Date:   Wed Jan 22 09:16:58 2014 +0000

    hv: Add hyperv.h to uapi headers
    
    This patch adds the hyperv.h header to the uapi folder, and adds it to the Kbuild file.
    Doing this enables compiling userspace Hyper-V tools using the installed headers.
    
    Version 2: Split UAPI parts into new header, instead of duplicating.
    
    Signed-off-by: Bjarke Istrup Pedersen <gurligebis@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 15da677478dd..167ef47e3d6e 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -25,325 +25,9 @@
 #ifndef _HYPERV_H
 #define _HYPERV_H
 
-#include <linux/types.h>
-
-/*
- * Framework version for util services.
- */
-#define UTIL_FW_MINOR  0
-
-#define UTIL_WS2K8_FW_MAJOR  1
-#define UTIL_WS2K8_FW_VERSION     (UTIL_WS2K8_FW_MAJOR << 16 | UTIL_FW_MINOR)
-
-#define UTIL_FW_MAJOR  3
-#define UTIL_FW_VERSION     (UTIL_FW_MAJOR << 16 | UTIL_FW_MINOR)
-
-
-/*
- * Implementation of host controlled snapshot of the guest.
- */
-
-#define VSS_OP_REGISTER 128
-
-enum hv_vss_op {
-	VSS_OP_CREATE = 0,
-	VSS_OP_DELETE,
-	VSS_OP_HOT_BACKUP,
-	VSS_OP_GET_DM_INFO,
-	VSS_OP_BU_COMPLETE,
-	/*
-	 * Following operations are only supported with IC version >= 5.0
-	 */
-	VSS_OP_FREEZE, /* Freeze the file systems in the VM */
-	VSS_OP_THAW, /* Unfreeze the file systems */
-	VSS_OP_AUTO_RECOVER,
-	VSS_OP_COUNT /* Number of operations, must be last */
-};
-
-
-/*
- * Header for all VSS messages.
- */
-struct hv_vss_hdr {
-	__u8 operation;
-	__u8 reserved[7];
-} __attribute__((packed));
-
-
-/*
- * Flag values for the hv_vss_check_feature. Linux supports only
- * one value.
- */
-#define VSS_HBU_NO_AUTO_RECOVERY	0x00000005
-
-struct hv_vss_check_feature {
-	__u32 flags;
-} __attribute__((packed));
-
-struct hv_vss_check_dm_info {
-	__u32 flags;
-} __attribute__((packed));
-
-struct hv_vss_msg {
-	union {
-		struct hv_vss_hdr vss_hdr;
-		int error;
-	};
-	union {
-		struct hv_vss_check_feature vss_cf;
-		struct hv_vss_check_dm_info dm_info;
-	};
-} __attribute__((packed));
-
-/*
- * An implementation of HyperV key value pair (KVP) functionality for Linux.
- *
- *
- * Copyright (C) 2010, Novell, Inc.
- * Author : K. Y. Srinivasan <ksrinivasan@novell.com>
- *
- */
-
-/*
- * Maximum value size - used for both key names and value data, and includes
- * any applicable NULL terminators.
- *
- * Note:  This limit is somewhat arbitrary, but falls easily within what is
- * supported for all native guests (back to Win 2000) and what is reasonable
- * for the IC KVP exchange functionality.  Note that Windows Me/98/95 are
- * limited to 255 character key names.
- *
- * MSDN recommends not storing data values larger than 2048 bytes in the
- * registry.
- *
- * Note:  This value is used in defining the KVP exchange message - this value
- * cannot be modified without affecting the message size and compatibility.
- */
-
-/*
- * bytes, including any null terminators
- */
-#define HV_KVP_EXCHANGE_MAX_VALUE_SIZE          (2048)
-
-
-/*
- * Maximum key size - the registry limit for the length of an entry name
- * is 256 characters, including the null terminator
- */
-
-#define HV_KVP_EXCHANGE_MAX_KEY_SIZE            (512)
+#include <uapi/linux/hyperv.h>
 
-/*
- * In Linux, we implement the KVP functionality in two components:
- * 1) The kernel component which is packaged as part of the hv_utils driver
- * is responsible for communicating with the host and responsible for
- * implementing the host/guest protocol. 2) A user level daemon that is
- * responsible for data gathering.
- *
- * Host/Guest Protocol: The host iterates over an index and expects the guest
- * to assign a key name to the index and also return the value corresponding to
- * the key. The host will have atmost one KVP transaction outstanding at any
- * given point in time. The host side iteration stops when the guest returns
- * an error. Microsoft has specified the following mapping of key names to
- * host specified index:
- *
- *	Index		Key Name
- *	0		FullyQualifiedDomainName
- *	1		IntegrationServicesVersion
- *	2		NetworkAddressIPv4
- *	3		NetworkAddressIPv6
- *	4		OSBuildNumber
- *	5		OSName
- *	6		OSMajorVersion
- *	7		OSMinorVersion
- *	8		OSVersion
- *	9		ProcessorArchitecture
- *
- * The Windows host expects the Key Name and Key Value to be encoded in utf16.
- *
- * Guest Kernel/KVP Daemon Protocol: As noted earlier, we implement all of the
- * data gathering functionality in a user mode daemon. The user level daemon
- * is also responsible for binding the key name to the index as well. The
- * kernel and user-level daemon communicate using a connector channel.
- *
- * The user mode component first registers with the
- * the kernel component. Subsequently, the kernel component requests, data
- * for the specified keys. In response to this message the user mode component
- * fills in the value corresponding to the specified key. We overload the
- * sequence field in the cn_msg header to define our KVP message types.
- *
- *
- * The kernel component simply acts as a conduit for communication between the
- * Windows host and the user-level daemon. The kernel component passes up the
- * index received from the Host to the user-level daemon. If the index is
- * valid (supported), the corresponding key as well as its
- * value (both are strings) is returned. If the index is invalid
- * (not supported), a NULL key string is returned.
- */
-
-
-/*
- * Registry value types.
- */
-
-#define REG_SZ 1
-#define REG_U32 4
-#define REG_U64 8
-
-/*
- * As we look at expanding the KVP functionality to include
- * IP injection functionality, we need to maintain binary
- * compatibility with older daemons.
- *
- * The KVP opcodes are defined by the host and it was unfortunate
- * that I chose to treat the registration operation as part of the
- * KVP operations defined by the host.
- * Here is the level of compatibility
- * (between the user level daemon and the kernel KVP driver) that we
- * will implement:
- *
- * An older daemon will always be supported on a newer driver.
- * A given user level daemon will require a minimal version of the
- * kernel driver.
- * If we cannot handle the version differences, we will fail gracefully
- * (this can happen when we have a user level daemon that is more
- * advanced than the KVP driver.
- *
- * We will use values used in this handshake for determining if we have
- * workable user level daemon and the kernel driver. We begin by taking the
- * registration opcode out of the KVP opcode namespace. We will however,
- * maintain compatibility with the existing user-level daemon code.
- */
-
-/*
- * Daemon code not supporting IP injection (legacy daemon).
- */
-
-#define KVP_OP_REGISTER	4
-
-/*
- * Daemon code supporting IP injection.
- * The KVP opcode field is used to communicate the
- * registration information; so define a namespace that
- * will be distinct from the host defined KVP opcode.
- */
-
-#define KVP_OP_REGISTER1 100
-
-enum hv_kvp_exchg_op {
-	KVP_OP_GET = 0,
-	KVP_OP_SET,
-	KVP_OP_DELETE,
-	KVP_OP_ENUMERATE,
-	KVP_OP_GET_IP_INFO,
-	KVP_OP_SET_IP_INFO,
-	KVP_OP_COUNT /* Number of operations, must be last. */
-};
-
-enum hv_kvp_exchg_pool {
-	KVP_POOL_EXTERNAL = 0,
-	KVP_POOL_GUEST,
-	KVP_POOL_AUTO,
-	KVP_POOL_AUTO_EXTERNAL,
-	KVP_POOL_AUTO_INTERNAL,
-	KVP_POOL_COUNT /* Number of pools, must be last. */
-};
-
-/*
- * Some Hyper-V status codes.
- */
-
-#define HV_S_OK				0x00000000
-#define HV_E_FAIL			0x80004005
-#define HV_S_CONT			0x80070103
-#define HV_ERROR_NOT_SUPPORTED		0x80070032
-#define HV_ERROR_MACHINE_LOCKED		0x800704F7
-#define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
-#define HV_INVALIDARG			0x80070057
-#define HV_GUID_NOTFOUND		0x80041002
-
-#define ADDR_FAMILY_NONE	0x00
-#define ADDR_FAMILY_IPV4	0x01
-#define ADDR_FAMILY_IPV6	0x02
-
-#define MAX_ADAPTER_ID_SIZE	128
-#define MAX_IP_ADDR_SIZE	1024
-#define MAX_GATEWAY_SIZE	512
-
-
-struct hv_kvp_ipaddr_value {
-	__u16	adapter_id[MAX_ADAPTER_ID_SIZE];
-	__u8	addr_family;
-	__u8	dhcp_enabled;
-	__u16	ip_addr[MAX_IP_ADDR_SIZE];
-	__u16	sub_net[MAX_IP_ADDR_SIZE];
-	__u16	gate_way[MAX_GATEWAY_SIZE];
-	__u16	dns_addr[MAX_IP_ADDR_SIZE];
-} __attribute__((packed));
-
-
-struct hv_kvp_hdr {
-	__u8 operation;
-	__u8 pool;
-	__u16 pad;
-} __attribute__((packed));
-
-struct hv_kvp_exchg_msg_value {
-	__u32 value_type;
-	__u32 key_size;
-	__u32 value_size;
-	__u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
-	union {
-		__u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
-		__u32 value_u32;
-		__u64 value_u64;
-	};
-} __attribute__((packed));
-
-struct hv_kvp_msg_enumerate {
-	__u32 index;
-	struct hv_kvp_exchg_msg_value data;
-} __attribute__((packed));
-
-struct hv_kvp_msg_get {
-	struct hv_kvp_exchg_msg_value data;
-};
-
-struct hv_kvp_msg_set {
-	struct hv_kvp_exchg_msg_value data;
-};
-
-struct hv_kvp_msg_delete {
-	__u32 key_size;
-	__u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
-};
-
-struct hv_kvp_register {
-	__u8 version[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
-};
-
-struct hv_kvp_msg {
-	union {
-		struct hv_kvp_hdr	kvp_hdr;
-		int error;
-	};
-	union {
-		struct hv_kvp_msg_get		kvp_get;
-		struct hv_kvp_msg_set		kvp_set;
-		struct hv_kvp_msg_delete	kvp_delete;
-		struct hv_kvp_msg_enumerate	kvp_enum_data;
-		struct hv_kvp_ipaddr_value      kvp_ip_val;
-		struct hv_kvp_register		kvp_register;
-	} body;
-} __attribute__((packed));
-
-struct hv_kvp_ip_msg {
-	__u8 operation;
-	__u8 pool;
-	struct hv_kvp_ipaddr_value      kvp_ip_val;
-} __attribute__((packed));
-
-#ifdef __KERNEL__
+#include <linux/types.h>
 #include <linux/scatterlist.h>
 #include <linux/list.h>
 #include <linux/uuid.h>
@@ -1465,5 +1149,4 @@ void hv_vss_onchannelcallback(void *);
 
 extern __u32 vmbus_proto_version;
 
-#endif /* __KERNEL__ */
 #endif /* _HYPERV_H */

commit e28bab4828354583bb66ac09021ca69b341a7db4
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Jan 15 17:12:58 2014 -0800

    Drivers: hv: vmbus: Specify the target CPU that should receive notification
    
    During the initial VMBUS connect phase, starting with WS2012 R2, we should
    specify the VPCU in the guest that should receive the notification. Fix this
    issue. This fix is required to properly connect to the host in the kexeced
    kernel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>        [3.9+]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 15da677478dd..344883dce584 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -875,7 +875,7 @@ struct vmbus_channel_relid_released {
 struct vmbus_channel_initiate_contact {
 	struct vmbus_channel_message_header header;
 	u32 vmbus_version_requested;
-	u32 padding2;
+	u32 target_vcpu; /* The VCPU the host should respond to */
 	u64 interrupt_page;
 	u64 monitor_page1;
 	u64 monitor_page2;

commit d7173493683853047d6efc8d4454c70469a7b033
Merge: 80d26236c7c5 15c03dd4859a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 29 18:27:03 2013 -0700

    Merge 3.12-rc3 into char-misc-next
    
    We need/want the mei fixes in here so we can apply other updates that
    are depending on them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3a4916050ba2e0f1d114ef540abdf02b2b173e61
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Sep 6 11:49:56 2013 -0700

    Drivers: hv: util: Correctly support ws2008R2 and earlier
    
    The current code does not correctly negotiate the version numbers for the util
    driver when hosted on earlier hosts. The version numbers presented by this
    driver were not compatible with the version numbers supported by Windows Server
    2008. Fix this problem.
    
    I would like to thank Olaf Hering (ohering@suse.com) for identifying the problem.
    
    Reported-by: Olaf Hering <ohering@suse.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a3b8b2e2d244..d98503bde7e9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -30,10 +30,13 @@
 /*
  * Framework version for util services.
  */
+#define UTIL_FW_MINOR  0
+
+#define UTIL_WS2K8_FW_MAJOR  1
+#define UTIL_WS2K8_FW_VERSION     (UTIL_WS2K8_FW_MAJOR << 16 | UTIL_FW_MINOR)
 
 #define UTIL_FW_MAJOR  3
-#define UTIL_FW_MINOR  0
-#define UTIL_FW_MAJOR_MINOR     (UTIL_FW_MAJOR << 16 | UTIL_FW_MINOR)
+#define UTIL_FW_VERSION     (UTIL_FW_MAJOR << 16 | UTIL_FW_MINOR)
 
 
 /*

commit 1fdde16d1f93376ad2a2df769f756572c2e84cbd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:33:00 2013 -0700

    hv: delete struct hv_dev_port_info
    
    It's no longer needed, and the struct hv_ring_buffer_debug_info
    structure shouldn't be "global" so move it to the local .h file instead.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c0e8faf40b35..c68ecfe29441 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -429,15 +429,6 @@ struct hv_ring_buffer_info {
 	u32 ring_data_startoffset;
 };
 
-struct hv_ring_buffer_debug_info {
-	u32 current_interrupt_mask;
-	u32 current_read_index;
-	u32 current_write_index;
-	u32 bytes_avail_toread;
-	u32 bytes_avail_towrite;
-};
-
-
 /*
  *
  * hv_get_ringbuffer_availbytes()
@@ -1166,14 +1157,6 @@ extern int vmbus_recvpacket_raw(struct vmbus_channel *channel,
 
 extern void vmbus_ontimer(unsigned long data);
 
-struct hv_dev_port_info {
-	u32 int_mask;
-	u32 read_idx;
-	u32 write_idx;
-	u32 bytes_avail_toread;
-	u32 bytes_avail_towrite;
-};
-
 /* Base driver object */
 struct hv_driver {
 	const char *name;

commit 2c9be3eacc39948af2341595322c014833699ac5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:59 2013 -0700

    hv: delete vmbus_get_debug_info()
    
    It's only used once, only contains 2 function calls, so just make those
    calls directly, deleting the function, and the now unneeded structure
    entirely.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 332e80ce9b8a..c0e8faf40b35 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -899,11 +899,6 @@ enum vmbus_channel_state {
 	CHANNEL_OPENED_STATE,
 };
 
-struct vmbus_channel_debug_info {
-	struct hv_ring_buffer_debug_info inbound;
-	struct hv_ring_buffer_debug_info outbound;
-};
-
 /*
  * Represents each channel msg on the vmbus connection This is a
  * variable-size data structure depending on the msg type itself
@@ -1169,9 +1164,6 @@ extern int vmbus_recvpacket_raw(struct vmbus_channel *channel,
 				     u64 *requestid);
 
 
-extern void vmbus_get_debug_info(struct vmbus_channel *channel,
-				     struct vmbus_channel_debug_info *debug);
-
 extern void vmbus_ontimer(unsigned long data);
 
 struct hv_dev_port_info {

commit 4947c7453b184bc33a0056cf95af61c3cad11ef6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:58 2013 -0700

    hv: move "client/server_monitor_conn_id" bus attributes to dev_groups
    
    This moves the "client_monitor_conn_id" and "server_monitor_conn_id" bus
    attributes to the dev_groups structure, removing the need for it to be
    in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index ec1e5033bb99..332e80ce9b8a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,9 +900,6 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	u32 servermonitor_connectionid;
-	u32 clientmonitor_connectionid;
-
 	struct hv_ring_buffer_debug_info inbound;
 	struct hv_ring_buffer_debug_info outbound;
 };

commit 1cee272b0249c5007391da6cf42903b8f30dbc5a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:57 2013 -0700

    hv: move "client/server_monitor_latency" bus attributes to dev_groups
    
    This moves the "client_monitor_latency" and "server_monitor_latency" bus
    attributes to the dev_groups structure, removing the need for it to be
    in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f0a7d27ffb21..ec1e5033bb99 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,9 +900,7 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	u32 servermonitor_latency;
 	u32 servermonitor_connectionid;
-	u32 clientmonitor_latency;
 	u32 clientmonitor_connectionid;
 
 	struct hv_ring_buffer_debug_info inbound;

commit 76c52bbe5e5ffc6812dcd49729c09f5a207b4a9a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:56 2013 -0700

    hv: move "client/server_monitor_pending" bus attributes to dev_groups
    
    This moves the "client_monitor_pending" and "server_monitor_pending" bus
    attributes to the dev_groups structure, removing the need for it to be
    in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 687c01b85037..f0a7d27ffb21 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,10 +900,8 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	u32 servermonitor_pending;
 	u32 servermonitor_latency;
 	u32 servermonitor_connectionid;
-	u32 clientmonitor_pending;
 	u32 clientmonitor_latency;
 	u32 clientmonitor_connectionid;
 

commit 7c55e1d0e64cf5acd8cf4a25927e2c7c322063aa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:54 2013 -0700

    hv: move "device_id" bus attribute to dev_groups
    
    This moves the "device_id" bus attribute to the dev_groups structure,
    removing the need for it to be in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8ccf6f686272..687c01b85037 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,7 +900,6 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	uuid_le interface_instance;
 	u32 servermonitor_pending;
 	u32 servermonitor_latency;
 	u32 servermonitor_connectionid;

commit 68234c049cc1637a8898ebb3743c8587560929b7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:53 2013 -0700

    hv: move "class_id" bus attribute to dev_groups
    
    This moves the "class_id" bus attribute to the dev_groups structure,
    removing the need for it to be in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 888a8e533d61..8ccf6f686272 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,7 +900,6 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	uuid_le interfacetype;
 	uuid_le interface_instance;
 	u32 servermonitor_pending;
 	u32 servermonitor_latency;

commit 5ffd00e241ea30fdd907d56419170a1e1338664c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:51 2013 -0700

    hv: move "monitor_id" bus attribute to dev_groups
    
    This moves the "state" bus attribute to the dev_groups structure,
    removing the need for it to be in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b350a8cfcff6..888a8e533d61 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -902,7 +902,6 @@ enum vmbus_channel_state {
 struct vmbus_channel_debug_info {
 	uuid_le interfacetype;
 	uuid_le interface_instance;
-	u32 monitorid;
 	u32 servermonitor_pending;
 	u32 servermonitor_latency;
 	u32 servermonitor_connectionid;

commit a8fb5f3d582d3b4997d9449ceb82a0223d169486
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:50 2013 -0700

    hv: move "state" bus attribute to dev_groups
    
    This moves the "state" bus attribute to the dev_groups structure,
    removing the need for it to be in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 45e9b65e6ab6..b350a8cfcff6 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,7 +900,6 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	enum vmbus_channel_state state;
 	uuid_le interfacetype;
 	uuid_le interface_instance;
 	u32 monitorid;

commit 03f3a9107f5e848a42f25e3ab133db9f3b6546c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:49 2013 -0700

    hv: use dev_groups for device attributes
    
    This patch is the first in a series that moves the hv bus code to use the
    dev_groups field instead of dev_attrs, as dev_attrs is going away in future
    kernel releases.
    
    It moves the id sysfs file to the dev_groups structure, and creates the needed
    show/store functions, instead of relying on one "universal" function for this.
    By doing this, it removes the need for this to be in a temporary structure.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a3b8b2e2d244..45e9b65e6ab6 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -900,7 +900,6 @@ enum vmbus_channel_state {
 };
 
 struct vmbus_channel_debug_info {
-	u32 relid;
 	enum vmbus_channel_state state;
 	uuid_le interfacetype;
 	uuid_le interface_instance;

commit cfc25993e81f3fa68481d062be634d33184d5eae
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed May 29 11:29:07 2013 +0200

    Drivers: hv: remove HV_DRV_VERSION
    
    Remove HV_DRV_VERSION, it has no meaning for upstream drivers.
    
    Initially it was supposed to show the "Linux Integration Services"
    version, now it is not in sync anymore with the out-of-tree drivers
    available from the MSFT website.
    
    The only place where a version string is still required is the KVP
    command "IntegrationServicesVersion" which is handled by
    tools/hv/hv_kvp_daemon.c. To satisfy such KVP request from the host pass
    the current string to the daemon during KVP userland registration.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Acked-by:  K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 49949079cf47..a3b8b2e2d244 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -463,27 +463,6 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 	*read = dsize - *write;
 }
 
-
-/*
- * We use the same version numbering for all Hyper-V modules.
- *
- * Definition of versioning is as follows;
- *
- *	Major Number	Changes for these scenarios;
- *			1.	When a new version of Windows Hyper-V
- *				is released.
- *			2.	A Major change has occurred in the
- *				Linux IC's.
- *			(For example the merge for the first time
- *			into the kernel) Every time the Major Number
- *			changes, the Revision number is reset to 0.
- *	Minor Number	Changes when new functionality is added
- *			to the Linux IC's that is not a bug fix.
- *
- * 3.1 - Added completed hv_utils driver. Shutdown/Heartbeat/Timesync
- */
-#define HV_DRV_VERSION           "3.1"
-
 /*
  * VMBUS version is 32 bit entity broken up into
  * two 16 bit quantities: major_number. minor_number.

commit 6741335bc7294548ac95cb1f4671991ff30da193
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Jul 2 10:31:30 2013 -0700

    Drivers: hv: util: Fix a bug in version negotiation code for util services
    
    The current code picked the highest version advertised by the host. WS2012 R2
    has implemented a protocol version for KVP that is not compatible with prior
    protocol versions of KVP. Fix the bug in the current code by explicitly specifying
    the protocol version that the guest can support.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index fae8bac907ef..49949079cf47 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -27,6 +27,14 @@
 
 #include <linux/types.h>
 
+/*
+ * Framework version for util services.
+ */
+
+#define UTIL_FW_MAJOR  3
+#define UTIL_FW_MINOR  0
+#define UTIL_FW_MAJOR_MINOR     (UTIL_FW_MAJOR << 16 | UTIL_FW_MINOR)
+
 
 /*
  * Implementation of host controlled snapshot of the guest.
@@ -1494,7 +1502,7 @@ struct hyperv_service_callback {
 };
 
 #define MAX_SRV_VER	0x7ffffff
-extern void vmbus_prep_negotiate_resp(struct icmsg_hdr *,
+extern bool vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 					struct icmsg_negotiate *, u8 *, int,
 					int);
 

commit 98b80d8938b8e381027f1c3f30855087238fb4fb
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu May 23 12:02:33 2013 -0700

    Drivers: hv: Add the GUID fot synthetic fibre channel device
    
    In preparation for supporting synthetic Fiber Channel device, add the GUID for
    this service.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 405e05a28e65..fae8bac907ef 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1388,6 +1388,16 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0x8e, 0x77, 0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8 \
 		}
 
+/*
+ * Synthetic FC GUID
+ * {2f9bcc4a-0069-4af3-b76b-6fd0be528cda}
+ */
+#define HV_SYNTHFC_GUID \
+	.guid = { \
+			0x4A, 0xCC, 0x9B, 0x2F, 0x69, 0x00, 0xF3, 0x4A, \
+			0xB7, 0x6B, 0x6F, 0xD0, 0xBE, 0x52, 0x8C, 0xDA \
+		}
+
 /*
  * Common header for Hyper-V ICs
  */

commit e68d2971d26577b932a16333ce165af98a96e068
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu May 23 12:02:32 2013 -0700

    Drivers: hv: vmbus: Implement multi-channel support
    
    Starting with Win8, the host supports multiple sub-channels for a given
    device. As in the past, the initial channel offer specifies the device and
    is associated with both the type and the instance GUIDs. For performance
    critical devices, the host may support multiple sub-channels. The sub-channels
    share the same type and instance GUID as the primary channel. The number of
    sub-channels offerrred to the guest depends on the number of virtual CPUs
    assigned to the guest. The guest can request the creation of these sub-channels
    and once created and opened, the guest can distribute the traffic across all
    the channels (the primary and the sub-channels). A request sent on a sub-channel
    will have the response delivered on the same sub-channel.
    
    At channel (sub-channel) creation we bind the channel interrupt to a CPU and
    with this sub-channel support we will be able to spread the interrupt load
    of a given device across all available CPUs.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c2559847d7ee..405e05a28e65 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -909,6 +909,7 @@ enum vmbus_channel_state {
 	CHANNEL_OFFER_STATE,
 	CHANNEL_OPENING_STATE,
 	CHANNEL_OPEN_STATE,
+	CHANNEL_OPENED_STATE,
 };
 
 struct vmbus_channel_debug_info {
@@ -1046,6 +1047,38 @@ struct vmbus_channel {
 	 * preserve the earlier behavior.
 	 */
 	u32 target_vp;
+	/*
+	 * Support for sub-channels. For high performance devices,
+	 * it will be useful to have multiple sub-channels to support
+	 * a scalable communication infrastructure with the host.
+	 * The support for sub-channels is implemented as an extention
+	 * to the current infrastructure.
+	 * The initial offer is considered the primary channel and this
+	 * offer message will indicate if the host supports sub-channels.
+	 * The guest is free to ask for sub-channels to be offerred and can
+	 * open these sub-channels as a normal "primary" channel. However,
+	 * all sub-channels will have the same type and instance guids as the
+	 * primary channel. Requests sent on a given channel will result in a
+	 * response on the same channel.
+	 */
+
+	/*
+	 * Sub-channel creation callback. This callback will be called in
+	 * process context when a sub-channel offer is received from the host.
+	 * The guest can open the sub-channel in the context of this callback.
+	 */
+	void (*sc_creation_callback)(struct vmbus_channel *new_sc);
+
+	spinlock_t sc_lock;
+	/*
+	 * All Sub-channels of a primary channel are linked here.
+	 */
+	struct list_head sc_list;
+	/*
+	 * The primary channel this sub-channel belongs to.
+	 * This will be NULL for the primary channel.
+	 */
+	struct vmbus_channel *primary_channel;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
@@ -1057,6 +1090,34 @@ void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);
 
+/*
+ * APIs for managing sub-channels.
+ */
+
+void vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,
+			void (*sc_cr_cb)(struct vmbus_channel *new_sc));
+
+/*
+ * Retrieve the (sub) channel on which to send an outgoing request.
+ * When a primary channel has multiple sub-channels, we choose a
+ * channel whose VCPU binding is closest to the VCPU on which
+ * this call is being made.
+ */
+struct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary);
+
+/*
+ * Check if sub-channels have already been offerred. This API will be useful
+ * when the driver is unloaded after establishing sub-channels. In this case,
+ * when the driver is re-loaded, the driver would have to check if the
+ * subchannels have already been established before attempting to request
+ * the creation of sub-channels.
+ * This function returns TRUE to indicate that subchannels have already been
+ * created.
+ * This function should be invoked after setting the callback function for
+ * sub-channel creation.
+ */
+bool vmbus_are_subchannels_present(struct vmbus_channel *primary);
+
 /* The format must be the same as struct vmdata_gpa_direct */
 struct vmbus_channel_packet_page_buffer {
 	u16 type;
@@ -1327,7 +1388,6 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0x8e, 0x77, 0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8 \
 		}
 
-
 /*
  * Common header for Hyper-V ICs
  */

commit 68a2d20b79b105f02dcbc52c211d7e62f98996b7
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Mon Apr 29 15:05:42 2013 -0700

    drivers/video: add Hyper-V Synthetic Video Frame Buffer Driver
    
    This is the driver for the Hyper-V Synthetic Video, which supports
    screen resolution up to Full HD 1920x1080 on Windows Server 2012 host,
    and 1600x1200 on Windows Server 2008 R2 or earlier.  It also solves the
    double mouse cursor issue of the emulated video mode.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
    Cc: Olaf Hering <olaf@aepfle.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 95d0850584da..c2559847d7ee 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1317,6 +1317,17 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0x29, 0x2e, 0xfa, 0x35, 0x23, 0xea, 0x36, 0x42, \
 			0x96, 0xae, 0x3a, 0x6e, 0xba, 0xcb, 0xa4,  0x40 \
 		}
+/*
+ * Synthetic Video GUID
+ * {DA0A7802-E377-4aac-8E77-0558EB1073F8}
+ */
+#define HV_SYNTHVID_GUID \
+	.guid = { \
+			0x02, 0x78, 0x0a, 0xda, 0x77, 0xe3, 0xac, 0x4a, \
+			0x8e, 0x77, 0x05, 0x58, 0xeb, 0x10, 0x73, 0xf8 \
+		}
+
+
 /*
  * Common header for Hyper-V ICs
  */

commit 96dd86fa588169b745a71aedf2070e80f4943623
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Mar 15 12:30:06 2013 -0700

    Drivers: hv: Add a new driver to support host initiated backup
    
    This driver supports host initiated backup of the guest. On Windows guests,
    the host can generate application consistent backups using the Windows VSS
    framework. On Linux, we ensure that the backup will be file system consistent.
    This driver allows the host to initiate a  "Freeze" operation on all the mounted
    file systems in the guest. Once the mounted file systems in the guest are frozen,
    the host snapshots the guest's file systems. Once this is done, the guest's file
    systems are "thawed".
    
    This driver has a user-level component (daemon) that invokes the appropriate
    operation on all the mounted file systems in response to the requests from
    the host. The duration for which the guest is frozen is very short - a few seconds.
    During this interval, the diff disk is comitted.
    
    In this version of the patch I have addressed the feedback from Olaf Herring.
    Also, some of the connector related issues have been fixed.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Evgeniy Polyakov <zbr@ioremap.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index df77ba9a8166..95d0850584da 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -27,6 +27,63 @@
 
 #include <linux/types.h>
 
+
+/*
+ * Implementation of host controlled snapshot of the guest.
+ */
+
+#define VSS_OP_REGISTER 128
+
+enum hv_vss_op {
+	VSS_OP_CREATE = 0,
+	VSS_OP_DELETE,
+	VSS_OP_HOT_BACKUP,
+	VSS_OP_GET_DM_INFO,
+	VSS_OP_BU_COMPLETE,
+	/*
+	 * Following operations are only supported with IC version >= 5.0
+	 */
+	VSS_OP_FREEZE, /* Freeze the file systems in the VM */
+	VSS_OP_THAW, /* Unfreeze the file systems */
+	VSS_OP_AUTO_RECOVER,
+	VSS_OP_COUNT /* Number of operations, must be last */
+};
+
+
+/*
+ * Header for all VSS messages.
+ */
+struct hv_vss_hdr {
+	__u8 operation;
+	__u8 reserved[7];
+} __attribute__((packed));
+
+
+/*
+ * Flag values for the hv_vss_check_feature. Linux supports only
+ * one value.
+ */
+#define VSS_HBU_NO_AUTO_RECOVERY	0x00000005
+
+struct hv_vss_check_feature {
+	__u32 flags;
+} __attribute__((packed));
+
+struct hv_vss_check_dm_info {
+	__u32 flags;
+} __attribute__((packed));
+
+struct hv_vss_msg {
+	union {
+		struct hv_vss_hdr vss_hdr;
+		int error;
+	};
+	union {
+		struct hv_vss_check_feature vss_cf;
+		struct hv_vss_check_dm_info dm_info;
+	};
+} __attribute__((packed));
+
 /*
  * An implementation of HyperV key value pair (KVP) functionality for Linux.
  *
@@ -1252,6 +1309,14 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 			0xb9, 0x8b, 0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a \
 		}
 
+/*
+ * VSS (Backup/Restore) GUID
+ */
+#define HV_VSS_GUID \
+	.guid = { \
+			0x29, 0x2e, 0xfa, 0x35, 0x23, 0xea, 0x36, 0x42, \
+			0x96, 0xae, 0x3a, 0x6e, 0xba, 0xcb, 0xa4,  0x40 \
+		}
 /*
  * Common header for Hyper-V ICs
  */
@@ -1356,6 +1421,10 @@ int hv_kvp_init(struct hv_util_service *);
 void hv_kvp_deinit(void);
 void hv_kvp_onchannelcallback(void *);
 
+int hv_vss_init(struct hv_util_service *);
+void hv_vss_deinit(void);
+void hv_vss_onchannelcallback(void *);
+
 /*
  * Negotiated version with the Host.
  */

commit 7fb96565e3e18ad41857ca6ffdaa9a26ae92df5a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Jan 23 17:42:40 2013 -0800

    Drivers: hv: vmbus: Consolidate all offer GUID definitions in hyperv.h
    
    Consolidate all GUID definitions in hyperv.h and use these definitions in implementing
    channel bindings (as far as interrupt delivery goes).
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5095b066df94..df77ba9a8166 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1158,6 +1158,100 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 	.guid = { g0, g1, g2, g3, g4, g5, g6, g7,	\
 		  g8, g9, ga, gb, gc, gd, ge, gf },
 
+/*
+ * GUID definitions of various offer types - services offered to the guest.
+ */
+
+/*
+ * Network GUID
+ * {f8615163-df3e-46c5-913f-f2d2f965ed0e}
+ */
+#define HV_NIC_GUID \
+	.guid = { \
+			0x63, 0x51, 0x61, 0xf8, 0x3e, 0xdf, 0xc5, 0x46, \
+			0x91, 0x3f, 0xf2, 0xd2, 0xf9, 0x65, 0xed, 0x0e \
+		}
+
+/*
+ * IDE GUID
+ * {32412632-86cb-44a2-9b5c-50d1417354f5}
+ */
+#define HV_IDE_GUID \
+	.guid = { \
+			0x32, 0x26, 0x41, 0x32, 0xcb, 0x86, 0xa2, 0x44, \
+			0x9b, 0x5c, 0x50, 0xd1, 0x41, 0x73, 0x54, 0xf5 \
+		}
+
+/*
+ * SCSI GUID
+ * {ba6163d9-04a1-4d29-b605-72e2ffb1dc7f}
+ */
+#define HV_SCSI_GUID \
+	.guid = { \
+			0xd9, 0x63, 0x61, 0xba, 0xa1, 0x04, 0x29, 0x4d, \
+			0xb6, 0x05, 0x72, 0xe2, 0xff, 0xb1, 0xdc, 0x7f \
+		}
+
+/*
+ * Shutdown GUID
+ * {0e0b6031-5213-4934-818b-38d90ced39db}
+ */
+#define HV_SHUTDOWN_GUID \
+	.guid = { \
+			0x31, 0x60, 0x0b, 0x0e, 0x13, 0x52, 0x34, 0x49, \
+			0x81, 0x8b, 0x38, 0xd9, 0x0c, 0xed, 0x39, 0xdb \
+		}
+
+/*
+ * Time Synch GUID
+ * {9527E630-D0AE-497b-ADCE-E80AB0175CAF}
+ */
+#define HV_TS_GUID \
+	.guid = { \
+			0x30, 0xe6, 0x27, 0x95, 0xae, 0xd0, 0x7b, 0x49, \
+			0xad, 0xce, 0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf \
+		}
+
+/*
+ * Heartbeat GUID
+ * {57164f39-9115-4e78-ab55-382f3bd5422d}
+ */
+#define HV_HEART_BEAT_GUID \
+	.guid = { \
+			0x39, 0x4f, 0x16, 0x57, 0x15, 0x91, 0x78, 0x4e, \
+			0xab, 0x55, 0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d \
+		}
+
+/*
+ * KVP GUID
+ * {a9a0f4e7-5a45-4d96-b827-8a841e8c03e6}
+ */
+#define HV_KVP_GUID \
+	.guid = { \
+			0xe7, 0xf4, 0xa0, 0xa9, 0x45, 0x5a, 0x96, 0x4d, \
+			0xb8, 0x27, 0x8a, 0x84, 0x1e, 0x8c, 0x3,  0xe6 \
+		}
+
+/*
+ * Dynamic memory GUID
+ * {525074dc-8985-46e2-8057-a307dc18a502}
+ */
+#define HV_DM_GUID \
+	.guid = { \
+			0xdc, 0x74, 0x50, 0X52, 0x85, 0x89, 0xe2, 0x46, \
+			0x80, 0x57, 0xa3, 0x07, 0xdc, 0x18, 0xa5, 0x02 \
+		}
+
+/*
+ * Mouse GUID
+ * {cfa8b69e-5b4a-4cc0-b98b-8ba1a1f3f95a}
+ */
+#define HV_MOUSE_GUID \
+	.guid = { \
+			0x9e, 0xb6, 0xa8, 0xcf, 0x4a, 0x5b, 0xc0, 0x4c, \
+			0xb9, 0x8b, 0x8b, 0xa1, 0xa1, 0xf3, 0xf9, 0x5a \
+		}
+
 /*
  * Common header for Hyper-V ICs
  */

commit 2a5c43a821b3b26e6af1cdb987b4daeba6f13a6f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:56 2012 -0800

    Drivers: hv: Enable protocol negotiation with win8 hosts
    
    Now that we have implemented all of the Win8 (WS2012) functionality, negotiate
    Win8 protocol with the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 8c3cb1fc34d4..5095b066df94 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -434,6 +434,7 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 
 #define VERSION_INVAL -1
 
+#define VERSION_CURRENT VERSION_WIN8
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)

commit abbf3b2aa090b4a6bf22c935924b6467990266da
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:48 2012 -0800

    Drivers: hv: Add state to manage incoming channel interrupt load
    
    Add state to bind a channel to a specific VCPU. This will help us better
    distribute incoming interrupt load.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index c6e2c44a1be9..8c3cb1fc34d4 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -732,8 +732,15 @@ struct vmbus_channel_open_channel {
 	/* GPADL for the channel's ring buffer. */
 	u32 ringbuffer_gpadlhandle;
 
-	/* GPADL for the channel's server context save area. */
-	u32 server_contextarea_gpadlhandle;
+	/*
+	 * Starting with win8, this field will be used to specify
+	 * the target virtual processor on which to deliver the interrupt for
+	 * the host to guest communication.
+	 * Prior to win8, incoming channel interrupts would only
+	 * be delivered on cpu 0. Setting this value to 0 would
+	 * preserve the earlier behavior.
+	 */
+	u32 target_vp;
 
 	/*
 	* The upstream ring buffer begins at offset zero in the memory
@@ -971,6 +978,16 @@ struct vmbus_channel {
 	bool is_dedicated_interrupt;
 	struct hv_input_signal_event_buffer sig_buf;
 	struct hv_input_signal_event *sig_event;
+
+	/*
+	 * Starting with win8, this field will be used to specify
+	 * the target virtual processor on which to deliver the interrupt for
+	 * the host to guest communication.
+	 * Prior to win8, incoming channel interrupts would only
+	 * be delivered on cpu 0. Setting this value to 0 would
+	 * preserve the earlier behavior.
+	 */
+	u32 target_vp;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)

commit b3bf60c7b4665d40b8eae2217b54c4745f49f470
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:45 2012 -0800

    Drivers: hv: Manage signaling state on a per-connection basis
    
    The current code has a global handle for supporting signaling of the host
    from guest. Make this a per-channel attribute as on some versions of the
    host we can signal on per-channel handle.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e72502689cdc..c6e2c44a1be9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -897,6 +897,27 @@ struct vmbus_close_msg {
 	struct vmbus_channel_close_channel msg;
 };
 
+/* Define connection identifier type. */
+union hv_connection_id {
+	u32 asu32;
+	struct {
+		u32 id:24;
+		u32 reserved:8;
+	} u;
+};
+
+/* Definition of the hv_signal_event hypercall input structure. */
+struct hv_input_signal_event {
+	union hv_connection_id connectionid;
+	u16 flag_number;
+	u16 rsvdz;
+};
+
+struct hv_input_signal_event_buffer {
+	u64 align8;
+	struct hv_input_signal_event event;
+};
+
 struct vmbus_channel {
 	struct list_head listentry;
 
@@ -946,6 +967,10 @@ struct vmbus_channel {
 	 */
 
 	bool batched_reading;
+
+	bool is_dedicated_interrupt;
+	struct hv_input_signal_event_buffer sig_buf;
+	struct hv_input_signal_event *sig_event;
 };
 
 static inline void set_channel_read_state(struct vmbus_channel *c, bool state)

commit eafa7072e7cd806dff42b705284ca26189e527a4
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:44 2012 -0800

    Drivers: hv: Move vmbus version definitions to hyperv.h
    
    To support version specific optimization in various vmbus drivers,
    move the vmbus definitions to the public header file.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 134a2022a7a3..e72502689cdc 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -419,6 +419,21 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
  */
 #define HV_DRV_VERSION           "3.1"
 
+/*
+ * VMBUS version is 32 bit entity broken up into
+ * two 16 bit quantities: major_number. minor_number.
+ *
+ * 0 . 13 (Windows Server 2008)
+ * 1 . 1  (Windows 7)
+ * 2 . 4  (Windows 8)
+ */
+
+#define VERSION_WS2008  ((0 << 16) | (13))
+#define VERSION_WIN7    ((1 << 16) | (1))
+#define VERSION_WIN8    ((2 << 16) | (4))
+
+#define VERSION_INVAL -1
+
 
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)

commit 37f7278b81a9ab9b76cf4d716ba420444ca4a616
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:41 2012 -0800

    Drivers: hv: Save and export negotiated vmbus version
    
    Export the negotiated vmbus version as this may be useful for
    individual drivers.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index bee559ada3bb..134a2022a7a3 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1204,5 +1204,11 @@ int hv_kvp_init(struct hv_util_service *);
 void hv_kvp_deinit(void);
 void hv_kvp_onchannelcallback(void *);
 
+/*
+ * Negotiated version with the Host.
+ */
+
+extern __u32 vmbus_proto_version;
+
 #endif /* __KERNEL__ */
 #endif /* _HYPERV_H */

commit 29423b7e51a8ea4d687cf98c3a50f33c554be194
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:40 2012 -0800

    Drivers: hv: Extend/modify vmbus_channel_offer_channel for win7 and beyond
    
    The "offfer" message sent by the host has been extended in win7 (ws2008 R2).
    Add/modify state to reflect this extension. All these changes are backward
    compatible.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2b5480126394..bee559ada3bb 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -440,9 +440,13 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 struct vmbus_channel_offer {
 	uuid_le if_type;
 	uuid_le if_instance;
-	u64 int_latency; /* in 100ns units */
-	u32 if_revision;
-	u32 server_ctx_size;	/* in bytes */
+
+	/*
+	 * These two fields are not currently used.
+	 */
+	u64 reserved1;
+	u64 reserved2;
+
 	u16 chn_flags;
 	u16 mmio_megabytes;		/* in bytes * 1024 * 1024 */
 
@@ -464,7 +468,11 @@ struct vmbus_channel_offer {
 			unsigned char user_def[MAX_PIPE_USER_DEFINED_BYTES];
 		} pipe;
 	} u;
-	u32 padding;
+	/*
+	 * The sub_channel_index is defined in win8.
+	 */
+	u16 sub_channel_index;
+	u16 reserved3;
 } __packed;
 
 /* Server Flags */
@@ -660,7 +668,25 @@ struct vmbus_channel_offer_channel {
 	struct vmbus_channel_offer offer;
 	u32 child_relid;
 	u8 monitorid;
-	u8 monitor_allocated;
+	/*
+	 * win7 and beyond splits this field into a bit field.
+	 */
+	u8 monitor_allocated:1;
+	u8 reserved:7;
+	/*
+	 * These are new fields added in win7 and later.
+	 * Do not access these fields without checking the
+	 * negotiated protocol.
+	 *
+	 * If "is_dedicated_interrupt" is set, we must not set the
+	 * associated bit in the channel bitmap while sending the
+	 * interrupt to the host.
+	 *
+	 * connection_id is to be used in signaling the host.
+	 */
+	u16 is_dedicated_interrupt:1;
+	u16 reserved1:15;
+	u32 connection_id;
 } __packed;
 
 /* Rescind Offer parameters */

commit 2416603ef1e12955850ade0d0cdecbef1fc59fa3
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:39 2012 -0800

    Drivers: hv: Update the ring buffer structure to match win8 functionality
    
    Update the ringbuffer structure to support win8 functionality.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b097bf9d9328..2b5480126394 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -325,14 +325,28 @@ struct hv_ring_buffer {
 
 	u32 interrupt_mask;
 
-	/* Pad it to PAGE_SIZE so that data starts on page boundary */
-	u8	reserved[4084];
-
-	/* NOTE:
-	 * The interrupt_mask field is used only for channels but since our
-	 * vmbus connection also uses this data structure and its data starts
-	 * here, we commented out this field.
+	/*
+	 * Win8 uses some of the reserved bits to implement
+	 * interrupt driven flow management. On the send side
+	 * we can request that the receiver interrupt the sender
+	 * when the ring transitions from being full to being able
+	 * to handle a message of size "pending_send_sz".
+	 *
+	 * Add necessary state for this enhancement.
 	 */
+	u32 pending_send_sz;
+
+	u32 reserved1[12];
+
+	union {
+		struct {
+			u32 feat_pending_send_sz:1;
+		};
+		u32 value;
+	} feature_bits;
+
+	/* Pad it to PAGE_SIZE so that data starts on page boundary */
+	u8	reserved2[4028];
 
 	/*
 	 * Ring data starts here + RingDataStartOffset

commit 610071c38463998d5a66388ff9956aaeb24b49a8
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:38 2012 -0800

    Drivers: hv: Support handling multiple VMBUS versions
    
    The current code hard coded the vmbus version independent of the host
    it was running on. Add code to dynamically negotiate the most appropriate
    version.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 1ffe84de6c55..b097bf9d9328 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -406,12 +406,6 @@ hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
 #define HV_DRV_VERSION           "3.1"
 
 
-/*
- * A revision number of vmbus that is used for ensuring both ends on a
- * partition are using compatible versions.
- */
-#define VMBUS_REVISION_NUMBER		13
-
 /* Make maximum size of pipe payload of 16K */
 #define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)
 

commit 132368bd0b286457f83f56d0bbdecd85999562dc
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:33 2012 -0800

    Drivers: hv: Add state to manage batched reading
    
    For the "read" side signaling optimization, the reader has to completely
    drain the queue before exiting. Add state to manage this "batched"
    reading.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e73b852156b1..1ffe84de6c55 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -882,8 +882,28 @@ struct vmbus_channel {
 
 	void (*onchannel_callback)(void *context);
 	void *channel_callback_context;
+
+	/*
+	 * A channel can be marked for efficient (batched)
+	 * reading:
+	 * If batched_reading is set to "true", we read until the
+	 * channel is empty and hold off interrupts from the host
+	 * during the entire read process.
+	 * If batched_reading is set to "false", the client is not
+	 * going to perform batched reading.
+	 *
+	 * By default we will enable batched reading; specific
+	 * drivers that don't want this behavior can turn it off.
+	 */
+
+	bool batched_reading;
 };
 
+static inline void set_channel_read_state(struct vmbus_channel *c, bool state)
+{
+	c->batched_reading = state;
+}
+
 void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);

commit 32061b4d3830e61975ede409df389804507fd220
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Sep 5 13:50:13 2012 -0700

    Tools: hv: Implement the KVP verb - KVP_OP_SET_IP_INFO
    
    Implement the KVP verb - KVP_OP_SET_IP_INFO. This operation configures the
    specified interface based on the given configuration. Since configuring
    an interface is very distro specific, we invoke an external (Distro specific)
    script to configure the interface.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7585d5533e43..e73b852156b1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -191,6 +191,8 @@ enum hv_kvp_exchg_pool {
 #define HV_ERROR_NOT_SUPPORTED		0x80070032
 #define HV_ERROR_MACHINE_LOCKED		0x800704F7
 #define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
+#define HV_INVALIDARG			0x80070057
+#define HV_GUID_NOTFOUND		0x80041002
 
 #define ADDR_FAMILY_NONE	0x00
 #define ADDR_FAMILY_IPV4	0x01

commit 1508d8111f0e965ebe06c32dc4d176750eb53c3a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Aug 16 08:23:20 2012 -0700

    Drivers: hv: Explicitly size elements of protocol structures
    
    Use explicitly sized types in data structures defining the host/guest
    protocol.
    
    Reported-by: Juan Sanchez-Agrelo <jagrelo@cisco.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b587c448e8ab..7585d5533e43 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -487,7 +487,7 @@ struct vmtransfer_page_range {
 struct vmtransfer_page_packet_header {
 	struct vmpacket_descriptor d;
 	u16 xfer_pageset_id;
-	bool sender_owns_set;
+	u8  sender_owns_set;
 	u8 reserved;
 	u32 range_cnt;
 	struct vmtransfer_page_range ranges[1];
@@ -641,7 +641,7 @@ struct vmbus_channel_query_vmbus_version {
 /* VMBus Version Supported parameters */
 struct vmbus_channel_version_supported {
 	struct vmbus_channel_message_header header;
-	bool version_supported;
+	u8 version_supported;
 } __packed;
 
 /* Offer Channel parameters */
@@ -650,7 +650,7 @@ struct vmbus_channel_offer_channel {
 	struct vmbus_channel_offer offer;
 	u32 child_relid;
 	u8 monitorid;
-	bool monitor_allocated;
+	u8 monitor_allocated;
 } __packed;
 
 /* Rescind Offer parameters */
@@ -786,7 +786,7 @@ struct vmbus_channel_initiate_contact {
 
 struct vmbus_channel_version_response {
 	struct vmbus_channel_message_header header;
-	bool version_supported;
+	u8 version_supported;
 } __packed;
 
 enum vmbus_channel_state {

commit b47a81dcc5a806efb6d970608299129771588289
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Aug 13 10:06:52 2012 -0700

    Drivers: hv: kvp: Cleanup error handling in KVP
    
    In preparation to implementing IP injection, cleanup the way we propagate
    and handle errors both in the driver as well as in the user level daemon.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: Olaf Hering <olaf@aepfle.de>
    Reviewed-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 11afc4e0849a..b587c448e8ab 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -181,6 +181,17 @@ enum hv_kvp_exchg_pool {
 	KVP_POOL_COUNT /* Number of pools, must be last. */
 };
 
+/*
+ * Some Hyper-V status codes.
+ */
+
+#define HV_S_OK				0x00000000
+#define HV_E_FAIL			0x80004005
+#define HV_S_CONT			0x80070103
+#define HV_ERROR_NOT_SUPPORTED		0x80070032
+#define HV_ERROR_MACHINE_LOCKED		0x800704F7
+#define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
+
 #define ADDR_FAMILY_NONE	0x00
 #define ADDR_FAMILY_IPV4	0x01
 #define ADDR_FAMILY_IPV6	0x02
@@ -1048,12 +1059,6 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 #define ICMSGHDRFLAG_REQUEST		2
 #define ICMSGHDRFLAG_RESPONSE		4
 
-#define HV_S_OK				0x00000000
-#define HV_E_FAIL			0x80004005
-#define HV_S_CONT			0x80070103
-#define HV_ERROR_NOT_SUPPORTED		0x80070032
-#define HV_ERROR_MACHINE_LOCKED		0x800704F7
-#define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
 
 /*
  * While we want to handle util services as regular devices,

commit 9b5957803cb444a99275355eb2309b6fecc63c5f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Aug 13 10:06:51 2012 -0700

    Drivers: hv: Add KVP definitions for IP address injection
    
    Add the necessary definitions for supporting the IP injection functionality.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: Olaf Hering <olaf@aepfle.de>
    Reviewed-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 68ed7f7e1fc9..11afc4e0849a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -122,12 +122,53 @@
 #define REG_U32 4
 #define REG_U64 8
 
+/*
+ * As we look at expanding the KVP functionality to include
+ * IP injection functionality, we need to maintain binary
+ * compatibility with older daemons.
+ *
+ * The KVP opcodes are defined by the host and it was unfortunate
+ * that I chose to treat the registration operation as part of the
+ * KVP operations defined by the host.
+ * Here is the level of compatibility
+ * (between the user level daemon and the kernel KVP driver) that we
+ * will implement:
+ *
+ * An older daemon will always be supported on a newer driver.
+ * A given user level daemon will require a minimal version of the
+ * kernel driver.
+ * If we cannot handle the version differences, we will fail gracefully
+ * (this can happen when we have a user level daemon that is more
+ * advanced than the KVP driver.
+ *
+ * We will use values used in this handshake for determining if we have
+ * workable user level daemon and the kernel driver. We begin by taking the
+ * registration opcode out of the KVP opcode namespace. We will however,
+ * maintain compatibility with the existing user-level daemon code.
+ */
+
+/*
+ * Daemon code not supporting IP injection (legacy daemon).
+ */
+
+#define KVP_OP_REGISTER	4
+
+/*
+ * Daemon code supporting IP injection.
+ * The KVP opcode field is used to communicate the
+ * registration information; so define a namespace that
+ * will be distinct from the host defined KVP opcode.
+ */
+
+#define KVP_OP_REGISTER1 100
+
 enum hv_kvp_exchg_op {
 	KVP_OP_GET = 0,
 	KVP_OP_SET,
 	KVP_OP_DELETE,
 	KVP_OP_ENUMERATE,
-	KVP_OP_REGISTER,
+	KVP_OP_GET_IP_INFO,
+	KVP_OP_SET_IP_INFO,
 	KVP_OP_COUNT /* Number of operations, must be last. */
 };
 
@@ -140,6 +181,26 @@ enum hv_kvp_exchg_pool {
 	KVP_POOL_COUNT /* Number of pools, must be last. */
 };
 
+#define ADDR_FAMILY_NONE	0x00
+#define ADDR_FAMILY_IPV4	0x01
+#define ADDR_FAMILY_IPV6	0x02
+
+#define MAX_ADAPTER_ID_SIZE	128
+#define MAX_IP_ADDR_SIZE	1024
+#define MAX_GATEWAY_SIZE	512
+
+
+struct hv_kvp_ipaddr_value {
+	__u16	adapter_id[MAX_ADAPTER_ID_SIZE];
+	__u8	addr_family;
+	__u8	dhcp_enabled;
+	__u16	ip_addr[MAX_IP_ADDR_SIZE];
+	__u16	sub_net[MAX_IP_ADDR_SIZE];
+	__u16	gate_way[MAX_GATEWAY_SIZE];
+	__u16	dns_addr[MAX_IP_ADDR_SIZE];
+} __attribute__((packed));
+
+
 struct hv_kvp_hdr {
 	__u8 operation;
 	__u8 pool;
@@ -181,16 +242,26 @@ struct hv_kvp_register {
 };
 
 struct hv_kvp_msg {
-	struct hv_kvp_hdr	kvp_hdr;
+	union {
+		struct hv_kvp_hdr	kvp_hdr;
+		int error;
+	};
 	union {
 		struct hv_kvp_msg_get		kvp_get;
 		struct hv_kvp_msg_set		kvp_set;
 		struct hv_kvp_msg_delete	kvp_delete;
 		struct hv_kvp_msg_enumerate	kvp_enum_data;
+		struct hv_kvp_ipaddr_value      kvp_ip_val;
 		struct hv_kvp_register		kvp_register;
 	} body;
 } __attribute__((packed));
 
+struct hv_kvp_ip_msg {
+	__u8 operation;
+	__u8 pool;
+	struct hv_kvp_ipaddr_value      kvp_ip_val;
+} __attribute__((packed));
+
 #ifdef __KERNEL__
 #include <linux/scatterlist.h>
 #include <linux/list.h>
@@ -982,6 +1053,7 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 #define HV_S_CONT			0x80070103
 #define HV_ERROR_NOT_SUPPORTED		0x80070032
 #define HV_ERROR_MACHINE_LOCKED		0x800704F7
+#define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
 
 /*
  * While we want to handle util services as regular devices,

commit 5d4e2d08e7fdf7339f84a1c670d296a77e02f881
Merge: fb2123fad3b4 94ca629e40eb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 22 16:02:13 2012 -0700

    Merge tag 'driver-core-3.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg Kroah-Hartman:
     "Here's the driver core, and other driver subsystems, pull request for
      the 3.5-rc1 merge window.
    
      Outside of a few minor driver core changes, we ended up with the
      following different subsystem and core changes as well, due to
      interdependancies on the driver core:
       - hyperv driver updates
       - drivers/memory being created and some drivers moved into it
       - extcon driver subsystem created out of the old Android staging
         switch driver code
       - dynamic debug updates
       - printk rework, and /dev/kmsg changes
    
      All of this has been tested in the linux-next releases for a few weeks
      with no reported problems.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fix up conflicts in drivers/extcon/extcon-max8997.c where git noticed
    that a patch to the deleted drivers/misc/max8997-muic.c driver needs to
    be applied to this one.
    
    * tag 'driver-core-3.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (90 commits)
      uio_pdrv_genirq: get irq through platform resource if not set otherwise
      memory: tegra{20,30}-mc: Remove empty *_remove()
      printk() - isolate KERN_CONT users from ordinary complete lines
      sysfs: get rid of some lockdep false positives
      Drivers: hv: util: Properly handle version negotiations.
      Drivers: hv: Get rid of an unnecessary check in vmbus_prep_negotiate_resp()
      memory: tegra{20,30}-mc: Use dev_err_ratelimited()
      driver core: Add dev_*_ratelimited() family
      Driver Core: don't oops with unregistered driver in driver_find_device()
      printk() - restore prefix/timestamp printing for multi-newline strings
      printk: add stub for prepend_timestamp()
      ARM: tegra30: Make MC optional in Kconfig
      ARM: tegra20: Make MC optional in Kconfig
      ARM: tegra30: MC: Remove unnecessary BUG*()
      ARM: tegra20: MC: Remove unnecessary BUG*()
      printk: correctly align __log_buf
      ARM: tegra30: Add Tegra Memory Controller(MC) driver
      ARM: tegra20: Add Tegra Memory Controller(MC) driver
      printk() - restore timestamp printing at console output
      printk() - do not merge continuation lines of different threads
      ...

commit c836d0ab70acf7b7bd2b698278e8abae9e6d9978
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat May 12 13:44:58 2012 -0700

    Drivers: hv: util: Properly handle version negotiations.
    
    The current version negotiation code is not "future proof". Fix this
    by allowing each service the flexibility to either specify the highest
    version it can support or it can support the highest version number
    the host is offering.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5852545e6bba..22172bd43745 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1035,8 +1035,10 @@ struct hyperv_service_callback {
 	void (*callback) (void *context);
 };
 
+#define MAX_SRV_VER	0x7ffffff
 extern void vmbus_prep_negotiate_resp(struct icmsg_hdr *,
-				      struct icmsg_negotiate *, u8 *);
+					struct icmsg_negotiate *, u8 *, int,
+					int);
 
 int hv_kvp_init(struct hv_util_service *);
 void hv_kvp_deinit(void);

commit 33be96e47cc27f2f1a753a0707b02a73df8c8d46
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Tue Mar 27 13:20:45 2012 +0000

    net/hyperv: Add flow control based on hi/low watermark
    
    In the existing code, we only stop queue when the ringbuffer is full,
    so the current packet has to be dropped or retried from upper layer.
    
    This patch stops the tx queue when available ringbuffer is below
    the low watermark. So the ringbuffer still has small amount of space
    available for the current packet. This will reduce the overhead of
    retries on sending.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 5852545e6bba..6af8738ae7e9 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -274,6 +274,33 @@ struct hv_ring_buffer_debug_info {
 	u32 bytes_avail_towrite;
 };
 
+
+/*
+ *
+ * hv_get_ringbuffer_availbytes()
+ *
+ * Get number of bytes available to read and to write to
+ * for the specified ring buffer
+ */
+static inline void
+hv_get_ringbuffer_availbytes(struct hv_ring_buffer_info *rbi,
+			  u32 *read, u32 *write)
+{
+	u32 read_loc, write_loc, dsize;
+
+	smp_read_barrier_depends();
+
+	/* Capture the read/write indices before they changed */
+	read_loc = rbi->ring_buffer->read_index;
+	write_loc = rbi->ring_buffer->write_index;
+	dsize = rbi->ring_datasize;
+
+	*write = write_loc >= read_loc ? dsize - (write_loc - read_loc) :
+		read_loc - write_loc;
+	*read = dsize - *write;
+}
+
+
 /*
  * We use the same version numbering for all Hyper-V modules.
  *

commit adc80ae60eae24a43a357bf5b30fb496f34aa605
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Mar 16 08:02:27 2012 -0700

    Tools: hv: Support enumeration from all the pools
    
    We have only supported enumeration only from the AUTO pool. Now support
    enumeration from all the available pools.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e88a979107b5..5852545e6bba 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -952,6 +952,7 @@ void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
 #define HV_S_OK				0x00000000
 #define HV_E_FAIL			0x80004005
+#define HV_S_CONT			0x80070103
 #define HV_ERROR_NOT_SUPPORTED		0x80070032
 #define HV_ERROR_MACHINE_LOCKED		0x800704F7
 

commit fa3d5b85c681518b6e4ec515814dcb2d5b702b89
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Mar 16 08:02:25 2012 -0700

    Drivers: hv: Support the newly introduced KVP messages in the driver
    
    Support the newly defined KVP message types. It turns out that the host
    pushes a set of standard key value pairs as soon as the guest opens the KVP channel.
    Since we cannot handle these tuples until the user level daemon loads up, defer
    reading the KVP channel until the user level daemon is launched.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a2d8c547f91b..e88a979107b5 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -119,6 +119,8 @@
  */
 
 #define REG_SZ 1
+#define REG_U32 4
+#define REG_U64 8
 
 enum hv_kvp_exchg_op {
 	KVP_OP_GET = 0,

commit e485ceac9ebd43901ef0ce13622385d509e072e7
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Mar 10 15:32:08 2012 -0800

    Drivers: hv: Add new message types to enhance KVP
    
    Add additional KVP (Key Value Pair) protocol  messages to
    enhance KVP functionality for Linux guests on Hyper-V. As part of this,
    patch define an explicit version negoitiation message.
    
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e57a6c6ee0e8..a2d8c547f91b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -149,7 +149,11 @@ struct hv_kvp_exchg_msg_value {
 	__u32 key_size;
 	__u32 value_size;
 	__u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
-	__u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+	union {
+		__u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+		__u32 value_u32;
+		__u64 value_u64;
+	};
 } __attribute__((packed));
 
 struct hv_kvp_msg_enumerate {
@@ -157,11 +161,31 @@ struct hv_kvp_msg_enumerate {
 	struct hv_kvp_exchg_msg_value data;
 } __attribute__((packed));
 
+struct hv_kvp_msg_get {
+	struct hv_kvp_exchg_msg_value data;
+};
+
+struct hv_kvp_msg_set {
+	struct hv_kvp_exchg_msg_value data;
+};
+
+struct hv_kvp_msg_delete {
+	__u32 key_size;
+	__u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+};
+
+struct hv_kvp_register {
+	__u8 version[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+};
+
 struct hv_kvp_msg {
 	struct hv_kvp_hdr	kvp_hdr;
 	union {
-		struct hv_kvp_msg_enumerate     kvp_enum_data;
-		char    kvp_version[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+		struct hv_kvp_msg_get		kvp_get;
+		struct hv_kvp_msg_set		kvp_set;
+		struct hv_kvp_msg_delete	kvp_delete;
+		struct hv_kvp_msg_enumerate	kvp_enum_data;
+		struct hv_kvp_register		kvp_register;
 	} body;
 } __attribute__((packed));
 

commit 263a5c8e16c34199ddf6de3f102e789ffa3ee26e
Merge: 54d20f006cef 192cfd58774b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Mar 9 12:35:53 2012 -0800

    Merge 3.3-rc6 into driver-core-next
    
    This was done to resolve a conflict in the drivers/base/cpu.c file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2640335438ca4d7b139e114dae5f0d80e740e106
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Feb 2 16:56:50 2012 -0800

    drivers: hv: kvp: Cleanup the kernel/user protocol
    
    Now, cleanup the user/kernel KVP protocol by using the same structure
    definition that is used for host/guest KVP protocol. This simplifies the code.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b822978ecbc8..75aee6720c1b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -113,30 +113,6 @@
  * (not supported), a NULL key string is returned.
  */
 
-/*
- *
- * The following definitions are shared with the user-mode component; do not
- * change any of this without making the corresponding changes in
- * the KVP user-mode component.
- */
-
-enum hv_ku_op {
-	KVP_REGISTER = 0, /* Register the user mode component */
-	KVP_KERNEL_GET, /* Kernel is requesting the value */
-	KVP_KERNEL_SET, /* Kernel is providing the value */
-	KVP_USER_GET,  /* User is requesting the value */
-	KVP_USER_SET  /* User is providing the value */
-};
-
-struct hv_ku_msg {
-	__u32 kvp_index; /* Key index */
-	__u8  kvp_key[HV_KVP_EXCHANGE_MAX_KEY_SIZE]; /* Key name */
-	__u8  kvp_value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE]; /* Key  value */
-};
-
-
-
-
 
 /*
  * Registry value types.
@@ -149,6 +125,7 @@ enum hv_kvp_exchg_op {
 	KVP_OP_SET,
 	KVP_OP_DELETE,
 	KVP_OP_ENUMERATE,
+	KVP_OP_REGISTER,
 	KVP_OP_COUNT /* Number of operations, must be last. */
 };
 
@@ -182,7 +159,10 @@ struct hv_kvp_msg_enumerate {
 
 struct hv_kvp_msg {
 	struct hv_kvp_hdr	kvp_hdr;
-	struct hv_kvp_msg_enumerate	kvp_data;
+	union {
+		struct hv_kvp_msg_enumerate     kvp_enum_data;
+		char    kvp_version[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+	} body;
 } __attribute__((packed));
 
 #ifdef __KERNEL__

commit 59a084a70afa0678bda2a23a7bc7cc59664945c7
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Feb 2 16:56:48 2012 -0800

    drivers: hv: Cleanup the kvp related state in hyperv.h
    
    Now cleanup the hyperv.h with regards to KVP definitions.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7332b3faecc8..b822978ecbc8 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -137,7 +137,6 @@ struct hv_ku_msg {
 
 
 
-#ifdef __KERNEL__
 
 /*
  * Registry value types.
@@ -163,28 +162,30 @@ enum hv_kvp_exchg_pool {
 };
 
 struct hv_kvp_hdr {
-	u8 operation;
-	u8 pool;
-};
+	__u8 operation;
+	__u8 pool;
+	__u16 pad;
+} __attribute__((packed));
 
 struct hv_kvp_exchg_msg_value {
-	u32 value_type;
-	u32 key_size;
-	u32 value_size;
-	u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
-	u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
-};
+	__u32 value_type;
+	__u32 key_size;
+	__u32 value_size;
+	__u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+	__u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+} __attribute__((packed));
 
 struct hv_kvp_msg_enumerate {
-	u32 index;
+	__u32 index;
 	struct hv_kvp_exchg_msg_value data;
-};
+} __attribute__((packed));
 
 struct hv_kvp_msg {
 	struct hv_kvp_hdr	kvp_hdr;
 	struct hv_kvp_msg_enumerate	kvp_data;
-};
+} __attribute__((packed));
 
+#ifdef __KERNEL__
 #include <linux/scatterlist.h>
 #include <linux/list.h>
 #include <linux/uuid.h>

commit 2939437ce8f2de07237eb2bcce29b6a699bfe799
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Jan 27 15:55:58 2012 -0800

    drivers: hv: kvp: Move the contents of hv_kvp.h to hyperv.h
    
    In preparation for consolidating all KVP related defines into a single header file
    that both the kernel and user level components can use, move the contents of
    hv_kvp.h into hyperv.h.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62b908e0e591..7332b3faecc8 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -25,6 +25,166 @@
 #ifndef _HYPERV_H
 #define _HYPERV_H
 
+#include <linux/types.h>
+
+/*
+ * An implementation of HyperV key value pair (KVP) functionality for Linux.
+ *
+ *
+ * Copyright (C) 2010, Novell, Inc.
+ * Author : K. Y. Srinivasan <ksrinivasan@novell.com>
+ *
+ */
+
+/*
+ * Maximum value size - used for both key names and value data, and includes
+ * any applicable NULL terminators.
+ *
+ * Note:  This limit is somewhat arbitrary, but falls easily within what is
+ * supported for all native guests (back to Win 2000) and what is reasonable
+ * for the IC KVP exchange functionality.  Note that Windows Me/98/95 are
+ * limited to 255 character key names.
+ *
+ * MSDN recommends not storing data values larger than 2048 bytes in the
+ * registry.
+ *
+ * Note:  This value is used in defining the KVP exchange message - this value
+ * cannot be modified without affecting the message size and compatibility.
+ */
+
+/*
+ * bytes, including any null terminators
+ */
+#define HV_KVP_EXCHANGE_MAX_VALUE_SIZE          (2048)
+
+
+/*
+ * Maximum key size - the registry limit for the length of an entry name
+ * is 256 characters, including the null terminator
+ */
+
+#define HV_KVP_EXCHANGE_MAX_KEY_SIZE            (512)
+
+/*
+ * In Linux, we implement the KVP functionality in two components:
+ * 1) The kernel component which is packaged as part of the hv_utils driver
+ * is responsible for communicating with the host and responsible for
+ * implementing the host/guest protocol. 2) A user level daemon that is
+ * responsible for data gathering.
+ *
+ * Host/Guest Protocol: The host iterates over an index and expects the guest
+ * to assign a key name to the index and also return the value corresponding to
+ * the key. The host will have atmost one KVP transaction outstanding at any
+ * given point in time. The host side iteration stops when the guest returns
+ * an error. Microsoft has specified the following mapping of key names to
+ * host specified index:
+ *
+ *	Index		Key Name
+ *	0		FullyQualifiedDomainName
+ *	1		IntegrationServicesVersion
+ *	2		NetworkAddressIPv4
+ *	3		NetworkAddressIPv6
+ *	4		OSBuildNumber
+ *	5		OSName
+ *	6		OSMajorVersion
+ *	7		OSMinorVersion
+ *	8		OSVersion
+ *	9		ProcessorArchitecture
+ *
+ * The Windows host expects the Key Name and Key Value to be encoded in utf16.
+ *
+ * Guest Kernel/KVP Daemon Protocol: As noted earlier, we implement all of the
+ * data gathering functionality in a user mode daemon. The user level daemon
+ * is also responsible for binding the key name to the index as well. The
+ * kernel and user-level daemon communicate using a connector channel.
+ *
+ * The user mode component first registers with the
+ * the kernel component. Subsequently, the kernel component requests, data
+ * for the specified keys. In response to this message the user mode component
+ * fills in the value corresponding to the specified key. We overload the
+ * sequence field in the cn_msg header to define our KVP message types.
+ *
+ *
+ * The kernel component simply acts as a conduit for communication between the
+ * Windows host and the user-level daemon. The kernel component passes up the
+ * index received from the Host to the user-level daemon. If the index is
+ * valid (supported), the corresponding key as well as its
+ * value (both are strings) is returned. If the index is invalid
+ * (not supported), a NULL key string is returned.
+ */
+
+/*
+ *
+ * The following definitions are shared with the user-mode component; do not
+ * change any of this without making the corresponding changes in
+ * the KVP user-mode component.
+ */
+
+enum hv_ku_op {
+	KVP_REGISTER = 0, /* Register the user mode component */
+	KVP_KERNEL_GET, /* Kernel is requesting the value */
+	KVP_KERNEL_SET, /* Kernel is providing the value */
+	KVP_USER_GET,  /* User is requesting the value */
+	KVP_USER_SET  /* User is providing the value */
+};
+
+struct hv_ku_msg {
+	__u32 kvp_index; /* Key index */
+	__u8  kvp_key[HV_KVP_EXCHANGE_MAX_KEY_SIZE]; /* Key name */
+	__u8  kvp_value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE]; /* Key  value */
+};
+
+
+
+
+#ifdef __KERNEL__
+
+/*
+ * Registry value types.
+ */
+
+#define REG_SZ 1
+
+enum hv_kvp_exchg_op {
+	KVP_OP_GET = 0,
+	KVP_OP_SET,
+	KVP_OP_DELETE,
+	KVP_OP_ENUMERATE,
+	KVP_OP_COUNT /* Number of operations, must be last. */
+};
+
+enum hv_kvp_exchg_pool {
+	KVP_POOL_EXTERNAL = 0,
+	KVP_POOL_GUEST,
+	KVP_POOL_AUTO,
+	KVP_POOL_AUTO_EXTERNAL,
+	KVP_POOL_AUTO_INTERNAL,
+	KVP_POOL_COUNT /* Number of pools, must be last. */
+};
+
+struct hv_kvp_hdr {
+	u8 operation;
+	u8 pool;
+};
+
+struct hv_kvp_exchg_msg_value {
+	u32 value_type;
+	u32 key_size;
+	u32 value_size;
+	u8 key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+	u8 value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+};
+
+struct hv_kvp_msg_enumerate {
+	u32 index;
+	struct hv_kvp_exchg_msg_value data;
+};
+
+struct hv_kvp_msg {
+	struct hv_kvp_hdr	kvp_hdr;
+	struct hv_kvp_msg_enumerate	kvp_data;
+};
+
 #include <linux/scatterlist.h>
 #include <linux/list.h>
 #include <linux/uuid.h>
@@ -870,4 +1030,9 @@ struct hyperv_service_callback {
 extern void vmbus_prep_negotiate_resp(struct icmsg_hdr *,
 				      struct icmsg_negotiate *, u8 *);
 
+int hv_kvp_init(struct hv_util_service *);
+void hv_kvp_deinit(void);
+void hv_kvp_onchannelcallback(void *);
+
+#endif /* __KERNEL__ */
 #endif /* _HYPERV_H */

commit c31c151b1c4a29da4dc92212aa8648fb4f8557b9
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Thu Feb 2 07:18:00 2012 +0000

    net/hyperv: Fix the page buffer when an RNDIS message goes beyond page boundary
    
    There is a possible data corruption if an RNDIS message goes beyond page
    boundary in the sending code path. This patch fixes the problem.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 62b908e0e591..0ae065a5fcb2 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,7 +35,7 @@
 #include <linux/mod_devicetable.h>
 
 
-#define MAX_PAGE_BUFFER_COUNT				18
+#define MAX_PAGE_BUFFER_COUNT				19
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
 
 #pragma pack(push, 1)

commit 4d447c9a6ebc0142d320f075c5bac6d202a79fd4
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Thu Dec 15 13:45:17 2011 -0800

    net/hyperv: Add support for jumbo frame up to 64KB
    
    Allow the user set the MTU up to 65536 for Linux guests running on
    Hyper-V 2008 R2 or later.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 12ec328481de..62b908e0e591 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,7 +35,7 @@
 #include <linux/mod_devicetable.h>
 
 
-#define MAX_PAGE_BUFFER_COUNT				16
+#define MAX_PAGE_BUFFER_COUNT				18
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
 
 #pragma pack(push, 1)

commit 15b80d641793968605254c2bbb2aa9a10accb415
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:43:14 2011 -0600

    hv: remove struct hv_device_info from hyperv.h
    
    This is only used/needed by the vmbus core code, so move it out of the
    hyperv.h file and into the .c file that uses it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 240e1141cbbd..12ec328481de 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -699,24 +699,6 @@ struct hv_dev_port_info {
 	u32 bytes_avail_towrite;
 };
 
-struct hv_device_info {
-	u32 chn_id;
-	u32 chn_state;
-	uuid_le chn_type;
-	uuid_le chn_instance;
-
-	u32 monitor_id;
-	u32 server_monitor_pending;
-	u32 server_monitor_latency;
-	u32 server_monitor_conn_id;
-	u32 client_monitor_pending;
-	u32 client_monitor_latency;
-	u32 client_monitor_conn_id;
-
-	struct hv_dev_port_info inbound;
-	struct hv_dev_port_info outbound;
-};
-
 /* Base driver object */
 struct hv_driver {
 	const char *name;

commit 9f3e28e375a8d509a27efe89f3c8ea2a15aeb524
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:40:01 2011 -0600

    hv: remove free_channel() from hyperv.h
    
    This function is only used in the file it is declared in
    (channel_mgmt.c) so make it static and remove it from the hyperv.h file.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index ae865a11ad46..240e1141cbbd 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -606,8 +606,6 @@ struct vmbus_channel {
 	void *channel_callback_context;
 };
 
-void free_channel(struct vmbus_channel *channel);
-
 void vmbus_onmessage(void *context);
 
 int vmbus_request_offers(void);

commit 2726f95e0b6c850b6162f287f2f83d9db37decd7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:37:27 2011 -0600

    hv: hyperv.h: remove unneeded forward declarations of structures
    
    This file was created by mushing different .h files together and it
    shows.  This change removes some unneeded forward declarations.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index f2bf0a51914b..ae865a11ad46 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -693,9 +693,6 @@ extern void vmbus_get_debug_info(struct vmbus_channel *channel,
 
 extern void vmbus_ontimer(unsigned long data);
 
-struct hv_driver;
-struct hv_device;
-
 struct hv_dev_port_info {
 	u32 int_mask;
 	u32 read_idx;

commit 7a4ba88cc11eb4ba72778f491d8241385cb0475d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:33:29 2011 -0600

    hv: hyperv.h: remove unused module macros
    
    I have no idea what these were ever for, but they aren't used, so delete
    them.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6d9a53fc8a37..f2bf0a51914b 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -693,29 +693,6 @@ extern void vmbus_get_debug_info(struct vmbus_channel *channel,
 
 extern void vmbus_ontimer(unsigned long data);
 
-
-#define VMBUS				0x0001
-#define STORVSC				0x0002
-#define NETVSC				0x0004
-#define INPUTVSC			0x0008
-#define BLKVSC				0x0010
-#define VMBUS_DRV			0x0100
-#define STORVSC_DRV			0x0200
-#define NETVSC_DRV			0x0400
-#define INPUTVSC_DRV		0x0800
-#define BLKVSC_DRV			0x1000
-
-#define ALL_MODULES			(VMBUS		|\
-							STORVSC		|\
-							NETVSC		|\
-							INPUTVSC	|\
-							BLKVSC		|\
-							VMBUS_DRV	|\
-							STORVSC_DRV	|\
-							NETVSC_DRV	|\
-							INPUTVSC_DRV|\
-							BLKVSC_DRV)
-
 struct hv_driver;
 struct hv_device;
 

commit 5557e8a60570d0c2f3a06d6e9e6a0f5074c313f2
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:30:22 2011 -0600

    hv: remove unused LOWORD and HIWORD macros from hyperv.h
    
    They aren't used anywhere anymore now that the debugging macros are
    gone, so remove it from hyperv.h as well.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 7211e2ce24f5..6d9a53fc8a37 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -694,10 +694,6 @@ extern void vmbus_get_debug_info(struct vmbus_channel *channel,
 extern void vmbus_ontimer(unsigned long data);
 
 
-#define LOWORD(dw) ((unsigned short)(dw))
-#define HIWORD(dw) ((unsigned short)(((unsigned int) (dw) >> 16) & 0xFFFF))
-
-
 #define VMBUS				0x0001
 #define STORVSC				0x0002
 #define NETVSC				0x0004

commit 815166b95df1acb4890e9dbdb26660e9c00a7505
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:27:48 2011 -0600

    Staging: hv: remove vmbus_loglevel as it is not used at all anymore
    
    As there is no user of this variable, it's time to delete it.  For
    dynamic debugging of the hyperv code, use the standard dynamic debug
    kernel interface.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 4fa32ec43aa4..7211e2ce24f5 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -720,11 +720,6 @@ extern void vmbus_ontimer(unsigned long data);
 							INPUTVSC_DRV|\
 							BLKVSC_DRV)
 
-/* Logging Level */
-#define INFO_LVL				6
-
-extern unsigned int vmbus_loglevel;
-
 struct hv_driver;
 struct hv_device;
 

commit 1a2643012fa2262e823b7f11d9732b7fea4c25ce
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:25:14 2011 -0600

    Staging: hv: remove last user of DPRINT() macro
    
    This also removed the unused function hv_dump_ring_info().
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 097d6dbe685a..4fa32ec43aa4 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -722,17 +722,9 @@ extern void vmbus_ontimer(unsigned long data);
 
 /* Logging Level */
 #define INFO_LVL				6
-#define DEBUG_RING_LVL				9
 
 extern unsigned int vmbus_loglevel;
 
-#define DPRINT(mod, lvl, fmt, args...) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) &&	\
-	    (lvl <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
-	} while (0)
-
-
 struct hv_driver;
 struct hv_device;
 

commit d181daa06dd72fa88652b1d8bf723570a9fc55ea
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 09:20:31 2011 -0600

    Staging: hv: storvsc: remove last usage of DPRINT_WARN
    
    Used the correct dev_warn() call instead.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 2229073874b0..097d6dbe685a 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -721,7 +721,6 @@ extern void vmbus_ontimer(unsigned long data);
 							BLKVSC_DRV)
 
 /* Logging Level */
-#define WARNING_LVL				4
 #define INFO_LVL				6
 #define DEBUG_RING_LVL				9
 
@@ -733,11 +732,6 @@ extern unsigned int vmbus_loglevel;
 		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
 	} while (0)
 
-#define DPRINT_WARN(mod, fmt, args...) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
-	    (WARNING_LVL <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_WARNING #mod": WARNING! " fmt "\n", ## args);\
-	} while (0)
 
 struct hv_driver;
 struct hv_device;

commit a832a1eba94096513bc42c96f33957cc46c5f2bf
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 08:47:32 2011 -0600

    hv: remove a bunch of unused debug macros from hyperv.h
    
    These aren't used by anyone anymore, so remove them before someone tries
    to use them again.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 98a57a51acfc..2229073874b0 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -721,11 +721,8 @@ extern void vmbus_ontimer(unsigned long data);
 							BLKVSC_DRV)
 
 /* Logging Level */
-#define ERROR_LVL				3
 #define WARNING_LVL				4
 #define INFO_LVL				6
-#define DEBUG_LVL				7
-#define DEBUG_LVL_ENTEREXIT			8
 #define DEBUG_RING_LVL				9
 
 extern unsigned int vmbus_loglevel;
@@ -736,33 +733,12 @@ extern unsigned int vmbus_loglevel;
 		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
 	} while (0)
 
-#define DPRINT_DBG(mod, fmt, args...) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
-	    (DEBUG_LVL <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
-	} while (0)
-
-#define DPRINT_INFO(mod, fmt, args...) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
-	    (INFO_LVL <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_INFO #mod": " fmt "\n", ## args);\
-	} while (0)
-
 #define DPRINT_WARN(mod, fmt, args...) do {\
 	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
 	    (WARNING_LVL <= LOWORD(vmbus_loglevel)))	\
 		printk(KERN_WARNING #mod": WARNING! " fmt "\n", ## args);\
 	} while (0)
 
-#define DPRINT_ERR(mod, fmt, args...) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
-	    (ERROR_LVL <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_ERR #mod": %s() ERROR!! " fmt "\n",	\
-		       __func__, ## args);\
-	} while (0)
-
-
-
 struct hv_driver;
 struct hv_device;
 

commit da0e96315ca703ab6540cc7665549622f71c155f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 08:42:28 2011 -0600

    hv: rename prep_negotiate_resp() to vmbus_prep_negotiate_resp()
    
    It's a global symbol, so properly prefix it and use the proper EXPORT
    value as well.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 4c8414a8b07f..98a57a51acfc 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -960,7 +960,7 @@ struct hyperv_service_callback {
 	void (*callback) (void *context);
 };
 
-extern void prep_negotiate_resp(struct icmsg_hdr *,
-				struct icmsg_negotiate *, u8 *);
+extern void vmbus_prep_negotiate_resp(struct icmsg_hdr *,
+				      struct icmsg_negotiate *, u8 *);
 
 #endif /* _HYPERV_H */

commit 407dd1644302ea78fa5d740e67a1c09677aa18a4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 08:36:44 2011 -0600

    Staging: hv: remove unneeded asm include file in hyperv.h
    
    No one outside of the hyperv core needs to include the asm/hyperv.h
    file, so don't put it in the "global" include/linux/hyperv.h file.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index edaa9e2f58ec..4c8414a8b07f 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -35,9 +35,6 @@
 #include <linux/mod_devicetable.h>
 
 
-#include <asm/hyperv.h>
-
-
 #define MAX_PAGE_BUFFER_COUNT				16
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
 

commit 46a971913611a23478283931460a95be962ce329
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 4 12:29:52 2011 -0700

    Staging: hv: move hyperv code out of staging directory
    
    After many years wandering the desert, it is finally time for the
    Microsoft HyperV code to move out of the staging directory.  Or at least
    the core hyperv bus code, and the utility driver, the rest still have
    some review to get through by the various subsystem maintainers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>

diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
new file mode 100644
index 000000000000..edaa9e2f58ec
--- /dev/null
+++ b/include/linux/hyperv.h
@@ -0,0 +1,969 @@
+/*
+ *
+ * Copyright (c) 2011, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *   K. Y. Srinivasan <kys@microsoft.com>
+ *
+ */
+
+#ifndef _HYPERV_H
+#define _HYPERV_H
+
+#include <linux/scatterlist.h>
+#include <linux/list.h>
+#include <linux/uuid.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/mod_devicetable.h>
+
+
+#include <asm/hyperv.h>
+
+
+#define MAX_PAGE_BUFFER_COUNT				16
+#define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
+
+#pragma pack(push, 1)
+
+/* Single-page buffer */
+struct hv_page_buffer {
+	u32 len;
+	u32 offset;
+	u64 pfn;
+};
+
+/* Multiple-page buffer */
+struct hv_multipage_buffer {
+	/* Length and Offset determines the # of pfns in the array */
+	u32 len;
+	u32 offset;
+	u64 pfn_array[MAX_MULTIPAGE_BUFFER_COUNT];
+};
+
+/* 0x18 includes the proprietary packet header */
+#define MAX_PAGE_BUFFER_PACKET		(0x18 +			\
+					(sizeof(struct hv_page_buffer) * \
+					 MAX_PAGE_BUFFER_COUNT))
+#define MAX_MULTIPAGE_BUFFER_PACKET	(0x18 +			\
+					 sizeof(struct hv_multipage_buffer))
+
+
+#pragma pack(pop)
+
+struct hv_ring_buffer {
+	/* Offset in bytes from the start of ring data below */
+	u32 write_index;
+
+	/* Offset in bytes from the start of ring data below */
+	u32 read_index;
+
+	u32 interrupt_mask;
+
+	/* Pad it to PAGE_SIZE so that data starts on page boundary */
+	u8	reserved[4084];
+
+	/* NOTE:
+	 * The interrupt_mask field is used only for channels but since our
+	 * vmbus connection also uses this data structure and its data starts
+	 * here, we commented out this field.
+	 */
+
+	/*
+	 * Ring data starts here + RingDataStartOffset
+	 * !!! DO NOT place any fields below this !!!
+	 */
+	u8 buffer[0];
+} __packed;
+
+struct hv_ring_buffer_info {
+	struct hv_ring_buffer *ring_buffer;
+	u32 ring_size;			/* Include the shared header */
+	spinlock_t ring_lock;
+
+	u32 ring_datasize;		/* < ring_size */
+	u32 ring_data_startoffset;
+};
+
+struct hv_ring_buffer_debug_info {
+	u32 current_interrupt_mask;
+	u32 current_read_index;
+	u32 current_write_index;
+	u32 bytes_avail_toread;
+	u32 bytes_avail_towrite;
+};
+
+/*
+ * We use the same version numbering for all Hyper-V modules.
+ *
+ * Definition of versioning is as follows;
+ *
+ *	Major Number	Changes for these scenarios;
+ *			1.	When a new version of Windows Hyper-V
+ *				is released.
+ *			2.	A Major change has occurred in the
+ *				Linux IC's.
+ *			(For example the merge for the first time
+ *			into the kernel) Every time the Major Number
+ *			changes, the Revision number is reset to 0.
+ *	Minor Number	Changes when new functionality is added
+ *			to the Linux IC's that is not a bug fix.
+ *
+ * 3.1 - Added completed hv_utils driver. Shutdown/Heartbeat/Timesync
+ */
+#define HV_DRV_VERSION           "3.1"
+
+
+/*
+ * A revision number of vmbus that is used for ensuring both ends on a
+ * partition are using compatible versions.
+ */
+#define VMBUS_REVISION_NUMBER		13
+
+/* Make maximum size of pipe payload of 16K */
+#define MAX_PIPE_DATA_PAYLOAD		(sizeof(u8) * 16384)
+
+/* Define PipeMode values. */
+#define VMBUS_PIPE_TYPE_BYTE		0x00000000
+#define VMBUS_PIPE_TYPE_MESSAGE		0x00000004
+
+/* The size of the user defined data buffer for non-pipe offers. */
+#define MAX_USER_DEFINED_BYTES		120
+
+/* The size of the user defined data buffer for pipe offers. */
+#define MAX_PIPE_USER_DEFINED_BYTES	116
+
+/*
+ * At the center of the Channel Management library is the Channel Offer. This
+ * struct contains the fundamental information about an offer.
+ */
+struct vmbus_channel_offer {
+	uuid_le if_type;
+	uuid_le if_instance;
+	u64 int_latency; /* in 100ns units */
+	u32 if_revision;
+	u32 server_ctx_size;	/* in bytes */
+	u16 chn_flags;
+	u16 mmio_megabytes;		/* in bytes * 1024 * 1024 */
+
+	union {
+		/* Non-pipes: The user has MAX_USER_DEFINED_BYTES bytes. */
+		struct {
+			unsigned char user_def[MAX_USER_DEFINED_BYTES];
+		} std;
+
+		/*
+		 * Pipes:
+		 * The following sructure is an integrated pipe protocol, which
+		 * is implemented on top of standard user-defined data. Pipe
+		 * clients have MAX_PIPE_USER_DEFINED_BYTES left for their own
+		 * use.
+		 */
+		struct {
+			u32  pipe_mode;
+			unsigned char user_def[MAX_PIPE_USER_DEFINED_BYTES];
+		} pipe;
+	} u;
+	u32 padding;
+} __packed;
+
+/* Server Flags */
+#define VMBUS_CHANNEL_ENUMERATE_DEVICE_INTERFACE	1
+#define VMBUS_CHANNEL_SERVER_SUPPORTS_TRANSFER_PAGES	2
+#define VMBUS_CHANNEL_SERVER_SUPPORTS_GPADLS		4
+#define VMBUS_CHANNEL_NAMED_PIPE_MODE			0x10
+#define VMBUS_CHANNEL_LOOPBACK_OFFER			0x100
+#define VMBUS_CHANNEL_PARENT_OFFER			0x200
+#define VMBUS_CHANNEL_REQUEST_MONITORED_NOTIFICATION	0x400
+
+struct vmpacket_descriptor {
+	u16 type;
+	u16 offset8;
+	u16 len8;
+	u16 flags;
+	u64 trans_id;
+} __packed;
+
+struct vmpacket_header {
+	u32 prev_pkt_start_offset;
+	struct vmpacket_descriptor descriptor;
+} __packed;
+
+struct vmtransfer_page_range {
+	u32 byte_count;
+	u32 byte_offset;
+} __packed;
+
+struct vmtransfer_page_packet_header {
+	struct vmpacket_descriptor d;
+	u16 xfer_pageset_id;
+	bool sender_owns_set;
+	u8 reserved;
+	u32 range_cnt;
+	struct vmtransfer_page_range ranges[1];
+} __packed;
+
+struct vmgpadl_packet_header {
+	struct vmpacket_descriptor d;
+	u32 gpadl;
+	u32 reserved;
+} __packed;
+
+struct vmadd_remove_transfer_page_set {
+	struct vmpacket_descriptor d;
+	u32 gpadl;
+	u16 xfer_pageset_id;
+	u16 reserved;
+} __packed;
+
+/*
+ * This structure defines a range in guest physical space that can be made to
+ * look virtually contiguous.
+ */
+struct gpa_range {
+	u32 byte_count;
+	u32 byte_offset;
+	u64 pfn_array[0];
+};
+
+/*
+ * This is the format for an Establish Gpadl packet, which contains a handle by
+ * which this GPADL will be known and a set of GPA ranges associated with it.
+ * This can be converted to a MDL by the guest OS.  If there are multiple GPA
+ * ranges, then the resulting MDL will be "chained," representing multiple VA
+ * ranges.
+ */
+struct vmestablish_gpadl {
+	struct vmpacket_descriptor d;
+	u32 gpadl;
+	u32 range_cnt;
+	struct gpa_range range[1];
+} __packed;
+
+/*
+ * This is the format for a Teardown Gpadl packet, which indicates that the
+ * GPADL handle in the Establish Gpadl packet will never be referenced again.
+ */
+struct vmteardown_gpadl {
+	struct vmpacket_descriptor d;
+	u32 gpadl;
+	u32 reserved;	/* for alignment to a 8-byte boundary */
+} __packed;
+
+/*
+ * This is the format for a GPA-Direct packet, which contains a set of GPA
+ * ranges, in addition to commands and/or data.
+ */
+struct vmdata_gpa_direct {
+	struct vmpacket_descriptor d;
+	u32 reserved;
+	u32 range_cnt;
+	struct gpa_range range[1];
+} __packed;
+
+/* This is the format for a Additional Data Packet. */
+struct vmadditional_data {
+	struct vmpacket_descriptor d;
+	u64 total_bytes;
+	u32 offset;
+	u32 byte_cnt;
+	unsigned char data[1];
+} __packed;
+
+union vmpacket_largest_possible_header {
+	struct vmpacket_descriptor simple_hdr;
+	struct vmtransfer_page_packet_header xfer_page_hdr;
+	struct vmgpadl_packet_header gpadl_hdr;
+	struct vmadd_remove_transfer_page_set add_rm_xfer_page_hdr;
+	struct vmestablish_gpadl establish_gpadl_hdr;
+	struct vmteardown_gpadl teardown_gpadl_hdr;
+	struct vmdata_gpa_direct data_gpa_direct_hdr;
+};
+
+#define VMPACKET_DATA_START_ADDRESS(__packet)	\
+	(void *)(((unsigned char *)__packet) +	\
+	 ((struct vmpacket_descriptor)__packet)->offset8 * 8)
+
+#define VMPACKET_DATA_LENGTH(__packet)		\
+	((((struct vmpacket_descriptor)__packet)->len8 -	\
+	  ((struct vmpacket_descriptor)__packet)->offset8) * 8)
+
+#define VMPACKET_TRANSFER_MODE(__packet)	\
+	(((struct IMPACT)__packet)->type)
+
+enum vmbus_packet_type {
+	VM_PKT_INVALID				= 0x0,
+	VM_PKT_SYNCH				= 0x1,
+	VM_PKT_ADD_XFER_PAGESET			= 0x2,
+	VM_PKT_RM_XFER_PAGESET			= 0x3,
+	VM_PKT_ESTABLISH_GPADL			= 0x4,
+	VM_PKT_TEARDOWN_GPADL			= 0x5,
+	VM_PKT_DATA_INBAND			= 0x6,
+	VM_PKT_DATA_USING_XFER_PAGES		= 0x7,
+	VM_PKT_DATA_USING_GPADL			= 0x8,
+	VM_PKT_DATA_USING_GPA_DIRECT		= 0x9,
+	VM_PKT_CANCEL_REQUEST			= 0xa,
+	VM_PKT_COMP				= 0xb,
+	VM_PKT_DATA_USING_ADDITIONAL_PKT	= 0xc,
+	VM_PKT_ADDITIONAL_DATA			= 0xd
+};
+
+#define VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED	1
+
+
+/* Version 1 messages */
+enum vmbus_channel_message_type {
+	CHANNELMSG_INVALID			=  0,
+	CHANNELMSG_OFFERCHANNEL		=  1,
+	CHANNELMSG_RESCIND_CHANNELOFFER	=  2,
+	CHANNELMSG_REQUESTOFFERS		=  3,
+	CHANNELMSG_ALLOFFERS_DELIVERED	=  4,
+	CHANNELMSG_OPENCHANNEL		=  5,
+	CHANNELMSG_OPENCHANNEL_RESULT		=  6,
+	CHANNELMSG_CLOSECHANNEL		=  7,
+	CHANNELMSG_GPADL_HEADER		=  8,
+	CHANNELMSG_GPADL_BODY			=  9,
+	CHANNELMSG_GPADL_CREATED		= 10,
+	CHANNELMSG_GPADL_TEARDOWN		= 11,
+	CHANNELMSG_GPADL_TORNDOWN		= 12,
+	CHANNELMSG_RELID_RELEASED		= 13,
+	CHANNELMSG_INITIATE_CONTACT		= 14,
+	CHANNELMSG_VERSION_RESPONSE		= 15,
+	CHANNELMSG_UNLOAD			= 16,
+#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
+	CHANNELMSG_VIEWRANGE_ADD		= 17,
+	CHANNELMSG_VIEWRANGE_REMOVE		= 18,
+#endif
+	CHANNELMSG_COUNT
+};
+
+struct vmbus_channel_message_header {
+	enum vmbus_channel_message_type msgtype;
+	u32 padding;
+} __packed;
+
+/* Query VMBus Version parameters */
+struct vmbus_channel_query_vmbus_version {
+	struct vmbus_channel_message_header header;
+	u32 version;
+} __packed;
+
+/* VMBus Version Supported parameters */
+struct vmbus_channel_version_supported {
+	struct vmbus_channel_message_header header;
+	bool version_supported;
+} __packed;
+
+/* Offer Channel parameters */
+struct vmbus_channel_offer_channel {
+	struct vmbus_channel_message_header header;
+	struct vmbus_channel_offer offer;
+	u32 child_relid;
+	u8 monitorid;
+	bool monitor_allocated;
+} __packed;
+
+/* Rescind Offer parameters */
+struct vmbus_channel_rescind_offer {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+} __packed;
+
+/*
+ * Request Offer -- no parameters, SynIC message contains the partition ID
+ * Set Snoop -- no parameters, SynIC message contains the partition ID
+ * Clear Snoop -- no parameters, SynIC message contains the partition ID
+ * All Offers Delivered -- no parameters, SynIC message contains the partition
+ *		           ID
+ * Flush Client -- no parameters, SynIC message contains the partition ID
+ */
+
+/* Open Channel parameters */
+struct vmbus_channel_open_channel {
+	struct vmbus_channel_message_header header;
+
+	/* Identifies the specific VMBus channel that is being opened. */
+	u32 child_relid;
+
+	/* ID making a particular open request at a channel offer unique. */
+	u32 openid;
+
+	/* GPADL for the channel's ring buffer. */
+	u32 ringbuffer_gpadlhandle;
+
+	/* GPADL for the channel's server context save area. */
+	u32 server_contextarea_gpadlhandle;
+
+	/*
+	* The upstream ring buffer begins at offset zero in the memory
+	* described by RingBufferGpadlHandle. The downstream ring buffer
+	* follows it at this offset (in pages).
+	*/
+	u32 downstream_ringbuffer_pageoffset;
+
+	/* User-specific data to be passed along to the server endpoint. */
+	unsigned char userdata[MAX_USER_DEFINED_BYTES];
+} __packed;
+
+/* Open Channel Result parameters */
+struct vmbus_channel_open_result {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+	u32 openid;
+	u32 status;
+} __packed;
+
+/* Close channel parameters; */
+struct vmbus_channel_close_channel {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+} __packed;
+
+/* Channel Message GPADL */
+#define GPADL_TYPE_RING_BUFFER		1
+#define GPADL_TYPE_SERVER_SAVE_AREA	2
+#define GPADL_TYPE_TRANSACTION		8
+
+/*
+ * The number of PFNs in a GPADL message is defined by the number of
+ * pages that would be spanned by ByteCount and ByteOffset.  If the
+ * implied number of PFNs won't fit in this packet, there will be a
+ * follow-up packet that contains more.
+ */
+struct vmbus_channel_gpadl_header {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+	u32 gpadl;
+	u16 range_buflen;
+	u16 rangecount;
+	struct gpa_range range[0];
+} __packed;
+
+/* This is the followup packet that contains more PFNs. */
+struct vmbus_channel_gpadl_body {
+	struct vmbus_channel_message_header header;
+	u32 msgnumber;
+	u32 gpadl;
+	u64 pfn[0];
+} __packed;
+
+struct vmbus_channel_gpadl_created {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+	u32 gpadl;
+	u32 creation_status;
+} __packed;
+
+struct vmbus_channel_gpadl_teardown {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+	u32 gpadl;
+} __packed;
+
+struct vmbus_channel_gpadl_torndown {
+	struct vmbus_channel_message_header header;
+	u32 gpadl;
+} __packed;
+
+#ifdef VMBUS_FEATURE_PARENT_OR_PEER_MEMORY_MAPPED_INTO_A_CHILD
+struct vmbus_channel_view_range_add {
+	struct vmbus_channel_message_header header;
+	PHYSICAL_ADDRESS viewrange_base;
+	u64 viewrange_length;
+	u32 child_relid;
+} __packed;
+
+struct vmbus_channel_view_range_remove {
+	struct vmbus_channel_message_header header;
+	PHYSICAL_ADDRESS viewrange_base;
+	u32 child_relid;
+} __packed;
+#endif
+
+struct vmbus_channel_relid_released {
+	struct vmbus_channel_message_header header;
+	u32 child_relid;
+} __packed;
+
+struct vmbus_channel_initiate_contact {
+	struct vmbus_channel_message_header header;
+	u32 vmbus_version_requested;
+	u32 padding2;
+	u64 interrupt_page;
+	u64 monitor_page1;
+	u64 monitor_page2;
+} __packed;
+
+struct vmbus_channel_version_response {
+	struct vmbus_channel_message_header header;
+	bool version_supported;
+} __packed;
+
+enum vmbus_channel_state {
+	CHANNEL_OFFER_STATE,
+	CHANNEL_OPENING_STATE,
+	CHANNEL_OPEN_STATE,
+};
+
+struct vmbus_channel_debug_info {
+	u32 relid;
+	enum vmbus_channel_state state;
+	uuid_le interfacetype;
+	uuid_le interface_instance;
+	u32 monitorid;
+	u32 servermonitor_pending;
+	u32 servermonitor_latency;
+	u32 servermonitor_connectionid;
+	u32 clientmonitor_pending;
+	u32 clientmonitor_latency;
+	u32 clientmonitor_connectionid;
+
+	struct hv_ring_buffer_debug_info inbound;
+	struct hv_ring_buffer_debug_info outbound;
+};
+
+/*
+ * Represents each channel msg on the vmbus connection This is a
+ * variable-size data structure depending on the msg type itself
+ */
+struct vmbus_channel_msginfo {
+	/* Bookkeeping stuff */
+	struct list_head msglistentry;
+
+	/* So far, this is only used to handle gpadl body message */
+	struct list_head submsglist;
+
+	/* Synchronize the request/response if needed */
+	struct completion  waitevent;
+	union {
+		struct vmbus_channel_version_supported version_supported;
+		struct vmbus_channel_open_result open_result;
+		struct vmbus_channel_gpadl_torndown gpadl_torndown;
+		struct vmbus_channel_gpadl_created gpadl_created;
+		struct vmbus_channel_version_response version_response;
+	} response;
+
+	u32 msgsize;
+	/*
+	 * The channel message that goes out on the "wire".
+	 * It will contain at minimum the VMBUS_CHANNEL_MESSAGE_HEADER header
+	 */
+	unsigned char msg[0];
+};
+
+struct vmbus_close_msg {
+	struct vmbus_channel_msginfo info;
+	struct vmbus_channel_close_channel msg;
+};
+
+struct vmbus_channel {
+	struct list_head listentry;
+
+	struct hv_device *device_obj;
+
+	struct work_struct work;
+
+	enum vmbus_channel_state state;
+
+	struct vmbus_channel_offer_channel offermsg;
+	/*
+	 * These are based on the OfferMsg.MonitorId.
+	 * Save it here for easy access.
+	 */
+	u8 monitor_grp;
+	u8 monitor_bit;
+
+	u32 ringbuffer_gpadlhandle;
+
+	/* Allocated memory for ring buffer */
+	void *ringbuffer_pages;
+	u32 ringbuffer_pagecount;
+	struct hv_ring_buffer_info outbound;	/* send to parent */
+	struct hv_ring_buffer_info inbound;	/* receive from parent */
+	spinlock_t inbound_lock;
+	struct workqueue_struct *controlwq;
+
+	struct vmbus_close_msg close_msg;
+
+	/* Channel callback are invoked in this workqueue context */
+	/* HANDLE dataWorkQueue; */
+
+	void (*onchannel_callback)(void *context);
+	void *channel_callback_context;
+};
+
+void free_channel(struct vmbus_channel *channel);
+
+void vmbus_onmessage(void *context);
+
+int vmbus_request_offers(void);
+
+/* The format must be the same as struct vmdata_gpa_direct */
+struct vmbus_channel_packet_page_buffer {
+	u16 type;
+	u16 dataoffset8;
+	u16 length8;
+	u16 flags;
+	u64 transactionid;
+	u32 reserved;
+	u32 rangecount;
+	struct hv_page_buffer range[MAX_PAGE_BUFFER_COUNT];
+} __packed;
+
+/* The format must be the same as struct vmdata_gpa_direct */
+struct vmbus_channel_packet_multipage_buffer {
+	u16 type;
+	u16 dataoffset8;
+	u16 length8;
+	u16 flags;
+	u64 transactionid;
+	u32 reserved;
+	u32 rangecount;		/* Always 1 in this case */
+	struct hv_multipage_buffer range;
+} __packed;
+
+
+extern int vmbus_open(struct vmbus_channel *channel,
+			    u32 send_ringbuffersize,
+			    u32 recv_ringbuffersize,
+			    void *userdata,
+			    u32 userdatalen,
+			    void(*onchannel_callback)(void *context),
+			    void *context);
+
+extern void vmbus_close(struct vmbus_channel *channel);
+
+extern int vmbus_sendpacket(struct vmbus_channel *channel,
+				  const void *buffer,
+				  u32 bufferLen,
+				  u64 requestid,
+				  enum vmbus_packet_type type,
+				  u32 flags);
+
+extern int vmbus_sendpacket_pagebuffer(struct vmbus_channel *channel,
+					    struct hv_page_buffer pagebuffers[],
+					    u32 pagecount,
+					    void *buffer,
+					    u32 bufferlen,
+					    u64 requestid);
+
+extern int vmbus_sendpacket_multipagebuffer(struct vmbus_channel *channel,
+					struct hv_multipage_buffer *mpb,
+					void *buffer,
+					u32 bufferlen,
+					u64 requestid);
+
+extern int vmbus_establish_gpadl(struct vmbus_channel *channel,
+				      void *kbuffer,
+				      u32 size,
+				      u32 *gpadl_handle);
+
+extern int vmbus_teardown_gpadl(struct vmbus_channel *channel,
+				     u32 gpadl_handle);
+
+extern int vmbus_recvpacket(struct vmbus_channel *channel,
+				  void *buffer,
+				  u32 bufferlen,
+				  u32 *buffer_actual_len,
+				  u64 *requestid);
+
+extern int vmbus_recvpacket_raw(struct vmbus_channel *channel,
+				     void *buffer,
+				     u32 bufferlen,
+				     u32 *buffer_actual_len,
+				     u64 *requestid);
+
+
+extern void vmbus_get_debug_info(struct vmbus_channel *channel,
+				     struct vmbus_channel_debug_info *debug);
+
+extern void vmbus_ontimer(unsigned long data);
+
+
+#define LOWORD(dw) ((unsigned short)(dw))
+#define HIWORD(dw) ((unsigned short)(((unsigned int) (dw) >> 16) & 0xFFFF))
+
+
+#define VMBUS				0x0001
+#define STORVSC				0x0002
+#define NETVSC				0x0004
+#define INPUTVSC			0x0008
+#define BLKVSC				0x0010
+#define VMBUS_DRV			0x0100
+#define STORVSC_DRV			0x0200
+#define NETVSC_DRV			0x0400
+#define INPUTVSC_DRV		0x0800
+#define BLKVSC_DRV			0x1000
+
+#define ALL_MODULES			(VMBUS		|\
+							STORVSC		|\
+							NETVSC		|\
+							INPUTVSC	|\
+							BLKVSC		|\
+							VMBUS_DRV	|\
+							STORVSC_DRV	|\
+							NETVSC_DRV	|\
+							INPUTVSC_DRV|\
+							BLKVSC_DRV)
+
+/* Logging Level */
+#define ERROR_LVL				3
+#define WARNING_LVL				4
+#define INFO_LVL				6
+#define DEBUG_LVL				7
+#define DEBUG_LVL_ENTEREXIT			8
+#define DEBUG_RING_LVL				9
+
+extern unsigned int vmbus_loglevel;
+
+#define DPRINT(mod, lvl, fmt, args...) do {\
+	if ((mod & (HIWORD(vmbus_loglevel))) &&	\
+	    (lvl <= LOWORD(vmbus_loglevel)))	\
+		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
+	} while (0)
+
+#define DPRINT_DBG(mod, fmt, args...) do {\
+	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
+	    (DEBUG_LVL <= LOWORD(vmbus_loglevel)))	\
+		printk(KERN_DEBUG #mod": %s() " fmt "\n", __func__, ## args);\
+	} while (0)
+
+#define DPRINT_INFO(mod, fmt, args...) do {\
+	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
+	    (INFO_LVL <= LOWORD(vmbus_loglevel)))	\
+		printk(KERN_INFO #mod": " fmt "\n", ## args);\
+	} while (0)
+
+#define DPRINT_WARN(mod, fmt, args...) do {\
+	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
+	    (WARNING_LVL <= LOWORD(vmbus_loglevel)))	\
+		printk(KERN_WARNING #mod": WARNING! " fmt "\n", ## args);\
+	} while (0)
+
+#define DPRINT_ERR(mod, fmt, args...) do {\
+	if ((mod & (HIWORD(vmbus_loglevel))) &&		\
+	    (ERROR_LVL <= LOWORD(vmbus_loglevel)))	\
+		printk(KERN_ERR #mod": %s() ERROR!! " fmt "\n",	\
+		       __func__, ## args);\
+	} while (0)
+
+
+
+struct hv_driver;
+struct hv_device;
+
+struct hv_dev_port_info {
+	u32 int_mask;
+	u32 read_idx;
+	u32 write_idx;
+	u32 bytes_avail_toread;
+	u32 bytes_avail_towrite;
+};
+
+struct hv_device_info {
+	u32 chn_id;
+	u32 chn_state;
+	uuid_le chn_type;
+	uuid_le chn_instance;
+
+	u32 monitor_id;
+	u32 server_monitor_pending;
+	u32 server_monitor_latency;
+	u32 server_monitor_conn_id;
+	u32 client_monitor_pending;
+	u32 client_monitor_latency;
+	u32 client_monitor_conn_id;
+
+	struct hv_dev_port_info inbound;
+	struct hv_dev_port_info outbound;
+};
+
+/* Base driver object */
+struct hv_driver {
+	const char *name;
+
+	/* the device type supported by this driver */
+	uuid_le dev_type;
+	const struct hv_vmbus_device_id *id_table;
+
+	struct device_driver driver;
+
+	int (*probe)(struct hv_device *, const struct hv_vmbus_device_id *);
+	int (*remove)(struct hv_device *);
+	void (*shutdown)(struct hv_device *);
+
+};
+
+/* Base device object */
+struct hv_device {
+	/* the device type id of this device */
+	uuid_le dev_type;
+
+	/* the device instance id of this device */
+	uuid_le dev_instance;
+
+	struct device device;
+
+	struct vmbus_channel *channel;
+};
+
+
+static inline struct hv_device *device_to_hv_device(struct device *d)
+{
+	return container_of(d, struct hv_device, device);
+}
+
+static inline struct hv_driver *drv_to_hv_drv(struct device_driver *d)
+{
+	return container_of(d, struct hv_driver, driver);
+}
+
+static inline void hv_set_drvdata(struct hv_device *dev, void *data)
+{
+	dev_set_drvdata(&dev->device, data);
+}
+
+static inline void *hv_get_drvdata(struct hv_device *dev)
+{
+	return dev_get_drvdata(&dev->device);
+}
+
+/* Vmbus interface */
+#define vmbus_driver_register(driver)	\
+	__vmbus_driver_register(driver, THIS_MODULE, KBUILD_MODNAME)
+int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
+					 struct module *owner,
+					 const char *mod_name);
+void vmbus_driver_unregister(struct hv_driver *hv_driver);
+
+/**
+ * VMBUS_DEVICE - macro used to describe a specific hyperv vmbus device
+ *
+ * This macro is used to create a struct hv_vmbus_device_id that matches a
+ * specific device.
+ */
+#define VMBUS_DEVICE(g0, g1, g2, g3, g4, g5, g6, g7,	\
+		     g8, g9, ga, gb, gc, gd, ge, gf)	\
+	.guid = { g0, g1, g2, g3, g4, g5, g6, g7,	\
+		  g8, g9, ga, gb, gc, gd, ge, gf },
+
+/*
+ * Common header for Hyper-V ICs
+ */
+
+#define ICMSGTYPE_NEGOTIATE		0
+#define ICMSGTYPE_HEARTBEAT		1
+#define ICMSGTYPE_KVPEXCHANGE		2
+#define ICMSGTYPE_SHUTDOWN		3
+#define ICMSGTYPE_TIMESYNC		4
+#define ICMSGTYPE_VSS			5
+
+#define ICMSGHDRFLAG_TRANSACTION	1
+#define ICMSGHDRFLAG_REQUEST		2
+#define ICMSGHDRFLAG_RESPONSE		4
+
+#define HV_S_OK				0x00000000
+#define HV_E_FAIL			0x80004005
+#define HV_ERROR_NOT_SUPPORTED		0x80070032
+#define HV_ERROR_MACHINE_LOCKED		0x800704F7
+
+/*
+ * While we want to handle util services as regular devices,
+ * there is only one instance of each of these services; so
+ * we statically allocate the service specific state.
+ */
+
+struct hv_util_service {
+	u8 *recv_buffer;
+	void (*util_cb)(void *);
+	int (*util_init)(struct hv_util_service *);
+	void (*util_deinit)(void);
+};
+
+struct vmbuspipe_hdr {
+	u32 flags;
+	u32 msgsize;
+} __packed;
+
+struct ic_version {
+	u16 major;
+	u16 minor;
+} __packed;
+
+struct icmsg_hdr {
+	struct ic_version icverframe;
+	u16 icmsgtype;
+	struct ic_version icvermsg;
+	u16 icmsgsize;
+	u32 status;
+	u8 ictransaction_id;
+	u8 icflags;
+	u8 reserved[2];
+} __packed;
+
+struct icmsg_negotiate {
+	u16 icframe_vercnt;
+	u16 icmsg_vercnt;
+	u32 reserved;
+	struct ic_version icversion_data[1]; /* any size array */
+} __packed;
+
+struct shutdown_msg_data {
+	u32 reason_code;
+	u32 timeout_seconds;
+	u32 flags;
+	u8  display_message[2048];
+} __packed;
+
+struct heartbeat_msg_data {
+	u64 seq_num;
+	u32 reserved[8];
+} __packed;
+
+/* Time Sync IC defs */
+#define ICTIMESYNCFLAG_PROBE	0
+#define ICTIMESYNCFLAG_SYNC	1
+#define ICTIMESYNCFLAG_SAMPLE	2
+
+#ifdef __x86_64__
+#define WLTIMEDELTA	116444736000000000L	/* in 100ns unit */
+#else
+#define WLTIMEDELTA	116444736000000000LL
+#endif
+
+struct ictimesync_data {
+	u64 parenttime;
+	u64 childtime;
+	u64 roundtriptime;
+	u8 flags;
+} __packed;
+
+struct hyperv_service_callback {
+	u8 msg_type;
+	char *log_msg;
+	uuid_le data;
+	struct vmbus_channel *channel;
+	void (*callback) (void *context);
+};
+
+extern void prep_negotiate_resp(struct icmsg_hdr *,
+				struct icmsg_negotiate *, u8 *);
+
+#endif /* _HYPERV_H */
