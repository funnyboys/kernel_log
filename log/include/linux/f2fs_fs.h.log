commit c84ef3c5e65ccf99a7a91a4d731ebb5d6331a178
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Tue Mar 3 19:59:26 2020 +0530

    f2fs: Add a new CP flag to help fsck fix resize SPO issues
    
    Add and set a new CP flag CP_RESIZEFS_FLAG during
    online resize FS to help fsck fix the metadata mismatch
    that may happen due to SPO during resize, where SB
    got updated but CP data couldn't be written yet.
    
    fsck errors -
    Info: CKPT version = 6ed7bccb
            Wrong user_block_count(2233856)
    [f2fs_do_mount:3365] Checkpoint is polluted
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index ac3f4888b3df..3c383ddd92dd 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -125,6 +125,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_RESIZEFS_FLAG		0x00004000
 #define CP_DISABLED_QUICK_FLAG		0x00002000
 #define CP_DISABLED_FLAG		0x00001000
 #define CP_QUOTA_NEED_FSCK_FLAG		0x00000800

commit 4c8ff7095bef64fc47e996a938f7d57f9e077da3
Author: Chao Yu <yuchao0@huawei.com>
Date:   Fri Nov 1 18:07:14 2019 +0800

    f2fs: support data compression
    
    This patch tries to support compression in f2fs.
    
    - New term named cluster is defined as basic unit of compression, file can
    be divided into multiple clusters logically. One cluster includes 4 << n
    (n >= 0) logical pages, compression size is also cluster size, each of
    cluster can be compressed or not.
    
    - In cluster metadata layout, one special flag is used to indicate cluster
    is compressed one or normal one, for compressed cluster, following metadata
    maps cluster to [1, 4 << n - 1] physical blocks, in where f2fs stores
    data including compress header and compressed data.
    
    - In order to eliminate write amplification during overwrite, F2FS only
    support compression on write-once file, data can be compressed only when
    all logical blocks in file are valid and cluster compress ratio is lower
    than specified threshold.
    
    - To enable compression on regular inode, there are three ways:
    * chattr +c file
    * chattr +c dir; touch dir/file
    * mount w/ -o compress_extension=ext; touch file.ext
    
    Compress metadata layout:
                                 [Dnode Structure]
                 +-----------------------------------------------+
                 | cluster 1 | cluster 2 | ......... | cluster N |
                 +-----------------------------------------------+
                 .           .                       .           .
           .                       .                .                      .
      .         Compressed Cluster       .        .        Normal Cluster            .
    +----------+---------+---------+---------+  +---------+---------+---------+---------+
    |compr flag| block 1 | block 2 | block 3 |  | block 1 | block 2 | block 3 | block 4 |
    +----------+---------+---------+---------+  +---------+---------+---------+---------+
               .                             .
             .                                           .
           .                                                           .
          +-------------+-------------+----------+----------------------------+
          | data length | data chksum | reserved |      compressed data       |
          +-------------+-------------+----------+----------------------------+
    
    Changelog:
    
    20190326:
    - fix error handling of read_end_io().
    - remove unneeded comments in f2fs_encrypt_one_page().
    
    20190327:
    - fix wrong use of f2fs_cluster_is_full() in f2fs_mpage_readpages().
    - don't jump into loop directly to avoid uninitialized variables.
    - add TODO tag in error path of f2fs_write_cache_pages().
    
    20190328:
    - fix wrong merge condition in f2fs_read_multi_pages().
    - check compressed file in f2fs_post_read_required().
    
    20190401
    - allow overwrite on non-compressed cluster.
    - check cluster meta before writing compressed data.
    
    20190402
    - don't preallocate blocks for compressed file.
    
    - add lz4 compress algorithm
    - process multiple post read works in one workqueue
      Now f2fs supports processing post read work in multiple workqueue,
      it shows low performance due to schedule overhead of multiple
      workqueue executing orderly.
    
    20190921
    - compress: support buffered overwrite
    C: compress cluster flag
    V: valid block address
    N: NEW_ADDR
    
    One cluster contain 4 blocks
    
     before overwrite   after overwrite
    
    - VVVV          ->      CVNN
    - CVNN          ->      VVVV
    
    - CVNN          ->      CVNN
    - CVNN          ->      CVVV
    
    - CVVV          ->      CVNN
    - CVVV          ->      CVVV
    
    20191029
    - add kconfig F2FS_FS_COMPRESSION to isolate compression related
    codes, add kconfig F2FS_FS_{LZO,LZ4} to cover backend algorithm.
    note that: will remove lzo backend if Jaegeuk agreed that too.
    - update codes according to Eric's comments.
    
    20191101
    - apply fixes from Jaegeuk
    
    20191113
    - apply fixes from Jaegeuk
    - split workqueue for fsverity
    
    20191216
    - apply fixes from Jaegeuk
    
    20200117
    - fix to avoid NULL pointer dereference
    
    [Jaegeuk Kim]
    - add tracepoint for f2fs_{,de}compress_pages()
    - fix many bugs and add some compression stats
    - fix overwrite/mmap bugs
    - address 32bit build error, reported by Geert.
    - bug fixes when handling errors and i_compressed_blocks
    
    Reported-by: <noreply@ellerman.id.au>
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 284738996028..ac3f4888b3df 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -23,6 +23,7 @@
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
+#define COMPRESS_ADDR		((block_t)-2)	/* used as compressed data flag */
 
 #define F2FS_BYTES_TO_BLK(bytes)	((bytes) >> F2FS_BLKSIZE_BITS)
 #define F2FS_BLK_TO_BYTES(blk)		((blk) << F2FS_BLKSIZE_BITS)
@@ -271,6 +272,10 @@ struct f2fs_inode {
 			__le32 i_inode_checksum;/* inode meta checksum */
 			__le64 i_crtime;	/* creation time */
 			__le32 i_crtime_nsec;	/* creation time in nano scale */
+			__le64 i_compr_blocks;	/* # of compressed blocks */
+			__u8 i_compress_algorithm;	/* compress algorithm */
+			__u8 i_log_cluster_size;	/* log of cluster size */
+			__le16 i_padding;		/* padding */
 			__le32 i_extra_end[0];	/* for attribute size calculation */
 		} __packed;
 		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */

commit 5aba54302a46fdd589040b928d5d010e5ace1234
Author: Daniel Rosenberg <drosen@google.com>
Date:   Tue Jul 23 16:05:28 2019 -0700

    f2fs: include charset encoding information in the superblock
    
    Add charset encoding to f2fs to support casefolding. It is modeled after
    the same feature introduced in commit c83ad55eaa91 ("ext4: include charset
    encoding information in the superblock")
    
    Currently this is not compatible with encryption, similar to the current
    ext4 imlpementation. This will change in the future.
    
    >From the ext4 patch:
    """
    The s_encoding field stores a magic number indicating the encoding
    format and version used globally by file and directory names in the
    filesystem.  The s_encoding_flags defines policies for using the charset
    encoding, like how to handle invalid sequences.  The magic number is
    mapped to the exact charset table, but the mapping is specific to ext4.
    Since we don't have any commitment to support old encodings, the only
    encoding I am supporting right now is utf8-12.1.0.
    
    The current implementation prevents the user from enabling encoding and
    per-directory encryption on the same filesystem at the same time.  The
    incompatibility between these features lies in how we do efficient
    directory searches when we cannot be sure the encryption of the user
    provided fname will match the actual hash stored in the disk without
    decrypting every directory entry, because of normalization cases.  My
    quickest solution is to simply block the concurrent use of these
    features for now, and enable it later, once we have a better solution.
    """
    
    Signed-off-by: Daniel Rosenberg <drosen@google.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 52af9ac164b4..284738996028 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -36,6 +36,11 @@
 
 #define F2FS_MAX_QUOTAS		3
 
+#define F2FS_ENC_UTF8_12_1	1
+#define F2FS_ENC_STRICT_MODE_FL	(1 << 0)
+#define f2fs_has_strict_mode(sbi) \
+	(sbi->s_encoding_flags & F2FS_ENC_STRICT_MODE_FL)
+
 #define F2FS_IO_SIZE(sbi)	(1 << F2FS_OPTION(sbi).write_io_size_bits) /* Blocks */
 #define F2FS_IO_SIZE_KB(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 2)) /* KB */
 #define F2FS_IO_SIZE_BYTES(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 12)) /* B */
@@ -110,7 +115,9 @@ struct f2fs_super_block {
 	struct f2fs_device devs[MAX_DEVICES];	/* device list */
 	__le32 qf_ino[F2FS_MAX_QUOTAS];	/* quota inode numbers */
 	__u8 hot_ext_count;		/* # of hot file extension */
-	__u8 reserved[310];		/* valid reserved region */
+	__le16  s_encoding;		/* Filename charset encoding */
+	__le16  s_encoding_flags;	/* Filename charset encoding flags */
+	__u8 reserved[306];		/* valid reserved region */
 	__le32 crc;			/* checksum of superblock */
 } __packed;
 

commit c72db71ed61ff51c2b8189ac9889dd18f22eb612
Author: Chao Yu <yuchao0@huawei.com>
Date:   Fri Jul 12 16:55:42 2019 +0800

    f2fs: fix panic of IO alignment feature
    
    Since 07173c3ec276 ("block: enable multipage bvecs"), one bio vector
    can store multi pages, so that we can not calculate max IO size of
    bio as PAGE_SIZE * bio->bi_max_vecs. However IO alignment feature of
    f2fs always has that assumption, so finally, it may cause panic during
    IO submission as below stack.
    
     kernel BUG at fs/f2fs/data.c:317!
     RIP: 0010:__submit_merged_bio+0x8b0/0x8c0
     Call Trace:
      f2fs_submit_page_write+0x3cd/0xdd0
      do_write_page+0x15d/0x360
      f2fs_outplace_write_data+0xd7/0x210
      f2fs_do_write_data_page+0x43b/0xf30
      __write_data_page+0xcf6/0x1140
      f2fs_write_cache_pages+0x3ba/0xb40
      f2fs_write_data_pages+0x3dd/0x8b0
      do_writepages+0xbb/0x1e0
      __writeback_single_inode+0xb6/0x800
      writeback_sb_inodes+0x441/0x910
      wb_writeback+0x261/0x650
      wb_workfn+0x1f9/0x7a0
      process_one_work+0x503/0x970
      worker_thread+0x7d/0x820
      kthread+0x1ad/0x210
      ret_from_fork+0x35/0x40
    
    This patch adds one extra condition to check left space in bio while
    trying merging page to bio, to avoid panic.
    
    This bug was reported in bugzilla:
    
    https://bugzilla.kernel.org/show_bug.cgi?id=204043
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 65559900d4d7..52af9ac164b4 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -41,6 +41,7 @@
 #define F2FS_IO_SIZE_BYTES(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 12)) /* B */
 #define F2FS_IO_SIZE_BITS(sbi)	(F2FS_OPTION(sbi).write_io_size_bits) /* power of 2 */
 #define F2FS_IO_SIZE_MASK(sbi)	(F2FS_IO_SIZE(sbi) - 1)
+#define F2FS_IO_ALIGNED(sbi)	(F2FS_IO_SIZE(sbi) > 1)
 
 /* This flag is used by node and meta inodes, and by recovery */
 #define GFP_F2FS_ZERO		(GFP_NOFS | __GFP_ZERO)

commit d7eb8f1cdfaefcd41b716ef0ed1745b43c6c4fc9
Author: Chao Yu <yuchao0@huawei.com>
Date:   Mon Apr 22 17:33:52 2019 +0800

    f2fs: allow unfixed f2fs_checkpoint.checksum_offset
    
    Previously, f2fs_checkpoint.checksum_offset points fixed position of
    f2fs_checkpoint structure:
    
    "#define CP_CHKSUM_OFFSET       4092"
    
    It is unnecessary, and it breaks the consecutiveness of nat and sit
    bitmap stored across checkpoint park block and payload blocks.
    
    This patch allows f2fs to handle unfixed .checksum_offset.
    
    In addition, for the case checksum value is stored in the middle of
    checkpoint park, calculating checksum value with superposition method
    like we did for inode_checksum.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 55da9abed023..65559900d4d7 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -164,6 +164,10 @@ struct f2fs_checkpoint {
 	unsigned char sit_nat_version_bitmap[1];
 } __packed;
 
+#define CP_CHKSUM_OFFSET	4092	/* default chksum offset in checkpoint */
+#define CP_MIN_CHKSUM_OFFSET						\
+	(offsetof(struct f2fs_checkpoint, sit_nat_version_bitmap))
+
 /*
  * For orphan inode management
  */

commit d02a6e6174a772fa90c5efa51a55a04e6d8c0006
Author: Chao Yu <yuchao0@huawei.com>
Date:   Mon Mar 25 21:08:19 2019 +0800

    f2fs: allow address pointer number of dnode aligning to specified size
    
    This patch expands scalability of dnode layout, it allows address pointer
    number of dnode aligning to specified size (now, the size is one byte by
    default), and later the number can align to compress cluster size
    (1 << n bytes, n=[2,..)), it can avoid cluster acrossing two dnode, making
    design of compress meta layout simple.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index f5740423b002..55da9abed023 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -198,11 +198,12 @@ struct f2fs_extent {
 					get_extra_isize(inode))
 #define DEF_NIDS_PER_INODE	5	/* Node IDs in an Inode */
 #define ADDRS_PER_INODE(inode)	addrs_per_inode(inode)
-#define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
+#define DEF_ADDRS_PER_BLOCK	1018	/* Address Pointers in a Direct Block */
+#define ADDRS_PER_BLOCK(inode)	addrs_per_block(inode)
 #define NIDS_PER_BLOCK		1018	/* Node IDs in an Indirect Block */
 
 #define ADDRS_PER_PAGE(page, inode)	\
-	(IS_INODE(page) ? ADDRS_PER_INODE(inode) : ADDRS_PER_BLOCK)
+	(IS_INODE(page) ? ADDRS_PER_INODE(inode) : ADDRS_PER_BLOCK(inode))
 
 #define	NODE_DIR1_BLOCK		(DEF_ADDRS_PER_INODE + 1)
 #define	NODE_DIR2_BLOCK		(DEF_ADDRS_PER_INODE + 2)
@@ -267,7 +268,7 @@ struct f2fs_inode {
 } __packed;
 
 struct direct_node {
-	__le32 addr[ADDRS_PER_BLOCK];	/* array of data block address */
+	__le32 addr[DEF_ADDRS_PER_BLOCK];	/* array of data block address */
 } __packed;
 
 struct indirect_node {

commit 68b79cdc6de97fe270ceb40082a4aa6ad3e41ea7
Author: Zeng Guangyue <zengguangyue@hisilicon.com>
Date:   Mon Feb 18 14:26:41 2019 +0800

    f2fs: correct spelling mistake
    
    correct spelling mistake for "nunmber"
    
    Signed-off-by: Zeng Guangyue <zengguangyue@hisilicon.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 666db8eb71e0..f5740423b002 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -285,7 +285,7 @@ enum {
 
 struct node_footer {
 	__le32 nid;		/* node id */
-	__le32 ino;		/* inode nunmber */
+	__le32 ino;		/* inode number */
 	__le32 flag;		/* include cold/fsync/dentry marks and offset */
 	__le64 cp_ver;		/* checkpoint version */
 	__le32 next_blkaddr;	/* next node page block address */

commit 500e0b28ecd3c5aade98f3c3a339d18dcb166bb6
Author: Chao Yu <yuchao0@huawei.com>
Date:   Fri Feb 15 00:08:25 2019 +0800

    f2fs: fix to check inline_xattr_size boundary correctly
    
    We use below condition to check inline_xattr_size boundary:
    
            if (!F2FS_OPTION(sbi).inline_xattr_size ||
                    F2FS_OPTION(sbi).inline_xattr_size >=
                                    DEF_ADDRS_PER_INODE -
                                    F2FS_TOTAL_EXTRA_ATTR_SIZE -
                                    DEF_INLINE_RESERVED_SIZE -
                                    DEF_MIN_INLINE_SIZE)
    
    There is there problems in that check:
    - we should allow inline_xattr_size equaling to min size of inline
    {data,dentry} area.
    - F2FS_TOTAL_EXTRA_ATTR_SIZE and inline_xattr_size are based on
    different size unit, previous one is 4 bytes, latter one is 1 bytes.
    - DEF_MIN_INLINE_SIZE only indicate min size of inline data area,
    however, we need to consider min size of inline dentry area as well,
    minimal inline dentry should at least contain two entries: '.' and
    '..', so that min inline_dentry size is 40 bytes.
    
    .bitmap         1 * 1 = 1
    .reserved       1 * 1 = 1
    .dentry         11 * 2 = 22
    .filename       8 * 2 = 16
    total           40
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 8d57aaee8166..666db8eb71e0 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -490,12 +490,12 @@ typedef __le32	f2fs_hash_t;
 
 /*
  * space utilization of regular dentry and inline dentry (w/o extra reservation)
- *		regular dentry			inline dentry
- * bitmap	1 * 27 = 27			1 * 23 = 23
- * reserved	1 * 3 = 3			1 * 7 = 7
- * dentry	11 * 214 = 2354			11 * 182 = 2002
- * filename	8 * 214 = 1712			8 * 182 = 1456
- * total	4096				3488
+ *		regular dentry		inline dentry (def)	inline dentry (min)
+ * bitmap	1 * 27 = 27		1 * 23 = 23		1 * 1 = 1
+ * reserved	1 * 3 = 3		1 * 7 = 7		1 * 1 = 1
+ * dentry	11 * 214 = 2354		11 * 182 = 2002		11 * 2 = 22
+ * filename	8 * 214 = 1712		8 * 182 = 1456		8 * 2 = 16
+ * total	4096			3488			40
  *
  * Note: there are more reserved space in inline dentry than in regular
  * dentry, when converting inline dentry we should handle this carefully.
@@ -507,6 +507,7 @@ typedef __le32	f2fs_hash_t;
 #define SIZE_OF_RESERVED	(PAGE_SIZE - ((SIZE_OF_DIR_ENTRY + \
 				F2FS_SLOT_LEN) * \
 				NR_DENTRY_IN_BLOCK + SIZE_OF_DENTRY_BITMAP))
+#define MIN_INLINE_DENTRY_SIZE		40	/* just include '.' and '..' entries */
 
 /* One directory entry slot representing F2FS_SLOT_LEN-sized file name */
 struct f2fs_dir_entry {

commit 1ffdc3807589779626924eb600db784d3d943a08
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Fri Jan 25 15:35:01 2019 +0800

    f2fs: fix typos in code comments
    
    lengh -> length
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index d6befe1f9dc7..8d57aaee8166 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -187,7 +187,7 @@ struct f2fs_orphan_block {
 struct f2fs_extent {
 	__le32 fofs;		/* start file offset of the extent */
 	__le32 blk;		/* start block address of the extent */
-	__le32 len;		/* lengh of the extent */
+	__le32 len;		/* length of the extent */
 } __packed;
 
 #define F2FS_NAME_LEN		255
@@ -512,7 +512,7 @@ typedef __le32	f2fs_hash_t;
 struct f2fs_dir_entry {
 	__le32 hash_code;	/* hash code of file name */
 	__le32 ino;		/* inode number */
-	__le16 name_len;	/* lengh of file name */
+	__le16 name_len;	/* length of file name */
 	__u8 file_type;		/* file type */
 } __packed;
 

commit db610a640eeeb268c36a4558414f28e1c269433e
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Jan 24 17:48:38 2019 -0800

    f2fs: add quick mode of checkpoint=disable for QA
    
    This mode returns mount() quickly with EAGAIN. We can trigger this by
    shutdown(F2FS_GOING_DOWN_NEED_FSCK).
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index d7711048ef93..d6befe1f9dc7 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -116,6 +116,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_DISABLED_QUICK_FLAG		0x00002000
 #define CP_DISABLED_FLAG		0x00001000
 #define CP_QUOTA_NEED_FSCK_FLAG		0x00000800
 #define CP_LARGE_NAT_BITMAP_FLAG	0x00000400

commit af033b2aa8a874fd5737fafe90d159136527b5b4
Author: Chao Yu <yuchao0@huawei.com>
Date:   Thu Sep 20 20:05:00 2018 +0800

    f2fs: guarantee journalled quota data by checkpoint
    
    For journalled quota mode, let checkpoint to flush dquot dirty data
    and quota file data to guarntee persistence of all quota sysfile in
    last checkpoint, by this way, we can avoid corrupting quota sysfile
    when encountering SPO.
    
    The implementation is as below:
    
    1. add a global state SBI_QUOTA_NEED_FLUSH to indicate that there is
    cached dquot metadata changes in quota subsystem, and later checkpoint
    should:
     a) flush dquot metadata into quota file.
     b) flush quota file to storage to keep file usage be consistent.
    
    2. add a global state SBI_QUOTA_NEED_REPAIR to indicate that quota
    operation failed due to -EIO or -ENOSPC, so later,
     a) checkpoint will skip syncing dquot metadata.
     b) CP_QUOTA_NEED_FSCK_FLAG will be set in last cp pack to give a
        hint for fsck repairing.
    
    3. add a global state SBI_QUOTA_SKIP_FLUSH, in checkpoint, if quota
    data updating is very heavy, it may cause hungtask in block_operation().
    To avoid this, if our retry time exceed threshold, let's just skip
    flushing and retry in next checkpoint().
    
    Signed-off-by: Weichao Guo <guoweichao@huawei.com>
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    [Jaegeuk Kim: avoid warnings and set fsck flag]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 8b9c7dc0260c..d7711048ef93 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -117,6 +117,7 @@ struct f2fs_super_block {
  * For checkpoint
  */
 #define CP_DISABLED_FLAG		0x00001000
+#define CP_QUOTA_NEED_FSCK_FLAG		0x00000800
 #define CP_LARGE_NAT_BITMAP_FLAG	0x00000400
 #define CP_NOCRC_RECOVERY_FLAG	0x00000200
 #define CP_TRIMMED_FLAG		0x00000100

commit 4354994f097d068a894aa1a0860da54571df3582
Author: Daniel Rosenberg <drosen@google.com>
Date:   Mon Aug 20 19:21:43 2018 -0700

    f2fs: checkpoint disabling
    
    Note that, it requires "f2fs: return correct errno in f2fs_gc".
    
    This adds a lightweight non-persistent snapshotting scheme to f2fs.
    
    To use, mount with the option checkpoint=disable, and to return to
    normal operation, remount with checkpoint=enable. If the filesystem
    is shut down before remounting with checkpoint=enable, it will revert
    back to its apparent state when it was first mounted with
    checkpoint=disable. This is useful for situations where you wish to be
    able to roll back the state of the disk in case of some critical
    failure.
    
    Signed-off-by: Daniel Rosenberg <drosen@google.com>
    [Jaegeuk Kim: use SB_RDONLY instead of MS_RDONLY]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 1db13ff9a3f4..8b9c7dc0260c 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -116,6 +116,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_DISABLED_FLAG		0x00001000
 #define CP_LARGE_NAT_BITMAP_FLAG	0x00000400
 #define CP_NOCRC_RECOVERY_FLAG	0x00000200
 #define CP_TRIMMED_FLAG		0x00000100

commit d440c52d3151a28358f4c2d52d8583a0aa54ab83
Author: Junling Zheng <zhengjunling@huawei.com>
Date:   Fri Sep 28 20:25:56 2018 +0800

    f2fs: support superblock checksum
    
    Now we support crc32 checksum for superblock.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Junling Zheng <zhengjunling@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 1d4b196291d6..1db13ff9a3f4 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -109,7 +109,8 @@ struct f2fs_super_block {
 	struct f2fs_device devs[MAX_DEVICES];	/* device list */
 	__le32 qf_ino[F2FS_MAX_QUOTAS];	/* quota inode numbers */
 	__u8 hot_ext_count;		/* # of hot file extension */
-	__u8 reserved[314];		/* valid reserved region */
+	__u8 reserved[310];		/* valid reserved region */
+	__le32 crc;			/* checksum of superblock */
 } __packed;
 
 /*

commit 7c1a000d466235c875a989971cfda344e6bb1166
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Sep 12 09:16:07 2018 +0800

    f2fs: add SPDX license identifiers
    
    Remove the verbose license text from f2fs files and replace them with
    SPDX tags.  This does not change the license of any of the code.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index f70f8ac9c4f4..1d4b196291d6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /**
  * include/linux/f2fs_fs.h
  *
  * Copyright (c) 2012 Samsung Electronics Co., Ltd.
  *             http://www.samsung.com/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef _LINUX_F2FS_FS_H
 #define _LINUX_F2FS_FS_H

commit e15d54d5009688ccb2a5312f3b70d631615329c9
Author: Yunlei He <heyunlei@huawei.com>
Date:   Wed Jun 27 14:46:21 2018 +0800

    f2fs: Allocate and stat mem used by free nid bitmap more accurately
    
    This patch used f2fs_bitmap_size macro to calculate mem used by
    free nid bitmap, and stat used mem including aligned part.
    
    Signed-off-by: Yunlei He <heyunlei@huawei.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index aa5db8b5521a..f70f8ac9c4f4 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -304,11 +304,6 @@ struct f2fs_node {
  * For NAT entries
  */
 #define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))
-#define NAT_ENTRY_BITMAP_SIZE	((NAT_ENTRY_PER_BLOCK + 7) / 8)
-#define NAT_ENTRY_BITMAP_SIZE_ALIGNED				\
-	((NAT_ENTRY_BITMAP_SIZE + BITS_PER_LONG - 1) /		\
-	BITS_PER_LONG * BITS_PER_LONG)
-
 
 struct f2fs_nat_entry {
 	__u8 version;		/* latest version of cached nat entry */

commit bb1105e479fbb8b0edc6f35affec71b75e31c8c0
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri Mar 9 17:42:28 2018 -0800

    f2fs: align memory boundary for bitops
    
    For example, in arm64, free_nid_bitmap should be aligned to word size in order
    to use bit operations.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 124787e8db58..aa5db8b5521a 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -305,6 +305,10 @@ struct f2fs_node {
  */
 #define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))
 #define NAT_ENTRY_BITMAP_SIZE	((NAT_ENTRY_PER_BLOCK + 7) / 8)
+#define NAT_ENTRY_BITMAP_SIZE_ALIGNED				\
+	((NAT_ENTRY_BITMAP_SIZE + BITS_PER_LONG - 1) /		\
+	BITS_PER_LONG * BITS_PER_LONG)
+
 
 struct f2fs_nat_entry {
 	__u8 version;		/* latest version of cached nat entry */

commit 63189b785960c3346d1af347516b7438f7ada8ec
Author: Chao Yu <yuchao0@huawei.com>
Date:   Thu Mar 8 14:22:56 2018 +0800

    f2fs: wrap all options with f2fs_sb_info.mount_opt
    
    This patch merges miscellaneous mount options into struct f2fs_mount_info,
    After this patch, once we add new mount option, we don't need to worry
    about recovery of it in remount_fs(), since we will recover the
    f2fs_sb_info.mount_opt including all options.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index b06ab1f04ff6..124787e8db58 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -39,10 +39,10 @@
 
 #define F2FS_MAX_QUOTAS		3
 
-#define F2FS_IO_SIZE(sbi)	(1 << (sbi)->write_io_size_bits) /* Blocks */
-#define F2FS_IO_SIZE_KB(sbi)	(1 << ((sbi)->write_io_size_bits + 2)) /* KB */
-#define F2FS_IO_SIZE_BYTES(sbi)	(1 << ((sbi)->write_io_size_bits + 12)) /* B */
-#define F2FS_IO_SIZE_BITS(sbi)	((sbi)->write_io_size_bits) /* power of 2 */
+#define F2FS_IO_SIZE(sbi)	(1 << F2FS_OPTION(sbi).write_io_size_bits) /* Blocks */
+#define F2FS_IO_SIZE_KB(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 2)) /* KB */
+#define F2FS_IO_SIZE_BYTES(sbi)	(1 << (F2FS_OPTION(sbi).write_io_size_bits + 12)) /* B */
+#define F2FS_IO_SIZE_BITS(sbi)	(F2FS_OPTION(sbi).write_io_size_bits) /* power of 2 */
 #define F2FS_IO_SIZE_MASK(sbi)	(F2FS_IO_SIZE(sbi) - 1)
 
 /* This flag is used by node and meta inodes, and by recovery */

commit b6a06cbbb5f7fd03589cff9178314af04c568826
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Feb 28 17:07:27 2018 +0800

    f2fs: support hot file extension
    
    This patch supports to recognize hot file extension in f2fs, so that we
    can allocate proper hot segment location for its data, which can lead to
    better hot/cold seperation in filesystem.
    
    In addition, we changes a bit on query/add/del operation method for
    extension_list sysfs entry as below:
    
    - Query: cat /sys/fs/f2fs/<disk>/extension_list
    - Add: echo 'extension' > /sys/fs/f2fs/<disk>/extension_list
    - Del: echo '!extension' > /sys/fs/f2fs/<disk>/extension_list
    - Add: echo '[h/c]extension' > /sys/fs/f2fs/<disk>/extension_list
    - Del: echo '[h/c]!extension' > /sys/fs/f2fs/<disk>/extension_list
    - [h] means add/del hot file extension
    - [c] means add/del cold file extension
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index d8c241451712..b06ab1f04ff6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -111,7 +111,8 @@ struct f2fs_super_block {
 	__u8 encrypt_pw_salt[16];	/* Salt used for string2key algorithm */
 	struct f2fs_device devs[MAX_DEVICES];	/* device list */
 	__le32 qf_ino[F2FS_MAX_QUOTAS];	/* quota inode numbers */
-	__u8 reserved[315];		/* valid reserved region */
+	__u8 hot_ext_count;		/* # of hot file extension */
+	__u8 reserved[314];		/* valid reserved region */
 } __packed;
 
 /*

commit 846ae671ad368e344a2b141c0f19e1014b27a0dd
Author: Chao Yu <yuchao0@huawei.com>
Date:   Mon Feb 26 22:04:13 2018 +0800

    f2fs: expose extension_list sysfs entry
    
    This patch adds a sysfs entry 'extension_list' to support
    query/add/del item in extension list.
    
    Query:
    cat /sys/fs/f2fs/<device>/extension_list
    
    Add:
    echo 'extension' > /sys/fs/f2fs/<device>/extension_list
    
    Del:
    echo '!extension' > /sys/fs/f2fs/<device>/extension_list
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 96c9bdbace50..d8c241451712 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -21,6 +21,7 @@
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
 #define F2FS_BLKSIZE_BITS		12	/* bits for F2FS_BLKSIZE */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
+#define F2FS_EXTENSION_LEN		8	/* max size of extension */
 #define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) >> F2FS_BLKSIZE_BITS)
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
@@ -101,7 +102,7 @@ struct f2fs_super_block {
 	__u8 uuid[16];			/* 128-bit uuid for volume */
 	__le16 volume_name[MAX_VOLUME_NAME];	/* volume name */
 	__le32 extension_count;		/* # of extensions below */
-	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
+	__u8 extension_list[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN];/* extension array */
 	__le32 cp_payload;
 	__u8 version[VERSION_LEN];	/* the kernel version */
 	__u8 init_version[VERSION_LEN];	/* the initial kernel version */

commit 199bc3fef29cacf672e7e5cd49d296c1fdc1a891
Author: Chao Yu <yuchao0@huawei.com>
Date:   Thu Jan 25 19:40:08 2018 +0800

    f2fs: support large nat bitmap
    
    Previously, we will store all nat version bitmap in checkpoint pack block,
    so our total node entry number has a limitation which caused total node
    number can not exceed (3900 * 8) block * 455 node/block = 14196000. So
    that once user wants to create more nodes in large size image, it becomes
    a bottleneck, that's unreasonable.
    
    This patch detects the new layout of nat/sit version bitmap in image in
    order to enable supporting large nat bitmap.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 393b880afc9a..96c9bdbace50 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -116,6 +116,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_LARGE_NAT_BITMAP_FLAG	0x00000400
 #define CP_NOCRC_RECOVERY_FLAG	0x00000200
 #define CP_TRIMMED_FLAG		0x00000100
 #define CP_NAT_BITS_FLAG	0x00000080

commit bdbc90fa55af632f8a883a3d93c54a08708ed80a
Author: Yunlong Song <yunlong.song@huawei.com>
Date:   Wed Feb 28 20:31:52 2018 +0800

    f2fs: don't put dentry page in pagecache into highmem
    
    Previous dentry page uses highmem, which will cause panic in platforms
    using highmem (such as arm), since the address space of dentry pages
    from highmem directly goes into the decryption path via the function
    fscrypt_fname_disk_to_usr. But sg_init_one assumes the address is not
    from highmem, and then cause panic since it doesn't call kmap_high but
    kunmap_high is triggered at the end. To fix this problem in a simple
    way, this patch avoids to put dentry page in pagecache into highmem.
    
    Signed-off-by: Yunlong Song <yunlong.song@huawei.com>
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    [Jaegeuk Kim: fix coding style]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 58aecb60ea51..393b880afc9a 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -46,7 +46,6 @@
 
 /* This flag is used by node and meta inodes, and by recovery */
 #define GFP_F2FS_ZERO		(GFP_NOFS | __GFP_ZERO)
-#define GFP_F2FS_HIGH_ZERO	(GFP_NOFS | __GFP_ZERO | __GFP_HIGHMEM)
 
 /*
  * For further optimization on multi-head logs, on-disk layout supports maximum

commit 1c1d35df71104c76a4a2e25862926f22c334c9d6
Author: Chao Yu <yuchao0@huawei.com>
Date:   Thu Jan 25 14:54:42 2018 +0800

    f2fs: support inode creation time
    
    This patch adds creation time field in inode layout to support showing
    kstat.btime in ->statx.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 6eed677b6d9a..58aecb60ea51 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -253,8 +253,10 @@ struct f2fs_inode {
 			__le16 i_inline_xattr_size;	/* inline xattr size, unit: 4 bytes */
 			__le32 i_projid;	/* project id */
 			__le32 i_inode_checksum;/* inode meta checksum */
+			__le64 i_crtime;	/* creation time */
+			__le32 i_crtime_nsec;	/* creation time in nano scale */
 			__le32 i_extra_end[0];	/* for attribute size calculation */
-		};
+		} __packed;
 		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
 	};
 	__le32 i_nid[DEF_NIDS_PER_INODE];	/* direct(2), indirect(2),

commit f236792311f4575a1ca47240d3a74034096ef9e8
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri Jan 19 13:42:33 2018 -0800

    f2fs: allow to recover node blocks given updated checkpoint
    
    If fsck.f2fs changes crc, we have no way to recover some inode blocks by roll-
    forward recovery. Let's relax the condition to recover them.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index cfb522e6affc..6eed677b6d9a 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -117,6 +117,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_NOCRC_RECOVERY_FLAG	0x00000200
 #define CP_TRIMMED_FLAG		0x00000100
 #define CP_NAT_BITS_FLAG	0x00000080
 #define CP_CRC_RECOVERY_FLAG	0x00000040

commit 1ad71a27124caf0b68ddd3c92be01aa2b2a72b2a
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Dec 7 16:25:39 2017 -0800

    f2fs: add an ioctl to disable GC for specific file
    
    This patch gives a flag to disable GC on given file, which would be useful, when
    user wants to keep its block map. It also conducts in-place-update for dontmove
    file.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 43e98d30d2df..cfb522e6affc 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -212,6 +212,7 @@ struct f2fs_extent {
 #define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
 #define F2FS_INLINE_DOTS	0x10	/* file having implicit dot dentries */
 #define F2FS_EXTRA_ATTR		0x20	/* file having extra attribute */
+#define F2FS_PIN_FILE		0x40	/* file should not be gced */
 
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
@@ -229,7 +230,13 @@ struct f2fs_inode {
 	__le32 i_ctime_nsec;		/* change time in nano scale */
 	__le32 i_mtime_nsec;		/* modification time in nano scale */
 	__le32 i_generation;		/* file version (for NFS) */
-	__le32 i_current_depth;		/* only for directory depth */
+	union {
+		__le32 i_current_depth;	/* only for directory depth */
+		__le16 i_gc_failures;	/*
+					 * # of gc failures on pinned file.
+					 * only for regular files.
+					 */
+	};
 	__le32 i_xattr_nid;		/* nid to save xattr */
 	__le32 i_flags;			/* file attributes */
 	__le32 i_pino;			/* parent inode number */

commit ea6767337f86312ebe473585899a159bf50ef1b7
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri Oct 6 09:14:28 2017 -0700

    f2fs: support quota sys files
    
    This patch supports hidden quota files in the system, which will be used for
    Android. It requires up-to-date f2fs-tools later than v1.9.0.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index ce34007972c3..43e98d30d2df 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -36,7 +36,6 @@
 #define F2FS_NODE_INO(sbi)	((sbi)->node_ino_num)
 #define F2FS_META_INO(sbi)	((sbi)->meta_ino_num)
 
-#define F2FS_QUOTA_INO		3
 #define F2FS_MAX_QUOTAS		3
 
 #define F2FS_IO_SIZE(sbi)	(1 << (sbi)->write_io_size_bits) /* Blocks */

commit 234a9689614272d93271b308adbd303b59d266e3
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Oct 5 21:03:06 2017 -0700

    f2fs: add quota_ino feature infra
    
    This patch adds quota_ino feature infra to be used for quota files.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 50a8ee501bf1..ce34007972c3 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -36,6 +36,9 @@
 #define F2FS_NODE_INO(sbi)	((sbi)->node_ino_num)
 #define F2FS_META_INO(sbi)	((sbi)->meta_ino_num)
 
+#define F2FS_QUOTA_INO		3
+#define F2FS_MAX_QUOTAS		3
+
 #define F2FS_IO_SIZE(sbi)	(1 << (sbi)->write_io_size_bits) /* Blocks */
 #define F2FS_IO_SIZE_KB(sbi)	(1 << ((sbi)->write_io_size_bits + 2)) /* KB */
 #define F2FS_IO_SIZE_BYTES(sbi)	(1 << ((sbi)->write_io_size_bits + 12)) /* B */
@@ -108,7 +111,8 @@ struct f2fs_super_block {
 	__u8 encryption_level;		/* versioning level for encryption */
 	__u8 encrypt_pw_salt[16];	/* Salt used for string2key algorithm */
 	struct f2fs_device devs[MAX_DEVICES];	/* device list */
-	__u8 reserved[327];		/* valid reserved region */
+	__le32 qf_ino[F2FS_MAX_QUOTAS];	/* quota inode numbers */
+	__u8 reserved[315];		/* valid reserved region */
 } __packed;
 
 /*

commit 6afc662e68b5f988282ff20afd58a89b1c279dca
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Sep 6 21:59:50 2017 +0800

    f2fs: support flexible inline xattr size
    
    Now, in product, more and more features based on file encryption were
    introduced, their demand of xattr space is increasing, however, inline
    xattr has fixed-size of 200 bytes, once inline xattr space is full, new
    increased xattr data would occupy additional xattr block which may bring
    us more space usage and performance regression during persisting.
    
    In order to resolve above issue, it's better to expand inline xattr size
    flexibly according to user's requirement.
    
    So this patch introduces new filesystem feature 'flexible inline xattr',
    and new mount option 'inline_xattr_size=%u', once mkfs enables the
    feature, we can use the option to make f2fs supporting flexible inline
    xattr size.
    
    To support this feature, we add extra attribute i_inline_xattr_size in
    inode layout, indicating that how many space inline xattr borrows from
    block address mapping space in inode layout, by this, we can easily
    locate and store flexible-sized inline xattr data in inode.
    
    Inode disk layout:
      +----------------------+
      | .i_mode              |
      | ...                  |
      | .i_ext               |
      +----------------------+
      | .i_extra_isize       |
      | .i_inline_xattr_size |-----------+
      | ...                  |           |
      +----------------------+           |
      | .i_addr              |           |
      |  - block address or  |           |
      |  - inline data       |           |
      +----------------------+<---+      v
      |    inline xattr      |    +---inline xattr range
      +----------------------+<---+
      | .i_nid               |
      +----------------------+
      |   node_footer        |
      | (nid, ino, offset)   |
      +----------------------+
    
    Note that, we have to cnosider backward compatibility which reserved
    inline_data space, 200 bytes, all the time, reported by Sheng Yong.
    
    Previous inline data or directory always reserved 200 bytes in inode layout,
    even if inline_xattr is disabled. In order to keep inline_dentry's structure
    for backward compatibility, we get the space back only from inline_data.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Reported-by: Sheng Yong <shengyong1@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 2a0c453d7235..50a8ee501bf1 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -184,7 +184,8 @@ struct f2fs_extent {
 } __packed;
 
 #define F2FS_NAME_LEN		255
-#define F2FS_INLINE_XATTR_ADDRS	50	/* 200 bytes for inline xattrs */
+/* 200 bytes for inline xattrs by default */
+#define DEFAULT_INLINE_XATTR_ADDRS	50
 #define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
 #define CUR_ADDRS_PER_INODE(inode)	(DEF_ADDRS_PER_INODE - \
 					get_extra_isize(inode))
@@ -238,7 +239,7 @@ struct f2fs_inode {
 	union {
 		struct {
 			__le16 i_extra_isize;	/* extra inode attribute size */
-			__le16 i_padding;	/* padding */
+			__le16 i_inline_xattr_size;	/* inline xattr size, unit: 4 bytes */
 			__le32 i_projid;	/* project id */
 			__le32 i_inode_checksum;/* inode meta checksum */
 			__le32 i_extra_end[0];	/* for attribute size calculation */

commit 704956ecf5bcdc14d14650f39f2b545b34c96265
Author: Chao Yu <yuchao0@huawei.com>
Date:   Mon Jul 31 20:19:09 2017 +0800

    f2fs: support inode checksum
    
    This patch adds to support inode checksum in f2fs.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    [Jaegeuk Kim: fix verification flow]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 50f176683676..2a0c453d7235 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -240,6 +240,7 @@ struct f2fs_inode {
 			__le16 i_extra_isize;	/* extra inode attribute size */
 			__le16 i_padding;	/* padding */
 			__le32 i_projid;	/* project id */
+			__le32 i_inode_checksum;/* inode meta checksum */
 			__le32 i_extra_end[0];	/* for attribute size calculation */
 		};
 		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */

commit 5c57132eaf5265937e46340bfbfb97ffb078c423
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Jul 26 00:01:41 2017 +0800

    f2fs: support project quota
    
    This patch adds to support plain project quota.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 0c79ddd40b70..50f176683676 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -239,6 +239,7 @@ struct f2fs_inode {
 		struct {
 			__le16 i_extra_isize;	/* extra inode attribute size */
 			__le16 i_padding;	/* padding */
+			__le32 i_projid;	/* project id */
 			__le32 i_extra_end[0];	/* for attribute size calculation */
 		};
 		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
@@ -522,4 +523,6 @@ enum {
 
 #define S_SHIFT 12
 
+#define	F2FS_DEF_PROJID		0	/* default project ID */
+
 #endif  /* _LINUX_F2FS_FS_H */

commit 7a2af766af15887754f7f7a0869b4603b390876a
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Jul 19 00:19:06 2017 +0800

    f2fs: enhance on-disk inode structure scalability
    
    This patch add new flag F2FS_EXTRA_ATTR storing in inode.i_inline
    to indicate that on-disk structure of current inode is extended.
    
    In order to extend, we changed the inode structure a bit:
    
    Original one:
    
    struct f2fs_inode {
            ...
            struct f2fs_extent i_ext;
            __le32 i_addr[DEF_ADDRS_PER_INODE];
            __le32 i_nid[DEF_NIDS_PER_INODE];
    }
    
    Extended one:
    
    struct f2fs_inode {
            ...
            struct f2fs_extent i_ext;
            union {
                    struct {
                            __le16 i_extra_isize;
                            __le16 i_padding;
                            __le32 i_extra_end[0];
                    };
                    __le32 i_addr[DEF_ADDRS_PER_INODE];
            };
            __le32 i_nid[DEF_NIDS_PER_INODE];
    }
    
    Once F2FS_EXTRA_ATTR is set, we will steal four bytes in the head of
    i_addr field for storing i_extra_isize and i_padding. with i_extra_isize,
    we can calculate actual size of reserved space in i_addr, available
    attribute fields included in total extra attribute fields for current
    inode can be described as below:
    
      +--------------------+
      | .i_mode            |
      | ...                |
      | .i_ext             |
      +--------------------+
      | .i_extra_isize     |-----+
      | .i_padding         |     |
      | .i_prjid           |     |
      | .i_atime_extra     |     |
      | .i_ctime_extra     |     |
      | .i_mtime_extra     |<----+
      | .i_inode_cs        |<----- store blkaddr/inline from here
      | .i_xattr_cs        |
      | ...                |
      +--------------------+
      |                    |
      |    block address   |
      |                    |
      +--------------------+
      | .i_nid             |
      +--------------------+
      |   node_footer      |
      | (nid, ino, offset) |
      +--------------------+
    
    Hence, with this patch, we would enhance scalability of f2fs inode for
    storing more newly added attribute.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 060b1c5b0836..0c79ddd40b70 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -186,6 +186,8 @@ struct f2fs_extent {
 #define F2FS_NAME_LEN		255
 #define F2FS_INLINE_XATTR_ADDRS	50	/* 200 bytes for inline xattrs */
 #define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
+#define CUR_ADDRS_PER_INODE(inode)	(DEF_ADDRS_PER_INODE - \
+					get_extra_isize(inode))
 #define DEF_NIDS_PER_INODE	5	/* Node IDs in an Inode */
 #define ADDRS_PER_INODE(inode)	addrs_per_inode(inode)
 #define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
@@ -205,6 +207,7 @@ struct f2fs_extent {
 #define F2FS_INLINE_DENTRY	0x04	/* file inline dentry flag */
 #define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
 #define F2FS_INLINE_DOTS	0x10	/* file having implicit dot dentries */
+#define F2FS_EXTRA_ATTR		0x20	/* file having extra attribute */
 
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
@@ -232,8 +235,14 @@ struct f2fs_inode {
 
 	struct f2fs_extent i_ext;	/* caching a largest extent */
 
-	__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
-
+	union {
+		struct {
+			__le16 i_extra_isize;	/* extra inode attribute size */
+			__le16 i_padding;	/* padding */
+			__le32 i_extra_end[0];	/* for attribute size calculation */
+		};
+		__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
+	};
 	__le32 i_nid[DEF_NIDS_PER_INODE];	/* direct(2), indirect(2),
 						double_indirect(1) node id */
 } __packed;

commit f247037120ecd3dcbbc196b51ded8b57edf4904f
Author: Chao Yu <yuchao0@huawei.com>
Date:   Wed Jul 19 00:19:05 2017 +0800

    f2fs: make max inline size changeable
    
    This patch tries to make below macros calculating max inline size,
    inline dentry field size considerring reserving size-changeable
    space:
    - MAX_INLINE_DATA
    - NR_INLINE_DENTRY
    - INLINE_DENTRY_BITMAP_SIZE
    - INLINE_RESERVED_SIZE
    
    Then, when inline_{data,dentry} options is enabled, it allows us to
    reserve inline space with different size flexibly for adding newly
    introduced inode attribute.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index b6feed6547ce..060b1c5b0836 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -206,9 +206,6 @@ struct f2fs_extent {
 #define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
 #define F2FS_INLINE_DOTS	0x10	/* file having implicit dot dentries */
 
-#define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
-						F2FS_INLINE_XATTR_ADDRS - 1))
-
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
 	__u8 i_advise;			/* file hints */
@@ -465,7 +462,7 @@ typedef __le32	f2fs_hash_t;
 #define MAX_DIR_BUCKETS		(1 << ((MAX_DIR_HASH_DEPTH / 2) - 1))
 
 /*
- * space utilization of regular dentry and inline dentry
+ * space utilization of regular dentry and inline dentry (w/o extra reservation)
  *		regular dentry			inline dentry
  * bitmap	1 * 27 = 27			1 * 23 = 23
  * reserved	1 * 3 = 3			1 * 7 = 7
@@ -501,24 +498,6 @@ struct f2fs_dentry_block {
 	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];
 } __packed;
 
-/* for inline dir */
-#define NR_INLINE_DENTRY	(MAX_INLINE_DATA * BITS_PER_BYTE / \
-				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
-				BITS_PER_BYTE + 1))
-#define INLINE_DENTRY_BITMAP_SIZE	((NR_INLINE_DENTRY + \
-					BITS_PER_BYTE - 1) / BITS_PER_BYTE)
-#define INLINE_RESERVED_SIZE	(MAX_INLINE_DATA - \
-				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
-				NR_INLINE_DENTRY + INLINE_DENTRY_BITMAP_SIZE))
-
-/* inline directory entry structure */
-struct f2fs_inline_dentry {
-	__u8 dentry_bitmap[INLINE_DENTRY_BITMAP_SIZE];
-	__u8 reserved[INLINE_RESERVED_SIZE];
-	struct f2fs_dir_entry dentry[NR_INLINE_DENTRY];
-	__u8 filename[NR_INLINE_DENTRY][F2FS_SLOT_LEN];
-} __packed;
-
 /* file types used in inode_info->flags */
 enum {
 	F2FS_FT_UNKNOWN,

commit 1f43e2ad7bff54f7c82a084a57e5c90da0d3f4d9
Author: Chao Yu <yuchao0@huawei.com>
Date:   Fri Apr 28 13:56:08 2017 +0800

    f2fs: introduce CP_TRIMMED_FLAG to avoid unneeded discard
    
    Introduce CP_TRIMMED_FLAG to indicate all invalid block were trimmed
    before umount, so once we do mount with image which contain the flag,
    we don't record invalid blocks as undiscard one, when fstrim is being
    triggered, we can avoid issuing redundant discard commands.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 093549e10ee2..b6feed6547ce 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -114,6 +114,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_TRIMMED_FLAG		0x00000100
 #define CP_NAT_BITS_FLAG	0x00000080
 #define CP_CRC_RECOVERY_FLAG	0x00000040
 #define CP_FASTBOOT_FLAG	0x00000020

commit b9dd46188edc2f0d1f37328637860bb65a771124
Author: Jin Qian <jinqian@google.com>
Date:   Tue Apr 25 16:28:48 2017 -0700

    f2fs: sanity check segment count
    
    F2FS uses 4 bytes to represent block address. As a result, supported
    size of disk is 16 TB and it equals to 16 * 1024 * 1024 / 2 segments.
    
    Signed-off-by: Jin Qian <jinqian@google.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 639cbdf65e2b..093549e10ee2 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -301,6 +301,12 @@ struct f2fs_nat_block {
 #define SIT_VBLOCK_MAP_SIZE 64
 #define SIT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_sit_entry))
 
+/*
+ * F2FS uses 4 bytes to represent block address. As a result, supported size of
+ * disk is 16 TB and it equals to 16 * 1024 * 1024 / 2 segments.
+ */
+#define F2FS_MAX_SEGMENT       ((16 * 1024 * 1024) / 2)
+
 /*
  * Note that f2fs_sit_entry->vblocks has the following bit-field information.
  * [15:10] : allocation type such as CURSEG_XXXX_TYPE

commit 29fa6c567855eb92d21122162029c5709892106b
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Wed Apr 19 17:36:38 2017 -0700

    f2fs: add parentheses for macro variables more
    
    This patch adds parentheses for macro variables more in include/linux/f2fs_fs.h.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index e2d239ed4c60..639cbdf65e2b 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -32,9 +32,9 @@
 /* 0, 1(node nid), 2(meta nid) are reserved node id */
 #define F2FS_RESERVED_NODE_NUM		3
 
-#define F2FS_ROOT_INO(sbi)	(sbi->root_ino_num)
-#define F2FS_NODE_INO(sbi)	(sbi->node_ino_num)
-#define F2FS_META_INO(sbi)	(sbi->meta_ino_num)
+#define F2FS_ROOT_INO(sbi)	((sbi)->root_ino_num)
+#define F2FS_NODE_INO(sbi)	((sbi)->node_ino_num)
+#define F2FS_META_INO(sbi)	((sbi)->meta_ino_num)
 
 #define F2FS_IO_SIZE(sbi)	(1 << (sbi)->write_io_size_bits) /* Blocks */
 #define F2FS_IO_SIZE_KB(sbi)	(1 << ((sbi)->write_io_size_bits + 2)) /* KB */
@@ -161,7 +161,7 @@ struct f2fs_checkpoint {
  */
 #define F2FS_ORPHANS_PER_BLOCK	1020
 
-#define GET_ORPHAN_BLOCKS(n)	((n + F2FS_ORPHANS_PER_BLOCK - 1) / \
+#define GET_ORPHAN_BLOCKS(n)	(((n) + F2FS_ORPHANS_PER_BLOCK - 1) / \
 					F2FS_ORPHANS_PER_BLOCK)
 
 struct f2fs_orphan_block {
@@ -449,7 +449,7 @@ typedef __le32	f2fs_hash_t;
 #define F2FS_SLOT_LEN		8
 #define F2FS_SLOT_LEN_BITS	3
 
-#define GET_DENTRY_SLOTS(x)	((x + F2FS_SLOT_LEN - 1) >> F2FS_SLOT_LEN_BITS)
+#define GET_DENTRY_SLOTS(x) (((x) + F2FS_SLOT_LEN - 1) >> F2FS_SLOT_LEN_BITS)
 
 /* MAX level for dir lookup */
 #define MAX_DIR_HASH_DEPTH	63

commit 4ac912427c4214d8031d9ad6fbc3bc75e71512df
Author: Chao Yu <yuchao0@huawei.com>
Date:   Thu Feb 23 10:53:49 2017 +0800

    f2fs: introduce free nid bitmap
    
    In scenario of intensively node allocation, free nids will be ran out
    soon, then it needs to stop to load free nids by traversing NAT blocks,
    in worse case, if NAT blocks does not be cached in memory, it generates
    IOs which slows down our foreground operations.
    
    In order to speed up node allocation, in this patch we introduce a new
    free_nid_bitmap array, so there is an bitmap table for each NAT block,
    Once the NAT block is loaded, related bitmap cache will be switched on,
    and bitmap will be set during traversing nat entries in NAT block, later
    we can query and update nid usage status in memory completely.
    
    With such implementation, I expect performance of node allocation can be
    improved in the long-term after filesystem image is mounted.
    
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 1c92ace2e8f8..e2d239ed4c60 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -279,6 +279,7 @@ struct f2fs_node {
  * For NAT entries
  */
 #define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))
+#define NAT_ENTRY_BITMAP_SIZE	((NAT_ENTRY_PER_BLOCK + 7) / 8)
 
 struct f2fs_nat_entry {
 	__u8 version;		/* latest version of cached nat entry */

commit 22ad0b6ab46683975c6da032f1c2593066c7b3bd
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Feb 9 10:38:09 2017 -0800

    f2fs: add bitmaps for empty or full NAT blocks
    
    This patches adds bitmaps to represent empty or full NAT blocks containing
    free nid entries.
    
    If we can find valid crc|cp_ver in the last block of checkpoint pack, we'll
    use these bitmaps when building free nids. In order to avoid checkpointing
    burden, up-to-date bitmaps will be flushed only during umount time. So,
    normally we can get this gain, but when power-cut happens, we rely on fsck.f2fs
    which recovers this bitmap again.
    
    After this patch, we build free nids from nid #0 at mount time to make more
    full NAT blocks, but in runtime, we check empty NAT blocks to load free nids
    without loading any NAT pages from disk.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index f0748524ca8c..1c92ace2e8f8 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -114,6 +114,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_NAT_BITS_FLAG	0x00000080
 #define CP_CRC_RECOVERY_FLAG	0x00000040
 #define CP_FASTBOOT_FLAG	0x00000020
 #define CP_FSCK_FLAG		0x00000010

commit 0a595ebaaa6b53a2226d3fee2a2fd616ea5ba378
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Wed Dec 14 10:12:56 2016 -0800

    f2fs: support IO alignment for DATA and NODE writes
    
    This patch implements IO alignment by filling dummy blocks in DATA and NODE
    write bios. If we can guarantee, for example, 32KB or 64KB for such the IOs,
    we can eliminate underlying dummy page problem which FTL conducts in order to
    close MLC or TLC partial written pages.
    
    Note that,
     - it requires "-o mode=lfs".
     - IO size should be power of 2, not exceed BIO_MAX_PAGES, 256.
     - read IO is still 4KB.
     - do checkpoint at fsync, if dummy NODE page was written.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index cea41a124a80..f0748524ca8c 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -36,6 +36,12 @@
 #define F2FS_NODE_INO(sbi)	(sbi->node_ino_num)
 #define F2FS_META_INO(sbi)	(sbi->meta_ino_num)
 
+#define F2FS_IO_SIZE(sbi)	(1 << (sbi)->write_io_size_bits) /* Blocks */
+#define F2FS_IO_SIZE_KB(sbi)	(1 << ((sbi)->write_io_size_bits + 2)) /* KB */
+#define F2FS_IO_SIZE_BYTES(sbi)	(1 << ((sbi)->write_io_size_bits + 12)) /* B */
+#define F2FS_IO_SIZE_BITS(sbi)	((sbi)->write_io_size_bits) /* power of 2 */
+#define F2FS_IO_SIZE_MASK(sbi)	(F2FS_IO_SIZE(sbi) - 1)
+
 /* This flag is used by node and meta inodes, and by recovery */
 #define GFP_F2FS_ZERO		(GFP_NOFS | __GFP_ZERO)
 #define GFP_F2FS_HIGH_ZERO	(GFP_NOFS | __GFP_ZERO | __GFP_HIGHMEM)

commit 3c62be17d4f562f43fe1d03b48194399caa35aa5
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Oct 6 19:02:05 2016 -0700

    f2fs: support multiple devices
    
    This patch implements multiple devices support for f2fs.
    Given multiple devices by mkfs.f2fs, f2fs shows them entirely as one big
    volume under one f2fs instance.
    
    Internal block management is very simple, but we will modify block allocation
    and background GC policy to boost IO speed by exploiting them accoording to
    each device speed.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 422630b8e588..cea41a124a80 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -52,10 +52,17 @@
 
 #define VERSION_LEN	256
 #define MAX_VOLUME_NAME		512
+#define MAX_PATH_LEN		64
+#define MAX_DEVICES		8
 
 /*
  * For superblock
  */
+struct f2fs_device {
+	__u8 path[MAX_PATH_LEN];
+	__le32 total_segments;
+} __packed;
+
 struct f2fs_super_block {
 	__le32 magic;			/* Magic Number */
 	__le16 major_ver;		/* Major Version */
@@ -94,7 +101,8 @@ struct f2fs_super_block {
 	__le32 feature;			/* defined features */
 	__u8 encryption_level;		/* versioning level for encryption */
 	__u8 encrypt_pw_salt[16];	/* Salt used for string2key algorithm */
-	__u8 reserved[871];		/* valid reserved region */
+	struct f2fs_device devs[MAX_DEVICES];	/* device list */
+	__u8 reserved[327];		/* valid reserved region */
 } __packed;
 
 /*

commit a468f0ef516fda9c7d91bb550d458e853d76955e
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Sep 19 17:55:10 2016 -0700

    f2fs: use crc and cp version to determine roll-forward recovery
    
    Previously, we used cp_version only to detect recoverable dnodes.
    In order to avoid same garbage cp_version, we needed to truncate the next
    dnode during checkpoint, resulting in additional discard or data write.
    If we can distinguish this by using crc in addition to cp_version, we can
    remove this overhead.
    
    There is backward compatibility concern where it changes node_footer layout.
    So, this patch introduces a new checkpoint flag, CP_CRC_RECOVERY_FLAG, to
    detect new layout. New layout will be activated only when this flag is set.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 4c02c6521fef..422630b8e588 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -100,6 +100,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_CRC_RECOVERY_FLAG	0x00000040
 #define CP_FASTBOOT_FLAG	0x00000020
 #define CP_FSCK_FLAG		0x00000010
 #define CP_ERROR_FLAG		0x00000008

commit 675f10bde6cc3874632a8f684df2a8a2a8ace76e
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Mon Feb 22 18:29:18 2016 +0800

    f2fs: fix to convert inline directory correctly
    
    With below serials, we will lose parts of dirents:
    
    1) mount f2fs with inline_dentry option
    2) echo 1 > /sys/fs/f2fs/sdX/dir_level
    3) mkdir dir
    4) touch 180 files named [1-180] in dir
    5) touch 181 in dir
    6) echo 3 > /proc/sys/vm/drop_caches
    7) ll dir
    
    ls: cannot access 2: No such file or directory
    ls: cannot access 4: No such file or directory
    ls: cannot access 5: No such file or directory
    ls: cannot access 6: No such file or directory
    ls: cannot access 8: No such file or directory
    ls: cannot access 9: No such file or directory
    ...
    total 360
    drwxr-xr-x 2 root root 4096 Feb 19 15:12 ./
    drwxr-xr-x 3 root root 4096 Feb 19 15:11 ../
    -rw-r--r-- 1 root root    0 Feb 19 15:12 1
    -rw-r--r-- 1 root root    0 Feb 19 15:12 10
    -rw-r--r-- 1 root root    0 Feb 19 15:12 100
    -????????? ? ?    ?       ?            ? 101
    -????????? ? ?    ?       ?            ? 102
    -????????? ? ?    ?       ?            ? 103
    ...
    
    The reason is: when doing the inline dir conversion, we didn't consider
    that directory has hierarchical hash structure which can be configured
    through sysfs interface 'dir_level'.
    
    By default, dir_level of directory inode is 0, it means we have one bucket
    in hash table located in first level, all dirents will be hashed in this
    bucket, so it has no problem for us to do the duplication simply between
    inline dentry page and converted normal dentry page.
    
    However, if we configured dir_level with the value N (greater than 0), it
    will expand the bucket number of first level hash table by 2^N - 1, it
    hashs dirents into different buckets according their hash value, if we
    still move all dirents to first bucket, it makes incorrent locating for
    inline dirents, the result is, although we can iterate all dirents through
    ->readdir, we can't stat some of them in ->lookup which based on hash
    table searching.
    
    This patch fixes this issue by rehashing dirents into correct position
    when converting inline directory.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index b90e9bdbd1dd..4c02c6521fef 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -508,4 +508,6 @@ enum {
 	F2FS_FT_MAX
 };
 
+#define S_SHIFT 12
+
 #endif  /* _LINUX_F2FS_FS_H */

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 9eb215a155e0..b90e9bdbd1dd 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -262,7 +262,7 @@ struct f2fs_node {
 /*
  * For NAT entries
  */
-#define NAT_ENTRY_PER_BLOCK (PAGE_CACHE_SIZE / sizeof(struct f2fs_nat_entry))
+#define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))
 
 struct f2fs_nat_entry {
 	__u8 version;		/* latest version of cached nat entry */
@@ -282,7 +282,7 @@ struct f2fs_nat_block {
  * Not allow to change this.
  */
 #define SIT_VBLOCK_MAP_SIZE 64
-#define SIT_ENTRY_PER_BLOCK (PAGE_CACHE_SIZE / sizeof(struct f2fs_sit_entry))
+#define SIT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_sit_entry))
 
 /*
  * Note that f2fs_sit_entry->vblocks has the following bit-field information.

commit dfc08a12e49a64f97d8b474da1d7745230cec5eb
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Sun Feb 14 18:50:40 2016 +0800

    f2fs: introduce f2fs_journal struct to wrap journal info
    
    Introduce a new structure f2fs_journal to wrap journal info in struct
    f2fs_summary_block for readability.
    
    struct f2fs_journal {
            union {
                    __le16 n_nats;
                    __le16 n_sits;
            };
            union {
                    struct nat_journal nat_j;
                    struct sit_journal sit_j;
                    struct f2fs_extra_info info;
            };
    } __packed;
    
    struct f2fs_summary_block {
            struct f2fs_summary entries[ENTRIES_IN_SUM];
            struct f2fs_journal journal;
            struct summary_footer footer;
    } __packed;
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index f43e6a01a023..9eb215a155e0 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -398,9 +398,7 @@ struct f2fs_extra_info {
 	__u8 reserved[EXTRA_INFO_RESERVED];
 } __packed;
 
-/* 4KB-sized summary block structure */
-struct f2fs_summary_block {
-	struct f2fs_summary entries[ENTRIES_IN_SUM];
+struct f2fs_journal {
 	union {
 		__le16 n_nats;
 		__le16 n_sits;
@@ -411,6 +409,12 @@ struct f2fs_summary_block {
 		struct sit_journal sit_j;
 		struct f2fs_extra_info info;
 	};
+} __packed;
+
+/* 4KB-sized summary block structure */
+struct f2fs_summary_block {
+	struct f2fs_summary entries[ENTRIES_IN_SUM];
+	struct f2fs_journal journal;
 	struct summary_footer footer;
 } __packed;
 

commit 24b8491251cde66879e74092167cc0f27a1f11ce
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Wed Feb 3 13:49:44 2016 -0800

    f2fs: preallocate blocks for buffered aio writes
    
    This patch preallocates data blocks for buffered aio writes.
    With this patch, we can avoid redundant locking and unlocking of node pages
    given consecutive aio request.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index ac8040278f69..f43e6a01a023 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -21,7 +21,7 @@
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
 #define F2FS_BLKSIZE_BITS		12	/* bits for F2FS_BLKSIZE */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
-#define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) / F2FS_BLKSIZE)
+#define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) >> F2FS_BLKSIZE_BITS)
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */

commit 479c8bc40c51535bf496440aa1d6af26e4ff9362
Author: Sheng Yong <shengyong1@huawei.com>
Date:   Thu Jan 28 11:40:26 2016 +0000

    f2fs: fix endianness of on-disk summary_footer
    
    Signed-off-by: Sheng Yong <shengyong1@huawei.com>
    Reviewed-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 44ae822e154f..ac8040278f69 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -345,7 +345,7 @@ struct f2fs_summary {
 
 struct summary_footer {
 	unsigned char entry_type;	/* SUM_TYPE_XXX */
-	__u32 check_sum;		/* summary checksum */
+	__le32 check_sum;		/* summary checksum */
 } __packed;
 
 #define SUM_JOURNAL_SIZE	(F2FS_BLKSIZE - SUM_FOOTER_SIZE -\

commit 81ca7350ce5ed438547ea769b0c33cb0abbd74ba
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Tue Jan 26 15:39:35 2016 +0800

    f2fs: remove unneeded pointer conversion
    
    There are redundant pointer conversion in following call stack:
     - at position a, inode was been converted to f2fs_file_info.
     - at position b, f2fs_file_info was been converted to inode again.
    
     - truncate_blocks(inode,..)
      - fi = F2FS_I(inode)          ---a
      - ADDRS_PER_PAGE(node_page, fi)
       - addrs_per_inode(fi)
        - inode = &fi->vfs_inode    ---b
        - f2fs_has_inline_xattr(inode)
         - fi = F2FS_I(inode)
         - is_inode_flag_set(fi,..)
    
    In order to avoid unneeded conversion, alter ADDRS_PER_PAGE and
    addrs_per_inode to acept parameter with type of inode pointer.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 67aa01df777d..44ae822e154f 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -170,12 +170,12 @@ struct f2fs_extent {
 #define F2FS_INLINE_XATTR_ADDRS	50	/* 200 bytes for inline xattrs */
 #define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
 #define DEF_NIDS_PER_INODE	5	/* Node IDs in an Inode */
-#define ADDRS_PER_INODE(fi)	addrs_per_inode(fi)
+#define ADDRS_PER_INODE(inode)	addrs_per_inode(inode)
 #define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
 #define NIDS_PER_BLOCK		1018	/* Node IDs in an Indirect Block */
 
-#define ADDRS_PER_PAGE(page, fi)	\
-	(IS_INODE(page) ? ADDRS_PER_INODE(fi) : ADDRS_PER_BLOCK)
+#define ADDRS_PER_PAGE(page, inode)	\
+	(IS_INODE(page) ? ADDRS_PER_INODE(inode) : ADDRS_PER_BLOCK)
 
 #define	NODE_DIR1_BLOCK		(DEF_ADDRS_PER_INODE + 1)
 #define	NODE_DIR2_BLOCK		(DEF_ADDRS_PER_INODE + 2)

commit 8f1dbbbbdfe9bada7e2f8041e07c6373f787c043
Author: Shuoran Liu <liushuoran@huawei.com>
Date:   Wed Jan 27 09:57:30 2016 +0800

    f2fs: introduce lifetime write IO statistics
    
    This patch introduces lifetime IO write statistics exposed to the sysfs interface.
    The write IO amount is obtained from block layer, accumulated in the file system and
    stored in the hot node summary of checkpoint.
    
    Signed-off-by: Shuoran Liu <liushuoran@huawei.com>
    Signed-off-by: Pengyang Hou <houpengyang@huawei.com>
    [Jaegeuk Kim: add sysfs documentation]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index e59c3be92106..67aa01df777d 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -358,6 +358,12 @@ struct summary_footer {
 				sizeof(struct sit_journal_entry))
 #define SIT_JOURNAL_RESERVED	((SUM_JOURNAL_SIZE - 2) %\
 				sizeof(struct sit_journal_entry))
+
+/* Reserved area should make size of f2fs_extra_info equals to
+ * that of nat_journal and sit_journal.
+ */
+#define EXTRA_INFO_RESERVED	(SUM_JOURNAL_SIZE - 2 - 8)
+
 /*
  * frequently updated NAT/SIT entries can be stored in the spare area in
  * summary blocks
@@ -387,6 +393,11 @@ struct sit_journal {
 	__u8 reserved[SIT_JOURNAL_RESERVED];
 } __packed;
 
+struct f2fs_extra_info {
+	__le64 kbytes_written;
+	__u8 reserved[EXTRA_INFO_RESERVED];
+} __packed;
+
 /* 4KB-sized summary block structure */
 struct f2fs_summary_block {
 	struct f2fs_summary entries[ENTRIES_IN_SUM];
@@ -394,10 +405,11 @@ struct f2fs_summary_block {
 		__le16 n_nats;
 		__le16 n_sits;
 	};
-	/* spare area is used by NAT or SIT journals */
+	/* spare area is used by NAT or SIT journals or extra info */
 	union {
 		struct nat_journal nat_j;
 		struct sit_journal sit_j;
+		struct f2fs_extra_info info;
 	};
 	struct summary_footer footer;
 } __packed;

commit a11fac3776fc4db6a9fa1104b1d0477809c677e0
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Dec 14 18:58:42 2015 -0800

    f2fs: add symbol to avoid any confusion with tools
    
    This patch adds MAX_VOLUME_NAME to sync with f2fs-tools.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 25c6324a0dd0..e59c3be92106 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -51,6 +51,7 @@
 #define MAX_ACTIVE_DATA_LOGS	8
 
 #define VERSION_LEN	256
+#define MAX_VOLUME_NAME		512
 
 /*
  * For superblock
@@ -84,7 +85,7 @@ struct f2fs_super_block {
 	__le32 node_ino;		/* node inode number */
 	__le32 meta_ino;		/* meta inode number */
 	__u8 uuid[16];			/* 128-bit uuid for volume */
-	__le16 volume_name[512];	/* volume name */
+	__le16 volume_name[MAX_VOLUME_NAME];	/* volume name */
 	__le32 extension_count;		/* # of extensions below */
 	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
 	__le32 cp_payload;

commit c031f6a904975d5fa84c541333cce444a21ca713
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Wed Aug 19 19:02:02 2015 +0800

    f2fs: add annotation for space utilization of regular/inline dentry
    
    Add annotation to let us know more clearly about space utilization
    information of regular dentry and inline dentry.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 920408a21ffd..25c6324a0dd0 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -417,15 +417,25 @@ typedef __le32	f2fs_hash_t;
 
 #define GET_DENTRY_SLOTS(x)	((x + F2FS_SLOT_LEN - 1) >> F2FS_SLOT_LEN_BITS)
 
-/* the number of dentry in a block */
-#define NR_DENTRY_IN_BLOCK	214
-
 /* MAX level for dir lookup */
 #define MAX_DIR_HASH_DEPTH	63
 
 /* MAX buckets in one level of dir */
 #define MAX_DIR_BUCKETS		(1 << ((MAX_DIR_HASH_DEPTH / 2) - 1))
 
+/*
+ * space utilization of regular dentry and inline dentry
+ *		regular dentry			inline dentry
+ * bitmap	1 * 27 = 27			1 * 23 = 23
+ * reserved	1 * 3 = 3			1 * 7 = 7
+ * dentry	11 * 214 = 2354			11 * 182 = 2002
+ * filename	8 * 214 = 1712			8 * 182 = 1456
+ * total	4096				3488
+ *
+ * Note: there are more reserved space in inline dentry than in regular
+ * dentry, when converting inline dentry we should handle this carefully.
+ */
+#define NR_DENTRY_IN_BLOCK	214	/* the number of dentry in a block */
 #define SIZE_OF_DIR_ENTRY	11	/* by byte */
 #define SIZE_OF_DENTRY_BITMAP	((NR_DENTRY_IN_BLOCK + BITS_PER_BYTE - 1) / \
 					BITS_PER_BYTE)

commit cde4de1205770514005663d70a9a7d81cb555085
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Apr 20 13:57:51 2015 -0700

    f2fs crypto: declare some definitions for f2fs encryption feature
    
    This definitions will be used by inode and superblock for encyption.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index d44e97f2b98e..920408a21ffd 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -91,7 +91,9 @@ struct f2fs_super_block {
 	__u8 version[VERSION_LEN];	/* the kernel version */
 	__u8 init_version[VERSION_LEN];	/* the initial kernel version */
 	__le32 feature;			/* defined features */
-	__u8 reserved[888];		/* valid reserved region */
+	__u8 encryption_level;		/* versioning level for encryption */
+	__u8 encrypt_pw_salt[16];	/* Salt used for string2key algorithm */
+	__u8 reserved[871];		/* valid reserved region */
 } __packed;
 
 /*

commit 76f105a2dbcd47509bac6ba8d94cb3759a3e6e9d
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Apr 13 15:10:36 2015 -0700

    f2fs: add feature facility in superblock
    
    This patch introduces a feature in superblock, which will indicate any new
    features for f2fs.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 8d345c24bcf7..d44e97f2b98e 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -90,7 +90,8 @@ struct f2fs_super_block {
 	__le32 cp_payload;
 	__u8 version[VERSION_LEN];	/* the kernel version */
 	__u8 init_version[VERSION_LEN];	/* the initial kernel version */
-	__u8 reserved[892];		/* valid reserved region */
+	__le32 feature;			/* defined features */
+	__u8 reserved[888];		/* valid reserved region */
 } __packed;
 
 /*

commit 0040b933187b11f78e83dd162a31d64a46be4e37
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Apr 20 11:52:23 2015 -0700

    f2fs: add missing version info in superblock
    
    The mkfs.f2fs remains kernel version in superblock, but f2fs module has not
    added that so far.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 591f8c3ef410..8d345c24bcf7 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -50,6 +50,8 @@
 #define MAX_ACTIVE_NODE_LOGS	8
 #define MAX_ACTIVE_DATA_LOGS	8
 
+#define VERSION_LEN	256
+
 /*
  * For superblock
  */
@@ -86,6 +88,9 @@ struct f2fs_super_block {
 	__le32 extension_count;		/* # of extensions below */
 	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
 	__le32 cp_payload;
+	__u8 version[VERSION_LEN];	/* the kernel version */
+	__u8 init_version[VERSION_LEN];	/* the initial kernel version */
+	__u8 reserved[892];		/* valid reserved region */
 } __packed;
 
 /*

commit 510022a85839a8409d1e6a519bb86ce71a84f30a
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Mar 30 15:07:16 2015 -0700

    f2fs: add F2FS_INLINE_DOTS to recover missing dot dentries
    
    If f2fs was corrupted with missing dot dentries, it needs to recover them after
    fsck.f2fs detection.
    
    The underlying precedure is:
    
    1. The fsck.f2fs remains F2FS_INLINE_DOTS flag in directory inode, if it detects
    missing dot dentries.
    
    2. When f2fs looks up the corrupted directory, it triggers f2fs_add_link with
    proper inode numbers and their dot and dotdot names.
    
    3. Once f2fs recovers the directory without errors, it removes F2FS_INLINE_DOTS
    finally.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 502f28cfb78e..591f8c3ef410 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -178,6 +178,7 @@ struct f2fs_extent {
 #define F2FS_INLINE_DATA	0x02	/* file inline data flag */
 #define F2FS_INLINE_DENTRY	0x04	/* file inline dentry flag */
 #define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
+#define F2FS_INLINE_DOTS	0x10	/* file having implicit dot dentries */
 
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))

commit 4d0b0bd4385f0ce8d3b430f9667c5e2ca1de10af
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Thu Feb 5 17:47:25 2015 +0800

    f2fs: simplfy a field name in struct f2fs_extent,extent_info
    
    Rename a filed name from 'blk_addr' to 'blk' in struct {f2fs_extent,extent_info}
    as annotation of this field descripts its meaning well to us.
    
    By this way, we can avoid long statement in code of following patches.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index a23556c32703..502f28cfb78e 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -153,7 +153,7 @@ struct f2fs_orphan_block {
  */
 struct f2fs_extent {
 	__le32 fofs;		/* start file offset of the extent */
-	__le32 blk_addr;	/* start block address of the extent */
+	__le32 blk;		/* start block address of the extent */
 	__le32 len;		/* lengh of the extent */
 } __packed;
 

commit f7ef9b83b583640111039b30e13263b71c3a6ed5
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Mon Feb 9 12:02:44 2015 -0800

    f2fs: introduce macros to convert bytes and blocks in f2fs
    
    This patch adds two macros for transition between byte and block offsets.
    Currently, f2fs only supports 4KB blocks, so use the default size for now.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 09805720f4bf..a23556c32703 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -19,12 +19,16 @@
 #define F2FS_MAX_LOG_SECTOR_SIZE	12	/* 12 bits for 4096 bytes */
 #define F2FS_LOG_SECTORS_PER_BLOCK	3	/* log number for sector/blk */
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
+#define F2FS_BLKSIZE_BITS		12	/* bits for F2FS_BLKSIZE */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
 #define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) / F2FS_BLKSIZE)
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
 
+#define F2FS_BYTES_TO_BLK(bytes)	((bytes) >> F2FS_BLKSIZE_BITS)
+#define F2FS_BLK_TO_BYTES(blk)		((blk) << F2FS_BLKSIZE_BITS)
+
 /* 0, 1(node nid), 2(meta nid) are reserved node id */
 #define F2FS_RESERVED_NODE_NUM		3
 

commit 119ee9144534141822462e3e8a5ccc8dc537f712
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Jan 29 11:45:33 2015 -0800

    f2fs: split UMOUNT and FASTBOOT flags
    
    This patch adds FASTBOOT flag into checkpoint as follows.
    
     - CP_UMOUNT_FLAG is set when system is umounted.
     - CP_FASTBOOT_FLAG is set when intermediate checkpoint having node summaries
       was done.
    
    So, if you get CP_UMOUNT_FLAG from checkpoint, the system was umounted cleanly.
    Instead, if there was sudden-power-off, you can get CP_FASTBOOT_FLAG or nothing.
    
    Reviewed-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index e993b0bc9abf..09805720f4bf 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -87,6 +87,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_FASTBOOT_FLAG	0x00000020
 #define CP_FSCK_FLAG		0x00000010
 #define CP_ERROR_FLAG		0x00000008
 #define CP_COMPACT_SUM_FLAG	0x00000004

commit 09eb483e895f36fd002e88c878e9578c359aa468
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Tue Dec 23 16:26:31 2014 -0800

    f2fs: fix missing cold bit during recovery
    
    In do_recover_data, we find and update previous node pages after updating
    its new block addresses.
    After then, we call fill_node_footer without reset field, we erase its
    cold bit so that this new cold node block is written to wrong log area.
    This patch fixes not to miss its old flag.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 87f14e90e984..e993b0bc9abf 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -224,6 +224,8 @@ enum {
 	OFFSET_BIT_SHIFT
 };
 
+#define OFFSET_BIT_MASK		(0x07)	/* (0x01 << OFFSET_BIT_SHIFT) - 1 */
+
 struct node_footer {
 	__le32 nid;		/* node id */
 	__le32 ino;		/* inode nunmber */

commit be138b7b0d4cbfb8a927d9bc333ceffee9908c23
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Oct 30 19:01:10 2014 -0700

    f2fs: remove unnecessary macro
    
    Let's remove unused macro.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index cc1064f3153f..87f14e90e984 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -177,10 +177,6 @@ struct f2fs_extent {
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))
 
-#define INLINE_DATA_OFFSET	(PAGE_CACHE_SIZE - sizeof(struct node_footer) -\
-				sizeof(__le32) * (DEF_ADDRS_PER_INODE + \
-				DEF_NIDS_PER_INODE - 1))
-
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
 	__u8 i_advise;			/* file hints */

commit b3d208f96d6bb21247108a956dead6a028d5cdb2
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Thu Oct 23 19:48:09 2014 -0700

    f2fs: revisit inline_data to avoid data races and potential bugs
    
    This patch simplifies the inline_data usage with the following rule.
    1. inline_data is set during the file creation.
    2. If new data is requested to be written ranges out of inline_data,
     f2fs converts that inode permanently.
    3. There is no cases which converts non-inline_data inode to inline_data.
    4. The inline_data flag should be changed under inode page lock.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 63f8303b79ba..cc1064f3153f 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -172,6 +172,7 @@ struct f2fs_extent {
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
 #define F2FS_INLINE_DATA	0x02	/* file inline data flag */
 #define F2FS_INLINE_DENTRY	0x04	/* file inline dentry flag */
+#define F2FS_DATA_EXIST		0x08	/* file inline data exist flag */
 
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))

commit 34d67debe02b3b2b035b5bdce0fab75800f9a344
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Wed Sep 24 18:15:19 2014 +0800

    f2fs: add infra struct and helper for inline dir
    
    This patch defines macro/inline dentry structure, and adds some helpers for
    inline dir infrastructure.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 6d7381b41304..63f8303b79ba 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -171,6 +171,7 @@ struct f2fs_extent {
 
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
 #define F2FS_INLINE_DATA	0x02	/* file inline data flag */
+#define F2FS_INLINE_DENTRY	0x04	/* file inline dentry flag */
 
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))
@@ -436,6 +437,24 @@ struct f2fs_dentry_block {
 	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];
 } __packed;
 
+/* for inline dir */
+#define NR_INLINE_DENTRY	(MAX_INLINE_DATA * BITS_PER_BYTE / \
+				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
+				BITS_PER_BYTE + 1))
+#define INLINE_DENTRY_BITMAP_SIZE	((NR_INLINE_DENTRY + \
+					BITS_PER_BYTE - 1) / BITS_PER_BYTE)
+#define INLINE_RESERVED_SIZE	(MAX_INLINE_DATA - \
+				((SIZE_OF_DIR_ENTRY + F2FS_SLOT_LEN) * \
+				NR_INLINE_DENTRY + INLINE_DENTRY_BITMAP_SIZE))
+
+/* inline directory entry structure */
+struct f2fs_inline_dentry {
+	__u8 dentry_bitmap[INLINE_DENTRY_BITMAP_SIZE];
+	__u8 reserved[INLINE_RESERVED_SIZE];
+	struct f2fs_dir_entry dentry[NR_INLINE_DENTRY];
+	__u8 filename[NR_INLINE_DENTRY][F2FS_SLOT_LEN];
+} __packed;
+
 /* file types used in inode_info->flags */
 enum {
 	F2FS_FT_UNKNOWN,

commit a78186ebe516b6d7df43636603f0998803ab356a
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri Oct 17 17:57:29 2014 -0700

    f2fs: use highmem for directory pages
    
    This patch fixes to use highmem for directory pages.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 860313a33a43..6d7381b41304 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -33,7 +33,8 @@
 #define F2FS_META_INO(sbi)	(sbi->meta_ino_num)
 
 /* This flag is used by node and meta inodes, and by recovery */
-#define GFP_F2FS_ZERO	(GFP_NOFS | __GFP_ZERO)
+#define GFP_F2FS_ZERO		(GFP_NOFS | __GFP_ZERO)
+#define GFP_F2FS_HIGH_ZERO	(GFP_NOFS | __GFP_ZERO | __GFP_HIGHMEM)
 
 /*
  * For further optimization on multi-head logs, on-disk layout supports maximum

commit 55cf9cb63f0e5439f208d78ed944de9a8df65011
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Mon Sep 15 18:01:10 2014 +0800

    f2fs: support large sector size
    
    Block size in f2fs is 4096 bytes, so theoretically, f2fs can support 4096 bytes
    sector device at maximum. But now f2fs only support 512 bytes size sector, so
    block device such as zRAM which uses page cache as its block storage space will
    not be mounted successfully as mismatch between sector size of zRAM and sector
    size of f2fs supported.
    
    In this patch we support large sector size in f2fs, so block device with sector
    size of 512/1024/2048/4096 bytes can be supported in f2fs.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 9ca1ff3d4662..860313a33a43 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -15,8 +15,9 @@
 #include <linux/types.h>
 
 #define F2FS_SUPER_OFFSET		1024	/* byte-size offset */
-#define F2FS_LOG_SECTOR_SIZE		9	/* 9 bits for 512 byte */
-#define F2FS_LOG_SECTORS_PER_BLOCK	3	/* 4KB: F2FS_BLKSIZE */
+#define F2FS_MIN_LOG_SECTOR_SIZE	9	/* 9 bits for 512 bytes */
+#define F2FS_MAX_LOG_SECTOR_SIZE	12	/* 12 bits for 4096 bytes */
+#define F2FS_LOG_SECTORS_PER_BLOCK	3	/* log number for sector/blk */
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
 #define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) / F2FS_BLKSIZE)

commit 2ae4c673e3cbd69bc2decf6d7f5961f3c7b9b38b
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Tue Sep 2 15:43:52 2014 -0700

    f2fs: retain inconsistency information to initiate fsck.f2fs
    
    This patch adds sbi->need_fsck to conduct fsck.f2fs later.
    This flag can only be removed by fsck.f2fs.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 08ed2b0a96e6..9ca1ff3d4662 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -85,6 +85,7 @@ struct f2fs_super_block {
 /*
  * For checkpoint
  */
+#define CP_FSCK_FLAG		0x00000010
 #define CP_ERROR_FLAG		0x00000008
 #define CP_COMPACT_SUM_FLAG	0x00000004
 #define CP_ORPHAN_PRESENT_FLAG	0x00000002

commit b5b822050ca3c4fc1f475100cc197cc00ba2d492
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Fri Aug 22 16:17:38 2014 +0800

    f2fs: use macro for code readability
    
    This patch introduces DEF_NIDS_PER_INODE/GET_ORPHAN_BLOCKS/F2FS_CP_PACKS macro
    instead of numbers in code for readability.
    
    change log from v1:
     o fix typo pointed out by Jaegeuk Kim.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 0ed77f32c9ac..08ed2b0a96e6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -90,6 +90,8 @@ struct f2fs_super_block {
 #define CP_ORPHAN_PRESENT_FLAG	0x00000002
 #define CP_UMOUNT_FLAG		0x00000001
 
+#define F2FS_CP_PACKS		2	/* # of checkpoint packs */
+
 struct f2fs_checkpoint {
 	__le64 checkpoint_ver;		/* checkpoint block version number */
 	__le64 user_block_count;	/* # of user blocks */
@@ -126,6 +128,9 @@ struct f2fs_checkpoint {
  */
 #define F2FS_ORPHANS_PER_BLOCK	1020
 
+#define GET_ORPHAN_BLOCKS(n)	((n + F2FS_ORPHANS_PER_BLOCK - 1) / \
+					F2FS_ORPHANS_PER_BLOCK)
+
 struct f2fs_orphan_block {
 	__le32 ino[F2FS_ORPHANS_PER_BLOCK];	/* inode numbers */
 	__le32 reserved;	/* reserved */
@@ -147,6 +152,7 @@ struct f2fs_extent {
 #define F2FS_NAME_LEN		255
 #define F2FS_INLINE_XATTR_ADDRS	50	/* 200 bytes for inline xattrs */
 #define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
+#define DEF_NIDS_PER_INODE	5	/* Node IDs in an Inode */
 #define ADDRS_PER_INODE(fi)	addrs_per_inode(fi)
 #define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
 #define NIDS_PER_BLOCK		1018	/* Node IDs in an Indirect Block */
@@ -166,8 +172,9 @@ struct f2fs_extent {
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))
 
-#define INLINE_DATA_OFFSET	(PAGE_CACHE_SIZE - sizeof(struct node_footer) \
-			- sizeof(__le32) * (DEF_ADDRS_PER_INODE + 5 - 1))
+#define INLINE_DATA_OFFSET	(PAGE_CACHE_SIZE - sizeof(struct node_footer) -\
+				sizeof(__le32) * (DEF_ADDRS_PER_INODE + \
+				DEF_NIDS_PER_INODE - 1))
 
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
@@ -197,7 +204,7 @@ struct f2fs_inode {
 
 	__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
 
-	__le32 i_nid[5];		/* direct(2), indirect(2),
+	__le32 i_nid[DEF_NIDS_PER_INODE];	/* direct(2), indirect(2),
 						double_indirect(1) node id */
 } __packed;
 

commit c200b1aa6cb460ce8c3ecf6fdc690d3949c3cc5d
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Wed Aug 20 18:36:46 2014 +0800

    f2fs: fix incorrect calculation with total/free inode num
    
    Theoretically, our total inodes number is the same as total node number, but
    there are three node ids are reserved in f2fs, they are 0, 1 (node nid), and 2
    (meta nid), and they should never be used by user, so our total/free inode
    number calculated in ->statfs is wrong.
    
    This patch indroduces F2FS_RESERVED_NODE_NUM and then fixes this issue by
    recalculating total/free inode number with the macro.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 6ff0b0b42d47..0ed77f32c9ac 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -24,6 +24,9 @@
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
 
+/* 0, 1(node nid), 2(meta nid) are reserved node id */
+#define F2FS_RESERVED_NODE_NUM		3
+
 #define F2FS_ROOT_INO(sbi)	(sbi->root_ino_num)
 #define F2FS_NODE_INO(sbi)	(sbi->node_ino_num)
 #define F2FS_META_INO(sbi)	(sbi->meta_ino_num)

commit 1dbe4152168d44fa164edbdc9f1243de70b98f7a
Author: Changman Lee <cm224.lee@samsung.com>
Date:   Mon May 12 12:27:43 2014 +0900

    f2fs: large volume support
    
    f2fs's cp has one page which consists of struct f2fs_checkpoint and
    version bitmap of sit and nat. To support lots of segments, we need more
    blocks for sit bitmap. So let's arrange sit bitmap as following:
    +-----------------+------------+
    | f2fs_checkpoint | sit bitmap |
    | + nat bitmap    |            |
    +-----------------+------------+
    0                 4k        N blocks
    
    Signed-off-by: Changman Lee <cm224.lee@samsung.com>
    [Jaegeuk Kim: simple code change for readability]
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index ba6f3127738f..6ff0b0b42d47 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -19,6 +19,7 @@
 #define F2FS_LOG_SECTORS_PER_BLOCK	3	/* 4KB: F2FS_BLKSIZE */
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
+#define F2FS_BLK_ALIGN(x)	(((x) + F2FS_BLKSIZE - 1) / F2FS_BLKSIZE)
 
 #define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
 #define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
@@ -75,6 +76,7 @@ struct f2fs_super_block {
 	__le16 volume_name[512];	/* volume name */
 	__le32 extension_count;		/* # of extensions below */
 	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
+	__le32 cp_payload;
 } __packed;
 
 /*

commit bfec07d0f8ed78b10df3ca3bc23e27de1166ea45
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Wed May 28 08:56:09 2014 +0800

    f2fs: avoid overflow when large directory feathure is enabled
    
    When large directory feathure is enable, We have one case which could cause
    overflow in dir_buckets() as following:
    special case: level + dir_level >= 32 and level < MAX_DIR_HASH_DEPTH / 2.
    
    Here we define MAX_DIR_BUCKETS to limit the return value when the condition
    could trigger potential overflow.
    
    Changes from V1
     o modify description of calculation in f2fs.txt suggested by Changman Lee.
    
    Suggested-by: Changman Lee <cm224.lee@samsung.com>
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 8c03f71307c6..ba6f3127738f 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -394,6 +394,9 @@ typedef __le32	f2fs_hash_t;
 /* MAX level for dir lookup */
 #define MAX_DIR_HASH_DEPTH	63
 
+/* MAX buckets in one level of dir */
+#define MAX_DIR_BUCKETS		(1 << ((MAX_DIR_HASH_DEPTH / 2) - 1))
+
 #define SIZE_OF_DIR_ENTRY	11	/* by byte */
 #define SIZE_OF_DENTRY_BITMAP	((NR_DENTRY_IN_BLOCK + BITS_PER_BYTE - 1) / \
 					BITS_PER_BYTE)

commit 6403eb1f646a49cc92f25c08f8716f8870a4a865
Author: Chao Yu <chao2.yu@samsung.com>
Date:   Sat Apr 26 19:59:52 2014 +0800

    f2fs: introduce help macro ADDRS_PER_PAGE()
    
    Introduce help macro ADDRS_PER_PAGE() to get the number of address pointers in
    direct node or inode.
    
    Signed-off-by: Chao Yu <chao2.yu@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index df53e1753a76..8c03f71307c6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -146,6 +146,9 @@ struct f2fs_extent {
 #define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
 #define NIDS_PER_BLOCK		1018	/* Node IDs in an Indirect Block */
 
+#define ADDRS_PER_PAGE(page, fi)	\
+	(IS_INODE(page) ? ADDRS_PER_INODE(fi) : ADDRS_PER_BLOCK)
+
 #define	NODE_DIR1_BLOCK		(DEF_ADDRS_PER_INODE + 1)
 #define	NODE_DIR2_BLOCK		(DEF_ADDRS_PER_INODE + 2)
 #define	NODE_IND1_BLOCK		(DEF_ADDRS_PER_INODE + 3)

commit 3843154598a00408f4214a68bd536fdf27b1df10
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Thu Feb 27 18:20:00 2014 +0900

    f2fs: introduce large directory support
    
    This patch introduces an i_dir_level field to support large directory.
    
    Previously, f2fs maintains multi-level hash tables to find a dentry quickly
    from a bunch of chiild dentries in a directory, and the hash tables consist of
    the following tree structure as below.
    
    In Documentation/filesystems/f2fs.txt,
    
    ----------------------
    A : bucket
    B : block
    N : MAX_DIR_HASH_DEPTH
    ----------------------
    
    level #0   | A(2B)
               |
    level #1   | A(2B) - A(2B)
               |
    level #2   | A(2B) - A(2B) - A(2B) - A(2B)
         .     |   .       .       .       .
    level #N/2 | A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)
         .     |   .       .       .       .
    level #N   | A(4B) - A(4B) - A(4B) - A(4B) - A(4B) - ... - A(4B)
    
    But, if we can guess that a directory will handle a number of child files,
    we don't need to traverse the tree from level #0 to #N all the time.
    Since the lower level tables contain relatively small number of dentries,
    the miss ratio of the target dentry is likely to be high.
    
    In order to avoid that, we can configure the hash tables sparsely from level #0
    like this.
    
    level #0   | A(2B) - A(2B) - A(2B) - A(2B)
    
    level #1   | A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)
         .     |   .       .       .       .
    level #N/2 | A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)
         .     |   .       .       .       .
    level #N   | A(4B) - A(4B) - A(4B) - A(4B) - A(4B) - ... - A(4B)
    
    With this structure, we can skip the ineffective tree searches in lower level
    hash tables.
    
    This patch adds just a facility for this by introducing i_dir_level in
    f2fs_inode.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index da74d878dc4f..df53e1753a76 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -183,7 +183,7 @@ struct f2fs_inode {
 	__le32 i_pino;			/* parent inode number */
 	__le32 i_namelen;		/* file name length */
 	__u8 i_name[F2FS_NAME_LEN];	/* file name for SPOR */
-	__u8 i_reserved2;		/* for backward compatibility */
+	__u8 i_dir_level;		/* dentry_level for large dir */
 
 	struct f2fs_extent i_ext;	/* caching a largest extent */
 

commit 1e1bb4baf10be371f72150e2801d97a04d40b3b9
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Thu Dec 26 12:49:48 2013 +0900

    f2fs: add inline_data recovery routine
    
    This patch adds a inline_data recovery routine with the following policy.
    
    [prev.] [next] of inline_data flag
       o       o  -> recover inline_data
       o       x  -> remove inline_data, and then recover data blocks
       x       o  -> remove inline_data, and then recover inline_data
       x       x  -> recover data blocks
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index aea5eedbb1ca..da74d878dc4f 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -155,12 +155,11 @@ struct f2fs_extent {
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
 #define F2FS_INLINE_DATA	0x02	/* file inline data flag */
 
-
 #define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
 						F2FS_INLINE_XATTR_ADDRS - 1))
 
 #define INLINE_DATA_OFFSET	(PAGE_CACHE_SIZE - sizeof(struct node_footer) \
-				- sizeof(__le32)*(DEF_ADDRS_PER_INODE + 5 - 1))
+			- sizeof(__le32) * (DEF_ADDRS_PER_INODE + 5 - 1))
 
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */

commit 1001b3479ce96e37aed5e4fcdc3c60126e034d08
Author: Huajun Li <huajun.li@intel.com>
Date:   Sun Nov 10 23:13:16 2013 +0800

    f2fs: add flags and helpers to support inline data
    
    Add new inode flags F2FS_INLINE_DATA and FI_INLINE_DATA to indicate
    whether the inode has inline data.
    
    Inline data makes use of inode block's data indices region to save small
    file. Currently there are 923 data indices in an inode block. Since
    inline xattr has made use of the last 50 indices to save its data, there
    are 873 indices left which can be used for inline data. When
    FI_INLINE_DATA is set, the layout of inode block's indices region is
    like below:
    
    +-----------------+
    |                 | Reserved. reserve_new_block() will make use of
    | i_addr[0]       | i_addr[0] when we need to reserve a new data block
    |                 | to convert inline data into regular one's.
    |-----------------|
    |                 | Used by inline data. A file whose size is less than
    | i_addr[1~872]   | 3488 bytes(~3.4k) and doesn't reserve extra
    |                 | blocks by fallocate() can be saved here.
    |-----------------|
    |                 |
    | i_addr[873~922] | Reserved for inline xattr
    |                 |
    +-----------------+
    
    Signed-off-by: Haicheng Li <haicheng.li@linux.intel.com>
    Signed-off-by: Huajun Li <huajun.li@intel.com>
    Signed-off-by: Weihong Xu <weihong.xu@intel.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index bb942f6d5702..aea5eedbb1ca 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -153,6 +153,14 @@ struct f2fs_extent {
 #define	NODE_DIND_BLOCK		(DEF_ADDRS_PER_INODE + 5)
 
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
+#define F2FS_INLINE_DATA	0x02	/* file inline data flag */
+
+
+#define MAX_INLINE_DATA		(sizeof(__le32) * (DEF_ADDRS_PER_INODE - \
+						F2FS_INLINE_XATTR_ADDRS - 1))
+
+#define INLINE_DATA_OFFSET	(PAGE_CACHE_SIZE - sizeof(struct node_footer) \
+				- sizeof(__le32)*(DEF_ADDRS_PER_INODE + 5 - 1))
 
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */

commit 65985d935ddd5657c66a8bb3ae9752ed842549b8
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Wed Aug 14 21:57:27 2013 +0900

    f2fs: support the inline xattrs
    
    0. modified inode structure
    --------------------------------------
    metadata (e.g., i_mtime, i_ctime, etc)
    --------------------------------------
    direct pointers [0 ~ 873]
    
    inline xattrs (200 bytes by default)
    
    indirect pointers [0 ~ 4]
    --------------------------------------
    node footer
    --------------------------------------
    
    1. setxattr flow
     - read_all_xattrs copies all the xattrs from inline and xattr node block.
     - handle xattr entries
     - write_all_xattrs copies modified xattrs into inline and xattr node block.
    
    2. getxattr flow
     - read_all_xattrs copies all the xattrs from inline and xattr node block.
     - check target entries
    
    3. Usage
     # mount -t f2fs -o inline_xattr $DEV $MNT
    
     Once mounted with the inline_xattr option, f2fs marks all the newly created
     files to reserve an amount of inline xattr space explicitly inside the inode
     block. Without the mount option, f2fs will not touch any existing files and
     newly created files as well.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 93e7020fb7a8..bb942f6d5702 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -140,7 +140,7 @@ struct f2fs_extent {
 } __packed;
 
 #define F2FS_NAME_LEN		255
-#define F2FS_INLINE_XATTR_ADDRS	0	/* 0 bytes for inline xattrs */
+#define F2FS_INLINE_XATTR_ADDRS	50	/* 200 bytes for inline xattrs */
 #define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
 #define ADDRS_PER_INODE(fi)	addrs_per_inode(fi)
 #define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */

commit de93653fe31fc9439971296842dcd0280f8ab5f4
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Mon Aug 12 21:08:03 2013 +0900

    f2fs: reserve the xattr space dynamically
    
    This patch enables the number of direct pointers inside on-disk inode block to
    be changed dynamically according to the size of inline xattr space.
    
    The number of direct pointers, ADDRS_PER_INODE, can be changed only if the file
    has inline xattr flag.
    
    The number of direct pointers that will be used by inline xattrs is defined as
    F2FS_INLINE_XATTR_ADDRS.
    Current patch assigns F2FS_INLINE_XATTR_ADDRS to 0 temporarily.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 10ab11f8f99d..93e7020fb7a8 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -140,9 +140,17 @@ struct f2fs_extent {
 } __packed;
 
 #define F2FS_NAME_LEN		255
-#define ADDRS_PER_INODE         923	/* Address Pointers in an Inode */
-#define ADDRS_PER_BLOCK         1018	/* Address Pointers in a Direct Block */
-#define NIDS_PER_BLOCK          1018	/* Node IDs in an Indirect Block */
+#define F2FS_INLINE_XATTR_ADDRS	0	/* 0 bytes for inline xattrs */
+#define DEF_ADDRS_PER_INODE	923	/* Address Pointers in an Inode */
+#define ADDRS_PER_INODE(fi)	addrs_per_inode(fi)
+#define ADDRS_PER_BLOCK		1018	/* Address Pointers in a Direct Block */
+#define NIDS_PER_BLOCK		1018	/* Node IDs in an Indirect Block */
+
+#define	NODE_DIR1_BLOCK		(DEF_ADDRS_PER_INODE + 1)
+#define	NODE_DIR2_BLOCK		(DEF_ADDRS_PER_INODE + 2)
+#define	NODE_IND1_BLOCK		(DEF_ADDRS_PER_INODE + 3)
+#define	NODE_IND2_BLOCK		(DEF_ADDRS_PER_INODE + 4)
+#define	NODE_DIND_BLOCK		(DEF_ADDRS_PER_INODE + 5)
 
 #define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
 
@@ -172,7 +180,7 @@ struct f2fs_inode {
 
 	struct f2fs_extent i_ext;	/* caching a largest extent */
 
-	__le32 i_addr[ADDRS_PER_INODE];	/* Pointers to data blocks */
+	__le32 i_addr[DEF_ADDRS_PER_INODE];	/* Pointers to data blocks */
 
 	__le32 i_nid[5];		/* direct(2), indirect(2),
 						double_indirect(1) node id */

commit 444c580f7e9ad29927a5d5269d576bd7cdccebb8
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Thu Aug 8 15:16:22 2013 +0900

    f2fs: add flags for inline xattrs
    
    This patch adds basic inode flags for inline xattrs, F2FS_INLINE_XATTR,
    and add a mount option, inline_xattr, which is enabled when xattr is set.
    
    If the mount option is enabled, all the files are marked with the inline_xattrs
    flag.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 383d5e39b280..10ab11f8f99d 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -144,10 +144,12 @@ struct f2fs_extent {
 #define ADDRS_PER_BLOCK         1018	/* Address Pointers in a Direct Block */
 #define NIDS_PER_BLOCK          1018	/* Node IDs in an Indirect Block */
 
+#define F2FS_INLINE_XATTR	0x01	/* file inline xattr flag */
+
 struct f2fs_inode {
 	__le16 i_mode;			/* file mode */
 	__u8 i_advise;			/* file hints */
-	__u8 i_reserved;		/* reserved */
+	__u8 i_inline;			/* file inline flags */
 	__le32 i_uid;			/* user ID */
 	__le32 i_gid;			/* group ID */
 	__le32 i_links;			/* links count */

commit a9841c4dbbdd8a2fb919ea305ffa95ab5ec80af2
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Fri May 24 12:41:04 2013 +0900

    f2fs: align data types between on-disk and in-memory block addresses
    
    The on-disk block address is defined as __le32, but in-memory block address,
    block_t, does as u64.
    
    Let's synchronize them to 32 bits.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index df6fab82f87e..383d5e39b280 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -20,8 +20,8 @@
 #define F2FS_BLKSIZE			4096	/* support only 4KB block */
 #define F2FS_MAX_EXTENSION		64	/* # of extension entries */
 
-#define NULL_ADDR		0x0U
-#define NEW_ADDR		-1U
+#define NULL_ADDR		((block_t)0)	/* used as block_t addresses */
+#define NEW_ADDR		((block_t)-1)	/* used as block_t addresses */
 
 #define F2FS_ROOT_INO(sbi)	(sbi->root_ino_num)
 #define F2FS_NODE_INO(sbi)	(sbi->node_ino_num)

commit 5a20d339c785d98d8b050b9afc098e4184a6098c
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Sun Mar 3 13:58:05 2013 +0900

    f2fs: align f2fs maximum name length to linux based filesystem
    
    The maximum filename length supported in linux is 255 characters.
    So let's follow that.
    
    Signed-off-by: Namjae Jeon <namjae.jeon@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index f9a12f6243a5..df6fab82f87e 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -139,7 +139,7 @@ struct f2fs_extent {
 	__le32 len;		/* lengh of the extent */
 } __packed;
 
-#define F2FS_MAX_NAME_LEN	256
+#define F2FS_NAME_LEN		255
 #define ADDRS_PER_INODE         923	/* Address Pointers in an Inode */
 #define ADDRS_PER_BLOCK         1018	/* Address Pointers in a Direct Block */
 #define NIDS_PER_BLOCK          1018	/* Node IDs in an Indirect Block */
@@ -165,7 +165,8 @@ struct f2fs_inode {
 	__le32 i_flags;			/* file attributes */
 	__le32 i_pino;			/* parent inode number */
 	__le32 i_namelen;		/* file name length */
-	__u8 i_name[F2FS_MAX_NAME_LEN];	/* file name for SPOR */
+	__u8 i_name[F2FS_NAME_LEN];	/* file name for SPOR */
+	__u8 i_reserved2;		/* for backward compatibility */
 
 	struct f2fs_extent i_ext;	/* caching a largest extent */
 
@@ -362,10 +363,10 @@ struct f2fs_summary_block {
 typedef __le32	f2fs_hash_t;
 
 /* One directory entry slot covers 8bytes-long file name */
-#define F2FS_NAME_LEN		8
-#define F2FS_NAME_LEN_BITS	3
+#define F2FS_SLOT_LEN		8
+#define F2FS_SLOT_LEN_BITS	3
 
-#define GET_DENTRY_SLOTS(x)	((x + F2FS_NAME_LEN - 1) >> F2FS_NAME_LEN_BITS)
+#define GET_DENTRY_SLOTS(x)	((x + F2FS_SLOT_LEN - 1) >> F2FS_SLOT_LEN_BITS)
 
 /* the number of dentry in a block */
 #define NR_DENTRY_IN_BLOCK	214
@@ -377,10 +378,10 @@ typedef __le32	f2fs_hash_t;
 #define SIZE_OF_DENTRY_BITMAP	((NR_DENTRY_IN_BLOCK + BITS_PER_BYTE - 1) / \
 					BITS_PER_BYTE)
 #define SIZE_OF_RESERVED	(PAGE_SIZE - ((SIZE_OF_DIR_ENTRY + \
-				F2FS_NAME_LEN) * \
+				F2FS_SLOT_LEN) * \
 				NR_DENTRY_IN_BLOCK + SIZE_OF_DENTRY_BITMAP))
 
-/* One directory entry slot representing F2FS_NAME_LEN-sized file name */
+/* One directory entry slot representing F2FS_SLOT_LEN-sized file name */
 struct f2fs_dir_entry {
 	__le32 hash_code;	/* hash code of file name */
 	__le32 ino;		/* inode number */
@@ -394,7 +395,7 @@ struct f2fs_dentry_block {
 	__u8 dentry_bitmap[SIZE_OF_DENTRY_BITMAP];
 	__u8 reserved[SIZE_OF_RESERVED];
 	struct f2fs_dir_entry dentry[NR_DENTRY_IN_BLOCK];
-	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_NAME_LEN];
+	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_SLOT_LEN];
 } __packed;
 
 /* file types used in inode_info->flags */

commit 457d08ee4fd91c8df17917ff2d32565e6adacbfc
Author: Namjae Jeon <namjae.jeon@samsung.com>
Date:   Sat Dec 8 14:54:50 2012 +0900

    f2fs: introduce accessor to retrieve number of dentry slots
    
    Simplify code by providing the accessor macro to retrieve the
    number of dentry slots for a given filename length.
    
    Signed-off-by: Namjae Jeon <namjae.jeon@samsung.com>
    Signed-off-by: Amit Sahrawat <a.sahrawat@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index c2fbbc35c1e6..f9a12f6243a5 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -363,6 +363,9 @@ typedef __le32	f2fs_hash_t;
 
 /* One directory entry slot covers 8bytes-long file name */
 #define F2FS_NAME_LEN		8
+#define F2FS_NAME_LEN_BITS	3
+
+#define GET_DENTRY_SLOTS(x)	((x + F2FS_NAME_LEN - 1) >> F2FS_NAME_LEN_BITS)
 
 /* the number of dentry in a block */
 #define NR_DENTRY_IN_BLOCK	214

commit 25ca923b2a766b9c93b63777ead351137533a623
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Wed Nov 28 16:12:41 2012 +0900

    f2fs: fix endian conversion bugs reported by sparse
    
    This patch should resolve the bugs reported by the sparse tool.
    Initial reports were written by "kbuild test robot" managed by fengguang.wu.
    
    In my local machines, I've tested also by running:
    > make C=2 CF="-D__CHECK_ENDIAN__"
    
    Accordingly, I've found lots of warnings and bugs related to the endian
    conversion. And I've fixed all at this moment.
    
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
index 1429ece7caab..c2fbbc35c1e6 100644
--- a/include/linux/f2fs_fs.h
+++ b/include/linux/f2fs_fs.h
@@ -272,8 +272,8 @@ struct f2fs_sit_block {
  * ex) data_blkaddr = (block_t)(nodepage_start_address + ofs_in_node)
  */
 #define ENTRIES_IN_SUM		512
-#define	SUMMARY_SIZE		(sizeof(struct f2fs_summary))
-#define	SUM_FOOTER_SIZE		(sizeof(struct summary_footer))
+#define	SUMMARY_SIZE		(7)	/* sizeof(struct summary) */
+#define	SUM_FOOTER_SIZE		(5)	/* sizeof(struct summary_footer) */
 #define SUM_ENTRY_SIZE		(SUMMARY_SIZE * ENTRIES_IN_SUM)
 
 /* a summary entry for a 4KB-sized block in a segment */
@@ -297,7 +297,7 @@ struct summary_footer {
 	__u32 check_sum;		/* summary checksum */
 } __packed;
 
-#define SUM_JOURNAL_SIZE	(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE -\
+#define SUM_JOURNAL_SIZE	(F2FS_BLKSIZE - SUM_FOOTER_SIZE -\
 				SUM_ENTRY_SIZE)
 #define NAT_JOURNAL_ENTRIES	((SUM_JOURNAL_SIZE - 2) /\
 				sizeof(struct nat_journal_entry))

commit dd31866b0d55c9b70722ebad6ccd643223d9269e
Author: Jaegeuk Kim <jaegeuk.kim@samsung.com>
Date:   Fri Nov 2 17:06:26 2012 +0900

    f2fs: add on-disk layout
    
    This adds a header file describing the on-disk layout of f2fs.
    
    Signed-off-by: Changman Lee <cm224.lee@samsung.com>
    Signed-off-by: Chul Lee <chur.lee@samsung.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk.kim@samsung.com>

diff --git a/include/linux/f2fs_fs.h b/include/linux/f2fs_fs.h
new file mode 100644
index 000000000000..1429ece7caab
--- /dev/null
+++ b/include/linux/f2fs_fs.h
@@ -0,0 +1,410 @@
+/**
+ * include/linux/f2fs_fs.h
+ *
+ * Copyright (c) 2012 Samsung Electronics Co., Ltd.
+ *             http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _LINUX_F2FS_FS_H
+#define _LINUX_F2FS_FS_H
+
+#include <linux/pagemap.h>
+#include <linux/types.h>
+
+#define F2FS_SUPER_OFFSET		1024	/* byte-size offset */
+#define F2FS_LOG_SECTOR_SIZE		9	/* 9 bits for 512 byte */
+#define F2FS_LOG_SECTORS_PER_BLOCK	3	/* 4KB: F2FS_BLKSIZE */
+#define F2FS_BLKSIZE			4096	/* support only 4KB block */
+#define F2FS_MAX_EXTENSION		64	/* # of extension entries */
+
+#define NULL_ADDR		0x0U
+#define NEW_ADDR		-1U
+
+#define F2FS_ROOT_INO(sbi)	(sbi->root_ino_num)
+#define F2FS_NODE_INO(sbi)	(sbi->node_ino_num)
+#define F2FS_META_INO(sbi)	(sbi->meta_ino_num)
+
+/* This flag is used by node and meta inodes, and by recovery */
+#define GFP_F2FS_ZERO	(GFP_NOFS | __GFP_ZERO)
+
+/*
+ * For further optimization on multi-head logs, on-disk layout supports maximum
+ * 16 logs by default. The number, 16, is expected to cover all the cases
+ * enoughly. The implementaion currently uses no more than 6 logs.
+ * Half the logs are used for nodes, and the other half are used for data.
+ */
+#define MAX_ACTIVE_LOGS	16
+#define MAX_ACTIVE_NODE_LOGS	8
+#define MAX_ACTIVE_DATA_LOGS	8
+
+/*
+ * For superblock
+ */
+struct f2fs_super_block {
+	__le32 magic;			/* Magic Number */
+	__le16 major_ver;		/* Major Version */
+	__le16 minor_ver;		/* Minor Version */
+	__le32 log_sectorsize;		/* log2 sector size in bytes */
+	__le32 log_sectors_per_block;	/* log2 # of sectors per block */
+	__le32 log_blocksize;		/* log2 block size in bytes */
+	__le32 log_blocks_per_seg;	/* log2 # of blocks per segment */
+	__le32 segs_per_sec;		/* # of segments per section */
+	__le32 secs_per_zone;		/* # of sections per zone */
+	__le32 checksum_offset;		/* checksum offset inside super block */
+	__le64 block_count;		/* total # of user blocks */
+	__le32 section_count;		/* total # of sections */
+	__le32 segment_count;		/* total # of segments */
+	__le32 segment_count_ckpt;	/* # of segments for checkpoint */
+	__le32 segment_count_sit;	/* # of segments for SIT */
+	__le32 segment_count_nat;	/* # of segments for NAT */
+	__le32 segment_count_ssa;	/* # of segments for SSA */
+	__le32 segment_count_main;	/* # of segments for main area */
+	__le32 segment0_blkaddr;	/* start block address of segment 0 */
+	__le32 cp_blkaddr;		/* start block address of checkpoint */
+	__le32 sit_blkaddr;		/* start block address of SIT */
+	__le32 nat_blkaddr;		/* start block address of NAT */
+	__le32 ssa_blkaddr;		/* start block address of SSA */
+	__le32 main_blkaddr;		/* start block address of main area */
+	__le32 root_ino;		/* root inode number */
+	__le32 node_ino;		/* node inode number */
+	__le32 meta_ino;		/* meta inode number */
+	__u8 uuid[16];			/* 128-bit uuid for volume */
+	__le16 volume_name[512];	/* volume name */
+	__le32 extension_count;		/* # of extensions below */
+	__u8 extension_list[F2FS_MAX_EXTENSION][8];	/* extension array */
+} __packed;
+
+/*
+ * For checkpoint
+ */
+#define CP_ERROR_FLAG		0x00000008
+#define CP_COMPACT_SUM_FLAG	0x00000004
+#define CP_ORPHAN_PRESENT_FLAG	0x00000002
+#define CP_UMOUNT_FLAG		0x00000001
+
+struct f2fs_checkpoint {
+	__le64 checkpoint_ver;		/* checkpoint block version number */
+	__le64 user_block_count;	/* # of user blocks */
+	__le64 valid_block_count;	/* # of valid blocks in main area */
+	__le32 rsvd_segment_count;	/* # of reserved segments for gc */
+	__le32 overprov_segment_count;	/* # of overprovision segments */
+	__le32 free_segment_count;	/* # of free segments in main area */
+
+	/* information of current node segments */
+	__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];
+	__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];
+	/* information of current data segments */
+	__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];
+	__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];
+	__le32 ckpt_flags;		/* Flags : umount and journal_present */
+	__le32 cp_pack_total_block_count;	/* total # of one cp pack */
+	__le32 cp_pack_start_sum;	/* start block number of data summary */
+	__le32 valid_node_count;	/* Total number of valid nodes */
+	__le32 valid_inode_count;	/* Total number of valid inodes */
+	__le32 next_free_nid;		/* Next free node number */
+	__le32 sit_ver_bitmap_bytesize;	/* Default value 64 */
+	__le32 nat_ver_bitmap_bytesize; /* Default value 256 */
+	__le32 checksum_offset;		/* checksum offset inside cp block */
+	__le64 elapsed_time;		/* mounted time */
+	/* allocation type of current segment */
+	unsigned char alloc_type[MAX_ACTIVE_LOGS];
+
+	/* SIT and NAT version bitmap */
+	unsigned char sit_nat_version_bitmap[1];
+} __packed;
+
+/*
+ * For orphan inode management
+ */
+#define F2FS_ORPHANS_PER_BLOCK	1020
+
+struct f2fs_orphan_block {
+	__le32 ino[F2FS_ORPHANS_PER_BLOCK];	/* inode numbers */
+	__le32 reserved;	/* reserved */
+	__le16 blk_addr;	/* block index in current CP */
+	__le16 blk_count;	/* Number of orphan inode blocks in CP */
+	__le32 entry_count;	/* Total number of orphan nodes in current CP */
+	__le32 check_sum;	/* CRC32 for orphan inode block */
+} __packed;
+
+/*
+ * For NODE structure
+ */
+struct f2fs_extent {
+	__le32 fofs;		/* start file offset of the extent */
+	__le32 blk_addr;	/* start block address of the extent */
+	__le32 len;		/* lengh of the extent */
+} __packed;
+
+#define F2FS_MAX_NAME_LEN	256
+#define ADDRS_PER_INODE         923	/* Address Pointers in an Inode */
+#define ADDRS_PER_BLOCK         1018	/* Address Pointers in a Direct Block */
+#define NIDS_PER_BLOCK          1018	/* Node IDs in an Indirect Block */
+
+struct f2fs_inode {
+	__le16 i_mode;			/* file mode */
+	__u8 i_advise;			/* file hints */
+	__u8 i_reserved;		/* reserved */
+	__le32 i_uid;			/* user ID */
+	__le32 i_gid;			/* group ID */
+	__le32 i_links;			/* links count */
+	__le64 i_size;			/* file size in bytes */
+	__le64 i_blocks;		/* file size in blocks */
+	__le64 i_atime;			/* access time */
+	__le64 i_ctime;			/* change time */
+	__le64 i_mtime;			/* modification time */
+	__le32 i_atime_nsec;		/* access time in nano scale */
+	__le32 i_ctime_nsec;		/* change time in nano scale */
+	__le32 i_mtime_nsec;		/* modification time in nano scale */
+	__le32 i_generation;		/* file version (for NFS) */
+	__le32 i_current_depth;		/* only for directory depth */
+	__le32 i_xattr_nid;		/* nid to save xattr */
+	__le32 i_flags;			/* file attributes */
+	__le32 i_pino;			/* parent inode number */
+	__le32 i_namelen;		/* file name length */
+	__u8 i_name[F2FS_MAX_NAME_LEN];	/* file name for SPOR */
+
+	struct f2fs_extent i_ext;	/* caching a largest extent */
+
+	__le32 i_addr[ADDRS_PER_INODE];	/* Pointers to data blocks */
+
+	__le32 i_nid[5];		/* direct(2), indirect(2),
+						double_indirect(1) node id */
+} __packed;
+
+struct direct_node {
+	__le32 addr[ADDRS_PER_BLOCK];	/* array of data block address */
+} __packed;
+
+struct indirect_node {
+	__le32 nid[NIDS_PER_BLOCK];	/* array of data block address */
+} __packed;
+
+enum {
+	COLD_BIT_SHIFT = 0,
+	FSYNC_BIT_SHIFT,
+	DENT_BIT_SHIFT,
+	OFFSET_BIT_SHIFT
+};
+
+struct node_footer {
+	__le32 nid;		/* node id */
+	__le32 ino;		/* inode nunmber */
+	__le32 flag;		/* include cold/fsync/dentry marks and offset */
+	__le64 cp_ver;		/* checkpoint version */
+	__le32 next_blkaddr;	/* next node page block address */
+} __packed;
+
+struct f2fs_node {
+	/* can be one of three types: inode, direct, and indirect types */
+	union {
+		struct f2fs_inode i;
+		struct direct_node dn;
+		struct indirect_node in;
+	};
+	struct node_footer footer;
+} __packed;
+
+/*
+ * For NAT entries
+ */
+#define NAT_ENTRY_PER_BLOCK (PAGE_CACHE_SIZE / sizeof(struct f2fs_nat_entry))
+
+struct f2fs_nat_entry {
+	__u8 version;		/* latest version of cached nat entry */
+	__le32 ino;		/* inode number */
+	__le32 block_addr;	/* block address */
+} __packed;
+
+struct f2fs_nat_block {
+	struct f2fs_nat_entry entries[NAT_ENTRY_PER_BLOCK];
+} __packed;
+
+/*
+ * For SIT entries
+ *
+ * Each segment is 2MB in size by default so that a bitmap for validity of
+ * there-in blocks should occupy 64 bytes, 512 bits.
+ * Not allow to change this.
+ */
+#define SIT_VBLOCK_MAP_SIZE 64
+#define SIT_ENTRY_PER_BLOCK (PAGE_CACHE_SIZE / sizeof(struct f2fs_sit_entry))
+
+/*
+ * Note that f2fs_sit_entry->vblocks has the following bit-field information.
+ * [15:10] : allocation type such as CURSEG_XXXX_TYPE
+ * [9:0] : valid block count
+ */
+#define SIT_VBLOCKS_SHIFT	10
+#define SIT_VBLOCKS_MASK	((1 << SIT_VBLOCKS_SHIFT) - 1)
+#define GET_SIT_VBLOCKS(raw_sit)				\
+	(le16_to_cpu((raw_sit)->vblocks) & SIT_VBLOCKS_MASK)
+#define GET_SIT_TYPE(raw_sit)					\
+	((le16_to_cpu((raw_sit)->vblocks) & ~SIT_VBLOCKS_MASK)	\
+	 >> SIT_VBLOCKS_SHIFT)
+
+struct f2fs_sit_entry {
+	__le16 vblocks;				/* reference above */
+	__u8 valid_map[SIT_VBLOCK_MAP_SIZE];	/* bitmap for valid blocks */
+	__le64 mtime;				/* segment age for cleaning */
+} __packed;
+
+struct f2fs_sit_block {
+	struct f2fs_sit_entry entries[SIT_ENTRY_PER_BLOCK];
+} __packed;
+
+/*
+ * For segment summary
+ *
+ * One summary block contains exactly 512 summary entries, which represents
+ * exactly 2MB segment by default. Not allow to change the basic units.
+ *
+ * NOTE: For initializing fields, you must use set_summary
+ *
+ * - If data page, nid represents dnode's nid
+ * - If node page, nid represents the node page's nid.
+ *
+ * The ofs_in_node is used by only data page. It represents offset
+ * from node's page's beginning to get a data block address.
+ * ex) data_blkaddr = (block_t)(nodepage_start_address + ofs_in_node)
+ */
+#define ENTRIES_IN_SUM		512
+#define	SUMMARY_SIZE		(sizeof(struct f2fs_summary))
+#define	SUM_FOOTER_SIZE		(sizeof(struct summary_footer))
+#define SUM_ENTRY_SIZE		(SUMMARY_SIZE * ENTRIES_IN_SUM)
+
+/* a summary entry for a 4KB-sized block in a segment */
+struct f2fs_summary {
+	__le32 nid;		/* parent node id */
+	union {
+		__u8 reserved[3];
+		struct {
+			__u8 version;		/* node version number */
+			__le16 ofs_in_node;	/* block index in parent node */
+		} __packed;
+	};
+} __packed;
+
+/* summary block type, node or data, is stored to the summary_footer */
+#define SUM_TYPE_NODE		(1)
+#define SUM_TYPE_DATA		(0)
+
+struct summary_footer {
+	unsigned char entry_type;	/* SUM_TYPE_XXX */
+	__u32 check_sum;		/* summary checksum */
+} __packed;
+
+#define SUM_JOURNAL_SIZE	(PAGE_CACHE_SIZE - SUM_FOOTER_SIZE -\
+				SUM_ENTRY_SIZE)
+#define NAT_JOURNAL_ENTRIES	((SUM_JOURNAL_SIZE - 2) /\
+				sizeof(struct nat_journal_entry))
+#define NAT_JOURNAL_RESERVED	((SUM_JOURNAL_SIZE - 2) %\
+				sizeof(struct nat_journal_entry))
+#define SIT_JOURNAL_ENTRIES	((SUM_JOURNAL_SIZE - 2) /\
+				sizeof(struct sit_journal_entry))
+#define SIT_JOURNAL_RESERVED	((SUM_JOURNAL_SIZE - 2) %\
+				sizeof(struct sit_journal_entry))
+/*
+ * frequently updated NAT/SIT entries can be stored in the spare area in
+ * summary blocks
+ */
+enum {
+	NAT_JOURNAL = 0,
+	SIT_JOURNAL
+};
+
+struct nat_journal_entry {
+	__le32 nid;
+	struct f2fs_nat_entry ne;
+} __packed;
+
+struct nat_journal {
+	struct nat_journal_entry entries[NAT_JOURNAL_ENTRIES];
+	__u8 reserved[NAT_JOURNAL_RESERVED];
+} __packed;
+
+struct sit_journal_entry {
+	__le32 segno;
+	struct f2fs_sit_entry se;
+} __packed;
+
+struct sit_journal {
+	struct sit_journal_entry entries[SIT_JOURNAL_ENTRIES];
+	__u8 reserved[SIT_JOURNAL_RESERVED];
+} __packed;
+
+/* 4KB-sized summary block structure */
+struct f2fs_summary_block {
+	struct f2fs_summary entries[ENTRIES_IN_SUM];
+	union {
+		__le16 n_nats;
+		__le16 n_sits;
+	};
+	/* spare area is used by NAT or SIT journals */
+	union {
+		struct nat_journal nat_j;
+		struct sit_journal sit_j;
+	};
+	struct summary_footer footer;
+} __packed;
+
+/*
+ * For directory operations
+ */
+#define F2FS_DOT_HASH		0
+#define F2FS_DDOT_HASH		F2FS_DOT_HASH
+#define F2FS_MAX_HASH		(~((0x3ULL) << 62))
+#define F2FS_HASH_COL_BIT	((0x1ULL) << 63)
+
+typedef __le32	f2fs_hash_t;
+
+/* One directory entry slot covers 8bytes-long file name */
+#define F2FS_NAME_LEN		8
+
+/* the number of dentry in a block */
+#define NR_DENTRY_IN_BLOCK	214
+
+/* MAX level for dir lookup */
+#define MAX_DIR_HASH_DEPTH	63
+
+#define SIZE_OF_DIR_ENTRY	11	/* by byte */
+#define SIZE_OF_DENTRY_BITMAP	((NR_DENTRY_IN_BLOCK + BITS_PER_BYTE - 1) / \
+					BITS_PER_BYTE)
+#define SIZE_OF_RESERVED	(PAGE_SIZE - ((SIZE_OF_DIR_ENTRY + \
+				F2FS_NAME_LEN) * \
+				NR_DENTRY_IN_BLOCK + SIZE_OF_DENTRY_BITMAP))
+
+/* One directory entry slot representing F2FS_NAME_LEN-sized file name */
+struct f2fs_dir_entry {
+	__le32 hash_code;	/* hash code of file name */
+	__le32 ino;		/* inode number */
+	__le16 name_len;	/* lengh of file name */
+	__u8 file_type;		/* file type */
+} __packed;
+
+/* 4KB-sized directory entry block */
+struct f2fs_dentry_block {
+	/* validity bitmap for directory entries in each block */
+	__u8 dentry_bitmap[SIZE_OF_DENTRY_BITMAP];
+	__u8 reserved[SIZE_OF_RESERVED];
+	struct f2fs_dir_entry dentry[NR_DENTRY_IN_BLOCK];
+	__u8 filename[NR_DENTRY_IN_BLOCK][F2FS_NAME_LEN];
+} __packed;
+
+/* file types used in inode_info->flags */
+enum {
+	F2FS_FT_UNKNOWN,
+	F2FS_FT_REG_FILE,
+	F2FS_FT_DIR,
+	F2FS_FT_CHRDEV,
+	F2FS_FT_BLKDEV,
+	F2FS_FT_FIFO,
+	F2FS_FT_SOCK,
+	F2FS_FT_SYMLINK,
+	F2FS_FT_MAX
+};
+
+#endif  /* _LINUX_F2FS_FS_H */
