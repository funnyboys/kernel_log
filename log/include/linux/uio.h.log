commit 8cefc107ca54c8b06438b7dc9cc08bc0a11d5b98
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 15 13:30:32 2019 +0000

    pipe: Use head and tail pointers for the ring, not cursor and length
    
    Convert pipes to use head and tail pointers for the buffer ring rather than
    pointer and length as the latter requires two atomic ops to update (or a
    combined op) whereas the former only requires one.
    
     (1) The head pointer is the point at which production occurs and points to
         the slot in which the next buffer will be placed.  This is equivalent
         to pipe->curbuf + pipe->nrbufs.
    
         The head pointer belongs to the write-side.
    
     (2) The tail pointer is the point at which consumption occurs.  It points
         to the next slot to be consumed.  This is equivalent to pipe->curbuf.
    
         The tail pointer belongs to the read-side.
    
     (3) head and tail are allowed to run to UINT_MAX and wrap naturally.  They
         are only masked off when the array is being accessed, e.g.:
    
            pipe->bufs[head & mask]
    
         This means that it is not necessary to have a dead slot in the ring as
         head == tail isn't ambiguous.
    
     (4) The ring is empty if "head == tail".
    
         A helper, pipe_empty(), is provided for this.
    
     (5) The occupancy of the ring is "head - tail".
    
         A helper, pipe_occupancy(), is provided for this.
    
     (6) The number of free slots in the ring is "pipe->ring_size - occupancy".
    
         A helper, pipe_space_for_user() is provided to indicate how many slots
         userspace may use.
    
     (7) The ring is full if "head - tail >= pipe->ring_size".
    
         A helper, pipe_full(), is provided for this.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index ab5f523bc0df..9576fd8158d7 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -45,8 +45,8 @@ struct iov_iter {
 	union {
 		unsigned long nr_segs;
 		struct {
-			int idx;
-			int start_idx;
+			unsigned int head;
+			unsigned int start_head;
 		};
 	};
 };

commit a2d79c7174aeb43b13020dd53d85a7aefdd9f3e5
Merge: 964a4eacef67 a4c0b3decb33
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 10:36:53 2019 -0700

    Merge tag 'for-5.3/io_uring-20190711' of git://git.kernel.dk/linux-block
    
    Pull io_uring updates from Jens Axboe:
     "This contains:
    
       - Support for recvmsg/sendmsg as first class opcodes.
    
         I don't envision going much further down this path, as there are
         plans in progress to support potentially any system call in an
         async fashion through io_uring. But I think it does make sense to
         have certain core ops available directly, especially those that can
         support a "try this non-blocking" flag/mode. (me)
    
       - Handle generic short reads automatically.
    
         This can happen fairly easily if parts of the buffered read is
         cached. Since the application needs to issue another request for
         the remainder, just do this internally and save kernel/user
         roundtrip while providing a nicer more robust API. (me)
    
       - Support for linked SQEs.
    
         This allows SQEs to depend on each other, enabling an application
         to eg queue a read-from-this-file,write-to-that-file pair. (me)
    
       - Fix race in stopping SQ thread (Jackie)"
    
    * tag 'for-5.3/io_uring-20190711' of git://git.kernel.dk/linux-block:
      io_uring: fix io_sq_thread_stop running in front of io_sq_thread
      io_uring: add support for recvmsg()
      io_uring: add support for sendmsg()
      io_uring: add support for sqe links
      io_uring: punt short reads to async context
      uio: make import_iovec()/compat_import_iovec() return bytes on success

commit b620743077e291ae7d0debd21f50413a8c266229
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 26 15:49:28 2019 +0200

    block: never take page references for ITER_BVEC
    
    If we pass pages through an iov_iter we always already have a reference
    in the caller.  Thus remove the ITER_BVEC_FLAG_NO_REF and don't take
    reference to pages by default for bvec backed iov_iters.
    
    Reviewed-by: Minwoo Im <minwoo.im.dev@gmail.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 2c90a0842ee8..cea1761c5672 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -19,9 +19,6 @@ struct kvec {
 };
 
 enum iter_type {
-	/* set if ITER_BVEC doesn't hold a bv_page ref */
-	ITER_BVEC_FLAG_NO_REF = 2,
-
 	/* iter types */
 	ITER_IOVEC = 4,
 	ITER_KVEC = 8,
@@ -56,7 +53,7 @@ struct iov_iter {
 
 static inline enum iter_type iov_iter_type(const struct iov_iter *i)
 {
-	return i->type & ~(READ | WRITE | ITER_BVEC_FLAG_NO_REF);
+	return i->type & ~(READ | WRITE);
 }
 
 static inline bool iter_is_iovec(const struct iov_iter *i)
@@ -89,11 +86,6 @@ static inline unsigned char iov_iter_rw(const struct iov_iter *i)
 	return i->type & (READ | WRITE);
 }
 
-static inline bool iov_iter_bvec_no_ref(const struct iov_iter *i)
-{
-	return (i->type & ITER_BVEC_FLAG_NO_REF) != 0;
-}
-
 /*
  * Total number of bytes covered by an iovec.
  *

commit 87e5e6dab6c2a21fab2620f37786276d202e2ce0
Author: Jens Axboe <axboe@kernel.dk>
Date:   Tue May 14 16:02:22 2019 -0600

    uio: make import_iovec()/compat_import_iovec() return bytes on success
    
    Currently these functions return < 0 on error, and 0 for success.
    Change that so that we return < 0 on error, but number of bytes
    for success.
    
    Some callers already treat the return value that way, others need a
    slight tweak.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 2d0131ad4604..a61ceb6575ab 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -279,13 +279,13 @@ bool csum_and_copy_from_iter_full(void *addr, size_t bytes, __wsum *csum, struct
 size_t hash_and_copy_to_iter(const void *addr, size_t bytes, void *hashp,
 		struct iov_iter *i);
 
-int import_iovec(int type, const struct iovec __user * uvector,
+ssize_t import_iovec(int type, const struct iovec __user * uvector,
 		 unsigned nr_segs, unsigned fast_segs,
 		 struct iovec **iov, struct iov_iter *i);
 
 #ifdef CONFIG_COMPAT
 struct compat_iovec;
-int compat_import_iovec(int type, const struct compat_iovec __user * uvector,
+ssize_t compat_import_iovec(int type, const struct compat_iovec __user * uvector,
 		 unsigned nr_segs, unsigned fast_segs,
 		 struct iovec **iov, struct iov_iter *i);
 #endif

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 2d0131ad4604..2c90a0842ee8 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -1,10 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *	Berkeley style UIO structures	-	Alan Cox 1994.
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
  */
 #ifndef __LINUX_UIO_H
 #define __LINUX_UIO_H

commit f5eb4d3b92a6a1096ef3480b54782a9409281300
Author: Ming Lei <ming.lei@redhat.com>
Date:   Fri Apr 26 18:45:21 2019 +0800

    iov_iter: fix iov_iter_type
    
    Commit 875f1d0769cd ("iov_iter: add ITER_BVEC_FLAG_NO_REF flag")
    introduces one extra flag of ITER_BVEC_FLAG_NO_REF, and this flag
    is stored into iter->type.
    
    However, iov_iter_type() doesn't consider the new added flag, fix
    it by masking this flag in iov_iter_type().
    
    Fixes: 875f1d0769cd ("iov_iter: add ITER_BVEC_FLAG_NO_REF flag")
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index f184af1999a8..2d0131ad4604 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -60,7 +60,7 @@ struct iov_iter {
 
 static inline enum iter_type iov_iter_type(const struct iov_iter *i)
 {
-	return i->type & ~(READ | WRITE);
+	return i->type & ~(READ | WRITE | ITER_BVEC_FLAG_NO_REF);
 }
 
 static inline bool iter_is_iovec(const struct iov_iter *i)

commit 1bdd3dbfff7a308643c7f9ef74e4a8ef3923e686
Merge: 2335cbe648e7 399254aaf489
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 23 10:25:12 2019 -0700

    Merge tag 'io_uring-20190323' of git://git.kernel.dk/linux-block
    
    Pull io_uring fixes and improvements from Jens Axboe:
     "The first five in this series are heavily inspired by the work Al did
      on the aio side to fix the races there.
    
      The last two re-introduce a feature that was in io_uring before it got
      merged, but which I pulled since we didn't have a good way to have
      BVEC iters that already have a stable reference. These aren't
      necessarily related to block, it's just how io_uring pins fixed
      buffers"
    
    * tag 'io_uring-20190323' of git://git.kernel.dk/linux-block:
      block: add BIO_NO_PAGE_REF flag
      iov_iter: add ITER_BVEC_FLAG_NO_REF flag
      io_uring: mark me as the maintainer
      io_uring: retry bulk slab allocs as single allocs
      io_uring: fix poll races
      io_uring: fix fget/fput handling
      io_uring: add prepped flag
      io_uring: make io_read/write return an integer
      io_uring: use regular request ref counts

commit 875f1d0769cdcfe1596ff0ca609b453359e42ec9
Author: Jens Axboe <axboe@kernel.dk>
Date:   Wed Feb 27 13:05:25 2019 -0700

    iov_iter: add ITER_BVEC_FLAG_NO_REF flag
    
    For ITER_BVEC, if we're holding on to kernel pages, the caller
    doesn't need to grab a reference to the bvec pages, and drop that
    same reference on IO completion. This is essentially safe for any
    ITER_BVEC, but some use cases end up reusing pages and uncondtionally
    dropping a page reference on completion. And example of that is
    sendfile(2), that ends up being a splice_in + splice_out on the
    pipe pages.
    
    Add a flag that tells us it's fine to not grab a page reference
    to the bvec pages, since that caller knows not to drop a reference
    when it's done with the pages.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index ecf584f6b82d..4e926641fa80 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -23,14 +23,23 @@ struct kvec {
 };
 
 enum iter_type {
-	ITER_IOVEC = 0,
-	ITER_KVEC = 2,
-	ITER_BVEC = 4,
-	ITER_PIPE = 8,
-	ITER_DISCARD = 16,
+	/* set if ITER_BVEC doesn't hold a bv_page ref */
+	ITER_BVEC_FLAG_NO_REF = 2,
+
+	/* iter types */
+	ITER_IOVEC = 4,
+	ITER_KVEC = 8,
+	ITER_BVEC = 16,
+	ITER_PIPE = 32,
+	ITER_DISCARD = 64,
 };
 
 struct iov_iter {
+	/*
+	 * Bit 0 is the read/write bit, set if we're writing.
+	 * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and
+	 * the caller isn't expecting to drop a page reference when done.
+	 */
 	unsigned int type;
 	size_t iov_offset;
 	size_t count;
@@ -84,6 +93,11 @@ static inline unsigned char iov_iter_rw(const struct iov_iter *i)
 	return i->type & (READ | WRITE);
 }
 
+static inline bool iov_iter_bvec_no_ref(const struct iov_iter *i)
+{
+	return (i->type & ITER_BVEC_FLAG_NO_REF) != 0;
+}
+
 /*
  * Total number of bytes covered by an iovec.
  *

commit 77000bc43da17d5d6bc4ebfaf44d52d43bb69492
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 4 16:31:04 2019 +0100

    uio: remove the unused iov_for_each macro
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index ecf584f6b82d..87477e1640f9 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -110,14 +110,6 @@ static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
 	};
 }
 
-#define iov_for_each(iov, iter, start)				\
-	if (iov_iter_type(start) == ITER_IOVEC ||		\
-	    iov_iter_type(start) == ITER_KVEC)			\
-	for (iter = (start);					\
-	     (iter).count &&					\
-	     ((iov = iov_iter_iovec(&(iter))), 1);		\
-	     iov_iter_advance(&(iter), (iov).iov_len))
-
 size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);

commit d05f443554b3c7dc6d46e3ba9c3c4de468875d4f
Author: Sagi Grimberg <sagi@lightbitslabs.com>
Date:   Mon Dec 3 17:52:09 2018 -0800

    iov_iter: introduce hash_and_copy_to_iter helper
    
    Allow consumers that want to use iov iterator helpers and also update
    a predefined hash calculation online when copying data. This is useful
    when copying incoming network buffers to a local iterator and calculate
    a digest on the incoming stream. nvme-tcp host driver that will be
    introduced in following patches is the first consumer via
    skb_copy_and_hash_datagram_iter.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sagi Grimberg <sagi@lightbitslabs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 41d1f8d3313d..ecf584f6b82d 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -11,6 +11,7 @@
 
 #include <linux/kernel.h>
 #include <linux/thread_info.h>
+#include <crypto/hash.h>
 #include <uapi/linux/uio.h>
 
 struct page;
@@ -269,6 +270,8 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 size_t csum_and_copy_to_iter(const void *addr, size_t bytes, void *csump, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 bool csum_and_copy_from_iter_full(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
+size_t hash_and_copy_to_iter(const void *addr, size_t bytes, void *hashp,
+		struct iov_iter *i);
 
 int import_iovec(int type, const struct iovec __user * uvector,
 		 unsigned nr_segs, unsigned fast_segs,

commit cb002d074dabfaa2248507fd9478d16a542e4f1e
Author: Sagi Grimberg <sagi@lightbitslabs.com>
Date:   Mon Dec 3 17:52:07 2018 -0800

    iov_iter: pass void csum pointer to csum_and_copy_to_iter
    
    The single caller to csum_and_copy_to_iter is skb_copy_and_csum_datagram
    and we are trying to unite its logic with skb_copy_datagram_iter by passing
    a callback to the copy function that we want to apply. Thus, we need
    to make the checksum pointer private to the function.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sagi Grimberg <sagi@lightbitslabs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 55ce99ddb912..41d1f8d3313d 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -266,7 +266,7 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 {
 	i->count = count;
 }
-size_t csum_and_copy_to_iter(const void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
+size_t csum_and_copy_to_iter(const void *addr, size_t bytes, void *csump, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 bool csum_and_copy_from_iter_full(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 

commit 9ea9ce0427aab02a2fd88fc608267cf6952119f1
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 20 00:57:56 2018 +0100

    iov_iter: Add I/O discard iterator
    
    Add a new iterator, ITER_DISCARD, that can only be used in READ mode and
    just discards any data copied to it.
    
    This is useful in a network filesystem for discarding any unwanted data
    sent by a server.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 3d8f1acc142c..55ce99ddb912 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -26,6 +26,7 @@ enum iter_type {
 	ITER_KVEC = 2,
 	ITER_BVEC = 4,
 	ITER_PIPE = 8,
+	ITER_DISCARD = 16,
 };
 
 struct iov_iter {
@@ -72,6 +73,11 @@ static inline bool iov_iter_is_pipe(const struct iov_iter *i)
 	return iov_iter_type(i) == ITER_PIPE;
 }
 
+static inline bool iov_iter_is_discard(const struct iov_iter *i)
+{
+	return iov_iter_type(i) == ITER_DISCARD;
+}
+
 static inline unsigned char iov_iter_rw(const struct iov_iter *i)
 {
 	return i->type & (READ | WRITE);
@@ -220,6 +226,7 @@ void iov_iter_bvec(struct iov_iter *i, unsigned int direction, const struct bio_
 			unsigned long nr_segs, size_t count);
 void iov_iter_pipe(struct iov_iter *i, unsigned int direction, struct pipe_inode_info *pipe,
 			size_t count);
+void iov_iter_discard(struct iov_iter *i, unsigned int direction, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, unsigned maxpages, size_t *start);
 ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,

commit aa563d7bca6e882ec2bdae24603c8f016401a144
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 20 00:57:56 2018 +0100

    iov_iter: Separate type from direction and use accessor functions
    
    In the iov_iter struct, separate the iterator type from the iterator
    direction and use accessor functions to access them in most places.
    
    Convert a bunch of places to use switch-statements to access them rather
    then chains of bitwise-AND statements.  This makes it easier to add further
    iterator types.  Also, this can be more efficient as to implement a switch
    of small contiguous integers, the compiler can use ~50% fewer compare
    instructions than it has to use bitwise-and instructions.
    
    Further, cease passing the iterator type into the iterator setup function.
    The iterator function can set that itself.  Only the direction is required.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index fcabc959c794..3d8f1acc142c 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -29,7 +29,7 @@ enum iter_type {
 };
 
 struct iov_iter {
-	int type;
+	unsigned int type;
 	size_t iov_offset;
 	size_t count;
 	union {
@@ -212,13 +212,13 @@ size_t copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i)
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 unsigned long iov_iter_gap_alignment(const struct iov_iter *i);
-void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
+void iov_iter_init(struct iov_iter *i, unsigned int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
-void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *kvec,
+void iov_iter_kvec(struct iov_iter *i, unsigned int direction, const struct kvec *kvec,
 			unsigned long nr_segs, size_t count);
-void iov_iter_bvec(struct iov_iter *i, int direction, const struct bio_vec *bvec,
+void iov_iter_bvec(struct iov_iter *i, unsigned int direction, const struct bio_vec *bvec,
 			unsigned long nr_segs, size_t count);
-void iov_iter_pipe(struct iov_iter *i, int direction, struct pipe_inode_info *pipe,
+void iov_iter_pipe(struct iov_iter *i, unsigned int direction, struct pipe_inode_info *pipe,
 			size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, unsigned maxpages, size_t *start);

commit 00e23707442a75b404392cef1405ab4fd498de6b
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 22 13:07:28 2018 +0100

    iov_iter: Use accessor function
    
    Use accessor functions to access an iterator's type and direction.  This
    allows for the possibility of using some other method of determining the
    type of iterator than if-chains with bitwise-AND conditions.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 422b1c01ee0d..fcabc959c794 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -21,7 +21,7 @@ struct kvec {
 	size_t iov_len;
 };
 
-enum {
+enum iter_type {
 	ITER_IOVEC = 0,
 	ITER_KVEC = 2,
 	ITER_BVEC = 4,
@@ -47,6 +47,36 @@ struct iov_iter {
 	};
 };
 
+static inline enum iter_type iov_iter_type(const struct iov_iter *i)
+{
+	return i->type & ~(READ | WRITE);
+}
+
+static inline bool iter_is_iovec(const struct iov_iter *i)
+{
+	return iov_iter_type(i) == ITER_IOVEC;
+}
+
+static inline bool iov_iter_is_kvec(const struct iov_iter *i)
+{
+	return iov_iter_type(i) == ITER_KVEC;
+}
+
+static inline bool iov_iter_is_bvec(const struct iov_iter *i)
+{
+	return iov_iter_type(i) == ITER_BVEC;
+}
+
+static inline bool iov_iter_is_pipe(const struct iov_iter *i)
+{
+	return iov_iter_type(i) == ITER_PIPE;
+}
+
+static inline unsigned char iov_iter_rw(const struct iov_iter *i)
+{
+	return i->type & (READ | WRITE);
+}
+
 /*
  * Total number of bytes covered by an iovec.
  *
@@ -74,7 +104,8 @@ static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
 }
 
 #define iov_for_each(iov, iter, start)				\
-	if (!((start).type & (ITER_BVEC | ITER_PIPE)))		\
+	if (iov_iter_type(start) == ITER_IOVEC ||		\
+	    iov_iter_type(start) == ITER_KVEC)			\
 	for (iter = (start);					\
 	     (iter).count &&					\
 	     ((iov = iov_iter_iovec(&(iter))), 1);		\
@@ -202,19 +233,6 @@ static inline size_t iov_iter_count(const struct iov_iter *i)
 	return i->count;
 }
 
-static inline bool iter_is_iovec(const struct iov_iter *i)
-{
-	return !(i->type & (ITER_BVEC | ITER_KVEC | ITER_PIPE));
-}
-
-/*
- * Get one of READ or WRITE out of iter->type without any other flags OR'd in
- * with it.
- *
- * The ?: is just for type safety.
- */
-#define iov_iter_rw(i) ((0 ? (struct iov_iter *)0 : (i))->type & (READ | WRITE))
-
 /*
  * Cap the iov_iter by given limit; note that the second argument is
  * *not* the new size - it's upper limit for such.  Passing it a value

commit dfb06cba8c73c0704710b2e3fbe2c35ac66a01b4
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Sep 5 13:31:40 2018 -0700

    uaccess: Fix is_source param for check_copy_size() in copy_to_iter_mcsafe()
    
    copy_to_iter_mcsafe() is passing in the is_source parameter as "false"
    to check_copy_size(). This is different than what copy_to_iter() does.
    Also, the addr parameter passed to check_copy_size() is the source so
    therefore we should be passing in "true" instead.
    
    Fixes: 8780356ef630 ("x86/asm/memcpy_mcsafe: Define copy_to_iter_mcsafe()")
    Cc: <stable@vger.kernel.org>
    Reported-by: Fan Du <fan.du@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Reported-by: Wenwei Tao <wenwei.tww@alibaba-inc.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 409c845d4cd3..422b1c01ee0d 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -172,7 +172,7 @@ size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i)
 static __always_inline __must_check
 size_t copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i)
 {
-	if (unlikely(!check_copy_size(addr, bytes, false)))
+	if (unlikely(!check_copy_size(addr, bytes, true)))
 		return 0;
 	else
 		return _copy_to_iter_mcsafe(addr, bytes, i);

commit 522239b445a2de988edb81672963708a6aaf9046
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 22 23:17:03 2018 -0700

    uio, lib: Fix CONFIG_ARCH_HAS_UACCESS_MCSAFE compilation
    
    Add a common Kconfig CONFIG_ARCH_HAS_UACCESS_MCSAFE that archs can
    optionally select, and fixup the declaration of _copy_to_iter_mcsafe().
    
    Fixes: 8780356ef630 ("x86/asm/memcpy_mcsafe: Define copy_to_iter_mcsafe()")
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index f5766e853a77..409c845d4cd3 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -155,7 +155,7 @@ size_t _copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i);
 #endif
 
 #ifdef CONFIG_ARCH_HAS_UACCESS_MCSAFE
-size_t _copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i);
+size_t _copy_to_iter_mcsafe(const void *addr, size_t bytes, struct iov_iter *i);
 #else
 #define _copy_to_iter_mcsafe _copy_to_iter
 #endif

commit 8780356ef630aa577fd4daa49e49b79674711fae
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 3 17:06:31 2018 -0700

    x86/asm/memcpy_mcsafe: Define copy_to_iter_mcsafe()
    
    Use the updated memcpy_mcsafe() implementation to define
    copy_user_mcsafe() and copy_to_iter_mcsafe(). The most significant
    difference from typical copy_to_iter() is that the ITER_KVEC and
    ITER_BVEC iterator types can fail to complete a full transfer.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: hch@lst.de
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-nvdimm@lists.01.org
    Link: http://lkml.kernel.org/r/152539239150.31796.9189779163576449784.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index e67e12adb136..f5766e853a77 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -154,6 +154,12 @@ size_t _copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i);
 #define _copy_from_iter_flushcache _copy_from_iter_nocache
 #endif
 
+#ifdef CONFIG_ARCH_HAS_UACCESS_MCSAFE
+size_t _copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i);
+#else
+#define _copy_to_iter_mcsafe _copy_to_iter
+#endif
+
 static __always_inline __must_check
 size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i)
 {
@@ -163,6 +169,15 @@ size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i)
 		return _copy_from_iter_flushcache(addr, bytes, i);
 }
 
+static __always_inline __must_check
+size_t copy_to_iter_mcsafe(void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, false)))
+		return 0;
+	else
+		return _copy_to_iter_mcsafe(addr, bytes, i);
+}
+
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 unsigned long iov_iter_gap_alignment(const struct iov_iter *i);

commit 09cf698a594276139b7dfafb232af3fe4fbc4438
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 18 01:44:03 2017 -0500

    new primitive: iov_iter_for_each_range()
    
    For kvec and bvec: feeds segments to given callback as long as it
    returns 0.  For iovec and pipe: fails.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 5885daeae721..e67e12adb136 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -244,4 +244,8 @@ int compat_import_iovec(int type, const struct compat_iovec __user * uvector,
 int import_single_range(int type, void __user *buf, size_t len,
 		 struct iovec *iov, struct iov_iter *i);
 
+int iov_iter_for_each_range(struct iov_iter *i, size_t bytes,
+			    int (*f)(struct kvec *vec, void *context),
+			    void *context);
+
 #endif

commit faea13297ea739f94913d56d7b865134b4fc8726
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 24 14:03:29 2017 -0400

    kill iov_shorten()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 8a642cda641c..5885daeae721 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -80,8 +80,6 @@ static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
 	     ((iov = iov_iter_iovec(&(iter))), 1);		\
 	     iov_iter_advance(&(iter), (iov).iov_len))
 
-unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
-
 size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);

commit c43aeb198048f64abda8655fdcdebe71cf1877ba
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 10 07:40:49 2017 -0400

    fix brown paperbag bug in inlined copy_..._iter()
    
    "copied nothing" == "return 0", not "return full size".
    
    Fixes: aa28de275a24 "iov_iter/hardening: move object size checks to inlined part"
    Spotted-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 342d2dc225b9..8a642cda641c 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -103,7 +103,7 @@ static __always_inline __must_check
 size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i)
 {
 	if (unlikely(!check_copy_size(addr, bytes, true)))
-		return bytes;
+		return 0;
 	else
 		return _copy_to_iter(addr, bytes, i);
 }
@@ -112,7 +112,7 @@ static __always_inline __must_check
 size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)
 {
 	if (unlikely(!check_copy_size(addr, bytes, false)))
-		return bytes;
+		return 0;
 	else
 		return _copy_from_iter(addr, bytes, i);
 }
@@ -130,7 +130,7 @@ static __always_inline __must_check
 size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i)
 {
 	if (unlikely(!check_copy_size(addr, bytes, false)))
-		return bytes;
+		return 0;
 	else
 		return _copy_from_iter_nocache(addr, bytes, i);
 }
@@ -160,7 +160,7 @@ static __always_inline __must_check
 size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i)
 {
 	if (unlikely(!check_copy_size(addr, bytes, false)))
-		return bytes;
+		return 0;
 	else
 		return _copy_from_iter_flushcache(addr, bytes, i);
 }

commit 6a37e94009b1a76d415b2759755f5cc7854c4ff6
Merge: da029c11e6b1 09fc68dc66f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 20:39:20 2017 -0700

    Merge branch 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull iov_iter hardening from Al Viro:
     "This is the iov_iter/uaccess/hardening pile.
    
      For one thing, it trims the inline part of copy_to_user/copy_from_user
      to the minimum that *does* need to be inlined - object size checks,
      basically. For another, it sanitizes the checks for iov_iter
      primitives. There are 4 groups of checks: access_ok(), might_fault(),
      object size and KASAN.
    
       - access_ok() had been verified by whoever had set the iov_iter up.
         However, that has happened in a function far away, so proving that
         there's no path to actual copying bypassing those checks is hard
         and proving that iov_iter has not been buggered in the meanwhile is
         also not pleasant. So we want those redone in actual
         copyin/copyout.
    
       - might_fault() is better off consolidated - we know whether it needs
         to be checked as soon as we enter iov_iter primitive and observe
         the iov_iter flavour. No need to wait until the copyin/copyout. The
         call chains are short enough to make sure we won't miss anything -
         in fact, it's more robust that way, since there are cases where we
         do e.g. forced fault-in before getting to copyin/copyout. It's not
         quite what we need to check (in particular, combination of
         iovec-backed and set_fs(KERNEL_DS) is almost certainly a bug, not a
         cause to skip checks), but that's for later series. For now let's
         keep might_fault().
    
       - KASAN checks belong in copyin/copyout - at the same level where
         other iov_iter flavours would've hit them in memcpy().
    
       - object size checks should apply to *all* iov_iter flavours, not
         just iovec-backed ones.
    
      There are two groups of primitives - one gets the kernel object
      described as pointer + size (copy_to_iter(), etc.) while another gets
      it as page + offset + size (copy_page_to_iter(), etc.)
    
      For the first group the checks are best done where we actually have a
      chance to find the object size. In other words, those belong in inline
      wrappers in uio.h, before calling into iov_iter.c. Same kind as we
      have for inlined part of copy_to_user().
    
      For the second group there is no object to look at - offset in page is
      just a number, it bears no type information. So we do them in the
      common helper called by iov_iter.c primitives of that kind. All it
      currently does is checking that we are not trying to access outside of
      the compound page; eventually we might want to add some sanity checks
      on the page involved.
    
      So the things we need in copyin/copyout part of iov_iter.c do not
      quite match anything in uaccess.h (we want no zeroing, we *do* want
      access_ok() and KASAN and we want no might_fault() or object size
      checks done on that level). OTOH, these needs are simple enough to
      provide a couple of helpers (static in iov_iter.c) doing just what we
      need..."
    
    * 'uaccess-work.iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      iov_iter: saner checks on copyin/copyout
      iov_iter: sanity checks for copy to/from page primitives
      iov_iter/hardening: move object size checks to inlined part
      copy_{to,from}_user(): consolidate object size checks
      copy_{from,to}_user(): move kasan checks and might_fault() out-of-line

commit aa28de275a248879f9828cb9f7ee7e119c72ff96
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 29 21:45:10 2017 -0400

    iov_iter/hardening: move object size checks to inlined part
    
    There we actually have useful information about object sizes.
    Note: this patch has them done for all iov_iter flavours.
    Right now we do them twice in iovec case, but that'll change
    very shortly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index f2d36a3d3005..243e2362fe1a 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -10,6 +10,7 @@
 #define __LINUX_UIO_H
 
 #include <linux/kernel.h>
+#include <linux/thread_info.h>
 #include <uapi/linux/uio.h>
 
 struct page;
@@ -91,11 +92,58 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
-size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
-size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
-bool copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i);
-size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
-bool copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i);
+
+size_t _copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
+size_t _copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
+bool _copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i);
+size_t _copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
+bool _copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i);
+
+static __always_inline __must_check
+size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, true)))
+		return bytes;
+	else
+		return _copy_to_iter(addr, bytes, i);
+}
+
+static __always_inline __must_check
+size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, false)))
+		return bytes;
+	else
+		return _copy_from_iter(addr, bytes, i);
+}
+
+static __always_inline __must_check
+bool copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, false)))
+		return false;
+	else
+		return _copy_from_iter_full(addr, bytes, i);
+}
+
+static __always_inline __must_check
+size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, false)))
+		return bytes;
+	else
+		return _copy_from_iter_nocache(addr, bytes, i);
+}
+
+static __always_inline __must_check
+bool copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i)
+{
+	if (unlikely(!check_copy_size(addr, bytes, false)))
+		return false;
+	else
+		return _copy_from_iter_full_nocache(addr, bytes, i);
+}
+
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 unsigned long iov_iter_gap_alignment(const struct iov_iter *i);

commit 0aed55af88345b5d673240f90e671d79662fb01e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon May 29 12:22:50 2017 -0700

    x86, uaccess: introduce copy_from_iter_flushcache for pmem / cache-bypass operations
    
    The pmem driver has a need to transfer data with a persistent memory
    destination and be able to rely on the fact that the destination writes are not
    cached. It is sufficient for the writes to be flushed to a cpu-store-buffer
    (non-temporal / "movnt" in x86 terms), as we expect userspace to call fsync()
    to ensure data-writes have reached a power-fail-safe zone in the platform. The
    fsync() triggers a REQ_FUA or REQ_FLUSH to the pmem driver which will turn
    around and fence previous writes with an "sfence".
    
    Implement a __copy_from_user_inatomic_flushcache, memcpy_page_flushcache, and
    memcpy_flushcache, that guarantee that the destination buffer is not dirty in
    the cpu cache on completion. The new copy_from_iter_flushcache and sub-routines
    will be used to replace the "pmem api" (include/linux/pmem.h +
    arch/x86/include/asm/pmem.h). The availability of copy_from_iter_flushcache()
    and memcpy_flushcache() are gated by the CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE
    config symbol, and fallback to copy_from_iter_nocache() and plain memcpy()
    otherwise.
    
    This is meant to satisfy the concern from Linus that if a driver wants to do
    something beyond the normal nocache semantics it should be something private to
    that driver [1], and Al's concern that anything uaccess related belongs with
    the rest of the uaccess code [2].
    
    The first consumer of this interface is a new 'copy_from_iter' dax operation so
    that pmem can inject cache maintenance operations without imposing this
    overhead on other dax-capable drivers.
    
    [1]: https://lists.01.org/pipermail/linux-nvdimm/2017-January/008364.html
    [2]: https://lists.01.org/pipermail/linux-nvdimm/2017-April/009942.html
    
    Cc: <x86@kernel.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Matthew Wilcox <mawilcox@microsoft.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index f2d36a3d3005..55cd54a0e941 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -95,6 +95,21 @@ size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
 bool copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
+#ifdef CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE
+/*
+ * Note, users like pmem that depend on the stricter semantics of
+ * copy_from_iter_flushcache() than copy_from_iter_nocache() must check for
+ * IS_ENABLED(CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE) before assuming that the
+ * destination is flushed from the cache on return.
+ */
+size_t copy_from_iter_flushcache(void *addr, size_t bytes, struct iov_iter *i);
+#else
+static inline size_t copy_from_iter_flushcache(void *addr, size_t bytes,
+				       struct iov_iter *i)
+{
+	return copy_from_iter_nocache(addr, bytes, i);
+}
+#endif
 bool copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i);
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);

commit 27c0e3748e41ca79171ffa3e97415a20af6facd0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 17 18:42:24 2017 -0500

    [iov_iter] new privimitive: iov_iter_revert()
    
    opposite to iov_iter_advance(); the caller is responsible for never
    using it to move back past the initial position.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 804e34c6f981..f2d36a3d3005 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -39,7 +39,10 @@ struct iov_iter {
 	};
 	union {
 		unsigned long nr_segs;
-		int idx;
+		struct {
+			int idx;
+			int start_idx;
+		};
 	};
 };
 
@@ -81,6 +84,7 @@ unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
 size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
+void iov_iter_revert(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,

commit 9a19a6db37ee0b7a6db796b3dcd6bb6e7237d6ea
Merge: bd9999cd6a5e c4364f837caf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:24:44 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
    
     - more ->d_init() stuff (work.dcache)
    
     - pathname resolution cleanups (work.namei)
    
     - a few missing iov_iter primitives - copy_from_iter_full() and
       friends. Either copy the full requested amount, advance the iterator
       and return true, or fail, return false and do _not_ advance the
       iterator. Quite a few open-coded callers converted (and became more
       readable and harder to fuck up that way) (work.iov_iter)
    
     - several assorted patches, the big one being logfs removal
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      logfs: remove from tree
      vfs: fix put_compat_statfs64() does not handle errors
      namei: fold should_follow_link() with the step into not-followed link
      namei: pass both WALK_GET and WALK_MORE to should_follow_link()
      namei: invert WALK_PUT logics
      namei: shift interpretation of LOOKUP_FOLLOW inside should_follow_link()
      namei: saner calling conventions for mountpoint_last()
      namei.c: get rid of user_path_parent()
      switch getfrag callbacks to ..._full() primitives
      make skb_add_data,{_nocache}() and skb_copy_to_page_nocache() advance only on success
      [iov_iter] new primitives - copy_from_iter_full() and friends
      don't open-code file_inode()
      ceph: switch to use of ->d_init()
      ceph: unify dentry_operations instances
      lustre: switch to use of ->d_init()

commit cbbd26b8b1a6af9c02e2b6523e12bd50cc765059
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 1 22:09:04 2016 -0400

    [iov_iter] new primitives - copy_from_iter_full() and friends
    
    copy_from_iter_full(), copy_from_iter_full_nocache() and
    csum_and_copy_from_iter_full() - counterparts of copy_from_iter()
    et.al., advancing iterator only in case of successful full copy
    and returning whether it had been successful or not.
    
    Convert some obvious users.  *NOTE* - do not blindly assume that
    something is a good candidate for those unless you are sure that
    not advancing iov_iter in failure case is the right thing in
    this case.  Anything that does short read/short write kind of
    stuff (or is in a loop, etc.) is unlikely to be a good one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 6e22b544d039..e57c0ccd61c6 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -89,7 +89,9 @@ size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
+bool copy_from_iter_full(void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
+bool copy_from_iter_full_nocache(void *addr, size_t bytes, struct iov_iter *i);
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 unsigned long iov_iter_gap_alignment(const struct iov_iter *i);
@@ -155,6 +157,7 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 }
 size_t csum_and_copy_to_iter(const void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
+bool csum_and_copy_from_iter_full(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
 int import_iovec(int type, const struct iovec __user * uvector,
 		 unsigned nr_segs, unsigned fast_segs,

commit d38499530e5f170d30f32d3841fade204e63081d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:11 2016 -0600

    fs: decouple READ and WRITE from the block layer ops
    
    Move READ and WRITE to kernel.h and don't define them in terms of block
    layer ops; they are our generic data direction indicators these days
    and have no more resemblance with the block layer ops.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 6e22b544d039..d5aba1512b8b 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -125,7 +125,7 @@ static inline bool iter_is_iovec(const struct iov_iter *i)
  *
  * The ?: is just for type safety.
  */
-#define iov_iter_rw(i) ((0 ? (struct iov_iter *)0 : (i))->type & RW_MASK)
+#define iov_iter_rw(i) ((0 ? (struct iov_iter *)0 : (i))->type & (READ | WRITE))
 
 /*
  * Cap the iov_iter by given limit; note that the second argument is

commit fed41f7d039bad02f94cad9059e4b14cd81d13f2
Merge: abb5a14fa20f cd27e455042d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:38:49 2016 -0700

    Merge branch 'work.splice_read' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull splice fixups from Al Viro:
     "A couple of fixups for interaction of pipe-backed iov_iter with
      O_DIRECT reads + constification of a couple of primitives in uio.h
      missed by previous rounds.
    
      Kudos to davej - his fuzzing has caught those bugs"
    
    * 'work.splice_read' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      [btrfs] fix check_direct_IO() for non-iovec iterators
      constify iov_iter_count() and iter_is_iovec()
      fix ITER_PIPE interaction with direct_IO

commit abb5a14fa20fdd400995926134b7be9eb8ce6048
Merge: 911f9dab301e e55f1d1d13e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:04:49 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted misc bits and pieces.
    
      There are several single-topic branches left after this (rename2
      series from Miklos, current_time series from Deepa Dinamani, xattr
      series from Andreas, uaccess stuff from from me) and I'd prefer to
      send those separately"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (39 commits)
      proc: switch auxv to use of __mem_open()
      hpfs: support FIEMAP
      cifs: get rid of unused arguments of CIFSSMBWrite()
      posix_acl: uapi header split
      posix_acl: xattr representation cleanups
      fs/aio.c: eliminate redundant loads in put_aio_ring_file
      fs/internal.h: add const to ns_dentry_operations declaration
      compat: remove compat_printk()
      fs/buffer.c: make __getblk_slow() static
      proc: unsigned file descriptors
      fs/file: more unsigned file descriptors
      fs: compat: remove redundant check of nr_segs
      cachefiles: Fix attempt to read i_blocks after deleting file [ver #2]
      cifs: don't use memcpy() to copy struct iov_iter
      get rid of separate multipage fault-in primitives
      fs: Avoid premature clearing of capabilities
      fs: Give dentry to inode_change_ok() instead of inode
      fuse: Propagate dentry down to inode_change_ok()
      ceph: Propagate dentry down to inode_change_ok()
      xfs: Propagate dentry down to inode_change_ok()
      ...

commit b57332b4105abf1d518d93886e547ee2f98cd414
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 10 13:57:37 2016 -0400

    constify iov_iter_count() and iter_is_iovec()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index b5ebe6dca404..544c03552b99 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -110,12 +110,12 @@ int iov_iter_npages(const struct iov_iter *i, int maxpages);
 
 const void *dup_iter(struct iov_iter *new, struct iov_iter *old, gfp_t flags);
 
-static inline size_t iov_iter_count(struct iov_iter *i)
+static inline size_t iov_iter_count(const struct iov_iter *i)
 {
 	return i->count;
 }
 
-static inline bool iter_is_iovec(struct iov_iter *i)
+static inline bool iter_is_iovec(const struct iov_iter *i)
 {
 	return !(i->type & (ITER_BVEC | ITER_KVEC | ITER_PIPE));
 }

commit 241699cd72a8489c9446ae3910ddd243e9b9061b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Sep 22 16:33:12 2016 -0400

    new iov_iter flavour: pipe-backed
    
    iov_iter variant for passing data into pipe.  copy_to_iter()
    copies data into page(s) it has allocated and stuffs them into
    the pipe; copy_page_to_iter() stuffs there a reference to the
    page given to it.  Both will try to coalesce if possible.
    iov_iter_zero() is similar to copy_to_iter(); iov_iter_get_pages()
    and friends will do as copy_to_iter() would have and return the
    pages where the data would've been copied.  iov_iter_advance()
    will truncate everything past the spot it has advanced to.
    
    New primitive: iov_iter_pipe(), used for initializing those.
    pipe should be locked all along.
    
    Running out of space acts as fault would for iovec-backed ones;
    in other words, giving it to ->read_iter() may result in short
    read if the pipe overflows, or -EFAULT if it happens with nothing
    copied there.
    
    In other words, ->read_iter() on those acts pretty much like
    ->splice_read().  Moreover, all generic_file_splice_read() users,
    as well as many other ->splice_read() instances can be switched
    to that scheme - that'll happen in the next commit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 75b4aaf31a9d..b5ebe6dca404 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -13,6 +13,7 @@
 #include <uapi/linux/uio.h>
 
 struct page;
+struct pipe_inode_info;
 
 struct kvec {
 	void *iov_base; /* and that should *never* hold a userland pointer */
@@ -23,6 +24,7 @@ enum {
 	ITER_IOVEC = 0,
 	ITER_KVEC = 2,
 	ITER_BVEC = 4,
+	ITER_PIPE = 8,
 };
 
 struct iov_iter {
@@ -33,8 +35,12 @@ struct iov_iter {
 		const struct iovec *iov;
 		const struct kvec *kvec;
 		const struct bio_vec *bvec;
+		struct pipe_inode_info *pipe;
+	};
+	union {
+		unsigned long nr_segs;
+		int idx;
 	};
-	unsigned long nr_segs;
 };
 
 /*
@@ -64,7 +70,7 @@ static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
 }
 
 #define iov_for_each(iov, iter, start)				\
-	if (!((start).type & ITER_BVEC))			\
+	if (!((start).type & (ITER_BVEC | ITER_PIPE)))		\
 	for (iter = (start);					\
 	     (iter).count &&					\
 	     ((iov = iov_iter_iovec(&(iter))), 1);		\
@@ -94,6 +100,8 @@ void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *kvec,
 			unsigned long nr_segs, size_t count);
 void iov_iter_bvec(struct iov_iter *i, int direction, const struct bio_vec *bvec,
 			unsigned long nr_segs, size_t count);
+void iov_iter_pipe(struct iov_iter *i, int direction, struct pipe_inode_info *pipe,
+			size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, unsigned maxpages, size_t *start);
 ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
@@ -109,7 +117,7 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 
 static inline bool iter_is_iovec(struct iov_iter *i)
 {
-	return !(i->type & (ITER_BVEC | ITER_KVEC));
+	return !(i->type & (ITER_BVEC | ITER_KVEC | ITER_PIPE));
 }
 
 /*

commit 4bce9f6ee8f84fdf333d0fd7fcf7f0d8c7cce7fa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Sep 17 18:02:44 2016 -0400

    get rid of separate multipage fault-in primitives
    
    * the only remaining callers of "short" fault-ins are just as happy with generic
    variants (both in lib/iov_iter.c); switch them to multipage variants, kill the
    "short" ones
    * rename the multipage variants to now available plain ones.
    * get rid of compat macro defining iov_iter_fault_in_multipage_readable by
    expanding it in its only user.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 75b4aaf31a9d..7709f8d4a9cb 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -76,7 +76,6 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
-#define iov_iter_fault_in_multipages_readable iov_iter_fault_in_readable
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);

commit d4690f1e1cdabb4d61207b6787b1605a0dc0aeab
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Fri Sep 16 00:11:45 2016 +0100

    fix iov_iter_fault_in_readable()
    
    ... by turning it into what used to be multipages counterpart
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 1b5d1cd796e2..75b4aaf31a9d 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -76,7 +76,7 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
-int iov_iter_fault_in_multipages_readable(struct iov_iter *i, size_t bytes);
+#define iov_iter_fault_in_multipages_readable iov_iter_fault_in_readable
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);

commit 357f435d8a0d32068c75f3c7176434d992b3adb7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 8 19:05:19 2016 -0400

    fix the copy vs. map logics in blk_rq_map_user_iov()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index fd9bcfedad42..1b5d1cd796e2 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -87,6 +87,7 @@ size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
+unsigned long iov_iter_gap_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
 void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *kvec,

commit 36f7a8a4cd2e99b7172ab8ed2130c5c841466824
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 6 16:49:22 2015 -0500

    iov_iter: constify {csum_and_,}copy_to_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 8b01e1c3c614..fd9bcfedad42 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -82,7 +82,7 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
-size_t copy_to_iter(void *addr, size_t bytes, struct iov_iter *i);
+size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
@@ -145,7 +145,7 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 {
 	i->count = count;
 }
-size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
+size_t csum_and_copy_to_iter(const void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
 int import_iovec(int type, const struct iovec __user * uvector,

commit bd8e0ff956456ad9071dbb6c2ed7d33bd22fc216
Author: Omar Sandoval <osandov@osandov.com>
Date:   Tue Mar 17 14:04:02 2015 -0700

    new helper: iov_iter_rw()
    
    Get either READ or WRITE out of iter->type.
    
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 15f11fb9fff6..8b01e1c3c614 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -111,6 +111,14 @@ static inline bool iter_is_iovec(struct iov_iter *i)
 	return !(i->type & (ITER_BVEC | ITER_KVEC));
 }
 
+/*
+ * Get one of READ or WRITE out of iter->type without any other flags OR'd in
+ * with it.
+ *
+ * The ?: is just for type safety.
+ */
+#define iov_iter_rw(i) ((0 ? (struct iov_iter *)0 : (i))->type & RW_MASK)
+
 /*
  * Cap the iov_iter by given limit; note that the second argument is
  * *not* the new size - it's upper limit for such.  Passing it a value

commit 36e9f6535f398952772df5238b23e795a2810f86
Merge: a96114fa1aca bc917be81059
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:26:51 2015 -0400

    Merge branch 'iov_iter' into for-next

commit 171a02032bf1e1bb35442a38d6e25e0dcbb85c63
Author: Anton Altaparmakov <anton@tuxera.com>
Date:   Wed Mar 11 10:43:31 2015 -0400

    VFS: Add iov_iter_fault_in_multipages_readable()
    
    simillar to iov_iter_fault_in_readable() but differs in that it is
    not limited to faulting in the first iovec and instead faults in
    "bytes" bytes iterating over the iovecs as necessary.
    
    Also, instead of only faulting in the first and last page of the
    range, all pages are faulted in.
    
    This function is needed by NTFS when it does multi page file
    writes.
    
    Signed-off-by: Anton Altaparmakov <anton@tuxera.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 71880299ed48..a69ed25af07f 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -76,6 +76,7 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
+int iov_iter_fault_in_multipages_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);

commit bc917be8105993c256338ad1189650364a741483
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 21 17:45:43 2015 -0400

    saner iov_iter initialization primitives
    
    iovec-backed iov_iter instances are assumed to satisfy several properties:
            * no more than UIO_MAXIOV elements in iovec array
            * total size of all ranges is no more than MAX_RW_COUNT
            * all ranges pass access_ok().
    
    The problem is, invariants of data structures should be established in the
    primitives creating those data structures, not in the code using those
    primitives.  And iov_iter_init() violates that principle.  For a while we
    managed to get away with that, but once the use of iov_iter started to
    spread, it didn't take long for shit to hit the fan - missed check in
    sys_sendto() had introduced a roothole.
    
    We _do_ have primitives for importing and validating iovecs (both native and
    compat ones) and those primitives are almost always followed by shoving the
    resulting iovec into iov_iter.  Life would be considerably simpler (and safer)
    if we combined those primitives with initializing iov_iter.
    
    That gives us two new primitives - import_iovec() and compat_import_iovec().
    Calling conventions:
            iovec = iov_array;
            err = import_iovec(direction, uvec, nr_segs,
                               ARRAY_SIZE(iov_array), &iovec,
                               &iter);
    imports user vector into kernel space (into iov_array if it fits, allocated
    if it doesn't fit or if iovec was NULL), validates it and sets iter up to
    refer to it.  On success 0 is returned and allocated kernel copy (or NULL
    if the array had fit into caller-supplied one) is returned via iovec.
    On failure all allocations are undone and -E... is returned.  If the total
    size of ranges exceeds MAX_RW_COUNT, the excess is silently truncated.
    
    compat_import_iovec() expects uvec to be a pointer to user array of compat_iovec;
    otherwise it's identical to import_iovec().
    
    Finally, import_single_range() sets iov_iter backed by single-element iovec
    covering a user-supplied range -
    
            err = import_single_range(direction, address, size, iovec, &iter);
    
    does validation and sets iter up.  Again, size in excess of MAX_RW_COUNT gets
    silently truncated.
    
    Next commits will be switching the things up to use of those and reducing
    the amount of iov_iter_init() instances.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 71880299ed48..1f4a37f1f025 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -139,4 +139,18 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
+int import_iovec(int type, const struct iovec __user * uvector,
+		 unsigned nr_segs, unsigned fast_segs,
+		 struct iovec **iov, struct iov_iter *i);
+
+#ifdef CONFIG_COMPAT
+struct compat_iovec;
+int compat_import_iovec(int type, const struct compat_iovec __user * uvector,
+		 unsigned nr_segs, unsigned fast_segs,
+		 struct iovec **iov, struct iov_iter *i);
+#endif
+
+int import_single_range(int type, void __user *buf, size_t len,
+		 struct iovec *iov, struct iov_iter *i);
+
 #endif

commit 4b8164b91d9fdff4dbac0a742d076bdff7fda21b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 31 20:08:47 2015 -0500

    new helper: dup_iter()
    
    Copy iter and kmemdup the underlying array for the copy.  Returns
    a pointer to result of kmemdup() to be kfree()'d later.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 07a022641996..71880299ed48 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -98,6 +98,8 @@ ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
 			size_t maxsize, size_t *start);
 int iov_iter_npages(const struct iov_iter *i, int maxpages);
 
+const void *dup_iter(struct iov_iter *new, struct iov_iter *old, gfp_t flags);
+
 static inline size_t iov_iter_count(struct iov_iter *i)
 {
 	return i->count;

commit 66dc830d14a222c9214a8557e9feb1e4a67a3857
Merge: 05016b0f0a9d dbe4e192a234
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 15:48:33 2015 -0800

    Merge branch 'iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull iov_iter updates from Al Viro:
     "More iov_iter work - missing counterpart of iov_iter_init() for
      bvec-backed ones and vfs_read_iter()/vfs_write_iter() - wrappers for
      sync calls of ->read_iter()/->write_iter()"
    
    * 'iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: add vfs_iter_{read,write} helpers
      new helper: iov_iter_bvec()

commit 57dd8a0735aabff4862025cf64ad94da3d80e620
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 16:03:43 2014 -0500

    vhost: vhost_scsi_handle_vq() should just use copy_from_user()
    
    it has just verified that it asks no more than the length of the
    first segment of iovec.
    
    And with that the last user of stuff in lib/iovec.c is gone.
    RIP.
    
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Nicholas A. Bellinger <nab@linux-iscsi.org>
    Cc: kvm@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 02bd8a92038a..3e0cb4ea3905 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -135,6 +135,4 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
-int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
-			int offset, int len);
 #endif

commit ba7438aed924133df54a60e4cd5499d359bcf2a8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 15:51:28 2014 -0500

    vhost: don't bother copying iovecs in handle_rx(), kill memcpy_toiovecend()
    
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: kvm@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index af3439f4ebf2..02bd8a92038a 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -137,7 +137,4 @@ size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct io
 
 int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
 			int offset, int len);
-int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,
-		      int offset, int len);
-
 #endif

commit aad9a1cec7dcd1d45809b64643fce37061b17788
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 10 14:49:01 2014 -0500

    vhost: switch vhost get_indirect() to iov_iter, kill memcpy_fromiovec()
    
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: kvm@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 1c5e453f7ea9..af3439f4ebf2 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -135,7 +135,6 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
-int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
 			int offset, int len);
 int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,

commit 05afcb77eb4713f46e7ebaa3cb54bc465c5d516e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 23 01:08:07 2015 -0500

    new helper: iov_iter_bvec()
    
    similar to iov_iter_kvec(), for ITER_BVEC ones
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 1c5e453f7ea9..b447402d9737 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -88,7 +88,9 @@ size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
-void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *iov,
+void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *kvec,
+			unsigned long nr_segs, size_t count);
+void iov_iter_bvec(struct iov_iter *i, int direction, const struct bio_vec *bvec,
 			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, unsigned maxpages, size_t *start);

commit 777eda2c5b84d6f3543f4aecbf4cd1f29b222a81
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 17 04:46:46 2014 -0500

    new helper: iter_is_iovec()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index a41e252396c0..1c5e453f7ea9 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -101,6 +101,11 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 	return i->count;
 }
 
+static inline bool iter_is_iovec(struct iov_iter *i)
+{
+	return !(i->type & (ITER_BVEC | ITER_KVEC));
+}
+
 /*
  * Cap the iov_iter by given limit; note that the second argument is
  * *not* the new size - it's upper limit for such.  Passing it a value

commit 218321e7a0838c2be974539f0a5341b398d4432b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 24 19:45:05 2014 -0500

    bury memcpy_toiovec()
    
    no users left
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index bd8569a14c4a..a41e252396c0 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -131,7 +131,6 @@ size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_
 size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
-int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
 int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
 			int offset, int len);
 int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,

commit aa583096d9767892983332e7c1a984bd17e3cd39
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 27 20:27:08 2014 -0500

    copy_from_iter_nocache()
    
    BTW, do we want memcpy_nocache()?
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index c567655b9595..bd8569a14c4a 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -83,6 +83,7 @@ size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 size_t copy_to_iter(void *addr, size_t bytes, struct iov_iter *i);
 size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
+size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i);
 size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,

commit abb78f875f3fcedb88d85eef9f7be7aa474c6727
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 24 14:46:11 2014 -0500

    new helper: iov_iter_kvec()
    
    initialization of kvec-backed iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 28ed2d904deb..c567655b9595 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -87,6 +87,8 @@ size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
+void iov_iter_kvec(struct iov_iter *i, int direction, const struct kvec *iov,
+			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, unsigned maxpages, size_t *start);
 ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,

commit a604ec7e9ffea22fed84db8306585090e7a6e85d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 24 01:08:00 2014 -0500

    csum_and_copy_..._iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 6e16945ec832..28ed2d904deb 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -124,6 +124,8 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 {
 	i->count = count;
 }
+size_t csum_and_copy_to_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
+size_t csum_and_copy_from_iter(void *addr, size_t bytes, __wsum *csum, struct iov_iter *i);
 
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);

commit a280455fa87053eed59de8464200d03ae4caa8c3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Nov 27 14:48:42 2014 -0500

    iov_iter.c: handle ITER_KVEC directly
    
    ... without bothering with copy_..._user()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 9b1581414cd4..6e16945ec832 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -31,6 +31,7 @@ struct iov_iter {
 	size_t count;
 	union {
 		const struct iovec *iov;
+		const struct kvec *kvec;
 		const struct bio_vec *bvec;
 	};
 	unsigned long nr_segs;

commit c35e02480014f7a86e264a2fda39a568690163da
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Aug 1 09:27:22 2014 -0400

    Add copy_to_iter(), copy_from_iter() and iov_iter_zero()
    
    For DAX, we want to be able to copy between iovecs and kernel addresses
    that don't necessarily have a struct page.  This is a fairly simple
    rearrangement for bvec iters to kmap the pages outside and pass them in,
    but for user iovecs it gets more complicated because we might try various
    different ways to kmap the memory.  Duplicating the existing logic works
    out best in this case.
    
    We need to be able to write zeroes to an iovec for reads from unwritten
    ranges in a file.  This is performed by the new iov_iter_zero() function,
    again patterned after the existing code that handles iovec iterators.
    
    [AV: and export the buggers...]
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 290fbf0b6b8a..9b1581414cd4 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -80,6 +80,9 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
+size_t copy_to_iter(void *addr, size_t bytes, struct iov_iter *i);
+size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i);
+size_t iov_iter_zero(size_t bytes, struct iov_iter *);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);

commit 2c80929c4c4d54e568b07ab85877d5fd38f4b02f
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Sep 24 17:09:11 2014 +0200

    fuse: honour max_read and max_write in direct_io mode
    
    The third argument of fuse_get_user_pages() "nbytesp" refers to the number of
    bytes a caller asked to pack into fuse request. This value may be lesser
    than capacity of fuse request or iov_iter.  So fuse_get_user_pages() must
    ensure that *nbytesp won't grow.
    
    Now, when helper iov_iter_get_pages() performs all hard work of extracting
    pages from iov_iter, it can be done by passing properly calculated
    "maxsize" to the helper.
    
    The other caller of iov_iter_get_pages() (dio_refill_pages()) doesn't need
    this capability, so pass LONG_MAX as the maxsize argument here.
    
    Fixes: c9c37e2e6378 ("fuse: switch to iov_iter_get_pages()")
    Reported-by: Werner Baumann <werner.baumann@onlinehome.de>
    Tested-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 48d64e6ab292..290fbf0b6b8a 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -84,7 +84,7 @@ unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
-			unsigned maxpages, size_t *start);
+			size_t maxsize, unsigned maxpages, size_t *start);
 ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
 			size_t maxsize, size_t *start);
 int iov_iter_npages(const struct iov_iter *i, int maxpages);

commit c7f3888ad7f0932a87fb76e6e4edff2a90cc7920
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 18 20:34:33 2014 -0400

    switch iov_iter_get_pages() to passing maximal number of pages
    
    ... instead of maximal size.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 09a7cffc224e..48d64e6ab292 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -84,7 +84,7 @@ unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
-			size_t maxsize, size_t *start);
+			unsigned maxpages, size_t *start);
 ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
 			size_t maxsize, size_t *start);
 int iov_iter_npages(const struct iov_iter *i, int maxpages);

commit eb477e03feb8dacb3a9e3b2f750ff6c6eeffee33
Merge: 3e7b256cba33 81a9c5e72bdf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 28 09:43:58 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/nab/target-pending
    
    Pull SCSI target fixes from Nicholas Bellinger:
     "Mostly minor fixes this time around.  The highlights include:
    
       - iscsi-target CHAP authentication fixes to enforce explicit key
         values (Tejas Vaykole + rahul.rane)
       - fix a long-standing OOPs in target-core when a alua configfs
         attribute is accessed after port symlink has been removed.
         (Sebastian Herbszt)
       - fix a v3.10.y iscsi-target regression causing the login reject
         status class/detail to be ignored (Christoph Vu-Brugier)
       - fix a v3.10.y iscsi-target regression to avoid rejecting an
         existing ITT during Data-Out when data-direction is wrong (Santosh
         Kulkarni + Arshad Hussain)
       - fix a iscsi-target related shutdown deadlock on UP kernels (Mikulas
         Patocka)
       - fix a v3.16-rc1 build issue with vhost-scsi + !CONFIG_NET (MST)"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/nab/target-pending:
      iscsi-target: fix iscsit_del_np deadlock on unload
      iovec: move memcpy_from/toiovecend to lib/iovec.c
      iscsi-target: Avoid rejecting incorrect ITT for Data-Out
      tcm_loop: Fix memory leak in tcm_loop_submission_work error path
      iscsi-target: Explicily clear login response PDU in exception path
      target: Fix left-over se_lun->lun_sep pointer OOPs
      iscsi-target; Enforce 1024 byte maximum for CHAP_C key value
      iscsi-target: Convert chap_server_compute_md5 to use kstrtoul

commit ac5ccdba3a1659b3517e7e99ef7d35a6a2d77cf4
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Thu Jun 19 21:22:56 2014 +0300

    iovec: move memcpy_from/toiovecend to lib/iovec.c
    
    ERROR: "memcpy_fromiovecend" [drivers/vhost/vhost_scsi.ko] undefined!
    
    commit 9f977ef7b671f6169eca78bf40f230fe84b7c7e5
        vhost-scsi: Include prot_bytes into expected data transfer length
    in target-pending makes drivers/vhost/scsi.c call memcpy_fromiovecend().
    This function is not available when CONFIG_NET is not enabled.
    
    socket.h already includes uio.h, so no callers need updating.
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index e2231e47cec1..04c8c4bb4927 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -111,6 +111,9 @@ static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
 
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
-
+int memcpy_fromiovecend(unsigned char *kdata, const struct iovec *iov,
+			int offset, int len);
+int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,
+		      int offset, int len);
 
 #endif

commit 0b86dbf675e0170a191a9ca18e5e99fd39a678c0
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Jun 23 08:44:40 2014 +0100

    Fix 32-bit regression in block device read(2)
    
    blkdev_read_iter() wants to cap the iov_iter by the amount of data
    remaining to the end of device.  That's what iov_iter_truncate() is for
    (trim iter->count if it's above the given limit).  So far, so good, but
    the argument of iov_iter_truncate() is size_t, so on 32bit boxen (in
    case of a large device) we end up with that upper limit truncated down
    to 32 bits *before* comparing it with iter->count.
    
    Easily fixed by making iov_iter_truncate() take 64bit argument - it does
    the right thing after such change (we only reach the assignment in there
    when the current value of iter->count is greater than the limit, i.e.
    for anything that would get truncated we don't reach the assignment at
    all) and that argument is not the new value of iter->count - it's an
    upper limit for such.
    
    The overhead of passing u64 is not an issue - the thing is inlined, so
    callers passing size_t won't pay any penalty.
    
    Reported-and-tested-by: Theodore Tso <tytso@mit.edu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Tested-by: Bruno Wolff III <bruno@wolff.to>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index e2231e47cec1..d54985e0705e 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -94,8 +94,20 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 	return i->count;
 }
 
-static inline void iov_iter_truncate(struct iov_iter *i, size_t count)
+/*
+ * Cap the iov_iter by given limit; note that the second argument is
+ * *not* the new size - it's upper limit for such.  Passing it a value
+ * greater than the amount of data in iov_iter is fine - it'll just do
+ * nothing in that case.
+ */
+static inline void iov_iter_truncate(struct iov_iter *i, u64 count)
 {
+	/*
+	 * count doesn't have to fit in size_t - comparison extends both
+	 * operands to u64 here and any value that would be truncated by
+	 * conversion in assignement is by definition greater than all
+	 * values of size_t, including old i->count.
+	 */
 	if (i->count > count)
 		i->count = count;
 }

commit 62a8067a7f35dba2de501c9cb00e4cf36da90bc0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 4 23:12:29 2014 -0400

    bio_vec-backed iov_iter
    
    New variant of iov_iter - ITER_BVEC in iter->type, backed with
    bio_vec array instead of iovec one.  Primitives taught to deal
    with such beasts, __swap_write() switched to using that kind
    of iov_iter.
    
    Note that bio_vec is just a <page, offset, length> triple - there's
    nothing block-specific about it.  I've left the definition where it
    was, but took it from under ifdef CONFIG_BLOCK.
    
    Next target: ->splice_write()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index e8a109a75de1..e2231e47cec1 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -19,12 +19,21 @@ struct kvec {
 	size_t iov_len;
 };
 
+enum {
+	ITER_IOVEC = 0,
+	ITER_KVEC = 2,
+	ITER_BVEC = 4,
+};
+
 struct iov_iter {
 	int type;
-	const struct iovec *iov;
-	unsigned long nr_segs;
 	size_t iov_offset;
 	size_t count;
+	union {
+		const struct iovec *iov;
+		const struct bio_vec *bvec;
+	};
+	unsigned long nr_segs;
 };
 
 /*
@@ -54,6 +63,7 @@ static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
 }
 
 #define iov_for_each(iov, iter, start)				\
+	if (!((start).type & ITER_BVEC))			\
 	for (iter = (start);					\
 	     (iter).count &&					\
 	     ((iov = iov_iter_iovec(&(iter))), 1);		\

commit b42b15fdad3ebb790250041d1517acebb9bd56d9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 4 12:15:19 2014 -0400

    lustre: get rid of messing with iovecs
    
    * switch to ->read_iter/->write_iter
    * keep a pointer to iov_iter instead of iov/nr_segs
    * do not modify iovecs; use iov_iter_truncate()/iov_iter_advance() and
    a new primitive - iov_iter_reexpand() (expand previously truncated
    iterator) istead.
    * (racy) check for lustre VMAs intersecting with iovecs kept for now as
    for_each_iov() loop.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 66012352d333..e8a109a75de1 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -90,6 +90,15 @@ static inline void iov_iter_truncate(struct iov_iter *i, size_t count)
 		i->count = count;
 }
 
+/*
+ * reexpand a previously truncated iterator; count must be no more than how much
+ * we had shrunk it.
+ */
+static inline void iov_iter_reexpand(struct iov_iter *i, size_t count)
+{
+	i->count = count;
+}
+
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
 

commit f0d1bec9d58d4c038d0ac958c9af82be6eb18045
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 15:05:18 2014 -0400

    new helper: copy_page_from_iter()
    
    parallel to copy_page_to_iter().  pipe_write() switched to it (and became
    ->write_iter()).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 532f59d0adbb..66012352d333 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -68,6 +68,8 @@ int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
+size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,
+			 struct iov_iter *i);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);

commit 0c949334a9e2581646c6ff0d1470a805b1e5be99
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 22 06:51:37 2014 -0400

    iov_iter_truncate()
    
    Now It Can Be Done(tm) - we don't need to do iov_shorten() in
    generic_file_direct_write() anymore, now that all ->direct_IO()
    instances are converted to proper iov_iter methods and honour
    iter->count and iter->iov_offset properly.
    
    Get rid of count/ocount arguments of generic_file_direct_write(),
    while we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 4876e9f2a58f..532f59d0adbb 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -82,6 +82,12 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 	return i->count;
 }
 
+static inline void iov_iter_truncate(struct iov_iter *i, size_t count)
+{
+	if (i->count > count)
+		i->count = count;
+}
+
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
 

commit 91f79c43d1b54d7154b118860d81b39bad07dfff
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 21 04:58:33 2014 -0400

    new helper: iov_iter_get_pages_alloc()
    
    same as iov_iter_get_pages(), except that pages array is allocated
    (kmalloc if possible, vmalloc if that fails) and left for caller to
    free.  Lustre and NFS ->direct_IO() switched to it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 2f8825b06680..4876e9f2a58f 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -73,6 +73,8 @@ void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, size_t *start);
+ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,
+			size_t maxsize, size_t *start);
 int iov_iter_npages(const struct iov_iter *i, int maxpages);
 
 static inline size_t iov_iter_count(struct iov_iter *i)

commit f67da30c1d5fc9e341bc8121708874bfd7b31e45
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 19 01:16:16 2014 -0400

    new helper: iov_iter_npages()
    
    counts the pages covered by iov_iter, up to given limit.
    do_block_direct_io() and fuse_iter_npages() switched to
    it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 341986116d83..2f8825b06680 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -73,6 +73,7 @@ void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
 ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
 			size_t maxsize, size_t *start);
+int iov_iter_npages(const struct iov_iter *i, int maxpages);
 
 static inline size_t iov_iter_count(struct iov_iter *i)
 {

commit 7b2c99d15559e285384c742db52316802e24b0bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 15 04:05:57 2014 -0400

    new helper: iov_iter_get_pages()
    
    iov_iter_get_pages(iter, pages, maxsize, &start) grabs references pinning
    the pages of up to maxsize of (contiguous) data from iter.  Returns the
    amount of memory grabbed or -error.  In case of success, the requested
    area begins at offset start in pages[0] and runs through pages[1], etc.
    Less than requested amount might be returned - either because the contiguous
    area in the beginning of iterator is smaller than requested, or because
    the kernel failed to pin that many pages.
    
    direct-io.c switched to using iov_iter_get_pages()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index b80bbe197d13..341986116d83 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -71,6 +71,8 @@ size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 unsigned long iov_iter_alignment(const struct iov_iter *i);
 void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
 			unsigned long nr_segs, size_t count);
+ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,
+			size_t maxsize, size_t *start);
 
 static inline size_t iov_iter_count(struct iov_iter *i)
 {

commit 71d8e532b1549a478e6a6a8a44f309d050294d00
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 5 19:28:09 2014 -0500

    start adding the tag to iov_iter
    
    For now, just use the same thing we pass to ->direct_IO() - it's all
    iovec-based at the moment.  Pass it explicitly to iov_iter_init() and
    account for kvec vs. iovec in there, by the same kludge NFS ->direct_IO()
    uses.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 4ee17413fe1b..b80bbe197d13 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -20,6 +20,7 @@ struct kvec {
 };
 
 struct iov_iter {
+	int type;
 	const struct iovec *iov;
 	unsigned long nr_segs;
 	size_t iov_offset;
@@ -68,18 +69,8 @@ size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
 unsigned long iov_iter_alignment(const struct iov_iter *i);
-
-static inline void iov_iter_init(struct iov_iter *i,
-			const struct iovec *iov, unsigned long nr_segs,
-			size_t count, size_t written)
-{
-	i->iov = iov;
-	i->nr_segs = nr_segs;
-	i->iov_offset = 0;
-	i->count = count + written;
-
-	iov_iter_advance(i, written);
-}
+void iov_iter_init(struct iov_iter *i, int direction, const struct iovec *iov,
+			unsigned long nr_segs, size_t count);
 
 static inline size_t iov_iter_count(struct iov_iter *i)
 {

commit 886a39115005ced8b15ab067c9c2a8d546b40a5e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 5 13:50:45 2014 -0500

    new primitive: iov_iter_alignment()
    
    returns the value aligned as badly as the worst remaining segment
    in iov_iter is.  Use instead of open-coded equivalents.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index abbe83ded630..4ee17413fe1b 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -67,6 +67,7 @@ int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
 size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
 			 struct iov_iter *i);
+unsigned long iov_iter_alignment(const struct iov_iter *i);
 
 static inline void iov_iter_init(struct iov_iter *i,
 			const struct iovec *iov, unsigned long nr_segs,
@@ -88,4 +89,5 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
 
+
 #endif

commit e7c24607b5d68a4cdc56e09d70a3c8bae5f0519f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 10 20:54:51 2014 -0400

    kill iov_iter_copy_from_user()
    
    all callers can use copy_page_from_iter() and it actually simplifies
    them.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 199bcc34241b..abbe83ded630 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -62,8 +62,6 @@ unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
 
 size_t iov_iter_copy_from_user_atomic(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
-size_t iov_iter_copy_from_user(struct page *page,
-		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);

commit 6e58e79db8a16222b31fc8da1ca2ac2dccfc4237
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Feb 3 17:07:03 2014 -0500

    introduce copy_page_to_iter, kill loop over iovec in generic_file_aio_read()
    
    generic_file_aio_read() was looping over the target iovec, with loop over
    (source) pages nested inside that.  Just set an iov_iter up and pass *that*
    to do_generic_file_aio_read().  With copy_page_to_iter() doing all work
    of mapping and copying a page to iovec and advancing iov_iter.
    
    Switch shmem_file_aio_read() to the same and kill file_read_actor(), while
    we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 347d70ce098e..199bcc34241b 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -67,6 +67,8 @@ size_t iov_iter_copy_from_user(struct page *page,
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(const struct iov_iter *i);
+size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
+			 struct iov_iter *i);
 
 static inline void iov_iter_init(struct iov_iter *i,
 			const struct iovec *iov, unsigned long nr_segs,

commit 9223687863ffa63fa655f52ef64148ee08dee4d1
Author: Kent Overstreet <kmo@daterainc.com>
Date:   Wed Nov 27 16:29:46 2013 -0800

    iov_iter: Move iov_iter to uio.h
    
    Signed-off-by: Kent Overstreet <kmo@daterainc.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index c55ce243cc09..347d70ce098e 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -9,14 +9,23 @@
 #ifndef __LINUX_UIO_H
 #define __LINUX_UIO_H
 
+#include <linux/kernel.h>
 #include <uapi/linux/uio.h>
 
+struct page;
 
 struct kvec {
 	void *iov_base; /* and that should *never* hold a userland pointer */
 	size_t iov_len;
 };
 
+struct iov_iter {
+	const struct iovec *iov;
+	unsigned long nr_segs;
+	size_t iov_offset;
+	size_t count;
+};
+
 /*
  * Total number of bytes covered by an iovec.
  *
@@ -34,8 +43,49 @@ static inline size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
 	return ret;
 }
 
+static inline struct iovec iov_iter_iovec(const struct iov_iter *iter)
+{
+	return (struct iovec) {
+		.iov_base = iter->iov->iov_base + iter->iov_offset,
+		.iov_len = min(iter->count,
+			       iter->iov->iov_len - iter->iov_offset),
+	};
+}
+
+#define iov_for_each(iov, iter, start)				\
+	for (iter = (start);					\
+	     (iter).count &&					\
+	     ((iov = iov_iter_iovec(&(iter))), 1);		\
+	     iov_iter_advance(&(iter), (iov).iov_len))
+
 unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
 
+size_t iov_iter_copy_from_user_atomic(struct page *page,
+		struct iov_iter *i, unsigned long offset, size_t bytes);
+size_t iov_iter_copy_from_user(struct page *page,
+		struct iov_iter *i, unsigned long offset, size_t bytes);
+void iov_iter_advance(struct iov_iter *i, size_t bytes);
+int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
+size_t iov_iter_single_seg_count(const struct iov_iter *i);
+
+static inline void iov_iter_init(struct iov_iter *i,
+			const struct iovec *iov, unsigned long nr_segs,
+			size_t count, size_t written)
+{
+	i->iov = iov;
+	i->nr_segs = nr_segs;
+	i->iov_offset = 0;
+	i->count = count + written;
+
+	iov_iter_advance(i, written);
+}
+
+static inline size_t iov_iter_count(struct iov_iter *i)
+{
+	return i->count;
+}
+
 int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
 int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
+
 #endif

commit d2f83e9078b8114e3b9d09082856c1aac299aa37
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri May 17 09:05:21 2013 +0930

    Hoist memcpy_fromiovec/memcpy_toiovec into lib/
    
    ERROR: "memcpy_fromiovec" [drivers/vhost/vhost_scsi.ko] undefined!
    
    That function is only present with CONFIG_NET.  Turns out that
    crypto/algif_skcipher.c also uses that outside net, but it actually
    needs sockets anyway.
    
    In addition, commit 6d4f0139d642c45411a47879325891ce2a7c164a added
    CONFIG_NET dependency to CONFIG_VMCI for memcpy_toiovec, so hoist
    that function and revert that commit too.
    
    socket.h already includes uio.h, so no callers need updating; trying
    only broke things fo x86_64 randconfig (thanks Fengguang!).
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 629aaf51f30b..c55ce243cc09 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -35,4 +35,7 @@ static inline size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
 }
 
 unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
+
+int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
+int memcpy_toiovec(struct iovec *iov, unsigned char *kdata, int len);
 #endif

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 98c114323a8b..629aaf51f30b 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -1,9 +1,3 @@
-#ifndef __LINUX_UIO_H
-#define __LINUX_UIO_H
-
-#include <linux/compiler.h>
-#include <linux/types.h>
-
 /*
  *	Berkeley style UIO structures	-	Alan Cox 1994.
  *
@@ -12,21 +6,11 @@
  *		as published by the Free Software Foundation; either version
  *		2 of the License, or (at your option) any later version.
  */
+#ifndef __LINUX_UIO_H
+#define __LINUX_UIO_H
 
-struct iovec
-{
-	void __user *iov_base;	/* BSD uses caddr_t (1003.1g requires void *) */
-	__kernel_size_t iov_len; /* Must be size_t (1003.1g) */
-};
-
-/*
- *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
- */
- 
-#define UIO_FASTIOV	8
-#define UIO_MAXIOV	1024
+#include <uapi/linux/uio.h>
 
-#ifdef __KERNEL__
 
 struct kvec {
 	void *iov_base; /* and that should *never* hold a userland pointer */
@@ -52,5 +36,3 @@ static inline size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
 
 unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
 #endif
-
-#endif

commit 812ed032cdc8138b7546eecc996879756b92d801
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Wed Jul 29 15:04:19 2009 -0700

    uio: mark uio.h functions __KERNEL__ only
    
    To avoid userspace build failures such as:
    
    .../linux/uio.h:37: error: expected `=', `,', `;', `asm' or `__attribute__' before `iov_length'
    .../linux/uio.h:47: error: expected declaration specifiers or `...' before `size_t'
    
    move uio functions inside a __KERNEL__ block.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index b7fe13883bdb..98c114323a8b 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -19,15 +19,6 @@ struct iovec
 	__kernel_size_t iov_len; /* Must be size_t (1003.1g) */
 };
 
-#ifdef __KERNEL__
-
-struct kvec {
-	void *iov_base; /* and that should *never* hold a userland pointer */
-	size_t iov_len;
-};
-
-#endif
-
 /*
  *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
  */
@@ -35,6 +26,13 @@ struct kvec {
 #define UIO_FASTIOV	8
 #define UIO_MAXIOV	1024
 
+#ifdef __KERNEL__
+
+struct kvec {
+	void *iov_base; /* and that should *never* hold a userland pointer */
+	size_t iov_len;
+};
+
 /*
  * Total number of bytes covered by an iovec.
  *
@@ -53,5 +51,6 @@ static inline size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
 }
 
 unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
+#endif
 
 #endif

commit e0807061908a7a9441d0f745deb444f7216904cb
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jul 15 23:40:30 2007 -0700

    remove odd and misleading comments from uio.h
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/uio.h b/include/linux/uio.h
index 9af8bbcd8963..b7fe13883bdb 100644
--- a/include/linux/uio.h
+++ b/include/linux/uio.h
@@ -13,10 +13,6 @@
  *		2 of the License, or (at your option) any later version.
  */
 
-
-/* A word of warning: Our uio structure will clash with the C library one (which is now obsolete). Remove the C
-   library one from sys/uio.h if you have a very old library set */
-
 struct iovec
 {
 	void __user *iov_base;	/* BSD uses caddr_t (1003.1g requires void *) */
@@ -38,11 +34,6 @@ struct kvec {
  
 #define UIO_FASTIOV	8
 #define UIO_MAXIOV	1024
-#if 0
-#define UIO_MAXIOV	16	/* Maximum iovec's in one operation 
-				   16 matches BSD */
-                                /* Beg pardon: BSD has 1024 --ANK */
-#endif
 
 /*
  * Total number of bytes covered by an iovec.

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/uio.h b/include/linux/uio.h
new file mode 100644
index 000000000000..9af8bbcd8963
--- /dev/null
+++ b/include/linux/uio.h
@@ -0,0 +1,66 @@
+#ifndef __LINUX_UIO_H
+#define __LINUX_UIO_H
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+
+/*
+ *	Berkeley style UIO structures	-	Alan Cox 1994.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+
+/* A word of warning: Our uio structure will clash with the C library one (which is now obsolete). Remove the C
+   library one from sys/uio.h if you have a very old library set */
+
+struct iovec
+{
+	void __user *iov_base;	/* BSD uses caddr_t (1003.1g requires void *) */
+	__kernel_size_t iov_len; /* Must be size_t (1003.1g) */
+};
+
+#ifdef __KERNEL__
+
+struct kvec {
+	void *iov_base; /* and that should *never* hold a userland pointer */
+	size_t iov_len;
+};
+
+#endif
+
+/*
+ *	UIO_MAXIOV shall be at least 16 1003.1g (5.4.1.1)
+ */
+ 
+#define UIO_FASTIOV	8
+#define UIO_MAXIOV	1024
+#if 0
+#define UIO_MAXIOV	16	/* Maximum iovec's in one operation 
+				   16 matches BSD */
+                                /* Beg pardon: BSD has 1024 --ANK */
+#endif
+
+/*
+ * Total number of bytes covered by an iovec.
+ *
+ * NOTE that it is not safe to use this function until all the iovec's
+ * segment lengths have been validated.  Because the individual lengths can
+ * overflow a size_t when added together.
+ */
+static inline size_t iov_length(const struct iovec *iov, unsigned long nr_segs)
+{
+	unsigned long seg;
+	size_t ret = 0;
+
+	for (seg = 0; seg < nr_segs; seg++)
+		ret += iov[seg].iov_len;
+	return ret;
+}
+
+unsigned long iov_shorten(struct iovec *iov, unsigned long nr_segs, size_t to);
+
+#endif
