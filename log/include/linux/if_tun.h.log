commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 12e3eebf0ce6..5bda8cf457b6 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -1,16 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  Universal TUN/TAP device driver.
  *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
  */
 #ifndef __IF_TUN_H
 #define __IF_TUN_H

commit fe8dd45bb7556246c6b76277b1ba4296c91c2505
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Sep 12 11:17:06 2018 +0800

    tun: switch to new type of msg_control
    
    This patch introduces to a new tun/tap specific msg_control:
    
    #define TUN_MSG_UBUF 1
    #define TUN_MSG_PTR  2
    struct tun_msg_ctl {
           int type;
           void *ptr;
    };
    
    This allows us to pass different kinds of msg_control through
    sendmsg(). The first supported type is ubuf (TUN_MSG_UBUF) which will
    be used by the existed vhost_net zerocopy code. The second is XDP
    buff, which allows vhost_net to pass XDP buff to TUN. This could be
    used to implement accepting an array of XDP buffs from vhost_net in
    the following patches.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 3d2996dc7d85..12e3eebf0ce6 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -16,9 +16,23 @@
 #define __IF_TUN_H
 
 #include <uapi/linux/if_tun.h>
+#include <uapi/linux/virtio_net.h>
 
 #define TUN_XDP_FLAG 0x1UL
 
+#define TUN_MSG_UBUF 1
+#define TUN_MSG_PTR  2
+struct tun_msg_ctl {
+	unsigned short type;
+	unsigned short num;
+	void *ptr;
+};
+
+struct tun_xdp_hdr {
+	int buflen;
+	struct virtio_net_hdr gso;
+};
+
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
 struct ptr_ring *tun_get_tx_ring(struct file *file);

commit 1ffcbc8537d0bc32aaca7000cb9c904ec4b6300f
Author: Jesper Dangaard Brouer <brouer@redhat.com>
Date:   Tue Apr 17 16:45:47 2018 +0200

    tun: convert to use generic xdp_frame and xdp_return_frame API
    
    The tuntap driver invented it's own driver specific way of queuing
    XDP packets, by storing the xdp_buff information in the top of
    the XDP frame data.
    
    Convert it over to use the more generic xdp_frame structure.  The
    main problem with the in-driver method is that the xdp_rxq_info pointer
    cannot be trused/used when dequeueing the frame.
    
    V3: Remove check based on feedback from Jason
    
    Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index fd00170b494f..3d2996dc7d85 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -22,7 +22,7 @@
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
 struct ptr_ring *tun_get_tx_ring(struct file *file);
-bool tun_is_xdp_buff(void *ptr);
+bool tun_is_xdp_frame(void *ptr);
 void *tun_xdp_to_ptr(void *ptr);
 void *tun_ptr_to_xdp(void *ptr);
 void tun_ptr_free(void *ptr);
@@ -39,7 +39,7 @@ static inline struct ptr_ring *tun_get_tx_ring(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }
-static inline bool tun_is_xdp_buff(void *ptr)
+static inline bool tun_is_xdp_frame(void *ptr)
 {
 	return false;
 }

commit 3a4030761ea88ff439030ca98e3094b9900e96b7
Author: Jason Wang <jasowang@redhat.com>
Date:   Fri Mar 9 14:50:34 2018 +0800

    vhost_net: examine pointer types during un-producing
    
    After commit fc72d1d54dd9 ("tuntap: XDP transmission"), we can
    actually queueing XDP pointers in the pointer ring, so we should
    examine the pointer type before freeing the pointer.
    
    Fixes: fc72d1d54dd9 ("tuntap: XDP transmission")
    Reported-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index c5b0a75a7812..fd00170b494f 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -25,6 +25,7 @@ struct ptr_ring *tun_get_tx_ring(struct file *file);
 bool tun_is_xdp_buff(void *ptr);
 void *tun_xdp_to_ptr(void *ptr);
 void *tun_ptr_to_xdp(void *ptr);
+void tun_ptr_free(void *ptr);
 #else
 #include <linux/err.h>
 #include <linux/errno.h>
@@ -50,5 +51,8 @@ static inline void *tun_ptr_to_xdp(void *ptr)
 {
 	return NULL;
 }
+static inline void tun_ptr_free(void *ptr)
+{
+}
 #endif /* CONFIG_TUN */
 #endif /* __IF_TUN_H */

commit 1125b008711581a8962ee028e2982d7757093600
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Jan 10 15:06:14 2018 +1100

    tuntap: fix for "tuntap: XDP transmission"
    
    Fixes: fc72d1d54dd9 ("tuntap: XDP transmission")
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 08e66827ad8e..c5b0a75a7812 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -42,11 +42,11 @@ static inline bool tun_is_xdp_buff(void *ptr)
 {
 	return false;
 }
-void *tun_xdp_to_ptr(void *ptr)
+static inline void *tun_xdp_to_ptr(void *ptr)
 {
 	return NULL;
 }
-void *tun_ptr_to_xdp(void *ptr)
+static inline void *tun_ptr_to_xdp(void *ptr)
 {
 	return NULL;
 }

commit fc72d1d54dd9ffe2552c76b17e9129803ca7b255
Author: Jason Wang <jasowang@redhat.com>
Date:   Thu Jan 4 11:14:28 2018 +0800

    tuntap: XDP transmission
    
    This patch implements XDP transmission for TAP. Since we can't create
    new queues for TAP during XDP set, exist ptr_ring was reused for
    queuing XDP buffers. To differ xdp_buff from sk_buff, TUN_XDP_FLAG
    (0x1UL) was encoded into lowest bit of xpd_buff pointer during
    ptr_ring_produce, and was decoded during consuming. XDP metadata was
    stored in the headroom of the packet which should work in most of
    cases since driver usually reserve enough headroom. Very minor changes
    were done for vhost_net: it just need to peek the length depends on
    the type of pointer.
    
    Tests were done on two Intel E5-2630 2.40GHz machines connected back
    to back through two 82599ES. Traffic were generated/received through
    MoonGen/testpmd(rxonly). It reports ~20% improvements when
    xdp_redirect_map is doing redirection from ixgbe to TAP (from 2.50Mpps
    to 3.05Mpps)
    
    Cc: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index bdee9b83baf6..08e66827ad8e 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -17,9 +17,14 @@
 
 #include <uapi/linux/if_tun.h>
 
+#define TUN_XDP_FLAG 0x1UL
+
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
 struct ptr_ring *tun_get_tx_ring(struct file *file);
+bool tun_is_xdp_buff(void *ptr);
+void *tun_xdp_to_ptr(void *ptr);
+void *tun_ptr_to_xdp(void *ptr);
 #else
 #include <linux/err.h>
 #include <linux/errno.h>
@@ -33,5 +38,17 @@ static inline struct ptr_ring *tun_get_tx_ring(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }
+static inline bool tun_is_xdp_buff(void *ptr)
+{
+	return false;
+}
+void *tun_xdp_to_ptr(void *ptr)
+{
+	return NULL;
+}
+void *tun_ptr_to_xdp(void *ptr)
+{
+	return NULL;
+}
 #endif /* CONFIG_TUN */
 #endif /* __IF_TUN_H */

commit 5990a30510ed1c37a769d3a035ad2d030b843528
Author: Jason Wang <jasowang@redhat.com>
Date:   Thu Jan 4 11:14:27 2018 +0800

    tun/tap: use ptr_ring instead of skb_array
    
    This patch switches to use ptr_ring instead of skb_array. This will be
    used to enqueue different types of pointers by encoding type into
    lower bits.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index bf9bdf42d577..bdee9b83baf6 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -19,7 +19,7 @@
 
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
-struct skb_array *tun_get_skb_array(struct file *file);
+struct ptr_ring *tun_get_tx_ring(struct file *file);
 #else
 #include <linux/err.h>
 #include <linux/errno.h>
@@ -29,7 +29,7 @@ static inline struct socket *tun_get_socket(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }
-static inline struct skb_array *tun_get_skb_array(struct file *f)
+static inline struct ptr_ring *tun_get_tx_ring(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }

commit 83339c6b159ea6429a1db40b0d9d1083ab574733
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed May 17 12:14:41 2017 +0800

    tun: export skb_array
    
    This patch exports skb_array through tun_get_skb_array(). Caller can
    then manipulate skb array directly.
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index ed6da2e6df90..bf9bdf42d577 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -19,6 +19,7 @@
 
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
+struct skb_array *tun_get_skb_array(struct file *file);
 #else
 #include <linux/err.h>
 #include <linux/errno.h>
@@ -28,5 +29,9 @@ static inline struct socket *tun_get_socket(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }
+static inline struct skb_array *tun_get_skb_array(struct file *f)
+{
+	return ERR_PTR(-EINVAL);
+}
 #endif /* CONFIG_TUN */
 #endif /* __IF_TUN_H */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 06b1829731fd..ed6da2e6df90 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -12,86 +12,11 @@
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  */
-
 #ifndef __IF_TUN_H
 #define __IF_TUN_H
 
-#include <linux/types.h>
-#include <linux/if_ether.h>
-#include <linux/filter.h>
-
-/* Read queue size */
-#define TUN_READQ_SIZE	500
-
-/* TUN device flags */
-#define TUN_TUN_DEV 	0x0001	
-#define TUN_TAP_DEV	0x0002
-#define TUN_TYPE_MASK   0x000f
-
-#define TUN_FASYNC	0x0010
-#define TUN_NOCHECKSUM	0x0020
-#define TUN_NO_PI	0x0040
-#define TUN_ONE_QUEUE	0x0080
-#define TUN_PERSIST 	0x0100	
-#define TUN_VNET_HDR 	0x0200
-
-/* Ioctl defines */
-#define TUNSETNOCSUM  _IOW('T', 200, int) 
-#define TUNSETDEBUG   _IOW('T', 201, int) 
-#define TUNSETIFF     _IOW('T', 202, int) 
-#define TUNSETPERSIST _IOW('T', 203, int) 
-#define TUNSETOWNER   _IOW('T', 204, int)
-#define TUNSETLINK    _IOW('T', 205, int)
-#define TUNSETGROUP   _IOW('T', 206, int)
-#define TUNGETFEATURES _IOR('T', 207, unsigned int)
-#define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
-#define TUNSETTXFILTER _IOW('T', 209, unsigned int)
-#define TUNGETIFF      _IOR('T', 210, unsigned int)
-#define TUNGETSNDBUF   _IOR('T', 211, int)
-#define TUNSETSNDBUF   _IOW('T', 212, int)
-#define TUNATTACHFILTER _IOW('T', 213, struct sock_fprog)
-#define TUNDETACHFILTER _IOW('T', 214, struct sock_fprog)
-#define TUNGETVNETHDRSZ _IOR('T', 215, int)
-#define TUNSETVNETHDRSZ _IOW('T', 216, int)
-
-/* TUNSETIFF ifr flags */
-#define IFF_TUN		0x0001
-#define IFF_TAP		0x0002
-#define IFF_NO_PI	0x1000
-#define IFF_ONE_QUEUE	0x2000
-#define IFF_VNET_HDR	0x4000
-#define IFF_TUN_EXCL	0x8000
-
-/* Features for GSO (TUNSETOFFLOAD). */
-#define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */
-#define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
-#define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
-#define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
-#define TUN_F_UFO	0x10	/* I can handle UFO packets */
-
-/* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
-#define TUN_PKT_STRIP	0x0001
-struct tun_pi {
-	__u16  flags;
-	__be16 proto;
-};
-
-/*
- * Filter spec (used for SETXXFILTER ioctls)
- * This stuff is applicable only to the TAP (Ethernet) devices.
- * If the count is zero the filter is disabled and the driver accepts
- * all packets (promisc mode).
- * If the filter is enabled in order to accept broadcast packets
- * broadcast addr must be explicitly included in the addr list.
- */
-#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
-struct tun_filter {
-	__u16  flags; /* TUN_FLT_ flags see above */
-	__u16  count; /* Number of addresses */
-	__u8   addr[0][ETH_ALEN];
-};
+#include <uapi/linux/if_tun.h>
 
-#ifdef __KERNEL__
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
 #else
@@ -104,5 +29,4 @@ static inline struct socket *tun_get_socket(struct file *f)
 	return ERR_PTR(-EINVAL);
 }
 #endif /* CONFIG_TUN */
-#endif /* __KERNEL__ */
 #endif /* __IF_TUN_H */

commit d9d52b5178af586d679c1052fb161ee05ea2e83f
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed Mar 17 17:45:01 2010 +0200

    tun: add ioctl to modify vnet header size
    
    virtio added mergeable buffers mode where 2 bytes of extra info is put
    after vnet header but before actual data (tun does not need this data).
    In hindsight, it would have been better to add the new info *before* the
    packet: as it is, users need a lot of tricky code to skip the extra 2
    bytes in the middle of the iovec, and in fact applications seem to get
    it wrong, and only work with specific iovec layout.  The fact we might
    need to split iovec also means we might in theory overflow iovec max
    size.
    
    This patch adds a simpler way for applications to handle this,
    and future proofs the interface against further extensions,
    by making the size of the virtio net header configurable
    from userspace. As a result, tun driver will simply
    skip the extra 2 bytes on both input and output.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 1350a246893a..06b1829731fd 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -51,6 +51,8 @@
 #define TUNSETSNDBUF   _IOW('T', 212, int)
 #define TUNATTACHFILTER _IOW('T', 213, struct sock_fprog)
 #define TUNDETACHFILTER _IOW('T', 214, struct sock_fprog)
+#define TUNGETVNETHDRSZ _IOR('T', 215, int)
+#define TUNSETVNETHDRSZ _IOW('T', 216, int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit 99405162598176e830d17ae6d4f3d9e070ad900c
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun Feb 14 01:01:10 2010 +0000

    tun: socket filter support
    
    This patch adds Linux Socket Filter support to
    tun driver.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 404abe00162c..1350a246893a 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -18,6 +18,7 @@
 
 #include <linux/types.h>
 #include <linux/if_ether.h>
+#include <linux/filter.h>
 
 /* Read queue size */
 #define TUN_READQ_SIZE	500
@@ -48,6 +49,8 @@
 #define TUNGETIFF      _IOR('T', 210, unsigned int)
 #define TUNGETSNDBUF   _IOR('T', 211, int)
 #define TUNSETSNDBUF   _IOW('T', 212, int)
+#define TUNATTACHFILTER _IOW('T', 213, struct sock_fprog)
+#define TUNDETACHFILTER _IOW('T', 214, struct sock_fprog)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit 05c2828c72c4eabf62376adfe27bd24797621f62
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Thu Jan 14 06:17:09 2010 +0000

    tun: export underlying socket
    
    Tun device looks similar to a packet socket
    in that both pass complete frames from/to userspace.
    
    This patch fills in enough fields in the socket underlying tun driver
    to support sendmsg/recvmsg operations, and message flags
    MSG_TRUNC and MSG_DONTWAIT, and exports access to this socket
    to modules.  Regular read/write behaviour is unchanged.
    
    This way, code using raw sockets to inject packets
    into a physical device, can support injecting
    packets into host network stack almost without modification.
    
    First user of this interface will be vhost virtualization
    accelerator.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 3f5fd523b49d..404abe00162c 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -86,4 +86,18 @@ struct tun_filter {
 	__u8   addr[0][ETH_ALEN];
 };
 
+#ifdef __KERNEL__
+#if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
+struct socket *tun_get_socket(struct file *);
+#else
+#include <linux/err.h>
+#include <linux/errno.h>
+struct file;
+struct socket;
+static inline struct socket *tun_get_socket(struct file *f)
+{
+	return ERR_PTR(-EINVAL);
+}
+#endif /* CONFIG_TUN */
+#endif /* __KERNEL__ */
 #endif /* __IF_TUN_H */

commit e36aa25a533962b08402530e8443ac804a454e27
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Tue Jul 14 14:21:04 2009 +0000

    tun: Allow tap device to send/receive UFO packets.
    
    - Allow setting UFO on tap device and handle UFO packets.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    
    ---------------------------------------------------------
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 915ba5789f0e..3f5fd523b49d 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -62,6 +62,7 @@
 #define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
 #define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
 #define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
+#define TUN_F_UFO	0x10	/* I can handle UFO packets */
 
 /* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
 #define TUN_PKT_STRIP	0x0001

commit f85ba78068ac137fe9c1f50d25405d2783d75c77
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Apr 27 03:23:54 2009 -0700

    tun: add IFF_TUN_EXCL flag to avoid opening a persistent device.
    
    When creating a certain types of VPN, NetworkManager will first attempt
    to find an available tun device by iterating through 'vpn%d' until it
    finds one that isn't already busy. Then it'll set that to be persistent
    and owned by the otherwise unprivileged user that the VPN dæmon itself
    runs as.
    
    There's a race condition here -- during the period where the vpn%d
    device is created and we're waiting for the VPN dæmon to actually
    connect and use it, if we try to create _another_ device we could end up
    re-using the same one -- because trying to open it again doesn't get
    -EBUSY as it would while it's _actually_ busy.
    
    So solve this, we add an IFF_TUN_EXCL flag which causes tun_set_iff() to
    fail if it would be opening an existing persistent tundevice -- so that
    we can make sure we're getting an entirely _new_ device.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 049d6c9428db..915ba5789f0e 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -55,6 +55,7 @@
 #define IFF_NO_PI	0x1000
 #define IFF_ONE_QUEUE	0x2000
 #define IFF_VNET_HDR	0x4000
+#define IFF_TUN_EXCL	0x8000
 
 /* Features for GSO (TUNSETOFFLOAD). */
 #define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */

commit 33dccbb050bbe35b88ca8cf1228dcf3e4d4b3554
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Feb 5 21:25:32 2009 -0800

    tun: Limit amount of queued packets per device
    
    Unlike a normal socket path, the tuntap device send path does
    not have any accounting.  This means that the user-space sender
    may be able to pin down arbitrary amounts of kernel memory by
    continuing to send data to an end-point that is congested.
    
    Even when this isn't an issue because of limited queueing at
    most end points, this can also be a problem because its only
    response to congestion is packet loss.  That is, when those
    local queues at the end-point fills up, the tuntap device will
    start wasting system time because it will continue to send
    data there which simply gets dropped straight away.
    
    Of course one could argue that everybody should do congestion
    control end-to-end, unfortunately there are people in this world
    still hooked on UDP, and they don't appear to be going away
    anywhere fast.  In fact, we've always helped them by performing
    accounting in our UDP code, the sole purpose of which is to
    provide congestion feedback other than through packet loss.
    
    This patch attempts to apply the same bandaid to the tuntap device.
    It creates a pseudo-socket object which is used to account our
    packets just as a normal socket does for UDP.  Of course things
    are a little complex because we're actually reinjecting traffic
    back into the stack rather than out of the stack.
    
    The stack complexities however should have been resolved by preceding
    patches.  So this one can simply start using skb_set_owner_w.
    
    For now the accounting is essentially disabled by default for
    backwards compatibility.  In particular, we set the cap to INT_MAX.
    This is so that existing applications don't get confused by the
    sudden arrival EAGAIN errors.
    
    In future we may wish (or be forced to) do this by default.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 8529f57ba263..049d6c9428db 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -46,6 +46,8 @@
 #define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
 #define TUNSETTXFILTER _IOW('T', 209, unsigned int)
 #define TUNGETIFF      _IOR('T', 210, unsigned int)
+#define TUNGETSNDBUF   _IOR('T', 211, int)
+#define TUNSETSNDBUF   _IOW('T', 212, int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit e3b99556975907530aeb9745e7b3945a0da48f17
Author: Mark McLoughlin <markmc@redhat.com>
Date:   Fri Aug 15 15:09:56 2008 -0700

    tun: TUNGETIFF interface to query name and flags
    
    Add a TUNGETIFF interface so that userspace can query a
    tun/tap descriptor for its name and flags.
    
    This is needed because it is common for one app to create
    a tap interface, exec another app and pass it the file
    descriptor for the interface. Without TUNGETIFF the spawned
    app has no way of detecting wheter the interface has e.g.
    IFF_VNET_HDR set.
    
    Signed-off-by: Mark McLoughlin <markmc@redhat.com>
    Acked-by: Max Krasnyansky <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 4c6307ad9fdb..8529f57ba263 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -45,6 +45,7 @@
 #define TUNGETFEATURES _IOR('T', 207, unsigned int)
 #define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
 #define TUNSETTXFILTER _IOW('T', 209, unsigned int)
+#define TUNGETIFF      _IOR('T', 210, unsigned int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit f271b2cc78f09c93ccd00a2056d3237134bf994c
Author: Max Krasnyansky <maxk@qualcomm.com>
Date:   Mon Jul 14 22:18:19 2008 -0700

    tun: Fix/rewrite packet filtering logic
    
    Please see the following thread to get some context on this
            http://marc.info/?l=linux-netdev&m=121564433018903&w=2
    
    Basically the issue is that current multi-cast filtering stuff in
    the TUN/TAP driver is seriously broken.
    Original patch went in without proper review and ACK. It was broken and
    confusing to start with and subsequent patches broke it completely.
    To give you an idea of what's broken here are some of the issues:
    
    - Very confusing comments throughout the code that imply that the
    character device is a network interface in its own right, and that packets
    are passed between the two nics. Which is completely wrong.
    
    - Wrong set of ioctls is used for setting up filters. They look like
    shortcuts for manipulating state of the tun/tap network interface but
    in reality manipulate the state of the TX filter.
    
    - ioctls that were originally used for setting address of the the TX filter
    got "fixed" and now set the address of the network interface itself. Which
    made filter totaly useless.
    
    - Filtering is done too late. Instead of filtering early on, to avoid
    unnecessary wakeups, filtering is done in the read() call.
    
    The list goes on and on :)
    
    So the patch cleans all that up. It introduces simple and clean interface for
    setting up TX filters (TUNSETTXFILTER + tun_filter spec) and does filtering
    before enqueuing the packets.
    
    TX filtering is useful in the scenarios where TAP is part of a bridge, in
    which case it gets all broadcast, multicast and potentially other packets when
    the bridge is learning. So for example Ethernet tunnelling app may want to
    setup TX filters to avoid tunnelling multicast traffic. QEMU and other
    hypervisors can push RX filtering that is currently done in the guest into the
    host context therefore saving wakeups and unnecessary data transfer.
    
    Signed-off-by: Max Krasnyansky <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 563fae542da6..4c6307ad9fdb 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -17,6 +17,7 @@
 #define __IF_TUN_H
 
 #include <linux/types.h>
+#include <linux/if_ether.h>
 
 /* Read queue size */
 #define TUN_READQ_SIZE	500
@@ -42,7 +43,8 @@
 #define TUNSETLINK    _IOW('T', 205, int)
 #define TUNSETGROUP   _IOW('T', 206, int)
 #define TUNGETFEATURES _IOR('T', 207, unsigned int)
-#define TUNSETOFFLOAD _IOW('T', 208, unsigned int)
+#define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
+#define TUNSETTXFILTER _IOW('T', 209, unsigned int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001
@@ -57,10 +59,26 @@
 #define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
 #define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
 
+/* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
+#define TUN_PKT_STRIP	0x0001
 struct tun_pi {
-	unsigned short flags;
+	__u16  flags;
 	__be16 proto;
 };
-#define TUN_PKT_STRIP	0x0001
+
+/*
+ * Filter spec (used for SETXXFILTER ioctls)
+ * This stuff is applicable only to the TAP (Ethernet) devices.
+ * If the count is zero the filter is disabled and the driver accepts
+ * all packets (promisc mode).
+ * If the filter is enabled in order to accept broadcast packets
+ * broadcast addr must be explicitly included in the addr list.
+ */
+#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
+struct tun_filter {
+	__u16  flags; /* TUN_FLT_ flags see above */
+	__u16  count; /* Number of addresses */
+	__u8   addr[0][ETH_ALEN];
+};
 
 #endif /* __IF_TUN_H */

commit f43798c27684ab925adde7d8acc34c78c6e50df8
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Jul 3 03:48:02 2008 -0700

    tun: Allow GSO using virtio_net_hdr
    
    Add a IFF_VNET_HDR flag.  This uses the same ABI as virtio_net
    (ie. prepending struct virtio_net_hdr to packets) to indicate GSO and
    checksum information.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Max Krasnyansky <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 3f0a0995d449..563fae542da6 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -31,6 +31,7 @@
 #define TUN_NO_PI	0x0040
 #define TUN_ONE_QUEUE	0x0080
 #define TUN_PERSIST 	0x0100	
+#define TUN_VNET_HDR 	0x0200
 
 /* Ioctl defines */
 #define TUNSETNOCSUM  _IOW('T', 200, int) 
@@ -48,6 +49,7 @@
 #define IFF_TAP		0x0002
 #define IFF_NO_PI	0x1000
 #define IFF_ONE_QUEUE	0x2000
+#define IFF_VNET_HDR	0x4000
 
 /* Features for GSO (TUNSETOFFLOAD). */
 #define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */

commit 5228ddc98fa49b3cedab4024e269d62410a0d806
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Jul 3 03:46:16 2008 -0700

    tun: TUNSETFEATURES to set gso features.
    
    ethtool is useful for setting (some) device fields, but it's
    root-only.  Finer feature control is available through a tun-specific
    ioctl.
    
    (Includes Mark McLoughlin <markmc@redhat.com>'s fix to hold rtnl sem).
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Max Krasnyansky <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 94f76a112303..3f0a0995d449 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -41,6 +41,7 @@
 #define TUNSETLINK    _IOW('T', 205, int)
 #define TUNSETGROUP   _IOW('T', 206, int)
 #define TUNGETFEATURES _IOR('T', 207, unsigned int)
+#define TUNSETOFFLOAD _IOW('T', 208, unsigned int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001
@@ -48,6 +49,12 @@
 #define IFF_NO_PI	0x1000
 #define IFF_ONE_QUEUE	0x2000
 
+/* Features for GSO (TUNSETOFFLOAD). */
+#define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */
+#define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
+#define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
+#define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
+
 struct tun_pi {
 	unsigned short flags;
 	__be16 proto;

commit 07240fd0902c872f044f523893364a1a24c9f278
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Jul 3 03:45:32 2008 -0700

    tun: Interface to query tun/tap features.
    
    The problem with introducing checksum offload and gso to tun is they
    need to set dev->features to enable GSO and/or checksumming, which is
    supposed to be done before register_netdevice(), ie. as part of
    TUNSETIFF.
    
    Unfortunately, TUNSETIFF has always just ignored flags it doesn't
    understand, so there's no good way of detecting whether the kernel
    supports new IFF_ flags.
    
    This patch implements a TUNGETFEATURES ioctl which returns all the valid IFF
    flags.  It could be extended later to include other features.
    
    Here's an example program which uses it:
    
    #include <linux/if_tun.h>
    #include <sys/types.h>
    #include <sys/ioctl.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <err.h>
    #include <stdio.h>
    
    static struct {
            unsigned int flag;
            const char *name;
    } known_flags[] = {
            { IFF_TUN, "TUN" },
            { IFF_TAP, "TAP" },
            { IFF_NO_PI, "NO_PI" },
            { IFF_ONE_QUEUE, "ONE_QUEUE" },
    };
    
    int main()
    {
            unsigned int features, i;
    
            int netfd = open("/dev/net/tun", O_RDWR);
            if (netfd < 0)
                    err(1, "Opening /dev/net/tun");
    
            if (ioctl(netfd, TUNGETFEATURES, &features) != 0) {
                    printf("Kernel does not support TUNGETFEATURES, guessing\n");
                    features = (IFF_TUN|IFF_TAP|IFF_NO_PI|IFF_ONE_QUEUE);
            }
            printf("Available features are: ");
            for (i = 0; i < sizeof(known_flags)/sizeof(known_flags[0]); i++) {
                    if (features & known_flags[i].flag) {
                            features &= ~known_flags[i].flag;
                            printf("%s ", known_flags[i].name);
                    }
            }
            if (features)
                    printf("(UNKNOWN %#x)", features);
            printf("\n");
            return 0;
    }
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Max Krasnyansky <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 18f31b6187a3..94f76a112303 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -40,6 +40,7 @@
 #define TUNSETOWNER   _IOW('T', 204, int)
 #define TUNSETLINK    _IOW('T', 205, int)
 #define TUNSETGROUP   _IOW('T', 206, int)
+#define TUNGETFEATURES _IOR('T', 207, unsigned int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit 0b040829952d84bf2a62526f0e24b624e0699447
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jun 10 22:46:50 2008 -0700

    net: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 8c71fe2fb1f5..18f31b6187a3 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -11,8 +11,6 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
- *
- *  $Id: if_tun.h,v 1.2 2001/06/01 18:39:47 davem Exp $
  */
 
 #ifndef __IF_TUN_H

commit 14daa02139dcb3193b2b0250c0720a23ef610c49
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Apr 12 18:48:58 2008 -0700

    net: make struct tun_struct private to tun.c
    
    There's no reason for this to be in the header, and it just hurts
    recompile time.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Max Krasnyanskiy <maxk@qualcomm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 72f1c5f47be3..8c71fe2fb1f5 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -18,47 +18,8 @@
 #ifndef __IF_TUN_H
 #define __IF_TUN_H
 
-/* Uncomment to enable debugging */
-/* #define TUN_DEBUG 1 */
-
 #include <linux/types.h>
 
-#ifdef __KERNEL__
-
-#ifdef TUN_DEBUG
-#define DBG  if(tun->debug)printk
-#define DBG1 if(debug==2)printk
-#else
-#define DBG( a... )
-#define DBG1( a... )
-#endif
-
-struct tun_struct {
-	struct list_head        list;
-	unsigned long 		flags;
-	int			attached;
-	uid_t			owner;
-	gid_t			group;
-
-	wait_queue_head_t	read_wait;
-	struct sk_buff_head	readq;
-
-	struct net_device	*dev;
-
-	struct fasync_struct    *fasync;
-
-	unsigned long if_flags;
-	u8 dev_addr[ETH_ALEN];
-	u32 chr_filter[2];
-	u32 net_filter[2];
-
-#ifdef TUN_DEBUG	
-	int debug;
-#endif  
-};
-
-#endif /* __KERNEL__ */
-
 /* Read queue size */
 #define TUN_READQ_SIZE	500
 

commit a3edb08311fc559652ffc959e93eb5be9294443f
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Dec 22 17:52:42 2007 +0000

    annotate tun
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 33e489d5bb33..72f1c5f47be3 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -21,6 +21,8 @@
 /* Uncomment to enable debugging */
 /* #define TUN_DEBUG 1 */
 
+#include <linux/types.h>
+
 #ifdef __KERNEL__
 
 #ifdef TUN_DEBUG
@@ -88,7 +90,7 @@ struct tun_struct {
 
 struct tun_pi {
 	unsigned short flags;
-	unsigned short proto;
+	__be16 proto;
 };
 #define TUN_PKT_STRIP	0x0001
 

commit 09f75cd7bf13720738e6a196cc0107ce9a5bd5a0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Oct 3 17:41:50 2007 -0700

    [NET] drivers/net: statistics cleanup #1 -- save memory and shrink code
    
    We now have struct net_device_stats embedded in struct net_device,
    and the default ->get_stats() hook does the obvious thing for us.
    
    Run through drivers/net/* and remove the driver-local storage of
    statistics, and driver-local ->get_stats() hook where applicable.
    
    This was just the low-hanging fruit in drivers/net; plenty more drivers
    remain to be updated.
    
    [ Resolved conflicts with napi_struct changes and fix sunqe build
      regression... -DaveM ]
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 42eb6945b93e..33e489d5bb33 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -42,7 +42,6 @@ struct tun_struct {
 	struct sk_buff_head	readq;
 
 	struct net_device	*dev;
-	struct net_device_stats	stats;
 
 	struct fasync_struct    *fasync;
 

commit 8c644623fe7e41f59fe97cdf666cba3cb7ced7d8
Author: Guido Guenther <agx@sigxcpu.org>
Date:   Mon Jul 2 22:50:25 2007 -0700

    [NET]: Allow group ownership of TUN/TAP devices.
    
    Introduce a new syscall TUNSETGROUP for group ownership setting of tap
    devices. The user now is allowed to send packages if either his euid or
    his egid matches the one specified via tunctl (via -u or -g
    respecitvely). If both, gid and uid, are set via tunctl, both have to
    match.
    
    Signed-off-by: Guido Guenther <agx@sigxcpu.org>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 88aef7b86ef4..42eb6945b93e 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -36,6 +36,7 @@ struct tun_struct {
 	unsigned long 		flags;
 	int			attached;
 	uid_t			owner;
+	gid_t			group;
 
 	wait_queue_head_t	read_wait;
 	struct sk_buff_head	readq;
@@ -78,6 +79,7 @@ struct tun_struct {
 #define TUNSETPERSIST _IOW('T', 203, int) 
 #define TUNSETOWNER   _IOW('T', 204, int)
 #define TUNSETLINK    _IOW('T', 205, int)
+#define TUNSETGROUP   _IOW('T', 206, int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit ff4cc3ac93e1d0369928fd60ec1fe82417afc576
Author: Mike Kershaw <dragorn@kismetwireless.net>
Date:   Thu Sep 1 17:40:05 2005 -0700

    [TUNTAP]: Allow setting the linktype of the tap device from userspace
    
    Currently tun/tap only supports the EN10MB ARP type.  For use with
    wireless and other networking types it should be possible to set the
    ARP type via an ioctl.
    
    Patch v2: Included check that the tap interface is down before changing the
    link type out from underneath it
    
    Signed-off-by: Mike Kershaw <dragorn@kismetwireless.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index 096a85a58ae5..88aef7b86ef4 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -77,6 +77,7 @@ struct tun_struct {
 #define TUNSETIFF     _IOW('T', 202, int) 
 #define TUNSETPERSIST _IOW('T', 203, int) 
 #define TUNSETOWNER   _IOW('T', 204, int)
+#define TUNSETLINK    _IOW('T', 205, int)
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
new file mode 100644
index 000000000000..096a85a58ae5
--- /dev/null
+++ b/include/linux/if_tun.h
@@ -0,0 +1,93 @@
+/*
+ *  Universal TUN/TAP device driver.
+ *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  $Id: if_tun.h,v 1.2 2001/06/01 18:39:47 davem Exp $
+ */
+
+#ifndef __IF_TUN_H
+#define __IF_TUN_H
+
+/* Uncomment to enable debugging */
+/* #define TUN_DEBUG 1 */
+
+#ifdef __KERNEL__
+
+#ifdef TUN_DEBUG
+#define DBG  if(tun->debug)printk
+#define DBG1 if(debug==2)printk
+#else
+#define DBG( a... )
+#define DBG1( a... )
+#endif
+
+struct tun_struct {
+	struct list_head        list;
+	unsigned long 		flags;
+	int			attached;
+	uid_t			owner;
+
+	wait_queue_head_t	read_wait;
+	struct sk_buff_head	readq;
+
+	struct net_device	*dev;
+	struct net_device_stats	stats;
+
+	struct fasync_struct    *fasync;
+
+	unsigned long if_flags;
+	u8 dev_addr[ETH_ALEN];
+	u32 chr_filter[2];
+	u32 net_filter[2];
+
+#ifdef TUN_DEBUG	
+	int debug;
+#endif  
+};
+
+#endif /* __KERNEL__ */
+
+/* Read queue size */
+#define TUN_READQ_SIZE	500
+
+/* TUN device flags */
+#define TUN_TUN_DEV 	0x0001	
+#define TUN_TAP_DEV	0x0002
+#define TUN_TYPE_MASK   0x000f
+
+#define TUN_FASYNC	0x0010
+#define TUN_NOCHECKSUM	0x0020
+#define TUN_NO_PI	0x0040
+#define TUN_ONE_QUEUE	0x0080
+#define TUN_PERSIST 	0x0100	
+
+/* Ioctl defines */
+#define TUNSETNOCSUM  _IOW('T', 200, int) 
+#define TUNSETDEBUG   _IOW('T', 201, int) 
+#define TUNSETIFF     _IOW('T', 202, int) 
+#define TUNSETPERSIST _IOW('T', 203, int) 
+#define TUNSETOWNER   _IOW('T', 204, int)
+
+/* TUNSETIFF ifr flags */
+#define IFF_TUN		0x0001
+#define IFF_TAP		0x0002
+#define IFF_NO_PI	0x1000
+#define IFF_ONE_QUEUE	0x2000
+
+struct tun_pi {
+	unsigned short flags;
+	unsigned short proto;
+};
+#define TUN_PKT_STRIP	0x0001
+
+#endif /* __IF_TUN_H */
