commit e45ee71ae101bd271c3cd951cf66341dc8f504a0
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Mar 30 11:58:01 2020 +0200

    pinctrl: Define of_pinctrl_get() dummy for !PINCTRL
    
    Currently, the of_pinctrl_get() dummy is only defined for !OF, which can
    still cause build failures on configurations with OF enabled but PINCTRL
    disabled. Make sure to define the dummy if either OF or PINCTRL are not
    enabled.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://lore.kernel.org/r/20200330095801.2421589-1-thierry.reding@gmail.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 7ce23450a1cb..2aef59df93d7 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -186,7 +186,7 @@ extern int pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
 				const char *pin_group, const unsigned **pins,
 				unsigned *num_pins);
 
-#ifdef CONFIG_OF
+#if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_PINCTRL)
 extern struct pinctrl_dev *of_pinctrl_get(struct device_node *np);
 #else
 static inline

commit 43c95d3694cc448fdf50bd53b7ff3a5bb4655883
Merge: 073c916bc005 4c105769bf6d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 15:02:27 2019 -0700

    Merge tag 'pinctrl-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl
    
    Pull pin control updates from Linus Walleij:
     "This is the bulk of pin control changes for the v5.3 kernel cycle:
    
      Core changes:
    
       - Device links can optionally be added between a pin control producer
         and its consumers. This will affect how the system power management
         is handled: a pin controller will not suspend before all of its
         consumers have been suspended.
    
         This was necessary for the ST Microelectronics STMFX expander and
         need to be tested on other systems as well: it makes sense to make
         this default in the long run.
    
         Right now it is opt-in per driver.
    
       - Drive strength can be specified in microamps. With decreases in
         silicon technology, milliamps isn't granular enough, let's make it
         possible to select drive strengths in microamps.
    
         Right now the Meson (AMlogic) driver needs this.
    
      New drivers:
    
       - New subdriver for the Tegra 194 SoC.
    
       - New subdriver for the Qualcomm SDM845.
    
       - New subdriver for the Qualcomm SM8150.
    
       - New subdriver for the Freescale i.MX8MN (Freescale is now a product
         line of NXP).
    
       - New subdriver for Marvell MV98DX1135.
    
      Driver improvements:
    
       - The Bitmain BM1880 driver now supports pin config in addition to
         muxing.
    
       - The Qualcomm drivers can now reserve some GPIOs as taken aside and
         not usable for users. This is used in ACPI systems to take out some
         GPIO lines used by the BIOS so that noone else (neither kernel nor
         userspace) will play with them by mistake and crash the machine.
    
       - A slew of refurbishing around the Aspeed drivers (board management
         controllers for servers) in preparation for the new Aspeed AST2600
         SoC.
    
       - A slew of improvements over the SH PFC drivers as usual.
    
       - Misc cleanups and fixes"
    
    * tag 'pinctrl-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-pinctrl: (106 commits)
      pinctrl: aspeed: Strip moved macros and structs from private header
      pinctrl: aspeed: Fix missed include
      pinctrl: baytrail: Use GENMASK() consistently
      pinctrl: baytrail: Re-use data structures from pinctrl-intel.h
      pinctrl: baytrail: Use defined macro instead of magic in byt_get_gpio_mux()
      pinctrl: qcom: Add SM8150 pinctrl driver
      dt-bindings: pinctrl: qcom: Add SM8150 pinctrl binding
      dt-bindings: pinctrl: qcom: Document missing gpio nodes
      pinctrl: aspeed: Add implementation-related documentation
      pinctrl: aspeed: Split out pinmux from general pinctrl
      pinctrl: aspeed: Clarify comment about strapping W1C
      pinctrl: aspeed: Correct comment that is no longer true
      MAINTAINERS: Add entry for ASPEED pinctrl drivers
      dt-bindings: pinctrl: aspeed: Convert AST2500 bindings to json-schema
      dt-bindings: pinctrl: aspeed: Convert AST2400 bindings to json-schema
      dt-bindings: pinctrl: aspeed: Split bindings document in two
      pinctrl: qcom: Add irq_enable callback for msm gpio
      pinctrl: madera: Fixup SPDX headers
      pinctrl: qcom: sdm845: Fix CONFIG preprocessor guard
      pinctrl: tegra: Add bitmask support for parked bits
      ...

commit ec6516bfbaf72e7c81811162b6de96322e32a027
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Jun 13 10:55:31 2019 +0900

    pinctrl: remove unneeded #ifdef around declarations
    
    What is the point in surrounding the whole of declarations with
    ifdef like this?
    
      #ifdef CONFIG_FOO
      int foo(void);
      #endif
    
    If CONFIG_FOO is not defined, all callers of foo() will fail
    with implicit declaration errors since the top Makefile adds
    -Werror-implicit-function-declaration to KBUILD_CFLAGS.
    
    This breaks the build earlier when you are doing something wrong.
    That's it.
    
    Anyway, it will fail to link since the definition of foo() is not
    compiled.
    
    In summary, these ifdef are unneeded.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 36a79fe7b84f..27738164daa7 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -12,8 +12,6 @@
 #ifndef __LINUX_PINCTRL_PINCTRL_H
 #define __LINUX_PINCTRL_PINCTRL_H
 
-#ifdef CONFIG_PINCTRL
-
 #include <linux/radix-tree.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
@@ -203,6 +201,4 @@ extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern const char *pinctrl_dev_get_devname(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 
-#endif /* !CONFIG_PINCTRL */
-
 #endif /* __LINUX_PINCTRL_PINCTRL_H */

commit 78b99577b3934e3e787fe0c52aa1b59442c8bbb5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Jun 10 00:09:53 2019 +0900

    pinctrl: remove unused pin_is_valid()
    
    This function was used by pin_request() to pointlessly double-check
    the pin validity, and it was the only user ever.
    
    Since commit d2f6a1c6fb0e ("pinctrl: remove double pin validity
    check."), no one has ever used it.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 2744113f1024..36a79fe7b84f 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -172,7 +172,6 @@ extern struct pinctrl_dev *devm_pinctrl_register(struct device *dev,
 extern void devm_pinctrl_unregister(struct device *dev,
 				struct pinctrl_dev *pctldev);
 
-extern bool pin_is_valid(struct pinctrl_dev *pctldev, int pin);
 extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);
 extern void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
@@ -203,15 +202,6 @@ struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern const char *pinctrl_dev_get_devname(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
-#else
-
-struct pinctrl_dev;
-
-/* Sufficiently stupid default functions when pinctrl is not in use */
-static inline bool pin_is_valid(struct pinctrl_dev *pctldev, int pin)
-{
-	return pin >= 0;
-}
 
 #endif /* !CONFIG_PINCTRL */
 

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 8f5dbb84547a..e429e5d92dd6 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Interface the pinctrl subsystem
  *
@@ -6,8 +7,6 @@
  * This interface is used in the core to keep track of pins.
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 #ifndef __LINUX_PINCTRL_PINCTRL_H
 #define __LINUX_PINCTRL_PINCTRL_H

commit 036f394dd77f8117346874151793ec38967d843f
Author: Benjamin Gaignard <benjamin.gaignard@st.com>
Date:   Wed May 22 17:29:24 2019 +0200

    pinctrl: Enable device link creation for pin control
    
    A pin controller may want to create a link between itself
    and its clients to be sure of suspend/resume call ordering.
    
    Introduce link_consumers field in pinctrl_desc structure to let
    pinctrl core knows that controller expect to create a link.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@st.com>
    [Renamed create_link to link_consumers]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 8f5dbb84547a..2744113f1024 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -125,6 +125,10 @@ struct pinctrl_ops {
  *	the hardware description
  * @custom_conf_items: Information how to print @params in debugfs, must be
  *	the same size as the @custom_params, i.e. @num_custom_params
+ * @link_consumers: If true create a device link between pinctrl and its
+ *	consumers (i.e. the devices requesting pin control states). This is
+ *	sometimes necessary to ascertain the right suspend/resume order for
+ *	example.
  */
 struct pinctrl_desc {
 	const char *name;
@@ -139,6 +143,7 @@ struct pinctrl_desc {
 	const struct pinconf_generic_params *custom_params;
 	const struct pin_config_item *custom_conf_items;
 #endif
+	bool link_consumers;
 };
 
 /* External interface to pin controller */

commit 23c35f48f5fbe33f68904138b23fee64df7d2f0f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 2 16:44:14 2018 -0800

    pinctrl: remove include file from <linux/device.h>
    
    When pulling the recent pinctrl merge, I was surprised by how a
    pinctrl-only pull request ended up rebuilding basically the whole
    kernel.
    
    The reason for that ended up being that <linux/device.h> included
    <linux/pinctrl/devinfo.h>, so any change to that file ended up causing
    pretty much every driver out there to be rebuilt.
    
    The reason for that was because 'struct device' has this in it:
    
        #ifdef CONFIG_PINCTRL
            struct dev_pin_info     *pins;
        #endif
    
    but we already avoid header includes for these kinds of things in that
    header file, preferring to just use a forward-declaration of the
    structure instead.  Exactly to avoid this kind of header dependency.
    
    Since some drivers seem to expect that <linux/pinctrl/devinfo.h> header
    to come in automatically, move the include to <linux/pinctrl/pinctrl.h>
    instead.  It might be better to just make the includes more targeted,
    but I'm not going to review every driver.
    
    It would definitely be good to have a tool for finding and minimizing
    header dependencies automatically - or at least help with them.  Right
    now we almost certainly end up having way too many of these things, and
    it's hard to test every single configuration.
    
    FWIW, you can get a sense of the "hotness" of a header file with something
    like this after doing a full build:
    
        find . -name '.*.o.cmd' -print0 |
            xargs -0 tail --lines=+2 |
            grep -v 'wildcard ' |
            tr ' \\' '\n' |
            sort | uniq -c | sort -n | less -S
    
    which isn't exact (there are other things in those '*.o.cmd' than just
    the dependencies, and the "--lines=+2" only removes the header), but
    might a useful approximation.
    
    With this patch, <linux/pinctrl/devinfo.h> drops to "only" having 833
    users in the current x86-64 allmodconfig.  In contrast, <linux/device.h>
    has 14857 build files including it directly or indirectly.
    
    Of course, the headers that absolutely _everybody_ includes (things like
    <linux/types.h> etc) get a score of 23000+.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 5e45385c5bdc..8f5dbb84547a 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -18,6 +18,7 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include <linux/pinctrl/pinctrl-state.h>
+#include <linux/pinctrl/devinfo.h>
 
 struct device;
 struct pinctrl_dev;

commit 6118714275f0a313ecc296a87ed1af32d9691bed
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 30 09:16:39 2017 -0700

    pinctrl: core: Fix pinctrl_register_and_init() with pinctrl_enable()
    
    Recent pinctrl changes to allow dynamic allocation of pins exposed one
    more issue with the pinctrl pins claimed early by the controller itself.
    This caused a regression for IMX6 pinctrl hogs.
    
    Before enabling the pin controller driver we need to wait until it has
    been properly initialized, then claim the hogs, and only then enable it.
    
    To fix the regression, split the code into pinctrl_claim_hogs() and
    pinctrl_enable(). And then let's require that pinctrl_enable() is always
    called by the pin controller driver when ready after calling
    pinctrl_register_and_init().
    
    Depends-on: 950b0d91dc10 ("pinctrl: core: Fix regression caused by delayed
    work for hogs")
    Fixes: df61b366af26 ("pinctrl: core: Use delayed work for hogs")
    Fixes: e566fc11ea76 ("pinctrl: imx: use generic pinctrl helpers for
    managing groups")
    Cc: Haojian Zhuang <haojian.zhuang@linaro.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Mika Penttilä <mika.penttila@nextfour.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Stefan Agner <stefan@agner.ch>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Gary Bisson <gary.bisson@boundarydevices.com>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 8ce2d87a238b..5e45385c5bdc 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -145,8 +145,9 @@ struct pinctrl_desc {
 extern int pinctrl_register_and_init(struct pinctrl_desc *pctldesc,
 				     struct device *dev, void *driver_data,
 				     struct pinctrl_dev **pctldev);
+extern int pinctrl_enable(struct pinctrl_dev *pctldev);
 
-/* Please use pinctrl_register_and_init() instead */
+/* Please use pinctrl_register_and_init() and pinctrl_enable() instead */
 extern struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 				struct device *dev, void *driver_data);
 

commit 950b0d91dc108f54bccca5a2f75bb46f2df63d29
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jan 11 14:13:34 2017 -0800

    pinctrl: core: Fix regression caused by delayed work for hogs
    
    Commit df61b366af26 ("pinctrl: core: Use delayed work for hogs") caused a
    regression at least with sh-pfc that is also a GPIO controller as
    noted by Geert Uytterhoeven <geert@linux-m68k.org>.
    
    As the original pinctrl_register() has issues calling pin controller
    driver functions early before the controller has finished registering,
    we can't just revert commit df61b366af26. That would break the drivers
    using GENERIC_PINCTRL_GROUPS or GENERIC_PINMUX_FUNCTIONS.
    
    So let's fix the issue with the following steps as a single patch:
    
    1. Revert the late_init parts of commit df61b366af26.
    
       The late_init clearly won't work and we have to just give up
       on fixing pinctrl_register() for GENERIC_PINCTRL_GROUPS and
       GENERIC_PINMUX_FUNCTIONS.
    
    2. Split pinctrl_register() into two parts
    
       By splitting pinctrl_register() into pinctrl_init_controller()
       and pinctrl_create_and_start() we have better control over when
       it's safe to call pinctrl_create().
    
    3. Introduce a new pinctrl_register_and_init() function
    
       As suggested by Linus Walleij <linus.walleij@linaro.org>, we
       can just introduce a new function for the controllers that need
       pinctrl_create() called later.
    
    4. Convert the four known problem cases to use new function
    
       Let's convert pinctrl-imx, pinctrl-single, sh-pfc and ti-iodelay
       to use the new function to fix the issues. The rest of the drivers
       can be converted later. Let's also update Documentation/pinctrl.txt
       accordingly because of the known issues with pinctrl_register().
    
    Fixes: df61b366af26 ("pinctrl: core: Use delayed work for hogs")
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Gary Bisson <gary.bisson@boundarydevices.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index a42e57da270d..8ce2d87a238b 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -141,12 +141,27 @@ struct pinctrl_desc {
 };
 
 /* External interface to pin controller */
+
+extern int pinctrl_register_and_init(struct pinctrl_desc *pctldesc,
+				     struct device *dev, void *driver_data,
+				     struct pinctrl_dev **pctldev);
+
+/* Please use pinctrl_register_and_init() instead */
 extern struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 				struct device *dev, void *driver_data);
+
 extern void pinctrl_unregister(struct pinctrl_dev *pctldev);
+
+extern int devm_pinctrl_register_and_init(struct device *dev,
+				struct pinctrl_desc *pctldesc,
+				void *driver_data,
+				struct pinctrl_dev **pctldev);
+
+/* Please use devm_pinctrl_register_and_init() instead */
 extern struct pinctrl_dev *devm_pinctrl_register(struct device *dev,
 				struct pinctrl_desc *pctldesc,
 				void *driver_data);
+
 extern void devm_pinctrl_unregister(struct device *dev,
 				struct pinctrl_dev *pctldev);
 

commit 80e0f8d94d3090f0f7bf3faf3e6180e920ee0d22
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Feb 24 14:12:59 2016 +0530

    pinctrl: Add devm_ apis for pinctrl_{register, unregister}
    
    Add device managed APIs devm_pinctrl_register() and
    devm_pinctrl_unregister() for the APIs pinctrl_register()
    and pinctrl_unregister().
    
    This helps in reducing code in error path and sometimes
    removal of .remove callback for driver unbind.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 9ba59fcba549..a42e57da270d 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -144,6 +144,12 @@ struct pinctrl_desc {
 extern struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 				struct device *dev, void *driver_data);
 extern void pinctrl_unregister(struct pinctrl_dev *pctldev);
+extern struct pinctrl_dev *devm_pinctrl_register(struct device *dev,
+				struct pinctrl_desc *pctldesc,
+				void *driver_data);
+extern void devm_pinctrl_unregister(struct device *dev,
+				struct pinctrl_dev *pctldev);
+
 extern bool pin_is_valid(struct pinctrl_dev *pctldev, int pin);
 extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);

commit b3da97ee581387cd42dafd76eb2ac23f2335cd92
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri May 22 15:25:50 2015 +0900

    pinctrl: use "const struct ..." rather than "struct ... const"
    
    Only this member, pins, is defined as "struct ... const *", but the
    others in this struct, pinlops, pmxops, confops, etc. are defined as
    "const struct ... *".
    
    Swap the "struct pinctrl_pin_desc" and "const" for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 66e4697516de..9ba59fcba549 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -127,7 +127,7 @@ struct pinctrl_ops {
  */
 struct pinctrl_desc {
 	const char *name;
-	struct pinctrl_pin_desc const *pins;
+	const struct pinctrl_pin_desc *pins;
 	unsigned int npins;
 	const struct pinctrl_ops *pctlops;
 	const struct pinmux_ops *pmxops;

commit 8c4c2016345feefcd289ce2479eb70286d30825a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed May 6 14:19:13 2015 +0200

    pinctrl: move strict option to pinmux_ops
    
    While the pinmux_ops are ideally just a vtable for pin mux
    calls, the "strict" setting belongs so intuitively with the
    pin multiplexing that we should move it here anyway. Putting
    it in the top pinctrl_desc makes no sense.
    
    Cc: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index fc6b0348c375..66e4697516de 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -114,8 +114,6 @@ struct pinctrl_ops {
  *	of the pins field above
  * @pctlops: pin control operation vtable, to support global concepts like
  *	grouping of pins, this is optional.
- * @strict: check both gpio_owner and mux_owner strictly before approving
-	the pin request
  * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver
  * @confops: pin config operations vtable, if you support pin configuration in
  *	your driver
@@ -134,7 +132,6 @@ struct pinctrl_desc {
 	const struct pinctrl_ops *pctlops;
 	const struct pinmux_ops *pmxops;
 	const struct pinconf_ops *confops;
-	bool strict;
 	struct module *owner;
 #ifdef CONFIG_GENERIC_PINCONF
 	unsigned int num_custom_params;

commit fa76a3db7093a527333c380df82a0f158d9b8299
Author: Sonic Zhang <sonic.zhang@analog.com>
Date:   Thu Apr 9 11:13:07 2015 +0800

    pinctrl: allow exlusive GPIO/mux pin allocation
    
    Disallow simultaneous use of the the GPIO and peripheral mux
    functions by setting a flag "strict" in struct pinctrl_desc.
    
    The blackfin pinmux and gpio controller doesn't allow user to
    set up a pin for both GPIO and peripheral function. So, add flag
    strict in struct pinctrl_desc to check both gpio_owner and
    mux_owner before approving the pin request.
    
    v2-changes:
    - if strict flag is set, check gpio_owner and mux_onwer in if and
      else clause
    
    v3-changes:
    - add kerneldoc for this struct
    - augment Documentation/pinctrl.txt
    
    Signed-off-by: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 66e4697516de..fc6b0348c375 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -114,6 +114,8 @@ struct pinctrl_ops {
  *	of the pins field above
  * @pctlops: pin control operation vtable, to support global concepts like
  *	grouping of pins, this is optional.
+ * @strict: check both gpio_owner and mux_owner strictly before approving
+	the pin request
  * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver
  * @confops: pin config operations vtable, if you support pin configuration in
  *	your driver
@@ -132,6 +134,7 @@ struct pinctrl_desc {
 	const struct pinctrl_ops *pctlops;
 	const struct pinmux_ops *pmxops;
 	const struct pinconf_ops *confops;
+	bool strict;
 	struct module *owner;
 #ifdef CONFIG_GENERIC_PINCONF
 	unsigned int num_custom_params;

commit f684e4ac9f4bae4e6ecff92eef9645a44764fc04
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 12 00:45:55 2015 +0100

    pinctrl: pinconf-generic: loose DT dependence
    
    New pin controllers such as ACPI-based may also have custom properties
    to parse, and should be able to use generic pin config. Let's make the
    code compile on !OF systems and rename members a bit to underscore it
    is custom parameters and not necessarily DT parameters.
    
    This fixes a build regression for x86_64 on the zeroday kernel builds.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Reviewed-and-tested-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index c58b3e11ba8e..66e4697516de 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -118,9 +118,12 @@ struct pinctrl_ops {
  * @confops: pin config operations vtable, if you support pin configuration in
  *	your driver
  * @owner: module providing the pin controller, used for refcounting
- * @num_dt_params: Number of driver-specific DT parameters
- * @params: List of DT parameters
- * @conf_items: Information how to print @params in debugfs
+ * @num_custom_params: Number of driver-specific custom parameters to be parsed
+ *	from the hardware description
+ * @custom_params: List of driver_specific custom parameters to be parsed from
+ *	the hardware description
+ * @custom_conf_items: Information how to print @params in debugfs, must be
+ *	the same size as the @custom_params, i.e. @num_custom_params
  */
 struct pinctrl_desc {
 	const char *name;
@@ -130,10 +133,10 @@ struct pinctrl_desc {
 	const struct pinmux_ops *pmxops;
 	const struct pinconf_ops *confops;
 	struct module *owner;
-#if defined(CONFIG_GENERIC_PINCONF) && defined(CONFIG_OF)
-	unsigned int num_dt_params;
-	const struct pinconf_generic_dt_params *params;
-	const struct pin_config_item *conf_items;
+#ifdef CONFIG_GENERIC_PINCONF
+	unsigned int num_custom_params;
+	const struct pinconf_generic_params *custom_params;
+	const struct pin_config_item *custom_conf_items;
 #endif
 };
 

commit dd4d01f7bad886c22687224bc7070b87de8deb51
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Fri Jan 9 07:43:46 2015 -0800

    pinctrl: pinconf-generic: Allow driver to specify DT params
    
    Additionally to the generic DT parameters, allow drivers to provide
    driver-specific DT parameters to be used with the generic parser
    infrastructure.
    
    To achieve this 'struct pinctrl_desc' is extended to pass custom pinconf
    option to the core. In order to pass this kind of information, the
    related data structures - 'struct pinconf_generic_dt_params',
    'pin_config_item' - are moved from pinconf internals to the
    pinconf-generic header.
    
    Additionally pinconfg-generic is refactored to not only iterate over the
    generic pinconf parameters but also take the parameters into account
    that are provided through the driver's 'struct pinctrl_desc'.
    In particular 'pinconf_generic_parse_dt_config()' and
    'pinconf_generic_dump' helpers are split into two parts each. In order
    to have a more generic helper that can be used to process the generic
    parameters as well as the driver-specific ones.
    
    v2:
     - fix typo
     - add missing documentation for @conf_items member in struct
     - rebase to pinctrl/devel: conflict in abx500
     - rename _pinconf_generic_dump() to pinconf_generic_dump_one()
     - removed '_' from _parse_dt_cfg()
     - removed BUG_ONs, error condition is handled in if statements
     - removed pinconf_generic_dump_group() & pinconf_generic_dump_pin
       helpers
       - fixed up corresponding call sites
       - renamed pinconf_generic_dump() to pinconf_generic_dump_pins()
       - added kernel-doc to pinconf_generic_dump_pins()
     - add kernel-doc
     - more verbose commit message
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Tested-by: Andreas FÃ¤rber <afaerber@suse.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index cc8e1aff0e28..c58b3e11ba8e 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -24,6 +24,7 @@ struct pinctrl_dev;
 struct pinctrl_map;
 struct pinmux_ops;
 struct pinconf_ops;
+struct pin_config_item;
 struct gpio_chip;
 struct device_node;
 
@@ -117,6 +118,9 @@ struct pinctrl_ops {
  * @confops: pin config operations vtable, if you support pin configuration in
  *	your driver
  * @owner: module providing the pin controller, used for refcounting
+ * @num_dt_params: Number of driver-specific DT parameters
+ * @params: List of DT parameters
+ * @conf_items: Information how to print @params in debugfs
  */
 struct pinctrl_desc {
 	const char *name;
@@ -126,6 +130,11 @@ struct pinctrl_desc {
 	const struct pinmux_ops *pmxops;
 	const struct pinconf_ops *confops;
 	struct module *owner;
+#if defined(CONFIG_GENERIC_PINCONF) && defined(CONFIG_OF)
+	unsigned int num_dt_params;
+	const struct pinconf_generic_dt_params *params;
+	const struct pin_config_item *conf_items;
+#endif
 };
 
 /* External interface to pin controller */

commit a30d54218e0306b3b7db7df34fe70d5e86fcbbe2
Author: Sherman Yin <syin@broadcom.com>
Date:   Fri Dec 20 18:13:33 2013 -0800

    pinctrl: Add void * to pinctrl_pin_desc
    
    drv_data is added to the pinctrl_pin_desc for drivers to define additional
    driver-specific per-pin data.
    
    Signed-off-by: Sherman Yin <syin@broadcom.com>
    Reviewed-by: Christian Daudt <bcm@fixthebug.org>
    Reviewed-by: Matt Porter <matt.porter@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index fefb88663975..cc8e1aff0e28 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -32,10 +32,12 @@ struct device_node;
  * pins, pads or other muxable units in this struct
  * @number: unique pin number from the global pin number space
  * @name: a name for this pin
+ * @drv_data: driver-defined per-pin data. pinctrl core does not touch this
  */
 struct pinctrl_pin_desc {
 	unsigned number;
 	const char *name;
+	void *drv_data;
 };
 
 /* Convenience macro to define a single named or anonymous pin descriptor */

commit 586a87e6edc936d6d3c3585af504b33b9c3f0a06
Author: Christian Ruppert <christian.ruppert@abilis.com>
Date:   Tue Oct 15 15:37:54 2013 +0200

    pinctrl/gpio: non-linear GPIO ranges accesible from gpiolib
    
    This patch adds the infrastructure required to register non-linear gpio
    ranges through gpiolib and the standard GPIO device tree bindings.
    
    Signed-off-by: Christian Ruppert <christian.ruppert@abilis.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 5979147d2bda..fefb88663975 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -144,6 +144,9 @@ extern struct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,
 extern struct pinctrl_gpio_range *
 pinctrl_find_gpio_range_from_pin(struct pinctrl_dev *pctldev,
 				 unsigned int pin);
+extern int pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
+				const char *pin_group, const unsigned **pins,
+				unsigned *num_pins);
 
 #ifdef CONFIG_OF
 extern struct pinctrl_dev *of_pinctrl_get(struct device_node *np);

commit 56a59911e502fabbbefa5cfa0cddae22e3c94866
Author: Christian Ruppert <christian.ruppert@abilis.com>
Date:   Fri Jun 14 10:24:48 2013 +0200

    Fix comment on pinctrl_gpio_range.pin_base
    
    The comment introduced with the recently added pinctrl_gpio_range.pins
    element was wrong. This corrects it.
    Thanks to Patrice Chotard for pointing this out.
    
    Signed-off-by: Christian Ruppert <christian.ruppert@abilis.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 176a6c1b4e03..5979147d2bda 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -49,7 +49,7 @@ struct pinctrl_pin_desc {
  * @name: a name for the chip in this range
  * @id: an ID number for the chip in this range
  * @base: base offset of the GPIO range
- * @pin_base: base pin number of the GPIO range if pins != NULL
+ * @pin_base: base pin number of the GPIO range if pins == NULL
  * @pins: enumeration of pins in GPIO range or NULL
  * @npins: number of pins in the GPIO range, including the base number
  * @gc: an optional pointer to a gpio_chip

commit c8587eeef8fc219e806e868c6f0c7170c769efab
Author: Christian Ruppert <christian.ruppert@abilis.com>
Date:   Thu Jun 13 14:55:31 2013 +0200

    pinctrl: add pin list based GPIO ranges
    
    Traditionally, GPIO ranges are based on consecutive ranges of both GPIO
    and pin numbers. This patch allows for GPIO ranges with arbitrary lists
    of pin numbers.
    
    Signed-off-by: Christian Ruppert <christian.ruppert@abilis.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 2c2a9e8d8578..176a6c1b4e03 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -49,7 +49,8 @@ struct pinctrl_pin_desc {
  * @name: a name for the chip in this range
  * @id: an ID number for the chip in this range
  * @base: base offset of the GPIO range
- * @pin_base: base pin number of the GPIO range
+ * @pin_base: base pin number of the GPIO range if pins != NULL
+ * @pins: enumeration of pins in GPIO range or NULL
  * @npins: number of pins in the GPIO range, including the base number
  * @gc: an optional pointer to a gpio_chip
  */
@@ -59,6 +60,7 @@ struct pinctrl_gpio_range {
 	unsigned int id;
 	unsigned int base;
 	unsigned int pin_base;
+	unsigned const *pins;
 	unsigned int npins;
 	struct gpio_chip *gc;
 };

commit 022ab148d28e8466e45d28552224e3029f1cccd8
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sat Feb 16 10:25:07 2013 +0100

    pinctrl: Declare operation structures as const
    
    The pinconf, pinctrl and pinmux operation structures hold function
    pointers that are never modified. Declare them as const.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 778804df293f..2c2a9e8d8578 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -118,9 +118,9 @@ struct pinctrl_desc {
 	const char *name;
 	struct pinctrl_pin_desc const *pins;
 	unsigned int npins;
-	struct pinctrl_ops *pctlops;
-	struct pinmux_ops *pmxops;
-	struct pinconf_ops *confops;
+	const struct pinctrl_ops *pctlops;
+	const struct pinmux_ops *pmxops;
+	const struct pinconf_ops *confops;
 	struct module *owner;
 };
 

commit d6e99abb424a916ecbb127dba065a379b460a062
Author: Haojian Zhuang <haojian.zhuang@linaro.org>
Date:   Fri Jan 18 15:31:06 2013 +0800

    pinctrl: core: get devname from pinctrl_dev
    
    Add new function to get devname from pinctrl_dev. pinctrl_dev_get_name()
    can only get pinctrl description name. If we want to use gpio driver to
    find pinctrl device node, we need to fetch the pinctrl device name.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 04d6700d99af..778804df293f 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -154,6 +154,7 @@ struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 #endif /* CONFIG_OF */
 
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
+extern const char *pinctrl_dev_get_devname(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else
 

commit 9afbefb227792a3c195085d662050dcca748f521
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 20 14:25:07 2012 +0100

    pinctrl: add function to retrieve range from pin
    
    This adds a function to the pinctrl core to retrieve the GPIO
    range associated with a certain pin for a certain controller.
    This is needed when a pinctrl driver want to look up the
    corresponding struct gpio_chip for a certain pin. As the
    GPIO drivers can now create these ranges themselves, the
    pinctrl driver no longer knows about all its associated GPIO
    chips.
    
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 7dee9acbd271..04d6700d99af 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -139,6 +139,9 @@ extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
 
 extern struct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,
 		struct pinctrl_gpio_range *range);
+extern struct pinctrl_gpio_range *
+pinctrl_find_gpio_range_from_pin(struct pinctrl_dev *pctldev,
+				 unsigned int pin);
 
 #ifdef CONFIG_OF
 extern struct pinctrl_dev *of_pinctrl_get(struct device_node *np);

commit 192c369c6165dff233f22aa70209a92b030d233d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 20 14:03:37 2012 +0100

    gpiolib: rename find_pinctrl_*
    
    Rename the function find_pinctrl_and_add_gpio_range()
    to pinctrl_find_and_add_gpio_range() so as to be consistent
    with the rest of the functions.
    
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 4a58428bc793..7dee9acbd271 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -137,7 +137,7 @@ extern void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
 extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);
 
-extern struct pinctrl_dev *find_pinctrl_and_add_gpio_range(const char *devname,
+extern struct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,
 		struct pinctrl_gpio_range *range);
 
 #ifdef CONFIG_OF

commit 1e63d7b9363f0c57d00991f9f2e0af374dfc591a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 6 16:03:35 2012 +0100

    gpiolib: separation of pin concerns
    
    The fact that of_gpiochip_add_pin_range() and
    gpiochip_add_pin_range() share too much code is fragile and
    will invariably mean that bugs need to be fixed in two places
    instead of one.
    
    So separate the concerns of gpiolib.c and gpiolib-of.c and
    have the latter call the former as back-end. This is necessary
    also when going forward with other device descriptions such
    as ACPI.
    
    This is done by:
    
    - Adding a return code to gpiochip_add_pin_range() so we can
      reliably check whether this succeeds.
    
    - Get rid of the custom of_pinctrl_add_gpio_range() from
      pinctrl. Instead create of_pinctrl_get() to just retrive the
      pin controller per se from an OF node. This composite
      function was just begging to be deleted, it was way to
      purpose-specific.
    
    - Use pinctrl_dev_get_name() to get the name of the retrieved
      pin controller and use that to call back into the generic
      gpiochip_add_pin_range().
    
    Now the pin range is only allocated and tied to a pin
    controller from the core implementation in gpiolib.c.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 434e5a94e131..4a58428bc793 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -141,16 +141,13 @@ extern struct pinctrl_dev *find_pinctrl_and_add_gpio_range(const char *devname,
 		struct pinctrl_gpio_range *range);
 
 #ifdef CONFIG_OF
-extern struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
-		struct pinctrl_gpio_range *range);
+extern struct pinctrl_dev *of_pinctrl_get(struct device_node *np);
 #else
 static inline
-struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
-		struct pinctrl_gpio_range *range)
+struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
 {
 	return NULL;
 }
-
 #endif /* CONFIG_OF */
 
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);

commit f23f1516b6757c326cc638bed8c402c77e2a596e
Author: Shiraz Hashim <shiraz.hashim@st.com>
Date:   Sat Oct 27 15:21:36 2012 +0530

    gpiolib: provide provision to register pin ranges
    
    pinctrl subsystem needs gpio chip base to prepare set of gpio
    pin ranges, which a given pinctrl driver can handle. This is
    important to handle pinctrl gpio request calls in order to
    program a given pin properly for gpio operation.
    
    As gpio base is allocated dynamically during gpiochip
    registration, presently there exists no clean way to pass this
    information to the pinctrl subsystem.
    
    After few discussions from [1], it was concluded that may be
    gpio controller reporting the pin range it supports, is a
    better way than pinctrl subsystem directly registering it.
    
    [1] http://comments.gmane.org/gmane.linux.ports.arm.kernel/184816
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    [Edited documentation a bit]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index eda04674633d..434e5a94e131 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -136,6 +136,23 @@ extern void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
 				unsigned nranges);
 extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);
+
+extern struct pinctrl_dev *find_pinctrl_and_add_gpio_range(const char *devname,
+		struct pinctrl_gpio_range *range);
+
+#ifdef CONFIG_OF
+extern struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
+		struct pinctrl_gpio_range *range);
+#else
+static inline
+struct pinctrl_dev *of_pinctrl_add_gpio_range(struct device_node *np,
+		struct pinctrl_gpio_range *range)
+{
+	return NULL;
+}
+
+#endif /* CONFIG_OF */
+
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else

commit 7e10ee68f8ccc62e0934ff02f39ce541f3879844
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Oct 27 15:21:35 2012 +0530

    Revert "pinctrl: remove pinctrl_remove_gpio_range"
    
    This reverts earlier commit which removed
    pinctrl_remove_gpio_range(), because at that time there
    weren't any more users of that routine. It was removed as the
    removal of ranges was done in unregister of pinctrl.
    
    But as we are now registering stuff from gpiolib, we may
    remove and insert a gpio module multiple times. So, we
    need this routine again.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 7d087f03e91e..eda04674633d 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -134,6 +134,8 @@ extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 extern void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *ranges,
 				unsigned nranges);
+extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
+				struct pinctrl_gpio_range *range);
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else

commit a1ce39288e6fbefdd8d607021d02384eb4a20b99
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:25 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
    
    Convert #include "..." to #include <path/...> in kernel system headers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 69393a662532..7d087f03e91e 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -17,7 +17,7 @@
 #include <linux/radix-tree.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
-#include "pinctrl-state.h"
+#include <linux/pinctrl/pinctrl-state.h>
 
 struct device;
 struct pinctrl_dev;

commit 3e5e00b654997aa2c3998d30f7213b9611eb23d7
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Wed May 23 21:22:41 2012 +0800

    pinctrl: add pinctrl_add_gpio_ranges function
    
    Often GPIO ranges are added in batch, so create a special
    function for that.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 170a588a55b6..69393a662532 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -131,6 +131,9 @@ extern void pinctrl_unregister(struct pinctrl_dev *pctldev);
 extern bool pin_is_valid(struct pinctrl_dev *pctldev, int pin);
 extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);
+extern void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
+				struct pinctrl_gpio_range *ranges,
+				unsigned nranges);
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else

commit 5d589b092ab212bbcc27828167e1c036e7fc77d2
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Wed May 23 21:22:40 2012 +0800

    pinctrl: remove pinctrl_remove_gpio_range
    
    The gpio ranges will be automatically removed when the pinctrl
    driver is unregistered.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 3b894a668d32..170a588a55b6 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -131,8 +131,6 @@ extern void pinctrl_unregister(struct pinctrl_dev *pctldev);
 extern bool pin_is_valid(struct pinctrl_dev *pctldev, int pin);
 extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 				struct pinctrl_gpio_range *range);
-extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
-				struct pinctrl_gpio_range *range);
 extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else

commit 02ae6da28fb7aa31d8bf1972c99e83c58b684198
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Apr 26 10:18:52 2012 -0600

    pinctrl: add kerneldoc for pinctrl_ops device tree functions
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index c22d0409d2ef..3b894a668d32 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -72,6 +72,15 @@ struct pinctrl_gpio_range {
  *	group selector @pins, and the size of the array in @num_pins
  * @pin_dbg_show: optional debugfs display hook that will provide per-device
  *	info for a certain pin in debugfs
+ * @dt_node_to_map: parse a device tree "pin configuration node", and create
+ *	mapping table entries for it. These are returned through the @map and
+ *	@num_maps output parameters. This function is optional, and may be
+ *	omitted for pinctrl drivers that do not support device tree.
+ * @dt_free_map: free mapping table entries created via @dt_node_to_map. The
+ *	top-level @map pointer must be freed, along with any dynamically
+ *	allocated members of the mapping table entries themselves. This
+ *	function is optional, and may be omitted for pinctrl drivers that do
+ *	not support device tree.
  */
 struct pinctrl_ops {
 	int (*get_groups_count) (struct pinctrl_dev *pctldev);

commit d1e90e9e7467dbfe521b25ba79f520bf676ebc36
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Fri Mar 30 11:25:40 2012 +0530

    pinctrl: replace list_*() with get_*_count()
    
    Most of the SoC drivers implement list_groups() and list_functions()
    routines for pinctrl and pinmux. These routines continue returning
    zero until the selector argument is greater than total count of
    available groups or functions.
    
    This patch replaces these list_*() routines with get_*_count()
    routines, which returns the number of available selection for SoC
    driver. pinctrl layer will use this value to check the range it can
    choose.
    
    This patch fixes all user drivers for this change. There are other
    routines in user drivers, which have checks to check validity of
    selector passed to them. It is also no more required and hence
    removed.
    
    Documentation updated as well.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    [Folded in fix and fixed a minor merge artifact manually]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index aa92cdeb99fd..c22d0409d2ef 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -66,9 +66,7 @@ struct pinctrl_gpio_range {
 /**
  * struct pinctrl_ops - global pin control operations, to be implemented by
  * pin controller drivers.
- * @list_groups: list the number of selectable named groups available
- *	in this pinmux driver, the core will begin on 0 and call this
- *	repeatedly as long as it returns >= 0 to enumerate the groups
+ * @get_groups_count: Returns the count of total number of groups registered.
  * @get_group_name: return the group name of the pin group
  * @get_group_pins: return an array of pins corresponding to a certain
  *	group selector @pins, and the size of the array in @num_pins
@@ -76,7 +74,7 @@ struct pinctrl_gpio_range {
  *	info for a certain pin in debugfs
  */
 struct pinctrl_ops {
-	int (*list_groups) (struct pinctrl_dev *pctldev, unsigned selector);
+	int (*get_groups_count) (struct pinctrl_dev *pctldev);
 	const char *(*get_group_name) (struct pinctrl_dev *pctldev,
 				       unsigned selector);
 	int (*get_group_pins) (struct pinctrl_dev *pctldev,

commit 57291ce295c0aca738dd284c4a9c591c09ebee71
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Fri Mar 23 10:29:46 2012 -0600

    pinctrl: core device tree mapping table parsing support
    
    During pinctrl_get(), if the client device has a device tree node, look
    for the common pinctrl properties there. If found, parse the referenced
    device tree nodes, with the help of the pinctrl drivers, and generate
    mapping table entries from them.
    
    During pinctrl_put(), free any results of device tree parsing.
    
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 4e9f0788c221..aa92cdeb99fd 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -21,9 +21,11 @@
 
 struct device;
 struct pinctrl_dev;
+struct pinctrl_map;
 struct pinmux_ops;
 struct pinconf_ops;
 struct gpio_chip;
+struct device_node;
 
 /**
  * struct pinctrl_pin_desc - boards/machines provide information on their
@@ -83,6 +85,11 @@ struct pinctrl_ops {
 			       unsigned *num_pins);
 	void (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s,
 			  unsigned offset);
+	int (*dt_node_to_map) (struct pinctrl_dev *pctldev,
+			       struct device_node *np_config,
+			       struct pinctrl_map **map, unsigned *num_maps);
+	void (*dt_free_map) (struct pinctrl_dev *pctldev,
+			     struct pinctrl_map *map, unsigned num_maps);
 };
 
 /**

commit 0acfb076f7987bd4bb5cd5de879ba3e3e71724e9
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Tue Mar 6 12:12:12 2012 -0700

    pinctrl: forward-declare struct device
    
    Add a dummy declaration of struct device to avoid the following warning:
    
    In file included from include/linux/pinctrl/machine.h:15:0,
                     from arch/arm/mach-tegra/board-pinmux.h:18,
                     from arch/arm/mach-tegra/board-trimslice-pinmux.c:20:
    include/linux/pinctrl/pinctrl.h:115:12: warning: 'struct device' declared inside parameter list [enabled by default]
    include/linux/pinctrl/pinctrl.h:115:12: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default]
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index e9e94eb52d79..4e9f0788c221 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -19,6 +19,7 @@
 #include <linux/seq_file.h>
 #include "pinctrl-state.h"
 
+struct device;
 struct pinctrl_dev;
 struct pinmux_ops;
 struct pinconf_ops;

commit 9a01be1715b6a027765701ca09ba0401ff066fc5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 6 21:15:51 2012 +0100

    pinctrl: split pincontrol states into its own header
    
    Move the pin control state defines into its own header file,
    since it is used both by machine.h which is facing the platform
    and by consumer.h which is facing the drivers, and pinctrl.h
    which is pinctrl-driver internal, let's not have each and every
    .h file include all others, then isolation is moot.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index bbdd7e16bada..e9e94eb52d79 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -17,8 +17,7 @@
 #include <linux/radix-tree.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
-
-#define PINCTRL_STATE_DEFAULT "default"
+#include "pinctrl-state.h"
 
 struct pinctrl_dev;
 struct pinmux_ops;

commit 57b676f9c1b7cd84397fe5a86c9bd2788ac4bd32
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:44 2012 -0700

    pinctrl: fix and simplify locking
    
    There are many problems with the current pinctrl locking:
    
    struct pinctrl_dev's gpio_ranges_lock isn't effective;
    pinctrl_match_gpio_range() only holds this lock while searching for a gpio
    range, but the found range is return and manipulated after releading the
    lock. This could allow pinctrl_remove_gpio_range() for that range while it
    is in use, and the caller may very well delete the range after removing it,
    causing pinctrl code to touch the now-free range object.
    
    Solving this requires the introduction of a higher-level lock, at least
    a lock per pin controller, which both gpio range registration and
    pinctrl_get()/put() will acquire.
    
    There is missing locking on HW programming; pin controllers may pack the
    configuration for different pins/groups/config options/... into one
    register, and hence have to read-modify-write the register. This needs to
    be protected, but currently isn't. Related, a future change will add a
    "complete" op to the pin controller drivers, the idea being that each
    state's programming will be programmed into the pinctrl driver followed
    by the "complete" call, which may e.g. flush a register cache to HW. For
    this to work, it must not be possible to interleave the pinctrl driver
    calls for different devices.
    
    As above, solving this requires the introduction of a higher-level lock,
    at least a lock per pin controller, which will be held for the duration
    of any pinctrl_enable()/disable() call.
    
    However, each pinctrl mapping table entry may affect a different pin
    controller if necessary. Hence, with a per-pin-controller lock, almost
    any pinctrl API may need to acquire multiple locks, one per controller.
    To avoid deadlock, these would need to be acquired in the same order in
    all cases. This is extremely difficult to implement in the case of
    pinctrl_get(), which doesn't know which pin controllers to lock until it
    has parsed the entire mapping table, since it contains somewhat arbitrary
    data.
    
    The simplest solution here is to introduce a single lock that covers all
    pin controllers at once. This will be acquired by all pinctrl APIs.
    
    This then makes struct pinctrl's mutex irrelevant, since that single lock
    will always be held whenever this mutex is currently held.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 411fe232adf1..bbdd7e16bada 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -15,7 +15,6 @@
 #ifdef CONFIG_PINCTRL
 
 #include <linux/radix-tree.h>
-#include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
 

commit 46919ae63d4820e76724beb655274ce143f0da0b
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 1 18:48:32 2012 -0700

    pinctrl: introduce PINCTRL_STATE_DEFAULT, define hogs as that state
    
    This provides a single centralized name for the default state.
    
    Update PIN_MAP_* macros to use this state name, instead of requiring the
    user to pass a state name in.
    
    With this change, hog entries in the mapping table are defined as those
    with state name PINCTRL_STATE_DEFAULT, i.e. all entries have the same
    name. This interacts badly with the nested iteration over mapping table
    entries in pinctrl_hog_maps() and pinctrl_hog_map() which would now
    attempt to claim each hog mapping table entry multiple times. Replacing
    the custom hog code with a simple pinctrl_get()/pinctrl_enable().
    
    Update documentation and mapping tables to use this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 8bd22ee7aa09..411fe232adf1 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -19,6 +19,8 @@
 #include <linux/list.h>
 #include <linux/seq_file.h>
 
+#define PINCTRL_STATE_DEFAULT "default"
+
 struct pinctrl_dev;
 struct pinmux_ops;
 struct pinconf_ops;

commit 0d2006bbf09e817f125ba1e42b2549bc2c5d7351
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Tue Jan 3 16:47:51 2012 +0900

    pinctrl: remove unnecessary max pin number
    
    This patch removes maxpin member in the pin control descriptor
    because we don't need this value as we enumerate a pin space
    using offset.
    
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 9809a94f151b..8bd22ee7aa09 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -92,10 +92,6 @@ struct pinctrl_ops {
  *	this pin controller
  * @npins: number of descriptors in the array, usually just ARRAY_SIZE()
  *	of the pins field above
- * @maxpin: since pin spaces may be sparse, there can he "holes" in the
- *	pin range, this attribute gives the maximum pin number in the
- *	total range. This should not be lower than npins for example,
- *	but may be equal to npins if you have no holes in the pin range.
  * @pctlops: pin control operation vtable, to support global concepts like
  *	grouping of pins, this is optional.
  * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver
@@ -107,7 +103,6 @@ struct pinctrl_desc {
 	const char *name;
 	struct pinctrl_pin_desc const *pins;
 	unsigned int npins;
-	unsigned int maxpin;
 	struct pinctrl_ops *pctlops;
 	struct pinmux_ops *pmxops;
 	struct pinconf_ops *confops;

commit ae6b4d8588f4fc95520b0e62c4b1f474c82191a9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 19 18:14:33 2011 +0200

    pinctrl: add a pin config interface
    
    This add per-pin and per-group pin config interfaces for biasing,
    driving and other such electronic properties. The details of passed
    configurations are passed in an opaque unsigned long which may be
    dereferences to integer types, structs or lists on either side
    of the configuration interface.
    
    ChangeLog v1->v2:
    - Clear split of terminology: we now have pin controllers, and
      those may support two interfaces using vtables: pin
      multiplexing and pin configuration.
    - Break out pin configuration to its own C file, controllers may
      implement only config without mux, and vice versa, so keep each
      sub-functionality of pin controllers separate. Introduce
      CONFIG_PINCONF in Kconfig.
    - Implement some core logic around pin configuration in the
      pinconf.c file.
    - Remove UNKNOWN config states, these were just surplus baggage.
    - Remove FLOAT config state - HIGH_IMPEDANCE should be enough for
      everyone.
    - PIN_CONFIG_POWER_SOURCE added to handle switching the power
      supply for the pin logic between different sources
    - Explicit DISABLE config enums to turn schmitt-trigger,
      wakeup etc OFF.
    - Update documentation to reflect all the recent reasoning.
    ChangeLog v2->v3:
    - Twist API around to pass around arrays of config tuples instead
      of (param, value) pairs everywhere.
    - Explicit drive strength semantics for push/pull and similar
      drive modes, this shall be the number of drive stages vs
      nominal load impedance, which should match the actual
      electronics used in push/pull CMOS or TTY totempoles.
    - Drop load capacitance configuration - I probably don't know
      what I'm doing here so leave it out.
    - Drop PIN_CONFIG_INPUT_SCHMITT_OFF, instead the argument zero to
      PIN_CONFIG_INPUT_SCHMITT turns schmitt trigger off.
    - Drop PIN_CONFIG_NORMAL_POWER_MODE and have a well defined
      argument to PIN_CONFIG_LOW_POWER_MODE to get out of it instead.
    - Drop PIN_CONFIG_WAKEUP_ENABLE/DISABLE and just use
      PIN_CONFIG_WAKEUP with defined value zero to turn wakeup off.
    - Add PIN_CONFIG_INPUT_DEBOUNCE for configuring debounce time
      on input lines.
    - Fix a bug when we tried to configure pins for pin controllers
      without pinconf support.
    - Initialized debugfs properly so it works.
    - Initialize the mutex properly and lock around config tampering
      sections.
    - Check the return value from get_initial_config() properly.
    ChangeLog v3->v4:
    - Export the pin_config_get(), pin_config_set() and
      pin_config_group() functions.
    - Drop the entire concept of just getting initial config and
      keeping track of pin states internally, instead ask the pins
      what state they are in. Previous idea was plain wrong, if the
      device cannot keep track of its state, the driver should do
      it.
    - Drop the generic configuration layout, it seems this impose
      too much restriction on some pin controllers, so let them do
      things the way they want and split off support for generic
      config as an optional add-on.
    ChangeLog v4->v5:
    - Introduce two symmetric driver calls for group configuration,
      .pin_config_group_[get|set] and corresponding external calls.
    - Remove generic semantic meanings of return values from config
      calls, these belong in the generic config patch. Just pass the
      return value through instead.
    - Add a debugfs entry "pinconf-groups" to read status from group
      configuration only, also slam in a per-group debug callback in
      the pinconf_ops so custom drivers can display something
      meaningful for their pins.
    - Fix some dangling newline.
    - Drop dangling #else clause.
    - Update documentation to match the above.
    ChangeLog v5->v6:
    - Change to using a pin name as parameter for the
      [get|set]_config() functions, as suggested by Stephen Warren.
      This is more natural as names will be what a developer has
      access to in written documentation etc.
    ChangeLog v6->v7:
    - Refactor out by-pin and by-name get/set functions, only expose
      the by-name functions externally, expose the by-pin functions
      internally.
    - Show supported pin control functionality in the debugfs
      pinctrl-devices file.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index f17fac4b51f1..9809a94f151b 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -21,6 +21,7 @@
 
 struct pinctrl_dev;
 struct pinmux_ops;
+struct pinconf_ops;
 struct gpio_chip;
 
 /**
@@ -97,7 +98,9 @@ struct pinctrl_ops {
  *	but may be equal to npins if you have no holes in the pin range.
  * @pctlops: pin control operation vtable, to support global concepts like
  *	grouping of pins, this is optional.
- * @pmxops: pinmux operation vtable, if you support pinmuxing in your driver
+ * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver
+ * @confops: pin config operations vtable, if you support pin configuration in
+ *	your driver
  * @owner: module providing the pin controller, used for refcounting
  */
 struct pinctrl_desc {
@@ -107,6 +110,7 @@ struct pinctrl_desc {
 	unsigned int maxpin;
 	struct pinctrl_ops *pctlops;
 	struct pinmux_ops *pmxops;
+	struct pinconf_ops *confops;
 	struct module *owner;
 };
 
@@ -125,7 +129,7 @@ extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 
 struct pinctrl_dev;
 
-/* Sufficiently stupid default function when pinctrl is not in use */
+/* Sufficiently stupid default functions when pinctrl is not in use */
 static inline bool pin_is_valid(struct pinctrl_dev *pctldev, int pin)
 {
 	return pin >= 0;

commit 3c739ad0df5eb41cd7adad879eda6aa09879eb76
Author: Chanho Park <chanho61.park@samsung.com>
Date:   Fri Nov 11 18:47:58 2011 +0900

    pinctrl: add a pin_base for sparse gpio-ranges
    
    This patch enables mapping a base offset of gpio ranges with
    a pin offset even if does'nt matched. A base of pinctrl_gpio_range
    means a base offset of gpio. However, we cannot convert gpio to pin
    number for sparse gpio ranges just only using a gpio base offset.
    We can convert a gpio to real pin number(even if not matched) using
    a new pin_base which means a base pin offset of requested gpio range.
    Now, the pin control subsystem passes the pin base offset to the
    pinmux driver.
    
    For example, let's assume below two gpio ranges in the system.
    
    static struct pinctrl_gpio_range gpio_range_a = {
        .name = "chip a",
        .id = 0,
        .base = 32,
        .pin_base = 32,
        .npins = 16,
        .gc = &chip_a;
    };
    
    static struct pinctrl_gpio_range gpio_range_b = {
        .name = "chip b",
        .id = 0,
        .base = 48,
        .pin_base = 64,
        .npins = 8,
        .gc = &chip_b;
    };
    
    We can calucalate a exact pin ranges even if doesn't matched with gpio ranges.
    
    chip a:
        gpio-range : [32 .. 47]
        pin-range  : [32 .. 47]
    chip b:
        gpio-range : [48 .. 55]
        pin-range  : [64 .. 71]
    
    Signed-off-by: Chanho Park <chanho61.park@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 04c011038f32..f17fac4b51f1 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -45,6 +45,7 @@ struct pinctrl_pin_desc {
  * @name: a name for the chip in this range
  * @id: an ID number for the chip in this range
  * @base: base offset of the GPIO range
+ * @pin_base: base pin number of the GPIO range
  * @npins: number of pins in the GPIO range, including the base number
  * @gc: an optional pointer to a gpio_chip
  */
@@ -53,6 +54,7 @@ struct pinctrl_gpio_range {
 	const char *name;
 	unsigned int id;
 	unsigned int base;
+	unsigned int pin_base;
 	unsigned int npins;
 	struct gpio_chip *gc;
 };

commit e0e20753c15fc418d94fee826af394907df856d8
Author: Barry Song <Baohua.Song@csr.com>
Date:   Thu Oct 27 20:38:24 2011 -0700

    pinctrl: fix "warning: 'struct pinctrl_dev' declared inside parameter list"
    
    when pinctl subsystem is not selected, when compiling drivers including
    the include/linux/pinctrl/pinctrl.h, we will get the warning as below:
    In file included from include/linux/pinctrl/pinmux.h:17,
                     from drivers/tty/serial/sirfsoc_uart.c:25:
    include/linux/pinctrl/pinctrl.h:126: warning: 'struct pinctrl_dev'
                    declared inside parameter list
    include/linux/pinctrl/pinctrl.h:126: warning: its scope is only this
          definition or declaration, which is probably not what you want
    
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 3605e947fa90..04c011038f32 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -121,6 +121,7 @@ extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
 extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
 #else
 
+struct pinctrl_dev;
 
 /* Sufficiently stupid default function when pinctrl is not in use */
 static inline bool pin_is_valid(struct pinctrl_dev *pctldev, int pin)

commit a5818a8bd095a08cfb1871b63af9c8bed103e4b9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Oct 19 16:19:25 2011 -0600

    pinctrl: get_group_pins() const fixes
    
    get_group_pins() "returns" a pointer to an array of const objects, through
    a pointer parameter. Fix the prototype so what's pointed at by the returned
    pointer is const, rather than the function parameter being const.
    
    This also allows the removal of a cast in each of the two current pinmux
    drivers.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
index 4f8d2089acce..3605e947fa90 100644
--- a/include/linux/pinctrl/pinctrl.h
+++ b/include/linux/pinctrl/pinctrl.h
@@ -75,8 +75,8 @@ struct pinctrl_ops {
 				       unsigned selector);
 	int (*get_group_pins) (struct pinctrl_dev *pctldev,
 			       unsigned selector,
-			       unsigned ** const pins,
-			       unsigned * const num_pins);
+			       const unsigned **pins,
+			       unsigned *num_pins);
 	void (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s,
 			  unsigned offset);
 };

commit 2744e8afb3b76343e7eb8197e8b3e085036010a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 2 20:50:54 2011 +0200

    drivers: create a pin control subsystem
    
    This creates a subsystem for handling of pin control devices.
    These are devices that control different aspects of package
    pins.
    
    Currently it handles pinmuxing, i.e. assigning electronic
    functions to groups of pins on primarily PGA and BGA type of
    chip packages which are common in embedded systems.
    
    The plan is to also handle other I/O pin control aspects
    such as biasing, driving, input properties such as
    schmitt-triggering, load capacitance etc within this
    subsystem, to remove a lot of ARM arch code as well as
    feature-creepy GPIO drivers which are implementing the same
    thing over and over again.
    
    This is being done to depopulate the arch/arm/* directory
    of such custom drivers and try to abstract the infrastructure
    they all need. See the Documentation/pinctrl.txt file that is
    part of this patch for more details.
    
    ChangeLog v1->v2:
    
    - Various minor fixes from Joe's and Stephens review comments
    - Added a pinmux_config() that can invoke custom configuration
      with arbitrary data passed in or out to/from the pinmux driver
    
    ChangeLog v2->v3:
    
    - Renamed subsystem folder to "pinctrl" since we will likely
      want to keep other pin control such as biasing in this
      subsystem too, so let us keep to something generic even though
      we're mainly doing pinmux now.
    - As a consequence, register pins as an abstract entity separate
      from the pinmux. The muxing functions will claim pins out of the
      pin pool and make sure they do not collide. Pins can now be
      named by the pinctrl core.
    - Converted the pin lookup from a static array into a radix tree,
      I agreed with Grant Likely to try to avoid any static allocation
      (which is crap for device tree stuff) so I just rewrote this
      to be dynamic, just like irq number descriptors. The
      platform-wide definition of number of pins goes away - this is
      now just the sum total of the pins registered to the subsystem.
    - Make sure mappings with only a function name and no device
      works properly.
    
    ChangeLog v3->v4:
    
    - Define a number space per controller instead of globally,
      Stephen and Grant requested the same thing so now maps need to
      define target controller, and the radix tree of pin descriptors
      is a property on each pin controller device.
    - Add a compulsory pinctrl device entry to the pinctrl mapping
      table. This must match the pinctrl device, like "pinctrl.0"
    - Split the file core.c in two: core.c and pinmux.c where the
      latter carry all pinmux stuff, the core is for generic pin
      control, and use local headers to access functionality between
      files. It is now possible to implement a "blank" pin controller
      without pinmux capabilities. This split will make new additions
      like pindrive.c, pinbias.c etc possible for combined drivers
      and chunks of functionality which is a GoodThing(TM).
    - Rewrite the interaction with the GPIO subsystem - the pin
      controller descriptor now handles this by defining an offset
      into the GPIO numberspace for its handled pin range. This is
      used to look up the apropriate pin controller for a GPIO pin.
      Then that specific GPIO range is matched 1-1 for the target
      controller instance.
    - Fixed a number of review comments from Joe Perches.
    - Broke out a header file pinctrl.h for the core pin handling
      stuff that will be reused by other stuff than pinmux.
    - Fixed some erroneous EXPORT() stuff.
    - Remove mispatched U300 Kconfig and Makefile entries
    - Fixed a number of review comments from Stephen Warren, not all
      of them - still WIP. But I think the new mapping that will
      specify which function goes to which pin mux controller address
      50% of your concerns (else beat me up).
    
    ChangeLog v4->v5:
    
    - Defined a "position" for each function, so the pin controller now
      tracks a function in a certain position, and the pinmux maps define
      what position you want the function in. (Feedback from Stephen
      Warren and Sascha Hauer).
    - Since we now need to request a combined function+position from
      the machine mapping table that connect mux settings to drivers,
      it was extended with a position field and a name field. The
      name field is now used if you e.g. need to switch between two
      mux map settings at runtime.
    - Switched from a class device to using struct bus_type for this
      subsystem. Verified sysfs functionality: seems to work fine.
      (Feedback from Arnd Bergmann and Greg Kroah-Hartman)
    - Define a per pincontroller list of GPIO ranges from the GPIO
      pin space that can be handled by the pin controller. These can
      be added one by one at runtime. (Feedback from Barry Song)
    - Expanded documentation of regulator_[get|enable|disable|put]
      semantics.
    - Fixed a number of review comments from Barry Song. (Thanks!)
    
    ChangeLog v5->v6:
    
    - Create an abstract pin group concept that can sort pins into
      named and enumerated groups no matter what the use of these
      groups may be, one possible usecase is a group of pins being
      muxed in or so. The intention is however to also use these
      groups for other pin control activities.
    - Make it compulsory for pinmux functions to associate with
      at least one group, so the abstract pin group concept is used
      to define the groups of pins affected by a pinmux function.
      The pinmux driver interface has been altered so as to enforce
      a function to list applicable groups per function.
    - Provide an optional .group entry in the pinmux machine map
      so the map can select beteween different available groups
      to be used with a certain function.
    - Consequent changes all over the place so that e.g. debugfs
      present reasonable information about the world.
    - Drop the per-pin mux (*config) function in the pinmux_ops
      struct - I was afraid that this would start to be used for
      things totally unrelated to muxing, we can introduce that to
      the generic struct pinctrl_ops if needed. I want to keep
      muxing orthogonal to other pin control subjects and not mix
      these things up.
    
    ChangeLog v6->v7:
    
    - Make it possible to have several map entries matching the
      same device, pin controller and function, but using
      a different group, and alter the semantics so that
      pinmux_get() will pick all matching map entries, and
      store the associated groups in a list. The list will
      then be iterated over at pinmux_enable()/pinmux_disable()
      and corresponding driver functions called for each
      defined group. Notice that you're only allowed to map
      multiple *groups* to the same
      { device, pin controller, function } triplet, attempts
      to map the same device to multiple pin controllers will
      for example fail. This is hopefully the crucial feature
      requested by Stephen Warren.
    - Add a pinmux hogging field to the pinmux mapping entries,
      and enable the pinmux core to hog pinmux map entries.
      This currently only works for pinmuxes without assigned
      devices as it looks now, but with device trees we can
      look up the corresponding struct device * entries when
      we register the pinmux driver, and have it hog each
      pinmux map in turn, for a simple approach to
      non-dynamic pin muxing. This addresses an issue from
      Grant Likely that the machine should take care of as
      much of the pinmux setup as possible, not the devices.
      By supplying a list of hogs, it can now instruct the
      core to take care of any static mappings.
    - Switch pinmux group retrieveal function to grab an
      array of strings representing the groups rather than an
      array of unsigned and rewrite accordingly.
    - Alter debugfs to show the grouplist handled by each
      pinmux. Also add a list of hogs.
    - Dynamically allocate a struct pinmux at pinmux_get() and
      free it at pinmux_put(), then add these to the global
      list of pinmuxes active as we go along.
    - Go over the list of pinmux maps at pinmux_get() time
      and repeatedly apply matches.
    - Retrieve applicable groups per function from the driver
      as a string array rather than a unsigned array, then
      lookup the enumerators.
    - Make the device to pinmux map a singleton - only allow the
      mapping table to be registered once and even tag the
      registration function with __init so it surely won't be
      abused.
    - Create a separate debugfs file to view the pinmux map at
      runtime.
    - Introduce a spin lock to the pin descriptor struct, lock it
      when modifying pin status entries. Reported by Stijn Devriendt.
    - Fix up the documentation after review from Stephen Warren.
    - Let the GPIO ranges give names as const char * instead of some
      fixed-length string.
    - add a function to unregister GPIO ranges to mirror the
      registration function.
    - Privatized the struct pinctrl_device and removed it from the
      <linux/pinctrl/pinctrl.h> API, the drivers do not need to know
      the members of this struct. It is now in the local header
      "core.h".
    - Rename the concept of "anonymous" mux maps to "system" muxes
      and add convenience macros and documentation.
    
    ChangeLog v7->v8:
    
    - Delete the leftover pinmux_config() function from the
     <linux/pinctrl/pinmux.h> header.
    - Fix a race condition found by Stijn Devriendt in pin_request()
    
    ChangeLog v8->v9:
    
    - Drop the bus_type and the sysfs attributes and all, we're not on
      the clear about how this should be used for e.g. userspace
      interfaces so let us save this for the future.
    - Use the right name in MAINTAINERS, PIN CONTROL rather than
      PINMUX
    - Don't kfree() the device state holder, let the .remove() callback
      handle this.
    - Fix up numerous kerneldoc headers to have one line for the function
      description and more verbose documentation below the parameters
    
    ChangeLog v9->v10:
    - pinctrl: EXPORT_SYMBOL needs export.h, folded in a patch
      from Steven Rothwell
    - fix pinctrl_register error handling, folded in a patch from
      Axel Lin
    - Various fixes to documentation text so that it's consistent.
    - Removed pointless comment from drivers/Kconfig
    - Removed dependency on SYSFS since we removed the bus in
      v9.
    - Renamed hopelessly abbreviated pctldev_* functions to the
      more verbose pinctrl_dev_*
    - Drop mutex properly when looking up GPIO ranges
    - Return NULL instead of ERR_PTR() errors on registration of
      pin controllers, using cast pointers is fragile. We can
      live without the detailed error codes for sure.
    
    Cc: Stijn Devriendt <highguy@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/pinctrl.h b/include/linux/pinctrl/pinctrl.h
new file mode 100644
index 000000000000..4f8d2089acce
--- /dev/null
+++ b/include/linux/pinctrl/pinctrl.h
@@ -0,0 +1,133 @@
+/*
+ * Interface the pinctrl subsystem
+ *
+ * Copyright (C) 2011 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * This interface is used in the core to keep track of pins.
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#ifndef __LINUX_PINCTRL_PINCTRL_H
+#define __LINUX_PINCTRL_PINCTRL_H
+
+#ifdef CONFIG_PINCTRL
+
+#include <linux/radix-tree.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+
+struct pinctrl_dev;
+struct pinmux_ops;
+struct gpio_chip;
+
+/**
+ * struct pinctrl_pin_desc - boards/machines provide information on their
+ * pins, pads or other muxable units in this struct
+ * @number: unique pin number from the global pin number space
+ * @name: a name for this pin
+ */
+struct pinctrl_pin_desc {
+	unsigned number;
+	const char *name;
+};
+
+/* Convenience macro to define a single named or anonymous pin descriptor */
+#define PINCTRL_PIN(a, b) { .number = a, .name = b }
+#define PINCTRL_PIN_ANON(a) { .number = a }
+
+/**
+ * struct pinctrl_gpio_range - each pin controller can provide subranges of
+ * the GPIO number space to be handled by the controller
+ * @node: list node for internal use
+ * @name: a name for the chip in this range
+ * @id: an ID number for the chip in this range
+ * @base: base offset of the GPIO range
+ * @npins: number of pins in the GPIO range, including the base number
+ * @gc: an optional pointer to a gpio_chip
+ */
+struct pinctrl_gpio_range {
+	struct list_head node;
+	const char *name;
+	unsigned int id;
+	unsigned int base;
+	unsigned int npins;
+	struct gpio_chip *gc;
+};
+
+/**
+ * struct pinctrl_ops - global pin control operations, to be implemented by
+ * pin controller drivers.
+ * @list_groups: list the number of selectable named groups available
+ *	in this pinmux driver, the core will begin on 0 and call this
+ *	repeatedly as long as it returns >= 0 to enumerate the groups
+ * @get_group_name: return the group name of the pin group
+ * @get_group_pins: return an array of pins corresponding to a certain
+ *	group selector @pins, and the size of the array in @num_pins
+ * @pin_dbg_show: optional debugfs display hook that will provide per-device
+ *	info for a certain pin in debugfs
+ */
+struct pinctrl_ops {
+	int (*list_groups) (struct pinctrl_dev *pctldev, unsigned selector);
+	const char *(*get_group_name) (struct pinctrl_dev *pctldev,
+				       unsigned selector);
+	int (*get_group_pins) (struct pinctrl_dev *pctldev,
+			       unsigned selector,
+			       unsigned ** const pins,
+			       unsigned * const num_pins);
+	void (*pin_dbg_show) (struct pinctrl_dev *pctldev, struct seq_file *s,
+			  unsigned offset);
+};
+
+/**
+ * struct pinctrl_desc - pin controller descriptor, register this to pin
+ * control subsystem
+ * @name: name for the pin controller
+ * @pins: an array of pin descriptors describing all the pins handled by
+ *	this pin controller
+ * @npins: number of descriptors in the array, usually just ARRAY_SIZE()
+ *	of the pins field above
+ * @maxpin: since pin spaces may be sparse, there can he "holes" in the
+ *	pin range, this attribute gives the maximum pin number in the
+ *	total range. This should not be lower than npins for example,
+ *	but may be equal to npins if you have no holes in the pin range.
+ * @pctlops: pin control operation vtable, to support global concepts like
+ *	grouping of pins, this is optional.
+ * @pmxops: pinmux operation vtable, if you support pinmuxing in your driver
+ * @owner: module providing the pin controller, used for refcounting
+ */
+struct pinctrl_desc {
+	const char *name;
+	struct pinctrl_pin_desc const *pins;
+	unsigned int npins;
+	unsigned int maxpin;
+	struct pinctrl_ops *pctlops;
+	struct pinmux_ops *pmxops;
+	struct module *owner;
+};
+
+/* External interface to pin controller */
+extern struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
+				struct device *dev, void *driver_data);
+extern void pinctrl_unregister(struct pinctrl_dev *pctldev);
+extern bool pin_is_valid(struct pinctrl_dev *pctldev, int pin);
+extern void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
+				struct pinctrl_gpio_range *range);
+extern void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
+				struct pinctrl_gpio_range *range);
+extern const char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev);
+extern void *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev);
+#else
+
+
+/* Sufficiently stupid default function when pinctrl is not in use */
+static inline bool pin_is_valid(struct pinctrl_dev *pctldev, int pin)
+{
+	return pin >= 0;
+}
+
+#endif /* !CONFIG_PINCTRL */
+
+#endif /* __LINUX_PINCTRL_PINCTRL_H */
