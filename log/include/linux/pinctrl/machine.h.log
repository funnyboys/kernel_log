commit c72bed23b9e45accdeab626cf2cb2bd08d846f3e
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Dec 16 21:51:18 2019 +0100

    pinctrl: Allow modules to use pinctrl_[un]register_mappings
    
    Currently only the drivers/pinctrl/devicetree.c code allows registering
    pinctrl-mappings which may later be unregistered, all other mappings
    are assumed to be permanent.
    
    Non-dt platforms may also want to register pinctrl mappings from code which
    is build as a module, which requires being able to unregister the mapping
    when the module is unloaded to avoid dangling pointers.
    
    To allow unregistering the mappings the devicetree code uses 2 internal
    functions: pinctrl_register_map and pinctrl_unregister_map.
    
    pinctrl_register_map allows the devicetree code to tell the core to
    not memdup the mappings as it retains ownership of them and
    pinctrl_unregister_map does the unregistering, note this only works
    when the mappings where not memdupped.
    
    The only code relying on the memdup/shallow-copy done by
    pinctrl_register_mappings is arch/arm/mach-u300/core.c this commit
    replaces the __initdata with const, so that the shallow-copy is no
    longer necessary.
    
    After that we can get rid of the internal pinctrl_unregister_map function
    and just use pinctrl_register_mappings directly everywhere.
    
    This commit also renames pinctrl_unregister_map to
    pinctrl_unregister_mappings so that its naming matches its
    pinctrl_register_mappings counter-part and exports it.
    
    Together these 2 changes will allow non-dt platform code to
    register pinctrl-mappings from modules without breaking things on
    module unload (as they can now unregister the mapping on unload).
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20191216205122.1850923-2-hdegoede@redhat.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index ddd1b2773431..e987dc9fd2af 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -153,6 +153,7 @@ struct pinctrl_map {
 
 extern int pinctrl_register_mappings(const struct pinctrl_map *map,
 				unsigned num_maps);
+extern void pinctrl_unregister_mappings(const struct pinctrl_map *map);
 extern void pinctrl_provide_dummies(void);
 #else
 
@@ -162,6 +163,10 @@ static inline int pinctrl_register_mappings(const struct pinctrl_map *map,
 	return 0;
 }
 
+static inline void pinctrl_unregister_mappings(const struct pinctrl_map *map)
+{
+}
+
 static inline void pinctrl_provide_dummies(void)
 {
 }

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 7fa5d87190c2..ddd1b2773431 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Machine interface for the pinctrl subsystem.
  *
@@ -6,8 +7,6 @@
  * Based on bits of regulator core, gpio core and clk core
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 #ifndef __LINUX_PINCTRL_MACHINE_H
 #define __LINUX_PINCTRL_MACHINE_H

commit 3f713b7c223ebe5094973ce6e0272bd97363b552
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 4 11:22:31 2017 +0900

    pinctrl: move const qualifier before struct
    
    Update subsystem wide for consistency.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index e5b1716f98cc..7fa5d87190c2 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -152,12 +152,12 @@ struct pinctrl_map {
 
 #ifdef CONFIG_PINCTRL
 
-extern int pinctrl_register_mappings(struct pinctrl_map const *map,
+extern int pinctrl_register_mappings(const struct pinctrl_map *map,
 				unsigned num_maps);
 extern void pinctrl_provide_dummies(void);
 #else
 
-static inline int pinctrl_register_mappings(struct pinctrl_map const *map,
+static inline int pinctrl_register_mappings(const struct pinctrl_map *map,
 					   unsigned num_maps)
 {
 	return 0;

commit a1ce39288e6fbefdd8d607021d02384eb4a20b99
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:25 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
    
    Convert #include "..." to #include <path/...> in kernel system headers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 7d22ab00343f..e5b1716f98cc 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -14,7 +14,7 @@
 
 #include <linux/bug.h>
 
-#include "pinctrl-state.h"
+#include <linux/pinctrl/pinctrl-state.h>
 
 enum pinctrl_map_type {
 	PIN_MAP_TYPE_INVALID,

commit 5b3aa5f7c6287b1a0698950a91e94546888e553b
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Thu Apr 26 16:15:50 2012 +0800

    pinctrl: add pinctrl_provide_dummies interface for platforms to use
    
    Add a interface pinctrl_provide_dummies for platform to indicate
    whether it needs use pinctrl dummy state.
    
    ChangeLog v3->v4:
    * remove dummy gpio support in pinctrl subsystem.
      Let gpio driver decide whether it wants to use pinctrl gpio mux
      function.
    ChangeLog v2->v3:
    * Also changed the missed pinctrl gpio APIs in v1.
    ChangeLog v1->v2:
    * Based on sascha's suggestion, drop using kconfig since it will hide
      pinctrl errors on all other boards.
      See: https://lkml.org/lkml/2012/4/18/282
      It seemed both Linus and Stephen agreed with this way, so i'm ok
      with it too.
    * Add dummy gpio support.
      pinctrl gpio in the same situation as state.
    * Patch name changed.
      Original is pinctrl: handle dummy state in core.
    * Split removing old dt dummy interface into a separate patch
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 9c4a19867289..7d22ab00343f 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -154,7 +154,7 @@ struct pinctrl_map {
 
 extern int pinctrl_register_mappings(struct pinctrl_map const *map,
 				unsigned num_maps);
-
+extern void pinctrl_provide_dummies(void);
 #else
 
 static inline int pinctrl_register_mappings(struct pinctrl_map const *map,
@@ -163,5 +163,8 @@ static inline int pinctrl_register_mappings(struct pinctrl_map const *map,
 	return 0;
 }
 
+static inline void pinctrl_provide_dummies(void)
+{
+}
 #endif /* !CONFIG_PINCTRL */
 #endif

commit dd5127010afa560b1cfde7e2cffeadabdd20885d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 24 15:20:02 2012 +0200

    pinctrl: fix dangling comment
    
    This comment was referring to an older PINMUX define, it should
    be PINCTRL now.
    
    Reported-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index e4d1de742502..9c4a19867289 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -163,5 +163,5 @@ static inline int pinctrl_register_mappings(struct pinctrl_map const *map,
 	return 0;
 }
 
-#endif /* !CONFIG_PINMUX */
+#endif /* !CONFIG_PINCTRL */
 #endif

commit 22f099d0fcb33073a1f1f10402a16b28602e20f2
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Fri Mar 16 14:54:23 2012 -0600

    pinctrl: include <linux/bug.h> to prevent compile errors
    
    Macros in <linux/pinctrl/machine.h> call ARRAY_SIZE(), the definition of
    which eventually calls BUILD_BUG_ON_ZERO(), which is defined in
    <linux/bug.h>. Include that so that every .c file using the pinctrl macros
    doesn't have to do that itself.
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index d32eb8ccba84..e4d1de742502 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -12,6 +12,8 @@
 #ifndef __LINUX_PINCTRL_MACHINE_H
 #define __LINUX_PINCTRL_MACHINE_H
 
+#include <linux/bug.h>
+
 #include "pinctrl-state.h"
 
 enum pinctrl_map_type {

commit 6974f1f458b083a84778641c6a4665799d6156da
Author: Dong Aisheng <dong.aisheng@linaro.org>
Date:   Thu Apr 5 17:07:23 2012 +0800

    pinctrl: fix compile error if not select PINMUX support
    
    The pinctrl_register_mappings is defined in core.c, so change the dependent
    macro from CONFIG_MUX to CONFIG_PINCTRL.
    
    The compile error message is:
    drivers/pinctrl/core.c:886: error: redefinition of 'pinctrl_register_mappings'
    include/linux/pinctrl/machine.h:160: note: previous definition of 'pinctrl_register_mappings' was here
    make[2]: *** [drivers/pinctrl/core.o] Error 1
    make[1]: *** [drivers/pinctrl] Error 2
    make: *** [drivers] Error 2
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index fee4349364f7..d32eb8ccba84 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -148,7 +148,7 @@ struct pinctrl_map {
 #define PIN_MAP_CONFIGS_GROUP_HOG_DEFAULT(dev, grp, cfgs)		\
 	PIN_MAP_CONFIGS_GROUP(dev, PINCTRL_STATE_DEFAULT, dev, grp, cfgs)
 
-#ifdef CONFIG_PINMUX
+#ifdef CONFIG_PINCTRL
 
 extern int pinctrl_register_mappings(struct pinctrl_map const *map,
 				unsigned num_maps);

commit 9a01be1715b6a027765701ca09ba0401ff066fc5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 6 21:15:51 2012 +0100

    pinctrl: split pincontrol states into its own header
    
    Move the pin control state defines into its own header file,
    since it is used both by machine.h which is facing the platform
    and by consumer.h which is facing the drivers, and pinctrl.h
    which is pinctrl-driver internal, let's not have each and every
    .h file include all others, then isolation is moot.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 3fd2f9dfc645..fee4349364f7 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -12,7 +12,7 @@
 #ifndef __LINUX_PINCTRL_MACHINE_H
 #define __LINUX_PINCTRL_MACHINE_H
 
-#include "pinctrl.h"
+#include "pinctrl-state.h"
 
 enum pinctrl_map_type {
 	PIN_MAP_TYPE_INVALID,

commit 1e2082b520721734c358f776d34a069867214c8e
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:48 2012 -0700

    pinctrl: enhance mapping table to support pin config operations
    
    The pinctrl mapping table can now contain entries to:
    * Set the mux function of a pin group
    * Apply a set of pin config options to a pin or a group
    
    This allows pinctrl_select_state() to apply pin configs settings as well
    as mux settings.
    
    v3: Fix find_pinctrl() to iterate over the correct list.
       s/_MUX_CONFIGS_/_CONFIGS_/ in mapping table macros.
       Fix documentation to use correct mapping table macro.
    v2: Added numerous extra PIN_MAP_*() special-case macros.
       Fixed kerneldoc typo. Delete pinctrl_get_pin_id() and
       replace it with pin_get_from_name(). Various minor fixes.
       Updates due to rebase.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 05d25c8adbaf..3fd2f9dfc645 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -14,6 +14,41 @@
 
 #include "pinctrl.h"
 
+enum pinctrl_map_type {
+	PIN_MAP_TYPE_INVALID,
+	PIN_MAP_TYPE_DUMMY_STATE,
+	PIN_MAP_TYPE_MUX_GROUP,
+	PIN_MAP_TYPE_CONFIGS_PIN,
+	PIN_MAP_TYPE_CONFIGS_GROUP,
+};
+
+/**
+ * struct pinctrl_map_mux - mapping table content for MAP_TYPE_MUX_GROUP
+ * @group: the name of the group whose mux function is to be configured. This
+ *	field may be left NULL, and the first applicable group for the function
+ *	will be used.
+ * @function: the mux function to select for the group
+ */
+struct pinctrl_map_mux {
+	const char *group;
+	const char *function;
+};
+
+/**
+ * struct pinctrl_map_configs - mapping table content for MAP_TYPE_CONFIGS_*
+ * @group_or_pin: the name of the pin or group whose configuration parameters
+ *	are to be configured.
+ * @configs: a pointer to an array of config parameters/values to program into
+ *	hardware. Each individual pin controller defines the format and meaning
+ *	of config parameters.
+ * @num_configs: the number of entries in array @configs
+ */
+struct pinctrl_map_configs {
+	const char *group_or_pin;
+	unsigned long *configs;
+	unsigned num_configs;
+};
+
 /**
  * struct pinctrl_map - boards/machines shall provide this map for devices
  * @dev_name: the name of the device using this specific mapping, the name
@@ -22,46 +57,96 @@
  *	hogged by the driver itself upon registration
  * @name: the name of this specific map entry for the particular machine.
  *	This is the parameter passed to pinmux_lookup_state()
+ * @type: the type of mapping table entry
  * @ctrl_dev_name: the name of the device controlling this specific mapping,
- *	the name must be the same as in your struct device*
- * @group: sometimes a function can map to different pin groups, so this
- *	selects a certain specific pin group to activate for the function, if
- *	left as NULL, the first applicable group will be used
- * @function: a function in the driver to use for this mapping, the driver
- *	will lookup the function referenced by this ID on the specified
- *	pin control device
+ *	the name must be the same as in your struct device*. This field is not
+ *	used for PIN_MAP_TYPE_DUMMY_STATE
+ * @data: Data specific to the mapping type
  */
 struct pinctrl_map {
 	const char *dev_name;
 	const char *name;
+	enum pinctrl_map_type type;
 	const char *ctrl_dev_name;
-	const char *group;
-	const char *function;
+	union {
+		struct pinctrl_map_mux mux;
+		struct pinctrl_map_configs configs;
+	} data;
 };
 
-/*
- * Convenience macro to set a simple map from a certain pin controller and a
- * certain function to a named device
- */
-#define PIN_MAP(a, b, c, d) \
-	{ .name = a, .ctrl_dev_name = b, .function = c, .dev_name = d }
+/* Convenience macros to create mapping table entries */
 
-/*
- * Convenience macro to map a system function onto a certain pinctrl device,
- * to be hogged by the pin control core until the system shuts down.
- */
-#define PIN_MAP_SYS_HOG(a, b) \
-	{ .name = PINCTRL_STATE_DEFAULT, .ctrl_dev_name = a, .dev_name = a, \
-	  .function = b, }
+#define PIN_MAP_DUMMY_STATE(dev, state) \
+	{								\
+		.dev_name = dev,					\
+		.name = state,						\
+		.type = PIN_MAP_TYPE_DUMMY_STATE,			\
+	}
 
-/*
- * Convenience macro to map a system function onto a certain pinctrl device
- * using a specified group, to be hogged by the pin control core until the
- * system shuts down.
- */
-#define PIN_MAP_SYS_HOG_GROUP(a, b, c) \
-	{ .name = PINCTRL_STATE_DEFAULT, .ctrl_dev_name = a, .dev_name = a, \
-	  .function = b, .group = c, }
+#define PIN_MAP_MUX_GROUP(dev, state, pinctrl, grp, func)		\
+	{								\
+		.dev_name = dev,					\
+		.name = state,						\
+		.type = PIN_MAP_TYPE_MUX_GROUP,				\
+		.ctrl_dev_name = pinctrl,				\
+		.data.mux = {						\
+			.group = grp,					\
+			.function = func,				\
+		},							\
+	}
+
+#define PIN_MAP_MUX_GROUP_DEFAULT(dev, pinctrl, grp, func)		\
+	PIN_MAP_MUX_GROUP(dev, PINCTRL_STATE_DEFAULT, pinctrl, grp, func)
+
+#define PIN_MAP_MUX_GROUP_HOG(dev, state, grp, func)			\
+	PIN_MAP_MUX_GROUP(dev, state, dev, grp, func)
+
+#define PIN_MAP_MUX_GROUP_HOG_DEFAULT(dev, grp, func)			\
+	PIN_MAP_MUX_GROUP(dev, PINCTRL_STATE_DEFAULT, dev, grp, func)
+
+#define PIN_MAP_CONFIGS_PIN(dev, state, pinctrl, pin, cfgs)		\
+	{								\
+		.dev_name = dev,					\
+		.name = state,						\
+		.type = PIN_MAP_TYPE_CONFIGS_PIN,			\
+		.ctrl_dev_name = pinctrl,				\
+		.data.configs = {					\
+			.group_or_pin = pin,				\
+			.configs = cfgs,				\
+			.num_configs = ARRAY_SIZE(cfgs),		\
+		},							\
+	}
+
+#define PIN_MAP_CONFIGS_PIN_DEFAULT(dev, pinctrl, pin, cfgs)		\
+	PIN_MAP_CONFIGS_PIN(dev, PINCTRL_STATE_DEFAULT, pinctrl, pin, cfgs)
+
+#define PIN_MAP_CONFIGS_PIN_HOG(dev, state, pin, cfgs)			\
+	PIN_MAP_CONFIGS_PIN(dev, state, dev, pin, cfgs)
+
+#define PIN_MAP_CONFIGS_PIN_HOG_DEFAULT(dev, pin, cfgs)			\
+	PIN_MAP_CONFIGS_PIN(dev, PINCTRL_STATE_DEFAULT, dev, pin, cfgs)
+
+#define PIN_MAP_CONFIGS_GROUP(dev, state, pinctrl, grp, cfgs)		\
+	{								\
+		.dev_name = dev,					\
+		.name = state,						\
+		.type = PIN_MAP_TYPE_CONFIGS_GROUP,			\
+		.ctrl_dev_name = pinctrl,				\
+		.data.configs = {					\
+			.group_or_pin = grp,				\
+			.configs = cfgs,				\
+			.num_configs = ARRAY_SIZE(cfgs),		\
+		},							\
+	}
+
+#define PIN_MAP_CONFIGS_GROUP_DEFAULT(dev, pinctrl, grp, cfgs)		\
+	PIN_MAP_CONFIGS_GROUP(dev, PINCTRL_STATE_DEFAULT, pinctrl, grp, cfgs)
+
+#define PIN_MAP_CONFIGS_GROUP_HOG(dev, state, grp, cfgs)		\
+	PIN_MAP_CONFIGS_GROUP(dev, state, dev, grp, cfgs)
+
+#define PIN_MAP_CONFIGS_GROUP_HOG_DEFAULT(dev, grp, cfgs)		\
+	PIN_MAP_CONFIGS_GROUP(dev, PINCTRL_STATE_DEFAULT, dev, grp, cfgs)
 
 #ifdef CONFIG_PINMUX
 

commit 6e5e959dde0d92d177f035652aeaa77f9330c9c6
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:47 2012 -0700

    pinctrl: API changes to support multiple states per device
    
    The API model is changed from:
    
    p = pinctrl_get(dev, "state1");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    p = pinctrl_get(dev, "state2");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    
    to this:
    
    p = pinctrl_get(dev);
    s1 = pinctrl_lookup_state(p, "state1");
    s2 = pinctrl_lookup_state(p, "state2");
    pinctrl_select_state(p, s1);
    ...
    pinctrl_select_state(p, s2);
    ...
    pinctrl_put(p);
    
    This allows devices to directly transition between states without
    disabling the pin controller programming and put()/get()ing the
    configuration data each time. This model will also better suit pinconf
    programming, which doesn't have a concept of "disable".
    
    The special-case hogging feature of pin controllers is re-written to use
    the regular APIs instead of special-case code. Hence, the pinmux-hogs
    debugfs file is removed; see the top-level pinctrl-handles files for
    equivalent data.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 20e97353d5f9..05d25c8adbaf 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -21,23 +21,22 @@
  *	same name as the pin controllers own dev_name(), the map entry will be
  *	hogged by the driver itself upon registration
  * @name: the name of this specific map entry for the particular machine.
- *	This is the second parameter passed to pinmux_get() when you want
- *	to have several mappings to the same device
+ *	This is the parameter passed to pinmux_lookup_state()
  * @ctrl_dev_name: the name of the device controlling this specific mapping,
  *	the name must be the same as in your struct device*
- * @function: a function in the driver to use for this mapping, the driver
- *	will lookup the function referenced by this ID on the specified
- *	pin control device
  * @group: sometimes a function can map to different pin groups, so this
  *	selects a certain specific pin group to activate for the function, if
  *	left as NULL, the first applicable group will be used
+ * @function: a function in the driver to use for this mapping, the driver
+ *	will lookup the function referenced by this ID on the specified
+ *	pin control device
  */
 struct pinctrl_map {
 	const char *dev_name;
 	const char *name;
 	const char *ctrl_dev_name;
-	const char *function;
 	const char *group;
+	const char *function;
 };
 
 /*

commit 46919ae63d4820e76724beb655274ce143f0da0b
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Mar 1 18:48:32 2012 -0700

    pinctrl: introduce PINCTRL_STATE_DEFAULT, define hogs as that state
    
    This provides a single centralized name for the default state.
    
    Update PIN_MAP_* macros to use this state name, instead of requiring the
    user to pass a state name in.
    
    With this change, hog entries in the mapping table are defined as those
    with state name PINCTRL_STATE_DEFAULT, i.e. all entries have the same
    name. This interacts badly with the nested iteration over mapping table
    entries in pinctrl_hog_maps() and pinctrl_hog_map() which would now
    attempt to claim each hog mapping table entry multiple times. Replacing
    the custom hog code with a simple pinctrl_get()/pinctrl_enable().
    
    Update documentation and mapping tables to use this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 73fbb2745301..20e97353d5f9 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -12,6 +12,8 @@
 #ifndef __LINUX_PINCTRL_MACHINE_H
 #define __LINUX_PINCTRL_MACHINE_H
 
+#include "pinctrl.h"
+
 /**
  * struct pinctrl_map - boards/machines shall provide this map for devices
  * @dev_name: the name of the device using this specific mapping, the name
@@ -49,17 +51,18 @@ struct pinctrl_map {
  * Convenience macro to map a system function onto a certain pinctrl device,
  * to be hogged by the pin control core until the system shuts down.
  */
-#define PIN_MAP_SYS_HOG(a, b, c) \
-	{ .name = a, .ctrl_dev_name = b, .dev_name = b, .function = c, }
+#define PIN_MAP_SYS_HOG(a, b) \
+	{ .name = PINCTRL_STATE_DEFAULT, .ctrl_dev_name = a, .dev_name = a, \
+	  .function = b, }
 
 /*
  * Convenience macro to map a system function onto a certain pinctrl device
  * using a specified group, to be hogged by the pin control core until the
  * system shuts down.
  */
-#define PIN_MAP_SYS_HOG_GROUP(a, b, c, d)		\
-	{ .name = a, .ctrl_dev_name = b, .dev_name = b, .function = c, \
-	  .group = d, }
+#define PIN_MAP_SYS_HOG_GROUP(a, b, c) \
+	{ .name = PINCTRL_STATE_DEFAULT, .ctrl_dev_name = a, .dev_name = a, \
+	  .function = b, .group = c, }
 
 #ifdef CONFIG_PINMUX
 

commit 806d314325812fb8ffe7059bd84a23d334350c21
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Feb 23 17:04:39 2012 -0700

    pinctrl: re-order struct pinctrl_map
    
    The lookup key in struct pinctrl_map is (.dev_name, .name). Re-order the
    struct definition to put the lookup key fields first, and the result
    values afterwards. To me at least, this slightly better reflects the
    lookup process.
    
    Update the documentation in a similar fashion.
    
    Note: PIN_MAP*() macros aren't updated; I plan to update this once later
    when enhancing the mapping table format to support pin config to reduce
    churn.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    [Rebased for cherry-picking]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 400f1926b234..73fbb2745301 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -14,6 +14,10 @@
 
 /**
  * struct pinctrl_map - boards/machines shall provide this map for devices
+ * @dev_name: the name of the device using this specific mapping, the name
+ *	must be the same as in your struct device*. If this name is set to the
+ *	same name as the pin controllers own dev_name(), the map entry will be
+ *	hogged by the driver itself upon registration
  * @name: the name of this specific map entry for the particular machine.
  *	This is the second parameter passed to pinmux_get() when you want
  *	to have several mappings to the same device
@@ -25,17 +29,13 @@
  * @group: sometimes a function can map to different pin groups, so this
  *	selects a certain specific pin group to activate for the function, if
  *	left as NULL, the first applicable group will be used
- * @dev_name: the name of the device using this specific mapping, the name
- *	must be the same as in your struct device*. If this name is set to the
- *	same name as the pin controllers own dev_name(), the map entry will be
- *	hogged by the driver itself upon registration
  */
 struct pinctrl_map {
+	const char *dev_name;
 	const char *name;
 	const char *ctrl_dev_name;
 	const char *function;
 	const char *group;
-	const char *dev_name;
 };
 
 /*

commit 1681f5ae4ca25bddb6f7b6d4f463cc83e3d1ad01
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Feb 22 14:25:58 2012 -0700

    pinctrl: disallow map table entries with NULL dev_name field
    
    Hog entries are mapping table entries with .ctrl_dev_name == .dev_name.
    All other mapping table entries need .dev_name set so that they will
    match some pinctrl_get() call. All extant PIN_MAP*() macros set
    .dev_name.
    
    So, there is no reason to allow mapping table entries without .dev_name
    set. Update the code and documentation to disallow this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index af145d571970..400f1926b234 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -45,13 +45,6 @@ struct pinctrl_map {
 #define PIN_MAP(a, b, c, d) \
 	{ .name = a, .ctrl_dev_name = b, .function = c, .dev_name = d }
 
-/*
- * Convenience macro to map a system function onto a certain pinctrl device.
- * System functions are not assigned to a particular device.
- */
-#define PIN_MAP_SYS(a, b, c) \
-	{ .name = a, .ctrl_dev_name = b, .function = c }
-
 /*
  * Convenience macro to map a system function onto a certain pinctrl device,
  * to be hogged by the pin control core until the system shuts down.

commit 77a5988355f993840928d195f790a939200a4ff0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 10 01:34:12 2012 +0100

    pinctrl: changes hog mechanism to be self-referential
    
    Instead of a specific boolean field to indicate if a map entry shall
    be hogged, treat self-reference as an indication of desired hogging.
    This drops one field off the map struct and has a nice Douglas R.
    Hofstadter-feel to it.
    
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index a2ab524a0106..af145d571970 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -26,13 +26,9 @@
  *	selects a certain specific pin group to activate for the function, if
  *	left as NULL, the first applicable group will be used
  * @dev_name: the name of the device using this specific mapping, the name
- *	must be the same as in your struct device*
- * @hog_on_boot: if this is set to true, the pin control subsystem will itself
- *	hog the mappings as the pinmux device drivers are attached, so this is
- *	typically used with system maps (mux mappings without an assigned
- *	device) that you want to get hogged and enabled by default as soon as
- *	a pinmux device supporting it is registered. These maps will not be
- *	disabled and put until the system shuts down.
+ *	must be the same as in your struct device*. If this name is set to the
+ *	same name as the pin controllers own dev_name(), the map entry will be
+ *	hogged by the driver itself upon registration
  */
 struct pinctrl_map {
 	const char *name;
@@ -40,7 +36,6 @@ struct pinctrl_map {
 	const char *function;
 	const char *group;
 	const char *dev_name;
-	bool hog_on_boot;
 };
 
 /*
@@ -62,8 +57,7 @@ struct pinctrl_map {
  * to be hogged by the pin control core until the system shuts down.
  */
 #define PIN_MAP_SYS_HOG(a, b, c) \
-	{ .name = a, .ctrl_dev_name = b, .function = c, \
-	  .hog_on_boot = true }
+	{ .name = a, .ctrl_dev_name = b, .dev_name = b, .function = c, }
 
 /*
  * Convenience macro to map a system function onto a certain pinctrl device
@@ -71,8 +65,8 @@ struct pinctrl_map {
  * system shuts down.
  */
 #define PIN_MAP_SYS_HOG_GROUP(a, b, c, d)		\
-	{ .name = a, .ctrl_dev_name = b, .function = c, .group = d, \
-	  .hog_on_boot = true }
+	{ .name = a, .ctrl_dev_name = b, .dev_name = b, .function = c, \
+	  .group = d, }
 
 #ifdef CONFIG_PINMUX
 

commit e93bcee00c43e2bd4037291262111016f4c05793
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 07:23:28 2012 +0100

    pinctrl: move generic functions to the pinctrl_ namespace
    
    Since we want to use the former pinmux handles and mapping tables for
    generic control involving both muxing and configuration we begin
    refactoring by renaming them from pinmux_* to pinctrl_*.
    
    ChangeLog v1->v2:
    - Also rename the PINMUX_* macros in machine.h to PIN_ as indicated
      in the documentation so as to reflect the generic nature of these
      mapping entries from now on.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index f8593fdc6466..a2ab524a0106 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -9,11 +9,11 @@
  *
  * License terms: GNU General Public License (GPL) version 2
  */
-#ifndef __LINUX_PINMUX_MACHINE_H
-#define __LINUX_PINMUX_MACHINE_H
+#ifndef __LINUX_PINCTRL_MACHINE_H
+#define __LINUX_PINCTRL_MACHINE_H
 
 /**
- * struct pinmux_map - boards/machines shall provide this map for devices
+ * struct pinctrl_map - boards/machines shall provide this map for devices
  * @name: the name of this specific map entry for the particular machine.
  *	This is the second parameter passed to pinmux_get() when you want
  *	to have several mappings to the same device
@@ -34,7 +34,7 @@
  *	a pinmux device supporting it is registered. These maps will not be
  *	disabled and put until the system shuts down.
  */
-struct pinmux_map {
+struct pinctrl_map {
 	const char *name;
 	const char *ctrl_dev_name;
 	const char *function;
@@ -47,41 +47,41 @@ struct pinmux_map {
  * Convenience macro to set a simple map from a certain pin controller and a
  * certain function to a named device
  */
-#define PINMUX_MAP(a, b, c, d) \
+#define PIN_MAP(a, b, c, d) \
 	{ .name = a, .ctrl_dev_name = b, .function = c, .dev_name = d }
 
 /*
  * Convenience macro to map a system function onto a certain pinctrl device.
  * System functions are not assigned to a particular device.
  */
-#define PINMUX_MAP_SYS(a, b, c) \
+#define PIN_MAP_SYS(a, b, c) \
 	{ .name = a, .ctrl_dev_name = b, .function = c }
 
 /*
  * Convenience macro to map a system function onto a certain pinctrl device,
- * to be hogged by the pinmux core until the system shuts down.
+ * to be hogged by the pin control core until the system shuts down.
  */
-#define PINMUX_MAP_SYS_HOG(a, b, c) \
+#define PIN_MAP_SYS_HOG(a, b, c) \
 	{ .name = a, .ctrl_dev_name = b, .function = c, \
 	  .hog_on_boot = true }
 
 /*
  * Convenience macro to map a system function onto a certain pinctrl device
- * using a specified group, to be hogged by the pinmux core until the system
- * shuts down.
+ * using a specified group, to be hogged by the pin control core until the
+ * system shuts down.
  */
-#define PINMUX_MAP_SYS_HOG_GROUP(a, b, c, d)		\
+#define PIN_MAP_SYS_HOG_GROUP(a, b, c, d)		\
 	{ .name = a, .ctrl_dev_name = b, .function = c, .group = d, \
 	  .hog_on_boot = true }
 
 #ifdef CONFIG_PINMUX
 
-extern int pinmux_register_mappings(struct pinmux_map const *map,
+extern int pinctrl_register_mappings(struct pinctrl_map const *map,
 				unsigned num_maps);
 
 #else
 
-static inline int pinmux_register_mappings(struct pinmux_map const *map,
+static inline int pinctrl_register_mappings(struct pinctrl_map const *map,
 					   unsigned num_maps)
 {
 	return 0;

commit 9dfac4fd7f8cdcdf734dff2ccc7ca467f53f1cfd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 1 18:02:47 2012 +0100

    pinctrl: delete raw device pointers in pinmux maps
    
    After discussion with Mark Brown in an unrelated thread about
    ADC lookups, it came to my knowledge that the ability to pass
    a struct device * in the regulator consumers is just a
    historical artifact, and not really recommended. Since there
    are no in-kernel users of these pointers, we just kill them
    right now, before someone starts to use them.
    
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index d0aecb7f6fb9..f8593fdc6466 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -17,22 +17,16 @@
  * @name: the name of this specific map entry for the particular machine.
  *	This is the second parameter passed to pinmux_get() when you want
  *	to have several mappings to the same device
- * @ctrl_dev: the pin control device to be used by this mapping, may be NULL
- *	if you provide .ctrl_dev_name instead (this is more common)
  * @ctrl_dev_name: the name of the device controlling this specific mapping,
- *	the name must be the same as in your struct device*, may be NULL if
- *	you provide .ctrl_dev instead
+ *	the name must be the same as in your struct device*
  * @function: a function in the driver to use for this mapping, the driver
  *	will lookup the function referenced by this ID on the specified
  *	pin control device
  * @group: sometimes a function can map to different pin groups, so this
  *	selects a certain specific pin group to activate for the function, if
  *	left as NULL, the first applicable group will be used
- * @dev: the device using this specific mapping, may be NULL if you provide
- *	.dev_name instead (this is more common)
  * @dev_name: the name of the device using this specific mapping, the name
- *	must be the same as in your struct device*, may be NULL if you
- *	provide .dev instead
+ *	must be the same as in your struct device*
  * @hog_on_boot: if this is set to true, the pin control subsystem will itself
  *	hog the mappings as the pinmux device drivers are attached, so this is
  *	typically used with system maps (mux mappings without an assigned
@@ -42,11 +36,9 @@
  */
 struct pinmux_map {
 	const char *name;
-	struct device *ctrl_dev;
 	const char *ctrl_dev_name;
 	const char *function;
 	const char *group;
-	struct device *dev;
 	const char *dev_name;
 	bool hog_on_boot;
 };

commit 23750196ef472e9249958d5165b0bb292518c710
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Dec 14 09:30:08 2011 +0100

    pinctrl: add a group-specific hog macro
    
    To create elegant tables for pinmux hogs on the PXA MMP platform,
    we need this hog macro that can specify both function and group in
    one go.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index ad430e05a7ba..d0aecb7f6fb9 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -73,6 +73,15 @@ struct pinmux_map {
 	{ .name = a, .ctrl_dev_name = b, .function = c, \
 	  .hog_on_boot = true }
 
+/*
+ * Convenience macro to map a system function onto a certain pinctrl device
+ * using a specified group, to be hogged by the pinmux core until the system
+ * shuts down.
+ */
+#define PINMUX_MAP_SYS_HOG_GROUP(a, b, c, d)		\
+	{ .name = a, .ctrl_dev_name = b, .function = c, .group = d, \
+	  .hog_on_boot = true }
+
 #ifdef CONFIG_PINMUX
 
 extern int pinmux_register_mappings(struct pinmux_map const *map,

commit 51cd24ee625c348654114032499914d0311e5832
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Dec 9 16:59:05 2011 -0700

    pinctrl: don't create a device for each pin controller
    
    Pin controllers should already be instantiated as a device, so there's
    no need for the pinctrl core to create a new struct device for each
    controller.
    
    This allows the controller's real name to be used in the mux mapping
    table, rather than e.g. "pinctrl.0", "pinctrl.1", etc.
    
    This necessitates removal of the PINMUX_MAP_PRIMARY*() macros, since
    their sole purpose was to hard-code the .ctrl_dev_name field to be
    "pinctrl.0".
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 0ca32eb63b67..ad430e05a7ba 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -73,31 +73,6 @@ struct pinmux_map {
 	{ .name = a, .ctrl_dev_name = b, .function = c, \
 	  .hog_on_boot = true }
 
-/*
- * Convenience macro to map a function onto the primary device pinctrl device
- * this is especially helpful on systems that have only one pin controller
- * or need to set up a lot of mappings on the primary controller.
- */
-#define PINMUX_MAP_PRIMARY(a, b, c) \
-	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b, \
-	  .dev_name = c }
-
-/*
- * Convenience macro to map a system function onto the primary pinctrl device.
- * System functions are not assigned to a particular device.
- */
-#define PINMUX_MAP_PRIMARY_SYS(a, b) \
-	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b }
-
-/*
- * Convenience macro to map a system function onto the primary pinctrl device,
- * to be hogged by the pinmux core until the system shuts down.
- */
-#define PINMUX_MAP_PRIMARY_SYS_HOG(a, b) \
-	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b, \
-	  .hog_on_boot = true }
-
-
 #ifdef CONFIG_PINMUX
 
 extern int pinmux_register_mappings(struct pinmux_map const *map,

commit 1ddb6ff03c0cdec58c6cfdbada95acddcce4a7b7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Dec 9 16:59:03 2011 -0700

    pinctrl: implement PINMUX_MAP_SYS_HOG
    
    This is the same as PINMUX_MAP_PRIMARY_SYS_HOG, except that it allows
    you to specify a particular control device.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index f5372319d999..0ca32eb63b67 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -65,6 +65,14 @@ struct pinmux_map {
 #define PINMUX_MAP_SYS(a, b, c) \
 	{ .name = a, .ctrl_dev_name = b, .function = c }
 
+/*
+ * Convenience macro to map a system function onto a certain pinctrl device,
+ * to be hogged by the pinmux core until the system shuts down.
+ */
+#define PINMUX_MAP_SYS_HOG(a, b, c) \
+	{ .name = a, .ctrl_dev_name = b, .function = c, \
+	  .hog_on_boot = true }
+
 /*
  * Convenience macro to map a function onto the primary device pinctrl device
  * this is especially helpful on systems that have only one pin controller

commit 97607d157c133ab18dfcd77fa836e37fa950a44a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 29 12:52:39 2011 +0100

    pinctrl: make a copy of pinmux map
    
    This makes a deep copy of the pinmux function map instead of
    keeping the copy supplied from the platform around. This makes
    it possible to tag the platforms map with __initdata as is also
    done as part of this patch.
    
    Rationale: a certain target platform (PXA) has numerous
    pinmux maps, many of which will be lying around unused after
    boot in a multi-platform binary. Instead, deep-copy the one
    we're going to use and tag them all __initdata so they go away
    after boot.
    
    ChangeLog v1->v2:
    - Fixup the deep copy, missed a few items on the struct,
      plus mark bool member non-const since we're making runtime
      copies if this stuff now.
    ChangeLog v2->v3:
    - Make a shallow copy (just copy the array of map structs)
      as Arnd noticed, string constants never get discarded by the
      kernel anyway, so these pointers may be safely copied over.
    
    Reviewed-by: Arnd Bergmann <arnd.bergmann@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
index 88863531d862..f5372319d999 100644
--- a/include/linux/pinctrl/machine.h
+++ b/include/linux/pinctrl/machine.h
@@ -48,7 +48,7 @@ struct pinmux_map {
 	const char *group;
 	struct device *dev;
 	const char *dev_name;
-	const bool hog_on_boot;
+	bool hog_on_boot;
 };
 
 /*

commit 2744e8afb3b76343e7eb8197e8b3e085036010a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon May 2 20:50:54 2011 +0200

    drivers: create a pin control subsystem
    
    This creates a subsystem for handling of pin control devices.
    These are devices that control different aspects of package
    pins.
    
    Currently it handles pinmuxing, i.e. assigning electronic
    functions to groups of pins on primarily PGA and BGA type of
    chip packages which are common in embedded systems.
    
    The plan is to also handle other I/O pin control aspects
    such as biasing, driving, input properties such as
    schmitt-triggering, load capacitance etc within this
    subsystem, to remove a lot of ARM arch code as well as
    feature-creepy GPIO drivers which are implementing the same
    thing over and over again.
    
    This is being done to depopulate the arch/arm/* directory
    of such custom drivers and try to abstract the infrastructure
    they all need. See the Documentation/pinctrl.txt file that is
    part of this patch for more details.
    
    ChangeLog v1->v2:
    
    - Various minor fixes from Joe's and Stephens review comments
    - Added a pinmux_config() that can invoke custom configuration
      with arbitrary data passed in or out to/from the pinmux driver
    
    ChangeLog v2->v3:
    
    - Renamed subsystem folder to "pinctrl" since we will likely
      want to keep other pin control such as biasing in this
      subsystem too, so let us keep to something generic even though
      we're mainly doing pinmux now.
    - As a consequence, register pins as an abstract entity separate
      from the pinmux. The muxing functions will claim pins out of the
      pin pool and make sure they do not collide. Pins can now be
      named by the pinctrl core.
    - Converted the pin lookup from a static array into a radix tree,
      I agreed with Grant Likely to try to avoid any static allocation
      (which is crap for device tree stuff) so I just rewrote this
      to be dynamic, just like irq number descriptors. The
      platform-wide definition of number of pins goes away - this is
      now just the sum total of the pins registered to the subsystem.
    - Make sure mappings with only a function name and no device
      works properly.
    
    ChangeLog v3->v4:
    
    - Define a number space per controller instead of globally,
      Stephen and Grant requested the same thing so now maps need to
      define target controller, and the radix tree of pin descriptors
      is a property on each pin controller device.
    - Add a compulsory pinctrl device entry to the pinctrl mapping
      table. This must match the pinctrl device, like "pinctrl.0"
    - Split the file core.c in two: core.c and pinmux.c where the
      latter carry all pinmux stuff, the core is for generic pin
      control, and use local headers to access functionality between
      files. It is now possible to implement a "blank" pin controller
      without pinmux capabilities. This split will make new additions
      like pindrive.c, pinbias.c etc possible for combined drivers
      and chunks of functionality which is a GoodThing(TM).
    - Rewrite the interaction with the GPIO subsystem - the pin
      controller descriptor now handles this by defining an offset
      into the GPIO numberspace for its handled pin range. This is
      used to look up the apropriate pin controller for a GPIO pin.
      Then that specific GPIO range is matched 1-1 for the target
      controller instance.
    - Fixed a number of review comments from Joe Perches.
    - Broke out a header file pinctrl.h for the core pin handling
      stuff that will be reused by other stuff than pinmux.
    - Fixed some erroneous EXPORT() stuff.
    - Remove mispatched U300 Kconfig and Makefile entries
    - Fixed a number of review comments from Stephen Warren, not all
      of them - still WIP. But I think the new mapping that will
      specify which function goes to which pin mux controller address
      50% of your concerns (else beat me up).
    
    ChangeLog v4->v5:
    
    - Defined a "position" for each function, so the pin controller now
      tracks a function in a certain position, and the pinmux maps define
      what position you want the function in. (Feedback from Stephen
      Warren and Sascha Hauer).
    - Since we now need to request a combined function+position from
      the machine mapping table that connect mux settings to drivers,
      it was extended with a position field and a name field. The
      name field is now used if you e.g. need to switch between two
      mux map settings at runtime.
    - Switched from a class device to using struct bus_type for this
      subsystem. Verified sysfs functionality: seems to work fine.
      (Feedback from Arnd Bergmann and Greg Kroah-Hartman)
    - Define a per pincontroller list of GPIO ranges from the GPIO
      pin space that can be handled by the pin controller. These can
      be added one by one at runtime. (Feedback from Barry Song)
    - Expanded documentation of regulator_[get|enable|disable|put]
      semantics.
    - Fixed a number of review comments from Barry Song. (Thanks!)
    
    ChangeLog v5->v6:
    
    - Create an abstract pin group concept that can sort pins into
      named and enumerated groups no matter what the use of these
      groups may be, one possible usecase is a group of pins being
      muxed in or so. The intention is however to also use these
      groups for other pin control activities.
    - Make it compulsory for pinmux functions to associate with
      at least one group, so the abstract pin group concept is used
      to define the groups of pins affected by a pinmux function.
      The pinmux driver interface has been altered so as to enforce
      a function to list applicable groups per function.
    - Provide an optional .group entry in the pinmux machine map
      so the map can select beteween different available groups
      to be used with a certain function.
    - Consequent changes all over the place so that e.g. debugfs
      present reasonable information about the world.
    - Drop the per-pin mux (*config) function in the pinmux_ops
      struct - I was afraid that this would start to be used for
      things totally unrelated to muxing, we can introduce that to
      the generic struct pinctrl_ops if needed. I want to keep
      muxing orthogonal to other pin control subjects and not mix
      these things up.
    
    ChangeLog v6->v7:
    
    - Make it possible to have several map entries matching the
      same device, pin controller and function, but using
      a different group, and alter the semantics so that
      pinmux_get() will pick all matching map entries, and
      store the associated groups in a list. The list will
      then be iterated over at pinmux_enable()/pinmux_disable()
      and corresponding driver functions called for each
      defined group. Notice that you're only allowed to map
      multiple *groups* to the same
      { device, pin controller, function } triplet, attempts
      to map the same device to multiple pin controllers will
      for example fail. This is hopefully the crucial feature
      requested by Stephen Warren.
    - Add a pinmux hogging field to the pinmux mapping entries,
      and enable the pinmux core to hog pinmux map entries.
      This currently only works for pinmuxes without assigned
      devices as it looks now, but with device trees we can
      look up the corresponding struct device * entries when
      we register the pinmux driver, and have it hog each
      pinmux map in turn, for a simple approach to
      non-dynamic pin muxing. This addresses an issue from
      Grant Likely that the machine should take care of as
      much of the pinmux setup as possible, not the devices.
      By supplying a list of hogs, it can now instruct the
      core to take care of any static mappings.
    - Switch pinmux group retrieveal function to grab an
      array of strings representing the groups rather than an
      array of unsigned and rewrite accordingly.
    - Alter debugfs to show the grouplist handled by each
      pinmux. Also add a list of hogs.
    - Dynamically allocate a struct pinmux at pinmux_get() and
      free it at pinmux_put(), then add these to the global
      list of pinmuxes active as we go along.
    - Go over the list of pinmux maps at pinmux_get() time
      and repeatedly apply matches.
    - Retrieve applicable groups per function from the driver
      as a string array rather than a unsigned array, then
      lookup the enumerators.
    - Make the device to pinmux map a singleton - only allow the
      mapping table to be registered once and even tag the
      registration function with __init so it surely won't be
      abused.
    - Create a separate debugfs file to view the pinmux map at
      runtime.
    - Introduce a spin lock to the pin descriptor struct, lock it
      when modifying pin status entries. Reported by Stijn Devriendt.
    - Fix up the documentation after review from Stephen Warren.
    - Let the GPIO ranges give names as const char * instead of some
      fixed-length string.
    - add a function to unregister GPIO ranges to mirror the
      registration function.
    - Privatized the struct pinctrl_device and removed it from the
      <linux/pinctrl/pinctrl.h> API, the drivers do not need to know
      the members of this struct. It is now in the local header
      "core.h".
    - Rename the concept of "anonymous" mux maps to "system" muxes
      and add convenience macros and documentation.
    
    ChangeLog v7->v8:
    
    - Delete the leftover pinmux_config() function from the
     <linux/pinctrl/pinmux.h> header.
    - Fix a race condition found by Stijn Devriendt in pin_request()
    
    ChangeLog v8->v9:
    
    - Drop the bus_type and the sysfs attributes and all, we're not on
      the clear about how this should be used for e.g. userspace
      interfaces so let us save this for the future.
    - Use the right name in MAINTAINERS, PIN CONTROL rather than
      PINMUX
    - Don't kfree() the device state holder, let the .remove() callback
      handle this.
    - Fix up numerous kerneldoc headers to have one line for the function
      description and more verbose documentation below the parameters
    
    ChangeLog v9->v10:
    - pinctrl: EXPORT_SYMBOL needs export.h, folded in a patch
      from Steven Rothwell
    - fix pinctrl_register error handling, folded in a patch from
      Axel Lin
    - Various fixes to documentation text so that it's consistent.
    - Removed pointless comment from drivers/Kconfig
    - Removed dependency on SYSFS since we removed the bus in
      v9.
    - Renamed hopelessly abbreviated pctldev_* functions to the
      more verbose pinctrl_dev_*
    - Drop mutex properly when looking up GPIO ranges
    - Return NULL instead of ERR_PTR() errors on registration of
      pin controllers, using cast pointers is fragile. We can
      live without the detailed error codes for sure.
    
    Cc: Stijn Devriendt <highguy@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/machine.h b/include/linux/pinctrl/machine.h
new file mode 100644
index 000000000000..88863531d862
--- /dev/null
+++ b/include/linux/pinctrl/machine.h
@@ -0,0 +1,107 @@
+/*
+ * Machine interface for the pinctrl subsystem.
+ *
+ * Copyright (C) 2011 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * Based on bits of regulator core, gpio core and clk core
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#ifndef __LINUX_PINMUX_MACHINE_H
+#define __LINUX_PINMUX_MACHINE_H
+
+/**
+ * struct pinmux_map - boards/machines shall provide this map for devices
+ * @name: the name of this specific map entry for the particular machine.
+ *	This is the second parameter passed to pinmux_get() when you want
+ *	to have several mappings to the same device
+ * @ctrl_dev: the pin control device to be used by this mapping, may be NULL
+ *	if you provide .ctrl_dev_name instead (this is more common)
+ * @ctrl_dev_name: the name of the device controlling this specific mapping,
+ *	the name must be the same as in your struct device*, may be NULL if
+ *	you provide .ctrl_dev instead
+ * @function: a function in the driver to use for this mapping, the driver
+ *	will lookup the function referenced by this ID on the specified
+ *	pin control device
+ * @group: sometimes a function can map to different pin groups, so this
+ *	selects a certain specific pin group to activate for the function, if
+ *	left as NULL, the first applicable group will be used
+ * @dev: the device using this specific mapping, may be NULL if you provide
+ *	.dev_name instead (this is more common)
+ * @dev_name: the name of the device using this specific mapping, the name
+ *	must be the same as in your struct device*, may be NULL if you
+ *	provide .dev instead
+ * @hog_on_boot: if this is set to true, the pin control subsystem will itself
+ *	hog the mappings as the pinmux device drivers are attached, so this is
+ *	typically used with system maps (mux mappings without an assigned
+ *	device) that you want to get hogged and enabled by default as soon as
+ *	a pinmux device supporting it is registered. These maps will not be
+ *	disabled and put until the system shuts down.
+ */
+struct pinmux_map {
+	const char *name;
+	struct device *ctrl_dev;
+	const char *ctrl_dev_name;
+	const char *function;
+	const char *group;
+	struct device *dev;
+	const char *dev_name;
+	const bool hog_on_boot;
+};
+
+/*
+ * Convenience macro to set a simple map from a certain pin controller and a
+ * certain function to a named device
+ */
+#define PINMUX_MAP(a, b, c, d) \
+	{ .name = a, .ctrl_dev_name = b, .function = c, .dev_name = d }
+
+/*
+ * Convenience macro to map a system function onto a certain pinctrl device.
+ * System functions are not assigned to a particular device.
+ */
+#define PINMUX_MAP_SYS(a, b, c) \
+	{ .name = a, .ctrl_dev_name = b, .function = c }
+
+/*
+ * Convenience macro to map a function onto the primary device pinctrl device
+ * this is especially helpful on systems that have only one pin controller
+ * or need to set up a lot of mappings on the primary controller.
+ */
+#define PINMUX_MAP_PRIMARY(a, b, c) \
+	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b, \
+	  .dev_name = c }
+
+/*
+ * Convenience macro to map a system function onto the primary pinctrl device.
+ * System functions are not assigned to a particular device.
+ */
+#define PINMUX_MAP_PRIMARY_SYS(a, b) \
+	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b }
+
+/*
+ * Convenience macro to map a system function onto the primary pinctrl device,
+ * to be hogged by the pinmux core until the system shuts down.
+ */
+#define PINMUX_MAP_PRIMARY_SYS_HOG(a, b) \
+	{ .name = a, .ctrl_dev_name = "pinctrl.0", .function = b, \
+	  .hog_on_boot = true }
+
+
+#ifdef CONFIG_PINMUX
+
+extern int pinmux_register_mappings(struct pinmux_map const *map,
+				unsigned num_maps);
+
+#else
+
+static inline int pinmux_register_mappings(struct pinmux_map const *map,
+					   unsigned num_maps)
+{
+	return 0;
+}
+
+#endif /* !CONFIG_PINMUX */
+#endif
