commit 55d54d1ee84e5980446b390154526d62bee24ca2
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Dec 6 18:08:13 2019 +0100

    pinctrl: core: Add pinctrl_select_default_state() and export it
    
    It has turned out that some mmc host drivers, but perhaps also others
    drivers, needs to reset the pinctrl into the default state
    (PINCTRL_STATE_DEFAULT). However, they can't use the existing
    pinctrl_pm_select_default_state(), as that requires CONFIG_PM to be set.
    This leads to open coding, as they need to look up the default state
    themselves and then select it.
    
    To avoid the open coding, let's introduce pinctrl_select_default_state()
    and make it available independently of CONFIG_PM. As a matter of fact, this
    makes it more consistent with the behaviour of the driver core, as it
    already tries to looks up the default state during probe.
    
    Going forward, users of pinctrl_pm_select_default_state() are encouraged to
    move to pinctrl_select_default_state(), so the old API can be removed.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Link: https://lore.kernel.org/r/20191206170821.29711-2-ulf.hansson@linaro.org
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 7f8c7d9583d3..019fecd75d0c 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -40,6 +40,7 @@ extern int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);
 
 extern struct pinctrl * __must_check devm_pinctrl_get(struct device *dev);
 extern void devm_pinctrl_put(struct pinctrl *p);
+extern int pinctrl_select_default_state(struct device *dev);
 
 #ifdef CONFIG_PM
 extern int pinctrl_pm_select_default_state(struct device *dev);
@@ -122,6 +123,11 @@ static inline void devm_pinctrl_put(struct pinctrl *p)
 {
 }
 
+static inline int pinctrl_select_default_state(struct device *dev)
+{
+	return 0;
+}
+
 static inline int pinctrl_pm_select_default_state(struct device *dev)
 {
 	return 0;

commit 472a61e777fe78cdcb6cb6f25efee0ae9f629aca
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Wed Aug 14 14:00:35 2019 +0300

    pinctrl/gpio: Take MUX usage into account
    
    The user space like gpioinfo only see the GPIO usage but not the
    MUX usage (e.g. I2C or SPI usage) of a pin. As a user we want
    to know which pin is free/safe to use. So take the MUX usage of
    strict pinmux controllers into account to get a more realistic
    view for ioctl GPIO_GET_LINEINFO_IOCTL.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Tested-by: Ramon Fried <rfried.dev@gmail.com>
    Signed-off-by: Ramon Fried <rfried.dev@gmail.com>
    Link: https://lore.kernel.org/r/20190814110035.13451-1-ramon.fried@linux.intel.com
    Acked-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 86720a5a384f..7f8c7d9583d3 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -24,6 +24,7 @@ struct device;
 #ifdef CONFIG_PINCTRL
 
 /* External interface to pin control */
+extern bool pinctrl_gpio_can_use_line(unsigned gpio);
 extern int pinctrl_gpio_request(unsigned gpio);
 extern void pinctrl_gpio_free(unsigned gpio);
 extern int pinctrl_gpio_direction_input(unsigned gpio);
@@ -61,6 +62,11 @@ static inline int pinctrl_pm_select_idle_state(struct device *dev)
 
 #else /* !CONFIG_PINCTRL */
 
+static inline bool pinctrl_gpio_can_use_line(unsigned gpio)
+{
+	return true;
+}
+
 static inline int pinctrl_gpio_request(unsigned gpio)
 {
 	return 0;

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 0412cc9833e9..86720a5a384f 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Consumer interface the pin control subsystem
  *
@@ -6,8 +7,6 @@
  * Based on bits of regulator core, gpio core and clk core
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 #ifndef __LINUX_PINCTRL_CONSUMER_H
 #define __LINUX_PINCTRL_CONSUMER_H

commit a9a1d2a7827c9cf780966d0879c73ef5a91380e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 22 11:02:10 2017 +0200

    pinctrl/gpio: Unify namespace for cross-calls
    
    The pinctrl_request_gpio() and pinctrl_free_gpio() break the nice
    namespacing in the other cross-calls like pinctrl_gpio_foo().
    Just rename them and all references so we have one namespace
    with all cross-calls under pinctrl_gpio_*().
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index a0f2aba72fa9..0412cc9833e9 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -25,8 +25,8 @@ struct device;
 #ifdef CONFIG_PINCTRL
 
 /* External interface to pin control */
-extern int pinctrl_request_gpio(unsigned gpio);
-extern void pinctrl_free_gpio(unsigned gpio);
+extern int pinctrl_gpio_request(unsigned gpio);
+extern void pinctrl_gpio_free(unsigned gpio);
 extern int pinctrl_gpio_direction_input(unsigned gpio);
 extern int pinctrl_gpio_direction_output(unsigned gpio);
 extern int pinctrl_gpio_set_config(unsigned gpio, unsigned long config);
@@ -62,12 +62,12 @@ static inline int pinctrl_pm_select_idle_state(struct device *dev)
 
 #else /* !CONFIG_PINCTRL */
 
-static inline int pinctrl_request_gpio(unsigned gpio)
+static inline int pinctrl_gpio_request(unsigned gpio)
 {
 	return 0;
 }
 
-static inline void pinctrl_free_gpio(unsigned gpio)
+static inline void pinctrl_gpio_free(unsigned gpio)
 {
 }
 

commit 15381bc7c7f52d56f87c56dd7c948ad78704b852
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jan 23 15:34:33 2017 +0300

    pinctrl: Allow configuration of pins from gpiolib based drivers
    
    When a GPIO driver is backed by a pinctrl driver the GPIO driver
    sometimes needs to call the pinctrl driver to configure certain things,
    like whether the pin is used as input or output. In addition to this
    there are other configurations applicable to GPIOs such as setting
    debounce time of the GPIO.
    
    To support this we introduce a new function pinctrl_gpio_set_config()
    that can be used by gpiolib based driver to pass configuration requests
    to the backing pinctrl driver.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index d7e5d608faa7..a0f2aba72fa9 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -29,6 +29,7 @@ extern int pinctrl_request_gpio(unsigned gpio);
 extern void pinctrl_free_gpio(unsigned gpio);
 extern int pinctrl_gpio_direction_input(unsigned gpio);
 extern int pinctrl_gpio_direction_output(unsigned gpio);
+extern int pinctrl_gpio_set_config(unsigned gpio, unsigned long config);
 
 extern struct pinctrl * __must_check pinctrl_get(struct device *dev);
 extern void pinctrl_put(struct pinctrl *p);
@@ -80,6 +81,11 @@ static inline int pinctrl_gpio_direction_output(unsigned gpio)
 	return 0;
 }
 
+static inline int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
+{
+	return 0;
+}
+
 static inline struct pinctrl * __must_check pinctrl_get(struct device *dev)
 {
 	return NULL;

commit 66eb3bd857f5311f72c7c371f78ddc9c472befba
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Apr 27 18:04:05 2015 +0200

    pinctrl: use ERR_CAST instead of ERR_PTR/PTR_ERR
    
    Inspired by scripts/coccinelle/api/err_cast.cocci
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 18eccefea06e..d7e5d608faa7 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -142,7 +142,7 @@ static inline struct pinctrl * __must_check pinctrl_get_select(
 	s = pinctrl_lookup_state(p, name);
 	if (IS_ERR(s)) {
 		pinctrl_put(p);
-		return ERR_PTR(PTR_ERR(s));
+		return ERR_CAST(s);
 	}
 
 	ret = pinctrl_select_state(p, s);

commit 40eeb111d7c88bfbc38e1dfe330bc4cec05e0806
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 5 10:08:14 2015 +0100

    Revert "pinctrl: consumer: use correct retval for placeholder functions"
    
    This reverts commit 5a7d2efdd93f6c4bb6cd3d5df3d2f5611c9b87ac.
    
    As per discussion on the mailing list, this is not the right
    thing to do. NULL cookies are valid in the stubs.
    
    Reported-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 72c0415d6c21..18eccefea06e 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -82,7 +82,7 @@ static inline int pinctrl_gpio_direction_output(unsigned gpio)
 
 static inline struct pinctrl * __must_check pinctrl_get(struct device *dev)
 {
-	return ERR_PTR(-ENOSYS);
+	return NULL;
 }
 
 static inline void pinctrl_put(struct pinctrl *p)
@@ -93,7 +93,7 @@ static inline struct pinctrl_state * __must_check pinctrl_lookup_state(
 							struct pinctrl *p,
 							const char *name)
 {
-	return ERR_PTR(-ENOSYS);
+	return NULL;
 }
 
 static inline int pinctrl_select_state(struct pinctrl *p,
@@ -104,7 +104,7 @@ static inline int pinctrl_select_state(struct pinctrl *p,
 
 static inline struct pinctrl * __must_check devm_pinctrl_get(struct device *dev)
 {
-	return ERR_PTR(-ENOSYS);
+	return NULL;
 }
 
 static inline void devm_pinctrl_put(struct pinctrl *p)

commit 5a7d2efdd93f6c4bb6cd3d5df3d2f5611c9b87ac
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Dec 16 10:59:17 2014 +0100

    pinctrl: consumer: use correct retval for placeholder functions
    
    These functions are supposed to return an error pointer, not NULL.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 18eccefea06e..72c0415d6c21 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -82,7 +82,7 @@ static inline int pinctrl_gpio_direction_output(unsigned gpio)
 
 static inline struct pinctrl * __must_check pinctrl_get(struct device *dev)
 {
-	return NULL;
+	return ERR_PTR(-ENOSYS);
 }
 
 static inline void pinctrl_put(struct pinctrl *p)
@@ -93,7 +93,7 @@ static inline struct pinctrl_state * __must_check pinctrl_lookup_state(
 							struct pinctrl *p,
 							const char *name)
 {
-	return NULL;
+	return ERR_PTR(-ENOSYS);
 }
 
 static inline int pinctrl_select_state(struct pinctrl *p,
@@ -104,7 +104,7 @@ static inline int pinctrl_select_state(struct pinctrl *p,
 
 static inline struct pinctrl * __must_check devm_pinctrl_get(struct device *dev)
 {
-	return NULL;
+	return ERR_PTR(-ENOSYS);
 }
 
 static inline void devm_pinctrl_put(struct pinctrl *p)

commit ad42fc6c84795d19972e7f7dee70fe74bec4c2d8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jun 24 15:06:19 2013 +0200

    pinctrl: rip out the direct pinconf API
    
    From the inception ot the pin config API there has been the
    possibility to get a handle at a pin directly and configure
    its electrical characteristics. For this reason we had:
    
    int pin_config_get(const char *dev_name, const char *name,
                   unsigned long *config);
    int pin_config_set(const char *dev_name, const char *name,
                   unsigned long config);
    int pin_config_group_get(const char *dev_name,
                   const char *pin_group,
                   unsigned long *config);
    int pin_config_group_set(const char *dev_name,
                   const char *pin_group,
                   unsigned long config);
    
    After the introduction of the pin control states that will
    control pins associated with devices, and its subsequent
    introduction to the device core, as well as the
    introduction of pin control hogs that can set up states on
    boot and optionally also at sleep, this direct pin control
    API is a thing of the past.
    
    As could be expected, it has zero in-kernel users.
    Let's delete this API and make our world simpler.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index d071d850d1de..18eccefea06e 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -192,47 +192,4 @@ static inline struct pinctrl * __must_check devm_pinctrl_get_select_default(
 	return devm_pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);
 }
 
-#ifdef CONFIG_PINCONF
-
-extern int pin_config_get(const char *dev_name, const char *name,
-			  unsigned long *config);
-extern int pin_config_set(const char *dev_name, const char *name,
-			  unsigned long config);
-extern int pin_config_group_get(const char *dev_name,
-				const char *pin_group,
-				unsigned long *config);
-extern int pin_config_group_set(const char *dev_name,
-				const char *pin_group,
-				unsigned long config);
-
-#else
-
-static inline int pin_config_get(const char *dev_name, const char *name,
-				 unsigned long *config)
-{
-	return 0;
-}
-
-static inline int pin_config_set(const char *dev_name, const char *name,
-				 unsigned long config)
-{
-	return 0;
-}
-
-static inline int pin_config_group_get(const char *dev_name,
-				       const char *pin_group,
-				       unsigned long *config)
-{
-	return 0;
-}
-
-static inline int pin_config_group_set(const char *dev_name,
-				       const char *pin_group,
-				       unsigned long config)
-{
-	return 0;
-}
-
-#endif
-
 #endif /* __LINUX_PINCTRL_CONSUMER_H */

commit ff73ceed0b5a046468de20d3b014a8c59051f90a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jun 13 22:27:59 2013 +0200

    pinctrl: move the pm state stubs
    
    The stubs for the !PINCTRL case were placed in the wrong
    part of the file, causing breakage in linux-next when compiling
    SH without pinctrl. Fix it up by moving the stubs to the right
    place.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 0f32f10e347d..d071d850d1de 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -111,6 +111,21 @@ static inline void devm_pinctrl_put(struct pinctrl *p)
 {
 }
 
+static inline int pinctrl_pm_select_default_state(struct device *dev)
+{
+	return 0;
+}
+
+static inline int pinctrl_pm_select_sleep_state(struct device *dev)
+{
+	return 0;
+}
+
+static inline int pinctrl_pm_select_idle_state(struct device *dev)
+{
+	return 0;
+}
+
 #endif /* CONFIG_PINCTRL */
 
 static inline struct pinctrl * __must_check pinctrl_get_select(
@@ -218,21 +233,6 @@ static inline int pin_config_group_set(const char *dev_name,
 	return 0;
 }
 
-static inline int pinctrl_pm_select_default_state(struct device *dev)
-{
-	return 0;
-}
-
-static inline int pinctrl_pm_select_sleep_state(struct device *dev)
-{
-	return 0;
-}
-
-static inline int pinctrl_pm_select_idle_state(struct device *dev)
-{
-	return 0;
-}
-
 #endif
 
 #endif /* __LINUX_PINCTRL_CONSUMER_H */

commit 14005ee270cad7078adbce6b7f3687b992a8334e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jun 5 15:30:33 2013 +0200

    drivers: pinctrl sleep and idle states in the core
    
    If a device have sleep and idle states in addition to the
    default state, look up these in the core and stash them in
    the pinctrl state container.
    
    Add accessor functions for pinctrl consumers to put the pins
    into "default", "sleep" and "idle" states passing nothing but
    the struct device * affected.
    
    Solution suggested by Kevin Hilman, Mark Brown and Dmitry
    Torokhov in response to a patch series from Hebbar
    Gururaja.
    
    Cc: Hebbar Gururaja <gururaja.hebbar@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 4aad3cea69ae..0f32f10e347d 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -40,6 +40,25 @@ extern int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);
 extern struct pinctrl * __must_check devm_pinctrl_get(struct device *dev);
 extern void devm_pinctrl_put(struct pinctrl *p);
 
+#ifdef CONFIG_PM
+extern int pinctrl_pm_select_default_state(struct device *dev);
+extern int pinctrl_pm_select_sleep_state(struct device *dev);
+extern int pinctrl_pm_select_idle_state(struct device *dev);
+#else
+static inline int pinctrl_pm_select_default_state(struct device *dev)
+{
+	return 0;
+}
+static inline int pinctrl_pm_select_sleep_state(struct device *dev)
+{
+	return 0;
+}
+static inline int pinctrl_pm_select_idle_state(struct device *dev)
+{
+	return 0;
+}
+#endif
+
 #else /* !CONFIG_PINCTRL */
 
 static inline int pinctrl_request_gpio(unsigned gpio)
@@ -199,6 +218,21 @@ static inline int pin_config_group_set(const char *dev_name,
 	return 0;
 }
 
+static inline int pinctrl_pm_select_default_state(struct device *dev)
+{
+	return 0;
+}
+
+static inline int pinctrl_pm_select_sleep_state(struct device *dev)
+{
+	return 0;
+}
+
+static inline int pinctrl_pm_select_idle_state(struct device *dev)
+{
+	return 0;
+}
+
 #endif
 
 #endif /* __LINUX_PINCTRL_CONSUMER_H */

commit 9b2e077c42a97fcbdc0dd71edb1fc9d15c74ad29
Merge: a54dfb1a845c 10b63956fce7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 3 13:45:43 2012 -0700

    Merge tag 'uapi-prep-20121002' of git://git.infradead.org/users/dhowells/linux-headers
    
    Pull preparatory patches for user API disintegration from David Howells:
     "The patches herein prepare for the extraction of the Userspace API
      bits from the various header files named in the Kbuild files.
    
      New subdirectories are created under either include/uapi/ or
      arch/x/include/uapi/ that correspond to the subdirectory containing
      that file under include/ or arch/x/include/.
    
      The new subdirs under the uapi/ directory are populated with Kbuild
      files that mostly do nothing at this time.  Further patches will
      disintegrate the headers in each original directory and fill in the
      Kbuild files as they do it.
    
      These patches also:
    
       (1) fix up #inclusions of "foo.h" rather than <foo.h>.
    
       (2) Remove some redundant #includes from the DRM code.
    
       (3) Make the kernel build infrastructure handle Kbuild files both in
           the old places and the new UAPI place that both specify headers
           to be exported.
    
       (4) Fix some kernel tools that #include kernel headers during their
           build.
    
      I have compile tested this with allyesconfig against x86_64,
      allmodconfig against i386 and a scattering of additional defconfigs of
      other arches.  Prepared for main script
    
      Signed-off-by: David Howells <dhowells@redhat.com>
      Acked-by: Arnd Bergmann <arnd@arndb.de>
      Acked-by: Thomas Gleixner <tglx@linutronix.de>
      Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
      Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
      Acked-by: Dave Jones <davej@redhat.com>
      Acked-by: H. Peter Anvin <hpa@zytor.com>"
    
    * tag 'uapi-prep-20121002' of git://git.infradead.org/users/dhowells/linux-headers:
      UAPI: Plumb the UAPI Kbuilds into the user header installation and checking
      UAPI: x86: Differentiate the generated UAPI and internal headers
      UAPI: Remove the objhdr-y export list
      UAPI: Move linux/version.h
      UAPI: Set up uapi/asm/Kbuild.asm
      UAPI: x86: Fix insn_sanity build failure after UAPI split
      UAPI: x86: Fix the test_get_len tool
      UAPI: (Scripted) Set up UAPI Kbuild files
      UAPI: Partition the header include path sets and add uapi/ header directories
      UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
      UAPI: (Scripted) Convert #include "..." to #include <path/...> in drivers/gpu/
      UAPI: (Scripted) Remove redundant DRM UAPI header #inclusions from drivers/gpu/.
      UAPI: Refer to the DRM UAPI headers with <...> and from certain headers only

commit a1ce39288e6fbefdd8d607021d02384eb4a20b99
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:25 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
    
    Convert #include "..." to #include <path/...> in kernel system headers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index e9b7f4350844..cbb07f850791 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -15,7 +15,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
-#include "pinctrl-state.h"
+#include <linux/pinctrl/pinctrl-state.h>
 
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;

commit e60bc2df9ba5574af87a8d0fa249ceac9fa1d3bd
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Jul 30 18:38:33 2012 +0200

    pinctrl: use ERR_CAST instead of ERR_PTR(PTR_ERR(...))
    
    This doesn't change semantics, just looks nicer.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index e9b7f4350844..d2816454c263 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -140,7 +140,7 @@ static inline struct pinctrl * __must_check devm_pinctrl_get_select(
 	s = pinctrl_lookup_state(p, name);
 	if (IS_ERR(s)) {
 		devm_pinctrl_put(p);
-		return ERR_PTR(PTR_ERR(s));
+		return ERR_CAST(s);
 	}
 
 	ret = pinctrl_select_state(p, s);

commit ac5aa7f9e0891a115ab307b4bdde9c55b9232970
Author: Richard Genoud <richard.genoud@gmail.com>
Date:   Fri Aug 10 16:52:58 2012 +0200

    pinctrl: header: trivial: declare struct device
    
    As struct device is used as a function argument, it should at
    least be declared (device.h is not included).
    
    Signed-off-by: Richard Genoud <richard.genoud@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 6dd96fb45482..e9b7f4350844 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -20,6 +20,7 @@
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;
 struct pinctrl_state;
+struct device;
 
 #ifdef CONFIG_PINCTRL
 

commit 6d4ca1fb467932773da7b808c52f3d7ef4461ba0
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Apr 16 10:51:00 2012 -0600

    pinctrl: implement devm_pinctrl_get()/put()
    
    These functions allow the driver core to automatically clean up any
    allocations made by drivers, thus leading to simplified drivers.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 191e72688481..6dd96fb45482 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -36,6 +36,9 @@ extern struct pinctrl_state * __must_check pinctrl_lookup_state(
 							const char *name);
 extern int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);
 
+extern struct pinctrl * __must_check devm_pinctrl_get(struct device *dev);
+extern void devm_pinctrl_put(struct pinctrl *p);
+
 #else /* !CONFIG_PINCTRL */
 
 static inline int pinctrl_request_gpio(unsigned gpio)
@@ -79,6 +82,15 @@ static inline int pinctrl_select_state(struct pinctrl *p,
 	return 0;
 }
 
+static inline struct pinctrl * __must_check devm_pinctrl_get(struct device *dev)
+{
+	return NULL;
+}
+
+static inline void devm_pinctrl_put(struct pinctrl *p)
+{
+}
+
 #endif /* CONFIG_PINCTRL */
 
 static inline struct pinctrl * __must_check pinctrl_get_select(
@@ -113,6 +125,38 @@ static inline struct pinctrl * __must_check pinctrl_get_select_default(
 	return pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);
 }
 
+static inline struct pinctrl * __must_check devm_pinctrl_get_select(
+					struct device *dev, const char *name)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *s;
+	int ret;
+
+	p = devm_pinctrl_get(dev);
+	if (IS_ERR(p))
+		return p;
+
+	s = pinctrl_lookup_state(p, name);
+	if (IS_ERR(s)) {
+		devm_pinctrl_put(p);
+		return ERR_PTR(PTR_ERR(s));
+	}
+
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		devm_pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+
+	return p;
+}
+
+static inline struct pinctrl * __must_check devm_pinctrl_get_select_default(
+					struct device *dev)
+{
+	return devm_pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);
+}
+
 #ifdef CONFIG_PINCONF
 
 extern int pin_config_get(const char *dev_name, const char *name,

commit 9a01be1715b6a027765701ca09ba0401ff066fc5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 6 21:15:51 2012 +0100

    pinctrl: split pincontrol states into its own header
    
    Move the pin control state defines into its own header file,
    since it is used both by machine.h which is facing the platform
    and by consumer.h which is facing the drivers, and pinctrl.h
    which is pinctrl-driver internal, let's not have each and every
    .h file include all others, then isolation is moot.
    
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 9ad5896cfa0e..191e72688481 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -15,7 +15,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
-#include "pinctrl.h"
+#include "pinctrl-state.h"
 
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;

commit 6e5e959dde0d92d177f035652aeaa77f9330c9c6
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Mar 2 13:05:47 2012 -0700

    pinctrl: API changes to support multiple states per device
    
    The API model is changed from:
    
    p = pinctrl_get(dev, "state1");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    p = pinctrl_get(dev, "state2");
    pinctrl_enable(p);
    ...
    pinctrl_disable(p);
    pinctrl_put(p);
    
    to this:
    
    p = pinctrl_get(dev);
    s1 = pinctrl_lookup_state(p, "state1");
    s2 = pinctrl_lookup_state(p, "state2");
    pinctrl_select_state(p, s1);
    ...
    pinctrl_select_state(p, s2);
    ...
    pinctrl_put(p);
    
    This allows devices to directly transition between states without
    disabling the pin controller programming and put()/get()ing the
    configuration data each time. This model will also better suit pinconf
    programming, which doesn't have a concept of "disable".
    
    The special-case hogging feature of pin controllers is re-written to use
    the regular APIs instead of special-case code. Hence, the pinmux-hogs
    debugfs file is removed; see the top-level pinctrl-handles files for
    equivalent data.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 30865947f2d9..9ad5896cfa0e 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -12,12 +12,14 @@
 #ifndef __LINUX_PINCTRL_CONSUMER_H
 #define __LINUX_PINCTRL_CONSUMER_H
 
+#include <linux/err.h>
 #include <linux/list.h>
 #include <linux/seq_file.h>
 #include "pinctrl.h"
 
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;
+struct pinctrl_state;
 
 #ifdef CONFIG_PINCTRL
 
@@ -26,10 +28,13 @@ extern int pinctrl_request_gpio(unsigned gpio);
 extern void pinctrl_free_gpio(unsigned gpio);
 extern int pinctrl_gpio_direction_input(unsigned gpio);
 extern int pinctrl_gpio_direction_output(unsigned gpio);
-extern struct pinctrl * __must_check pinctrl_get(struct device *dev, const char *name);
+
+extern struct pinctrl * __must_check pinctrl_get(struct device *dev);
 extern void pinctrl_put(struct pinctrl *p);
-extern int pinctrl_enable(struct pinctrl *p);
-extern void pinctrl_disable(struct pinctrl *p);
+extern struct pinctrl_state * __must_check pinctrl_lookup_state(
+							struct pinctrl *p,
+							const char *name);
+extern int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);
 
 #else /* !CONFIG_PINCTRL */
 
@@ -52,7 +57,7 @@ static inline int pinctrl_gpio_direction_output(unsigned gpio)
 	return 0;
 }
 
-static inline struct pinctrl * __must_check pinctrl_get(struct device *dev, const char *name)
+static inline struct pinctrl * __must_check pinctrl_get(struct device *dev)
 {
 	return NULL;
 }
@@ -61,17 +66,53 @@ static inline void pinctrl_put(struct pinctrl *p)
 {
 }
 
-static inline int pinctrl_enable(struct pinctrl *p)
+static inline struct pinctrl_state * __must_check pinctrl_lookup_state(
+							struct pinctrl *p,
+							const char *name)
 {
-	return 0;
+	return NULL;
 }
 
-static inline void pinctrl_disable(struct pinctrl *p)
+static inline int pinctrl_select_state(struct pinctrl *p,
+				       struct pinctrl_state *s)
 {
+	return 0;
 }
 
 #endif /* CONFIG_PINCTRL */
 
+static inline struct pinctrl * __must_check pinctrl_get_select(
+					struct device *dev, const char *name)
+{
+	struct pinctrl *p;
+	struct pinctrl_state *s;
+	int ret;
+
+	p = pinctrl_get(dev);
+	if (IS_ERR(p))
+		return p;
+
+	s = pinctrl_lookup_state(p, name);
+	if (IS_ERR(s)) {
+		pinctrl_put(p);
+		return ERR_PTR(PTR_ERR(s));
+	}
+
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+
+	return p;
+}
+
+static inline struct pinctrl * __must_check pinctrl_get_select_default(
+					struct device *dev)
+{
+	return pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);
+}
+
 #ifdef CONFIG_PINCONF
 
 extern int pin_config_get(const char *dev_name, const char *name,

commit befe5bdfbb698b3bc57c58d0bd7ca3391c9275ed
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 19:47:48 2012 +0100

    pinctrl: factor pin control handles over to the core
    
    This moves the per-devices struct pinctrl handles and device map
    over from the pinmux part of the subsystem to the core pinctrl part.
    This makes the device handles core infrastructure with the goal of
    using these handles also for pin configuration, so that device
    drivers (or boards etc) will need one and only one handle to the
    pin control core.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index c7d061776293..30865947f2d9 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -19,9 +19,9 @@
 /* This struct is private to the core and should be regarded as a cookie */
 struct pinctrl;
 
-#ifdef CONFIG_PINMUX
+#ifdef CONFIG_PINCTRL
 
-/* External interface to pinmux */
+/* External interface to pin control */
 extern int pinctrl_request_gpio(unsigned gpio);
 extern void pinctrl_free_gpio(unsigned gpio);
 extern int pinctrl_gpio_direction_input(unsigned gpio);
@@ -31,7 +31,7 @@ extern void pinctrl_put(struct pinctrl *p);
 extern int pinctrl_enable(struct pinctrl *p);
 extern void pinctrl_disable(struct pinctrl *p);
 
-#else /* !CONFIG_PINMUX */
+#else /* !CONFIG_PINCTRL */
 
 static inline int pinctrl_request_gpio(unsigned gpio)
 {
@@ -70,7 +70,7 @@ static inline void pinctrl_disable(struct pinctrl *p)
 {
 }
 
-#endif /* CONFIG_PINMUX */
+#endif /* CONFIG_PINCTRL */
 
 #ifdef CONFIG_PINCONF
 

commit e93bcee00c43e2bd4037291262111016f4c05793
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 07:23:28 2012 +0100

    pinctrl: move generic functions to the pinctrl_ namespace
    
    Since we want to use the former pinmux handles and mapping tables for
    generic control involving both muxing and configuration we begin
    refactoring by renaming them from pinmux_* to pinctrl_*.
    
    ChangeLog v1->v2:
    - Also rename the PINMUX_* macros in machine.h to PIN_ as indicated
      in the documentation so as to reflect the generic nature of these
      mapping entries from now on.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
index 9c8513d5d0fb..c7d061776293 100644
--- a/include/linux/pinctrl/consumer.h
+++ b/include/linux/pinctrl/consumer.h
@@ -17,56 +17,56 @@
 #include "pinctrl.h"
 
 /* This struct is private to the core and should be regarded as a cookie */
-struct pinmux;
+struct pinctrl;
 
 #ifdef CONFIG_PINMUX
 
 /* External interface to pinmux */
-extern int pinmux_request_gpio(unsigned gpio);
-extern void pinmux_free_gpio(unsigned gpio);
-extern int pinmux_gpio_direction_input(unsigned gpio);
-extern int pinmux_gpio_direction_output(unsigned gpio);
-extern struct pinmux * __must_check pinmux_get(struct device *dev, const char *name);
-extern void pinmux_put(struct pinmux *pmx);
-extern int pinmux_enable(struct pinmux *pmx);
-extern void pinmux_disable(struct pinmux *pmx);
+extern int pinctrl_request_gpio(unsigned gpio);
+extern void pinctrl_free_gpio(unsigned gpio);
+extern int pinctrl_gpio_direction_input(unsigned gpio);
+extern int pinctrl_gpio_direction_output(unsigned gpio);
+extern struct pinctrl * __must_check pinctrl_get(struct device *dev, const char *name);
+extern void pinctrl_put(struct pinctrl *p);
+extern int pinctrl_enable(struct pinctrl *p);
+extern void pinctrl_disable(struct pinctrl *p);
 
 #else /* !CONFIG_PINMUX */
 
-static inline int pinmux_request_gpio(unsigned gpio)
+static inline int pinctrl_request_gpio(unsigned gpio)
 {
 	return 0;
 }
 
-static inline void pinmux_free_gpio(unsigned gpio)
+static inline void pinctrl_free_gpio(unsigned gpio)
 {
 }
 
-static inline int pinmux_gpio_direction_input(unsigned gpio)
+static inline int pinctrl_gpio_direction_input(unsigned gpio)
 {
 	return 0;
 }
 
-static inline int pinmux_gpio_direction_output(unsigned gpio)
+static inline int pinctrl_gpio_direction_output(unsigned gpio)
 {
 	return 0;
 }
 
-static inline struct pinmux * __must_check pinmux_get(struct device *dev, const char *name)
+static inline struct pinctrl * __must_check pinctrl_get(struct device *dev, const char *name)
 {
 	return NULL;
 }
 
-static inline void pinmux_put(struct pinmux *pmx)
+static inline void pinctrl_put(struct pinctrl *p)
 {
 }
 
-static inline int pinmux_enable(struct pinmux *pmx)
+static inline int pinctrl_enable(struct pinctrl *p)
 {
 	return 0;
 }
 
-static inline void pinmux_disable(struct pinmux *pmx)
+static inline void pinctrl_disable(struct pinctrl *p)
 {
 }
 

commit 28a8d14cc74a0180323d9150c3d3dbf9dd60d55a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 9 01:52:22 2012 +0100

    pinctrl: break out a pinctrl consumer header
    
    This breaks out a <linux/pinctrl/consumer.h> header to be used by
    all pinmux and pinconfig alike, so drivers needing services from
    pinctrl does not need to include different headers. This is similar
    to the approach taken by the regulator API.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/consumer.h b/include/linux/pinctrl/consumer.h
new file mode 100644
index 000000000000..9c8513d5d0fb
--- /dev/null
+++ b/include/linux/pinctrl/consumer.h
@@ -0,0 +1,118 @@
+/*
+ * Consumer interface the pin control subsystem
+ *
+ * Copyright (C) 2012 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * Based on bits of regulator core, gpio core and clk core
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#ifndef __LINUX_PINCTRL_CONSUMER_H
+#define __LINUX_PINCTRL_CONSUMER_H
+
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include "pinctrl.h"
+
+/* This struct is private to the core and should be regarded as a cookie */
+struct pinmux;
+
+#ifdef CONFIG_PINMUX
+
+/* External interface to pinmux */
+extern int pinmux_request_gpio(unsigned gpio);
+extern void pinmux_free_gpio(unsigned gpio);
+extern int pinmux_gpio_direction_input(unsigned gpio);
+extern int pinmux_gpio_direction_output(unsigned gpio);
+extern struct pinmux * __must_check pinmux_get(struct device *dev, const char *name);
+extern void pinmux_put(struct pinmux *pmx);
+extern int pinmux_enable(struct pinmux *pmx);
+extern void pinmux_disable(struct pinmux *pmx);
+
+#else /* !CONFIG_PINMUX */
+
+static inline int pinmux_request_gpio(unsigned gpio)
+{
+	return 0;
+}
+
+static inline void pinmux_free_gpio(unsigned gpio)
+{
+}
+
+static inline int pinmux_gpio_direction_input(unsigned gpio)
+{
+	return 0;
+}
+
+static inline int pinmux_gpio_direction_output(unsigned gpio)
+{
+	return 0;
+}
+
+static inline struct pinmux * __must_check pinmux_get(struct device *dev, const char *name)
+{
+	return NULL;
+}
+
+static inline void pinmux_put(struct pinmux *pmx)
+{
+}
+
+static inline int pinmux_enable(struct pinmux *pmx)
+{
+	return 0;
+}
+
+static inline void pinmux_disable(struct pinmux *pmx)
+{
+}
+
+#endif /* CONFIG_PINMUX */
+
+#ifdef CONFIG_PINCONF
+
+extern int pin_config_get(const char *dev_name, const char *name,
+			  unsigned long *config);
+extern int pin_config_set(const char *dev_name, const char *name,
+			  unsigned long config);
+extern int pin_config_group_get(const char *dev_name,
+				const char *pin_group,
+				unsigned long *config);
+extern int pin_config_group_set(const char *dev_name,
+				const char *pin_group,
+				unsigned long config);
+
+#else
+
+static inline int pin_config_get(const char *dev_name, const char *name,
+				 unsigned long *config)
+{
+	return 0;
+}
+
+static inline int pin_config_set(const char *dev_name, const char *name,
+				 unsigned long config)
+{
+	return 0;
+}
+
+static inline int pin_config_group_get(const char *dev_name,
+				       const char *pin_group,
+				       unsigned long *config)
+{
+	return 0;
+}
+
+static inline int pin_config_group_set(const char *dev_name,
+				       const char *pin_group,
+				       unsigned long config)
+{
+	return 0;
+}
+
+#endif
+
+#endif /* __LINUX_PINCTRL_CONSUMER_H */
