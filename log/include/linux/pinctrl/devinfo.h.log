commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pinctrl/devinfo.h b/include/linux/pinctrl/devinfo.h
index d01a8638bb45..a48ff69acddd 100644
--- a/include/linux/pinctrl/devinfo.h
+++ b/include/linux/pinctrl/devinfo.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Per-device information from the pin control system.
  * This is the stuff that get included into the device
@@ -8,8 +9,6 @@
  * This interface is used in the core to keep track of pins.
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 
 #ifndef PINCTRL_DEVINFO_H

commit d3452f1d88311c9af16d709d51dba5ad44afbd1d
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Mon Jan 22 13:31:11 2018 +0100

    pinctrl: Forward declare struct device
    
    pinctrl/devinfo.h is using forward declaration from pinctrl/consumer.h
    for configurations with CONFIG_PINCTRL defined, however nothing declares
    it in the opposite case. Fix this by adding a forward declaration.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/devinfo.h b/include/linux/pinctrl/devinfo.h
index 05082e407c4a..d01a8638bb45 100644
--- a/include/linux/pinctrl/devinfo.h
+++ b/include/linux/pinctrl/devinfo.h
@@ -43,6 +43,8 @@ extern int pinctrl_init_done(struct device *dev);
 
 #else
 
+struct device;
+
 /* Stubs if we're not using pinctrl */
 
 static inline int pinctrl_bind_pins(struct device *dev)

commit ef0eebc05130b0d22b0ea65c0cd014ee16fc89c7
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 20 21:15:06 2015 -0700

    drivers/pinctrl: Add the concept of an "init" state
    
    For pinctrl the "default" state is applied to pins before the driver's
    probe function is called.  This is normally a sensible thing to do,
    but in some cases can cause problems.  That's because the pins will
    change state before the driver is given a chance to program how those
    pins should behave.
    
    As an example you might have a regulator that is controlled by a PWM
    (output high = high voltage, output low = low voltage).  The firmware
    might leave this pin as driven high.  If we allow the driver core to
    reconfigure this pin as a PWM pin before the PWM's probe function runs
    then you might end up running at too low of a voltage while we probe.
    
    Let's introudce a new "init" state.  If this is defined we'll set
    pinctrl to this state before probe and then "default" after probe
    (unless the driver explicitly changed states already).
    
    An alternative idea that was thought of was to use the pre-existing
    "sleep" or "idle" states and add a boolean property that we should
    start in that mode.  This was not done because the "init" state is
    needed for correctness and those other states are only present (and
    only transitioned in to and out of) when (optional) power management
    is enabled.
    
    Changes in v3:
    - Moved declarations to pinctrl/devinfo.h
    - Fixed author/SoB
    
    Changes in v2:
    - Added comment to pinctrl_init_done() as per Linus W.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/devinfo.h b/include/linux/pinctrl/devinfo.h
index 281cb91ddcf5..05082e407c4a 100644
--- a/include/linux/pinctrl/devinfo.h
+++ b/include/linux/pinctrl/devinfo.h
@@ -24,10 +24,14 @@
  * struct dev_pin_info - pin state container for devices
  * @p: pinctrl handle for the containing device
  * @default_state: the default state for the handle, if found
+ * @init_state: the state at probe time, if found
+ * @sleep_state: the state at suspend time, if found
+ * @idle_state: the state at idle (runtime suspend) time, if found
  */
 struct dev_pin_info {
 	struct pinctrl *p;
 	struct pinctrl_state *default_state;
+	struct pinctrl_state *init_state;
 #ifdef CONFIG_PM
 	struct pinctrl_state *sleep_state;
 	struct pinctrl_state *idle_state;
@@ -35,6 +39,7 @@ struct dev_pin_info {
 };
 
 extern int pinctrl_bind_pins(struct device *dev);
+extern int pinctrl_init_done(struct device *dev);
 
 #else
 
@@ -45,5 +50,10 @@ static inline int pinctrl_bind_pins(struct device *dev)
 	return 0;
 }
 
+static inline int pinctrl_init_done(struct device *dev)
+{
+	return 0;
+}
+
 #endif /* CONFIG_PINCTRL */
 #endif /* PINCTRL_DEVINFO_H */

commit 14005ee270cad7078adbce6b7f3687b992a8334e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jun 5 15:30:33 2013 +0200

    drivers: pinctrl sleep and idle states in the core
    
    If a device have sleep and idle states in addition to the
    default state, look up these in the core and stash them in
    the pinctrl state container.
    
    Add accessor functions for pinctrl consumers to put the pins
    into "default", "sleep" and "idle" states passing nothing but
    the struct device * affected.
    
    Solution suggested by Kevin Hilman, Mark Brown and Dmitry
    Torokhov in response to a patch series from Hebbar
    Gururaja.
    
    Cc: Hebbar Gururaja <gururaja.hebbar@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/devinfo.h b/include/linux/pinctrl/devinfo.h
index 6e5f8a985ea7..281cb91ddcf5 100644
--- a/include/linux/pinctrl/devinfo.h
+++ b/include/linux/pinctrl/devinfo.h
@@ -28,6 +28,10 @@
 struct dev_pin_info {
 	struct pinctrl *p;
 	struct pinctrl_state *default_state;
+#ifdef CONFIG_PM
+	struct pinctrl_state *sleep_state;
+	struct pinctrl_state *idle_state;
+#endif
 };
 
 extern int pinctrl_bind_pins(struct device *dev);

commit ab78029ecc347debbd737f06688d788bd9d60c1d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 22 10:56:14 2013 -0700

    drivers/pinctrl: grab default handles from device core
    
    This makes the device core auto-grab the pinctrl handle and set
    the "default" (PINCTRL_STATE_DEFAULT) state for every device
    that is present in the device model right before probe. This will
    account for the lion's share of embedded silicon devcies.
    
    A modification of the semantics for pinctrl_get() is also done:
    previously if the pinctrl handle for a certain device was already
    taken, the pinctrl core would return an error. Now, since the
    core may have already default-grabbed the handle and set its
    state to "default", if the handle was already taken, this will
    be disregarded and the located, previously instanitated handle
    will be returned to the caller.
    
    This way all code in drivers explicitly requesting their pinctrl
    handlers will still be functional, and drivers that want to
    explicitly retrieve and switch their handles can still do that.
    But if the desired functionality is just boilerplate of this
    type in the probe() function:
    
    struct pinctrl  *p;
    
    p = devm_pinctrl_get_select_default(&dev);
    if (IS_ERR(p)) {
       if (PTR_ERR(p) == -EPROBE_DEFER)
            return -EPROBE_DEFER;
            dev_warn(&dev, "no pinctrl handle\n");
    }
    
    The discussion began with the addition of such boilerplate
    to the omap4 keypad driver:
    http://marc.info/?l=linux-input&m=135091157719300&w=2
    
    A previous approach using notifiers was discussed:
    http://marc.info/?l=linux-kernel&m=135263661110528&w=2
    This failed because it could not handle deferred probes.
    
    This patch alone does not solve the entire dilemma faced:
    whether code should be distributed into the drivers or
    if it should be centralized to e.g. a PM domain. But it
    solves the immediate issue of the addition of boilerplate
    to a lot of drivers that just want to grab the default
    state. As mentioned, they can later explicitly retrieve
    the handle and set different states, and this could as
    well be done by e.g. PM domains as it is only related
    to a certain struct device * pointer.
    
    ChangeLog v4->v5 (Stephen):
    - Simplified the devicecore grab code.
    - Deleted a piece of documentation recommending that pins
      be mapped to a device rather than hogged.
    ChangeLog v3->v4 (Linus):
    - Drop overzealous NULL checks.
    - Move kref initialization to pinctrl_create().
    - Seeking Tested-by from Stephen Warren so we do not disturb
      the Tegra platform.
    - Seeking ACK on this from Greg (and others who like it) so I
      can merge it through the pinctrl subsystem.
    ChangeLog v2->v3 (Linus):
    - Abstain from using IS_ERR_OR_NULL() in the driver core,
      Russell recently sent a patch to remove it. Handle the
      NULL case explicitly even though it's a bogus case.
    - Make sure we handle probe deferral correctly in the device
      core file. devm_kfree() the container on error so we don't
      waste memory for devices without pinctrl handles.
    - Introduce reference counting into the pinctrl core using
      <linux/kref.h> so that we don't release pinctrl handles
      that have been obtained for two or more places.
    ChangeLog v1->v2 (Linus):
    - Only store a pointer in the device struct, and only allocate
      this if it's really used by the device.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Mitch Bradley <wmb@firmworks.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Rickard Andersson <rickard.andersson@stericsson.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [swarren: fixed and simplified error-handling in pinctrl_bind_pins(), to
    correctly handle deferred probe. Removed admonition from docs not to use
    pinctrl hogs for devices]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pinctrl/devinfo.h b/include/linux/pinctrl/devinfo.h
new file mode 100644
index 000000000000..6e5f8a985ea7
--- /dev/null
+++ b/include/linux/pinctrl/devinfo.h
@@ -0,0 +1,45 @@
+/*
+ * Per-device information from the pin control system.
+ * This is the stuff that get included into the device
+ * core.
+ *
+ * Copyright (C) 2012 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * This interface is used in the core to keep track of pins.
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+
+#ifndef PINCTRL_DEVINFO_H
+#define PINCTRL_DEVINFO_H
+
+#ifdef CONFIG_PINCTRL
+
+/* The device core acts as a consumer toward pinctrl */
+#include <linux/pinctrl/consumer.h>
+
+/**
+ * struct dev_pin_info - pin state container for devices
+ * @p: pinctrl handle for the containing device
+ * @default_state: the default state for the handle, if found
+ */
+struct dev_pin_info {
+	struct pinctrl *p;
+	struct pinctrl_state *default_state;
+};
+
+extern int pinctrl_bind_pins(struct device *dev);
+
+#else
+
+/* Stubs if we're not using pinctrl */
+
+static inline int pinctrl_bind_pins(struct device *dev)
+{
+	return 0;
+}
+
+#endif /* CONFIG_PINCTRL */
+#endif /* PINCTRL_DEVINFO_H */
