commit 14ee2ac618e49e767c9af4aa007f951eb9e35153
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Fri Mar 20 14:53:33 2020 +0000

    linux/clocksource.h: Extract common header for vDSO
    
    The vDSO library should only include the necessary headers required for
    a userspace library (UAPI and a minimal set of kernel headers). To make
    this possible it is necessary to isolate from the kernel headers the
    common parts that are strictly necessary to build the library.
    
    Split clocksource.h into linux and common headers to make the latter
    suitable for inclusion in the vDSO library.
    
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200320145351.32292-9-vincenzo.frascino@arm.com

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 02e3282719bd..86d143db6523 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -28,16 +28,7 @@ struct module;
 #include <asm/clocksource.h>
 #endif
 
-enum vdso_clock_mode {
-	VDSO_CLOCKMODE_NONE,
-#ifdef CONFIG_GENERIC_GETTIMEOFDAY
-	VDSO_ARCH_CLOCKMODES,
-#endif
-	VDSO_CLOCKMODE_MAX,
-
-	/* Indicator for time namespace VDSO */
-	VDSO_CLOCKMODE_TIMENS = INT_MAX
-};
+#include <vdso/clocksource.h>
 
 /**
  * struct clocksource - hardware abstraction for a free running counter

commit 2d6b01bd88ccabba06d342ef80eaab6b39d12497
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 13:39:01 2020 +0100

    lib/vdso: Move VCLOCK_TIMENS to vdso_clock_modes
    
    Move the time namespace indicator clock mode to the other ones for
    consistency sake.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Link: https://lkml.kernel.org/r/20200207124403.656097274@linutronix.de

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7fefe0b21a14..02e3282719bd 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -34,6 +34,9 @@ enum vdso_clock_mode {
 	VDSO_ARCH_CLOCKMODES,
 #endif
 	VDSO_CLOCKMODE_MAX,
+
+	/* Indicator for time namespace VDSO */
+	VDSO_CLOCKMODE_TIMENS = INT_MAX
 };
 
 /**

commit f86fd32db706613fe8d0104057efa6e83e0d7e8f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 13:38:59 2020 +0100

    lib/vdso: Cleanup clock mode storage leftovers
    
    Now that all architectures are converted to use the generic storage the
    helpers and conditionals can be removed.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Link: https://lkml.kernel.org/r/20200207124403.470699892@linutronix.de

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 6d5ed1b4d24d..7fefe0b21a14 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -24,13 +24,13 @@ struct clocksource;
 struct module;
 
 #if defined(CONFIG_ARCH_CLOCKSOURCE_DATA) || \
-    defined(CONFIG_GENERIC_VDSO_CLOCK_MODE)
+    defined(CONFIG_GENERIC_GETTIMEOFDAY)
 #include <asm/clocksource.h>
 #endif
 
 enum vdso_clock_mode {
 	VDSO_CLOCKMODE_NONE,
-#ifdef CONFIG_GENERIC_VDSO_CLOCK_MODE
+#ifdef CONFIG_GENERIC_GETTIMEOFDAY
 	VDSO_ARCH_CLOCKMODES,
 #endif
 	VDSO_CLOCKMODE_MAX,

commit 5d51bee725cc1497352d6b0b604e42a90c680540
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 13:38:55 2020 +0100

    clocksource: Add common vdso clock mode storage
    
    All architectures which use the generic VDSO code have their own storage
    for the VDSO clock mode. That's pointless and just requires duplicate code.
    
    Provide generic storage for it. The new Kconfig symbol is intermediate and
    will be removed once all architectures are converted over.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Link: https://lkml.kernel.org/r/20200207124403.028046322@linutronix.de

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 2c4574b517d2..6d5ed1b4d24d 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -23,10 +23,19 @@
 struct clocksource;
 struct module;
 
-#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
+#if defined(CONFIG_ARCH_CLOCKSOURCE_DATA) || \
+    defined(CONFIG_GENERIC_VDSO_CLOCK_MODE)
 #include <asm/clocksource.h>
 #endif
 
+enum vdso_clock_mode {
+	VDSO_CLOCKMODE_NONE,
+#ifdef CONFIG_GENERIC_VDSO_CLOCK_MODE
+	VDSO_ARCH_CLOCKMODES,
+#endif
+	VDSO_CLOCKMODE_MAX,
+};
+
 /**
  * struct clocksource - hardware abstraction for a free running counter
  *	Provides mostly state-free accessors to the underlying hardware.
@@ -97,6 +106,7 @@ struct clocksource {
 	const char		*name;
 	struct list_head	list;
 	int			rating;
+	enum vdso_clock_mode	vdso_clock_mode;
 	unsigned long		flags;
 
 	int			(*enable)(struct clocksource *cs);

commit 3bd142a46b561a12408e8db78cc6d62eb1c6b84e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 7 13:38:53 2020 +0100

    clocksource: Cleanup struct clocksource and documentation
    
    Reformat the struct definition, add missing member documentation.
    No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Link: https://lkml.kernel.org/r/20200207124402.825471920@linutronix.de

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index b21db536fd52..2c4574b517d2 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -32,9 +32,19 @@ struct module;
  *	Provides mostly state-free accessors to the underlying hardware.
  *	This is the structure used for system time.
  *
- * @name:		ptr to clocksource name
- * @list:		list head for registration
- * @rating:		rating value for selection (higher is better)
+ * @read:		Returns a cycle value, passes clocksource as argument
+ * @mask:		Bitmask for two's complement
+ *			subtraction of non 64 bit counters
+ * @mult:		Cycle to nanosecond multiplier
+ * @shift:		Cycle to nanosecond divisor (power of two)
+ * @max_idle_ns:	Maximum idle time permitted by the clocksource (nsecs)
+ * @maxadj:		Maximum adjustment value to mult (~11%)
+ * @archdata:		Optional arch-specific data
+ * @max_cycles:		Maximum safe cycle value which won't overflow on
+ *			multiplication
+ * @name:		Pointer to clocksource name
+ * @list:		List head for registration (internal)
+ * @rating:		Rating value for selection (higher is better)
  *			To avoid rating inflation the following
  *			list should give you a guide as to how
  *			to assign your clocksource a rating
@@ -49,27 +59,23 @@ struct module;
  *			400-499: Perfect
  *				The ideal clocksource. A must-use where
  *				available.
- * @read:		returns a cycle value, passes clocksource as argument
- * @enable:		optional function to enable the clocksource
- * @disable:		optional function to disable the clocksource
- * @mask:		bitmask for two's complement
- *			subtraction of non 64 bit counters
- * @mult:		cycle to nanosecond multiplier
- * @shift:		cycle to nanosecond divisor (power of two)
- * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
- * @maxadj:		maximum adjustment value to mult (~11%)
- * @max_cycles:		maximum safe cycle value which won't overflow on multiplication
- * @flags:		flags describing special properties
- * @archdata:		arch-specific data
- * @suspend:		suspend function for the clocksource, if necessary
- * @resume:		resume function for the clocksource, if necessary
+ * @flags:		Flags describing special properties
+ * @enable:		Optional function to enable the clocksource
+ * @disable:		Optional function to disable the clocksource
+ * @suspend:		Optional suspend function for the clocksource
+ * @resume:		Optional resume function for the clocksource
  * @mark_unstable:	Optional function to inform the clocksource driver that
  *			the watchdog marked the clocksource unstable
- * @owner:		module reference, must be set by clocksource in modules
+ * @tick_stable:        Optional function called periodically from the watchdog
+ *			code to provide stable syncrhonization points
+ * @wd_list:		List head to enqueue into the watchdog list (internal)
+ * @cs_last:		Last clocksource value for clocksource watchdog
+ * @wd_last:		Last watchdog value corresponding to @cs_last
+ * @owner:		Module reference, must be set by clocksource in modules
  *
  * Note: This struct is not used in hotpathes of the timekeeping code
  * because the timekeeper caches the hot path fields in its own data
- * structure, so no line cache alignment is required,
+ * structure, so no cache line alignment is required,
  *
  * The pointer to the clocksource itself is handed to the read
  * callback. If you need extra information there you can wrap struct
@@ -78,35 +84,36 @@ struct module;
  * structure.
  */
 struct clocksource {
-	u64 (*read)(struct clocksource *cs);
-	u64 mask;
-	u32 mult;
-	u32 shift;
-	u64 max_idle_ns;
-	u32 maxadj;
+	u64			(*read)(struct clocksource *cs);
+	u64			mask;
+	u32			mult;
+	u32			shift;
+	u64			max_idle_ns;
+	u32			maxadj;
 #ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif
-	u64 max_cycles;
-	const char *name;
-	struct list_head list;
-	int rating;
-	int (*enable)(struct clocksource *cs);
-	void (*disable)(struct clocksource *cs);
-	unsigned long flags;
-	void (*suspend)(struct clocksource *cs);
-	void (*resume)(struct clocksource *cs);
-	void (*mark_unstable)(struct clocksource *cs);
-	void (*tick_stable)(struct clocksource *cs);
+	u64			max_cycles;
+	const char		*name;
+	struct list_head	list;
+	int			rating;
+	unsigned long		flags;
+
+	int			(*enable)(struct clocksource *cs);
+	void			(*disable)(struct clocksource *cs);
+	void			(*suspend)(struct clocksource *cs);
+	void			(*resume)(struct clocksource *cs);
+	void			(*mark_unstable)(struct clocksource *cs);
+	void			(*tick_stable)(struct clocksource *cs);
 
 	/* private: */
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
-	struct list_head wd_list;
-	u64 cs_last;
-	u64 wd_last;
+	struct list_head	wd_list;
+	u64			cs_last;
+	u64			wd_last;
 #endif
-	struct module *owner;
+	struct module		*owner;
 };
 
 /*

commit 4dcb9239dad6cee17c538482619a5b659774ee51
Merge: 3acbd2de6bc3 d59e0ba19481
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 25 11:14:36 2018 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping updates from Thomas Gleixner:
     "The timers and timekeeping departement provides:
    
       - Another large y2038 update with further preparations for providing
         the y2038 safe timespecs closer to the syscalls.
    
       - An overhaul of the SHCMT clocksource driver
    
       - SPDX license identifier updates
    
       - Small cleanups and fixes all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (31 commits)
      tick/sched : Remove redundant cpu_online() check
      clocksource/drivers/dw_apb: Add reset control
      clocksource: Remove obsolete CLOCKSOURCE_OF_DECLARE
      clocksource/drivers: Unify the names to timer-* format
      clocksource/drivers/sh_cmt: Add R-Car gen3 support
      dt-bindings: timer: renesas: cmt: document R-Car gen3 support
      clocksource/drivers/sh_cmt: Properly line-wrap sh_cmt_of_table[] initializer
      clocksource/drivers/sh_cmt: Fix clocksource width for 32-bit machines
      clocksource/drivers/sh_cmt: Fixup for 64-bit machines
      clocksource/drivers/sh_tmu: Convert to SPDX identifiers
      clocksource/drivers/sh_mtu2: Convert to SPDX identifiers
      clocksource/drivers/sh_cmt: Convert to SPDX identifiers
      clocksource/drivers/renesas-ostm: Convert to SPDX identifiers
      clocksource: Convert to using %pOFn instead of device_node.name
      tick/broadcast: Remove redundant check
      RISC-V: Request newstat syscalls
      y2038: signal: Change rt_sigtimedwait to use __kernel_timespec
      y2038: socket: Change recvmmsg to use __kernel_timespec
      y2038: sched: Change sched_rr_get_interval to use __kernel_timespec
      y2038: utimes: Rework #ifdef guards for compat syscalls
      ...

commit d67f34c19a679436dd2963b588015e119279e7a8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 17 14:45:34 2018 +0200

    clocksource: Provide clocksource_arch_init()
    
    Architectures have extra archdata in the clocksource, e.g. for VDSO
    support. There are no sanity checks or general initializations for this
    available. Add support for that.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Andy Lutomirski <luto@kernel.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Matt Rickard <matt@softrans.com.au>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Florian Weimer <fweimer@redhat.com>
    Cc: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
    Cc: devel@linuxdriverproject.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Juergen Gross <jgross@suse.com>
    Link: https://lkml.kernel.org/r/20180917130706.973042587@linutronix.de

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 308918928767..6e6b86f9046d 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -241,6 +241,11 @@ static inline void __clocksource_update_freq_khz(struct clocksource *cs, u32 khz
 	__clocksource_update_freq_scale(cs, 1000, khz);
 }
 
+#ifdef CONFIG_ARCH_CLOCKSOURCE_INIT
+extern void clocksource_arch_init(struct clocksource *cs);
+#else
+static inline void clocksource_arch_init(struct clocksource *cs) { }
+#endif
 
 extern int timekeeping_notify(struct clocksource *clock);
 

commit 9414229c9c53d3604032aa80f3d2e9ba5770cd4a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Sep 24 06:08:07 2018 +0200

    clocksource: Remove obsolete CLOCKSOURCE_OF_DECLARE
    
    The macro CLOCKSOURCE_OF_DECLARE was renamed more TIMER_OF_DECLARE, and we
    kept an alias CLOCKSOURCE_OF_DECLARE in order to smooth the transition for
    drivers.
    
    This change was done 1.5 year ago, we can reasonably remove this backward
    compatible macro as it is no longer used anywhere.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 308918928767..4c58c1e64080 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -257,9 +257,6 @@ extern int clocksource_i8253_init(void);
 #define TIMER_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1_RET(timer, name, compat, fn)
 
-#define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
-	TIMER_OF_DECLARE(name, compat, fn)
-
 #ifdef CONFIG_TIMER_PROBE
 extern void timer_probe(void);
 #else

commit 39232ed5a1793f67b11430c43ed8a9ed6e96c6eb
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Tue Jul 17 15:55:16 2018 +0800

    time: Introduce one suspend clocksource to compensate the suspend time
    
    On some hardware with multiple clocksources, we have coarse grained
    clocksources that support the CLOCK_SOURCE_SUSPEND_NONSTOP flag, but
    which are less than ideal for timekeeping whereas other clocksources
    can be better candidates but halt on suspend.
    
    Currently, the timekeeping core only supports timing suspend using
    CLOCK_SOURCE_SUSPEND_NONSTOP clocksources if that clocksource is the
    current clocksource for timekeeping.
    
    As a result, some architectures try to implement read_persistent_clock64()
    using those non-stop clocksources, but isn't really ideal, which will
    introduce more duplicate code. To fix this, provide logic to allow a
    registered SUSPEND_NONSTOP clocksource, which isn't the current
    clocksource, to be used to calculate the suspend time.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    [jstultz: minor tweaks to merge with previous resume changes]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7dff1963c185..308918928767 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -194,6 +194,9 @@ extern void clocksource_suspend(void);
 extern void clocksource_resume(void);
 extern struct clocksource * __init clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
+extern void
+clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles);
+extern u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 now);
 
 extern u64
 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cycles);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a78cb1848e65..7dff1963c185 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*  linux/include/linux/clocksource.h
  *
  *  This file contains the structure definitions for clocksources.

commit 1b044f1cfc65a7d90b209dfabd57e16d98b58c5b
Merge: e0f3e8f14da8 2287d8664fe7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 16:14:51 2017 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "A rather large update for timers/timekeeping:
    
       - compat syscall consolidation (Al Viro)
    
       - Posix timer consolidation (Christoph Helwig / Thomas Gleixner)
    
       - Cleanup of the device tree based initialization for clockevents and
         clocksources (Daniel Lezcano)
    
       - Consolidation of the FTTMR010 clocksource/event driver (Linus
         Walleij)
    
       - The usual set of small fixes and updates all over the place"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (93 commits)
      timers: Make the cpu base lock raw
      clocksource/drivers/mips-gic-timer: Fix an error code in 'gic_clocksource_of_init()'
      clocksource/drivers/fsl_ftm_timer: Unmap region obtained by of_iomap
      clocksource/drivers/tcb_clksrc: Make IO endian agnostic
      clocksource/drivers/sun4i: Switch to the timer-of common init
      clocksource/drivers/timer-of: Fix invalid iomap check
      Revert "ktime: Simplify ktime_compare implementation"
      clocksource/drivers: Fix uninitialized variable use in timer_of_init
      kselftests: timers: Add test for frequency step
      kselftests: timers: Fix inconsistency-check to not ignore first timestamp
      time: Add warning about imminent deprecation of CONFIG_GENERIC_TIME_VSYSCALL_OLD
      time: Clean up CLOCK_MONOTONIC_RAW time handling
      posix-cpu-timers: Make timespec to nsec conversion safe
      itimer: Make timeval to nsec conversion range limited
      timers: Fix parameter description of try_to_del_timer_sync()
      ktime: Simplify ktime_compare implementation
      clocksource/drivers/fttmr010: Factor out clock read code
      clocksource/drivers/fttmr010: Implement delay timer
      clocksource/drivers: Add timer-of common init routine
      clocksource/drivers/tcb_clksrc: Save timer context on suspend/resume
      ...

commit 8b7a3b568814a8e36d2910dd74465b0215aa0a31
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue May 30 08:35:40 2017 +0200

    clocksource/drivers: Add an alias macro CLOCKSOURCE_OF_DECLARE
    
    The macro CLOCKSOURCE_OF_DECLARE has been rename to TIMER_OF_DECLARE.
    
    In order to prevent conflicts for the next merge window, a temporary
    alias has been added which will be removed later.
    
    Cc: Arnd Bergman <arnd@arndb.de>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c48ceefe0e6e..d92bd83eed9f 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -252,6 +252,9 @@ extern int clocksource_i8253_init(void);
 #define TIMER_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1_RET(timer, name, compat, fn)
 
+#define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
+	TIMER_OF_DECLARE(name, compat, fn)
+
 #ifdef CONFIG_TIMER_PROBE
 extern void timer_probe(void);
 #else

commit bb0eb050a577a866cb47c2dc37596f1207f4c2d9
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 19:34:11 2017 +0200

    clocksource/drivers: Rename CLKSRC_OF to TIMER_OF
    
    The config option name is now renamed to 'TIMER_OF' for consistency with
    the CLOCKSOURCE_OF_DECLARE => TIMER_OF_DECLARE change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7cd38b21cbd3..c48ceefe0e6e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -252,7 +252,7 @@ extern int clocksource_i8253_init(void);
 #define TIMER_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1_RET(timer, name, compat, fn)
 
-#ifdef CONFIG_CLKSRC_PROBE
+#ifdef CONFIG_TIMER_PROBE
 extern void timer_probe(void);
 #else
 static inline void timer_probe(void) {}

commit 2fcc112af37fa88f8da077d6dd3bb8e38e75adb1
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 18:33:27 2017 +0200

    clocksource/drivers: Rename clksrc table to timer
    
    The table name is now renamed to 'timer' for consistency with
    the CLOCKSOURCE_OF_DECLARE => TIMER_OF_DECLARE change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index e43f37f9a1b6..7cd38b21cbd3 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -250,7 +250,7 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 extern int clocksource_i8253_init(void);
 
 #define TIMER_OF_DECLARE(name, compat, fn) \
-	OF_DECLARE_1_RET(clksrc, name, compat, fn)
+	OF_DECLARE_1_RET(timer, name, compat, fn)
 
 #ifdef CONFIG_CLKSRC_PROBE
 extern void timer_probe(void);
@@ -259,6 +259,6 @@ static inline void timer_probe(void) {}
 #endif
 
 #define TIMER_ACPI_DECLARE(name, table_id, fn)		\
-	ACPI_DECLARE_PROBE_ENTRY(clksrc, name, table_id, 0, NULL, 0, fn)
+	ACPI_DECLARE_PROBE_ENTRY(timer, name, table_id, 0, NULL, 0, fn)
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 77d62f532282010d5859a99819d6a0c233bfcfff
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 17:42:25 2017 +0200

    clocksource/drivers: Rename CLOCKSOURCE_ACPI_DECLARE to TIMER_ACPI_DECLARE
    
    The macro name is now renamed to 'TIMER_ACPI_DECLARE' for consistency
    with the CLOCKSOURCE_OF_DECLARE => TIMER_OF_DECLARE change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 010bb9f60db2..e43f37f9a1b6 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -258,7 +258,7 @@ extern void timer_probe(void);
 static inline void timer_probe(void) {}
 #endif
 
-#define CLOCKSOURCE_ACPI_DECLARE(name, table_id, fn)		\
+#define TIMER_ACPI_DECLARE(name, table_id, fn)		\
 	ACPI_DECLARE_PROBE_ENTRY(clksrc, name, table_id, 0, NULL, 0, fn)
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit ba5d08c0ea785d5710c5a1e7dc3182b7124d63c0
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 17:40:46 2017 +0200

    clocksource/drivers: Rename clocksource_probe to timer_probe
    
    The function name is now renamed to 'timer_probe' for consistency with
    the CLOCKSOURCE_OF_DECLARE => TIMER_OF_DECLARE change.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a86b65f0a246..010bb9f60db2 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -253,9 +253,9 @@ extern int clocksource_i8253_init(void);
 	OF_DECLARE_1_RET(clksrc, name, compat, fn)
 
 #ifdef CONFIG_CLKSRC_PROBE
-extern void clocksource_probe(void);
+extern void timer_probe(void);
 #else
-static inline void clocksource_probe(void) {}
+static inline void timer_probe(void) {}
 #endif
 
 #define CLOCKSOURCE_ACPI_DECLARE(name, table_id, fn)		\

commit 1727339590fdb5a1ded881b540cd32121278d414
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 16:56:11 2017 +0200

    clocksource/drivers: Rename CLOCKSOURCE_OF_DECLARE to TIMER_OF_DECLARE
    
    The CLOCKSOURCE_OF_DECLARE macro is used widely for the timers to declare the
    clocksource at early stage. However, this macro is also used to initialize
    the clockevent if any, or the clockevent only.
    
    It was originally suggested to declare another macro to initialize a
    clockevent, so in order to separate the two entities even they belong to the
    same IP. This was not accepted because of the impact on the DT where splitting
    a clocksource/clockevent definition does not make sense as it is a Linux
    concept not a hardware description.
    
    On the other side, the clocksource has not interrupt declared while the
    clockevent has, so it is easy from the driver to know if the description is
    for a clockevent or a clocksource, IOW it could be implemented at the driver
    level.
    
    So instead of dealing with a named clocksource macro, let's use a more generic
    one: TIMER_OF_DECLARE.
    
    The patch has not functional changes.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f2b10d9ebd04..a86b65f0a246 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -249,7 +249,7 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 
 extern int clocksource_i8253_init(void);
 
-#define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
+#define TIMER_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1_RET(clksrc, name, compat, fn)
 
 #ifdef CONFIG_CLKSRC_PROBE

commit b421b22b00b0011f6a2ce3561176c4e79e640c49
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Fri Apr 21 12:14:13 2017 +0200

    x86/tsc, sched/clock, clocksource: Use clocksource watchdog to provide stable sync points
    
    Currently we keep sched_clock_tick() active for stable TSC in order to
    keep the per-CPU state semi up-to-date. The (obvious) problem is that
    by the time we detect TSC is borked, our per-CPU state is also borked.
    
    So hook into the clocksource watchdog and call a method after we've
    found it to still be stable.
    
    There's the obvious race where the TSC goes wonky between finding it
    stable and us running the callback, but closing that is too much work
    and not really worth it, since we're already detecting TSC wobbles
    after the fact, so we cannot, per definition, fully avoid funny clock
    values.
    
    And since the watchdog runs less often than the tick, this is also an
    optimization.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f2b10d9ebd04..81490456c242 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -96,6 +96,7 @@ struct clocksource {
 	void (*suspend)(struct clocksource *cs);
 	void (*resume)(struct clocksource *cs);
 	void (*mark_unstable)(struct clocksource *cs);
+	void (*tick_stable)(struct clocksource *cs);
 
 	/* private: */
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG

commit 0773cea37470f8e080c510fe720fc356cf35df3a
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Tue Apr 18 16:30:37 2017 -0700

    clocksource: Use GENMASK_ULL in definition of CLOCKSOURCE_MASK
    
    Besides reusing existing code this removes the special case handling
    for 64-bit masks, which causes clang to raise a shift count overflow
    warning due to https://bugs.llvm.org//show_bug.cgi?id=10030.
    
    Suggested-by: Dmitry Torokhov <dtor@chromium.org>
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Cc: Grant Grundler <grundler@chromium.org>
    Cc: Greg Hackmann <ghackmann@google.com>
    Cc: Michael Davidson <md@google.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/20170418233037.70990-1-mka@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index cfc75848a35d..f2b10d9ebd04 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -120,7 +120,7 @@ struct clocksource {
 #define CLOCK_SOURCE_RESELECT			0x100
 
 /* simplify initialization of mask field */
-#define CLOCKSOURCE_MASK(bits) (u64)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)
+#define CLOCKSOURCE_MASK(bits) GENMASK_ULL((bits) - 1, 0)
 
 static inline u32 clocksource_freq2mult(u32 freq, u32 shift_constant, u64 from)
 {

commit 12907fbb1a691807bb0420a27126e15934cb7954
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Dec 15 11:44:28 2016 +0100

    sched/clock, clocksource: Add optional cs::mark_unstable() method
    
    PeterZ reported that we'd fail to mark the TSC unstable when the
    clocksource watchdog finds it unsuitable.
    
    Allow a clocksource to run a custom action when its being marked
    unstable and hook up the TSC unstable code.
    
    Reported-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index e315d04a2fd9..cfc75848a35d 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -62,6 +62,8 @@ struct module;
  * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
+ * @mark_unstable:	Optional function to inform the clocksource driver that
+ *			the watchdog marked the clocksource unstable
  * @owner:		module reference, must be set by clocksource in modules
  *
  * Note: This struct is not used in hotpathes of the timekeeping code
@@ -93,6 +95,7 @@ struct clocksource {
 	unsigned long flags;
 	void (*suspend)(struct clocksource *cs);
 	void (*resume)(struct clocksource *cs);
+	void (*mark_unstable)(struct clocksource *cs);
 
 	/* private: */
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 65602d395a52..e315d04a2fd9 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -75,8 +75,8 @@ struct module;
  * structure.
  */
 struct clocksource {
-	cycle_t (*read)(struct clocksource *cs);
-	cycle_t mask;
+	u64 (*read)(struct clocksource *cs);
+	u64 mask;
 	u32 mult;
 	u32 shift;
 	u64 max_idle_ns;
@@ -98,8 +98,8 @@ struct clocksource {
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
 	struct list_head wd_list;
-	cycle_t cs_last;
-	cycle_t wd_last;
+	u64 cs_last;
+	u64 wd_last;
 #endif
 	struct module *owner;
 };
@@ -117,7 +117,7 @@ struct clocksource {
 #define CLOCK_SOURCE_RESELECT			0x100
 
 /* simplify initialization of mask field */
-#define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)
+#define CLOCKSOURCE_MASK(bits) (u64)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)
 
 static inline u32 clocksource_freq2mult(u32 freq, u32 shift_constant, u64 from)
 {
@@ -176,7 +176,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
  *
  * XXX - This could use some mult_lxl_ll() asm optimization
  */
-static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
+static inline s64 clocksource_cyc2ns(u64 cycles, u32 mult, u32 shift)
 {
 	return ((u64) cycles * mult) >> shift;
 }
@@ -236,13 +236,13 @@ static inline void __clocksource_update_freq_khz(struct clocksource *cs, u32 khz
 
 extern int timekeeping_notify(struct clocksource *clock);
 
-extern cycle_t clocksource_mmio_readl_up(struct clocksource *);
-extern cycle_t clocksource_mmio_readl_down(struct clocksource *);
-extern cycle_t clocksource_mmio_readw_up(struct clocksource *);
-extern cycle_t clocksource_mmio_readw_down(struct clocksource *);
+extern u64 clocksource_mmio_readl_up(struct clocksource *);
+extern u64 clocksource_mmio_readl_down(struct clocksource *);
+extern u64 clocksource_mmio_readw_up(struct clocksource *);
+extern u64 clocksource_mmio_readw_down(struct clocksource *);
 
 extern int clocksource_mmio_init(void __iomem *, const char *,
-	unsigned long, int, unsigned, cycle_t (*)(struct clocksource *));
+	unsigned long, int, unsigned, u64 (*)(struct clocksource *));
 
 extern int clocksource_i8253_init(void);
 

commit ec4101e8903e318b9fd4e3bbf72b1eaba53c64e1
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Mon Nov 28 14:35:20 2016 -0800

    timekeeping/clocksource_cyc2ns: Document intended range limitation
    
    The "cycles" argument should not be an absolute clocksource cycle
    value, as the implementation's arithmetic will overflow relatively
    easily with wide (64 bit) clocksource counters.
    
    For performance, the implementation is simple and fast, since the
    function is intended for only relatively small delta values of
    clocksource cycles.
    
    [jstultz: Fixed up to merge against HEAD & commit message tweaks,
     also included rewording suggestion by Ingo]
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1480372524-15181-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 08398182f56e..65602d395a52 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -169,7 +169,10 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
  * @mult:	cycle to nanosecond multiplier
  * @shift:	cycle to nanosecond divisor (power of two)
  *
- * Converts cycles to nanoseconds, using the given mult and shift.
+ * Converts clocksource cycles to nanoseconds, using the given @mult and @shift.
+ * The code is optimized for performance and is not intended to work
+ * with absolute clocksource cycles (as those will easily overflow),
+ * but is only intended to be used with relative (delta) clocksource cycles.
  *
  * XXX - This could use some mult_lxl_ll() asm optimization
  */

commit 177cf6e52b0a1a382b9892d3cc9aafd6e7c5943f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Jun 7 00:27:44 2016 +0200

    clocksources: Switch back to the clksrc table
    
    All the clocksource drivers's init function are now converted to return
    an error code. CLOCKSOURCE_OF_DECLARE is no longer used as well as the
    clksrc-of table.
    
    Let's convert back the names:
     - CLOCKSOURCE_OF_DECLARE_RET => CLOCKSOURCE_OF_DECLARE
     - clksrc-of-ret              => clksrc-of
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    
    For exynos_mct and samsung_pwm_timer:
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    
    For arch/arc:
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    
    For mediatek driver:
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    
    For the Rockchip-part
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    
    For STi :
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    
    For the mps2-timer.c and versatile.c changes:
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    
    For the OXNAS part :
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    
    For LPC32xx driver:
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    
    For Broadcom Kona timer change:
    Acked-by: Ray Jui <ray.jui@broadcom.com>
    
    For Sun4i and Sun5i:
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    
    For Meson6:
    Acked-by: Carlo Caione <carlo@caione.org>
    
    For Keystone:
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    
    For NPS:
    Acked-by: Noam Camus <noamca@mellanox.com>
    
    For bcm2835:
    Acked-by: Eric Anholt <eric@anholt.net>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 15c3839850f4..08398182f56e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -244,10 +244,7 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 extern int clocksource_i8253_init(void);
 
 #define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
-	OF_DECLARE_1(clksrc, name, compat, fn)
-
-#define CLOCKSOURCE_OF_DECLARE_RET(name, compat, fn) \
-	OF_DECLARE_1_RET(clksrc_ret, name, compat, fn)
+	OF_DECLARE_1_RET(clksrc, name, compat, fn)
 
 #ifdef CONFIG_CLKSRC_PROBE
 extern void clocksource_probe(void);

commit b7c4db861683af5fc50ac3cb3751cf847d765211
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue May 31 16:25:59 2016 +0200

    clocksource/drivers/clksrc-probe: Introduce init functions with return code
    
    Currently, the clksrc-probe is not able to handle any error from the init
    functions. There are different issues with the current code:
     - the code is duplicated in the init functions by writing error
     - every driver tends to panic in its own init function
     - counting the number of clocksources is not reliable
    
    This patch adds another table to store the functions returning an error.
    The table is temporary while we convert all the drivers to return an error
    and will disappear.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 44a1aff22566..15c3839850f4 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -246,6 +246,9 @@ extern int clocksource_i8253_init(void);
 #define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1(clksrc, name, compat, fn)
 
+#define CLOCKSOURCE_OF_DECLARE_RET(name, compat, fn) \
+	OF_DECLARE_1_RET(clksrc_ret, name, compat, fn)
+
 #ifdef CONFIG_CLKSRC_PROBE
 extern void clocksource_probe(void);
 #else

commit 02fad5e9b433da3829d39f0afb3c51b4b6409ed5
Author: David Lechner <david@lechnology.com>
Date:   Wed Mar 9 18:16:54 2016 -0600

    clocksource: Add missing include of of.h.
    
    This header uses OF_DELCARE_1 which is defined in linux/of.h.
    
    This fixes getting unhelpful compiler error messages about missing ')'
    before a string constant.
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a307bf62974f..44a1aff22566 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -15,6 +15,7 @@
 #include <linux/cache.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/of.h>
 #include <asm/div64.h>
 #include <asm/io.h>
 

commit 7aca0c07207385cca76025cc85231519935722b9
Author: Alexander Kuleshov <kuleshovmail@gmail.com>
Date:   Fri Feb 26 19:14:13 2016 -0800

    clocksource: Introduce clocksource_freq2mult()
    
    The clocksource_khz2mult() and clocksource_hz2mult() share similar
    code wihch calculates a mult from the given frequency. Both implementations
    in differ only in value of a frequency. This patch introduces the
    clocksource_freq2mult() helper with generic implementation of
    mult calculation to prevent code duplication.
    
    Signed-off-by: Alexander Kuleshov <kuleshovmail@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Link: http://lkml.kernel.org/r/1456542854-22104-2-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 6013021a3b39..a307bf62974f 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -118,6 +118,23 @@ struct clocksource {
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)
 
+static inline u32 clocksource_freq2mult(u32 freq, u32 shift_constant, u64 from)
+{
+	/*  freq = cyc/from
+	 *  mult/2^shift  = ns/cyc
+	 *  mult = ns/cyc * 2^shift
+	 *  mult = from/freq * 2^shift
+	 *  mult = from * 2^shift / freq
+	 *  mult = (from<<shift) / freq
+	 */
+	u64 tmp = ((u64)from) << shift_constant;
+
+	tmp += freq/2; /* round for do_div */
+	do_div(tmp, freq);
+
+	return (u32)tmp;
+}
+
 /**
  * clocksource_khz2mult - calculates mult from khz and shift
  * @khz:		Clocksource frequency in KHz
@@ -128,19 +145,7 @@ struct clocksource {
  */
 static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
 {
-	/*  khz = cyc/(Million ns)
-	 *  mult/2^shift  = ns/cyc
-	 *  mult = ns/cyc * 2^shift
-	 *  mult = 1Million/khz * 2^shift
-	 *  mult = 1000000 * 2^shift / khz
-	 *  mult = (1000000<<shift) / khz
-	 */
-	u64 tmp = ((u64)1000000) << shift_constant;
-
-	tmp += khz/2; /* round for do_div */
-	do_div(tmp, khz);
-
-	return (u32)tmp;
+	return clocksource_freq2mult(khz, shift_constant, NSEC_PER_MSEC);
 }
 
 /**
@@ -154,19 +159,7 @@ static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
  */
 static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 {
-	/*  hz = cyc/(Billion ns)
-	 *  mult/2^shift  = ns/cyc
-	 *  mult = ns/cyc * 2^shift
-	 *  mult = 1Billion/hz * 2^shift
-	 *  mult = 1000000000 * 2^shift / hz
-	 *  mult = (1000000000<<shift) / hz
-	 */
-	u64 tmp = ((u64)1000000000) << shift_constant;
-
-	tmp += hz/2; /* round for do_div */
-	do_div(tmp, hz);
-
-	return (u32)tmp;
+	return clocksource_freq2mult(hz, shift_constant, NSEC_PER_SEC);
 }
 
 /**

commit 09a9982016499daeb3fbee5ac8d87797310a565a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Nov 19 11:43:09 2015 +0100

    timekeeping: Lift clocksource cacheline restriction
    
    We cache all hotpath members of a clocksource in the time keeper
    core. So there is no requirement in general to cache line align struct
    clocksource. Remove the enforces alignment.
    
    That allows users which need to wrap struct clocksource into their own
    struct to align the struct without getting extra padding.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Cc: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Mans Rullgard <mans@mansr.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Sebastian Frias <sebastian_frias@sigmadesigns.com>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.11.1511191209000.3898@nanos

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7784b597e959..6013021a3b39 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -62,12 +62,18 @@ struct module;
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
  * @owner:		module reference, must be set by clocksource in modules
+ *
+ * Note: This struct is not used in hotpathes of the timekeeping code
+ * because the timekeeper caches the hot path fields in its own data
+ * structure, so no line cache alignment is required,
+ *
+ * The pointer to the clocksource itself is handed to the read
+ * callback. If you need extra information there you can wrap struct
+ * clocksource into your own struct. Depending on the amount of
+ * information you need you should consider to cache line align that
+ * structure.
  */
 struct clocksource {
-	/*
-	 * Hotpath data, fits in a single cache line when the
-	 * clocksource itself is cacheline aligned.
-	 */
 	cycle_t (*read)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
@@ -95,7 +101,7 @@ struct clocksource {
 	cycle_t wd_last;
 #endif
 	struct module *owner;
-} ____cacheline_aligned;
+};
 
 /*
  * Clock source flags bits::

commit 3722ed2380ad6e89eaf81fcf93f06d605e740435
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:18 2015 +0100

    clocksource: cosmetic: Drop OF 'dependency' from symbols
    
    Seeing the 'of' characters in a symbol that is being called from
    ACPI seems to freak out people. So let's do a bit of pointless
    renaming so that these folks do feel at home.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 116645f746c1..7784b597e959 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -247,9 +247,9 @@ extern int clocksource_i8253_init(void);
 	OF_DECLARE_1(clksrc, name, compat, fn)
 
 #ifdef CONFIG_CLKSRC_PROBE
-extern void clocksource_of_init(void);
+extern void clocksource_probe(void);
 #else
-static inline void clocksource_of_init(void) {}
+static inline void clocksource_probe(void) {}
 #endif
 
 #define CLOCKSOURCE_ACPI_DECLARE(name, table_id, fn)		\

commit ae281cbd2689200329afe2474b2f39f3f6eb54b9
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:17 2015 +0100

    clocksource / arm_arch_timer: Convert to ACPI probing
    
    It is now absolutely trivial to convert the arch timer driver to
    use ACPI probing, just like its DT counterpart.
    
    Let's enjoy another crapectomy.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 6eab6abf89b3..116645f746c1 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -252,12 +252,6 @@ extern void clocksource_of_init(void);
 static inline void clocksource_of_init(void) {}
 #endif
 
-#ifdef CONFIG_ACPI
-void acpi_generic_timer_init(void);
-#else
-static inline void acpi_generic_timer_init(void) { }
-#endif
-
 #define CLOCKSOURCE_ACPI_DECLARE(name, table_id, fn)		\
 	ACPI_DECLARE_PROBE_ENTRY(clksrc, name, table_id, 0, NULL, 0, fn)
 

commit aad83b15aa21f2d9e46b978b27bc63989e61202d
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:16 2015 +0100

    clocksource: Add new CLKSRC_{PROBE,ACPI} config symbols
    
    The clocksource probing infrastructure currently depends on
    CONFIG_CLKSRC_OF, which depends on CONFIG_OF. In order to make
    this infrastructure selectable even if CONFIG_OF is not selected,
    introduce a new CONFIG_CLKSRC_PROBE (which allow the infrastructure
    to be compiled in), and CONFIG_CLKSRC_ACPI (which is the pendent
    of CONFIG_CLKSRC_OF for ACPI).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 8cde04803d91..6eab6abf89b3 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -246,7 +246,7 @@ extern int clocksource_i8253_init(void);
 #define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
 	OF_DECLARE_1(clksrc, name, compat, fn)
 
-#ifdef CONFIG_CLKSRC_OF
+#ifdef CONFIG_CLKSRC_PROBE
 extern void clocksource_of_init(void);
 #else
 static inline void clocksource_of_init(void) {}

commit c625f76a9910b9d51df5d6ca40a8da0684326996
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Mon Sep 28 15:49:15 2015 +0100

    clocksource / ACPI: Add probing infrastructure for ACPI-based clocksources
    
    DT enjoys a rather nice probing infrastructure for clocksources,
    while ACPI is so far stuck into a very distant past.
    
    This patch introduces a declarative API, allowing clocksources
    to be self-contained and be called when parsing the GTDT table.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 278dd279a7a8..8cde04803d91 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -258,4 +258,7 @@ void acpi_generic_timer_init(void);
 static inline void acpi_generic_timer_init(void) { }
 #endif
 
+#define CLOCKSOURCE_ACPI_DECLARE(name, table_id, fn)		\
+	ACPI_DECLARE_PROBE_ENTRY(clksrc, name, table_id, 0, NULL, 0, fn)
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit c3b5d3cea508d2c8ff493ef18c45a9cc58fb7015
Merge: daa67b4b7056 e26081808eda
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 19 16:12:32 2015 +0200

    Merge branch 'linus' into timers/core
    
    Make sure the upstream fixes are applied before adding further
    modifications.

commit 836ee4874e201a5907f9658fb2bf3527dd952d30
Merge: fb65d872d7a8 7676fa70feb2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 24 08:23:45 2015 -0700

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull initial ACPI support for arm64 from Will Deacon:
     "This series introduces preliminary ACPI 5.1 support to the arm64
      kernel using the "hardware reduced" profile.  We don't support any
      peripherals yet, so it's fairly limited in scope:
    
       - MEMORY init (UEFI)
    
       - ACPI discovery (RSDP via UEFI)
    
       - CPU init (FADT)
    
       - GIC init (MADT)
    
       - SMP boot (MADT + PSCI)
    
       - ACPI Kconfig options (dependent on EXPERT)
    
      ACPI for arm64 has been in development for a while now and hardware
      has been available that can boot with either FDT or ACPI tables.  This
      has been made possible by both changes to the ACPI spec to cater for
      ARM-based machines (known as "hardware-reduced" in ACPI parlance) but
      also a Linaro-driven effort to get this supported on top of the Linux
      kernel.  This pull request is the result of that work.
    
      These changes allow us to initialise the CPUs, interrupt controller,
      and timers via ACPI tables, with memory information and cmdline coming
      from EFI.  We don't support a hybrid ACPI/FDT scheme.  Of course,
      there is still plenty of work to do (a serial console would be nice!)
      but I expect that to happen on a per-driver basis after this core
      series has been merged.
    
      Anyway, the diff stat here is fairly horrible, but splitting this up
      and merging it via all the different subsystems would have been
      extremely painful.  Instead, we've got all the relevant Acks in place
      and I've not seen anything other than trivial (Kconfig) conflicts in
      -next (for completeness, I've included my resolution below).  Nearly
      half of the insertions fall under Documentation/.
    
      So, we'll see how this goes.  Right now, it all depends on EXPERT and
      I fully expect people to use FDT by default for the immediate future"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (31 commits)
      ARM64 / ACPI: make acpi_map_gic_cpu_interface() as void function
      ARM64 / ACPI: Ignore the return error value of acpi_map_gic_cpu_interface()
      ARM64 / ACPI: fix usage of acpi_map_gic_cpu_interface
      ARM64: kernel: acpi: honour acpi=force command line parameter
      ARM64: kernel: acpi: refactor ACPI tables init and checks
      ARM64: kernel: psci: let ACPI probe PSCI version
      ARM64: kernel: psci: factor out probe function
      ACPI: move arm64 GSI IRQ model to generic GSI IRQ layer
      ARM64 / ACPI: Don't unflatten device tree if acpi=force is passed
      ARM64 / ACPI: additions of ACPI documentation for arm64
      Documentation: ACPI for ARM64
      ARM64 / ACPI: Enable ARM64 in Kconfig
      XEN / ACPI: Make XEN ACPI depend on X86
      ARM64 / ACPI: Select ACPI_REDUCED_HARDWARE_ONLY if ACPI is enabled on ARM64
      clocksource / arch_timer: Parse GTDT to initialize arch timer
      irqchip: Add GICv2 specific ACPI boot support
      ARM64 / ACPI: Introduce ACPI_IRQ_MODEL_GIC and register device's gsi
      ACPI / processor: Make it possible to get CPU hardware ID via GICC
      ACPI / processor: Introduce phys_cpuid_t for CPU hardware ID
      ARM64 / ACPI: Parse MADT for SMP initialization
      ...

commit 4796cf9b02b5bea141632e21d64556a7eb883a65
Author: Yingjoe Chen <yingjoe.chen@mediatek.com>
Date:   Fri Apr 10 21:55:50 2015 +0800

    time: Remove nonexistent function prototype
    
    The function clocksource_get_next() was removed in commit 75c5158f70
    (timekeeping: Update clocksource with stop_machine), but the
    prototype was not removed with it. Remove the prototype.
    
    Signed-off-by: Yingjoe Chen <yingjoe.chen@mediatek.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: <srv_heupstream@mediatek.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/1428674150-1780-1-git-send-email-yingjoe.chen@mediatek.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 135509821c39..a25fc6e873b8 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -181,7 +181,6 @@ static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 
 extern int clocksource_unregister(struct clocksource*);
 extern void clocksource_touch_watchdog(void);
-extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_suspend(void);
 extern void clocksource_resume(void);

commit b09ca1ecf6d499d5a33f978c905d2fbcc79b55d9
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue Mar 24 14:02:50 2015 +0000

    clocksource / arch_timer: Parse GTDT to initialize arch timer
    
    Using the information presented by GTDT (Generic Timer Description Table)
    to initialize the arch timer (not memory-mapped).
    
    CC: Daniel Lezcano <daniel.lezcano@linaro.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Originally-by: Amit Daniel Kachhap <amit.daniel@samsung.com>
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Tested-by: Mark Langsdorf <mlangsdo@redhat.com>
    Tested-by: Jon Masters <jcm@redhat.com>
    Tested-by: Timur Tabi <timur@codeaurora.org>
    Tested-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Robert Richter <rrichter@cavium.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 9c78d15d33e4..2b2e1f80c519 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -244,4 +244,10 @@ extern void clocksource_of_init(void);
 static inline void clocksource_of_init(void) {}
 #endif
 
+#ifdef CONFIG_ACPI
+void acpi_generic_timer_init(void);
+#else
+static inline void acpi_generic_timer_init(void) { }
+#endif
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit fba9e07208c0f9d92d9f73761c99c8612039da44
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:40 2015 -0700

    clocksource: Rename __clocksource_updatefreq_*() to __clocksource_update_freq_*()
    
    Ingo requested this function be renamed to improve readability,
    so I've renamed __clocksource_updatefreq_scale() as well as the
    __clocksource_updatefreq_hz/khz() functions to avoid
    squishedtogethernames.
    
    This touches some of the sh clocksources, which I've not tested.
    
    The arch/arm/plat-omap change is just a comment change for
    consistency.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-13-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index bd98eaa4d005..135509821c39 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -200,7 +200,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
 extern int
 __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);
 extern void
-__clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq);
+__clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq);
 
 /*
  * Don't call this unless you are a default clocksource
@@ -221,14 +221,14 @@ static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
 	return __clocksource_register_scale(cs, 1000, khz);
 }
 
-static inline void __clocksource_updatefreq_hz(struct clocksource *cs, u32 hz)
+static inline void __clocksource_update_freq_hz(struct clocksource *cs, u32 hz)
 {
-	__clocksource_updatefreq_scale(cs, 1, hz);
+	__clocksource_update_freq_scale(cs, 1, hz);
 }
 
-static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
+static inline void __clocksource_update_freq_khz(struct clocksource *cs, u32 khz)
 {
-	__clocksource_updatefreq_scale(cs, 1000, khz);
+	__clocksource_update_freq_scale(cs, 1000, khz);
 }
 
 

commit f8935983f110505daa38e8d36ee406807f83a069
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:37 2015 -0700

    clocksource: Mostly kill clocksource_register()
    
    A long running project has been to clean up remaining uses
    of clocksource_register(), replacing it with the simpler
    clocksource_register_khz/hz() functions.
    
    However, there are a few cases where we need to self-define
    our mult/shift values, so switch the function to a more
    obviously internal __clocksource_register() name, and
    consolidate much of the internal logic so we don't have
    duplication.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-10-git-send-email-john.stultz@linaro.org
    [ Minor cleanups. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 16d048cadebb..bd98eaa4d005 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -179,7 +179,6 @@ static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 }
 
 
-extern int clocksource_register(struct clocksource*);
 extern int clocksource_unregister(struct clocksource*);
 extern void clocksource_touch_watchdog(void);
 extern struct clocksource* clocksource_get_next(void);
@@ -203,6 +202,15 @@ __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);
 extern void
 __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq);
 
+/*
+ * Don't call this unless you are a default clocksource
+ * (AKA: jiffies) and absolutely have to.
+ */
+static inline int __clocksource_register(struct clocksource *cs)
+{
+	return __clocksource_register_scale(cs, 1, 0);
+}
+
 static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
 {
 	return __clocksource_register_scale(cs, 1, hz);

commit fb82fe2fe8588745edd73aa3a6229facac5c1e15
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:31 2015 -0700

    clocksource: Add 'max_cycles' to 'struct clocksource'
    
    In order to facilitate clocksource validation, add a
    'max_cycles' field to the clocksource structure which
    will hold the maximum cycle value that can safely be
    multiplied without potentially causing an overflow.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-4-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 9c78d15d33e4..16d048cadebb 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -56,6 +56,7 @@ struct module;
  * @shift:		cycle to nanosecond divisor (power of two)
  * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
  * @maxadj:		maximum adjustment value to mult (~11%)
+ * @max_cycles:		maximum safe cycle value which won't overflow on multiplication
  * @flags:		flags describing special properties
  * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
@@ -76,7 +77,7 @@ struct clocksource {
 #ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif
-
+	u64 max_cycles;
 	const char *name;
 	struct list_head list;
 	int rating;
@@ -189,7 +190,7 @@ extern struct clocksource * __init clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
 extern u64
-clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask);
+clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cycles);
 extern void
 clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
 

commit 74d23cc704d19732e70ef1579a669f7d5f09dd9a
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sun Dec 21 19:46:56 2014 +0100

    time: move the timecounter/cyclecounter code into its own file.
    
    The timecounter code has almost nothing to do with the clocksource
    code. Let it live in its own file. This will help isolate the
    timecounter users from the clocksource users in the source tree.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index abcafaa20b86..9c78d15d33e4 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -18,8 +18,6 @@
 #include <asm/div64.h>
 #include <asm/io.h>
 
-/* clocksource cycle base type */
-typedef u64 cycle_t;
 struct clocksource;
 struct module;
 
@@ -27,106 +25,6 @@ struct module;
 #include <asm/clocksource.h>
 #endif
 
-/**
- * struct cyclecounter - hardware abstraction for a free running counter
- *	Provides completely state-free accessors to the underlying hardware.
- *	Depending on which hardware it reads, the cycle counter may wrap
- *	around quickly. Locking rules (if necessary) have to be defined
- *	by the implementor and user of specific instances of this API.
- *
- * @read:		returns the current cycle value
- * @mask:		bitmask for two's complement
- *			subtraction of non 64 bit counters,
- *			see CLOCKSOURCE_MASK() helper macro
- * @mult:		cycle to nanosecond multiplier
- * @shift:		cycle to nanosecond divisor (power of two)
- */
-struct cyclecounter {
-	cycle_t (*read)(const struct cyclecounter *cc);
-	cycle_t mask;
-	u32 mult;
-	u32 shift;
-};
-
-/**
- * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds
- *	Contains the state needed by timecounter_read() to detect
- *	cycle counter wrap around. Initialize with
- *	timecounter_init(). Also used to convert cycle counts into the
- *	corresponding nanosecond counts with timecounter_cyc2time(). Users
- *	of this code are responsible for initializing the underlying
- *	cycle counter hardware, locking issues and reading the time
- *	more often than the cycle counter wraps around. The nanosecond
- *	counter will only wrap around after ~585 years.
- *
- * @cc:			the cycle counter used by this instance
- * @cycle_last:		most recent cycle counter value seen by
- *			timecounter_read()
- * @nsec:		continuously increasing count
- */
-struct timecounter {
-	const struct cyclecounter *cc;
-	cycle_t cycle_last;
-	u64 nsec;
-};
-
-/**
- * cyclecounter_cyc2ns - converts cycle counter cycles to nanoseconds
- * @cc:		Pointer to cycle counter.
- * @cycles:	Cycles
- *
- * XXX - This could use some mult_lxl_ll() asm optimization. Same code
- * as in cyc2ns, but with unsigned result.
- */
-static inline u64 cyclecounter_cyc2ns(const struct cyclecounter *cc,
-				      cycle_t cycles)
-{
-	u64 ret = (u64)cycles;
-	ret = (ret * cc->mult) >> cc->shift;
-	return ret;
-}
-
-/**
- * timecounter_init - initialize a time counter
- * @tc:			Pointer to time counter which is to be initialized/reset
- * @cc:			A cycle counter, ready to be used.
- * @start_tstamp:	Arbitrary initial time stamp.
- *
- * After this call the current cycle register (roughly) corresponds to
- * the initial time stamp. Every call to timecounter_read() increments
- * the time stamp counter by the number of elapsed nanoseconds.
- */
-extern void timecounter_init(struct timecounter *tc,
-			     const struct cyclecounter *cc,
-			     u64 start_tstamp);
-
-/**
- * timecounter_read - return nanoseconds elapsed since timecounter_init()
- *                    plus the initial time stamp
- * @tc:          Pointer to time counter.
- *
- * In other words, keeps track of time since the same epoch as
- * the function which generated the initial time stamp.
- */
-extern u64 timecounter_read(struct timecounter *tc);
-
-/**
- * timecounter_cyc2time - convert a cycle counter to same
- *                        time base as values returned by
- *                        timecounter_read()
- * @tc:		Pointer to time counter.
- * @cycle_tstamp:	a value returned by tc->cc->read()
- *
- * Cycle counts that are converted correctly as long as they
- * fall into the interval [-1/2 max cycle count, +1/2 max cycle count],
- * with "max cycle count" == cs->mask+1.
- *
- * This allows conversion of cycle counter values which were generated
- * in the past.
- */
-extern u64 timecounter_cyc2time(struct timecounter *tc,
-				cycle_t cycle_tstamp);
-
 /**
  * struct clocksource - hardware abstraction for a free running counter
  *	Provides mostly state-free accessors to the underlying hardware.

commit 96a2adbc6f501996418da9f7afe39bf0e4d006a9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 13 18:59:09 2014 -0600

    clocksource: Remove "weak" from clocksource_default_clock() declaration
    
    kernel/time/jiffies.c provides a default clocksource_default_clock()
    definition explicitly marked "weak".  arch/s390 provides its own definition
    intended to override the default, but the "weak" attribute on the
    declaration applied to the s390 definition as well, so the linker chose one
    based on link order (see 10629d711ed7 ("PCI: Remove __weak annotation from
    pcibios_get_phb_of_node decl")).
    
    Remove the "weak" attribute from the clocksource_default_clock()
    declaration so we always prefer a non-weak definition over the weak one,
    independent of link order.
    
    Fixes: f1b82746c1e9 ("clocksource: Cleanup clocksource selection")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    CC: Daniel Lezcano <daniel.lezcano@linaro.org>
    CC: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 653f0e2b6ca9..abcafaa20b86 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -287,7 +287,7 @@ extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_suspend(void);
 extern void clocksource_resume(void);
-extern struct clocksource * __init __weak clocksource_default_clock(void);
+extern struct clocksource * __init clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
 extern u64

commit 4a0e637738f06673725792d74eed67f8779b62c7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:05:13 2014 +0000

    clocksource: Get rid of cycle_last
    
    cycle_last was added to the clocksource to support the TSC
    validation. We moved that to the core code, so we can get rid of the
    extra copy.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a16b497d5159..653f0e2b6ca9 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -162,7 +162,6 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
- * @cycle_last:		most recent cycle counter value seen by ::read()
  * @owner:		module reference, must be set by clocksource in modules
  */
 struct clocksource {
@@ -171,7 +170,6 @@ struct clocksource {
 	 * clocksource itself is cacheline aligned.
 	 */
 	cycle_t (*read)(struct clocksource *cs);
-	cycle_t cycle_last;
 	cycle_t mask;
 	u32 mult;
 	u32 shift;

commit 54196ccbe0ba1f268a646059473313589db35b01
Author: Rob Herring <robh@kernel.org>
Date:   Thu May 8 16:09:24 2014 -0500

    of: consolidate linker section OF match table declarations
    
    We now have several OF match tables using linker sections that are
    nearly the same definition. The only variation is the callback function
    prototype. Create a common define for creating linker section OF match
    table entries which each table declaration can use.
    
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 67301a405712..a16b497d5159 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -339,23 +339,13 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 
 extern int clocksource_i8253_init(void);
 
-struct device_node;
-typedef void(*clocksource_of_init_fn)(struct device_node *);
+#define CLOCKSOURCE_OF_DECLARE(name, compat, fn) \
+	OF_DECLARE_1(clksrc, name, compat, fn)
+
 #ifdef CONFIG_CLKSRC_OF
 extern void clocksource_of_init(void);
-
-#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)			\
-	static const struct of_device_id __clksrc_of_table_##name	\
-		__used __section(__clksrc_of_table)			\
-		 = { .compatible = compat,				\
-		     .data = (fn == (clocksource_of_init_fn)NULL) ? fn : fn }
 #else
 static inline void clocksource_of_init(void) {}
-#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)			\
-	static const struct of_device_id __clksrc_of_table_##name	\
-		__attribute__((unused))					\
-		 = { .compatible = compat,				\
-		     .data = (fn == (clocksource_of_init_fn)NULL) ? fn : fn }
 #endif
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 87d8b9eb7eb6669aad6435a51e9862362141ba76
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 18 16:21:14 2013 -0700

    clocksource: Extract max nsec calculation into separate function
    
    We need to calculate the same number in the clocksource code and
    the sched_clock code, so extract this code into its own function.
    We also drop the min_t and just use min() because the two types
    are the same.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index dbbf8aa7731b..67301a405712 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -292,6 +292,8 @@ extern void clocksource_resume(void);
 extern struct clocksource * __init __weak clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
+extern u64
+clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask);
 extern void
 clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
 

commit 332962f2c88868ed3cdab466870baaa34dd58612
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jul 4 22:46:45 2013 +0200

    clocksource: Reselect clocksource when watchdog validated high-res capability
    
    Up to commit 5d33b883a (clocksource: Always verify highres capability)
    we had no sanity check when selecting a clocksource, which prevented
    that a non highres capable clocksource is used when the system already
    switched to highres/nohz mode.
    
    The new sanity check works as Alex and Tim found out. It prevents the
    TSC from being used. This happens because on x86 the boot process
    looks like this:
    
     tsc_start_freqency_validation(TSC);
     clocksource_register(HPET);
     clocksource_done_booting();
            clocksource_select()
                    Selects HPET which is valid for high-res
    
     switch_to_highres();
    
     clocksource_register(TSC);
            TSC is not selected, because it is not yet
            flagged as VALID_HIGH_RES
    
     clocksource_watchdog()
            Validates TSC for highres, but that does not make TSC
            the current clocksource.
    
    Before the sanity check was added, we installed TSC unvalidated which
    worked most of the time. If the TSC was really detected as unstable,
    then the unstable logic removed it and installed HPET again.
    
    The sanity check is correct and needed. So the watchdog needs to kick
    a reselection of the clocksource, when it qualifies TSC as a valid
    high res clocksource.
    
    To solve this, we mark the clocksource which got the flag
    CLOCK_SOURCE_VALID_FOR_HRES set by the watchdog with an new flag
    CLOCK_SOURCE_RESELECT and trigger the watchdog thread. The watchdog
    thread evaluates the flag and invokes clocksource_select() when set.
    
    To avoid that the clocksource_done_booting() code, which is about to
    install the first real clocksource anyway, needs to go through
    clocksource_select and tick_oneshot_notify() pointlessly, split out
    the clocksource_watchdog_kthread() list walk code and invoke the
    select/notify only when called from clocksource_watchdog_kthread().
    
    So clocksource_done_booting() can utilize the same splitout code
    without the select/notify invocation and the clocksource_mutex
    unlock/relock dance.
    
    Reported-and-tested-by: Alex Shi <alex.shi@intel.com>
    Cc: Hans Peter Anvin <hpa@linux.intel.com>
    Cc: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: Andi Kleen <andi.kleen@intel.com>
    Tested-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Davidlohr Bueso <davidlohr.bueso@hp.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1307042239150.11637@ionos.tec.linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 2f39a4911668..dbbf8aa7731b 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -210,6 +210,7 @@ struct clocksource {
 #define CLOCK_SOURCE_VALID_FOR_HRES		0x20
 #define CLOCK_SOURCE_UNSTABLE			0x40
 #define CLOCK_SOURCE_SUSPEND_NONSTOP		0x80
+#define CLOCK_SOURCE_RESELECT			0x100
 
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)

commit a89c7edbe7d7aa80f507915f3dd801211b116b79
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:46 2013 +0000

    clocksource: Let clocksource_unregister() return success/error
    
    The unregister call can fail, if the clocksource is the current one
    and there is no replacement clocksource available. It can also fail,
    if the clocksource is the watchdog clocksource and I'm not going to
    provide support for this.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143436.029915527@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 32a895b114d8..2f39a4911668 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -282,7 +282,7 @@ static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 
 
 extern int clocksource_register(struct clocksource*);
-extern void clocksource_unregister(struct clocksource*);
+extern int clocksource_unregister(struct clocksource*);
 extern void clocksource_touch_watchdog(void);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);

commit 09ac369c825d9d593404306d59062d854b321e9b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:44 2013 +0000

    clocksource: Add module refcount
    
    Add a module refcount, so the current clocksource cannot be removed
    unconditionally.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143435.762417789@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index aa6ba44e75d5..32a895b114d8 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -21,6 +21,7 @@
 /* clocksource cycle base type */
 typedef u64 cycle_t;
 struct clocksource;
+struct module;
 
 #ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 #include <asm/clocksource.h>
@@ -162,6 +163,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
  * @cycle_last:		most recent cycle counter value seen by ::read()
+ * @owner:		module reference, must be set by clocksource in modules
  */
 struct clocksource {
 	/*
@@ -195,6 +197,7 @@ struct clocksource {
 	cycle_t cs_last;
 	cycle_t wd_last;
 #endif
+	struct module *owner;
 } ____cacheline_aligned;
 
 /*

commit ba919d1caa2e624eb8c6cae1f2ce0a253e697d45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 25 20:31:44 2013 +0000

    clocksource: Let timekeeping_notify return success/error
    
    timekeeping_notify() can fail due cs->enable() failure. Though the
    caller does not notice and happily keeps the wrong clocksource as the
    current one.
    
    Let the caller know about failure, so the current clocksource will be
    shown correctly in sysfs.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130425143435.696321912@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7279b94c01da..aa6ba44e75d5 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -321,7 +321,7 @@ static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
 }
 
 
-extern void timekeeping_notify(struct clocksource *clock);
+extern int timekeeping_notify(struct clocksource *clock);
 
 extern cycle_t clocksource_mmio_readl_up(struct clocksource *);
 extern cycle_t clocksource_mmio_readl_down(struct clocksource *);

commit a7726350e06401929eac0aa0677a5467106565fc
Merge: 4d26aa305414 afcf7924ecab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:03:55 2013 -0700

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanup from Olof Johansson:
     "Here is a collection of cleanup patches.  Among the pieces that stand
      out are:
    
       - The deletion of h720x platforms
       - Split of at91 non-dt platforms to their own Kconfig file to keep
         them separate
       - General cleanups and refactoring of i.MX and MXS platforms
       - Some restructuring of clock tables for OMAP
       - Convertion of PMC driver for Tegra to dt-only
       - Some renames of sunxi -> sun4i (Allwinner A10)
       - ... plus a bunch of other stuff that I haven't mentioned"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (119 commits)
      ARM: i.MX: remove unused ARCH_* configs
      ARM i.MX53: remove platform ahci support
      ARM: sunxi: Rework the restart code
      irqchip: sunxi: Rename sunxi to sun4i
      irqchip: sunxi: Make use of the IRQCHIP_DECLARE macro
      clocksource: sunxi: Rename sunxi to sun4i
      clocksource: sunxi: make use of CLKSRC_OF
      clocksource: sunxi: Cleanup the timer code
      ARM: at91: remove trailing semicolon from macros
      ARM: at91/setup: fix trivial typos
      ARM: EXYNOS: remove "config EXYNOS_DEV_DRM"
      ARM: EXYNOS: change the name of USB ohci header
      ARM: SAMSUNG: Remove unnecessary code for dma
      ARM: S3C24XX: Remove unused GPIO drive strength register definitions
      ARM: OMAP4+: PM: Restore CPU power state to ON with clockdomain force wakeup method
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2412
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2410
      ARM: S3C24XX: Removed unneeded dependency on ARCH_S3C24XX for boards
      ARM: SAMSUNG: Fix typo "CONFIG_SAMSUNG_DEV_RTC"
      ARM: S5P64X0: Fix typo "CONFIG_S5P64X0_SETUP_SDHCI"
      ...

commit 3d5a96582303e28c48699f3faaf920ef7d43e6f2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 19 15:38:50 2013 +0100

    clocksource: make CLOCKSOURCE_OF_DECLARE type safe
    
    This ensures that a function pointer passed into CLOCKSOURCE_OF_DECLARE
    takes the same arguments that we use for calling that function later.
    
    Also fix the extraneous semicolon at end of the CLOCKSOURCE_OF_DECLARE
    definition.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 08ed5e19d8c6..192d6d1771ee 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -332,16 +332,23 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 
 extern int clocksource_i8253_init(void);
 
+struct device_node;
+typedef void(*clocksource_of_init_fn)(struct device_node *);
 #ifdef CONFIG_CLKSRC_OF
 extern void clocksource_of_init(void);
 
 #define CLOCKSOURCE_OF_DECLARE(name, compat, fn)			\
 	static const struct of_device_id __clksrc_of_table_##name	\
 		__used __section(__clksrc_of_table)			\
-		 = { .compatible = compat, .data = fn };
+		 = { .compatible = compat,				\
+		     .data = (fn == (clocksource_of_init_fn)NULL) ? fn : fn }
 #else
 static inline void clocksource_of_init(void) {}
-#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)
+#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)			\
+	static const struct of_device_id __clksrc_of_table_##name	\
+		__attribute__((unused))					\
+		 = { .compatible = compat,				\
+		     .data = (fn == (clocksource_of_init_fn)NULL) ? fn : fn }
 #endif
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 5caf4636259ae3af0efbb9bfc4cd97874b547c7d
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue Mar 12 11:56:46 2013 +0800

    clocksource: Add new feature flag CLOCK_SOURCE_SUSPEND_NONSTOP
    
    Some x86 processors have a TSC clocksource, which continues to run
    even when system is suspended. Also most OMAP platforms have a
    32 KHz timer which has similar capability. Add a feature flag so that
    it could be utilized.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 27cfda427dd9..aa7032c7238f 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -206,6 +206,7 @@ struct clocksource {
 #define CLOCK_SOURCE_WATCHDOG			0x10
 #define CLOCK_SOURCE_VALID_FOR_HRES		0x20
 #define CLOCK_SOURCE_UNSTABLE			0x40
+#define CLOCK_SOURCE_SUSPEND_NONSTOP		0x80
 
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)

commit e0c25362384f4be9c755c98560cd4b1cdb2ec79c
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sun Mar 10 21:52:53 2013 -0500

    clocksource: add empty version of clocksource_of_init
    
    Add an empty clocksource_of_init when !CLKSRC_OF. This is needed for builds
    where no timer has selected CLKSRC_OF.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 27cfda427dd9..08ed5e19d8c6 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -340,6 +340,7 @@ extern void clocksource_of_init(void);
 		__used __section(__clksrc_of_table)			\
 		 = { .compatible = compat, .data = fn };
 #else
+static inline void clocksource_of_init(void) {}
 #define CLOCKSOURCE_OF_DECLARE(name, compat, fn)
 #endif
 

commit e1d7ef1cc472de30995a50ecb9c7aa3361f985f9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Jan 30 10:49:30 2013 -0700

    clocksource: always define CLOCKSOURCE_OF_DECLARE
    
    This allows clocksource drivers that support both DT and non-DT to
    always invoke macro CLOCKSOURCE_OF_DECLARE(), rather than wrapping
    it in a #ifdef CONFIG_CLKSRC_OF, which simplifies their code.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 7944f14ea947..27cfda427dd9 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -339,6 +339,8 @@ extern void clocksource_of_init(void);
 	static const struct of_device_id __clksrc_of_table_##name	\
 		__used __section(__clksrc_of_table)			\
 		 = { .compatible = compat, .data = fn };
+#else
+#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)
 #endif
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit ae278a935f086775e8ae31a8ec9f7224ea25ea3c
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Nov 19 16:41:20 2012 -0700

    clocksource: add common of_clksrc_init() function
    
    It is desirable to move all clocksource drivers to drivers/clocksource,
    yet each requires its own initialization function. We'd rather not
    pollute <linux/> with a header for each function. Instead, create a
    single of_clksrc_init() function which will determine which clocksource
    driver to initialize based on device tree.
    
    Based on a similar patch for drivers/irqchip by Thomas Petazzoni.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 4dceaf8ae152..7944f14ea947 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -332,4 +332,13 @@ extern int clocksource_mmio_init(void __iomem *, const char *,
 
 extern int clocksource_i8253_init(void);
 
+#ifdef CONFIG_CLKSRC_OF
+extern void clocksource_of_init(void);
+
+#define CLOCKSOURCE_OF_DECLARE(name, compat, fn)			\
+	static const struct of_device_id __clksrc_of_table_##name	\
+		__used __section(__clksrc_of_table)			\
+		 = { .compatible = compat, .data = fn };
+#endif
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 189374aed657e2228ad6b39ece438c9cdafc8dae
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Sep 4 15:27:48 2012 -0400

    time: Move update_vsyscall definitions to timekeeper_internal.h
    
    Since users will need to include timekeeper_internal.h, move
    update_vsyscall definitions to timekeeper_internal.h.
    
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Turner <pjt@google.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index fbe89e17124e..4dceaf8ae152 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -319,22 +319,6 @@ static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
 	__clocksource_updatefreq_scale(cs, 1000, khz);
 }
 
-#ifdef CONFIG_GENERIC_TIME_VSYSCALL
-extern void
-update_vsyscall(struct timespec *ts, struct timespec *wtm,
-			struct clocksource *c, u32 mult);
-extern void update_vsyscall_tz(void);
-#else
-static inline void
-update_vsyscall(struct timespec *ts, struct timespec *wtm,
-			struct clocksource *c, u32 mult)
-{
-}
-
-static inline void update_vsyscall_tz(void)
-{
-}
-#endif
 
 extern void timekeeping_notify(struct clocksource *clock);
 

commit c7f798e3722610d486e951f04bbc00b6ba124d62
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Thu Dec 1 11:25:59 2011 -0800

    clocksource: Get rid of clocksource_calc_mult_shift()
    
    No one is using this, so encourage the use of
    clocksource_register_hz/khz(), and drop this helper.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    [jstultz: tweaked commit message]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 081147da0564..fbe89e17124e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -319,13 +319,6 @@ static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
 	__clocksource_updatefreq_scale(cs, 1000, khz);
 }
 
-static inline void
-clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)
-{
-	return clocks_calc_mult_shift(&cs->mult, &cs->shift, freq,
-				      NSEC_PER_SEC, minsec);
-}
-
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void
 update_vsyscall(struct timespec *ts, struct timespec *wtm,

commit b1b73d095084e754562961c443aa8f6587a55f8e
Author: Kusanagi Kouichi <slash@ac.auone-net.jp>
Date:   Mon Dec 19 18:13:19 2011 +0900

    time/clocksource: Fix kernel-doc warnings
    
    Fix various KernelDoc build warnings.
    
    Signed-off-by: Kusanagi Kouichi <slash@ac.auone-net.jp>
    Cc: John Stultz <johnstul@us.ibm.com>
    Link: http://lkml.kernel.org/r/20111219091320.0D5AF6FC03D@msa105.auone-net.jp
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c86c940d1de3..081147da0564 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -71,7 +71,7 @@ struct timecounter {
 
 /**
  * cyclecounter_cyc2ns - converts cycle counter cycles to nanoseconds
- * @tc:		Pointer to cycle counter.
+ * @cc:		Pointer to cycle counter.
  * @cycles:	Cycles
  *
  * XXX - This could use some mult_lxl_ll() asm optimization. Same code
@@ -114,7 +114,7 @@ extern u64 timecounter_read(struct timecounter *tc);
  *                        time base as values returned by
  *                        timecounter_read()
  * @tc:		Pointer to time counter.
- * @cycle:	a value returned by tc->cc->read()
+ * @cycle_tstamp:	a value returned by tc->cc->read()
  *
  * Cycle counts that are converted correctly as long as they
  * fall into the interval [-1/2 max cycle count, +1/2 max cycle count],
@@ -156,11 +156,12 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
- * @maxadj		maximum adjustment value to mult (~11%)
+ * @maxadj:		maximum adjustment value to mult (~11%)
  * @flags:		flags describing special properties
  * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
+ * @cycle_last:		most recent cycle counter value seen by ::read()
  */
 struct clocksource {
 	/*
@@ -187,6 +188,7 @@ struct clocksource {
 	void (*suspend)(struct clocksource *cs);
 	void (*resume)(struct clocksource *cs);
 
+	/* private: */
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
 	struct list_head wd_list;
@@ -261,6 +263,9 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 
 /**
  * clocksource_cyc2ns - converts clocksource cycles to nanoseconds
+ * @cycles:	cycles
+ * @mult:	cycle to nanosecond multiplier
+ * @shift:	cycle to nanosecond divisor (power of two)
  *
  * Converts cycles to nanoseconds, using the given mult and shift.
  *

commit d65670a78cdbfae94f20a9e05ec705871d7cdf2b
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Oct 31 17:06:35 2011 -0400

    clocksource: Avoid selecting mult values that might overflow when adjusted
    
    For some frequencies, the clocks_calc_mult_shift() function will
    unfortunately select mult values very close to 0xffffffff.  This
    has the potential to overflow when NTP adjusts the clock, adding
    to the mult value.
    
    This patch adds a clocksource.maxadj value, which provides
    an approximation of an 11% adjustment(NTP limits adjustments to
    500ppm and the tick adjustment is limited to 10%), which could
    be made to the clocksource.mult value. This is then used to both
    check that the current mult value won't overflow/underflow, as
    well as warning us if the timekeeping_adjust() code pushes over
    that 11% boundary.
    
    v2: Fix max_adjustment calculation, and improve WARN_ONCE
    messages.
    
    v3: Don't warn before maxadj has actually been set
    
    CC: Yong Zhang <yong.zhang0@gmail.com>
    CC: David Daney <ddaney.cavm@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Chen Jie <chenj@lemote.com>
    CC: zhangfx <zhangfx@lemote.com>
    CC: stable@kernel.org
    Reported-by: Chen Jie <chenj@lemote.com>
    Reported-by: zhangfx <zhangfx@lemote.com>
    Tested-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 139c4db55f17..c86c940d1de3 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -156,6 +156,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
+ * @maxadj		maximum adjustment value to mult (~11%)
  * @flags:		flags describing special properties
  * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
@@ -172,7 +173,7 @@ struct clocksource {
 	u32 mult;
 	u32 shift;
 	u64 max_idle_ns;
-
+	u32 maxadj;
 #ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif

commit 8e204874db000928e37199c2db82b7eb8966cc3c
Merge: 3e0b8df79ddb aafade242ff2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 22 17:05:15 2011 -0700

    Merge branch 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-vdso-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86-64, vdso: Do not allocate memory for the vDSO
      clocksource: Change __ARCH_HAS_CLOCKSOURCE_DATA to a CONFIG option
      x86, vdso: Drop now wrong comment
      Document the vDSO and add a reference parser
      ia64: Replace clocksource.fsys_mmio with generic arch data
      x86-64: Move vread_tsc and vread_hpet into the vDSO
      clocksource: Replace vread with generic arch data
      x86-64: Add --no-undefined to vDSO build
      x86-64: Allow alternative patching in the vDSO
      x86: Make alternative instruction pointers relative
      x86-64: Improve vsyscall emulation CS and RIP handling
      x86-64: Emulate legacy vsyscalls
      x86-64: Fill unused parts of the vsyscall page with 0xcc
      x86-64: Remove vsyscall number 3 (venosys)
      x86-64: Map the HPET NX
      x86-64: Remove kernel.vsyscall64 sysctl
      x86-64: Give vvars their own page
      x86-64: Document some of entry_64.S
      x86-64: Fix alignment of jiffies variable

commit ae7bd11b471931752e5609094ca0a49386590524
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Thu Jul 21 13:34:05 2011 -0700

    clocksource: Change __ARCH_HAS_CLOCKSOURCE_DATA to a CONFIG option
    
    The machinery for __ARCH_HAS_CLOCKSOURCE_DATA assumed a file in
    asm-generic would be the default for architectures without their own
    file in asm/, but that is not how it works.
    
    Replace it with a Kconfig option instead.
    
    Link: http://lkml.kernel.org/r/4E288AA6.7090804@zytor.com
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@mit.edu>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 6bb69702c4fa..59ee970cf89e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -22,7 +22,9 @@
 typedef u64 cycle_t;
 struct clocksource;
 
+#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 #include <asm/clocksource.h>
+#endif
 
 /**
  * struct cyclecounter - hardware abstraction for a free running counter
@@ -171,7 +173,7 @@ struct clocksource {
 	u32 shift;
 	u64 max_idle_ns;
 
-#ifdef __ARCH_HAS_CLOCKSOURCE_DATA
+#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif
 

commit 574c44fa8fa6262ffd5939789ef51a6e98ed62d7
Author: Andy Lutomirski <luto@mit.edu>
Date:   Wed Jul 13 09:24:15 2011 -0400

    ia64: Replace clocksource.fsys_mmio with generic arch data
    
    Now that clocksource.archdata is available, use it for ia64-specific
    code.
    
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: linux-ia64@vger.kernel.org
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Link: http://lkml.kernel.org/r/d31de0ee0842a0e322fb6441571c2b0adb323fa2.1310563276.git.luto@mit.edu
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 0fb83c224471..6bb69702c4fa 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -171,13 +171,6 @@ struct clocksource {
 	u32 shift;
 	u64 max_idle_ns;
 
-#ifdef CONFIG_IA64
-	void *fsys_mmio;        /* used by fsyscall asm code */
-#define CLKSRC_FSYS_MMIO_SET(mmio, addr)      ((mmio) = (addr))
-#else
-#define CLKSRC_FSYS_MMIO_SET(mmio, addr)      do { } while (0)
-#endif
-
 #ifdef __ARCH_HAS_CLOCKSOURCE_DATA
 	struct arch_clocksource_data archdata;
 #endif

commit 433bd805e5fd2c731b3a9025b034f066272d336e
Author: Andy Lutomirski <luto@mit.edu>
Date:   Wed Jul 13 09:24:13 2011 -0400

    clocksource: Replace vread with generic arch data
    
    The vread field was bloating struct clocksource everywhere except
    x86_64, and I want to change the way this works on x86_64, so let's
    split it out into per-arch data.
    
    Cc: x86@kernel.org
    Cc: Clemens Ladisch <clemens@ladisch.de>
    Cc: linux-ia64@vger.kernel.org
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andy Lutomirski <luto@mit.edu>
    Link: http://lkml.kernel.org/r/3ae5ec76a168eaaae63f08a2a1060b91aa0b7759.1310563276.git.luto@mit.edu
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index d4646b48dc4a..0fb83c224471 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -22,6 +22,8 @@
 typedef u64 cycle_t;
 struct clocksource;
 
+#include <asm/clocksource.h>
+
 /**
  * struct cyclecounter - hardware abstraction for a free running counter
  *	Provides completely state-free accessors to the underlying hardware.
@@ -153,7 +155,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @shift:		cycle to nanosecond divisor (power of two)
  * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
  * @flags:		flags describing special properties
- * @vread:		vsyscall based read
+ * @archdata:		arch-specific data
  * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
  */
@@ -175,10 +177,14 @@ struct clocksource {
 #else
 #define CLKSRC_FSYS_MMIO_SET(mmio, addr)      do { } while (0)
 #endif
+
+#ifdef __ARCH_HAS_CLOCKSOURCE_DATA
+	struct arch_clocksource_data archdata;
+#endif
+
 	const char *name;
 	struct list_head list;
 	int rating;
-	cycle_t (*vread)(void);
 	int (*enable)(struct clocksource *cs);
 	void (*disable)(struct clocksource *cs);
 	unsigned long flags;

commit b5199515c25cca622495eb9c6a8a1d275e775088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jun 16 16:22:08 2011 +0200

    clocksource: Make watchdog robust vs. interruption
    
    The clocksource watchdog code is interruptible and it has been
    observed that this can trigger false positives which disable the TSC.
    
    The reason is that an interrupt storm or a long running interrupt
    handler between the read of the watchdog source and the read of the
    TSC brings the two far enough apart that the delta is larger than the
    unstable treshold. Move both reads into a short interrupt disabled
    region to avoid that.
    
    Reported-and-tested-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@kernel.org

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index d4646b48dc4a..18a1baf31f2d 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -188,6 +188,7 @@ struct clocksource {
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
 	struct list_head wd_list;
+	cycle_t cs_last;
 	cycle_t wd_last;
 #endif
 } ____cacheline_aligned;

commit 442c8176d2efa468577738e3a99a6e051f6e8e55
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 14:06:52 2011 +0100

    clocksource: add common mmio clocksource
    
    Add a generic mmio clocksource, covering both 32-bit and 16-bit register
    access sizes, for up or down counters.  This can be used to easily
    create clocksources for simple counter-based implementations.
    
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: Colin Cross <ccross@android.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Erik Gilling <konkers@android.com>
    Acked-by: "Hans J. Koch" <hjk@hansjkoch.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: linux-omap@vger.kernel.org
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Cc: Olof Johansson <olof@lixom.net>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c918fbd33ee5..d4646b48dc4a 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -337,6 +337,14 @@ static inline void update_vsyscall_tz(void)
 
 extern void timekeeping_notify(struct clocksource *clock);
 
+extern cycle_t clocksource_mmio_readl_up(struct clocksource *);
+extern cycle_t clocksource_mmio_readl_down(struct clocksource *);
+extern cycle_t clocksource_mmio_readw_up(struct clocksource *);
+extern cycle_t clocksource_mmio_readw_down(struct clocksource *);
+
+extern int clocksource_mmio_init(void __iomem *, const char *,
+	unsigned long, int, unsigned, cycle_t (*)(struct clocksource *));
+
 extern int clocksource_i8253_init(void);
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 369db4c9524b7487faf1ff89646eee396c1363e1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 18 21:33:40 2011 +0000

    clocksource: Restructure clocksource struct members
    
    Group the hot path members of struct clocksource together so we have a
    better cache line footprint. Make it cacheline aligned.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Link: http://lkml.kernel.org/r/%3C20110518210136.003081882%40linutronix.de%3E

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 0fb0b7e79394..c918fbd33ee5 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -159,42 +159,38 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  */
 struct clocksource {
 	/*
-	 * First part of structure is read mostly
+	 * Hotpath data, fits in a single cache line when the
+	 * clocksource itself is cacheline aligned.
 	 */
-	const char *name;
-	struct list_head list;
-	int rating;
 	cycle_t (*read)(struct clocksource *cs);
-	int (*enable)(struct clocksource *cs);
-	void (*disable)(struct clocksource *cs);
+	cycle_t cycle_last;
 	cycle_t mask;
 	u32 mult;
 	u32 shift;
 	u64 max_idle_ns;
-	unsigned long flags;
-	cycle_t (*vread)(void);
-	void (*suspend)(struct clocksource *cs);
-	void (*resume)(struct clocksource *cs);
+
 #ifdef CONFIG_IA64
 	void *fsys_mmio;        /* used by fsyscall asm code */
 #define CLKSRC_FSYS_MMIO_SET(mmio, addr)      ((mmio) = (addr))
 #else
 #define CLKSRC_FSYS_MMIO_SET(mmio, addr)      do { } while (0)
 #endif
-
-	/*
-	 * Second part is written at each timer interrupt
-	 * Keep it in a different cache line to dirty no
-	 * more than one cache line.
-	 */
-	cycle_t cycle_last ____cacheline_aligned_in_smp;
+	const char *name;
+	struct list_head list;
+	int rating;
+	cycle_t (*vread)(void);
+	int (*enable)(struct clocksource *cs);
+	void (*disable)(struct clocksource *cs);
+	unsigned long flags;
+	void (*suspend)(struct clocksource *cs);
+	void (*resume)(struct clocksource *cs);
 
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
 	struct list_head wd_list;
 	cycle_t wd_last;
 #endif
-};
+} ____cacheline_aligned;
 
 /*
  * Clock source flags bits::

commit a18f22a968de17b29f2310cdb7ba69163e65ec15
Merge: a1c57e0fec53 798778b8653f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat May 14 12:06:36 2011 +0200

    Merge branch 'consolidate-clksrc-i8253' of master.kernel.org:~rmk/linux-2.6-arm into timers/clocksource
    
    Conflicts:
            arch/ia64/kernel/cyclone.c
            arch/mips/kernel/i8253.c
            arch/x86/kernel/i8253.c
    
    Reason: Resolve conflicts so further cleanups do not conflict further
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit 8c414ff3f4dcdde228c6a668385218290d73a265
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 18:50:20 2011 +0100

    clocksource: convert footbridge to generic i8253 clocksource
    
    Convert the footbridge isa-timer code to use generic i8253 clocksource.
    
    Acked-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c37b21ad5a3b..f13469b3df86 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -341,4 +341,6 @@ static inline void update_vsyscall_tz(void)
 
 extern void timekeeping_notify(struct clocksource *clock);
 
+extern int clocksource_i8253_init(void);
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 36d8593ec74dc04d3bd7c1c897a7b7cfbd0b0dc6
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Sat Feb 19 15:34:50 2011 +0000

    Make clocksource name const
    
    As nothing should be writing to the clocksource name string, make the
    clocksource name pointer const.  Build-tested on ARM Versatile Express.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c37b21ad5a3b..94c1f38e922a 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -161,7 +161,7 @@ struct clocksource {
 	/*
 	 * First part of structure is read mostly
 	 */
-	char *name;
+	const char *name;
 	struct list_head list;
 	int rating;
 	cycle_t (*read)(struct clocksource *cs);

commit 852db46d55e85b475a72e665ca08d3317769ceef
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:28 2010 -0700

    clocksource: Add __clocksource_updatefreq_hz/khz methods
    
    To properly handle clocksources that change frequencies
    at the clocksource->enable() point, this patch adds
    a method that will update the clocksource's mult/shift and
    max_idle_ns values.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1279068988-21864-12-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 21677d99a161..c37b21ad5a3b 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -292,6 +292,8 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
  */
 extern int
 __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);
+extern void
+__clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq);
 
 static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
 {
@@ -303,6 +305,15 @@ static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
 	return __clocksource_register_scale(cs, 1000, khz);
 }
 
+static inline void __clocksource_updatefreq_hz(struct clocksource *cs, u32 hz)
+{
+	__clocksource_updatefreq_scale(cs, 1, hz);
+}
+
+static inline void __clocksource_updatefreq_khz(struct clocksource *cs, u32 khz)
+{
+	__clocksource_updatefreq_scale(cs, 1000, khz);
+}
 
 static inline void
 clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)

commit 7615856ebfee52b080c22d263ca4debbd0df0ac1
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:23 2010 -0700

    timkeeping: Fix update_vsyscall to provide wall_to_monotonic offset
    
    update_vsyscall() did not provide the wall_to_monotoinc offset,
    so arch specific implementations tend to reference wall_to_monotonic
    directly. This limits future cleanups in the timekeeping core, so
    this patch fixes the update_vsyscall interface to provide
    wall_to_monotonic, allowing wall_to_monotonic to be made static
    as planned in Documentation/feature-removal-schedule.txt
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Tony Luck <tony.luck@intel.com>
    LKML-Reference: <1279068988-21864-7-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 5ea3c60c160c..21677d99a161 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -313,11 +313,13 @@ clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void
-update_vsyscall(struct timespec *ts, struct clocksource *c, u32 mult);
+update_vsyscall(struct timespec *ts, struct timespec *wtm,
+			struct clocksource *c, u32 mult);
 extern void update_vsyscall_tz(void);
 #else
 static inline void
-update_vsyscall(struct timespec *ts, struct clocksource *c, u32 mult)
+update_vsyscall(struct timespec *ts, struct timespec *wtm,
+			struct clocksource *c, u32 mult)
 {
 }
 

commit d7e81c269db899b800e0963dc4aceece1f82a680
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri May 7 18:07:38 2010 -0700

    clocksource: Add clocksource_register_hz/khz interface
    
    How to pick good mult/shift pairs has always been difficult to
    describe to folks writing clocksource drivers, since it requires
    careful tradeoffs in adjustment accuracy vs overflow limits.
    
    Now, with the clocks_calc_mult_shift function, its much
    easier. However, not many clocksources have converted to using that
    function, and there is still the issue of the max interval length
    assumption being made by each clocksource driver independently.
    
    So this patch simplifies the registration process by having
    clocksources be registered with a hz/khz value and the registration
    function taking care of setting mult/shift.
    
    This should take most of the confusion out of writing a clocksource
    driver.
    
    Additionally it also keeps the shift size tradeoff (more accuracy vs
    longer possible nohz times) centralized so the timekeeping core can
    keep track of the assumptions being made.
    
    [ tglx: Coding style and comments fixed ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1273280858-30143-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 4bca8b60cdf7..5ea3c60c160c 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -273,7 +273,6 @@ static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 }
 
 
-/* used to install a new clocksource */
 extern int clocksource_register(struct clocksource*);
 extern void clocksource_unregister(struct clocksource*);
 extern void clocksource_touch_watchdog(void);
@@ -287,6 +286,24 @@ extern void clocksource_mark_unstable(struct clocksource *cs);
 extern void
 clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
 
+/*
+ * Don't call __clocksource_register_scale directly, use
+ * clocksource_register_hz/khz
+ */
+extern int
+__clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq);
+
+static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
+{
+	return __clocksource_register_scale(cs, 1, hz);
+}
+
+static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
+{
+	return __clocksource_register_scale(cs, 1000, khz);
+}
+
+
 static inline void
 clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)
 {

commit c54a42b19fbaae4e9f212322ecca25a6bc95c1ba
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Feb 2 14:41:41 2010 -0800

    clocksource: add suspend callback
    
    Add a clocksource suspend callback.  This callback can be used by the
    clocksource driver to shutdown and perform any kind of late suspend
    activities even though the clocksource driver itself is a non-sysdev
    driver.
    
    One example where this is useful is to fix the sh_cmt.c platform driver
    that today suspends using the platform bus and shuts down the clocksource
    too early.
    
    With this callback in place the sh_cmt driver will suspend using the
    clocksource and clockevent hooks and leave the platform device pm
    callbacks unused.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 0de7e72c3995..4bca8b60cdf7 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -154,6 +154,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
+ * @suspend:		suspend function for the clocksource, if necessary
  * @resume:		resume function for the clocksource, if necessary
  */
 struct clocksource {
@@ -172,6 +173,7 @@ struct clocksource {
 	u64 max_idle_ns;
 	unsigned long flags;
 	cycle_t (*vread)(void);
+	void (*suspend)(struct clocksource *cs);
 	void (*resume)(struct clocksource *cs);
 #ifdef CONFIG_IA64
 	void *fsys_mmio;        /* used by fsyscall asm code */
@@ -277,6 +279,7 @@ extern void clocksource_unregister(struct clocksource*);
 extern void clocksource_touch_watchdog(void);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
+extern void clocksource_suspend(void);
 extern void clocksource_resume(void);
 extern struct clocksource * __init __weak clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);

commit 17622339af2536b32cf29699ddd4ba0fe79a61d5
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Feb 2 14:41:39 2010 -0800

    clocksource: add argument to resume callback
    
    Pass the clocksource as an argument to the clocksource resume callback.
    Needed so we can point out which CMT channel the sh_cmt.c driver shall
    resume.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 8a4a130cc196..0de7e72c3995 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -172,7 +172,7 @@ struct clocksource {
 	u64 max_idle_ns;
 	unsigned long flags;
 	cycle_t (*vread)(void);
-	void (*resume)(void);
+	void (*resume)(struct clocksource *cs);
 #ifdef CONFIG_IA64
 	void *fsys_mmio;        /* used by fsyscall asm code */
 #define CLKSRC_FSYS_MMIO_SET(mmio, addr)      ((mmio) = (addr))

commit fbf07eac7bf21c262143194181bd97c5d18b8ceb
Merge: 60d8ce2cd6c2 8629ea2eaba8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 8 19:28:09 2009 -0800

    Merge branch 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'timers-for-linus-urgent' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      hrtimer: Fix /proc/timer_list regression
      itimers: Fix racy writes to cpu_itimer fields
      timekeeping: Fix clock_gettime vsyscall time warp

commit 0696b711e4be45fa104c12329f617beb29c03f78
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Nov 17 13:49:50 2009 +0800

    timekeeping: Fix clock_gettime vsyscall time warp
    
    Since commit 0a544198 "timekeeping: Move NTP adjusted clock multiplier
    to struct timekeeper" the clock multiplier of vsyscall is updated with
    the unmodified clock multiplier of the clock source and not with the
    NTP adjusted multiplier of the timekeeper.
    
    This causes user space observerable time warps:
    new CLOCK-warp maximum: 120 nsecs,  00000025c337c537 -> 00000025c337c4bf
    
    Add a new argument "mult" to update_vsyscall() and hand in the
    timekeeping internal NTP adjusted multiplier.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Cc: "Zhang Yanmin" <yanmin_zhang@linux.intel.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Tony Luck <tony.luck@intel.com>
    LKML-Reference: <1258436990.17765.83.camel@minggr.sh.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 83d2fbd81b93..95e4995d9987 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -280,10 +280,12 @@ extern struct clocksource * __init __weak clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
-extern void update_vsyscall(struct timespec *ts, struct clocksource *c);
+extern void
+update_vsyscall(struct timespec *ts, struct clocksource *c, u32 mult);
 extern void update_vsyscall_tz(void);
 #else
-static inline void update_vsyscall(struct timespec *ts, struct clocksource *c)
+static inline void
+update_vsyscall(struct timespec *ts, struct clocksource *c, u32 mult)
 {
 }
 

commit 98962465ed9e6ea99c38e0af63fe1dcb5a79dc25
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Aug 18 12:45:10 2009 -0500

    nohz: Prevent clocksource wrapping during idle
    
    The dynamic tick allows the kernel to sleep for periods longer than a
    single tick, but it does not limit the sleep time currently. In the
    worst case the kernel could sleep longer than the wrap around time of
    the time keeping clock source which would result in losing track of
    time.
    
    Prevent this by limiting it to the safe maximum sleep time of the
    current time keeping clock source. The value is calculated when the
    clock source is registered.
    
    [ tglx: simplified the code a bit and massaged the commit msg ]
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1250617512-23567-2-git-send-email-jon-hunter@ti.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f57f88250526..279c5478e8a6 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -151,6 +151,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
+ * @max_idle_ns:	max idle time permitted by the clocksource (nsecs)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
  * @resume:		resume function for the clocksource, if necessary
@@ -168,6 +169,7 @@ struct clocksource {
 	cycle_t mask;
 	u32 mult;
 	u32 shift;
+	u64 max_idle_ns;
 	unsigned long flags;
 	cycle_t (*vread)(void);
 	void (*resume)(void);

commit 7d2f944a2b836c69a9d260a0a5f0d1720d57fdff
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Nov 11 14:05:29 2009 +0000

    clocksource: Provide a generic mult/shift factor calculation
    
    MIPS has two functions to calculcate the mult/shift factors for clock
    sources and clock events at run time. ARM needs such functions as
    well.
    
    Implement a function which calculates the mult/shift factors based on
    the frequencies to which and from which is converted. The function
    also has a parameter to specify the minimum conversion range in
    seconds. This range is guaranteed not to produce a 64bit overflow when
    a value is multiplied with the calculated mult factor. The larger the
    conversion range the less becomes the conversion accuracy.
    
    Provide two inline wrappers which handle clock events and clock
    sources. For clock events the "from" frequency is nano seconds per
    second which corresponds to 1GHz and "to" is the device frequency. For
    clock sources "from" is the device frequency and "to" is nano seconds
    per second.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20091111134229.766673305@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 83d2fbd81b93..f57f88250526 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -279,6 +279,16 @@ extern void clocksource_resume(void);
 extern struct clocksource * __init __weak clocksource_default_clock(void);
 extern void clocksource_mark_unstable(struct clocksource *cs);
 
+extern void
+clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 minsec);
+
+static inline void
+clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)
+{
+	return clocks_calc_mult_shift(&cs->mult, &cs->shift, freq,
+				      NSEC_PER_SEC, minsec);
+}
+
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void update_vsyscall(struct timespec *ts, struct clocksource *c);
 extern void update_vsyscall_tz(void);

commit 7285dd7fd375763bfb8ab1ac9cf3f1206f503c16
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Aug 28 20:25:24 2009 +0200

    clocksource: Resolve cpu hotplug dead lock with TSC unstable
    
    Martin Schwidefsky analyzed it:
    To register a clocksource the clocksource_mutex is acquired and if
    necessary timekeeping_notify is called to install the clocksource as
    the timekeeper clock. timekeeping_notify uses stop_machine which needs
    to take cpu_add_remove_lock mutex.
    Starting a new cpu is done with the cpu_add_remove_lock mutex held.
    native_cpu_up checks the tsc of the new cpu and if the tsc is no good
    clocksource_change_rating is called. Which needs the clocksource_mutex
    and the deadlock is complete.
    
    The solution is to replace the TSC via the clocksource watchdog
    mechanism. Mark the TSC as unstable and schedule the watchdog work so
    it gets removed in the watchdog thread context.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <new-submission>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 9ea40ff26f0e..83d2fbd81b93 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -277,6 +277,7 @@ extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_resume(void);
 extern struct clocksource * __init __weak clocksource_default_clock(void);
+extern void clocksource_mark_unstable(struct clocksource *cs);
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void update_vsyscall(struct timespec *ts, struct clocksource *c);

commit 75c5158f70c065b9704b924503d96e8297838f79
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:30 2009 +0200

    timekeeping: Update clocksource with stop_machine
    
    update_wall_time calls change_clocksource HZ times per second to check
    if a new clock source is available. In close to 100% of all calls
    there is no new clock. Replace the tick based check by an update done
    with stop_machine.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134810.711836357@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index e34015effeb6..9ea40ff26f0e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -291,4 +291,6 @@ static inline void update_vsyscall_tz(void)
 }
 #endif
 
+extern void timekeeping_notify(struct clocksource *clock);
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 0a54419836254a27baecd9037103171bcbabaf67
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:28 2009 +0200

    timekeeping: Move NTP adjusted clock multiplier to struct timekeeper
    
    The clocksource structure has two multipliers, the unmodified multiplier
    clock->mult_orig and the NTP corrected multiplier clock->mult. The NTP
    multiplier is misplaced in the struct clocksource, this is private
    information of the timekeeping code. Add the mult field to the struct
    timekeeper to contain the NTP corrected value, keep the unmodifed
    multiplier in clock->mult and remove clock->mult_orig.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134810.149047645@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index e12e3095e2fb..e34015effeb6 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -149,8 +149,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @disable:		optional function to disable the clocksource
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
- * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
- * @mult_orig:		cycle to nanosecond multiplier (unadjusted by NTP)
+ * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
@@ -168,7 +167,6 @@ struct clocksource {
 	void (*disable)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
-	u32 mult_orig;
 	u32 shift;
 	unsigned long flags;
 	cycle_t (*vread)(void);

commit 155ec60226ae0ae2aadaa57c951a58a359331030
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:26 2009 +0200

    timekeeping: Introduce struct timekeeper
    
    Add struct timekeeper to keep the internal values timekeeping.c needs
    in regard to the currently selected clock source. This moves the
    timekeeping intervals, xtime_nsec and the ntp error value from struct
    clocksource to struct timekeeper. The raw_time is removed from the
    clocksource as well. It gets treated like xtime as a global variable.
    Eventually xtime raw_time should be moved to struct timekeeper.
    
    [ tglx: minor cleanup ]
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134809.613209842@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 19ad43af62d0..e12e3095e2fb 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -155,8 +155,6 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
  * @resume:		resume function for the clocksource, if necessary
- * @cycle_interval:	Used internally by timekeeping core, please ignore.
- * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
 struct clocksource {
 	/*
@@ -182,19 +180,12 @@ struct clocksource {
 #define CLKSRC_FSYS_MMIO_SET(mmio, addr)      do { } while (0)
 #endif
 
-	/* timekeeping specific data, ignore */
-	cycle_t cycle_interval;
-	u64	xtime_interval;
-	u32	raw_interval;
 	/*
 	 * Second part is written at each timer interrupt
 	 * Keep it in a different cache line to dirty no
 	 * more than one cache line.
 	 */
 	cycle_t cycle_last ____cacheline_aligned_in_smp;
-	u64 xtime_nsec;
-	s64 error;
-	struct timespec raw_time;
 
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
@@ -203,8 +194,6 @@ struct clocksource {
 #endif
 };
 
-extern struct clocksource *clock;	/* current clocksource */
-
 /*
  * Clock source flags bits::
  */
@@ -270,50 +259,15 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 }
 
 /**
- * cyc2ns - converts clocksource cycles to nanoseconds
- * @cs:		Pointer to clocksource
- * @cycles:	Cycles
+ * clocksource_cyc2ns - converts clocksource cycles to nanoseconds
  *
- * Uses the clocksource and ntp ajdustment to convert cycle_ts to nanoseconds.
+ * Converts cycles to nanoseconds, using the given mult and shift.
  *
  * XXX - This could use some mult_lxl_ll() asm optimization
  */
-static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
+static inline s64 clocksource_cyc2ns(cycle_t cycles, u32 mult, u32 shift)
 {
-	u64 ret = (u64)cycles;
-	ret = (ret * cs->mult) >> cs->shift;
-	return ret;
-}
-
-/**
- * clocksource_calculate_interval - Calculates a clocksource interval struct
- *
- * @c:		Pointer to clocksource.
- * @length_nsec: Desired interval length in nanoseconds.
- *
- * Calculates a fixed cycle/nsec interval for a given clocksource/adjustment
- * pair and interval request.
- *
- * Unless you're the timekeeping code, you should not be using this!
- */
-static inline void clocksource_calculate_interval(struct clocksource *c,
-					  	  unsigned long length_nsec)
-{
-	u64 tmp;
-
-	/* Do the ns -> cycle conversion first, using original mult */
-	tmp = length_nsec;
-	tmp <<= c->shift;
-	tmp += c->mult_orig/2;
-	do_div(tmp, c->mult_orig);
-
-	c->cycle_interval = (cycle_t)tmp;
-	if (c->cycle_interval == 0)
-		c->cycle_interval = 1;
-
-	/* Go back from cycles -> shifted ns, this time use ntp adjused mult */
-	c->xtime_interval = (u64)c->cycle_interval * c->mult;
-	c->raw_interval = ((u64)c->cycle_interval * c->mult_orig) >> c->shift;
+	return ((u64) cycles * mult) >> shift;
 }
 
 

commit c55c87c892c1875deace0c8fc28787335277fdf2
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:25 2009 +0200

    clocksource: Move watchdog downgrade to a work queue thread
    
    Move the downgrade of an unstable clocksource from the timer interrupt
    context into the process context of a work queue thread. This is
    needed to be able to do the clocksource switch with stop_machine.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134809.354926067@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f263b3abf46e..19ad43af62d0 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -213,6 +213,7 @@ extern struct clocksource *clock;	/* current clocksource */
 
 #define CLOCK_SOURCE_WATCHDOG			0x10
 #define CLOCK_SOURCE_VALID_FOR_HRES		0x20
+#define CLOCK_SOURCE_UNSTABLE			0x40
 
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)

commit f1b82746c1e93daf24e1ab9bfbd39bcdb2e7018b
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:21 2009 +0200

    clocksource: Cleanup clocksource selection
    
    If a non high-resolution clocksource is first set as override clock
    and then registered it becomes active even if the system is in one-shot
    mode. Move the override check from sysfs_override_clocksource to the
    clocksource selection. That fixes the bug and simplifies the code. The
    check in clocksource_register for double registration of the same
    clocksource is removed without replacement.
    
    To find the initial clocksource a new weak function in jiffies.c is
    defined that returns the jiffies clocksource. The architecture code
    can then override the weak function with a more suitable clocksource,
    e.g. the TOD clock on s390.
    
    [ tglx: Folded in a fix from John Stultz ]
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134808.388024160@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a1ef46f61c81..f263b3abf46e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/cache.h>
 #include <linux/timer.h>
+#include <linux/init.h>
 #include <asm/div64.h>
 #include <asm/io.h>
 
@@ -322,6 +323,7 @@ extern void clocksource_touch_watchdog(void);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_resume(void);
+extern struct clocksource * __init __weak clocksource_default_clock(void);
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void update_vsyscall(struct timespec *ts, struct clocksource *c);

commit a0f7d48bfb95a4c5172a2756dbc4b82afc8e9ae4
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:19 2009 +0200

    timekeeping: Remove clocksource inline functions
    
    The three inline functions clocksource_read, clocksource_enable and
    clocksource_disable are simple wrappers of an indirect call plus the
    copy from and to the mult_orig value. The functions are exclusively
    used by the timekeeping code which has intimate knowledge of the
    clocksource anyway. Therefore remove the inline functions. No
    functional change.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134807.903108946@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 1219be4fb42e..a1ef46f61c81 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -267,64 +267,6 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 	return (u32)tmp;
 }
 
-/**
- * clocksource_read: - Access the clocksource's current cycle value
- * @cs:		pointer to clocksource being read
- *
- * Uses the clocksource to return the current cycle_t value
- */
-static inline cycle_t clocksource_read(struct clocksource *cs)
-{
-	return cs->read(cs);
-}
-
-/**
- * clocksource_enable: - enable clocksource
- * @cs:		pointer to clocksource
- *
- * Enables the specified clocksource. The clocksource callback
- * function should start up the hardware and setup mult and field
- * members of struct clocksource to reflect hardware capabilities.
- */
-static inline int clocksource_enable(struct clocksource *cs)
-{
-	int ret = 0;
-
-	if (cs->enable)
-		ret = cs->enable(cs);
-
-	/*
-	 * The frequency may have changed while the clocksource
-	 * was disabled. If so the code in ->enable() must update
-	 * the mult value to reflect the new frequency. Make sure
-	 * mult_orig follows this change.
-	 */
-	cs->mult_orig = cs->mult;
-
-	return ret;
-}
-
-/**
- * clocksource_disable: - disable clocksource
- * @cs:		pointer to clocksource
- *
- * Disables the specified clocksource. The clocksource callback
- * function should power down the now unused hardware block to
- * save power.
- */
-static inline void clocksource_disable(struct clocksource *cs)
-{
-	/*
-	 * Save mult_orig in mult so clocksource_enable() can
-	 * restore the value regardless if ->enable() updates
-	 * the value of mult or not.
-	 */
-	cs->mult = cs->mult_orig;
-
-	if (cs->disable)
-		cs->disable(cs);
-}
-
 /**
  * cyc2ns - converts clocksource cycles to nanoseconds
  * @cs:		Pointer to clocksource

commit c7121843685de2bf7f3afd3ae1d6a146010bf1fc
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Jul 28 14:09:55 2009 -0700

    clocksource: Save mult_orig in clocksource_disable()
    
    To fix the common case where ->enable() does not set up
    mult, make sure mult_orig is saved in mult on disable.
    
    Also add comments to explain why we do this.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Cc: johnstul@us.ibm.com
    Cc: lethal@linux-sh.org
    Cc: akpm@linux-foundation.org
    LKML-Reference: <20090618152432.10136.9932.sendpatchset@rx1.opensource.se>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c56457c8334e..1219be4fb42e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -293,7 +293,12 @@ static inline int clocksource_enable(struct clocksource *cs)
 	if (cs->enable)
 		ret = cs->enable(cs);
 
-	/* save mult_orig on enable */
+	/*
+	 * The frequency may have changed while the clocksource
+	 * was disabled. If so the code in ->enable() must update
+	 * the mult value to reflect the new frequency. Make sure
+	 * mult_orig follows this change.
+	 */
 	cs->mult_orig = cs->mult;
 
 	return ret;
@@ -309,6 +314,13 @@ static inline int clocksource_enable(struct clocksource *cs)
  */
 static inline void clocksource_disable(struct clocksource *cs)
 {
+	/*
+	 * Save mult_orig in mult so clocksource_enable() can
+	 * restore the value regardless if ->enable() updates
+	 * the value of mult or not.
+	 */
+	cs->mult = cs->mult_orig;
+
 	if (cs->disable)
 		cs->disable(cs);
 }

commit a25cbd045a2ffc42787d4dbcbb9c7118f5f42732
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri May 1 14:45:46 2009 +0900

    clocksource: setup mult_orig in clocksource_enable()
    
    Setup clocksource mult_orig in clocksource_enable().
    
    Clocksource drivers can save power by using keeping the
    device clock disabled while the clocksource is unused.
    
    In practice this means that the enable() and disable()
    callbacks perform clk_enable() and clk_disable().
    
    The enable() callback may also use clk_get_rate() to get
    the clock rate from the clock framework. This information
    can then be used to calculate the shift and mult variables.
    
    Currently the mult_orig variable is setup from mult at
    registration time only. This is conflicting with the above
    case since the clock is disabled and the mult variable is
    not yet calculated at the time of registration.
    
    Moving the mult_orig setup code to clocksource_enable()
    allows us to both handle the common case with no enable()
    callback and the mult-changed-after-enable() case.
    
    [ Impact: allow dynamic clock source usage ]
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    LKML-Reference: <20090501054546.8193.10688.sendpatchset@rx1.opensource.se>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 5a40d14daa9f..c56457c8334e 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -288,7 +288,15 @@ static inline cycle_t clocksource_read(struct clocksource *cs)
  */
 static inline int clocksource_enable(struct clocksource *cs)
 {
-	return cs->enable ? cs->enable(cs) : 0;
+	int ret = 0;
+
+	if (cs->enable)
+		ret = cs->enable(cs);
+
+	/* save mult_orig on enable */
+	cs->mult_orig = cs->mult;
+
+	return ret;
 }
 
 /**

commit 4614e6adafa2c5e6c3a9c245af2807fa7bc5117a
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Apr 21 12:24:02 2009 -0700

    clocksource: add enable() and disable() callbacks
    
    Add enable() and disable() callbacks for clocksources.
    
    This allows us to put unused clocksources in power save mode.  The
    functions clocksource_enable() and clocksource_disable() wrap the
    callbacks and are inserted in the timekeeping code to enable before use
    and disable after switching to a new clocksource.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 0d96cde9ee5d..5a40d14daa9f 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -144,6 +144,8 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  *				The ideal clocksource. A must-use where
  *				available.
  * @read:		returns a cycle value, passes clocksource as argument
+ * @enable:		optional function to enable the clocksource
+ * @disable:		optional function to disable the clocksource
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
@@ -163,6 +165,8 @@ struct clocksource {
 	struct list_head list;
 	int rating;
 	cycle_t (*read)(struct clocksource *cs);
+	int (*enable)(struct clocksource *cs);
+	void (*disable)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
 	u32 mult_orig;
@@ -274,6 +278,33 @@ static inline cycle_t clocksource_read(struct clocksource *cs)
 	return cs->read(cs);
 }
 
+/**
+ * clocksource_enable: - enable clocksource
+ * @cs:		pointer to clocksource
+ *
+ * Enables the specified clocksource. The clocksource callback
+ * function should start up the hardware and setup mult and field
+ * members of struct clocksource to reflect hardware capabilities.
+ */
+static inline int clocksource_enable(struct clocksource *cs)
+{
+	return cs->enable ? cs->enable(cs) : 0;
+}
+
+/**
+ * clocksource_disable: - disable clocksource
+ * @cs:		pointer to clocksource
+ *
+ * Disables the specified clocksource. The clocksource callback
+ * function should power down the now unused hardware block to
+ * save power.
+ */
+static inline void clocksource_disable(struct clocksource *cs)
+{
+	if (cs->disable)
+		cs->disable(cs);
+}
+
 /**
  * cyc2ns - converts clocksource cycles to nanoseconds
  * @cs:		Pointer to clocksource

commit 8e19608e8b5c001e4a66ce482edc474f05fb7355
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Apr 21 12:24:00 2009 -0700

    clocksource: pass clocksource to read() callback
    
    Pass clocksource pointer to the read() callback for clocksources.  This
    allows us to share the callback between multiple instances.
    
    [hugh@veritas.com: fix powerpc build of clocksource pass clocksource mods]
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 573819ef4cc0..0d96cde9ee5d 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -143,7 +143,7 @@ extern u64 timecounter_cyc2time(struct timecounter *tc,
  *			400-499: Perfect
  *				The ideal clocksource. A must-use where
  *				available.
- * @read:		returns a cycle value
+ * @read:		returns a cycle value, passes clocksource as argument
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
@@ -162,7 +162,7 @@ struct clocksource {
 	char *name;
 	struct list_head list;
 	int rating;
-	cycle_t (*read)(void);
+	cycle_t (*read)(struct clocksource *cs);
 	cycle_t mask;
 	u32 mult;
 	u32 mult_orig;
@@ -271,7 +271,7 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
  */
 static inline cycle_t clocksource_read(struct clocksource *cs)
 {
-	return cs->read();
+	return cs->read(cs);
 }
 
 /**

commit a038a353c3de4040d8445ec568acebdac144436f
Author: Patrick Ohly <patrick.ohly@intel.com>
Date:   Thu Feb 12 05:03:34 2009 +0000

    clocksource: allow usage independent of timekeeping.c
    
    So far struct clocksource acted as the interface between time/timekeeping.c
    and hardware. This patch generalizes the concept so that a similar
    interface can also be used in other contexts. For that it introduces
    new structures and related functions *without* touching the existing
    struct clocksource.
    
    The reasons for adding these new structures to clocksource.[ch] are
    * the APIs are clearly related
    * struct clocksource could be cleaned up to use the new structs
    * avoids proliferation of files with similar names (timesource.h?
      timecounter.h?)
    
    As outlined in the discussion with John Stultz, this patch adds
    * struct cyclecounter: stateless API to hardware which counts clock cycles
    * struct timecounter: stateful utility code built on a cyclecounter which
      provides a nanosecond counter
    * only the function to read the nanosecond counter; deltas are used internally
      and not exposed to users of timecounter
    
    The code does no locking of the shared state. It must be called at least
    as often as the cycle counter wraps around to detect these wrap arounds.
    Both is the responsibility of the timecounter user.
    
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Patrick Ohly <patrick.ohly@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f88d32f8ff7c..573819ef4cc0 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -21,9 +21,110 @@
 typedef u64 cycle_t;
 struct clocksource;
 
+/**
+ * struct cyclecounter - hardware abstraction for a free running counter
+ *	Provides completely state-free accessors to the underlying hardware.
+ *	Depending on which hardware it reads, the cycle counter may wrap
+ *	around quickly. Locking rules (if necessary) have to be defined
+ *	by the implementor and user of specific instances of this API.
+ *
+ * @read:		returns the current cycle value
+ * @mask:		bitmask for two's complement
+ *			subtraction of non 64 bit counters,
+ *			see CLOCKSOURCE_MASK() helper macro
+ * @mult:		cycle to nanosecond multiplier
+ * @shift:		cycle to nanosecond divisor (power of two)
+ */
+struct cyclecounter {
+	cycle_t (*read)(const struct cyclecounter *cc);
+	cycle_t mask;
+	u32 mult;
+	u32 shift;
+};
+
+/**
+ * struct timecounter - layer above a %struct cyclecounter which counts nanoseconds
+ *	Contains the state needed by timecounter_read() to detect
+ *	cycle counter wrap around. Initialize with
+ *	timecounter_init(). Also used to convert cycle counts into the
+ *	corresponding nanosecond counts with timecounter_cyc2time(). Users
+ *	of this code are responsible for initializing the underlying
+ *	cycle counter hardware, locking issues and reading the time
+ *	more often than the cycle counter wraps around. The nanosecond
+ *	counter will only wrap around after ~585 years.
+ *
+ * @cc:			the cycle counter used by this instance
+ * @cycle_last:		most recent cycle counter value seen by
+ *			timecounter_read()
+ * @nsec:		continuously increasing count
+ */
+struct timecounter {
+	const struct cyclecounter *cc;
+	cycle_t cycle_last;
+	u64 nsec;
+};
+
+/**
+ * cyclecounter_cyc2ns - converts cycle counter cycles to nanoseconds
+ * @tc:		Pointer to cycle counter.
+ * @cycles:	Cycles
+ *
+ * XXX - This could use some mult_lxl_ll() asm optimization. Same code
+ * as in cyc2ns, but with unsigned result.
+ */
+static inline u64 cyclecounter_cyc2ns(const struct cyclecounter *cc,
+				      cycle_t cycles)
+{
+	u64 ret = (u64)cycles;
+	ret = (ret * cc->mult) >> cc->shift;
+	return ret;
+}
+
+/**
+ * timecounter_init - initialize a time counter
+ * @tc:			Pointer to time counter which is to be initialized/reset
+ * @cc:			A cycle counter, ready to be used.
+ * @start_tstamp:	Arbitrary initial time stamp.
+ *
+ * After this call the current cycle register (roughly) corresponds to
+ * the initial time stamp. Every call to timecounter_read() increments
+ * the time stamp counter by the number of elapsed nanoseconds.
+ */
+extern void timecounter_init(struct timecounter *tc,
+			     const struct cyclecounter *cc,
+			     u64 start_tstamp);
+
+/**
+ * timecounter_read - return nanoseconds elapsed since timecounter_init()
+ *                    plus the initial time stamp
+ * @tc:          Pointer to time counter.
+ *
+ * In other words, keeps track of time since the same epoch as
+ * the function which generated the initial time stamp.
+ */
+extern u64 timecounter_read(struct timecounter *tc);
+
+/**
+ * timecounter_cyc2time - convert a cycle counter to same
+ *                        time base as values returned by
+ *                        timecounter_read()
+ * @tc:		Pointer to time counter.
+ * @cycle:	a value returned by tc->cc->read()
+ *
+ * Cycle counts that are converted correctly as long as they
+ * fall into the interval [-1/2 max cycle count, +1/2 max cycle count],
+ * with "max cycle count" == cs->mask+1.
+ *
+ * This allows conversion of cycle counter values which were generated
+ * in the past.
+ */
+extern u64 timecounter_cyc2time(struct timecounter *tc,
+				cycle_t cycle_tstamp);
+
 /**
  * struct clocksource - hardware abstraction for a free running counter
  *	Provides mostly state-free accessors to the underlying hardware.
+ *	This is the structure used for system time.
  *
  * @name:		ptr to clocksource name
  * @list:		list head for registration

commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 20 16:37:30 2008 -0700

    clocksource: introduce CLOCK_MONOTONIC_RAW
    
    In talking with Josip Loncaric, and his work on clock synchronization (see
    btime.sf.net), he mentioned that for really close synchronization, it is
    useful to have access to "hardware time", that is a notion of time that is
    not in any way adjusted by the clock slewing done to keep close time sync.
    
    Part of the issue is if we are using the kernel's ntp adjusted
    representation of time in order to measure how we should correct time, we
    can run into what Paul McKenney aptly described as "Painting a road using
    the lines we're painting as the guide".
    
    I had been thinking of a similar problem, and was trying to come up with a
    way to give users access to a purely hardware based time representation
    that avoided users having to know the underlying frequency and mask values
    needed to deal with the wide variety of possible underlying hardware
    counters.
    
    My solution is to introduce CLOCK_MONOTONIC_RAW.  This exposes a
    nanosecond based time value, that increments starting at bootup and has no
    frequency adjustments made to it what so ever.
    
    The time is accessed from userspace via the posix_clock_gettime() syscall,
    passing CLOCK_MONOTONIC_RAW as the clock_id.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index f0a7fb984413..f88d32f8ff7c 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -79,6 +79,7 @@ struct clocksource {
 	/* timekeeping specific data, ignore */
 	cycle_t cycle_interval;
 	u64	xtime_interval;
+	u32	raw_interval;
 	/*
 	 * Second part is written at each timer interrupt
 	 * Keep it in a different cache line to dirty no
@@ -87,6 +88,7 @@ struct clocksource {
 	cycle_t cycle_last ____cacheline_aligned_in_smp;
 	u64 xtime_nsec;
 	s64 error;
+	struct timespec raw_time;
 
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG
 	/* Watchdog related data, used by the framework */
@@ -215,6 +217,7 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 
 	/* Go back from cycles -> shifted ns, this time use ntp adjused mult */
 	c->xtime_interval = (u64)c->cycle_interval * c->mult;
+	c->raw_interval = ((u64)c->cycle_interval * c->mult_orig) >> c->shift;
 }
 
 

commit 1aa5dfb751d275ae7117d3b73ac423b4a46f2a73
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 20 16:37:28 2008 -0700

    clocksource: keep track of original clocksource frequency
    
    The clocksource frequency is represented by
    clocksource->mult/2^(clocksource->shift).  Currently, when NTP makes
    adjustments to the clock frequency, they are made directly to the mult
    value.
    
    This has the drawback that once changed, we cannot know what the orignal
    mult value was, or how much adjustment has been applied.
    
    This property causes problems in calculating proper ntp intervals when
    switching back and forth between clocksources.
    
    This patch separates the current mult value into a mult and mult_orig
    pair.  The mult_orig value stays constant, while the ntp clocksource
    adjustments are done only to the mult value.
    
    This allows for correct ntp interval calculation and additionally lays the
    groundwork for a new notion of time, what I'm calling the monotonic-raw
    time, which is introduced in a following patch.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 55e434feec99..f0a7fb984413 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -45,7 +45,8 @@ struct clocksource;
  * @read:		returns a cycle value
  * @mask:		bitmask for two's complement
  *			subtraction of non 64 bit counters
- * @mult:		cycle to nanosecond multiplier
+ * @mult:		cycle to nanosecond multiplier (adjusted by NTP)
+ * @mult_orig:		cycle to nanosecond multiplier (unadjusted by NTP)
  * @shift:		cycle to nanosecond divisor (power of two)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
@@ -63,6 +64,7 @@ struct clocksource {
 	cycle_t (*read)(void);
 	cycle_t mask;
 	u32 mult;
+	u32 mult_orig;
 	u32 shift;
 	unsigned long flags;
 	cycle_t (*vread)(void);
@@ -201,16 +203,17 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 {
 	u64 tmp;
 
-	/* XXX - All of this could use a whole lot of optimization */
+	/* Do the ns -> cycle conversion first, using original mult */
 	tmp = length_nsec;
 	tmp <<= c->shift;
-	tmp += c->mult/2;
-	do_div(tmp, c->mult);
+	tmp += c->mult_orig/2;
+	do_div(tmp, c->mult_orig);
 
 	c->cycle_interval = (cycle_t)tmp;
 	if (c->cycle_interval == 0)
 		c->cycle_interval = 1;
 
+	/* Go back from cycles -> shifted ns, this time use ntp adjused mult */
 	c->xtime_interval = (u64)c->cycle_interval * c->mult;
 }
 

commit 7dffa3c673fbcf835cd7be80bb4aec8ad3f51168
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Thu May 1 04:34:41 2008 -0700

    ntp: handle leap second via timer
    
    Remove the leap second handling from second_overflow(), which doesn't have to
    check for it every second anymore.  With CONFIG_NO_HZ this also makes sure the
    leap second is handled close to the full second.  Additionally this makes it
    possible to abort a leap second properly by resetting the STA_INS/STA_DEL
    status bits.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 35094479ca55..55e434feec99 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -93,6 +93,8 @@ struct clocksource {
 #endif
 };
 
+extern struct clocksource *clock;	/* current clocksource */
+
 /*
  * Clock source flags bits::
  */

commit 7c3078b637882303b1dcf6a16229d0e35f6b60a5
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri Feb 15 14:55:54 2008 -0600

    kgdb: clocksource watchdog
    
    In order to not trip the clocksource watchdog, kgdb must touch the
    clocksource watchdog on the return to normal system run state.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 85778a4b1209..35094479ca55 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -216,6 +216,7 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 /* used to install a new clocksource */
 extern int clocksource_register(struct clocksource*);
 extern void clocksource_unregister(struct clocksource*);
+extern void clocksource_touch_watchdog(void);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_resume(void);

commit 4713e22ce81eb8b3353e16435362eb3d0ec95640
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jan 30 13:30:02 2008 +0100

    clocksource: add unregister function to disable unusable clocksources
    
    On x86 the PIT might become an unusable clocksource. Add an unregister
    function to provide a possibilty to remove the PIT from the list of
    available clock sources.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 07b42153de24..85778a4b1209 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -215,6 +215,7 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 
 /* used to install a new clocksource */
 extern int clocksource_register(struct clocksource*);
+extern void clocksource_unregister(struct clocksource*);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 extern void clocksource_resume(void);

commit 1d76c2622813fbc692b0d323028cfef9ee36051a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Jan 30 13:30:01 2008 +0100

    clocksource: make CLOCKSOURCE_MASK bullet-proof
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 107787aacb64..07b42153de24 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -103,7 +103,7 @@ struct clocksource {
 #define CLOCK_SOURCE_VALID_FOR_HRES		0x20
 
 /* simplify initialization of mask field */
-#define CLOCKSOURCE_MASK(bits) (cycle_t)(bits<64 ? ((1ULL<<bits)-1) : -1)
+#define CLOCKSOURCE_MASK(bits) (cycle_t)((bits) < 64 ? ((1ULL<<(bits))-1) : -1)
 
 /**
  * clocksource_khz2mult - calculates mult from khz and shift

commit 2c6221483169ddd4c04797cd7296ed4fe52fcdd7
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Thu Oct 18 03:04:57 2007 -0700

    Fix discrepancy between VDSO based gettimeofday() and sys_gettimeofday().
    
    On platforms that copy sys_tz into the vdso (currently only x86_64, soon to
    include powerpc), it is possible for the vdso to get out of sync if a user
    calls (admittedly unusual) settimeofday(NULL, ptr).
    
    This patch adds a hook for architectures that set
    CONFIG_GENERIC_TIME_VSYSCALL to ensure when sys_tz is updated they can also
    updatee their copy in the vdso.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 16ea3374dddf..107787aacb64 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -221,10 +221,15 @@ extern void clocksource_resume(void);
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void update_vsyscall(struct timespec *ts, struct clocksource *c);
+extern void update_vsyscall_tz(void);
 #else
 static inline void update_vsyscall(struct timespec *ts, struct clocksource *c)
 {
 }
+
+static inline void update_vsyscall_tz(void)
+{
+}
 #endif
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 0aa366f351d044703e25c8425e508170e80d83b1
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Jul 20 11:22:30 2007 -0700

    [IA64] Convert to generic timekeeping/clocksource
    
    This is a merge of Peter Keilty's initial patch (which was
    revived by Bob Picco) for this with Hidetoshi Seto's fixes
    and scaling improvements.
    
    Acked-by: Bob Picco <bob.picco@hp.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index bf297b03a4e4..16ea3374dddf 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -67,6 +67,12 @@ struct clocksource {
 	unsigned long flags;
 	cycle_t (*vread)(void);
 	void (*resume)(void);
+#ifdef CONFIG_IA64
+	void *fsys_mmio;        /* used by fsyscall asm code */
+#define CLKSRC_FSYS_MMIO_SET(mmio, addr)      ((mmio) = (addr))
+#else
+#define CLKSRC_FSYS_MMIO_SET(mmio, addr)      do { } while (0)
+#endif
 
 	/* timekeeping specific data, ignore */
 	cycle_t cycle_interval;

commit b52f52a093bb1e841e014c2087b5bee7162da413
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 9 02:35:15 2007 -0700

    clocksource: fix resume logic
    
    We need to make sure that the clocksources are resumed, when timekeeping is
    resumed.  The current resume logic does not guarantee this.
    
    Add a resume function pointer to the clocksource struct, so clocksource
    drivers which need to reinitialize the clocksource can provide a resume
    function.
    
    Add a resume function, which calls the maybe available clocksource resume
    functions and resets the watchdog function, so a stable TSC can be used
    accross suspend/resume.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 2665ca04cf8f..bf297b03a4e4 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -49,6 +49,7 @@ struct clocksource;
  * @shift:		cycle to nanosecond divisor (power of two)
  * @flags:		flags describing special properties
  * @vread:		vsyscall based read
+ * @resume:		resume function for the clocksource, if necessary
  * @cycle_interval:	Used internally by timekeeping core, please ignore.
  * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
@@ -65,6 +66,7 @@ struct clocksource {
 	u32 shift;
 	unsigned long flags;
 	cycle_t (*vread)(void);
+	void (*resume)(void);
 
 	/* timekeeping specific data, ignore */
 	cycle_t cycle_interval;
@@ -209,6 +211,7 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 extern int clocksource_register(struct clocksource*);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
+extern void clocksource_resume(void);
 
 #ifdef CONFIG_GENERIC_TIME_VSYSCALL
 extern void update_vsyscall(struct timespec *ts, struct clocksource *c);

commit 329c8d84ca1946c037d9859dc251b56d8b1b4630
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Tue May 8 00:27:57 2007 -0700

    time: SMP friendly alignment of struct clocksource
    
    struct clocksource is a critical data structure.
    
    Most of its fields are read only, some of them are heavily modified at each
    timer interrupt.
    
    It makes sense to separate those fields and make sure they all share one
    cache line, or at least the minimum for machines with small cache lines.
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index daa4940cc0f1..2665ca04cf8f 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -12,6 +12,7 @@
 #include <linux/timex.h>
 #include <linux/time.h>
 #include <linux/list.h>
+#include <linux/cache.h>
 #include <linux/timer.h>
 #include <asm/div64.h>
 #include <asm/io.h>
@@ -52,6 +53,9 @@ struct clocksource;
  * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
 struct clocksource {
+	/*
+	 * First part of structure is read mostly
+	 */
 	char *name;
 	struct list_head list;
 	int rating;
@@ -63,8 +67,15 @@ struct clocksource {
 	cycle_t (*vread)(void);
 
 	/* timekeeping specific data, ignore */
-	cycle_t cycle_last, cycle_interval;
-	u64 xtime_nsec, xtime_interval;
+	cycle_t cycle_interval;
+	u64	xtime_interval;
+	/*
+	 * Second part is written at each timer interrupt
+	 * Keep it in a different cache line to dirty no
+	 * more than one cache line.
+	 */
+	cycle_t cycle_last ____cacheline_aligned_in_smp;
+	u64 xtime_nsec;
 	s64 error;
 
 #ifdef CONFIG_CLOCKSOURCE_WATCHDOG

commit acc9a9dcdd0dd1d295c2f2ee02c27c761bd63cb1
Author: john stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:28:17 2007 -0800

    [PATCH] generic: vsyscall-gtod support for GENERIC_TIME
    
    Provides generic infrastructure for vsyscall-gtod.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 830a250ecf94..daa4940cc0f1 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -47,6 +47,7 @@ struct clocksource;
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  * @flags:		flags describing special properties
+ * @vread:		vsyscall based read
  * @cycle_interval:	Used internally by timekeeping core, please ignore.
  * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
@@ -59,6 +60,7 @@ struct clocksource {
 	u32 mult;
 	u32 shift;
 	unsigned long flags;
+	cycle_t (*vread)(void);
 
 	/* timekeeping specific data, ignore */
 	cycle_t cycle_last, cycle_interval;
@@ -197,4 +199,12 @@ extern int clocksource_register(struct clocksource*);
 extern struct clocksource* clocksource_get_next(void);
 extern void clocksource_change_rating(struct clocksource *cs, int rating);
 
+#ifdef CONFIG_GENERIC_TIME_VSYSCALL
+extern void update_vsyscall(struct timespec *ts, struct clocksource *c);
+#else
+static inline void update_vsyscall(struct timespec *ts, struct clocksource *c)
+{
+}
+#endif
+
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 5d8b34fdcb384161552d01ee8f34af5ff11f9684
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:43 2007 -0800

    [PATCH] clocksource: Add verification (watchdog) helper
    
    The TSC needs to be verified against another clocksource.  Instead of using
    hardwired assumptions of available hardware, provide a generic verification
    mechanism.  The verification uses the best available clocksource and handles
    the usability for high resolution timers / dynticks of the clocksource which
    needs to be verified.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index a585a29fe7c4..830a250ecf94 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -12,11 +12,13 @@
 #include <linux/timex.h>
 #include <linux/time.h>
 #include <linux/list.h>
+#include <linux/timer.h>
 #include <asm/div64.h>
 #include <asm/io.h>
 
 /* clocksource cycle base type */
 typedef u64 cycle_t;
+struct clocksource;
 
 /**
  * struct clocksource - hardware abstraction for a free running counter
@@ -62,13 +64,22 @@ struct clocksource {
 	cycle_t cycle_last, cycle_interval;
 	u64 xtime_nsec, xtime_interval;
 	s64 error;
+
+#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
+	/* Watchdog related data, used by the framework */
+	struct list_head wd_list;
+	cycle_t wd_last;
+#endif
 };
 
 /*
  * Clock source flags bits::
  */
-#define CLOCK_SOURCE_IS_CONTINUOUS	0x01
-#define CLOCK_SOURCE_MUST_VERIFY	0x02
+#define CLOCK_SOURCE_IS_CONTINUOUS		0x01
+#define CLOCK_SOURCE_MUST_VERIFY		0x02
+
+#define CLOCK_SOURCE_WATCHDOG			0x10
+#define CLOCK_SOURCE_VALID_FOR_HRES		0x20
 
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)(bits<64 ? ((1ULL<<bits)-1) : -1)

commit 7e69f2b1ead2a4c51c12817f18263ff0e59335a6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:42 2007 -0800

    [PATCH] clocksource: Remove the update callback
    
    The clocksource code allows direct updates of the rating of a given
    clocksource now.  Change TSC unstable tracking to use this interface and
    remove the update callback.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 45b0c310ae82..a585a29fe7c4 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -44,7 +44,6 @@ typedef u64 cycle_t;
  *			subtraction of non 64 bit counters
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
- * @update_callback:	called when safe to alter clocksource values
  * @flags:		flags describing special properties
  * @cycle_interval:	Used internally by timekeeping core, please ignore.
  * @xtime_interval:	Used internally by timekeeping core, please ignore.
@@ -57,7 +56,6 @@ struct clocksource {
 	cycle_t mask;
 	u32 mult;
 	u32 shift;
-	int (*update_callback)(void);
 	unsigned long flags;
 
 	/* timekeeping specific data, ignore */

commit 73b08d2aa4245806ef1bdd48463e9a0b045c62cf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:36 2007 -0800

    [PATCH] clocksource: replace is_continuous by a flag field
    
    Using a flag filed allows to encode more than one information into a variable.
    Preparatory patch for the generic clocksource verification.
    
    [mingo@elte.hu: convert vmitime.c to the new clocksource flag]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 55d714052374..45b0c310ae82 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -45,7 +45,7 @@ typedef u64 cycle_t;
  * @mult:		cycle to nanosecond multiplier
  * @shift:		cycle to nanosecond divisor (power of two)
  * @update_callback:	called when safe to alter clocksource values
- * @is_continuous:	defines if clocksource is free-running.
+ * @flags:		flags describing special properties
  * @cycle_interval:	Used internally by timekeeping core, please ignore.
  * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
@@ -58,7 +58,7 @@ struct clocksource {
 	u32 mult;
 	u32 shift;
 	int (*update_callback)(void);
-	int is_continuous;
+	unsigned long flags;
 
 	/* timekeeping specific data, ignore */
 	cycle_t cycle_last, cycle_interval;
@@ -66,6 +66,12 @@ struct clocksource {
 	s64 error;
 };
 
+/*
+ * Clock source flags bits::
+ */
+#define CLOCK_SOURCE_IS_CONTINUOUS	0x01
+#define CLOCK_SOURCE_MUST_VERIFY	0x02
+
 /* simplify initialization of mask field */
 #define CLOCKSOURCE_MASK(bits) (cycle_t)(bits<64 ? ((1ULL<<bits)-1) : -1)
 

commit 92c7e00254b2d0efc1e36ac3e45474ce1871b6b2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:33 2007 -0800

    [PATCH] Simplify the registration of clocksources
    
    Enqueue clocksources in rating order to make selection of the clocksource
    easier.  Also check the match with an user override at enqueue time.
    
    Preparatory patch for the generic clocksource verification.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 1622d23a8dc3..55d714052374 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -178,8 +178,8 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 
 
 /* used to install a new clocksource */
-int clocksource_register(struct clocksource*);
-void clocksource_reselect(void);
-struct clocksource* clocksource_get_next(void);
+extern int clocksource_register(struct clocksource*);
+extern struct clocksource* clocksource_get_next(void);
+extern void clocksource_change_rating(struct clocksource *cs, int rating);
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit f5f1a24a2caa299bb7d294aee92d7dd3410d9ed7
Author: Daniel Walker <dwalker@mvista.com>
Date:   Sun Dec 10 02:21:33 2006 -0800

    [PATCH] clocksource: small cleanup
    
    Mostly changing alignment.  Just some general cleanup.
    
    [akpm@osdl.org: build fix]
    Signed-off-by: Daniel Walker <dwalker@mvista.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index d852024ed095..1622d23a8dc3 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -159,7 +159,7 @@ static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
  * Unless you're the timekeeping code, you should not be using this!
  */
 static inline void clocksource_calculate_interval(struct clocksource *c,
-						unsigned long length_nsec)
+					  	  unsigned long length_nsec)
 {
 	u64 tmp;
 

commit 19923c190e0932bf0ac1e1d06a48f5c3678dd0de
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Mon Jun 26 00:25:18 2006 -0700

    [PATCH] fix and optimize clock source update
    
    This fixes the clock source updates in update_wall_time() to correctly
    track the time coming in via current_tick_length().  Optimize the fast
    paths to be as short as possible to keep the overhead low.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 4bc94282c364..d852024ed095 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -46,8 +46,8 @@ typedef u64 cycle_t;
  * @shift:		cycle to nanosecond divisor (power of two)
  * @update_callback:	called when safe to alter clocksource values
  * @is_continuous:	defines if clocksource is free-running.
- * @interval_cycles:	Used internally by timekeeping core, please ignore.
- * @interval_snsecs:	Used internally by timekeeping core, please ignore.
+ * @cycle_interval:	Used internally by timekeeping core, please ignore.
+ * @xtime_interval:	Used internally by timekeeping core, please ignore.
  */
 struct clocksource {
 	char *name;
@@ -61,8 +61,9 @@ struct clocksource {
 	int is_continuous;
 
 	/* timekeeping specific data, ignore */
-	cycle_t interval_cycles;
-	u64 interval_snsecs;
+	cycle_t cycle_last, cycle_interval;
+	u64 xtime_nsec, xtime_interval;
+	s64 error;
 };
 
 /* simplify initialization of mask field */
@@ -168,107 +169,11 @@ static inline void clocksource_calculate_interval(struct clocksource *c,
 	tmp += c->mult/2;
 	do_div(tmp, c->mult);
 
-	c->interval_cycles = (cycle_t)tmp;
-	if(c->interval_cycles == 0)
-		c->interval_cycles = 1;
+	c->cycle_interval = (cycle_t)tmp;
+	if (c->cycle_interval == 0)
+		c->cycle_interval = 1;
 
-	c->interval_snsecs = (u64)c->interval_cycles * c->mult;
-}
-
-
-/**
- * error_aproximation - calculates an error adjustment for a given error
- *
- * @error:	Error value (unsigned)
- * @unit:	Adjustment unit
- *
- * For a given error value, this function takes the adjustment unit
- * and uses binary approximation to return a power of two adjustment value.
- *
- * This function is only for use by the the make_ntp_adj() function
- * and you must hold a write on the xtime_lock when calling.
- */
-static inline int error_aproximation(u64 error, u64 unit)
-{
-	static int saved_adj = 0;
-	u64 adjusted_unit = unit << saved_adj;
-
-	if (error > (adjusted_unit * 2)) {
-		/* large error, so increment the adjustment factor */
-		saved_adj++;
-	} else if (error > adjusted_unit) {
-		/* just right, don't touch it */
-	} else if (saved_adj) {
-		/* small error, so drop the adjustment factor */
-		saved_adj--;
-		return 0;
-	}
-
-	return saved_adj;
-}
-
-
-/**
- * make_ntp_adj - Adjusts the specified clocksource for a given error
- *
- * @clock:		Pointer to clock to be adjusted
- * @cycles_delta:	Current unacounted cycle delta
- * @error:		Pointer to current error value
- *
- * Returns clock shifted nanosecond adjustment to be applied against
- * the accumulated time value (ie: xtime).
- *
- * If the error value is large enough, this function calulates the
- * (power of two) adjustment value, and adjusts the clock's mult and
- * interval_snsecs values accordingly.
- *
- * However, since there may be some unaccumulated cycles, to avoid
- * time inconsistencies we must adjust the accumulation value
- * accordingly.
- *
- * This is not very intuitive, so the following proof should help:
- * The basic timeofday algorithm:  base + cycle * mult
- * Thus:
- *    new_base + cycle * new_mult = old_base + cycle * old_mult
- *    new_base = old_base + cycle * old_mult - cycle * new_mult
- *    new_base = old_base + cycle * (old_mult - new_mult)
- *    new_base - old_base = cycle * (old_mult - new_mult)
- *    base_delta = cycle * (old_mult - new_mult)
- *    base_delta = cycle * (mult_delta)
- *
- * Where mult_delta is the adjustment value made to mult
- *
- */
-static inline s64 make_ntp_adj(struct clocksource *clock,
-				cycles_t cycles_delta, s64* error)
-{
-	s64 ret = 0;
-	if (*error  > ((s64)clock->interval_cycles+1)/2) {
-		/* calculate adjustment value */
-		int adjustment = error_aproximation(*error,
-						clock->interval_cycles);
-		/* adjust clock */
-		clock->mult += 1 << adjustment;
-		clock->interval_snsecs += clock->interval_cycles << adjustment;
-
-		/* adjust the base and error for the adjustment */
-		ret =  -(cycles_delta << adjustment);
-		*error -= clock->interval_cycles << adjustment;
-		/* XXX adj error for cycle_delta offset? */
-	} else if ((-(*error))  > ((s64)clock->interval_cycles+1)/2) {
-		/* calculate adjustment value */
-		int adjustment = error_aproximation(-(*error),
-						clock->interval_cycles);
-		/* adjust clock */
-		clock->mult -= 1 << adjustment;
-		clock->interval_snsecs -= clock->interval_cycles << adjustment;
-
-		/* adjust the base and error for the adjustment */
-		ret =  cycles_delta << adjustment;
-		*error += clock->interval_cycles << adjustment;
-		/* XXX adj error for cycle_delta offset? */
-	}
-	return ret;
+	c->xtime_interval = (u64)c->cycle_interval * c->mult;
 }
 
 

commit 7f9f303aa33c7acc7b4aa9ebea25cbd990bc707b
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Mon Jun 26 00:25:15 2006 -0700

    [PATCH] generic-time: add macro to simplify/hide mask constants
    
    Add a CLOCKSOURCE_MASK macro to simplify initializing the mask for a struct
    clocksource, and use it to replace literal mask constants in the various
    clocksource drivers.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index 5f4a7f72f3ee..4bc94282c364 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -65,6 +65,8 @@ struct clocksource {
 	u64 interval_snsecs;
 };
 
+/* simplify initialization of mask field */
+#define CLOCKSOURCE_MASK(bits) (cycle_t)(bits<64 ? ((1ULL<<bits)-1) : -1)
 
 /**
  * clocksource_khz2mult - calculates mult from khz and shift

commit a275254975a29c51929ee175b92ac471ac2a0043
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:14 2006 -0700

    [PATCH] time: rename clocksource functions
    
    As suggested by Roman Zippel, change clocksource functions to use
    clocksource_xyz rather then xyz_clocksource to avoid polluting the
    namespace.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c4739c4e3039..5f4a7f72f3ee 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -118,12 +118,12 @@ static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
 }
 
 /**
- * read_clocksource: - Access the clocksource's current cycle value
+ * clocksource_read: - Access the clocksource's current cycle value
  * @cs:		pointer to clocksource being read
  *
  * Uses the clocksource to return the current cycle_t value
  */
-static inline cycle_t read_clocksource(struct clocksource *cs)
+static inline cycle_t clocksource_read(struct clocksource *cs)
 {
 	return cs->read();
 }
@@ -145,7 +145,7 @@ static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
 }
 
 /**
- * calculate_clocksource_interval - Calculates a clocksource interval struct
+ * clocksource_calculate_interval - Calculates a clocksource interval struct
  *
  * @c:		Pointer to clocksource.
  * @length_nsec: Desired interval length in nanoseconds.
@@ -155,7 +155,7 @@ static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
  *
  * Unless you're the timekeeping code, you should not be using this!
  */
-static inline void calculate_clocksource_interval(struct clocksource *c,
+static inline void clocksource_calculate_interval(struct clocksource *c,
 						unsigned long length_nsec)
 {
 	u64 tmp;
@@ -271,8 +271,8 @@ static inline s64 make_ntp_adj(struct clocksource *clock,
 
 
 /* used to install a new clocksource */
-int register_clocksource(struct clocksource*);
-void reselect_clocksource(void);
-struct clocksource* get_next_clocksource(void);
+int clocksource_register(struct clocksource*);
+void clocksource_reselect(void);
+struct clocksource* clocksource_get_next(void);
 
 #endif /* _LINUX_CLOCKSOURCE_H */

commit 5eb6d20533d14a432df714520939a6181e28f099
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:07 2006 -0700

    [PATCH] Time: Use clocksource abstraction for NTP adjustments
    
    Instead of incrementing xtime by tick_nsec + ntp adjustments, use the
    clocksource abstraction to increment and scale time.  Using the clocksource
    abstraction allows other clocksources to be used consistently in the face of
    late or lost ticks, while preserving the existing behavior via the jiffies
    clocksource.
    
    This removes the need to keep time_phase adjustments as we just use the
    current_tick_length() function as the NTP interface and accumulate time using
    shifted nanoseconds.
    
    The basics of this design was by Roman Zippel, however it is my own
    interpretation and implementation, so the credit should go to him and the
    blame to me.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
index c4187cda0ee4..c4739c4e3039 100644
--- a/include/linux/clocksource.h
+++ b/include/linux/clocksource.h
@@ -173,6 +173,103 @@ static inline void calculate_clocksource_interval(struct clocksource *c,
 	c->interval_snsecs = (u64)c->interval_cycles * c->mult;
 }
 
+
+/**
+ * error_aproximation - calculates an error adjustment for a given error
+ *
+ * @error:	Error value (unsigned)
+ * @unit:	Adjustment unit
+ *
+ * For a given error value, this function takes the adjustment unit
+ * and uses binary approximation to return a power of two adjustment value.
+ *
+ * This function is only for use by the the make_ntp_adj() function
+ * and you must hold a write on the xtime_lock when calling.
+ */
+static inline int error_aproximation(u64 error, u64 unit)
+{
+	static int saved_adj = 0;
+	u64 adjusted_unit = unit << saved_adj;
+
+	if (error > (adjusted_unit * 2)) {
+		/* large error, so increment the adjustment factor */
+		saved_adj++;
+	} else if (error > adjusted_unit) {
+		/* just right, don't touch it */
+	} else if (saved_adj) {
+		/* small error, so drop the adjustment factor */
+		saved_adj--;
+		return 0;
+	}
+
+	return saved_adj;
+}
+
+
+/**
+ * make_ntp_adj - Adjusts the specified clocksource for a given error
+ *
+ * @clock:		Pointer to clock to be adjusted
+ * @cycles_delta:	Current unacounted cycle delta
+ * @error:		Pointer to current error value
+ *
+ * Returns clock shifted nanosecond adjustment to be applied against
+ * the accumulated time value (ie: xtime).
+ *
+ * If the error value is large enough, this function calulates the
+ * (power of two) adjustment value, and adjusts the clock's mult and
+ * interval_snsecs values accordingly.
+ *
+ * However, since there may be some unaccumulated cycles, to avoid
+ * time inconsistencies we must adjust the accumulation value
+ * accordingly.
+ *
+ * This is not very intuitive, so the following proof should help:
+ * The basic timeofday algorithm:  base + cycle * mult
+ * Thus:
+ *    new_base + cycle * new_mult = old_base + cycle * old_mult
+ *    new_base = old_base + cycle * old_mult - cycle * new_mult
+ *    new_base = old_base + cycle * (old_mult - new_mult)
+ *    new_base - old_base = cycle * (old_mult - new_mult)
+ *    base_delta = cycle * (old_mult - new_mult)
+ *    base_delta = cycle * (mult_delta)
+ *
+ * Where mult_delta is the adjustment value made to mult
+ *
+ */
+static inline s64 make_ntp_adj(struct clocksource *clock,
+				cycles_t cycles_delta, s64* error)
+{
+	s64 ret = 0;
+	if (*error  > ((s64)clock->interval_cycles+1)/2) {
+		/* calculate adjustment value */
+		int adjustment = error_aproximation(*error,
+						clock->interval_cycles);
+		/* adjust clock */
+		clock->mult += 1 << adjustment;
+		clock->interval_snsecs += clock->interval_cycles << adjustment;
+
+		/* adjust the base and error for the adjustment */
+		ret =  -(cycles_delta << adjustment);
+		*error -= clock->interval_cycles << adjustment;
+		/* XXX adj error for cycle_delta offset? */
+	} else if ((-(*error))  > ((s64)clock->interval_cycles+1)/2) {
+		/* calculate adjustment value */
+		int adjustment = error_aproximation(-(*error),
+						clock->interval_cycles);
+		/* adjust clock */
+		clock->mult -= 1 << adjustment;
+		clock->interval_snsecs -= clock->interval_cycles << adjustment;
+
+		/* adjust the base and error for the adjustment */
+		ret =  cycles_delta << adjustment;
+		*error += clock->interval_cycles << adjustment;
+		/* XXX adj error for cycle_delta offset? */
+	}
+	return ret;
+}
+
+
 /* used to install a new clocksource */
 int register_clocksource(struct clocksource*);
 void reselect_clocksource(void);

commit 734efb467b31e56c2f9430590a9aa867ecf3eea1
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:05 2006 -0700

    [PATCH] Time: Clocksource Infrastructure
    
    This introduces the clocksource management infrastructure.  A clocksource is a
    driver-like architecture generic abstraction of a free-running counter.  This
    code defines the clocksource structure, and provides management code for
    registering, selecting, accessing and scaling clocksources.
    
    Additionally, this includes the trivial jiffies clocksource, a lowest common
    denominator clocksource, provided mainly for use as an example.
    
    [hirofumi@mail.parknet.co.jp: Don't enable IRQ too early]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/clocksource.h b/include/linux/clocksource.h
new file mode 100644
index 000000000000..c4187cda0ee4
--- /dev/null
+++ b/include/linux/clocksource.h
@@ -0,0 +1,181 @@
+/*  linux/include/linux/clocksource.h
+ *
+ *  This file contains the structure definitions for clocksources.
+ *
+ *  If you are not a clocksource, or timekeeping code, you should
+ *  not be including this file!
+ */
+#ifndef _LINUX_CLOCKSOURCE_H
+#define _LINUX_CLOCKSOURCE_H
+
+#include <linux/types.h>
+#include <linux/timex.h>
+#include <linux/time.h>
+#include <linux/list.h>
+#include <asm/div64.h>
+#include <asm/io.h>
+
+/* clocksource cycle base type */
+typedef u64 cycle_t;
+
+/**
+ * struct clocksource - hardware abstraction for a free running counter
+ *	Provides mostly state-free accessors to the underlying hardware.
+ *
+ * @name:		ptr to clocksource name
+ * @list:		list head for registration
+ * @rating:		rating value for selection (higher is better)
+ *			To avoid rating inflation the following
+ *			list should give you a guide as to how
+ *			to assign your clocksource a rating
+ *			1-99: Unfit for real use
+ *				Only available for bootup and testing purposes.
+ *			100-199: Base level usability.
+ *				Functional for real use, but not desired.
+ *			200-299: Good.
+ *				A correct and usable clocksource.
+ *			300-399: Desired.
+ *				A reasonably fast and accurate clocksource.
+ *			400-499: Perfect
+ *				The ideal clocksource. A must-use where
+ *				available.
+ * @read:		returns a cycle value
+ * @mask:		bitmask for two's complement
+ *			subtraction of non 64 bit counters
+ * @mult:		cycle to nanosecond multiplier
+ * @shift:		cycle to nanosecond divisor (power of two)
+ * @update_callback:	called when safe to alter clocksource values
+ * @is_continuous:	defines if clocksource is free-running.
+ * @interval_cycles:	Used internally by timekeeping core, please ignore.
+ * @interval_snsecs:	Used internally by timekeeping core, please ignore.
+ */
+struct clocksource {
+	char *name;
+	struct list_head list;
+	int rating;
+	cycle_t (*read)(void);
+	cycle_t mask;
+	u32 mult;
+	u32 shift;
+	int (*update_callback)(void);
+	int is_continuous;
+
+	/* timekeeping specific data, ignore */
+	cycle_t interval_cycles;
+	u64 interval_snsecs;
+};
+
+
+/**
+ * clocksource_khz2mult - calculates mult from khz and shift
+ * @khz:		Clocksource frequency in KHz
+ * @shift_constant:	Clocksource shift factor
+ *
+ * Helper functions that converts a khz counter frequency to a timsource
+ * multiplier, given the clocksource shift value
+ */
+static inline u32 clocksource_khz2mult(u32 khz, u32 shift_constant)
+{
+	/*  khz = cyc/(Million ns)
+	 *  mult/2^shift  = ns/cyc
+	 *  mult = ns/cyc * 2^shift
+	 *  mult = 1Million/khz * 2^shift
+	 *  mult = 1000000 * 2^shift / khz
+	 *  mult = (1000000<<shift) / khz
+	 */
+	u64 tmp = ((u64)1000000) << shift_constant;
+
+	tmp += khz/2; /* round for do_div */
+	do_div(tmp, khz);
+
+	return (u32)tmp;
+}
+
+/**
+ * clocksource_hz2mult - calculates mult from hz and shift
+ * @hz:			Clocksource frequency in Hz
+ * @shift_constant:	Clocksource shift factor
+ *
+ * Helper functions that converts a hz counter
+ * frequency to a timsource multiplier, given the
+ * clocksource shift value
+ */
+static inline u32 clocksource_hz2mult(u32 hz, u32 shift_constant)
+{
+	/*  hz = cyc/(Billion ns)
+	 *  mult/2^shift  = ns/cyc
+	 *  mult = ns/cyc * 2^shift
+	 *  mult = 1Billion/hz * 2^shift
+	 *  mult = 1000000000 * 2^shift / hz
+	 *  mult = (1000000000<<shift) / hz
+	 */
+	u64 tmp = ((u64)1000000000) << shift_constant;
+
+	tmp += hz/2; /* round for do_div */
+	do_div(tmp, hz);
+
+	return (u32)tmp;
+}
+
+/**
+ * read_clocksource: - Access the clocksource's current cycle value
+ * @cs:		pointer to clocksource being read
+ *
+ * Uses the clocksource to return the current cycle_t value
+ */
+static inline cycle_t read_clocksource(struct clocksource *cs)
+{
+	return cs->read();
+}
+
+/**
+ * cyc2ns - converts clocksource cycles to nanoseconds
+ * @cs:		Pointer to clocksource
+ * @cycles:	Cycles
+ *
+ * Uses the clocksource and ntp ajdustment to convert cycle_ts to nanoseconds.
+ *
+ * XXX - This could use some mult_lxl_ll() asm optimization
+ */
+static inline s64 cyc2ns(struct clocksource *cs, cycle_t cycles)
+{
+	u64 ret = (u64)cycles;
+	ret = (ret * cs->mult) >> cs->shift;
+	return ret;
+}
+
+/**
+ * calculate_clocksource_interval - Calculates a clocksource interval struct
+ *
+ * @c:		Pointer to clocksource.
+ * @length_nsec: Desired interval length in nanoseconds.
+ *
+ * Calculates a fixed cycle/nsec interval for a given clocksource/adjustment
+ * pair and interval request.
+ *
+ * Unless you're the timekeeping code, you should not be using this!
+ */
+static inline void calculate_clocksource_interval(struct clocksource *c,
+						unsigned long length_nsec)
+{
+	u64 tmp;
+
+	/* XXX - All of this could use a whole lot of optimization */
+	tmp = length_nsec;
+	tmp <<= c->shift;
+	tmp += c->mult/2;
+	do_div(tmp, c->mult);
+
+	c->interval_cycles = (cycle_t)tmp;
+	if(c->interval_cycles == 0)
+		c->interval_cycles = 1;
+
+	c->interval_snsecs = (u64)c->interval_cycles * c->mult;
+}
+
+/* used to install a new clocksource */
+int register_clocksource(struct clocksource*);
+void reselect_clocksource(void);
+struct clocksource* get_next_clocksource(void);
+
+#endif /* _LINUX_CLOCKSOURCE_H */
