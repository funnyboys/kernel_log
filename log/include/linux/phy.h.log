commit 3dd4ef1bdbac959bb20faec93937720ddd9917c6
Author: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
Date:   Wed Jun 24 15:58:24 2020 +0800

    net: phy: make phy_disable_interrupts() non-static
    
    We face an issue with rtl8211f, a pin is shared between INTB and PMEB,
    and the PHY Register Accessible Interrupt is enabled by default, so
    the INTB/PMEB pin is always active in polling mode case.
    
    As Heiner pointed out "I was thinking about calling
    phy_disable_interrupts() in phy_init_hw(), to have a defined init
    state as we don't know in which state the PHY is if the PHY driver is
    loaded. We shouldn't assume that it's the chip power-on defaults, BIOS
    or boot loader could have changed this. Or in case of dual-boot
    systems the other OS could leave the PHY in whatever state."
    
    Make phy_disable_interrupts() non-static so that it could be used in
    phy_init_hw() to have a defined init state.
    
    Suggested-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8c05d0fb5c00..b693b609b2f5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1416,6 +1416,7 @@ int phy_ethtool_ksettings_set(struct phy_device *phydev,
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 int phy_do_ioctl_running(struct net_device *dev, struct ifreq *ifr, int cmd);
+int phy_disable_interrupts(struct phy_device *phydev);
 void phy_request_interrupt(struct phy_device *phydev);
 void phy_free_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);

commit f2bc8ad31a7f814237bc6301d59296d76505a688
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed May 27 00:21:41 2020 +0200

    net: ethtool: Allow PHY cable test TDR data to configured
    
    Allow the user to configure where on the cable the TDR data should be
    retrieved, in terms of first and last sample, and the step between
    samples. Also add the ability to ask for TDR data for just one pair.
    
    If this configuration is not provided, it defaults to 1-150m at 1m
    intervals for all pairs.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    
    v3:
    Move the TDR configuration into a structure
    Add a range check on step
    Use NL_SET_ERR_MSG_ATTR() when appropriate
    Move TDR configuration into a nest
    Document attributes in the request
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d3c384f353ca..8c05d0fb5c00 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -548,6 +548,18 @@ struct phy_device {
 #define to_phy_device(d) container_of(to_mdio_device(d), \
 				      struct phy_device, mdio)
 
+/* A structure containing possible configuration parameters
+ * for a TDR cable test. The driver does not need to implement
+ * all the parameters, but should report what is actually used.
+ */
+struct phy_tdr_config {
+	u32 first;
+	u32 last;
+	u32 step;
+	s8 pair;
+};
+#define PHY_PAIR_ALL -1
+
 /* struct phy_driver: Driver structure for a particular PHY type
  *
  * driver_data: static driver data
@@ -701,7 +713,8 @@ struct phy_driver {
 	int (*cable_test_start)(struct phy_device *dev);
 
 	/* Start a raw TDR cable test */
-	int (*cable_test_tdr_start)(struct phy_device *dev);
+	int (*cable_test_tdr_start)(struct phy_device *dev,
+				    const struct phy_tdr_config *config);
 
 	/* Once per second, or on interrupt, request the status of the
 	 * test.
@@ -1256,7 +1269,8 @@ int phy_reset_after_clk_enable(struct phy_device *phydev);
 int phy_start_cable_test(struct phy_device *phydev,
 			 struct netlink_ext_ack *extack);
 int phy_start_cable_test_tdr(struct phy_device *phydev,
-			     struct netlink_ext_ack *extack);
+			     struct netlink_ext_ack *extack,
+			     const struct phy_tdr_config *config);
 #else
 static inline
 int phy_start_cable_test(struct phy_device *phydev,
@@ -1267,7 +1281,8 @@ int phy_start_cable_test(struct phy_device *phydev,
 }
 static inline
 int phy_start_cable_test_tdr(struct phy_device *phydev,
-			     struct netlink_ext_ack *extack)
+			     struct netlink_ext_ack *extack,
+			     const struct phy_tdr_config *config)
 {
 	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
 	return -EOPNOTSUPP;

commit 1a644de29f712771c2ec00e52caa391544eb6141
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed May 27 00:21:38 2020 +0200

    net: ethtool: Add generic parts of cable test TDR
    
    Add the generic parts of the code used to trigger a cable test and
    return raw TDR data. Any PHY driver which support this must implement
    the new driver op.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    
    v2
    Update nxp-tja11xx for API change.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6d256e720a66..d3c384f353ca 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -699,6 +699,10 @@ struct phy_driver {
 
 	/* Start a cable test */
 	int (*cable_test_start)(struct phy_device *dev);
+
+	/* Start a raw TDR cable test */
+	int (*cable_test_tdr_start)(struct phy_device *dev);
+
 	/* Once per second, or on interrupt, request the status of the
 	 * test.
 	 */
@@ -1251,6 +1255,8 @@ int phy_reset_after_clk_enable(struct phy_device *phydev);
 #if IS_ENABLED(CONFIG_PHYLIB)
 int phy_start_cable_test(struct phy_device *phydev,
 			 struct netlink_ext_ack *extack);
+int phy_start_cable_test_tdr(struct phy_device *phydev,
+			     struct netlink_ext_ack *extack);
 #else
 static inline
 int phy_start_cable_test(struct phy_device *phydev,
@@ -1259,6 +1265,13 @@ int phy_start_cable_test(struct phy_device *phydev,
 	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
 	return -EOPNOTSUPP;
 }
+static inline
+int phy_start_cable_test_tdr(struct phy_device *phydev,
+			     struct netlink_ext_ack *extack)
+{
+	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
+	return -EOPNOTSUPP;
+}
 #endif
 
 int phy_cable_test_result(struct phy_device *phydev, u8 pair, u16 result);

commit 90ce665c6a40dc1be771bf5f86e624c0acf3a76f
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue May 26 16:29:36 2020 +0100

    net: mdiobus: add clause 45 mdiobus accessors
    
    There is a recurring pattern throughout some of the PHY code converting
    a devad and regnum to our packed clause 45 representation. Rather than
    having this scattered around the code, let's put a common translation
    function in mdio.h, and provide some register accessors.
    
    Convert the phylib core, phylink, bcm87xx and cortina to use these.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2bcdf19ed3b4..6d256e720a66 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -209,12 +209,6 @@ static inline const char *phy_modes(phy_interface_t interface)
 
 #define MII_BUS_ID_SIZE	61
 
-/* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit
-   IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
-#define MII_ADDR_C45 (1<<30)
-#define MII_DEVADDR_C45_SHIFT	16
-#define MII_REGADDR_C45_MASK	GENMASK(15, 0)
-
 struct device;
 struct phylink;
 struct sfp_bus;

commit 8066021915924f58ed338bf38208215f5a7355f6
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Wed May 20 08:29:14 2020 +0200

    ethtool: provide UAPI for PHY Signal Quality Index (SQI)
    
    Signal Quality Index is a mandatory value required by "OPEN Alliance
    SIG" for the 100Base-T1 PHYs [1]. This indicator can be used for cable
    integrity diagnostic and investigating other noise sources and
    implement by at least two vendors: NXP[2] and TI[3].
    
    [1] http://www.opensig.org/download/document/218/Advanced_PHY_features_for_automotive_Ethernet_V1.0.pdf
    [2] https://www.nxp.com/docs/en/data-sheet/TJA1100.pdf
    [3] https://www.ti.com/product/DP83TC811R-Q1
    
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 467aa8bf9f64..2bcdf19ed3b4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -723,6 +723,8 @@ struct phy_driver {
 			    struct ethtool_tunable *tuna,
 			    const void *data);
 	int (*set_loopback)(struct phy_device *dev, bool enable);
+	int (*get_sqi)(struct phy_device *dev);
+	int (*get_sqi_max)(struct phy_device *dev);
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)

commit a307593a644443db12888f45eed0dafb5869e2cc
Author: Doug Berger <opendmb@gmail.com>
Date:   Mon May 18 15:23:59 2020 -0700

    net: phy: simplify phy_link_change arguments
    
    This function was introduced to allow for different handling of
    link up and link down events particularly with regard to the
    netif_carrier. The third argument do_carrier allowed the flag to
    be left unchanged.
    
    Since then the phylink has introduced an implementation that
    completely ignores the third parameter since it never wants to
    change the flag and the phylib always sets the third parameter
    to true so the flag is always changed.
    
    Therefore the third argument (i.e. do_carrier) is no longer
    necessary and can be removed. This also means that the phylib
    phy_link_down() function no longer needs its second argument.
    
    Signed-off-by: Doug Berger <opendmb@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5d8ff5428010..467aa8bf9f64 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -543,7 +543,7 @@ struct phy_device {
 	u8 mdix;
 	u8 mdix_ctrl;
 
-	void (*phy_link_change)(struct phy_device *, bool up, bool do_carrier);
+	void (*phy_link_change)(struct phy_device *phydev, bool up);
 	void (*adjust_link)(struct net_device *dev);
 
 #if IS_ENABLED(CONFIG_MACSEC)

commit 1e2dc14509fd072739e4bab98ac42317267dbad6
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 10 21:12:37 2020 +0200

    net: ethtool: Add helpers for reporting test results
    
    The PHY drivers can use these helpers for reporting the results. The
    results get translated into netlink attributes which are added to the
    pre-allocated skbuf.
    
    v3:
    Poison phydev->skb
    Return -EMSGSIZE when ethnl_bcastmsg_put() fails
    Return valid error code when nla_nest_start() fails
    Use u8 for results
    Actually put u32 length into message
    
    v4:
    s/ENOTSUPP/EOPNOTSUPP/g
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 169fae4249a9..5d8ff5428010 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1265,6 +1265,10 @@ int phy_start_cable_test(struct phy_device *phydev,
 }
 #endif
 
+int phy_cable_test_result(struct phy_device *phydev, u8 pair, u16 result);
+int phy_cable_test_fault_length(struct phy_device *phydev, u8 pair,
+				u16 cm);
+
 static inline void phy_device_reset(struct phy_device *phydev, int value)
 {
 	mdio_device_reset(&phydev->mdio, value);

commit 1dd3f212af30b42c90ba252c165f2f6d2ddf5230
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 10 21:12:36 2020 +0200

    net: ethtool: Add infrastructure for reporting cable test results
    
    Provide infrastructure for PHY drivers to report the cable test
    results.  A netlink skb is associated to the phydev. Helpers will be
    added which can add results to this skb. Once the test has finished
    the results are sent to user space.
    
    When netlink ethtool is not part of the kernel configuration stubs are
    provided. It is also impossible to trigger a cable test, so the error
    code returned by the alloc function is of no consequence.
    
    v2:
    Include the status complete in the netlink notification message
    
    v4:
    Replace -EINVAL with -EMSGSIZE
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f58eee735a45..169fae4249a9 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -523,6 +523,11 @@ struct phy_device {
 	/* For use by PHYs inside the same package that need a shared state. */
 	struct phy_package_shared *shared;
 
+	/* Reporting cable test results */
+	struct sk_buff *skb;
+	void *ehdr;
+	struct nlattr *nest;
+
 	/* Interrupt and Polling infrastructure */
 	struct delayed_work state_queue;
 

commit 97c22438963a7484c05c59ab6654e30f0a3e9288
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 10 21:12:32 2020 +0200

    net: phy: Add support for polling cable test
    
    Some PHYs are not capable of generating interrupts when a cable test
    finished. They do however support interrupts for normal operations,
    like link up/down. As such, the PHY state machine would normally not
    poll the PHY.
    
    Add support for indicating the PHY state machine must poll the PHY
    when performing a cable test.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 632403fc34f4..f58eee735a45 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -79,6 +79,7 @@ extern const int phy_10gbit_features_array[1];
 
 #define PHY_IS_INTERNAL		0x00000001
 #define PHY_RST_AFTER_CLK_EN	0x00000002
+#define PHY_POLL_CABLE_TEST	0x00000004
 #define MDIO_DEVICE_IS_PHY	0x80000000
 
 /* Interface Mode definitions */
@@ -1061,6 +1062,10 @@ static inline bool phy_interrupt_is_valid(struct phy_device *phydev)
  */
 static inline bool phy_polling_mode(struct phy_device *phydev)
 {
+	if (phydev->state == PHY_CABLETEST)
+		if (phydev->drv->flags & PHY_POLL_CABLE_TEST)
+			return true;
+
 	return phydev->irq == PHY_POLL;
 }
 

commit a68a813836e12b15715d9101309899123c250302
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 10 21:12:30 2020 +0200

    net: phy: Add cable test support to state machine
    
    Running a cable test is desruptive to normal operation of the PHY and
    can take a 5 to 10 seconds to complete. The RTNL lock cannot be held
    for this amount of time, and add a new state to the state machine for
    running a cable test.
    
    The driver is expected to implement two functions. The first is used
    to start a cable test. Once the test has started, it should return.
    
    The second function is called once per second, or on interrupt to
    check if the cable test is complete, and to allow the PHY to report
    the status.
    
    v2:
    Rename phy_cable_test_abort to phy_abort_cable_test
    Return different extack when already running test
    Use phy_init_hw() to reset the PHY
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a2b91b5f9d0a..632403fc34f4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -15,6 +15,7 @@
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
 #include <linux/linkmode.h>
+#include <linux/netlink.h>
 #include <linux/mdio.h>
 #include <linux/mii.h>
 #include <linux/mii_timestamper.h>
@@ -372,6 +373,12 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  * - irq or timer will set NOLINK if link goes down
  * - phy_stop moves to HALTED
  *
+ * CABLETEST: PHY is performing a cable test. Packet reception/sending
+ * is not expected to work, carrier will be indicated as down. PHY will be
+ * poll once per second, or on interrupt for it current state.
+ * Once complete, move to UP to restart the PHY.
+ * - phy_stop aborts the running test and moves to HALTED
+ *
  * HALTED: PHY is up, but no polling or interrupts are done. Or
  * PHY is in an error state.
  * - phy_start moves to UP
@@ -383,6 +390,7 @@ enum phy_state {
 	PHY_UP,
 	PHY_RUNNING,
 	PHY_NOLINK,
+	PHY_CABLETEST,
 };
 
 /**
@@ -689,6 +697,13 @@ struct phy_driver {
 	int (*module_eeprom)(struct phy_device *dev,
 			     struct ethtool_eeprom *ee, u8 *data);
 
+	/* Start a cable test */
+	int (*cable_test_start)(struct phy_device *dev);
+	/* Once per second, or on interrupt, request the status of the
+	 * test.
+	 */
+	int (*cable_test_get_status)(struct phy_device *dev, bool *finished);
+
 	/* Get statistics from the phy using ethtool */
 	int (*get_sset_count)(struct phy_device *dev);
 	void (*get_strings)(struct phy_device *dev, u8 *data);
@@ -1227,6 +1242,19 @@ int phy_speed_up(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);
 int phy_reset_after_clk_enable(struct phy_device *phydev);
 
+#if IS_ENABLED(CONFIG_PHYLIB)
+int phy_start_cable_test(struct phy_device *phydev,
+			 struct netlink_ext_ack *extack);
+#else
+static inline
+int phy_start_cable_test(struct phy_device *phydev,
+			 struct netlink_ext_ack *extack)
+{
+	NL_SET_ERR_MSG(extack, "Kernel not compiled with PHYLIB support");
+	return -EOPNOTSUPP;
+}
+#endif
+
 static inline void phy_device_reset(struct phy_device *phydev, int value)
 {
 	mdio_device_reset(&phydev->mdio, value);

commit bdbdac7649fac05f88c9f7ab18121a17fb591687
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Tue May 5 08:35:05 2020 +0200

    ethtool: provide UAPI for PHY master/slave configuration.
    
    This UAPI is needed for BroadR-Reach 100BASE-T1 devices. Due to lack of
    auto-negotiation support, we needed to be able to configure the
    MASTER-SLAVE role of the port manually or from an application in user
    space.
    
    The same UAPI can be used for 1000BASE-T or MultiGBASE-T devices to
    force MASTER or SLAVE role. See IEEE 802.3-2018:
    22.2.4.3.7 MASTER-SLAVE control register (Register 9)
    22.2.4.3.8 MASTER-SLAVE status register (Register 10)
    40.5.2 MASTER-SLAVE configuration resolution
    45.2.1.185.1 MASTER-SLAVE config value (1.2100.14)
    45.2.7.10 MultiGBASE-T AN control 1 register (Register 7.32)
    
    The MASTER-SLAVE role affects the clock configuration:
    
    -------------------------------------------------------------------------------
    When the  PHY is configured as MASTER, the PMA Transmit function shall
    source TX_TCLK from a local clock source. When configured as SLAVE, the
    PMA Transmit function shall source TX_TCLK from the clock recovered from
    data stream provided by MASTER.
    
    iMX6Q                     KSZ9031                XXX
    ------\                /-----------\        /------------\
          |                |           |        |            |
     MAC  |<----RGMII----->| PHY Slave |<------>| PHY Master |
          |<--- 125 MHz ---+-<------/  |        | \          |
    ------/                \-----------/        \------------/
                                                   ^
                                                    \-TX_TCLK
    
    -------------------------------------------------------------------------------
    
    Since some clock or link related issues are only reproducible in a
    specific MASTER-SLAVE-role, MAC and PHY configuration, it is beneficial
    to provide generic (not 100BASE-T1 specific) interface to the user space
    for configuration flexibility and trouble shooting.
    
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1d36ac608159..a2b91b5f9d0a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -477,6 +477,9 @@ struct phy_device {
 	int duplex;
 	int pause;
 	int asym_pause;
+	u8 master_slave_get;
+	u8 master_slave_set;
+	u8 master_slave_state;
 
 	/* Union of PHY and Attached devices' supported link modes */
 	/* See ethtool.h for more info */

commit 6349084746ff4f5f7ebc748e4b2a890f8c57b129
Author: Michael Walle <michael@walle.cc>
Date:   Wed May 6 16:53:13 2020 +0200

    net: phy: add concept of shared storage for PHYs
    
    There are packages which contain multiple PHY devices, eg. a quad PHY
    transceiver. Provide functions to allocate and free shared storage.
    
    Usually, a quad PHY contains global registers, which don't belong to any
    PHY. Provide convenience functions to access these registers.
    
    Signed-off-by: Michael Walle <michael@walle.cc>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e2bfb9240587..1d36ac608159 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -25,6 +25,7 @@
 #include <linux/u64_stats_sync.h>
 #include <linux/irqreturn.h>
 #include <linux/iopoll.h>
+#include <linux/refcount.h>
 
 #include <linux/atomic.h>
 
@@ -227,6 +228,28 @@ struct mdio_bus_stats {
 	struct u64_stats_sync syncp;
 };
 
+/* Represents a shared structure between different phydev's in the same
+ * package, for example a quad PHY. See phy_package_join() and
+ * phy_package_leave().
+ */
+struct phy_package_shared {
+	int addr;
+	refcount_t refcnt;
+	unsigned long flags;
+	size_t priv_size;
+
+	/* private data pointer */
+	/* note that this pointer is shared between different phydevs and
+	 * the user has to take care of appropriate locking. It is allocated
+	 * and freed automatically by phy_package_join() and
+	 * phy_package_leave().
+	 */
+	void *priv;
+};
+
+/* used as bit number in atomic bitops */
+#define PHY_SHARED_F_INIT_DONE 0
+
 /*
  * The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure
@@ -278,6 +301,12 @@ struct mii_bus {
 	int reset_delay_us;
 	/* RESET GPIO descriptor pointer */
 	struct gpio_desc *reset_gpiod;
+
+	/* protect access to the shared element */
+	struct mutex shared_lock;
+
+	/* shared state across different PHYs */
+	struct phy_package_shared *shared[PHY_MAX_ADDR];
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 
@@ -478,6 +507,10 @@ struct phy_device {
 	/* For use by PHYs to maintain extra state */
 	void *priv;
 
+	/* shared data pointer */
+	/* For use by PHYs inside the same package that need a shared state. */
+	struct phy_package_shared *shared;
+
 	/* Interrupt and Polling infrastructure */
 	struct delayed_work state_queue;
 
@@ -1354,6 +1387,10 @@ int phy_ethtool_get_link_ksettings(struct net_device *ndev,
 int phy_ethtool_set_link_ksettings(struct net_device *ndev,
 				   const struct ethtool_link_ksettings *cmd);
 int phy_ethtool_nway_reset(struct net_device *ndev);
+int phy_package_join(struct phy_device *phydev, int addr, size_t priv_size);
+void phy_package_leave(struct phy_device *phydev);
+int devm_phy_package_join(struct device *dev, struct phy_device *phydev,
+			  int addr, size_t priv_size);
 
 #if IS_ENABLED(CONFIG_PHYLIB)
 int __init mdio_bus_init(void);
@@ -1406,6 +1443,58 @@ static inline int phy_ethtool_get_stats(struct phy_device *phydev,
 	return 0;
 }
 
+static inline int phy_package_read(struct phy_device *phydev, u32 regnum)
+{
+	struct phy_package_shared *shared = phydev->shared;
+
+	if (!shared)
+		return -EIO;
+
+	return mdiobus_read(phydev->mdio.bus, shared->addr, regnum);
+}
+
+static inline int __phy_package_read(struct phy_device *phydev, u32 regnum)
+{
+	struct phy_package_shared *shared = phydev->shared;
+
+	if (!shared)
+		return -EIO;
+
+	return __mdiobus_read(phydev->mdio.bus, shared->addr, regnum);
+}
+
+static inline int phy_package_write(struct phy_device *phydev,
+				    u32 regnum, u16 val)
+{
+	struct phy_package_shared *shared = phydev->shared;
+
+	if (!shared)
+		return -EIO;
+
+	return mdiobus_write(phydev->mdio.bus, shared->addr, regnum, val);
+}
+
+static inline int __phy_package_write(struct phy_device *phydev,
+				      u32 regnum, u16 val)
+{
+	struct phy_package_shared *shared = phydev->shared;
+
+	if (!shared)
+		return -EIO;
+
+	return __mdiobus_write(phydev->mdio.bus, shared->addr, regnum, val);
+}
+
+static inline bool phy_package_init_once(struct phy_device *phydev)
+{
+	struct phy_package_shared *shared = phydev->shared;
+
+	if (!shared)
+		return false;
+
+	return !test_and_set_bit(PHY_SHARED_F_INIT_DONE, &shared->flags);
+}
+
 extern struct bus_type mdio_bus_type;
 
 struct mdio_board_info {

commit 3194915486b2bc3f77745774f1731b78f32ff688
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Apr 23 21:35:36 2020 +0200

    net: phy: remove genphy_no_soft_reset
    
    Since 6e2d85ec0559 ("net: phy: Stop with excessive soft reset")
    we don't need genphy_no_soft_reset() any longer. Not setting
    callback soft_reset results in a no-op now.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3941a6bcba10..e2bfb9240587 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1251,10 +1251,6 @@ static inline int genphy_config_aneg(struct phy_device *phydev)
 	return __genphy_config_aneg(phydev, false);
 }
 
-static inline int genphy_no_soft_reset(struct phy_device *phydev)
-{
-	return 0;
-}
 static inline int genphy_no_ack_interrupt(struct phy_device *phydev)
 {
 	return 0;

commit 38f961e744840db9044af68f4773ae5feae60a89
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Apr 20 23:29:05 2020 +0200

    net: phy: add device-managed devm_mdiobus_register
    
    If there's no special ordering requirement for mdiobus_unregister(),
    then driver code can be simplified by using a device-managed version
    of mdiobus_register(). Prerequisite is that bus allocation has been
    done device-managed too. Else mdiobus_free() may be called whilst
    bus is still registered, resulting in a BUG_ON(). Therefore let
    devm_mdiobus_register() return -EPERM if bus was allocated
    non-managed.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2432ca463ddc..3941a6bcba10 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -241,6 +241,9 @@ struct mii_bus {
 	int (*reset)(struct mii_bus *bus);
 	struct mdio_bus_stats stats[PHY_MAX_ADDR];
 
+	unsigned int is_managed:1;	/* is device-managed */
+	unsigned int is_managed_registered:1;
+
 	/*
 	 * A lock to ensure that only one thing can read/write
 	 * the MDIO bus at a time
@@ -286,6 +289,20 @@ static inline struct mii_bus *mdiobus_alloc(void)
 
 int __mdiobus_register(struct mii_bus *bus, struct module *owner);
 #define mdiobus_register(bus) __mdiobus_register(bus, THIS_MODULE)
+static inline int devm_mdiobus_register(struct mii_bus *bus)
+{
+	int ret;
+
+	if (!bus->is_managed)
+		return -EPERM;
+
+	ret = mdiobus_register(bus);
+	if (!ret)
+		bus->is_managed_registered = 1;
+
+	return ret;
+}
+
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);
 struct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv);

commit fcbd30d09ba05389cb40cc1769b565df62aead35
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Mon Mar 23 23:05:57 2020 +0800

    net: phy: introduce phy_read_poll_timeout macro
    
    it is sometimes necessary to poll a phy register by phy_read()
    function until its value satisfies some condition. introduce
    phy_read_poll_timeout() macros that do this.
    
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3984f375126e..2432ca463ddc 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -717,6 +717,19 @@ static inline int phy_read(struct phy_device *phydev, u32 regnum)
 	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
 }
 
+#define phy_read_poll_timeout(phydev, regnum, val, cond, sleep_us, \
+				timeout_us, sleep_before_read) \
+({ \
+	int __ret = read_poll_timeout(phy_read, val, (cond) || val < 0, \
+		sleep_us, timeout_us, sleep_before_read, phydev, regnum); \
+	if (val <  0) \
+		__ret = val; \
+	if (__ret) \
+		phydev_err(phydev, "%s failed: %d\n", __func__, __ret); \
+	__ret; \
+})
+
+
 /**
  * __phy_read - convenience function for reading a given PHY register
  * @phydev: the phy_device struct

commit bd971ff0b73927b91f4520621d49d3a801ee4837
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Mon Mar 23 23:05:53 2020 +0800

    net: phy: introduce phy_read_mmd_poll_timeout macro
    
    it is sometimes necessary to poll a phy register by phy_read_mmd()
    function until its value satisfies some condition. introduce
    phy_read_mmd_poll_timeout() macros that do this.
    
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 99b5e3c4b621..3984f375126e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -24,6 +24,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/u64_stats_sync.h>
 #include <linux/irqreturn.h>
+#include <linux/iopoll.h>
 
 #include <linux/atomic.h>
 
@@ -787,6 +788,19 @@ static inline int __phy_modify_changed(struct phy_device *phydev, u32 regnum,
  */
 int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
 
+#define phy_read_mmd_poll_timeout(phydev, devaddr, regnum, val, cond, \
+				  sleep_us, timeout_us, sleep_before_read) \
+({ \
+	int __ret = read_poll_timeout(phy_read_mmd, val, (cond) || val < 0, \
+				  sleep_us, timeout_us, sleep_before_read, \
+				  phydev, devaddr, regnum); \
+	if (val <  0) \
+		__ret = val; \
+	if (__ret) \
+		phydev_err(phydev, "%s failed: %d\n", __func__, __ret); \
+	__ret; \
+})
+
 /**
  * __phy_read_mmd - Convenience function for reading a register
  * from an MMD on a given PHY.

commit 5eee3bb7103f4a66e4b90c2817f5e72509a2a607
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Mar 20 17:51:38 2020 +0100

    net: phy: add and use phy_check_downshift
    
    So far PHY drivers have to check whether a downshift occurred to be
    able to notify the user. To make life of drivers authors a little bit
    easier move the downshift notification to phylib. phy_check_downshift()
    compares the highest mutually advertised speed with the actual value
    of phydev->speed (typically read by the PHY driver from a
    vendor-specific register) to detect a downshift.
    
    v2:
    - Add downshift hint to phy_print_status
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 36d9dea04016..99b5e3c4b621 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -365,6 +365,7 @@ struct macsec_ops;
  * suspended_by_mdio_bus: Set to true if this phy was suspended by MDIO bus.
  * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
  * loopback_enabled: Set true if this phy has been loopbacked successfully.
+ * downshifted_rate: Set true if link speed has been downshifted.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * irq: IRQ number of the PHY's interrupt (-1 if none)
@@ -405,6 +406,7 @@ struct phy_device {
 	unsigned suspended_by_mdio_bus:1;
 	unsigned sysfs_links:1;
 	unsigned loopback_enabled:1;
+	unsigned downshifted_rate:1;
 
 	unsigned autoneg:1;
 	/* The most recently read link state */
@@ -698,6 +700,7 @@ static inline bool phy_is_started(struct phy_device *phydev)
 
 void phy_resolve_aneg_pause(struct phy_device *phydev);
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);
+void phy_check_downshift(struct phy_device *phydev);
 
 /**
  * phy_read - Convenience function for reading a given PHY register

commit 6cc7cf8125b3d086cd80c96e02edb6f4ab9b20fa
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Mar 17 14:52:31 2020 +0000

    net: mdiobus: add APIs for modifying a MDIO device register
    
    Add APIs for modifying a MDIO device register, similar to the existing
    phy_modify() group of functions, but at mdiobus level instead.  Adapt
    __phy_modify_changed() to use the new mdiobus level helper.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index cb5a2182ba6d..36d9dea04016 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -754,6 +754,25 @@ static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 			       val);
 }
 
+/**
+ * __phy_modify_changed() - Convenience function for modifying a PHY register
+ * @phydev: a pointer to a &struct phy_device
+ * @regnum: register number
+ * @mask: bit mask of bits to clear
+ * @set: bit mask of bits to set
+ *
+ * Unlocked helper function which allows a PHY register to be modified as
+ * new register value = (old register value & ~mask) | set
+ *
+ * Returns negative errno, 0 if there was no change, and 1 in case of change
+ */
+static inline int __phy_modify_changed(struct phy_device *phydev, u32 regnum,
+				       u16 mask, u16 set)
+{
+	return __mdiobus_modify_changed(phydev->mdio.bus, phydev->mdio.addr,
+					regnum, mask, set);
+}
+
 /**
  * phy_read_mmd - Convenience function for reading a register
  * from an MMD on a given PHY.

commit 9010f9deb000edce823cb79345f137742ccffa19
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Mar 16 22:32:33 2020 +0100

    net: phy: improve phy_driver callback handle_interrupt
    
    did_interrupt() clears the interrupt, therefore handle_interrupt() can
    not check which event triggered the interrupt. To overcome this
    constraint and allow more flexibility for customer interrupt handlers,
    let's decouple handle_interrupt() from parts of the phylib interrupt
    handling. Custom interrupt handlers now have to implement the
    did_interrupt() functionality in handle_interrupt() if needed.
    
    Fortunately we have just one custom interrupt handler so far (in the
    mscc PHY driver), convert it to the changed API.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6b872aed8ba6..cb5a2182ba6d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -23,6 +23,7 @@
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
 #include <linux/u64_stats_sync.h>
+#include <linux/irqreturn.h>
 
 #include <linux/atomic.h>
 
@@ -568,7 +569,7 @@ struct phy_driver {
 	int (*did_interrupt)(struct phy_device *phydev);
 
 	/* Override default interrupt handling */
-	int (*handle_interrupt)(struct phy_device *phydev);
+	irqreturn_t (*handle_interrupt)(struct phy_device *phydev);
 
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);

commit 58b05e58d155fd5a9a181d51b4c9c8a69a0816d3
Author: Jose Abreu <Jose.Abreu@synopsys.com>
Date:   Thu Mar 12 18:10:09 2020 +0100

    net: phy: Add XLGMII interface define
    
    Add a define for XLGMII interface.
    
    Signed-off-by: Jose Abreu <Jose.Abreu@synopsys.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7a08023bdbc5..6b872aed8ba6 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -94,6 +94,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_RTBI,
 	PHY_INTERFACE_MODE_SMII,
 	PHY_INTERFACE_MODE_XGMII,
+	PHY_INTERFACE_MODE_XLGMII,
 	PHY_INTERFACE_MODE_MOCA,
 	PHY_INTERFACE_MODE_QSGMII,
 	PHY_INTERFACE_MODE_TRGMII,
@@ -165,6 +166,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "smii";
 	case PHY_INTERFACE_MODE_XGMII:
 		return "xgmii";
+	case PHY_INTERFACE_MODE_XLGMII:
+		return "xlgmii";
 	case PHY_INTERFACE_MODE_MOCA:
 		return "moca";
 	case PHY_INTERFACE_MODE_QSGMII:

commit 1d343579312311aa9875b34d5a921f5e2ec69f0a
Merge: a8eceea84a3a 0d81a3f29c0a
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Mar 12 21:29:30 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Minor overlapping changes, nothing serious.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 611d779af7cad2b87487ff58e4931a90c20b113c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Mar 12 22:25:20 2020 +0100

    net: phy: fix MDIO bus PM PHY resuming
    
    So far we have the unfortunate situation that mdio_bus_phy_may_suspend()
    is called in suspend AND resume path, assuming that function result is
    the same. After the original change this is no longer the case,
    resulting in broken resume as reported by Geert.
    
    To fix this call mdio_bus_phy_may_suspend() in the suspend path only,
    and let the phy_device store the info whether it was suspended by
    MDIO bus PM.
    
    Fixes: 503ba7c69610 ("net: phy: Avoid multiple suspends")
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 22f5e763e894..452e8ba8665f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -357,6 +357,7 @@ struct macsec_ops;
  * is_gigabit_capable: Set to true if PHY supports 1000Mbps
  * has_fixups: Set to true if this phy has fixups/quirks.
  * suspended: Set to true if this phy has been suspended successfully.
+ * suspended_by_mdio_bus: Set to true if this phy was suspended by MDIO bus.
  * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
  * loopback_enabled: Set true if this phy has been loopbacked successfully.
  * state: state of the PHY for management purposes
@@ -396,6 +397,7 @@ struct phy_device {
 	unsigned is_gigabit_capable:1;
 	unsigned has_fixups:1;
 	unsigned suspended:1;
+	unsigned suspended_by_mdio_bus:1;
 	unsigned sysfs_links:1;
 	unsigned loopback_enabled:1;
 

commit 249bc9744e165abe74ae326f43e9d70bad54c3b7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Mar 1 21:36:09 2020 +0100

    net: phy: avoid clearing PHY interrupts twice in irq handler
    
    On all PHY drivers that implement did_interrupt() reading the interrupt
    status bits clears them. This means we may loose an interrupt that
    is triggered between calling did_interrupt() and phy_clear_interrupt().
    As part of the fix make it a requirement that did_interrupt() clears
    the interrupt.
    
    The Fixes tag refers to the first commit where the patch applies
    cleanly.
    
    Fixes: 49644e68f472 ("net: phy: add callback for custom interrupt handler to struct phy_driver")
    Reported-by: Michael Walle <michael@walle.cc>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c570e162e05e..22f5e763e894 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -557,6 +557,7 @@ struct phy_driver {
 	/*
 	 * Checks if the PHY generated an interrupt.
 	 * For multi-PHY devices with shared PHY interrupt pin
+	 * Set interrupt bits have to be cleared.
 	 */
 	int (*did_interrupt)(struct phy_device *phydev);
 

commit ce69e2162f158d9d4a0e513971d02dabc7d14cb7
Author: Jeremy Linton <jeremy.linton@arm.com>
Date:   Mon Feb 24 16:53:58 2020 -0600

    mdio_bus: Add generic mdio_find_bus()
    
    It appears most ethernet drivers follow one of two main strategies
    for mdio bus/phy management. A monolithic model where the net driver
    itself creates, probes and uses the phy, and one where an external
    mdio/phy driver instantiates the mdio bus/phy and the net driver
    only attaches to a known phy. Usually in this latter model the phys
    are discovered via DT relationships or simply phy name/address
    hardcoding.
    
    This is a shame because modern well behaved mdio buses are self
    describing and can be probed. The mdio layer itself is fully capable
    of this, yet there isn't a clean way for a standalone net driver
    to attach and enumerate the discovered devices. This is because
    outside of of_mdio_find_bus() there isn't a straightforward way
    to acquire the mii_bus pointer.
    
    So, lets add a mdio_find_bus which can return the mii_bus based
    only on its name.
    
    Signed-off-by: Jeremy Linton <jeremy.linton@arm.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 80f8b2158271..e72dbd0d2d6a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -289,6 +289,7 @@ static inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)
 	return devm_mdiobus_alloc_size(dev, 0);
 }
 
+struct mii_bus *mdio_find_bus(const char *mdio_name);
 void devm_mdiobus_free(struct device *dev, struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 

commit a87ae8a963bde755b0962bcc18db83d611f63e7a
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Sat Feb 15 15:49:27 2020 +0000

    net: add helpers to resolve negotiated flow control
    
    Add a couple of helpers to resolve negotiated flow control. Two helpers
    are provided:
    
    - linkmode_resolve_pause() which takes the link partner and local
      advertisements, and decodes whether we should enable TX or RX pause
      at the MAC. This is useful outside of phylib, e.g. in phylink.
    - phy_get_pause(), which returns the TX/RX enablement status for the
      current negotiation results of the PHY.
    
    This allows us to centralise the flow control resolution, rather than
    spreading it around.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c570e162e05e..80f8b2158271 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1257,6 +1257,9 @@ void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,
 void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);
 bool phy_validate_pause(struct phy_device *phydev,
 			struct ethtool_pauseparam *pp);
+void phy_get_pause(struct phy_device *phydev, bool *tx_pause, bool *rx_pause);
+void phy_resolve_pause(unsigned long *local_adv, unsigned long *partner_adv,
+		       bool *tx_pause, bool *rx_pause);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit bbbf8430afe6906abbf879352fe10d24d380e588
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Jan 20 22:17:11 2020 +0100

    net: phy: add new version of phy_do_ioctl
    
    Add a new version of phy_do_ioctl that doesn't check whether net_device
    is running. It will typically be used if suitable drivers attach the
    PHY in probe already.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f6e714da37d8..c570e162e05e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1242,6 +1242,7 @@ void phy_ethtool_ksettings_get(struct phy_device *phydev,
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
+int phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 int phy_do_ioctl_running(struct net_device *dev, struct ifreq *ifr, int cmd);
 void phy_request_interrupt(struct phy_device *phydev);
 void phy_free_interrupt(struct phy_device *phydev);

commit 3231e5d2228a2078ce5982d63ea9a617e4972c00
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Jan 20 22:16:07 2020 +0100

    net: phy: rename phy_do_ioctl to phy_do_ioctl_running
    
    We just added phy_do_ioctl, but it turned out that we need another
    version of this function that doesn't check whether net_device is
    running. So rename phy_do_ioctl to phy_do_ioctl_running.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index be6b3a1b03da..f6e714da37d8 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1242,7 +1242,7 @@ void phy_ethtool_ksettings_get(struct phy_device *phydev,
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
-int phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+int phy_do_ioctl_running(struct net_device *dev, struct ifreq *ifr, int cmd);
 void phy_request_interrupt(struct phy_device *phydev);
 void phy_free_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);

commit 2ab1d925aa4c0c179dd1eb492e8c03536972707b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Jan 19 14:31:55 2020 +0100

    net: phy: add generic ndo_do_ioctl handler phy_do_ioctl
    
    A number of network drivers has the same glue code to use phy_mii_ioctl
    as ndo_do_ioctl handler. So let's add such a generic ndo_do_ioctl
    handler to phylib.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 99a87f02667f..be6b3a1b03da 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1242,6 +1242,7 @@ void phy_ethtool_ksettings_get(struct phy_device *phydev,
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
+int phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 void phy_request_interrupt(struct phy_device *phydev);
 void phy_free_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);

commit 080bb352fad00d04995102f681b134e3754bfb6e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Jan 15 20:48:50 2020 -0800

    net: phy: Maintain MDIO device and bus statistics
    
    We maintain global statistics for an entire MDIO bus, as well as broken
    down, per MDIO bus address statistics. Given that it is possible for
    MDIO devices such as switches to access MDIO bus addresses for which
    there is not a mdio_device instance created (therefore not a a
    corresponding device directory in sysfs either), we also maintain
    per-address statistics under the statistics folder. The layout looks
    like this:
    
    /sys/class/mdio_bus/../statistics/
            transfers
            errrors
            writes
            reads
            transfers_<addr>
            errors_<addr>
            writes_<addr>
            reads_<addr>
    
    When a mdio_device instance is registered, a statistics/ folder is
    created with the tranfers, errors, writes and reads attributes which
    point to the appropriate MDIO bus statistics structure.
    
    Statistics are 64-bit unsigned quantities and maintained through the
    u64_stats_sync.h helper functions.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2929d0bc307f..99a87f02667f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -22,6 +22,7 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
+#include <linux/u64_stats_sync.h>
 
 #include <linux/atomic.h>
 
@@ -212,6 +213,15 @@ struct sfp_bus;
 struct sfp_upstream_ops;
 struct sk_buff;
 
+struct mdio_bus_stats {
+	u64_stats_t transfers;
+	u64_stats_t errors;
+	u64_stats_t writes;
+	u64_stats_t reads;
+	/* Must be last, add new statistics above */
+	struct u64_stats_sync syncp;
+};
+
 /*
  * The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure
@@ -224,6 +234,7 @@ struct mii_bus {
 	int (*read)(struct mii_bus *bus, int addr, int regnum);
 	int (*write)(struct mii_bus *bus, int addr, int regnum, u16 val);
 	int (*reset)(struct mii_bus *bus);
+	struct mdio_bus_stats stats[PHY_MAX_ADDR];
 
 	/*
 	 * A lock to ensure that only one thing can read/write

commit 2e18135845b359f26c37df38ba56565496517c10
Author: Antoine Tenart <antoine.tenart@bootlin.com>
Date:   Mon Jan 13 23:31:42 2020 +0100

    net: phy: add MACsec ops in phy_device
    
    This patch adds a reference to MACsec ops in the phy_device, to allow
    PHYs to support offloading MACsec operations. The phydev lock will be
    held while calling those helpers.
    
    Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index be079a7bb40a..2929d0bc307f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -333,6 +333,7 @@ struct phy_c45_device_ids {
 };
 
 struct macsec_context;
+struct macsec_ops;
 
 /* phy_device: An instance of a PHY
  *
@@ -356,6 +357,7 @@ struct macsec_context;
  * attached_dev: The attached enet driver's device instance ptr
  * adjust_link: Callback for the enet controller to respond to
  * changes in the link state.
+ * macsec_ops: MACsec offloading ops.
  *
  * speed, duplex, pause, supported, advertising, lp_advertising,
  * and autoneg are used like in mii_if_info
@@ -455,6 +457,11 @@ struct phy_device {
 
 	void (*phy_link_change)(struct phy_device *, bool up, bool do_carrier);
 	void (*adjust_link)(struct net_device *dev);
+
+#if IS_ENABLED(CONFIG_MACSEC)
+	/* MACsec management functions */
+	const struct macsec_ops *macsec_ops;
+#endif
 };
 #define to_phy_device(d) container_of(to_mdio_device(d), \
 				      struct phy_device, mdio)

commit 76564261a7db80c5f5c624e0122a28787f266bdf
Author: Antoine Tenart <antoine.tenart@bootlin.com>
Date:   Mon Jan 13 23:31:40 2020 +0100

    net: macsec: introduce the macsec_context structure
    
    This patch introduces the macsec_context structure. It will be used
    in the kernel to exchange information between the common MACsec
    implementation (macsec.c) and the MACsec hardware offloading
    implementations. This structure contains pointers to MACsec specific
    structures which contain the actual MACsec configuration, and to the
    underlying device (phydev for now).
    
    Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3a70b756ac1a..be079a7bb40a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -332,6 +332,8 @@ struct phy_c45_device_ids {
 	u32 device_ids[8];
 };
 
+struct macsec_context;
+
 /* phy_device: An instance of a PHY
  *
  * drv: Pointer to the driver for this PHY instance

commit e27f178793de16ca1b421f2c3f4bc3497b2ce723
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 12 09:35:38 2020 -0800

    net: phy: Added IRQ print to phylink_bringup_phy()
    
    The information about the PHY attached to the PHYLINK instance is useful
    but is missing the IRQ prints that phy_attached_info() adds.
    phy_attached_info() is a bit long and it would not be possible to use
    phylink_info() anyway.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5932bb8e9c35..3a70b756ac1a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1131,6 +1131,8 @@ static inline void phy_unlock_mdio_bus(struct phy_device *phydev)
 
 void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
 	__printf(2, 3);
+char *phy_attached_info_irq(struct phy_device *phydev)
+	__malloc;
 void phy_attached_info(struct phy_device *phydev);
 
 /* Clause 22 PHY */

commit c114574ebfdf42f826776f717c8056a00fa94881
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Jan 3 20:43:17 2020 +0000

    net: phy: add PHY_INTERFACE_MODE_10GBASER
    
    Recent discussion has revealed that the use of PHY_INTERFACE_MODE_10GKR
    is incorrect. Add a 10GBASE-R definition, document both the -R and -KR
    versions, and the fact that 10GKR was used incorrectly.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 30e599c454db..5932bb8e9c35 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -100,9 +100,11 @@ typedef enum {
 	PHY_INTERFACE_MODE_2500BASEX,
 	PHY_INTERFACE_MODE_RXAUI,
 	PHY_INTERFACE_MODE_XAUI,
-	/* 10GBASE-KR, XFI, SFI - single lane 10G Serdes */
-	PHY_INTERFACE_MODE_10GKR,
+	/* 10GBASE-R, XFI, SFI - single lane 10G Serdes */
+	PHY_INTERFACE_MODE_10GBASER,
 	PHY_INTERFACE_MODE_USXGMII,
+	/* 10GBASE-KR - with Clause 73 AN */
+	PHY_INTERFACE_MODE_10GKR,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -176,10 +178,12 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "rxaui";
 	case PHY_INTERFACE_MODE_XAUI:
 		return "xaui";
-	case PHY_INTERFACE_MODE_10GKR:
-		return "10gbase-kr";
+	case PHY_INTERFACE_MODE_10GBASER:
+		return "10gbase-r";
 	case PHY_INTERFACE_MODE_USXGMII:
 		return "usxgmii";
+	case PHY_INTERFACE_MODE_10GKR:
+		return "10gbase-kr";
 	default:
 		return "unknown";
 	}

commit 4715f65ffa0520af0680dbfbedbe349f175adaf4
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Wed Dec 25 18:16:15 2019 -0800

    net: Introduce a new MII time stamping interface.
    
    Currently the stack supports time stamping in PHY devices.  However,
    there are newer, non-PHY devices that can snoop an MII bus and provide
    time stamps.  In order to support such devices, this patch introduces
    a new interface to be used by both PHY and non-PHY devices.
    
    In addition, the one and only user of the old PHY time stamping API is
    converted to the new interface.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0248f5e9939d..30e599c454db 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -17,6 +17,7 @@
 #include <linux/linkmode.h>
 #include <linux/mdio.h>
 #include <linux/mii.h>
+#include <linux/mii_timestamper.h>
 #include <linux/module.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
@@ -441,6 +442,7 @@ struct phy_device {
 	struct sfp_bus *sfp_bus;
 	struct phylink *phylink;
 	struct net_device *attached_dev;
+	struct mii_timestamper *mii_ts;
 
 	u8 mdix;
 	u8 mdix_ctrl;
@@ -546,29 +548,6 @@ struct phy_driver {
 	 */
 	int (*match_phy_device)(struct phy_device *phydev);
 
-	/* Handles ethtool queries for hardware time stamping. */
-	int (*ts_info)(struct phy_device *phydev, struct ethtool_ts_info *ti);
-
-	/* Handles SIOCSHWTSTAMP ioctl for hardware time stamping. */
-	int  (*hwtstamp)(struct phy_device *phydev, struct ifreq *ifr);
-
-	/*
-	 * Requests a Rx timestamp for 'skb'. If the skb is accepted,
-	 * the phy driver promises to deliver it using netif_rx() as
-	 * soon as a timestamp becomes available. One of the
-	 * PTP_CLASS_ values is passed in 'type'. The function must
-	 * return true if the skb is accepted for delivery.
-	 */
-	bool (*rxtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
-
-	/*
-	 * Requests a Tx timestamp for 'skb'. The phy driver promises
-	 * to deliver it using skb_complete_tx_timestamp() as soon as a
-	 * timestamp becomes available. One of the PTP_CLASS_ values
-	 * is passed in 'type'.
-	 */
-	void (*txtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
-
 	/* Some devices (e.g. qnap TS-119P II) require PHY register changes to
 	 * enable Wake on LAN, so set_wol is provided to be called in the
 	 * ethernet driver's set_wol function. */
@@ -942,7 +921,7 @@ static inline bool phy_polling_mode(struct phy_device *phydev)
  */
 static inline bool phy_has_hwtstamp(struct phy_device *phydev)
 {
-	return phydev && phydev->drv && phydev->drv->hwtstamp;
+	return phydev && phydev->mii_ts && phydev->mii_ts->hwtstamp;
 }
 
 /**
@@ -951,7 +930,7 @@ static inline bool phy_has_hwtstamp(struct phy_device *phydev)
  */
 static inline bool phy_has_rxtstamp(struct phy_device *phydev)
 {
-	return phydev && phydev->drv && phydev->drv->rxtstamp;
+	return phydev && phydev->mii_ts && phydev->mii_ts->rxtstamp;
 }
 
 /**
@@ -961,7 +940,7 @@ static inline bool phy_has_rxtstamp(struct phy_device *phydev)
  */
 static inline bool phy_has_tsinfo(struct phy_device *phydev)
 {
-	return phydev && phydev->drv && phydev->drv->ts_info;
+	return phydev && phydev->mii_ts && phydev->mii_ts->ts_info;
 }
 
 /**
@@ -970,30 +949,30 @@ static inline bool phy_has_tsinfo(struct phy_device *phydev)
  */
 static inline bool phy_has_txtstamp(struct phy_device *phydev)
 {
-	return phydev && phydev->drv && phydev->drv->txtstamp;
+	return phydev && phydev->mii_ts && phydev->mii_ts->txtstamp;
 }
 
 static inline int phy_hwtstamp(struct phy_device *phydev, struct ifreq *ifr)
 {
-	return phydev->drv->hwtstamp(phydev, ifr);
+	return phydev->mii_ts->hwtstamp(phydev->mii_ts, ifr);
 }
 
 static inline bool phy_rxtstamp(struct phy_device *phydev, struct sk_buff *skb,
 				int type)
 {
-	return phydev->drv->rxtstamp(phydev, skb, type);
+	return phydev->mii_ts->rxtstamp(phydev->mii_ts, skb, type);
 }
 
 static inline int phy_ts_info(struct phy_device *phydev,
 			      struct ethtool_ts_info *tsinfo)
 {
-	return phydev->drv->ts_info(phydev, tsinfo);
+	return phydev->mii_ts->ts_info(phydev->mii_ts, tsinfo);
 }
 
 static inline void phy_txtstamp(struct phy_device *phydev, struct sk_buff *skb,
 				int type)
 {
-	phydev->drv->txtstamp(phydev, skb, type);
+	phydev->mii_ts->txtstamp(phydev->mii_ts, skb, type);
 }
 
 /**

commit 0e5dafc8a6e540c0145b61545c557c43be70af10
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Wed Dec 25 18:16:09 2019 -0800

    net: phy: Introduce helper functions for time stamping support.
    
    Some parts of the networking stack and at least one driver test fields
    within the 'struct phy_device' in order to query time stamping
    capabilities and to invoke time stamping methods.  This patch adds a
    functional interface around the time stamping fields.  This will allow
    insulating the callers from future changes to the details of the time
    stamping implemenation.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7d530b3f8855..0248f5e9939d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -936,6 +936,66 @@ static inline bool phy_polling_mode(struct phy_device *phydev)
 	return phydev->irq == PHY_POLL;
 }
 
+/**
+ * phy_has_hwtstamp - Tests whether a PHY time stamp configuration.
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_has_hwtstamp(struct phy_device *phydev)
+{
+	return phydev && phydev->drv && phydev->drv->hwtstamp;
+}
+
+/**
+ * phy_has_rxtstamp - Tests whether a PHY supports receive time stamping.
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_has_rxtstamp(struct phy_device *phydev)
+{
+	return phydev && phydev->drv && phydev->drv->rxtstamp;
+}
+
+/**
+ * phy_has_tsinfo - Tests whether a PHY reports time stamping and/or
+ * PTP hardware clock capabilities.
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_has_tsinfo(struct phy_device *phydev)
+{
+	return phydev && phydev->drv && phydev->drv->ts_info;
+}
+
+/**
+ * phy_has_txtstamp - Tests whether a PHY supports transmit time stamping.
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_has_txtstamp(struct phy_device *phydev)
+{
+	return phydev && phydev->drv && phydev->drv->txtstamp;
+}
+
+static inline int phy_hwtstamp(struct phy_device *phydev, struct ifreq *ifr)
+{
+	return phydev->drv->hwtstamp(phydev, ifr);
+}
+
+static inline bool phy_rxtstamp(struct phy_device *phydev, struct sk_buff *skb,
+				int type)
+{
+	return phydev->drv->rxtstamp(phydev, skb, type);
+}
+
+static inline int phy_ts_info(struct phy_device *phydev,
+			      struct ethtool_ts_info *tsinfo)
+{
+	return phydev->drv->ts_info(phydev, tsinfo);
+}
+
+static inline void phy_txtstamp(struct phy_device *phydev, struct sk_buff *skb,
+				int type)
+{
+	phydev->drv->txtstamp(phydev, skb, type);
+}
+
 /**
  * phy_is_internal - Convenience function for testing if a PHY is internal
  * @phydev: the phy_device struct

commit ac80010fc94eb0680d9a432b639583bd7ac29066
Merge: cfeec3fb5451 c60174717544
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Dec 22 15:15:05 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Mere overlapping changes in the conflicts here.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7d49a32a66d2215c5b3bf9bc67c9036ea9904111
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Dec 19 23:24:52 2019 +0000

    net: phy: ensure that phy IDs are correctly typed
    
    PHY IDs are 32-bit unsigned quantities. Ensure that they are always
    treated as such, and not passed around as "int"s.
    
    Fixes: 13d0ab6750b2 ("net: phy: check return code when requesting PHY driver module")
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5032d453ac66..dd4a91f1feaa 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1000,7 +1000,7 @@ int phy_modify_paged_changed(struct phy_device *phydev, int page, u32 regnum,
 int phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,
 		     u16 mask, u16 set);
 
-struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
+struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);
 #if IS_ENABLED(CONFIG_PHYLIB)

commit 0efc286a923874f0c243e5766cce54e9429ed949
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Dec 17 13:39:16 2019 +0000

    net: phy: provide and use genphy_read_status_fixed()
    
    There are two drivers and generic code which contain exactly the same
    code to read the status of a PHY operating without autonegotiation
    enabled. Rather than duplicate this code, provide a helper to read
    this information.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1c4f97d2631d..b2105e0d72d3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1100,6 +1100,7 @@ int __genphy_config_aneg(struct phy_device *phydev, bool changed);
 int genphy_aneg_done(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
 int genphy_read_lpa(struct phy_device *phydev);
+int genphy_read_status_fixed(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);

commit 2a10ab043ac5a658225ee77852db7942de9ac4c5
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Dec 17 13:39:11 2019 +0000

    net: phy: add genphy_check_and_restart_aneg()
    
    Add a helper for restarting autonegotiation(), similar to the clause 45
    variant.  Use it in __genphy_config_aneg()
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5032d453ac66..1c4f97d2631d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1094,6 +1094,7 @@ void phy_attached_info(struct phy_device *phydev);
 int genphy_read_abilities(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
+int genphy_check_and_restart_aneg(struct phy_device *phydev, bool restart);
 int genphy_config_eee_advert(struct phy_device *phydev);
 int __genphy_config_aneg(struct phy_device *phydev, bool changed);
 int genphy_aneg_done(struct phy_device *phydev);

commit bec170e55982c2d3b8e1beccadf16e288fe6fb5a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Nov 23 17:28:37 2019 +0100

    net: phy: add helpers phy_(un)lock_mdio_bus
    
    Add helpers to make locking/unlocking the MDIO bus easier.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f5cdfb206097..5032d453ac66 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1076,6 +1076,16 @@ static inline const char *phydev_name(const struct phy_device *phydev)
 	return dev_name(&phydev->mdio.dev);
 }
 
+static inline void phy_lock_mdio_bus(struct phy_device *phydev)
+{
+	mutex_lock(&phydev->mdio.bus->mdio_lock);
+}
+
+static inline void phy_unlock_mdio_bus(struct phy_device *phydev)
+{
+	mutex_unlock(&phydev->mdio.bus->mdio_lock);
+}
+
 void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
 	__printf(2, 3);
 void phy_attached_info(struct phy_device *phydev);

commit e3cf8b3668a808c1d252269ffc34a5723cfb9a7b
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Nov 22 12:37:08 2019 +0000

    net: phy: remove phy_ethtool_sset()
    
    There are no users of phy_ethtool_sset() in the kernel anymore, and
    as of commit 3c1bcc8614db ("net: ethernet: Convert phydev advertize
    and supported from u32 to link mode"), the implementation is slightly
    buggy - it doesn't correctly check the masked advertising mask as it
    used to.
    
    Remove it, and update the phy documentation to refer to its replacement
    function.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 124516fe2763..f5cdfb206097 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1160,7 +1160,6 @@ void phy_queue_state_machine(struct phy_device *phydev, unsigned long jiffies);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
-int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 void phy_ethtool_ksettings_get(struct phy_device *phydev,
 			       struct ethtool_link_ksettings *cmd);
 int phy_ethtool_ksettings_set(struct phy_device *phydev,

commit 298e54fa810e027f1b0800d789eb862592721f08
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Nov 15 19:56:51 2019 +0000

    net: phy: add core phylib sfp support
    
    Add core phylib help for supporting SFP sockets on PHYs.  This provides
    a mechanism to inform the SFP layer about PHY up/down events, and also
    unregister the SFP bus when the PHY is going away.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 78436d58ce7c..124516fe2763 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -203,6 +203,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 
 struct device;
 struct phylink;
+struct sfp_bus;
+struct sfp_upstream_ops;
 struct sk_buff;
 
 /*
@@ -342,6 +344,8 @@ struct phy_c45_device_ids {
  * dev_flags: Device-specific flags used by the PHY driver.
  * irq: IRQ number of the PHY's interrupt (-1 if none)
  * phy_timer: The timer for handling the state machine
+ * sfp_bus_attached: flag indicating whether the SFP bus has been attached
+ * sfp_bus: SFP bus attached to this PHY's fiber port
  * attached_dev: The attached enet driver's device instance ptr
  * adjust_link: Callback for the enet controller to respond to
  * changes in the link state.
@@ -432,6 +436,9 @@ struct phy_device {
 
 	struct mutex lock;
 
+	/* This may be modified under the rtnl lock */
+	bool sfp_bus_attached;
+	struct sfp_bus *sfp_bus;
 	struct phylink *phylink;
 	struct net_device *attached_dev;
 
@@ -1020,6 +1027,10 @@ int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);
 int __phy_resume(struct phy_device *phydev);
 int phy_loopback(struct phy_device *phydev, bool enable);
+void phy_sfp_attach(void *upstream, struct sfp_bus *bus);
+void phy_sfp_detach(void *upstream, struct sfp_bus *bus);
+int phy_sfp_probe(struct phy_device *phydev,
+	          const struct sfp_upstream_ops *ops);
 struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 			      phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);

commit fa6e98cee558622565c97924e922b97340aeabd8
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Oct 22 11:31:07 2019 -0700

    net: phy: add support for clause 37 auto-negotiation
    
    This patch adds support for clause 37 1000Base-X auto-negotiation.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Tao Ren <taoren@fb.com>
    Tested-by: Ren van Dorst <opensource@vdorst.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9a0e981df502..78436d58ce7c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1106,6 +1106,10 @@ int genphy_read_mmd_unsupported(struct phy_device *phdev, int devad,
 int genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,
 				 u16 regnum, u16 val);
 
+/* Clause 37 */
+int genphy_c37_config_aneg(struct phy_device *phydev);
+int genphy_c37_read_status(struct phy_device *phydev);
+
 /* Clause 45 PHY */
 int genphy_c45_restart_aneg(struct phy_device *phydev);
 int genphy_c45_check_and_restart_aneg(struct phy_device *phydev, bool restart);

commit 2d880b8709c013d47472f85a9d42ea1aca3bce47
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Oct 4 17:06:09 2019 +0100

    net: phy: extract pause mode
    
    Extract the update of phylib's software pause mode state from
    genphy_read_status(), so that we can re-use this functionality with
    PHYs that have alternative ways to read the negotiation results.
    
    Tested-by: tinywrkb <tinywrkb@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7abee820d05c..9a0e981df502 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -678,6 +678,7 @@ static inline bool phy_is_started(struct phy_device *phydev)
 	return phydev->state >= PHY_UP;
 }
 
+void phy_resolve_aneg_pause(struct phy_device *phydev);
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);
 
 /**

commit 8d3dc3ac9dd6801c732a72ca6979698c38451b4f
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Oct 4 17:06:04 2019 +0100

    net: phy: extract link partner advertisement reading
    
    Move reading the link partner advertisement out of genphy_read_status()
    into its own separate function.  This will allow re-use of this code by
    PHY drivers that are able to read the resolved status from the PHY.
    
    Tested-by: tinywrkb <tinywrkb@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a7ecbe0e55aa..7abee820d05c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1076,6 +1076,7 @@ int genphy_config_eee_advert(struct phy_device *phydev);
 int __genphy_config_aneg(struct phy_device *phydev, bool changed);
 int genphy_aneg_done(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
+int genphy_read_lpa(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);

commit 765b7590c92d849806e9a27ab3a5a17cfc6a47a9
Merge: 4bc61b0b1695 089cf7f6ecb2
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Sep 2 11:20:17 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    r8152 conflicts are the NAPI fixes in 'net' overlapping with
    some tasklet stuff in net-next
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 94acaeb50ced653bfe2c4d8037c70b107af14124
Author: Marco Hartmann <marco.hartmann@nxp.com>
Date:   Wed Aug 21 11:00:46 2019 +0000

    Add genphy_c45_config_aneg() function to phy-c45.c
    
    Commit 34786005eca3 ("net: phy: prevent PHYs w/o Clause 22 regs from calling
    genphy_config_aneg") introduced a check that aborts phy_config_aneg()
    if the phy is a C45 phy.
    This causes phy_state_machine() to call phy_error() so that the phy
    ends up in PHY_HALTED state.
    
    Instead of returning -EOPNOTSUPP, call genphy_c45_config_aneg()
    (analogous to the C22 case) so that the state machine can run
    correctly.
    
    genphy_c45_config_aneg() closely resembles mv3310_config_aneg()
    in drivers/net/phy/marvell10g.c, excluding vendor specific
    configurations for 1000BaseT.
    
    Fixes: 22b56e827093 ("net: phy: replace genphy_10g_driver with genphy_c45_driver")
    
    Signed-off-by: Marco Hartmann <marco.hartmann@nxp.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 462b90b73f93..2fb9c8ffaf10 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1107,6 +1107,7 @@ int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 int genphy_c45_read_mdix(struct phy_device *phydev);
 int genphy_c45_pma_read_abilities(struct phy_device *phydev);
 int genphy_c45_read_status(struct phy_device *phydev);
+int genphy_c45_config_aneg(struct phy_device *phydev);
 
 /* The gen10g_* functions are the old Clause 45 stub */
 int gen10g_config_aneg(struct phy_device *phydev);

commit 4b9cb2a5ceedd7f715d92570b773fad024ca9950
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Aug 17 12:30:39 2019 +0200

    net: phy: remove genphy_config_init
    
    Now that all users have been removed we can remove genphy_config_init.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5ac7d21375ac..d26779f1fb6b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1069,7 +1069,6 @@ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
 void phy_attached_info(struct phy_device *phydev);
 
 /* Clause 22 PHY */
-int genphy_config_init(struct phy_device *phydev);
 int genphy_read_abilities(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);

commit 65b27995a4ab8fc51b4adc6b4dcdca20f7a595bb
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Aug 12 23:52:19 2019 +0200

    net: phy: let phy_speed_down/up support speeds >1Gbps
    
    So far phy_speed_down/up can be used up to 1Gbps only. Remove this
    restriction by using new helper __phy_speed_down. New member adv_old
    in struct phy_device is used by phy_speed_up to restore the advertised
    modes before calling phy_speed_down. Don't simply advertise what is
    supported because a user may have intentionally removed modes from
    advertisement.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 62fdc7ff2b24..5ac7d21375ac 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -403,6 +403,8 @@ struct phy_device {
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(lp_advertising);
+	/* used with phy_speed_down */
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_old);
 
 	/* Energy efficient ethernet modes which should be prohibited */
 	u32 eee_broken_modes;

commit 331c56ac73846fa267c04ee6aa9a00bb5fed9440
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Aug 12 23:51:27 2019 +0200

    net: phy: add phy_speed_down_core and phy_resolve_min_speed
    
    phy_speed_down_core provides most of the functionality for
    phy_speed_down. It makes use of new helper phy_resolve_min_speed that is
    based on the sorting of the settings[] array. In certain cases it may be
    helpful to be able to exclude legacy half duplex modes, therefore
    prepare phy_resolve_min_speed() for it.
    
    v2:
    - rename __phy_speed_down to phy_speed_down_core
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 781f4810ceba..62fdc7ff2b24 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -665,6 +665,7 @@ size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask);
 void of_set_phy_supported(struct phy_device *phydev);
 void of_set_phy_eee_broken(struct phy_device *phydev);
+int phy_speed_down_core(struct phy_device *phydev);
 
 /**
  * phy_is_started - Convenience function to check whether PHY is started

commit bf22b343ca800aac076ccf986e762b28545aa6bb
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Aug 9 20:44:22 2019 +0200

    net: phy: add phy_modify_paged_changed
    
    Add helper function phy_modify_paged_changed, behavios is the same
    as for phy_modify_changed.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7117825ee57a..781f4810ceba 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -984,6 +984,8 @@ int phy_select_page(struct phy_device *phydev, int page);
 int phy_restore_page(struct phy_device *phydev, int oldpage, int ret);
 int phy_read_paged(struct phy_device *phydev, int page, u32 regnum);
 int phy_write_paged(struct phy_device *phydev, int page, u32 regnum, u16 val);
+int phy_modify_paged_changed(struct phy_device *phydev, int page, u32 regnum,
+			     u16 mask, u16 set);
 int phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,
 		     u16 mask, u16 set);
 

commit f4069cd7fa6583e7094001c6fce6f426d17a4c76
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Aug 9 20:43:50 2019 +0200

    net: phy: prepare phylib to deal with PHY's extending Clause 22
    
    The integrated PHY in 2.5Gbps chip RTL8125 is the first (known to me)
    PHY that uses standard Clause 22 for all modes up to 1Gbps and adds
    2.5Gbps control using vendor-specific registers. To use phylib for
    the standard part little extensions are needed:
    - Move most of genphy_config_aneg to a new function
      __genphy_config_aneg that takes a parameter whether restarting
      auto-negotiation is needed (depending on whether content of
      vendor-specific advertisement register changed).
    - Don't clear phydev->lp_advertising in genphy_read_status so that
      we can set non-C22 mode flags before.
    
    Basically both changes mimic the behavior of the equivalent Clause 45
    functions.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 462b90b73f93..7117825ee57a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1069,7 +1069,7 @@ int genphy_read_abilities(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_eee_advert(struct phy_device *phydev);
-int genphy_config_aneg(struct phy_device *phydev);
+int __genphy_config_aneg(struct phy_device *phydev, bool changed);
 int genphy_aneg_done(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
@@ -1077,6 +1077,12 @@ int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
 int genphy_loopback(struct phy_device *phydev, bool enable);
 int genphy_soft_reset(struct phy_device *phydev);
+
+static inline int genphy_config_aneg(struct phy_device *phydev)
+{
+	return __genphy_config_aneg(phydev, false);
+}
+
 static inline int genphy_no_soft_reset(struct phy_device *phydev)
 {
 	return 0;

commit 54638c6eaf445ecf901128599cfeb4620be47d2f
Author: Denis Efremov <efremov@linux.com>
Date:   Wed Jul 10 21:03:24 2019 +0300

    net: phy: make exported variables non-static
    
    The variables phy_basic_ports_array, phy_fibre_port_array and
    phy_all_ports_features_array are declared static and marked
    EXPORT_SYMBOL_GPL(), which is at best an odd combination.
    Because the variables were decided to be a part of API, this commit
    removes the static attributes and adds the declarations to the header.
    
    Fixes: 3c1bcc8614db ("net: ethernet: Convert phydev advertize and supported from u32 to link mode")
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1739c6dc470e..462b90b73f93 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -55,6 +55,9 @@ extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_ini
 #define PHY_10GBIT_FEC_FEATURES ((unsigned long *)&phy_10gbit_fec_features)
 #define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)
 
+extern const int phy_basic_ports_array[3];
+extern const int phy_fibre_port_array[1];
+extern const int phy_all_ports_features_array[7];
 extern const int phy_10_100_features_array[4];
 extern const int phy_basic_t1_features_array[2];
 extern const int phy_gbit_features_array[2];

commit d4117d63a30876a3654f587c3a419db63d8b529d
Author: Kweh Hock Leong <hock.leong.kweh@intel.com>
Date:   Sat Jul 6 01:33:27 2019 +0800

    net: stmmac: enable clause 45 mdio support
    
    DWMAC4 is capable to support clause 45 mdio communication.
    This patch enable the feature on stmmac_mdio_write() and
    stmmac_mdio_read() by following phy_write_mmd() and
    phy_read_mmd() mdiobus read write implementation format.
    
    Reviewed-by: Li, Yifan <yifan2.li@intel.com>
    Signed-off-by: Kweh Hock Leong <hock.leong.kweh@intel.com>
    Signed-off-by: Ong Boon Leong <boon.leong.ong@intel.com>
    Signed-off-by: Voon Weifeng <weifeng.voon@intel.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d0af7d37fdf9..1739c6dc470e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -195,6 +195,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 /* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit
    IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
 #define MII_ADDR_C45 (1<<30)
+#define MII_DEVADDR_C45_SHIFT	16
+#define MII_REGADDR_C45_MASK	GENMASK(15, 0)
 
 struct device;
 struct phylink;

commit a6cdeeb16bff89c8486324f53577db058cbe81ba
Merge: 96524ea4be04 1e1d92636954
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 7 11:00:14 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Some ISDN files that got removed in net-next had some changes
    done in mainline, take the removals.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2bd229df5e2ecbc13909f71dbd196fced1d533ca
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Jun 4 23:02:34 2019 +0200

    net: phy: remove state PHY_FORCING
    
    In the early days of phylib we had a functionality that changed to the
    next lower speed in fixed mode if no link was established after a
    certain period of time. This functionality has been removed years ago,
    and state PHY_FORCING isn't needed any longer. Instead we can go from
    UP to RUNNING or NOLINK directly (same as in autoneg mode).
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index dc4b51060ebc..8caaf76685cd 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -297,12 +297,6 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  * - irq or timer will set RUNNING if link comes back
  * - phy_stop moves to HALTED
  *
- * FORCING: PHY is being configured with forced settings
- * - if link is up, move to RUNNING
- * - If link is down, we drop to the next highest setting, and
- *   retry (FORCING) after a timeout
- * - phy_stop moves to HALTED
- *
  * RUNNING: PHY is currently up, running, and possibly sending
  * and/or receiving packets
  * - irq or timer will set NOLINK if link goes down
@@ -319,7 +313,6 @@ enum phy_state {
 	PHY_UP,
 	PHY_RUNNING,
 	PHY_NOLINK,
-	PHY_FORCING,
 };
 
 /**
@@ -347,8 +340,6 @@ struct phy_c45_device_ids {
  * loopback_enabled: Set true if this phy has been loopbacked successfully.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
- * link_timeout: The number of timer firings to wait before the
- * giving up on the current attempt at acquiring a link
  * irq: IRQ number of the PHY's interrupt (-1 if none)
  * phy_timer: The timer for handling the state machine
  * attached_dev: The attached enet driver's device instance ptr
@@ -416,8 +407,6 @@ struct phy_device {
 	/* Energy efficient ethernet modes which should be prohibited */
 	u32 eee_broken_modes;
 
-	int link_timeout;
-
 #ifdef CONFIG_LED_TRIGGER_PHY
 	struct phy_led_trigger *phy_led_triggers;
 	unsigned int phy_num_led_triggers;

commit 97b33bdf9bddb6bebc2e87148df3e30aa7a13b2d
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu May 30 15:11:06 2019 +0200

    net: phy: export phy_queue_state_machine
    
    We face the issue that link change interrupt and link status may be
    reported by different PHY layers. As a result the link change
    interrupt may occur before the link status changes.
    Export phy_queue_state_machine to allow PHY drivers to specify a
    delay between link status change interrupt and link status check.
    
    v2:
    - change jiffies parameter type to unsigned long
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Suggested-by: Russell King <rmk+kernel@armlinux.org.uk>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 16cd33915496..dc4b51060ebc 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -188,7 +188,6 @@ static inline const char *phy_modes(phy_interface_t interface)
 
 
 #define PHY_INIT_TIMEOUT	100000
-#define PHY_STATE_TIME		1
 #define PHY_FORCE_TIMEOUT	10
 
 #define PHY_MAX_ADDR	32
@@ -1140,6 +1139,7 @@ int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 int phy_drivers_register(struct phy_driver *new_driver, int n,
 			 struct module *owner);
 void phy_state_machine(struct work_struct *work);
+void phy_queue_state_machine(struct phy_device *phydev, unsigned long jiffies);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);

commit 49644e68f472c6480e015253fa4d7448c6cfa2aa
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu May 30 15:10:06 2019 +0200

    net: phy: add callback for custom interrupt handler to struct phy_driver
    
    The phylib interrupt handler handles link change events only currently.
    However PHY drivers may want to use other interrupt sources too,
    e.g. to report temperature monitoring events. Therefore add a callback
    to struct phy_driver allowing PHY drivers to implement a custom
    interrupt handler.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Suggested-by: Russell King - ARM Linux admin <linux@armlinux.org.uk>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 72e1196f9799..16cd33915496 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -537,6 +537,9 @@ struct phy_driver {
 	 */
 	int (*did_interrupt)(struct phy_device *phydev);
 
+	/* Override default interrupt handling */
+	int (*handle_interrupt)(struct phy_device *phydev);
+
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 

commit 07b0928918c694c845a387cc16256a8b63ced4fc
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu May 30 15:09:15 2019 +0200

    net: phy: enable interrupts when PHY is attached already
    
    This patch is a step towards allowing PHY drivers to handle more
    interrupt sources than just link change. E.g. several PHY's have
    built-in temperature monitoring and can raise an interrupt if a
    temperature threshold is exceeded. We may be interested in such
    interrupts also if the phylib state machine isn't started.
    Therefore move enabling interrupts to phy_request_interrupt().
    
    v2:
    - patch added to series
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7180b1d1e5e3..72e1196f9799 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1147,6 +1147,7 @@ int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 void phy_request_interrupt(struct phy_device *phydev);
+void phy_free_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 073fb151b5a9..6424586fe2d6 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Framework and drivers for configuring and reading different PHYs
  * Based on code in sungem_phy.c and (long-removed) gianfar_phy.c
@@ -5,12 +6,6 @@
  * Author: Andy Fleming
  *
  * Copyright (c) 2004 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
  */
 
 #ifndef __PHY_H

commit 4618d6719743b60f1da4b8112c4518ee46110b94
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu May 23 20:06:49 2019 +0200

    net: phy: add interface mode PHY_INTERFACE_MODE_USXGMII
    
    Add support for interface mode PHY_INTERFACE_MODE_USXGMII.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 073fb151b5a9..7180b1d1e5e3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -103,6 +103,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_XAUI,
 	/* 10GBASE-KR, XFI, SFI - single lane 10G Serdes */
 	PHY_INTERFACE_MODE_10GKR,
+	PHY_INTERFACE_MODE_USXGMII,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -178,6 +179,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "xaui";
 	case PHY_INTERFACE_MODE_10GKR:
 		return "10gbase-kr";
+	case PHY_INTERFACE_MODE_USXGMII:
+		return "usxgmii";
 	default:
 		return "unknown";
 	}

commit f24098f80748ea95d53603a7bb7954a41bb3ca1b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed May 1 22:14:21 2019 +0200

    net: phy: improve resuming from hibernation
    
    I got an interesting report [0] that after resuming from hibernation
    the link has 100Mbps instead of 1Gbps. Reason is that another OS has
    been used whilst Linux was hibernated. And this OS speeds down the link
    due to WoL. Therefore, when resuming, we shouldn't expect that what
    the PHY advertises is what it did when hibernating.
    Easiest way to do this is removing state PHY_RESUMING. Instead always
    go via PHY_UP that configures PHY advertisement.
    
    [0] https://bugzilla.kernel.org/show_bug.cgi?id=202851
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4a03f8a46d33..073fb151b5a9 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -308,13 +308,7 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  *
  * HALTED: PHY is up, but no polling or interrupts are done. Or
  * PHY is in an error state.
- *
- * - phy_start moves to RESUMING
- *
- * RESUMING: PHY was halted, but now wants to run again.
- * - If we are forcing, or aneg is done, timer moves to RUNNING
- * - If aneg is not done, timer moves to AN
- * - phy_stop moves to HALTED
+ * - phy_start moves to UP
  */
 enum phy_state {
 	PHY_DOWN = 0,
@@ -324,7 +318,6 @@ enum phy_state {
 	PHY_RUNNING,
 	PHY_NOLINK,
 	PHY_FORCING,
-	PHY_RESUMING
 };
 
 /**

commit 22c0ef6b1475aef4765efc4aa764b8580018123c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed May 1 21:34:43 2019 +0200

    net: phy: improve pause handling
    
    When probing the phy device we set sym and asym pause in the "supported"
    bitmap (unless the PHY tells us otherwise). However we don't know yet
    whether the MAC supports pause. Simply copying phy->supported to
    phy->advertising will trigger advertising pause, and that's not
    what we want. Therefore add phy_advertise_supported() that copies all
    modes but doesn't touch the pause bits.
    
    In phy_support_(a)sym_pause we shouldn't set any bits in the supported
    bitmap because we may set a bit the PHY intentionally disabled.
    Effective pause support should be the AND-combined PHY and MAC pause
    capabilities. If the MAC supports everything, then it's only relevant
    what the PHY supports. If MAC supports sym pause only, then we have to
    clear the asym bit in phydev->supported.
    Copy the pause flags only and don't touch the modes, because a driver
    may have intentionally removed a mode from phydev->advertising.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0f9552b17ee7..4a03f8a46d33 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1154,6 +1154,7 @@ void phy_request_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
+void phy_advertise_supported(struct phy_device *phydev);
 void phy_support_sym_pause(struct phy_device *phydev);
 void phy_support_asym_pause(struct phy_device *phydev);
 void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,

commit 3b8b11f96616c2e763ebcc093b778b309fc07a92
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Apr 5 21:23:13 2019 +0200

    net: phy: improve link partner capability detection
    
    genphy_read_status() so far checks phydev->supported, not the actual
    PHY capabilities. This can make a difference if the supported speeds
    have been limited by of_set_phy_supported() or phy_set_max_speed().
    
    It seems that this issue only affects the link partner advertisements
    as displayed by ethtool. Also this patch wouldn't apply to older
    kernels because linkmode bitmaps have been introduced recently.
    Therefore net-next.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ab7439b3da2b..0f9552b17ee7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -345,6 +345,7 @@ struct phy_c45_device_ids {
  * is_c45:  Set to true if this phy uses clause 45 addressing.
  * is_internal: Set to true if this phy is internal to a MAC.
  * is_pseudo_fixed_link: Set to true if this phy is an Ethernet switch, etc.
+ * is_gigabit_capable: Set to true if PHY supports 1000Mbps
  * has_fixups: Set to true if this phy has fixups/quirks.
  * suspended: Set to true if this phy has been suspended successfully.
  * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
@@ -382,6 +383,7 @@ struct phy_device {
 	unsigned is_c45:1;
 	unsigned is_internal:1;
 	unsigned is_pseudo_fixed_link:1;
+	unsigned is_gigabit_capable:1;
 	unsigned has_fixups:1;
 	unsigned suspended:1;
 	unsigned sysfs_links:1;

commit 4950c2ba49cc6f2b38dbedcfa0ff67acf761419a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Apr 2 20:43:30 2019 +0200

    net: phy: fix autoneg mismatch case in genphy_read_status
    
    The original patch didn't consider the case that autoneg process
    finishes successfully but both link partners have no mode in common.
    In this case there's no link, nevertheless we may be interested in
    what the link partner advertised.
    
    Like phydev->link we set phydev->autoneg_complete in
    genphy_update_link() and use the stored value in genphy_read_status().
    This way we don't have to read register BMSR again.
    
    Fixes: b6163f194c69 ("net: phy: improve genphy_read_status")
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ad88f063e50f..ab7439b3da2b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -390,6 +390,7 @@ struct phy_device {
 	unsigned autoneg:1;
 	/* The most recently read link state */
 	unsigned link:1;
+	unsigned autoneg_complete:1;
 
 	/* Interrupts are enabled */
 	unsigned interrupts:1;

commit 045925e3fe5b98e402337a176d154252c56cef2e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Mar 27 21:58:44 2019 +0100

    net: phy: add genphy_read_abilities
    
    Similar to genphy_c45_pma_read_abilities() add a function to dynamically
    detect the abilities of a Clause 22 PHY. This is mainly copied from
    genphy_config_init().
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 34084892a466..ad88f063e50f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1075,6 +1075,7 @@ void phy_attached_info(struct phy_device *phydev);
 
 /* Clause 22 PHY */
 int genphy_config_init(struct phy_device *phydev);
+int genphy_read_abilities(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_eee_advert(struct phy_device *phydev);

commit 7be3ad848f77eba893bd08b97e7383e8d5e873ac
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Mar 2 17:13:11 2019 +0100

    net: phy: remove gen10g_no_soft_reset
    
    genphy_no_soft_reset and gen10g_no_soft_reset are both the same no-ops,
    one is enough.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 60794240141f..34084892a466 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1119,7 +1119,6 @@ int genphy_c45_read_status(struct phy_device *phydev);
 
 /* The gen10g_* functions are the old Clause 45 stub */
 int gen10g_config_aneg(struct phy_device *phydev);
-int gen10g_no_soft_reset(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {

commit d81210c25e17b5cca71138f3990ed8071d510ba9
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Mar 2 17:15:56 2019 +0100

    net: phy: don't export gen10g_read_status
    
    gen10g_read_status is deprecated, therefore stop exporting it.
    We don't want to encourage anybody to use it.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 817c8453aeb5..60794240141f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1119,7 +1119,6 @@ int genphy_c45_read_status(struct phy_device *phydev);
 
 /* The gen10g_* functions are the old Clause 45 stub */
 int gen10g_config_aneg(struct phy_device *phydev);
-int gen10g_read_status(struct phy_device *phydev);
 int gen10g_no_soft_reset(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)

commit c5e91d39427d1759d6205599e145553b5b2bc19e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Mar 2 17:11:40 2019 +0100

    net: phy: remove gen10g_config_init
    
    ETHTOOL_LINK_MODE_10000baseT_Full_BIT is set anyway in the supported
    and advertising bitmap because it's part of PHY_10GBIT_FEATURES.
    And all users of gen10g_config_init use PHY_10GBIT_FEATURES.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c69de3b87e87..817c8453aeb5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1121,7 +1121,6 @@ int genphy_c45_read_status(struct phy_device *phydev);
 int gen10g_config_aneg(struct phy_device *phydev);
 int gen10g_read_status(struct phy_device *phydev);
 int gen10g_no_soft_reset(struct phy_device *phydev);
-int gen10g_config_init(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {

commit a6d0aa97f453cc1a13ba93428590ef4fd29d005a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Mar 2 17:10:36 2019 +0100

    net: phy: remove gen10g_suspend and gen10g_resume
    
    phy_suspend() and phy_resume() are no-ops anyway if no callback is
    defined. Therefore we don't need these stubs.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bfe60e2a5174..c69de3b87e87 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1122,8 +1122,6 @@ int gen10g_config_aneg(struct phy_device *phydev);
 int gen10g_read_status(struct phy_device *phydev);
 int gen10g_no_soft_reset(struct phy_device *phydev);
 int gen10g_config_init(struct phy_device *phydev);
-int gen10g_suspend(struct phy_device *phydev);
-int gen10g_resume(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {

commit 70f3522614e60b6125eff5f9dd7c887543812187
Merge: a75d1d01477d c3619a482e15
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Feb 24 11:48:04 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three conflicts, one of which, for marvell10g.c is non-trivial and
    requires some follow-up from Heiner or someone else.
    
    The issue is that Heiner converted the marvell10g driver over to
    use the generic c45 code as much as possible.
    
    However, in 'net' a bug fix appeared which makes sure that a new
    local mask (MDIO_AN_10GBT_CTRL_ADV_NBT_MASK) with value 0x01e0
    is cleared.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 4c8e0459b585e2a7b367545be3e102737f1e489f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 24 01:11:15 2019 +0100

    net: phy: realtek: Dummy IRQ calls for RTL8366RB
    
    This fixes a regression introduced by
    commit 0d2e778e38e0ddffab4bb2b0e9ed2ad5165c4bf7
    "net: phy: replace PHY_HAS_INTERRUPT with a check for
    config_intr and ack_interrupt".
    
    This assumes that a PHY cannot trigger interrupt unless
    it has .config_intr() or .ack_interrupt() implemented.
    A later patch makes the code assume both need to be
    implemented for interrupts to be present.
    
    But this PHY (which is inside a DSA) will happily
    fire interrupts without either callback.
    
    Implement dummy callbacks for .config_intr() and
    .ack_interrupt() in the phy header to fix this.
    
    Tested on the RTL8366RB on D-Link DIR-685.
    
    Fixes: 0d2e778e38e0 ("net: phy: replace PHY_HAS_INTERRUPT with a check for config_intr and ack_interrupt")
    Cc: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 127fcc9c3778..333b56d8f746 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -992,6 +992,14 @@ static inline int genphy_no_soft_reset(struct phy_device *phydev)
 {
 	return 0;
 }
+static inline int genphy_no_ack_interrupt(struct phy_device *phydev)
+{
+	return 0;
+}
+static inline int genphy_no_config_intr(struct phy_device *phydev)
+{
+	return 0;
+}
 int genphy_read_mmd_unsupported(struct phy_device *phdev, int devad,
 				u16 regnum);
 int genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,

commit 70fa3a9699cbc7aa1e93a5fddb9b9105d2b3acda
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Feb 22 23:51:44 2019 +0100

    net: phy: add genphy_c45_read_status
    
    Similar to genphy_read_status() for Clause 22 add a generic read_status
    function for Clause 45.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8e9fc576472b..a05ba366dae4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1107,6 +1107,7 @@ int genphy_c45_an_config_aneg(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 int genphy_c45_read_mdix(struct phy_device *phydev);
 int genphy_c45_pma_read_abilities(struct phy_device *phydev);
+int genphy_c45_read_status(struct phy_device *phydev);
 
 /* The gen10g_* functions are the old Clause 45 stub */
 int gen10g_config_aneg(struct phy_device *phydev);

commit 1af9f16840e920c6193490ae58371fc5cc28bb01
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Feb 18 21:27:18 2019 +0100

    net: phy: add genphy_c45_check_and_restart_aneg
    
    This function will be used by config_aneg callback implementations of
    PHY drivers and allows to reduce boilerplate code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 761131de4971..8e9fc576472b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1097,6 +1097,7 @@ int genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,
 
 /* Clause 45 PHY */
 int genphy_c45_restart_aneg(struct phy_device *phydev);
+int genphy_c45_check_and_restart_aneg(struct phy_device *phydev, bool restart);
 int genphy_c45_aneg_done(struct phy_device *phydev);
 int genphy_c45_read_link(struct phy_device *phydev);
 int genphy_c45_read_lpa(struct phy_device *phydev);

commit cd34499cacf3c34e2e094ff2a347b9378417970c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Feb 18 21:26:58 2019 +0100

    net: phy: export genphy_config_eee_advert
    
    We want to use this function in phy-c45.c too, therefore export it.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3db507e68191..761131de4971 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1077,6 +1077,7 @@ void phy_attached_info(struct phy_device *phydev);
 int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
+int genphy_config_eee_advert(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
 int genphy_aneg_done(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);

commit 9a5dc8af441668a3db7fdcd927cb288be62c0a2e
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Feb 17 10:29:19 2019 +0100

    net: phy: add genphy_c45_an_config_aneg
    
    C45 configuration of 10/100 and multi-giga bit auto negotiation
    advertisement is standardized. Configuration of 1000Base-T however
    appears to be vendor specific. Move the generic code out of the
    Marvell driver into the common phy-c45.c file.
    
    v2:
    - change function name to genphy_c45_an_config_aneg
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    [hkallweit1@gmail.com: use new helper linkmode_adv_to_mii_10gbt_adv_t and split patch]
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bf1070c2a53b..3db507e68191 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1101,6 +1101,7 @@ int genphy_c45_read_link(struct phy_device *phydev);
 int genphy_c45_read_lpa(struct phy_device *phydev);
 int genphy_c45_read_pma(struct phy_device *phydev);
 int genphy_c45_pma_setup_forced(struct phy_device *phydev);
+int genphy_c45_an_config_aneg(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 int genphy_c45_read_mdix(struct phy_device *phydev);
 int genphy_c45_pma_read_abilities(struct phy_device *phydev);

commit 3313da8188cc346a205783c22c37e821b4b7016d
Merge: 50f444aa50a4 24f0a48743a2
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Feb 15 12:38:38 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    The netfilter conflicts were rather simple overlapping
    changes.
    
    However, the cls_tcindex.c stuff was a bit more complex.
    
    On the 'net' side, Cong is fixing several races and memory
    leaks.  Whilst on the 'net-next' side we have Vlad adding
    the rtnl-ness support.
    
    What I've decided to do, in order to resolve this, is revert the
    conversion over to using a workqueue that Cong did, bringing us back
    to pure RCU.  I did it this way because I believe that either Cong's
    races don't apply with have Vlad did things, or Cong will have to
    implement the race fix slightly differently.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a2fc9d7e36f6d484d9be4a0a204400aaf6059544
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Feb 13 20:11:40 2019 +0100

    net: phy: don't use locking in phy_is_started
    
    Russell suggested to remove the locking from phy_is_started() because
    the read is atomic anyway and actually the locking may be more
    misleading.
    
    Fixes: 2b3e88ea6528 ("net: phy: improve phy state checking")
    Suggested-by: Russell King - ARM Linux admin <linux@armlinux.org.uk>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ef20aeea10cc..127fcc9c3778 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -674,26 +674,13 @@ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask);
 
-static inline bool __phy_is_started(struct phy_device *phydev)
-{
-	WARN_ON(!mutex_is_locked(&phydev->lock));
-
-	return phydev->state >= PHY_UP;
-}
-
 /**
  * phy_is_started - Convenience function to check whether PHY is started
  * @phydev: The phy_device struct
  */
 static inline bool phy_is_started(struct phy_device *phydev)
 {
-	bool started;
-
-	mutex_lock(&phydev->lock);
-	started = __phy_is_started(phydev);
-	mutex_unlock(&phydev->lock);
-
-	return started;
+	return phydev->state >= PHY_UP;
 }
 
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);

commit ac3f5533343f6ec7fa24a27f0ae22bbfd27e0b23
Author: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date:   Mon Feb 11 15:25:28 2019 +0100

    net: phy: Extract genphy_c45_pma_read_abilities from marvell10g
    
    Marvell 10G PHY driver has a generic way of initializing the supported
    link modes by reading the PHY's C45 PMA abilities. This can be made
    generic, since these registers are part of the 802.3 specifications.
    
    This commit extracts the config_init link_mode initialization code from
    marvell10g and uses it to introduce the genphy_c45_pma_read_abilities
    function.
    
    Only PMA modes are read, it's still up to the caller to set the Pause
    parameters.
    
    Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1a1d93a2a906..177a330d84e5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1116,6 +1116,7 @@ int genphy_c45_read_pma(struct phy_device *phydev);
 int genphy_c45_pma_setup_forced(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 int genphy_c45_read_mdix(struct phy_device *phydev);
+int genphy_c45_pma_read_abilities(struct phy_device *phydev);
 
 /* The gen10g_* functions are the old Clause 45 stub */
 int gen10g_config_aneg(struct phy_device *phydev);

commit 3feb9b23bf4cbf9f34568035170c6f1c25416523
Author: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date:   Mon Feb 11 15:25:27 2019 +0100

    net: phy: Move of_set_phy_eee_broken to phy-core.c
    
    Since of_set_phy_supported was moved to phy-core.c, we can also move
    of_set_phy_eee_broken to the same location, so that we have all OF
    functions in the same place.
    
    This patch doesn't intend to introduce any change in behaviour.
    
    Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 20344c7744d8..1a1d93a2a906 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -674,6 +674,7 @@ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask);
 void of_set_phy_supported(struct phy_device *phydev);
+void of_set_phy_eee_broken(struct phy_device *phydev);
 
 static inline bool __phy_is_started(struct phy_device *phydev)
 {

commit a4eaed9f9a895b16bb2c54e0ff6b3c99404fec92
Author: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date:   Mon Feb 11 15:25:26 2019 +0100

    net: phy: Mask-out non-compatible modes when setting the max-speed
    
    When setting a PHY's max speed using either the max-speed DT property
    or ethtool, we should mask-out all non-compatible modes according to the
    settings table, instead of just the 10/100BASET modes.
    
    Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Suggested-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 378da9a6165e..20344c7744d8 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -673,6 +673,7 @@ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 		   bool exact);
 size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask);
+void of_set_phy_supported(struct phy_device *phydev);
 
 static inline bool __phy_is_started(struct phy_device *phydev)
 {

commit b8554d4f7288f86fb278e0bc7b5b19579bf16b69
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Feb 10 19:57:56 2019 +0100

    net: phy: add register modifying helpers returning 1 on change
    
    When modifying registers there are scenarios where we need to know
    whether the register content actually changed. This patch adds
    new helpers to not break users of the current ones, phy_modify() etc.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d2ffae992e4a..378da9a6165e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -799,13 +799,21 @@ int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
  */
 int __phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 
+int __phy_modify_changed(struct phy_device *phydev, u32 regnum, u16 mask,
+			 u16 set);
+int phy_modify_changed(struct phy_device *phydev, u32 regnum, u16 mask,
+		       u16 set);
 int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 int phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 
+int __phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,
+			     u16 mask, u16 set);
+int phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,
+			   u16 mask, u16 set);
 int __phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
-		u16 mask, u16 set);
+		     u16 mask, u16 set);
 int phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
-		u16 mask, u16 set);
+		   u16 mask, u16 set);
 
 /**
  * __phy_set_bits - Convenience function for setting bits in a PHY register

commit efbdfdc29bdd4dbf79ad4bddc8f7a5ac62c66bfe
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Feb 9 15:24:47 2019 +0100

    net: phy: Add support for asking the PHY its abilities
    
    Add support for runtime determination of what the PHY supports, by
    adding a new function to the phy driver. The get_features call should
    set the phydev->supported member with the features the PHY supports.
    It is only called if phydrv->features is NULL.
    
    This requires minor changes to pause. The PHY driver should not set
    pause abilities, except for when it has odd cause capabilities, e.g.
    pause cannot be disabled. With this change, phydev->supported already
    contains the drivers abilities, including pause. So rather than
    considering phydrv->features, look at the phydev->supported, and
    enable pause if neither of the pause bits are already set.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    [hkallweit1@gmail.com: fixed small checkpatch complaint in one comment]
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f41bf651f6a0..d2ffae992e4a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -502,6 +502,12 @@ struct phy_driver {
 	 */
 	int (*probe)(struct phy_device *phydev);
 
+	/*
+	 * Probe the hardware to determine what abilities it has.
+	 * Should only set phydev->supported.
+	 */
+	int (*get_features)(struct phy_device *phydev);
+
 	/* PHY Power Management */
 	int (*suspend)(struct phy_device *phydev);
 	int (*resume)(struct phy_device *phydev);

commit 998a8a8387ff5f65da456d1fc448dbb926fb5d78
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Feb 7 21:41:46 2019 +0100

    net: phy: let genphy_c45_read_link manage the devices to check
    
    Let genphy_c45_read_link manage the devices to check, this removes
    overhead from callers. Add C22EXT to the list of excluded devices
    because it doesn't implement the status register. According to the
    802.3 clause 45 spec registers 29.0 - 29.4 are reserved.
    
    At the moment we have very few clause 45 PHY drivers, so we are
    lacking experience whether other drivers will have to exclude further
    devices, or may need to check PHY XS. If we should figure out that
    list of devices to check needs to be configurable, I think best will
    be to add a device list member to struct phy_driver.
    
    v2:
    - adjusted commit message
    - exclude also device C22EXT from link checking
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 237dd035858a..f41bf651f6a0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1094,7 +1094,7 @@ int genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,
 /* Clause 45 PHY */
 int genphy_c45_restart_aneg(struct phy_device *phydev);
 int genphy_c45_aneg_done(struct phy_device *phydev);
-int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask);
+int genphy_c45_read_link(struct phy_device *phydev);
 int genphy_c45_read_lpa(struct phy_device *phydev);
 int genphy_c45_read_pma(struct phy_device *phydev);
 int genphy_c45_pma_setup_forced(struct phy_device *phydev);

commit 1878f0dcbff0cd07f62602deb160a44d69a8f146
Author: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date:   Wed Feb 6 07:36:40 2019 +0100

    net: phy: provide full set of accessor functions to MMD registers
    
    This adds full set of locked and unlocked accessor functions to read and
    write PHY MMD registers and/or bitfields.
    
    Set of functions exactly matches what is already available for PHY
    legacy registers.
    
    Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 70f83d0d7469..237dd035858a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -692,17 +692,6 @@ static inline bool phy_is_started(struct phy_device *phydev)
 
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);
 
-/**
- * phy_read_mmd - Convenience function for reading a register
- * from an MMD on a given PHY.
- * @phydev: The phy_device struct
- * @devad: The MMD to read from
- * @regnum: The register on the MMD to read
- *
- * Same rules as for phy_read();
- */
-int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
-
 /**
  * phy_read - Convenience function for reading a given PHY register
  * @phydev: the phy_device struct
@@ -758,9 +747,60 @@ static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 			       val);
 }
 
+/**
+ * phy_read_mmd - Convenience function for reading a register
+ * from an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ *
+ * Same rules as for phy_read();
+ */
+int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
+
+/**
+ * __phy_read_mmd - Convenience function for reading a register
+ * from an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ *
+ * Same rules as for __phy_read();
+ */
+int __phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
+
+/**
+ * phy_write_mmd - Convenience function for writing a register
+ * on an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to write to
+ * @regnum: The register on the MMD to read
+ * @val: value to write to @regnum
+ *
+ * Same rules as for phy_write();
+ */
+int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
+
+/**
+ * __phy_write_mmd - Convenience function for writing a register
+ * on an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to write to
+ * @regnum: The register on the MMD to read
+ * @val: value to write to @regnum
+ *
+ * Same rules as for __phy_write();
+ */
+int __phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
+
 int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 int phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 
+int __phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
+		u16 mask, u16 set);
+int phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,
+		u16 mask, u16 set);
+
 /**
  * __phy_set_bits - Convenience function for setting bits in a PHY register
  * @phydev: the phy_device struct
@@ -810,6 +850,66 @@ static inline int phy_clear_bits(struct phy_device *phydev, u32 regnum, u16 val)
 	return phy_modify(phydev, regnum, val, 0);
 }
 
+/**
+ * __phy_set_bits_mmd - Convenience function for setting bits in a register
+ * on MMD
+ * @phydev: the phy_device struct
+ * @devad: the MMD containing register to modify
+ * @regnum: register number to modify
+ * @val: bits to set
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_set_bits_mmd(struct phy_device *phydev, int devad,
+		u32 regnum, u16 val)
+{
+	return __phy_modify_mmd(phydev, devad, regnum, 0, val);
+}
+
+/**
+ * __phy_clear_bits_mmd - Convenience function for clearing bits in a register
+ * on MMD
+ * @phydev: the phy_device struct
+ * @devad: the MMD containing register to modify
+ * @regnum: register number to modify
+ * @val: bits to clear
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_clear_bits_mmd(struct phy_device *phydev, int devad,
+		u32 regnum, u16 val)
+{
+	return __phy_modify_mmd(phydev, devad, regnum, val, 0);
+}
+
+/**
+ * phy_set_bits_mmd - Convenience function for setting bits in a register
+ * on MMD
+ * @phydev: the phy_device struct
+ * @devad: the MMD containing register to modify
+ * @regnum: register number to modify
+ * @val: bits to set
+ */
+static inline int phy_set_bits_mmd(struct phy_device *phydev, int devad,
+		u32 regnum, u16 val)
+{
+	return phy_modify_mmd(phydev, devad, regnum, 0, val);
+}
+
+/**
+ * phy_clear_bits_mmd - Convenience function for clearing bits in a register
+ * on MMD
+ * @phydev: the phy_device struct
+ * @devad: the MMD containing register to modify
+ * @regnum: register number to modify
+ * @val: bits to clear
+ */
+static inline int phy_clear_bits_mmd(struct phy_device *phydev, int devad,
+		u32 regnum, u16 val)
+{
+	return phy_modify_mmd(phydev, devad, regnum, val, 0);
+}
+
 /**
  * phy_interrupt_is_valid - Convenience function for testing a given PHY irq
  * @phydev: the phy_device struct
@@ -886,18 +986,6 @@ static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
 	return phydev->is_pseudo_fixed_link;
 }
 
-/**
- * phy_write_mmd - Convenience function for writing a register
- * on an MMD on a given PHY.
- * @phydev: The phy_device struct
- * @devad: The MMD to read from
- * @regnum: The register on the MMD to read
- * @val: value to write to @regnum
- *
- * Same rules as for phy_write();
- */
-int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
-
 int phy_save_page(struct phy_device *phydev);
 int phy_select_page(struct phy_device *phydev, int page);
 int phy_restore_page(struct phy_device *phydev, int oldpage, int ret);

commit 434a4315b9617bf1742bc64712bf44a208502f7f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Jan 23 07:31:58 2019 +0100

    net: phy: change phy_start_interrupts to phy_request_interrupt
    
    Now that we enable the interrupts in phy_start() we don't have to do it
    before. Therefore remove enabling interrupts from phy_start_interrupts()
    and rename this function to reflect the changed functionality.
    
    v2:
    - improve warning to clearly state that we fall back to polling
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1f3873a2ff29..70f83d0d7469 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1047,7 +1047,7 @@ void phy_ethtool_ksettings_get(struct phy_device *phydev,
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
-int phy_start_interrupts(struct phy_device *phydev);
+void phy_request_interrupt(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);

commit fa7f3a8d56b38a3ed1880a3780afba82387da277
Merge: 28f9d1a3d4fe 49a57857aeea
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jan 21 14:41:32 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Completely minor snmp doc conflict.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3e64cf7a435ed0500e3adaa8aada2272d3ae8abc
Author: Camelia Groza <camelia.groza@nxp.com>
Date:   Thu Jan 17 14:22:36 2019 +0200

    net: phy: phy driver features are mandatory
    
    Since phy driver features became a link_mode bitmap, phy drivers that
    don't have a list of features configured will cause the kernel to crash
    when probed.
    
    Prevent the phy driver from registering if the features field is missing.
    
    Fixes: 719655a14971 ("net: phy: Replace phy driver features u32 with link_mode bitmap")
    Reported-by: Scott Wood <oss@buserror.net>
    Signed-off-by: Camelia Groza <camelia.groza@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 55114657a577..ef20aeea10cc 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -469,8 +469,8 @@ struct phy_device {
  *   only works for PHYs with IDs which match this field
  * name: The friendly name of this PHY type
  * phy_id_mask: Defines the important bits of the phy_id
- * features: A list of features (speed, duplex, etc) supported
- *   by this PHY
+ * features: A mandatory list of features (speed, duplex, etc)
+ *   supported by this PHY
  * flags: A bitfield defining certain other features this PHY
  *   supports (like interrupts)
  *

commit bb658ab7b8f2828b35c207a95cb0c05965721022
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Jan 17 20:09:21 2019 +0100

    net: phy: remove phy_stop_interrupts
    
    Interrupts have been disabled in phy_stop() already. So we can remove
    phy_stop_interrupts() and free the interrupt in phy_disconnect()
    directly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 232d93b9cea4..0990f913d649 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -951,7 +951,6 @@ int phy_aneg_done(struct phy_device *phydev);
 int phy_speed_down(struct phy_device *phydev, bool sync);
 int phy_speed_up(struct phy_device *phydev);
 
-int phy_stop_interrupts(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);
 int phy_reset_after_clk_enable(struct phy_device *phydev);
 

commit e302c2a5fe0ca63b8fcc93389917625f486e0670
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Jan 16 19:47:57 2019 +0100

    net: phy: remove state PHY_CHANGELINK
    
    Since recent changes to the phylib state machine state PHY_CHANGELINK
    isn't used any longer. Therefore let's remove it.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f1c19bf8c658..232d93b9cea4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -304,11 +304,6 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  * - irq or timer will set NOLINK if link goes down
  * - phy_stop moves to HALTED
  *
- * CHANGELINK: PHY experienced a change in link state
- * - timer moves to RUNNING if link
- * - timer moves to NOLINK if the link is down
- * - phy_stop moves to HALTED
- *
  * HALTED: PHY is up, but no polling or interrupts are done. Or
  * PHY is in an error state.
  *
@@ -327,7 +322,6 @@ enum phy_state {
 	PHY_RUNNING,
 	PHY_NOLINK,
 	PHY_FORCING,
-	PHY_CHANGELINK,
 	PHY_RESUMING
 };
 

commit 5db5ea995fc2fa89fdef61ef3a658cbb41a24222
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jan 15 15:09:35 2019 -0800

    net: phy: Add helpers to determine if PHY driver is generic
    
    We are already checking in phy_detach() that the PHY driver is of
    generic kind (1G or 10G) and we are going to make use of that in the SFP
    layer as well for 1000BaseT SFP modules, so expose helper functions to
    return that information.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3b051f761450..f1c19bf8c658 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1183,4 +1183,7 @@ module_exit(phy_module_exit)
 #define module_phy_driver(__phy_drivers)				\
 	phy_module_driver(__phy_drivers, ARRAY_SIZE(__phy_drivers))
 
+bool phy_driver_is_genphy(struct phy_device *phydev);
+bool phy_driver_is_genphy_10g(struct phy_device *phydev);
+
 #endif /* __PHY_H */

commit 9e857a40dc4eba15a739b4194d7db873d82c28a0
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Jan 15 16:55:30 2019 +0100

    net: phy: Add missing features to PHY drivers
    
    The bcm87xx and micrel driver has PHYs which are missing the .features
    value. Add them. The bcm87xx is a 10G FEC only PHY. Add the needed
    features definition of this PHY.
    
    Fixes: 719655a14971 ("net: phy: Replace phy driver features u32 with link_mode bitmap")
    Reported-by: Scott Wood <oss@buserror.net>
    Reported-by: Camelia Groza <camelia.groza@nxp.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3b051f761450..55114657a577 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -48,6 +48,7 @@ extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;
 extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;
 extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;
 extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_fec_features) __ro_after_init;
 extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;
 
 #define PHY_BASIC_FEATURES ((unsigned long *)&phy_basic_features)
@@ -56,6 +57,7 @@ extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_ini
 #define PHY_GBIT_FIBRE_FEATURES ((unsigned long *)&phy_gbit_fibre_features)
 #define PHY_GBIT_ALL_PORTS_FEATURES ((unsigned long *)&phy_gbit_all_ports_features)
 #define PHY_10GBIT_FEATURES ((unsigned long *)&phy_10gbit_features)
+#define PHY_10GBIT_FEC_FEATURES ((unsigned long *)&phy_10gbit_fec_features)
 #define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)
 
 extern const int phy_10_100_features_array[4];

commit d8de01b763e0d8b3b418d3606d26f203983b6637
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Dec 26 06:35:23 2018 -0600

    phy.h: fix obvious errors in doc and kerneldoc content
    
    1) note that gianfar_phy.c was removed years ago
     2) fix obvious copy and paste error in regular doc
     3) change regular doc into kerneldoc for phy_modes()
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index da039f211c22..3b051f761450 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1,6 +1,6 @@
 /*
  * Framework and drivers for configuring and reading different PHYs
- * Based on code in sungem_phy.c and gianfar_phy.c
+ * Based on code in sungem_phy.c and (long-removed) gianfar_phy.c
  *
  * Author: Andy Fleming
  *
@@ -110,9 +110,9 @@ typedef enum {
  * @speeds: buffer to store supported speeds in.
  * @size: size of speeds buffer.
  *
- * Description: Returns the number of supported speeds, and
- * fills the speeds * buffer with the supported speeds. If speeds buffer is
- * too small to contain * all currently supported speeds, will return as
+ * Description: Returns the number of supported speeds, and fills
+ * the speeds buffer with the supported speeds. If speeds buffer is
+ * too small to contain all currently supported speeds, will return as
  * many speeds as can fit.
  */
 unsigned int phy_supported_speeds(struct phy_device *phy,
@@ -120,7 +120,10 @@ unsigned int phy_supported_speeds(struct phy_device *phy,
 				      unsigned int size);
 
 /**
- * It maps 'enum phy_interface_t' found in include/linux/phy.h
+ * phy_modes - map phy_interface_t enum to device tree binding of phy-mode
+ * @interface: enum phy_interface_t value
+ *
+ * Description: maps 'enum phy_interface_t' defined in this file
  * into the device tree binding of 'phy-mode', so that Ethernet
  * device driver can get phy interface from device tree.
  */

commit 2b3e88ea65287ba738a798622405b15344871085
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Dec 16 18:30:14 2018 +0100

    net: phy: improve phy state checking
    
    Add helpers phy_is_started() and __phy_is_started() to avoid open-coded
    checks whether PHY has been started. To make the check easier move
    PHY_HALTED before PHY_UP in enum phy_state. Further improvements:
    
    phy_start_aneg():
    Return -EBUSY and print warning if function is called from a non-started
    state (DOWN, READY, HALTED). Better check because function is exported
    and drivers may use it incorrectly.
    
    phy_interrupt():
    Return IRQ_NONE also if state is DOWN or READY. We should never receive
    an interrupt in one of these states, but better play safe.
    
    phy_stop():
    Just return and print a warning if PHY is in a non-started state.
    This warning should help to identify drivers with unbalanced calls to
    phy_start() / phy_stop().
    
    phy_state_machine():
    Schedule state machine run only if PHY is in a started state.
    E.g. if state is READY we don't need the state machine, it will be
    started by phy_start().
    
    v2:
    - don't use __func__ within phy_warn_state
    v3:
    - use WARN() instead of printing error message to facilitate debugging
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8f927246acdb..da039f211c22 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -319,12 +319,12 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 enum phy_state {
 	PHY_DOWN = 0,
 	PHY_READY,
+	PHY_HALTED,
 	PHY_UP,
 	PHY_RUNNING,
 	PHY_NOLINK,
 	PHY_FORCING,
 	PHY_CHANGELINK,
-	PHY_HALTED,
 	PHY_RESUMING
 };
 
@@ -669,6 +669,28 @@ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask);
 
+static inline bool __phy_is_started(struct phy_device *phydev)
+{
+	WARN_ON(!mutex_is_locked(&phydev->lock));
+
+	return phydev->state >= PHY_UP;
+}
+
+/**
+ * phy_is_started - Convenience function to check whether PHY is started
+ * @phydev: The phy_device struct
+ */
+static inline bool phy_is_started(struct phy_device *phydev)
+{
+	bool started;
+
+	mutex_lock(&phydev->lock);
+	started = __phy_is_started(phydev);
+	mutex_unlock(&phydev->lock);
+
+	return started;
+}
+
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);
 
 /**

commit c0ec3c2736774c69bf5c641aea7712132c0f0eba
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Nov 10 23:43:34 2018 +0100

    net: phy: Convert u32 phydev->lp_advertising to linkmode
    
    Convert phy drivers to report the link partner advertised modes using
    a linkmode bitmap. This allows them to report the higher speeds which
    don't fit in a u32.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index cbc66ac3b560..8f927246acdb 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -414,8 +414,7 @@ struct phy_device {
 	/* See ethtool.h for more info */
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
-
-	u32 lp_advertising;
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(lp_advertising);
 
 	/* Energy efficient ethernet modes which should be prohibited */
 	u32 eee_broken_modes;

commit 3c1bcc8614db10803f1f57ef0295363917448cb2
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Nov 10 23:43:33 2018 +0100

    net: ethernet: Convert phydev advertize and supported from u32 to link mode
    
    There are a few MAC/PHYs combinations which now support > 1Gbps. These
    may need to make use of link modes with bits > 31. Thus their
    supported PHY features or advertised features cannot be implemented
    using the current bitmap in a u32. Convert to using a linkmode bitmap,
    which can support all the currently devices link modes, and is future
    proof as more modes are added.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a5bcb4aaa48e..cbc66ac3b560 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -58,6 +58,11 @@ extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_ini
 #define PHY_10GBIT_FEATURES ((unsigned long *)&phy_10gbit_features)
 #define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)
 
+extern const int phy_10_100_features_array[4];
+extern const int phy_basic_t1_features_array[2];
+extern const int phy_gbit_features_array[2];
+extern const int phy_10gbit_features_array[1];
+
 /*
  * Set phydev->irq to PHY_POLL if interrupts are not supported,
  * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if
@@ -405,10 +410,11 @@ struct phy_device {
 	int pause;
 	int asym_pause;
 
-	/* Union of PHY and Attached devices' supported modes */
-	/* See mii.h for more info */
-	u32 supported;
-	u32 advertising;
+	/* Union of PHY and Attached devices' supported link modes */
+	/* See ethtool.h for more info */
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
+
 	u32 lp_advertising;
 
 	/* Energy efficient ethernet modes which should be prohibited */
@@ -660,9 +666,9 @@ struct phy_setting {
 
 const struct phy_setting *
 phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
-		   size_t maxbit, bool exact);
+		   bool exact);
 size_t phy_speeds(unsigned int *speeds, size_t size,
-		  unsigned long *mask, size_t maxbit);
+		  unsigned long *mask);
 
 void phy_resolve_aneg_linkmode(struct phy_device *phydev);
 

commit 899a3cbbf77a2a3d6d53d67ff6f10ad59eb03605
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Nov 10 23:40:50 2018 +0100

    net: phy: remove states PHY_STARTING and PHY_PENDING
    
    Both states aren't used. Most likely they result from an idea that
    never materialized. So remove them.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 03005c65e02d..a5bcb4aaa48e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -270,29 +270,13 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  * DOWN: PHY device and driver are not ready for anything.  probe
  * should be called if and only if the PHY is in this state,
  * given that the PHY device exists.
- * - PHY driver probe function will, depending on the PHY, set
- * the state to STARTING or READY
- *
- * STARTING:  PHY device is coming up, and the ethernet driver is
- * not ready.  PHY drivers may set this in the probe function.
- * If they do, they are responsible for making sure the state is
- * eventually set to indicate whether the PHY is UP or READY,
- * depending on the state when the PHY is done starting up.
- * - PHY driver will set the state to READY
- * - start will set the state to PENDING
+ * - PHY driver probe function will set the state to READY
  *
  * READY: PHY is ready to send and receive packets, but the
  * controller is not.  By default, PHYs which do not implement
- * probe will be set to this state by phy_probe().  If the PHY
- * driver knows the PHY is ready, and the PHY state is STARTING,
- * then it sets this STATE.
+ * probe will be set to this state by phy_probe().
  * - start will set the state to UP
  *
- * PENDING: PHY device is coming up, but the ethernet driver is
- * ready.  phy_start will set this state if the PHY state is
- * STARTING.
- * - PHY driver will set the state to UP when the PHY is ready
- *
  * UP: The PHY and attached device are ready to do work.
  * Interrupts should be started here.
  * - timer moves to NOLINK or RUNNING
@@ -329,9 +313,7 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  */
 enum phy_state {
 	PHY_DOWN = 0,
-	PHY_STARTING,
 	PHY_READY,
-	PHY_PENDING,
 	PHY_UP,
 	PHY_RUNNING,
 	PHY_NOLINK,

commit aa2af2eb447c9a21c8c9e8d2336672bb620cf900
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Nov 10 00:39:14 2018 +0100

    net: phy: add macros for PHYID matching
    
    Add macros for PHYID matching to be used in PHY driver configs.
    By using these macros some boilerplate code can be avoided.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 17d1f64723e4..03005c65e02d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -651,6 +651,10 @@ struct phy_driver {
 #define PHY_ANY_ID "MATCH ANY PHY"
 #define PHY_ANY_UID 0xffffffff
 
+#define PHY_ID_MATCH_EXACT(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 0)
+#define PHY_ID_MATCH_MODEL(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 4)
+#define PHY_ID_MATCH_VENDOR(id) .phy_id = (id), .phy_id_mask = GENMASK(31, 10)
+
 /* A Structure for boards to register fixups with the PHY Lib */
 struct phy_fixup {
 	struct list_head list;

commit d73a2156bdad6bdf7e0c42051c5ebbea11f6271e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 9 18:56:52 2018 +0100

    net: phy: simplify phy_mac_interrupt and related functions
    
    When using phy_mac_interrupt() the irq number is set to
    PHY_IGNORE_INTERRUPT, therefore phy_interrupt_is_valid() returns false.
    As a result phy_change() effectively just calls phy_trigger_machine()
    when called from phy_mac_interrupt() via phy_change_work(). So we can
    call phy_trigger_machine() from phy_mac_interrupt() directly and
    remove some now unneeded code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7db07e69c88f..17d1f64723e4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -369,7 +369,6 @@ struct phy_c45_device_ids {
  * giving up on the current attempt at acquiring a link
  * irq: IRQ number of the PHY's interrupt (-1 if none)
  * phy_timer: The timer for handling the state machine
- * phy_queue: A work_queue for the phy_mac_interrupt
  * attached_dev: The attached enet driver's device instance ptr
  * adjust_link: Callback for the enet controller to respond to
  * changes in the link state.
@@ -454,7 +453,6 @@ struct phy_device {
 	void *priv;
 
 	/* Interrupt and Polling infrastructure */
-	struct work_struct phy_queue;
 	struct delayed_work state_queue;
 
 	struct mutex lock;
@@ -1029,7 +1027,6 @@ int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 int phy_drivers_register(struct phy_driver *new_driver, int n,
 			 struct module *owner);
 void phy_state_machine(struct work_struct *work);
-void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);

commit 8deeb6309cc447b9b35939558f18e2164dd110df
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 9 18:55:50 2018 +0100

    net: phy: don't set state PHY_CHANGELINK in phy_change
    
    State PHY_CHANGELINK isn't needed here, we can call the state machine
    directly. We just have to remove the check for phy_polling_mode() to
    make this work also in interrupt mode. Removing this check doesn't
    cause any overhead because when not polling the state machine is
    called only if required by some event.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 59bb31ee132f..7db07e69c88f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -298,7 +298,7 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  * - timer moves to NOLINK or RUNNING
  *
  * NOLINK: PHY is up, but not currently plugged in.
- * - If the timer notes that the link comes back, we move to RUNNING
+ * - irq or timer will set RUNNING if link comes back
  * - phy_stop moves to HALTED
  *
  * FORCING: PHY is being configured with forced settings
@@ -309,10 +309,7 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  *
  * RUNNING: PHY is currently up, running, and possibly sending
  * and/or receiving packets
- * - timer will set CHANGELINK if we're polling (this ensures the
- *   link state is polled every other cycle of this state machine,
- *   which makes it every other second)
- * - irq will set CHANGELINK
+ * - irq or timer will set NOLINK if link goes down
  * - phy_stop moves to HALTED
  *
  * CHANGELINK: PHY experienced a change in link state

commit a4307c0ec66131e722a8fa0f1da09646c46ee924
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 9 18:17:22 2018 +0100

    net: phy: remove flag PHY_HAS_INTERRUPT from driver configs
    
    Now that flag PHY_HAS_INTERRUPT has been replaced with a check for
    callbacks config_intr and ack_interrupt, we can remove setting this
    flag from all driver configs.
    Last but not least remove flag PHY_HAS_INTERRUPT completely.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3299ec6e69f3..59bb31ee132f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -66,9 +66,8 @@ extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_ini
 #define PHY_POLL		-1
 #define PHY_IGNORE_INTERRUPT	-2
 
-#define PHY_HAS_INTERRUPT	0x00000001
-#define PHY_IS_INTERNAL		0x00000002
-#define PHY_RST_AFTER_CLK_EN	0x00000004
+#define PHY_IS_INTERNAL		0x00000001
+#define PHY_RST_AFTER_CLK_EN	0x00000002
 #define MDIO_DEVICE_IS_PHY	0x80000000
 
 /* Interface Mode definitions */

commit 695bce8fd8e994999f40ee279e2fa9979cbae87a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 9 18:35:52 2018 +0100

    net: phy: improve struct phy_device member interrupts handling
    
    As a heritage from the very early days of phylib member interrupts is
    defined as u32 even though it's just a flag whether interrupts are
    enabled. So we can change it to a bitfield member. In addition change
    the code dealing with this member in a way that it's clear we're
    dealing with a bool value.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2090277eac4f..3299ec6e69f3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -263,8 +263,8 @@ static inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)
 void devm_mdiobus_free(struct device *dev, struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 
-#define PHY_INTERRUPT_DISABLED	0x0
-#define PHY_INTERRUPT_ENABLED	0x80000000
+#define PHY_INTERRUPT_DISABLED	false
+#define PHY_INTERRUPT_ENABLED	true
 
 /* PHY state machine states:
  *
@@ -410,6 +410,9 @@ struct phy_device {
 	/* The most recently read link state */
 	unsigned link:1;
 
+	/* Interrupts are enabled */
+	unsigned interrupts:1;
+
 	enum phy_state state;
 
 	u32 dev_flags;
@@ -425,9 +428,6 @@ struct phy_device {
 	int pause;
 	int asym_pause;
 
-	/* Enabled Interrupts */
-	u32 interrupts;
-
 	/* Union of PHY and Attached devices' supported modes */
 	/* See mii.h for more info */
 	u32 supported;

commit 85a1f31d6392fb2c6726fcc4e072de008e3f0656
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Nov 7 20:46:51 2018 +0100

    net: phy: remove state PHY_AN
    
    After the recent changes in the state machine state PHY_AN isn't used
    any longer and can be removed.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9e4d49ef4bca..2090277eac4f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -178,7 +178,6 @@ static inline const char *phy_modes(phy_interface_t interface)
 #define PHY_INIT_TIMEOUT	100000
 #define PHY_STATE_TIME		1
 #define PHY_FORCE_TIMEOUT	10
-#define PHY_AN_TIMEOUT		10
 
 #define PHY_MAX_ADDR	32
 
@@ -297,24 +296,10 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  *
  * UP: The PHY and attached device are ready to do work.
  * Interrupts should be started here.
- * - timer moves to AN
- *
- * AN: The PHY is currently negotiating the link state.  Link is
- * therefore down for now.  phy_timer will set this state when it
- * detects the state is UP.  config_aneg will set this state
- * whenever called with phydev->autoneg set to AUTONEG_ENABLE.
- * - If autonegotiation finishes, but there's no link, it sets
- *   the state to NOLINK.
- * - If aneg finishes with link, it sets the state to RUNNING,
- *   and calls adjust_link
- * - If autonegotiation did not finish after an arbitrary amount
- *   of time, autonegotiation should be tried again if the PHY
- *   supports "magic" autonegotiation (back to AN)
- * - If it didn't finish, and no magic_aneg, move to FORCING.
+ * - timer moves to NOLINK or RUNNING
  *
  * NOLINK: PHY is up, but not currently plugged in.
  * - If the timer notes that the link comes back, we move to RUNNING
- * - config_aneg moves to AN
  * - phy_stop moves to HALTED
  *
  * FORCING: PHY is being configured with forced settings
@@ -329,7 +314,6 @@ struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
  *   link state is polled every other cycle of this state machine,
  *   which makes it every other second)
  * - irq will set CHANGELINK
- * - config_aneg will set AN
  * - phy_stop moves to HALTED
  *
  * CHANGELINK: PHY experienced a change in link state
@@ -353,7 +337,6 @@ enum phy_state {
 	PHY_READY,
 	PHY_PENDING,
 	PHY_UP,
-	PHY_AN,
 	PHY_RUNNING,
 	PHY_NOLINK,
 	PHY_FORCING,

commit a3320bcf28e07163354b0acfad874bf46209df63
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Nov 7 08:15:58 2018 +0100

    net: phy: make phy_trigger_machine static
    
    phy_trigger_machine() is used in phy.c only, so we can make it static.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3ea87f774a76..9e4d49ef4bca 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1054,7 +1054,6 @@ void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
-void phy_trigger_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 void phy_ethtool_ksettings_get(struct phy_device *phydev,
 			       struct ethtool_link_ksettings *cmd);

commit 9f2959b6b52d43326b2f6a0e0d7ffe6f4fc3b5ca
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Sep 28 08:51:09 2018 +0200

    net: phy: improve handling delayed work
    
    Using mod_delayed_work() allows to simplify handling delayed work and
    removes the need for the sync parameter in phy_trigger_machine().
    Also introduce a helper phy_queue_state_machine() to encapsulate the
    low-level delayed work calls. No functional change intended.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index dff51dd36e52..3ea87f774a76 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1054,7 +1054,7 @@ void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
-void phy_trigger_machine(struct phy_device *phydev, bool sync);
+void phy_trigger_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 void phy_ethtool_ksettings_get(struct phy_device *phydev,
 			       struct ethtool_link_ksettings *cmd);

commit 719655a149715f26fc4de904fe0aa83068bd5b9e
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Sep 29 23:04:16 2018 +0200

    net: phy: Replace phy driver features u32 with link_mode bitmap
    
    This is one step in allowing phylib to make use of link_mode bitmaps,
    instead of u32 for supported and advertised features. Convert the phy
    drivers to use bitmaps to indicates the features they support.
    
    Build bitmap equivalents of the u32 values at runtime, and have the
    drivers point to the appropriate bitmap. These bitmaps are shared, and
    we don't want a driver to modify them. So mark them __ro_after_init.
    
    Within phylib, the features bitmap is currently turned back into a
    u32. This will be removed once the whole of phylib, and the drivers
    are converted to use bitmaps.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0f6e7bf5e9c5..dff51dd36e52 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -42,13 +42,21 @@
 #define PHY_1000BT_FEATURES	(SUPPORTED_1000baseT_Half | \
 				 SUPPORTED_1000baseT_Full)
 
-#define PHY_BASIC_FEATURES	(PHY_10BT_FEATURES | \
-				 PHY_100BT_FEATURES | \
-				 PHY_DEFAULT_FEATURES)
-
-#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \
-				 PHY_1000BT_FEATURES)
-
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;
+extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;
+
+#define PHY_BASIC_FEATURES ((unsigned long *)&phy_basic_features)
+#define PHY_BASIC_T1_FEATURES ((unsigned long *)&phy_basic_t1_features)
+#define PHY_GBIT_FEATURES ((unsigned long *)&phy_gbit_features)
+#define PHY_GBIT_FIBRE_FEATURES ((unsigned long *)&phy_gbit_fibre_features)
+#define PHY_GBIT_ALL_PORTS_FEATURES ((unsigned long *)&phy_gbit_all_ports_features)
+#define PHY_10GBIT_FEATURES ((unsigned long *)&phy_10gbit_features)
+#define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)
 
 /*
  * Set phydev->irq to PHY_POLL if interrupts are not supported,
@@ -510,7 +518,7 @@ struct phy_driver {
 	u32 phy_id;
 	char *name;
 	u32 phy_id_mask;
-	u32 features;
+	const unsigned long * const features;
 	u32 flags;
 	const void *driver_data;
 

commit c4fabb8b3c0d724eb93dabaf346b0dd8a8be7118
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Sep 29 23:04:11 2018 +0200

    net: phy: Add phydev_info()
    
    Add phydev_info() and make use of it within the phy drivers and core
    code.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0ab9f89773fd..0f6e7bf5e9c5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -968,6 +968,9 @@ static inline void phy_device_reset(struct phy_device *phydev, int value)
 #define phydev_err(_phydev, format, args...)	\
 	dev_err(&_phydev->mdio.dev, format, ##args)
 
+#define phydev_info(_phydev, format, args...)	\
+	dev_info(&_phydev->mdio.dev, format, ##args)
+
 #define phydev_warn(_phydev, format, args...)	\
 	dev_warn(&_phydev->mdio.dev, format, ##args)
 

commit ab2a605fa621ecf4ec26603a237822f7772cfa28
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Sep 29 23:04:10 2018 +0200

    net: phy: Add phydev_warn()
    
    Not all new style LINK_MODE bits can be converted into old style
    SUPPORTED bits. We need to warn when such a conversion is attempted.
    Add a helper for this.
    
    Convert all pr_warn() calls to phydev_warn() where possible.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d24cc46748e2..0ab9f89773fd 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -968,6 +968,9 @@ static inline void phy_device_reset(struct phy_device *phydev, int value)
 #define phydev_err(_phydev, format, args...)	\
 	dev_err(&_phydev->mdio.dev, format, ##args)
 
+#define phydev_warn(_phydev, format, args...)	\
+	dev_warn(&_phydev->mdio.dev, format, ##args)
+
 #define phydev_dbg(_phydev, format, args...)	\
 	dev_dbg(&_phydev->mdio.dev, format, ##args)
 

commit b31cdffa2329fe330cd304ca26c250dd1520fb0a
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Sep 29 23:04:09 2018 +0200

    net: phy: Move linkmode helpers to somewhere public
    
    phylink has some useful helpers to working with linkmode bitmaps.
    Move them to there own header so other code can use them.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 192a1fa0c73b..d24cc46748e2 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -19,6 +19,7 @@
 #include <linux/compiler.h>
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
+#include <linux/linkmode.h>
 #include <linux/mdio.h>
 #include <linux/mii.h>
 #include <linux/module.h>

commit 22b7d29926b577ff4f480611380d03268545b787
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:19 2018 +0200

    net: ethernet: Add helper to determine if pause configuration is supported
    
    Rather than have MAC drivers open code the test, add a helper in
    phylib. This will help when we change the type of phydev->supported.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8521391ebb20..192a1fa0c73b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1055,6 +1055,8 @@ void phy_support_asym_pause(struct phy_device *phydev);
 void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,
 		       bool autoneg);
 void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);
+bool phy_validate_pause(struct phy_device *phydev,
+			struct ethtool_pauseparam *pp);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit 0c122405d4c3ec638ba00865c872ec5a3ed1a6c0
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:18 2018 +0200

    net: ethernet: Add helper for set_pauseparam for Pause
    
    ethtool can be used to enable/disable pause. Add a helper to configure
    the PHY when Pause is supported.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e4062ba7472f..8521391ebb20 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1052,6 +1052,8 @@ int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
 void phy_support_sym_pause(struct phy_device *phydev);
 void phy_support_asym_pause(struct phy_device *phydev);
+void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,
+		       bool autoneg);
 void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,

commit 70814e819c1139e5e7faacb3700eab5eac559272
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:17 2018 +0200

    net: ethernet: Add helper for set_pauseparam for Asym Pause
    
    ethtool can be used to enable/disable pause. Add a helper to configure
    the PHY when asym pause is supported.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bc5d6c3f1388..e4062ba7472f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1052,6 +1052,7 @@ int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
 void phy_support_sym_pause(struct phy_device *phydev);
 void phy_support_asym_pause(struct phy_device *phydev);
+void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit c306ad36184fb7d0bd53f45441f45c1810e88a53
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:16 2018 +0200

    net: ethernet: Add helper for MACs which support pause
    
    Rather than have the MAC drivers manipulate phydev members, add a
    helper function for MACs supporting Pause, but not Asym Pause.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e2db819807c1..bc5d6c3f1388 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1050,6 +1050,7 @@ int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
+void phy_support_sym_pause(struct phy_device *phydev);
 void phy_support_asym_pause(struct phy_device *phydev);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,

commit af8d9bb2f2f405ad541794b46f9d7bc70f13e5cb
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:15 2018 +0200

    net: ethernet: Add helper for MACs which support asym pause
    
    Rather than have the MAC drivers manipulate phydev members to indicate
    they support Asym Pause, add a helper function.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9c4c3eca8cf2..e2db819807c1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1050,6 +1050,7 @@ int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
+void phy_support_asym_pause(struct phy_device *phydev);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit 41124fa64d4b298b82266b7ddbefc43540b77b44
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Sep 12 01:53:14 2018 +0200

    net: ethernet: Add helper to remove a supported link mode
    
    Some MAC hardware cannot support a subset of link modes. e.g. often
    1Gbps Full duplex is supported, but Half duplex is not. Add a helper
    to remove such a link mode.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index cd6f637cbbfb..9c4c3eca8cf2 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1049,6 +1049,7 @@ int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
+void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit 3c507b8af638c67d4a80d70091d2057ecb01e8a6
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Jul 23 21:40:07 2018 +0200

    net: phy: add helper phy_polling_mode
    
    Add a helper for checking whether polling is used to detect PHY status
    changes.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 075c2f770d3e..cd6f637cbbfb 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -824,6 +824,16 @@ static inline bool phy_interrupt_is_valid(struct phy_device *phydev)
 	return phydev->irq != PHY_POLL && phydev->irq != PHY_IGNORE_INTERRUPT;
 }
 
+/**
+ * phy_polling_mode - Convenience function for testing whether polling is
+ * used to detect PHY status changes
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_polling_mode(struct phy_device *phydev)
+{
+	return phydev->irq == PHY_POLL;
+}
+
 /**
  * phy_is_internal - Convenience function for testing if a PHY is internal
  * @phydev: the phy_device struct

commit 2b9672ddb6f347467d7b33b86c5dfc4d5c0501a8
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Jul 12 21:32:53 2018 +0200

    net: phy: add phy_speed_down and phy_speed_up
    
    Some network drivers include functionality to speed down the PHY when
    suspending and just waiting for a WoL packet because this saves energy.
    This functionality is quite generic, therefore let's factor it out to
    phylib.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6cd09098427c..075c2f770d3e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -942,6 +942,8 @@ void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
 int phy_aneg_done(struct phy_device *phydev);
+int phy_speed_down(struct phy_device *phydev, bool sync);
+int phy_speed_up(struct phy_device *phydev);
 
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);

commit 87e5808d52b65fc5b0bfda209ba8864cc2f933e5
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed May 23 08:05:20 2018 +0200

    net: phy: replace bool members in struct phy_device with bit-fields
    
    In struct phy_device we have a number of flags being defined as type
    bool. Similar to e.g. struct pci_dev we can save some space by using
    bit-fields.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 073235e70442..6cd09098427c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -406,13 +406,17 @@ struct phy_device {
 	u32 phy_id;
 
 	struct phy_c45_device_ids c45_ids;
-	bool is_c45;
-	bool is_internal;
-	bool is_pseudo_fixed_link;
-	bool has_fixups;
-	bool suspended;
-	bool sysfs_links;
-	bool loopback_enabled;
+	unsigned is_c45:1;
+	unsigned is_internal:1;
+	unsigned is_pseudo_fixed_link:1;
+	unsigned has_fixups:1;
+	unsigned suspended:1;
+	unsigned sysfs_links:1;
+	unsigned loopback_enabled:1;
+
+	unsigned autoneg:1;
+	/* The most recently read link state */
+	unsigned link:1;
 
 	enum phy_state state;
 
@@ -429,9 +433,6 @@ struct phy_device {
 	int pause;
 	int asym_pause;
 
-	/* The most recently read link state */
-	int link;
-
 	/* Enabled Interrupts */
 	u32 interrupts;
 
@@ -444,8 +445,6 @@ struct phy_device {
 	/* Energy efficient ethernet modes which should be prohibited */
 	u32 eee_broken_modes;
 
-	int autoneg;
-
 	int link_timeout;
 
 #ifdef CONFIG_LED_TRIGGER_PHY

commit 9e8d438e8ba43a38def2890a65a26917f2233a83
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Apr 27 12:41:49 2018 -0700

    net: phy: Fix modular PHYLIB build
    
    After commit c59530d0d5dc ("net: Move PHY statistics code into PHY
    library helpers") we made net/core/ethtool.c reference symbols which are
    part of the library which can be modular. David introduced a temporary
    fix with 1ecd6e8ad996 ("phy: Temporary build fix after phylib changes.")
    which would prevent such modularity.
    
    This is not desireable of course, so instead, just inline the functions
    into include/linux/phy.h to keep both options available.
    
    Fixes: c59530d0d5dc ("net: Move PHY statistics code into PHY library helpers")
    Fixes: 1ecd6e8ad996 ("phy: Temporary build fix after phylib changes.")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6ca81395c545..073235e70442 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1066,27 +1066,53 @@ int phy_ethtool_nway_reset(struct net_device *ndev);
 #if IS_ENABLED(CONFIG_PHYLIB)
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
-int phy_ethtool_get_strings(struct phy_device *phydev, u8 *data);
-int phy_ethtool_get_sset_count(struct phy_device *phydev);
-int phy_ethtool_get_stats(struct phy_device *phydev,
-			  struct ethtool_stats *stats, u64 *data);
-#else
-int phy_ethtool_get_strings(struct phy_device *phydev, u8 *data)
+#endif
+
+/* Inline function for use within net/core/ethtool.c (built-in) */
+static inline int phy_ethtool_get_strings(struct phy_device *phydev, u8 *data)
 {
-	return -EOPNOTSUPP;
+	if (!phydev->drv)
+		return -EIO;
+
+	mutex_lock(&phydev->lock);
+	phydev->drv->get_strings(phydev, data);
+	mutex_unlock(&phydev->lock);
+
+	return 0;
 }
 
-int phy_ethtool_get_sset_count(struct phy_device *phydev)
+static inline int phy_ethtool_get_sset_count(struct phy_device *phydev)
 {
+	int ret;
+
+	if (!phydev->drv)
+		return -EIO;
+
+	if (phydev->drv->get_sset_count &&
+	    phydev->drv->get_strings &&
+	    phydev->drv->get_stats) {
+		mutex_lock(&phydev->lock);
+		ret = phydev->drv->get_sset_count(phydev);
+		mutex_unlock(&phydev->lock);
+
+		return ret;
+	}
+
 	return -EOPNOTSUPP;
 }
 
-int phy_ethtool_get_stats(struct phy_device *phydev,
-			  struct ethtool_stats *stats, u64 *data)
+static inline int phy_ethtool_get_stats(struct phy_device *phydev,
+					struct ethtool_stats *stats, u64 *data)
 {
-	return -EOPNOTSUPP;
+	if (!phydev->drv)
+		return -EIO;
+
+	mutex_lock(&phydev->lock);
+	phydev->drv->get_stats(phydev, stats, data);
+	mutex_unlock(&phydev->lock);
+
+	return 0;
 }
-#endif
 
 extern struct bus_type mdio_bus_type;
 

commit c59530d0d5dccc96795af12c139f618182cf98db
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Apr 25 12:12:47 2018 -0700

    net: Move PHY statistics code into PHY library helpers
    
    In order to make it possible for network device drivers that do not
    necessarily have a phy_device attached, but still report PHY statistics,
    have a preliminary refactoring consisting in creating helper functions
    that encapsulate the PHY device driver knowledge within PHYLIB.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f0b5870a6d40..6ca81395c545 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1066,6 +1066,26 @@ int phy_ethtool_nway_reset(struct net_device *ndev);
 #if IS_ENABLED(CONFIG_PHYLIB)
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
+int phy_ethtool_get_strings(struct phy_device *phydev, u8 *data);
+int phy_ethtool_get_sset_count(struct phy_device *phydev);
+int phy_ethtool_get_stats(struct phy_device *phydev,
+			  struct ethtool_stats *stats, u64 *data);
+#else
+int phy_ethtool_get_strings(struct phy_device *phydev, u8 *data)
+{
+	return -EOPNOTSUPP;
+}
+
+int phy_ethtool_get_sset_count(struct phy_device *phydev)
+{
+	return -EOPNOTSUPP;
+}
+
+int phy_ethtool_get_stats(struct phy_device *phydev,
+			  struct ethtool_stats *stats, u64 *data)
+{
+	return -EOPNOTSUPP;
+}
 #endif
 
 extern struct bus_type mdio_bus_type;

commit 03fe2debbb2771fb90881e4ce8109b09cf772a5c
Merge: 6686c459e144 f36b7534b833
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 23 11:24:57 2018 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Fun set of conflict resolutions here...
    
    For the mac80211 stuff, these were fortunately just parallel
    adds.  Trivially resolved.
    
    In drivers/net/phy/phy.c we had a bug fix in 'net' that moved the
    function phy_disable_interrupts() earlier in the file, whilst in
    'net-next' the phy_error() call from this function was removed.
    
    In net/ipv4/xfrm4_policy.c, David Ahern's changes to remove the
    'rt_table_id' member of rtable collided with a bug fix in 'net' that
    added a new struct member "rt_mtu_locked" which needs to be copied
    over here.
    
    The mlxsw driver conflict consisted of net-next separating
    the span code and definitions into separate files, whilst
    a 'net' bug fix made some changes to that moved code.
    
    The mlx5 infiniband conflict resolution was quite non-trivial,
    the RDMA tree's merge commit was used as a guide here, and
    here are their notes:
    
    ====================
    
        Due to bug fixes found by the syzkaller bot and taken into the for-rc
        branch after development for the 4.17 merge window had already started
        being taken into the for-next branch, there were fairly non-trivial
        merge issues that would need to be resolved between the for-rc branch
        and the for-next branch.  This merge resolves those conflicts and
        provides a unified base upon which ongoing development for 4.17 can
        be based.
    
        Conflicts:
                drivers/infiniband/hw/mlx5/main.c - Commit 42cea83f9524
                (IB/mlx5: Fix cleanup order on unload) added to for-rc and
                commit b5ca15ad7e61 (IB/mlx5: Add proper representors support)
                add as part of the devel cycle both needed to modify the
                init/de-init functions used by mlx5.  To support the new
                representors, the new functions added by the cleanup patch
                needed to be made non-static, and the init/de-init list
                added by the representors patch needed to be modified to
                match the init/de-init list changes made by the cleanup
                patch.
        Updates:
                drivers/infiniband/hw/mlx5/mlx5_ib.h - Update function
                prototypes added by representors patch to reflect new function
                names as changed by cleanup patch
                drivers/infiniband/hw/mlx5/ib_rep.c - Update init/de-init
                stage list to match new order from cleanup patch
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5df7af85ecd88e8b5f1f31d6456c3cf38a8bbdda
Author: Kevin Hao <haokexin@gmail.com>
Date:   Tue Mar 20 09:44:52 2018 +0800

    net: phy: Add general dummy stubs for MMD register access
    
    For some phy devices, even though they don't support the MMD extended
    register access, it does have some side effect if we are trying to
    read/write the MMD registers via indirect method. So introduce general
    dummy stubs for MMD register access which these devices can use to avoid
    such side effect.
    
    Fixes: b6b5e8a69118 ("gianfar: Disable EEE autoneg by default")
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b260fb336b25..7c4c2379e010 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -984,6 +984,10 @@ static inline int genphy_no_soft_reset(struct phy_device *phydev)
 {
 	return 0;
 }
+int genphy_read_mmd_unsupported(struct phy_device *phdev, int devad,
+				u16 regnum);
+int genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,
+				 u16 regnum, u16 val);
 
 /* Clause 45 PHY */
 int genphy_c45_restart_aneg(struct phy_device *phydev);

commit a2c054a896b8ac794ddcfc7c92e2dc7ec4ed4ed5
Author: Brad Mouring <brad.mouring@ni.com>
Date:   Thu Mar 8 16:23:03 2018 -0600

    net: phy: Tell caller result of phy_change()
    
    In 664fcf123a30e (net: phy: Threaded interrupts allow some simplification)
    the phy_interrupt system was changed to use a traditional threaded
    interrupt scheme instead of a workqueue approach.
    
    With this change, the phy status check moved into phy_change, which
    did not report back to the caller whether or not the interrupt was
    handled. This means that, in the case of a shared phy interrupt,
    only the first phydev's interrupt registers are checked (since
    phy_interrupt() would always return IRQ_HANDLED). This leads to
    interrupt storms when it is a secondary device that's actually the
    interrupt source.
    
    Signed-off-by: Brad Mouring <brad.mouring@ni.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d7069539f351..b260fb336b25 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1012,7 +1012,6 @@ int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 int phy_drivers_register(struct phy_driver *new_driver, int n,
 			 struct module *owner);
 void phy_state_machine(struct work_struct *work);
-void phy_change(struct phy_device *phydev);
 void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);

commit 0f3e9c97eb5a97972b0c0076a5cc01bb142f8e70
Merge: ef3f6c256f0b ce380619fab9
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 6 00:53:44 2018 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    All of the conflicts were cases of overlapping changes.
    
    In net/core/devlink.c, we have to make care that the
    resouce size_params have become a struct member rather
    than a pointer to such an object.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e8a714e086e42972fd0e2d59e90c28eb2d839429
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Mar 1 16:08:56 2018 -0800

    net: phy: Export gen10g_* functions
    
    In order to remove a fair amount of duplication in the different 10G PHY
    drivers, export all gen10g_* functions to be able to make use of those.
    While we are at it, rename gen10g_soft_reset() to gen10g_no_soft_reset()
    to illustrate what it does.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5a0c3e53e7c2..6e38c699b753 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -994,6 +994,14 @@ int genphy_c45_pma_setup_forced(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 int genphy_c45_read_mdix(struct phy_device *phydev);
 
+/* The gen10g_* functions are the old Clause 45 stub */
+int gen10g_config_aneg(struct phy_device *phydev);
+int gen10g_read_status(struct phy_device *phydev);
+int gen10g_no_soft_reset(struct phy_device *phydev);
+int gen10g_config_init(struct phy_device *phydev);
+int gen10g_suspend(struct phy_device *phydev);
+int gen10g_resume(struct phy_device *phydev);
+
 static inline int phy_read_status(struct phy_device *phydev)
 {
 	if (!phydev->drv)

commit 9c2c2e62df3fa30fb13fbeb7512a4eede729383b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Feb 27 01:56:06 2018 +0100

    net: phy: Restore phy_resume() locking assumption
    
    commit f5e64032a799 ("net: phy: fix resume handling") changes the
    locking semantics for phy_resume() such that the caller now needs to
    hold the phy mutex. Not all call sites were adopted to this new
    semantic, resulting in warnings from the added
    WARN_ON(!mutex_is_locked(&phydev->lock)).  Rather than change the
    semantics, add a __phy_resume() and restore the old behavior of
    phy_resume().
    
    Reported-by: Heiner Kallweit <hkallweit1@gmail.com>
    Fixes: f5e64032a799 ("net: phy: fix resume handling")
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5a0c3e53e7c2..d7069539f351 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -924,6 +924,7 @@ void phy_device_remove(struct phy_device *phydev);
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);
+int __phy_resume(struct phy_device *phydev);
 int phy_loopback(struct phy_device *phydev, bool enable);
 struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 			      phy_interface_t interface);

commit ac8322d806d15fd53fd5d70ceda61e05163392ee
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Jan 12 21:20:33 2018 +0100

    phy: add helpers for setting/clearing bits in PHY registers
    
    Based on the recent introduction of phy_modify add helpers for setting
    and clearing bits in PHY registers.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 47715a3115b0..5a0c3e53e7c2 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -764,6 +764,55 @@ static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 int phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 
+/**
+ * __phy_set_bits - Convenience function for setting bits in a PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: bits to set
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)
+{
+	return __phy_modify(phydev, regnum, 0, val);
+}
+
+/**
+ * __phy_clear_bits - Convenience function for clearing bits in a PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: bits to clear
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_clear_bits(struct phy_device *phydev, u32 regnum,
+				   u16 val)
+{
+	return __phy_modify(phydev, regnum, val, 0);
+}
+
+/**
+ * phy_set_bits - Convenience function for setting bits in a PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: bits to set
+ */
+static inline int phy_set_bits(struct phy_device *phydev, u32 regnum, u16 val)
+{
+	return phy_modify(phydev, regnum, 0, val);
+}
+
+/**
+ * phy_clear_bits - Convenience function for clearing bits in a PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: bits to clear
+ */
+static inline int phy_clear_bits(struct phy_device *phydev, u32 regnum, u16 val)
+{
+	return phy_modify(phydev, regnum, val, 0);
+}
+
 /**
  * phy_interrupt_is_valid - Convenience function for testing a given PHY irq
  * @phydev: the phy_device struct

commit 28b2e0d2cd132284ad69fcea4b7cf6b7d0662c2f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Jan 10 21:21:31 2018 +0100

    net: phy: remove parameter new_link from phy_mac_interrupt()
    
    I see two issues with parameter new_link:
    
    1. It's not needed. See also phy_interrupt(), works w/o this parameter.
       phy_mac_interrupt sets the state to PHY_CHANGELINK and triggers the
       state machine which then calls phy_read_status. And phy_read_status
       updates the link state.
    
    2. phy_mac_interrupt is used in interrupt context and getting the link
       state may sleep (at least when having to access the PHY registers
       via MDIO bus).
    
    So let's remove it.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 135aba5c3d39..47715a3115b0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -964,7 +964,7 @@ int phy_drivers_register(struct phy_driver *new_driver, int n,
 void phy_state_machine(struct work_struct *work);
 void phy_change(struct phy_device *phydev);
 void phy_change_work(struct work_struct *work);
-void phy_mac_interrupt(struct phy_device *phydev, int new_link);
+void phy_mac_interrupt(struct phy_device *phydev);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
 void phy_trigger_machine(struct phy_device *phydev, bool sync);

commit 2b74e5be17d25fbca4be236a19efcd2ecae81cb2
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Jan 2 10:58:53 2018 +0000

    net: phy: add phy_modify() accessor
    
    Add phy_modify() convenience accessor to complement the mdiobus
    counterpart.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index af1a740dafd4..135aba5c3d39 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -762,6 +762,7 @@ static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 }
 
 int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
+int phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
 
 /**
  * phy_interrupt_is_valid - Convenience function for testing a given PHY irq

commit 78ffc4acceff48522b92d8fbf8f4a0ffe78838b2
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Jan 2 10:58:43 2018 +0000

    net: phy: add paged phy register accessors
    
    Add a set of paged phy register accessors which are inherently safe in
    their design against other accesses interfering with the paged access.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0c5a28520c65..af1a740dafd4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -634,6 +634,9 @@ struct phy_driver {
 	int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,
 			 u16 val);
 
+	int (*read_page)(struct phy_device *dev);
+	int (*write_page)(struct phy_device *dev, int page);
+
 	/* Get the size and type of the eeprom contained within a plug-in
 	 * module */
 	int (*module_info)(struct phy_device *dev,
@@ -838,6 +841,14 @@ static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
  */
 int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 
+int phy_save_page(struct phy_device *phydev);
+int phy_select_page(struct phy_device *phydev, int page);
+int phy_restore_page(struct phy_device *phydev, int oldpage, int ret);
+int phy_read_paged(struct phy_device *phydev, int page, u32 regnum);
+int phy_write_paged(struct phy_device *phydev, int page, u32 regnum, u16 val);
+int phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,
+		     u16 mask, u16 set);
+
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);

commit 788f9933db6172801336d0ae2dec5bdc7525389f
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Jan 2 10:58:37 2018 +0000

    net: phy: add unlocked accessors
    
    Add unlocked versions of the bus accessors, which allows access to the
    bus with all the tracing. These accessors validate that the bus mutex
    is held, which is a basic requirement for all mii bus accesses.
    
    Also added is a read-modify-write unlocked accessor with the same
    locking requirements.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a052e3768422..0c5a28520c65 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -717,6 +717,18 @@ static inline int phy_read(struct phy_device *phydev, u32 regnum)
 	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
 }
 
+/**
+ * __phy_read - convenience function for reading a given PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to read
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_read(struct phy_device *phydev, u32 regnum)
+{
+	return __mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
+}
+
 /**
  * phy_write - Convenience function for writing a given PHY register
  * @phydev: the phy_device struct
@@ -732,6 +744,22 @@ static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
 }
 
+/**
+ * __phy_write - Convenience function for writing a given PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: value to write to @regnum
+ *
+ * The caller must have taken the MDIO bus lock.
+ */
+static inline int __phy_write(struct phy_device *phydev, u32 regnum, u16 val)
+{
+	return __mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum,
+			       val);
+}
+
+int __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set);
+
 /**
  * phy_interrupt_is_valid - Convenience function for testing a given PHY irq
  * @phydev: the phy_device struct

commit 8c5e850c0ce597cf5934beba8b55f7651d2cd6da
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Dec 29 12:46:38 2017 +0000

    net: phy: add helper to convert negotiation result to phy settings
    
    Add a helper to convert the result of the autonegotiation advertisment
    into the PHYs speed and duplex settings.  If the result is full duplex,
    also extract the pause mode settings from the link partner advertisment.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bc379a408c4f..a052e3768422 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -690,6 +690,8 @@ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
 size_t phy_speeds(unsigned int *speeds, size_t size,
 		  unsigned long *mask, size_t maxbit);
 
+void phy_resolve_aneg_linkmode(struct phy_device *phydev);
+
 /**
  * phy_read_mmd - Convenience function for reading a register
  * from an MMD on a given PHY.

commit ea4efe25ec937a7bc1108e26261c9dd4082375af
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Dec 29 12:46:27 2017 +0000

    net: phy: marvell10g: add MDI swap reporting
    
    Add reporting of the MDI swap to the Marvell 10G PHY driver by providing
    a generic implementation for the standard 10GBASE-T pair swap register
    and polarity register.  We also support reading the MDI swap status for
    1G and below from a PCS register.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c4b4715caa21..bc379a408c4f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -901,6 +901,7 @@ int genphy_c45_read_lpa(struct phy_device *phydev);
 int genphy_c45_read_pma(struct phy_device *phydev);
 int genphy_c45_pma_setup_forced(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
+int genphy_c45_read_mdix(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {

commit a96684914adb4adb9f81faf6917e0673b92288d8
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Mon Dec 11 13:16:58 2017 +0100

    phylib: add reset after clk enable support
    
    Some PHYs need the refclk to be a continuous clock. Therefore they don't
    allow turning it off and on again during operation. Nonetheless such a
    clock switching is performed by some ETH drivers (namely FEC [1]) for
    power saving reasons. An example for an affected PHY is the
    SMSC/Microchip LAN8720 in "REF_CLK In Mode".
    
    In order to provide a uniform method to overcome this problem this patch
    adds a new phy_driver flag (PHY_RST_AFTER_CLK_EN) and corresponding
    function phy_reset_after_clk_enable() to the phylib. These should be
    used to trigger reset of the PHY after the refclk is switched on again.
    
    [1] commit e8fcfcd5684a ("net: fec: optimize the clock management to save power")
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d3037e2ffbc4..c4b4715caa21 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -59,6 +59,7 @@
 
 #define PHY_HAS_INTERRUPT	0x00000001
 #define PHY_IS_INTERNAL		0x00000002
+#define PHY_RST_AFTER_CLK_EN	0x00000004
 #define MDIO_DEVICE_IS_PHY	0x80000000
 
 /* Interface Mode definitions */
@@ -853,6 +854,7 @@ int phy_aneg_done(struct phy_device *phydev);
 
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);
+int phy_reset_after_clk_enable(struct phy_device *phydev);
 
 static inline void phy_device_reset(struct phy_device *phydev, int value)
 {

commit bafbdd527d569c8200521f2f7579f65a044271be
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Mon Dec 4 13:35:05 2017 +0100

    phylib: Add device reset GPIO support
    
    The PHY devices sometimes do have their reset signal (maybe even power
    supply?) tied to some GPIO and sometimes it also does happen that a boot
    loader does not leave it deasserted. So far this issue has been attacked
    from (as I believe) a wrong angle: by teaching the MAC driver to manipulate
    the GPIO in question; that solution, when applied to the device trees, led
    to adding the PHY reset GPIO properties to the MAC device node, with one
    exception: Cadence MACB driver which could handle the "reset-gpios" prop
    in a PHY device subnode. I believe that the correct approach is to teach
    the 'phylib' to get the MDIO device reset GPIO from the device tree node
    corresponding to this device -- which this patch is doing...
    
    Note that I had to modify the AT803x PHY driver as it would stop working
    otherwise -- it made use of the reset GPIO for its own purposes...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-by: Rob Herring <robh@kernel.org>
    [geert: Propagate actual errors from fwnode_get_named_gpiod()]
    [geert: Avoid destroying initial setup]
    [geert: Consolidate GPIO descriptor acquiring code]
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7570cb838410..d3037e2ffbc4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -854,6 +854,11 @@ int phy_aneg_done(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);
 
+static inline void phy_device_reset(struct phy_device *phydev, int value)
+{
+	mdio_device_reset(&phydev->mdio, value);
+}
+
 #define phydev_err(_phydev, format, args...)	\
 	dev_err(&_phydev->mdio.dev, format, ##args)
 

commit 365c1e64ad4831f3d1806ff3d7771839ec5eeb6b
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Dec 1 10:24:16 2017 +0000

    phy: add phy_interface_mode_is_8023z() helper
    
    Add and use phy_interface_mode_is_8023z() helper to identify the
    interface modes that use 802.3z negotiation.  Use it in phylink's
    phylink_mac_an_restart().
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 50030da01664..7570cb838410 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -761,6 +761,20 @@ static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
 		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
 };
 
+/**
+ * phy_interface_mode_is_8023z() - does the phy interface mode use 802.3z
+ *   negotiation
+ * @mode: one of &enum phy_interface_t
+ *
+ * Returns true if the phy interface mode uses the 16-bit negotiation
+ * word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)
+ */
+static inline bool phy_interface_mode_is_8023z(phy_interface_t mode)
+{
+	return mode == PHY_INTERFACE_MODE_1000BASEX ||
+	       mode == PHY_INTERFACE_MODE_2500BASEX;
+}
+
 /**
  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
  * is RGMII (all variants)

commit a6d1642dab0c49829cda61508cbdc97172815ff7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Nov 30 23:55:15 2017 +0100

    net: phy: core: remove now uneeded disabling of interrupts
    
    After commits c974bdbc3e "net: phy: Use threaded IRQ, to allow IRQ from
    sleeping devices" and 664fcf123a30 "net: phy: Threaded interrupts allow
    some simplification" all relevant code pieces run in process context
    anyway and I don't think we need the disabling of interrupts any longer.
    
    Interestingly enough, latter commit already removed the comment
    explaining why interrupts need to be temporarily disabled.
    
    On my system phy interrupt mode works fine with this patch.
    However I may miss something, especially in the context of shared phy
    interrupts, therefore I'd appreciate if more people could test this.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4962af37722a..50030da01664 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -468,7 +468,6 @@ struct phy_device {
 	/* Interrupt and Polling infrastructure */
 	struct work_struct phy_queue;
 	struct delayed_work state_queue;
-	atomic_t irq_disable;
 
 	struct mutex lock;
 

commit 00fde79532d66d18cd0b21fdbd515f4b14078ccf
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Nov 30 23:46:19 2017 +0100

    net: phy: core: use genphy version of callbacks read_status and config_aneg per default
    
    read_status and config_aneg are the only mandatory callbacks and most
    of the time the generic implementation is used by drivers.
    So make the core fall back to the generic version if a driver doesn't
    implement the respective callback.
    
    Also currently the core doesn't seem to verify that drivers implement
    the mandatory calls. If a driver doesn't do so we'd just get a NPE.
    With this patch this potential issue doesn't exit any longer.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e00fd9ce3bce..4962af37722a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -497,13 +497,13 @@ struct phy_device {
  * flags: A bitfield defining certain other features this PHY
  *   supports (like interrupts)
  *
- * The drivers must implement config_aneg and read_status.  All
- * other functions are optional. Note that none of these
- * functions should be called from interrupt time.  The goal is
- * for the bus read/write functions to be able to block when the
- * bus transaction is happening, and be freed up by an interrupt
- * (The MPC85xx has this ability, though it is not currently
- * supported in the driver).
+ * All functions are optional. If config_aneg or read_status
+ * are not implemented, the phy core uses the genphy versions.
+ * Note that none of these functions should be called from
+ * interrupt time. The goal is for the bus read/write functions
+ * to be able to block when the bus transaction is happening,
+ * and be freed up by an interrupt (The MPC85xx has this ability,
+ * though it is not currently supported in the driver).
  */
 struct phy_driver {
 	struct mdio_driver_common mdiodrv;
@@ -841,14 +841,6 @@ int phy_aneg_done(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_restart_aneg(struct phy_device *phydev);
 
-static inline int phy_read_status(struct phy_device *phydev)
-{
-	if (!phydev->drv)
-		return -EIO;
-
-	return phydev->drv->read_status(phydev);
-}
-
 #define phydev_err(_phydev, format, args...)	\
 	dev_err(&_phydev->mdio.dev, format, ##args)
 
@@ -890,6 +882,17 @@ int genphy_c45_read_pma(struct phy_device *phydev);
 int genphy_c45_pma_setup_forced(struct phy_device *phydev);
 int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 
+static inline int phy_read_status(struct phy_device *phydev)
+{
+	if (!phydev->drv)
+		return -EIO;
+
+	if (phydev->drv->read_status)
+		return phydev->drv->read_status(phydev);
+	else
+		return genphy_read_status(phydev);
+}
+
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver, struct module *owner);

commit 511e3036e3c108281edbabf60cf43963c336abf3
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Mon Nov 27 08:16:45 2017 +0100

    net: phy: harmonize phy_id{,_mask} data type
    
    Previously phy_id was u32 and phy_id_mask was unsigned int. As the
    phy_id_mask defines the important bits of the phy_id (and is therefore
    the same size) these two variables should be the same data type.
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index dc82a07cb4fd..e00fd9ce3bce 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -509,7 +509,7 @@ struct phy_driver {
 	struct mdio_driver_common mdiodrv;
 	u32 phy_id;
 	char *name;
-	unsigned int phy_id_mask;
+	u32 phy_id_mask;
 	u32 features;
 	u32 flags;
 	const void *driver_data;

commit 3928ee6485a316c8abde7e24c7f82033a1c8d3ae
Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
Date:   Thu Nov 2 00:49:18 2017 +0100

    net: phy: leds: Add support for "link" trigger
    
    Currently, we create a LED trigger for any link speed known to a PHY.
    These triggers only fire when their exact link speed had been negotiated
    (they aren't cumulative, that is, they don't fire for "their or any higher"
    link speed).
    
    What we are missing, however, is a trigger which will fire on any link
    speed known to the PHY. Such trigger can then be used for implementing a
    poor man's substitute of the "link" LED on boards that lack it.
    Let's add it.
    
    Signed-off-by: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d78cd01ea513..dc82a07cb4fd 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -451,6 +451,8 @@ struct phy_device {
 	struct phy_led_trigger *phy_led_triggers;
 	unsigned int phy_num_led_triggers;
 	struct phy_led_trigger *last_triggered;
+
+	struct phy_led_trigger *led_link_trigger;
 #endif
 
 	/*

commit 9525ae83959b60c6061fe2f2caabdc8f69a48bc6
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 25 15:03:13 2017 +0100

    phylink: add phylink infrastructure
    
    The link between the ethernet MAC and its PHY has become more complex
    as the interface evolves.  This is especially true with serdes links,
    where the part of the PHY is effectively integrated into the MAC.
    
    Serdes links can be connected to a variety of devices, including SFF
    modules soldered down onto the board with the MAC, a SFP cage with
    a hotpluggable SFP module which may contain a PHY or directly modulate
    the serdes signals onto optical media with or without a PHY, or even
    a classical PHY connection.
    
    Moreover, the negotiation information on serdes links comes in two
    varieties - SGMII mode, where the PHY provides its speed/duplex/flow
    control information to the MAC, and 1000base-X mode where both ends
    exchange their abilities and each resolve the link capabilities.
    
    This means we need a more flexible means to support these arrangements,
    particularly with the hotpluggable nature of SFP, where the PHY can
    be attached or detached after the network device has been brought up.
    
    Ethtool information can come from multiple sources:
    - we may have a PHY operating in either SGMII or 1000base-X mode, in
      which case we take ethtool/mii data directly from the PHY.
    - we may have a optical SFP module without a PHY, with the MAC
      operating in 1000base-X mode - the ethtool/mii data needs to come
      from the MAC.
    - we may have a copper SFP module with a PHY whic can't be accessed,
      which means we need to take ethtool/mii data from the MAC.
    
    Phylink aims to solve this by providing an intermediary between the
    MAC and PHY, providing a safe way for PHYs to be hotplugged, and
    allowing a SFP driver to reconfigure the serdes connection.
    
    Phylink also takes over support of fixed link connections, where the
    speed/duplex/flow control are fixed, but link status may be controlled
    by a GPIO signal.  By avoiding the fixed-phy implementation, phylink
    can provide a faster response to link events: fixed-phy has to wait for
    phylib to operate its state machine, which can take several seconds.
    In comparison, phylink takes milliseconds.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    
    - remove sync status
    - rework supported and advertisment handling
    - add 1000base-x speed for fixed links
    - use functionality exported from phy-core, reworking
      __phylink_ethtool_ksettings_set for it
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0a5e8e62c9e0..d78cd01ea513 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -182,6 +182,7 @@ static inline const char *phy_modes(phy_interface_t interface)
 #define MII_ADDR_C45 (1<<30)
 
 struct device;
+struct phylink;
 struct sk_buff;
 
 /*
@@ -469,6 +470,7 @@ struct phy_device {
 
 	struct mutex lock;
 
+	struct phylink *phylink;
 	struct net_device *attached_dev;
 
 	u8 mdix;

commit a81497bee70eb15039594b3116913133aa9c9b29
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 25 15:02:58 2017 +0100

    net: phy: provide a hook for link up/link down events
    
    Sometimes, we need to do additional work between the PHY coming up and
    marking the carrier present - for example, we may need to wait for the
    PHY to MAC link to finish negotiation.  This changes phylib to provide
    a notification function pointer which avoids the built-in
    netif_carrier_on() and netif_carrier_off() functions.
    
    Standard ->adjust_link functionality is provided by hooking a helper
    into the new ->phy_link_change method.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8a280257778c..0a5e8e62c9e0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -474,6 +474,7 @@ struct phy_device {
 	u8 mdix;
 	u8 mdix_ctrl;
 
+	void (*phy_link_change)(struct phy_device *, bool up, bool do_carrier);
 	void (*adjust_link)(struct net_device *dev);
 };
 #define to_phy_device(d) container_of(to_mdio_device(d), \

commit 0ccb4fc65d2799a315d5ee8732d75f35a114379c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Jul 25 15:02:47 2017 +0100

    net: phy: move phy_lookup_setting() and guts of phy_supported_speeds() to phy-core
    
    phy_lookup_setting() provides useful functionality in ethtool code
    outside phylib.  Move it to phy-core and allow it to be re-used (eg,
    in phylink) rather than duplicated elsewhere.  Note that this supports
    the larger linkmode space.
    
    As we move the phy settings table, we also need to move the guts of
    phy_supported_speeds() as well.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e8264c78b75b..8a280257778c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -670,6 +670,21 @@ struct phy_fixup {
 const char *phy_speed_to_str(int speed);
 const char *phy_duplex_to_str(unsigned int duplex);
 
+/* A structure for mapping a particular speed and duplex
+ * combination to a particular SUPPORTED and ADVERTISED value
+ */
+struct phy_setting {
+	u32 speed;
+	u8 duplex;
+	u8 bit;
+};
+
+const struct phy_setting *
+phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
+		   size_t maxbit, bool exact);
+size_t phy_speeds(unsigned int *speeds, size_t size,
+		  unsigned long *mask, size_t maxbit);
+
 /**
  * phy_read_mmd - Convenience function for reading a register
  * from an MMD on a given PHY.

commit da4625ac2637e4e5249dc08a10f8dce7643603d2
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Jul 25 15:02:42 2017 +0100

    net: phy: split out PHY speed and duplex string generation
    
    Other code would like to make use of this, so make the speed and duplex
    string generation visible, and place it in a separate file.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 0bb5b212ab42..e8264c78b75b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -667,6 +667,9 @@ struct phy_fixup {
 	int (*run)(struct phy_device *phydev);
 };
 
+const char *phy_speed_to_str(int speed);
+const char *phy_duplex_to_str(unsigned int duplex);
+
 /**
  * phy_read_mmd - Convenience function for reading a register
  * from an MMD on a given PHY.

commit 2eaa38d9fcba5294182268b8d11770cf3fdc9bc9
Author: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
Date:   Tue Jul 25 11:08:15 2017 +0200

    net: phy: Remove trailing semicolon in macro definition
    
    Commit e5a03bfd873c2 ("phy: Add an mdio_device structure")
    introduced a spurious trailing semicolon. Remove it.
    
    Signed-off-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2a9567bb8186..0bb5b212ab42 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -830,7 +830,7 @@ static inline int phy_read_status(struct phy_device *phydev)
 	dev_err(&_phydev->mdio.dev, format, ##args)
 
 #define phydev_dbg(_phydev, format, args...)	\
-	dev_dbg(&_phydev->mdio.dev, format, ##args);
+	dev_dbg(&_phydev->mdio.dev, format, ##args)
 
 static inline const char *phydev_name(const struct phy_device *phydev)
 {

commit f0f9b4ed23381d97cde2ac64248198bc43608e6d
Author: Lin Yun Sheng <linyunsheng@huawei.com>
Date:   Fri Jun 30 17:44:15 2017 +0800

    net: phy: Add phy loopback support in net phy framework
    
    This patch add set_loopback in phy_driver, which is used by MAC
    driver to enable or disable phy loopback. it also add a generic
    genphy_loopback function, which use BMCR loopback bit to enable
    or disable loopback.
    
    Signed-off-by: Lin Yun Sheng <linyunsheng@huawei.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1d8d70193782..2a9567bb8186 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -372,6 +372,7 @@ struct phy_c45_device_ids {
  * has_fixups: Set to true if this phy has fixups/quirks.
  * suspended: Set to true if this phy has been suspended successfully.
  * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
+ * loopback_enabled: Set true if this phy has been loopbacked successfully.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * link_timeout: The number of timer firings to wait before the
@@ -409,6 +410,7 @@ struct phy_device {
 	bool has_fixups;
 	bool suspended;
 	bool sysfs_links;
+	bool loopback_enabled;
 
 	enum phy_state state;
 
@@ -648,6 +650,7 @@ struct phy_driver {
 	int (*set_tunable)(struct phy_device *dev,
 			    struct ethtool_tunable *tuna,
 			    const void *data);
+	int (*set_loopback)(struct phy_device *dev, bool enable);
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)
@@ -793,6 +796,7 @@ void phy_device_remove(struct phy_device *phydev);
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);
+int phy_loopback(struct phy_device *phydev, bool enable);
 struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 			      phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
@@ -847,6 +851,7 @@ int genphy_update_link(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
+int genphy_loopback(struct phy_device *phydev, bool enable);
 int genphy_soft_reset(struct phy_device *phydev);
 static inline int genphy_no_soft_reset(struct phy_device *phydev)
 {

commit 735d8a18433e8d953e4e2b92883bfcc566e382c2
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 23 10:33:14 2017 -0700

    net: phy: Support "internal" PHY interface
    
    Now that the Device Tree binding has been updated, update the PHY
    library phy_interface_t and phy_modes to support the "internal" PHY
    interface type.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 23d2e46dd322..1d8d70193782 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -64,6 +64,7 @@
 /* Interface Mode definitions */
 typedef enum {
 	PHY_INTERFACE_MODE_NA,
+	PHY_INTERFACE_MODE_INTERNAL,
 	PHY_INTERFACE_MODE_MII,
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
@@ -114,6 +115,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 	switch (interface) {
 	case PHY_INTERFACE_MODE_NA:
 		return "";
+	case PHY_INTERFACE_MODE_INTERNAL:
+		return "internal";
 	case PHY_INTERFACE_MODE_MII:
 		return "mii";
 	case PHY_INTERFACE_MODE_GMII:

commit 5514174fe9c61c83bd8781c1e048ea6b4bf16a14
Author: yuval.shaia@oracle.com <yuval.shaia@oracle.com>
Date:   Tue Jun 13 10:09:46 2017 +0300

    net: phy: Make phy_ethtool_ksettings_get return void
    
    Make return value void since function never return meaningfull value
    
    Signed-off-by: Yuval Shaia <yuval.shaia@oracle.com>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 51bea6593409..23d2e46dd322 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -872,8 +872,8 @@ void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
 void phy_trigger_machine(struct phy_device *phydev, bool sync);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
-int phy_ethtool_ksettings_get(struct phy_device *phydev,
-			      struct ethtool_link_ksettings *cmd);
+void phy_ethtool_ksettings_get(struct phy_device *phydev,
+			       struct ethtool_link_ksettings *cmd);
 int phy_ethtool_ksettings_set(struct phy_device *phydev,
 			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);

commit d396e84c56047b303cac378dde4b2e5cc430b336
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Mon Jun 12 23:55:38 2017 +0300

    mdio_bus: handle only single PHY reset GPIO
    
    Commit 4c5e7a2c0501 ("dt-bindings: mdio: Clarify binding document")
    declared that a MDIO reset GPIO property should have only a single GPIO
    reference/specifier, however the supporting code was left intact, still
    burdening the kernel with now apparently useless loops -- get rid of them.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 414242200a90..51bea6593409 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -226,10 +226,8 @@ struct mii_bus {
 
 	/* GPIO reset pulse width in microseconds */
 	int reset_delay_us;
-	/* Number of reset GPIOs */
-	int num_reset_gpios;
-	/* Array of RESET GPIO descriptors */
-	struct gpio_desc **reset_gpiod;
+	/* RESET GPIO descriptor pointer */
+	struct gpio_desc *reset_gpiod;
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 

commit c125ca091873f2e848cc31c2371a3a66c2fd4dd8
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon Jun 5 12:23:10 2017 +0100

    net: phy: add XAUI and 10GBASE-KR PHY connection types
    
    XAUI allows XGMII to reach an extended distance by using a XGXS layer at
    each end of the MAC to PHY link, operating over four Serdes lanes.
    
    10GBASE-KR is a single lane Serdes backplane ethernet connection method
    with autonegotiation on the link.  Some PHYs use this to connect to the
    ethernet interface at 10G speeds, switching to other connection types
    when utilising slower speeds.
    
    10GBASE-KR is also used for XFI and SFI to connect to XFP and SFP fiber
    modules.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b24de9ddc886..414242200a90 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -83,6 +83,9 @@ typedef enum {
 	PHY_INTERFACE_MODE_1000BASEX,
 	PHY_INTERFACE_MODE_2500BASEX,
 	PHY_INTERFACE_MODE_RXAUI,
+	PHY_INTERFACE_MODE_XAUI,
+	/* 10GBASE-KR, XFI, SFI - single lane 10G Serdes */
+	PHY_INTERFACE_MODE_10GKR,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -149,6 +152,10 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "2500base-x";
 	case PHY_INTERFACE_MODE_RXAUI:
 		return "rxaui";
+	case PHY_INTERFACE_MODE_XAUI:
+		return "xaui";
+	case PHY_INTERFACE_MODE_10GKR:
+		return "10gbase-kr";
 	default:
 		return "unknown";
 	}

commit 002ba7058a7f141cf22d37967a4ef78239c50e9e
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon Jun 5 12:23:00 2017 +0100

    net: phy: hook up clause 45 autonegotiation restart
    
    genphy_restart_aneg() can only restart autonegotiation on clause 22
    PHYs.  Add a phy_restart_aneg() function which selects between the
    clause 22 and clause 45 restart functionality depending on the PHY
    type and whether the Clause 45 PHY supports the Clause 22 register set.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a47eb5e841d2..b24de9ddc886 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -804,6 +804,7 @@ int phy_start_aneg(struct phy_device *phydev);
 int phy_aneg_done(struct phy_device *phydev);
 
 int phy_stop_interrupts(struct phy_device *phydev);
+int phy_restart_aneg(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {

commit 5acde34a5a420ffe7441bb7d3909dc2618025c3c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon Jun 5 12:22:50 2017 +0100

    net: phy: add 802.3 clause 45 support to phylib
    
    Add generic helpers for 802.3 clause 45 PHYs for >= 10Gbps support.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 748e526c0698..a47eb5e841d2 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -827,6 +827,8 @@ static inline const char *phydev_name(const struct phy_device *phydev)
 void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
 	__printf(2, 3);
 void phy_attached_info(struct phy_device *phydev);
+
+/* Clause 22 PHY */
 int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
@@ -841,6 +843,16 @@ static inline int genphy_no_soft_reset(struct phy_device *phydev)
 {
 	return 0;
 }
+
+/* Clause 45 PHY */
+int genphy_c45_restart_aneg(struct phy_device *phydev);
+int genphy_c45_aneg_done(struct phy_device *phydev);
+int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask);
+int genphy_c45_read_lpa(struct phy_device *phydev);
+int genphy_c45_read_pma(struct phy_device *phydev);
+int genphy_c45_pma_setup_forced(struct phy_device *phydev);
+int genphy_c45_an_disable_aneg(struct phy_device *phydev);
+
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver, struct module *owner);

commit f8fe99754673719ab791713a676bf27dae616fbc
Author: yuval.shaia@oracle.com <yuval.shaia@oracle.com>
Date:   Mon Jun 5 10:18:40 2017 +0300

    net: phy: Delete unused function phy_ethtool_gset
    
    It's unused, so remove it.
    
    Signed-off-by: Yuval Shaia <yuval.shaia@oracle.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 58f1b45a4c44..748e526c0698 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -854,7 +854,6 @@ void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
 void phy_trigger_machine(struct phy_device *phydev, bool sync);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
-int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_ksettings_get(struct phy_device *phydev,
 			      struct ethtool_link_ksettings *cmd);
 int phy_ethtool_ksettings_set(struct phy_device *phydev,

commit a3995460491d4570af8e99ad34ddf6d1948254d9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat May 27 10:42:25 2017 -0700

    net: phy: Relax error checking on sysfs_create_link()
    
    Some Ethernet drivers will attach/connect to a PHY device before calling
    register_netdevice() which is responsible for calling netdev_register_kobject()
    which would do the network device's kobject initialization. In such a case,
    sysfs_create_link() would return -ENOENT because the network device's kobject
    is not ready yet, and we would fail to connect to the PHY device.
    
    In order to keep things simple and symetrical, we just take the success path as
    indicative of the ability to access the network device's kobject, and create
    the second link if that's the case.
    
    Fixes: 5568363f0cb3 ("net: phy: Create sysfs reciprocal links for attached_dev/phydev")
    Reported-by: Woojung Hung <Woojung.Huh@microchip.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5a808a26e4cf..58f1b45a4c44 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -363,6 +363,7 @@ struct phy_c45_device_ids {
  * is_pseudo_fixed_link: Set to true if this phy is an Ethernet switch, etc.
  * has_fixups: Set to true if this phy has fixups/quirks.
  * suspended: Set to true if this phy has been suspended successfully.
+ * sysfs_links: Internal boolean tracking sysfs symbolic links setup/removal.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * link_timeout: The number of timer firings to wait before the
@@ -399,6 +400,7 @@ struct phy_device {
 	bool is_pseudo_fixed_link;
 	bool has_fixups;
 	bool suspended;
+	bool sysfs_links;
 
 	enum phy_state state;
 

commit 32d0f7830d9be5b1652a718e050d808b4908155f
Author: Iyappan Subramanian <isubramanian@apm.com>
Date:   Thu May 18 15:13:43 2017 -0700

    phy: Add helper function to check phy interface mode
    
    Added helper function that checks phy_mode is RGMII (all variants)
    'bool phy_interface_mode_is_rgmii(phy_interface_t mode)'
    
    Changed the following function, to use the above.
    'bool phy_interface_is_rgmii(struct phy_device *phydev)'
    
    Signed-off-by: Iyappan Subramanian <isubramanian@apm.com>
    Suggested-by: Florian Fainelli <f.fainelli@gmail.com>
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 54ef45823fc1..5a808a26e4cf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -715,6 +715,17 @@ static inline bool phy_is_internal(struct phy_device *phydev)
 	return phydev->is_internal;
 }
 
+/**
+ * phy_interface_mode_is_rgmii - Convenience function for testing if a
+ * PHY interface mode is RGMII (all variants)
+ * @mode: the phy_interface_t enum
+ */
+static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
+{
+	return mode >= PHY_INTERFACE_MODE_RGMII &&
+		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
+};
+
 /**
  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
  * is RGMII (all variants)
@@ -722,8 +733,7 @@ static inline bool phy_is_internal(struct phy_device *phydev)
  */
 static inline bool phy_interface_is_rgmii(struct phy_device *phydev)
 {
-	return phydev->interface >= PHY_INTERFACE_MODE_RGMII &&
-		phydev->interface <= PHY_INTERFACE_MODE_RGMII_TXID;
+	return phy_interface_mode_is_rgmii(phydev->interface);
 };
 
 /*

commit 1b86f702f80de32d555519e2c4c61385faeab710
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue May 16 18:29:11 2017 +0200

    net: phy: Remove residual magic from PHY drivers
    
    commit fa8cddaf903c ("net phylib: Remove unnecessary condition check in phy")
    removed the only place where the PHY flag PHY_HAS_MAGICANEG was
    checked. But it left the flag being set in the drivers. Remove the flag.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e76e4adbc7c7..54ef45823fc1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -58,8 +58,7 @@
 #define PHY_IGNORE_INTERRUPT	-2
 
 #define PHY_HAS_INTERRUPT	0x00000001
-#define PHY_HAS_MAGICANEG	0x00000002
-#define PHY_IS_INTERNAL		0x00000004
+#define PHY_IS_INTERNAL		0x00000002
 #define MDIO_DEVICE_IS_PHY	0x80000000
 
 /* Interface Mode definitions */

commit b1513c35317c106a1588f3ab32f6888f0e2afd71
Merge: 78a57b482aa5 f83246089ca0
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Apr 26 22:39:08 2017 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f555f34fdc586a56204cd16d9a7c104ec6cb6650
Author: Alexander Kochetkov <al.kochet@gmail.com>
Date:   Thu Apr 20 14:00:04 2017 +0300

    net: phy: fix auto-negotiation stall due to unavailable interrupt
    
    The Ethernet link on an interrupt driven PHY was not coming up if the Ethernet
    cable was plugged before the Ethernet interface was brought up.
    
    The patch trigger PHY state machine to update link state if PHY was requested to
    do auto-negotiation and auto-negotiation complete flag already set.
    
    During power-up cycle the PHY do auto-negotiation, generate interrupt and set
    auto-negotiation complete flag. Interrupt is handled by PHY state machine but
    doesn't update link state because PHY is in PHY_READY state. After some time
    MAC bring up, start and request PHY to do auto-negotiation. If there are no new
    settings to advertise genphy_config_aneg() doesn't start PHY auto-negotiation.
    PHY continue to stay in auto-negotiation complete state and doesn't fire
    interrupt. At the same time PHY state machine expect that PHY started
    auto-negotiation and is waiting for interrupt from PHY and it won't get it.
    
    Fixes: 321beec5047a ("net: phy: Use interrupts when available in NOLINK state")
    Signed-off-by: Alexander Kochetkov <al.kochet@gmail.com>
    Cc: stable <stable@vger.kernel.org> # v4.9+
    Tested-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 43a774873aa9..fb3857337151 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -852,6 +852,7 @@ void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev, int new_link);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
+void phy_trigger_machine(struct phy_device *phydev, bool sync);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_ksettings_get(struct phy_device *phydev,

commit 69226896ad636b94f6d2e55d75ff21a29c4de83b
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Apr 21 16:15:38 2017 +0300

    mdio_bus: Issue GPIO RESET to PHYs.
    
    Some boards [1] leave the PHYs at an invalid state
    during system power-up or reset thus causing unreliability
    issues with the PHY which manifests as PHY not being detected
    or link not functional. To fix this, these PHYs need to be RESET
    via a GPIO connected to the PHY's RESET pin.
    
    Some boards have a single GPIO controlling the PHY RESET pin of all
    PHYs on the bus whereas some others have separate GPIOs controlling
    individual PHY RESETs.
    
    In both cases, the RESET de-assertion cannot be done in the PHY driver
    as the PHY will not probe till its reset is de-asserted.
    So do the RESET de-assertion in the MDIO bus driver.
    
    [1] - am572x-idk, am571x-idk, a437x-idk
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 624cecf69c28..37ca77d86983 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -217,6 +217,13 @@ struct mii_bus {
 	 * matching its address
 	 */
 	int irq[PHY_MAX_ADDR];
+
+	/* GPIO reset pulse width in microseconds */
+	int reset_delay_us;
+	/* Number of reset GPIOs */
+	int num_reset_gpios;
+	/* Array of RESET GPIO descriptors */
+	struct gpio_desc **reset_gpiod;
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 

commit 90eff9096c01ba90cdae504a6b95ee87fe2556a3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Mar 23 10:01:19 2017 -0700

    net: phy: Allow splitting MDIO bus/device support from PHYs
    
    Introduce a new configuration symbol: MDIO_DEVICE which allows building
    the MDIO devices and bus code, without pulling in the entire Ethernet
    PHY library and devices code.
    
    PHYLIB nows select MDIO_DEVICE and the relevant Makefile files are
    updated to reflect that.
    
    When MDIO_DEVICE (MDIO bus/device only) is selected, but not PHYLIB, we
    have mdio-bus.ko as a loadable module, and it does not have a
    module_exit() function because the safety of removing a bus class is
    unclear.
    
    When both MDIO_DEVICE and PHYLIB are enabled, we need to assemble
    everything into a common loadable module: libphy.ko because of nasty
    circular dependencies between phy.c, phy_device.c and mdio_bus.c which
    are really tough to untangle.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2efca6b39fba..624cecf69c28 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -745,8 +745,24 @@ int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);
+#if IS_ENABLED(CONFIG_PHYLIB)
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
+void phy_device_free(struct phy_device *phydev);
+#else
+static inline
+struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
+{
+	return NULL;
+}
+
+static inline int phy_device_register(struct phy_device *phy)
+{
+	return 0;
+}
+
+static inline void phy_device_free(struct phy_device *phydev) { }
+#endif /* CONFIG_PHYLIB */
 void phy_device_remove(struct phy_device *phydev);
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
@@ -827,7 +843,6 @@ int phy_ethtool_ksettings_set(struct phy_device *phydev,
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
-void phy_device_free(struct phy_device *phydev);
 int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
@@ -854,8 +869,10 @@ int phy_ethtool_set_link_ksettings(struct net_device *ndev,
 				   const struct ethtool_link_ksettings *cmd);
 int phy_ethtool_nway_reset(struct net_device *ndev);
 
+#if IS_ENABLED(CONFIG_PHYLIB)
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
+#endif
 
 extern struct bus_type mdio_bus_type;
 
@@ -866,7 +883,7 @@ struct mdio_board_info {
 	const void	*platform_data;
 };
 
-#if IS_ENABLED(CONFIG_PHYLIB)
+#if IS_ENABLED(CONFIG_MDIO_DEVICE)
 int mdiobus_register_board_info(const struct mdio_board_info *info,
 				unsigned int n);
 #else

commit 3b85d8df2655a4a5831ee8233108b53e69efa1ed
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Mar 21 16:37:03 2017 +0000

    net: phy: remove the indirect MMD read/write methods
    
    Remove the indirect MMD read/write methods which are now no longer
    necessary.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b8feeffeb64c..2efca6b39fba 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -611,24 +611,6 @@ struct phy_driver {
 	int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,
 			 u16 val);
 
-	/* A function provided by a phy specific driver to override the
-	 * the PHY driver framework support for reading a MMD register
-	 * from the PHY. If not supported, return -1. This function is
-	 * optional for PHY specific drivers, if not provided then the
-	 * default MMD read function is used by the PHY framework.
-	 */
-	int (*read_mmd_indirect)(struct phy_device *dev, int ptrad,
-				 int devnum, int regnum);
-
-	/* A function provided by a phy specific driver to override the
-	 * the PHY driver framework support for writing a MMD register
-	 * from the PHY. This function is optional for PHY specific drivers,
-	 * if not provided then the default MMD read function is used by
-	 * the PHY framework.
-	 */
-	void (*write_mmd_indirect)(struct phy_device *dev, int ptrad,
-				   int devnum, int regnum, u32 val);
-
 	/* Get the size and type of the eeprom contained within a plug-in
 	 * module */
 	int (*module_info)(struct phy_device *dev,
@@ -677,17 +659,6 @@ struct phy_fixup {
  */
 int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
 
-/**
- * phy_read_mmd_indirect - reads data from the MMD registers
- * @phydev: The PHY device bus
- * @prtad: MMD Address
- * @addr: PHY address on the MII bus
- *
- * Description: it reads data from the MMD registers (clause 22 to access to
- * clause 45) of the specified phy address.
- */
-int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad);
-
 /**
  * phy_read - Convenience function for reading a given PHY register
  * @phydev: the phy_device struct
@@ -771,19 +742,6 @@ static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
  */
 int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 
-/**
- * phy_write_mmd_indirect - writes data to the MMD registers
- * @phydev: The PHY device
- * @prtad: MMD Address
- * @devad: MMD DEVAD
- * @data: data to write in the MMD register
- *
- * Description: Write data from the MMD registers of the specified
- * phy address.
- */
-void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
-			    int devad, u32 data);
-
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);

commit 1ee6b9bc6206cd0837bc16e46f580e40fe663384
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Mar 21 16:36:43 2017 +0000

    net: phy: make phy_(read|write)_mmd() generic MMD accessors
    
    Make phy_(read|write)_mmd() generic 802.3 clause 45 register accessors
    for both Clause 22 and Clause 45 PHYs, using either the direct register
    reading for Clause 45, or the indirect method for Clause 22 PHYs.
    Allow this behaviour to be overriden by PHY drivers where necessary.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bcb4549b41d6..b8feeffeb64c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -587,6 +587,30 @@ struct phy_driver {
 	 */
 	void (*link_change_notify)(struct phy_device *dev);
 
+	/*
+	 * Phy specific driver override for reading a MMD register.
+	 * This function is optional for PHY specific drivers.  When
+	 * not provided, the default MMD read function will be used
+	 * by phy_read_mmd(), which will use either a direct read for
+	 * Clause 45 PHYs or an indirect read for Clause 22 PHYs.
+	 *  devnum is the MMD device number within the PHY device,
+	 *  regnum is the register within the selected MMD device.
+	 */
+	int (*read_mmd)(struct phy_device *dev, int devnum, u16 regnum);
+
+	/*
+	 * Phy specific driver override for writing a MMD register.
+	 * This function is optional for PHY specific drivers.  When
+	 * not provided, the default MMD write function will be used
+	 * by phy_write_mmd(), which will use either a direct write for
+	 * Clause 45 PHYs, or an indirect write for Clause 22 PHYs.
+	 *  devnum is the MMD device number within the PHY device,
+	 *  regnum is the register within the selected MMD device.
+	 *  val is the value to be written.
+	 */
+	int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,
+			 u16 val);
+
 	/* A function provided by a phy specific driver to override the
 	 * the PHY driver framework support for reading a MMD register
 	 * from the PHY. If not supported, return -1. This function is

commit 9860118b58241169f67ba77dfeb935fcf53ce4cd
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Mar 21 16:36:37 2017 +0000

    net: phy: move phy MMD accessors to phy-core.c
    
    Move the phy_(read|write)__mmd() helpers out of line, they will become
    our main MMD accessor functions, and so will be a little more complex.
    This complexity doesn't belong in an inline function.  Also move the
    _indirect variants as well to keep like functionality together.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 43a774873aa9..bcb4549b41d6 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -651,14 +651,7 @@ struct phy_fixup {
  *
  * Same rules as for phy_read();
  */
-static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
-{
-	if (!phydev->is_c45)
-		return -EOPNOTSUPP;
-
-	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr,
-			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
-}
+int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
 
 /**
  * phy_read_mmd_indirect - reads data from the MMD registers
@@ -752,16 +745,7 @@ static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
  *
  * Same rules as for phy_write();
  */
-static inline int phy_write_mmd(struct phy_device *phydev, int devad,
-				u32 regnum, u16 val)
-{
-	if (!phydev->is_c45)
-		return -EOPNOTSUPP;
-
-	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
-
-	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
-}
+int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 
 /**
  * phy_write_mmd_indirect - writes data to the MMD registers

commit 0878fff1f42c18e448ab5b8b4f6a3eb32365b5b6
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Mar 5 12:34:49 2017 -0800

    net: phy: Do not perform software reset for Generic PHY
    
    The Generic PHY driver is a catch-all PHY driver and it should preserve
    whatever prior initialization has been done by boot loader or firmware
    agents. For specific PHY device configuration it is expected that a
    specialized PHY driver would take over that role.
    
    Resetting the generic PHY was a bad idea that has lead to several
    complaints and downstream workarounds e.g: in OpenWrt/LEDE so restore
    the behavior prior to 87aa9f9c61ad ("net: phy: consolidate PHY
    reset in phy_init_hw()").
    
    Reported-by: Felix Fietkau <nbd@nbd.name>
    Fixes: 87aa9f9c61ad ("net: phy: consolidate PHY reset in phy_init_hw()")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 772476028a65..43a774873aa9 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -837,6 +837,10 @@ int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
 int genphy_soft_reset(struct phy_device *phydev);
+static inline int genphy_no_soft_reset(struct phy_device *phydev)
+{
+	return 0;
+}
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver, struct module *owner);

commit 25149ef9d25cafc4f4fe9f4461f18f876f397417
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Feb 17 16:07:34 2017 -0800

    net: phy: Check phydev->drv
    
    There are number of function calls, originating from user-space,
    typically through the Ethernet driver that can make us crash by
    dereferencing phydev->drv which will be NULL once we unbind the driver
    from the PHY.
    
    There are still functional issues that prevent an unbind then rebind to
    work, but these will be addressed separately.
    
    Suggested-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d9bdf53e0514..772476028a65 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -807,6 +807,9 @@ int phy_stop_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {
+	if (!phydev->drv)
+		return -EIO;
+
 	return phydev->drv->read_status(phydev);
 }
 

commit 648ea0134069cda7d4940f397bcc6901fb88752a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Feb 4 13:02:44 2017 -0800

    net: phy: Allow pre-declaration of MDIO devices
    
    Allow board support code to collect pre-declarations for MDIO devices by
    registering them with mdiobus_register_board_info(). SPI and I2C buses
    have a similar feature, we were missing this for MDIO devices, but this
    is particularly useful for e.g: MDIO-connected switches which need to
    provide their port layout (often board-specific) to a MDIO Ethernet
    switch driver.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 28ae9eafec19..d9bdf53e0514 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -886,6 +886,25 @@ void mdio_bus_exit(void);
 
 extern struct bus_type mdio_bus_type;
 
+struct mdio_board_info {
+	const char	*bus_id;
+	char		modalias[MDIO_NAME_SIZE];
+	int		mdio_addr;
+	const void	*platform_data;
+};
+
+#if IS_ENABLED(CONFIG_PHYLIB)
+int mdiobus_register_board_info(const struct mdio_board_info *info,
+				unsigned int n);
+#else
+static inline int mdiobus_register_board_info(const struct mdio_board_info *i,
+					      unsigned int n)
+{
+	return 0;
+}
+#endif
+
+
 /**
  * module_phy_driver() - Helper macro for registering PHY drivers
  * @__phy_drivers: array of PHY drivers to register

commit 55601a880690cdeccdb5923c2493f0e3736f8f6b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Feb 4 20:02:49 2017 +0100

    net: phy: Add 2000base-x, 2500base-x and rxaui modes
    
    The mv88e6390 ports 9 and 10 supports some additional PHY modes. Add
    these modes to the PHY core so they can be used in the binding.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 43474f39ef65..28ae9eafec19 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -81,6 +81,9 @@ typedef enum {
 	PHY_INTERFACE_MODE_MOCA,
 	PHY_INTERFACE_MODE_QSGMII,
 	PHY_INTERFACE_MODE_TRGMII,
+	PHY_INTERFACE_MODE_1000BASEX,
+	PHY_INTERFACE_MODE_2500BASEX,
+	PHY_INTERFACE_MODE_RXAUI,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -141,6 +144,12 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "qsgmii";
 	case PHY_INTERFACE_MODE_TRGMII:
 		return "trgmii";
+	case PHY_INTERFACE_MODE_1000BASEX:
+		return "1000base-x";
+	case PHY_INTERFACE_MODE_2500BASEX:
+		return "2500base-x";
+	case PHY_INTERFACE_MODE_RXAUI:
+		return "rxaui";
 	default:
 		return "unknown";
 	}

commit 4e8f2fc1a55d543717efb70e170b09e773d0542b
Merge: 158f323b9868 1b1bc42c1692
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Jan 28 10:33:06 2017 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Two trivial overlapping changes conflicts in MPLS and mlx5.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d6f8cfa3dea294eabf8f302e90176dd6381fb66e
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jan 25 11:39:49 2017 +0100

    net: phy: leds: Break dependency of phy.h on phy_led_triggers.h
    
    <linux/phy.h> includes <linux/phy_led_triggers.h>, which is not really
    needed.  Drop the include from <linux/phy.h>, and add it to all users
    that didn't include it explicitly.
    
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f7d95f644eed..7fc1105605bf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -25,7 +25,6 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
-#include <linux/phy_led_triggers.h>
 
 #include <linux/atomic.h>
 

commit 4567d686f5c6d955e57a3afa1741944c1e7f4033
Author: Volodymyr Bendiuga <volodymyr.bendiuga@gmail.com>
Date:   Thu Jan 19 17:05:04 2017 +0100

    phy: increase size of MII_BUS_ID_SIZE and bus_id
    
    Some bus names are pretty long and do not fit into
    17 chars. Increase therefore MII_BUS_ID_SIZE and
    phy_fixup.bus_id to larger number. Now mii_bus.id
    can host larger name.
    
    Signed-off-by: Volodymyr Bendiuga <volodymyr.bendiuga@gmail.com>
    Signed-off-by: Magnus berg <magnus.oberg@westermo.se>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f7d95f644eed..5c9d2529685f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -158,11 +158,7 @@ static inline const char *phy_modes(phy_interface_t interface)
 /* Used when trying to connect to a specific phy (mii bus id:phy device id) */
 #define PHY_ID_FMT "%s:%02x"
 
-/*
- * Need to be a little smaller than phydev->dev.bus_id to leave room
- * for the ":%02x"
- */
-#define MII_BUS_ID_SIZE	(20 - 3)
+#define MII_BUS_ID_SIZE	61
 
 /* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit
    IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
@@ -632,7 +628,7 @@ struct phy_driver {
 /* A Structure for boards to register fixups with the PHY Lib */
 struct phy_fixup {
 	struct list_head list;
-	char bus_id[20];
+	char bus_id[MII_BUS_ID_SIZE + 3];
 	u32 phy_uid;
 	u32 phy_uid_mask;
 	int (*run)(struct phy_device *phydev);

commit f38e7a32ee4fc9c8aeeac59e6e0462cd281586e3
Author: Woojung.Huh@microchip.com <Woojung.Huh@microchip.com>
Date:   Wed Dec 7 20:26:07 2016 +0000

    phy: add phy fixup unregister functions
    
    >From : Woojung Huh <woojung.huh@microchip.com>
    
    Add functions to unregister phy fixup for modules.
    
    int phy_unregister_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask)
            Unregister phy fixup from phy_fixup_list per bus_id, phy_uid &
            phy_uid_mask
    
    int phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask)
            Unregister phy fixup from phy_fixup_list.
            Use it for fixup registered by phy_register_fixup_for_uid()
    
    int phy_unregister_fixup_for_id(const char *bus_id)
            Unregister phy fixup from phy_fixup_list.
            Use it for fixup registered by phy_register_fixup_for_id()
    
    Signed-off-by: Woojung Huh <woojung.huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index feb8a98e8dd3..f7d95f644eed 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -860,6 +860,10 @@ int phy_register_fixup_for_id(const char *bus_id,
 int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
 			       int (*run)(struct phy_device *));
 
+int phy_unregister_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask);
+int phy_unregister_fixup_for_id(const char *bus_id);
+int phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask);
+
 int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);
 int phy_get_eee_err(struct phy_device *phydev);
 int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);

commit f4ed2fe34fb793755ef8cfc3509e783c4709ffc1
Author: Raju Lakkaraju <Raju.Lakkaraju@microsemi.com>
Date:   Tue Nov 29 15:16:46 2016 +0530

    net: phy: add mdix_ctrl to hold the user configuration.
    
    Add new parameter mdix_ctrl to hold the user configuration.
    Existing mdix maintain the current status of MDI(X) crossover performed or
    not.
    mdix_ctrl can configure either ETH_TP_MDI or ETH_TP_MDI_X orETH_TP_MDI_AUTO.
    
    Signed-off-by: Raju Lakkaraju <Raju.Lakkaraju@microsemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b53177fd38af..feb8a98e8dd3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -450,6 +450,7 @@ struct phy_device {
 	struct net_device *attached_dev;
 
 	u8 mdix;
+	u8 mdix_ctrl;
 
 	void (*adjust_link)(struct net_device *dev);
 };

commit d853d145ea3e63387a2ac759aa41d5e43876e561
Author: jbrunet <jbrunet@baylibre.com>
Date:   Mon Nov 28 10:46:46 2016 +0100

    net: phy: add an option to disable EEE advertisement
    
    This patch adds an option to disable EEE advertisement in the generic PHY
    by providing a mask of prohibited modes corresponding to the value found in
    the MDIO_AN_EEE_ADV register.
    
    On some platforms, PHY Low power idle seems to be causing issues, even
    breaking the link some cases. The patch provides a convenient way for these
    platforms to disable EEE advertisement and work around the issue.
    
    Signed-off-by: Jerome Brunet <jbrunet@baylibre.com>
    Tested-by: Yegor Yefremov <yegorslists@googlemail.com>
    Tested-by: Andreas Frber <afaerber@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index edde28ce163a..b53177fd38af 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -417,6 +417,9 @@ struct phy_device {
 	u32 advertising;
 	u32 lp_advertising;
 
+	/* Energy efficient ethernet modes which should be prohibited */
+	u32 eee_broken_modes;
+
 	int autoneg;
 
 	int link_timeout;

commit 968ad9da7e0e333e25442950e10a1b631981ce84
Author: Raju Lakkaraju <Raju.Lakkaraju@microsemi.com>
Date:   Thu Nov 17 13:07:21 2016 +0100

    ethtool: Implements ETHTOOL_PHY_GTUNABLE/ETHTOOL_PHY_STUNABLE
    
    Adding get_tunable/set_tunable function pointer to the phy_driver
    structure, and uses these function pointers to implement the
    ETHTOOL_PHY_GTUNABLE/ETHTOOL_PHY_STUNABLE ioctls.
    
    Signed-off-by: Raju Lakkaraju <Raju.Lakkaraju@microsemi.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Allan W. Nielsen <allan.nielsen@microsemi.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b9bd3b4f4ea1..edde28ce163a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -611,6 +611,13 @@ struct phy_driver {
 	void (*get_strings)(struct phy_device *dev, u8 *data);
 	void (*get_stats)(struct phy_device *dev,
 			  struct ethtool_stats *stats, u64 *data);
+
+	/* Get and Set PHY tunables */
+	int (*get_tunable)(struct phy_device *dev,
+			   struct ethtool_tunable *tuna, void *data);
+	int (*set_tunable)(struct phy_device *dev,
+			    struct ethtool_tunable *tuna,
+			    const void *data);
 };
 #define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 				      struct phy_driver, mdiodrv)

commit e86a8987e458a1826f509c41494b0b29a61144a7
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 15 10:06:30 2016 -0800

    net: phy: Add phy_ethtool_nway_reset
    
    This function just calls into genphy_restart_aneg() to perform an
    autonegotation restart.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9880d73a2c3d..b9bd3b4f4ea1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -860,6 +860,7 @@ int phy_ethtool_get_link_ksettings(struct net_device *ndev,
 				   struct ethtool_link_ksettings *cmd);
 int phy_ethtool_set_link_ksettings(struct net_device *ndev,
 				   const struct ethtool_link_ksettings *cmd);
+int phy_ethtool_nway_reset(struct net_device *ndev);
 
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);

commit 372788f964c95a6fa0f677c43d6153c27896ef42
Author: Lendacky, Thomas <Thomas.Lendacky@amd.com>
Date:   Thu Nov 10 17:10:46 2016 -0600

    net: phy: expose phy_aneg_done API for use by drivers
    
    Make phy_aneg_done() available to drivers so that the result of the
    auto-negotiation initiated by phy_start_aneg() can be determined.
    
    Remove the local implementation of phy_aneg_done() from the Aeroflex
    driver and use the phy library version.
    
    Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e7e1fd382564..9880d73a2c3d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -786,6 +786,7 @@ void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
+int phy_aneg_done(struct phy_device *phydev);
 
 int phy_stop_interrupts(struct phy_device *phydev);
 

commit 2e0bc452f4721520502575362a9cd3c1248d2337
Author: Zach Brown <zach.brown@ni.com>
Date:   Mon Oct 17 10:49:55 2016 -0500

    net: phy: leds: add support for led triggers on phy link state change
    
    Create an option CONFIG_LED_TRIGGER_PHY (default n), which will create a
    set of led triggers for each instantiated PHY device. There is one LED
    trigger per link-speed, per-phy.
    The triggers are registered during phy_attach and unregistered during
    phy_detach.
    
    This allows for a user to configure their system to allow a set of LEDs
    not controlled by the phy to represent link state changes on the phy.
    LEDS controlled by the phy are unaffected.
    
    For example, we have a board where some of the leds in the
    RJ45 socket are controlled by the phy, but others are not. Using the
    triggers provided by this patch the leds not controlled by the phy can
    be configured to show the current speed of the ethernet connection. The
    leds controlled by the phy are unaffected.
    
    Signed-off-by: Josh Cartwright <josh.cartwright@ni.com>
    Signed-off-by: Nathan Sullivan <nathan.sullivan@ni.com>
    Signed-off-by: Zach Brown <zach.brown@ni.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4b6c246c63bb..e7e1fd382564 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -25,6 +25,7 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
+#include <linux/phy_led_triggers.h>
 
 #include <linux/atomic.h>
 
@@ -420,6 +421,12 @@ struct phy_device {
 
 	int link_timeout;
 
+#ifdef CONFIG_LED_TRIGGER_PHY
+	struct phy_led_trigger *phy_led_triggers;
+	unsigned int phy_num_led_triggers;
+	struct phy_led_trigger *last_triggered;
+#endif
+
 	/*
 	 * Interrupt number for this PHY
 	 * -1 means no interrupt

commit 1f9127caece42514a47011326b83ad93d95cd5d7
Author: Zach Brown <zach.brown@ni.com>
Date:   Mon Oct 17 10:49:54 2016 -0500

    net: phy: Create phy_supported_speeds function which lists speeds currently supported by a phydevice
    
    phy_supported_speeds provides a means to get a list of all the speeds a
    phy device currently supports.
    
    Signed-off-by: Zach Brown <zach.brown@ni.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c47378c93607..4b6c246c63bb 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -84,6 +84,21 @@ typedef enum {
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
+/**
+ * phy_supported_speeds - return all speeds currently supported by a phy device
+ * @phy: The phy device to return supported speeds of.
+ * @speeds: buffer to store supported speeds in.
+ * @size: size of speeds buffer.
+ *
+ * Description: Returns the number of supported speeds, and
+ * fills the speeds * buffer with the supported speeds. If speeds buffer is
+ * too small to contain * all currently supported speeds, will return as
+ * many speeds as can fit.
+ */
+unsigned int phy_supported_speeds(struct phy_device *phy,
+				      unsigned int *speeds,
+				      unsigned int size);
+
 /**
  * It maps 'enum phy_interface_t' found in include/linux/phy.h
  * into the device tree binding of 'phy-mode', so that Ethernet

commit 664fcf123a30edf16b47d2ce1f610d654ba917b2
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Oct 16 19:56:51 2016 +0200

    net: phy: Threaded interrupts allow some simplification
    
    The PHY interrupts are now handled in a threaded interrupt handler,
    which can sleep. The work queue is no longer needed, phy_change() can
    be called directly. phy_mac_interrupt() still needs to be safe to call
    in interrupt context, so keep the work queue, and use a helper to call
    phy_change().
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e25f1830fbcf..c47378c93607 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -343,7 +343,7 @@ struct phy_c45_device_ids {
  * giving up on the current attempt at acquiring a link
  * irq: IRQ number of the PHY's interrupt (-1 if none)
  * phy_timer: The timer for handling the state machine
- * phy_queue: A work_queue for the interrupt
+ * phy_queue: A work_queue for the phy_mac_interrupt
  * attached_dev: The attached enet driver's device instance ptr
  * adjust_link: Callback for the enet controller to respond to
  * changes in the link state.
@@ -802,7 +802,8 @@ int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 int phy_drivers_register(struct phy_driver *new_driver, int n,
 			 struct module *owner);
 void phy_state_machine(struct work_struct *work);
-void phy_change(struct work_struct *work);
+void phy_change(struct phy_device *phydev);
+void phy_change_work(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev, int new_link);
 void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);

commit 572de608e36279f249c9a6350f142e69f23dacab
Author: Sean Wang <sean.wang@mediatek.com>
Date:   Thu Sep 22 10:33:54 2016 +0800

    net: ethernet: mediatek: add extension of phy-mode for TRGMII
    
    adds PHY-mode "trgmii" as an extension for the operation
    mode of the PHY interface for PHY_INTERFACE_MODE_TRGMII.
    and adds a variable trgmii inside mtk_mac as the indication
    to make the difference between the MAC connected to internal
    switch or connected to external PHY by the given configuration
    on the board and then to perform the corresponding setup on
    TRGMII hardware module.
    
    Signed-off-by: Sean Wang <sean.wang@mediatek.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2d24b283aa2d..e25f1830fbcf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -80,6 +80,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_XGMII,
 	PHY_INTERFACE_MODE_MOCA,
 	PHY_INTERFACE_MODE_QSGMII,
+	PHY_INTERFACE_MODE_TRGMII,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -123,6 +124,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "moca";
 	case PHY_INTERFACE_MODE_QSGMII:
 		return "qsgmii";
+	case PHY_INTERFACE_MODE_TRGMII:
+		return "trgmii";
 	default:
 		return "unknown";
 	}

commit 9d9a77cee1ab53dc6419b1ab9da88c4e9342d26a
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Tue May 10 00:19:41 2016 +0200

    net: phy: add phy_ethtool_{get|set}_link_ksettings
    
    Ethtool callbacks {get|set}_link_ksettings are often the same, so
    we add two generics functions phy_ethtool_{get|set}_link_ksettings
    to avoid writing severals times the same function.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Acked-By: David Decotigny <decot@googlers.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index be3f83bbdc0b..2d24b283aa2d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -829,6 +829,10 @@ int phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);
 int phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
 void phy_ethtool_get_wol(struct phy_device *phydev,
 			 struct ethtool_wolinfo *wol);
+int phy_ethtool_get_link_ksettings(struct net_device *ndev,
+				   struct ethtool_link_ksettings *cmd);
+int phy_ethtool_set_link_ksettings(struct net_device *ndev,
+				   const struct ethtool_link_ksettings *cmd);
 
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);

commit 2d55173e71b06c5a369489852d972304e14189fd
Author: Philippe Reynes <tremyfr@gmail.com>
Date:   Fri Apr 15 00:35:00 2016 +0200

    phy: add generic function to support ksetting support
    
    The old ethtool api (get_setting and set_setting) has
    generic phy functions phy_ethtool_sset and phy_ethtool_gset.
    To supprt the new ethtool api (get_link_ksettings and
    set_link_ksettings), we add generic phy function
    phy_ethtool_ksettings_get and phy_ethtool_ksettings_set.
    
    Signed-off-by: Philippe Reynes <tremyfr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2abd7918f64f..be3f83bbdc0b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -805,6 +805,10 @@ void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_ethtool_ksettings_get(struct phy_device *phydev,
+			      struct ethtool_link_ksettings *cmd);
+int phy_ethtool_ksettings_set(struct phy_device *phydev,
+			      const struct ethtool_link_ksettings *cmd);
 int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);

commit 470c3822d2ab7fadcbb1ac317ef27b31caac370e
Author: LABBE Corentin <clabbe.montjoie@gmail.com>
Date:   Thu Mar 10 13:58:58 2016 +0100

    phy: remove documentation of removed members of phy_device structure
    
    Commit e5a03bfd873c ("phy: Add an mdio_device structure") removed addr,
    bus and dev member of the phy_device structure.
    This patch remove the documentation about those members.
    
    Signed-off-by: LABBE Corentin <clabbe.montjoie@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d6f3641e7933..2abd7918f64f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -327,8 +327,6 @@ struct phy_c45_device_ids {
 /* phy_device: An instance of a PHY
  *
  * drv: Pointer to the driver for this PHY instance
- * bus: Pointer to the bus this PHY is on
- * dev: driver model device structure for this PHY
  * phy_id: UID for this device found during discovery
  * c45_ids: 802.3-c45 Device Identifers if is_c45.
  * is_c45:  Set to true if this phy uses clause 45 addressing.
@@ -338,7 +336,6 @@ struct phy_c45_device_ids {
  * suspended: Set to true if this phy has been suspended successfully.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
- * addr: Bus address of PHY
  * link_timeout: The number of timer firings to wait before the
  * giving up on the current attempt at acquiring a link
  * irq: IRQ number of the PHY's interrupt (-1 if none)

commit a9049e0c513c4521dbfaa302af8ed08b3366b41f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:26 2016 +0100

    mdio: Add support for mdio drivers.
    
    Not all devices on an MDIO bus are PHYs. Meaning not all MDIO drivers
    are PHY drivers. Add support for generic MDIO drivers.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 49e4418822b3..d6f3641e7933 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -60,6 +60,7 @@
 #define PHY_HAS_INTERRUPT	0x00000001
 #define PHY_HAS_MAGICANEG	0x00000002
 #define PHY_IS_INTERNAL		0x00000004
+#define MDIO_DEVICE_IS_PHY	0x80000000
 
 /* Interface Mode definitions */
 typedef enum {
@@ -432,6 +433,7 @@ struct phy_device {
 
 /* struct phy_driver: Driver structure for a particular PHY type
  *
+ * driver_data: static driver data
  * phy_id: The result of reading the UID registers of this PHY
  *   type, and ANDing them with the phy_id_mask.  This driver
  *   only works for PHYs with IDs which match this field
@@ -441,7 +443,6 @@ struct phy_device {
  *   by this PHY
  * flags: A bitfield defining certain other features this PHY
  *   supports (like interrupts)
- * driver_data: static driver data
  *
  * The drivers must implement config_aneg and read_status.  All
  * other functions are optional. Note that none of these
@@ -452,6 +453,7 @@ struct phy_device {
  * supported in the driver).
  */
 struct phy_driver {
+	struct mdio_driver_common mdiodrv;
 	u32 phy_id;
 	char *name;
 	unsigned int phy_id_mask;
@@ -587,10 +589,9 @@ struct phy_driver {
 	void (*get_strings)(struct phy_device *dev, u8 *data);
 	void (*get_stats)(struct phy_device *dev,
 			  struct ethtool_stats *stats, u64 *data);
-
-	struct device_driver driver;
 };
-#define to_phy_driver(d) container_of(d, struct phy_driver, driver)
+#define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
+				      struct phy_driver, mdiodrv)
 
 #define PHY_ANY_ID "MATCH ANY PHY"
 #define PHY_ANY_UID 0xffffffff

commit be01da72b1b832b89fbdf59ae6f1b60e53ca2987
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:22 2016 +0100

    phy: Centralize setting driver module owner
    
    Rather than have each driver set the driver owner field, do it once in
    the core code. This will also help with later changes, when the device
    structure will move.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2d7beef20825..49e4418822b3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -797,8 +797,9 @@ int genphy_resume(struct phy_device *phydev);
 int genphy_soft_reset(struct phy_device *phydev);
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
-int phy_driver_register(struct phy_driver *new_driver);
-int phy_drivers_register(struct phy_driver *new_driver, int n);
+int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
+int phy_drivers_register(struct phy_driver *new_driver, int n,
+			 struct module *owner);
 void phy_state_machine(struct work_struct *work);
 void phy_change(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev, int new_link);
@@ -843,7 +844,7 @@ extern struct bus_type mdio_bus_type;
 #define phy_module_driver(__phy_drivers, __count)			\
 static int __init phy_module_init(void)					\
 {									\
-	return phy_drivers_register(__phy_drivers, __count);		\
+	return phy_drivers_register(__phy_drivers, __count, THIS_MODULE); \
 }									\
 module_init(phy_module_init);						\
 static void __exit phy_module_exit(void)				\

commit 7f854420fbfe9d49afe2ffb1df052cfe8e215541
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:18 2016 +0100

    phy: Add API for {un}registering an mdio device to a bus.
    
    Rather than have drivers directly manipulate the mii_bus structure,
    provide and API for registering and unregistering devices on an MDIO
    bus, and performing lookups.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 239a0c2bc49d..2d7beef20825 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -180,7 +180,7 @@ struct mii_bus {
 	struct device dev;
 
 	/* list of all PHYs on bus */
-	struct phy_device *phy_map[PHY_MAX_ADDR];
+	struct mdio_device *mdio_map[PHY_MAX_ADDR];
 
 	/* PHY addresses to be ignored when probing */
 	u32 phy_mask;

commit e5a03bfd873c29eb786655ef2e95e53ed242b404
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:16 2016 +0100

    phy: Add an mdio_device structure
    
    Not all devices attached to an MDIO bus are phys. So add an
    mdio_device structure to represent the generic parts of an mdio
    device, and place this structure into the phy_device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a5473c9e19de..239a0c2bc49d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -358,14 +358,12 @@ struct phy_c45_device_ids {
  * handling, as well as handling shifts in PHY hardware state
  */
 struct phy_device {
+	struct mdio_device mdio;
+
 	/* Information about the PHY type */
 	/* And management functions */
 	struct phy_driver *drv;
 
-	struct mii_bus *bus;
-
-	struct device dev;
-
 	u32 phy_id;
 
 	struct phy_c45_device_ids c45_ids;
@@ -381,9 +379,6 @@ struct phy_device {
 
 	phy_interface_t interface;
 
-	/* Bus address of the PHY (0-31) */
-	int addr;
-
 	/*
 	 * forced speed & duplex (no autoneg)
 	 * partner speed & duplex & pause (autoneg)
@@ -432,7 +427,8 @@ struct phy_device {
 
 	void (*adjust_link)(struct net_device *dev);
 };
-#define to_phy_device(d) container_of(d, struct phy_device, dev)
+#define to_phy_device(d) container_of(to_mdio_device(d), \
+				      struct phy_device, mdio)
 
 /* struct phy_driver: Driver structure for a particular PHY type
  *
@@ -622,7 +618,7 @@ static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
 	if (!phydev->is_c45)
 		return -EOPNOTSUPP;
 
-	return mdiobus_read(phydev->bus, phydev->addr,
+	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr,
 			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
 }
 
@@ -648,7 +644,7 @@ int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad);
  */
 static inline int phy_read(struct phy_device *phydev, u32 regnum)
 {
-	return mdiobus_read(phydev->bus, phydev->addr, regnum);
+	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
 }
 
 /**
@@ -663,7 +659,7 @@ static inline int phy_read(struct phy_device *phydev, u32 regnum)
  */
 static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 {
-	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
+	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
 }
 
 /**
@@ -726,7 +722,7 @@ static inline int phy_write_mmd(struct phy_device *phydev, int devad,
 
 	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
 
-	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
+	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
 }
 
 /**
@@ -776,14 +772,14 @@ static inline int phy_read_status(struct phy_device *phydev)
 }
 
 #define phydev_err(_phydev, format, args...)	\
-	dev_err(&_phydev->dev, format, ##args)
+	dev_err(&_phydev->mdio.dev, format, ##args)
 
 #define phydev_dbg(_phydev, format, args...)	\
-	dev_dbg(&_phydev->dev, format, ##args)
+	dev_dbg(&_phydev->mdio.dev, format, ##args);
 
 static inline const char *phydev_name(const struct phy_device *phydev)
 {
-	return dev_name(&phydev->dev);
+	return dev_name(&phydev->mdio.dev);
 }
 
 void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)

commit e7f4dc3536a40097f95103ddf98dd55b3a980f5b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:15 2016 +0100

    mdio: Move allocation of interrupts into core
    
    Have mdio_alloc() create the array of interrupt numbers, and
    initialize it to POLLING. This is what most MDIO drivers want, so
    allowing code to be removed from the drivers.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ecbf6382ba29..a5473c9e19de 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -189,10 +189,10 @@ struct mii_bus {
 	u32 phy_ignore_ta_mask;
 
 	/*
-	 * Pointer to an array of interrupts, each PHY's
-	 * interrupt at the index matching its address
+	 * An array of interrupts, each PHY's interrupt at the index
+	 * matching its address
 	 */
-	int *irq;
+	int irq[PHY_MAX_ADDR];
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 

commit 2220943a21e26d97d7fd8f83c004b947326b469d
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:13 2016 +0100

    phy: Centralise print about attached phy
    
    Many Ethernet drivers contain the same netdev_info() print statement
    about the attached phy. Move it into the phy device code. Additionally
    add a varargs function which can be used to append additional
    information.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 08198ce98773..ecbf6382ba29 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -16,6 +16,7 @@
 #ifndef __PHY_H
 #define __PHY_H
 
+#include <linux/compiler.h>
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
 #include <linux/mdio.h>
@@ -785,6 +786,9 @@ static inline const char *phydev_name(const struct phy_device *phydev)
 	return dev_name(&phydev->dev);
 }
 
+void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+	__printf(2, 3);
+void phy_attached_info(struct phy_device *phydev);
 int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);

commit 053e7e169229adebbc27fc176c5369398e9f5eba
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:12 2016 +0100

    phy: phy_{read|write}_mmd_indirect: get addr from phydev
    
    The address of the device can be determined from the phydev structure,
    rather than passing it as a parameter.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5f5cc3424b9e..08198ce98773 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -629,14 +629,12 @@ static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
  * phy_read_mmd_indirect - reads data from the MMD registers
  * @phydev: The PHY device bus
  * @prtad: MMD Address
- * @devad: MMD DEVAD
  * @addr: PHY address on the MII bus
  *
  * Description: it reads data from the MMD registers (clause 22 to access to
  * clause 45) of the specified phy address.
  */
-int phy_read_mmd_indirect(struct phy_device *phydev, int prtad,
-			  int devad, int addr);
+int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad);
 
 /**
  * phy_read - Convenience function for reading a given PHY register
@@ -735,14 +733,13 @@ static inline int phy_write_mmd(struct phy_device *phydev, int devad,
  * @phydev: The PHY device
  * @prtad: MMD Address
  * @devad: MMD DEVAD
- * @addr: PHY address on the MII bus
  * @data: data to write in the MMD register
  *
  * Description: Write data from the MMD registers of the specified
  * phy address.
  */
 void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
-			    int devad, int addr, u32 data);
+			    int devad, u32 data);
 
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,

commit 84eff6d194df442bee62c129f2f47efb0dbd0468
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:10 2016 +0100

    phy: add phydev_name() wrapper
    
    Add a phydev_name() function, to help with moving some structure members
    from phy_device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index dbcf9fdd960c..5f5cc3424b9e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -783,6 +783,11 @@ static inline int phy_read_status(struct phy_device *phydev)
 #define phydev_dbg(_phydev, format, args...)	\
 	dev_dbg(&_phydev->dev, format, ##args)
 
+static inline const char *phydev_name(const struct phy_device *phydev)
+{
+	return dev_name(&phydev->dev);
+}
+
 int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);

commit 72ba48be3ec8e70937ad97d4420ef7144617c64b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:09 2016 +0100

    phy: Add phydev_err() and phydev_dbg() macros
    
    In preparation for moving some of the phy_device structure members,
    add macros for printing errors and debug information.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8ca161a37e8a..dbcf9fdd960c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -777,6 +777,12 @@ static inline int phy_read_status(struct phy_device *phydev)
 	return phydev->drv->read_status(phydev);
 }
 
+#define phydev_err(_phydev, format, args...)	\
+	dev_err(&_phydev->dev, format, ##args)
+
+#define phydev_dbg(_phydev, format, args...)	\
+	dev_dbg(&_phydev->dev, format, ##args)
+
 int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);

commit bac83c653799d7ea3f6cc4d7396d75adc5e0f778
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:07 2016 +0100

    mdio: Move mdiobus_read/write operatings into mdio.h
    
    These are logically MDIO operations, not phy operations, so move them
    into the mdio header.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 77b5e56e2a92..8ca161a37e8a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -18,6 +18,7 @@
 
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
+#include <linux/mdio.h>
 #include <linux/mii.h>
 #include <linux/module.h>
 #include <linux/timer.h>
@@ -212,11 +213,6 @@ static inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)
 
 void devm_mdiobus_free(struct device *dev, struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
-int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
-int mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum);
-int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
-int mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val);
-
 
 #define PHY_INTERRUPT_DISABLED	0x0
 #define PHY_INTERRUPT_ENABLED	0x80000000

commit ccaa953e9fc7ebb90fba4e4815966683bef4866f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jan 6 20:11:06 2016 +0100

    phy: Consistently use addr for address on an MII bus
    
    Within phy.h, an address on an MII bus has been called both addr and
    phy_id. phy_id is particularly confusion, since it also means the ID
    found in register 3, if the device on the bus is a phy. Consistently
    use addr.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a89cb0eef911..77b5e56e2a92 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -158,8 +158,8 @@ struct mii_bus {
 	const char *name;
 	char id[MII_BUS_ID_SIZE];
 	void *priv;
-	int (*read)(struct mii_bus *bus, int phy_id, int regnum);
-	int (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val);
+	int (*read)(struct mii_bus *bus, int addr, int regnum);
+	int (*write)(struct mii_bus *bus, int addr, int regnum, u16 val);
 	int (*reset)(struct mii_bus *bus);
 
 	/*

commit f3a4094558ddf8afa8bb58250d548e15e059c65a
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 30 16:28:25 2015 +0100

    ethtool: Add phy statistics
    
    Ethernet PHYs can maintain statistics, for example errors while idle
    and receive errors. Add an ethtool mechanism to retrieve these
    statistics, using the same model as MAC statistics.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 05fde31b6dc6..a89cb0eef911 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -589,6 +589,12 @@ struct phy_driver {
 	int (*module_eeprom)(struct phy_device *dev,
 			     struct ethtool_eeprom *ee, u8 *data);
 
+	/* Get statistics from the phy using ethtool */
+	int (*get_sset_count)(struct phy_device *dev);
+	void (*get_strings)(struct phy_device *dev, u8 *data);
+	void (*get_stats)(struct phy_device *dev,
+			  struct ethtool_stats *stats, u64 *data);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)

commit 21dd19fed3c3eb42a3877600f4a97a774323e562
Author: Neil Armstrong <narmstrong@baylibre.com>
Date:   Thu Oct 22 10:37:49 2015 +0200

    net: phy: Add nested variants of mdiobus read/write
    
    Since nested variants of mdiobus_read/write are used in multiple
    drivers, add nested variants in the mdiobus core.
    
    Suggested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4c477e6ece33..05fde31b6dc6 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -213,7 +213,9 @@ static inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)
 void devm_mdiobus_free(struct device *dev, struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
+int mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum);
 int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
+int mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val);
 
 
 #define PHY_INTERRUPT_DISABLED	0x0

commit f3a6bd393c2c5d0e6b16624ba99a1c5fa07bdb0b
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Wed Sep 30 15:15:52 2015 +0900

    phylib: Add phy_set_max_speed helper
    
    Add a helper to allow ethernet drivers to limit the speed of a phy
    (that they are attached to).
    
    This mainly involves factoring out the business-end of
    of_set_phy_supported() and exporting a new symbol.
    
    This code seems to be open coded in several places, in several different
    variants.
    
    It is is envisaged that this will be used in situations where setting the
    "max-speed" property in DT is not appropriate, e.g. because the maximum
    speed is not a property of the phy hardware.
    
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4a4e3a092337..4c477e6ece33 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -798,6 +798,7 @@ int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 void phy_device_free(struct phy_device *phydev);
+int phy_set_max_speed(struct phy_device *phydev, u32 max_speed);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
 		       int (*run)(struct phy_device *));

commit 38737e490d4ea91660d3cec83ef88c4e6d360ae4
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 24 20:36:28 2015 +0100

    phy: add phy_device_remove()
    
    Add a phy_device_remove() function to complement phy_device_register(),
    which undoes the effects of phy_device_register() by removing the phy
    device from visibility, but not freeing it.
    
    This allows these details to be moved out of the mdio bus code into
    the phy code where this action belongs.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 11bce44f6d65..4a4e3a092337 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -745,6 +745,7 @@ struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     struct phy_c45_device_ids *c45_ids);
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
+void phy_device_remove(struct phy_device *phydev);
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);

commit 3e3aaf649416988ca8be4ad2c52dc24d8be7b46e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 24 20:36:02 2015 +0100

    phy: fix mdiobus module safety
    
    Re-implement the mdiobus module refcounting to ensure that we actually
    ensure that the mdiobus module code does not go away while we might call
    into it.
    
    The old scheme using bus->dev.driver was buggy, because bus->dev is a
    class device which never has a struct device_driver associated with it,
    and hence the associated code trying to obtain a refcount did nothing
    useful.
    
    Instead, take the approach that other subsystems do: pass the module
    when calling mdiobus_register(), and record that in the mii_bus struct.
    When we need to increment the module use count in the phy code, use
    this stored pointer.  When the phy is deteched, drop the module
    refcount, remembering that the phy device might go away at that point.
    
    This doesn't stop the mii_bus going away while there are in-use phys -
    it merely stops the underlying code vanishing.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 962387a192f1..11bce44f6d65 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -19,6 +19,7 @@
 #include <linux/spinlock.h>
 #include <linux/ethtool.h>
 #include <linux/mii.h>
+#include <linux/module.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
@@ -153,6 +154,7 @@ struct sk_buff;
  * PHYs should register using this structure
  */
 struct mii_bus {
+	struct module *owner;
 	const char *name;
 	char id[MII_BUS_ID_SIZE];
 	void *priv;
@@ -198,7 +200,8 @@ static inline struct mii_bus *mdiobus_alloc(void)
 	return mdiobus_alloc_size(0);
 }
 
-int mdiobus_register(struct mii_bus *bus);
+int __mdiobus_register(struct mii_bus *bus, struct module *owner);
+#define mdiobus_register(bus) __mdiobus_register(bus, THIS_MODULE)
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);
 struct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv);

commit 5a11dd7d9649149f336ca72069d56ce52b21567f
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Aug 31 15:56:46 2015 +0200

    net: phy: Allow PHY devices to identify themselves as Ethernet switches, etc.
    
    Some Ethernet MAC drivers using the PHY library require the hardcoding
    of link parameters when interfaced to a switch device, SFP module,
    switch to switch port, etc. This has typically lead to various ad-hoc
    implementations looking like this:
    
    - using a "fixed PHY" emulated device, which will provide link
      indication towards the Ethernet MAC driver and hardware
    
    - pretend there is no PHY and hardcode link parameters, ala mv643x_eth
    
    Based on that, it is desireable to have the PHY drivers advertise the
    correct link parameters, just like regular Ethernet PHYs towards their
    CPU Ethernet MAC drivers, however, Ethernet MAC drivers should be able
    to tell whether this link should be monitored or not. In the context
    of an Ethernet switch, SFP module, switch to switch link, we do not
    need to monitor this link since it should be always up.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e5fb1d415961..962387a192f1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -330,6 +330,7 @@ struct phy_c45_device_ids {
  * c45_ids: 802.3-c45 Device Identifers if is_c45.
  * is_c45:  Set to true if this phy uses clause 45 addressing.
  * is_internal: Set to true if this phy is internal to a MAC.
+ * is_pseudo_fixed_link: Set to true if this phy is an Ethernet switch, etc.
  * has_fixups: Set to true if this phy has fixups/quirks.
  * suspended: Set to true if this phy has been suspended successfully.
  * state: state of the PHY for management purposes
@@ -368,6 +369,7 @@ struct phy_device {
 	struct phy_c45_device_ids c45_ids;
 	bool is_c45;
 	bool is_internal;
+	bool is_pseudo_fixed_link;
 	bool has_fixups;
 	bool suspended;
 
@@ -688,6 +690,16 @@ static inline bool phy_interface_is_rgmii(struct phy_device *phydev)
 {
 	return phydev->interface >= PHY_INTERFACE_MODE_RGMII &&
 		phydev->interface <= PHY_INTERFACE_MODE_RGMII_TXID;
+};
+
+/*
+ * phy_is_pseudo_fixed_link - Convenience function for testing if this
+ * PHY is the CPU port facing side of an Ethernet switch, or similar.
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_is_pseudo_fixed_link(struct phy_device *phydev)
+{
+	return phydev->is_pseudo_fixed_link;
 }
 
 /**

commit 634ec36cc0ab9d8dda0f2c101fa28d2e2a61b9eb
Author: David Thomson <david.thomson@alliedtelesis.co.nz>
Date:   Fri Jul 10 13:56:54 2015 +1200

    net: phy: Pass mdix ethtool setting through to phy driver
    
    Pass the mdix setting from ethtool down to the phy driver, to allow
    driver specific implementations of manually setting the polarity.
    
    Signed-off-by: David Thomson <david.thomson@alliedtelesis.co.nz>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a26c3f84b8dd..e5fb1d415961 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -424,6 +424,8 @@ struct phy_device {
 
 	struct net_device *attached_dev;
 
+	u8 mdix;
+
 	void (*adjust_link)(struct net_device *dev);
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)

commit e463d88c36d42211aa72ed76d32fb8bf37820ef1
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue May 26 12:19:58 2015 -0700

    net: phy: Add phy_interface_is_rgmii helper
    
    RGMII interfaces come in 4 different flavors that the PHY library needs
    to care about: regular RGMII (no delays), RGMII with either RX or TX
    delay, and both. In order to avoid errors of checking only for one type
    of RGMII interface and miss the 3 others, introduce a convenience
    function which tests for all values.
    
    Suggested-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 701c7a3946e0..a26c3f84b8dd 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -677,6 +677,17 @@ static inline bool phy_is_internal(struct phy_device *phydev)
 	return phydev->is_internal;
 }
 
+/**
+ * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
+ * is RGMII (all variants)
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_interface_is_rgmii(struct phy_device *phydev)
+{
+	return phydev->interface >= PHY_INTERFACE_MODE_RGMII &&
+		phydev->interface <= PHY_INTERFACE_MODE_RGMII_TXID;
+}
+
 /**
  * phy_write_mmd - Convenience function for writing a register
  * on an MMD on a given PHY.

commit 922f2dd1b65a888e34c472979460dc23211750a2
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue May 12 10:33:24 2015 -0700

    net: phy: Add phy_ignore_ta_mask to account for broken turn-around
    
    Some PHY devices/switches will not release the turn-around line as they
    should do at the end of a MDIO transaction. To help with such
    situations, allow MDIO bus drivers to be made aware of such
    restrictions.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 685809835b5c..701c7a3946e0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -181,6 +181,9 @@ struct mii_bus {
 	/* PHY addresses to be ignored when probing */
 	u32 phy_mask;
 
+	/* PHY addresses to ignore the TA/read failure */
+	u32 phy_ignore_ta_mask;
+
 	/*
 	 * Pointer to an array of interrupts, each PHY's
 	 * interrupt at the index matching its address

commit 8a477a6fb6a33651adda772360b85fd813569743
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jan 26 22:05:39 2015 -0800

    net: phy: keep track of the PHY suspend state
    
    In order to avoid double calls to phydev->drv->suspend and resume, keep
    track of whether the PHY has already been suspended as a consequence of
    a successful call to phy_suspend(). We will use this in our MDIO bus
    suspend/resume hooks to avoid a double suspend call.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 1b3690b597d5..685809835b5c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -328,6 +328,7 @@ struct phy_c45_device_ids {
  * is_c45:  Set to true if this phy uses clause 45 addressing.
  * is_internal: Set to true if this phy is internal to a MAC.
  * has_fixups: Set to true if this phy has fixups/quirks.
+ * suspended: Set to true if this phy has been suspended successfully.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * addr: Bus address of PHY
@@ -365,6 +366,7 @@ struct phy_device {
 	bool is_c45;
 	bool is_internal;
 	bool has_fixups;
+	bool suspended;
 
 	enum phy_state state;
 

commit aae88261abd58fffef7ee0e00160ce4ea105b0f3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jan 26 22:05:38 2015 -0800

    net: phy: document has_fixups field
    
    has_fixups was introduced to help keeping track of fixups/quirks running
    on a PHY device, but we did not update the comment above struct
    phy_device accordingly.
    
    Fixes: b0ae009f3dc14 (net: phy: add "has_fixups" boolean property")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9c189a1fa3a2..1b3690b597d5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -327,6 +327,7 @@ struct phy_c45_device_ids {
  * c45_ids: 802.3-c45 Device Identifers if is_c45.
  * is_c45:  Set to true if this phy uses clause 45 addressing.
  * is_internal: Set to true if this phy is internal to a MAC.
+ * has_fixups: Set to true if this phy has fixups/quirks.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * addr: Bus address of PHY

commit 2f4383667d57d1c719070db86b14277277752841
Author: Ed Swierk <eswierk@skyportsystems.com>
Date:   Fri Jan 2 17:27:56 2015 -0800

    ethtool: Extend ethtool plugin module eeprom API to phylib
    
    This patch extends the ethtool plugin module eeprom API to support cards
    whose phy support is delegated to a separate driver.
    
    The handlers for ETHTOOL_GMODULEINFO and ETHTOOL_GMODULEEEPROM call the
    module_info and module_eeprom functions if the phy driver provides them;
    otherwise the handlers call the equivalent ethtool_ops functions provided
    by network drivers with built-in phy support.
    
    Signed-off-by: Ed Swierk <eswierk@skyportsystems.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 22af8f8f5802..9c189a1fa3a2 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -565,6 +565,15 @@ struct phy_driver {
 	void (*write_mmd_indirect)(struct phy_device *dev, int ptrad,
 				   int devnum, int regnum, u32 val);
 
+	/* Get the size and type of the eeprom contained within a plug-in
+	 * module */
+	int (*module_info)(struct phy_device *dev,
+			   struct ethtool_modinfo *modinfo);
+
+	/* Get the eeprom information from the plug-in module */
+	int (*module_eeprom)(struct phy_device *dev,
+			     struct ethtool_eeprom *ee, u8 *data);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)

commit 860f6e9eb780443381a76e3766a9698afbc5e2e5
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Nov 19 12:59:14 2014 +0100

    net: phy: add static data field to struct phy_driver
    
    Add static driver-data field to struct phy_driver, which can be used to
    store structured device-type information.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 07794e720139..22af8f8f5802 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -433,6 +433,7 @@ struct phy_device {
  *   by this PHY
  * flags: A bitfield defining certain other features this PHY
  *   supports (like interrupts)
+ * driver_data: static driver data
  *
  * The drivers must implement config_aneg and read_status.  All
  * other functions are optional. Note that none of these
@@ -448,6 +449,7 @@ struct phy_driver {
 	unsigned int phy_id_mask;
 	u32 features;
 	u32 flags;
+	const void *driver_data;
 
 	/*
 	 * Called to issue a PHY software reset

commit c31accd159a6477b91de61ae237dce38e3f3ee4d
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 11 19:45:57 2014 +0100

    net: phy: add module_phy_driver macro
    
    Add helper macro for PHY drivers which do not do anything special in
    module init/exit. This will allow us to eliminate a lot of boilerplate
    code.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d090cfcaa167..07794e720139 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -772,4 +772,28 @@ int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
 
 extern struct bus_type mdio_bus_type;
+
+/**
+ * module_phy_driver() - Helper macro for registering PHY drivers
+ * @__phy_drivers: array of PHY drivers to register
+ *
+ * Helper macro for PHY drivers which do not do anything special in module
+ * init/exit. Each module may only use this macro once, and calling it
+ * replaces module_init() and module_exit().
+ */
+#define phy_module_driver(__phy_drivers, __count)			\
+static int __init phy_module_init(void)					\
+{									\
+	return phy_drivers_register(__phy_drivers, __count);		\
+}									\
+module_init(phy_module_init);						\
+static void __exit phy_module_exit(void)				\
+{									\
+	phy_drivers_unregister(__phy_drivers, __count);			\
+}									\
+module_exit(phy_module_exit)
+
+#define module_phy_driver(__phy_drivers)				\
+	phy_module_driver(__phy_drivers, ARRAY_SIZE(__phy_drivers))
+
 #endif /* __PHY_H */

commit 66ce7fb9807b036058aa380bfd2b3851ae25ce39
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Aug 22 18:55:43 2014 -0700

    net: phy: export phy_{read,write}_mmd_indirect
    
    Some PHY drivers might need to access Clause 45 registers in Clause 22
    compatibility mode to e.g: properly advertise EEE support when disabled
    by default.
    
    Export these two helper functions: phy_read_mmd_indirect() and
    phy_write_mmd_indirect() for drivers to use them.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ed39956b5613..d090cfcaa167 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -597,6 +597,19 @@ static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
 			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
 }
 
+/**
+ * phy_read_mmd_indirect - reads data from the MMD registers
+ * @phydev: The PHY device bus
+ * @prtad: MMD Address
+ * @devad: MMD DEVAD
+ * @addr: PHY address on the MII bus
+ *
+ * Description: it reads data from the MMD registers (clause 22 to access to
+ * clause 45) of the specified phy address.
+ */
+int phy_read_mmd_indirect(struct phy_device *phydev, int prtad,
+			  int devad, int addr);
+
 /**
  * phy_read - Convenience function for reading a given PHY register
  * @phydev: the phy_device struct
@@ -668,6 +681,20 @@ static inline int phy_write_mmd(struct phy_device *phydev, int devad,
 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 }
 
+/**
+ * phy_write_mmd_indirect - writes data to the MMD registers
+ * @phydev: The PHY device
+ * @prtad: MMD Address
+ * @devad: MMD DEVAD
+ * @addr: PHY address on the MII bus
+ * @data: data to write in the MMD register
+ *
+ * Description: Write data from the MMD registers of the specified
+ * phy address.
+ */
+void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
+			    int devad, int addr, u32 data);
+
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);

commit 0c1d77dfb56660329d639090352bf690d3c33466
Author: Vince Bridgers <vbridgers2013@gmail.com>
Date:   Tue Jul 29 15:19:57 2014 -0500

    net: libphy: Add phy specific function to access mmd phy registers
    
    libphy was originally written assuming all phy devices support clause 45
    access extensions to the mmd registers through the indirection registers
    located within the first 16 phy registers. This assumption is not true
    in all cases, and one specific example is the Micrel ksz9021 10/100/1000
    Mbps phy. Using the stmmac driver, accessing the mmd registers to query
    and configure energy efficient Ethernet (EEE) features yielded unexpected
    behavior.
    
    This patch adds mmd access functions to the phy driver that can be
    overriden by the phy specific driver if the phy does not support this
    mechanism or uses it's own non-standard access mechanism. By default,
    the IEEE Compatible clause 45 access mechanism described in clause 22
    is used. With this patch, EEE query/configure functions as expected
    using the stmmac and the Micrel ksz9021 phy.
    
    Signed-off-by: Vince Bridgers <vbridgers2013@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 68041446c450..ed39956b5613 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -545,6 +545,24 @@ struct phy_driver {
 	 */
 	void (*link_change_notify)(struct phy_device *dev);
 
+	/* A function provided by a phy specific driver to override the
+	 * the PHY driver framework support for reading a MMD register
+	 * from the PHY. If not supported, return -1. This function is
+	 * optional for PHY specific drivers, if not provided then the
+	 * default MMD read function is used by the PHY framework.
+	 */
+	int (*read_mmd_indirect)(struct phy_device *dev, int ptrad,
+				 int devnum, int regnum);
+
+	/* A function provided by a phy specific driver to override the
+	 * the PHY driver framework support for writing a MMD register
+	 * from the PHY. This function is optional for PHY specific drivers,
+	 * if not provided then the default MMD read function is used by
+	 * the PHY framework.
+	 */
+	void (*write_mmd_indirect)(struct phy_device *dev, int ptrad,
+				   int devnum, int regnum, u32 val);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)

commit 2b8f2a28eac1d35a432705d269f02bdaeba9be8f
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Jun 18 11:01:41 2014 +0200

    net: phylib: add link_change_notify callback to phy device
    
    Add a notify callback to inform phy drivers when the core is about to
    do its link adjustment. No change for drivers that do not implement
    this callback.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 864ddafad8cc..68041446c450 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -536,6 +536,15 @@ struct phy_driver {
 	/* See set_wol, but for checking whether Wake on LAN is enabled. */
 	void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
 
+	/*
+	 * Called to inform a PHY device driver when the core is about to
+	 * change the link state. This callback is supposed to be used as
+	 * fixup hook for drivers that need to take action when the link
+	 * state changes. Drivers are by no means allowed to mess with the
+	 * PHY device structure in their implementations.
+	 */
+	void (*link_change_notify)(struct phy_device *dev);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)

commit 6d48f44b7b2af67b33c1ae5994b8f642685c8bc8
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Wed Apr 30 15:23:33 2014 +0300

    mdio_bus: implement devm_mdiobus_alloc/devm_mdiobus_free
    
    Add a resource managed devm_mdiobus_alloc[_size]()/devm_mdiobus_free()
    to automatically clean up MDIO bus alocations made by MDIO drivers,
    thus leading to simplified MDIO drivers code.
    
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Acked-and-tested-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 51d15f684e7e..864ddafad8cc 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -198,6 +198,13 @@ static inline struct mii_bus *mdiobus_alloc(void)
 int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);
+struct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv);
+static inline struct mii_bus *devm_mdiobus_alloc(struct device *dev)
+{
+	return devm_mdiobus_alloc_size(dev, 0);
+}
+
+void devm_mdiobus_free(struct device *dev, struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
 int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);

commit af6b6967d6e17fe070c0fd1be364c34cbd31a523
Author: Daniel Mack <zonque@gmail.com>
Date:   Wed Apr 16 17:19:12 2014 +0200

    net: phy: export genphy_config_init()
    
    This enables other drivers to call this generic implementation, and then
    only do specific details on top of it.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4d0221fd0688..51d15f684e7e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -666,6 +666,7 @@ static inline int phy_read_status(struct phy_device *phydev)
 	return phydev->drv->read_status(phydev);
 }
 
+int genphy_config_init(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);

commit b9d12085f2f531fdea67f0361564e0812696227c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 15 15:50:19 2014 +0200

    net: phy: add minimal support for QSGMII PHY
    
    This commit adds the necessary definitions for the PHY layer to
    recognize "qsgmii" as a valid PHY interface. A QSMII interface, as
    defined at
    http://en.wikipedia.org/wiki/Media_Independent_Interface#Quad_Serial_Gigabit_Media_Independent_Interface,
    is "is a method of combining four SGMII lines into a 5Gbit/s
    interface. QSGMII, like SGMII, uses LVDS signalling for the TX and RX
    data and a single LVDS clock signal. QSGMII uses significantly fewer
    signal lines than four SGMII busses."
    
    This type of MAC <-> PHY connection might require special handling on
    the MAC driver side, so it should be possible to express this type of
    MAC <-> PHY connection, for example in the Device Tree.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: devicetree@vger.kernel.org
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 24126c4b27b5..4d0221fd0688 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -75,6 +75,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_SMII,
 	PHY_INTERFACE_MODE_XGMII,
 	PHY_INTERFACE_MODE_MOCA,
+	PHY_INTERFACE_MODE_QSGMII,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -116,6 +117,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "xgmii";
 	case PHY_INTERFACE_MODE_MOCA:
 		return "moca";
+	case PHY_INTERFACE_MODE_QSGMII:
+		return "qsgmii";
 	default:
 		return "unknown";
 	}

commit 9df81dd7583d14862d0cfb673a941b261f3b2112
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Feb 17 13:34:03 2014 -0800

    net: phy: allow PHY drivers to implement their own software reset
    
    As pointed out by Shaohui, most 10G PHYs out there have a non-standard
    compliant software reset sequence, eventually something much more
    complex than just toggling the BMCR_RESET bit. Allow PHY driver to
    implement their own soft_reset() callback to deal with that. If no
    callback is provided, call into genphy_soft_reset() which makes sure the
    existing behavior is kept intact.
    
    Reported-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bffe0ec1604f..24126c4b27b5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -439,6 +439,11 @@ struct phy_driver {
 	u32 features;
 	u32 flags;
 
+	/*
+	 * Called to issue a PHY software reset
+	 */
+	int (*soft_reset)(struct phy_device *phydev);
+
 	/*
 	 * Called to initialize the PHY,
 	 * including after a reset

commit 797ac07137d9ae8572008e21e6123a9ae17dae50
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Feb 17 13:34:02 2014 -0800

    net: phy: move PHY software reset to genphy_soft_reset
    
    As pointed out by Shaohui, this function is generic for 10/100/1000
    PHYs, but 10G PHYs might have a slightly different reset sequence which
    prevents most of them from using this function.
    
    Move the BMCR_RESET based software resent sequence to
    genphy_soft_reset() in preparation for allowing PHY drivers to implement
    a soft_reset() callback.
    
    Reported-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f7fe54628424..bffe0ec1604f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -666,6 +666,7 @@ int genphy_update_link(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
+int genphy_soft_reset(struct phy_device *phydev);
 void phy_driver_unregister(struct phy_driver *drv);
 void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver);

commit fd70f72c66eeada848abaed9eb6bbdbaf57764e9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Feb 13 16:08:42 2014 -0800

    net: phy: add MoCA PHY type
    
    Some Ethernet MACs are connected to a MoCA PHY which will handle the
    low-level job of sending Ethernet frames on the coaxial cable, these
    Ethernet MACs need to know about it to be properly configured.
    Add a new PHY mode "moca" and update the Device Tree parsing logic to
    look for it.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 42f1bc7eaeb0..f7fe54628424 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -74,6 +74,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_RTBI,
 	PHY_INTERFACE_MODE_SMII,
 	PHY_INTERFACE_MODE_XGMII,
+	PHY_INTERFACE_MODE_MOCA,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -113,6 +114,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "smii";
 	case PHY_INTERFACE_MODE_XGMII:
 		return "xgmii";
+	case PHY_INTERFACE_MODE_MOCA:
+		return "moca";
 	default:
 		return "unknown";
 	}

commit b0ae009f3dc14643e56972cfc08c060dd72cc24d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 11 17:27:41 2014 -0800

    net: phy: add "has_fixups" boolean property
    
    Add a boolean property which indicates if the PHY has had any fixup
    routine ran on it. We are later going to use that boolean to expose it
    as a sysfs property to help troubleshooting.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ef7fa1131145..42f1bc7eaeb0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -350,6 +350,7 @@ struct phy_device {
 	struct phy_c45_device_ids c45_ids;
 	bool is_c45;
 	bool is_internal;
+	bool has_fixups;
 
 	enum phy_state state;
 

commit 8a2fe56e8827f2b1eb1766702f0215074dd2767e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 11 17:27:39 2014 -0800

    net: phy: re-design phy_modes to be self-contained
    
    of_get_phy_mode() uses a local array to map phy_interface_t values from
    include/linux/net/phy.h to a string which is read from the 'phy-mode' or
    'phy-connection-type' property. In preparation for exposing the PHY
    interface mode through sysfs, perform the following:
    
    - mode phy_modes from drivers/of/of_net.c to include/linux/phy.h such
      that it is right below the phy_interface_t enum
    - make it a static inline function returning the string such that we can
      use it by just including include/linux/net/phy.h
    - add a PHY_INTERFACE_MODE_MAX enum value to guard the iteration in
      of_get_phy_mode()
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index eede6579cae7..ef7fa1131145 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -74,8 +74,50 @@ typedef enum {
 	PHY_INTERFACE_MODE_RTBI,
 	PHY_INTERFACE_MODE_SMII,
 	PHY_INTERFACE_MODE_XGMII,
+	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
+/**
+ * It maps 'enum phy_interface_t' found in include/linux/phy.h
+ * into the device tree binding of 'phy-mode', so that Ethernet
+ * device driver can get phy interface from device tree.
+ */
+static inline const char *phy_modes(phy_interface_t interface)
+{
+	switch (interface) {
+	case PHY_INTERFACE_MODE_NA:
+		return "";
+	case PHY_INTERFACE_MODE_MII:
+		return "mii";
+	case PHY_INTERFACE_MODE_GMII:
+		return "gmii";
+	case PHY_INTERFACE_MODE_SGMII:
+		return "sgmii";
+	case PHY_INTERFACE_MODE_TBI:
+		return "tbi";
+	case PHY_INTERFACE_MODE_REVMII:
+		return "rev-mii";
+	case PHY_INTERFACE_MODE_RMII:
+		return "rmii";
+	case PHY_INTERFACE_MODE_RGMII:
+		return "rgmii";
+	case PHY_INTERFACE_MODE_RGMII_ID:
+		return "rgmii-id";
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		return "rgmii-rxid";
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		return "rgmii-txid";
+	case PHY_INTERFACE_MODE_RTBI:
+		return "rtbi";
+	case PHY_INTERFACE_MODE_SMII:
+		return "smii";
+	case PHY_INTERFACE_MODE_XGMII:
+		return "xgmii";
+	default:
+		return "unknown";
+	}
+}
+
 
 #define PHY_INIT_TIMEOUT	100000
 #define PHY_STATE_TIME		1

commit 76a423a3f8f16bfc7fb86360a620be18c775b94d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 11 17:27:37 2014 -0800

    net: phy: allow driver to implement their own aneg_done
    
    Some PHYs out there can be very quirky with respect to how they would
    report the auto-negotiation is completed. Allow drivers to override the
    generic aneg_done() implementation by providing their own.
    
    Since not all drivers have been updated yet to use genphy_aneg_done() as
    aneg_done() callback, we explicitely check that this callback is valid
    before calling into it.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c572842c9029..eede6579cae7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -417,6 +417,9 @@ struct phy_driver {
 	 */
 	int (*config_aneg)(struct phy_device *phydev);
 
+	/* Determines the auto negotiation result */
+	int (*aneg_done)(struct phy_device *phydev);
+
 	/* Determines the negotiated speed and duplex */
 	int (*read_status)(struct phy_device *phydev);
 

commit a9fa6e6ac29709e7a623b60695c172da675df045
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 11 17:27:36 2014 -0800

    net: phy: add genphy_aneg_done()
    
    In preparation for allowing PHY drivers to potentially override their
    auto-negotiation done callback, move the contents of phy_aneg_done() to
    genphy_aneg_done() since that function really is the generic
    implementation based on the BMSR_ANEGCOMPLETE status.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 565188ca328f..c572842c9029 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -612,6 +612,7 @@ static inline int phy_read_status(struct phy_device *phydev)
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
+int genphy_aneg_done(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);

commit 257184d7cc03519e1ea37b421879767b4194ce8c
Author: Andy Fleming <afleming@gmail.com>
Date:   Fri Jan 10 14:27:54 2014 +0800

    phylib: Support attaching to generic 10g driver
    
    phy_attach_direct() may now attach to a generic 10G driver. It can
    also be used exactly as phy_connect_direct(), which will be useful
    when using of_mdio, as phy_connect (and therefore of_phy_connect)
    start the PHY state machine, which is currently irrelevant for 10G
    PHYs.
    
    Signed-off-by: Andy Fleming <afleming@gmail.com>
    Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a9685b109049..565188ca328f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -588,6 +588,8 @@ int phy_resume(struct phy_device *phydev);
 struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 			      phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
+int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
+		      u32 flags, phy_interface_t interface);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 		       void (*handler)(struct net_device *),
 		       phy_interface_t interface);

commit 898dd0bda366edd0b077db4389a26c00509c73c9
Author: Andy Fleming <afleming@gmail.com>
Date:   Fri Jan 10 14:26:46 2014 +0800

    phylib: introduce PHY_INTERFACE_MODE_XGMII for 10G PHY
    
    Signed-off-by: Andy Fleming <afleming@gmail.com>
    Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3eda43c90875..a9685b109049 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -73,6 +73,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_RGMII_TXID,
 	PHY_INTERFACE_MODE_RTBI,
 	PHY_INTERFACE_MODE_SMII,
+	PHY_INTERFACE_MODE_XGMII,
 } phy_interface_t;
 
 

commit efabdfb95ab698b51009e7783ddc2714cef0aecf
Author: Andy Fleming <afleming@gmail.com>
Date:   Fri Jan 10 14:25:09 2014 +0800

    phylib: Add Clause 45 read/write functions
    
    Need an extra parameter to read or write Clause 45 PHYs, so
    need a different API with the extra parameter.
    
    Signed-off-by: Andy Fleming <afleming@gmail.com>
    Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7c81dd8870d4..3eda43c90875 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -487,6 +487,24 @@ struct phy_fixup {
 	int (*run)(struct phy_device *phydev);
 };
 
+/**
+ * phy_read_mmd - Convenience function for reading a register
+ * from an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ *
+ * Same rules as for phy_read();
+ */
+static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
+{
+	if (!phydev->is_c45)
+		return -EOPNOTSUPP;
+
+	return mdiobus_read(phydev->bus, phydev->addr,
+			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
+}
+
 /**
  * phy_read - Convenience function for reading a given PHY register
  * @phydev: the phy_device struct
@@ -537,6 +555,27 @@ static inline bool phy_is_internal(struct phy_device *phydev)
 	return phydev->is_internal;
 }
 
+/**
+ * phy_write_mmd - Convenience function for writing a register
+ * on an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ * @val: value to write to @regnum
+ *
+ * Same rules as for phy_write();
+ */
+static inline int phy_write_mmd(struct phy_device *phydev, int devad,
+				u32 regnum, u16 val)
+{
+	if (!phydev->is_c45)
+		return -EOPNOTSUPP;
+
+	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
+
+	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
+}
+
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);

commit fbfcec635dba38345a446f44b22352cd96ad9463
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jan 5 03:28:27 2014 +0300

    phylib: make phy_scan_fixups() static
    
    phy_scan_fixups()  isn't and shouldn't be called by the drivers directly, so
    unexport it. And since Florian Fainelli's recent patches, the function is only
    called locally, so we can make it static as well.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index cf1bb480cfb1..7c81dd8870d4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -596,7 +596,6 @@ int phy_register_fixup_for_id(const char *bus_id,
 			      int (*run)(struct phy_device *));
 int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
 			       int (*run)(struct phy_device *));
-int phy_scan_fixups(struct phy_device *phydev);
 
 int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);
 int phy_get_eee_err(struct phy_device *phydev);

commit 29935aebc7a8f2d3f9cc1743f24f0db8b4610ece
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jan 5 03:27:17 2014 +0300

    phylib: remove unused adjust_state() callback
    
    Remove adjust_state() callback from 'struct phy_device' since it seems to have
    never been really used from the inception: phy_start_machine() has been always
    called with 2nd argument equal to NULL.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d4cb756a41c5..cf1bb480cfb1 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -282,8 +282,6 @@ struct phy_c45_device_ids {
  * attached_dev: The attached enet driver's device instance ptr
  * adjust_link: Callback for the enet controller to respond to
  * changes in the link state.
- * adjust_state: Callback for the enet driver to respond to
- * changes in the state machine.
  *
  * speed, duplex, pause, supported, advertising, lp_advertising,
  * and autoneg are used like in mii_if_info
@@ -364,8 +362,6 @@ struct phy_device {
 	struct net_device *attached_dev;
 
 	void (*adjust_link)(struct net_device *dev);
-
-	void (*adjust_state)(struct net_device *dev);
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -585,8 +581,7 @@ int phy_drivers_register(struct phy_driver *new_driver, int n);
 void phy_state_machine(struct work_struct *work);
 void phy_change(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev, int new_link);
-void phy_start_machine(struct phy_device *phydev,
-		       void (*handler)(struct net_device *));
+void phy_start_machine(struct phy_device *phydev);
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);

commit 4017b4d3212b7b9d979d7174cbe340c9acbb4666
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Jan 5 03:20:17 2014 +0300

    <linux/phy.h>: coding style fixes
    
    Running 'checkpatch.pl' gives some errors and warnings:
    
    - no spaces around =;
    
    - * separated by space from the function name;
    
    - { in function definition not on a separate line;
    
    - line over 80 characters.
    
    While fixing these, also fix the following style issues:
    
    - file name in the heading comment;
    
    - alignment not matching open paren.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 73384ff3b5e5..d4cb756a41c5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -1,6 +1,4 @@
 /*
- * include/linux/phy.h
- *
  * Framework and drivers for configuring and reading different PHYs
  * Based on code in sungem_phy.c and gianfar_phy.c
  *
@@ -240,7 +238,7 @@ int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
  * - phy_stop moves to HALTED
  */
 enum phy_state {
-	PHY_DOWN=0,
+	PHY_DOWN = 0,
 	PHY_STARTING,
 	PHY_READY,
 	PHY_PENDING,
@@ -544,21 +542,22 @@ static inline bool phy_is_internal(struct phy_device *phydev)
 }
 
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
-		bool is_c45, struct phy_c45_device_ids *c45_ids);
+				     bool is_c45,
+				     struct phy_c45_device_ids *c45_ids);
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);
-struct phy_device * phy_attach(struct net_device *dev,
-		const char *bus_id, phy_interface_t interface);
+struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
+			      phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		void (*handler)(struct net_device *),
-		phy_interface_t interface);
-struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *),
-		phy_interface_t interface);
+		       void (*handler)(struct net_device *),
+		       phy_interface_t interface);
+struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
+			       void (*handler)(struct net_device *),
+			       phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
@@ -567,7 +566,8 @@ int phy_start_aneg(struct phy_device *phydev);
 
 int phy_stop_interrupts(struct phy_device *phydev);
 
-static inline int phy_read_status(struct phy_device *phydev) {
+static inline int phy_read_status(struct phy_device *phydev)
+{
 	return phydev->drv->read_status(phydev);
 }
 
@@ -586,22 +586,21 @@ void phy_state_machine(struct work_struct *work);
 void phy_change(struct work_struct *work);
 void phy_mac_interrupt(struct phy_device *phydev, int new_link);
 void phy_start_machine(struct phy_device *phydev,
-		void (*handler)(struct net_device *));
+		       void (*handler)(struct net_device *));
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
-int phy_mii_ioctl(struct phy_device *phydev,
-		struct ifreq *ifr, int cmd);
+int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 void phy_device_free(struct phy_device *phydev);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
-		int (*run)(struct phy_device *));
+		       int (*run)(struct phy_device *));
 int phy_register_fixup_for_id(const char *bus_id,
-		int (*run)(struct phy_device *));
+			      int (*run)(struct phy_device *));
 int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
-		int (*run)(struct phy_device *));
+			       int (*run)(struct phy_device *));
 int phy_scan_fixups(struct phy_device *phydev);
 
 int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);
@@ -609,7 +608,8 @@ int phy_get_eee_err(struct phy_device *phydev);
 int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);
 int phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);
 int phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
-void phy_ethtool_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
+void phy_ethtool_get_wol(struct phy_device *phydev,
+			 struct ethtool_wolinfo *wol);
 
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);

commit 481b5d938b4a60f052d7e15965a8417125e0d39f
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Fri Dec 13 10:20:27 2013 +0100

    net: phy: provide phy_resume/phy_suspend helpers
    
    This adds helper functions to resume and suspend a given phy_device
    by calling the corresponding driver callbacks if available.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 90a666e0884b..73384ff3b5e5 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -548,6 +548,8 @@ struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);
+int phy_suspend(struct phy_device *phydev);
+int phy_resume(struct phy_device *phydev);
 struct phy_device * phy_attach(struct net_device *dev,
 		const char *bus_id, phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);

commit 114002bc1af6c63de4c003f8c5d3ca0bb430d987
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Dec 6 13:01:30 2013 -0800

    net: phy: report link partner features through ethtool
    
    The PHY library already reads the MII_STAT1000 and MII_LPA registers in
    genphy_read_status(), so extend it to also populate the PHY device link
    partner advertised features such that we can feed this back into ethtool
    when asked for it in phy_ethtool_gset().
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7ff751ae6f0a..90a666e0884b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -287,8 +287,8 @@ struct phy_c45_device_ids {
  * adjust_state: Callback for the enet driver to respond to
  * changes in the state machine.
  *
- * speed, duplex, pause, supported, advertising, and
- * autoneg are used like in mii_if_info
+ * speed, duplex, pause, supported, advertising, lp_advertising,
+ * and autoneg are used like in mii_if_info
  *
  * interrupts currently only supports enabled or disabled,
  * but could be changed in the future to support enabling
@@ -340,6 +340,7 @@ struct phy_device {
 	/* See mii.h for more info */
 	u32 supported;
 	u32 advertising;
+	u32 lp_advertising;
 
 	int autoneg;
 

commit e9fbdf176d2a7993b9d4c487b50c68d1c6019b2c
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Dec 5 14:52:13 2013 -0800

    net: phy: breakdown PHY_*_FEATURES defines
    
    Breakdown the PHY_*_FEATURES into per speed defines such that we can
    easily re-use them individually.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 48a4dc3cb8cf..7ff751ae6f0a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -27,18 +27,27 @@
 
 #include <linux/atomic.h>
 
-#define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
-				 SUPPORTED_10baseT_Full | \
-				 SUPPORTED_100baseT_Half | \
-				 SUPPORTED_100baseT_Full | \
-				 SUPPORTED_Autoneg | \
+#define PHY_DEFAULT_FEATURES	(SUPPORTED_Autoneg | \
 				 SUPPORTED_TP | \
 				 SUPPORTED_MII)
 
-#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \
-				 SUPPORTED_1000baseT_Half | \
+#define PHY_10BT_FEATURES	(SUPPORTED_10baseT_Half | \
+				 SUPPORTED_10baseT_Full)
+
+#define PHY_100BT_FEATURES	(SUPPORTED_100baseT_Half | \
+				 SUPPORTED_100baseT_Full)
+
+#define PHY_1000BT_FEATURES	(SUPPORTED_1000baseT_Half | \
 				 SUPPORTED_1000baseT_Full)
 
+#define PHY_BASIC_FEATURES	(PHY_10BT_FEATURES | \
+				 PHY_100BT_FEATURES | \
+				 PHY_DEFAULT_FEATURES)
+
+#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \
+				 PHY_1000BT_FEATURES)
+
+
 /*
  * Set phydev->irq to PHY_POLL if interrupts are not supported,
  * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if

commit 3fb69bcadda6263b92dbf8dd74717cba27c77ed9
Author: Madalin Bucur <madalin.bucur@freescale.com>
Date:   Wed Nov 20 16:38:19 2013 -0600

    net/phy: Add the autocross feature for forced links on VSC82x4
    
    Add auto-MDI/MDI-X capability for forced (autonegotiation disabled)
    10/100 Mbps speeds on Vitesse VSC82x4 PHYs. Exported previously static
    function genphy_setup_forced() required by the new config_aneg handler
    in the Vitesse PHY module.
    
    Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
    Signed-off-by: Shruti Kanetkar <Shruti@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 64ab823f7b74..48a4dc3cb8cf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -559,6 +559,7 @@ static inline int phy_read_status(struct phy_device *phydev) {
 	return phydev->drv->read_status(phydev);
 }
 
+int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);

commit 2cc70ba4cf5f97a7cf08063d2fae693d36b462eb
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue May 28 04:07:21 2013 +0000

    phy: add reverse MII PHY connection type
    
    The PHY library currently does not know about the the reverse MII
    connection type. Add it to the list of supported PHY modes and update
    of_get_phy_mode() to support it and look for the string "rev-mii".
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ee411b0eef5d..64ab823f7b74 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -58,6 +58,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
 	PHY_INTERFACE_MODE_TBI,
+	PHY_INTERFACE_MODE_REVMII,
 	PHY_INTERFACE_MODE_RMII,
 	PHY_INTERFACE_MODE_RGMII,
 	PHY_INTERFACE_MODE_RGMII_ID,

commit 4284b6a535a9aab33e5f3c37929143508dd2ee60
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu May 23 01:11:12 2013 +0000

    phy: allow drivers to flag a PHY device as internal
    
    libphy currently always reports a PHY as an external transceiver from
    the ethtool output. This is inaccurate, because some drivers should be
    able to tell that a PHY device is an internal transceiver of an Ethernet
    MAC. Add a new flag (PHY_IS_INTERNAL) which can be set by PHY drivers
    just like other flags, and a corresponding helper: phy_is_internal()
    which can be used by networking drivers to query if a given
    PHY device is internal.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index fdfa11542974..ee411b0eef5d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -49,6 +49,7 @@
 
 #define PHY_HAS_INTERRUPT	0x00000001
 #define PHY_HAS_MAGICANEG	0x00000002
+#define PHY_IS_INTERNAL		0x00000004
 
 /* Interface Mode definitions */
 typedef enum {
@@ -261,6 +262,7 @@ struct phy_c45_device_ids {
  * phy_id: UID for this device found during discovery
  * c45_ids: 802.3-c45 Device Identifers if is_c45.
  * is_c45:  Set to true if this phy uses clause 45 addressing.
+ * is_internal: Set to true if this phy is internal to a MAC.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * addr: Bus address of PHY
@@ -298,6 +300,7 @@ struct phy_device {
 
 	struct phy_c45_device_ids c45_ids;
 	bool is_c45;
+	bool is_internal;
 
 	enum phy_state state;
 
@@ -520,6 +523,15 @@ static inline bool phy_interrupt_is_valid(struct phy_device *phydev)
 	return phydev->irq != PHY_POLL && phydev->irq != PHY_IGNORE_INTERRUPT;
 }
 
+/**
+ * phy_is_internal - Convenience function for testing if a PHY is internal
+ * @phydev: the phy_device struct
+ */
+static inline bool phy_is_internal(struct phy_device *phydev)
+{
+	return phydev->is_internal;
+}
+
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 		bool is_c45, struct phy_c45_device_ids *c45_ids);
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);

commit 5ea94e7686a3aa04cc0d01a2d8bd3d0292b3f592
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun May 19 22:53:43 2013 +0000

    phy: add phy_mac_interrupt() to use with PHY_IGNORE_INTERRUPT
    
    There is currently no way for an Ethernet MAC driver servicing PHY link
    interrupts to notify this to the PHY state machine without defining its
    own state machine. Since most drivers are not so special, introduce a
    helper: phy_mac_interrupt() which can be called from a link up/down
    interrupt routine to update the PHY state machine. To avoid code
    duplication some refactoring has been done to expose the workqueue and
    its corresponding callback internally.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 8e4bc8ab692d..fdfa11542974 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -557,6 +557,8 @@ void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver);
 int phy_drivers_register(struct phy_driver *new_driver, int n);
 void phy_state_machine(struct work_struct *work);
+void phy_change(struct work_struct *work);
+void phy_mac_interrupt(struct phy_device *phydev, int new_link);
 void phy_start_machine(struct phy_device *phydev,
 		void (*handler)(struct net_device *));
 void phy_stop_machine(struct phy_device *phydev);

commit 2c7b49212a86f13697281a4dace2cb96aec71d6b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun May 19 22:53:42 2013 +0000

    phy: fix the use of PHY_IGNORE_INTERRUPT
    
    When a PHY device is registered with the special IRQ value
    PHY_IGNORE_INTERRUPT (-2) it will not properly be handled by the PHY
    library:
    
    - it continues to poll its register, while we do not want this
      because such PHY link events or register changes are serviced by an
      Ethernet MAC
    - it will still try to configure PHY interrupts at the PHY level, such
      interrupts do not exist at the PHY but at the MAC level
    - the state machine only handles PHY_POLL, but should also handle
      PHY_IGNORE_INTERRUPT similarly
    
    This patch updates the PHY state machine and initialization paths to
    account for the specific PHY_IGNORE_INTERRUPT. Based on an earlier patch
    by Thomas Petazzoni, and reworked to add the missing bits. Add a helper
    phy_interrupt_is_valid() which specifically tests for a PHY interrupt
    not to be PHY_POLL or PHY_IGNORE_INTERRUPT and use it throughout the
    code.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9e11039dd7a3..8e4bc8ab692d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -508,6 +508,18 @@ static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 }
 
+/**
+ * phy_interrupt_is_valid - Convenience function for testing a given PHY irq
+ * @phydev: the phy_device struct
+ *
+ * NOTE: must be kept in sync with addition/removal of PHY_POLL and
+ * PHY_IGNORE_INTERRUPT
+ */
+static inline bool phy_interrupt_is_valid(struct phy_device *phydev)
+{
+	return phydev->irq != PHY_POLL && phydev->irq != PHY_IGNORE_INTERRUPT;
+}
+
 struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
 		bool is_c45, struct phy_c45_device_ids *c45_ids);
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);

commit 42e836eb4527fb635cb799a701fe4c9fe741c03a
Author: Michael Stapelberg <michael@stapelberg.de>
Date:   Mon Mar 11 13:56:44 2013 +0000

    phy: add set_wol/get_wol functions
    
    This allows ethernet drivers (such as the mv643xx_eth) to support
    Wake on LAN on platforms where PHY registers have to be configured
    for Wake on LAN (e.g. the Marvell Kirkwood based qnap TS-119P II).
    
    Signed-off-by: Michael Stapelberg <michael@stapelberg.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 33999adbf8c8..9e11039dd7a3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -455,6 +455,14 @@ struct phy_driver {
 	 */
 	void (*txtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
 
+	/* Some devices (e.g. qnap TS-119P II) require PHY register changes to
+	 * enable Wake on LAN, so set_wol is provided to be called in the
+	 * ethernet driver's set_wol function. */
+	int (*set_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
+
+	/* See set_wol, but for checking whether Wake on LAN is enabled. */
+	void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)
@@ -560,6 +568,8 @@ int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);
 int phy_get_eee_err(struct phy_device *phydev);
 int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);
 int phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);
+int phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
+void phy_ethtool_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol);
 
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);

commit f9a8f83b04e0c362a2fc660dbad980d24af209fc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Mon Jan 14 00:52:52 2013 +0000

    net: phy: remove flags argument from phy_{attach, connect, connect_direct}
    
    The flags argument of the phy_{attach,connect,connect_direct} functions
    is then used to assign a struct phy_device dev_flags with its value.
    All callers but the tg3 driver pass the flag 0, which results in the
    underlying PHY drivers in drivers/net/phy/ not being able to actually
    use any of the flags they would set in dev_flags. This patch gets rid of
    the flags argument, and passes phydev->dev_flags to the internal PHY
    library call phy_attach_direct() such that drivers which actually modify
    a phy device dev_flags get the value preserved for use by the underlying
    phy driver.
    
    Acked-by: Kosta Zertsekel <konszert@marvell.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 93b3cf77f564..33999adbf8c8 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -506,13 +506,13 @@ struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);
 struct phy_device * phy_attach(struct net_device *dev,
-		const char *bus_id, u32 flags, phy_interface_t interface);
+		const char *bus_id, phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		void (*handler)(struct net_device *), u32 flags,
+		void (*handler)(struct net_device *),
 		phy_interface_t interface);
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *), u32 flags,
+		void (*handler)(struct net_device *),
 		phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);

commit d5bf9071e71a4db85a0eea6236ef94a29fc3eec9
Author: Christian Hohnstaedt <chohnstaedt@innominate.com>
Date:   Wed Jul 4 05:44:34 2012 +0000

    phylib: Support registering a bunch of drivers
    
    If registering of one of them fails, all already registered drivers
    of this module will be unregistered.
    
    Use the new register/unregister functions in all drivers
    registering more than one driver.
    
    amd.c, realtek.c: Simplify: directly return registration result.
    
    Tested with broadcom.c
    All others compile-tested.
    
    Signed-off-by: Christian Hohnstaedt <chohnstaedt@innominate.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c35299e4da8e..93b3cf77f564 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -533,7 +533,9 @@ int genphy_read_status(struct phy_device *phydev);
 int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
 void phy_driver_unregister(struct phy_driver *drv);
+void phy_drivers_unregister(struct phy_driver *drv, int n);
 int phy_driver_register(struct phy_driver *new_driver);
+int phy_drivers_register(struct phy_driver *new_driver, int n);
 void phy_state_machine(struct work_struct *work);
 void phy_start_machine(struct phy_device *phydev,
 		void (*handler)(struct net_device *));

commit a59a4d1921664da63d801ba477950114c71c88c9
Author: Giuseppe CAVALLARO <peppe.cavallaro@st.com>
Date:   Wed Jun 27 21:14:38 2012 +0000

    phy: add the EEE support and the way to access to the MMD registers.
    
    This patch adds the support for the Energy-Efficient Ethernet (EEE)
    to the Physical Abstraction Layer.
    To support the EEE we have to access to the MMD registers 3.20 and
    7.60/61. So two new functions have been added to read/write the MMD
    registers (clause 45).
    
    An Ethernet driver (I tested the stmmac) can invoke the phy_init_eee to properly
    check if the EEE is supported by the PHYs and it can also set the clock
    stop enable bit in the 3.0 register.
    The phy_get_eee_err can be used for reporting the number of time where
    the PHY failed to complete its normal wake sequence.
    
    In the end, this patch also adds the EEE ethtool support implementing:
     o phy_ethtool_set_eee
     o phy_ethtool_get_eee
    
    v1: initial patch
    v2: fixed some errors especially on naming convention
    v3: renamed again the mmd read/write functions thank to Ben's feedback
    v4: moved file to phy.c and added the ethtool support.
    v5: fixed phy_adv_to_eee, phy_eee_to_supported, phy_eee_to_adv return
        values according to ethtool API (thanks to Ben's feedback).
        Renamed some macros to avoid too long names.
    v6: fixed kernel-doc comments to be properly parsed.
        Fixed the phy_init_eee function: we need to check which link mode
        was autonegotiated and then the corresponding bits in 7.60 and 7.61
        registers.
    v7: reviewed the way to get the negotiated settings.
    v8: fixed a problem in the phy_init_eee return value erroneously added
        when included the phy_read_status call.
    v9: do not remove the MDIO_AN_EEE_ADV_100TX and MDIO_AN_EEE_ADV_1000T
        and fixed the eee_{cap,lp,adv} declaration as "int" instead of u16.
    
    Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Reviewed-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7eac80a2557b..c35299e4da8e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -554,6 +554,11 @@ int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
 		int (*run)(struct phy_device *));
 int phy_scan_fixups(struct phy_device *phydev);
 
+int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable);
+int phy_get_eee_err(struct phy_device *phydev);
+int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data);
+int phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data);
+
 int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
 

commit a30e2c1891296b5ee8de48430a07fdf8b818c661
Author: David Daney <david.daney@cavium.com>
Date:   Wed Jun 27 07:33:37 2012 +0000

    netdev/phy/of: Add more methods for binding PHY devices to drivers.
    
    Allow PHY drivers to supply their own device matching function
    (match_phy_device()), or to be matched OF compatible properties.
    
    PHYs following IEEE802.3 clause 45 have more than one device
    identifier constants, which breaks the default device matching code.
    Other 10G PHYs don't follow the standard manufacturer/device
    identifier register layout standards, but they do use the standard
    MDIO bus protocols for register access.  Both of these require
    adjustments to the PHY driver to device matching code.
    
    If the there is an of_node associated with such a PHY, we can match it
    to its driver using the "compatible" properties, just as we do with
    certain platform devices.  If the "compatible" property match fails,
    first check if there is a driver supplied matching function, and if
    not fall back to the existing identifier matching rules.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 597d05dd0fb4..7eac80a2557b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -426,6 +426,12 @@ struct phy_driver {
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 
+	/* Returns true if this is a suitable driver for the given
+	 * phydev.  If NULL, matching is based on phy_id and
+	 * phy_id_mask.
+	 */
+	int (*match_phy_device)(struct phy_device *phydev);
+
 	/* Handles ethtool queries for hardware time stamping. */
 	int (*ts_info)(struct phy_device *phydev, struct ethtool_ts_info *ti);
 

commit ac28b9f8cd66d6bc54f8063df59e99abd62173a4
Author: David Daney <david.daney@cavium.com>
Date:   Wed Jun 27 07:33:35 2012 +0000

    netdev/phy: Handle IEEE802.3 clause 45 Ethernet PHYs
    
    The IEEE802.3 clause 45 MDIO bus protocol allows for directly
    addressing PHY registers using a 21 bit address, and is used by many
    10G Ethernet PHYS.  Already existing is the ability of MDIO bus
    drivers to use clause 45, with the MII_ADDR_C45 flag.  Here we add
    struct phy_c45_device_ids to hold the device identifier registers
    present in clause 45. struct phy_device gets a couple of new fields:
    c45_ids to hold the identifiers and is_c45 to signal that it is clause
    45.
    
    get_phy_device() gets a new parameter is_c45 to indicate that the PHY
    device should use the clause 45 protocol, and its callers are adjusted
    to pass false.  The follow-on patch to of_mdio.c will pass true where
    appropriate.
    
    EXPORT phy_device_create() so that the follow-on patch to of_mdio.c
    can use it to create phy devices for PHYs, that have non-standard
    device identifier registers, based on the device tree bindings.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c291cae8ce32..597d05dd0fb4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -243,6 +243,15 @@ enum phy_state {
 	PHY_RESUMING
 };
 
+/**
+ * struct phy_c45_device_ids - 802.3-c45 Device Identifiers
+ * @devices_in_package: Bit vector of devices present.
+ * @device_ids: The device identifer for each present device.
+ */
+struct phy_c45_device_ids {
+	u32 devices_in_package;
+	u32 device_ids[8];
+};
 
 /* phy_device: An instance of a PHY
  *
@@ -250,6 +259,8 @@ enum phy_state {
  * bus: Pointer to the bus this PHY is on
  * dev: driver model device structure for this PHY
  * phy_id: UID for this device found during discovery
+ * c45_ids: 802.3-c45 Device Identifers if is_c45.
+ * is_c45:  Set to true if this phy uses clause 45 addressing.
  * state: state of the PHY for management purposes
  * dev_flags: Device-specific flags used by the PHY driver.
  * addr: Bus address of PHY
@@ -285,6 +296,9 @@ struct phy_device {
 
 	u32 phy_id;
 
+	struct phy_c45_device_ids c45_ids;
+	bool is_c45;
+
 	enum phy_state state;
 
 	u32 dev_flags;
@@ -480,7 +494,9 @@ static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 }
 
-struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
+struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
+		bool is_c45, struct phy_c45_device_ids *c45_ids);
+struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);
 struct phy_device * phy_attach(struct net_device *dev,

commit 82251de2a2b7b84987dde104d48a765b63170149
Author: David Daney <david.daney@cavium.com>
Date:   Tue May 15 10:46:52 2012 +0000

    netdev/phy: Make get_phy_id() static and quit EXPORTing it.
    
    This function is only referenced from within phy_device.c, so there is
    no reason to export it.  In fact, we can make it static.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f092032f1c98..c291cae8ce32 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -480,7 +480,6 @@ static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 }
 
-int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_device_register(struct phy_device *phy);
 int phy_init_hw(struct phy_device *phydev);

commit c8f3a8c31069137fe0100e6920558f1a7487ef3c
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Tue Apr 3 22:59:17 2012 +0000

    ethtool: Introduce a method for getting time stamping capabilities.
    
    This commit adds a new ethtool ioctl that exposes the SO_TIMESTAMPING
    capabilities of a network interface. In addition, user space programs
    can use this ioctl to discover the PTP Hardware Clock (PHC) device
    associated with the interface.
    
    Since software receive time stamps are handled by the stack, the generic
    ethtool code can answer the query correctly in case the MAC or PHY
    drivers lack special time stamping features.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Reviewed-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6fe0a37d4abf..f092032f1c98 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -412,6 +412,9 @@ struct phy_driver {
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 
+	/* Handles ethtool queries for hardware time stamping. */
+	int (*ts_info)(struct phy_device *phydev, struct ethtool_ts_info *ti);
+
 	/* Handles SIOCSHWTSTAMP ioctl for hardware time stamping. */
 	int  (*hwtstamp)(struct phy_device *phydev, struct ifreq *ifr);
 

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c599f7eca1e7..6fe0a37d4abf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -19,7 +19,6 @@
 #define __PHY_H
 
 #include <linux/spinlock.h>
-#include <linux/device.h>
 #include <linux/ethtool.h>
 #include <linux/mii.h>
 #include <linux/timer.h>
@@ -88,6 +87,9 @@ typedef enum {
    IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
 #define MII_ADDR_C45 (1<<30)
 
+struct device;
+struct sk_buff;
+
 /*
  * The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure
@@ -241,7 +243,6 @@ enum phy_state {
 	PHY_RESUMING
 };
 
-struct sk_buff;
 
 /* phy_device: An instance of a PHY
  *

commit eb8a54a78e974e1af3e17fa38bb74d3747c5c1bd
Author: Timur Tabi <timur@freescale.com>
Date:   Thu Jan 12 15:23:04 2012 -0800

    phylib: introduce mdiobus_alloc_size()
    
    Introduce function mdiobus_alloc_size() as an alternative to mdiobus_alloc().
    Most callers of mdiobus_alloc() also allocate a private data structure, and
    then manually point bus->priv to this object.  mdiobus_alloc_size()
    combines the two operations into one, which simplifies memory management.
    
    The original mdiobus_alloc() now just calls mdiobus_alloc_size(0).
    
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 79f337c47388..c599f7eca1e7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -129,7 +129,12 @@ struct mii_bus {
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 
-struct mii_bus *mdiobus_alloc(void);
+struct mii_bus *mdiobus_alloc_size(size_t);
+static inline struct mii_bus *mdiobus_alloc(void)
+{
+	return mdiobus_alloc_size(0);
+}
+
 int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);

commit da92b194cc36b5dc1fbd85206aeeffd80bee0c39
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri Oct 21 00:49:15 2011 +0000

    net: hold sock reference while processing tx timestamps
    
    The pair of functions,
    
     * skb_clone_tx_timestamp()
     * skb_complete_tx_timestamp()
    
    were designed to allow timestamping in PHY devices. The first
    function, called during the MAC driver's hard_xmit method, identifies
    PTP protocol packets, clones them, and gives them to the PHY device
    driver. The PHY driver may hold onto the packet and deliver it at a
    later time using the second function, which adds the packet to the
    socket's error queue.
    
    As pointed out by Johannes, nothing prevents the socket from
    disappearing while the cloned packet is sitting in the PHY driver
    awaiting a timestamp. This patch fixes the issue by taking a reference
    on the socket for each such packet. In addition, the comments
    regarding the usage of these function are expanded to highlight the
    rule that PHY drivers must use skb_complete_tx_timestamp() to release
    the packet, in order to release the socket reference, too.
    
    These functions first appeared in v2.6.36.
    
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 54fc4138955f..79f337c47388 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -420,7 +420,7 @@ struct phy_driver {
 
 	/*
 	 * Requests a Tx timestamp for 'skb'. The phy driver promises
-	 * to deliver it to the socket's error queue as soon as a
+	 * to deliver it using skb_complete_tx_timestamp() as soon as a
 	 * timestamp becomes available. One of the PTP_CLASS_ values
 	 * is passed in 'type'.
 	 */

commit 4157ef1b8779b34581ee8b9dc8f7f95188008eca
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Jul 5 16:42:09 2011 +0800

    net: ibm_newemac: convert it to use of_get_phy_mode
    
    The patch extends 'enum phy_interface_t' and of_get_phy_mode a little
    bit with PHY_INTERFACE_MODE_NA and PHY_INTERFACE_MODE_SMII added,
    and then converts ibm_newemac net driver to use of_get_phy_mode
    getting phy mode from device tree.
    
    It also resolves the namespace conflict on phy_read/write between
    common mdiobus interface and ibm_newemac private one.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ad5186354d92..54fc4138955f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -53,6 +53,7 @@
 
 /* Interface Mode definitions */
 typedef enum {
+	PHY_INTERFACE_MODE_NA,
 	PHY_INTERFACE_MODE_MII,
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
@@ -62,7 +63,8 @@ typedef enum {
 	PHY_INTERFACE_MODE_RGMII_ID,
 	PHY_INTERFACE_MODE_RGMII_RXID,
 	PHY_INTERFACE_MODE_RGMII_TXID,
-	PHY_INTERFACE_MODE_RTBI
+	PHY_INTERFACE_MODE_RTBI,
+	PHY_INTERFACE_MODE_SMII,
 } phy_interface_t;
 
 

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7da5fa845959..ad5186354d92 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -26,7 +26,7 @@
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
 
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 #define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
 				 SUPPORTED_10baseT_Full | \

commit 89ff05ec553f3e70b8773c501da01bf7ad952cab
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Thu Oct 21 08:37:41 2010 +0000

    phylib: make local function static
    
    The following functions are not used directly by any drivers:
        phy_attach_direct
        phy_device_create
        phy_prepare_link
        genphy_config_advert
        genphy_setup_forced
        phy_config_interrupt
        phy_clear_interrypt
        phy_sanitize_settings
        phy_enable_interrupts
        phy_disable_interrupts
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index a6e047a04f79..7da5fa845959 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -472,11 +472,7 @@ static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_device_register(struct phy_device *phy);
-int phy_clear_interrupt(struct phy_device *phydev);
-int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
 int phy_init_hw(struct phy_device *phydev);
-int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
-		u32 flags, phy_interface_t interface);
 struct phy_device * phy_attach(struct net_device *dev,
 		const char *bus_id, u32 flags, phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
@@ -492,17 +488,12 @@ void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
 
-void phy_sanitize_settings(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
-int phy_enable_interrupts(struct phy_device *phydev);
-int phy_disable_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev) {
 	return phydev->drv->read_status(phydev);
 }
 
-int genphy_config_advert(struct phy_device *phydev);
-int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
@@ -511,8 +502,6 @@ int genphy_suspend(struct phy_device *phydev);
 int genphy_resume(struct phy_device *phydev);
 void phy_driver_unregister(struct phy_driver *drv);
 int phy_driver_register(struct phy_driver *new_driver);
-void phy_prepare_link(struct phy_device *phydev,
-		void (*adjust_link)(struct net_device *));
 void phy_state_machine(struct work_struct *work);
 void phy_start_machine(struct phy_device *phydev,
 		void (*handler)(struct net_device *));
@@ -523,7 +512,6 @@ int phy_mii_ioctl(struct phy_device *phydev,
 		struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
-struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id);
 void phy_device_free(struct phy_device *phydev);
 
 int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,

commit c68839963426d42bdb2c915b435f9860d060e645
Author: Peter Meerwald <pmeerw@pmeerw.net>
Date:   Thu Sep 2 04:06:24 2010 +0000

    net: Improve comments in include/linux/phy.h
    
    Correct state range of PHY bus addresses (i.e. 0-31) in comment,
    make spelling of PHY consistent in comments.
    
    Signed-off-by: Peter Meerwald <pmeerw@pmeerw.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6b0a782c6224..a6e047a04f79 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -116,7 +116,7 @@ struct mii_bus {
 	/* list of all PHYs on bus */
 	struct phy_device *phy_map[PHY_MAX_ADDR];
 
-	/* Phy addresses to be ignored when probing */
+	/* PHY addresses to be ignored when probing */
 	u32 phy_mask;
 
 	/*
@@ -283,7 +283,7 @@ struct phy_device {
 
 	phy_interface_t interface;
 
-	/* Bus address of the PHY (0-32) */
+	/* Bus address of the PHY (0-31) */
 	int addr;
 
 	/*

commit c1f19b51d1d87f3e3bb7e6648f43f7d57ed2da6b
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sat Jul 17 08:49:36 2010 +0000

    net: support time stamping in phy devices.
    
    This patch adds a new networking option to allow hardware time stamps
    from PHY devices. When enabled, likely candidates among incoming and
    outgoing network packets are offered to the PHY driver for possible
    time stamping. When accepted by the PHY driver, incoming packets are
    deferred for later delivery by the driver.
    
    The patch also adds phylib driver methods for the SIOCSHWTSTAMP ioctl
    and callbacks for transmit and receive time stamping. Drivers may
    optionally implement these functions.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d63736a84002..6b0a782c6224 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -234,6 +234,8 @@ enum phy_state {
 	PHY_RESUMING
 };
 
+struct sk_buff;
+
 /* phy_device: An instance of a PHY
  *
  * drv: Pointer to the driver for this PHY instance
@@ -402,6 +404,26 @@ struct phy_driver {
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 
+	/* Handles SIOCSHWTSTAMP ioctl for hardware time stamping. */
+	int  (*hwtstamp)(struct phy_device *phydev, struct ifreq *ifr);
+
+	/*
+	 * Requests a Rx timestamp for 'skb'. If the skb is accepted,
+	 * the phy driver promises to deliver it using netif_rx() as
+	 * soon as a timestamp becomes available. One of the
+	 * PTP_CLASS_ values is passed in 'type'. The function must
+	 * return true if the skb is accepted for delivery.
+	 */
+	bool (*rxtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
+
+	/*
+	 * Requests a Tx timestamp for 'skb'. The phy driver promises
+	 * to deliver it to the socket's error queue as soon as a
+	 * timestamp becomes available. One of the PTP_CLASS_ values
+	 * is passed in 'type'.
+	 */
+	void (*txtstamp)(struct phy_device *dev, struct sk_buff *skb, int type);
+
 	struct device_driver driver;
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)

commit 28b041139e344ecd0f144d6205b004ae354cfa1e
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Sat Jul 17 08:48:55 2010 +0000

    net: preserve ifreq parameter when calling generic phy_mii_ioctl().
    
    The phy_mii_ioctl() function unnecessarily throws away the original ifreq.
    We need access to the ifreq in order to support PHYs that can perform
    hardware time stamping.
    
    Two maverick drivers filter the ioctl commands passed to phy_mii_ioctl().
    This is unnecessary since phylib will check the command in any case.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 987e111f7b11..d63736a84002 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -498,7 +498,7 @@ void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_mii_ioctl(struct phy_device *phydev,
-		struct mii_ioctl_data *mii_data, int cmd);
+		struct ifreq *ifr, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id);

commit 8626d3b4328061f5b82b11ae1d6918a0c3602f42
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Fri Apr 2 01:05:27 2010 +0000

    phylib: Support phy module autoloading
    
    We don't use the normal hotplug mechanism because it doesn't work. It will
    load the module some time after the device appears, but that's not good
    enough for us -- we need the driver loaded _immediately_ because otherwise
    the NIC driver may just abort and then the phy 'device' goes away.
    
    [bwh: s/phy/mdio/ in module alias, kerneldoc for struct mdio_device_id]
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d9bce4b526b4..987e111f7b11 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -24,6 +24,7 @@
 #include <linux/mii.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
+#include <linux/mod_devicetable.h>
 
 #include <asm/atomic.h>
 

commit abf35df21513c51d7761c41fa6d3b819cdf4103e
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Tue Mar 9 09:17:42 2010 +0000

    NET: Support clause 45 MDIO commands at the MDIO bus level
    
    IEEE 802.3ae clause 45 specifies a somewhat modified MDIO protocol
    for use by 10GIGE phys. The main change is a 21 bit address split into
    a 5 bit device ID and a 16 bit register offset. The definition is designed
    so that normal and extended devices can run on the same MDIO bus.
    
    Extend mdio-bitbang to do the new protocol. At the MDIO bus level the
    protocol is requested by or'ing MII_ADDR_C45 into the register offset.
    
    Make phy_read/phy_write/etc pass a full 32 bit register offset.
    
    This does not attempt to make the phy layer support C45 style PHYs, just
    to provide the MDIO bus support.
    
    Tested against a Broadcom 10GE phy with ID 0x206034, and several
    Broadcom 10/100/1000 Phys in normal mode.
    
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 14d7fdf6a90a..d9bce4b526b4 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -81,6 +81,10 @@ typedef enum {
  */
 #define MII_BUS_ID_SIZE	(20 - 3)
 
+/* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit
+   IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
+#define MII_ADDR_C45 (1<<30)
+
 /*
  * The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure
@@ -127,8 +131,8 @@ int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
 void mdiobus_free(struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
-int mdiobus_read(struct mii_bus *bus, int addr, u16 regnum);
-int mdiobus_write(struct mii_bus *bus, int addr, u16 regnum, u16 val);
+int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
+int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
 
 
 #define PHY_INTERRUPT_DISABLED	0x0
@@ -422,7 +426,7 @@ struct phy_fixup {
  * because the bus read/write functions may wait for an interrupt
  * to conclude the operation.
  */
-static inline int phy_read(struct phy_device *phydev, u16 regnum)
+static inline int phy_read(struct phy_device *phydev, u32 regnum)
 {
 	return mdiobus_read(phydev->bus, phydev->addr, regnum);
 }
@@ -437,7 +441,7 @@ static inline int phy_read(struct phy_device *phydev, u16 regnum)
  * because the bus read/write functions may wait for an interrupt
  * to conclude the operation.
  */
-static inline int phy_write(struct phy_device *phydev, u16 regnum, u16 val)
+static inline int phy_write(struct phy_device *phydev, u32 regnum, u16 val)
 {
 	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 }

commit f8f76db1db369f3a130ac3fd33e2eee5f1610d9c
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Thu Feb 4 10:23:02 2010 -0800

    libphy: add phy_find_first function
    
    Many drivers do this in them manually. Now they can use this function.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6a7eb402165d..14d7fdf6a90a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -452,6 +452,7 @@ int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
 		u32 flags, phy_interface_t interface);
 struct phy_device * phy_attach(struct net_device *dev,
 		const char *bus_id, u32 flags, phy_interface_t interface);
+struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface);

commit 4f9c85a1b03bfa5c0a0d8488a3a7766f3c9fb756
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Mon Jan 18 05:37:16 2010 +0000

    phylib: Move workqueue initialization to a proper place
    
    commit 541cd3ee00a4fe975b22fac6a3bc846bacef37f7 ("phylib: Fix deadlock
    on resume") caused TI DaVinci EMAC ethernet driver to oops upon resume:
    
     PM: resume of devices complete after 237.098 msecs
     Restarting tasks ... done.
     kernel BUG at kernel/workqueue.c:354!
     Unable to handle kernel NULL pointer dereference at virtual address 00000000
     [...]
     Backtrace:
     [<c002c598>] (__bug+0x0/0x2c) from [<c0052a54>] (queue_delayed_work_on+0x74/0xf8)
     [<c00529e0>] (queue_delayed_work_on+0x0/0xf8) from [<c0052b30>] (queue_delayed_work+0x2c/0x30)
    
    The oops pops up because TI DaVinci EMAC driver detaches PHY on
    suspend and attaches it back on resume. Attaching makes phylib call
    phy_start_machine() that initializes a workqueue. On the other hand,
    PHY's resume routine will call phy_start_machine() again, and that
    will cause the oops since we just destroyed the already scheduled
    workqueue.
    
    This patch fixes the issue by moving workqueue initialization to
    phy_device_create().
    
    p.s. We don't see this oops with ucc_geth and gianfar drivers because
    they perform a fine-grained suspend, i.e. they just stop the PHYs
    without detaching.
    
    Reported-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Tested-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7968defd2fa7..6a7eb402165d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -485,6 +485,7 @@ void phy_driver_unregister(struct phy_driver *drv);
 int phy_driver_register(struct phy_driver *new_driver);
 void phy_prepare_link(struct phy_device *phydev,
 		void (*adjust_link)(struct net_device *));
+void phy_state_machine(struct work_struct *work);
 void phy_start_machine(struct phy_device *phydev,
 		void (*handler)(struct net_device *));
 void phy_stop_machine(struct phy_device *phydev);

commit 2f5cb43406d0b29b96248f5328a14a6f6abf8ae6
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Wed Dec 30 08:23:30 2009 +0000

    phylib: Properly reinitialize PHYs after hibernation
    
    Since hibernation assumes power loss, we should fully reinitialize
    PHYs (including platform fixups), as if PHYs were just attached.
    
    This patch factors phy_init_hw() out of phy_attach_direct(), then
    converts mdio_bus to dev_pm_ops and adds an appropriate restore()
    callback.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index b1368b8f6572..7968defd2fa7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -447,6 +447,7 @@ struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_device_register(struct phy_device *phy);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
+int phy_init_hw(struct phy_device *phydev);
 int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
 		u32 flags, phy_interface_t interface);
 struct phy_device * phy_attach(struct net_device *dev,

commit 8e401eccd3a62fb57f117bb09b7c1fc70ab19e8c
Author: David S. Miller <davem@davemloft.net>
Date:   Tue May 26 21:16:25 2009 -0700

    phy: Eliminate references to BUS_ID_SIZE.
    
    Just use the constant 20 to keep things working.
    
    If someone is so motivated, this can be converted over to
    dynamic strings.  I tried and it's a lot of work.
    
    But for now this is good enough.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index c216e4e503b3..b1368b8f6572 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -79,7 +79,7 @@ typedef enum {
  * Need to be a little smaller than phydev->dev.bus_id to leave room
  * for the ":%02x"
  */
-#define MII_BUS_ID_SIZE	(BUS_ID_SIZE - 3)
+#define MII_BUS_ID_SIZE	(20 - 3)
 
 /*
  * The Bus class for PHYs.  Devices which provide access to
@@ -407,7 +407,7 @@ struct phy_driver {
 /* A Structure for boards to register fixups with the PHY Lib */
 struct phy_fixup {
 	struct list_head list;
-	char bus_id[BUS_ID_SIZE];
+	char bus_id[20];
 	u32 phy_uid;
 	u32 phy_uid_mask;
 	int (*run)(struct phy_device *phydev);

commit fa94f6d93c5382810ff41f010f12ca8698fc775e
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 25 12:52:51 2009 +0000

    phylib: add *_direct() variants of phy_connect and phy_attach functions
    
    Add phy_connect_direct() and phy_attach_direct() functions so that
    drivers can use a pointer to the phy_device instead of trying to determine
    the phy's bus_id string.
    
    This patch is useful for OF device tree descriptions of phy devices where
    the driver doesn't need or know what the bus_id value in order to get a
    phy_device pointer.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index bf0b5f112dc7..c216e4e503b3 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -447,8 +447,13 @@ struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_device_register(struct phy_device *phy);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
+int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
+		u32 flags, phy_interface_t interface);
 struct phy_device * phy_attach(struct net_device *dev,
 		const char *bus_id, u32 flags, phy_interface_t interface);
+int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+		void (*handler)(struct net_device *), u32 flags,
+		phy_interface_t interface);
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
 		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface);

commit 4dea547fef1ba23f9d23f5e7f5218187a7dcf1b3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 25 12:52:46 2009 +0000

    phylib: rework to prepare for OF registration of PHYs
    
    This patch makes changes in preparation for supporting open firmware
    device tree descriptions of MDIO busses.  Changes include:
    - Cleanup handling of phy_map[] entries; they are already NULLed when
      registering and so don't need to be re-cleared, and it is good practice
      to clear them out when unregistering.
    - Split phy_device registration out into a new function so that the
      OF helpers can do two stage registration (separate allocation and
      registration steps).
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 97e40cb6b588..bf0b5f112dc7 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -444,6 +444,7 @@ static inline int phy_write(struct phy_device *phydev, u16 regnum, u16 val)
 
 int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
+int phy_device_register(struct phy_device *phy);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
 struct phy_device * phy_attach(struct net_device *dev,

commit a8729eb302a5b5da8b0b4d29582c42648a2e0f12
Author: Anatolij Gustschin <agust@denx.de>
Date:   Tue Apr 7 02:01:42 2009 +0000

    phylib: Allow early-out in phy_change
    
    Marvell 88E1121R Dual PHY device can be hardware-configured
    to use shared interrupt pin for both PHY ports. For such
    PHY configurations using shared PHY interrupt phy_interrupt()
    handler will also schedule a work for PHY port which didn't
    cause an interrupt.
    
    This patch adds a possibility for PHY drivers to provide
    did_interrupt() function which reports if the PHY (or a PHY
    port in a multi-PHY device) generated an interrupt. This
    function is called in phy_change() as phy_change() shouldn't
    proceed if it is invoked for a PHY which didn't cause an
    interrupt. So check for interrupt originator in phy_change()
    to allow early-out.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 32cf14a4b034..97e40cb6b588 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -388,6 +388,12 @@ struct phy_driver {
 	/* Enables or disables interrupts */
 	int (*config_intr)(struct phy_device *phydev);
 
+	/*
+	 * Checks if the PHY generated an interrupt.
+	 * For multi-PHY devices with shared PHY interrupt pin
+	 */
+	int (*did_interrupt)(struct phy_device *phydev);
+
 	/* Clears up any memory if needed */
 	void (*remove)(struct phy_device *phydev);
 

commit a390d1f379cf821248b735f43d2e1147ebb8241d
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Fri Mar 13 15:41:19 2009 -0700

    phylib: convert state_queue work to delayed_work
    
    It closes a race in phy_stop_machine when reprogramming of phy_timer
    (from phy_state_machine) happens between del_timer_sync and cancel_work_sync.
    
    Without this change it could lead to crash if phy_device would be freed after
    phy_stop_machine (timer would fire and schedule freed work).
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index d7e54d98869f..32cf14a4b034 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -315,8 +315,7 @@ struct phy_device {
 
 	/* Interrupt and Polling infrastructure */
 	struct work_struct phy_queue;
-	struct work_struct state_queue;
-	struct timer_list phy_timer;
+	struct delayed_work state_queue;
 	atomic_t irq_disable;
 
 	struct mutex lock;

commit 0f0ca340e57bd7446855fefd07a64249acf81223
Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
Date:   Fri Nov 28 16:24:56 2008 -0800

    phy: power management support
    
    This patch adds the power management support into the physical
    abstraction layer.
    
    Suspend and resume functions respectively turns on/off the bit 11
    into the PHY Basic mode control register.
    Generic PHY device starts supporting PM.
    
    In order to support the wake-on LAN and avoid to put in power down
    the PHY device, the MDIO is aware of what the Ethernet device wants to do.
    
    Voluntary, no CONFIG_PM defines were added into the sources.
    Also generic suspend/resume functions are exported to allow
    other drivers use them (such as genphy_config_aneg etc.).
    
    Within the phy_driver_register function, we need to remove the
    memset. It overrides the device driver owner and it is not good.
    
    Signed-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 77c4ed60b982..d7e54d98869f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -467,6 +467,8 @@ int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
 int genphy_update_link(struct phy_device *phydev);
 int genphy_read_status(struct phy_device *phydev);
+int genphy_suspend(struct phy_device *phydev);
+int genphy_resume(struct phy_device *phydev);
 void phy_driver_unregister(struct phy_driver *drv);
 int phy_driver_register(struct phy_driver *new_driver);
 void phy_prepare_link(struct phy_device *phydev,

commit 2e888103295f47b8fcbf7e9bb8c5da97dd2ecd76
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Sep 29 17:12:35 2008 +0000

    phylib: add mdiobus_{read,write}
    
    Add mdiobus_{read,write} routines to allow direct reading/writing
    of registers on an mii bus without having to go through the PHY
    abstraction, and make phy_{read,write} use these primitives.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 891f27f9137e..77c4ed60b982 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -122,6 +122,15 @@ struct mii_bus {
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 
+struct mii_bus *mdiobus_alloc(void);
+int mdiobus_register(struct mii_bus *bus);
+void mdiobus_unregister(struct mii_bus *bus);
+void mdiobus_free(struct mii_bus *bus);
+struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
+int mdiobus_read(struct mii_bus *bus, int addr, u16 regnum);
+int mdiobus_write(struct mii_bus *bus, int addr, u16 regnum, u16 val);
+
+
 #define PHY_INTERRUPT_DISABLED	0x0
 #define PHY_INTERRUPT_ENABLED	0x80000000
 
@@ -399,8 +408,35 @@ struct phy_fixup {
 	int (*run)(struct phy_device *phydev);
 };
 
-int phy_read(struct phy_device *phydev, u16 regnum);
-int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
+/**
+ * phy_read - Convenience function for reading a given PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to read
+ *
+ * NOTE: MUST NOT be called from interrupt context,
+ * because the bus read/write functions may wait for an interrupt
+ * to conclude the operation.
+ */
+static inline int phy_read(struct phy_device *phydev, u16 regnum)
+{
+	return mdiobus_read(phydev->bus, phydev->addr, regnum);
+}
+
+/**
+ * phy_write - Convenience function for writing a given PHY register
+ * @phydev: the phy_device struct
+ * @regnum: register number to write
+ * @val: value to write to @regnum
+ *
+ * NOTE: MUST NOT be called from interrupt context,
+ * because the bus read/write functions may wait for an interrupt
+ * to conclude the operation.
+ */
+static inline int phy_write(struct phy_device *phydev, u16 regnum, u16 val)
+{
+	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
+}
+
 int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
@@ -416,12 +452,6 @@ void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
 
-struct mii_bus *mdiobus_alloc(void);
-int mdiobus_register(struct mii_bus *bus);
-void mdiobus_unregister(struct mii_bus *bus);
-void mdiobus_free(struct mii_bus *bus);
-struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
-
 void phy_sanitize_settings(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_enable_interrupts(struct phy_device *phydev);

commit 46abc02175b3c246dd5141d878f565a8725060c9
Author: Lennert Buytenhek <buytenh@marvell.com>
Date:   Wed Oct 8 16:33:40 2008 -0700

    phylib: give mdio buses a device tree presence
    
    Introduce the mdio_bus class, and give each 'struct mii_bus' its own
    'struct device', so that mii_bus objects are represented in the device
    tree and can be found by querying the device tree.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ca4a83c4c537..891f27f9137e 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -100,6 +100,13 @@ struct mii_bus {
 	struct mutex mdio_lock;
 
 	struct device *parent;
+	enum {
+		MDIOBUS_ALLOCATED = 1,
+		MDIOBUS_REGISTERED,
+		MDIOBUS_UNREGISTERED,
+		MDIOBUS_RELEASED,
+	} state;
+	struct device dev;
 
 	/* list of all PHYs on bus */
 	struct phy_device *phy_map[PHY_MAX_ADDR];
@@ -113,6 +120,7 @@ struct mii_bus {
 	 */
 	int *irq;
 };
+#define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 
 #define PHY_INTERRUPT_DISABLED	0x0
 #define PHY_INTERRUPT_ENABLED	0x80000000

commit 298cf9beb9679522de995e249eccbd82f7c51999
Author: Lennert Buytenhek <buytenh@marvell.com>
Date:   Wed Oct 8 16:29:57 2008 -0700

    phylib: move to dynamic allocation of struct mii_bus
    
    This patch introduces mdiobus_alloc() and mdiobus_free(), and
    makes all mdio bus drivers use these functions to allocate their
    struct mii_bus'es dynamically.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Andy Fleming <afleming@freescale.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 87499bdedc6f..ca4a83c4c537 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -408,8 +408,10 @@ void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
 
+struct mii_bus *mdiobus_alloc(void);
 int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
+void mdiobus_free(struct mii_bus *bus);
 struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
 
 void phy_sanitize_settings(struct phy_device *phydev);

commit 18ee49ddb0d242ed1d0e273038d5e4f6de7379d3
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed Oct 1 15:41:33 2008 +0000

    phylib: rename mii_bus::dev to mii_bus::parent
    
    In preparation of giving mii_bus objects a device tree presence of
    their own, rename struct mii_bus's ->dev argument to ->parent, since
    having a 'struct device *dev' that points to our parent device
    conflicts with introducing a 'struct device dev' representing our own
    device.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Andy Fleming <afleming@freescale.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5f170f5b1a30..87499bdedc6f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -99,7 +99,7 @@ struct mii_bus {
 	 */
 	struct mutex mdio_lock;
 
-	struct device *dev;
+	struct device *parent;
 
 	/* list of all PHYs on bus */
 	struct phy_device *phy_map[PHY_MAX_ADDR];

commit 4fd5f812c23c7deee6425f4a318e85c317cd1d6c
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Aug 26 13:08:46 2008 +0200

    phylib: allow incremental scanning of an mii bus
    
    This patch splits the bus scanning code in mdiobus_register() off
    into a separate function, and makes this function available for
    calling from external code.  This allows incrementally scanning an
    mii bus, e.g. as information about which addresses are 'safe' to
    scan becomes available.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Andy Fleming <afleming@freescale.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 7224c4099a28..5f170f5b1a30 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -410,6 +410,8 @@ int phy_start_aneg(struct phy_device *phydev);
 
 int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
+struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr);
+
 void phy_sanitize_settings(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
 int phy_enable_interrupts(struct phy_device *phydev);

commit 9b9a8bfc8dfbe09dc57f274e32e8b06151abbad7
Author: Andy Fleming <afleming@freescale.com>
Date:   Fri May 2 13:00:51 2008 -0500

    phylib: Fix some sparse warnings
    
    Declared some things static, declared some things in the header.
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 02df20f085fe..7224c4099a28 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -412,6 +412,8 @@ int mdiobus_register(struct mii_bus *bus);
 void mdiobus_unregister(struct mii_bus *bus);
 void phy_sanitize_settings(struct phy_device *phydev);
 int phy_stop_interrupts(struct phy_device *phydev);
+int phy_enable_interrupts(struct phy_device *phydev);
+int phy_disable_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev) {
 	return phydev->drv->read_status(phydev);
@@ -447,5 +449,8 @@ int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
 		int (*run)(struct phy_device *));
 int phy_scan_fixups(struct phy_device *phydev);
 
+int __init mdio_bus_init(void);
+void mdio_bus_exit(void);
+
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit f62220d3a9ccb879c3f90f845ae57b724b7bbb62
Author: Andy Fleming <afleming@freescale.com>
Date:   Fri Apr 18 17:29:54 2008 -0500

    phylib: Add support for board-level PHY fixups
    
    Sometimes the specific interaction between the platform and the PHY
    requires special handling.  For instance, to change where the PHY's
    clock input is, or to add a delay to account for latency issues in the
    data path.  We add a mechanism for registering a callback with the PHY
    Lib to be called on matching PHYs when they are brought up, or reset.
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 779cbcd65f62..02df20f085fe 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -379,6 +379,18 @@ struct phy_driver {
 };
 #define to_phy_driver(d) container_of(d, struct phy_driver, driver)
 
+#define PHY_ANY_ID "MATCH ANY PHY"
+#define PHY_ANY_UID 0xffffffff
+
+/* A Structure for boards to register fixups with the PHY Lib */
+struct phy_fixup {
+	struct list_head list;
+	char bus_id[BUS_ID_SIZE];
+	u32 phy_uid;
+	u32 phy_uid_mask;
+	int (*run)(struct phy_device *phydev);
+};
+
 int phy_read(struct phy_device *phydev, u16 regnum);
 int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
 int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
@@ -386,8 +398,8 @@ struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
 struct phy_device * phy_attach(struct net_device *dev,
-		const char *phy_id, u32 flags, phy_interface_t interface);
-struct phy_device * phy_connect(struct net_device *dev, const char *phy_id,
+		const char *bus_id, u32 flags, phy_interface_t interface);
+struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
 		void (*handler)(struct net_device *), u32 flags,
 		phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
@@ -427,5 +439,13 @@ void phy_print_status(struct phy_device *phydev);
 struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id);
 void phy_device_free(struct phy_device *phydev);
 
+int phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,
+		int (*run)(struct phy_device *));
+int phy_register_fixup_for_id(const char *bus_id,
+		int (*run)(struct phy_device *));
+int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
+		int (*run)(struct phy_device *));
+int phy_scan_fixups(struct phy_device *phydev);
+
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit cac1f3c8a80f3fc0b4489d1d3ba29214677ffab2
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Apr 15 12:49:21 2008 -0400

    phylib: factor out get_phy_id from within get_phy_device
    
    We were already doing what amounts to a get_phy_id from within
    get_phy_device, and rather than duplicate this for the TBIPA
    probing, we might as well just factor it out and make it available
    instead.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2d838448415c..779cbcd65f62 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -381,6 +381,7 @@ struct phy_driver {
 
 int phy_read(struct phy_device *phydev, u16 regnum);
 int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
+int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);

commit c5e38a949bfa11d10f73927fbf4fe66b73bc3001
Author: Andy Fleming <afleming@freescale.com>
Date:   Wed Apr 9 19:38:27 2008 -0500

    phy: Clean up header style
    
    Multi-line comments weren't all CodingStyle compliant
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 6509f377bb10..2d838448415c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -39,7 +39,8 @@
 				 SUPPORTED_1000baseT_Half | \
 				 SUPPORTED_1000baseT_Full)
 
-/* Set phydev->irq to PHY_POLL if interrupts are not supported,
+/*
+ * Set phydev->irq to PHY_POLL if interrupts are not supported,
  * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if
  * the attached driver handles the interrupt
  */
@@ -80,8 +81,10 @@ typedef enum {
  */
 #define MII_BUS_ID_SIZE	(BUS_ID_SIZE - 3)
 
-/* The Bus class for PHYs.  Devices which provide access to
- * PHYs should register using this structure */
+/*
+ * The Bus class for PHYs.  Devices which provide access to
+ * PHYs should register using this structure
+ */
 struct mii_bus {
 	const char *name;
 	char id[MII_BUS_ID_SIZE];
@@ -90,8 +93,10 @@ struct mii_bus {
 	int (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val);
 	int (*reset)(struct mii_bus *bus);
 
-	/* A lock to ensure that only one thing can read/write
-	 * the MDIO bus at a time */
+	/*
+	 * A lock to ensure that only one thing can read/write
+	 * the MDIO bus at a time
+	 */
 	struct mutex mdio_lock;
 
 	struct device *dev;
@@ -102,8 +107,10 @@ struct mii_bus {
 	/* Phy addresses to be ignored when probing */
 	u32 phy_mask;
 
-	/* Pointer to an array of interrupts, each PHY's
-	 * interrupt at the index matching its address */
+	/*
+	 * Pointer to an array of interrupts, each PHY's
+	 * interrupt at the index matching its address
+	 */
 	int *irq;
 };
 
@@ -255,7 +262,8 @@ struct phy_device {
 	/* Bus address of the PHY (0-32) */
 	int addr;
 
-	/* forced speed & duplex (no autoneg)
+	/*
+	 * forced speed & duplex (no autoneg)
 	 * partner speed & duplex & pause (autoneg)
 	 */
 	int speed;
@@ -278,8 +286,10 @@ struct phy_device {
 
 	int link_timeout;
 
-	/* Interrupt number for this PHY
-	 * -1 means no interrupt */
+	/*
+	 * Interrupt number for this PHY
+	 * -1 means no interrupt
+	 */
 	int irq;
 
 	/* private data pointer */
@@ -329,22 +339,28 @@ struct phy_driver {
 	u32 features;
 	u32 flags;
 
-	/* Called to initialize the PHY,
-	 * including after a reset */
+	/*
+	 * Called to initialize the PHY,
+	 * including after a reset
+	 */
 	int (*config_init)(struct phy_device *phydev);
 
-	/* Called during discovery.  Used to set
-	 * up device-specific structures, if any */
+	/*
+	 * Called during discovery.  Used to set
+	 * up device-specific structures, if any
+	 */
 	int (*probe)(struct phy_device *phydev);
 
 	/* PHY Power Management */
 	int (*suspend)(struct phy_device *phydev);
 	int (*resume)(struct phy_device *phydev);
 
-	/* Configures the advertisement and resets
+	/*
+	 * Configures the advertisement and resets
 	 * autonegotiation if phydev->autoneg is on,
 	 * forces the speed to the current settings in phydev
-	 * if phydev->autoneg is off */
+	 * if phydev->autoneg is off
+	 */
 	int (*config_aneg)(struct phy_device *phydev);
 
 	/* Determines the negotiated speed and duplex */

commit 9d9326d3bc0ea9a8bbe40bf3e5e66c7b9858caa0
Author: Andy Fleming <afleming@freescale.com>
Date:   Wed Apr 9 19:38:13 2008 -0500

    phy: Change mii_bus id field to a string
    
    Having the id field be an int was making more complex bus topologies
    excessively difficult.  For now, just convert it to a string, and
    change all instances of "bus->id = val" to
    snprintf(id, MII_BUS_ID_LEN, "%x", val).
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 5e43ae751412..6509f377bb10 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -63,8 +63,6 @@ typedef enum {
 	PHY_INTERFACE_MODE_RTBI
 } phy_interface_t;
 
-#define MII_BUS_MAX 4
-
 
 #define PHY_INIT_TIMEOUT	100000
 #define PHY_STATE_TIME		1
@@ -74,13 +72,19 @@ typedef enum {
 #define PHY_MAX_ADDR	32
 
 /* Used when trying to connect to a specific phy (mii bus id:phy device id) */
-#define PHY_ID_FMT "%x:%02x"
+#define PHY_ID_FMT "%s:%02x"
+
+/*
+ * Need to be a little smaller than phydev->dev.bus_id to leave room
+ * for the ":%02x"
+ */
+#define MII_BUS_ID_SIZE	(BUS_ID_SIZE - 3)
 
 /* The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure */
 struct mii_bus {
 	const char *name;
-	int id;
+	char id[MII_BUS_ID_SIZE];
 	void *priv;
 	int (*read)(struct mii_bus *bus, int phy_id, int regnum);
 	int (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val);

commit 35b5f6b1a82b5c586e0b24c711dc6ba944e88ef1
Author: Nate Case <ncase@xes-inc.com>
Date:   Tue Jan 29 10:05:09 2008 -0600

    PHYLIB: Locking fixes for PHY I/O potentially sleeping
    
    PHY read/write functions can potentially sleep (e.g., a PHY accessed
    via I2C).  The following changes were made to account for this:
    
        * Change spin locks to mutex locks
        * Add a BUG_ON() to phy_read() phy_write() to warn against
          calling them from an interrupt context.
        * Use work queue for PHY state machine handling since
          it can potentially sleep
        * Change phydev lock from spinlock to mutex
    
    Signed-off-by: Nate Case <ncase@xes-inc.com>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 554836edd915..5e43ae751412 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -88,7 +88,7 @@ struct mii_bus {
 
 	/* A lock to ensure that only one thing can read/write
 	 * the MDIO bus at a time */
-	spinlock_t mdio_lock;
+	struct mutex mdio_lock;
 
 	struct device *dev;
 
@@ -284,10 +284,11 @@ struct phy_device {
 
 	/* Interrupt and Polling infrastructure */
 	struct work_struct phy_queue;
+	struct work_struct state_queue;
 	struct timer_list phy_timer;
 	atomic_t irq_disable;
 
-	spinlock_t lock;
+	struct mutex lock;
 
 	struct net_device *attached_dev;
 

commit 6f4a7f4183bdbd02741dcd8edbd10b8628acc5d5
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Dec 4 16:17:33 2007 +0300

    PHY: Add the phy_device_release device method.
    
    Lately I've got this nice badness on mdio bus removal:
    
    Device 'e0103120:06' does not have a release() function, it is broken and must be fixed.
    ------------[ cut here ]------------
    Badness at drivers/base/core.c:107
    NIP: c015c1a8 LR: c015c1a8 CTR: c0157488
    REGS: c34bdcf0 TRAP: 0700   Not tainted  (2.6.23-rc5-g9ebadfbb-dirty)
    MSR: 00029032 <EE,ME,IR,DR>  CR: 24088422  XER: 00000000
    ...
    [c34bdda0] [c015c1a8] device_release+0x78/0x80 (unreliable)
    [c34bddb0] [c01354cc] kobject_cleanup+0x80/0xbc
    [c34bddd0] [c01365f0] kref_put+0x54/0x6c
    [c34bdde0] [c013543c] kobject_put+0x24/0x34
    [c34bddf0] [c015c384] put_device+0x1c/0x2c
    [c34bde00] [c0180e84] mdiobus_unregister+0x2c/0x58
    ...
    
    Though actually there is nothing broken, it just device
    subsystem core expects another "pattern" of resource managment.
    
    This patch implement phy device's release function, thus
    we're getting rid of this badness.
    
    Also small hidden bug fixed, hope none other introduced. ;-)
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Acked-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index e10763d79181..554836edd915 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -403,6 +403,7 @@ int phy_mii_ioctl(struct phy_device *phydev,
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id);
+void phy_device_free(struct phy_device *phydev);
 
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit 7d400a4c589749bf5b5e544aee07b3c489b54d02
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Mon Nov 26 16:17:48 2007 -0600

    phylib: add PHY interface modes for internal delay for tx and rx only
    
    Allow phylib specification of cases where hardware needs to configure
    PHYs for Internal Delay only on either RX or TX (not both).
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Tested-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Acked-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index f0742b6aaa64..e10763d79181 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -58,6 +58,8 @@ typedef enum {
 	PHY_INTERFACE_MODE_RMII,
 	PHY_INTERFACE_MODE_RGMII,
 	PHY_INTERFACE_MODE_RGMII_ID,
+	PHY_INTERFACE_MODE_RGMII_RXID,
+	PHY_INTERFACE_MODE_RGMII_TXID,
 	PHY_INTERFACE_MODE_RTBI
 } phy_interface_t;
 

commit 0ac49527318bc388a881152d60f49d7951606024
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Sep 28 22:42:14 2007 -0700

    PHYLIB: IRQ event workqueue handling fixes
    
    Keep track of disable_irq_nosync() invocations and call enable_irq() the
    right number of times if work has been cancelled that would include them.
    
    Now that the call to flush_work_keventd() (problematic because of
    rtnl_mutex being held) has been replaced by cancel_work_sync() another
    issue has arisen and been left unresolved.  As the MDIO bus cannot be
    accessed from the interrupt context the PHY interrupt handler uses
    disable_irq_nosync() to prevent from looping and schedules some work to be
    done as a softirq, which, apart from handling the state change of the
    originating PHY, is responsible for reenabling the interrupt.  Now if the
    interrupt line is shared by another device and a call to the softirq
    handler has been cancelled, that call to enable_irq() never happens and the
    other device cannot use its interrupt anymore as its stuck disabled.
    
    I decided to use a counter rather than a flag because there may be more
    than one call to phy_change() cancelled in the queue -- a real one and a
    fake one triggered by free_irq() if DEBUG_SHIRQ is used, if nothing else.
    Therefore because of its nesting property enable_irq() has to be called the
    right number of times to match the number disable_irq_nosync() was called
    and restore the original state.  This DEBUG_SHIRQ feature is also the
    reason why free_irq() has to be called before cancel_work_sync().
    
    While at it I updated the comment about phy_stop_interrupts() being called
    from `keventd' -- this is no longer relevant as the use of
    cancel_work_sync() makes such an approach unnecessary.  OTOH a similar
    comment referring to flush_scheduled_work() in phy_stop() still applies as
    using cancel_work_sync() there would be dangerous.
    
    Checked with checkpatch.pl and at the run time (with and without
    DEBUG_SHIRQ).
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Andy Fleming <afleming@freescale.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 2a659789f9ca..f0742b6aaa64 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -25,6 +25,8 @@
 #include <linux/timer.h>
 #include <linux/workqueue.h>
 
+#include <asm/atomic.h>
+
 #define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
 				 SUPPORTED_10baseT_Full | \
 				 SUPPORTED_100baseT_Half | \
@@ -281,6 +283,7 @@ struct phy_device {
 	/* Interrupt and Polling infrastructure */
 	struct work_struct phy_queue;
 	struct timer_list phy_timer;
+	atomic_t irq_disable;
 
 	spinlock_t lock;
 

commit a999589ccaae16472531e0616f23826ad097aa40
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Fri Apr 13 01:25:57 2007 -0500

    phylib: add RGMII-ID interface mode definition
    
    The RGMII spec allows compliance for devices that implement an internal
    delay on TXC or RXC inside the transmitter.  This patch adds an RGMII_ID
    definition to support RGMII-ID devices in the phylib.
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index edd4c88ca7d8..2a659789f9ca 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -55,6 +55,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_TBI,
 	PHY_INTERFACE_MODE_RMII,
 	PHY_INTERFACE_MODE_RGMII,
+	PHY_INTERFACE_MODE_RGMII_ID,
 	PHY_INTERFACE_MODE_RTBI
 } phy_interface_t;
 

commit e8a2b6a4207332a2d59628a12cece9e8c1d769e4
Author: Andy Fleming <afleming@freescale.com>
Date:   Fri Dec 1 12:01:06 2006 -0600

    [PATCH] PHY: Add support for configuring the PHY connection interface
    
    Most PHYs connect to an ethernet controller over a GMII or MII
    interface.  However, a growing number are connected over
    different interfaces, such as RGMII or SGMII.
    
    The ethernet driver will tell the PHY what type of connection it
    is by setting it manually, or passing it in through phy_connect
    (or phy_attach).
    
    Changes include:
    * Updates to documentation
    * Updates to PHY Lib consumers
    * Changes to PHY Lib to add interface support
    * Some minor changes to whitespace in phy.h
    * gianfar driver now detects interface and passes appropriate
      value to PHY Lib
    Signed-off-by: Andrew Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index ce8bc80b3c86..edd4c88ca7d8 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -47,15 +47,26 @@
 #define PHY_HAS_INTERRUPT	0x00000001
 #define PHY_HAS_MAGICANEG	0x00000002
 
+/* Interface Mode definitions */
+typedef enum {
+	PHY_INTERFACE_MODE_MII,
+	PHY_INTERFACE_MODE_GMII,
+	PHY_INTERFACE_MODE_SGMII,
+	PHY_INTERFACE_MODE_TBI,
+	PHY_INTERFACE_MODE_RMII,
+	PHY_INTERFACE_MODE_RGMII,
+	PHY_INTERFACE_MODE_RTBI
+} phy_interface_t;
+
 #define MII_BUS_MAX 4
 
 
-#define PHY_INIT_TIMEOUT 100000
+#define PHY_INIT_TIMEOUT	100000
 #define PHY_STATE_TIME		1
 #define PHY_FORCE_TIMEOUT	10
 #define PHY_AN_TIMEOUT		10
 
-#define PHY_MAX_ADDR 32
+#define PHY_MAX_ADDR	32
 
 /* Used when trying to connect to a specific phy (mii bus id:phy device id) */
 #define PHY_ID_FMT "%x:%02x"
@@ -87,8 +98,8 @@ struct mii_bus {
 	int *irq;
 };
 
-#define PHY_INTERRUPT_DISABLED 0x0
-#define PHY_INTERRUPT_ENABLED 0x80000000
+#define PHY_INTERRUPT_DISABLED	0x0
+#define PHY_INTERRUPT_ENABLED	0x80000000
 
 /* PHY state machine states:
  *
@@ -230,6 +241,8 @@ struct phy_device {
 
 	u32 dev_flags;
 
+	phy_interface_t interface;
+
 	/* Bus address of the PHY (0-32) */
 	int addr;
 
@@ -345,9 +358,10 @@ struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
 struct phy_device * phy_attach(struct net_device *dev,
-		const char *phy_id, u32 flags);
+		const char *phy_id, u32 flags, phy_interface_t interface);
 struct phy_device * phy_connect(struct net_device *dev, const char *phy_id,
-		void (*handler)(struct net_device *), u32 flags);
+		void (*handler)(struct net_device *), u32 flags,
+		phy_interface_t interface);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);

commit 13df29f69749a61b5209d52b71fcbf7300e5d6fb
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Oct 3 16:18:28 2006 +0100

    [PATCH] 2.6.18: sb1250-mac: Missing inclusions from <linux/phy.h>
    
     The <linux/phy.h> uses some types and macros defined in
    <linux/ethtool.h>, <linux/mii.h>, <linux/timer.h> and <linux/workqueue.h>,
    but fails to include these headers.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    
    patch-mips-2.6.18-20060920-include-phy-16
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9447a57ee8a9..ce8bc80b3c86 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -20,6 +20,10 @@
 
 #include <linux/spinlock.h>
 #include <linux/device.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
 
 #define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
 				 SUPPORTED_10baseT_Full | \

commit 11b0bacd717c285c94dbb56505a28434b34f0639
Author: Vitaly Bordug <vbordug@ru.mvista.com>
Date:   Mon Aug 14 23:00:29 2006 -0700

    [PATCH] PAL: Support of the fixed PHY
    
    This makes it possible for HW PHY-less boards to utilize PAL goodies.  Generic
    routines to connect to fixed PHY are provided, as well as ability to specify
    software callback that fills up link, speed, etc.  information into PHY
    descriptor (the latter feature not tested so far).
    
    Signed-off-by: Vitaly Bordug <vbordug@ru.mvista.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 331521a10a2d..9447a57ee8a9 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -378,6 +378,7 @@ int phy_mii_ioctl(struct phy_device *phydev,
 		struct mii_ioctl_data *mii_data, int cmd);
 int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
+struct phy_device* phy_device_create(struct mii_bus *bus, int addr, int phy_id);
 
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit a4d00f179fcec7065fe5742e9cebd6500886070f
Author: Kumar Gala <galak@gate.crashing.org>
Date:   Wed Jan 11 11:27:33 2006 -0800

    [PATCH] phy: Added a macro to represent the string format used to match a phy device
    
    Add the PHY_ID_FMT macro to ensure that the format of the id string used by a
    driver to match to its specific phy is consistent between the mdio_bus and the
    driver.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 92a9696fdebe..331521a10a2d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -53,6 +53,9 @@
 
 #define PHY_MAX_ADDR 32
 
+/* Used when trying to connect to a specific phy (mii bus id:phy device id) */
+#define PHY_ID_FMT "%x:%02x"
+
 /* The Bus class for PHYs.  Devices which provide access to
  * PHYs should register using this structure */
 struct mii_bus {

commit f896424cbc61225e8f029fe23e5aae3e32103229
Author: Matt Porter <mporter@kernel.crashing.org>
Date:   Wed Nov 2 16:13:06 2005 -0700

    [PATCH] phy address mask support for generic phy layer
    
    Adds a phy_mask field to struct mii_bus and uses it.  This field
    indicates each phy address to be ignored when probing the mdio bus.
    
    This support is needed for the fs_enet and ibm_emac drivers to be
    converted to the generic phy layer among other drivers. Many systems
    lock up on probing certain phy addresses or probing doesn't return
    0xffff when nothing is found at the address. A new driver I'm
    working on also makes use of this mask.
    
    Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 72cb67b66e0c..92a9696fdebe 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -72,6 +72,9 @@ struct mii_bus {
 	/* list of all PHYs on bus */
 	struct phy_device *phy_map[PHY_MAX_ADDR];
 
+	/* Phy addresses to be ignored when probing */
+	u32 phy_mask;
+
 	/* Pointer to an array of interrupts, each PHY's
 	 * interrupt at the index matching its address */
 	int *irq;

commit e13934563db047043ccead26412f552375cea90c
Author: Andy Fleming <afleming@freescale.com>
Date:   Wed Aug 24 18:46:21 2005 -0500

    [PATCH] PHY Layer fixup
    
    This patch adds back the code that was taken out, thus re-enabling:
    
    * The PHY Layer to initialize without crashing
    * Drivers to actually connect to PHYs
    * The entire PHY Control Layer
    
    This patch is used by the gianfar driver, and other drivers which are in
    development.
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4f2b5effc16b..72cb67b66e0c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -334,11 +334,26 @@ int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
+struct phy_device * phy_attach(struct net_device *dev,
+		const char *phy_id, u32 flags);
+struct phy_device * phy_connect(struct net_device *dev, const char *phy_id,
+		void (*handler)(struct net_device *), u32 flags);
+void phy_disconnect(struct phy_device *phydev);
+void phy_detach(struct phy_device *phydev);
+void phy_start(struct phy_device *phydev);
+void phy_stop(struct phy_device *phydev);
+int phy_start_aneg(struct phy_device *phydev);
+
+int mdiobus_register(struct mii_bus *bus);
+void mdiobus_unregister(struct mii_bus *bus);
+void phy_sanitize_settings(struct phy_device *phydev);
+int phy_stop_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev) {
 	return phydev->drv->read_status(phydev);
 }
 
+int genphy_config_advert(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
@@ -355,6 +370,8 @@ int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_mii_ioctl(struct phy_device *phydev,
 		struct mii_ioctl_data *mii_data, int cmd);
+int phy_start_interrupts(struct phy_device *phydev);
+void phy_print_status(struct phy_device *phydev);
 
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit 2bf69b5fe90b3246ab50064c5a690a363e8c53e2
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu Aug 11 02:47:54 2005 -0400

    phy subsystem: more cleanups
    
    - unexport symbols never used outside of home module
    - remove dead code
    - remove CONFIG_PHYCONTROL, make it unconditionally enabled

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 72cb67b66e0c..4f2b5effc16b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -334,26 +334,11 @@ int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
 struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
 int phy_clear_interrupt(struct phy_device *phydev);
 int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
-struct phy_device * phy_attach(struct net_device *dev,
-		const char *phy_id, u32 flags);
-struct phy_device * phy_connect(struct net_device *dev, const char *phy_id,
-		void (*handler)(struct net_device *), u32 flags);
-void phy_disconnect(struct phy_device *phydev);
-void phy_detach(struct phy_device *phydev);
-void phy_start(struct phy_device *phydev);
-void phy_stop(struct phy_device *phydev);
-int phy_start_aneg(struct phy_device *phydev);
-
-int mdiobus_register(struct mii_bus *bus);
-void mdiobus_unregister(struct mii_bus *bus);
-void phy_sanitize_settings(struct phy_device *phydev);
-int phy_stop_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev) {
 	return phydev->drv->read_status(phydev);
 }
 
-int genphy_config_advert(struct phy_device *phydev);
 int genphy_setup_forced(struct phy_device *phydev);
 int genphy_restart_aneg(struct phy_device *phydev);
 int genphy_config_aneg(struct phy_device *phydev);
@@ -370,8 +355,6 @@ int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_mii_ioctl(struct phy_device *phydev,
 		struct mii_ioctl_data *mii_data, int cmd);
-int phy_start_interrupts(struct phy_device *phydev);
-void phy_print_status(struct phy_device *phydev);
 
 extern struct bus_type mdio_bus_type;
 #endif /* __PHY_H */

commit 67c4f3fa25502ce7ed82fb0307e09cf36f1f81da
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Thu Aug 11 02:07:25 2005 -0400

    Fix numerous minor problems with new phy subsystem.
    
    Includes fixes for problems noted by Adrian Bunk, Andrew Morton,
    and one other person lost in the annals of history (and email folders).

diff --git a/include/linux/phy.h b/include/linux/phy.h
index 3404804dc22d..72cb67b66e0c 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -374,5 +374,4 @@ int phy_start_interrupts(struct phy_device *phydev);
 void phy_print_status(struct phy_device *phydev);
 
 extern struct bus_type mdio_bus_type;
-extern struct phy_driver genphy_driver;
 #endif /* __PHY_H */

commit 00db8189d984d6c51226dafbbe4a667ce9b7d5da
Author: Andy Fleming <afleming@freescale.com>
Date:   Sat Jul 30 19:31:23 2005 -0400

    This patch adds a PHY Abstraction Layer to the Linux Kernel, enabling
    ethernet drivers to remain as ignorant as is reasonable of the connected
    PHY's design and operation details.
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/include/linux/phy.h b/include/linux/phy.h
new file mode 100644
index 000000000000..3404804dc22d
--- /dev/null
+++ b/include/linux/phy.h
@@ -0,0 +1,378 @@
+/*
+ * include/linux/phy.h
+ *
+ * Framework and drivers for configuring and reading different PHYs
+ * Based on code in sungem_phy.c and gianfar_phy.c
+ *
+ * Author: Andy Fleming
+ *
+ * Copyright (c) 2004 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __PHY_H
+#define __PHY_H
+
+#include <linux/spinlock.h>
+#include <linux/device.h>
+
+#define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
+				 SUPPORTED_10baseT_Full | \
+				 SUPPORTED_100baseT_Half | \
+				 SUPPORTED_100baseT_Full | \
+				 SUPPORTED_Autoneg | \
+				 SUPPORTED_TP | \
+				 SUPPORTED_MII)
+
+#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \
+				 SUPPORTED_1000baseT_Half | \
+				 SUPPORTED_1000baseT_Full)
+
+/* Set phydev->irq to PHY_POLL if interrupts are not supported,
+ * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if
+ * the attached driver handles the interrupt
+ */
+#define PHY_POLL		-1
+#define PHY_IGNORE_INTERRUPT	-2
+
+#define PHY_HAS_INTERRUPT	0x00000001
+#define PHY_HAS_MAGICANEG	0x00000002
+
+#define MII_BUS_MAX 4
+
+
+#define PHY_INIT_TIMEOUT 100000
+#define PHY_STATE_TIME		1
+#define PHY_FORCE_TIMEOUT	10
+#define PHY_AN_TIMEOUT		10
+
+#define PHY_MAX_ADDR 32
+
+/* The Bus class for PHYs.  Devices which provide access to
+ * PHYs should register using this structure */
+struct mii_bus {
+	const char *name;
+	int id;
+	void *priv;
+	int (*read)(struct mii_bus *bus, int phy_id, int regnum);
+	int (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val);
+	int (*reset)(struct mii_bus *bus);
+
+	/* A lock to ensure that only one thing can read/write
+	 * the MDIO bus at a time */
+	spinlock_t mdio_lock;
+
+	struct device *dev;
+
+	/* list of all PHYs on bus */
+	struct phy_device *phy_map[PHY_MAX_ADDR];
+
+	/* Pointer to an array of interrupts, each PHY's
+	 * interrupt at the index matching its address */
+	int *irq;
+};
+
+#define PHY_INTERRUPT_DISABLED 0x0
+#define PHY_INTERRUPT_ENABLED 0x80000000
+
+/* PHY state machine states:
+ *
+ * DOWN: PHY device and driver are not ready for anything.  probe
+ * should be called if and only if the PHY is in this state,
+ * given that the PHY device exists.
+ * - PHY driver probe function will, depending on the PHY, set
+ * the state to STARTING or READY
+ *
+ * STARTING:  PHY device is coming up, and the ethernet driver is
+ * not ready.  PHY drivers may set this in the probe function.
+ * If they do, they are responsible for making sure the state is
+ * eventually set to indicate whether the PHY is UP or READY,
+ * depending on the state when the PHY is done starting up.
+ * - PHY driver will set the state to READY
+ * - start will set the state to PENDING
+ *
+ * READY: PHY is ready to send and receive packets, but the
+ * controller is not.  By default, PHYs which do not implement
+ * probe will be set to this state by phy_probe().  If the PHY
+ * driver knows the PHY is ready, and the PHY state is STARTING,
+ * then it sets this STATE.
+ * - start will set the state to UP
+ *
+ * PENDING: PHY device is coming up, but the ethernet driver is
+ * ready.  phy_start will set this state if the PHY state is
+ * STARTING.
+ * - PHY driver will set the state to UP when the PHY is ready
+ *
+ * UP: The PHY and attached device are ready to do work.
+ * Interrupts should be started here.
+ * - timer moves to AN
+ *
+ * AN: The PHY is currently negotiating the link state.  Link is
+ * therefore down for now.  phy_timer will set this state when it
+ * detects the state is UP.  config_aneg will set this state
+ * whenever called with phydev->autoneg set to AUTONEG_ENABLE.
+ * - If autonegotiation finishes, but there's no link, it sets
+ *   the state to NOLINK.
+ * - If aneg finishes with link, it sets the state to RUNNING,
+ *   and calls adjust_link
+ * - If autonegotiation did not finish after an arbitrary amount
+ *   of time, autonegotiation should be tried again if the PHY
+ *   supports "magic" autonegotiation (back to AN)
+ * - If it didn't finish, and no magic_aneg, move to FORCING.
+ *
+ * NOLINK: PHY is up, but not currently plugged in.
+ * - If the timer notes that the link comes back, we move to RUNNING
+ * - config_aneg moves to AN
+ * - phy_stop moves to HALTED
+ *
+ * FORCING: PHY is being configured with forced settings
+ * - if link is up, move to RUNNING
+ * - If link is down, we drop to the next highest setting, and
+ *   retry (FORCING) after a timeout
+ * - phy_stop moves to HALTED
+ *
+ * RUNNING: PHY is currently up, running, and possibly sending
+ * and/or receiving packets
+ * - timer will set CHANGELINK if we're polling (this ensures the
+ *   link state is polled every other cycle of this state machine,
+ *   which makes it every other second)
+ * - irq will set CHANGELINK
+ * - config_aneg will set AN
+ * - phy_stop moves to HALTED
+ *
+ * CHANGELINK: PHY experienced a change in link state
+ * - timer moves to RUNNING if link
+ * - timer moves to NOLINK if the link is down
+ * - phy_stop moves to HALTED
+ *
+ * HALTED: PHY is up, but no polling or interrupts are done. Or
+ * PHY is in an error state.
+ *
+ * - phy_start moves to RESUMING
+ *
+ * RESUMING: PHY was halted, but now wants to run again.
+ * - If we are forcing, or aneg is done, timer moves to RUNNING
+ * - If aneg is not done, timer moves to AN
+ * - phy_stop moves to HALTED
+ */
+enum phy_state {
+	PHY_DOWN=0,
+	PHY_STARTING,
+	PHY_READY,
+	PHY_PENDING,
+	PHY_UP,
+	PHY_AN,
+	PHY_RUNNING,
+	PHY_NOLINK,
+	PHY_FORCING,
+	PHY_CHANGELINK,
+	PHY_HALTED,
+	PHY_RESUMING
+};
+
+/* phy_device: An instance of a PHY
+ *
+ * drv: Pointer to the driver for this PHY instance
+ * bus: Pointer to the bus this PHY is on
+ * dev: driver model device structure for this PHY
+ * phy_id: UID for this device found during discovery
+ * state: state of the PHY for management purposes
+ * dev_flags: Device-specific flags used by the PHY driver.
+ * addr: Bus address of PHY
+ * link_timeout: The number of timer firings to wait before the
+ * giving up on the current attempt at acquiring a link
+ * irq: IRQ number of the PHY's interrupt (-1 if none)
+ * phy_timer: The timer for handling the state machine
+ * phy_queue: A work_queue for the interrupt
+ * attached_dev: The attached enet driver's device instance ptr
+ * adjust_link: Callback for the enet controller to respond to
+ * changes in the link state.
+ * adjust_state: Callback for the enet driver to respond to
+ * changes in the state machine.
+ *
+ * speed, duplex, pause, supported, advertising, and
+ * autoneg are used like in mii_if_info
+ *
+ * interrupts currently only supports enabled or disabled,
+ * but could be changed in the future to support enabling
+ * and disabling specific interrupts
+ *
+ * Contains some infrastructure for polling and interrupt
+ * handling, as well as handling shifts in PHY hardware state
+ */
+struct phy_device {
+	/* Information about the PHY type */
+	/* And management functions */
+	struct phy_driver *drv;
+
+	struct mii_bus *bus;
+
+	struct device dev;
+
+	u32 phy_id;
+
+	enum phy_state state;
+
+	u32 dev_flags;
+
+	/* Bus address of the PHY (0-32) */
+	int addr;
+
+	/* forced speed & duplex (no autoneg)
+	 * partner speed & duplex & pause (autoneg)
+	 */
+	int speed;
+	int duplex;
+	int pause;
+	int asym_pause;
+
+	/* The most recently read link state */
+	int link;
+
+	/* Enabled Interrupts */
+	u32 interrupts;
+
+	/* Union of PHY and Attached devices' supported modes */
+	/* See mii.h for more info */
+	u32 supported;
+	u32 advertising;
+
+	int autoneg;
+
+	int link_timeout;
+
+	/* Interrupt number for this PHY
+	 * -1 means no interrupt */
+	int irq;
+
+	/* private data pointer */
+	/* For use by PHYs to maintain extra state */
+	void *priv;
+
+	/* Interrupt and Polling infrastructure */
+	struct work_struct phy_queue;
+	struct timer_list phy_timer;
+
+	spinlock_t lock;
+
+	struct net_device *attached_dev;
+
+	void (*adjust_link)(struct net_device *dev);
+
+	void (*adjust_state)(struct net_device *dev);
+};
+#define to_phy_device(d) container_of(d, struct phy_device, dev)
+
+/* struct phy_driver: Driver structure for a particular PHY type
+ *
+ * phy_id: The result of reading the UID registers of this PHY
+ *   type, and ANDing them with the phy_id_mask.  This driver
+ *   only works for PHYs with IDs which match this field
+ * name: The friendly name of this PHY type
+ * phy_id_mask: Defines the important bits of the phy_id
+ * features: A list of features (speed, duplex, etc) supported
+ *   by this PHY
+ * flags: A bitfield defining certain other features this PHY
+ *   supports (like interrupts)
+ *
+ * The drivers must implement config_aneg and read_status.  All
+ * other functions are optional. Note that none of these
+ * functions should be called from interrupt time.  The goal is
+ * for the bus read/write functions to be able to block when the
+ * bus transaction is happening, and be freed up by an interrupt
+ * (The MPC85xx has this ability, though it is not currently
+ * supported in the driver).
+ */
+struct phy_driver {
+	u32 phy_id;
+	char *name;
+	unsigned int phy_id_mask;
+	u32 features;
+	u32 flags;
+
+	/* Called to initialize the PHY,
+	 * including after a reset */
+	int (*config_init)(struct phy_device *phydev);
+
+	/* Called during discovery.  Used to set
+	 * up device-specific structures, if any */
+	int (*probe)(struct phy_device *phydev);
+
+	/* PHY Power Management */
+	int (*suspend)(struct phy_device *phydev);
+	int (*resume)(struct phy_device *phydev);
+
+	/* Configures the advertisement and resets
+	 * autonegotiation if phydev->autoneg is on,
+	 * forces the speed to the current settings in phydev
+	 * if phydev->autoneg is off */
+	int (*config_aneg)(struct phy_device *phydev);
+
+	/* Determines the negotiated speed and duplex */
+	int (*read_status)(struct phy_device *phydev);
+
+	/* Clears any pending interrupts */
+	int (*ack_interrupt)(struct phy_device *phydev);
+
+	/* Enables or disables interrupts */
+	int (*config_intr)(struct phy_device *phydev);
+
+	/* Clears up any memory if needed */
+	void (*remove)(struct phy_device *phydev);
+
+	struct device_driver driver;
+};
+#define to_phy_driver(d) container_of(d, struct phy_driver, driver)
+
+int phy_read(struct phy_device *phydev, u16 regnum);
+int phy_write(struct phy_device *phydev, u16 regnum, u16 val);
+struct phy_device* get_phy_device(struct mii_bus *bus, int addr);
+int phy_clear_interrupt(struct phy_device *phydev);
+int phy_config_interrupt(struct phy_device *phydev, u32 interrupts);
+struct phy_device * phy_attach(struct net_device *dev,
+		const char *phy_id, u32 flags);
+struct phy_device * phy_connect(struct net_device *dev, const char *phy_id,
+		void (*handler)(struct net_device *), u32 flags);
+void phy_disconnect(struct phy_device *phydev);
+void phy_detach(struct phy_device *phydev);
+void phy_start(struct phy_device *phydev);
+void phy_stop(struct phy_device *phydev);
+int phy_start_aneg(struct phy_device *phydev);
+
+int mdiobus_register(struct mii_bus *bus);
+void mdiobus_unregister(struct mii_bus *bus);
+void phy_sanitize_settings(struct phy_device *phydev);
+int phy_stop_interrupts(struct phy_device *phydev);
+
+static inline int phy_read_status(struct phy_device *phydev) {
+	return phydev->drv->read_status(phydev);
+}
+
+int genphy_config_advert(struct phy_device *phydev);
+int genphy_setup_forced(struct phy_device *phydev);
+int genphy_restart_aneg(struct phy_device *phydev);
+int genphy_config_aneg(struct phy_device *phydev);
+int genphy_update_link(struct phy_device *phydev);
+int genphy_read_status(struct phy_device *phydev);
+void phy_driver_unregister(struct phy_driver *drv);
+int phy_driver_register(struct phy_driver *new_driver);
+void phy_prepare_link(struct phy_device *phydev,
+		void (*adjust_link)(struct net_device *));
+void phy_start_machine(struct phy_device *phydev,
+		void (*handler)(struct net_device *));
+void phy_stop_machine(struct phy_device *phydev);
+int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
+int phy_mii_ioctl(struct phy_device *phydev,
+		struct mii_ioctl_data *mii_data, int cmd);
+int phy_start_interrupts(struct phy_device *phydev);
+void phy_print_status(struct phy_device *phydev);
+
+extern struct bus_type mdio_bus_type;
+extern struct phy_driver genphy_driver;
+#endif /* __PHY_H */
