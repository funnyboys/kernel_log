commit e886274031200bb60965c1b9c49b7acda56a93bd
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Tue Mar 10 16:19:01 2020 +0100

    libceph: fix alloc_msg_with_page_vector() memory leaks
    
    Make it so that CEPH_MSG_DATA_PAGES data item can own pages,
    fixing a bunch of memory leaks for a page vector allocated in
    alloc_msg_with_page_vector().  Currently, only watch-notify
    messages trigger this allocation, and normally the page vector
    is freed either in handle_watch_notify() or by the caller of
    ceph_osdc_notify().  But if the message is freed before that
    (e.g. if the session faults while reading in the message or
    if the notify is stale), we leak the page vector.
    
    This was supposed to be fixed by switching to a message-owned
    pagelist, but that never happened.
    
    Fixes: 1907920324f1 ("libceph: support for sending notifies")
    Reported-by: Roman Penyaev <rpenyaev@suse.de>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Roman Penyaev <rpenyaev@suse.de>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c4458dc6a757..76371aaae2d1 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -175,9 +175,10 @@ struct ceph_msg_data {
 #endif /* CONFIG_BLOCK */
 		struct ceph_bvec_iter	bvec_pos;
 		struct {
-			struct page	**pages;	/* NOT OWNER. */
+			struct page	**pages;
 			size_t		length;		/* total # bytes */
 			unsigned int	alignment;	/* first page */
+			bool		own_pages;
 		};
 		struct ceph_pagelist	*pagelist;
 	};
@@ -356,8 +357,8 @@ extern void ceph_con_keepalive(struct ceph_connection *con);
 extern bool ceph_con_keepalive_expired(struct ceph_connection *con,
 				       unsigned long interval);
 
-extern void ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,
-				size_t length, size_t alignment);
+void ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,
+			     size_t length, size_t alignment, bool own_pages);
 extern void ceph_msg_data_add_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
 #ifdef CONFIG_BLOCK

commit 120a75ea9f4ba02f852171e75d44f29139b9c83e
Author: Yan, Zheng <zyan@redhat.com>
Date:   Thu Jul 25 20:16:39 2019 +0800

    libceph: add function that reset client's entity addr
    
    This function also re-open connections to OSD/MON, and re-send in-flight
    OSD requests after re-opening connections to OSD.
    
    Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 23895d178149..c4458dc6a757 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -337,6 +337,7 @@ extern void ceph_msgr_flush(void);
 extern void ceph_messenger_init(struct ceph_messenger *msgr,
 				struct ceph_entity_addr *myaddr);
 extern void ceph_messenger_fini(struct ceph_messenger *msgr);
+extern void ceph_messenger_reset_nonce(struct ceph_messenger *msgr);
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,
 			const struct ceph_connection_operations *ops,

commit b726ec972cf2122137fbc47847b4fcc7b3bc2801
Author: Jeff Layton <jlayton@kernel.org>
Date:   Mon May 6 09:38:47 2019 -0400

    libceph: make ceph_pr_addr take an struct ceph_entity_addr pointer
    
    GCC9 is throwing a lot of warnings about unaligned accesses by
    callers of ceph_pr_addr. All of the current callers are passing a
    pointer to the sockaddr inside struct ceph_entity_addr.
    
    Fix it to take a pointer to a struct ceph_entity_addr instead,
    and then have the function make a copy of the sockaddr before
    printing it.
    
    Signed-off-by: Jeff Layton <jlayton@kernel.org>
    Reviewed-by: Ilya Dryomov <idryomov@gmail.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 800a2128d411..23895d178149 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -323,7 +323,8 @@ struct ceph_connection {
 };
 
 
-extern const char *ceph_pr_addr(const struct sockaddr_storage *ss);
+extern const char *ceph_pr_addr(const struct ceph_entity_addr *addr);
+
 extern int ceph_parse_ips(const char *c, const char *end,
 			  struct ceph_entity_addr *addr,
 			  int max_count, int *count);

commit 0d9c1ab3be4c0187663096a6a084421d0a1e45c6
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Oct 15 17:38:23 2018 +0200

    libceph: preallocate message data items
    
    Currently message data items are allocated with ceph_msg_data_create()
    in setup_request_data() inside send_request().  send_request() has never
    been allowed to fail, so each allocation is followed by a BUG_ON:
    
      data = ceph_msg_data_create(...);
      BUG_ON(!data);
    
    It's been this way since support for multiple message data items was
    added in commit 6644ed7b7e04 ("libceph: make message data be a pointer")
    in 3.10.
    
    There is no reason to delay the allocation of message data items until
    the last possible moment and we certainly don't need a linked list of
    them as they are only ever appended to the end and never erased.  Make
    ceph_msg_new2() take max_data_items and adapt the rest of the code.
    
    Reported-by: Jerry Lee <leisurelysw24@gmail.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index fc2b4491ee0a..800a2128d411 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -82,22 +82,6 @@ enum ceph_msg_data_type {
 	CEPH_MSG_DATA_BVECS,	/* data source/destination is a bio_vec array */
 };
 
-static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
-{
-	switch (type) {
-	case CEPH_MSG_DATA_NONE:
-	case CEPH_MSG_DATA_PAGES:
-	case CEPH_MSG_DATA_PAGELIST:
-#ifdef CONFIG_BLOCK
-	case CEPH_MSG_DATA_BIO:
-#endif /* CONFIG_BLOCK */
-	case CEPH_MSG_DATA_BVECS:
-		return true;
-	default:
-		return false;
-	}
-}
-
 #ifdef CONFIG_BLOCK
 
 struct ceph_bio_iter {
@@ -181,7 +165,6 @@ struct ceph_bvec_iter {
 } while (0)
 
 struct ceph_msg_data {
-	struct list_head		links;	/* ceph_msg->data */
 	enum ceph_msg_data_type		type;
 	union {
 #ifdef CONFIG_BLOCK
@@ -202,7 +185,6 @@ struct ceph_msg_data {
 
 struct ceph_msg_data_cursor {
 	size_t			total_resid;	/* across all data items */
-	struct list_head	*data_head;	/* = &ceph_msg->data */
 
 	struct ceph_msg_data	*data;		/* current data item */
 	size_t			resid;		/* bytes not yet consumed */
@@ -240,7 +222,9 @@ struct ceph_msg {
 	struct ceph_buffer *middle;
 
 	size_t				data_length;
-	struct list_head		data;
+	struct ceph_msg_data		*data;
+	int				num_data_items;
+	int				max_data_items;
 	struct ceph_msg_data_cursor	cursor;
 
 	struct ceph_connection *con;
@@ -381,6 +365,8 @@ void ceph_msg_data_add_bio(struct ceph_msg *msg, struct ceph_bio_iter *bio_pos,
 void ceph_msg_data_add_bvecs(struct ceph_msg *msg,
 			     struct ceph_bvec_iter *bvec_pos);
 
+struct ceph_msg *ceph_msg_new2(int type, int front_len, int max_data_items,
+			       gfp_t flags, bool can_fail);
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);
 

commit 6daca13d2e72bedaaacfc08f873114c9307d5aea
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Jul 27 19:18:34 2018 +0200

    libceph: add authorizer challenge
    
    When a client authenticates with a service, an authorizer is sent with
    a nonce to the service (ceph_x_authorize_[ab]) and the service responds
    with a mutation of that nonce (ceph_x_authorize_reply).  This lets the
    client verify the service is who it says it is but it doesn't protect
    against a replay: someone can trivially capture the exchange and reuse
    the same authorizer to authenticate themselves.
    
    Allow the service to reject an initial authorizer with a random
    challenge (ceph_x_authorize_challenge).  The client then has to respond
    with an updated authorizer proving they are able to decrypt the
    service's challenge and that the new authorizer was produced for this
    specific connection instance.
    
    The accepting side requires this challenge and response unconditionally
    if the client side advertises they have CEPHX_V2 feature bit.
    
    This addresses CVE-2018-1128.
    
    Link: http://tracker.ceph.com/issues/24836
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 021718570b50..fc2b4491ee0a 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -31,6 +31,9 @@ struct ceph_connection_operations {
 	struct ceph_auth_handshake *(*get_authorizer) (
 				struct ceph_connection *con,
 			       int *proto, int force_new);
+	int (*add_authorizer_challenge)(struct ceph_connection *con,
+					void *challenge_buf,
+					int challenge_buf_len);
 	int (*verify_authorizer_reply) (struct ceph_connection *con);
 	int (*invalidate_authorizer)(struct ceph_connection *con);
 

commit 262614c4294d33b1f19e0d18c0091d9c329b544a
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Jul 26 15:17:46 2018 +0200

    libceph: store ceph_auth_handshake pointer in ceph_connection
    
    We already copy authorizer_reply_buf and authorizer_reply_buf_len into
    ceph_connection.  Factoring out __prepare_write_connect() requires two
    more: authorizer_buf and authorizer_buf_len.  Store the pointer to the
    handshake in con->auth rather than piling on.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index a718b877c597..021718570b50 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -286,9 +286,8 @@ struct ceph_connection {
 				 attempt for this connection, client */
 	u32 peer_global_seq;  /* peer's global seq for this connection */
 
+	struct ceph_auth_handshake *auth;
 	int auth_retry;       /* true if we need a newer authorizer */
-	void *auth_reply_buf;   /* where to put the authorizer reply */
-	int auth_reply_buf_len;
 
 	struct mutex mutex;
 

commit 473bd2d780d1699d81b25f57c0ec4de633a28eb8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 13 22:18:34 2018 +0200

    libceph: use timespec64 in for keepalive2 and ticket validity
    
    ceph_con_keepalive_expired() is the last user of timespec_add() and some
    of the last uses of ktime_get_real_ts().  Replacing this with timespec64
    based interfaces  lets us remove that deprecated API.
    
    I'm introducing new ceph_encode_timespec64()/ceph_decode_timespec64()
    here that take timespec64 structures and convert to/from ceph_timespec,
    which is defined to have an unsigned 32-bit tv_sec member. This extends
    the range of valid times to year 2106, avoiding the year 2038 overflow.
    
    The ceph file system portion still uses the old functions for inode
    timestamps, this will be done separately after the VFS layer is converted.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Ilya Dryomov <idryomov@gmail.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c7dfcb8a1fb2..a718b877c597 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -330,7 +330,7 @@ struct ceph_connection {
 	int in_base_pos;     /* bytes read */
 	__le64 in_temp_ack;  /* for reading an ack */
 
-	struct timespec last_keepalive_ack; /* keepalive2 ack stamp */
+	struct timespec64 last_keepalive_ack; /* keepalive2 ack stamp */
 
 	struct delayed_work work;	    /* send|recv work */
 	unsigned long       delay;          /* current delay interval */

commit b9e281c2b38804984d619e1d9efc4b9020bcb291
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Sat Jan 20 10:30:11 2018 +0100

    libceph: introduce BVECS data type
    
    In preparation for rbd "fancy" striping, introduce ceph_bvec_iter for
    working with bio_vec array data buffers.  The wrappers are trivial, but
    make it look similar to ceph_bio_iter.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index d7b9605fd51d..c7dfcb8a1fb2 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -76,6 +76,7 @@ enum ceph_msg_data_type {
 #ifdef CONFIG_BLOCK
 	CEPH_MSG_DATA_BIO,	/* data source/destination is a bio list */
 #endif /* CONFIG_BLOCK */
+	CEPH_MSG_DATA_BVECS,	/* data source/destination is a bio_vec array */
 };
 
 static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
@@ -87,6 +88,7 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 #ifdef CONFIG_BLOCK
 	case CEPH_MSG_DATA_BIO:
 #endif /* CONFIG_BLOCK */
+	case CEPH_MSG_DATA_BVECS:
 		return true;
 	default:
 		return false;
@@ -139,6 +141,42 @@ struct ceph_bio_iter {
 
 #endif /* CONFIG_BLOCK */
 
+struct ceph_bvec_iter {
+	struct bio_vec *bvecs;
+	struct bvec_iter iter;
+};
+
+#define __ceph_bvec_iter_advance_step(it, n, STEP) do {			      \
+	BUG_ON((n) > (it)->iter.bi_size);				      \
+	(void)(STEP);							      \
+	bvec_iter_advance((it)->bvecs, &(it)->iter, (n));		      \
+} while (0)
+
+/*
+ * Advance @it by @n bytes.
+ */
+#define ceph_bvec_iter_advance(it, n)					      \
+	__ceph_bvec_iter_advance_step(it, n, 0)
+
+/*
+ * Advance @it by @n bytes, executing BVEC_STEP for each bio_vec.
+ */
+#define ceph_bvec_iter_advance_step(it, n, BVEC_STEP)			      \
+	__ceph_bvec_iter_advance_step(it, n, ({				      \
+		struct bio_vec bv;					      \
+		struct bvec_iter __cur_iter;				      \
+									      \
+		__cur_iter = (it)->iter;				      \
+		__cur_iter.bi_size = (n);				      \
+		for_each_bvec(bv, (it)->bvecs, __cur_iter, __cur_iter)	      \
+			(void)(BVEC_STEP);				      \
+	}))
+
+#define ceph_bvec_iter_shorten(it, n) do {				      \
+	BUG_ON((n) > (it)->iter.bi_size);				      \
+	(it)->iter.bi_size = (n);					      \
+} while (0)
+
 struct ceph_msg_data {
 	struct list_head		links;	/* ceph_msg->data */
 	enum ceph_msg_data_type		type;
@@ -149,6 +187,7 @@ struct ceph_msg_data {
 			u32			bio_length;
 		};
 #endif /* CONFIG_BLOCK */
+		struct ceph_bvec_iter	bvec_pos;
 		struct {
 			struct page	**pages;	/* NOT OWNER. */
 			size_t		length;		/* total # bytes */
@@ -170,6 +209,7 @@ struct ceph_msg_data_cursor {
 #ifdef CONFIG_BLOCK
 		struct ceph_bio_iter	bio_iter;
 #endif /* CONFIG_BLOCK */
+		struct bvec_iter	bvec_iter;
 		struct {				/* pages */
 			unsigned int	page_offset;	/* offset in page */
 			unsigned short	page_index;	/* index in array */
@@ -336,6 +376,8 @@ extern void ceph_msg_data_add_pagelist(struct ceph_msg *msg,
 void ceph_msg_data_add_bio(struct ceph_msg *msg, struct ceph_bio_iter *bio_pos,
 			   u32 length);
 #endif /* CONFIG_BLOCK */
+void ceph_msg_data_add_bvecs(struct ceph_msg *msg,
+			     struct ceph_bvec_iter *bvec_pos);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit 5359a17d2706b86da2af83027343d5eb256f7670
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Sat Jan 20 10:30:10 2018 +0100

    libceph, rbd: new bio handling code (aka don't clone bios)
    
    The reason we clone bios is to be able to give each object request
    (and consequently each ceph_osd_data/ceph_msg_data item) its own
    pointer to a (list of) bio(s).  The messenger then initializes its
    cursor with cloned bio's ->bi_iter, so it knows where to start reading
    from/writing to.  That's all the cloned bios are used for: to determine
    each object request's starting position in the provided data buffer.
    
    Introduce ceph_bio_iter to do exactly that -- store position within bio
    list (i.e. pointer to bio) + position within that bio (i.e. bvec_iter).
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index ead9d85f1c11..d7b9605fd51d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -93,14 +93,60 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 	}
 }
 
+#ifdef CONFIG_BLOCK
+
+struct ceph_bio_iter {
+	struct bio *bio;
+	struct bvec_iter iter;
+};
+
+#define __ceph_bio_iter_advance_step(it, n, STEP) do {			      \
+	unsigned int __n = (n), __cur_n;				      \
+									      \
+	while (__n) {							      \
+		BUG_ON(!(it)->iter.bi_size);				      \
+		__cur_n = min((it)->iter.bi_size, __n);			      \
+		(void)(STEP);						      \
+		bio_advance_iter((it)->bio, &(it)->iter, __cur_n);	      \
+		if (!(it)->iter.bi_size && (it)->bio->bi_next) {	      \
+			dout("__ceph_bio_iter_advance_step next bio\n");      \
+			(it)->bio = (it)->bio->bi_next;			      \
+			(it)->iter = (it)->bio->bi_iter;		      \
+		}							      \
+		__n -= __cur_n;						      \
+	}								      \
+} while (0)
+
+/*
+ * Advance @it by @n bytes.
+ */
+#define ceph_bio_iter_advance(it, n)					      \
+	__ceph_bio_iter_advance_step(it, n, 0)
+
+/*
+ * Advance @it by @n bytes, executing BVEC_STEP for each bio_vec.
+ */
+#define ceph_bio_iter_advance_step(it, n, BVEC_STEP)			      \
+	__ceph_bio_iter_advance_step(it, n, ({				      \
+		struct bio_vec bv;					      \
+		struct bvec_iter __cur_iter;				      \
+									      \
+		__cur_iter = (it)->iter;				      \
+		__cur_iter.bi_size = __cur_n;				      \
+		__bio_for_each_segment(bv, (it)->bio, __cur_iter, __cur_iter) \
+			(void)(BVEC_STEP);				      \
+	}))
+
+#endif /* CONFIG_BLOCK */
+
 struct ceph_msg_data {
 	struct list_head		links;	/* ceph_msg->data */
 	enum ceph_msg_data_type		type;
 	union {
 #ifdef CONFIG_BLOCK
 		struct {
-			struct bio	*bio;
-			size_t		bio_length;
+			struct ceph_bio_iter	bio_pos;
+			u32			bio_length;
 		};
 #endif /* CONFIG_BLOCK */
 		struct {
@@ -122,10 +168,7 @@ struct ceph_msg_data_cursor {
 	bool			need_crc;	/* crc update needed */
 	union {
 #ifdef CONFIG_BLOCK
-		struct {				/* bio */
-			struct bio	*bio;		/* bio from list */
-			struct bvec_iter bvec_iter;
-		};
+		struct ceph_bio_iter	bio_iter;
 #endif /* CONFIG_BLOCK */
 		struct {				/* pages */
 			unsigned int	page_offset;	/* offset in page */
@@ -290,8 +333,8 @@ extern void ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,
 extern void ceph_msg_data_add_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
 #ifdef CONFIG_BLOCK
-extern void ceph_msg_data_add_bio(struct ceph_msg *msg, struct bio *bio,
-				size_t length);
+void ceph_msg_data_add_bio(struct ceph_msg *msg, struct ceph_bio_iter *bio_pos,
+			   u32 length);
 #endif /* CONFIG_BLOCK */
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index fbd94d9fa5dd..ead9d85f1c11 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __FS_CEPH_MESSENGER_H
 #define __FS_CEPH_MESSENGER_H
 

commit 98ad5ebd1505eb903ae8bc27e94c1ab0d1c3e651
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Jun 15 16:30:54 2017 +0200

    libceph: ceph_connection_operations::reencode_message() method
    
    Give upper layers a chance to reencode the message after the connection
    is negotiated and ->peer_features is set.  OSD client will use this to
    support both luminous and pre-luminous OSDs (in a single cluster): the
    former need MOSDOp v8; the latter will continue to be sent MOSDOp v4.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c5c4c713e00f..fbd94d9fa5dd 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -44,6 +44,8 @@ struct ceph_connection_operations {
 					struct ceph_msg_header *hdr,
 					int *skip);
 
+	void (*reencode_message) (struct ceph_msg *msg);
+
 	int (*sign_message) (struct ceph_msg *msg);
 	int (*check_message_signature) (struct ceph_msg *msg);
 };

commit 59331c215daf600a650e281b6e8ef3e1ed1174c2
Merge: ff0f962ca3c3 45ee2c1d6618
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 11:23:34 2016 -0800

    Merge tag 'ceph-for-4.10-rc1' of git://github.com/ceph/ceph-client
    
    Pull ceph updates from Ilya Dryomov:
     "A varied set of changes:
    
       - a large rework of cephx auth code to cope with CONFIG_VMAP_STACK
         (myself). Also fixed a deadlock caused by a bogus allocation on the
         writeback path and authorize reply verification.
    
       - a fix for long stalls during fsync (Jeff Layton). The client now
         has a way to force the MDS log flush, leading to ~100x speedups in
         some synthetic tests.
    
       - a new [no]require_active_mds mount option (Zheng Yan).
    
         On mount, we will now check whether any of the MDSes are available
         and bail rather than block if none are. This check can be avoided
         by specifying the "no" option.
    
       - a couple of MDS cap handling fixes and a few assorted patches
         throughout"
    
    * tag 'ceph-for-4.10-rc1' of git://github.com/ceph/ceph-client: (32 commits)
      libceph: remove now unused finish_request() wrapper
      libceph: always signal completion when done
      ceph: avoid creating orphan object when checking pool permission
      ceph: properly set issue_seq for cap release
      ceph: add flags parameter to send_cap_msg
      ceph: update cap message struct version to 10
      ceph: define new argument structure for send_cap_msg
      ceph: move xattr initialzation before the encoding past the ceph_mds_caps
      ceph: fix minor typo in unsafe_request_wait
      ceph: record truncate size/seq for snap data writeback
      ceph: check availability of mds cluster on mount
      ceph: fix splice read for no Fc capability case
      ceph: try getting buffer capability for readahead/fadvise
      ceph: fix scheduler warning due to nested blocking
      ceph: fix printing wrong return variable in ceph_direct_read_write()
      crush: include mapper.h in mapper.c
      rbd: silence bogus -Wmaybe-uninitialized warning
      libceph: no need to drop con->mutex for ->get_authorizer()
      libceph: drop len argument of *verify_authorizer_reply()
      libceph: verify authorize reply on connect
      ...

commit 0dde584882ade13dc9708d611fbf69b0ae8a9e48
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Fri Dec 2 16:35:09 2016 +0100

    libceph: drop len argument of *verify_authorizer_reply()
    
    The length of the reply is protocol-dependent - for cephx it's
    ceph_x_authorize_reply.  Nothing sensible can be passed from the
    messenger layer anyway.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 8dbd7879fdc6..531f2d882bd9 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -30,7 +30,7 @@ struct ceph_connection_operations {
 	struct ceph_auth_handshake *(*get_authorizer) (
 				struct ceph_connection *con,
 			       int *proto, int force_new);
-	int (*verify_authorizer_reply) (struct ceph_connection *con, int len);
+	int (*verify_authorizer_reply) (struct ceph_connection *con);
 	int (*invalidate_authorizer)(struct ceph_connection *con);
 
 	/* there was some error on the socket (disconnect, whatever) */

commit 9f08217120568afdfb59973a89a675e649c0096d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:15 2016 -0600

    ceph: don't include blk_types.h in messenger.h
    
    The file only needs the struct bvec_iter delcaration, which is available
    from bvec.h.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 8dbd7879fdc6..67bcef2ecddb 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -1,7 +1,7 @@
 #ifndef __FS_CEPH_MESSENGER_H
 #define __FS_CEPH_MESSENGER_H
 
-#include <linux/blk_types.h>
+#include <linux/bvec.h>
 #include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/net.h>

commit 67645d7619738e51c668ca69f097cb90b5470422
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Dec 28 13:18:34 2015 +0300

    libceph: fix ceph_msg_revoke()
    
    There are a number of problems with revoking a "was sending" message:
    
    (1) We never make any attempt to revoke data - only kvecs contibute to
    con->out_skip.  However, once the header (envelope) is written to the
    socket, our peer learns data_len and sets itself to expect at least
    data_len bytes to follow front or front+middle.  If ceph_msg_revoke()
    is called while the messenger is sending message's data portion,
    anything we send after that call is counted by the OSD towards the now
    revoked message's data portion.  The effects vary, the most common one
    is the eventual hang - higher layers get stuck waiting for the reply to
    the message that was sent out after ceph_msg_revoke() returned and
    treated by the OSD as a bunch of data bytes.  This is what Matt ran
    into.
    
    (2) Flat out zeroing con->out_kvec_bytes worth of bytes to handle kvecs
    is wrong.  If ceph_msg_revoke() is called before the tag is sent out or
    while the messenger is sending the header, we will get a connection
    reset, either due to a bad tag (0 is not a valid tag) or a bad header
    CRC, which kind of defeats the purpose of revoke.  Currently the kernel
    client refuses to work with header CRCs disabled, but that will likely
    change in the future, making this even worse.
    
    (3) con->out_skip is not reset on connection reset, leading to one or
    more spurious connection resets if we happen to get a real one between
    con->out_skip is set in ceph_msg_revoke() and before it's cleared in
    write_partial_skip().
    
    Fixing (1) and (3) is trivial.  The idea behind fixing (2) is to never
    zero the tag or the header, i.e. send out tag+header regardless of when
    ceph_msg_revoke() is called.  That way the header is always correct, no
    unnecessary resets are induced and revoke stands ready for disabled
    CRCs.  Since ceph_msg_revoke() rips out con->out_msg, introduce a new
    "message out temp" and copy the header into it before sending.
    
    Cc: stable@vger.kernel.org # 4.0+
    Reported-by: Matt Conner <matt.conner@keepertech.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Tested-by: Matt Conner <matt.conner@keepertech.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 71b1d6cdcb5d..8dbd7879fdc6 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -220,6 +220,7 @@ struct ceph_connection {
 	struct ceph_entity_addr actual_peer_addr;
 
 	/* message out temps */
+	struct ceph_msg_header out_hdr;
 	struct ceph_msg *out_msg;        /* sending message (== tail of
 					    out_sent) */
 	bool out_msg_done;
@@ -229,7 +230,6 @@ struct ceph_connection {
 	int out_kvec_left;   /* kvec's left in out_kvec */
 	int out_skip;        /* skip this many bytes */
 	int out_kvec_bytes;  /* total bytes left */
-	bool out_kvec_is_msg; /* kvec refers to out_msg */
 	int out_more;        /* there is more data after the kvecs */
 	__le64 out_temp_ack; /* for writing an ack */
 	struct ceph_timespec out_temp_keepalive2; /* for writing keepalive2

commit 859bff51dc5e92ddfb5eb6f17b8040d9311095bb
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Wed Oct 28 23:50:58 2015 +0100

    libceph: stop duplicating client fields in messenger
    
    supported_features and required_features serve no purpose at all, while
    nocrc and tcp_nodelay belong to ceph_options::flags.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 3687ff0f0133..71b1d6cdcb5d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -57,8 +57,6 @@ struct ceph_messenger {
 
 	atomic_t stopping;
 	possible_net_t net;
-	bool nocrc;
-	bool tcp_nodelay;
 
 	/*
 	 * the global_seq counts connections i (attempt to) initiate
@@ -66,9 +64,6 @@ struct ceph_messenger {
 	 */
 	u32 global_seq;
 	spinlock_t global_seq_lock;
-
-	u64 supported_features;
-	u64 required_features;
 };
 
 enum ceph_msg_data_type {
@@ -267,11 +262,7 @@ extern void ceph_msgr_exit(void);
 extern void ceph_msgr_flush(void);
 
 extern void ceph_messenger_init(struct ceph_messenger *msgr,
-			struct ceph_entity_addr *myaddr,
-			u64 supported_features,
-			u64 required_features,
-			bool nocrc,
-			bool tcp_nodelay);
+				struct ceph_entity_addr *myaddr);
 extern void ceph_messenger_fini(struct ceph_messenger *msgr);
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,

commit 79dbd1baa651cece408e68a1b445f3628c4b5bdc
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Oct 26 22:23:56 2015 +0100

    libceph: msg signing callouts don't need con argument
    
    We can use msg->con instead - at the point we sign an outgoing message
    or check the signature on the incoming one, msg->con is always set.  We
    wouldn't know how to sign a message without an associated session (i.e.
    msg->con == NULL) and being able to sign a message using an explicitly
    provided authorizer is of no use.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index b2371d9b51fa..3687ff0f0133 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -43,10 +43,9 @@ struct ceph_connection_operations {
 	struct ceph_msg * (*alloc_msg) (struct ceph_connection *con,
 					struct ceph_msg_header *hdr,
 					int *skip);
-	int (*sign_message) (struct ceph_connection *con, struct ceph_msg *msg);
 
-	int (*check_message_signature) (struct ceph_connection *con,
-					struct ceph_msg *msg);
+	int (*sign_message) (struct ceph_msg *msg);
+	int (*check_message_signature) (struct ceph_msg *msg);
 };
 
 /* use format string %s%d */

commit 7f61f545657281a3a1b0faf68993165ebdecc51b
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Mon Sep 14 16:01:05 2015 +0300

    libceph: don't access invalid memory in keepalive2 path
    
    This
    
        struct ceph_timespec ceph_ts;
        ...
        con_out_kvec_add(con, sizeof(ceph_ts), &ceph_ts);
    
    wraps ceph_ts into a kvec and adds it to con->out_kvec array, yet
    ceph_ts becomes invalid on return from prepare_write_keepalive().  As
    a result, we send out bogus keepalive2 stamps.  Fix this by encoding
    into a ceph_timespec member, similar to how acks are read and written.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Yan, Zheng <zyan@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 7e1252e97a30..b2371d9b51fa 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -238,6 +238,8 @@ struct ceph_connection {
 	bool out_kvec_is_msg; /* kvec refers to out_msg */
 	int out_more;        /* there is more data after the kvecs */
 	__le64 out_temp_ack; /* for writing an ack */
+	struct ceph_timespec out_temp_keepalive2; /* for writing keepalive2
+						     stamp */
 
 	/* message in temps */
 	struct ceph_msg_header in_hdr;
@@ -248,7 +250,7 @@ struct ceph_connection {
 	int in_base_pos;     /* bytes read */
 	__le64 in_temp_ack;  /* for reading an ack */
 
-	struct timespec last_keepalive_ack;
+	struct timespec last_keepalive_ack; /* keepalive2 ack stamp */
 
 	struct delayed_work work;	    /* send|recv work */
 	unsigned long       delay;          /* current delay interval */

commit 8b9558aab853e98ba6e3fee0dd8545544966958c
Author: Yan, Zheng <zyan@redhat.com>
Date:   Tue Sep 1 17:19:38 2015 +0800

    libceph: use keepalive2 to verify the mon session is alive
    
    Signed-off-by: Yan, Zheng <zyan@redhat.com>
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 37753278987a..7e1252e97a30 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -248,6 +248,8 @@ struct ceph_connection {
 	int in_base_pos;     /* bytes read */
 	__le64 in_temp_ack;  /* for reading an ack */
 
+	struct timespec last_keepalive_ack;
+
 	struct delayed_work work;	    /* send|recv work */
 	unsigned long       delay;          /* current delay interval */
 };
@@ -285,6 +287,8 @@ extern void ceph_msg_revoke(struct ceph_msg *msg);
 extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
 
 extern void ceph_con_keepalive(struct ceph_connection *con);
+extern bool ceph_con_keepalive_expired(struct ceph_connection *con,
+				       unsigned long interval);
 
 extern void ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,
 				size_t length, size_t alignment);

commit 757856d2b9568a701df9ea6a4be68effbb9d6f44
Author: Ilya Dryomov <idryomov@gmail.com>
Date:   Thu Jun 25 17:47:45 2015 +0300

    libceph: enable ceph in a non-default network namespace
    
    Grab a reference on a network namespace of the 'rbd map' (in case of
    rbd) or 'mount' (in case of ceph) process and use that to open sockets
    instead of always using init_net and bailing if network namespace is
    anything but init_net.  Be careful to not share struct ceph_client
    instances between different namespaces and don't add any code in the
    !CONFIG_NET_NS case.
    
    This is based on a patch from Hong Zhiguo <zhiguohong@tencent.com>.
    
    Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index e15499422fdc..37753278987a 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -8,6 +8,7 @@
 #include <linux/radix-tree.h>
 #include <linux/uio.h>
 #include <linux/workqueue.h>
+#include <net/net_namespace.h>
 
 #include <linux/ceph/types.h>
 #include <linux/ceph/buffer.h>
@@ -56,6 +57,7 @@ struct ceph_messenger {
 	struct ceph_entity_addr my_enc_addr;
 
 	atomic_t stopping;
+	possible_net_t net;
 	bool nocrc;
 	bool tcp_nodelay;
 
@@ -267,6 +269,7 @@ extern void ceph_messenger_init(struct ceph_messenger *msgr,
 			u64 required_features,
 			bool nocrc,
 			bool tcp_nodelay);
+extern void ceph_messenger_fini(struct ceph_messenger *msgr);
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,
 			const struct ceph_connection_operations *ops,

commit ba988f87f532cd2b8c4740aa8ec49056521ae833
Author: Chaitanya Huilgol <chaitanya.huilgol@gmail.com>
Date:   Fri Jan 23 16:41:25 2015 +0530

    libceph: tcp_nodelay support
    
    TCP_NODELAY socket option set on connection sockets,
    disables Nagle’s algorithm and improves latency characteristics.
    tcp_nodelay(default)/notcp_nodelay option flags provided to
    enable/disable setting the socket option.
    
    Signed-off-by: Chaitanya Huilgol <chaitanya.huilgol@sandisk.com>
    [idryomov@redhat.com: NO_TCP_NODELAY -> TCP_NODELAY, minor adjustments]
    Signed-off-by: Ilya Dryomov <idryomov@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index d9d396c16503..e15499422fdc 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -57,6 +57,7 @@ struct ceph_messenger {
 
 	atomic_t stopping;
 	bool nocrc;
+	bool tcp_nodelay;
 
 	/*
 	 * the global_seq counts connections i (attempt to) initiate
@@ -264,7 +265,8 @@ extern void ceph_messenger_init(struct ceph_messenger *msgr,
 			struct ceph_entity_addr *myaddr,
 			u64 supported_features,
 			u64 required_features,
-			bool nocrc);
+			bool nocrc,
+			bool tcp_nodelay);
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,
 			const struct ceph_connection_operations *ops,

commit 33d07337962c7bbd2fd5cf7f1106735c9507fbe2
Author: Yan, Zheng <zyan@redhat.com>
Date:   Tue Nov 4 16:33:37 2014 +0800

    libceph: message signature support
    
    Signed-off-by: Yan, Zheng <zyan@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 40ae58e3e9db..d9d396c16503 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -42,6 +42,10 @@ struct ceph_connection_operations {
 	struct ceph_msg * (*alloc_msg) (struct ceph_connection *con,
 					struct ceph_msg_header *hdr,
 					int *skip);
+	int (*sign_message) (struct ceph_connection *con, struct ceph_msg *msg);
+
+	int (*check_message_signature) (struct ceph_connection *con,
+					struct ceph_msg *msg);
 };
 
 /* use format string %s%d */
@@ -142,7 +146,10 @@ struct ceph_msg_data_cursor {
  */
 struct ceph_msg {
 	struct ceph_msg_header hdr;	/* header */
-	struct ceph_msg_footer footer;	/* footer */
+	union {
+		struct ceph_msg_footer footer;		/* footer */
+		struct ceph_msg_footer_old old_footer;	/* old format footer */
+	};
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 

commit 0215e44bb390a968d01404aa2f35af56f9b55fc8
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Fri Jun 20 14:14:41 2014 +0400

    libceph: move and add dout()s to ceph_msg_{get,put}()
    
    Add dout()s to ceph_msg_{get,put}().  Also move them to .c and turn
    kref release callback into a static function.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index d21f2dba0731..40ae58e3e9db 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -285,19 +285,9 @@ extern void ceph_msg_data_add_bio(struct ceph_msg *msg, struct bio *bio,
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);
-extern void ceph_msg_kfree(struct ceph_msg *m);
 
-
-static inline struct ceph_msg *ceph_msg_get(struct ceph_msg *msg)
-{
-	kref_get(&msg->kref);
-	return msg;
-}
-extern void ceph_msg_last_put(struct kref *kref);
-static inline void ceph_msg_put(struct ceph_msg *msg)
-{
-	kref_put(&msg->kref, ceph_msg_last_put);
-}
+extern struct ceph_msg *ceph_msg_get(struct ceph_msg *msg);
+extern void ceph_msg_put(struct ceph_msg *msg);
 
 extern void ceph_msg_dump(struct ceph_msg *msg);
 

commit f568849edac8611d603e00bd6cbbcfea09395ae6
Merge: d9894c228b11 675675ada486
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 30 11:19:05 2014 -0800

    Merge branch 'for-3.14/core' of git://git.kernel.dk/linux-block
    
    Pull core block IO changes from Jens Axboe:
     "The major piece in here is the immutable bio_ve series from Kent, the
      rest is fairly minor.  It was supposed to go in last round, but
      various issues pushed it to this release instead.  The pull request
      contains:
    
       - Various smaller blk-mq fixes from different folks.  Nothing major
         here, just minor fixes and cleanups.
    
       - Fix for a memory leak in the error path in the block ioctl code
         from Christian Engelmayer.
    
       - Header export fix from CaiZhiyong.
    
       - Finally the immutable biovec changes from Kent Overstreet.  This
         enables some nice future work on making arbitrarily sized bios
         possible, and splitting more efficient.  Related fixes to immutable
         bio_vecs:
    
            - dm-cache immutable fixup from Mike Snitzer.
            - btrfs immutable fixup from Muthu Kumar.
    
      - bio-integrity fix from Nic Bellinger, which is also going to stable"
    
    * 'for-3.14/core' of git://git.kernel.dk/linux-block: (44 commits)
      xtensa: fixup simdisk driver to work with immutable bio_vecs
      block/blk-mq-cpu.c: use hotcpu_notifier()
      blk-mq: for_each_* macro correctness
      block: Fix memory leak in rw_copy_check_uvector() handling
      bio-integrity: Fix bio_integrity_verify segment start bug
      block: remove unrelated header files and export symbol
      blk-mq: uses page->list incorrectly
      blk-mq: use __smp_call_function_single directly
      btrfs: fix missing increment of bi_remaining
      Revert "block: Warn and free bio if bi_end_io is not set"
      block: Warn and free bio if bi_end_io is not set
      blk-mq: fix initializing request's start time
      block: blk-mq: don't export blk_mq_free_queue()
      block: blk-mq: make blk_sync_queue support mq
      block: blk-mq: support draining mq queue
      dm cache: increment bi_remaining when bi_end_io is restored
      block: fixup for generic bio chaining
      block: Really silence spurious compiler warnings
      block: Silence spurious compiler warnings
      block: Kill bio_pair_split()
      ...

commit eeb0bed5572b1282009dfc2635604df5a35d1a02
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Thu Jan 9 20:08:21 2014 +0200

    libceph: add ceph_kv{malloc,free}() and switch to them
    
    Encapsulate kmalloc vs vmalloc memory allocation and freeing logic into
    two helpers, ceph_kvmalloc() and ceph_kvfree(), and switch to them.
    
    ceph_kvmalloc() kmalloc()'s a maximum of 8 pages, anything bigger is
    vmalloc()'ed with __GFP_HIGHMEM set.  This changes the existing
    behaviour:
    
    - for buffers (ceph_buffer_new()), from trying to kmalloc() everything
      and using vmalloc() just as a fallback
    
    - for messages (ceph_msg_new()), from going to vmalloc() for anything
      bigger than a page
    
    - for messages (ceph_msg_new()), from disallowing vmalloc() to use high
      memory
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 861138f7c161..20ee8b63a968 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -154,7 +154,6 @@ struct ceph_msg {
 	struct list_head list_head;	/* links for connection lists */
 
 	struct kref kref;
-	bool front_is_vmalloc;
 	bool more_to_follow;
 	bool needs_out_seq;
 	int front_alloc_len;

commit 3cea4c3071d4e55e9d7356efe9d0ebf92f0c2204
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Thu Jan 9 20:08:21 2014 +0200

    libceph: rename ceph_msg::front_max to front_alloc_len
    
    Rename front_max field of struct ceph_msg to front_alloc_len to make
    its purpose more clear.
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c1d3f5a65273..861138f7c161 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -157,7 +157,7 @@ struct ceph_msg {
 	bool front_is_vmalloc;
 	bool more_to_follow;
 	bool needs_out_seq;
-	int front_max;
+	int front_alloc_len;
 	unsigned long ack_stamp;        /* tx: when we were acked */
 
 	struct ceph_msgpool *pool;

commit 12b4629a9fb80fecaebadc217b13b8776ed8dbef
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Dec 24 21:19:23 2013 +0200

    libceph: all features fields must be u64
    
    In preparation for ceph_features.h update, change all features fields
    from unsigned int/u32 to u64.  (ceph.git has ~40 feature bits at this
    point.)
    
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 7c1420bb1dce..c1d3f5a65273 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -60,8 +60,8 @@ struct ceph_messenger {
 	u32 global_seq;
 	spinlock_t global_seq_lock;
 
-	u32 supported_features;
-	u32 required_features;
+	u64 supported_features;
+	u64 required_features;
 };
 
 enum ceph_msg_data_type {
@@ -192,7 +192,7 @@ struct ceph_connection {
 
 	struct ceph_entity_name peer_name; /* peer name */
 
-	unsigned peer_features;
+	u64 peer_features;
 	u32 connect_seq;      /* identify the most recent connection
 				 attempt for this connection, client */
 	u32 peer_global_seq;  /* peer's global seq for this connection */
@@ -256,8 +256,8 @@ extern void ceph_msgr_flush(void);
 
 extern void ceph_messenger_init(struct ceph_messenger *msgr,
 			struct ceph_entity_addr *myaddr,
-			u32 supported_features,
-			u32 required_features,
+			u64 supported_features,
+			u64 required_features,
 			bool nocrc);
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,

commit f38a5181d9f3e004b1f50f9d7e1f2a8492ce240a
Author: Kent Overstreet <kmo@daterainc.com>
Date:   Wed Aug 7 14:30:24 2013 -0700

    ceph: Convert to immutable biovecs
    
    Now that we've got a mechanism for immutable biovecs -
    bi_iter.bi_bvec_done - we need to convert drivers to use primitives that
    respect it instead of using the bvec array directly.
    
    Signed-off-by: Kent Overstreet <kmo@daterainc.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Sage Weil <sage@inktank.com>
    Cc: ceph-devel@vger.kernel.org

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 7c1420bb1dce..091fdb600d55 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -1,6 +1,7 @@
 #ifndef __FS_CEPH_MESSENGER_H
 #define __FS_CEPH_MESSENGER_H
 
+#include <linux/blk_types.h>
 #include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/net.h>
@@ -119,8 +120,7 @@ struct ceph_msg_data_cursor {
 #ifdef CONFIG_BLOCK
 		struct {				/* bio */
 			struct bio	*bio;		/* bio from list */
-			unsigned int	vector_index;	/* vector from bio */
-			unsigned int	vector_offset;	/* bytes from vector */
+			struct bvec_iter bvec_iter;
 		};
 #endif /* CONFIG_BLOCK */
 		struct {				/* pages */

commit 90af36022aecdeeb1b9c0755461187de717c86dd
Author: Alex Elder <elder@inktank.com>
Date:   Fri Apr 5 14:46:01 2013 -0500

    libceph: add, don't set data for a message
    
    Change the names of the functions that put data on a pagelist to
    reflect that we're adding to whatever's already there rather than
    just setting it to the one thing.  Currently only one data item is
    ever added to a message, but that's about to change.
    
    This resolves:
        http://tracker.ceph.com/issues/2770
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index de1d2e1ecce2..7c1420bb1dce 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -275,12 +275,12 @@ extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
 
 extern void ceph_con_keepalive(struct ceph_connection *con);
 
-extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
+extern void ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,
 				size_t length, size_t alignment);
-extern void ceph_msg_data_set_pagelist(struct ceph_msg *msg,
+extern void ceph_msg_data_add_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
 #ifdef CONFIG_BLOCK
-extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio,
+extern void ceph_msg_data_add_bio(struct ceph_msg *msg, struct bio *bio,
 				size_t length);
 #endif /* CONFIG_BLOCK */
 

commit ca8b3a69174b04376722672d7dd6b666a7f17c50
Author: Alex Elder <elder@inktank.com>
Date:   Fri Apr 5 14:46:01 2013 -0500

    libceph: implement multiple data items in a message
    
    This patch adds support to the messenger for more than one data item
    in its data list.
    
    A message data cursor has two more fields to support this:
        - a count of the number of bytes left to be consumed across
          all data items in the list, "total_resid"
        - a pointer to the head of the list (for validation only)
    
    The cursor initialization routine has been split into two parts: the
    outer one, which initializes the cursor for traversing the entire
    list of data items; and the inner one, which initializes the cursor
    to start processing a single data item.
    
    When a message cursor is first initialized, the outer initialization
    routine sets total_resid to the length provided.  The data pointer
    is initialized to the first data item on the list.  From there, the
    inner initialization routine finishes by setting up to process the
    data item the cursor points to.
    
    Advancing the cursor consumes bytes in total_resid.  If the resid
    field reaches zero, it means the current data item is fully
    consumed.  If total_resid indicates there is more data, the cursor
    is advanced to point to the next data item, and then the inner
    initialization routine prepares for using that.  (A check is made at
    this point to make sure we don't wrap around the front of the list.)
    
    The type-specific init routines are modified so they can be given a
    length that's larger than what the data item can support.  The resid
    field is initialized to the smaller of the provided length and the
    length of the entire data item.
    
    When total_resid reaches zero, we're done.
    
    This resolves:
        http://tracker.ceph.com/issues/3761
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 318da0170a1e..de1d2e1ecce2 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -108,7 +108,10 @@ struct ceph_msg_data {
 };
 
 struct ceph_msg_data_cursor {
-	struct ceph_msg_data	*data;		/* data item this describes */
+	size_t			total_resid;	/* across all data items */
+	struct list_head	*data_head;	/* = &ceph_msg->data */
+
+	struct ceph_msg_data	*data;		/* current data item */
 	size_t			resid;		/* bytes not yet consumed */
 	bool			last_piece;	/* current is last piece */
 	bool			need_crc;	/* crc update needed */

commit 5240d9f95dfe0f0701b35fbff1cb5b70825ad23f
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 14 14:09:06 2013 -0500

    libceph: replace message data pointer with list
    
    In place of the message data pointer, use a list head which links
    through message data items.  For now we only support a single entry
    on that list.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 8846ff610502..318da0170a1e 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -89,6 +89,7 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 }
 
 struct ceph_msg_data {
+	struct list_head		links;	/* ceph_msg->data */
 	enum ceph_msg_data_type		type;
 	union {
 #ifdef CONFIG_BLOCK
@@ -143,7 +144,7 @@ struct ceph_msg {
 	struct ceph_buffer *middle;
 
 	size_t				data_length;
-	struct ceph_msg_data		*data;
+	struct list_head		data;
 	struct ceph_msg_data_cursor	cursor;
 
 	struct ceph_connection *con;

commit 8ae4f4f5c056150d5480710ab356801e84d01a3d
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 14 14:09:06 2013 -0500

    libceph: have cursor point to data
    
    Rather than having a ceph message data item point to the cursor it's
    associated with, have the cursor point to a data item.  This will
    allow a message cursor to be used for more than one data item.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index e7557242817c..8846ff610502 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -104,13 +104,13 @@ struct ceph_msg_data {
 		};
 		struct ceph_pagelist	*pagelist;
 	};
-	struct ceph_msg_data_cursor	*cursor;
 };
 
 struct ceph_msg_data_cursor {
-	size_t		resid;		/* bytes not yet consumed */
-	bool		last_piece;	/* now at last piece of data item */
-	bool		need_crc;	/* new piece; crc update needed */
+	struct ceph_msg_data	*data;		/* data item this describes */
+	size_t			resid;		/* bytes not yet consumed */
+	bool			last_piece;	/* current is last piece */
+	bool			need_crc;	/* crc update needed */
 	union {
 #ifdef CONFIG_BLOCK
 		struct {				/* bio */

commit 36153ec9dd6287d7cedf6afb51453c445d946cee
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 14 14:09:06 2013 -0500

    libceph: move cursor into message
    
    A message will only be processing a single data item at a time, so
    there's no need for each data item to have its own cursor.
    
    Move the cursor embedded in the message data structure into the
    message itself.  To minimize the impact, keep the data->cursor
    field, but make it be a pointer to the cursor in the message.
    
    Move the definition of ceph_msg_data above ceph_msg_data_cursor so
    the cursor can point to the data without a forward definition rather
    than vice-versa.
    
    This and the upcoming patches are part of:
        http://tracker.ceph.com/issues/3761
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 4fb870a5b5fc..e7557242817c 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -88,6 +88,25 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 	}
 }
 
+struct ceph_msg_data {
+	enum ceph_msg_data_type		type;
+	union {
+#ifdef CONFIG_BLOCK
+		struct {
+			struct bio	*bio;
+			size_t		bio_length;
+		};
+#endif /* CONFIG_BLOCK */
+		struct {
+			struct page	**pages;	/* NOT OWNER. */
+			size_t		length;		/* total # bytes */
+			unsigned int	alignment;	/* first page */
+		};
+		struct ceph_pagelist	*pagelist;
+	};
+	struct ceph_msg_data_cursor	*cursor;
+};
+
 struct ceph_msg_data_cursor {
 	size_t		resid;		/* bytes not yet consumed */
 	bool		last_piece;	/* now at last piece of data item */
@@ -112,25 +131,6 @@ struct ceph_msg_data_cursor {
 	};
 };
 
-struct ceph_msg_data {
-	enum ceph_msg_data_type		type;
-	union {
-#ifdef CONFIG_BLOCK
-		struct {
-			struct bio	*bio;
-			size_t		bio_length;
-		};
-#endif /* CONFIG_BLOCK */
-		struct {
-			struct page	**pages;	/* NOT OWNER. */
-			size_t		length;		/* total # bytes */
-			unsigned int	alignment;	/* first page */
-		};
-		struct ceph_pagelist	*pagelist;
-	};
-	struct ceph_msg_data_cursor	cursor;		/* pagelist only */
-};
-
 /*
  * a single message.  it contains a header (src, dest, message type, etc.),
  * footer (crc values, mainly), a "front" message body, and possibly a
@@ -142,8 +142,9 @@ struct ceph_msg {
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 
-	size_t			data_length;
-	struct ceph_msg_data	*data;	/* data payload */
+	size_t				data_length;
+	struct ceph_msg_data		*data;
+	struct ceph_msg_data_cursor	cursor;
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */

commit c851c49591ebf000c610711e39eea7da5ff05b21
Author: Alex Elder <elder@inktank.com>
Date:   Fri Apr 5 14:46:01 2013 -0500

    libceph: record bio length
    
    The bio is the only data item type that doesn't record its full
    length.  Fix that.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index cdeebae03e0d..4fb870a5b5fc 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -116,7 +116,10 @@ struct ceph_msg_data {
 	enum ceph_msg_data_type		type;
 	union {
 #ifdef CONFIG_BLOCK
-		struct bio		*bio;
+		struct {
+			struct bio	*bio;
+			size_t		bio_length;
+		};
 #endif /* CONFIG_BLOCK */
 		struct {
 			struct page	**pages;	/* NOT OWNER. */

commit ea96571f7b865edaf1acd472e6f2cddc9fb67892
Author: Alex Elder <elder@inktank.com>
Date:   Fri Apr 5 14:46:01 2013 -0500

    libceph: fix possible CONFIG_BLOCK build problem
    
    This patch:
        15a0d7b libceph: record message data length
    did not enclose some bio-specific code inside CONFIG_BLOCK as
    it should have.  Fix that.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index b832c0ce899a..cdeebae03e0d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -271,8 +271,10 @@ extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
 				size_t length, size_t alignment);
 extern void ceph_msg_data_set_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
+#ifdef CONFIG_BLOCK
 extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio,
 				size_t length);
+#endif /* CONFIG_BLOCK */
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit a19308048182d5f9e16b03b1d1c038d9346c7589
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 14 14:09:06 2013 -0500

    libceph: record message data length
    
    Keep track of the length of the data portion for a message in a
    separate field in the ceph_msg structure.  This information has
    been maintained in wire byte order in the message header, but
    that's going to change soon.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 3181321bed6d..b832c0ce899a 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -139,6 +139,7 @@ struct ceph_msg {
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 
+	size_t			data_length;
 	struct ceph_msg_data	*data;	/* data payload */
 
 	struct ceph_connection *con;
@@ -270,7 +271,8 @@ extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
 				size_t length, size_t alignment);
 extern void ceph_msg_data_set_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
-extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio);
+extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio,
+				size_t length);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit 6644ed7b7e04f8e588aebdaa58cededb9416ab95
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:24 2013 -0500

    libceph: make message data be a pointer
    
    Begin the transition from a single message data item to a list of
    them by replacing the "data" structure in a message with a pointer
    to a ceph_msg_data structure.
    
    A null pointer will indicate the message has no data; replace the
    use of ceph_msg_has_data() with a simple check for a null pointer.
    
    Create functions ceph_msg_data_create() and ceph_msg_data_destroy()
    to dynamically allocate and free a data item structure of a given type.
    
    When a message has its data item "set," allocate one of these to
    hold the data description, and free it when the last reference to
    the message is dropped.
    
    This partially resolves:
        http://tracker.ceph.com/issues/4429
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 686df5bfa717..3181321bed6d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -64,8 +64,6 @@ struct ceph_messenger {
 	u32 required_features;
 };
 
-#define ceph_msg_has_data(m)		((m)->data.type != CEPH_MSG_DATA_NONE)
-
 enum ceph_msg_data_type {
 	CEPH_MSG_DATA_NONE,	/* message contains no data payload */
 	CEPH_MSG_DATA_PAGES,	/* data source/destination is a page array */
@@ -141,8 +139,7 @@ struct ceph_msg {
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 
-	/* data payload */
-	struct ceph_msg_data	data;
+	struct ceph_msg_data	*data;	/* data payload */
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */

commit f5db90bcf2c69d099f9d828a8104796f41de6bc5
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:23 2013 -0500

    libceph: kill last of ceph_msg_pos
    
    The only remaining field in the ceph_msg_pos structure is
    did_page_crc.  In the new cursor model of things that flag (or
    something like it) belongs in the cursor.
    
    Define a new field "need_crc" in the cursor (which applies to all
    types of data) and initialize it to true whenever a cursor is
    initialized.
    
    In write_partial_message_data(), the data CRC still will be computed
    as before, but it will check the cursor->need_crc field to determine
    whether it's needed.  Any time the cursor is advanced to a new piece
    of a data item, need_crc will be set, and this will cause the crc
    for that entire piece to be accumulated into the data crc.
    
    In write_partial_message_data() the intermediate crc value is now
    held in a local variable so it doesn't have to be byte-swapped so
    many times.  In read_partial_msg_data() we do something similar
    (but mainly for consistency there).
    
    With that, the ceph_msg_pos structure can go away,  and it no longer
    needs to be passed as an argument to prepare_message_data().
    
    This cleanup is related to:
        http://tracker.ceph.com/issues/4428
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c76b228cb524..686df5bfa717 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -93,6 +93,7 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 struct ceph_msg_data_cursor {
 	size_t		resid;		/* bytes not yet consumed */
 	bool		last_piece;	/* now at last piece of data item */
+	bool		need_crc;	/* new piece; crc update needed */
 	union {
 #ifdef CONFIG_BLOCK
 		struct {				/* bio */
@@ -156,10 +157,6 @@ struct ceph_msg {
 	struct ceph_msgpool *pool;
 };
 
-struct ceph_msg_pos {
-	bool did_page_crc;   /* true if we've calculated crc for current page */
-};
-
 /* ceph connection fault delay defaults, for exponential backoff */
 #define BASE_DELAY_INTERVAL	(HZ/2)
 #define MAX_DELAY_INTERVAL	(5 * 60 * HZ)
@@ -217,7 +214,6 @@ struct ceph_connection {
 	struct ceph_msg *out_msg;        /* sending message (== tail of
 					    out_sent) */
 	bool out_msg_done;
-	struct ceph_msg_pos out_msg_pos;
 
 	struct kvec out_kvec[8],         /* sending header/footer data */
 		*out_kvec_cur;
@@ -231,7 +227,6 @@ struct ceph_connection {
 	/* message in temps */
 	struct ceph_msg_header in_hdr;
 	struct ceph_msg *in_msg;
-	struct ceph_msg_pos in_msg_pos;
 	u32 in_front_crc, in_middle_crc, in_data_crc;  /* calculated crc */
 
 	char in_tag;         /* protocol control byte */

commit 859a35d5523e8e6a5c3568c12febe2e1270bc3a1
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:23 2013 -0500

    libceph: kill most of ceph_msg_pos
    
    All but one of the fields in the ceph_msg_pos structure are now
    never used (only assigned), so get rid of them.  This allows
    several small blocks of code to go away.
    
    This is cleanup of old code related to:
        http://tracker.ceph.com/issues/4428
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index af786b29f7a4..c76b228cb524 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -157,8 +157,6 @@ struct ceph_msg {
 };
 
 struct ceph_msg_pos {
-	int page, page_pos;  /* which page; offset in page */
-	int data_pos;        /* offset in data payload */
 	bool did_page_crc;   /* true if we've calculated crc for current page */
 };
 

commit 4c59b4a278f9b7a418ad8af933fd7b341df64393
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:23 2013 -0500

    libceph: collapse all data items into one
    
    It turns out that only one of the data item types is ever used at
    any one time in a single message (currently).
        - A page array is used by the osd client (on behalf of the file
          system) and by rbd.  Only one osd op (and therefore at most
          one data item) is ever used at a time by rbd.  And the only
          time the file system sends two, the second op contains no
          data.
        - A bio is only used by the rbd client (and again, only one
          data item per message)
        - A page list is used by the file system and by rbd for outgoing
          data, but only one op (and one data item) at a time.
    
    We can therefore collapse all three of our data item fields into a
    single field "data", and depend on the messenger code to properly
    handle it based on its type.
    
    This allows us to eliminate quite a bit of duplicated code.
    
    This is related to:
        http://tracker.ceph.com/issues/4429
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 252e01b7f7de..af786b29f7a4 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -64,11 +64,7 @@ struct ceph_messenger {
 	u32 required_features;
 };
 
-#define ceph_msg_has_pages(m)		((m)->p.type == CEPH_MSG_DATA_PAGES)
-#define ceph_msg_has_pagelist(m)	((m)->l.type == CEPH_MSG_DATA_PAGELIST)
-#ifdef CONFIG_BLOCK
-#define ceph_msg_has_bio(m)		((m)->b.type == CEPH_MSG_DATA_BIO)
-#endif /* CONFIG_BLOCK */
+#define ceph_msg_has_data(m)		((m)->data.type != CEPH_MSG_DATA_NONE)
 
 enum ceph_msg_data_type {
 	CEPH_MSG_DATA_NONE,	/* message contains no data payload */
@@ -145,11 +141,7 @@ struct ceph_msg {
 	struct ceph_buffer *middle;
 
 	/* data payload */
-	struct ceph_msg_data	p;	/* pages */
-	struct ceph_msg_data	l;	/* pagelist */
-#ifdef CONFIG_BLOCK
-	struct ceph_msg_data	b;	/* bio */
-#endif /* CONFIG_BLOCK */
+	struct ceph_msg_data	data;
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */

commit 6518be47f910f62a98cb6044dbb457af55241f95
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:23 2013 -0500

    libceph: kill ceph message bio_iter, bio_seg
    
    The bio_iter and bio_seg fields in a message are no longer used, we
    use the cursor instead.  So get rid of them and the functions that
    operate on them them.
    
    This is related to:
        http://tracker.ceph.com/issues/4428
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 459e55280bf8..252e01b7f7de 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -121,11 +121,7 @@ struct ceph_msg_data {
 	enum ceph_msg_data_type		type;
 	union {
 #ifdef CONFIG_BLOCK
-		struct {
-			struct bio	*bio_iter;	/* iterator */
-			struct bio	*bio;
-			unsigned int	bio_seg;	/* current seg in bio */
-		};
+		struct bio		*bio;
 #endif /* CONFIG_BLOCK */
 		struct {
 			struct page	**pages;	/* NOT OWNER. */

commit 25aff7c559c8b54a810bc094d59fe037cfed6b18
Author: Alex Elder <elder@inktank.com>
Date:   Mon Mar 11 23:34:22 2013 -0500

    libceph: record residual bytes for all message data types
    
    All of the data types can use this, not just the page array.  Until
    now, only the bio type doesn't have it available, and only the
    initiator of the request (the rbd client) is able to supply the
    length of the full request without re-scanning the bio list.  Change
    the cursor init routines so the length is supplied based on the
    message header "data_len" field, and use that length to intiialize
    the "resid" field of the cursor.
    
    In addition, change the way "last_piece" is defined so it is based
    on the residual number of bytes in the original request.  This is
    necessary (at least for bio messages) because it is possible for
    a read request to succeed without consuming all of the space
    available in the data buffer.
    
    This resolves:
        http://tracker.ceph.com/issues/4427
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 0e4536cc46f0..459e55280bf8 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -95,6 +95,7 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 }
 
 struct ceph_msg_data_cursor {
+	size_t		resid;		/* bytes not yet consumed */
 	bool		last_piece;	/* now at last piece of data item */
 	union {
 #ifdef CONFIG_BLOCK
@@ -105,7 +106,6 @@ struct ceph_msg_data_cursor {
 		};
 #endif /* CONFIG_BLOCK */
 		struct {				/* pages */
-			size_t		resid;		/* bytes from array */
 			unsigned int	page_offset;	/* offset in page */
 			unsigned short	page_index;	/* index in array */
 			unsigned short	page_count;	/* pages in array */

commit 9d2a06c2750177dca5f8d0e89884c1d409d64bbc
Author: Alex Elder <elder@inktank.com>
Date:   Fri Mar 8 13:35:36 2013 -0600

    libceph: kill message trail
    
    The wart that is the ceph message trail can now be removed, because
    its only user was the osd client, and the previous patch made that
    no longer the case.
    
    The result allows write_partial_msg_pages() to be simplified
    considerably.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index b53b9ef65009..0e4536cc46f0 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -69,7 +69,6 @@ struct ceph_messenger {
 #ifdef CONFIG_BLOCK
 #define ceph_msg_has_bio(m)		((m)->b.type == CEPH_MSG_DATA_BIO)
 #endif /* CONFIG_BLOCK */
-#define ceph_msg_has_trail(m)		((m)->t.type == CEPH_MSG_DATA_PAGELIST)
 
 enum ceph_msg_data_type {
 	CEPH_MSG_DATA_NONE,	/* message contains no data payload */
@@ -155,7 +154,6 @@ struct ceph_msg {
 #ifdef CONFIG_BLOCK
 	struct ceph_msg_data	b;	/* bio */
 #endif /* CONFIG_BLOCK */
-	struct ceph_msg_data	t;	/* trail */
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */
@@ -295,8 +293,6 @@ extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
 extern void ceph_msg_data_set_pagelist(struct ceph_msg *msg,
 				struct ceph_pagelist *pagelist);
 extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio);
-extern void ceph_msg_data_set_trail(struct ceph_msg *msg,
-				struct ceph_pagelist *trail);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit e766d7b55e10f93c7bab298135a4e90dcc46620d
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 7 15:38:28 2013 -0600

    libceph: implement pages array cursor
    
    Implement and use cursor routines for page array message data items
    for outbound message data.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 76b4645e2dff..b53b9ef65009 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -105,6 +105,12 @@ struct ceph_msg_data_cursor {
 			unsigned int	vector_offset;	/* bytes from vector */
 		};
 #endif /* CONFIG_BLOCK */
+		struct {				/* pages */
+			size_t		resid;		/* bytes from array */
+			unsigned int	page_offset;	/* offset in page */
+			unsigned short	page_index;	/* index in array */
+			unsigned short	page_count;	/* pages in array */
+		};
 		struct {				/* pagelist */
 			struct page	*page;		/* page from list */
 			size_t		offset;		/* bytes from list */

commit 6aaa4511deb4b0fd776d1153dc63a89cdc024fb8
Author: Alex Elder <elder@inktank.com>
Date:   Wed Mar 6 23:39:39 2013 -0600

    libceph: implement bio message data item cursor
    
    Implement and use cursor routines for bio message data items for
    outbound message data.
    
    (See the previous commit for reasoning in support of the changes
    in out_msg_pos_next().)
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 716c3fdeb257..76b4645e2dff 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -98,6 +98,13 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 struct ceph_msg_data_cursor {
 	bool		last_piece;	/* now at last piece of data item */
 	union {
+#ifdef CONFIG_BLOCK
+		struct {				/* bio */
+			struct bio	*bio;		/* bio from list */
+			unsigned int	vector_index;	/* vector from bio */
+			unsigned int	vector_offset;	/* bytes from vector */
+		};
+#endif /* CONFIG_BLOCK */
 		struct {				/* pagelist */
 			struct page	*page;		/* page from list */
 			size_t		offset;		/* bytes from list */

commit dd236fcb65d7b6b80c408cb5f66aab55f4594284
Author: Alex Elder <elder@inktank.com>
Date:   Wed Mar 6 23:39:39 2013 -0600

    libceph: prepare for other message data item types
    
    This just inserts some infrastructure in preparation for handling
    other types of ceph message data items.  No functional changes,
    just trying to simplify review by separating out some noise.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 14862438faff..716c3fdeb257 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -97,8 +97,12 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 
 struct ceph_msg_data_cursor {
 	bool		last_piece;	/* now at last piece of data item */
-	struct page	*page;		/* current page in pagelist */
-	size_t		offset;		/* pagelist bytes consumed */
+	union {
+		struct {				/* pagelist */
+			struct page	*page;		/* page from list */
+			size_t		offset;		/* bytes from list */
+		};
+	};
 };
 
 struct ceph_msg_data {

commit fe38a2b67bc6b3a60da82a23e9082256a30e39d9
Author: Alex Elder <elder@inktank.com>
Date:   Wed Mar 6 23:39:39 2013 -0600

    libceph: start defining message data cursor
    
    This patch lays out the foundation for using generic routines to
    manage processing items of message data.
    
    For simplicity, we'll start with just the trail portion of a
    message, because it stands alone and is only present for outgoing
    data.
    
    First some basic concepts.  We'll use the term "data item" to
    represent one of the ceph_msg_data structures associated with a
    message.  There are currently four of those, with single-letter
    field names p, l, b, and t.  A data item is further broken into
    "pieces" which always lie in a single page.  A data item will
    include a "cursor" that will track state as the memory defined by
    the item is consumed by sending data from or receiving data into it.
    
    We define three routines to manipulate a data item's cursor: the
    "init" routine; the "next" routine; and the "advance" routine.  The
    "init" routine initializes the cursor so it points at the beginning
    of the first piece in the item.  The "next" routine returns the
    page, page offset, and length (limited by both the page and item
    size) of the next unconsumed piece in the item.  It also indicates
    to the caller whether the piece being returned is the last one in
    the data item.
    
    The "advance" routine consumes the requested number of bytes in the
    item (advancing the cursor).  This is used to record the number of
    bytes from the current piece that were actually sent or received by
    the network code.  It returns an indication of whether the result
    means the current piece has been fully consumed.  This is used by
    the message send code to determine whether it should calculate the
    CRC for the next piece processed.
    
    The trail of a message is implemented as a ceph pagelist.  The
    routines defined for it will be usable for non-trail pagelist data
    as well.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 5860dd0c2caf..14862438faff 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -95,6 +95,12 @@ static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
 	}
 }
 
+struct ceph_msg_data_cursor {
+	bool		last_piece;	/* now at last piece of data item */
+	struct page	*page;		/* current page in pagelist */
+	size_t		offset;		/* pagelist bytes consumed */
+};
+
 struct ceph_msg_data {
 	enum ceph_msg_data_type		type;
 	union {
@@ -112,6 +118,7 @@ struct ceph_msg_data {
 		};
 		struct ceph_pagelist	*pagelist;
 	};
+	struct ceph_msg_data_cursor	cursor;		/* pagelist only */
 };
 
 /*

commit 437945094fed0deb1810e8da95465c8f26bc6f80
Author: Alex Elder <elder@inktank.com>
Date:   Fri Mar 1 18:00:16 2013 -0600

    libceph: abstract message data
    
    Group the types of message data into an abstract structure with a
    type indicator and a union containing fields appropriate to the
    type of data it represents.  Use this to represent the pages,
    pagelist, bio, and trail in a ceph message.
    
    Verify message data is of type NONE in ceph_msg_data_set_*()
    routines.  Since information about message data of type NONE really
    should not be interpreted, get rid of the other assertions in those
    functions.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index fb2b18a20c13..5860dd0c2caf 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -64,12 +64,55 @@ struct ceph_messenger {
 	u32 required_features;
 };
 
-#define ceph_msg_has_pages(m)		((m)->p.pages != NULL)
-#define ceph_msg_has_pagelist(m)	((m)->l.pagelist != NULL)
+#define ceph_msg_has_pages(m)		((m)->p.type == CEPH_MSG_DATA_PAGES)
+#define ceph_msg_has_pagelist(m)	((m)->l.type == CEPH_MSG_DATA_PAGELIST)
 #ifdef CONFIG_BLOCK
-#define ceph_msg_has_bio(m)		((m)->b.bio != NULL)
+#define ceph_msg_has_bio(m)		((m)->b.type == CEPH_MSG_DATA_BIO)
 #endif /* CONFIG_BLOCK */
-#define ceph_msg_has_trail(m)		((m)->t.trail != NULL)
+#define ceph_msg_has_trail(m)		((m)->t.type == CEPH_MSG_DATA_PAGELIST)
+
+enum ceph_msg_data_type {
+	CEPH_MSG_DATA_NONE,	/* message contains no data payload */
+	CEPH_MSG_DATA_PAGES,	/* data source/destination is a page array */
+	CEPH_MSG_DATA_PAGELIST,	/* data source/destination is a pagelist */
+#ifdef CONFIG_BLOCK
+	CEPH_MSG_DATA_BIO,	/* data source/destination is a bio list */
+#endif /* CONFIG_BLOCK */
+};
+
+static __inline__ bool ceph_msg_data_type_valid(enum ceph_msg_data_type type)
+{
+	switch (type) {
+	case CEPH_MSG_DATA_NONE:
+	case CEPH_MSG_DATA_PAGES:
+	case CEPH_MSG_DATA_PAGELIST:
+#ifdef CONFIG_BLOCK
+	case CEPH_MSG_DATA_BIO:
+#endif /* CONFIG_BLOCK */
+		return true;
+	default:
+		return false;
+	}
+}
+
+struct ceph_msg_data {
+	enum ceph_msg_data_type		type;
+	union {
+#ifdef CONFIG_BLOCK
+		struct {
+			struct bio	*bio_iter;	/* iterator */
+			struct bio	*bio;
+			unsigned int	bio_seg;	/* current seg in bio */
+		};
+#endif /* CONFIG_BLOCK */
+		struct {
+			struct page	**pages;	/* NOT OWNER. */
+			size_t		length;		/* total # bytes */
+			unsigned int	alignment;	/* first page */
+		};
+		struct ceph_pagelist	*pagelist;
+	};
+};
 
 /*
  * a single message.  it contains a header (src, dest, message type, etc.),
@@ -83,24 +126,12 @@ struct ceph_msg {
 	struct ceph_buffer *middle;
 
 	/* data payload */
-	struct {
-		struct page	**pages;	/* NOT OWNER. */
-		size_t		length;		/* # data bytes in array */
-		unsigned int	alignment;	/* first page */
-	} p;
-	struct {
-		struct ceph_pagelist	*pagelist;
-	} l;
+	struct ceph_msg_data	p;	/* pages */
+	struct ceph_msg_data	l;	/* pagelist */
 #ifdef CONFIG_BLOCK
-	struct {
-		struct bio	*bio_iter;	/* iterator */
-		struct bio	*bio;
-		unsigned int	bio_seg;	/* current seg in bio */
-	} b;
+	struct ceph_msg_data	b;	/* bio */
 #endif /* CONFIG_BLOCK */
-	struct {
-		struct ceph_pagelist *trail;	/* trailing part of data */
-	} t;
+	struct ceph_msg_data	t;	/* trail */
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */

commit f9e15777afd87585f2222dfd446c2e52deb65eba
Author: Alex Elder <elder@inktank.com>
Date:   Fri Mar 1 18:00:16 2013 -0600

    libceph: be explicit about message data representation
    
    A ceph message has a data payload portion.  The memory for that data
    (either the source of data to send or the location to place data
    that is received) is specified in several ways.  The ceph_msg
    structure includes fields for all of those ways, but this
    mispresents the fact that not all of them are used at a time.
    
    Specifically, the data in a message can be in:
        - an array of pages
        - a list of pages
        - a list of Linux bios
        - a second list of pages (the "trail")
    (The two page lists are currently only ever used for outgoing data.)
    
    Impose more structure on the ceph message, making the grouping of
    some of these fields explicit.  Shorten the name of the
    "page_alignment" field.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 889fe4720133..fb2b18a20c13 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -64,12 +64,12 @@ struct ceph_messenger {
 	u32 required_features;
 };
 
-#define ceph_msg_has_pages(m)		((m)->pages != NULL)
-#define ceph_msg_has_pagelist(m)	((m)->pagelist != NULL)
+#define ceph_msg_has_pages(m)		((m)->p.pages != NULL)
+#define ceph_msg_has_pagelist(m)	((m)->l.pagelist != NULL)
 #ifdef CONFIG_BLOCK
-#define ceph_msg_has_bio(m)		((m)->bio != NULL)
+#define ceph_msg_has_bio(m)		((m)->b.bio != NULL)
 #endif /* CONFIG_BLOCK */
-#define ceph_msg_has_trail(m)		((m)->trail != NULL)
+#define ceph_msg_has_trail(m)		((m)->t.trail != NULL)
 
 /*
  * a single message.  it contains a header (src, dest, message type, etc.),
@@ -82,16 +82,25 @@ struct ceph_msg {
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 
-	struct page **pages;		/* data payload.  NOT OWNER. */
-	unsigned int page_alignment;	/* io offset in first page */
-	size_t length;			/* # data bytes in array or list */
-	struct ceph_pagelist *pagelist; /* instead of pages */
+	/* data payload */
+	struct {
+		struct page	**pages;	/* NOT OWNER. */
+		size_t		length;		/* # data bytes in array */
+		unsigned int	alignment;	/* first page */
+	} p;
+	struct {
+		struct ceph_pagelist	*pagelist;
+	} l;
 #ifdef CONFIG_BLOCK
-	unsigned int bio_seg;		/* current bio segment */
-	struct bio  *bio;		/* instead of pages/pagelist */
-	struct bio  *bio_iter;		/* bio iterator */
+	struct {
+		struct bio	*bio_iter;	/* iterator */
+		struct bio	*bio;
+		unsigned int	bio_seg;	/* current seg in bio */
+	} b;
 #endif /* CONFIG_BLOCK */
-	struct ceph_pagelist *trail;	/* the trailing part of the data */
+	struct {
+		struct ceph_pagelist *trail;	/* trailing part of data */
+	} t;
 
 	struct ceph_connection *con;
 	struct list_head list_head;	/* links for connection lists */

commit 97fb1c7f6637ee61c90b8bc186d464cfd426b063
Author: Alex Elder <elder@inktank.com>
Date:   Fri Mar 1 18:00:16 2013 -0600

    libceph: define ceph_msg_has_*() data macros
    
    Define and use macros ceph_msg_has_*() to determine whether to
    operate on the pages, pagelist, bio, and trail fields of a message.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 1991a6f9dc90..889fe4720133 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -64,6 +64,13 @@ struct ceph_messenger {
 	u32 required_features;
 };
 
+#define ceph_msg_has_pages(m)		((m)->pages != NULL)
+#define ceph_msg_has_pagelist(m)	((m)->pagelist != NULL)
+#ifdef CONFIG_BLOCK
+#define ceph_msg_has_bio(m)		((m)->bio != NULL)
+#endif /* CONFIG_BLOCK */
+#define ceph_msg_has_trail(m)		((m)->trail != NULL)
+
 /*
  * a single message.  it contains a header (src, dest, message type, etc.),
  * footer (crc values, mainly), a "front" message body, and possibly a

commit 4a73ef27ad04f1b8ea23eb55e50b20fcc0530a6f
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 7 15:38:26 2013 -0600

    libceph: record message data byte length
    
    Record the number of bytes of data in a page array rather than the
    number of pages in the array.  It can be assumed that the page array
    is of sufficient size to hold the number of bytes indicated (and
    offset by the indicated alignment).
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 9d9be4682ac3..1991a6f9dc90 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -77,7 +77,7 @@ struct ceph_msg {
 
 	struct page **pages;		/* data payload.  NOT OWNER. */
 	unsigned int page_alignment;	/* io offset in first page */
-	unsigned int page_count;	/* # pages in array or list */
+	size_t length;			/* # data bytes in array or list */
 	struct ceph_pagelist *pagelist; /* instead of pages */
 #ifdef CONFIG_BLOCK
 	unsigned int bio_seg;		/* current bio segment */

commit 27fa83852ba275361eaa1a1283cf6704fa8191a6
Author: Alex Elder <elder@inktank.com>
Date:   Thu Feb 14 12:16:43 2013 -0600

    libceph: isolate other message data fields
    
    Define ceph_msg_data_set_pagelist(), ceph_msg_data_set_bio(), and
    ceph_msg_data_set_trail() to clearly abstract the assignment of the
    remaining data-related fields in a ceph message structure.  Use the
    new functions in the osd client and mds client.
    
    This partially resolves:
        http://tracker.ceph.com/issues/4263
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index e6d20e892a88..9d9be4682ac3 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -221,6 +221,11 @@ extern void ceph_con_keepalive(struct ceph_connection *con);
 
 extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
 				size_t length, size_t alignment);
+extern void ceph_msg_data_set_pagelist(struct ceph_msg *msg,
+				struct ceph_pagelist *pagelist);
+extern void ceph_msg_data_set_bio(struct ceph_msg *msg, struct bio *bio);
+extern void ceph_msg_data_set_trail(struct ceph_msg *msg,
+				struct ceph_pagelist *trail);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit f1baeb2b9fc1c2c87ec02f1bf8cb88e108d4fbce
Author: Alex Elder <elder@inktank.com>
Date:   Thu Mar 7 15:38:26 2013 -0600

    libceph: set page info with byte length
    
    When setting page array information for message data, provide the
    byte length rather than the page count ceph_msg_data_set_pages().
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index aa463b9b30af..e6d20e892a88 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -220,7 +220,7 @@ extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
 extern void ceph_con_keepalive(struct ceph_connection *con);
 
 extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
-				unsigned int page_count, size_t alignment);
+				size_t length, size_t alignment);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit 02afca6ca00b7972887c5cc77068356f33bdfc18
Author: Alex Elder <elder@inktank.com>
Date:   Thu Feb 14 12:16:43 2013 -0600

    libceph: isolate message page field manipulation
    
    Define a function ceph_msg_data_set_pages(), which more clearly
    abstracts the assignment page-related fields for data in a ceph
    message structure.  Use this new function in the osd client and mds
    client.
    
    Ideally, these fields would never be set more than once (with
    BUG_ON() calls to guarantee that).  At the moment though the osd
    client sets these every time it receives a message, and in the event
    of a communication problem this can happen more than once.  (This
    will be resolved shortly, but setting up these helpers first makes
    it all a bit easier to work with.)
    
    Rearrange the field order in a ceph_msg structure to group those
    that are used to define the possible data payloads.
    
    This partially resolves:
        http://tracker.ceph.com/issues/4263
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 6c118748a7f8..aa463b9b30af 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -74,21 +74,22 @@ struct ceph_msg {
 	struct ceph_msg_footer footer;	/* footer */
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
-	struct page **pages;            /* data payload.  NOT OWNER. */
-	unsigned page_count;		/* size of page array */
-	unsigned page_alignment;        /* io offset in first page */
-	struct ceph_pagelist *pagelist; /* instead of pages */
-
-	struct ceph_connection *con;
-	struct list_head list_head;
 
-	struct kref kref;
+	struct page **pages;		/* data payload.  NOT OWNER. */
+	unsigned int page_alignment;	/* io offset in first page */
+	unsigned int page_count;	/* # pages in array or list */
+	struct ceph_pagelist *pagelist; /* instead of pages */
 #ifdef CONFIG_BLOCK
+	unsigned int bio_seg;		/* current bio segment */
 	struct bio  *bio;		/* instead of pages/pagelist */
 	struct bio  *bio_iter;		/* bio iterator */
-	unsigned int bio_seg;		/* current bio segment */
 #endif /* CONFIG_BLOCK */
 	struct ceph_pagelist *trail;	/* the trailing part of the data */
+
+	struct ceph_connection *con;
+	struct list_head list_head;	/* links for connection lists */
+
+	struct kref kref;
 	bool front_is_vmalloc;
 	bool more_to_follow;
 	bool needs_out_seq;
@@ -218,6 +219,9 @@ extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
 
 extern void ceph_con_keepalive(struct ceph_connection *con);
 
+extern void ceph_msg_data_set_pages(struct ceph_msg *msg, struct page **pages,
+				unsigned int page_count, size_t alignment);
+
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);
 extern void ceph_msg_kfree(struct ceph_msg *m);

commit ec02a2f2ffae13e038453ae89592a8c6210f7f4d
Author: Alex Elder <elder@inktank.com>
Date:   Fri Mar 1 18:00:15 2013 -0600

    libceph: kill ceph_msg->pagelist_count
    
    The pagelist_count field is never actually used, so get rid of it.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 1b08349a413c..6c118748a7f8 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -78,7 +78,6 @@ struct ceph_msg {
 	unsigned page_count;		/* size of page array */
 	unsigned page_alignment;        /* io offset in first page */
 	struct ceph_pagelist *pagelist; /* instead of pages */
-	unsigned int pagelist_count;	/* number of pages in pagelist */
 
 	struct ceph_connection *con;
 	struct list_head list_head;

commit d4b515fa10dd52a2aef88df7299e9f3a8ab0957a
Author: Alex Elder <elder@inktank.com>
Date:   Mon Feb 25 17:35:46 2013 -0600

    libceph: distinguish page array and pagelist count
    
    Use distinct fields for tracking the number of pages in a message's
    page array and in a message's page list.  Currently only one or the
    other is used at a time, but that will be changing soon.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 8297288a66e0..1b08349a413c 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -75,9 +75,10 @@ struct ceph_msg {
 	struct kvec front;              /* unaligned blobs of message */
 	struct ceph_buffer *middle;
 	struct page **pages;            /* data payload.  NOT OWNER. */
-	unsigned nr_pages;              /* size of page array */
+	unsigned page_count;		/* size of page array */
 	unsigned page_alignment;        /* io offset in first page */
 	struct ceph_pagelist *pagelist; /* instead of pages */
+	unsigned int pagelist_count;	/* number of pages in pagelist */
 
 	struct ceph_connection *con;
 	struct list_head list_head;

commit 07c09b725543ff2958c11522d583f90f7fdba735
Author: Alex Elder <elder@inktank.com>
Date:   Fri Feb 15 22:10:17 2013 -0600

    libceph: make ceph_msg->bio_seg be unsigned
    
    The bio_seg field is used by the ceph messenger in iterating through
    a bio.  It should never have a negative value, so make it an
    unsigned.  (I contemplated making it unsigned short to match the
    struct bio definition, but it offered no benefit.)
    
    Change variables used to hold bio_seg values to all be unsigned as
    well.  Change two variable names in init_bio_iter() to match the
    convention used everywhere else.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 60903e0f665c..8297288a66e0 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -86,7 +86,7 @@ struct ceph_msg {
 #ifdef CONFIG_BLOCK
 	struct bio  *bio;		/* instead of pages/pagelist */
 	struct bio  *bio_iter;		/* bio iterator */
-	int bio_seg;			/* current bio segment */
+	unsigned int bio_seg;		/* current bio segment */
 #endif /* CONFIG_BLOCK */
 	struct ceph_pagelist *trail;	/* the trailing part of the data */
 	bool front_is_vmalloc;

commit 3ebc21f7bc2f9c0145bbbf0f12430b766a200f9f
Author: Alex Elder <elder@inktank.com>
Date:   Thu Jan 31 16:02:01 2013 -0600

    libceph: fix messenger CONFIG_BLOCK dependencies
    
    The ceph messenger has a few spots that are only used when
    bio messages are supported, and that's only when CONFIG_BLOCK
    is defined.  This surrounds a couple of spots with #ifdef's
    that would cause a problem if CONFIG_BLOCK were not present
    in the kernel configuration.
    
    This resolves:
        http://tracker.ceph.com/issues/3976
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Josh Durgin <josh.durgin@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 14ba5ee738a9..60903e0f665c 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -83,9 +83,11 @@ struct ceph_msg {
 	struct list_head list_head;
 
 	struct kref kref;
+#ifdef CONFIG_BLOCK
 	struct bio  *bio;		/* instead of pages/pagelist */
 	struct bio  *bio_iter;		/* bio iterator */
 	int bio_seg;			/* current bio segment */
+#endif /* CONFIG_BLOCK */
 	struct ceph_pagelist *trail;	/* the trailing part of the data */
 	bool front_is_vmalloc;
 	bool more_to_follow;

commit a1ce39288e6fbefdd8d607021d02384eb4a20b99
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:25 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in kernel system headers
    
    Convert #include "..." to #include <path/...> in kernel system headers.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 189ae0637634..14ba5ee738a9 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -8,8 +8,8 @@
 #include <linux/uio.h>
 #include <linux/workqueue.h>
 
-#include "types.h"
-#include "buffer.h"
+#include <linux/ceph/types.h>
+#include <linux/ceph/buffer.h>
 
 struct ceph_msg;
 struct ceph_connection;

commit 4a8616920860920abaa51193146fe36b38ef09aa
Author: Sage Weil <sage@inktank.com>
Date:   Fri Jul 20 17:29:55 2012 -0700

    libceph: clean up con flags
    
    Rename flags with CON_FLAG prefix, move the definitions into the c file,
    and (better) document their meaning.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index d9c2b8f5abde..189ae0637634 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -106,16 +106,6 @@ struct ceph_msg_pos {
 #define BASE_DELAY_INTERVAL	(HZ/2)
 #define MAX_DELAY_INTERVAL	(5 * 60 * HZ)
 
-/*
- * ceph_connection flag bits
- */
-
-#define LOSSYTX         0  /* we can close channel or drop messages on errors */
-#define KEEPALIVE_PENDING      3
-#define WRITE_PENDING	4  /* we have data ready to send */
-#define SOCK_CLOSED	11 /* socket state changed to closed */
-#define BACKOFF         15
-
 /*
  * A single connection with another host.
  *

commit 8dacc7da69a491c515851e68de6036f21b5663ce
Author: Sage Weil <sage@inktank.com>
Date:   Fri Jul 20 17:24:40 2012 -0700

    libceph: replace connection state bits with states
    
    Use a simple set of 6 enumerated values for the socket states (CON_STATE_*)
    and use those instead of the state bits.  All of the con->state checks are
    now under the protection of the con mutex, so this is safe.  It also
    simplifies many of the state checks because we can check for anything other
    than the expected state instead of various bits for races we can think of.
    
    This appears to hold up well to stress testing both with and without socket
    failure injection on the server side.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index a310d7fe6e29..d9c2b8f5abde 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -116,18 +116,6 @@ struct ceph_msg_pos {
 #define SOCK_CLOSED	11 /* socket state changed to closed */
 #define BACKOFF         15
 
-/*
- * ceph_connection states
- */
-#define CONNECTING	1
-#define NEGOTIATING	2
-#define CONNECTED	5
-#define STANDBY		8  /* no outgoing messages, socket closed.  we keep
-			    * the ceph_connection around to maintain shared
-			    * state with the peer. */
-#define CLOSED		10 /* we've closed the connection */
-#define OPENING         13 /* open connection w/ (possibly new) peer */
-
 /*
  * A single connection with another host.
  *

commit a2a3258417eb6a1799cf893350771428875a8287
Author: Guanjun He <gjhe@suse.com>
Date:   Sun Jul 8 19:50:33 2012 -0700

    libceph: prevent the race of incoming work during teardown
    
    Add an atomic variable 'stopping' as flag in struct ceph_messenger,
    set this flag to 1 in function ceph_destroy_client(), and add the condition code
    in function ceph_data_ready() to test the flag value, if true(1), just return.
    
    Signed-off-by: Guanjun He <gjhe@suse.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index cfb1bbdac624..a310d7fe6e29 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -50,6 +50,7 @@ struct ceph_messenger {
 	struct ceph_entity_inst inst;    /* my name+address */
 	struct ceph_entity_addr my_enc_addr;
 
+	atomic_t stopping;
 	bool nocrc;
 
 	/*

commit a16cb1f70799c851410d9dca0a24122e258df06c
Author: Sage Weil <sage@inktank.com>
Date:   Tue Jul 10 11:53:34 2012 -0700

    libceph: fix messenger retry
    
    In ancient times, the messenger could both initiate and accept connections.
    An artifact if that was data structures to store/process an incoming
    ceph_msg_connect request and send an outgoing ceph_msg_connect_reply.
    Sadly, the negotiation code was referencing those structures and ignoring
    important information (like the peer's connect_seq) from the correct ones.
    
    Among other things, this fixes tight reconnect loops where the server sends
    RETRY_SESSION and we (the client) retries with the same connect_seq as last
    time.  This bug pretty easily triggered by injecting socket failures on the
    MDS and running some fs workload like workunits/direct_io/test_sync_io.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 478f814f2100..cfb1bbdac624 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -172,16 +172,8 @@ struct ceph_connection {
 
 	/* connection negotiation temps */
 	char in_banner[CEPH_BANNER_MAX_LEN];
-	union {
-		struct {  /* outgoing connection */
-			struct ceph_msg_connect out_connect;
-			struct ceph_msg_connect_reply in_reply;
-		};
-		struct {  /* incoming */
-			struct ceph_msg_connect in_connect;
-			struct ceph_msg_connect_reply out_reply;
-		};
-	};
+	struct ceph_msg_connect out_connect;
+	struct ceph_msg_connect_reply in_reply;
 	struct ceph_entity_addr actual_peer_addr;
 
 	/* message out temps */

commit b7a9e5dd40f17a48a72f249b8bbc989b63bae5fd
Author: Sage Weil <sage@inktank.com>
Date:   Wed Jun 27 12:24:08 2012 -0700

    libceph: set peer name on con_open, not init
    
    The peer name may change on each open attempt, even when the connection is
    reused.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index dd4ef1f8ec93..478f814f2100 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -232,9 +232,9 @@ extern void ceph_messenger_init(struct ceph_messenger *msgr,
 
 extern void ceph_con_init(struct ceph_connection *con, void *private,
 			const struct ceph_connection_operations *ops,
-			struct ceph_messenger *msgr, __u8 entity_type,
-			__u64 entity_num);
+			struct ceph_messenger *msgr);
 extern void ceph_con_open(struct ceph_connection *con,
+			  __u8 entity_type, __u64 entity_num,
 			  struct ceph_entity_addr *addr);
 extern bool ceph_con_opened(struct ceph_connection *con);
 extern void ceph_con_close(struct ceph_connection *con);

commit 261030215d970c62f799e6e508e3c68fc7ec2aa9
Author: Alex Elder <elder@inktank.com>
Date:   Thu Jun 21 12:49:23 2012 -0700

    libceph: drop declaration of ceph_con_get()
    
    For some reason the declaration of ceph_con_get() and
    ceph_con_put() did not get deleted in this commit:
        d59315ca libceph: drop ceph_con_get/put helpers and nref member
    
    Clean that up.
    
    Signed-off-by: Alex Elder <elder@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 002d504df3b7..dd4ef1f8ec93 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -244,8 +244,6 @@ extern void ceph_msg_revoke(struct ceph_msg *msg);
 extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
 
 extern void ceph_con_keepalive(struct ceph_connection *con);
-extern struct ceph_connection *ceph_con_get(struct ceph_connection *con);
-extern void ceph_con_put(struct ceph_connection *con);
 
 extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
 				     bool can_fail);

commit e27947c767f5bed15048f4e4dad3e2eb69133697
Author: Alex Elder <elder@inktank.com>
Date:   Wed May 23 14:35:23 2012 -0500

    libceph: define and use an explicit CONNECTED state
    
    There is no state explicitly defined when a ceph connection is fully
    operational.  So define one.
    
    It's set when the connection sequence completes successfully, and is
    cleared when the connection gets closed.
    
    Be a little more careful when examining the old state when a socket
    disconnect event is reported.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index cc6f9bdcf466..002d504df3b7 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -120,6 +120,7 @@ struct ceph_msg_pos {
  */
 #define CONNECTING	1
 #define NEGOTIATING	2
+#define CONNECTED	5
 #define STANDBY		8  /* no outgoing messages, socket closed.  we keep
 			    * the ceph_connection around to maintain shared
 			    * state with the peer. */

commit d59315ca8c0de00df9b363f94a2641a30961ca1c
Author: Sage Weil <sage@inktank.com>
Date:   Thu Jun 21 12:49:23 2012 -0700

    libceph: drop ceph_con_get/put helpers and nref member
    
    These are no longer used.  Every ceph_connection instance is embedded in
    another structure, and refcounts manipulated via the get/put ops.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index a334dbd1b324..cc6f9bdcf466 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -135,7 +135,6 @@ struct ceph_msg_pos {
  */
 struct ceph_connection {
 	void *private;
-	atomic_t nref;
 
 	const struct ceph_connection_operations *ops;
 

commit 8921d114f5574c6da2cdd00749d185633ecf88f3
Author: Alex Elder <elder@inktank.com>
Date:   Fri Jun 1 14:56:43 2012 -0500

    libceph: make ceph_con_revoke_message() a msg op
    
    ceph_con_revoke_message() is passed both a message and a ceph
    connection.  A ceph_msg allocated for incoming messages on a
    connection always has a pointer to that connection, so there's no
    need to provide the connection when revoking such a message.
    
    Note that the existing logic does not preclude the message supplied
    being a null/bogus message pointer.  The only user of this interface
    is the OSD client, and the only value an osd client passes is a
    request's r_reply field.  That is always non-null (except briefly in
    an error path in ceph_osdc_alloc_request(), and that drops the
    only reference so the request won't ever have a reply to revoke).
    So we can safely assume the passed-in message is non-null, but add a
    BUG_ON() to make it very obvious we are imposing this restriction.
    
    Rename the function ceph_msg_revoke_incoming() to reflect that it is
    really an operation on an incoming message.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 9008f81c20cd..a334dbd1b324 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -241,8 +241,8 @@ extern void ceph_con_close(struct ceph_connection *con);
 extern void ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg);
 
 extern void ceph_msg_revoke(struct ceph_msg *msg);
-extern void ceph_con_revoke_message(struct ceph_connection *con,
-				  struct ceph_msg *msg);
+extern void ceph_msg_revoke_incoming(struct ceph_msg *msg);
+
 extern void ceph_con_keepalive(struct ceph_connection *con);
 extern struct ceph_connection *ceph_con_get(struct ceph_connection *con);
 extern void ceph_con_put(struct ceph_connection *con);

commit 6740a845b2543cc46e1902ba21bac743fbadd0dc
Author: Alex Elder <elder@inktank.com>
Date:   Fri Jun 1 14:56:43 2012 -0500

    libceph: make ceph_con_revoke() a msg operation
    
    ceph_con_revoke() is passed both a message and a ceph connection.
    Now that any message associated with a connection holds a pointer
    to that connection, there's no need to provide the connection when
    revoking a message.
    
    This has the added benefit of precluding the possibility of the
    providing the wrong connection pointer.  If the message's connection
    pointer is null, it is not being tracked by any connection, so
    revoking it is a no-op.  This is supported as a convenience for
    upper layers, so they can revoke a message that is not actually
    "in flight."
    
    Rename the function ceph_msg_revoke() to reflect that it is really
    an operation on a message, not a connection.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 6df837f72761..9008f81c20cd 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -239,7 +239,8 @@ extern void ceph_con_open(struct ceph_connection *con,
 extern bool ceph_con_opened(struct ceph_connection *con);
 extern void ceph_con_close(struct ceph_connection *con);
 extern void ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg);
-extern void ceph_con_revoke(struct ceph_connection *con, struct ceph_msg *msg);
+
+extern void ceph_msg_revoke(struct ceph_msg *msg);
 extern void ceph_con_revoke_message(struct ceph_connection *con,
 				  struct ceph_msg *msg);
 extern void ceph_con_keepalive(struct ceph_connection *con);

commit 38941f8031bf042dba3ced6394ba3a3b16c244ea
Author: Alex Elder <elder@inktank.com>
Date:   Fri Jun 1 14:56:43 2012 -0500

    libceph: have messages point to their connection
    
    When a ceph message is queued for sending it is placed on a list of
    pending messages (ceph_connection->out_queue).  When they are
    actually sent over the wire, they are moved from that list to
    another (ceph_connection->out_sent).  When acknowledgement for the
    message is received, it is removed from the sent messages list.
    
    During that entire time the message is "in the possession" of a
    single ceph connection.  Keep track of that connection in the
    message.  This will be used in the next patch (and is a helpful
    bit of information for debugging anyway).
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index dd27837f79ac..6df837f72761 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -77,7 +77,10 @@ struct ceph_msg {
 	unsigned nr_pages;              /* size of page array */
 	unsigned page_alignment;        /* io offset in first page */
 	struct ceph_pagelist *pagelist; /* instead of pages */
+
+	struct ceph_connection *con;
 	struct list_head list_head;
+
 	struct kref kref;
 	struct bio  *bio;		/* instead of pages/pagelist */
 	struct bio  *bio_iter;		/* bio iterator */

commit 1bfd89f4e6e1adc6a782d94aa5d4c53be1e404d7
Author: Alex Elder <elder@inktank.com>
Date:   Sat May 26 23:26:43 2012 -0500

    libceph: fully initialize connection in con_init()
    
    Move the initialization of a ceph connection's private pointer,
    operations vector pointer, and peer name information into
    ceph_con_init().  Rearrange the arguments so the connection pointer
    is first.  Hide the byte-swapping of the peer entity number inside
    ceph_con_init()
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 5e852f444f68..dd27837f79ac 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -227,8 +227,10 @@ extern void ceph_messenger_init(struct ceph_messenger *msgr,
 			u32 required_features,
 			bool nocrc);
 
-extern void ceph_con_init(struct ceph_messenger *msgr,
-			  struct ceph_connection *con);
+extern void ceph_con_init(struct ceph_connection *con, void *private,
+			const struct ceph_connection_operations *ops,
+			struct ceph_messenger *msgr, __u8 entity_type,
+			__u64 entity_num);
 extern void ceph_con_open(struct ceph_connection *con,
 			  struct ceph_entity_addr *addr);
 extern bool ceph_con_opened(struct ceph_connection *con);

commit ce2c8903e76e690846a00a0284e4bd9ee954d680
Author: Alex Elder <elder@inktank.com>
Date:   Tue May 22 22:15:49 2012 -0500

    libceph: start tracking connection socket state
    
    Start explicitly keeping track of the state of a ceph connection's
    socket, separate from the state of the connection itself.  Create
    placeholder functions to encapsulate the state transitions.
    
        --------
        | NEW* |  transient initial state
        --------
            | con_sock_state_init()
            v
        ----------
        | CLOSED |  initialized, but no socket (and no
        ----------  TCP connection)
         ^      \
         |       \ con_sock_state_connecting()
         |        ----------------------
         |                              \
         + con_sock_state_closed()       \
         |\                               \
         | \                               \
         |  -----------                     \
         |  | CLOSING |  socket event;       \
         |  -----------  await close          \
         |       ^                            |
         |       |                            |
         |       + con_sock_state_closing()   |
         |      / \                           |
         |     /   ---------------            |
         |    /                   \           v
         |   /                    --------------
         |  /    -----------------| CONNECTING |  socket created, TCP
         |  |   /                 --------------  connect initiated
         |  |   | con_sock_state_connected()
         |  |   v
        -------------
        | CONNECTED |  TCP connection established
        -------------
    
    Make the socket state an atomic variable, reinforcing that it's a
    distinct transtion with no possible "intermediate/both" states.
    This is almost certainly overkill at this point, though the
    transitions into CONNECTED and CLOSING state do get called via
    socket callback (the rest of the transitions occur with the
    connection mutex held).  We can back out the atomicity later.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil<sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 920235e114ad..5e852f444f68 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -137,14 +137,18 @@ struct ceph_connection {
 	const struct ceph_connection_operations *ops;
 
 	struct ceph_messenger *msgr;
+
+	atomic_t sock_state;
 	struct socket *sock;
+	struct ceph_entity_addr peer_addr; /* peer address */
+	struct ceph_entity_addr peer_addr_for_me;
+
 	unsigned long flags;
 	unsigned long state;
 	const char *error_msg;  /* error message, if any */
 
-	struct ceph_entity_addr peer_addr; /* peer address */
 	struct ceph_entity_name peer_name; /* peer name */
-	struct ceph_entity_addr peer_addr_for_me;
+
 	unsigned peer_features;
 	u32 connect_seq;      /* identify the most recent connection
 				 attempt for this connection, client */

commit 928443cd9644e7cfd46f687dbeffda2d1a357ff9
Author: Alex Elder <elder@inktank.com>
Date:   Tue May 22 11:41:43 2012 -0500

    libceph: start separating connection flags from state
    
    A ceph_connection holds a mixture of connection state (as in "state
    machine" state) and connection flags in a single "state" field.  To
    make the distinction more clear, define a new "flags" field and use
    it rather than the "state" field to hold Boolean flag values.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil<sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 3fbd4be804ed..920235e114ad 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -103,20 +103,25 @@ struct ceph_msg_pos {
 #define MAX_DELAY_INTERVAL	(5 * 60 * HZ)
 
 /*
- * ceph_connection state bit flags
+ * ceph_connection flag bits
  */
+
 #define LOSSYTX         0  /* we can close channel or drop messages on errors */
-#define CONNECTING	1
-#define NEGOTIATING	2
 #define KEEPALIVE_PENDING      3
 #define WRITE_PENDING	4  /* we have data ready to send */
+#define SOCK_CLOSED	11 /* socket state changed to closed */
+#define BACKOFF         15
+
+/*
+ * ceph_connection states
+ */
+#define CONNECTING	1
+#define NEGOTIATING	2
 #define STANDBY		8  /* no outgoing messages, socket closed.  we keep
 			    * the ceph_connection around to maintain shared
 			    * state with the peer. */
 #define CLOSED		10 /* we've closed the connection */
-#define SOCK_CLOSED	11 /* socket state changed to closed */
 #define OPENING         13 /* open connection w/ (possibly new) peer */
-#define BACKOFF         15
 
 /*
  * A single connection with another host.
@@ -133,7 +138,8 @@ struct ceph_connection {
 
 	struct ceph_messenger *msgr;
 	struct socket *sock;
-	unsigned long state;	/* connection state (see flags above) */
+	unsigned long flags;
+	unsigned long state;
 	const char *error_msg;  /* error message, if any */
 
 	struct ceph_entity_addr peer_addr; /* peer address */

commit 15d9882c336db2db73ccf9871ae2398e452f694c
Author: Alex Elder <elder@inktank.com>
Date:   Sat May 26 23:26:43 2012 -0500

    libceph: embed ceph messenger structure in ceph_client
    
    A ceph client has a pointer to a ceph messenger structure in it.
    There is always exactly one ceph messenger for a ceph client, so
    there is no need to allocate it separate from the ceph client
    structure.
    
    Switch the ceph_client structure to embed its ceph_messenger
    structure.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Yehuda Sadeh <yehuda@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 74f6c9bd8074..3fbd4be804ed 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -211,10 +211,11 @@ extern int ceph_msgr_init(void);
 extern void ceph_msgr_exit(void);
 extern void ceph_msgr_flush(void);
 
-extern struct ceph_messenger *ceph_messenger_create(
-	struct ceph_entity_addr *myaddr,
-	u32 features, u32 required);
-extern void ceph_messenger_destroy(struct ceph_messenger *);
+extern void ceph_messenger_init(struct ceph_messenger *msgr,
+			struct ceph_entity_addr *myaddr,
+			u32 supported_features,
+			u32 required_features,
+			bool nocrc);
 
 extern void ceph_con_init(struct ceph_messenger *msgr,
 			  struct ceph_connection *con);

commit 6384bb8b8e88a9c6bf2ae0d9517c2c0199177c34
Author: Alex Elder <elder@inktank.com>
Date:   Tue May 29 21:47:38 2012 -0500

    libceph: kill bad_proto ceph connection op
    
    No code sets a bad_proto method in its ceph connection operations
    vector, so just get rid of it.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Yehuda Sadeh <yehuda@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index aa506cadea67..74f6c9bd8074 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -31,9 +31,6 @@ struct ceph_connection_operations {
 	int (*verify_authorizer_reply) (struct ceph_connection *con, int len);
 	int (*invalidate_authorizer)(struct ceph_connection *con);
 
-	/* protocol version mismatch */
-	void (*bad_proto) (struct ceph_connection *con);
-
 	/* there was some error on the socket (disconnect, whatever) */
 	void (*fault) (struct ceph_connection *con);
 

commit e5e372da9a469dfe3ece40277090a7056c566838
Author: Alex Elder <elder@inktank.com>
Date:   Tue May 22 11:41:43 2012 -0500

    libceph: eliminate connection state "DEAD"
    
    The ceph connection state "DEAD" is never set and is therefore not
    needed.  Eliminate it.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Yehuda Sadeh <yehuda@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 2521a95fa6d9..aa506cadea67 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -119,7 +119,6 @@ struct ceph_msg_pos {
 #define CLOSED		10 /* we've closed the connection */
 #define SOCK_CLOSED	11 /* socket state changed to closed */
 #define OPENING         13 /* open connection w/ (possibly new) peer */
-#define DEAD            14 /* dead, about to kfree */
 #define BACKOFF         15
 
 /*

commit 8f43fb53894079bf0caab6e348ceaffe7adc651a
Author: Alex Elder <elder@inktank.com>
Date:   Wed May 16 15:16:39 2012 -0500

    ceph: use info returned by get_authorizer
    
    Rather than passing a bunch of arguments to be filled in with the
    content of the ceph_auth_handshake buffer now returned by the
    get_authorizer method, just use the returned information in the
    caller, and drop the unnecessary arguments.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index b10b55f8f301..2521a95fa6d9 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -27,9 +27,7 @@ struct ceph_connection_operations {
 	/* authorize an outgoing connection */
 	struct ceph_auth_handshake *(*get_authorizer) (
 				struct ceph_connection *con,
-				void **buf, int *len, int *proto,
-				void **reply_buf, int *reply_len,
-				int force_new);
+			       int *proto, int force_new);
 	int (*verify_authorizer_reply) (struct ceph_connection *con, int len);
 	int (*invalidate_authorizer)(struct ceph_connection *con);
 

commit a3530df33eb91d787d08c7383a0a9982690e42d0
Author: Alex Elder <elder@inktank.com>
Date:   Wed May 16 15:16:39 2012 -0500

    ceph: have get_authorizer methods return pointers
    
    Have the get_authorizer auth_client method return a ceph_auth
    pointer rather than an integer, pointer-encoding any returned
    error value.  This is to pave the way for making use of the
    returned value in an upcoming patch.
    
    Signed-off-by: Alex Elder <elder@inktank.com>
    Reviewed-by: Sage Weil <sage@inktank.com>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 3bff047f6b0f..b10b55f8f301 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -25,9 +25,11 @@ struct ceph_connection_operations {
 	void (*dispatch) (struct ceph_connection *con, struct ceph_msg *m);
 
 	/* authorize an outgoing connection */
-	int (*get_authorizer) (struct ceph_connection *con,
-			       void **buf, int *len, int *proto,
-			       void **reply_buf, int *reply_len, int force_new);
+	struct ceph_auth_handshake *(*get_authorizer) (
+				struct ceph_connection *con,
+				void **buf, int *len, int *proto,
+				void **reply_buf, int *reply_len,
+				int force_new);
 	int (*verify_authorizer_reply) (struct ceph_connection *con, int len);
 	int (*invalidate_authorizer)(struct ceph_connection *con);
 

commit bca064d236a2e3162a07c758855221bcbe3c475b
Author: Alex Elder <elder@dreamhost.com>
Date:   Wed Feb 15 07:43:54 2012 -0600

    libceph: use "do" in CRC-related Boolean variables
    
    Change the name (and type) of a few CRC-related Boolean local
    variables so they contain the word "do", to distingish their purpose
    from variables used for holding an actual CRC value.
    
    Note that in the process of doing this I identified a fairly serious
    logic error in write_partial_msg_pages():  the value of "do_crc"
    assigned appears to be the opposite of what it should be.  No
    attempt to fix this is made here; this change preserves the
    erroneous behavior.  The problem I found is documented here:
        http://tracker.newdream.net/issues/2064
    
    Signed-off-by: Alex Elder <elder@dreamhost.com>
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 5ca0f8244203..3bff047f6b0f 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -98,7 +98,7 @@ struct ceph_msg {
 struct ceph_msg_pos {
 	int page, page_pos;  /* which page; offset in page */
 	int data_pos;        /* offset in data payload */
-	int did_page_crc;    /* true if we've calculated crc for current page */
+	bool did_page_crc;   /* true if we've calculated crc for current page */
 };
 
 /* ceph connection fault delay defaults, for exponential backoff */

commit e0f43c9419c1900e5b50de4261e9686a45a0a2b8
Author: Alex Elder <elder@dreamhost.com>
Date:   Tue Feb 14 14:05:33 2012 -0600

    libceph: make ceph_msgr_wq private
    
    The messenger workqueue has no need to be public.  So give it static
    scope.
    
    Signed-off-by: Alex Elder <elder@dreamhost.com>
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 6b5af5f976d1..5ca0f8244203 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -14,8 +14,6 @@
 struct ceph_msg;
 struct ceph_connection;
 
-extern struct workqueue_struct *ceph_msgr_wq;       /* receive work queue */
-
 /*
  * Ceph defines these callbacks for handling connection events.
  */

commit 5766651971e81298732466c9aa462ff47898ba37
Author: Alex Elder <elder@dreamhost.com>
Date:   Mon Jan 23 15:49:27 2012 -0600

    ceph: use a shared zero page rather than one per messenger
    
    Each messenger allocates a page to be used when writing zeroes
    out in the event of error or other abnormal condition.  Instead,
    use the kernel ZERO_PAGE() for that purpose.
    
    Signed-off-by: Alex Elder <elder@dreamhost.com>
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index ffbeb2c217b4..6b5af5f976d1 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -54,7 +54,6 @@ struct ceph_connection_operations {
 struct ceph_messenger {
 	struct ceph_entity_inst inst;    /* my name+address */
 	struct ceph_entity_addr my_enc_addr;
-	struct page *zero_page;          /* used in certain error cases */
 
 	bool nocrc;
 

commit 97d2eb13a019ec09cc1a7ea2d3705c0b117b3c0d
Merge: 68d99b2c8efc 339573406737
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 16:42:18 2011 -0700

    Merge branch 'for-linus' of git://ceph.newdream.net/git/ceph-client
    
    * 'for-linus' of git://ceph.newdream.net/git/ceph-client:
      libceph: fix double-free of page vector
      ceph: fix 32-bit ino numbers
      libceph: force resend of osd requests if we skip an osdmap
      ceph: use kernel DNS resolver
      ceph: fix ceph_monc_init memory leak
      ceph: let the set_layout ioctl set single traits
      Revert "ceph: don't truncate dirty pages in invalidate work thread"
      ceph: replace leading spaces with tabs
      libceph: warn on msg allocation failures
      libceph: don't complain on msgpool alloc failures
      libceph: always preallocate mon connection
      libceph: create messenger with client
      ceph: document ioctls
      ceph: implement (optional) max read size
      ceph: rename rsize -> rasize
      ceph: make readpages fully async

commit b61c27636fffbaf1980e675282777b9467254a40
Author: Sage Weil <sage@newdream.net>
Date:   Tue Aug 9 15:03:46 2011 -0700

    libceph: don't complain on msgpool alloc failures
    
    The pool allocation failures are masked by the pool; there is no need to
    spam the console about them.  (That's the whole point of having the pool
    in the first place.)
    
    Mark msg allocations whose failure is safely handled as such.
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index d7adf151d335..bbd4a4bb2c6b 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -238,7 +238,8 @@ extern void ceph_con_keepalive(struct ceph_connection *con);
 extern struct ceph_connection *ceph_con_get(struct ceph_connection *con);
 extern void ceph_con_put(struct ceph_connection *con);
 
-extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags);
+extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,
+				     bool can_fail);
 extern void ceph_msg_kfree(struct ceph_msg *m);
 
 

commit e060c38434b2caa78efe7cedaff4191040b65a15
Merge: 10e4ac572eef cc39c6a9bbde
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Sep 15 15:08:05 2011 +0200

    Merge branch 'master' into for-next
    
    Fast-forward merge with Linus to be able to merge patches
    based on more recent version of the tree.

commit e81b15168e2d3d1ab56b13782fe8ad0cb362379d
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Aug 1 23:04:30 2011 +0200

    Remove unneeded version.h includes from include/
    
    It was pointed out by 'make versioncheck' that some includes of
    linux/version.h are not needed in include/.
    This patch removes them.
    
    When I last posted the patch, the ceph bit was ACK'ed by Sage Weil, so
    I've added that below.
    
    The pwc-ioctl change generated quite a bit of discussion about V4L version
    numbers in general, but as far as I can tell, no concensus was reached on
    what the long term solution should be, so in the mean time I think we
    could start by just removing the unneeded include, which is why I'm
    resending the patch with that hunk still included.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Acked-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 31d91a64838b..291aa6e18d31 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -6,7 +6,6 @@
 #include <linux/net.h>
 #include <linux/radix-tree.h>
 #include <linux/uio.h>
-#include <linux/version.h>
 #include <linux/workqueue.h>
 
 #include "types.h"

commit 4cf9d544631c92809cb94ea680c71df56e9437aa
Author: Sage Weil <sage@newdream.net>
Date:   Tue Jul 26 11:27:24 2011 -0700

    libceph: don't time out osd requests that haven't been received
    
    Keep track of when an outgoing message is ACKed (i.e., the server fully
    received it and, presumably, queued it for processing).  Time out OSD
    requests only if it's been too long since they've been received.
    
    This prevents timeouts and connection thrashing when the OSDs are simply
    busy and are throttling the requests they read off the network.
    
    Reviewed-by: Yehuda Sadeh <yehuda@hq.newdream.net>
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 31d91a64838b..d7adf151d335 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -94,6 +94,7 @@ struct ceph_msg {
 	bool more_to_follow;
 	bool needs_out_seq;
 	int front_max;
+	unsigned long ack_stamp;        /* tx: when we were acked */
 
 	struct ceph_msgpool *pool;
 };

commit e76661d0a59e53e5cc4dccbe4b755d1dc8a968ec
Author: Sage Weil <sage@newdream.net>
Date:   Thu Mar 3 10:10:15 2011 -0800

    libceph: fix msgr keepalive flag
    
    There was some broken keepalive code using a dead variable.  Shift to using
    the proper bit flag.
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index eb31e108a64d..31d91a64838b 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -161,7 +161,6 @@ struct ceph_connection {
 	struct list_head out_queue;
 	struct list_head out_sent;   /* sending or sent but unacked */
 	u64 out_seq;		     /* last message queued for send */
-	bool out_keepalive_pending;
 
 	u64 in_seq, in_seq_acked;  /* last message received, acked */
 

commit 60bf8bf8815e6adea4c1d0423578c3b8000e2ec8
Author: Sage Weil <sage@newdream.net>
Date:   Fri Mar 4 12:24:28 2011 -0800

    libceph: fix msgr backoff
    
    With commit f363e45f we replaced a bunch of hacky workqueue mutual
    exclusion logic with the WQ_NON_REENTRANT flag.  One pieces of fallout is
    that the exponential backoff breaks in certain cases:
    
     * con_work attempts to connect.
     * we get an immediate failure, and the socket state change handler queues
       immediate work.
     * con_work calls con_fault, we decide to back off, but can't queue delayed
       work.
    
    In this case, we add a BACKOFF bit to make con_work reschedule delayed work
    next time it runs (which should be immediately).
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index c3011beac30d..eb31e108a64d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -123,6 +123,7 @@ struct ceph_msg_pos {
 #define SOCK_CLOSED	11 /* socket state changed to closed */
 #define OPENING         13 /* open connection w/ (possibly new) peer */
 #define DEAD            14 /* dead, about to kfree */
+#define BACKOFF         15
 
 /*
  * A single connection with another host.

commit f363e45fd1184219b472ea549cb7e192e24ef4d2
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Jan 3 14:49:46 2011 +0100

    net/ceph: make ceph_msgr_wq non-reentrant
    
    ceph messenger code does a rather complex dancing around multithread
    workqueue to make sure the same work item isn't executed concurrently
    on different CPUs.  This restriction can be provided by workqueue with
    WQ_NON_REENTRANT.
    
    Make ceph_msgr_wq non-reentrant workqueue with the default concurrency
    level and remove the QUEUED/BUSY logic.
    
    * This removes backoff handling in con_work() but it couldn't reliably
      block execution of con_work() to begin with - queue_con() can be
      called after the work started but before BUSY is set.  It seems that
      it was an optimization for a rather cold path and can be safely
      removed.
    
    * The number of concurrent work items is bound by the number of
      connections and connetions are independent from each other.  With
      the default concurrency level, different connections will be
      executed independently.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Sage Weil <sage@newdream.net>
    Cc: ceph-devel@vger.kernel.org
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index a108b425fee2..c3011beac30d 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -110,17 +110,12 @@ struct ceph_msg_pos {
 
 /*
  * ceph_connection state bit flags
- *
- * QUEUED and BUSY are used together to ensure that only a single
- * thread is currently opening, reading or writing data to the socket.
  */
 #define LOSSYTX         0  /* we can close channel or drop messages on errors */
 #define CONNECTING	1
 #define NEGOTIATING	2
 #define KEEPALIVE_PENDING      3
 #define WRITE_PENDING	4  /* we have data ready to send */
-#define QUEUED          5  /* there is work queued on this connection */
-#define BUSY            6  /* work is being done */
 #define STANDBY		8  /* no outgoing messages, socket closed.  we keep
 			    * the ceph_connection around to maintain shared
 			    * state with the peer. */

commit c5c6b19d4b8f5431fca05f28ae9e141045022149
Author: Sage Weil <sage@newdream.net>
Date:   Tue Nov 9 12:40:00 2010 -0800

    ceph: explicitly specify page alignment in network messages
    
    The alignment used for reading data into or out of pages used to be taken
    from the data_off field in the message header.  This only worked as long
    as the page alignment matched the object offset, breaking direct io to
    non-page aligned offsets.
    
    Instead, explicitly specify the page alignment next to the page vector
    in the ceph_msg struct, and use that instead of the message header (which
    probably shouldn't be trusted).  The alloc_msg callback is responsible for
    filling in this field properly when it sets up the page vector.
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
index 5956d62c3057..a108b425fee2 100644
--- a/include/linux/ceph/messenger.h
+++ b/include/linux/ceph/messenger.h
@@ -82,6 +82,7 @@ struct ceph_msg {
 	struct ceph_buffer *middle;
 	struct page **pages;            /* data payload.  NOT OWNER. */
 	unsigned nr_pages;              /* size of page array */
+	unsigned page_alignment;        /* io offset in first page */
 	struct ceph_pagelist *pagelist; /* instead of pages */
 	struct list_head list_head;
 	struct kref kref;

commit 3d14c5d2b6e15c21d8e5467dc62d33127c23a644
Author: Yehuda Sadeh <yehuda@hq.newdream.net>
Date:   Tue Apr 6 15:14:15 2010 -0700

    ceph: factor out libceph from Ceph file system
    
    This factors out protocol and low-level storage parts of ceph into a
    separate libceph module living in net/ceph and include/linux/ceph.  This
    is mostly a matter of moving files around.  However, a few key pieces
    of the interface change as well:
    
     - ceph_client becomes ceph_fs_client and ceph_client, where the latter
       captures the mon and osd clients, and the fs_client gets the mds client
       and file system specific pieces.
     - Mount option parsing and debugfs setup is correspondingly broken into
       two pieces.
     - The mon client gets a generic handler callback for otherwise unknown
       messages (mds map, in this case).
     - The basic supported/required feature bits can be expanded (and are by
       ceph_fs_client).
    
    No functional change, aside from some subtle error handling cases that got
    cleaned up in the refactoring process.
    
    Signed-off-by: Sage Weil <sage@newdream.net>

diff --git a/include/linux/ceph/messenger.h b/include/linux/ceph/messenger.h
new file mode 100644
index 000000000000..5956d62c3057
--- /dev/null
+++ b/include/linux/ceph/messenger.h
@@ -0,0 +1,261 @@
+#ifndef __FS_CEPH_MESSENGER_H
+#define __FS_CEPH_MESSENGER_H
+
+#include <linux/kref.h>
+#include <linux/mutex.h>
+#include <linux/net.h>
+#include <linux/radix-tree.h>
+#include <linux/uio.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+
+#include "types.h"
+#include "buffer.h"
+
+struct ceph_msg;
+struct ceph_connection;
+
+extern struct workqueue_struct *ceph_msgr_wq;       /* receive work queue */
+
+/*
+ * Ceph defines these callbacks for handling connection events.
+ */
+struct ceph_connection_operations {
+	struct ceph_connection *(*get)(struct ceph_connection *);
+	void (*put)(struct ceph_connection *);
+
+	/* handle an incoming message. */
+	void (*dispatch) (struct ceph_connection *con, struct ceph_msg *m);
+
+	/* authorize an outgoing connection */
+	int (*get_authorizer) (struct ceph_connection *con,
+			       void **buf, int *len, int *proto,
+			       void **reply_buf, int *reply_len, int force_new);
+	int (*verify_authorizer_reply) (struct ceph_connection *con, int len);
+	int (*invalidate_authorizer)(struct ceph_connection *con);
+
+	/* protocol version mismatch */
+	void (*bad_proto) (struct ceph_connection *con);
+
+	/* there was some error on the socket (disconnect, whatever) */
+	void (*fault) (struct ceph_connection *con);
+
+	/* a remote host as terminated a message exchange session, and messages
+	 * we sent (or they tried to send us) may be lost. */
+	void (*peer_reset) (struct ceph_connection *con);
+
+	struct ceph_msg * (*alloc_msg) (struct ceph_connection *con,
+					struct ceph_msg_header *hdr,
+					int *skip);
+};
+
+/* use format string %s%d */
+#define ENTITY_NAME(n) ceph_entity_type_name((n).type), le64_to_cpu((n).num)
+
+struct ceph_messenger {
+	struct ceph_entity_inst inst;    /* my name+address */
+	struct ceph_entity_addr my_enc_addr;
+	struct page *zero_page;          /* used in certain error cases */
+
+	bool nocrc;
+
+	/*
+	 * the global_seq counts connections i (attempt to) initiate
+	 * in order to disambiguate certain connect race conditions.
+	 */
+	u32 global_seq;
+	spinlock_t global_seq_lock;
+
+	u32 supported_features;
+	u32 required_features;
+};
+
+/*
+ * a single message.  it contains a header (src, dest, message type, etc.),
+ * footer (crc values, mainly), a "front" message body, and possibly a
+ * data payload (stored in some number of pages).
+ */
+struct ceph_msg {
+	struct ceph_msg_header hdr;	/* header */
+	struct ceph_msg_footer footer;	/* footer */
+	struct kvec front;              /* unaligned blobs of message */
+	struct ceph_buffer *middle;
+	struct page **pages;            /* data payload.  NOT OWNER. */
+	unsigned nr_pages;              /* size of page array */
+	struct ceph_pagelist *pagelist; /* instead of pages */
+	struct list_head list_head;
+	struct kref kref;
+	struct bio  *bio;		/* instead of pages/pagelist */
+	struct bio  *bio_iter;		/* bio iterator */
+	int bio_seg;			/* current bio segment */
+	struct ceph_pagelist *trail;	/* the trailing part of the data */
+	bool front_is_vmalloc;
+	bool more_to_follow;
+	bool needs_out_seq;
+	int front_max;
+
+	struct ceph_msgpool *pool;
+};
+
+struct ceph_msg_pos {
+	int page, page_pos;  /* which page; offset in page */
+	int data_pos;        /* offset in data payload */
+	int did_page_crc;    /* true if we've calculated crc for current page */
+};
+
+/* ceph connection fault delay defaults, for exponential backoff */
+#define BASE_DELAY_INTERVAL	(HZ/2)
+#define MAX_DELAY_INTERVAL	(5 * 60 * HZ)
+
+/*
+ * ceph_connection state bit flags
+ *
+ * QUEUED and BUSY are used together to ensure that only a single
+ * thread is currently opening, reading or writing data to the socket.
+ */
+#define LOSSYTX         0  /* we can close channel or drop messages on errors */
+#define CONNECTING	1
+#define NEGOTIATING	2
+#define KEEPALIVE_PENDING      3
+#define WRITE_PENDING	4  /* we have data ready to send */
+#define QUEUED          5  /* there is work queued on this connection */
+#define BUSY            6  /* work is being done */
+#define STANDBY		8  /* no outgoing messages, socket closed.  we keep
+			    * the ceph_connection around to maintain shared
+			    * state with the peer. */
+#define CLOSED		10 /* we've closed the connection */
+#define SOCK_CLOSED	11 /* socket state changed to closed */
+#define OPENING         13 /* open connection w/ (possibly new) peer */
+#define DEAD            14 /* dead, about to kfree */
+
+/*
+ * A single connection with another host.
+ *
+ * We maintain a queue of outgoing messages, and some session state to
+ * ensure that we can preserve the lossless, ordered delivery of
+ * messages in the case of a TCP disconnect.
+ */
+struct ceph_connection {
+	void *private;
+	atomic_t nref;
+
+	const struct ceph_connection_operations *ops;
+
+	struct ceph_messenger *msgr;
+	struct socket *sock;
+	unsigned long state;	/* connection state (see flags above) */
+	const char *error_msg;  /* error message, if any */
+
+	struct ceph_entity_addr peer_addr; /* peer address */
+	struct ceph_entity_name peer_name; /* peer name */
+	struct ceph_entity_addr peer_addr_for_me;
+	unsigned peer_features;
+	u32 connect_seq;      /* identify the most recent connection
+				 attempt for this connection, client */
+	u32 peer_global_seq;  /* peer's global seq for this connection */
+
+	int auth_retry;       /* true if we need a newer authorizer */
+	void *auth_reply_buf;   /* where to put the authorizer reply */
+	int auth_reply_buf_len;
+
+	struct mutex mutex;
+
+	/* out queue */
+	struct list_head out_queue;
+	struct list_head out_sent;   /* sending or sent but unacked */
+	u64 out_seq;		     /* last message queued for send */
+	bool out_keepalive_pending;
+
+	u64 in_seq, in_seq_acked;  /* last message received, acked */
+
+	/* connection negotiation temps */
+	char in_banner[CEPH_BANNER_MAX_LEN];
+	union {
+		struct {  /* outgoing connection */
+			struct ceph_msg_connect out_connect;
+			struct ceph_msg_connect_reply in_reply;
+		};
+		struct {  /* incoming */
+			struct ceph_msg_connect in_connect;
+			struct ceph_msg_connect_reply out_reply;
+		};
+	};
+	struct ceph_entity_addr actual_peer_addr;
+
+	/* message out temps */
+	struct ceph_msg *out_msg;        /* sending message (== tail of
+					    out_sent) */
+	bool out_msg_done;
+	struct ceph_msg_pos out_msg_pos;
+
+	struct kvec out_kvec[8],         /* sending header/footer data */
+		*out_kvec_cur;
+	int out_kvec_left;   /* kvec's left in out_kvec */
+	int out_skip;        /* skip this many bytes */
+	int out_kvec_bytes;  /* total bytes left */
+	bool out_kvec_is_msg; /* kvec refers to out_msg */
+	int out_more;        /* there is more data after the kvecs */
+	__le64 out_temp_ack; /* for writing an ack */
+
+	/* message in temps */
+	struct ceph_msg_header in_hdr;
+	struct ceph_msg *in_msg;
+	struct ceph_msg_pos in_msg_pos;
+	u32 in_front_crc, in_middle_crc, in_data_crc;  /* calculated crc */
+
+	char in_tag;         /* protocol control byte */
+	int in_base_pos;     /* bytes read */
+	__le64 in_temp_ack;  /* for reading an ack */
+
+	struct delayed_work work;	    /* send|recv work */
+	unsigned long       delay;          /* current delay interval */
+};
+
+
+extern const char *ceph_pr_addr(const struct sockaddr_storage *ss);
+extern int ceph_parse_ips(const char *c, const char *end,
+			  struct ceph_entity_addr *addr,
+			  int max_count, int *count);
+
+
+extern int ceph_msgr_init(void);
+extern void ceph_msgr_exit(void);
+extern void ceph_msgr_flush(void);
+
+extern struct ceph_messenger *ceph_messenger_create(
+	struct ceph_entity_addr *myaddr,
+	u32 features, u32 required);
+extern void ceph_messenger_destroy(struct ceph_messenger *);
+
+extern void ceph_con_init(struct ceph_messenger *msgr,
+			  struct ceph_connection *con);
+extern void ceph_con_open(struct ceph_connection *con,
+			  struct ceph_entity_addr *addr);
+extern bool ceph_con_opened(struct ceph_connection *con);
+extern void ceph_con_close(struct ceph_connection *con);
+extern void ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg);
+extern void ceph_con_revoke(struct ceph_connection *con, struct ceph_msg *msg);
+extern void ceph_con_revoke_message(struct ceph_connection *con,
+				  struct ceph_msg *msg);
+extern void ceph_con_keepalive(struct ceph_connection *con);
+extern struct ceph_connection *ceph_con_get(struct ceph_connection *con);
+extern void ceph_con_put(struct ceph_connection *con);
+
+extern struct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags);
+extern void ceph_msg_kfree(struct ceph_msg *m);
+
+
+static inline struct ceph_msg *ceph_msg_get(struct ceph_msg *msg)
+{
+	kref_get(&msg->kref);
+	return msg;
+}
+extern void ceph_msg_last_put(struct kref *kref);
+static inline void ceph_msg_put(struct ceph_msg *msg)
+{
+	kref_put(&msg->kref, ceph_msg_last_put);
+}
+
+extern void ceph_msg_dump(struct ceph_msg *msg);
+
+#endif
