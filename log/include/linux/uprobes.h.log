commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 12bf0b68ed92..f46e0ca0169c 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -1,22 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifndef _LINUX_UPROBES_H
 #define _LINUX_UPROBES_H
 /*
  * User-space Probes (UProbes)
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Copyright (C) IBM Corporation, 2008-2012
  * Authors:
  *	Srikar Dronamraju

commit aad42dd44db086c79ca3f470ad563d2ac4ac218d
Author: Nadav Amit <namit@vmware.com>
Date:   Fri Apr 26 16:22:44 2019 -0700

    uprobes: Initialize uprobes earlier
    
    In order to have a separate address space for text poking, we need to
    duplicate init_mm early during start_kernel(). This, however, introduces
    a problem since uprobes functions are called from dup_mmap(), but
    uprobes is still not initialized in this early stage.
    
    Since uprobes initialization is necassary for fork, and since all the
    dependant initialization has been done when fork is initialized (percpu
    and vmalloc), move uprobes initialization to fork_init(). It does not
    seem uprobes introduces any security problem for the poking_mm.
    
    Crash and burn if uprobes initialization fails, similarly to other early
    initializations. Change the init_probes() name to probes_init() to match
    other early initialization functions name convention.
    
    Reported-by: kernel test robot <lkp@intel.com>
    Signed-off-by: Nadav Amit <namit@vmware.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rick Edgecombe <rick.p.edgecombe@intel.com>
    Cc: Rik van Riel <riel@surriel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: akpm@linux-foundation.org
    Cc: ard.biesheuvel@linaro.org
    Cc: deneen.t.dock@intel.com
    Cc: kernel-hardening@lists.openwall.com
    Cc: kristen@linux.intel.com
    Cc: linux_dti@icloud.com
    Cc: will.deacon@arm.com
    Link: https://lkml.kernel.org/r/20190426232303.28381-6-nadav.amit@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 103a48a48872..12bf0b68ed92 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -115,6 +115,7 @@ struct uprobes_state {
 	struct xol_area		*xol_area;
 };
 
+extern void __init uprobes_init(void);
 extern int set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool is_swbp_insn(uprobe_opcode_t *insn);
@@ -154,6 +155,10 @@ extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 struct uprobes_state {
 };
 
+static inline void uprobes_init(void)
+{
+}
+
 #define uprobe_get_trap_addr(regs)	instruction_pointer(regs)
 
 static inline int

commit 1cc33161a83d20b5462b1e93f95d3ce6388079ee
Author: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
Date:   Mon Aug 20 10:12:47 2018 +0530

    uprobes: Support SDT markers having reference count (semaphore)
    
    Userspace Statically Defined Tracepoints[1] are dtrace style markers
    inside userspace applications. Applications like PostgreSQL, MySQL,
    Pthread, Perl, Python, Java, Ruby, Node.js, libvirt, QEMU, glib etc
    have these markers embedded in them. These markers are added by developer
    at important places in the code. Each marker source expands to a single
    nop instruction in the compiled code but there may be additional
    overhead for computing the marker arguments which expands to couple of
    instructions. In case the overhead is more, execution of it can be
    omitted by runtime if() condition when no one is tracing on the marker:
    
        if (reference_counter > 0) {
            Execute marker instructions;
        }
    
    Default value of reference counter is 0. Tracer has to increment the
    reference counter before tracing on a marker and decrement it when
    done with the tracing.
    
    Implement the reference counter logic in core uprobe. User will be
    able to use it from trace_uprobe as well as from kernel module. New
    trace_uprobe definition with reference counter will now be:
    
        <path>:<offset>[(ref_ctr_offset)]
    
    where ref_ctr_offset is an optional field. For kernel module, new
    variant of uprobe_register() has been introduced:
    
        uprobe_register_refctr(inode, offset, ref_ctr_offset, consumer)
    
    No new variant for uprobe_unregister() because it's assumed to have
    only one reference counter for one uprobe.
    
    [1] https://sourceware.org/systemtap/wiki/UserSpaceProbeImplementation
    
    Note: 'reference counter' is called as 'semaphore' in original Dtrace
    (or Systemtap, bcc and even in ELF) documentation and code. But the
    term 'semaphore' is misleading in this context. This is just a counter
    used to hold number of tracers tracing on a marker. This is not really
    used for any synchronization. So we are calling it a 'reference counter'
    in kernel / perf code.
    
    Link: http://lkml.kernel.org/r/20180820044250.11659-2-ravi.bangoria@linux.ibm.com
    
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    [Only trace_uprobe.c]
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Song Liu <songliubraving@fb.com>
    Tested-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index bb9d2084af03..103a48a48872 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -123,6 +123,7 @@ extern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);
 extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
 extern int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
+extern int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
@@ -160,6 +161,10 @@ uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
 	return -ENOSYS;
 }
+static inline int uprobe_register_refctr(struct inode *inode, loff_t offset, loff_t ref_ctr_offset, struct uprobe_consumer *uc)
+{
+	return -ENOSYS;
+}
 static inline int
 uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool add)
 {

commit 6d43743e9079ac0531b60cde7eadd0f042873344
Author: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
Date:   Thu Aug 9 09:48:52 2018 +0530

    Uprobe: Additional argument arch_uprobe to uprobe_write_opcode()
    
    Add addition argument 'arch_uprobe' to uprobe_write_opcode().
    We need this in later set of patches.
    
    Link: http://lkml.kernel.org/r/20180809041856.1547-3-ravi.bangoria@linux.ibm.com
    
    Reviewed-by: Song Liu <songliubraving@fb.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 0a294e950df8..bb9d2084af03 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -121,7 +121,7 @@ extern bool is_swbp_insn(uprobe_opcode_t *insn);
 extern bool is_trap_insn(uprobe_opcode_t *insn);
 extern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);
 extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
-extern int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
+extern int uprobe_write_opcode(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);

commit e8f4aa6087fa80732382881ef7c0c96733bb1984
Author: Allen Pais <allen.pais@oracle.com>
Date:   Thu Oct 13 10:06:13 2016 +0530

    sparc64:Support User Probes for sparc
    
    Signed-off-by: Eric Saint Etienne <eric.saint.etienne@oracle.com>
    Signed-off-by: Allen Pais <allen.pais@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 4a29c75b146e..0a294e950df8 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -27,6 +27,7 @@
 #include <linux/errno.h>
 #include <linux/rbtree.h>
 #include <linux/types.h>
+#include <linux/wait.h>
 
 struct vm_area_struct;
 struct mm_struct;

commit 90eec103b96e30401c0b846045bf8a1c7159b6da
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 16 11:08:45 2015 +0100

    treewide: Remove old email address
    
    There were still a number of references to my old Red Hat email
    address in the kernel source. Remove these while keeping the
    Red Hat copyright notices intact.
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Stephane Eranian <eranian@google.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vince Weaver <vincent.weaver@maine.edu>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 0bdc72f36905..4a29c75b146e 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -21,7 +21,7 @@
  * Authors:
  *	Srikar Dronamraju
  *	Jim Keniston
- * Copyright (C) 2011-2012 Red Hat, Inc., Peter Zijlstra <pzijlstr@redhat.com>
+ * Copyright (C) 2011-2012 Red Hat, Inc., Peter Zijlstra
  */
 
 #include <linux/errno.h>

commit db087ef69a2b155ae001665bf0b3806abde7ee34
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Jul 21 15:40:28 2015 +0200

    uprobes/x86: Make arch_uretprobe_is_alive(RP_CHECK_CALL) more clever
    
    The previous change documents that cleanup_return_instances()
    can't always detect the dead frames, the stack can grow. But
    there is one special case which imho worth fixing:
    arch_uretprobe_is_alive() can return true when the stack didn't
    actually grow, but the next "call" insn uses the already
    invalidated frame.
    
    Test-case:
    
            #include <stdio.h>
            #include <setjmp.h>
    
            jmp_buf jmp;
            int nr = 1024;
    
            void func_2(void)
            {
                    if (--nr == 0)
                            return;
                    longjmp(jmp, 1);
            }
    
            void func_1(void)
            {
                    setjmp(jmp);
                    func_2();
            }
    
            int main(void)
            {
                    func_1();
                    return 0;
            }
    
    If you ret-probe func_1() and func_2() prepare_uretprobe() hits
    the MAX_URETPROBE_DEPTH limit and "return" from func_2() is not
    reported.
    
    When we know that the new call is not chained, we can do the
    more strict check. In this case "sp" points to the new ret-addr,
    so every frame which uses the same "sp" must be dead. The only
    complication is that arch_uretprobe_is_alive() needs to know was
    it chained or not, so we add the new RP_CHECK_CHAIN_CALL enum
    and change prepare_uretprobe() to pass RP_CHECK_CALL only if
    !chained.
    
    Note: arch_uretprobe_is_alive() could also re-read *sp and check
    if this word is still trampoline_vaddr. This could obviously
    improve the logic, but I would like to avoid another
    copy_from_user() especially in the case when we can't avoid the
    false "alive == T" positives.
    
    Tested-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Anton Arapov <arapov@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150721134028.GA4786@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index c0a540239ab6..0bdc72f36905 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -104,6 +104,7 @@ struct return_instance {
 
 enum rp_check {
 	RP_CHECK_CALL,
+	RP_CHECK_CHAIN_CALL,
 	RP_CHECK_RET,
 };
 

commit 86dcb702e74b8ab7d3b2d36984ef00671cea73b9
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Jul 21 15:40:26 2015 +0200

    uprobes: Add the "enum rp_check ctx" arg to arch_uretprobe_is_alive()
    
    arch/x86 doesn't care (so far), but as Pratyush Anand pointed
    out other architectures might want why arch_uretprobe_is_alive()
    was called and use different checks depending on the context.
    Add the new argument to distinguish 2 callers.
    
    Tested-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Anton Arapov <arapov@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150721134026.GA4779@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 7ab6d2c8be49..c0a540239ab6 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -102,6 +102,11 @@ struct return_instance {
 	struct return_instance	*next;		/* keep as stack */
 };
 
+enum rp_check {
+	RP_CHECK_CALL,
+	RP_CHECK_RET,
+};
+
 struct xol_area;
 
 struct uprobes_state {
@@ -138,7 +143,7 @@ extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
 extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
-extern bool arch_uretprobe_is_alive(struct return_instance *ret, struct pt_regs *regs);
+extern bool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx, struct pt_regs *regs);
 extern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
 extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 					 void *src, unsigned long len);

commit 7b868e4802a86d867aad1be0471b5767d9c20e10
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Jul 21 15:40:18 2015 +0200

    uprobes/x86: Reimplement arch_uretprobe_is_alive()
    
    Add the x86 specific version of arch_uretprobe_is_alive()
    helper. It returns true if the stack frame mangled by
    prepare_uretprobe() is still on stack. So if it returns false,
    we know that the probed function has already returned.
    
    We add the new return_instance->stack member and change the
    generic code to initialize it in prepare_uretprobe, but it
    should be equally useful for other architectures.
    
    TODO: this assumes that the probed application can't use
          multiple stacks (say sigaltstack). We will try to improve
          this logic later.
    
    Tested-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Anton Arapov <arapov@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150721134018.GA4766@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 50d2764d66a8..7ab6d2c8be49 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -95,6 +95,7 @@ struct uprobe_task {
 struct return_instance {
 	struct uprobe		*uprobe;
 	unsigned long		func;
+	unsigned long		stack;		/* stack pointer */
 	unsigned long		orig_ret_vaddr; /* original return address */
 	bool			chained;	/* true, if instance is nested */
 

commit 97da89767d398c1dfa1f34e5f312eb8ebb382f7f
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Jul 21 15:40:16 2015 +0200

    uprobes: Export 'struct return_instance', introduce arch_uretprobe_is_alive()
    
    Add the new "weak" helper, arch_uretprobe_is_alive(), used by
    the next patches. It should return true if this return_instance
    is still valid. The arch agnostic version just always returns
    true.
    
    The patch exports "struct return_instance" for the architectures
    which want to override this hook. We can also cleanup
    prepare_uretprobe() if we pass the new return_instance to
    arch_uretprobe_hijack_return_addr().
    
    Tested-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Anton Arapov <arapov@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/20150721134016.GA4762@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 60beb5dc7977..50d2764d66a8 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -92,6 +92,15 @@ struct uprobe_task {
 	unsigned int			depth;
 };
 
+struct return_instance {
+	struct uprobe		*uprobe;
+	unsigned long		func;
+	unsigned long		orig_ret_vaddr; /* original return address */
+	bool			chained;	/* true, if instance is nested */
+
+	struct return_instance	*next;		/* keep as stack */
+};
+
 struct xol_area;
 
 struct uprobes_state {
@@ -128,6 +137,7 @@ extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
 extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
+extern bool arch_uretprobe_is_alive(struct return_instance *ret, struct pt_regs *regs);
 extern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
 extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 					 void *src, unsigned long len);

commit 271a9c35158910496f6fc3a635c2ed85df6be3d9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 13 19:01:03 2014 -0600

    uprobes: Remove "weak" from function declarations
    
    For the following interfaces:
    
      set_swbp()
      set_orig_insn()
      is_swbp_insn()
      is_trap_insn()
      uprobe_get_swbp_addr()
      arch_uprobe_ignore()
      arch_uprobe_copy_ixol()
    
    kernel/events/uprobes.c provides default definitions explicitly marked
    "weak".  Some architectures provide their own definitions intended to
    override the defaults, but the "weak" attribute on the declarations applied
    to the arch definitions as well, so the linker chose one based on link
    order (see 10629d711ed7 ("PCI: Remove __weak annotation from
    pcibios_get_phb_of_node decl")).
    
    Remove the "weak" attribute from the declarations so we always prefer a
    non-weak definition over the weak one, independent of link order.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    CC: Victor Kamensky <victor.kamensky@linaro.org>
    CC: Oleg Nesterov <oleg@redhat.com>
    CC: David A. Long <dave.long@linaro.org>
    CC: Ananth N Mavinakayanahalli <ananth@in.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 4f844c6b03ee..60beb5dc7977 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -98,11 +98,11 @@ struct uprobes_state {
 	struct xol_area		*xol_area;
 };
 
-extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
-extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
-extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
-extern bool __weak is_trap_insn(uprobe_opcode_t *insn);
-extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
+extern int set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
+extern int set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
+extern bool is_swbp_insn(uprobe_opcode_t *insn);
+extern bool is_trap_insn(uprobe_opcode_t *insn);
+extern unsigned long uprobe_get_swbp_addr(struct pt_regs *regs);
 extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
 extern int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
@@ -128,8 +128,8 @@ extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
 extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
-extern bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
-extern void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
+extern bool arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
+extern void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 					 void *src, unsigned long len);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {

commit 3737a12761636ebde0f09ef49daebb8eed18cc8a
Merge: c29deef32e36 82b897782d10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 19:18:49 2014 -0700

    Merge branch 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull more perf updates from Ingo Molnar:
     "A second round of perf updates:
    
       - wide reaching kprobes sanitization and robustization, with the hope
         of fixing all 'probe this function crashes the kernel' bugs, by
         Masami Hiramatsu.
    
       - uprobes updates from Oleg Nesterov: tmpfs support, corner case
         fixes and robustization work.
    
       - perf tooling updates and fixes from Jiri Olsa, Namhyung Ki, Arnaldo
         et al:
            * Add support to accumulate hist periods (Namhyung Kim)
            * various fixes, refactorings and enhancements"
    
    * 'perf-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (101 commits)
      perf: Differentiate exec() and non-exec() comm events
      perf: Fix perf_event_comm() vs. exec() assumption
      uprobes/x86: Rename arch_uprobe->def to ->defparam, minor comment updates
      perf/documentation: Add description for conditional branch filter
      perf/x86: Add conditional branch filtering support
      perf/tool: Add conditional branch filter 'cond' to perf record
      perf: Add new conditional branch filter 'PERF_SAMPLE_BRANCH_COND'
      uprobes: Teach copy_insn() to support tmpfs
      uprobes: Shift ->readpage check from __copy_insn() to uprobe_register()
      perf/x86: Use common PMU interrupt disabled code
      perf/ARM: Use common PMU interrupt disabled code
      perf: Disable sampled events if no PMU interrupt
      perf: Fix use after free in perf_remove_from_context()
      perf tools: Fix 'make help' message error
      perf record: Fix poll return value propagation
      perf tools: Move elide bool into perf_hpp_fmt struct
      perf tools: Remove elide setup for SORT_MODE__MEMORY mode
      perf tools: Fix "==" into "=" in ui_browser__warning assignment
      perf tools: Allow overriding sysfs and proc finding with env var
      perf tools: Consider header files outside perf directory in tags target
      ...

commit 72e6ae285a1dbff553734985bedadf409d99c02d
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 29 04:20:52 2014 +0100

    ARM: 8043/1: uprobes need icache flush after xol write
    
    After instruction write into xol area, on ARM V7
    architecture code need to flush dcache and icache to sync
    them up for given set of addresses. Having just
    'flush_dcache_page(page)' call is not enough - it is
    possible to have stale instruction sitting in icache
    for given xol area slot address.
    
    Introduce arch_uprobe_ixol_copy weak function
    that by default calls uprobes copy_to_page function and
    than flush_dcache_page function and on ARM define new one
    that handles xol slot copy in ARM specific way
    
    flush_uprobe_xol_access function shares/reuses implementation
    with/of flush_ptrace_access function and takes care of writing
    instruction to user land address space on given variety of
    different cache types on ARM CPUs. Because
    flush_uprobe_xol_access does not have vma around
    flush_ptrace_access was split into two parts. First that
    retrieves set of condition from vma and common that receives
    those conditions as flags.
    
    Note ARM cache flush function need kernel address
    through which instruction write happened, so instead
    of using uprobes copy_to_page function changed
    code to explicitly map page and do memcpy.
    
    Note arch_uprobe_copy_ixol function, in similar way as
    copy_to_user_page function, has preempt_disable/preempt_enable.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: David A. Long <dave.long@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index edff2b97b864..c52f827ba6ce 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -32,6 +32,7 @@ struct vm_area_struct;
 struct mm_struct;
 struct inode;
 struct notifier_block;
+struct page;
 
 #define UPROBE_HANDLER_REMOVE		1
 #define UPROBE_HANDLER_MASK		1
@@ -127,6 +128,8 @@ extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned l
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
 extern bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
+extern void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
+					 void *src, unsigned long len);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {
 };

commit b02ef20a9fba08948e643d3eec0efadf1da01a44
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon May 12 18:24:45 2014 +0200

    uprobes/x86: Fix the wrong ->si_addr when xol triggers a trap
    
    If the probed insn triggers a trap, ->si_addr = regs->ip is technically
    correct, but this is not what the signal handler wants; we need to pass
    the address of the probed insn, not the address of xol slot.
    
    Add the new arch-agnostic helper, uprobe_get_trap_addr(), and change
    fill_trap_info() and math_error() to use it. !CONFIG_UPROBES case in
    uprobes.h uses a macro to avoid include hell and ensure that it can be
    compiled even if an architecture doesn't define instruction_pointer().
    
    Test-case:
    
            #include <signal.h>
            #include <stdio.h>
            #include <unistd.h>
    
            extern void probe_div(void);
    
            void sigh(int sig, siginfo_t *info, void *c)
            {
                    int passed = (info->si_addr == probe_div);
                    printf(passed ? "PASS\n" : "FAIL\n");
                    _exit(!passed);
            }
    
            int main(void)
            {
                    struct sigaction sa = {
                            .sa_sigaction   = sigh,
                            .sa_flags       = SA_SIGINFO,
                    };
    
                    sigaction(SIGFPE, &sa, NULL);
    
                    asm (
                            "xor %ecx,%ecx\n"
                            ".globl probe_div; probe_div:\n"
                            "idiv %ecx\n"
                    );
    
                    return 0;
            }
    
    it fails if probe_div() is probed.
    
    Note: show_unhandled_signals users should probably use this helper too,
    but we need to cleanup them first.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index edff2b97b864..88c3b7e8b384 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -102,6 +102,7 @@ extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, u
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern bool __weak is_trap_insn(uprobe_opcode_t *insn);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
+extern unsigned long uprobe_get_trap_addr(struct pt_regs *regs);
 extern int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
@@ -130,6 +131,9 @@ extern bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *r
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {
 };
+
+#define uprobe_get_trap_addr(regs)	instruction_pointer(regs)
+
 static inline int
 uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {

commit 6fe50a28ba6e5fafb4a549dea666dd15297dd8bd
Author: David A. Long <dave.long@linaro.org>
Date:   Mon Feb 3 14:25:49 2014 -0500

    uprobes: allow ignoring of probe hits
    
    Allow arches to decided to ignore a probe hit.  ARM will use this to
    only call handlers if the conditions to execute a conditionally executed
    instruction are satisfied.
    
    Signed-off-by: David A. Long <dave.long@linaro.org>
    Acked-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index e32251e00e62..edff2b97b864 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -126,6 +126,7 @@ extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
 extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
 extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
 extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
+extern bool __weak arch_uprobe_ignore(struct arch_uprobe *aup, struct pt_regs *regs);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {
 };

commit c912dae60ae6f659455f239298110adc67a5f3e9
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sat Nov 9 19:49:39 2013 +0100

    uprobes: Cleanup !CONFIG_UPROBES decls, unexport xol_area
    
    1. Don't include asm/uprobes.h unconditionally, we only need
       it if CONFIG_UPROBES.
    
    2. Move the definition of "struct xol_area" into uprobes.c.
    
       Perhaps we should simply kill struct uprobes_state, it buys
       nothing.
    
    3. Kill the dummy definition of uprobe_get_swbp_addr(), nobody
       except handle_swbp() needs it.
    
    4. Purely cosmetic, but move the decl of uprobe_get_swbp_addr()
       up, close to other __weak helpers.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 2225542624de..e32251e00e62 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -33,10 +33,6 @@ struct mm_struct;
 struct inode;
 struct notifier_block;
 
-#ifdef CONFIG_ARCH_SUPPORTS_UPROBES
-# include <asm/uprobes.h>
-#endif
-
 #define UPROBE_HANDLER_REMOVE		1
 #define UPROBE_HANDLER_MASK		1
 
@@ -61,6 +57,8 @@ struct uprobe_consumer {
 };
 
 #ifdef CONFIG_UPROBES
+#include <asm/uprobes.h>
+
 enum uprobe_task_state {
 	UTASK_RUNNING,
 	UTASK_SSTEP,
@@ -93,24 +91,7 @@ struct uprobe_task {
 	unsigned int			depth;
 };
 
-/*
- * On a breakpoint hit, thread contests for a slot.  It frees the
- * slot after singlestep. Currently a fixed number of slots are
- * allocated.
- */
-struct xol_area {
-	wait_queue_head_t 	wq;		/* if all slots are busy */
-	atomic_t 		slot_count;	/* number of in-use slots */
-	unsigned long 		*bitmap;	/* 0 = free slot */
-	struct page 		*page;
-
-	/*
-	 * We keep the vma's vm_start rather than a pointer to the vma
-	 * itself.  The probed process or a naughty kernel module could make
-	 * the vma go away, and we must handle that reasonably gracefully.
-	 */
-	unsigned long 		vaddr;		/* Page(s) of instruction slots */
-};
+struct xol_area;
 
 struct uprobes_state {
 	struct xol_area		*xol_area;
@@ -120,6 +101,7 @@ extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsign
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern bool __weak is_trap_insn(uprobe_opcode_t *insn);
+extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
 extern int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
@@ -131,7 +113,6 @@ extern void uprobe_end_dup_mmap(void);
 extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t, unsigned long flags);
-extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
 extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
 extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
 extern void uprobe_notify_resume(struct pt_regs *regs);
@@ -187,10 +168,6 @@ static inline bool uprobe_deny_signal(void)
 {
 	return false;
 }
-static inline unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)
-{
-	return 0;
-}
 static inline void uprobe_free_utask(struct task_struct *t)
 {
 }

commit 3247343118daa73f2b94b7fa565425d1d9f9ac84
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Nov 8 18:52:21 2013 +0100

    uprobes: Add uprobe_task->dup_xol_work/dup_xol_addr
    
    uprobe_task->vaddr is a bit strange. The generic code uses it only
    to pass the additional argument to arch_uprobe_pre_xol(), and since
    it is always equal to instruction_pointer() this looks even more
    strange.
    
    And both utask->vaddr and and utask->autask have the same scope,
    they only have the meaning when the task executes the probed insn
    out-of-line, so it is safe to reuse both in UTASK_RUNNING state.
    
    This all means that logically ->vaddr belongs to arch_uprobe_task
    and we should probably move it there, arch_uprobe_pre_xol() can
    record instruction_pointer() itself.
    
    OTOH, it is also used by uprobe_copy_process() and dup_xol_work()
    for another purpose, this doesn't look clean and doesn't allow to
    move this member into arch_uprobe_task.
    
    This patch adds the union with 2 anonymous structs into uprobe_task.
    
    The first struct is autask + vaddr, this way we "almost" move vaddr
    into autask.
    
    The second struct has 2 new members for uprobe_copy_process() paths:
    ->dup_xol_addr which can be used instead ->vaddr, and ->dup_xol_work
    which can be used to avoid kmalloc() and simplify the code.
    
    Note that this union will likely have another member(s), we need
    something like "private_data_for_handlers" so that the tracing
    handlers could use it to communicate with call_fetch() methods.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 319eae70fe84..2225542624de 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -26,6 +26,7 @@
 
 #include <linux/errno.h>
 #include <linux/rbtree.h>
+#include <linux/types.h>
 
 struct vm_area_struct;
 struct mm_struct;
@@ -72,14 +73,24 @@ enum uprobe_task_state {
  */
 struct uprobe_task {
 	enum uprobe_task_state		state;
-	struct arch_uprobe_task		autask;
 
-	struct return_instance		*return_instances;
-	unsigned int			depth;
-	struct uprobe			*active_uprobe;
+	union {
+		struct {
+			struct arch_uprobe_task	autask;
+			unsigned long		vaddr;
+		};
+
+		struct {
+			struct callback_head	dup_xol_work;
+			unsigned long		dup_xol_addr;
+		};
+	};
 
+	struct uprobe			*active_uprobe;
 	unsigned long			xol_vaddr;
-	unsigned long			vaddr;
+
+	struct return_instance		*return_instances;
+	unsigned int			depth;
 };
 
 /*

commit f72d41fa902fb19a9b63028202a400b0ce497491
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Nov 5 19:50:39 2013 +0100

    uprobes: Export write_opcode() as uprobe_write_opcode()
    
    set_swbp() and set_orig_insn() are __weak, but this is pointless
    because write_opcode() is static.
    
    Export write_opcode() as uprobe_write_opcode() for the upcoming
    arm port, this way it can actually override set_swbp() and use
    __opcode_to_mem_arm(bpinsn) instead if UPROBE_SWBP_INSN.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 28473e3f6068..319eae70fe84 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -109,6 +109,7 @@ extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsign
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern bool __weak is_trap_insn(uprobe_opcode_t *insn);
+extern int uprobe_write_opcode(struct mm_struct *mm, unsigned long vaddr, uprobe_opcode_t);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);

commit 3820b4d2789f5166afdb136bb14f93166e6cfbc2
Author: David A. Long <dave.long@linaro.org>
Date:   Tue Oct 15 17:04:16 2013 -0400

    uprobes: Move function declarations out of arch
    
    Move the function declarations from the arch headers to the common
    header, since only the function bodies are architecture-specific.
    These changes are from Vincent Rabin's uprobes patch.
    
    [ oleg: update arch/powerpc/include/asm/uprobes.h ]
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: David A. Long <dave.long@linaro.org>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 9e0d5a6fe7a8..28473e3f6068 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -30,6 +30,7 @@
 struct vm_area_struct;
 struct mm_struct;
 struct inode;
+struct notifier_block;
 
 #ifdef CONFIG_ARCH_SUPPORTS_UPROBES
 # include <asm/uprobes.h>
@@ -125,6 +126,13 @@ extern void uprobe_notify_resume(struct pt_regs *regs);
 extern bool uprobe_deny_signal(void);
 extern bool arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
 extern void uprobe_clear_state(struct mm_struct *mm);
+extern int  arch_uprobe_analyze_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long addr);
+extern int  arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern int  arch_uprobe_post_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern bool arch_uprobe_xol_was_trapped(struct task_struct *tsk);
+extern int  arch_uprobe_exception_notify(struct notifier_block *self, unsigned long val, void *data);
+extern void arch_uprobe_abort_xol(struct arch_uprobe *aup, struct pt_regs *regs);
+extern unsigned long arch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr, struct pt_regs *regs);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {
 };

commit 3ab679661721b1ec2aaad99a801870ed59ab1110
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Oct 16 19:39:37 2013 +0200

    uprobes: Teach uprobe_copy_process() to handle CLONE_VFORK
    
    uprobe_copy_process() does nothing if the child shares ->mm with
    the forking process, but there is a special case: CLONE_VFORK.
    In this case it would be more correct to do dup_utask() but avoid
    dup_xol(). This is not that important, the child should not unwind
    its stack too much, this can corrupt the parent's stack, but at
    least we need this to allow to ret-probe __vfork() itself.
    
    Note: in theory, it would be better to check task_pt_regs(p)->sp
    instead of CLONE_VFORK, we need to dup_utask() if and only if the
    child can return from the function called by the parent. But this
    needs the arch-dependant helper, and I think that nobody actually
    does clone(same_stack, CLONE_VM).
    
    Reported-by: Martin Cermak <mcermak@redhat.com>
    Reported-by: David Smith <dsmith@redhat.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index e6fba627ea45..9e0d5a6fe7a8 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -117,7 +117,7 @@ extern void uprobe_start_dup_mmap(void);
 extern void uprobe_end_dup_mmap(void);
 extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
-extern void uprobe_copy_process(struct task_struct *t);
+extern void uprobe_copy_process(struct task_struct *t, unsigned long flags);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
 extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
 extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
@@ -174,7 +174,7 @@ static inline unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)
 static inline void uprobe_free_utask(struct task_struct *t)
 {
 }
-static inline void uprobe_copy_process(struct task_struct *t)
+static inline void uprobe_copy_process(struct task_struct *t, unsigned long flags)
 {
 }
 static inline void uprobe_clear_state(struct mm_struct *mm)

commit c2d3f25dda016d9697c5416810d4528770f0a281
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Oct 9 14:08:09 2013 +0200

    uprobes: Remove the wrong __weak attribute
    
    linux/uprobes.h declares arch_uprobe_skip_sstep() as a weak function.
    But as there is no definition of generic version so when trying to build
    uprobes for an architecture that doesn't yet have a arch_uprobe_skip_sstep()
    implementation, the vmlinux will try to call arch_uprobe_skip_sstep()
    somehwere in Stupidhistan leading to a system crash.  We rather want a
    proper link error so remove arch_uprobe_skip_sstep().
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 06f28beed7c2..e6fba627ea45 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -123,7 +123,7 @@ extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
 extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
 extern void uprobe_notify_resume(struct pt_regs *regs);
 extern bool uprobe_deny_signal(void);
-extern bool __weak arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
+extern bool arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
 extern void uprobe_clear_state(struct mm_struct *mm);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {

commit ded49c55309a37129dc30a5f0e85b8a64e5c1716
Author: Anton Arapov <anton@redhat.com>
Date:   Wed Apr 3 18:00:37 2013 +0200

    uretprobes: Limit the depth of return probe nestedness
    
    Unlike the kretprobes we can't trust userspace, thus must have
    protection from user space attacks. User-space have  "unlimited"
    stack, and this patch limits the return probes nestedness as a
    simple remedy for it.
    
    Note that this implementation leaks return_instance on siglongjmp
    until exit()/exec().
    
    The intention is to have KISS and bare minimum solution for the
    initial implementation in order to not complicate the uretprobes
    code.
    
    In the future we may come up with more sophisticated solution that
    remove this depth limitation. It is not easy task and lays beyond
    this patchset.
    
    Signed-off-by: Anton Arapov <anton@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index b0507f24eeb0..06f28beed7c2 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -38,6 +38,8 @@ struct inode;
 #define UPROBE_HANDLER_REMOVE		1
 #define UPROBE_HANDLER_MASK		1
 
+#define MAX_URETPROBE_DEPTH		64
+
 enum uprobe_filter_ctx {
 	UPROBE_FILTER_REGISTER,
 	UPROBE_FILTER_UNREGISTER,
@@ -72,6 +74,7 @@ struct uprobe_task {
 	struct arch_uprobe_task		autask;
 
 	struct return_instance		*return_instances;
+	unsigned int			depth;
 	struct uprobe			*active_uprobe;
 
 	unsigned long			xol_vaddr;

commit 0dfd0eb8e4d72ded8b21f4fee74ba5547408cbe9
Author: Anton Arapov <anton@redhat.com>
Date:   Wed Apr 3 18:00:35 2013 +0200

    uretprobes: Return probe entry, prepare_uretprobe()
    
    When a uprobe with return probe consumer is hit, prepare_uretprobe()
    function is invoked. It creates return_instance, hijacks return address
    and replaces it with the trampoline.
    
    * Return instances are kept as stack per uprobed task.
    * Return instance is chained, when the original return address is
      trampoline's page vaddr (e.g. recursive call of the probed function).
    
    Signed-off-by: Anton Arapov <anton@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 5c8d3290df41..b0507f24eeb0 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -71,6 +71,7 @@ struct uprobe_task {
 	enum uprobe_task_state		state;
 	struct arch_uprobe_task		autask;
 
+	struct return_instance		*return_instances;
 	struct uprobe			*active_uprobe;
 
 	unsigned long			xol_vaddr;

commit ea024870cf10687b3fded66a9deb6253888f30b7
Author: Anton Arapov <anton@redhat.com>
Date:   Wed Apr 3 18:00:31 2013 +0200

    uretprobes: Introduce uprobe_consumer->ret_handler()
    
    Enclose return probes implementation, introduce ->ret_handler() and update
    existing code to rely on ->handler() *and* ->ret_handler() for uprobe and
    uretprobe respectively.
    
    Signed-off-by: Anton Arapov <anton@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 19612881399a..5c8d3290df41 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -46,6 +46,9 @@ enum uprobe_filter_ctx {
 
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
+	int (*ret_handler)(struct uprobe_consumer *self,
+				unsigned long func,
+				struct pt_regs *regs);
 	bool (*filter)(struct uprobe_consumer *self,
 				enum uprobe_filter_ctx ctx,
 				struct mm_struct *mm);

commit 0908ad6e56b5a6e86745680bc324bdbfac64d0b6
Author: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
Date:   Fri Mar 22 20:46:27 2013 +0530

    uprobes: Add trap variant helper
    
    Some architectures like powerpc have multiple variants of the trap
    instruction. Introduce an additional helper is_trap_insn() for run-time
    handling of non-uprobe traps on such architectures.
    
    While there, change is_swbp_at_addr() to is_trap_at_addr() for reading
    clarity.
    
    With this change, the uprobe registration path will supercede any trap
    instruction inserted at the requested location, while taking care of
    delivering the SIGTRAP for cases where the trap notification came in
    for an address without a uprobe. See [1] for a more detailed explanation.
    
    [1] https://lists.ozlabs.org/pipermail/linuxppc-dev/2013-March/104771.html
    
    This change was suggested by Oleg Nesterov.
    
    Signed-off-by: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 02b83db8e2c5..19612881399a 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -100,6 +100,7 @@ struct uprobes_state {
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
+extern bool __weak is_trap_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);

commit bdf8647c44766590ed02f9a84a450a796558b753
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Feb 3 19:21:12 2013 +0100

    uprobes: Introduce uprobe_apply()
    
    Currently it is not possible to change the filtering constraints after
    uprobe_register(), so a consumer can not, say, start to trace a task/mm
    which was previously filtered out, or remove the no longer needed bp's.
    
    Introduce uprobe_apply() which simply does register_for_each_vma() again
    to consult uprobe_consumer->filter() and install/remove the breakpoints.
    The only complication is that register_for_each_vma() can no longer
    assume that uprobe->consumers should be consulter if is_register == T,
    so we change it to accept "struct uprobe_consumer *new" instead.
    
    Unlike uprobe_register(), uprobe_apply(true) doesn't do "unregister" if
    register_for_each_vma() fails, it is up to caller to handle the error.
    
    Note: we probably need to cleanup the current interface, it is strange
    that uprobe_apply/unregister need inode/offset. We should either change
    uprobe_register() to return "struct uprobe *", or add a private ->uprobe
    member in uprobe_consumer. And in the long term uprobe_apply() should
    take a single argument, uprobe or consumer, even "bool add" should go
    away.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 95d0002efda5..02b83db8e2c5 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -101,6 +101,7 @@ extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsign
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
+extern int uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
 extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
@@ -124,6 +125,11 @@ uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
 	return -ENOSYS;
 }
+static inline int
+uprobe_apply(struct inode *inode, loff_t offset, struct uprobe_consumer *uc, bool add)
+{
+	return -ENOSYS;
+}
 static inline void
 uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {

commit da1816b1caeccdff04531e763bb35d7caa3ed19f
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sat Dec 29 17:49:11 2012 +0100

    uprobes: Teach handler_chain() to filter out the probed task
    
    Currrently the are 2 problems with pre-filtering:
    
    1. It is not possible to add/remove a task (mm) after uprobe_register()
    
    2. A forked child inherits all breakpoints and uprobe_consumer can not
       control this.
    
    This patch does the first step to improve the filtering. handler_chain()
    removes the breakpoints installed by this uprobe from current->mm if all
    handlers return UPROBE_HANDLER_REMOVE.
    
    Note that handler_chain() relies on ->register_rwsem to avoid the race
    with uprobe_register/unregister which can add/del a consumer, or even
    remove and then insert the new uprobe at the same address.
    
    Perhaps we will add uprobe_apply_mm(uprobe, mm, is_register) and teach
    copy_mm() to do filter(UPROBE_FILTER_FORK), but I think this change makes
    sense anyway.
    
    Note: instead of checking the retcode from uc->handler, we could add
    uc->filter(UPROBE_FILTER_BPHIT). But I think this is not optimal to
    call 2 hooks in a row. This buys nothing, and if handler/filter do
    something nontrivial they will probably do the same work twice.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index c2df6934fdc6..95d0002efda5 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -35,6 +35,9 @@ struct inode;
 # include <asm/uprobes.h>
 #endif
 
+#define UPROBE_HANDLER_REMOVE		1
+#define UPROBE_HANDLER_MASK		1
+
 enum uprobe_filter_ctx {
 	UPROBE_FILTER_REGISTER,
 	UPROBE_FILTER_UNREGISTER,

commit 8a7f2fa0dea3b019500961b86d765e6fdd4bffb2
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Dec 28 17:58:38 2012 +0100

    uprobes: Reintroduce uprobe_consumer->filter()
    
    Finally add uprobe_consumer->filter() and change consumer_filter()
    to actually call this method.
    
    Note that ->filter() accepts mm_struct, not task_struct. Because:
    
            1. We do not have for_each_mm_user(mm, task).
    
            2. Even if we implement for_each_mm_user(), ->filter() can
               use it itself.
    
            3. It is not clear who will actually need this interface to
               do the "nontrivial" filtering.
    
    Another argument is "enum uprobe_filter_ctx", consumer->filter() can
    use it to figure out why/where it was called. For example, perhaps
    we can add UPROBE_FILTER_PRE_REGISTER used by build_map_info() to
    quickly "nack" the unwanted mm's. In this case consumer should know
    that it is called under ->i_mmap_mutex.
    
    See the previous discussion at http://marc.info/?t=135214229700002
    Perhaps we should pass more arguments, vma/vaddr?
    
    Note: this patch obviously can't help to filter out the child created
    by fork(), this will be addressed later.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 83742b91ff73..c2df6934fdc6 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -35,8 +35,17 @@ struct inode;
 # include <asm/uprobes.h>
 #endif
 
+enum uprobe_filter_ctx {
+	UPROBE_FILTER_REGISTER,
+	UPROBE_FILTER_UNREGISTER,
+	UPROBE_FILTER_MMAP,
+};
+
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
+	bool (*filter)(struct uprobe_consumer *self,
+				enum uprobe_filter_ctx ctx,
+				struct mm_struct *mm);
 
 	struct uprobe_consumer *next;
 };

commit fe20d71f25400cccc8bffef865f79250be7dbc81
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Nov 21 17:32:30 2012 +0100

    uprobes: Kill uprobe_consumer->filter()
    
    uprobe_consumer->filter() is pointless in its current form, kill it.
    
    We will add it back, but with the different signature/semantics. Perhaps
    we will even re-introduce the callsite in handler_chain(), but not to
    just skip uc->handler().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 4f628a6fc5b4..83742b91ff73 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -37,11 +37,6 @@ struct inode;
 
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
-	/*
-	 * filter is optional; If a filter exists, handler is run
-	 * if and only if filter returns true.
-	 */
-	bool (*filter)(struct uprobe_consumer *self, struct task_struct *task);
 
 	struct uprobe_consumer *next;
 };

commit 32cdba1e05418909708a17e52505e8b2ba4381d1
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Nov 14 19:03:42 2012 +0100

    uprobes: Use percpu_rw_semaphore to fix register/unregister vs dup_mmap() race
    
    This was always racy, but 268720903f87e0b84b161626c4447b81671b5d18
    "uprobes: Rework register_for_each_vma() to make it O(n)" should be
    blamed anyway, it made everything worse and I didn't notice.
    
    register/unregister call build_map_info() and then do install/remove
    breakpoint for every mm which mmaps inode/offset. This can obviously
    race with fork()->dup_mmap() in between and we can miss the child.
    
    uprobe_register() could be easily fixed but unregister is much worse,
    the new mm inherits "int3" from parent and there is no way to detect
    this if uprobe goes away.
    
    So this patch simply adds percpu_down_read/up_read around dup_mmap(),
    and percpu_down_write/up_write into register_for_each_vma().
    
    This adds 2 new hooks into dup_mmap() but we can kill uprobe_dup_mmap()
    and fold it into uprobe_end_dup_mmap().
    
    Reported-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 2615c4d7788d..4f628a6fc5b4 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -97,6 +97,8 @@ extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_con
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
 extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
+extern void uprobe_start_dup_mmap(void);
+extern void uprobe_end_dup_mmap(void);
 extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
@@ -127,6 +129,12 @@ static inline void
 uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
 }
+static inline void uprobe_start_dup_mmap(void)
+{
+}
+static inline void uprobe_end_dup_mmap(void)
+{
+}
 static inline void
 uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)
 {

commit 19f5ee2716373519fda2129e9333f4c3847aa742
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Oct 28 18:14:14 2012 +0100

    uprobes: Kill arch_uprobe_enable/disable_step() hooks
    
    Kill arch_uprobe_enable/disable_step() hooks, they do nothing and
    nobody needs them.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 24594571c5a3..2615c4d7788d 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -101,8 +101,6 @@ extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
-extern void __weak arch_uprobe_enable_step(struct arch_uprobe *arch);
-extern void __weak arch_uprobe_disable_step(struct arch_uprobe *arch);
 extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
 extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
 extern void uprobe_notify_resume(struct pt_regs *regs);

commit cb9a19fe4aa51afa34786bd383e6614fa0083d58
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Sep 30 20:11:45 2012 +0200

    uprobes: Introduce prepare_uprobe()
    
    Preparation. Extract the copy_insn/arch_uprobe_analyze_insn code
    from install_breakpoint() into the new helper, prepare_uprobe().
    
    And move uprobe->flags defines from uprobes.h to uprobes.c, nobody
    else can use them anyway.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 18d839da6517..24594571c5a3 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -35,16 +35,6 @@ struct inode;
 # include <asm/uprobes.h>
 #endif
 
-/* flags that denote/change uprobes behaviour */
-
-/* Have a copy of original instruction */
-#define UPROBE_COPY_INSN	0x1
-
-/* Dont run handlers when first register/ last unregister in progress*/
-#define UPROBE_RUN_HANDLER	0x2
-/* Can skip singlestep */
-#define UPROBE_SKIP_SSTEP	0x4
-
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
 	/*

commit 1b08e907211cdc744f54871736005d9f3e7f182c
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Sep 14 18:52:10 2012 +0200

    uprobes: Kill UTASK_BP_HIT state
    
    Kill UTASK_BP_HIT state, it buys nothing but complicates the code.
    It is only used in uprobe_notify_resume() to decide who should be
    called, we can check utask->active_uprobe != NULL instead. And this
    allows us to simplify handle_swbp(), no need to clear utask->state.
    
    Likewise we could kill UTASK_SSTEP, but UTASK_BP_HIT is worse and
    imho should die. The problem is, it creates the special case when
    task->utask is NULL, we can't distinguish RUNNING and BP_HIT. With
    this patch utask == NULL always means RUNNING.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index e6f0331e3d45..18d839da6517 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -59,7 +59,6 @@ struct uprobe_consumer {
 #ifdef CONFIG_UPROBES
 enum uprobe_task_state {
 	UTASK_RUNNING,
-	UTASK_BP_HIT,
 	UTASK_SSTEP,
 	UTASK_SSTEP_ACK,
 	UTASK_SSTEP_TRAPPED,

commit 9d778782266f95e5c6ec43ed8195ba331c821018
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Aug 7 18:12:28 2012 +0200

    uprobes: Introduce arch_uprobe_enable/disable_step()
    
    As Oleg pointed out in [0] uprobe should not use the ptrace interface
    for enabling/disabling single stepping.
    
    [0] http://lkml.kernel.org/r/20120730141638.GA5306@redhat.com
    
    Add the new "__weak arch" helpers which simply call user_*_single_step()
    as a preparation. This is only needed to not break the powerpc port, we
    will fold this logic into arch_uprobe_pre/post_xol() hooks later.
    
    We should also change handle_singlestep(), _disable_step(&uprobe->arch)
    should be called before put_uprobe().
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 6d4fe79a1a6a..e6f0331e3d45 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -112,6 +112,8 @@ extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
+extern void __weak arch_uprobe_enable_step(struct arch_uprobe *arch);
+extern void __weak arch_uprobe_disable_step(struct arch_uprobe *arch);
 extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
 extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
 extern void uprobe_notify_resume(struct pt_regs *regs);

commit ded86e7c8fc4404414c4700010c9962ea8bd083a
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Aug 8 18:07:03 2012 +0200

    uprobes: Remove "verify" argument from set_orig_insn()
    
    Nobody does set_orig_insn(verify => false), and I think nobody will.
    Remove this argument. IIUC set_orig_insn(verify => false) was needed
    to single-step without xol area.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 30297f95c8af..6d4fe79a1a6a 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -102,7 +102,7 @@ struct uprobes_state {
 };
 
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
-extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
+extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);

commit 61559a8165da2b6bab7621ac36379c6280efacb6
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Aug 8 17:17:46 2012 +0200

    uprobes: Fold uprobe_reset_state() into uprobe_dup_mmap()
    
    Now that we have uprobe_dup_mmap() we can fold uprobe_reset_state()
    into the new hook and remove it. mmput()->uprobe_clear_state() can't
    be called before dup_mmap().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 4a37ab153247..30297f95c8af 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -118,7 +118,6 @@ extern void uprobe_notify_resume(struct pt_regs *regs);
 extern bool uprobe_deny_signal(void);
 extern bool __weak arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
 extern void uprobe_clear_state(struct mm_struct *mm);
-extern void uprobe_reset_state(struct mm_struct *mm);
 #else /* !CONFIG_UPROBES */
 struct uprobes_state {
 };
@@ -163,8 +162,5 @@ static inline void uprobe_copy_process(struct task_struct *t)
 static inline void uprobe_clear_state(struct mm_struct *mm)
 {
 }
-static inline void uprobe_reset_state(struct mm_struct *mm)
-{
-}
 #endif /* !CONFIG_UPROBES */
 #endif	/* _LINUX_UPROBES_H */

commit f8ac4ec9c064b330dcc49e03c450fe74298c4622
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Aug 8 17:11:42 2012 +0200

    uprobes: Introduce MMF_HAS_UPROBES
    
    Add the new MMF_HAS_UPROBES flag. It is set by install_breakpoint()
    and it is copied by dup_mmap(), uprobe_pre_sstep_notifier() checks
    it to avoid the slow path if the task was never probed. Perhaps it
    makes sense to check it in valid_vma(is_register => false) as well.
    
    This needs the new dup_mmap()->uprobe_dup_mmap() hook. We can't use
    uprobe_reset_state() or put MMF_HAS_UPROBES into MMF_INIT_MASK, we
    need oldmm->mmap_sem to avoid the race with uprobe_register() or
    mmap() from another thread.
    
    Currently we never clear this bit, it can be false-positive after
    uprobe_unregister() or uprobe_munmap() or if dup_mmap() hits the
    probed VM_DONTCOPY vma. But this is fine correctness-wise and has
    no effect unless the task hits the non-uprobe breakpoint.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 03ae547c1c31..4a37ab153247 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -108,6 +108,7 @@ extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_con
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
 extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
+extern void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
@@ -138,6 +139,10 @@ static inline void
 uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
 }
+static inline void
+uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)
+{
+}
 static inline void uprobe_notify_resume(struct pt_regs *regs)
 {
 }

commit 647c42dfd40fec032a4c8525a755160f0765921f
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Aug 6 13:15:09 2012 +0200

    uprobes: Kill uprobes_state->count
    
    uprobes_state->count is only needed to avoid the slow path in
    uprobe_pre_sstep_notifier(). It is also checked in uprobe_munmap()
    but ironically its only goal to decrement this counter. However,
    it is very broken. Just some examples:
    
    - uprobe_mmap() can race with uprobe_unregister() and wrongly
      increment the counter if it hits the non-uprobe "int3". Note
      that install_breakpoint() checks ->consumers first and returns
      -EEXIST if it is NULL.
    
      "atomic_sub() if error" in uprobe_mmap() looks obviously wrong
      too.
    
    - uprobe_munmap() can race with uprobe_register() and wrongly
      decrement the counter by the same reason.
    
    - Suppose an appication tries to increase the mmapped area via
      sys_mremap(). vma_adjust() does uprobe_munmap(whole_vma) first,
      this can nullify the counter temporarily and race with another
      thread which can hit the bp, the application will be killed by
      SIGTRAP.
    
    - Suppose an application mmaps 2 consecutive areas in the same file
      and one (or both) of these areas has uprobes. In the likely case
      mmap_region()->vma_merge() suceeds. Like above, this leads to
      uprobe_munmap/uprobe_mmap from vma_merge()->vma_adjust() but then
      mmap_region() does another uprobe_mmap(resulting_vma) and doubles
      the counter.
    
    This patch only removes this counter and fixes the compile errors,
    then we will try to cleanup the changed code and add something else
    instead.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index efe4b3308c74..03ae547c1c31 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -99,8 +99,8 @@ struct xol_area {
 
 struct uprobes_state {
 	struct xol_area		*xol_area;
-	atomic_t		count;
 };
+
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);

commit cbc91f71b51b8335f1fc7ccfca8011f31a717367
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Wed Apr 11 16:05:27 2012 +0530

    uprobes/core: Decrement uprobe count before the pages are unmapped
    
    Uprobes has a callback (uprobe_munmap()) in the unmap path to
    maintain the uprobes count.
    
    In the exit path this callback gets called in unlink_file_vma().
    However by the time unlink_file_vma() is called, the pages would
    have been unmapped (in unmap_vmas()) and the task->rss_stat counts
    accounted (in zap_pte_range()).
    
    If the exiting process has probepoints, uprobe_munmap() checks if
    the breakpoint instruction was around before decrementing the probe
    count.
    
    This results in a file backed page being reread by uprobe_munmap()
    and hence it does not find the breakpoint.
    
    This patch fixes this problem by moving the callback to
    unmap_single_vma(). Since unmap_single_vma() may not unmap the
    complete vma, add start and end parameters to uprobe_munmap().
    
    This bug became apparent courtesy of commit c3f0327f8e9d
    ("mm: add rss counters consistency check").
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120411103527.23245.9835.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index d594d3b3ad4c..efe4b3308c74 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -107,7 +107,7 @@ extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
-extern void uprobe_munmap(struct vm_area_struct *vma);
+extern void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
@@ -134,7 +134,8 @@ static inline int uprobe_mmap(struct vm_area_struct *vma)
 {
 	return 0;
 }
-static inline void uprobe_munmap(struct vm_area_struct *vma)
+static inline void
+uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
 }
 static inline void uprobe_notify_resume(struct pt_regs *regs)

commit 682968e0c425c60f0dde37977e5beb2b12ddc4cc
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Fri Mar 30 23:56:46 2012 +0530

    uprobes/core: Optimize probe hits with the help of a counter
    
    Maintain a per-mm counter: number of uprobes that are inserted
    on this process address space.
    
    This counter can be used at probe hit time to determine if we
    need a lookup in the uprobes rbtree. Everytime a probe gets
    inserted successfully, the probe count is incremented and
    everytime a probe gets removed, the probe count is decremented.
    
    The new uprobe_munmap hook ensures the count is correct on a
    unmap or remap of a region. We expect that once a
    uprobe_munmap() is called, the vma goes away.  So
    uprobe_unregister() finding a probe to unregister would either
    mean unmap event hasnt occurred yet or a mmap event on the same
    executable file occured after a unmap event.
    
    Additionally, uprobe_mmap hook now also gets called:
    
     a. on every executable vma that is COWed at fork.
     b. a vma of interest is newly mapped; breakpoint insertion also
        happens at the required address.
    
    On process creation, make sure the probes count in the child is
    set correctly.
    
    Special cases that are taken care include:
    
     a. mremap
     b. VM_DONTCOPY vmas on fork()
     c. insertion/removal races in the parent during fork().
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120330182646.10018.85805.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index a111460c07d5..d594d3b3ad4c 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -99,6 +99,7 @@ struct xol_area {
 
 struct uprobes_state {
 	struct xol_area		*xol_area;
+	atomic_t		count;
 };
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
@@ -106,6 +107,7 @@ extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
+extern void uprobe_munmap(struct vm_area_struct *vma);
 extern void uprobe_free_utask(struct task_struct *t);
 extern void uprobe_copy_process(struct task_struct *t);
 extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
@@ -132,6 +134,9 @@ static inline int uprobe_mmap(struct vm_area_struct *vma)
 {
 	return 0;
 }
+static inline void uprobe_munmap(struct vm_area_struct *vma)
+{
+}
 static inline void uprobe_notify_resume(struct pt_regs *regs)
 {
 }

commit d4b3b6384f98f8692ad0209891ccdbc7e78bbefe
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Fri Mar 30 23:56:31 2012 +0530

    uprobes/core: Allocate XOL slots for uprobes use
    
    Uprobes executes the original instruction at a probed location
    out of line. For this, we allocate a page (per mm) upon the
    first uprobe hit, in the process user address space, divide it
    into slots that are used to store the actual instructions to be
    singlestepped. These slots are known as xol (execution out of
    line) slots.
    
    Care is taken to ensure that the allocation is in an unmapped
    area as close to the top of the user address space as possible,
    with appropriate permission settings to keep selinux like
    frameworks happy.
    
    Upon a uprobe hit, a free slot is acquired, and is released
    after the singlestep completes.
    
    Lots of improvements courtesy suggestions/inputs from Peter and
    Oleg.
    
    [ Folded a fix for build issue on powerpc fixed and reported by
      Stephen Rothwell. ]
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120330182631.10018.48175.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 5ec778fdce6f..a111460c07d5 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -28,6 +28,8 @@
 #include <linux/rbtree.h>
 
 struct vm_area_struct;
+struct mm_struct;
+struct inode;
 
 #ifdef CONFIG_ARCH_SUPPORTS_UPROBES
 # include <asm/uprobes.h>
@@ -76,6 +78,28 @@ struct uprobe_task {
 	unsigned long			vaddr;
 };
 
+/*
+ * On a breakpoint hit, thread contests for a slot.  It frees the
+ * slot after singlestep. Currently a fixed number of slots are
+ * allocated.
+ */
+struct xol_area {
+	wait_queue_head_t 	wq;		/* if all slots are busy */
+	atomic_t 		slot_count;	/* number of in-use slots */
+	unsigned long 		*bitmap;	/* 0 = free slot */
+	struct page 		*page;
+
+	/*
+	 * We keep the vma's vm_start rather than a pointer to the vma
+	 * itself.  The probed process or a naughty kernel module could make
+	 * the vma go away, and we must handle that reasonably gracefully.
+	 */
+	unsigned long 		vaddr;		/* Page(s) of instruction slots */
+};
+
+struct uprobes_state {
+	struct xol_area		*xol_area;
+};
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
@@ -90,7 +114,11 @@ extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
 extern void uprobe_notify_resume(struct pt_regs *regs);
 extern bool uprobe_deny_signal(void);
 extern bool __weak arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
+extern void uprobe_clear_state(struct mm_struct *mm);
+extern void uprobe_reset_state(struct mm_struct *mm);
 #else /* !CONFIG_UPROBES */
+struct uprobes_state {
+};
 static inline int
 uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
@@ -121,5 +149,11 @@ static inline void uprobe_free_utask(struct task_struct *t)
 static inline void uprobe_copy_process(struct task_struct *t)
 {
 }
+static inline void uprobe_clear_state(struct mm_struct *mm)
+{
+}
+static inline void uprobe_reset_state(struct mm_struct *mm)
+{
+}
 #endif /* !CONFIG_UPROBES */
 #endif	/* _LINUX_UPROBES_H */

commit 0326f5a94ddea33fa331b2519f4172f4fb387baa
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Tue Mar 13 23:30:11 2012 +0530

    uprobes/core: Handle breakpoint and singlestep exceptions
    
    Uprobes uses exception notifiers to get to know if a thread hit
    a breakpoint or a singlestep exception.
    
    When a thread hits a uprobe or is singlestepping post a uprobe
    hit, the uprobe exception notifier sets its TIF_UPROBE bit,
    which will then be checked on its return to userspace path
    (do_notify_resume() ->uprobe_notify_resume()), where the
    consumers handlers are run (in task context) based on the
    defined filters.
    
    Uprobe hits are thread specific and hence we need to maintain
    information about if a task hit a uprobe, what uprobe was hit,
    the slot where the original instruction was copied for xol so
    that it can be singlestepped with appropriate fixups.
    
    In some cases, special care is needed for instructions that are
    executed out of line (xol). These are architecture specific
    artefacts, such as handling RIP relative instructions on x86_64.
    
    Since the instruction at which the uprobe was inserted is
    executed out of line, architecture specific fixups are added so
    that the thread continues normal execution in the presence of a
    uprobe.
    
    Postpone the signals until we execute the probed insn.
    post_xol() path does a recalc_sigpending() before return to
    user-mode, this ensures the signal can't be lost.
    
    Uprobes relies on DIE_DEBUG notification to notify if a
    singlestep is complete.
    
    Adds x86 specific uprobe exception notifiers and appropriate
    hooks needed to determine a uprobe hit and subsequent post
    processing.
    
    Add requisite x86 fixups for xol for uprobes. Specific cases
    needing fixups include relative jumps (x86_64), calls, etc.
    
    Where possible, we check and skip singlestepping the
    breakpointed instructions. For now we skip single byte as well
    as few multibyte nop instructions. However this can be extended
    to other instructions too.
    
    Credits to Oleg Nesterov for suggestions/patches related to
    signal, breakpoint, singlestep handling code.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120313180011.29771.89027.sendpatchset@srdronam.in.ibm.com
    [ Performed various cleanliness edits ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index eac525f41b94..5ec778fdce6f 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -28,8 +28,9 @@
 #include <linux/rbtree.h>
 
 struct vm_area_struct;
+
 #ifdef CONFIG_ARCH_SUPPORTS_UPROBES
-#include <asm/uprobes.h>
+# include <asm/uprobes.h>
 #endif
 
 /* flags that denote/change uprobes behaviour */
@@ -39,6 +40,8 @@ struct vm_area_struct;
 
 /* Dont run handlers when first register/ last unregister in progress*/
 #define UPROBE_RUN_HANDLER	0x2
+/* Can skip singlestep */
+#define UPROBE_SKIP_SSTEP	0x4
 
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
@@ -52,13 +55,42 @@ struct uprobe_consumer {
 };
 
 #ifdef CONFIG_UPROBES
+enum uprobe_task_state {
+	UTASK_RUNNING,
+	UTASK_BP_HIT,
+	UTASK_SSTEP,
+	UTASK_SSTEP_ACK,
+	UTASK_SSTEP_TRAPPED,
+};
+
+/*
+ * uprobe_task: Metadata of a task while it singlesteps.
+ */
+struct uprobe_task {
+	enum uprobe_task_state		state;
+	struct arch_uprobe_task		autask;
+
+	struct uprobe			*active_uprobe;
+
+	unsigned long			xol_vaddr;
+	unsigned long			vaddr;
+};
+
 extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
 extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
-#else /* CONFIG_UPROBES is not defined */
+extern void uprobe_free_utask(struct task_struct *t);
+extern void uprobe_copy_process(struct task_struct *t);
+extern unsigned long __weak uprobe_get_swbp_addr(struct pt_regs *regs);
+extern int uprobe_post_sstep_notifier(struct pt_regs *regs);
+extern int uprobe_pre_sstep_notifier(struct pt_regs *regs);
+extern void uprobe_notify_resume(struct pt_regs *regs);
+extern bool uprobe_deny_signal(void);
+extern bool __weak arch_uprobe_skip_sstep(struct arch_uprobe *aup, struct pt_regs *regs);
+#else /* !CONFIG_UPROBES */
 static inline int
 uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
@@ -72,5 +104,22 @@ static inline int uprobe_mmap(struct vm_area_struct *vma)
 {
 	return 0;
 }
-#endif /* CONFIG_UPROBES */
+static inline void uprobe_notify_resume(struct pt_regs *regs)
+{
+}
+static inline bool uprobe_deny_signal(void)
+{
+	return false;
+}
+static inline unsigned long uprobe_get_swbp_addr(struct pt_regs *regs)
+{
+	return 0;
+}
+static inline void uprobe_free_utask(struct task_struct *t)
+{
+}
+static inline void uprobe_copy_process(struct task_struct *t)
+{
+}
+#endif /* !CONFIG_UPROBES */
 #endif	/* _LINUX_UPROBES_H */

commit 5cb4ac3a583d4ee18c8682ab857e093c4a0d0895
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:45 2012 +0530

    uprobes/core: Rename bkpt to swbp
    
    bkpt doesnt seem to be a correct abbrevation for breakpoint.
    Choice was between bp and breakpoint. Since bp can refer to
    things other than breakpoint, use swbp to refer to breakpoints.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092545.5379.91251.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 58699182e9a7..eac525f41b94 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -52,9 +52,9 @@ struct uprobe_consumer {
 };
 
 #ifdef CONFIG_UPROBES
-extern int __weak set_bkpt(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
+extern int __weak set_swbp(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
 extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
-extern bool __weak is_bkpt_insn(uprobe_opcode_t *insn);
+extern bool __weak is_swbp_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);

commit e3343e6a2819ff5d0dfc4bb5c9fb7f9a4d04da73
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:30 2012 +0530

    uprobes/core: Make order of function parameters consistent across functions
    
    If a function takes struct uprobe or struct arch_uprobe, then it
    is passed as the first parameter.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092530.5379.18394.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 838fb312926a..58699182e9a7 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -52,20 +52,20 @@ struct uprobe_consumer {
 };
 
 #ifdef CONFIG_UPROBES
-extern int __weak set_bkpt(struct mm_struct *mm, struct arch_uprobe *auprobe, unsigned long vaddr);
-extern int __weak set_orig_insn(struct mm_struct *mm, struct arch_uprobe *auprobe, unsigned long vaddr, bool verify);
+extern int __weak set_bkpt(struct arch_uprobe *aup, struct mm_struct *mm, unsigned long vaddr);
+extern int __weak set_orig_insn(struct arch_uprobe *aup, struct mm_struct *mm,  unsigned long vaddr, bool verify);
 extern bool __weak is_bkpt_insn(uprobe_opcode_t *insn);
-extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);
-extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);
+extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
+extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc);
 extern int uprobe_mmap(struct vm_area_struct *vma);
 #else /* CONFIG_UPROBES is not defined */
 static inline int
-uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer)
+uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
 	return -ENOSYS;
 }
 static inline void
-uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer)
+uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *uc)
 {
 }
 static inline int uprobe_mmap(struct vm_area_struct *vma)

commit 900771a483ef28915a48066d7895d8252315607a
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Mon Mar 12 14:55:14 2012 +0530

    uprobes/core: Make macro names consistent
    
    Rename macros that refer to individual uprobe to start with
    UPROBE_ instead of UPROBES_.
    
    This is pure cleanup, no functional change intended.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Linux-mm <linux-mm@kvack.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20120312092514.5379.36595.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index f85797e1ccd4..838fb312926a 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -35,10 +35,10 @@ struct vm_area_struct;
 /* flags that denote/change uprobes behaviour */
 
 /* Have a copy of original instruction */
-#define UPROBES_COPY_INSN	0x1
+#define UPROBE_COPY_INSN	0x1
 
 /* Dont run handlers when first register/ last unregister in progress*/
-#define UPROBES_RUN_HANDLER	0x2
+#define UPROBE_RUN_HANDLER	0x2
 
 struct uprobe_consumer {
 	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);

commit 35aa621b5ab9d08767f7bc8d209b696df281d715
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Feb 22 11:37:29 2012 +0100

    uprobes: Update copyright notices
    
    Add Peter Zijlstra's copyright to the uprobes code, whose
    contributions to the uprobes code are not visible in the Git
    history, because they were backmerged.
    
    Also update existing copyright notices to the year 2012.
    
    Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-vjqxst502pc1efz7ah8cyht4@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 9c6be62787ed..f85797e1ccd4 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -17,10 +17,11 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- * Copyright (C) IBM Corporation, 2008-2011
+ * Copyright (C) IBM Corporation, 2008-2012
  * Authors:
  *	Srikar Dronamraju
  *	Jim Keniston
+ * Copyright (C) 2011-2012 Red Hat, Inc., Peter Zijlstra <pzijlstr@redhat.com>
  */
 
 #include <linux/errno.h>

commit 3ff54efdfaace9e9b2b7c1959a865be6b91de96c
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Wed Feb 22 14:46:02 2012 +0530

    uprobes/core: Move insn to arch specific structure
    
    Few cleanups suggested by Ingo Molnar.
    
    - Rename struct uprobe_arch_info to struct arch_uprobe.
    - Move insn from struct uprobe to struct arch_uprobe.
    - Make arch specific uprobe functions to accept struct arch_uprobe
      instead of  struct uprobe.
    - Move struct uprobe to kernel/uprobes.c from include/linux/uprobes.h
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Josh Stone <jistone@redhat.com>
    Link: http://lkml.kernel.org/r/20120222091602.15880.40249.sendpatchset@srdronam.in.ibm.com
    [ Made various small improvements ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index fd45b70750d4..9c6be62787ed 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -29,12 +29,6 @@
 struct vm_area_struct;
 #ifdef CONFIG_ARCH_SUPPORTS_UPROBES
 #include <asm/uprobes.h>
-#else
-
-typedef u8 uprobe_opcode_t;
-struct uprobe_arch_info {};
-
-#define MAX_UINSN_BYTES 4
 #endif
 
 /* flags that denote/change uprobes behaviour */
@@ -56,22 +50,9 @@ struct uprobe_consumer {
 	struct uprobe_consumer *next;
 };
 
-struct uprobe {
-	struct rb_node		rb_node;	/* node in the rb tree */
-	atomic_t		ref;
-	struct rw_semaphore	consumer_rwsem;
-	struct list_head	pending_list;
-	struct uprobe_arch_info arch_info;
-	struct uprobe_consumer	*consumers;
-	struct inode		*inode;		/* Also hold a ref to inode */
-	loff_t			offset;
-	int			flags;
-	u8			insn[MAX_UINSN_BYTES];
-};
-
 #ifdef CONFIG_UPROBES
-extern int __weak set_bkpt(struct mm_struct *mm, struct uprobe *uprobe, unsigned long vaddr);
-extern int __weak set_orig_insn(struct mm_struct *mm, struct uprobe *uprobe, unsigned long vaddr, bool verify);
+extern int __weak set_bkpt(struct mm_struct *mm, struct arch_uprobe *auprobe, unsigned long vaddr);
+extern int __weak set_orig_insn(struct mm_struct *mm, struct arch_uprobe *auprobe, unsigned long vaddr, bool verify);
 extern bool __weak is_bkpt_insn(uprobe_opcode_t *insn);
 extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);
 extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);

commit 96379f60075c75b261328aa7830ef8aa158247ac
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Wed Feb 22 14:45:49 2012 +0530

    uprobes/core: Remove uprobe_opcode_sz
    
    uprobe_opcode_sz refers to the smallest instruction size for
    that architecture. UPROBES_BKPT_INSN_SIZE refers to the size of
    the breakpoint instruction for that architecture.
    
    For now we are assuming that both uprobe_opcode_sz and
    UPROBES_BKPT_INSN_SIZE are the same for all archs and hence
    removing uprobe_opcode_sz in favour of UPROBES_BKPT_INSN_SIZE.
    
    However if we have to support architectures where the smallest
    instruction size is different from the size of breakpoint
    instruction, we may have to re-introduce uprobe_opcode_sz.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Jim Keniston <jkenisto@linux.vnet.ibm.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Josh Stone <jistone@redhat.com>
    Link: http://lkml.kernel.org/r/20120222091549.15880.67020.sendpatchset@srdronam.in.ibm.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index 64e45f116b2a..fd45b70750d4 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -37,8 +37,6 @@ struct uprobe_arch_info {};
 #define MAX_UINSN_BYTES 4
 #endif
 
-#define uprobe_opcode_sz sizeof(uprobe_opcode_t)
-
 /* flags that denote/change uprobes behaviour */
 
 /* Have a copy of original instruction */

commit 7b2d81d48a2d8e37efb6ce7b4d5ef58822b30d89
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Feb 17 09:27:41 2012 +0100

    uprobes/core: Clean up, refactor and improve the code
    
    Make the uprobes code readable to me:
    
     - improve the Kconfig text so that a mere mortal gets some idea
       what CONFIG_UPROBES=y is really about
    
     - do trivial renames to standardize around the uprobes_*() namespace
    
     - clean up and simplify various code flow details
    
     - separate basic blocks of functionality
    
     - line break artifact and white space related removal
    
     - use standard local varible definition blocks
    
     - use vertical spacing to make things more readable
    
     - remove unnecessary volatile
    
     - restructure comment blocks to make them more uniform and
       more readable in general
    
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Cc: Jim Keniston <jkenisto@us.ibm.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Link: http://lkml.kernel.org/n/tip-ewbwhb8o6navvllsauu7k07p@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
index f1d13fd140f2..64e45f116b2a 100644
--- a/include/linux/uprobes.h
+++ b/include/linux/uprobes.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_UPROBES_H
 #define _LINUX_UPROBES_H
 /*
- * Userspace Probes (UProbes)
+ * User-space Probes (UProbes)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -40,8 +40,10 @@ struct uprobe_arch_info {};
 #define uprobe_opcode_sz sizeof(uprobe_opcode_t)
 
 /* flags that denote/change uprobes behaviour */
+
 /* Have a copy of original instruction */
 #define UPROBES_COPY_INSN	0x1
+
 /* Dont run handlers when first register/ last unregister in progress*/
 #define UPROBES_RUN_HANDLER	0x2
 
@@ -70,27 +72,23 @@ struct uprobe {
 };
 
 #ifdef CONFIG_UPROBES
-extern int __weak set_bkpt(struct mm_struct *mm, struct uprobe *uprobe,
-							unsigned long vaddr);
-extern int __weak set_orig_insn(struct mm_struct *mm, struct uprobe *uprobe,
-					unsigned long vaddr, bool verify);
+extern int __weak set_bkpt(struct mm_struct *mm, struct uprobe *uprobe, unsigned long vaddr);
+extern int __weak set_orig_insn(struct mm_struct *mm, struct uprobe *uprobe, unsigned long vaddr, bool verify);
 extern bool __weak is_bkpt_insn(uprobe_opcode_t *insn);
-extern int register_uprobe(struct inode *inode, loff_t offset,
-				struct uprobe_consumer *consumer);
-extern void unregister_uprobe(struct inode *inode, loff_t offset,
-				struct uprobe_consumer *consumer);
-extern int mmap_uprobe(struct vm_area_struct *vma);
+extern int uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);
+extern void uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer);
+extern int uprobe_mmap(struct vm_area_struct *vma);
 #else /* CONFIG_UPROBES is not defined */
-static inline int register_uprobe(struct inode *inode, loff_t offset,
-				struct uprobe_consumer *consumer)
+static inline int
+uprobe_register(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer)
 {
 	return -ENOSYS;
 }
-static inline void unregister_uprobe(struct inode *inode, loff_t offset,
-				struct uprobe_consumer *consumer)
+static inline void
+uprobe_unregister(struct inode *inode, loff_t offset, struct uprobe_consumer *consumer)
 {
 }
-static inline int mmap_uprobe(struct vm_area_struct *vma)
+static inline int uprobe_mmap(struct vm_area_struct *vma)
 {
 	return 0;
 }

commit 2b144498350860b6ee9dc57ff27a93ad488de5dc
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Thu Feb 9 14:56:42 2012 +0530

    uprobes, mm, x86: Add the ability to install and remove uprobes breakpoints
    
    Add uprobes support to the core kernel, with x86 support.
    
    This commit adds the kernel facilities, the actual uprobes
    user-space ABI and perf probe support comes in later commits.
    
    General design:
    
    Uprobes are maintained in an rb-tree indexed by inode and offset
    (the offset here is from the start of the mapping). For a unique
    (inode, offset) tuple, there can be at most one uprobe in the
    rb-tree.
    
    Since the (inode, offset) tuple identifies a unique uprobe, more
    than one user may be interested in the same uprobe. This provides
    the ability to connect multiple 'consumers' to the same uprobe.
    
    Each consumer defines a handler and a filter (optional). The
    'handler' is run every time the uprobe is hit, if it matches the
    'filter' criteria.
    
    The first consumer of a uprobe causes the breakpoint to be
    inserted at the specified address and subsequent consumers are
    appended to this list.  On subsequent probes, the consumer gets
    appended to the existing list of consumers. The breakpoint is
    removed when the last consumer unregisters. For all other
    unregisterations, the consumer is removed from the list of
    consumers.
    
    Given a inode, we get a list of the mms that have mapped the
    inode. Do the actual registration if mm maps the page where a
    probe needs to be inserted/removed.
    
    We use a temporary list to walk through the vmas that map the
    inode.
    
    - The number of maps that map the inode, is not known before we
      walk the rmap and keeps changing.
    - extending vm_area_struct wasn't recommended, it's a
      size-critical data structure.
    - There can be more than one maps of the inode in the same mm.
    
    We add callbacks to the mmap methods to keep an eye on text vmas
    that are of interest to uprobes.  When a vma of interest is mapped,
    we insert the breakpoint at the right address.
    
    Uprobe works by replacing the instruction at the address defined
    by (inode, offset) with the arch specific breakpoint
    instruction. We save a copy of the original instruction at the
    uprobed address.
    
    This is needed for:
    
     a. executing the instruction out-of-line (xol).
     b. instruction analysis for any subsequent fixups.
     c. restoring the instruction back when the uprobe is unregistered.
    
    We insert or delete a breakpoint instruction, and this
    breakpoint instruction is assumed to be the smallest instruction
    available on the platform. For fixed size instruction platforms
    this is trivially true, for variable size instruction platforms
    the breakpoint instruction is typically the smallest (often a
    single byte).
    
    Writing the instruction is done by COWing the page and changing
    the instruction during the copy, this even though most platforms
    allow atomic writes of the breakpoint instruction. This also
    mirrors the behaviour of a ptrace() memory write to a PRIVATE
    file map.
    
    The core worker is derived from KSM's replace_page() logic.
    
    In essence, similar to KSM:
    
     a. allocate a new page and copy over contents of the page that
        has the uprobed vaddr
     b. modify the copy and insert the breakpoint at the required
        address
     c. switch the original page with the copy containing the
        breakpoint
     d. flush page tables.
    
    replace_page() is being replicated here because of some minor
    changes in the type of pages and also because Hugh Dickins had
    plans to improve replace_page() for KSM specific work.
    
    Instruction analysis on x86 is based on instruction decoder and
    determines if an instruction can be probed and determines the
    necessary fixups after singlestep.  Instruction analysis is done
    at probe insertion time so that we avoid having to repeat the
    same analysis every time a probe is hit.
    
    A lot of code here is due to the improvement/suggestions/inputs
    from Peter Zijlstra.
    
    Changelog:
    
    (v10):
     - Add code to clear REX.B prefix as suggested by Denys Vlasenko
       and Masami Hiramatsu.
    
    (v9):
     - Use insn_offset_modrm as suggested by Masami Hiramatsu.
    
    (v7):
    
     Handle comments from Peter Zijlstra:
    
     - Dont take reference to inode. (expect inode to uprobe_register to be sane).
     - Use PTR_ERR to set the return value.
     - No need to take reference to inode.
     - use PTR_ERR to return error value.
     - register and uprobe_unregister share code.
    
    (v5):
    
     - Modified del_consumer as per comments from Peter.
     - Drop reference to inode before dropping reference to uprobe.
     - Use i_size_read(inode) instead of inode->i_size.
     - Ensure uprobe->consumers is NULL, before __uprobe_unregister() is called.
     - Includes errno.h as recommended by Stephen Rothwell to fix a build issue
       on sparc defconfig
     - Remove restrictions while unregistering.
     - Earlier code leaked inode references under some conditions while
       registering/unregistering.
     - Continue the vma-rmap walk even if the intermediate vma doesnt
       meet the requirements.
     - Validate the vma found by find_vma before inserting/removing the
       breakpoint
     - Call del_consumer under mutex_lock.
     - Use hash locks.
     - Handle mremap.
     - Introduce find_least_offset_node() instead of close match logic in
       find_uprobe
     - Uprobes no more depends on MM_OWNER; No reference to task_structs
       while inserting/removing a probe.
     - Uses read_mapping_page instead of grab_cache_page so that the pages
       have valid content.
     - pass NULL to get_user_pages for the task parameter.
     - call SetPageUptodate on the new page allocated in write_opcode.
     - fix leaking a reference to the new page under certain conditions.
     - Include Instruction Decoder if Uprobes gets defined.
     - Remove const attributes for instruction prefix arrays.
     - Uses mm_context to know if the application is 32 bit.
    
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Also-written-by: Jim Keniston <jkenisto@us.ibm.com>
    Reviewed-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Roland McGrath <roland@hack.frob.com>
    Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Cc: Arnaldo Carvalho de Melo <acme@infradead.org>
    Cc: Anton Arapov <anton@redhat.com>
    Cc: Ananth N Mavinakayanahalli <ananth@in.ibm.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Denys Vlasenko <vda.linux@googlemail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linux-mm <linux-mm@kvack.org>
    Link: http://lkml.kernel.org/r/20120209092642.GE16600@linux.vnet.ibm.com
    [ Made various small edits to the commit log ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/uprobes.h b/include/linux/uprobes.h
new file mode 100644
index 000000000000..f1d13fd140f2
--- /dev/null
+++ b/include/linux/uprobes.h
@@ -0,0 +1,98 @@
+#ifndef _LINUX_UPROBES_H
+#define _LINUX_UPROBES_H
+/*
+ * Userspace Probes (UProbes)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2008-2011
+ * Authors:
+ *	Srikar Dronamraju
+ *	Jim Keniston
+ */
+
+#include <linux/errno.h>
+#include <linux/rbtree.h>
+
+struct vm_area_struct;
+#ifdef CONFIG_ARCH_SUPPORTS_UPROBES
+#include <asm/uprobes.h>
+#else
+
+typedef u8 uprobe_opcode_t;
+struct uprobe_arch_info {};
+
+#define MAX_UINSN_BYTES 4
+#endif
+
+#define uprobe_opcode_sz sizeof(uprobe_opcode_t)
+
+/* flags that denote/change uprobes behaviour */
+/* Have a copy of original instruction */
+#define UPROBES_COPY_INSN	0x1
+/* Dont run handlers when first register/ last unregister in progress*/
+#define UPROBES_RUN_HANDLER	0x2
+
+struct uprobe_consumer {
+	int (*handler)(struct uprobe_consumer *self, struct pt_regs *regs);
+	/*
+	 * filter is optional; If a filter exists, handler is run
+	 * if and only if filter returns true.
+	 */
+	bool (*filter)(struct uprobe_consumer *self, struct task_struct *task);
+
+	struct uprobe_consumer *next;
+};
+
+struct uprobe {
+	struct rb_node		rb_node;	/* node in the rb tree */
+	atomic_t		ref;
+	struct rw_semaphore	consumer_rwsem;
+	struct list_head	pending_list;
+	struct uprobe_arch_info arch_info;
+	struct uprobe_consumer	*consumers;
+	struct inode		*inode;		/* Also hold a ref to inode */
+	loff_t			offset;
+	int			flags;
+	u8			insn[MAX_UINSN_BYTES];
+};
+
+#ifdef CONFIG_UPROBES
+extern int __weak set_bkpt(struct mm_struct *mm, struct uprobe *uprobe,
+							unsigned long vaddr);
+extern int __weak set_orig_insn(struct mm_struct *mm, struct uprobe *uprobe,
+					unsigned long vaddr, bool verify);
+extern bool __weak is_bkpt_insn(uprobe_opcode_t *insn);
+extern int register_uprobe(struct inode *inode, loff_t offset,
+				struct uprobe_consumer *consumer);
+extern void unregister_uprobe(struct inode *inode, loff_t offset,
+				struct uprobe_consumer *consumer);
+extern int mmap_uprobe(struct vm_area_struct *vma);
+#else /* CONFIG_UPROBES is not defined */
+static inline int register_uprobe(struct inode *inode, loff_t offset,
+				struct uprobe_consumer *consumer)
+{
+	return -ENOSYS;
+}
+static inline void unregister_uprobe(struct inode *inode, loff_t offset,
+				struct uprobe_consumer *consumer)
+{
+}
+static inline int mmap_uprobe(struct vm_area_struct *vma)
+{
+	return 0;
+}
+#endif /* CONFIG_UPROBES */
+#endif	/* _LINUX_UPROBES_H */
