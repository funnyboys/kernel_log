commit 95fc87b44104d9a524ff3e975bbfbd7c1f1a2dd5
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Fri May 29 02:00:54 2020 +0530

    vfio: Selective dirty page tracking if IOMMU backed device pins pages
    
    Added a check such that only singleton IOMMU groups can pin pages.
    >From the point when vendor driver pins any pages, consider IOMMU group
    dirty page scope to be limited to pinned pages.
    
    To optimize to avoid walking list often, added flag
    pinned_page_dirty_scope to indicate if all of the vfio_groups for each
    vfio_domain in the domain_list dirty page scope is limited to pinned
    pages. This flag is updated on first pinned pages request for that IOMMU
    group and on attaching/detaching group.
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Reviewed-by: Neo Jia <cjia@nvidia.com>
    Reviewed-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 5d92ee15d098..38d3c6a8dc7e 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -76,7 +76,9 @@ struct vfio_iommu_driver_ops {
 					struct iommu_group *group);
 	void		(*detach_group)(void *iommu_data,
 					struct iommu_group *group);
-	int		(*pin_pages)(void *iommu_data, unsigned long *user_pfn,
+	int		(*pin_pages)(void *iommu_data,
+				     struct iommu_group *group,
+				     unsigned long *user_pfn,
 				     int npage, int prot,
 				     unsigned long *phys_pfn);
 	int		(*unpin_pages)(void *iommu_data,

commit 48219795e7dbd3d4850f5bf47fa3e37c9c2a561b
Merge: 723fe298ad85 b66574a3fb32 40280cf7e8ca
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Mar 24 09:32:41 2020 -0600

    Merge branches 'v5.7/vfio/alex-sriov-v3' and 'v5.7/vfio/yan-dma-rw-v4' into v5.7/vfio/next

commit 5f3874c2a2310d9bd6969ca6764961d27a843b9d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Mar 24 09:28:25 2020 -0600

    vfio: Include optional device match in vfio_device_ops callbacks
    
    Allow bus drivers to provide their own callback to match a device to
    the user provided string.
    
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index e42a711a2800..029694b977f2 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -26,6 +26,9 @@
  *         operations documented below
  * @mmap: Perform mmap(2) on a region of the device file descriptor
  * @request: Request for the bus driver to release the device
+ * @match: Optional device name match callback (return: 0 for no-match, >0 for
+ *         match, -errno for abort (ex. match with insufficient or incorrect
+ *         additional args)
  */
 struct vfio_device_ops {
 	char	*name;
@@ -39,6 +42,7 @@ struct vfio_device_ops {
 			 unsigned long arg);
 	int	(*mmap)(void *device_data, struct vm_area_struct *vma);
 	void	(*request)(void *device_data, unsigned int count);
+	int	(*match)(void *device_data, char *buf);
 };
 
 extern struct iommu_group *vfio_iommu_group_get(struct device *dev);

commit 40280cf7e8ca7d31bb0a9d626f36f458fec32815
Author: Yan Zhao <yan.y.zhao@intel.com>
Date:   Tue Mar 24 09:27:57 2020 -0600

    vfio: avoid inefficient operations on VFIO group in vfio_pin/unpin_pages
    
    vfio_group_pin_pages() and vfio_group_unpin_pages() are introduced to
    avoid inefficient search/check/ref/deref opertions associated with VFIO
    group as those in each calling into vfio_pin_pages() and
    vfio_unpin_pages().
    
    VFIO group is taken as arg directly. The callers combine
    search/check/ref/deref operations associated with VFIO group by calling
    vfio_group_get_external_user()/vfio_group_get_external_user_from_dev()
    beforehand, and vfio_group_put_external_user() afterwards.
    
    Suggested-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 34b2fdf4de6e..be2bd358b952 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -111,6 +111,12 @@ extern int vfio_pin_pages(struct device *dev, unsigned long *user_pfn,
 extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
 			    int npage);
 
+extern int vfio_group_pin_pages(struct vfio_group *group,
+				unsigned long *user_iova_pfn, int npage,
+				int prot, unsigned long *phys_pfn);
+extern int vfio_group_unpin_pages(struct vfio_group *group,
+				  unsigned long *user_iova_pfn, int npage);
+
 extern int vfio_dma_rw(struct vfio_group *group, dma_addr_t user_iova,
 		       void *data, size_t len, bool write);
 

commit 8d46c0cca5f4dc0538173d62cd36b1119b5105bc
Author: Yan Zhao <yan.y.zhao@intel.com>
Date:   Tue Mar 24 09:27:57 2020 -0600

    vfio: introduce vfio_dma_rw to read/write a range of IOVAs
    
    vfio_dma_rw will read/write a range of user space memory pointed to by
    IOVA into/from a kernel buffer without enforcing pinning the user space
    memory.
    
    TODO: mark the IOVAs to user space memory dirty if they are written in
    vfio_dma_rw().
    
    Cc: Kevin Tian <kevin.tian@intel.com>
    Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index fb71e0ac0e76..34b2fdf4de6e 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -82,6 +82,8 @@ struct vfio_iommu_driver_ops {
 					     struct notifier_block *nb);
 	int		(*unregister_notifier)(void *iommu_data,
 					       struct notifier_block *nb);
+	int		(*dma_rw)(void *iommu_data, dma_addr_t user_iova,
+				  void *data, size_t count, bool write);
 };
 
 extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
@@ -109,6 +111,9 @@ extern int vfio_pin_pages(struct device *dev, unsigned long *user_pfn,
 extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
 			    int npage);
 
+extern int vfio_dma_rw(struct vfio_group *group, dma_addr_t user_iova,
+		       void *data, size_t len, bool write);
+
 /* each type has independent events */
 enum vfio_notify_type {
 	VFIO_IOMMU_NOTIFY = 0,

commit c0560f51cf77472f4ed113539b0a02ca6cda7961
Author: Yan Zhao <yan.y.zhao@intel.com>
Date:   Tue Mar 24 09:27:56 2020 -0600

    vfio: allow external user to get vfio group from device
    
    external user calls vfio_group_get_external_user_from_dev() with a device
    pointer to get the VFIO group associated with this device.
    The VFIO group is checked to be vialbe and have IOMMU set. Then
    container user counter is increased and VFIO group reference is hold
    to prevent the VFIO group from disposal before external user exits.
    
    when the external user finishes using of the VFIO group, it calls
    vfio_group_put_external_user() to dereference the VFIO group and the
    container user counter.
    
    Suggested-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index e42a711a2800..fb71e0ac0e76 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -94,6 +94,8 @@ extern void vfio_unregister_iommu_driver(
  */
 extern struct vfio_group *vfio_group_get_external_user(struct file *filep);
 extern void vfio_group_put_external_user(struct vfio_group *group);
+extern struct vfio_group *vfio_group_get_external_user_from_dev(struct device
+								*dev);
 extern bool vfio_external_group_match_file(struct vfio_group *group,
 					   struct file *filep);
 extern int vfio_external_user_iommu_id(struct vfio_group *group);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 66741ab087c1..e42a711a2800 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * VFIO API definition
  *
  * Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
  *     Author: Alex Williamson <alex.williamson@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef VFIO_H
 #define VFIO_H

commit dda01f787df9f9e46f1c0bf8aa11f246e300750d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 12 12:59:39 2017 -0700

    vfio: Simplify capability helper
    
    The vfio_info_add_capability() helper requires the caller to pass a
    capability ID, which it then uses to fill in header fields, assuming
    hard coded versions.  This makes for an awkward and rigid interface.
    The only thing we want this helper to do is allocate sufficient
    space in the caps buffer and chain this capability into the list.
    Reduce it to that simple task.
    
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Acked-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
    Reviewed-by: Peter Xu <peterx@redhat.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index a47b985341d1..66741ab087c1 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -145,7 +145,8 @@ extern struct vfio_info_cap_header *vfio_info_cap_add(
 extern void vfio_info_cap_shift(struct vfio_info_cap *caps, size_t offset);
 
 extern int vfio_info_add_capability(struct vfio_info_cap *caps,
-				    int cap_type_id, void *cap_type);
+				    struct vfio_info_cap_header *cap,
+				    size_t size);
 
 extern int vfio_set_irqs_validate_and_prepare(struct vfio_irq_set *hdr,
 					      int num_irqs, int max_irq_type,

commit bb67b496c338e15813f075f482067da930f52e39
Author: Murilo Opsfelder Araujo <mopsfelder@gmail.com>
Date:   Tue Jul 18 14:22:20 2017 -0300

    include/linux/vfio.h: Guard powerpc-specific functions with CONFIG_VFIO_SPAPR_EEH
    
    When CONFIG_EEH=y and CONFIG_VFIO_SPAPR_EEH=n, build fails with the
    following:
    
        drivers/vfio/pci/vfio_pci.o: In function `.vfio_pci_release':
        vfio_pci.c:(.text+0xa98): undefined reference to `.vfio_spapr_pci_eeh_release'
        drivers/vfio/pci/vfio_pci.o: In function `.vfio_pci_open':
        vfio_pci.c:(.text+0x1420): undefined reference to `.vfio_spapr_pci_eeh_open'
    
    In this case, vfio_pci.c should use the empty definitions of
    vfio_spapr_pci_eeh_open and vfio_spapr_pci_eeh_release functions.
    
    This patch fixes it by guarding these function definitions with
    CONFIG_VFIO_SPAPR_EEH, the symbol that controls whether vfio_spapr_eeh.c is
    built, which is where the non-empty versions of these functions are. We need to
    make use of IS_ENABLED() macro because CONFIG_VFIO_SPAPR_EEH is a tristate
    option.
    
    This issue was found during a randconfig build. Logs are here:
    
        http://kisskb.ellerman.id.au/kisskb/buildresult/12982362/
    
    Signed-off-by: Murilo Opsfelder Araujo <mopsfelder@gmail.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 586809abb273..a47b985341d1 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -152,7 +152,7 @@ extern int vfio_set_irqs_validate_and_prepare(struct vfio_irq_set *hdr,
 					      size_t *data_size);
 
 struct pci_dev;
-#ifdef CONFIG_EEH
+#if IS_ENABLED(CONFIG_VFIO_SPAPR_EEH)
 extern void vfio_spapr_pci_eeh_open(struct pci_dev *pdev);
 extern void vfio_spapr_pci_eeh_release(struct pci_dev *pdev);
 extern long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
@@ -173,7 +173,7 @@ static inline long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
 {
 	return -ENOTTY;
 }
-#endif /* CONFIG_EEH */
+#endif /* CONFIG_VFIO_SPAPR_EEH */
 
 /*
  * IRQfd - generic

commit 8c6f5e7359e5bd0616b686dd5e14b99a34103b32
Merge: 3a00be19238c 7f56c30bd0a2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 13 12:23:54 2017 -0700

    Merge tag 'vfio-v4.13-rc1' of git://github.com/awilliam/linux-vfio
    
    Pull VFIO updates from Alex Williamson:
    
     - Include Intel XXV710 in INTx workaround (Alex Williamson)
    
     - Make use of ERR_CAST() for error return (Dan Carpenter)
    
     - Fix vfio_group release deadlock from iommu notifier (Alex Williamson)
    
     - Unset KVM-VFIO attributes only on group match (Alex Williamson)
    
     - Fix release path group/file matching with KVM-VFIO (Alex Williamson)
    
     - Remove unnecessary lock uses triggering lockdep splat (Alex Williamson)
    
    * tag 'vfio-v4.13-rc1' of git://github.com/awilliam/linux-vfio:
      vfio: Remove unnecessary uses of vfio_container.group_lock
      vfio: New external user group/file match
      kvm-vfio: Decouple only when we match a group
      vfio: Fix group release deadlock
      vfio: Use ERR_CAST() instead of open coding it
      vfio/pci: Add Intel XXV710 to hidden INTx devices

commit 5d6dee80a1e94cc284d03e06d930e60e8d3ecf7d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Jun 28 13:50:05 2017 -0600

    vfio: New external user group/file match
    
    At the point where the kvm-vfio pseudo device wants to release its
    vfio group reference, we can't always acquire a new reference to make
    that happen.  The group can be in a state where we wouldn't allow a
    new reference to be added.  This new helper function allows a caller
    to match a file to a group to facilitate this.  Given a file and
    group, report if they match.  Thus the caller needs to already have a
    group reference to match to the file.  This allows the deletion of a
    group without acquiring a new reference.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Reviewed-by: Eric Auger <eric.auger@redhat.com>
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Tested-by: Eric Auger <eric.auger@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index edf9b2cad277..9b34d0af5d27 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -97,6 +97,8 @@ extern void vfio_unregister_iommu_driver(
  */
 extern struct vfio_group *vfio_group_get_external_user(struct file *filep);
 extern void vfio_group_put_external_user(struct vfio_group *group);
+extern bool vfio_external_group_match_file(struct vfio_group *group,
+					   struct file *filep);
 extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);

commit ac6424b981bce1c4bc55675c6ce11bfe1bbfa64f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:06:13 2017 +0200

    sched/wait: Rename wait_queue_t => wait_queue_entry_t
    
    Rename:
    
            wait_queue_t            =>      wait_queue_entry_t
    
    'wait_queue_t' was always a slight misnomer: its name implies that it's a "queue",
    but in reality it's a queue *entry*. The 'real' queue is the wait queue head,
    which had to carry the name.
    
    Start sorting this out by renaming it to 'wait_queue_entry_t'.
    
    This also allows the real structure name 'struct __wait_queue' to
    lose its double underscore and become 'struct wait_queue_entry',
    which is the more canonical nomenclature for such data types.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index edf9b2cad277..f57076b958b7 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -183,7 +183,7 @@ struct virqfd {
 	void			(*thread)(void *, void *);
 	void			*data;
 	struct work_struct	inject;
-	wait_queue_t		wait;
+	wait_queue_entry_t		wait;
 	poll_table		pt;
 	struct work_struct	shutdown;
 	struct virqfd		**pvirqfd;

commit ccd46dbae77dbf0d33f42e04b59536f108c395e8
Author: Jike Song <jike.song@intel.com>
Date:   Thu Dec 1 13:20:06 2016 +0800

    vfio: support notifier chain in vfio_group
    
    Beyond vfio_iommu events, users might also be interested in
    vfio_group events. For example, if a vfio_group is used along
    with Qemu/KVM, whenever kvm pointer is set to/cleared from the
    vfio_group, users could be notified.
    
    Currently only VFIO_GROUP_NOTIFY_SET_KVM supported.
    
    Cc: Kirti Wankhede <kwankhede@nvidia.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    [aw: remove use of new typedef]
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 0e5201f207d3..edf9b2cad277 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -111,11 +111,15 @@ extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
 /* each type has independent events */
 enum vfio_notify_type {
 	VFIO_IOMMU_NOTIFY = 0,
+	VFIO_GROUP_NOTIFY = 1,
 };
 
 /* events for VFIO_IOMMU_NOTIFY */
 #define VFIO_IOMMU_NOTIFY_DMA_UNMAP	BIT(0)
 
+/* events for VFIO_GROUP_NOTIFY */
+#define VFIO_GROUP_NOTIFY_SET_KVM	BIT(0)
+
 extern int vfio_register_notifier(struct device *dev,
 				  enum vfio_notify_type type,
 				  unsigned long *required_events,
@@ -124,6 +128,9 @@ extern int vfio_unregister_notifier(struct device *dev,
 				    enum vfio_notify_type type,
 				    struct notifier_block *nb);
 
+struct kvm;
+extern void vfio_group_set_kvm(struct vfio_group *group, struct kvm *kvm);
+
 /*
  * Sub-module helpers
  */

commit 22195cbd3451a75abaf30651a61cf85c89061327
Author: Jike Song <jike.song@intel.com>
Date:   Thu Dec 1 13:20:05 2016 +0800

    vfio: vfio_register_notifier: classify iommu notifier
    
    Currently vfio_register_notifier assumes that there is only one
    notifier chain, which is in vfio_iommu. However, the user might
    also be interested in events other than vfio_iommu, for example,
    vfio_group. Refactor vfio_{un}register_notifier implementation
    to make it feasible.
    
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
    Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Jike Song <jike.song@intel.com>
    [aw: merge with commit 816ca69ea9c7 ("vfio: Fix handling of error returned by 'vfio_group_get_from_dev()'"), remove typedef]
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 15ff0421b423..0e5201f207d3 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -81,6 +81,7 @@ struct vfio_iommu_driver_ops {
 	int		(*unpin_pages)(void *iommu_data,
 				       unsigned long *user_pfn, int npage);
 	int		(*register_notifier)(void *iommu_data,
+					     unsigned long *events,
 					     struct notifier_block *nb);
 	int		(*unregister_notifier)(void *iommu_data,
 					       struct notifier_block *nb);
@@ -107,12 +108,20 @@ extern int vfio_pin_pages(struct device *dev, unsigned long *user_pfn,
 extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
 			    int npage);
 
-#define VFIO_IOMMU_NOTIFY_DMA_UNMAP	(1)
+/* each type has independent events */
+enum vfio_notify_type {
+	VFIO_IOMMU_NOTIFY = 0,
+};
+
+/* events for VFIO_IOMMU_NOTIFY */
+#define VFIO_IOMMU_NOTIFY_DMA_UNMAP	BIT(0)
 
 extern int vfio_register_notifier(struct device *dev,
+				  enum vfio_notify_type type,
+				  unsigned long *required_events,
 				  struct notifier_block *nb);
-
 extern int vfio_unregister_notifier(struct device *dev,
+				    enum vfio_notify_type type,
 				    struct notifier_block *nb);
 
 /*

commit c747f08aea847c8c0704acf9375ca83c4800f6c1
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Thu Nov 17 02:16:27 2016 +0530

    vfio: Introduce vfio_set_irqs_validate_and_prepare()
    
    Vendor driver using mediated device framework would use same mechnism to
    validate and prepare IRQs. Introducing this function to reduce code
    replication in multiple drivers.
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Neo Jia <cjia@nvidia.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index e26f7ccab564..15ff0421b423 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -129,6 +129,10 @@ extern void vfio_info_cap_shift(struct vfio_info_cap *caps, size_t offset);
 extern int vfio_info_add_capability(struct vfio_info_cap *caps,
 				    int cap_type_id, void *cap_type);
 
+extern int vfio_set_irqs_validate_and_prepare(struct vfio_irq_set *hdr,
+					      int num_irqs, int max_irq_type,
+					      size_t *data_size);
+
 struct pci_dev;
 #ifdef CONFIG_EEH
 extern void vfio_spapr_pci_eeh_open(struct pci_dev *pdev);

commit b3c0a866f1692da2d1059dadd9c429ff5b364fc9
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Thu Nov 17 02:16:25 2016 +0530

    vfio: Introduce common function to add capabilities
    
    Vendor driver using mediated device framework should use
    vfio_info_add_capability() to add capabilities.
    Introduced this function to reduce code duplication in vendor drivers.
    
    vfio_info_cap_shift() manipulated a data buffer to add an offset to each
    element in a chain. This data buffer is documented in a uapi header.
    Changing vfio_info_cap_shift symbol to be available to all drivers.
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Neo Jia <cjia@nvidia.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 6ab13f7e2920..e26f7ccab564 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -126,6 +126,9 @@ extern struct vfio_info_cap_header *vfio_info_cap_add(
 		struct vfio_info_cap *caps, size_t size, u16 id, u16 version);
 extern void vfio_info_cap_shift(struct vfio_info_cap *caps, size_t offset);
 
+extern int vfio_info_add_capability(struct vfio_info_cap *caps,
+				    int cap_type_id, void *cap_type);
+
 struct pci_dev;
 #ifdef CONFIG_EEH
 extern void vfio_spapr_pci_eeh_open(struct pci_dev *pdev);

commit c086de818dd81c3c2f7cecff23de6585b74340c0
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Thu Nov 17 10:28:26 2016 +0530

    vfio iommu: Add blocking notifier to notify DMA_UNMAP
    
    Added blocking notifier to IOMMU TYPE1 driver to notify vendor drivers
    about DMA_UNMAP.
    Exported two APIs vfio_register_notifier() and vfio_unregister_notifier().
    Notifier should be registered, if external user wants to use
    vfio_pin_pages()/vfio_unpin_pages() APIs to pin/unpin pages.
    Vendor driver should use VFIO_IOMMU_NOTIFY_DMA_UNMAP action to invalidate
    mappings.
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Neo Jia <cjia@nvidia.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 3c862a030029..6ab13f7e2920 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -80,6 +80,10 @@ struct vfio_iommu_driver_ops {
 				     unsigned long *phys_pfn);
 	int		(*unpin_pages)(void *iommu_data,
 				       unsigned long *user_pfn, int npage);
+	int		(*register_notifier)(void *iommu_data,
+					     struct notifier_block *nb);
+	int		(*unregister_notifier)(void *iommu_data,
+					       struct notifier_block *nb);
 };
 
 extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
@@ -103,6 +107,14 @@ extern int vfio_pin_pages(struct device *dev, unsigned long *user_pfn,
 extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
 			    int npage);
 
+#define VFIO_IOMMU_NOTIFY_DMA_UNMAP	(1)
+
+extern int vfio_register_notifier(struct device *dev,
+				  struct notifier_block *nb);
+
+extern int vfio_unregister_notifier(struct device *dev,
+				    struct notifier_block *nb);
+
 /*
  * Sub-module helpers
  */

commit 2169037dc322d8baa84d9bd4468995f818f25d82
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Thu Nov 17 02:16:17 2016 +0530

    vfio iommu: Added pin and unpin callback functions to vfio_iommu_driver_ops
    
    Added APIs for pining and unpining set of pages. These call back into
    backend iommu module to actually pin and unpin pages.
    Added two new callback functions to struct vfio_iommu_driver_ops. Backend
    IOMMU module that supports pining and unpinning pages for mdev devices
    should provide these functions.
    
    Renamed static functions in vfio_type1_iommu.c to resolve conflicts
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Neo Jia <cjia@nvidia.com>
    Reviewed-by: Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 0ecae0b1cd34..3c862a030029 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -75,7 +75,11 @@ struct vfio_iommu_driver_ops {
 					struct iommu_group *group);
 	void		(*detach_group)(void *iommu_data,
 					struct iommu_group *group);
-
+	int		(*pin_pages)(void *iommu_data, unsigned long *user_pfn,
+				     int npage, int prot,
+				     unsigned long *phys_pfn);
+	int		(*unpin_pages)(void *iommu_data,
+				       unsigned long *user_pfn, int npage);
 };
 
 extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
@@ -92,6 +96,13 @@ extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);
 
+#define VFIO_PIN_PAGES_MAX_ENTRIES	(PAGE_SIZE/sizeof(unsigned long))
+
+extern int vfio_pin_pages(struct device *dev, unsigned long *user_pfn,
+			  int npage, int prot, unsigned long *phys_pfn);
+extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
+			    int npage);
+
 /*
  * Sub-module helpers
  */

commit d7a8d5ed876970ac7f9bafbb6708500a7838c1d7
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Feb 22 16:02:33 2016 -0700

    vfio: Add capability chain helpers
    
    Allow sub-modules to easily reallocate a buffer for managing
    capability chains for info ioctls.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 610a86a892b8..0ecae0b1cd34 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -92,6 +92,17 @@ extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);
 
+/*
+ * Sub-module helpers
+ */
+struct vfio_info_cap {
+	struct vfio_info_cap_header *buf;
+	size_t size;
+};
+extern struct vfio_info_cap_header *vfio_info_cap_add(
+		struct vfio_info_cap *caps, size_t size, u16 id, u16 version);
+extern void vfio_info_cap_shift(struct vfio_info_cap *caps, size_t offset);
+
 struct pci_dev;
 #ifdef CONFIG_EEH
 extern void vfio_spapr_pci_eeh_open(struct pci_dev *pdev);

commit 03a76b60f8ba27974e2d252bc555d2c103420e15
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Dec 21 15:13:33 2015 -0700

    vfio: Include No-IOMMU mode
    
    There is really no way to safely give a user full access to a DMA
    capable device without an IOMMU to protect the host system.  There is
    also no way to provide DMA translation, for use cases such as device
    assignment to virtual machines.  However, there are still those users
    that want userspace drivers even under those conditions.  The UIO
    driver exists for this use case, but does not provide the degree of
    device access and programming that VFIO has.  In an effort to avoid
    code duplication, this introduces a No-IOMMU mode for VFIO.
    
    This mode requires building VFIO with CONFIG_VFIO_NOIOMMU and enabling
    the "enable_unsafe_noiommu_mode" option on the vfio driver.  This
    should make it very clear that this mode is not safe.  Additionally,
    CAP_SYS_RAWIO privileges are necessary to work with groups and
    containers using this mode.  Groups making use of this support are
    named /dev/vfio/noiommu-$GROUP and can only make use of the special
    VFIO_NOIOMMU_IOMMU for the container.  Use of this mode, specifically
    binding a device without a native IOMMU group to a VFIO bus driver
    will taint the kernel and should therefore not be considered
    supported.  This patch includes no-iommu support for the vfio-pci bus
    driver only.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index ddb440975382..610a86a892b8 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -44,6 +44,9 @@ struct vfio_device_ops {
 	void	(*request)(void *device_data, unsigned int count);
 };
 
+extern struct iommu_group *vfio_iommu_group_get(struct device *dev);
+extern void vfio_iommu_group_put(struct iommu_group *group, struct device *dev);
+
 extern int vfio_add_group_dev(struct device *dev,
 			      const struct vfio_device_ops *ops,
 			      void *device_data);

commit ae5515d66362b9d96cdcfce504567f0b8b7bd83e
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Dec 4 08:38:42 2015 -0700

    Revert: "vfio: Include No-IOMMU mode"
    
    Revert commit 033291eccbdb ("vfio: Include No-IOMMU mode") due to lack
    of a user.  This was originally intended to fill a need for the DPDK
    driver, but uptake has been slow so rather than support an unproven
    kernel interface revert it and revisit when userspace catches up.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 610a86a892b8..ddb440975382 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -44,9 +44,6 @@ struct vfio_device_ops {
 	void	(*request)(void *device_data, unsigned int count);
 };
 
-extern struct iommu_group *vfio_iommu_group_get(struct device *dev);
-extern void vfio_iommu_group_put(struct iommu_group *group, struct device *dev);
-
 extern int vfio_add_group_dev(struct device *dev,
 			      const struct vfio_device_ops *ops,
 			      void *device_data);

commit 033291eccbdb1b70ffc02641edae19ac825dc75d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Oct 15 15:08:48 2015 -0600

    vfio: Include No-IOMMU mode
    
    There is really no way to safely give a user full access to a DMA
    capable device without an IOMMU to protect the host system.  There is
    also no way to provide DMA translation, for use cases such as device
    assignment to virtual machines.  However, there are still those users
    that want userspace drivers even under those conditions.  The UIO
    driver exists for this use case, but does not provide the degree of
    device access and programming that VFIO has.  In an effort to avoid
    code duplication, this introduces a No-IOMMU mode for VFIO.
    
    This mode requires building VFIO with CONFIG_VFIO_NOIOMMU and enabling
    the "enable_unsafe_noiommu_mode" option on the vfio driver.  This
    should make it very clear that this mode is not safe.  Additionally,
    CAP_SYS_RAWIO privileges are necessary to work with groups and
    containers using this mode.  Groups making use of this support are
    named /dev/vfio/noiommu-$GROUP and can only make use of the special
    VFIO_NOIOMMU_IOMMU for the container.  Use of this mode, specifically
    binding a device without a native IOMMU group to a VFIO bus driver
    will taint the kernel and should therefore not be considered
    supported.  This patch includes no-iommu support for the vfio-pci bus
    driver only.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index ddb440975382..610a86a892b8 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -44,6 +44,9 @@ struct vfio_device_ops {
 	void	(*request)(void *device_data, unsigned int count);
 };
 
+extern struct iommu_group *vfio_iommu_group_get(struct device *dev);
+extern void vfio_iommu_group_put(struct iommu_group *group, struct device *dev);
+
 extern int vfio_add_group_dev(struct device *dev,
 			      const struct vfio_device_ops *ops,
 			      void *device_data);

commit 8c194f3bd322a8bd44d079092d870549b8ae62d1
Merge: 07e492eb8921 5a0ff17741c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 18:06:47 2015 -0700

    Merge tag 'vfio-v4.1-rc1' of git://github.com/awilliam/linux-vfio
    
    Pull VFIO updates from Alex Williamson:
    
     - VFIO platform bus driver support (Baptiste Reynal, Antonios Motakis,
       testing and review by Eric Auger)
    
     - Split VFIO irqfd support to separate module (Alex Williamson)
    
     - vfio-pci VGA arbiter client (Alex Williamson)
    
     - New vfio-pci.ids= module option (Alex Williamson)
    
     - vfio-pci D3 power state support for idle devices (Alex Williamson)
    
    * tag 'vfio-v4.1-rc1' of git://github.com/awilliam/linux-vfio: (30 commits)
      vfio-pci: Fix use after free
      vfio-pci: Move idle devices to D3hot power state
      vfio-pci: Remove warning if try-reset fails
      vfio-pci: Allow PCI IDs to be specified as module options
      vfio-pci: Add VGA arbiter client
      vfio-pci: Add module option to disable VGA region access
      vgaarb: Stub vga_set_legacy_decoding()
      vfio: Split virqfd into a separate module for vfio bus drivers
      vfio: virqfd_lock can be static
      vfio: put off the allocation of "minor" in vfio_create_group
      vfio/platform: implement IRQ masking/unmasking via an eventfd
      vfio: initialize the virqfd workqueue in VFIO generic code
      vfio: move eventfd support code for VFIO_PCI to a separate file
      vfio: pass an opaque pointer on virqfd initialization
      vfio: add local lock for virqfd instead of depending on VFIO PCI
      vfio: virqfd: rename vfio_pci_virqfd_init and vfio_pci_virqfd_exit
      vfio: add a vfio_ prefix to virqfd_enable and virqfd_disable and export
      vfio/platform: support for level sensitive interrupts
      vfio/platform: trigger an interrupt via eventfd
      vfio/platform: initial interrupts support code
      ...

commit 71be3423a62be548c56bab5b818e1a1383e659d2
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Mar 17 08:33:38 2015 -0600

    vfio: Split virqfd into a separate module for vfio bus drivers
    
    An unintended consequence of commit 42ac9bd18d4f ("vfio: initialize
    the virqfd workqueue in VFIO generic code") is that the vfio module
    is renamed to vfio_core so that it can include both vfio and virqfd.
    That's a user visible change that may break module loading scritps
    and it imposes eventfd support as a dependency on the core vfio code,
    which it's really not.  virqfd is intended to be provided as a service
    to vfio bus drivers, so instead of wrapping it into vfio.ko, we can
    make it a stand-alone module toggled by vfio bus drivers.  This has
    the additional benefit of removing initialization and exit from the
    core vfio code.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 683b5146022e..cbed15f194e0 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -142,8 +142,6 @@ struct virqfd {
 	struct virqfd		**pvirqfd;
 };
 
-extern int vfio_virqfd_init(void);
-extern void vfio_virqfd_exit(void);
 extern int vfio_virqfd_enable(void *opaque,
 			      int (*handler)(void *, void *),
 			      void (*thread)(void *, void *),

commit 3876488444e71238e287459c39d7692b6f718c3e
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Mon Mar 9 15:52:17 2015 +0100

    include/stddef.h: Move offsetofend() from vfio.h to a generic kernel header
    
    Suggested by Andy.
    
    Suggested-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alexei Starovoitov <ast@plumgrid.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Will Drewry <wad@chromium.org>
    Link: http://lkml.kernel.org/r/1425912738-559-1-git-send-email-dvlasenk@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 2d67b8998fd8..049b2f497bc7 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -78,19 +78,6 @@ extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
 extern void vfio_unregister_iommu_driver(
 				const struct vfio_iommu_driver_ops *ops);
 
-/**
- * offsetofend(TYPE, MEMBER)
- *
- * @TYPE: The type of the structure
- * @MEMBER: The member within the structure to get the end offset of
- *
- * Simple helper macro for dealing with variable sized structures passed
- * from user space.  This allows us to easily determine if the provided
- * structure is sized to include various fields.
- */
-#define offsetofend(TYPE, MEMBER) \
-	(offsetof(TYPE, MEMBER)	+ sizeof(((TYPE *)0)->MEMBER))
-
 /*
  * External user API
  */

commit 7e992d692750b2938224eb43fee907181d92a602
Author: Antonios Motakis <a.motakis@virtualopensystems.com>
Date:   Mon Mar 16 14:08:54 2015 -0600

    vfio: move eventfd support code for VFIO_PCI to a separate file
    
    The virqfd functionality that is used by VFIO_PCI to implement interrupt
    masking and unmasking via an eventfd, is generic enough and can be reused
    by another driver. Move it to a separate file in order to allow the code
    to be shared.
    
    Signed-off-by: Antonios Motakis <a.motakis@virtualopensystems.com>
    Signed-off-by: Baptiste Reynal <b.reynal@virtualopensystems.com>
    Reviewed-by: Eric Auger <eric.auger@linaro.org>
    Tested-by: Eric Auger <eric.auger@linaro.org>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 2d67b8998fd8..683b5146022e 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -14,6 +14,8 @@
 
 #include <linux/iommu.h>
 #include <linux/mm.h>
+#include <linux/workqueue.h>
+#include <linux/poll.h>
 #include <uapi/linux/vfio.h>
 
 /**
@@ -123,4 +125,29 @@ static inline long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
 	return -ENOTTY;
 }
 #endif /* CONFIG_EEH */
+
+/*
+ * IRQfd - generic
+ */
+struct virqfd {
+	void			*opaque;
+	struct eventfd_ctx	*eventfd;
+	int			(*handler)(void *, void *);
+	void			(*thread)(void *, void *);
+	void			*data;
+	struct work_struct	inject;
+	wait_queue_t		wait;
+	poll_table		pt;
+	struct work_struct	shutdown;
+	struct virqfd		**pvirqfd;
+};
+
+extern int vfio_virqfd_init(void);
+extern void vfio_virqfd_exit(void);
+extern int vfio_virqfd_enable(void *opaque,
+			      int (*handler)(void *, void *),
+			      void (*thread)(void *, void *),
+			      void *data, struct virqfd **pvirqfd, int fd);
+extern void vfio_virqfd_disable(struct virqfd **pvirqfd);
+
 #endif /* VFIO_H */

commit 13060b64b819c194909121b90b5f8dd9abb5ea4e
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Feb 6 15:05:07 2015 -0700

    vfio: Add and use device request op for vfio bus drivers
    
    When a request is made to unbind a device from a vfio bus driver,
    we need to wait for the device to become unused, ie. for userspace
    to release the device.  However, we have a long standing TODO in
    the code to do something proactive to make that happen.  To enable
    this, we add a request callback on the vfio bus driver struct,
    which is intended to signal the user through the vfio device
    interface to release the device.  Instead of passively waiting for
    the device to become unused, we can now pester the user to give
    it up.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index d3204115f15d..2d67b8998fd8 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -26,6 +26,7 @@
  * @ioctl: Perform ioctl(2) on device file descriptor, supporting VFIO_DEVICE_*
  *         operations documented below
  * @mmap: Perform mmap(2) on a region of the device file descriptor
+ * @request: Request for the bus driver to release the device
  */
 struct vfio_device_ops {
 	char	*name;
@@ -38,6 +39,7 @@ struct vfio_device_ops {
 	long	(*ioctl)(void *device_data, unsigned int cmd,
 			 unsigned long arg);
 	int	(*mmap)(void *device_data, struct vm_area_struct *vma);
+	void	(*request)(void *device_data, unsigned int count);
 };
 
 extern int vfio_add_group_dev(struct device *dev,

commit 9b936c960f22954bfb89f2fefd8f96916bb42908
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Fri Aug 8 10:39:16 2014 -0600

    drivers/vfio: Enable VFIO if EEH is not supported
    
    The existing vfio_pci_open() fails upon error returned from
    vfio_spapr_pci_eeh_open(), which breaks POWER7's P5IOC2 PHB
    support which this patch brings back.
    
    The patch fixes the issue by dropping the return value of
    vfio_spapr_pci_eeh_open().
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 224128a96b7f..d3204115f15d 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -100,15 +100,14 @@ extern long vfio_external_check_extension(struct vfio_group *group,
 
 struct pci_dev;
 #ifdef CONFIG_EEH
-extern int vfio_spapr_pci_eeh_open(struct pci_dev *pdev);
+extern void vfio_spapr_pci_eeh_open(struct pci_dev *pdev);
 extern void vfio_spapr_pci_eeh_release(struct pci_dev *pdev);
 extern long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
 				       unsigned int cmd,
 				       unsigned long arg);
 #else
-static inline int vfio_spapr_pci_eeh_open(struct pci_dev *pdev)
+static inline void vfio_spapr_pci_eeh_open(struct pci_dev *pdev)
 {
-	return 0;
 }
 
 static inline void vfio_spapr_pci_eeh_release(struct pci_dev *pdev)

commit 92d18a6851fb6295466657ad1cf7fe88c2054ffa
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Fri Aug 8 10:36:20 2014 -0600

    drivers/vfio: Fix EEH build error
    
    The VFIO related components could be built as dynamic modules.
    Unfortunately, CONFIG_EEH can't be configured to "m". The patch
    fixes the build errors when configuring VFIO related components
    as dynamic modules as follows:
    
      CC [M]  drivers/vfio/vfio_iommu_spapr_tce.o
    In file included from drivers/vfio/vfio.c:33:0:
    include/linux/vfio.h:101:43: warning: ‘struct pci_dev’ declared \
    inside parameter list [enabled by default]
       :
      WRAP    arch/powerpc/boot/zImage.pseries
      WRAP    arch/powerpc/boot/zImage.maple
      WRAP    arch/powerpc/boot/zImage.pmac
      WRAP    arch/powerpc/boot/zImage.epapr
      MODPOST 1818 modules
    ERROR: ".vfio_spapr_iommu_eeh_ioctl" [drivers/vfio/vfio_iommu_spapr_tce.ko]\
    undefined!
    ERROR: ".vfio_spapr_pci_eeh_open" [drivers/vfio/pci/vfio-pci.ko] undefined!
    ERROR: ".vfio_spapr_pci_eeh_release" [drivers/vfio/pci/vfio-pci.ko] undefined!
    
    Reported-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 25a0fbd4b998..224128a96b7f 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -98,6 +98,7 @@ extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);
 
+struct pci_dev;
 #ifdef CONFIG_EEH
 extern int vfio_spapr_pci_eeh_open(struct pci_dev *pdev);
 extern void vfio_spapr_pci_eeh_release(struct pci_dev *pdev);

commit 1b69be5e8afc634f39ad695a6ab6aad0cf0975c7
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue Jun 10 11:41:57 2014 +1000

    drivers/vfio: EEH support for VFIO PCI device
    
    The patch adds new IOCTL commands for sPAPR VFIO container device
    to support EEH functionality for PCI devices, which have been passed
    through from host to somebody else via VFIO.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Alexander Graf <agraf@suse.de>
    Acked-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 8ec980b5e3af..25a0fbd4b998 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -98,4 +98,27 @@ extern int vfio_external_user_iommu_id(struct vfio_group *group);
 extern long vfio_external_check_extension(struct vfio_group *group,
 					  unsigned long arg);
 
+#ifdef CONFIG_EEH
+extern int vfio_spapr_pci_eeh_open(struct pci_dev *pdev);
+extern void vfio_spapr_pci_eeh_release(struct pci_dev *pdev);
+extern long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
+				       unsigned int cmd,
+				       unsigned long arg);
+#else
+static inline int vfio_spapr_pci_eeh_open(struct pci_dev *pdev)
+{
+	return 0;
+}
+
+static inline void vfio_spapr_pci_eeh_release(struct pci_dev *pdev)
+{
+}
+
+static inline long vfio_spapr_iommu_eeh_ioctl(struct iommu_group *group,
+					      unsigned int cmd,
+					      unsigned long arg)
+{
+	return -ENOTTY;
+}
+#endif /* CONFIG_EEH */
 #endif /* VFIO_H */

commit b13460b92093b29347e99d6c3242e350052b62cd
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Fri May 30 11:35:54 2014 -0600

    drivers/vfio: Rework offsetofend()
    
    The macro offsetofend() introduces unnecessary temporary variable
    "tmp". The patch avoids that and saves a bit memory in stack.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 81022a52bc34..8ec980b5e3af 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -86,9 +86,8 @@ extern void vfio_unregister_iommu_driver(
  * from user space.  This allows us to easily determine if the provided
  * structure is sized to include various fields.
  */
-#define offsetofend(TYPE, MEMBER) ({				\
-	TYPE tmp;						\
-	offsetof(TYPE, MEMBER) + sizeof(tmp.MEMBER); })		\
+#define offsetofend(TYPE, MEMBER) \
+	(offsetof(TYPE, MEMBER)	+ sizeof(((TYPE *)0)->MEMBER))
 
 /*
  * External user API

commit 88d7ab8949427f492c39f6daf0ac67f0242a88bc
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Feb 26 11:38:39 2014 -0700

    vfio: Add external user check extension interface
    
    This lets us check extensions, particularly VFIO_DMA_CC_IOMMU using
    the external user interface, allowing KVM to probe IOMMU coherency.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 24579a0312a0..81022a52bc34 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -96,5 +96,7 @@ extern void vfio_unregister_iommu_driver(
 extern struct vfio_group *vfio_group_get_external_user(struct file *filep);
 extern void vfio_group_put_external_user(struct vfio_group *group);
 extern int vfio_external_user_iommu_id(struct vfio_group *group);
+extern long vfio_external_check_extension(struct vfio_group *group,
+					  unsigned long arg);
 
 #endif /* VFIO_H */

commit 6cdd97821322352b94bb92f271b4466ad38a2468
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Mon Aug 5 10:52:36 2013 -0600

    vfio: add external user support
    
    VFIO is designed to be used via ioctls on file descriptors
    returned by VFIO.
    
    However in some situations support for an external user is required.
    The first user is KVM on PPC64 (SPAPR TCE protocol) which is going to
    use the existing VFIO groups for exclusive access in real/virtual mode
    on a host to avoid passing map/unmap requests to the user space which
    would made things pretty slow.
    
    The protocol includes:
    
    1. do normal VFIO init operation:
            - opening a new container;
            - attaching group(s) to it;
            - setting an IOMMU driver for a container.
    When IOMMU is set for a container, all groups in it are
    considered ready to use by an external user.
    
    2. User space passes a group fd to an external user.
    The external user calls vfio_group_get_external_user()
    to verify that:
            - the group is initialized;
            - IOMMU is set for it.
    If both checks passed, vfio_group_get_external_user()
    increments the container user counter to prevent
    the VFIO group from disposal before KVM exits.
    
    3. The external user calls vfio_external_user_iommu_id()
    to know an IOMMU ID. PPC64 KVM uses it to link logical bus
    number (LIOBN) with IOMMU ID.
    
    4. When the external KVM finishes, it calls
    vfio_group_put_external_user() to release the VFIO group.
    This call decrements the container user counter.
    Everything gets released.
    
    The "vfio: Limit group opens" patch is also required for the consistency.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index ac8d488e4372..24579a0312a0 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -90,4 +90,11 @@ extern void vfio_unregister_iommu_driver(
 	TYPE tmp;						\
 	offsetof(TYPE, MEMBER) + sizeof(tmp.MEMBER); })		\
 
+/*
+ * External user API
+ */
+extern struct vfio_group *vfio_group_get_external_user(struct file *filep);
+extern void vfio_group_put_external_user(struct vfio_group *group);
+extern int vfio_external_user_iommu_id(struct vfio_group *group);
+
 #endif /* VFIO_H */

commit 44f507163d9e51238458ee6904b4d71fb0723723
Author: Vijay Mohan Pandarathil <vijaymohan.pandarathil@hp.com>
Date:   Mon Mar 11 09:28:44 2013 -0600

    VFIO: Wrapper for getting reference to vfio_device
    
    - Added vfio_device_get_from_dev() as wrapper to get
      reference to vfio_device from struct device.
    
    - Added vfio_device_data() as a wrapper to get device_data from
      vfio_device.
    
    Signed-off-by: Vijay Mohan Pandarathil <vijaymohan.pandarathil@hp.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index ab9e86224c54..ac8d488e4372 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -45,6 +45,9 @@ extern int vfio_add_group_dev(struct device *dev,
 			      void *device_data);
 
 extern void *vfio_del_group_dev(struct device *dev);
+extern struct vfio_device *vfio_device_get_from_dev(struct device *dev);
+extern void vfio_device_put(struct vfio_device *device);
+extern void *vfio_device_data(struct vfio_device *device);
 
 /**
  * struct vfio_iommu_driver_ops - VFIO IOMMU driver callbacks

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 0a4f180a11d8..ab9e86224c54 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -11,15 +11,10 @@
 #ifndef VFIO_H
 #define VFIO_H
 
-#include <linux/types.h>
-#include <linux/ioctl.h>
-
-#define VFIO_API_VERSION	0
-
-#ifdef __KERNEL__	/* Internal VFIO-core/bus driver API */
 
 #include <linux/iommu.h>
 #include <linux/mm.h>
+#include <uapi/linux/vfio.h>
 
 /**
  * struct vfio_device_ops - VFIO bus driver device callbacks
@@ -92,354 +87,4 @@ extern void vfio_unregister_iommu_driver(
 	TYPE tmp;						\
 	offsetof(TYPE, MEMBER) + sizeof(tmp.MEMBER); })		\
 
-#endif /* __KERNEL__ */
-
-/* Kernel & User level defines for VFIO IOCTLs. */
-
-/* Extensions */
-
-#define VFIO_TYPE1_IOMMU		1
-
-/*
- * The IOCTL interface is designed for extensibility by embedding the
- * structure length (argsz) and flags into structures passed between
- * kernel and userspace.  We therefore use the _IO() macro for these
- * defines to avoid implicitly embedding a size into the ioctl request.
- * As structure fields are added, argsz will increase to match and flag
- * bits will be defined to indicate additional fields with valid data.
- * It's *always* the caller's responsibility to indicate the size of
- * the structure passed by setting argsz appropriately.
- */
-
-#define VFIO_TYPE	(';')
-#define VFIO_BASE	100
-
-/* -------- IOCTLs for VFIO file descriptor (/dev/vfio/vfio) -------- */
-
-/**
- * VFIO_GET_API_VERSION - _IO(VFIO_TYPE, VFIO_BASE + 0)
- *
- * Report the version of the VFIO API.  This allows us to bump the entire
- * API version should we later need to add or change features in incompatible
- * ways.
- * Return: VFIO_API_VERSION
- * Availability: Always
- */
-#define VFIO_GET_API_VERSION		_IO(VFIO_TYPE, VFIO_BASE + 0)
-
-/**
- * VFIO_CHECK_EXTENSION - _IOW(VFIO_TYPE, VFIO_BASE + 1, __u32)
- *
- * Check whether an extension is supported.
- * Return: 0 if not supported, 1 (or some other positive integer) if supported.
- * Availability: Always
- */
-#define VFIO_CHECK_EXTENSION		_IO(VFIO_TYPE, VFIO_BASE + 1)
-
-/**
- * VFIO_SET_IOMMU - _IOW(VFIO_TYPE, VFIO_BASE + 2, __s32)
- *
- * Set the iommu to the given type.  The type must be supported by an
- * iommu driver as verified by calling CHECK_EXTENSION using the same
- * type.  A group must be set to this file descriptor before this
- * ioctl is available.  The IOMMU interfaces enabled by this call are
- * specific to the value set.
- * Return: 0 on success, -errno on failure
- * Availability: When VFIO group attached
- */
-#define VFIO_SET_IOMMU			_IO(VFIO_TYPE, VFIO_BASE + 2)
-
-/* -------- IOCTLs for GROUP file descriptors (/dev/vfio/$GROUP) -------- */
-
-/**
- * VFIO_GROUP_GET_STATUS - _IOR(VFIO_TYPE, VFIO_BASE + 3,
- *						struct vfio_group_status)
- *
- * Retrieve information about the group.  Fills in provided
- * struct vfio_group_info.  Caller sets argsz.
- * Return: 0 on succes, -errno on failure.
- * Availability: Always
- */
-struct vfio_group_status {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_GROUP_FLAGS_VIABLE		(1 << 0)
-#define VFIO_GROUP_FLAGS_CONTAINER_SET	(1 << 1)
-};
-#define VFIO_GROUP_GET_STATUS		_IO(VFIO_TYPE, VFIO_BASE + 3)
-
-/**
- * VFIO_GROUP_SET_CONTAINER - _IOW(VFIO_TYPE, VFIO_BASE + 4, __s32)
- *
- * Set the container for the VFIO group to the open VFIO file
- * descriptor provided.  Groups may only belong to a single
- * container.  Containers may, at their discretion, support multiple
- * groups.  Only when a container is set are all of the interfaces
- * of the VFIO file descriptor and the VFIO group file descriptor
- * available to the user.
- * Return: 0 on success, -errno on failure.
- * Availability: Always
- */
-#define VFIO_GROUP_SET_CONTAINER	_IO(VFIO_TYPE, VFIO_BASE + 4)
-
-/**
- * VFIO_GROUP_UNSET_CONTAINER - _IO(VFIO_TYPE, VFIO_BASE + 5)
- *
- * Remove the group from the attached container.  This is the
- * opposite of the SET_CONTAINER call and returns the group to
- * an initial state.  All device file descriptors must be released
- * prior to calling this interface.  When removing the last group
- * from a container, the IOMMU will be disabled and all state lost,
- * effectively also returning the VFIO file descriptor to an initial
- * state.
- * Return: 0 on success, -errno on failure.
- * Availability: When attached to container
- */
-#define VFIO_GROUP_UNSET_CONTAINER	_IO(VFIO_TYPE, VFIO_BASE + 5)
-
-/**
- * VFIO_GROUP_GET_DEVICE_FD - _IOW(VFIO_TYPE, VFIO_BASE + 6, char)
- *
- * Return a new file descriptor for the device object described by
- * the provided string.  The string should match a device listed in
- * the devices subdirectory of the IOMMU group sysfs entry.  The
- * group containing the device must already be added to this context.
- * Return: new file descriptor on success, -errno on failure.
- * Availability: When attached to container
- */
-#define VFIO_GROUP_GET_DEVICE_FD	_IO(VFIO_TYPE, VFIO_BASE + 6)
-
-/* --------------- IOCTLs for DEVICE file descriptors --------------- */
-
-/**
- * VFIO_DEVICE_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 7,
- *						struct vfio_device_info)
- *
- * Retrieve information about the device.  Fills in provided
- * struct vfio_device_info.  Caller sets argsz.
- * Return: 0 on success, -errno on failure.
- */
-struct vfio_device_info {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_DEVICE_FLAGS_RESET	(1 << 0)	/* Device supports reset */
-#define VFIO_DEVICE_FLAGS_PCI	(1 << 1)	/* vfio-pci device */
-	__u32	num_regions;	/* Max region index + 1 */
-	__u32	num_irqs;	/* Max IRQ index + 1 */
-};
-#define VFIO_DEVICE_GET_INFO		_IO(VFIO_TYPE, VFIO_BASE + 7)
-
-/**
- * VFIO_DEVICE_GET_REGION_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 8,
- *				       struct vfio_region_info)
- *
- * Retrieve information about a device region.  Caller provides
- * struct vfio_region_info with index value set.  Caller sets argsz.
- * Implementation of region mapping is bus driver specific.  This is
- * intended to describe MMIO, I/O port, as well as bus specific
- * regions (ex. PCI config space).  Zero sized regions may be used
- * to describe unimplemented regions (ex. unimplemented PCI BARs).
- * Return: 0 on success, -errno on failure.
- */
-struct vfio_region_info {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_REGION_INFO_FLAG_READ	(1 << 0) /* Region supports read */
-#define VFIO_REGION_INFO_FLAG_WRITE	(1 << 1) /* Region supports write */
-#define VFIO_REGION_INFO_FLAG_MMAP	(1 << 2) /* Region supports mmap */
-	__u32	index;		/* Region index */
-	__u32	resv;		/* Reserved for alignment */
-	__u64	size;		/* Region size (bytes) */
-	__u64	offset;		/* Region offset from start of device fd */
-};
-#define VFIO_DEVICE_GET_REGION_INFO	_IO(VFIO_TYPE, VFIO_BASE + 8)
-
-/**
- * VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,
- *				    struct vfio_irq_info)
- *
- * Retrieve information about a device IRQ.  Caller provides
- * struct vfio_irq_info with index value set.  Caller sets argsz.
- * Implementation of IRQ mapping is bus driver specific.  Indexes
- * using multiple IRQs are primarily intended to support MSI-like
- * interrupt blocks.  Zero count irq blocks may be used to describe
- * unimplemented interrupt types.
- *
- * The EVENTFD flag indicates the interrupt index supports eventfd based
- * signaling.
- *
- * The MASKABLE flags indicates the index supports MASK and UNMASK
- * actions described below.
- *
- * AUTOMASKED indicates that after signaling, the interrupt line is
- * automatically masked by VFIO and the user needs to unmask the line
- * to receive new interrupts.  This is primarily intended to distinguish
- * level triggered interrupts.
- *
- * The NORESIZE flag indicates that the interrupt lines within the index
- * are setup as a set and new subindexes cannot be enabled without first
- * disabling the entire index.  This is used for interrupts like PCI MSI
- * and MSI-X where the driver may only use a subset of the available
- * indexes, but VFIO needs to enable a specific number of vectors
- * upfront.  In the case of MSI-X, where the user can enable MSI-X and
- * then add and unmask vectors, it's up to userspace to make the decision
- * whether to allocate the maximum supported number of vectors or tear
- * down setup and incrementally increase the vectors as each is enabled.
- */
-struct vfio_irq_info {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_IRQ_INFO_EVENTFD		(1 << 0)
-#define VFIO_IRQ_INFO_MASKABLE		(1 << 1)
-#define VFIO_IRQ_INFO_AUTOMASKED	(1 << 2)
-#define VFIO_IRQ_INFO_NORESIZE		(1 << 3)
-	__u32	index;		/* IRQ index */
-	__u32	count;		/* Number of IRQs within this index */
-};
-#define VFIO_DEVICE_GET_IRQ_INFO	_IO(VFIO_TYPE, VFIO_BASE + 9)
-
-/**
- * VFIO_DEVICE_SET_IRQS - _IOW(VFIO_TYPE, VFIO_BASE + 10, struct vfio_irq_set)
- *
- * Set signaling, masking, and unmasking of interrupts.  Caller provides
- * struct vfio_irq_set with all fields set.  'start' and 'count' indicate
- * the range of subindexes being specified.
- *
- * The DATA flags specify the type of data provided.  If DATA_NONE, the
- * operation performs the specified action immediately on the specified
- * interrupt(s).  For example, to unmask AUTOMASKED interrupt [0,0]:
- * flags = (DATA_NONE|ACTION_UNMASK), index = 0, start = 0, count = 1.
- *
- * DATA_BOOL allows sparse support for the same on arrays of interrupts.
- * For example, to mask interrupts [0,1] and [0,3] (but not [0,2]):
- * flags = (DATA_BOOL|ACTION_MASK), index = 0, start = 1, count = 3,
- * data = {1,0,1}
- *
- * DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd.
- * A value of -1 can be used to either de-assign interrupts if already
- * assigned or skip un-assigned interrupts.  For example, to set an eventfd
- * to be trigger for interrupts [0,0] and [0,2]:
- * flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,
- * data = {fd1, -1, fd2}
- * If index [0,1] is previously set, two count = 1 ioctls calls would be
- * required to set [0,0] and [0,2] without changing [0,1].
- *
- * Once a signaling mechanism is set, DATA_BOOL or DATA_NONE can be used
- * with ACTION_TRIGGER to perform kernel level interrupt loopback testing
- * from userspace (ie. simulate hardware triggering).
- *
- * Setting of an event triggering mechanism to userspace for ACTION_TRIGGER
- * enables the interrupt index for the device.  Individual subindex interrupts
- * can be disabled using the -1 value for DATA_EVENTFD or the index can be
- * disabled as a whole with: flags = (DATA_NONE|ACTION_TRIGGER), count = 0.
- *
- * Note that ACTION_[UN]MASK specify user->kernel signaling (irqfds) while
- * ACTION_TRIGGER specifies kernel->user signaling.
- */
-struct vfio_irq_set {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_IRQ_SET_DATA_NONE		(1 << 0) /* Data not present */
-#define VFIO_IRQ_SET_DATA_BOOL		(1 << 1) /* Data is bool (u8) */
-#define VFIO_IRQ_SET_DATA_EVENTFD	(1 << 2) /* Data is eventfd (s32) */
-#define VFIO_IRQ_SET_ACTION_MASK	(1 << 3) /* Mask interrupt */
-#define VFIO_IRQ_SET_ACTION_UNMASK	(1 << 4) /* Unmask interrupt */
-#define VFIO_IRQ_SET_ACTION_TRIGGER	(1 << 5) /* Trigger interrupt */
-	__u32	index;
-	__u32	start;
-	__u32	count;
-	__u8	data[];
-};
-#define VFIO_DEVICE_SET_IRQS		_IO(VFIO_TYPE, VFIO_BASE + 10)
-
-#define VFIO_IRQ_SET_DATA_TYPE_MASK	(VFIO_IRQ_SET_DATA_NONE | \
-					 VFIO_IRQ_SET_DATA_BOOL | \
-					 VFIO_IRQ_SET_DATA_EVENTFD)
-#define VFIO_IRQ_SET_ACTION_TYPE_MASK	(VFIO_IRQ_SET_ACTION_MASK | \
-					 VFIO_IRQ_SET_ACTION_UNMASK | \
-					 VFIO_IRQ_SET_ACTION_TRIGGER)
-/**
- * VFIO_DEVICE_RESET - _IO(VFIO_TYPE, VFIO_BASE + 11)
- *
- * Reset a device.
- */
-#define VFIO_DEVICE_RESET		_IO(VFIO_TYPE, VFIO_BASE + 11)
-
-/*
- * The VFIO-PCI bus driver makes use of the following fixed region and
- * IRQ index mapping.  Unimplemented regions return a size of zero.
- * Unimplemented IRQ types return a count of zero.
- */
-
-enum {
-	VFIO_PCI_BAR0_REGION_INDEX,
-	VFIO_PCI_BAR1_REGION_INDEX,
-	VFIO_PCI_BAR2_REGION_INDEX,
-	VFIO_PCI_BAR3_REGION_INDEX,
-	VFIO_PCI_BAR4_REGION_INDEX,
-	VFIO_PCI_BAR5_REGION_INDEX,
-	VFIO_PCI_ROM_REGION_INDEX,
-	VFIO_PCI_CONFIG_REGION_INDEX,
-	VFIO_PCI_NUM_REGIONS
-};
-
-enum {
-	VFIO_PCI_INTX_IRQ_INDEX,
-	VFIO_PCI_MSI_IRQ_INDEX,
-	VFIO_PCI_MSIX_IRQ_INDEX,
-	VFIO_PCI_NUM_IRQS
-};
-
-/* -------- API for Type1 VFIO IOMMU -------- */
-
-/**
- * VFIO_IOMMU_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 12, struct vfio_iommu_info)
- *
- * Retrieve information about the IOMMU object. Fills in provided
- * struct vfio_iommu_info. Caller sets argsz.
- *
- * XXX Should we do these by CHECK_EXTENSION too?
- */
-struct vfio_iommu_type1_info {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_IOMMU_INFO_PGSIZES (1 << 0)	/* supported page sizes info */
-	__u64	iova_pgsizes;		/* Bitmap of supported page sizes */
-};
-
-#define VFIO_IOMMU_GET_INFO _IO(VFIO_TYPE, VFIO_BASE + 12)
-
-/**
- * VFIO_IOMMU_MAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 13, struct vfio_dma_map)
- *
- * Map process virtual addresses to IO virtual addresses using the
- * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
- */
-struct vfio_iommu_type1_dma_map {
-	__u32	argsz;
-	__u32	flags;
-#define VFIO_DMA_MAP_FLAG_READ (1 << 0)		/* readable from device */
-#define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)	/* writable from device */
-	__u64	vaddr;				/* Process virtual address */
-	__u64	iova;				/* IO virtual address */
-	__u64	size;				/* Size of mapping (bytes) */
-};
-
-#define VFIO_IOMMU_MAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 13)
-
-/**
- * VFIO_IOMMU_UNMAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 14, struct vfio_dma_unmap)
- *
- * Unmap IO virtual addresses using the provided struct vfio_dma_unmap.
- * Caller sets argsz.
- */
-struct vfio_iommu_type1_dma_unmap {
-	__u32	argsz;
-	__u32	flags;
-	__u64	iova;				/* IO virtual address */
-	__u64	size;				/* Size of mapping (bytes) */
-};
-
-#define VFIO_IOMMU_UNMAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 14)
-
 #endif /* VFIO_H */

commit 89e1f7d4c66d85f42c3d52ea3866eb10cadf6153
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Jul 31 08:16:24 2012 -0600

    vfio: Add PCI device driver
    
    Add PCI device support for VFIO.  PCI devices expose regions
    for accessing config space, I/O port space, and MMIO areas
    of the device.  PCI config access is virtualized in the kernel,
    allowing us to ensure the integrity of the system, by preventing
    various accesses while reducing duplicate support across various
    userspace drivers.  I/O port supports read/write access while
    MMIO also supports mmap of sufficiently sized regions.  Support
    for INTx, MSI, and MSI-X interrupts are provided using eventfds to
    userspace.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index acb046fd5b70..0a4f180a11d8 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -223,6 +223,7 @@ struct vfio_device_info {
 	__u32	argsz;
 	__u32	flags;
 #define VFIO_DEVICE_FLAGS_RESET	(1 << 0)	/* Device supports reset */
+#define VFIO_DEVICE_FLAGS_PCI	(1 << 1)	/* vfio-pci device */
 	__u32	num_regions;	/* Max region index + 1 */
 	__u32	num_irqs;	/* Max IRQ index + 1 */
 };
@@ -364,6 +365,31 @@ struct vfio_irq_set {
  */
 #define VFIO_DEVICE_RESET		_IO(VFIO_TYPE, VFIO_BASE + 11)
 
+/*
+ * The VFIO-PCI bus driver makes use of the following fixed region and
+ * IRQ index mapping.  Unimplemented regions return a size of zero.
+ * Unimplemented IRQ types return a count of zero.
+ */
+
+enum {
+	VFIO_PCI_BAR0_REGION_INDEX,
+	VFIO_PCI_BAR1_REGION_INDEX,
+	VFIO_PCI_BAR2_REGION_INDEX,
+	VFIO_PCI_BAR3_REGION_INDEX,
+	VFIO_PCI_BAR4_REGION_INDEX,
+	VFIO_PCI_BAR5_REGION_INDEX,
+	VFIO_PCI_ROM_REGION_INDEX,
+	VFIO_PCI_CONFIG_REGION_INDEX,
+	VFIO_PCI_NUM_REGIONS
+};
+
+enum {
+	VFIO_PCI_INTX_IRQ_INDEX,
+	VFIO_PCI_MSI_IRQ_INDEX,
+	VFIO_PCI_MSIX_IRQ_INDEX,
+	VFIO_PCI_NUM_IRQS
+};
+
 /* -------- API for Type1 VFIO IOMMU -------- */
 
 /**

commit 73fa0d10d077d9521ee2dace2307ae2c9a965336
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Jul 31 08:16:23 2012 -0600

    vfio: Type1 IOMMU implementation
    
    This VFIO IOMMU backend is designed primarily for AMD-Vi and Intel
    VT-d hardware, but is potentially usable by anything supporting
    similar mapping functionality.  We arbitrarily call this a Type1
    backend for lack of a better name.  This backend has no IOVA
    or host memory mapping restrictions for the user and is optimized
    for relatively static mappings.  Mapped areas are pinned into system
    memory.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
index 03e56a5154b6..acb046fd5b70 100644
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@ -98,7 +98,7 @@ extern void vfio_unregister_iommu_driver(
 
 /* Extensions */
 
-/* None yet */
+#define VFIO_TYPE1_IOMMU		1
 
 /*
  * The IOCTL interface is designed for extensibility by embedding the
@@ -364,4 +364,56 @@ struct vfio_irq_set {
  */
 #define VFIO_DEVICE_RESET		_IO(VFIO_TYPE, VFIO_BASE + 11)
 
+/* -------- API for Type1 VFIO IOMMU -------- */
+
+/**
+ * VFIO_IOMMU_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 12, struct vfio_iommu_info)
+ *
+ * Retrieve information about the IOMMU object. Fills in provided
+ * struct vfio_iommu_info. Caller sets argsz.
+ *
+ * XXX Should we do these by CHECK_EXTENSION too?
+ */
+struct vfio_iommu_type1_info {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_IOMMU_INFO_PGSIZES (1 << 0)	/* supported page sizes info */
+	__u64	iova_pgsizes;		/* Bitmap of supported page sizes */
+};
+
+#define VFIO_IOMMU_GET_INFO _IO(VFIO_TYPE, VFIO_BASE + 12)
+
+/**
+ * VFIO_IOMMU_MAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 13, struct vfio_dma_map)
+ *
+ * Map process virtual addresses to IO virtual addresses using the
+ * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
+ */
+struct vfio_iommu_type1_dma_map {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_DMA_MAP_FLAG_READ (1 << 0)		/* readable from device */
+#define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)	/* writable from device */
+	__u64	vaddr;				/* Process virtual address */
+	__u64	iova;				/* IO virtual address */
+	__u64	size;				/* Size of mapping (bytes) */
+};
+
+#define VFIO_IOMMU_MAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 13)
+
+/**
+ * VFIO_IOMMU_UNMAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 14, struct vfio_dma_unmap)
+ *
+ * Unmap IO virtual addresses using the provided struct vfio_dma_unmap.
+ * Caller sets argsz.
+ */
+struct vfio_iommu_type1_dma_unmap {
+	__u32	argsz;
+	__u32	flags;
+	__u64	iova;				/* IO virtual address */
+	__u64	size;				/* Size of mapping (bytes) */
+};
+
+#define VFIO_IOMMU_UNMAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 14)
+
 #endif /* VFIO_H */

commit cba3345cc494ad286ca8823f44b2c16cae496679
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Jul 31 08:16:22 2012 -0600

    vfio: VFIO core
    
    VFIO is a secure user level driver for use with both virtual machines
    and user level drivers.  VFIO makes use of IOMMU groups to ensure the
    isolation of devices in use, allowing unprivileged user access.  It's
    intended that VFIO will replace KVM device assignment and UIO drivers
    (in cases where the target platform includes a sufficiently capable
    IOMMU).
    
    New in this version of VFIO is support for IOMMU groups managed
    through the IOMMU core as well as a rework of the API, removing the
    group merge interface.  We now go back to a model more similar to
    original VFIO with UIOMMU support where the file descriptor obtained
    from /dev/vfio/vfio allows access to the IOMMU, but only after a
    group is added, avoiding the previous privilege issues with this type
    of model.  IOMMU support is also now fully modular as IOMMUs have
    vastly different interface requirements on different platforms.  VFIO
    users are able to query and initialize the IOMMU model of their
    choice.
    
    Please see the follow-on Documentation commit for further description
    and usage example.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/include/linux/vfio.h b/include/linux/vfio.h
new file mode 100644
index 000000000000..03e56a5154b6
--- /dev/null
+++ b/include/linux/vfio.h
@@ -0,0 +1,367 @@
+/*
+ * VFIO API definition
+ *
+ * Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
+ *     Author: Alex Williamson <alex.williamson@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef VFIO_H
+#define VFIO_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define VFIO_API_VERSION	0
+
+#ifdef __KERNEL__	/* Internal VFIO-core/bus driver API */
+
+#include <linux/iommu.h>
+#include <linux/mm.h>
+
+/**
+ * struct vfio_device_ops - VFIO bus driver device callbacks
+ *
+ * @open: Called when userspace creates new file descriptor for device
+ * @release: Called when userspace releases file descriptor for device
+ * @read: Perform read(2) on device file descriptor
+ * @write: Perform write(2) on device file descriptor
+ * @ioctl: Perform ioctl(2) on device file descriptor, supporting VFIO_DEVICE_*
+ *         operations documented below
+ * @mmap: Perform mmap(2) on a region of the device file descriptor
+ */
+struct vfio_device_ops {
+	char	*name;
+	int	(*open)(void *device_data);
+	void	(*release)(void *device_data);
+	ssize_t	(*read)(void *device_data, char __user *buf,
+			size_t count, loff_t *ppos);
+	ssize_t	(*write)(void *device_data, const char __user *buf,
+			 size_t count, loff_t *size);
+	long	(*ioctl)(void *device_data, unsigned int cmd,
+			 unsigned long arg);
+	int	(*mmap)(void *device_data, struct vm_area_struct *vma);
+};
+
+extern int vfio_add_group_dev(struct device *dev,
+			      const struct vfio_device_ops *ops,
+			      void *device_data);
+
+extern void *vfio_del_group_dev(struct device *dev);
+
+/**
+ * struct vfio_iommu_driver_ops - VFIO IOMMU driver callbacks
+ */
+struct vfio_iommu_driver_ops {
+	char		*name;
+	struct module	*owner;
+	void		*(*open)(unsigned long arg);
+	void		(*release)(void *iommu_data);
+	ssize_t		(*read)(void *iommu_data, char __user *buf,
+				size_t count, loff_t *ppos);
+	ssize_t		(*write)(void *iommu_data, const char __user *buf,
+				 size_t count, loff_t *size);
+	long		(*ioctl)(void *iommu_data, unsigned int cmd,
+				 unsigned long arg);
+	int		(*mmap)(void *iommu_data, struct vm_area_struct *vma);
+	int		(*attach_group)(void *iommu_data,
+					struct iommu_group *group);
+	void		(*detach_group)(void *iommu_data,
+					struct iommu_group *group);
+
+};
+
+extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
+
+extern void vfio_unregister_iommu_driver(
+				const struct vfio_iommu_driver_ops *ops);
+
+/**
+ * offsetofend(TYPE, MEMBER)
+ *
+ * @TYPE: The type of the structure
+ * @MEMBER: The member within the structure to get the end offset of
+ *
+ * Simple helper macro for dealing with variable sized structures passed
+ * from user space.  This allows us to easily determine if the provided
+ * structure is sized to include various fields.
+ */
+#define offsetofend(TYPE, MEMBER) ({				\
+	TYPE tmp;						\
+	offsetof(TYPE, MEMBER) + sizeof(tmp.MEMBER); })		\
+
+#endif /* __KERNEL__ */
+
+/* Kernel & User level defines for VFIO IOCTLs. */
+
+/* Extensions */
+
+/* None yet */
+
+/*
+ * The IOCTL interface is designed for extensibility by embedding the
+ * structure length (argsz) and flags into structures passed between
+ * kernel and userspace.  We therefore use the _IO() macro for these
+ * defines to avoid implicitly embedding a size into the ioctl request.
+ * As structure fields are added, argsz will increase to match and flag
+ * bits will be defined to indicate additional fields with valid data.
+ * It's *always* the caller's responsibility to indicate the size of
+ * the structure passed by setting argsz appropriately.
+ */
+
+#define VFIO_TYPE	(';')
+#define VFIO_BASE	100
+
+/* -------- IOCTLs for VFIO file descriptor (/dev/vfio/vfio) -------- */
+
+/**
+ * VFIO_GET_API_VERSION - _IO(VFIO_TYPE, VFIO_BASE + 0)
+ *
+ * Report the version of the VFIO API.  This allows us to bump the entire
+ * API version should we later need to add or change features in incompatible
+ * ways.
+ * Return: VFIO_API_VERSION
+ * Availability: Always
+ */
+#define VFIO_GET_API_VERSION		_IO(VFIO_TYPE, VFIO_BASE + 0)
+
+/**
+ * VFIO_CHECK_EXTENSION - _IOW(VFIO_TYPE, VFIO_BASE + 1, __u32)
+ *
+ * Check whether an extension is supported.
+ * Return: 0 if not supported, 1 (or some other positive integer) if supported.
+ * Availability: Always
+ */
+#define VFIO_CHECK_EXTENSION		_IO(VFIO_TYPE, VFIO_BASE + 1)
+
+/**
+ * VFIO_SET_IOMMU - _IOW(VFIO_TYPE, VFIO_BASE + 2, __s32)
+ *
+ * Set the iommu to the given type.  The type must be supported by an
+ * iommu driver as verified by calling CHECK_EXTENSION using the same
+ * type.  A group must be set to this file descriptor before this
+ * ioctl is available.  The IOMMU interfaces enabled by this call are
+ * specific to the value set.
+ * Return: 0 on success, -errno on failure
+ * Availability: When VFIO group attached
+ */
+#define VFIO_SET_IOMMU			_IO(VFIO_TYPE, VFIO_BASE + 2)
+
+/* -------- IOCTLs for GROUP file descriptors (/dev/vfio/$GROUP) -------- */
+
+/**
+ * VFIO_GROUP_GET_STATUS - _IOR(VFIO_TYPE, VFIO_BASE + 3,
+ *						struct vfio_group_status)
+ *
+ * Retrieve information about the group.  Fills in provided
+ * struct vfio_group_info.  Caller sets argsz.
+ * Return: 0 on succes, -errno on failure.
+ * Availability: Always
+ */
+struct vfio_group_status {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_GROUP_FLAGS_VIABLE		(1 << 0)
+#define VFIO_GROUP_FLAGS_CONTAINER_SET	(1 << 1)
+};
+#define VFIO_GROUP_GET_STATUS		_IO(VFIO_TYPE, VFIO_BASE + 3)
+
+/**
+ * VFIO_GROUP_SET_CONTAINER - _IOW(VFIO_TYPE, VFIO_BASE + 4, __s32)
+ *
+ * Set the container for the VFIO group to the open VFIO file
+ * descriptor provided.  Groups may only belong to a single
+ * container.  Containers may, at their discretion, support multiple
+ * groups.  Only when a container is set are all of the interfaces
+ * of the VFIO file descriptor and the VFIO group file descriptor
+ * available to the user.
+ * Return: 0 on success, -errno on failure.
+ * Availability: Always
+ */
+#define VFIO_GROUP_SET_CONTAINER	_IO(VFIO_TYPE, VFIO_BASE + 4)
+
+/**
+ * VFIO_GROUP_UNSET_CONTAINER - _IO(VFIO_TYPE, VFIO_BASE + 5)
+ *
+ * Remove the group from the attached container.  This is the
+ * opposite of the SET_CONTAINER call and returns the group to
+ * an initial state.  All device file descriptors must be released
+ * prior to calling this interface.  When removing the last group
+ * from a container, the IOMMU will be disabled and all state lost,
+ * effectively also returning the VFIO file descriptor to an initial
+ * state.
+ * Return: 0 on success, -errno on failure.
+ * Availability: When attached to container
+ */
+#define VFIO_GROUP_UNSET_CONTAINER	_IO(VFIO_TYPE, VFIO_BASE + 5)
+
+/**
+ * VFIO_GROUP_GET_DEVICE_FD - _IOW(VFIO_TYPE, VFIO_BASE + 6, char)
+ *
+ * Return a new file descriptor for the device object described by
+ * the provided string.  The string should match a device listed in
+ * the devices subdirectory of the IOMMU group sysfs entry.  The
+ * group containing the device must already be added to this context.
+ * Return: new file descriptor on success, -errno on failure.
+ * Availability: When attached to container
+ */
+#define VFIO_GROUP_GET_DEVICE_FD	_IO(VFIO_TYPE, VFIO_BASE + 6)
+
+/* --------------- IOCTLs for DEVICE file descriptors --------------- */
+
+/**
+ * VFIO_DEVICE_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 7,
+ *						struct vfio_device_info)
+ *
+ * Retrieve information about the device.  Fills in provided
+ * struct vfio_device_info.  Caller sets argsz.
+ * Return: 0 on success, -errno on failure.
+ */
+struct vfio_device_info {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_DEVICE_FLAGS_RESET	(1 << 0)	/* Device supports reset */
+	__u32	num_regions;	/* Max region index + 1 */
+	__u32	num_irqs;	/* Max IRQ index + 1 */
+};
+#define VFIO_DEVICE_GET_INFO		_IO(VFIO_TYPE, VFIO_BASE + 7)
+
+/**
+ * VFIO_DEVICE_GET_REGION_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 8,
+ *				       struct vfio_region_info)
+ *
+ * Retrieve information about a device region.  Caller provides
+ * struct vfio_region_info with index value set.  Caller sets argsz.
+ * Implementation of region mapping is bus driver specific.  This is
+ * intended to describe MMIO, I/O port, as well as bus specific
+ * regions (ex. PCI config space).  Zero sized regions may be used
+ * to describe unimplemented regions (ex. unimplemented PCI BARs).
+ * Return: 0 on success, -errno on failure.
+ */
+struct vfio_region_info {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_REGION_INFO_FLAG_READ	(1 << 0) /* Region supports read */
+#define VFIO_REGION_INFO_FLAG_WRITE	(1 << 1) /* Region supports write */
+#define VFIO_REGION_INFO_FLAG_MMAP	(1 << 2) /* Region supports mmap */
+	__u32	index;		/* Region index */
+	__u32	resv;		/* Reserved for alignment */
+	__u64	size;		/* Region size (bytes) */
+	__u64	offset;		/* Region offset from start of device fd */
+};
+#define VFIO_DEVICE_GET_REGION_INFO	_IO(VFIO_TYPE, VFIO_BASE + 8)
+
+/**
+ * VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,
+ *				    struct vfio_irq_info)
+ *
+ * Retrieve information about a device IRQ.  Caller provides
+ * struct vfio_irq_info with index value set.  Caller sets argsz.
+ * Implementation of IRQ mapping is bus driver specific.  Indexes
+ * using multiple IRQs are primarily intended to support MSI-like
+ * interrupt blocks.  Zero count irq blocks may be used to describe
+ * unimplemented interrupt types.
+ *
+ * The EVENTFD flag indicates the interrupt index supports eventfd based
+ * signaling.
+ *
+ * The MASKABLE flags indicates the index supports MASK and UNMASK
+ * actions described below.
+ *
+ * AUTOMASKED indicates that after signaling, the interrupt line is
+ * automatically masked by VFIO and the user needs to unmask the line
+ * to receive new interrupts.  This is primarily intended to distinguish
+ * level triggered interrupts.
+ *
+ * The NORESIZE flag indicates that the interrupt lines within the index
+ * are setup as a set and new subindexes cannot be enabled without first
+ * disabling the entire index.  This is used for interrupts like PCI MSI
+ * and MSI-X where the driver may only use a subset of the available
+ * indexes, but VFIO needs to enable a specific number of vectors
+ * upfront.  In the case of MSI-X, where the user can enable MSI-X and
+ * then add and unmask vectors, it's up to userspace to make the decision
+ * whether to allocate the maximum supported number of vectors or tear
+ * down setup and incrementally increase the vectors as each is enabled.
+ */
+struct vfio_irq_info {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_IRQ_INFO_EVENTFD		(1 << 0)
+#define VFIO_IRQ_INFO_MASKABLE		(1 << 1)
+#define VFIO_IRQ_INFO_AUTOMASKED	(1 << 2)
+#define VFIO_IRQ_INFO_NORESIZE		(1 << 3)
+	__u32	index;		/* IRQ index */
+	__u32	count;		/* Number of IRQs within this index */
+};
+#define VFIO_DEVICE_GET_IRQ_INFO	_IO(VFIO_TYPE, VFIO_BASE + 9)
+
+/**
+ * VFIO_DEVICE_SET_IRQS - _IOW(VFIO_TYPE, VFIO_BASE + 10, struct vfio_irq_set)
+ *
+ * Set signaling, masking, and unmasking of interrupts.  Caller provides
+ * struct vfio_irq_set with all fields set.  'start' and 'count' indicate
+ * the range of subindexes being specified.
+ *
+ * The DATA flags specify the type of data provided.  If DATA_NONE, the
+ * operation performs the specified action immediately on the specified
+ * interrupt(s).  For example, to unmask AUTOMASKED interrupt [0,0]:
+ * flags = (DATA_NONE|ACTION_UNMASK), index = 0, start = 0, count = 1.
+ *
+ * DATA_BOOL allows sparse support for the same on arrays of interrupts.
+ * For example, to mask interrupts [0,1] and [0,3] (but not [0,2]):
+ * flags = (DATA_BOOL|ACTION_MASK), index = 0, start = 1, count = 3,
+ * data = {1,0,1}
+ *
+ * DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd.
+ * A value of -1 can be used to either de-assign interrupts if already
+ * assigned or skip un-assigned interrupts.  For example, to set an eventfd
+ * to be trigger for interrupts [0,0] and [0,2]:
+ * flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,
+ * data = {fd1, -1, fd2}
+ * If index [0,1] is previously set, two count = 1 ioctls calls would be
+ * required to set [0,0] and [0,2] without changing [0,1].
+ *
+ * Once a signaling mechanism is set, DATA_BOOL or DATA_NONE can be used
+ * with ACTION_TRIGGER to perform kernel level interrupt loopback testing
+ * from userspace (ie. simulate hardware triggering).
+ *
+ * Setting of an event triggering mechanism to userspace for ACTION_TRIGGER
+ * enables the interrupt index for the device.  Individual subindex interrupts
+ * can be disabled using the -1 value for DATA_EVENTFD or the index can be
+ * disabled as a whole with: flags = (DATA_NONE|ACTION_TRIGGER), count = 0.
+ *
+ * Note that ACTION_[UN]MASK specify user->kernel signaling (irqfds) while
+ * ACTION_TRIGGER specifies kernel->user signaling.
+ */
+struct vfio_irq_set {
+	__u32	argsz;
+	__u32	flags;
+#define VFIO_IRQ_SET_DATA_NONE		(1 << 0) /* Data not present */
+#define VFIO_IRQ_SET_DATA_BOOL		(1 << 1) /* Data is bool (u8) */
+#define VFIO_IRQ_SET_DATA_EVENTFD	(1 << 2) /* Data is eventfd (s32) */
+#define VFIO_IRQ_SET_ACTION_MASK	(1 << 3) /* Mask interrupt */
+#define VFIO_IRQ_SET_ACTION_UNMASK	(1 << 4) /* Unmask interrupt */
+#define VFIO_IRQ_SET_ACTION_TRIGGER	(1 << 5) /* Trigger interrupt */
+	__u32	index;
+	__u32	start;
+	__u32	count;
+	__u8	data[];
+};
+#define VFIO_DEVICE_SET_IRQS		_IO(VFIO_TYPE, VFIO_BASE + 10)
+
+#define VFIO_IRQ_SET_DATA_TYPE_MASK	(VFIO_IRQ_SET_DATA_NONE | \
+					 VFIO_IRQ_SET_DATA_BOOL | \
+					 VFIO_IRQ_SET_DATA_EVENTFD)
+#define VFIO_IRQ_SET_ACTION_TYPE_MASK	(VFIO_IRQ_SET_ACTION_MASK | \
+					 VFIO_IRQ_SET_ACTION_UNMASK | \
+					 VFIO_IRQ_SET_ACTION_TRIGGER)
+/**
+ * VFIO_DEVICE_RESET - _IO(VFIO_TYPE, VFIO_BASE + 11)
+ *
+ * Reset a device.
+ */
+#define VFIO_DEVICE_RESET		_IO(VFIO_TYPE, VFIO_BASE + 11)
+
+#endif /* VFIO_H */
