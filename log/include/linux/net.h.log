commit ceabef7dd71720aef58bd182943352c9c307a3de
Author: Orson Zhai <orson.zhai@unisoc.com>
Date:   Sun Jun 7 21:40:14 2020 -0700

    dynamic_debug: add an option to enable dynamic debug for modules only
    
    Instead of enabling dynamic debug globally with CONFIG_DYNAMIC_DEBUG,
    CONFIG_DYNAMIC_DEBUG_CORE will only enable core function of dynamic
    debug.  With the DYNAMIC_DEBUG_MODULE defined for any modules, dynamic
    debug will be tied to them.
    
    This is useful for people who only want to enable dynamic debug for
    kernel modules without worrying about kernel image size and memory
    consumption is increasing too much.
    
    [orson.zhai@unisoc.com: v2]
      Link: http://lkml.kernel.org/r/1587408228-10861-1-git-send-email-orson.unisoc@gmail.com
    
    Signed-off-by: Orson Zhai <orson.zhai@unisoc.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Petr Mladek <pmladek@suse.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Link: http://lkml.kernel.org/r/1586521984-5890-1-git-send-email-orson.unisoc@gmail.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index e10f378194a5..016a9c5faa34 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -264,7 +264,8 @@ do {								\
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
-#if defined(CONFIG_DYNAMIC_DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG) || \
+	(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))
 #define net_dbg_ratelimited(fmt, ...)					\
 do {									\
 	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\

commit 5a892ff2facb4548c17c05931ed899038a0da63e
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 29 14:09:43 2020 +0200

    net: remove kernel_setsockopt
    
    No users left.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 74ef5d7315f7..e10f378194a5 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -303,8 +303,6 @@ int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
 		   int flags);
 int kernel_getsockname(struct socket *sock, struct sockaddr *addr);
 int kernel_getpeername(struct socket *sock, struct sockaddr *addr);
-int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
-		      unsigned int optlen);
 int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 		    size_t size, int flags);
 int kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,

commit 7a15b2e013f535a125ad7351ffc808c79bc6de35
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 27 20:22:29 2020 +0200

    net: remove kernel_getsockopt
    
    No users left.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6451425e828f..74ef5d7315f7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -303,8 +303,6 @@ int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
 		   int flags);
 int kernel_getsockname(struct socket *sock, struct sockaddr *addr);
 int kernel_getpeername(struct socket *sock, struct sockaddr *addr);
-int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
-		      int *optlen);
 int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
 		      unsigned int optlen);
 int kernel_sendpage(struct socket *sock, struct page *page, int offset,

commit b4653342b1514cb11f25b727c689451aff02996d
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Mon Dec 9 13:03:40 2019 +0300

    net: Allow to show socket-specific information in /proc/[pid]/fdinfo/[fd]
    
    This adds .show_fdinfo to socket_file_ops, so protocols will be able
    to print their specific data in fdinfo.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 9cafb5f353a9..6451425e828f 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -171,6 +171,7 @@ struct proto_ops {
 	int		(*compat_getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 #endif
+	void		(*show_fdinfo)(struct seq_file *m, struct socket *sock);
 	int		(*sendmsg)   (struct socket *sock, struct msghdr *m,
 				      size_t total_len);
 	/* Notes for implementing recvmsg:

commit 333f7909a8573145811c4ab7d8c9092301707721
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 5 20:14:16 2019 +0100

    coallocate socket_wq with socket itself
    
    socket->wq is assign-once, set when we are initializing both
    struct socket it's in and struct socket_wq it points to.  As the
    matter of fact, the only reason for separate allocation was the
    ability to RCU-delay freeing of socket_wq.  RCU-delaying the
    freeing of socket itself gets rid of that need, so we can just
    fold struct socket_wq into the end of struct socket and simplify
    the life both for sock_alloc_inode() (one allocation instead of
    two) and for tun/tap oddballs, where we used to embed struct socket
    and struct socket_wq into the same structure (now - embedding just
    the struct socket).
    
    Note that reference to struct socket_wq in struct sock does remain
    a reference - that's unchanged.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index f7d672cf25b5..9cafb5f353a9 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -116,11 +116,11 @@ struct socket {
 
 	unsigned long		flags;
 
-	struct socket_wq	*wq;
-
 	struct file		*file;
 	struct sock		*sk;
 	const struct proto_ops	*ops;
+
+	struct socket_wq	wq;
 };
 
 struct vm_area_struct;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 50bf5206ead6..f7d672cf25b5 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * NET		An implementation of the SOCKET network access protocol.
  *		This is the master header file for the Linux NET layer,
@@ -9,11 +10,6 @@
  * Authors:	Orest Zborowski, <obz@Kodak.COM>
  *		Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
  */
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H

commit c7cbdbf29f488a19982cd9f4a109887f18028bbb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Apr 17 22:51:48 2019 +0200

    net: rework SIOCGSTAMP ioctl handling
    
    The SIOCGSTAMP/SIOCGSTAMPNS ioctl commands are implemented by many
    socket protocol handlers, and all of those end up calling the same
    sock_get_timestamp()/sock_get_timestampns() helper functions, which
    results in a lot of duplicate code.
    
    With the introduction of 64-bit time_t on 32-bit architectures, this
    gets worse, as we then need four different ioctl commands in each
    socket protocol implementation.
    
    To simplify that, let's add a new .gettstamp() operation in
    struct proto_ops, and move ioctl implementation into the common
    sock_ioctl()/compat_sock_ioctl_trans() functions that these all go
    through.
    
    We can reuse the sock_get_timestamp() implementation, but generalize
    it so it can deal with both native and compat mode, as well as
    timeval and timespec structures.
    
    Acked-by: Stefan Schmidt <stefan@datenfreihafen.org>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Link: https://lore.kernel.org/lkml/CAK8P3a038aDQQotzua_QtKGhq8O9n+rdiz2=WDCp82ys8eUT+A@mail.gmail.com/
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index c606c72311d0..50bf5206ead6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -161,6 +161,8 @@ struct proto_ops {
 	int	 	(*compat_ioctl) (struct socket *sock, unsigned int cmd,
 				      unsigned long arg);
 #endif
+	int		(*gettstamp) (struct socket *sock, void __user *userstamp,
+				      bool timeval, bool time32);
 	int		(*listen)    (struct socket *sock, int len);
 	int		(*shutdown)  (struct socket *sock, int flags);
 	int		(*setsockopt)(struct socket *sock, int level,

commit 8a3c245c031944f2176118270e7bc5d4fd4a1075
Author: Pedro Tammela <pctammela@gmail.com>
Date:   Thu Mar 14 10:45:23 2019 -0300

    net: add documentation to socket.c
    
    Adds missing sphinx documentation to the
    socket.c's functions. Also fixes some whitespaces.
    
    I also changed the style of older documentation as an
    effort to have an uniform documentation style.
    
    Signed-off-by: Pedro Tammela <pctammela@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 651fca72286c..c606c72311d0 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -83,6 +83,12 @@ enum sock_type {
 
 #endif /* ARCH_HAS_SOCKET_TYPES */
 
+/**
+ * enum sock_shutdown_cmd - Shutdown types
+ * @SHUT_RD: shutdown receptions
+ * @SHUT_WR: shutdown transmissions
+ * @SHUT_RDWR: shutdown receptions/transmissions
+ */
 enum sock_shutdown_cmd {
 	SHUT_RD,
 	SHUT_WR,

commit 3f16d181174879eccc523300a53b9eac2eee6e6d
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Mar 7 16:27:25 2019 -0800

    linux/net.h: use DYNAMIC_DEBUG_BRANCH in net_dbg_ratelimited
    
    net_dbg_ratelimited tests the dynamic debug descriptor the old-fashioned
    way, and doesn't utilize the static key/jump label implementation when
    CONFIG_JUMP_LABEL is set.  Use the DYNAMIC_DEBUG_BRANCH which is defined
    appropriately.
    
    Link: http://lkml.kernel.org/r/20190212214150.4807-3-linux@rasmusvillemoes.dk
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Jason Baron <jbaron@akamai.com>
    Cc: David Sterba <dsterba@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: "Rafael J . Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index e0930678c8bf..651fca72286c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -263,7 +263,7 @@ do {								\
 #define net_dbg_ratelimited(fmt, ...)					\
 do {									\
 	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
-	if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT) &&	\
+	if (DYNAMIC_DEBUG_BRANCH(descriptor) &&				\
 	    net_ratelimit())						\
 		__dynamic_pr_debug(&descriptor, pr_fmt(fmt),		\
 		                   ##__VA_ARGS__);			\

commit e6476c21447c4b17c47e476aade6facf050f31e8
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 30 09:45:07 2018 +0200

    net: remove bogus RCU annotations on socket.wq
    
    We never use RCU protection for it, just a lot of cargo-cult
    rcu_deference_protects calls.
    
    Note that we do keep the kfree_rcu call for it, as the references through
    struct sock are RCU protected and thus might require a grace period before
    freeing.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6554d3ba4396..e0930678c8bf 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -114,7 +114,7 @@ struct socket {
 
 	unsigned long		flags;
 
-	struct socket_wq __rcu	*wq;
+	struct socket_wq	*wq;
 
 	struct file		*file;
 	struct sock		*sk;

commit a11e1d432b51f63ba698d044441284a661f01144
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 28 09:43:44 2018 -0700

    Revert changes to convert to ->poll_mask() and aio IOCB_CMD_POLL
    
    The poll() changes were not well thought out, and completely
    unexplained.  They also caused a huge performance regression, because
    "->poll()" was no longer a trivial file operation that just called down
    to the underlying file operations, but instead did at least two indirect
    calls.
    
    Indirect calls are sadly slow now with the Spectre mitigation, but the
    performance problem could at least be largely mitigated by changing the
    "->get_poll_head()" operation to just have a per-file-descriptor pointer
    to the poll head instead.  That gets rid of one of the new indirections.
    
    But that doesn't fix the new complexity that is completely unwarranted
    for the regular case.  The (undocumented) reason for the poll() changes
    was some alleged AIO poll race fixing, but we don't make the common case
    slower and more complex for some uncommon special case, so this all
    really needs way more explanations and most likely a fundamental
    redesign.
    
    [ This revert is a revert of about 30 different commits, not reverted
      individually because that would just be unnecessarily messy  - Linus ]
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 08b6eb964dd6..6554d3ba4396 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -147,7 +147,6 @@ struct proto_ops {
 	int		(*getname)   (struct socket *sock,
 				      struct sockaddr *addr,
 				      int peer);
-	__poll_t	(*poll_mask) (struct socket *sock, __poll_t events);
 	__poll_t	(*poll)	     (struct file *file, struct socket *sock,
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,

commit 1c8c5a9d38f607c0b6fd12c91cbe1a4418762a21
Merge: 285767604576 7170e6045a6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 6 18:39:49 2018 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
    
     1) Add Maglev hashing scheduler to IPVS, from Inju Song.
    
     2) Lots of new TC subsystem tests from Roman Mashak.
    
     3) Add TCP zero copy receive and fix delayed acks and autotuning with
        SO_RCVLOWAT, from Eric Dumazet.
    
     4) Add XDP_REDIRECT support to mlx5 driver, from Jesper Dangaard
        Brouer.
    
     5) Add ttl inherit support to vxlan, from Hangbin Liu.
    
     6) Properly separate ipv6 routes into their logically independant
        components. fib6_info for the routing table, and fib6_nh for sets of
        nexthops, which thus can be shared. From David Ahern.
    
     7) Add bpf_xdp_adjust_tail helper, which can be used to generate ICMP
        messages from XDP programs. From Nikita V. Shirokov.
    
     8) Lots of long overdue cleanups to the r8169 driver, from Heiner
        Kallweit.
    
     9) Add BTF ("BPF Type Format"), from Martin KaFai Lau.
    
    10) Add traffic condition monitoring to iwlwifi, from Luca Coelho.
    
    11) Plumb extack down into fib_rules, from Roopa Prabhu.
    
    12) Add Flower classifier offload support to igb, from Vinicius Costa
        Gomes.
    
    13) Add UDP GSO support, from Willem de Bruijn.
    
    14) Add documentation for eBPF helpers, from Quentin Monnet.
    
    15) Add TLS tx offload to mlx5, from Ilya Lesokhin.
    
    16) Allow applications to be given the number of bytes available to read
        on a socket via a control message returned from recvmsg(), from
        Soheil Hassas Yeganeh.
    
    17) Add x86_32 eBPF JIT compiler, from Wang YanQing.
    
    18) Add AF_XDP sockets, with zerocopy support infrastructure as well.
        From Björn Töpel.
    
    19) Remove indirect load support from all of the BPF JITs and handle
        these operations in the verifier by translating them into native BPF
        instead. From Daniel Borkmann.
    
    20) Add GRO support to ipv6 gre tunnels, from Eran Ben Elisha.
    
    21) Allow XDP programs to do lookups in the main kernel routing tables
        for forwarding. From David Ahern.
    
    22) Allow drivers to store hardware state into an ELF section of kernel
        dump vmcore files, and use it in cxgb4. From Rahul Lakkireddy.
    
    23) Various RACK and loss detection improvements in TCP, from Yuchung
        Cheng.
    
    24) Add TCP SACK compression, from Eric Dumazet.
    
    25) Add User Mode Helper support and basic bpfilter infrastructure, from
        Alexei Starovoitov.
    
    26) Support ports and protocol values in RTM_GETROUTE, from Roopa
        Prabhu.
    
    27) Support bulking in ->ndo_xdp_xmit() API, from Jesper Dangaard
        Brouer.
    
    28) Add lots of forwarding selftests, from Petr Machata.
    
    29) Add generic network device failover driver, from Sridhar Samudrala.
    
    * ra.kernel.org:/pub/scm/linux/kernel/git/davem/net-next: (1959 commits)
      strparser: Add __strp_unpause and use it in ktls.
      rxrpc: Fix terminal retransmission connection ID to include the channel
      net: hns3: Optimize PF CMDQ interrupt switching process
      net: hns3: Fix for VF mailbox receiving unknown message
      net: hns3: Fix for VF mailbox cannot receiving PF response
      bnx2x: use the right constant
      Revert "net: sched: cls: Fix offloading when ingress dev is vxlan"
      net: dsa: b53: Fix for brcm tag issue in Cygnus SoC
      enic: fix UDP rss bits
      netdev-FAQ: clarify DaveM's position for stable backports
      rtnetlink: validate attributes in do_setlink()
      mlxsw: Add extack messages for port_{un, }split failures
      netdevsim: Add extack error message for devlink reload
      devlink: Add extack to reload and port_{un, }split operations
      net: metrics: add proper netlink validation
      ipmr: fix error path when ipmr_new_table fails
      ip6mr: only set ip6mr_table from setsockopt when ip6mr_new_table succeeds
      net: hns3: remove unused hclgevf_cfg_func_mta_filter
      netfilter: provide udp*_lib_lookup for nf_tproxy
      qed*: Utilize FW 8.37.2.0
      ...

commit 152524231023c76b3b7b3e71017c7f951812868d
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Apr 9 15:25:28 2018 +0200

    net: add support for ->poll_mask in proto_ops
    
    The socket file operations still implement ->poll until all protocols are
    switched over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/net.h b/include/linux/net.h
index 2248a052061d..3fd9d8c16581 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -147,6 +147,7 @@ struct proto_ops {
 	int		(*getname)   (struct socket *sock,
 				      struct sockaddr *addr,
 				      int peer);
+	__poll_t	(*poll_mask) (struct socket *sock, __poll_t events);
 	__poll_t	(*poll)	     (struct file *file, struct socket *sock,
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,

commit d1361840f8c519eaee9a78ffe09e4f0a1b586846
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Apr 16 10:33:35 2018 -0700

    tcp: fix SO_RCVLOWAT and RCVBUF autotuning
    
    Applications might use SO_RCVLOWAT on TCP socket hoping to receive
    one [E]POLLIN event only when a given amount of bytes are ready in socket
    receive queue.
    
    Problem is that receive autotuning is not aware of this constraint,
    meaning sk_rcvbuf might be too small to allow all bytes to be stored.
    
    Add a new (struct proto_ops)->set_rcvlowat method so that a protocol
    can override the default setsockopt(SO_RCVLOWAT) behavior.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 2248a052061d..6554d3ba4396 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -197,6 +197,7 @@ struct proto_ops {
 					   int offset, size_t size, int flags);
 	int		(*sendmsg_locked)(struct sock *sk, struct msghdr *msg,
 					  size_t size);
+	int		(*set_rcvlowat)(struct sock *sk, int val);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\

commit 03fe2debbb2771fb90881e4ce8109b09cf772a5c
Merge: 6686c459e144 f36b7534b833
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 23 11:24:57 2018 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Fun set of conflict resolutions here...
    
    For the mac80211 stuff, these were fortunately just parallel
    adds.  Trivially resolved.
    
    In drivers/net/phy/phy.c we had a bug fix in 'net' that moved the
    function phy_disable_interrupts() earlier in the file, whilst in
    'net-next' the phy_error() call from this function was removed.
    
    In net/ipv4/xfrm4_policy.c, David Ahern's changes to remove the
    'rt_table_id' member of rtable collided with a bug fix in 'net' that
    added a new struct member "rt_mtu_locked" which needs to be copied
    over here.
    
    The mlxsw driver conflict consisted of net-next separating
    the span code and definitions into separate files, whilst
    a 'net' bug fix made some changes to that moved code.
    
    The mlx5 infiniband conflict resolution was quite non-trivial,
    the RDMA tree's merge commit was used as a guide here, and
    here are their notes:
    
    ====================
    
        Due to bug fixes found by the syzkaller bot and taken into the for-rc
        branch after development for the 4.17 merge window had already started
        being taken into the for-next branch, there were fairly non-trivial
        merge issues that would need to be resolved between the for-rc branch
        and the for-next branch.  This merge resolves those conflicts and
        provides a unified base upon which ongoing development for 4.17 can
        be based.
    
        Conflicts:
                drivers/infiniband/hw/mlx5/main.c - Commit 42cea83f9524
                (IB/mlx5: Fix cleanup order on unload) added to for-rc and
                commit b5ca15ad7e61 (IB/mlx5: Add proper representors support)
                add as part of the devel cycle both needed to modify the
                init/de-init functions used by mlx5.  To support the new
                representors, the new functions added by the cleanup patch
                needed to be made non-static, and the init/de-init list
                added by the representors patch needed to be modified to
                match the init/de-init list changes made by the cleanup
                patch.
        Updates:
                drivers/infiniband/hw/mlx5/mlx5_ib.h - Update function
                prototypes added by representors patch to reflect new function
                names as changed by cleanup patch
                drivers/infiniband/hw/mlx5/ib_rep.c - Update init/de-init
                stage list to match new order from cleanup patch
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit bf2ae2e4bf9360e07c0cdfa166bcdc0afd92f4ce
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Mar 10 18:57:50 2018 +0800

    sock_diag: request _diag module only when the family or proto has been registered
    
    Now when using 'ss' in iproute, kernel would try to load all _diag
    modules, which also causes corresponding family and proto modules
    to be loaded as well due to module dependencies.
    
    Like after running 'ss', sctp, dccp, af_packet (if it works as a module)
    would be loaded.
    
    For example:
    
      $ lsmod|grep sctp
      $ ss
      $ lsmod|grep sctp
      sctp_diag              16384  0
      sctp                  323584  5 sctp_diag
      inet_diag              24576  4 raw_diag,tcp_diag,sctp_diag,udp_diag
      libcrc32c              16384  3 nf_conntrack,nf_nat,sctp
    
    As these family and proto modules are loaded unintentionally, it
    could cause some problems, like:
    
    - Some debug tools use 'ss' to collect the socket info, which loads all
      those diag and family and protocol modules. It's noisy for identifying
      issues.
    
    - Users usually expect to drop sctp init packet silently when they
      have no sense of sctp protocol instead of sending abort back.
    
    - It wastes resources (especially with multiple netns), and SCTP module
      can't be unloaded once it's loaded.
    
    ...
    
    In short, it's really inappropriate to have these family and proto
    modules loaded unexpectedly when just doing debugging with inet_diag.
    
    This patch is to introduce sock_load_diag_module() where it loads
    the _diag module only when it's corresponding family or proto has
    been already registered.
    
    Note that we can't just load _diag module without the family or
    proto loaded, as some symbols used in _diag module are from the
    family or proto module.
    
    v1->v2:
      - move inet proto check to inet_diag to avoid a compiling err.
    v2->v3:
      - define sock_load_diag_module in sock.c and export one symbol
        only.
      - improve the changelog.
    
    Reported-by: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Phil Sutter <phil@nwl.cc>
    Acked-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 91216b16feb7..2a0391eea05c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -222,6 +222,7 @@ enum {
 int sock_wake_async(struct socket_wq *sk_wq, int how, int band);
 int sock_register(const struct net_proto_family *fam);
 void sock_unregister(int family);
+bool sock_is_registered(int family);
 int __sock_create(struct net *net, int family, int type, int proto,
 		  struct socket **res, int kern);
 int sock_create(int family, int type, int proto, struct socket **res);

commit 9b2c45d479d0fb8647c9e83359df69162b5fbe5f
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Mon Feb 12 20:00:20 2018 +0100

    net: make getname() functions return length rather than use int* parameter
    
    Changes since v1:
    Added changes in these files:
        drivers/infiniband/hw/usnic/usnic_transport.c
        drivers/staging/lustre/lnet/lnet/lib-socket.c
        drivers/target/iscsi/iscsi_target_login.c
        drivers/vhost/net.c
        fs/dlm/lowcomms.c
        fs/ocfs2/cluster/tcp.c
        security/tomoyo/network.c
    
    Before:
    All these functions either return a negative error indicator,
    or store length of sockaddr into "int *socklen" parameter
    and return zero on success.
    
    "int *socklen" parameter is awkward. For example, if caller does not
    care, it still needs to provide on-stack storage for the value
    it does not need.
    
    None of the many FOO_getname() functions of various protocols
    ever used old value of *socklen. They always just overwrite it.
    
    This change drops this parameter, and makes all these functions, on success,
    return length of sockaddr. It's always >= 0 and can be differentiated
    from an error.
    
    Tests in callers are changed from "if (err)" to "if (err < 0)", where needed.
    
    rpc_sockname() lost "int buflen" parameter, since its only use was
    to be passed to kernel_getsockname() as &buflen and subsequently
    not used in any way.
    
    Userspace API is not changed.
    
        text    data     bss      dec     hex filename
    30108430 2633624  873672 33615726 200ef6e vmlinux.before.o
    30108109 2633612  873672 33615393 200ee21 vmlinux.o
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: linux-kernel@vger.kernel.org
    CC: netdev@vger.kernel.org
    CC: linux-bluetooth@vger.kernel.org
    CC: linux-decnet-user@lists.sourceforge.net
    CC: linux-wireless@vger.kernel.org
    CC: linux-rdma@vger.kernel.org
    CC: linux-sctp@vger.kernel.org
    CC: linux-nfs@vger.kernel.org
    CC: linux-x25@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 91216b16feb7..000d1aada74f 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -146,7 +146,7 @@ struct proto_ops {
 				      struct socket *newsock, int flags, bool kern);
 	int		(*getname)   (struct socket *sock,
 				      struct sockaddr *addr,
-				      int *sockaddr_len, int peer);
+				      int peer);
 	__poll_t	(*poll)	     (struct file *file, struct socket *sock,
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
@@ -294,10 +294,8 @@ int kernel_listen(struct socket *sock, int backlog);
 int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
 int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
 		   int flags);
-int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
-		       int *addrlen);
-int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
-		       int *addrlen);
+int kernel_getsockname(struct socket *sock, struct sockaddr *addr);
+int kernel_getpeername(struct socket *sock, struct sockaddr *addr);
 int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
 		      int *optlen);
 int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,

commit b2fe5fa68642860e7de76167c3111623aa0d5de1
Merge: a103950e0dd2 a54667f6728c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 14:31:10 2018 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
    
     1) Significantly shrink the core networking routing structures. Result
        of http://vger.kernel.org/~davem/seoul2017_netdev_keynote.pdf
    
     2) Add netdevsim driver for testing various offloads, from Jakub
        Kicinski.
    
     3) Support cross-chip FDB operations in DSA, from Vivien Didelot.
    
     4) Add a 2nd listener hash table for TCP, similar to what was done for
        UDP. From Martin KaFai Lau.
    
     5) Add eBPF based queue selection to tun, from Jason Wang.
    
     6) Lockless qdisc support, from John Fastabend.
    
     7) SCTP stream interleave support, from Xin Long.
    
     8) Smoother TCP receive autotuning, from Eric Dumazet.
    
     9) Lots of erspan tunneling enhancements, from William Tu.
    
    10) Add true function call support to BPF, from Alexei Starovoitov.
    
    11) Add explicit support for GRO HW offloading, from Michael Chan.
    
    12) Support extack generation in more netlink subsystems. From Alexander
        Aring, Quentin Monnet, and Jakub Kicinski.
    
    13) Add 1000BaseX, flow control, and EEE support to mvneta driver. From
        Russell King.
    
    14) Add flow table abstraction to netfilter, from Pablo Neira Ayuso.
    
    15) Many improvements and simplifications to the NFP driver bpf JIT,
        from Jakub Kicinski.
    
    16) Support for ipv6 non-equal cost multipath routing, from Ido
        Schimmel.
    
    17) Add resource abstration to devlink, from Arkadi Sharshevsky.
    
    18) Packet scheduler classifier shared filter block support, from Jiri
        Pirko.
    
    19) Avoid locking in act_csum, from Davide Caratti.
    
    20) devinet_ioctl() simplifications from Al viro.
    
    21) More TCP bpf improvements from Lawrence Brakmo.
    
    22) Add support for onlink ipv6 route flag, similar to ipv4, from David
        Ahern.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1925 commits)
      tls: Add support for encryption using async offload accelerator
      ip6mr: fix stale iterator
      net/sched: kconfig: Remove blank help texts
      openvswitch: meter: Use 64-bit arithmetic instead of 32-bit
      tcp_nv: fix potential integer overflow in tcpnv_acked
      r8169: fix RTL8168EP take too long to complete driver initialization.
      qmi_wwan: Add support for Quectel EP06
      rtnetlink: enable IFLA_IF_NETNSID for RTM_NEWLINK
      ipmr: Fix ptrdiff_t print formatting
      ibmvnic: Wait for device response when changing MAC
      qlcnic: fix deadlock bug
      tcp: release sk_frag.page in tcp_disconnect
      ipv4: Get the address of interface correctly.
      net_sched: gen_estimator: fix lockdep splat
      net: macb: Handle HRESP error
      net/mlx5e: IPoIB, Fix copy-paste bug in flow steering refactoring
      ipv6: addrconf: break critical section in addrconf_verify_rtnl()
      ipv6: change route cache aging logic
      i40e/i40evf: Update DESC_NEEDED value to reflect larger value
      bnxt_en: cleanup DIM work on device shutdown
      ...

commit 5c59e564e46dcbab2ee7a4e9e0243562a39679a2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 1 18:46:30 2017 -0400

    kill kernel_sock_ioctl()
    
    no users since 2014
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/net.h b/include/linux/net.h
index caeb159abda5..68acc54976bf 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -306,7 +306,6 @@ int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 		    size_t size, int flags);
 int kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,
 			   size_t size, int flags);
-int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 
 /* Routine returns the IP overhead imposed by a (caller-protected) socket. */

commit a3f8683bf7d5e6254fe68f5c5d3585e27eea8ed0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 22:22:01 2017 -0400

    ->poll() methods should return __poll_t
    
    The most common place to find POLL... bitmaps: return values
    of ->poll() and its subsystem counterparts.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/net.h b/include/linux/net.h
index caeb159abda5..c2d468cb9821 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -147,7 +147,7 @@ struct proto_ops {
 	int		(*getname)   (struct socket *sock,
 				      struct sockaddr *addr,
 				      int *sockaddr_len, int peer);
-	unsigned int	(*poll)	     (struct file *file, struct socket *sock,
+	__poll_t	(*poll)	     (struct file *file, struct socket *sock,
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
 				      unsigned long arg);

commit 4950276672fce5c241857540f8561c440663673d
Author: Levin, Alexander (Sasha Levin) <alexander.levin@verizon.com>
Date:   Wed Nov 15 17:35:51 2017 -0800

    kmemcheck: remove annotations
    
    Patch series "kmemcheck: kill kmemcheck", v2.
    
    As discussed at LSF/MM, kill kmemcheck.
    
    KASan is a replacement that is able to work without the limitation of
    kmemcheck (single CPU, slow).  KASan is already upstream.
    
    We are also not aware of any users of kmemcheck (or users who don't
    consider KASan as a suitable replacement).
    
    The only objection was that since KASAN wasn't supported by all GCC
    versions provided by distros at that time we should hold off for 2
    years, and try again.
    
    Now that 2 years have passed, and all distros provide gcc that supports
    KASAN, kill kmemcheck again for the very same reasons.
    
    This patch (of 4):
    
    Remove kmemcheck annotations, and calls to kmemcheck from the kernel.
    
    [alexander.levin@verizon.com: correctly remove kmemcheck call from dma_map_sg_attrs]
      Link: http://lkml.kernel.org/r/20171012192151.26531-1-alexander.levin@verizon.com
    Link: http://lkml.kernel.org/r/20171007030159.22241-2-alexander.levin@verizon.com
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tim Hansen <devtimhansen@gmail.com>
    Cc: Vegard Nossum <vegardno@ifi.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index d97d80d7fdf8..caeb159abda5 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -22,7 +22,6 @@
 #include <linux/random.h>
 #include <linux/wait.h>
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
-#include <linux/kmemcheck.h>
 #include <linux/rcupdate.h>
 #include <linux/once.h>
 #include <linux/fs.h>
@@ -111,9 +110,7 @@ struct socket_wq {
 struct socket {
 	socket_state		state;
 
-	kmemcheck_bitfield_begin(type);
 	short			type;
-	kmemcheck_bitfield_end(type);
 
 	unsigned long		flags;
 

commit 463910e2dff580e4e9a678af710b4818b5189691
Merge: 22cb7a3ac380 510c8a899caf
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 15 20:23:23 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit b3dc8f772fab5b2d284b780830fd56494491e493
Author: Tonghao Zhang <xiangxia.m.yue@gmail.com>
Date:   Tue Aug 15 04:28:54 2017 -0700

    net: Fix a typo in comment about sock flags.
    
    Signed-off-by: Tonghao Zhang <xiangxia.m.yue@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index dda2cc939a53..ebeb48c92005 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -37,7 +37,7 @@ struct net;
 
 /* Historically, SOCKWQ_ASYNC_NOSPACE & SOCKWQ_ASYNC_WAITDATA were located
  * in sock->flags, but moved into sk->sk_wq->flags to be RCU protected.
- * Eventually all flags will be in sk->sk_wq_flags.
+ * Eventually all flags will be in sk->sk_wq->flags.
  */
 #define SOCKWQ_ASYNC_NOSPACE	0
 #define SOCKWQ_ASYNC_WAITDATA	1

commit 306b13eb3cf9515a8214bbf5d69d811371d05792
Author: Tom Herbert <tom@quantonium.net>
Date:   Fri Jul 28 16:22:41 2017 -0700

    proto_ops: Add locked held versions of sendmsg and sendpage
    
    Add new proto_ops sendmsg_locked and sendpage_locked that can be
    called when the socket lock is already held. Correspondingly, add
    kernel_sendmsg_locked and kernel_sendpage_locked as front end
    functions.
    
    These functions will be used in zero proxy so that we can take
    the socket lock in a ULP sendmsg/sendpage and then directly call the
    backend transport proto_ops functions.
    
    Signed-off-by: Tom Herbert <tom@quantonium.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index dda2cc939a53..b5c15b31709b 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -190,8 +190,16 @@ struct proto_ops {
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 	int		(*set_peek_off)(struct sock *sk, int val);
 	int		(*peek_len)(struct socket *sock);
+
+	/* The following functions are called internally by kernel with
+	 * sock lock already held.
+	 */
 	int		(*read_sock)(struct sock *sk, read_descriptor_t *desc,
 				     sk_read_actor_t recv_actor);
+	int		(*sendpage_locked)(struct sock *sk, struct page *page,
+					   int offset, size_t size, int flags);
+	int		(*sendmsg_locked)(struct sock *sk, struct msghdr *msg,
+					  size_t size);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\
@@ -279,6 +287,8 @@ do {									\
 
 int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 		   size_t num, size_t len);
+int kernel_sendmsg_locked(struct sock *sk, struct msghdr *msg,
+			  struct kvec *vec, size_t num, size_t len);
 int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 		   size_t num, size_t len, int flags);
 
@@ -297,6 +307,8 @@ int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
 		      unsigned int optlen);
 int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 		    size_t size, int flags);
+int kernel_sendpage_locked(struct sock *sk, struct page *page, int offset,
+			   size_t size, int flags);
 int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 

commit da9ba564bd683374b8d319756f312821b8265b06
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 7 20:05:02 2017 -0400

    random: add get_random_{bytes,u32,u64,int,long,once}_wait family
    
    These functions are simple convenience wrappers that call
    wait_for_random_bytes before calling the respective get_random_*
    function.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/net.h b/include/linux/net.h
index abcfa46a2bd9..dda2cc939a53 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -274,6 +274,8 @@ do {									\
 
 #define net_get_random_once(buf, nbytes)			\
 	get_random_once((buf), (nbytes))
+#define net_get_random_once_wait(buf, nbytes)			\
+	get_random_once_wait((buf), (nbytes))
 
 int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 		   size_t num, size_t len);

commit 57240d007816486131bee88cd474c2a71f0fe224
Author: R. Parameswaran <parameswaran.r7@gmail.com>
Date:   Wed Apr 12 18:31:04 2017 -0700

    l2tp: device MTU setup, tunnel socket needs a lock
    
    The MTU overhead calculation in L2TP device set-up
    merged via commit b784e7ebfce8cfb16c6f95e14e8532d0768ab7ff
    needs to be adjusted to lock the tunnel socket while
    referencing the sub-data structures to derive the
    socket's IP overhead.
    
    Reported-by: Guillaume Nault <g.nault@alphalink.fr>
    Tested-by: Guillaume Nault <g.nault@alphalink.fr>
    Signed-off-by: R. Parameswaran <rparames@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index a42fab24c8af..abcfa46a2bd9 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -298,7 +298,7 @@ int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 
-/* Following routine returns the IP overhead imposed by a socket.  */
+/* Routine returns the IP overhead imposed by a (caller-protected) socket. */
 u32 kernel_sock_ip_overhead(struct sock *sk);
 
 #define MODULE_ALIAS_NETPROTO(proto) \

commit 113c3075931a334f899008f6c753abe70a3a9323
Author: R. Parameswaran <parameswaran.r7@gmail.com>
Date:   Wed Apr 5 16:50:35 2017 -0700

    New kernel function to get IP overhead on a socket.
    
    A new function, kernel_sock_ip_overhead(), is provided
    to calculate the cumulative overhead imposed by the IP
    Header and IP options, if any, on a socket's payload.
    The new function returns an overhead of zero for sockets
    that do not belong to the IPv4 or IPv6 address families.
    This is used in the L2TP code path to compute the
    total outer IP overhead on the L2TP tunnel socket when
    calculating the default MTU for Ethernet pseudowires.
    
    Signed-off-by: R. Parameswaran <rparames@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 0620f5e18c96..a42fab24c8af 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -298,6 +298,9 @@ int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 
+/* Following routine returns the IP overhead imposed by a socket.  */
+u32 kernel_sock_ip_overhead(struct sock *sk);
+
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))
 

commit cdfbabfb2f0ce983fdaa42f20e5f7842178fc01e
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 9 08:09:05 2017 +0000

    net: Work around lockdep limitation in sockets that use sockets
    
    Lockdep issues a circular dependency warning when AFS issues an operation
    through AF_RXRPC from a context in which the VFS/VM holds the mmap_sem.
    
    The theory lockdep comes up with is as follows:
    
     (1) If the pagefault handler decides it needs to read pages from AFS, it
         calls AFS with mmap_sem held and AFS begins an AF_RXRPC call, but
         creating a call requires the socket lock:
    
            mmap_sem must be taken before sk_lock-AF_RXRPC
    
     (2) afs_open_socket() opens an AF_RXRPC socket and binds it.  rxrpc_bind()
         binds the underlying UDP socket whilst holding its socket lock.
         inet_bind() takes its own socket lock:
    
            sk_lock-AF_RXRPC must be taken before sk_lock-AF_INET
    
     (3) Reading from a TCP socket into a userspace buffer might cause a fault
         and thus cause the kernel to take the mmap_sem, but the TCP socket is
         locked whilst doing this:
    
            sk_lock-AF_INET must be taken before mmap_sem
    
    However, lockdep's theory is wrong in this instance because it deals only
    with lock classes and not individual locks.  The AF_INET lock in (2) isn't
    really equivalent to the AF_INET lock in (3) as the former deals with a
    socket entirely internal to the kernel that never sees userspace.  This is
    a limitation in the design of lockdep.
    
    Fix the general case by:
    
     (1) Double up all the locking keys used in sockets so that one set are
         used if the socket is created by userspace and the other set is used
         if the socket is created by the kernel.
    
     (2) Store the kern parameter passed to sk_alloc() in a variable in the
         sock struct (sk_kern_sock).  This informs sock_lock_init(),
         sock_init_data() and sk_clone_lock() as to the lock keys to be used.
    
         Note that the child created by sk_clone_lock() inherits the parent's
         kern setting.
    
     (3) Add a 'kern' parameter to ->accept() that is analogous to the one
         passed in to ->create() that distinguishes whether kernel_accept() or
         sys_accept4() was the caller and can be passed to sk_alloc().
    
         Note that a lot of accept functions merely dequeue an already
         allocated socket.  I haven't touched these as the new socket already
         exists before we get the parameter.
    
         Note also that there are a couple of places where I've made the accepted
         socket unconditionally kernel-based:
    
            irda_accept()
            rds_rcp_accept_one()
            tcp_accept_from_sock()
    
         because they follow a sock_create_kern() and accept off of that.
    
    Whilst creating this, I noticed that lustre and ocfs don't create sockets
    through sock_create_kern() and thus they aren't marked as for-kernel,
    though they appear to be internal.  I wonder if these should do that so
    that they use the new set of lock keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index cd0c8bd0a1de..0620f5e18c96 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -146,7 +146,7 @@ struct proto_ops {
 	int		(*socketpair)(struct socket *sock1,
 				      struct socket *sock2);
 	int		(*accept)    (struct socket *sock,
-				      struct socket *newsock, int flags);
+				      struct socket *newsock, int flags, bool kern);
 	int		(*getname)   (struct socket *sock,
 				      struct sockaddr *addr,
 				      int *sockaddr_len, int peer);

commit 0294b625ad5a6d1fb50632d67cf384862d8a4a46
Author: Tom Herbert <tom@herbertland.com>
Date:   Sun Aug 28 14:43:17 2016 -0700

    net: Add read_sock proto_op
    
    Add new function in proto_ops structure. This includes moving the
    typedef got sk_read_actor into net.h and removing the definition from
    tcp.h.
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index b9f0ff4d489c..cd0c8bd0a1de 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -25,6 +25,7 @@
 #include <linux/kmemcheck.h>
 #include <linux/rcupdate.h>
 #include <linux/once.h>
+#include <linux/fs.h>
 
 #include <uapi/linux/net.h>
 
@@ -128,6 +129,9 @@ struct page;
 struct sockaddr;
 struct msghdr;
 struct module;
+struct sk_buff;
+typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *,
+			       unsigned int, size_t);
 
 struct proto_ops {
 	int		family;
@@ -186,6 +190,8 @@ struct proto_ops {
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 	int		(*set_peek_off)(struct sock *sk, int val);
 	int		(*peek_len)(struct socket *sock);
+	int		(*read_sock)(struct sock *sk, read_descriptor_t *desc,
+				     sk_read_actor_t recv_actor);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\

commit 1576d98605998fb59d121a39581129e134217182
Author: Jason Wang <jasowang@redhat.com>
Date:   Thu Jun 30 14:45:36 2016 +0800

    tun: switch to use skb array for tx
    
    We used to queue tx packets in sk_receive_queue, this is less
    efficient since it requires spinlocks to synchronize between producer
    and consumer.
    
    This patch tries to address this by:
    
    - switch from sk_receive_queue to a skb_array, and resize it when
      tx_queue_len was changed.
    - introduce a new proto_ops peek_len which was used for peeking the
      skb length.
    - implement a tun version of peek_len for vhost_net to use and convert
      vhost_net to use peek_len if possible.
    
    Pktgen test shows about 15.3% improvement on guest receiving pps for small
    buffers:
    
    Before: ~1300000pps
    After : ~1500000pps
    
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 25aa03b51c4e..b9f0ff4d489c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -185,6 +185,7 @@ struct proto_ops {
 	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 	int		(*set_peek_off)(struct sock *sk, int val);
+	int		(*peek_len)(struct socket *sock);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\

commit daddef76c3deaaa7922f9d7b18edbf0a061215c3
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 15 11:14:53 2016 +0200

    net: Don't forget pr_fmt on net_dbg_ratelimited for CONFIG_DYNAMIC_DEBUG
    
    The implementation of net_dbg_ratelimited in the CONFIG_DYNAMIC_DEBUG
    case was added with 2c94b5373 ("net: Implement net_dbg_ratelimited() for
    CONFIG_DYNAMIC_DEBUG case"). The implementation strategy was to take the
    usual definition of the dynamic_pr_debug macro, but alter it by adding a
    call to "net_ratelimit()" in the if statement. This is, in fact, the
    correct approach.
    
    However, while doing this, the author of the commit forgot to surround
    fmt by pr_fmt, resulting in unprefixed log messages appearing in the
    console. So, this commit adds back the pr_fmt(fmt) invocation, making
    net_dbg_ratelimited properly consistent across DEBUG, no DEBUG, and
    DYNAMIC_DEBUG cases, and bringing parity with the behavior of
    dynamic_pr_debug as well.
    
    Fixes: 2c94b5373 ("net: Implement net_dbg_ratelimited() for CONFIG_DYNAMIC_DEBUG case")
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Tim Bingham <tbingham@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 9aa49a05fe38..25aa03b51c4e 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -251,7 +251,8 @@ do {									\
 	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
 	if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT) &&	\
 	    net_ratelimit())						\
-		__dynamic_pr_debug(&descriptor, fmt, ##__VA_ARGS__);	\
+		__dynamic_pr_debug(&descriptor, pr_fmt(fmt),		\
+		                   ##__VA_ARGS__);			\
 } while (0)
 #elif defined(DEBUG)
 #define net_dbg_ratelimited(fmt, ...)				\

commit cba653210056cf47cc1969f831f05ddfb99ee2bd
Merge: 26879da58711 7391daf2ffc7
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 4 00:52:29 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            net/ipv4/ip_gre.c
    
    Minor conflicts between tunnel bug fixes in net and
    ipv6 tunnel cleanups in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2c94b53738549d81dc7464a32117d1f5112c64d3
Author: Tim Bingham <tbingham@akamai.com>
Date:   Fri Apr 29 13:30:23 2016 -0400

    net: Implement net_dbg_ratelimited() for CONFIG_DYNAMIC_DEBUG case
    
    Prior to commit d92cff89a0c8 ("net_dbg_ratelimited: turn into no-op
    when !DEBUG") the implementation of net_dbg_ratelimited() was buggy
    for both the DEBUG and CONFIG_DYNAMIC_DEBUG cases.
    
    The bug was that net_ratelimit() was being called and, despite
    returning true, nothing was being printed to the console. This
    resulted in messages like the following -
    
    "net_ratelimit: %d callbacks suppressed"
    
    with no other output nearby.
    
    After commit d92cff89a0c8 ("net_dbg_ratelimited: turn into no-op when
    !DEBUG") the bug is fixed for the DEBUG case. However, there's no
    output at all for CONFIG_DYNAMIC_DEBUG case.
    
    This patch restores debug output (if enabled) for the
    CONFIG_DYNAMIC_DEBUG case.
    
    Add a definition of net_dbg_ratelimited() for the CONFIG_DYNAMIC_DEBUG
    case. The implementation takes care to check that dynamic debugging is
    enabled before calling net_ratelimit().
    
    Fixes: d92cff89a0c8 ("net_dbg_ratelimited: turn into no-op when !DEBUG")
    Signed-off-by: Tim Bingham <tbingham@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 49175e4ced11..f840d77c6c31 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -246,7 +246,15 @@ do {								\
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
-#if defined(DEBUG)
+#if defined(CONFIG_DYNAMIC_DEBUG)
+#define net_dbg_ratelimited(fmt, ...)					\
+do {									\
+	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\
+	if (unlikely(descriptor.flags & _DPRINTK_FLAGS_PRINT) &&	\
+	    net_ratelimit())						\
+		__dynamic_pr_debug(&descriptor, fmt, ##__VA_ARGS__);	\
+} while (0)
+#elif defined(DEBUG)
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
 #else

commit 2da62906b1e298695e1bb725927041cd59942c98
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 14 21:13:46 2015 -0400

    [net] drop 'size' argument of sock_recvmsg()
    
    all callers have it equal to msg_data_left(msg).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/net.h b/include/linux/net.h
index 49175e4ced11..72c1e0622ce2 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -218,8 +218,7 @@ int sock_create_lite(int family, int type, int proto, struct socket **res);
 struct socket *sock_alloc(void);
 void sock_release(struct socket *sock);
 int sock_sendmsg(struct socket *sock, struct msghdr *msg);
-int sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
-		 int flags);
+int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags);
 struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);
 struct socket *sockfd_lookup(int fd, int *err);
 struct socket *sock_from_file(struct file *file, int *err);

commit f4a00aacdb5f6784d46e8c999b6bb52ece4b306b
Author: Tom Herbert <tom@herbertland.com>
Date:   Mon Mar 7 14:11:01 2016 -0800

    net: Make sock_alloc exportable
    
    Export it for cases where we want to create sockets by hand.
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 0b4ac7da583a..49175e4ced11 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -215,6 +215,7 @@ int __sock_create(struct net *net, int family, int type, int proto,
 int sock_create(int family, int type, int proto, struct socket **res);
 int sock_create_kern(struct net *net, int family, int type, int proto, struct socket **res);
 int sock_create_lite(int family, int type, int proto, struct socket **res);
+struct socket *sock_alloc(void);
 void sock_release(struct socket *sock);
 int sock_sendmsg(struct socket *sock, struct msghdr *msg);
 int sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,

commit ceb5d58b217098a657f3850b7a2640f995032e62
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Nov 29 20:03:11 2015 -0800

    net: fix sock_wake_async() rcu protection
    
    Dmitry provided a syzkaller (http://github.com/google/syzkaller)
    triggering a fault in sock_wake_async() when async IO is requested.
    
    Said program stressed af_unix sockets, but the issue is generic
    and should be addressed in core networking stack.
    
    The problem is that by the time sock_wake_async() is called,
    we should not access the @flags field of 'struct socket',
    as the inode containing this socket might be freed without
    further notice, and without RCU grace period.
    
    We already maintain an RCU protected structure, "struct socket_wq"
    so moving SOCKWQ_ASYNC_NOSPACE & SOCKWQ_ASYNC_WAITDATA into it
    is the safe route.
    
    It also reduces number of cache lines needing dirtying, so might
    provide a performance improvement anyway.
    
    In followup patches, we might move remaining flags (SOCK_NOSPACE,
    SOCK_PASSCRED, SOCK_PASSSEC) to save 8 bytes and let 'struct socket'
    being mostly read and let it being shared between cpus.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index f514e4dd5521..0b4ac7da583a 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -34,6 +34,10 @@ struct inode;
 struct file;
 struct net;
 
+/* Historically, SOCKWQ_ASYNC_NOSPACE & SOCKWQ_ASYNC_WAITDATA were located
+ * in sock->flags, but moved into sk->sk_wq->flags to be RCU protected.
+ * Eventually all flags will be in sk->sk_wq_flags.
+ */
 #define SOCKWQ_ASYNC_NOSPACE	0
 #define SOCKWQ_ASYNC_WAITDATA	1
 #define SOCK_NOSPACE		2
@@ -89,6 +93,7 @@ struct socket_wq {
 	/* Note: wait MUST be first field of socket_wq */
 	wait_queue_head_t	wait;
 	struct fasync_struct	*fasync_list;
+	unsigned long		flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */
 	struct rcu_head		rcu;
 } ____cacheline_aligned_in_smp;
 
@@ -202,7 +207,7 @@ enum {
 	SOCK_WAKE_URG,
 };
 
-int sock_wake_async(struct socket *sk, int how, int band);
+int sock_wake_async(struct socket_wq *sk_wq, int how, int band);
 int sock_register(const struct net_proto_family *fam);
 void sock_unregister(int family);
 int __sock_create(struct net *net, int family, int type, int proto,

commit 9cd3e072b0be17446e37d7414eac8a3499e0601e
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Nov 29 20:03:10 2015 -0800

    net: rename SOCK_ASYNC_NOSPACE and SOCK_ASYNC_WAITDATA
    
    This patch is a cleanup to make following patch easier to
    review.
    
    Goal is to move SOCK_ASYNC_NOSPACE and SOCK_ASYNC_WAITDATA
    from (struct socket)->flags to a (struct socket_wq)->flags
    to benefit from RCU protection in sock_wake_async()
    
    To ease backports, we rename both constants.
    
    Two new helpers, sk_set_bit(int nr, struct sock *sk)
    and sk_clear_bit(int net, struct sock *sk) are added so that
    following patch can change their implementation.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 70ac5e28e6b7..f514e4dd5521 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -34,8 +34,8 @@ struct inode;
 struct file;
 struct net;
 
-#define SOCK_ASYNC_NOSPACE	0
-#define SOCK_ASYNC_WAITDATA	1
+#define SOCKWQ_ASYNC_NOSPACE	0
+#define SOCKWQ_ASYNC_WAITDATA	1
 #define SOCK_NOSPACE		2
 #define SOCK_PASSCRED		3
 #define SOCK_PASSSEC		4
@@ -96,7 +96,7 @@ struct socket_wq {
  *  struct socket - general BSD socket
  *  @state: socket state (%SS_CONNECTED, etc)
  *  @type: socket type (%SOCK_STREAM, etc)
- *  @flags: socket flags (%SOCK_ASYNC_NOSPACE, etc)
+ *  @flags: socket flags (%SOCK_NOSPACE, etc)
  *  @ops: protocol specific socket operations
  *  @file: File back pointer for gc
  *  @sk: internal networking protocol agnostic socket representation

commit 46234253b9363894a254844a6550b4cc5f3edfe8
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Oct 8 01:20:35 2015 +0200

    net: move net_get_random_once to lib
    
    There's no good reason why users outside of networking should not
    be using this facility, f.e. for initializing their seeds.
    
    Therefore, make it accessible from there as get_random_once().
    
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 049d4b03c4c4..70ac5e28e6b7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -24,7 +24,8 @@
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <linux/kmemcheck.h>
 #include <linux/rcupdate.h>
-#include <linux/jump_label.h>
+#include <linux/once.h>
+
 #include <uapi/linux/net.h>
 
 struct poll_table_struct;
@@ -250,22 +251,8 @@ do {								\
 	} while (0)
 #endif
 
-bool __net_get_random_once(void *buf, int nbytes, bool *done,
-			   struct static_key *done_key);
-
-#define net_get_random_once(buf, nbytes)				\
-	({								\
-		bool ___ret = false;					\
-		static bool ___done = false;				\
-		static struct static_key ___once_key =			\
-			STATIC_KEY_INIT_TRUE;				\
-		if (static_key_true(&___once_key))			\
-			___ret = __net_get_random_once(buf,		\
-						       nbytes,		\
-						       &___done,	\
-						       &___once_key);	\
-		___ret;							\
-	})
+#define net_get_random_once(buf, nbytes)			\
+	get_random_once((buf), (nbytes))
 
 int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 		   size_t num, size_t len);

commit d92cff89a0c80e7e49796366e441d97f07b5d321
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Aug 4 18:26:19 2015 +0200

    net_dbg_ratelimited: turn into no-op when !DEBUG
    
    The pr_debug family of functions turns into a no-op when -DDEBUG is not
    specified, opting instead to call "no_printk", which gets compiled to a
    no-op (but retains gcc's nice warnings about printf-style arguments).
    
    The problem with net_dbg_ratelimited is that it is defined to be a
    variant of net_ratelimited_function, which expands to essentially:
    
        if (net_ratelimit())
            pr_debug(fmt, ...);
    
    When DEBUG is not defined, then this becomes,
    
        if (net_ratelimit())
            ;
    
    This seems benign, except it isn't. Firstly, there's the obvious
    overhead of calling net_ratelimit needlessly, which does quite some book
    keeping for the rate limiting. Given that the pr_debug and
    net_dbg_ratelimited family of functions are sprinkled liberally through
    performance critical code, with developers assuming they'll be compiled
    out to a no-op most of the time, we certainly do not want this needless
    book keeping. Secondly, and most visibly, even though no debug message
    is printed when DEBUG is not defined, if there is a flood of
    invocations, dmesg winds up peppered with messages such as
    "net_ratelimit: 320 callbacks suppressed". This is because our
    aforementioned net_ratelimit() function actually prints this text in
    some circumstances. It's especially odd to see this when there isn't any
    other accompanying debug message.
    
    So, in sum, it doesn't make sense to have this function's current
    behavior, and instead it should match what every other debug family of
    functions in the kernel does with !DEBUG -- nothing.
    
    This patch replaces calls to net_dbg_ratelimited when !DEBUG with
    no_printk, keeping with the idiom of all the other debug print helpers.
    
    Also, though not strictly neccessary, it guards the call with an if (0)
    so that all evaluation of any arguments are sure to be compiled out.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 04aa06852771..049d4b03c4c4 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -239,8 +239,16 @@ do {								\
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
+#if defined(DEBUG)
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
+#else
+#define net_dbg_ratelimited(fmt, ...)				\
+	do {							\
+		if (0)						\
+			no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__); \
+	} while (0)
+#endif
 
 bool __net_get_random_once(void *buf, int nbytes, bool *done,
 			   struct static_key *done_key);

commit eeb1bd5c40edb0e2fd925c8535e2fdebdbc5cef2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 8 21:08:05 2015 -0500

    net: Add a struct net parameter to sock_create_kern
    
    This is long overdue, and is part of cleaning up how we allocate kernel
    sockets that don't reference count struct net.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 8a5e81d2bdf7..04aa06852771 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -207,7 +207,7 @@ void sock_unregister(int family);
 int __sock_create(struct net *net, int family, int type, int proto,
 		  struct socket **res, int kern);
 int sock_create(int family, int type, int proto, struct socket **res);
-int sock_create_kern(int family, int type, int proto, struct socket **res);
+int sock_create_kern(struct net *net, int family, int type, int proto, struct socket **res);
 int sock_create_lite(int family, int type, int proto, struct socket **res);
 void sock_release(struct socket *sock);
 int sock_sendmsg(struct socket *sock, struct msghdr *msg);

commit 140e807da12988e2a925fe029336e7bb67a8d4de
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 8 21:07:08 2015 -0500

    tun: Utilize the normal socket network namespace refcounting.
    
    There is no need for tun to do the weird network namespace refcounting.
    The existing network namespace refcounting in tfile has almost exactly
    the same lifetime.  So rewrite the code to use the struct sock network
    namespace refcounting and remove the unnecessary hand rolled network
    namespace refcounting and the unncesary tfile->net.
    
    This change allows the tun code to directly call sock_put bypassing
    sock_release and making SOCK_EXTERNALLY_ALLOCATED unnecessary.
    
    Remove the now unncessary tun_release so that if anything tries to use
    the sock_release code path the kernel will oops, and let us know about
    the bug.
    
    The macvtap code already uses it's internal socket this way.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 738ea48be889..8a5e81d2bdf7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -38,7 +38,6 @@ struct net;
 #define SOCK_NOSPACE		2
 #define SOCK_PASSCRED		3
 #define SOCK_PASSSEC		4
-#define SOCK_EXTERNALLY_ALLOCATED 5
 
 #ifndef ARCH_HAS_SOCKET_TYPES
 /**

commit d8725c86aebaf3516e220760aaf5fefc73825188
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 11 00:02:50 2014 -0500

    get rid of the size argument of sock_sendmsg()
    
    it's equal to iov_iter_count(&msg->msg_iter) in all cases
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/net.h b/include/linux/net.h
index e74114bcca68..738ea48be889 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -211,7 +211,7 @@ int sock_create(int family, int type, int proto, struct socket **res);
 int sock_create_kern(int family, int type, int proto, struct socket **res);
 int sock_create_lite(int family, int type, int proto, struct socket **res);
 void sock_release(struct socket *sock);
-int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len);
+int sock_sendmsg(struct socket *sock, struct msghdr *msg);
 int sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
 		 int flags);
 struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);

commit 1b784140474e4fc94281a49e96c67d29df0efbde
Author: Ying Xue <ying.xue@windriver.com>
Date:   Mon Mar 2 15:37:48 2015 +0800

    net: Remove iocb argument from sendmsg and recvmsg
    
    After TIPC doesn't depend on iocb argument in its internal
    implementations of sendmsg() and recvmsg() hooks defined in proto
    structure, no any user is using iocb argument in them at all now.
    Then we can drop the redundant iocb argument completely from kinds of
    implementations of both sendmsg() and recvmsg() in the entire
    networking stack.
    
    Cc: Christoph Hellwig <hch@lst.de>
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 17d83393afcc..e74114bcca68 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -120,7 +120,6 @@ struct socket {
 
 struct vm_area_struct;
 struct page;
-struct kiocb;
 struct sockaddr;
 struct msghdr;
 struct module;
@@ -162,8 +161,8 @@ struct proto_ops {
 	int		(*compat_getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 #endif
-	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, size_t total_len);
+	int		(*sendmsg)   (struct socket *sock, struct msghdr *m,
+				      size_t total_len);
 	/* Notes for implementing recvmsg:
 	 * ===============================
 	 * msg->msg_namelen should get updated by the recvmsg handlers
@@ -172,9 +171,8 @@ struct proto_ops {
 	 * handlers can assume that msg.msg_name is either NULL or has
 	 * a minimum size of sizeof(struct sockaddr_storage).
 	 */
-	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, size_t total_len,
-				      int flags);
+	int		(*recvmsg)   (struct socket *sock, struct msghdr *m,
+				      size_t total_len, int flags);
 	int		(*mmap)	     (struct file *file, struct socket *sock,
 				      struct vm_area_struct * vma);
 	ssize_t		(*sendpage)  (struct socket *sock, struct page *page,

commit 3d4405226d27b3a215e4d03cfa51f536244e5de7
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Sun May 11 22:59:30 2014 +0200

    net: avoid dependency of net_get_random_once on nop patching
    
    net_get_random_once depends on the static keys infrastructure to patch up
    the branch to the slow path during boot. This was realized by abusing the
    static keys api and defining a new initializer to not enable the call
    site while still indicating that the branch point should get patched
    up. This was needed to have the fast path considered likely by gcc.
    
    The static key initialization during boot up normally walks through all
    the registered keys and either patches in ideal nops or enables the jump
    site but omitted that step on x86 if ideal nops where already placed at
    static_key branch points. Thus net_get_random_once branches not always
    became active.
    
    This patch switches net_get_random_once to the ordinary static_key
    api and thus places the kernel fast path in the - by gcc considered -
    unlikely path.  Microbenchmarks on Intel and AMD x86-64 showed that
    the unlikely path actually beats the likely path in terms of cycle cost
    and that different nop patterns did not make much difference, thus this
    switch should not be noticeable.
    
    Fixes: a48e42920ff38b ("net: introduce new macro net_get_random_once")
    Reported-by: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 94734a6259a4..17d83393afcc 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -248,24 +248,17 @@ do {								\
 bool __net_get_random_once(void *buf, int nbytes, bool *done,
 			   struct static_key *done_key);
 
-#ifdef HAVE_JUMP_LABEL
-#define ___NET_RANDOM_STATIC_KEY_INIT ((struct static_key) \
-		{ .enabled = ATOMIC_INIT(0), .entries = (void *)1 })
-#else /* !HAVE_JUMP_LABEL */
-#define ___NET_RANDOM_STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
-#endif /* HAVE_JUMP_LABEL */
-
 #define net_get_random_once(buf, nbytes)				\
 	({								\
 		bool ___ret = false;					\
 		static bool ___done = false;				\
-		static struct static_key ___done_key =			\
-			___NET_RANDOM_STATIC_KEY_INIT;			\
-		if (!static_key_true(&___done_key))			\
+		static struct static_key ___once_key =			\
+			STATIC_KEY_INIT_TRUE;				\
+		if (static_key_true(&___once_key))			\
 			___ret = __net_get_random_once(buf,		\
 						       nbytes,		\
 						       &___done,	\
-						       &___done_key);	\
+						       &___once_key);	\
 		___ret;							\
 	})
 

commit 63862b5bef7349dd1137e4c70702c67d77565785
Author: Aruna-Hewapathirane <aruna.hewapathirane@gmail.com>
Date:   Sat Jan 11 07:15:59 2014 -0500

    net: replace macros net_random and net_srandom with direct calls to prandom
    
    This patch removes the net_random and net_srandom macros and replaces
    them with direct calls to the prandom ones. As new commits only seem to
    use prandom_u32 there is no use to keep them around.
    This change makes it easier to grep for users of prandom_u32.
    
    Signed-off-by: Aruna-Hewapathirane <aruna.hewapathirane@gmail.com>
    Suggested-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 69be3e6079c8..94734a6259a4 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -245,9 +245,6 @@ do {								\
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
 
-#define net_random()		prandom_u32()
-#define net_srandom(seed)	prandom_seed((__force u32)(seed))
-
 bool __net_get_random_once(void *buf, int nbytes, bool *done,
 			   struct static_key *done_key);
 

commit 12663bfc97c8b3fdb292428105dd92d563164050
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Sat Dec 7 17:26:27 2013 -0500

    net: unix: allow set_peek_off to fail
    
    unix_dgram_recvmsg() will hold the readlock of the socket until recv
    is complete.
    
    In the same time, we may try to setsockopt(SO_PEEK_OFF) which will hang until
    unix_dgram_recvmsg() will complete (which can take a while) without allowing
    us to break out of it, triggering a hung task spew.
    
    Instead, allow set_peek_off to fail, this way userspace will not hang.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Acked-by: Pavel Emelyanov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4bcee94cef93..69be3e6079c8 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -181,7 +181,7 @@ struct proto_ops {
 				      int offset, size_t size, int flags);
 	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
-	void		(*set_peek_off)(struct sock *sk, int val);
+	int		(*set_peek_off)(struct sock *sk, int val);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\

commit f3d3342602f8bcbf37d7c46641cb9bca7618eb1c
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Nov 21 03:14:22 2013 +0100

    net: rework recvmsg handler msg_name and msg_namelen logic
    
    This patch now always passes msg->msg_namelen as 0. recvmsg handlers must
    set msg_namelen to the proper size <= sizeof(struct sockaddr_storage)
    to return msg_name to the user.
    
    This prevents numerous uninitialized memory leaks we had in the
    recvmsg handlers and makes it harder for new code to accidentally leak
    uninitialized memory.
    
    Optimize for the case recvfrom is called with NULL as address. We don't
    need to copy the address at all, so set it to NULL before invoking the
    recvmsg handler. We can do so, because all the recvmsg handlers must
    cope with the case a plain read() is called on them. read() also sets
    msg_name to NULL.
    
    Also document these changes in include/linux/net.h as suggested by David
    Miller.
    
    Changes since RFC:
    
    Set msg->msg_name = NULL if user specified a NULL in msg_name but had a
    non-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't
    affect sendto as it would bail out earlier while trying to copy-in the
    address. It also more naturally reflects the logic by the callers of
    verify_iovec.
    
    With this change in place I could remove "
    if (!uaddr || msg_sys->msg_namelen == 0)
            msg->msg_name = NULL
    ".
    
    This change does not alter the user visible error logic as we ignore
    msg_namelen as long as msg_name is NULL.
    
    Also remove two unnecessary curly brackets in ___sys_recvmsg and change
    comments to netdev style.
    
    Cc: David Miller <davem@davemloft.net>
    Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index b292a0435571..4bcee94cef93 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -164,6 +164,14 @@ struct proto_ops {
 #endif
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len);
+	/* Notes for implementing recvmsg:
+	 * ===============================
+	 * msg->msg_namelen should get updated by the recvmsg handlers
+	 * iff msg_name != NULL. It is by default 0 to prevent
+	 * returning uninitialized memory to user space.  The recvfrom
+	 * handlers can assume that msg.msg_name is either NULL or has
+	 * a minimum size of sizeof(struct sockaddr_storage).
+	 */
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len,
 				      int flags);

commit f84be2bd96a108b09c8440263fa3adb3fb225fa3
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Wed Oct 23 20:05:27 2013 +0200

    net: make net_get_random_once irq safe
    
    I initial build non irq safe version of net_get_random_once because I
    would liked to have the freedom to defer even the extraction process of
    get_random_bytes until the nonblocking pool is fully seeded.
    
    I don't think this is a good idea anymore and thus this patch makes
    net_get_random_once irq safe. Now someone using net_get_random_once does
    not need to care from where it is called.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index aca446b46754..b292a0435571 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -250,7 +250,6 @@ bool __net_get_random_once(void *buf, int nbytes, bool *done,
 #define ___NET_RANDOM_STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
 #endif /* HAVE_JUMP_LABEL */
 
-/* BE CAREFUL: this function is not interrupt safe */
 #define net_get_random_once(buf, nbytes)				\
 	({								\
 		bool ___ret = false;					\

commit c68c7f5a88328fbcd992c68e99ebd6bf7d49e9d2
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Sun Oct 20 06:26:02 2013 +0200

    net: fix build warnings because of net_get_random_once merge
    
    This patch fixes the following warning:
    
       In file included from include/linux/skbuff.h:27:0,
                        from include/linux/netfilter.h:5,
                        from include/net/netns/netfilter.h:5,
                        from include/net/net_namespace.h:20,
                        from include/linux/init_task.h:14,
                        from init/init_task.c:1:
    include/linux/net.h:243:14: warning: 'struct static_key' declared inside parameter list [enabled by default]
              struct static_key *done_key);
    
    on x86_64 allnoconfig, um defconfig and ia64 allmodconfig and maybe others as well.
    
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index a489705f6fa3..aca446b46754 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -24,6 +24,7 @@
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <linux/kmemcheck.h>
 #include <linux/rcupdate.h>
+#include <linux/jump_label.h>
 #include <uapi/linux/net.h>
 
 struct poll_table_struct;

commit a48e42920ff38bc90bbf75143fff4555723d4540
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Sat Oct 19 21:48:55 2013 +0200

    net: introduce new macro net_get_random_once
    
    net_get_random_once is a new macro which handles the initialization
    of secret keys. It is possible to call it in the fast path. Only the
    initialization depends on the spinlock and is rather slow. Otherwise
    it should get used just before the key is used to delay the entropy
    extration as late as possible to get better randomness. It returns true
    if the key got initialized.
    
    The usage of static_keys for net_get_random_once is a bit uncommon so
    it needs some further explanation why this actually works:
    
    === In the simple non-HAVE_JUMP_LABEL case we actually have ===
    no constrains to use static_key_(true|false) on keys initialized with
    STATIC_KEY_INIT_(FALSE|TRUE). So this path just expands in favor of
    the likely case that the initialization is already done. The key is
    initialized like this:
    
    ___done_key = { .enabled = ATOMIC_INIT(0) }
    
    The check
    
                    if (!static_key_true(&___done_key))                     \
    
    expands into (pseudo code)
    
                    if (!likely(___done_key > 0))
    
    , so we take the fast path as soon as ___done_key is increased from the
    helper function.
    
    === If HAVE_JUMP_LABELs are available this depends ===
    on patching of jumps into the prepared NOPs, which is done in
    jump_label_init at boot-up time (from start_kernel). It is forbidden
    and dangerous to use net_get_random_once in functions which are called
    before that!
    
    At compilation time NOPs are generated at the call sites of
    net_get_random_once. E.g. net/ipv6/inet6_hashtable.c:inet6_ehashfn (we
    need to call net_get_random_once two times in inet6_ehashfn, so two NOPs):
    
          71:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
          76:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    
    Both will be patched to the actual jumps to the end of the function to
    call __net_get_random_once at boot time as explained above.
    
    arch_static_branch is optimized and inlined for false as return value and
    actually also returns false in case the NOP is placed in the instruction
    stream. So in the fast case we get a "return false". But because we
    initialize ___done_key with (enabled != (entries & 1)) this call-site
    will get patched up at boot thus returning true. The final check looks
    like this:
    
                    if (!static_key_true(&___done_key))                     \
                            ___ret = __net_get_random_once(buf,             \
    
    expands to
    
                    if (!!static_key_false(&___done_key))                     \
                            ___ret = __net_get_random_once(buf,             \
    
    So we get true at boot time and as soon as static_key_slow_inc is called
    on the key it will invert the logic and return false for the fast path.
    static_key_slow_inc will change the branch because it got initialized
    with .enabled == 0. After static_key_slow_inc is called on the key the
    branch is replaced with a nop again.
    
    === Misc: ===
    The helper defers the increment into a workqueue so we don't
    have problems calling this code from atomic sections. A seperate boolean
    (___done) guards the case where we enter net_get_random_once again before
    the increment happend.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index ca9ec8540905..a489705f6fa3 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -239,6 +239,31 @@ do {								\
 #define net_random()		prandom_u32()
 #define net_srandom(seed)	prandom_seed((__force u32)(seed))
 
+bool __net_get_random_once(void *buf, int nbytes, bool *done,
+			   struct static_key *done_key);
+
+#ifdef HAVE_JUMP_LABEL
+#define ___NET_RANDOM_STATIC_KEY_INIT ((struct static_key) \
+		{ .enabled = ATOMIC_INIT(0), .entries = (void *)1 })
+#else /* !HAVE_JUMP_LABEL */
+#define ___NET_RANDOM_STATIC_KEY_INIT STATIC_KEY_INIT_FALSE
+#endif /* HAVE_JUMP_LABEL */
+
+/* BE CAREFUL: this function is not interrupt safe */
+#define net_get_random_once(buf, nbytes)				\
+	({								\
+		bool ___ret = false;					\
+		static bool ___done = false;				\
+		static struct static_key ___done_key =			\
+			___NET_RANDOM_STATIC_KEY_INIT;			\
+		if (!static_key_true(&___done_key))			\
+			___ret = __net_get_random_once(buf,		\
+						       nbytes,		\
+						       &___done,	\
+						       &___done_key);	\
+		___ret;							\
+	})
+
 int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
 		   size_t num, size_t len);
 int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,

commit 7965bd4d71ef7cf1db00afb9e406ddfc13443c13
Author: Joe Perches <joe@perches.com>
Date:   Thu Sep 26 14:48:15 2013 -0700

    net.h/skbuff.h: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4f27575ce1d6..ca9ec8540905 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -195,27 +195,23 @@ enum {
 	SOCK_WAKE_URG,
 };
 
-extern int	     sock_wake_async(struct socket *sk, int how, int band);
-extern int	     sock_register(const struct net_proto_family *fam);
-extern void	     sock_unregister(int family);
-extern int	     __sock_create(struct net *net, int family, int type, int proto,
-				 struct socket **res, int kern);
-extern int	     sock_create(int family, int type, int proto,
-				 struct socket **res);
-extern int	     sock_create_kern(int family, int type, int proto,
-				      struct socket **res);
-extern int	     sock_create_lite(int family, int type, int proto,
-				      struct socket **res); 
-extern void	     sock_release(struct socket *sock);
-extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
-				  size_t len);
-extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
-				  size_t size, int flags);
-extern struct file  *sock_alloc_file(struct socket *sock, int flags, const char *dname);
-extern struct socket *sockfd_lookup(int fd, int *err);
-extern struct socket *sock_from_file(struct file *file, int *err);
+int sock_wake_async(struct socket *sk, int how, int band);
+int sock_register(const struct net_proto_family *fam);
+void sock_unregister(int family);
+int __sock_create(struct net *net, int family, int type, int proto,
+		  struct socket **res, int kern);
+int sock_create(int family, int type, int proto, struct socket **res);
+int sock_create_kern(int family, int type, int proto, struct socket **res);
+int sock_create_lite(int family, int type, int proto, struct socket **res);
+void sock_release(struct socket *sock);
+int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len);
+int sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
+		 int flags);
+struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname);
+struct socket *sockfd_lookup(int fd, int *err);
+struct socket *sock_from_file(struct file *file, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
-extern int	     net_ratelimit(void);
+int net_ratelimit(void);
 
 #define net_ratelimited_function(function, ...)			\
 do {								\
@@ -243,32 +239,28 @@ do {								\
 #define net_random()		prandom_u32()
 #define net_srandom(seed)	prandom_seed((__force u32)(seed))
 
-extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
-				    struct kvec *vec, size_t num, size_t len);
-extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
-				    struct kvec *vec, size_t num,
-				    size_t len, int flags);
+int kernel_sendmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+		   size_t num, size_t len);
+int kernel_recvmsg(struct socket *sock, struct msghdr *msg, struct kvec *vec,
+		   size_t num, size_t len, int flags);
 
-extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
-		       int addrlen);
-extern int kernel_listen(struct socket *sock, int backlog);
-extern int kernel_accept(struct socket *sock, struct socket **newsock,
-			 int flags);
-extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
-			  int addrlen, int flags);
-extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
-			      int *addrlen);
-extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
-			      int *addrlen);
-extern int kernel_getsockopt(struct socket *sock, int level, int optname,
-			     char *optval, int *optlen);
-extern int kernel_setsockopt(struct socket *sock, int level, int optname,
-			     char *optval, unsigned int optlen);
-extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
-			   size_t size, int flags);
-extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
-extern int kernel_sock_shutdown(struct socket *sock,
-				enum sock_shutdown_cmd how);
+int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen);
+int kernel_listen(struct socket *sock, int backlog);
+int kernel_accept(struct socket *sock, struct socket **newsock, int flags);
+int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
+		   int flags);
+int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+		       int *addrlen);
+int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+		       int *addrlen);
+int kernel_getsockopt(struct socket *sock, int level, int optname, char *optval,
+		      int *optlen);
+int kernel_setsockopt(struct socket *sock, int level, int optname, char *optval,
+		      unsigned int optlen);
+int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+		    size_t size, int flags);
+int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how);
 
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))

commit 0e9649c143eb9d7ecaaef221fd411e5c747f97ce
Author: Jean Sacren <sakiwit@gmail.com>
Date:   Sat Jun 1 16:23:16 2013 +0000

    net: do not manually initialize enumerators
    
    Clean up unnecessary initialization of enumerators as the compiler takes
    care of that.
    
    Signed-off-by: Jean Sacren <sakiwit@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 99c9f0c103c2..4f27575ce1d6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -79,9 +79,9 @@ enum sock_type {
 #endif /* ARCH_HAS_SOCKET_TYPES */
 
 enum sock_shutdown_cmd {
-	SHUT_RD		= 0,
-	SHUT_WR		= 1,
-	SHUT_RDWR	= 2,
+	SHUT_RD,
+	SHUT_WR,
+	SHUT_RDWR,
 };
 
 struct socket_wq {

commit 8d564368a9a3197f43e56dadf4a18c5738849f94
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Apr 29 16:21:42 2013 -0700

    net: rename random32 to prandom
    
    Commit 496f2f93b1cc ("random32: rename random32 to prandom") renamed
    random32() and srandom32() to prandom_u32() and prandom_seed()
    respectively.
    
    net_random() and net_srandom() need to be redefined with prandom_* in
    order to finish the naming transition.
    
    While I'm at it, enclose macro argument of net_srandom() with parenthesis.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index aa1673160a45..99c9f0c103c2 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -240,8 +240,8 @@ do {								\
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
 
-#define net_random()		random32()
-#define net_srandom(seed)	srandom32((__force u32)seed)
+#define net_random()		prandom_u32()
+#define net_srandom(seed)	prandom_seed((__force u32)(seed))
 
 extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 				    struct kvec *vec, size_t num, size_t len);

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6ab31cabef7c..aa1673160a45 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -18,49 +18,13 @@
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H
 
-#include <linux/socket.h>
-#include <asm/socket.h>
-
-#define NPROTO		AF_MAX
-
-#define SYS_SOCKET	1		/* sys_socket(2)		*/
-#define SYS_BIND	2		/* sys_bind(2)			*/
-#define SYS_CONNECT	3		/* sys_connect(2)		*/
-#define SYS_LISTEN	4		/* sys_listen(2)		*/
-#define SYS_ACCEPT	5		/* sys_accept(2)		*/
-#define SYS_GETSOCKNAME	6		/* sys_getsockname(2)		*/
-#define SYS_GETPEERNAME	7		/* sys_getpeername(2)		*/
-#define SYS_SOCKETPAIR	8		/* sys_socketpair(2)		*/
-#define SYS_SEND	9		/* sys_send(2)			*/
-#define SYS_RECV	10		/* sys_recv(2)			*/
-#define SYS_SENDTO	11		/* sys_sendto(2)		*/
-#define SYS_RECVFROM	12		/* sys_recvfrom(2)		*/
-#define SYS_SHUTDOWN	13		/* sys_shutdown(2)		*/
-#define SYS_SETSOCKOPT	14		/* sys_setsockopt(2)		*/
-#define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
-#define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
-#define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
-#define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
-#define SYS_RECVMMSG	19		/* sys_recvmmsg(2)		*/
-#define SYS_SENDMMSG	20		/* sys_sendmmsg(2)		*/
-
-typedef enum {
-	SS_FREE = 0,			/* not allocated		*/
-	SS_UNCONNECTED,			/* unconnected to any socket	*/
-	SS_CONNECTING,			/* in process of connecting	*/
-	SS_CONNECTED,			/* connected to socket		*/
-	SS_DISCONNECTING		/* in process of disconnecting	*/
-} socket_state;
-
-#define __SO_ACCEPTCON	(1 << 16)	/* performed a listen		*/
-
-#ifdef __KERNEL__
 #include <linux/stringify.h>
 #include <linux/random.h>
 #include <linux/wait.h>
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <linux/kmemcheck.h>
 #include <linux/rcupdate.h>
+#include <uapi/linux/net.h>
 
 struct poll_table_struct;
 struct pipe_inode_info;
@@ -319,5 +283,4 @@ extern int kernel_sock_shutdown(struct socket *sock,
 #define MODULE_ALIAS_NET_PF_PROTO_NAME(pf, proto, name) \
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
 		     name)
-#endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */

commit aab174f0df5d72d31caccf281af5f614fa254578
Merge: ca41cc96b281 2bd2c1941f14
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 20:25:04 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs update from Al Viro:
    
     - big one - consolidation of descriptor-related logics; almost all of
       that is moved to fs/file.c
    
       (BTW, I'm seriously tempted to rename the result to fd.c.  As it is,
       we have a situation when file_table.c is about handling of struct
       file and file.c is about handling of descriptor tables; the reasons
       are historical - file_table.c used to be about a static array of
       struct file we used to have way back).
    
       A lot of stray ends got cleaned up and converted to saner primitives,
       disgusting mess in android/binder.c is still disgusting, but at least
       doesn't poke so much in descriptor table guts anymore.  A bunch of
       relatively minor races got fixed in process, plus an ext4 struct file
       leak.
    
     - related thing - fget_light() partially unuglified; see fdget() in
       there (and yes, it generates the code as good as we used to have).
    
     - also related - bits of Cyrill's procfs stuff that got entangled into
       that work; _not_ all of it, just the initial move to fs/proc/fd.c and
       switch of fdinfo to seq_file.
    
     - Alex's fs/coredump.c spiltoff - the same story, had been easier to
       take that commit than mess with conflicts.  The rest is a separate
       pile, this was just a mechanical code movement.
    
     - a few misc patches all over the place.  Not all for this cycle,
       there'll be more (and quite a few currently sit in akpm's tree)."
    
    Fix up trivial conflicts in the android binder driver, and some fairly
    simple conflicts due to two different changes to the sock_alloc_file()
    interface ("take descriptor handling from sock_alloc_file() to callers"
    vs "net: Providing protocol type via system.sockprotoname xattr of
    /proc/PID/fd entries" adding a dentry name to the socket)
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (72 commits)
      MAX_LFS_FILESIZE should be a loff_t
      compat: fs: Generic compat_sys_sendfile implementation
      fs: push rcu_barrier() from deactivate_locked_super() to filesystems
      btrfs: reada_extent doesn't need kref for refcount
      coredump: move core dump functionality into its own file
      coredump: prevent double-free on an error path in core dumper
      usb/gadget: fix misannotations
      fcntl: fix misannotations
      ceph: don't abuse d_delete() on failure exits
      hypfs: ->d_parent is never NULL or negative
      vfs: delete surplus inode NULL check
      switch simple cases of fget_light to fdget
      new helpers: fdget()/fdput()
      switch o2hb_region_dev_write() to fget_light()
      proc_map_files_readdir(): don't bother with grabbing files
      make get_file() return its argument
      vhost_set_vring(): turn pollstart/pollstop into bool
      switch prctl_set_mm_exe_file() to fget_light()
      switch xfs_find_handle() to fget_light()
      switch xfs_swapext() to fget_light()
      ...

commit 56b31d1c9f1e6a3ad92e7bfe252721e05d92b285
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Aug 18 00:25:51 2012 -0400

    unexport sock_map_fd(), switch to sock_alloc_file()
    
    Both modular callers of sock_map_fd() had been buggy; sctp one leaks
    descriptor and file if copy_to_user() fails, 9p one shouldn't be
    exposing file in the descriptor table at all.
    
    Switch both to sock_alloc_file(), export it, unexport sock_map_fd() and
    make it static.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/net.h b/include/linux/net.h
index 99276c3dc89a..c8a9708d4d66 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -65,6 +65,7 @@ typedef enum {
 struct poll_table_struct;
 struct pipe_inode_info;
 struct inode;
+struct file;
 struct net;
 
 #define SOCK_ASYNC_NOSPACE	0
@@ -246,7 +247,7 @@ extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
 				  size_t len);
 extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
 				  size_t size, int flags);
-extern int 	     sock_map_fd(struct socket *sock, int flags);
+extern struct file  *sock_alloc_file(struct socket *sock, int flags);
 extern struct socket *sockfd_lookup(int fd, int *err);
 extern struct socket *sock_from_file(struct file *file, int *err);
 #define		     sockfd_put(sock) fput(sock->file)

commit 406a3c638ce8b17d9704052c07955490f732c2b8
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Fri Jul 20 10:39:25 2012 +0000

    net: netprio_cgroup: rework update socket logic
    
    Instead of updating the sk_cgrp_prioidx struct field on every send
    this only updates the field when a task is moved via cgroup
    infrastructure.
    
    This allows sockets that may be used by a kernel worker thread
    to be managed. For example in the iscsi case today a user can
    put iscsid in a netprio cgroup and control traffic will be sent
    with the correct sk_cgrp_prioidx value set but as soon as data
    is sent the kernel worker thread isssues a send and sk_cgrp_prioidx
    is updated with the kernel worker threads value which is the
    default case.
    
    It seems more correct to only update the field when the user
    explicitly sets it via control group infrastructure. This allows
    the users to manage sockets that may be used with other threads.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index dc95700de5df..99276c3dc89a 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -248,6 +248,7 @@ extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
 				  size_t size, int flags);
 extern int 	     sock_map_fd(struct socket *sock, int flags);
 extern struct socket *sockfd_lookup(int fd, int *err);
+extern struct socket *sock_from_file(struct file *file, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);
 

commit b09e786bd1dd66418b69348cb110f3a64764626a
Author: Mikulas Patocka <mikulas@artax.karlin.mff.cuni.cz>
Date:   Thu Jul 19 06:13:36 2012 +0000

    tun: fix a crash bug and a memory leak
    
    This patch fixes a crash
    tun_chr_close -> netdev_run_todo -> tun_free_netdev -> sk_release_kernel ->
    sock_release -> iput(SOCK_INODE(sock))
    introduced by commit 1ab5ecb90cb6a3df1476e052f76a6e8f6511cb3d
    
    The problem is that this socket is embedded in struct tun_struct, it has
    no inode, iput is called on invalid inode, which modifies invalid memory
    and optionally causes a crash.
    
    sock_release also decrements sockets_in_use, this causes a bug that
    "sockets: used" field in /proc/*/net/sockstat keeps on decreasing when
    creating and closing tun devices.
    
    This patch introduces a flag SOCK_EXTERNALLY_ALLOCATED that instructs
    sock_release to not free the inode and not decrement sockets_in_use,
    fixing both memory corruption and sockets_in_use underflow.
    
    It should be backported to 3.3 an 3.4 stabke.
    
    Signed-off-by: Mikulas Patocka <mikulas@artax.karlin.mff.cuni.cz>
    Cc: stable@kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index e9ac2df079ba..dc95700de5df 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -72,6 +72,7 @@ struct net;
 #define SOCK_NOSPACE		2
 #define SOCK_PASSCRED		3
 #define SOCK_PASSSEC		4
+#define SOCK_EXTERNALLY_ALLOCATED 5
 
 #ifndef ARCH_HAS_SOCKET_TYPES
 /**

commit 2033e9bf06f07e049bbc77e9452856df846714cc
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue May 29 09:30:40 2012 +0000

    net: add MODULE_ALIAS_NET_PF_PROTO_NAME
    
    The MODULE_ALAIS_NET_PF macro set is missing a variant that allows for the
    appending of an arbitrary string to the net-pf-<x>-proto-<y> base.  while
    MODULE_ALIAS_NET_PF_PROTO_NAME_TYPE allows an appending of a numerical type, we
    need to be able to append a generic string to support generic netlink families
    that have neither a fix numberical protocol nor type number
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: David Miller <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 2d7510f38934..e9ac2df079ba 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -313,5 +313,8 @@ extern int kernel_sock_shutdown(struct socket *sock,
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
 		     "-type-" __stringify(type))
 
+#define MODULE_ALIAS_NET_PF_PROTO_NAME(pf, proto, name) \
+	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
+		     name)
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */

commit 3a3bfb61e64476ff1e4ac3122cb6dec9c79b795c
Author: Joe Perches <joe@perches.com>
Date:   Sun May 13 21:56:25 2012 +0000

    net: Add net_ratelimited_function and net_<level>_ratelimited macros
    
    __ratelimit() can be considered an inverted bool test because
    it returns true when not ratelimited.  Several tests in the
    kernel tree use this __ratelimit() function incorrectly.
    
    No net_ratelimit uses are incorrect currently though.
    
    Most uses of net_ratelimit are to log something via printk or
    pr_<level>.
    
    In order to minimize the uses of net_ratelimit, and to start
    standardizing the code style used for __ratelimit() and net_ratelimit(),
    add a net_ratelimited_function() macro and net_<level>_ratelimited()
    logging macros similar to pr_<level>_ratelimited that use the global
    net_ratelimit instead of a static per call site "struct ratelimit_state".
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index be60c7f5e145..2d7510f38934 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -250,6 +250,29 @@ extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);
 
+#define net_ratelimited_function(function, ...)			\
+do {								\
+	if (net_ratelimit())					\
+		function(__VA_ARGS__);				\
+} while (0)
+
+#define net_emerg_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_emerg, fmt, ##__VA_ARGS__)
+#define net_alert_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_alert, fmt, ##__VA_ARGS__)
+#define net_crit_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_crit, fmt, ##__VA_ARGS__)
+#define net_err_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_err, fmt, ##__VA_ARGS__)
+#define net_notice_ratelimited(fmt, ...)			\
+	net_ratelimited_function(pr_notice, fmt, ##__VA_ARGS__)
+#define net_warn_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
+#define net_info_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
+#define net_dbg_ratelimited(fmt, ...)				\
+	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
+
 #define net_random()		random32()
 #define net_srandom(seed)	srandom32((__force u32)seed)
 

commit ef64a54f6e558155b4f149bb10666b9e914b6c54
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Tue Feb 21 07:31:34 2012 +0000

    sock: Introduce the SO_PEEK_OFF sock option
    
    This one specifies where to start MSG_PEEK-ing queue data from. When
    set to negative value means that MSG_PEEK works as ususally -- peeks
    from the head of the queue always.
    
    When some bytes are peeked from queue and the peeking offset is non
    negative it is moved forward so that the next peek will return next
    portion of data.
    
    When non-peeking recvmsg occurs and the peeking offset is non negative
    is is moved backward so that the next peek will still peek the proper
    data (i.e. the one that would have been picked if there were no non
    peeking recv in between).
    
    The offset is set using per-proto opteration to let the protocol handle
    the locking issues and to check whether the peeking offset feature is
    supported by the protocol the socket belongs to.
    
    Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index b29923006b11..be60c7f5e145 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -206,6 +206,7 @@ struct proto_ops {
 				      int offset, size_t size, int flags);
 	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
+	void		(*set_peek_off)(struct sock *sk, int val);
 };
 
 #define DECLARE_SOCKADDR(type, dst, src)	\

commit c5c177b4aca83338781e72be2e6dd1601c560cb3
Author: David S. Miller <davem@davemloft.net>
Date:   Fri May 27 13:41:33 2011 -0400

    net: Kill ratelimit.h dependency in linux/net.h
    
    Ingo Molnar noticed that we have this unnecessary ratelimit.h
    dependency in linux/net.h, which hid compilation problems from
    people doing builds only with CONFIG_NET enabled.
    
    Move this stuff out to a seperate net/net_ratelimit.h file and
    include that in the only two places where this thing is needed.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/net.h b/include/linux/net.h
index 1da55e9b6f01..b29923006b11 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -289,11 +289,5 @@ extern int kernel_sock_shutdown(struct socket *sock,
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
 		     "-type-" __stringify(type))
 
-#ifdef CONFIG_SYSCTL
-#include <linux/sysctl.h>
-#include <linux/ratelimit.h>
-extern struct ratelimit_state net_ratelimit_state;
-#endif
-
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */

commit 228e548e602061b08ee8e8966f567c12aa079682
Author: Anton Blanchard <anton@samba.org>
Date:   Mon May 2 20:21:35 2011 +0000

    net: Add sendmmsg socket system call
    
    This patch adds a multiple message send syscall and is the send
    version of the existing recvmmsg syscall. This is heavily
    based on the patch by Arnaldo that added recvmmsg.
    
    I wrote a microbenchmark to test the performance gains of using
    this new syscall:
    
    http://ozlabs.org/~anton/junkcode/sendmmsg_test.c
    
    The test was run on a ppc64 box with a 10 Gbit network card. The
    benchmark can send both UDP and RAW ethernet packets.
    
    64B UDP
    
    batch   pkts/sec
    1       804570
    2       872800 (+ 8 %)
    4       916556 (+14 %)
    8       939712 (+17 %)
    16      952688 (+18 %)
    32      956448 (+19 %)
    64      964800 (+20 %)
    
    64B raw socket
    
    batch   pkts/sec
    1       1201449
    2       1350028 (+12 %)
    4       1461416 (+22 %)
    8       1513080 (+26 %)
    16      1541216 (+28 %)
    32      1553440 (+29 %)
    64      1557888 (+30 %)
    
    We see a 20% improvement in throughput on UDP send and 30%
    on raw socket send.
    
    [ Add sparc syscall entries. -DaveM ]
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 94de83c0f877..1da55e9b6f01 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -42,6 +42,7 @@
 #define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
 #define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
 #define SYS_RECVMMSG	19		/* sys_recvmmsg(2)		*/
+#define SYS_SENDMMSG	20		/* sys_sendmmsg(2)		*/
 
 typedef enum {
 	SS_FREE = 0,			/* not allocated		*/

commit eaefd1105bc431ef329599e307a07f2a36ae7872
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Fri Feb 18 03:26:36 2011 +0000

    net: add __rcu annotations to sk_wq and wq
    
    Add proper RCU annotations/verbs to sk_wq and wq members
    
    Fix __sctp_write_space() sk_sleep() abuse (and sock->wq access)
    
    Fix sunrpc sk_sleep() abuse too
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 16faa130088c..94de83c0f877 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -118,6 +118,7 @@ enum sock_shutdown_cmd {
 };
 
 struct socket_wq {
+	/* Note: wait MUST be first field of socket_wq */
 	wait_queue_head_t	wait;
 	struct fasync_struct	*fasync_list;
 	struct rcu_head		rcu;
@@ -142,7 +143,7 @@ struct socket {
 
 	unsigned long		flags;
 
-	struct socket_wq	*wq;
+	struct socket_wq __rcu	*wq;
 
 	struct file		*file;
 	struct sock		*sk;

commit 721db93a55dad71bb89e7d11cc6be1f180ec3f2d
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Wed Sep 29 16:06:32 2010 +0400

    net: Export __sock_create
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/net.h b/include/linux/net.h
index dee0b11a8759..16faa130088c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -229,6 +229,8 @@ enum {
 extern int	     sock_wake_async(struct socket *sk, int how, int band);
 extern int	     sock_register(const struct net_proto_family *fam);
 extern void	     sock_unregister(int family);
+extern int	     __sock_create(struct net *net, int family, int type, int proto,
+				 struct socket **res, int kern);
 extern int	     sock_create(int family, int type, int proto,
 				 struct socket **res);
 extern int	     sock_create_kern(int family, int type, int proto,

commit e2aec372ff4b7e78e79c308104a860ae0ed20950
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Jul 1 13:18:58 2010 +0000

    linux/net.h: fix kernel-doc warnings
    
    Fix kernel-doc warnings in linux/net.h:
    
    Warning(include/linux/net.h:151): No description found for parameter 'wq'
    Warning(include/linux/net.h:151): Excess struct/union/enum/typedef member 'fasync_list' description in 'socket'
    Warning(include/linux/net.h:151): Excess struct/union/enum/typedef member 'wait' description in 'socket'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 2b4deeeb8646..dee0b11a8759 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -129,10 +129,9 @@ struct socket_wq {
  *  @type: socket type (%SOCK_STREAM, etc)
  *  @flags: socket flags (%SOCK_ASYNC_NOSPACE, etc)
  *  @ops: protocol specific socket operations
- *  @fasync_list: Asynchronous wake up list
  *  @file: File back pointer for gc
  *  @sk: internal networking protocol agnostic socket representation
- *  @wait: wait queue for several uses
+ *  @wq: wait queue for several uses
  */
 struct socket {
 	socket_state		state;

commit 43815482370c510c569fd18edb57afcb0fa8cab6
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Apr 29 11:01:49 2010 +0000

    net: sock_def_readable() and friends RCU conversion
    
    sk_callback_lock rwlock actually protects sk->sk_sleep pointer, so we
    need two atomic operations (and associated dirtying) per incoming
    packet.
    
    RCU conversion is pretty much needed :
    
    1) Add a new structure, called "struct socket_wq" to hold all fields
    that will need rcu_read_lock() protection (currently: a
    wait_queue_head_t and a struct fasync_struct pointer).
    
    [Future patch will add a list anchor for wakeup coalescing]
    
    2) Attach one of such structure to each "struct socket" created in
    sock_alloc_inode().
    
    3) Respect RCU grace period when freeing a "struct socket_wq"
    
    4) Change sk_sleep pointer in "struct sock" by sk_wq, pointer to "struct
    socket_wq"
    
    5) Change sk_sleep() function to use new sk->sk_wq instead of
    sk->sk_sleep
    
    6) Change sk_has_sleeper() to wq_has_sleeper() that must be used inside
    a rcu_read_lock() section.
    
    7) Change all sk_has_sleeper() callers to :
      - Use rcu_read_lock() instead of read_lock(&sk->sk_callback_lock)
      - Use wq_has_sleeper() to eventually wakeup tasks.
      - Use rcu_read_unlock() instead of read_unlock(&sk->sk_callback_lock)
    
    8) sock_wake_async() is modified to use rcu protection as well.
    
    9) Exceptions :
      macvtap, drivers/net/tun.c, af_unix use integrated "struct socket_wq"
    instead of dynamically allocated ones. They dont need rcu freeing.
    
    Some cleanups or followups are probably needed, (possible
    sk_callback_lock conversion to a spinlock for example...).
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4157b5d42bd6..2b4deeeb8646 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -59,6 +59,7 @@ typedef enum {
 #include <linux/wait.h>
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <linux/kmemcheck.h>
+#include <linux/rcupdate.h>
 
 struct poll_table_struct;
 struct pipe_inode_info;
@@ -116,6 +117,12 @@ enum sock_shutdown_cmd {
 	SHUT_RDWR	= 2,
 };
 
+struct socket_wq {
+	wait_queue_head_t	wait;
+	struct fasync_struct	*fasync_list;
+	struct rcu_head		rcu;
+} ____cacheline_aligned_in_smp;
+
 /**
  *  struct socket - general BSD socket
  *  @state: socket state (%SS_CONNECTED, etc)
@@ -135,11 +142,8 @@ struct socket {
 	kmemcheck_bitfield_end(type);
 
 	unsigned long		flags;
-	/*
-	 * Please keep fasync_list & wait fields in the same cache line
-	 */
-	struct fasync_struct	*fasync_list;
-	wait_queue_head_t	wait;
+
+	struct socket_wq	*wq;
 
 	struct file		*file;
 	struct sock		*sk;

commit 1621e0940294c20e302faf401f41204de7252e22
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 1 09:44:19 2010 +0000

    net: CONFIG_COMPAT redux
    
    Ifdef out
            struct proto_ops::compat_ioctl
            struct proto_ops::compat_setsockopt
            struct proto_ops::compat_getsockopt
    to make structures smaller on COMPAT=n kernels.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 5e8083cacc8b..4157b5d42bd6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -174,18 +174,22 @@ struct proto_ops {
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
 				      unsigned long arg);
+#ifdef CONFIG_COMPAT
 	int	 	(*compat_ioctl) (struct socket *sock, unsigned int cmd,
 				      unsigned long arg);
+#endif
 	int		(*listen)    (struct socket *sock, int len);
 	int		(*shutdown)  (struct socket *sock, int flags);
 	int		(*setsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, unsigned int optlen);
 	int		(*getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
+#ifdef CONFIG_COMPAT
 	int		(*compat_setsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, unsigned int optlen);
 	int		(*compat_getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
+#endif
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len);
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,

commit 28b4d5cc17c20786848cdc07b7ea237a309776bb
Merge: d29cecda036f 96fa2b508d2d
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Dec 5 15:22:26 2009 -0800

    Merge branch 'master' of /home/davem/src/GIT/linux-2.6/
    
    Conflicts:
            drivers/net/pcmcia/fmvj18x_cs.c
            drivers/net/pcmcia/nmclan_cs.c
            drivers/net/pcmcia/xirc2ps_cs.c
            drivers/net/wireless/ray_cs.c

commit d0b093a8b5ae34ee8be1f7e0dd197fe4788fa1d5
Merge: 3e72b810e30c 5c828713358c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 5 09:50:22 2009 -0800

    Merge branch 'core-printk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core-printk-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      ratelimit: Make suppressed output messages more useful
      printk: Remove ratelimit.h from kernel.h
      ratelimit: Fix/allow use in atomic contexts
      ratelimit: Use per ratelimit context locking

commit b215c57dcc847b15693899d26aa0ee4669dacefb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 5 04:37:30 2009 +0000

    net: kill proto_ops wrapper
    
    All users of wrapped proto_ops are now gone, so we can safely remove
    the wrappers as well.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 70ee3c310f15..6ce87663551c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -268,89 +268,6 @@ extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
 extern int kernel_sock_shutdown(struct socket *sock,
 				enum sock_shutdown_cmd how);
 
-#ifndef CONFIG_SMP
-#define SOCKOPS_WRAPPED(name) name
-#define SOCKOPS_WRAP(name, fam)
-#else
-
-#define SOCKOPS_WRAPPED(name) __unlocked_##name
-
-#define SOCKCALL_WRAP(name, call, parms, args)		\
-static int __lock_##name##_##call  parms		\
-{							\
-	int ret;					\
-	lock_kernel();					\
-	ret = __unlocked_##name##_ops.call  args ;\
-	unlock_kernel();				\
-	return ret;					\
-}
-
-#define SOCKCALL_UWRAP(name, call, parms, args)		\
-static unsigned int __lock_##name##_##call  parms	\
-{							\
-	int ret;					\
-	lock_kernel();					\
-	ret = __unlocked_##name##_ops.call  args ;\
-	unlock_kernel();				\
-	return ret;					\
-}
-
-
-#define SOCKOPS_WRAP(name, fam)					\
-SOCKCALL_WRAP(name, release, (struct socket *sock), (sock))	\
-SOCKCALL_WRAP(name, bind, (struct socket *sock, struct sockaddr *uaddr, int addr_len), \
-	      (sock, uaddr, addr_len))				\
-SOCKCALL_WRAP(name, connect, (struct socket *sock, struct sockaddr * uaddr, \
-			      int addr_len, int flags), 	\
-	      (sock, uaddr, addr_len, flags))			\
-SOCKCALL_WRAP(name, socketpair, (struct socket *sock1, struct socket *sock2), \
-	      (sock1, sock2))					\
-SOCKCALL_WRAP(name, accept, (struct socket *sock, struct socket *newsock, \
-			 int flags), (sock, newsock, flags)) \
-SOCKCALL_WRAP(name, getname, (struct socket *sock, struct sockaddr *uaddr, \
-			 int *addr_len, int peer), (sock, uaddr, addr_len, peer)) \
-SOCKCALL_UWRAP(name, poll, (struct file *file, struct socket *sock, struct poll_table_struct *wait), \
-	      (file, sock, wait)) \
-SOCKCALL_WRAP(name, ioctl, (struct socket *sock, unsigned int cmd, \
-			 unsigned long arg), (sock, cmd, arg)) \
-SOCKCALL_WRAP(name, compat_ioctl, (struct socket *sock, unsigned int cmd, \
-			 unsigned long arg), (sock, cmd, arg)) \
-SOCKCALL_WRAP(name, listen, (struct socket *sock, int len), (sock, len)) \
-SOCKCALL_WRAP(name, shutdown, (struct socket *sock, int flags), (sock, flags)) \
-SOCKCALL_WRAP(name, setsockopt, (struct socket *sock, int level, int optname, \
-			 char __user *optval, unsigned int optlen), (sock, level, optname, optval, optlen)) \
-SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
-			 char __user *optval, int __user *optlen), (sock, level, optname, optval, optlen)) \
-SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \
-	      (iocb, sock, m, len)) \
-SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len, int flags), \
-	      (iocb, sock, m, len, flags)) \
-SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
-	      (file, sock, vma)) \
-	      \
-static const struct proto_ops name##_ops = {			\
-	.family		= fam,				\
-	.owner		= THIS_MODULE,			\
-	.release	= __lock_##name##_release,	\
-	.bind		= __lock_##name##_bind,		\
-	.connect	= __lock_##name##_connect,	\
-	.socketpair	= __lock_##name##_socketpair,	\
-	.accept		= __lock_##name##_accept,	\
-	.getname	= __lock_##name##_getname,	\
-	.poll		= __lock_##name##_poll,		\
-	.ioctl		= __lock_##name##_ioctl,	\
-	.compat_ioctl	= __lock_##name##_compat_ioctl,	\
-	.listen		= __lock_##name##_listen,	\
-	.shutdown	= __lock_##name##_shutdown,	\
-	.setsockopt	= __lock_##name##_setsockopt,	\
-	.getsockopt	= __lock_##name##_getsockopt,	\
-	.sendmsg	= __lock_##name##_sendmsg,	\
-	.recvmsg	= __lock_##name##_recvmsg,	\
-	.mmap		= __lock_##name##_mmap,		\
-};
-
-#endif
-
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))
 

commit 3f378b684453f2a028eda463ce383370545d9cc9
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Nov 5 22:18:14 2009 -0800

    net: pass kern to net_proto_family create function
    
    The generic __sock_create function has a kern argument which allows the
    security system to make decisions based on if a socket is being created by
    the kernel or by userspace.  This patch passes that flag to the
    net_proto_family specific create function, so it can do the same thing.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4da9d571b053..70ee3c310f15 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -204,7 +204,8 @@ struct proto_ops {
 
 struct net_proto_family {
 	int		family;
-	int		(*create)(struct net *net, struct socket *sock, int protocol);
+	int		(*create)(struct net *net, struct socket *sock,
+				  int protocol, int kern);
 	struct module	*owner;
 };
 

commit 38bfd8f5bec496e8e0db8849e01c99a33479418a
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Thu Oct 29 02:59:18 2009 -0700

    net,socket: introduce DECLARE_SOCKADDR helper to catch overflow at build time
    
    proto_ops->getname implies copying protocol specific data
    into storage unit (particulary to __kernel_sockaddr_storage).
    So when we implement new protocol support we should keep such
    a detail in mind (which is easy to forget about).
    
    Lets introduce DECLARE_SOCKADDR helper which check if
    storage unit is not overfowed at build time.
    
    Eventually inet_getname is switched to use DECLARE_SOCKADDR
    (to show example of usage).
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index b42bb60fe92f..4da9d571b053 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -199,6 +199,9 @@ struct proto_ops {
 				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 };
 
+#define DECLARE_SOCKADDR(type, dst, src)	\
+	type dst = ({ __sockaddr_check_size(sizeof(*dst)); (type) src; })
+
 struct net_proto_family {
 	int		family;
 	int		(*create)(struct net *net, struct socket *sock, int protocol);

commit a2e2725541fad72416326798c2d7fa4dafb7d337
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Oct 12 23:40:10 2009 -0700

    net: Introduce recvmmsg socket syscall
    
    Meaning receive multiple messages, reducing the number of syscalls and
    net stack entry/exit operations.
    
    Next patches will introduce mechanisms where protocols that want to
    optimize this operation will provide an unlocked_recvmsg operation.
    
    This takes into account comments made by:
    
    . Paul Moore: sock_recvmsg is called only for the first datagram,
      sock_recvmsg_nosec is used for the rest.
    
    . Caitlin Bestler: recvmmsg now has a struct timespec timeout, that
      works in the same fashion as the ppoll one.
    
      If the underlying protocol returns a datagram with MSG_OOB set, this
      will make recvmmsg return right away with as many datagrams (+ the OOB
      one) it has received so far.
    
    . Rémi Denis-Courmont & Steven Whitehouse: If we receive N < vlen
      datagrams and then recvmsg returns an error, recvmmsg will return
      the successfully received datagrams, store the error and return it
      in the next call.
    
    This paves the way for a subsequent optimization, sk_prot->unlocked_recvmsg,
    where we will be able to acquire the lock only at batch start and end, not at
    every underlying recvmsg call.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 529a0931711d..b42bb60fe92f 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -41,6 +41,7 @@
 #define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
 #define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
 #define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
+#define SYS_RECVMMSG	19		/* sys_recvmmsg(2)		*/
 
 typedef enum {
 	SS_FREE = 0,			/* not allocated		*/

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 9040a10584f7..529a0931711d 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -178,11 +178,11 @@ struct proto_ops {
 	int		(*listen)    (struct socket *sock, int len);
 	int		(*shutdown)  (struct socket *sock, int flags);
 	int		(*setsockopt)(struct socket *sock, int level,
-				      int optname, char __user *optval, int optlen);
+				      int optname, char __user *optval, unsigned int optlen);
 	int		(*getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 	int		(*compat_setsockopt)(struct socket *sock, int level,
-				      int optname, char __user *optval, int optlen);
+				      int optname, char __user *optval, unsigned int optlen);
 	int		(*compat_getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
@@ -256,7 +256,7 @@ extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
 extern int kernel_getsockopt(struct socket *sock, int level, int optname,
 			     char *optval, int *optlen);
 extern int kernel_setsockopt(struct socket *sock, int level, int optname,
-			     char *optval, int optlen);
+			     char *optval, unsigned int optlen);
 extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 			   size_t size, int flags);
 extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
@@ -313,7 +313,7 @@ SOCKCALL_WRAP(name, compat_ioctl, (struct socket *sock, unsigned int cmd, \
 SOCKCALL_WRAP(name, listen, (struct socket *sock, int len), (sock, len)) \
 SOCKCALL_WRAP(name, shutdown, (struct socket *sock, int flags), (sock, flags)) \
 SOCKCALL_WRAP(name, setsockopt, (struct socket *sock, int level, int optname, \
-			 char __user *optval, int optlen), (sock, level, optname, optval, optlen)) \
+			 char __user *optval, unsigned int optlen), (sock, level, optname, optval, optlen)) \
 SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
 			 char __user *optval, int __user *optlen), (sock, level, optname, optval, optlen)) \
 SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \

commit 3fff4c42bd0a89869a0eb1e7874cc06ffa4aa0f5
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Sep 22 16:18:09 2009 +0200

    printk: Remove ratelimit.h from kernel.h
    
    Decouple kernel.h from ratelimit.h: the global declaration of
    printk's ratelimit_state is not needed, and it leads to messy
    circular dependencies due to ratelimit.h's (new) adding of a
    spinlock_types.h include.
    
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: David S. Miller <davem@davemloft.net>
    LKML-Reference: <new-submission>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/net.h b/include/linux/net.h
index 9040a10584f7..df20f680f455 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -358,6 +358,7 @@ static const struct proto_ops name##_ops = {			\
 
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
+#include <linux/ratelimit.h>
 extern struct ratelimit_state net_ratelimit_state;
 #endif
 

commit 29a020d35f629619c67fa5e32acaaac3f8a1ba90
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Sep 15 02:39:20 2009 -0700

    [PATCH] net: kmemcheck annotation in struct socket
    
    struct socket has a 16 bit hole that triggers kmemcheck warnings.
    
    As suggested by Ingo, use kmemcheck annotations
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4fc2ffd527f9..9040a10584f7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -57,6 +57,7 @@ typedef enum {
 #include <linux/random.h>
 #include <linux/wait.h>
 #include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
+#include <linux/kmemcheck.h>
 
 struct poll_table_struct;
 struct pipe_inode_info;
@@ -127,7 +128,11 @@ enum sock_shutdown_cmd {
  */
 struct socket {
 	socket_state		state;
+
+	kmemcheck_bitfield_begin(type);
 	short			type;
+	kmemcheck_bitfield_end(type);
+
 	unsigned long		flags;
 	/*
 	 * Please keep fasync_list & wait fields in the same cache line

commit 8bdd663aba341c15cd2fa9dbd7061b8b387964dc
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Sun Mar 15 19:59:13 2009 -0700

    net: reorder fields of struct socket
    
    On x86_64, its rather unfortunate that "wait_queue_head_t wait"
    field of "struct socket" spans two cache lines (assuming a 64
    bytes cache line in current cpus)
    
    offsetof(struct socket, wait)=0x30
    sizeof(wait_queue_head_t)=0x18
    
    This might explain why Kenny Chang noticed that his multicast workload
    was performing bad with 64 bit kernels, since more cache lines ping pongs
    were involved.
    
    This litle patch moves "wait" field next "fasync_list" so that both
    fields share a single cache line, to speedup sock_def_readable()
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4515efae4c39..4fc2ffd527f9 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -129,11 +129,15 @@ struct socket {
 	socket_state		state;
 	short			type;
 	unsigned long		flags;
-	const struct proto_ops	*ops;
+	/*
+	 * Please keep fasync_list & wait fields in the same cache line
+	 */
 	struct fasync_struct	*fasync_list;
+	wait_queue_head_t	wait;
+
 	struct file		*file;
 	struct sock		*sk;
-	wait_queue_head_t	wait;
+	const struct proto_ops	*ops;
 };
 
 struct vm_area_struct;

commit de11defebf00007677fb7ee91d9b089b78786fbb
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Nov 19 15:36:14 2008 -0800

    reintroduce accept4
    
    Introduce a new accept4() system call.  The addition of this system call
    matches analogous changes in 2.6.27 (dup3(), evenfd2(), signalfd4(),
    inotify_init1(), epoll_create1(), pipe2()) which added new system calls
    that differed from analogous traditional system calls in adding a flags
    argument that can be used to access additional functionality.
    
    The accept4() system call is exactly the same as accept(), except that
    it adds a flags bit-mask argument.  Two flags are initially implemented.
    (Most of the new system calls in 2.6.27 also had both of these flags.)
    
    SOCK_CLOEXEC causes the close-on-exec (FD_CLOEXEC) flag to be enabled
    for the new file descriptor returned by accept4().  This is a useful
    security feature to avoid leaking information in a multithreaded
    program where one thread is doing an accept() at the same time as
    another thread is doing a fork() plus exec().  More details here:
    http://udrepper.livejournal.com/20407.html "Secure File Descriptor Handling",
    Ulrich Drepper).
    
    The other flag is SOCK_NONBLOCK, which causes the O_NONBLOCK flag
    to be enabled on the new open file description created by accept4().
    (This flag is merely a convenience, saving the use of additional calls
    fcntl(F_GETFL) and fcntl (F_SETFL) to achieve the same result.
    
    Here's a test program.  Works on x86-32.  Should work on x86-64, but
    I (mtk) don't have a system to hand to test with.
    
    It tests accept4() with each of the four possible combinations of
    SOCK_CLOEXEC and SOCK_NONBLOCK set/clear in 'flags', and verifies
    that the appropriate flags are set on the file descriptor/open file
    description returned by accept4().
    
    I tested Ulrich's patch in this thread by applying against 2.6.28-rc2,
    and it passes according to my test program.
    
    /* test_accept4.c
    
      Copyright (C) 2008, Linux Foundation, written by Michael Kerrisk
           <mtk.manpages@gmail.com>
    
      Licensed under the GNU GPLv2 or later.
    */
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <stdio.h>
    #include <string.h>
    
    #define PORT_NUM 33333
    
    #define die(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)
    
    /**********************************************************************/
    
    /* The following is what we need until glibc gets a wrapper for
      accept4() */
    
    /* Flags for socket(), socketpair(), accept4() */
    #ifndef SOCK_CLOEXEC
    #define SOCK_CLOEXEC    O_CLOEXEC
    #endif
    #ifndef SOCK_NONBLOCK
    #define SOCK_NONBLOCK   O_NONBLOCK
    #endif
    
    #ifdef __x86_64__
    #define SYS_accept4 288
    #elif __i386__
    #define USE_SOCKETCALL 1
    #define SYS_ACCEPT4 18
    #else
    #error "Sorry -- don't know the syscall # on this architecture"
    #endif
    
    static int
    accept4(int fd, struct sockaddr *sockaddr, socklen_t *addrlen, int flags)
    {
       printf("Calling accept4(): flags = %x", flags);
       if (flags != 0) {
           printf(" (");
           if (flags & SOCK_CLOEXEC)
               printf("SOCK_CLOEXEC");
           if ((flags & SOCK_CLOEXEC) && (flags & SOCK_NONBLOCK))
               printf(" ");
           if (flags & SOCK_NONBLOCK)
               printf("SOCK_NONBLOCK");
           printf(")");
       }
       printf("\n");
    
    #if USE_SOCKETCALL
       long args[6];
    
       args[0] = fd;
       args[1] = (long) sockaddr;
       args[2] = (long) addrlen;
       args[3] = flags;
    
       return syscall(SYS_socketcall, SYS_ACCEPT4, args);
    #else
       return syscall(SYS_accept4, fd, sockaddr, addrlen, flags);
    #endif
    }
    
    /**********************************************************************/
    
    static int
    do_test(int lfd, struct sockaddr_in *conn_addr,
           int closeonexec_flag, int nonblock_flag)
    {
       int connfd, acceptfd;
       int fdf, flf, fdf_pass, flf_pass;
       struct sockaddr_in claddr;
       socklen_t addrlen;
    
       printf("=======================================\n");
    
       connfd = socket(AF_INET, SOCK_STREAM, 0);
       if (connfd == -1)
           die("socket");
       if (connect(connfd, (struct sockaddr *) conn_addr,
                   sizeof(struct sockaddr_in)) == -1)
           die("connect");
    
       addrlen = sizeof(struct sockaddr_in);
       acceptfd = accept4(lfd, (struct sockaddr *) &claddr, &addrlen,
                          closeonexec_flag | nonblock_flag);
       if (acceptfd == -1) {
           perror("accept4()");
           close(connfd);
           return 0;
       }
    
       fdf = fcntl(acceptfd, F_GETFD);
       if (fdf == -1)
           die("fcntl:F_GETFD");
       fdf_pass = ((fdf & FD_CLOEXEC) != 0) ==
                  ((closeonexec_flag & SOCK_CLOEXEC) != 0);
       printf("Close-on-exec flag is %sset (%s); ",
               (fdf & FD_CLOEXEC) ? "" : "not ",
               fdf_pass ? "OK" : "failed");
    
       flf = fcntl(acceptfd, F_GETFL);
       if (flf == -1)
           die("fcntl:F_GETFD");
       flf_pass = ((flf & O_NONBLOCK) != 0) ==
                  ((nonblock_flag & SOCK_NONBLOCK) !=0);
       printf("nonblock flag is %sset (%s)\n",
               (flf & O_NONBLOCK) ? "" : "not ",
               flf_pass ? "OK" : "failed");
    
       close(acceptfd);
       close(connfd);
    
       printf("Test result: %s\n", (fdf_pass && flf_pass) ? "PASS" : "FAIL");
       return fdf_pass && flf_pass;
    }
    
    static int
    create_listening_socket(int port_num)
    {
       struct sockaddr_in svaddr;
       int lfd;
       int optval;
    
       memset(&svaddr, 0, sizeof(struct sockaddr_in));
       svaddr.sin_family = AF_INET;
       svaddr.sin_addr.s_addr = htonl(INADDR_ANY);
       svaddr.sin_port = htons(port_num);
    
       lfd = socket(AF_INET, SOCK_STREAM, 0);
       if (lfd == -1)
           die("socket");
    
       optval = 1;
       if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval,
                      sizeof(optval)) == -1)
           die("setsockopt");
    
       if (bind(lfd, (struct sockaddr *) &svaddr,
                sizeof(struct sockaddr_in)) == -1)
           die("bind");
    
       if (listen(lfd, 5) == -1)
           die("listen");
    
       return lfd;
    }
    
    int
    main(int argc, char *argv[])
    {
       struct sockaddr_in conn_addr;
       int lfd;
       int port_num;
       int passed;
    
       passed = 1;
    
       port_num = (argc > 1) ? atoi(argv[1]) : PORT_NUM;
    
       memset(&conn_addr, 0, sizeof(struct sockaddr_in));
       conn_addr.sin_family = AF_INET;
       conn_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
       conn_addr.sin_port = htons(port_num);
    
       lfd = create_listening_socket(port_num);
    
       if (!do_test(lfd, &conn_addr, 0, 0))
           passed = 0;
       if (!do_test(lfd, &conn_addr, SOCK_CLOEXEC, 0))
           passed = 0;
       if (!do_test(lfd, &conn_addr, 0, SOCK_NONBLOCK))
           passed = 0;
       if (!do_test(lfd, &conn_addr, SOCK_CLOEXEC, SOCK_NONBLOCK))
           passed = 0;
    
       close(lfd);
    
       exit(passed ? EXIT_SUCCESS : EXIT_FAILURE);
    }
    
    [mtk.manpages@gmail.com: rewrote changelog, updated test program]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Tested-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: <linux-api@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6dc14a240042..4515efae4c39 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -40,7 +40,7 @@
 #define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
 #define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
 #define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
-#define SYS_PACCEPT	18		/* sys_paccept(2)		*/
+#define SYS_ACCEPT4	18		/* sys_accept4(2)		*/
 
 typedef enum {
 	SS_FREE = 0,			/* not allocated		*/
@@ -100,7 +100,7 @@ enum sock_type {
  * remaining bits are used as flags. */
 #define SOCK_TYPE_MASK 0xf
 
-/* Flags for socket, socketpair, paccept */
+/* Flags for socket, socketpair, accept4 */
 #define SOCK_CLOEXEC	O_CLOEXEC
 #ifndef SOCK_NONBLOCK
 #define SOCK_NONBLOCK	O_NONBLOCK
@@ -223,8 +223,6 @@ extern int 	     sock_map_fd(struct socket *sock, int flags);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);
-extern long	     do_accept(int fd, struct sockaddr __user *upeer_sockaddr,
-			       int __user *upeer_addrlen, int flags);
 
 #define net_random()		random32()
 #define net_srandom(seed)	srandom32((__force u32)seed)

commit 5770a3fb5f8544d40ae03b010318345cdd05d662
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Aug 26 15:29:22 2008 +0100

    Fix userspace export of <linux/net.h>
    
    Including <linux/fcntl.h> in the user-visible part of this header has
    caused build regressions with headers from 2.6.27-rc. Move it down to
    the #ifdef __KERNEL__ part, which is the only place it's needed. Move
    some other kernel-only things down there too, while we're at it.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4a9a30f2d68f..6dc14a240042 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -18,16 +18,9 @@
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H
 
-#include <linux/wait.h>
 #include <linux/socket.h>
-#include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <asm/socket.h>
 
-struct poll_table_struct;
-struct pipe_inode_info;
-struct inode;
-struct net;
-
 #define NPROTO		AF_MAX
 
 #define SYS_SOCKET	1		/* sys_socket(2)		*/
@@ -62,6 +55,13 @@ typedef enum {
 #ifdef __KERNEL__
 #include <linux/stringify.h>
 #include <linux/random.h>
+#include <linux/wait.h>
+#include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
+
+struct poll_table_struct;
+struct pipe_inode_info;
+struct inode;
+struct net;
 
 #define SOCK_ASYNC_NOSPACE	0
 #define SOCK_ASYNC_WAITDATA	1

commit 717115e1a5856b57af0f71e1df7149108294fc10
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Fri Jul 25 01:45:58 2008 -0700

    printk ratelimiting rewrite
    
    All ratelimit user use same jiffies and burst params, so some messages
    (callbacks) will be lost.
    
    For example:
    a call printk_ratelimit(5 * HZ, 1)
    b call printk_ratelimit(5 * HZ, 1) before the 5*HZ timeout of a, then b will
    will be supressed.
    
    - rewrite __ratelimit, and use a ratelimit_state as parameter.  Thanks for
      hints from andrew.
    
    - Add WARN_ON_RATELIMIT, update rcupreempt.h
    
    - remove __printk_ratelimit
    
    - use __ratelimit in net_ratelimit
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 2f999fbb188d..4a9a30f2d68f 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -351,8 +351,7 @@ static const struct proto_ops name##_ops = {			\
 
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
-extern int net_msg_cost;
-extern int net_msg_burst;
+extern struct ratelimit_state net_ratelimit_state;
 #endif
 
 #endif /* __KERNEL__ */

commit 77d2720059618b9b6e827a8b73831eb6c6fad63c
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:35 2008 -0700

    flag parameters: NONBLOCK in socket and socketpair
    
    This patch introduces support for the SOCK_NONBLOCK flag in socket,
    socketpair, and  paccept.  To do this the internal function sock_attach_fd
    gets an additional parameter which it uses to set the appropriate flag for
    the file descriptor.
    
    Given that in modern, scalable programs almost all socket connections are
    non-blocking and the minimal additional cost for the new functionality
    I see no reason not to add this code.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <pthread.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <netinet/in.h>
    #include <sys/socket.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_paccept
    # ifdef __x86_64__
    #  define __NR_paccept 288
    # elif defined __i386__
    #  define SYS_PACCEPT 18
    #  define USE_SOCKETCALL 1
    # else
    #  error "need __NR_paccept"
    # endif
    #endif
    
    #ifdef USE_SOCKETCALL
    # define paccept(fd, addr, addrlen, mask, flags) \
      ({ long args[6] = { \
           (long) fd, (long) addr, (long) addrlen, (long) mask, 8, (long) flags }; \
         syscall (__NR_socketcall, SYS_PACCEPT, args); })
    #else
    # define paccept(fd, addr, addrlen, mask, flags) \
      syscall (__NR_paccept, fd, addr, addrlen, mask, 8, flags)
    #endif
    
    #define PORT 57392
    
    #define SOCK_NONBLOCK O_NONBLOCK
    
    static pthread_barrier_t b;
    
    static void *
    tf (void *arg)
    {
      pthread_barrier_wait (&b);
      int s = socket (AF_INET, SOCK_STREAM, 0);
      struct sockaddr_in sin;
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
      pthread_barrier_wait (&b);
    
      pthread_barrier_wait (&b);
      s = socket (AF_INET, SOCK_STREAM, 0);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
      pthread_barrier_wait (&b);
    
      return NULL;
    }
    
    int
    main (void)
    {
      int fd;
      fd = socket (PF_INET, SOCK_STREAM, 0);
      if (fd == -1)
        {
          puts ("socket(0) failed");
          return 1;
        }
      int fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (fl & O_NONBLOCK)
        {
          puts ("socket(0) set non-blocking mode");
          return 1;
        }
      close (fd);
    
      fd = socket (PF_INET, SOCK_STREAM|SOCK_NONBLOCK, 0);
      if (fd == -1)
        {
          puts ("socket(SOCK_NONBLOCK) failed");
          return 1;
        }
      fl = fcntl (fd, F_GETFL);
      if (fl == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((fl & O_NONBLOCK) == 0)
        {
          puts ("socket(SOCK_NONBLOCK) does not set non-blocking mode");
          return 1;
        }
      close (fd);
    
      int fds[2];
      if (socketpair (PF_UNIX, SOCK_STREAM, 0, fds) == -1)
        {
          puts ("socketpair(0) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          fl = fcntl (fds[i], F_GETFL);
          if (fl == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if (fl & O_NONBLOCK)
            {
              printf ("socketpair(0) set non-blocking mode for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      if (socketpair (PF_UNIX, SOCK_STREAM|SOCK_NONBLOCK, 0, fds) == -1)
        {
          puts ("socketpair(SOCK_NONBLOCK) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          fl = fcntl (fds[i], F_GETFL);
          if (fl == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if ((fl & O_NONBLOCK) == 0)
            {
              printf ("socketpair(SOCK_NONBLOCK) does not set non-blocking mode for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      pthread_barrier_init (&b, NULL, 2);
    
      struct sockaddr_in sin;
      pthread_t th;
      if (pthread_create (&th, NULL, tf, NULL) != 0)
        {
          puts ("pthread_create failed");
          return 1;
        }
    
      int s = socket (AF_INET, SOCK_STREAM, 0);
      int reuse = 1;
      setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof (reuse));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      bind (s, (struct sockaddr *) &sin, sizeof (sin));
      listen (s, SOMAXCONN);
    
      pthread_barrier_wait (&b);
    
      int s2 = paccept (s, NULL, 0, NULL, 0);
      if (s2 < 0)
        {
          puts ("paccept(0) failed");
          return 1;
        }
    
      fl = fcntl (s2, F_GETFL);
      if (fl & O_NONBLOCK)
        {
          puts ("paccept(0) set non-blocking mode");
          return 1;
        }
      close (s2);
      close (s);
    
      pthread_barrier_wait (&b);
    
      s = socket (AF_INET, SOCK_STREAM, 0);
      sin.sin_port = htons (PORT);
      setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof (reuse));
      bind (s, (struct sockaddr *) &sin, sizeof (sin));
      listen (s, SOMAXCONN);
    
      pthread_barrier_wait (&b);
    
      s2 = paccept (s, NULL, 0, NULL, SOCK_NONBLOCK);
      if (s2 < 0)
        {
          puts ("paccept(SOCK_NONBLOCK) failed");
          return 1;
        }
    
      fl = fcntl (s2, F_GETFL);
      if ((fl & O_NONBLOCK) == 0)
        {
          puts ("paccept(SOCK_NONBLOCK) does not set non-blocking mode");
          return 1;
        }
      close (s2);
      close (s);
    
      pthread_barrier_wait (&b);
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 39a23af059b4..2f999fbb188d 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -20,7 +20,7 @@
 
 #include <linux/wait.h>
 #include <linux/socket.h>
-#include <linux/fcntl.h>	/* For O_CLOEXEC */
+#include <linux/fcntl.h>	/* For O_CLOEXEC and O_NONBLOCK */
 #include <asm/socket.h>
 
 struct poll_table_struct;

commit c019bbc612f6633ede7ed67725cbf68de45ae8a4
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:21 2008 -0700

    flag parameters: paccept w/out set_restore_sigmask
    
    Some platforms do not have support to restore the signal mask in the
    return path from a syscall.  For those platforms syscalls like pselect are
    not defined at all.  This is, I think, not a good choice for paccept()
    since paccept() adds more value on top of accept() than just the signal
    mask handling.
    
    Therefore this patch defines a scaled down version of the sys_paccept
    function for those platforms.  It returns -EINVAL in case the signal mask
    is non-NULL but behaves the same otherwise.
    
    Note that I explicitly included <linux/thread_info.h>.  I saw that it is
    currently included but indirectly two levels down.  There is too much risk
    in relying on this.  The header might change and then suddenly the
    function definition would change without anyone immediately noticing.
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 3a9b06d4d0fe..39a23af059b4 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -102,6 +102,9 @@ enum sock_type {
 
 /* Flags for socket, socketpair, paccept */
 #define SOCK_CLOEXEC	O_CLOEXEC
+#ifndef SOCK_NONBLOCK
+#define SOCK_NONBLOCK	O_NONBLOCK
+#endif
 
 #endif /* ARCH_HAS_SOCKET_TYPES */
 

commit aaca0bdca573f3f51ea03139f9c7289541e7bca3
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:20 2008 -0700

    flag parameters: paccept
    
    This patch is by far the most complex in the series.  It adds a new syscall
    paccept.  This syscall differs from accept in that it adds (at the userlevel)
    two additional parameters:
    
    - a signal mask
    - a flags value
    
    The flags parameter can be used to set flag like SOCK_CLOEXEC.  This is
    imlpemented here as well.  Some people argued that this is a property which
    should be inherited from the file desriptor for the server but this is against
    POSIX.  Additionally, we really want the signal mask parameter as well
    (similar to pselect, ppoll, etc).  So an interface change in inevitable.
    
    The flag value is the same as for socket and socketpair.  I think diverging
    here will only create confusion.  Similar to the filesystem interfaces where
    the use of the O_* constants differs, it is acceptable here.
    
    The signal mask is handled as for pselect etc.  The mask is temporarily
    installed for the thread and removed before the call returns.  I modeled the
    code after pselect.  If there is a problem it's likely also in pselect.
    
    For architectures which use socketcall I maintained this interface instead of
    adding a system call.  The symmetry shouldn't be broken.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <errno.h>
    #include <fcntl.h>
    #include <pthread.h>
    #include <signal.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <netinet/in.h>
    #include <sys/socket.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_paccept
    # ifdef __x86_64__
    #  define __NR_paccept 288
    # elif defined __i386__
    #  define SYS_PACCEPT 18
    #  define USE_SOCKETCALL 1
    # else
    #  error "need __NR_paccept"
    # endif
    #endif
    
    #ifdef USE_SOCKETCALL
    # define paccept(fd, addr, addrlen, mask, flags) \
      ({ long args[6] = { \
           (long) fd, (long) addr, (long) addrlen, (long) mask, 8, (long) flags }; \
         syscall (__NR_socketcall, SYS_PACCEPT, args); })
    #else
    # define paccept(fd, addr, addrlen, mask, flags) \
      syscall (__NR_paccept, fd, addr, addrlen, mask, 8, flags)
    #endif
    
    #define PORT 57392
    
    #define SOCK_CLOEXEC O_CLOEXEC
    
    static pthread_barrier_t b;
    
    static void *
    tf (void *arg)
    {
      pthread_barrier_wait (&b);
      int s = socket (AF_INET, SOCK_STREAM, 0);
      struct sockaddr_in sin;
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
    
      pthread_barrier_wait (&b);
      s = socket (AF_INET, SOCK_STREAM, 0);
      sin.sin_port = htons (PORT);
      connect (s, (const struct sockaddr *) &sin, sizeof (sin));
      close (s);
      pthread_barrier_wait (&b);
    
      pthread_barrier_wait (&b);
      sleep (2);
      pthread_kill ((pthread_t) arg, SIGUSR1);
    
      return NULL;
    }
    
    static void
    handler (int s)
    {
    }
    
    int
    main (void)
    {
      pthread_barrier_init (&b, NULL, 2);
    
      struct sockaddr_in sin;
      pthread_t th;
      if (pthread_create (&th, NULL, tf, (void *) pthread_self ()) != 0)
        {
          puts ("pthread_create failed");
          return 1;
        }
    
      int s = socket (AF_INET, SOCK_STREAM, 0);
      int reuse = 1;
      setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof (reuse));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
      sin.sin_port = htons (PORT);
      bind (s, (struct sockaddr *) &sin, sizeof (sin));
      listen (s, SOMAXCONN);
    
      pthread_barrier_wait (&b);
    
      int s2 = paccept (s, NULL, 0, NULL, 0);
      if (s2 < 0)
        {
          puts ("paccept(0) failed");
          return 1;
        }
    
      int coe = fcntl (s2, F_GETFD);
      if (coe & FD_CLOEXEC)
        {
          puts ("paccept(0) set close-on-exec-flag");
          return 1;
        }
      close (s2);
    
      pthread_barrier_wait (&b);
    
      s2 = paccept (s, NULL, 0, NULL, SOCK_CLOEXEC);
      if (s2 < 0)
        {
          puts ("paccept(SOCK_CLOEXEC) failed");
          return 1;
        }
    
      coe = fcntl (s2, F_GETFD);
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("paccept(SOCK_CLOEXEC) does not set close-on-exec flag");
          return 1;
        }
      close (s2);
    
      pthread_barrier_wait (&b);
    
      struct sigaction sa;
      sa.sa_handler = handler;
      sa.sa_flags = 0;
      sigemptyset (&sa.sa_mask);
      sigaction (SIGUSR1, &sa, NULL);
    
      sigset_t ss;
      pthread_sigmask (SIG_SETMASK, NULL, &ss);
      sigaddset (&ss, SIGUSR1);
      pthread_sigmask (SIG_SETMASK, &ss, NULL);
    
      sigdelset (&ss, SIGUSR1);
      alarm (4);
      pthread_barrier_wait (&b);
    
      errno = 0 ;
      s2 = paccept (s, NULL, 0, &ss, 0);
      if (s2 != -1 || errno != EINTR)
        {
          puts ("paccept did not fail with EINTR");
          return 1;
        }
    
      close (s);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    [akpm@linux-foundation.org: make it compile]
    [akpm@linux-foundation.org: add sys_ni stub]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 8b5383c45b45..3a9b06d4d0fe 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -47,6 +47,7 @@ struct net;
 #define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
 #define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
 #define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
+#define SYS_PACCEPT	18		/* sys_paccept(2)		*/
 
 typedef enum {
 	SS_FREE = 0,			/* not allocated		*/
@@ -219,6 +220,8 @@ extern int 	     sock_map_fd(struct socket *sock, int flags);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);
+extern long	     do_accept(int fd, struct sockaddr __user *upeer_sockaddr,
+			       int __user *upeer_addrlen, int flags);
 
 #define net_random()		random32()
 #define net_srandom(seed)	srandom32((__force u32)seed)

commit a677a039be7243357d93502bff2b40850c942e2d
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:17 2008 -0700

    flag parameters: socket and socketpair
    
    This patch adds support for flag values which are ORed to the type passwd
    to socket and socketpair.  The additional code is minimal.  The flag
    values in this implementation can and must match the O_* flags.  This
    avoids overhead in the conversion.
    
    The internal functions sock_alloc_fd and sock_map_fd get a new parameters
    and all callers are changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <netinet/in.h>
    #include <sys/socket.h>
    
    #define PORT 57392
    
    /* For Linux these must be the same.  */
    #define SOCK_CLOEXEC O_CLOEXEC
    
    int
    main (void)
    {
      int fd;
      fd = socket (PF_INET, SOCK_STREAM, 0);
      if (fd == -1)
        {
          puts ("socket(0) failed");
          return 1;
        }
      int coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if (coe & FD_CLOEXEC)
        {
          puts ("socket(0) set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      fd = socket (PF_INET, SOCK_STREAM|SOCK_CLOEXEC, 0);
      if (fd == -1)
        {
          puts ("socket(SOCK_CLOEXEC) failed");
          return 1;
        }
      coe = fcntl (fd, F_GETFD);
      if (coe == -1)
        {
          puts ("fcntl failed");
          return 1;
        }
      if ((coe & FD_CLOEXEC) == 0)
        {
          puts ("socket(SOCK_CLOEXEC) does not set close-on-exec flag");
          return 1;
        }
      close (fd);
    
      int fds[2];
      if (socketpair (PF_UNIX, SOCK_STREAM, 0, fds) == -1)
        {
          puts ("socketpair(0) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          coe = fcntl (fds[i], F_GETFD);
          if (coe == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if (coe & FD_CLOEXEC)
            {
              printf ("socketpair(0) set close-on-exec flag for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      if (socketpair (PF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0, fds) == -1)
        {
          puts ("socketpair(SOCK_CLOEXEC) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          coe = fcntl (fds[i], F_GETFD);
          if (coe == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if ((coe & FD_CLOEXEC) == 0)
            {
              printf ("socketpair(SOCK_CLOEXEC) does not set close-on-exec flag for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 150a48c68d52..8b5383c45b45 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -20,6 +20,7 @@
 
 #include <linux/wait.h>
 #include <linux/socket.h>
+#include <linux/fcntl.h>	/* For O_CLOEXEC */
 #include <asm/socket.h>
 
 struct poll_table_struct;
@@ -94,6 +95,12 @@ enum sock_type {
 };
 
 #define SOCK_MAX (SOCK_PACKET + 1)
+/* Mask which covers at least up to SOCK_MASK-1.  The
+ * remaining bits are used as flags. */
+#define SOCK_TYPE_MASK 0xf
+
+/* Flags for socket, socketpair, paccept */
+#define SOCK_CLOEXEC	O_CLOEXEC
 
 #endif /* ARCH_HAS_SOCKET_TYPES */
 
@@ -208,7 +215,7 @@ extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
 				  size_t len);
 extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
 				  size_t size, int flags);
-extern int 	     sock_map_fd(struct socket *sock);
+extern int 	     sock_map_fd(struct socket *sock, int flags);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);

commit 2c693610fe923764fe41b846fb86938a2010da6e
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Tue Jul 8 03:03:01 2008 -0700

    net: remove padding from struct socket on 64bit & increase objects/cache
    
    remove padding from struct socket reducing its size by 8 bytes.
    
    This allows more objects/cache in sock_inode_cache
    12 objects/cache when cacheline size is 128 (generic x86_64)
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 71f7dd559285..150a48c68d52 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -106,23 +106,23 @@ enum sock_shutdown_cmd {
 /**
  *  struct socket - general BSD socket
  *  @state: socket state (%SS_CONNECTED, etc)
+ *  @type: socket type (%SOCK_STREAM, etc)
  *  @flags: socket flags (%SOCK_ASYNC_NOSPACE, etc)
  *  @ops: protocol specific socket operations
  *  @fasync_list: Asynchronous wake up list
  *  @file: File back pointer for gc
  *  @sk: internal networking protocol agnostic socket representation
  *  @wait: wait queue for several uses
- *  @type: socket type (%SOCK_STREAM, etc)
  */
 struct socket {
 	socket_state		state;
+	short			type;
 	unsigned long		flags;
 	const struct proto_ops	*ops;
 	struct fasync_struct	*fasync_list;
 	struct file		*file;
 	struct sock		*sk;
 	wait_queue_head_t	wait;
-	short			type;
 };
 
 struct vm_area_struct;

commit 0098b7273e968fb9989a6e1e4e4c024cd081fe0d
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Mar 22 17:18:47 2008 -0700

    [NET]: NPROTO is redundant; it's equal to AF_MAX/PF_MAX.
    
    DaveM pointed out NPROTO exposed to userspace, so keep it around,
    just make sure it stays in sync.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index c414d90e647b..71f7dd559285 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -19,6 +19,7 @@
 #define _LINUX_NET_H
 
 #include <linux/wait.h>
+#include <linux/socket.h>
 #include <asm/socket.h>
 
 struct poll_table_struct;
@@ -26,7 +27,7 @@ struct pipe_inode_info;
 struct inode;
 struct net;
 
-#define NPROTO		34		/* should be enough for now..	*/
+#define NPROTO		AF_MAX
 
 #define SYS_SOCKET	1		/* sys_socket(2)		*/
 #define SYS_BIND	2		/* sys_bind(2)			*/

commit 08913681e484f3f0db949dd0809012e089846216
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Wed Dec 5 01:42:49 2007 -0800

    [NET]: Remove the empty net_table
    
    I have removed all the entries from this table (core_table,
    ipv4_table and tr_table), so now we can safely drop it.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index f95f12c5840c..c414d90e647b 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -337,7 +337,6 @@ static const struct proto_ops name##_ops = {			\
 
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
-extern ctl_table net_table[];
 extern int net_msg_cost;
 extern int net_msg_burst;
 #endif

commit 8d8ad9d7c4bfe79bc91b7fc419ecfb9dcdfe6a51
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Mon Nov 26 20:10:50 2007 +0800

    [NET]: Name magic constants in sock_wake_async()
    
    The sock_wake_async() performs a bit different actions
    depending on "how" argument. Unfortunately this argument
    ony has numerical magic values.
    
    I propose to give names to their constants to help people
    reading this function callers understand what's going on
    without looking into this function all the time.
    
    I suppose this is 2.6.25 material, but if it's not (or the
    naming seems poor/bad/awful), I can rework it against the
    current net-2.6 tree.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 0235d917d5c3..f95f12c5840c 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -186,6 +186,13 @@ struct net_proto_family {
 struct iovec;
 struct kvec;
 
+enum {
+	SOCK_WAKE_IO,
+	SOCK_WAKE_WAITD,
+	SOCK_WAKE_SPACE,
+	SOCK_WAKE_URG,
+};
+
 extern int	     sock_wake_async(struct socket *sk, int how, int band);
 extern int	     sock_register(const struct net_proto_family *fam);
 extern void	     sock_unregister(int family);

commit 9c55e01c0cc835818475a6ce8c4d684df9949ac8
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Nov 6 23:30:13 2007 -0800

    [TCP]: Splice receive support.
    
    Support for network splice receive.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 596131ea46f4..0235d917d5c3 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -22,6 +22,7 @@
 #include <asm/socket.h>
 
 struct poll_table_struct;
+struct pipe_inode_info;
 struct inode;
 struct net;
 
@@ -172,6 +173,8 @@ struct proto_ops {
 				      struct vm_area_struct * vma);
 	ssize_t		(*sendpage)  (struct socket *sock, struct page *page,
 				      int offset, size_t size, int flags);
+	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
+				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
 };
 
 struct net_proto_family {

commit 91cf45f02af5c871251165d000c3f42a2a0b0552
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Mon Nov 12 18:10:39 2007 -0800

    [NET]: Add the helper kernel_sock_shutdown()
    
    ...and fix a couple of bugs in the NBD, CIFS and OCFS2 socket handlers.
    
    Looking at the sock->op->shutdown() handlers, it looks as if all of them
    take a SHUT_RD/SHUT_WR/SHUT_RDWR argument instead of the
    RCV_SHUTDOWN/SEND_SHUTDOWN arguments.
    Add a helper, and then define the SHUT_* enum to ensure that kernel users
    of shutdown() don't get confused.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Acked-by: Mark Fasheh <mark.fasheh@oracle.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index dd79cdb8c4cf..596131ea46f4 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -95,6 +95,12 @@ enum sock_type {
 
 #endif /* ARCH_HAS_SOCKET_TYPES */
 
+enum sock_shutdown_cmd {
+	SHUT_RD		= 0,
+	SHUT_WR		= 1,
+	SHUT_RDWR	= 2,
+};
+
 /**
  *  struct socket - general BSD socket
  *  @state: socket state (%SS_CONNECTED, etc)
@@ -223,6 +229,8 @@ extern int kernel_setsockopt(struct socket *sock, int level, int optname,
 extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
 			   size_t size, int flags);
 extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+extern int kernel_sock_shutdown(struct socket *sock,
+				enum sock_shutdown_cmd how);
 
 #ifndef CONFIG_SMP
 #define SOCKOPS_WRAPPED(name) name

commit 305e1e96911417d8cda2699f6a20a6f434616a8c
Author: Jean Delvare <jdelvare@suse.de>
Date:   Sun Oct 21 16:44:04 2007 -0700

    [INET]: Let inet_diag and friends autoload
    
    By adding module aliases to inet_diag, tcp_diag and dccp_diag, we let
    them load automatically as needed. This makes tools like "ss" run
    faster.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index c136abce7ef6..dd79cdb8c4cf 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -313,6 +313,10 @@ static const struct proto_ops name##_ops = {			\
 #define MODULE_ALIAS_NET_PF_PROTO(pf, proto) \
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto))
 
+#define MODULE_ALIAS_NET_PF_PROTO_TYPE(pf, proto, type) \
+	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
+		     "-type-" __stringify(type))
+
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 extern ctl_table net_table[];

commit 1b8d7ae42d02e483ad94035cca851e4f7fbecb40
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 8 23:24:22 2007 -0700

    [NET]: Make socket creation namespace safe.
    
    This patch passes in the namespace a new socket should be created in
    and has the socket code do the appropriate reference counting.  By
    virtue of this all socket create methods are touched.  In addition
    the socket create methods are modified so that they will fail if
    you attempt to create a socket in a non-default network namespace.
    
    Failing if we attempt to create a socket outside of the default
    network namespace ensures that as we incrementally make the network stack
    network namespace aware we will not export functionality that someone
    has not audited and made certain is network namespace safe.
    Allowing us to partially enable network namespaces before all of the
    exotic protocols are supported.
    
    Any protocol layers I have missed will fail to compile because I now
    pass an extra parameter into the socket creation code.
    
    [ Integrated AF_IUCV build fixes from Andrew Morton... -DaveM ]
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index efc45177b503..c136abce7ef6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -23,6 +23,7 @@
 
 struct poll_table_struct;
 struct inode;
+struct net;
 
 #define NPROTO		34		/* should be enough for now..	*/
 
@@ -169,7 +170,7 @@ struct proto_ops {
 
 struct net_proto_family {
 	int		family;
-	int		(*create)(struct socket *sock, int protocol);
+	int		(*create)(struct net *net, struct socket *sock, int protocol);
 	struct module	*owner;
 };
 

commit 17926a79320afa9b95df6b977b40cca6d8713cea
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 26 15:48:28 2007 -0700

    [AF_RXRPC]: Provide secure RxRPC sockets for use by userspace and kernel both
    
    Provide AF_RXRPC sockets that can be used to talk to AFS servers, or serve
    answers to AFS clients.  KerberosIV security is fully supported.  The patches
    and some example test programs can be found in:
    
            http://people.redhat.com/~dhowells/rxrpc/
    
    This will eventually replace the old implementation of kernel-only RxRPC
    currently resident in net/rxrpc/.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4db21e63d8d2..efc45177b503 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -24,7 +24,7 @@
 struct poll_table_struct;
 struct inode;
 
-#define NPROTO		33		/* should be enough for now..	*/
+#define NPROTO		34		/* should be enough for now..	*/
 
 #define SYS_SOCKET	1		/* sys_socket(2)		*/
 #define SYS_BIND	2		/* sys_bind(2)			*/

commit eac3731bd04c7131478722a3c148b78774553116
Author: Jennifer Hunt <jenhunt@us.ibm.com>
Date:   Thu Feb 8 13:51:54 2007 -0800

    [S390]: Add AF_IUCV socket support
    
    From: Jennifer Hunt <jenhunt@us.ibm.com>
    
    This patch adds AF_IUCV socket support.
    
    Signed-off-by: Frank Pavlic <fpavlic@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index f28d8a2e2c91..4db21e63d8d2 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -24,7 +24,7 @@
 struct poll_table_struct;
 struct inode;
 
-#define NPROTO		32		/* should be enough for now..	*/
+#define NPROTO		33		/* should be enough for now..	*/
 
 #define SYS_SOCKET	1		/* sys_socket(2)		*/
 #define SYS_BIND	2		/* sys_bind(2)			*/

commit cb4db4c22182163f66325053331a4e7096f663cd
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Dec 28 21:21:55 2006 -0800

    [NET]: Don't export linux/random.h outside __KERNEL__.
    
    Don't add it there please; add it lower down inside the existing #ifdef
    __KERNEL__. You just made the _userspace_ net.h include random.h, which
    then fails to compile unless <asm/types.h> was already included.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6f0dfeba509a..f28d8a2e2c91 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -19,7 +19,6 @@
 #define _LINUX_NET_H
 
 #include <linux/wait.h>
-#include <linux/random.h>
 #include <asm/socket.h>
 
 struct poll_table_struct;
@@ -57,6 +56,7 @@ typedef enum {
 
 #ifdef __KERNEL__
 #include <linux/stringify.h>
+#include <linux/random.h>
 
 #define SOCK_ASYNC_NOSPACE	0
 #define SOCK_ASYNC_WAITDATA	1

commit a64b78a077a71c9b9c0c1b0be699083379783c3d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 14 21:12:29 2006 -0800

    [NET]: Annotate net_srandom().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 15c733b816f0..6f0dfeba509a 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -196,7 +196,7 @@ extern struct socket *sockfd_lookup(int fd, int *err);
 extern int	     net_ratelimit(void);
 
 #define net_random()		random32()
-#define net_srandom(seed)	srandom32(seed)
+#define net_srandom(seed)	srandom32((__force u32)seed)
 
 extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 				    struct kvec *vec, size_t num, size_t len);

commit aaa248f6c9c81b2683db7dbb0689cd5ed1c86d88
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Tue Oct 17 00:09:42 2006 -0700

    [PATCH] rename net_random to random32
    
    Make net_random() more widely available by calling it random32
    
    akpm: hopefully this will permit the removal of carta_random32.  That needs
    confirmation from Stephane - this code looks somewhat more computationally
    expensive, and has a different (ie: callee-stateful) interface.
    
    [akpm@osdl.org: lots of build fixes, cleanups]
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Cc: Stephane Eranian <eranian@hpl.hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index c257f716e00f..15c733b816f0 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -19,6 +19,7 @@
 #define _LINUX_NET_H
 
 #include <linux/wait.h>
+#include <linux/random.h>
 #include <asm/socket.h>
 
 struct poll_table_struct;
@@ -193,9 +194,9 @@ extern int 	     sock_map_fd(struct socket *sock);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
 extern int	     net_ratelimit(void);
-extern unsigned long net_random(void);
-extern void	     net_srandom(unsigned long);
-extern void	     net_random_init(void);
+
+#define net_random()		random32()
+#define net_srandom(seed)	srandom32(seed)
 
 extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
 				    struct kvec *vec, size_t num, size_t len);

commit f0fd27d42e39b91f85e1840ec49b072fd6c545b8
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Aug 9 21:03:17 2006 -0700

    [NET]: sock_register interface changes
    
    The sock_register() doesn't change the family, so the protocols can
    define it read-only.  No caller ever checks return value from
    sock_unregister()
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 1bd76327ee2b..c257f716e00f 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -176,8 +176,8 @@ struct iovec;
 struct kvec;
 
 extern int	     sock_wake_async(struct socket *sk, int how, int band);
-extern int	     sock_register(struct net_proto_family *fam);
-extern int	     sock_unregister(int family);
+extern int	     sock_register(const struct net_proto_family *fam);
+extern void	     sock_unregister(int family);
 extern int	     sock_create(int family, int type, int proto,
 				 struct socket **res);
 extern int	     sock_create_kern(int family, int type, int proto,

commit 757dbb494be3309fe41ce4c62f8057d8b41d8897
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Aug 9 20:50:00 2006 -0700

    [NET]: drop unused elements from net_proto_family
    
    Three values in net_proto_family are defined but never used.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 19da2c08d7b6..1bd76327ee2b 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -169,11 +169,6 @@ struct proto_ops {
 struct net_proto_family {
 	int		family;
 	int		(*create)(struct socket *sock, int protocol);
-	/* These are counters for the number of different methods of
-	   each we support */
-	short		authentication;
-	short		encryption;
-	short		encrypt_net;
 	struct module	*owner;
 };
 

commit ac5a488ef252ed673cb067843e411f8cc43f7ab9
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Mon Aug 7 20:57:31 2006 -0700

    [NET]: Round out in-kernel sockets API
    
    This patch implements wrapper functions that provide a convenient way
    to access the sockets API for in-kernel users like sunrpc, cifs &
    ocfs2 etc and any future users.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index b20c53c74413..19da2c08d7b6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -208,6 +208,25 @@ extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
 				    struct kvec *vec, size_t num,
 				    size_t len, int flags);
 
+extern int kernel_bind(struct socket *sock, struct sockaddr *addr,
+		       int addrlen);
+extern int kernel_listen(struct socket *sock, int backlog);
+extern int kernel_accept(struct socket *sock, struct socket **newsock,
+			 int flags);
+extern int kernel_connect(struct socket *sock, struct sockaddr *addr,
+			  int addrlen, int flags);
+extern int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
+			      int *addrlen);
+extern int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
+			      int *addrlen);
+extern int kernel_getsockopt(struct socket *sock, int level, int optname,
+			     char *optval, int *optlen);
+extern int kernel_setsockopt(struct socket *sock, int level, int optname,
+			     char *optval, int optlen);
+extern int kernel_sendpage(struct socket *sock, struct page *page, int offset,
+			   size_t size, int flags);
+extern int kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg);
+
 #ifndef CONFIG_SMP
 #define SOCKOPS_WRAPPED(name) name
 #define SOCKOPS_WRAP(name, fam)

commit 877ce7c1b3afd69a9b1caeb1b9964c992641f52a
Author: Catherine Zhang <cxzhang@watson.ibm.com>
Date:   Thu Jun 29 12:27:47 2006 -0700

    [AF_UNIX]: Datagram getpeersec
    
    This patch implements an API whereby an application can determine the
    label of its peer's Unix datagram sockets via the auxiliary data mechanism of
    recvmsg.
    
    Patch purpose:
    
    This patch enables a security-aware application to retrieve the
    security context of the peer of a Unix datagram socket.  The application
    can then use this security context to determine the security context for
    processing on behalf of the peer who sent the packet.
    
    Patch design and implementation:
    
    The design and implementation is very similar to the UDP case for INET
    sockets.  Basically we build upon the existing Unix domain socket API for
    retrieving user credentials.  Linux offers the API for obtaining user
    credentials via ancillary messages (i.e., out of band/control messages
    that are bundled together with a normal message).  To retrieve the security
    context, the application first indicates to the kernel such desire by
    setting the SO_PASSSEC option via getsockopt.  Then the application
    retrieves the security context using the auxiliary data mechanism.
    
    An example server application for Unix datagram socket should look like this:
    
    toggle = 1;
    toggle_len = sizeof(toggle);
    
    setsockopt(sockfd, SOL_SOCKET, SO_PASSSEC, &toggle, &toggle_len);
    recvmsg(sockfd, &msg_hdr, 0);
    if (msg_hdr.msg_controllen > sizeof(struct cmsghdr)) {
        cmsg_hdr = CMSG_FIRSTHDR(&msg_hdr);
        if (cmsg_hdr->cmsg_len <= CMSG_LEN(sizeof(scontext)) &&
            cmsg_hdr->cmsg_level == SOL_SOCKET &&
            cmsg_hdr->cmsg_type == SCM_SECURITY) {
            memcpy(&scontext, CMSG_DATA(cmsg_hdr), sizeof(scontext));
        }
    }
    
    sock_setsockopt is enhanced with a new socket option SOCK_PASSSEC to allow
    a server socket to receive security context of the peer.
    
    Testing:
    
    We have tested the patch by setting up Unix datagram client and server
    applications.  We verified that the server can retrieve the security context
    using the auxiliary data mechanism of recvmsg.
    
    Signed-off-by: Catherine Zhang <cxzhang@watson.ibm.com>
    Acked-by: Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 385e68f5bd93..b20c53c74413 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -61,6 +61,7 @@ typedef enum {
 #define SOCK_ASYNC_WAITDATA	1
 #define SOCK_NOSPACE		2
 #define SOCK_PASSCRED		3
+#define SOCK_PASSSEC		4
 
 #ifndef ARCH_HAS_SOCKET_TYPES
 /**

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index c88d7cf7f6b7..385e68f5bd93 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -18,7 +18,6 @@
 #ifndef _LINUX_NET_H
 #define _LINUX_NET_H
 
-#include <linux/config.h>
 #include <linux/wait.h>
 #include <asm/socket.h>
 

commit eacf17bdbc8e6f24fe46cd7e10fb9a657f060d08
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Tue Apr 25 14:46:09 2006 +0100

    Don't include <linux/stringify> from user-visible part of linux/net.h
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 84a490e5f0a1..c88d7cf7f6b7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -20,7 +20,6 @@
 
 #include <linux/config.h>
 #include <linux/wait.h>
-#include <linux/stringify.h>
 #include <asm/socket.h>
 
 struct poll_table_struct;
@@ -57,6 +56,7 @@ typedef enum {
 #define __SO_ACCEPTCON	(1 << 16)	/* performed a listen		*/
 
 #ifdef __KERNEL__
+#include <linux/stringify.h>
 
 #define SOCK_ASYNC_NOSPACE	0
 #define SOCK_ASYNC_WAITDATA	1

commit 89bbfc95d65839d6ae23ddab8a3cc5af4ae88383
Author: Shaun Pereira <spereira@tusc.com.au>
Date:   Tue Mar 21 23:58:08 2006 -0800

    [NET]: allow 32 bit socket ioctl in 64 bit kernel
    
    Since the register_ioctl32_conversion() patch in the kernel is now obsolete,
    provide another method to allow 32 bit user space ioctls to reach the kernel.
    
    Signed-off-by: Shaun Pereira <spereira@tusc.com.au>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 152fa6551fd8..84a490e5f0a1 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -143,6 +143,8 @@ struct proto_ops {
 				      struct poll_table_struct *wait);
 	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
 				      unsigned long arg);
+	int	 	(*compat_ioctl) (struct socket *sock, unsigned int cmd,
+				      unsigned long arg);
 	int		(*listen)    (struct socket *sock, int len);
 	int		(*shutdown)  (struct socket *sock, int flags);
 	int		(*setsockopt)(struct socket *sock, int level,
@@ -251,6 +253,8 @@ SOCKCALL_UWRAP(name, poll, (struct file *file, struct socket *sock, struct poll_
 	      (file, sock, wait)) \
 SOCKCALL_WRAP(name, ioctl, (struct socket *sock, unsigned int cmd, \
 			 unsigned long arg), (sock, cmd, arg)) \
+SOCKCALL_WRAP(name, compat_ioctl, (struct socket *sock, unsigned int cmd, \
+			 unsigned long arg), (sock, cmd, arg)) \
 SOCKCALL_WRAP(name, listen, (struct socket *sock, int len), (sock, len)) \
 SOCKCALL_WRAP(name, shutdown, (struct socket *sock, int flags), (sock, flags)) \
 SOCKCALL_WRAP(name, setsockopt, (struct socket *sock, int level, int optname, \
@@ -275,6 +279,7 @@ static const struct proto_ops name##_ops = {			\
 	.getname	= __lock_##name##_getname,	\
 	.poll		= __lock_##name##_poll,		\
 	.ioctl		= __lock_##name##_ioctl,	\
+	.compat_ioctl	= __lock_##name##_compat_ioctl,	\
 	.listen		= __lock_##name##_listen,	\
 	.shutdown	= __lock_##name##_shutdown,	\
 	.setsockopt	= __lock_##name##_setsockopt,	\
@@ -283,6 +288,7 @@ static const struct proto_ops name##_ops = {			\
 	.recvmsg	= __lock_##name##_recvmsg,	\
 	.mmap		= __lock_##name##_mmap,		\
 };
+
 #endif
 
 #define MODULE_ALIAS_NETPROTO(proto) \

commit 3fdadf7d27e3fbcf72930941884387d1f4936f04
Author: Dmitry Mishin <dim@openvz.org>
Date:   Mon Mar 20 22:45:21 2006 -0800

    [NET]: {get|set}sockopt compatibility layer
    
    This patch extends {get|set}sockopt compatibility layer in order to
    move protocol specific parts to their place and avoid huge universal
    net/compat.c file in the future.
    
    Signed-off-by: Dmitry Mishin <dim@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 28195a2d8ff0..152fa6551fd8 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -149,6 +149,10 @@ struct proto_ops {
 				      int optname, char __user *optval, int optlen);
 	int		(*getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
+	int		(*compat_setsockopt)(struct socket *sock, int level,
+				      int optname, char __user *optval, int optlen);
+	int		(*compat_getsockopt)(struct socket *sock, int level,
+				      int optname, char __user *optval, int __user *optlen);
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
 				      struct msghdr *m, size_t total_len);
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,

commit 90ddc4f0470427df306f308ad03db6b6b21644b8
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Thu Dec 22 12:49:22 2005 -0800

    [NET]: move struct proto_ops to const
    
    I noticed that some of 'struct proto_ops' used in the kernel may share
    a cache line used by locks or other heavily modified data. (default
    linker alignement is 32 bytes, and L1_CACHE_LINE is 64 or 128 at
    least)
    
    This patch makes sure a 'struct proto_ops' can be declared as const,
    so that all cpus can share all parts of it without false sharing.
    
    This is not mandatory : a driver can still use a read/write structure
    if it needs to (and eventually a __read_mostly)
    
    I made a global stubstitute to change all existing occurences to make
    them const.
    
    This should reduce the possibility of false sharing on SMP, and
    speedup some socket system calls.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index d6a41e6577f6..28195a2d8ff0 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -107,7 +107,7 @@ enum sock_type {
 struct socket {
 	socket_state		state;
 	unsigned long		flags;
-	struct proto_ops	*ops;
+	const struct proto_ops	*ops;
 	struct fasync_struct	*fasync_list;
 	struct file		*file;
 	struct sock		*sk;
@@ -260,7 +260,7 @@ SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct ms
 SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
 	      (file, sock, vma)) \
 	      \
-static struct proto_ops name##_ops = {			\
+static const struct proto_ops name##_ops = {			\
 	.family		= fam,				\
 	.owner		= THIS_MODULE,			\
 	.release	= __lock_##name##_release,	\

commit 8f2709b542c96a2b1910ca5f2fe27dc9023b1225
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Nov 7 01:01:05 2005 -0800

    [PATCH] kernel-doc: fix some kernel-api warnings
    
    Fix various warnings in kernel-doc:
    
    Warning(linux-2614-rc4//include/linux/net.h:89): Enum value 'SOCK_DCCP' not described in enum 'sock_type'
    
    usercopy.c: should use !E instead of !I for exported symbols:
    Warning(linux-2614-rc4//arch/i386/lib/usercopy.c): no structured comments found
    
    fs.h does not need to use !E since it has no exported symbols:
    Warning(linux-2614-rc4//include/linux/fs.h:1182): No description found for parameter 'find_exported_dentry'
    Warning(linux-2614-rc4//include/linux/fs.h): no structured comments found
    
    irq/manage.c should use !E for its exported symbols:
    Warning(linux-2614-rc4//kernel/irq/manage.c): no structured comments found
    
    macmodes.c should use !E for its exported symbols:
    Warning(linux-2614-rc4//drivers/video/macmodes.c): no structured comments found
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 4e981585a89a..d6a41e6577f6 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -71,6 +71,7 @@ typedef enum {
  * @SOCK_RAW: raw socket
  * @SOCK_RDM: reliably-delivered message
  * @SOCK_SEQPACKET: sequential packet socket
+ * @SOCK_DCCP: Datagram Congestion Control Protocol socket
  * @SOCK_PACKET: linux specific way of getting packets at the dev level.
  *		  For writing rarp and other similar things on the user level.
  *

commit 20380731bc2897f2952ae055420972ded4cd786e
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 16 02:18:02 2005 -0300

    [NET]: Fix sparse warnings
    
    Of this type, mostly:
    
    CHECK   net/ipv6/netfilter.c
    net/ipv6/netfilter.c:96:12: warning: symbol 'ipv6_netfilter_init' was not declared. Should it be static?
    net/ipv6/netfilter.c:101:6: warning: symbol 'ipv6_netfilter_fini' was not declared. Should it be static?
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 5f8b632ff653..4e981585a89a 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -286,5 +286,12 @@ static struct proto_ops name##_ops = {			\
 #define MODULE_ALIAS_NET_PF_PROTO(pf, proto) \
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto))
 
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+extern ctl_table net_table[];
+extern int net_msg_cost;
+extern int net_msg_burst;
+#endif
+
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */

commit 7c657876b63cb1d8a2ec06f8fc6c37bb8412e66c
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:14:34 2005 -0700

    [DCCP]: Initial implementation
    
    Development to this point was done on a subversion repository at:
    
    http://oops.ghostprotocols.net:81/cgi-bin/viewcvs.cgi/dccp-2.6/
    
    This repository will be kept at this site for the foreseable future,
    so that interested parties can see the history of this code,
    attributions, etc.
    
    If I ever decide to take this offline I'll provide the full history at
    some other suitable place.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 39906619b9d7..5f8b632ff653 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -84,6 +84,7 @@ enum sock_type {
 	SOCK_RAW	= 3,
 	SOCK_RDM	= 4,
 	SOCK_SEQPACKET	= 5,
+	SOCK_DCCP	= 6,
 	SOCK_PACKET	= 10,
 };
 

commit 4fdb3bb723db469717c6d38fda667d8b0fa86ebd
Author: Harald Welte <laforge@netfilter.org>
Date:   Tue Aug 9 19:40:55 2005 -0700

    [NETLINK]: Add properly module refcounting for kernel netlink sockets.
    
    - Remove bogus code for compiling netlink as module
    - Add module refcounting support for modules implementing a netlink
      protocol
    - Add support for autoloading modules that implement a netlink protocol
      as soon as someone opens a socket for that protocol
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 20cb226b2268..39906619b9d7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -282,5 +282,8 @@ static struct proto_ops name##_ops = {			\
 #define MODULE_ALIAS_NETPROTO(proto) \
 	MODULE_ALIAS("net-pf-" __stringify(proto))
 
+#define MODULE_ALIAS_NET_PF_PROTO(pf, proto) \
+	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto))
+
 #endif /* __KERNEL__ */
 #endif	/* _LINUX_NET_H */

commit deaf2622bdc74270381873c7936c91500c683853
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 23 12:45:26 2005 -0700

    [NET]: Kill stray reference to sock->passcred.
    
    That struct member was deleted, but a comment
    was not updated to reflect this.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/net.h b/include/linux/net.h
index 6d997ff3f103..20cb226b2268 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -101,7 +101,6 @@ enum sock_type {
  *  @sk: internal networking protocol agnostic socket representation
  *  @wait: wait queue for several uses
  *  @type: socket type (%SOCK_STREAM, etc)
- *  @passcred: credentials (used only in Unix Sockets (aka PF_LOCAL))
  */
 struct socket {
 	socket_state		state;

commit 02c30a84e6298b6b20a56f0896ac80b47839e134
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Thu May 5 16:16:16 2005 -0700

    [PATCH] update Ross Biro bouncing email address
    
    Ross moved.  Remove the bad email address so people will find the correct
    one in ./CREDITS.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index e5914c1f0c4d..6d997ff3f103 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -7,7 +7,7 @@
  * Version:	@(#)net.h	1.0.3	05/25/93
  *
  * Authors:	Orest Zborowski, <obz@Kodak.COM>
- *		Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  *
  *		This program is free software; you can redistribute it and/or

commit 4dc3b16ba18c0f967ad100c52fa65b01a4f76ff0
Author: Pavel Pisa <pisa@cmp.felk.cvut.cz>
Date:   Sun May 1 08:59:25 2005 -0700

    [PATCH] DocBook: changes and extensions to the kernel documentation
    
    I have recompiled Linux kernel 2.6.11.5 documentation for me and our
    university students again.  The documentation could be extended for more
    sources which are equipped by structured comments for recent 2.6 kernels.  I
    have tried to proceed with that task.  I have done that more times from 2.6.0
    time and it gets boring to do same changes again and again.  Linux kernel
    compiles after changes for i386 and ARM targets.  I have added references to
    some more files into kernel-api book, I have added some section names as well.
     So please, check that changes do not break something and that categories are
    not too much skewed.
    
    I have changed kernel-doc to accept "fastcall" and "asmlinkage" words reserved
    by kernel convention.  Most of the other changes are modifications in the
    comments to make kernel-doc happy, accept some parameters description and do
    not bail out on errors.  Changed <pid> to @pid in the description, moved some
    #ifdef before comments to correct function to comments bindings, etc.
    
    You can see result of the modified documentation build at
      http://cmp.felk.cvut.cz/~pisa/linux/lkdb-2.6.11.tar.gz
    
    Some more sources are ready to be included into kernel-doc generated
    documentation.  Sources has been added into kernel-api for now.  Some more
    section names added and probably some more chaos introduced as result of quick
    cleanup work.
    
    Signed-off-by: Pavel Pisa <pisa@cmp.felk.cvut.cz>
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/net.h b/include/linux/net.h
index 7823b3482506..e5914c1f0c4d 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -64,19 +64,19 @@ typedef enum {
 #define SOCK_PASSCRED		3
 
 #ifndef ARCH_HAS_SOCKET_TYPES
-/** sock_type - Socket types
- * 
+/**
+ * enum sock_type - Socket types
+ * @SOCK_STREAM: stream (connection) socket
+ * @SOCK_DGRAM: datagram (conn.less) socket
+ * @SOCK_RAW: raw socket
+ * @SOCK_RDM: reliably-delivered message
+ * @SOCK_SEQPACKET: sequential packet socket
+ * @SOCK_PACKET: linux specific way of getting packets at the dev level.
+ *		  For writing rarp and other similar things on the user level.
+ *
  * When adding some new socket type please
  * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
  * overrides this enum for binary compat reasons.
- * 
- * @SOCK_STREAM - stream (connection) socket
- * @SOCK_DGRAM - datagram (conn.less) socket
- * @SOCK_RAW - raw socket
- * @SOCK_RDM - reliably-delivered message
- * @SOCK_SEQPACKET - sequential packet socket 
- * @SOCK_PACKET - linux specific way of getting packets at the dev level.
- *		  For writing rarp and other similar things on the user level.
  */
 enum sock_type {
 	SOCK_STREAM	= 1,
@@ -93,15 +93,15 @@ enum sock_type {
 
 /**
  *  struct socket - general BSD socket
- *  @state - socket state (%SS_CONNECTED, etc)
- *  @flags - socket flags (%SOCK_ASYNC_NOSPACE, etc)
- *  @ops - protocol specific socket operations
- *  @fasync_list - Asynchronous wake up list
- *  @file - File back pointer for gc
- *  @sk - internal networking protocol agnostic socket representation
- *  @wait - wait queue for several uses
- *  @type - socket type (%SOCK_STREAM, etc)
- *  @passcred - credentials (used only in Unix Sockets (aka PF_LOCAL))
+ *  @state: socket state (%SS_CONNECTED, etc)
+ *  @flags: socket flags (%SOCK_ASYNC_NOSPACE, etc)
+ *  @ops: protocol specific socket operations
+ *  @fasync_list: Asynchronous wake up list
+ *  @file: File back pointer for gc
+ *  @sk: internal networking protocol agnostic socket representation
+ *  @wait: wait queue for several uses
+ *  @type: socket type (%SOCK_STREAM, etc)
+ *  @passcred: credentials (used only in Unix Sockets (aka PF_LOCAL))
  */
 struct socket {
 	socket_state		state;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/net.h b/include/linux/net.h
new file mode 100644
index 000000000000..7823b3482506
--- /dev/null
+++ b/include/linux/net.h
@@ -0,0 +1,287 @@
+/*
+ * NET		An implementation of the SOCKET network access protocol.
+ *		This is the master header file for the Linux NET layer,
+ *		or, in plain English: the networking handling part of the
+ *		kernel.
+ *
+ * Version:	@(#)net.h	1.0.3	05/25/93
+ *
+ * Authors:	Orest Zborowski, <obz@Kodak.COM>
+ *		Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_NET_H
+#define _LINUX_NET_H
+
+#include <linux/config.h>
+#include <linux/wait.h>
+#include <linux/stringify.h>
+#include <asm/socket.h>
+
+struct poll_table_struct;
+struct inode;
+
+#define NPROTO		32		/* should be enough for now..	*/
+
+#define SYS_SOCKET	1		/* sys_socket(2)		*/
+#define SYS_BIND	2		/* sys_bind(2)			*/
+#define SYS_CONNECT	3		/* sys_connect(2)		*/
+#define SYS_LISTEN	4		/* sys_listen(2)		*/
+#define SYS_ACCEPT	5		/* sys_accept(2)		*/
+#define SYS_GETSOCKNAME	6		/* sys_getsockname(2)		*/
+#define SYS_GETPEERNAME	7		/* sys_getpeername(2)		*/
+#define SYS_SOCKETPAIR	8		/* sys_socketpair(2)		*/
+#define SYS_SEND	9		/* sys_send(2)			*/
+#define SYS_RECV	10		/* sys_recv(2)			*/
+#define SYS_SENDTO	11		/* sys_sendto(2)		*/
+#define SYS_RECVFROM	12		/* sys_recvfrom(2)		*/
+#define SYS_SHUTDOWN	13		/* sys_shutdown(2)		*/
+#define SYS_SETSOCKOPT	14		/* sys_setsockopt(2)		*/
+#define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
+#define SYS_SENDMSG	16		/* sys_sendmsg(2)		*/
+#define SYS_RECVMSG	17		/* sys_recvmsg(2)		*/
+
+typedef enum {
+	SS_FREE = 0,			/* not allocated		*/
+	SS_UNCONNECTED,			/* unconnected to any socket	*/
+	SS_CONNECTING,			/* in process of connecting	*/
+	SS_CONNECTED,			/* connected to socket		*/
+	SS_DISCONNECTING		/* in process of disconnecting	*/
+} socket_state;
+
+#define __SO_ACCEPTCON	(1 << 16)	/* performed a listen		*/
+
+#ifdef __KERNEL__
+
+#define SOCK_ASYNC_NOSPACE	0
+#define SOCK_ASYNC_WAITDATA	1
+#define SOCK_NOSPACE		2
+#define SOCK_PASSCRED		3
+
+#ifndef ARCH_HAS_SOCKET_TYPES
+/** sock_type - Socket types
+ * 
+ * When adding some new socket type please
+ * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
+ * overrides this enum for binary compat reasons.
+ * 
+ * @SOCK_STREAM - stream (connection) socket
+ * @SOCK_DGRAM - datagram (conn.less) socket
+ * @SOCK_RAW - raw socket
+ * @SOCK_RDM - reliably-delivered message
+ * @SOCK_SEQPACKET - sequential packet socket 
+ * @SOCK_PACKET - linux specific way of getting packets at the dev level.
+ *		  For writing rarp and other similar things on the user level.
+ */
+enum sock_type {
+	SOCK_STREAM	= 1,
+	SOCK_DGRAM	= 2,
+	SOCK_RAW	= 3,
+	SOCK_RDM	= 4,
+	SOCK_SEQPACKET	= 5,
+	SOCK_PACKET	= 10,
+};
+
+#define SOCK_MAX (SOCK_PACKET + 1)
+
+#endif /* ARCH_HAS_SOCKET_TYPES */
+
+/**
+ *  struct socket - general BSD socket
+ *  @state - socket state (%SS_CONNECTED, etc)
+ *  @flags - socket flags (%SOCK_ASYNC_NOSPACE, etc)
+ *  @ops - protocol specific socket operations
+ *  @fasync_list - Asynchronous wake up list
+ *  @file - File back pointer for gc
+ *  @sk - internal networking protocol agnostic socket representation
+ *  @wait - wait queue for several uses
+ *  @type - socket type (%SOCK_STREAM, etc)
+ *  @passcred - credentials (used only in Unix Sockets (aka PF_LOCAL))
+ */
+struct socket {
+	socket_state		state;
+	unsigned long		flags;
+	struct proto_ops	*ops;
+	struct fasync_struct	*fasync_list;
+	struct file		*file;
+	struct sock		*sk;
+	wait_queue_head_t	wait;
+	short			type;
+};
+
+struct vm_area_struct;
+struct page;
+struct kiocb;
+struct sockaddr;
+struct msghdr;
+struct module;
+
+struct proto_ops {
+	int		family;
+	struct module	*owner;
+	int		(*release)   (struct socket *sock);
+	int		(*bind)	     (struct socket *sock,
+				      struct sockaddr *myaddr,
+				      int sockaddr_len);
+	int		(*connect)   (struct socket *sock,
+				      struct sockaddr *vaddr,
+				      int sockaddr_len, int flags);
+	int		(*socketpair)(struct socket *sock1,
+				      struct socket *sock2);
+	int		(*accept)    (struct socket *sock,
+				      struct socket *newsock, int flags);
+	int		(*getname)   (struct socket *sock,
+				      struct sockaddr *addr,
+				      int *sockaddr_len, int peer);
+	unsigned int	(*poll)	     (struct file *file, struct socket *sock,
+				      struct poll_table_struct *wait);
+	int		(*ioctl)     (struct socket *sock, unsigned int cmd,
+				      unsigned long arg);
+	int		(*listen)    (struct socket *sock, int len);
+	int		(*shutdown)  (struct socket *sock, int flags);
+	int		(*setsockopt)(struct socket *sock, int level,
+				      int optname, char __user *optval, int optlen);
+	int		(*getsockopt)(struct socket *sock, int level,
+				      int optname, char __user *optval, int __user *optlen);
+	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
+				      struct msghdr *m, size_t total_len);
+	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
+				      struct msghdr *m, size_t total_len,
+				      int flags);
+	int		(*mmap)	     (struct file *file, struct socket *sock,
+				      struct vm_area_struct * vma);
+	ssize_t		(*sendpage)  (struct socket *sock, struct page *page,
+				      int offset, size_t size, int flags);
+};
+
+struct net_proto_family {
+	int		family;
+	int		(*create)(struct socket *sock, int protocol);
+	/* These are counters for the number of different methods of
+	   each we support */
+	short		authentication;
+	short		encryption;
+	short		encrypt_net;
+	struct module	*owner;
+};
+
+struct iovec;
+struct kvec;
+
+extern int	     sock_wake_async(struct socket *sk, int how, int band);
+extern int	     sock_register(struct net_proto_family *fam);
+extern int	     sock_unregister(int family);
+extern int	     sock_create(int family, int type, int proto,
+				 struct socket **res);
+extern int	     sock_create_kern(int family, int type, int proto,
+				      struct socket **res);
+extern int	     sock_create_lite(int family, int type, int proto,
+				      struct socket **res); 
+extern void	     sock_release(struct socket *sock);
+extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
+				  size_t len);
+extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
+				  size_t size, int flags);
+extern int 	     sock_map_fd(struct socket *sock);
+extern struct socket *sockfd_lookup(int fd, int *err);
+#define		     sockfd_put(sock) fput(sock->file)
+extern int	     net_ratelimit(void);
+extern unsigned long net_random(void);
+extern void	     net_srandom(unsigned long);
+extern void	     net_random_init(void);
+
+extern int   	     kernel_sendmsg(struct socket *sock, struct msghdr *msg,
+				    struct kvec *vec, size_t num, size_t len);
+extern int   	     kernel_recvmsg(struct socket *sock, struct msghdr *msg,
+				    struct kvec *vec, size_t num,
+				    size_t len, int flags);
+
+#ifndef CONFIG_SMP
+#define SOCKOPS_WRAPPED(name) name
+#define SOCKOPS_WRAP(name, fam)
+#else
+
+#define SOCKOPS_WRAPPED(name) __unlocked_##name
+
+#define SOCKCALL_WRAP(name, call, parms, args)		\
+static int __lock_##name##_##call  parms		\
+{							\
+	int ret;					\
+	lock_kernel();					\
+	ret = __unlocked_##name##_ops.call  args ;\
+	unlock_kernel();				\
+	return ret;					\
+}
+
+#define SOCKCALL_UWRAP(name, call, parms, args)		\
+static unsigned int __lock_##name##_##call  parms	\
+{							\
+	int ret;					\
+	lock_kernel();					\
+	ret = __unlocked_##name##_ops.call  args ;\
+	unlock_kernel();				\
+	return ret;					\
+}
+
+
+#define SOCKOPS_WRAP(name, fam)					\
+SOCKCALL_WRAP(name, release, (struct socket *sock), (sock))	\
+SOCKCALL_WRAP(name, bind, (struct socket *sock, struct sockaddr *uaddr, int addr_len), \
+	      (sock, uaddr, addr_len))				\
+SOCKCALL_WRAP(name, connect, (struct socket *sock, struct sockaddr * uaddr, \
+			      int addr_len, int flags), 	\
+	      (sock, uaddr, addr_len, flags))			\
+SOCKCALL_WRAP(name, socketpair, (struct socket *sock1, struct socket *sock2), \
+	      (sock1, sock2))					\
+SOCKCALL_WRAP(name, accept, (struct socket *sock, struct socket *newsock, \
+			 int flags), (sock, newsock, flags)) \
+SOCKCALL_WRAP(name, getname, (struct socket *sock, struct sockaddr *uaddr, \
+			 int *addr_len, int peer), (sock, uaddr, addr_len, peer)) \
+SOCKCALL_UWRAP(name, poll, (struct file *file, struct socket *sock, struct poll_table_struct *wait), \
+	      (file, sock, wait)) \
+SOCKCALL_WRAP(name, ioctl, (struct socket *sock, unsigned int cmd, \
+			 unsigned long arg), (sock, cmd, arg)) \
+SOCKCALL_WRAP(name, listen, (struct socket *sock, int len), (sock, len)) \
+SOCKCALL_WRAP(name, shutdown, (struct socket *sock, int flags), (sock, flags)) \
+SOCKCALL_WRAP(name, setsockopt, (struct socket *sock, int level, int optname, \
+			 char __user *optval, int optlen), (sock, level, optname, optval, optlen)) \
+SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
+			 char __user *optval, int __user *optlen), (sock, level, optname, optval, optlen)) \
+SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \
+	      (iocb, sock, m, len)) \
+SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len, int flags), \
+	      (iocb, sock, m, len, flags)) \
+SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
+	      (file, sock, vma)) \
+	      \
+static struct proto_ops name##_ops = {			\
+	.family		= fam,				\
+	.owner		= THIS_MODULE,			\
+	.release	= __lock_##name##_release,	\
+	.bind		= __lock_##name##_bind,		\
+	.connect	= __lock_##name##_connect,	\
+	.socketpair	= __lock_##name##_socketpair,	\
+	.accept		= __lock_##name##_accept,	\
+	.getname	= __lock_##name##_getname,	\
+	.poll		= __lock_##name##_poll,		\
+	.ioctl		= __lock_##name##_ioctl,	\
+	.listen		= __lock_##name##_listen,	\
+	.shutdown	= __lock_##name##_shutdown,	\
+	.setsockopt	= __lock_##name##_setsockopt,	\
+	.getsockopt	= __lock_##name##_getsockopt,	\
+	.sendmsg	= __lock_##name##_sendmsg,	\
+	.recvmsg	= __lock_##name##_recvmsg,	\
+	.mmap		= __lock_##name##_mmap,		\
+};
+#endif
+
+#define MODULE_ALIAS_NETPROTO(proto) \
+	MODULE_ALIAS("net-pf-" __stringify(proto))
+
+#endif /* __KERNEL__ */
+#endif	/* _LINUX_NET_H */
