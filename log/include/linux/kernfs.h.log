commit 0c47383ba3bd10877956e41149d19644fba937d1
Author: Daniel Xu <dxu@dxuuu.xyz>
Date:   Thu Mar 12 13:03:16 2020 -0700

    kernfs: Add option to enable user xattrs
    
    User extended attributes are useful as metadata storage for kernfs
    consumers like cgroups. Especially in the case of cgroups, it is useful
    to have a central metadata store that multiple processes/services can
    use to coordinate actions.
    
    A concrete example is for userspace out of memory killers. We want to
    let delegated cgroup subtree owners (running as non-root) to be able to
    say "please avoid killing this cgroup". This is especially important for
    desktop linux as delegated subtrees owners are less likely to run as
    root.
    
    This patch introduces a new flag, KERNFS_ROOT_SUPPORT_USER_XATTR, that
    lets kernfs consumers enable user xattr support. An initial limit of 128
    entries or 128KB -- whichever is hit first -- is placed per cgroup
    because xattrs come from kernel memory and we don't want to let
    unprivileged users accidentally eat up too much kernel memory.
    
    Signed-off-by: Daniel Xu <dxu@dxuuu.xyz>
    Acked-by: Chris Down <chris@chrisdown.name>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index dded2e5a9f42..89f6a4214a70 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,8 +37,10 @@ enum kernfs_node_type {
 	KERNFS_LINK		= 0x0004,
 };
 
-#define KERNFS_TYPE_MASK	0x000f
-#define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
+#define KERNFS_TYPE_MASK		0x000f
+#define KERNFS_FLAG_MASK		~KERNFS_TYPE_MASK
+#define KERNFS_MAX_USER_XATTRS		128
+#define KERNFS_USER_XATTR_SIZE_LIMIT	(128 << 10)
 
 enum kernfs_node_flag {
 	KERNFS_ACTIVATED	= 0x0010,
@@ -78,6 +80,11 @@ enum kernfs_root_flag {
 	 * fhandle to access nodes of the fs.
 	 */
 	KERNFS_ROOT_SUPPORT_EXPORTOP		= 0x0004,
+
+	/*
+	 * Support user xattrs to be written to nodes rooted at this root.
+	 */
+	KERNFS_ROOT_SUPPORT_USER_XATTR		= 0x0008,
 };
 
 /* type-specific structures for kernfs_node union members */

commit 40430452fd5da1509177ac597b394614cd3a121f
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: use 64bit inos if ino_t is 64bit
    
    Each kernfs_node is identified with a 64bit ID.  The low 32bit is
    exposed as ino and the high gen.  While this already allows using inos
    as keys by looking up with wildcard generation number of 0, it's
    adding unnecessary complications for 64bit ino archs which can
    directly use kernfs_node IDs as inos to uniquely identify each cgroup
    instance.
    
    This patch exposes IDs directly as inos on 64bit ino archs.  The
    conversion is mostly straight-forward.
    
    * 32bit ino archs behave the same as before.  64bit ino archs now use
      the whole 64bit ID as ino and the generation number is fixed at 1.
    
    * 64bit inos still use the same idr allocator which gurantees that the
      lower 32bits identify the current live instance uniquely and the
      high 32bits are incremented whenever the low bits wrap.  As the
      upper 32bits are no longer used as gen and we don't wanna start ino
      allocation with 33rd bit set, the initial value for highbits
      allocation is changed to 0 on 64bit ino archs.
    
    * blktrace exposes two 32bit numbers - (INO,GEN) pair - to identify
      the issuing cgroup.  Userland builds FILEID_INO32_GEN fids from
      these numbers to look up the cgroups.  To remain compatible with the
      behavior, always output (LOW32,HIGH32) which will be constructed
      back to the original 64bit ID by __kernfs_fh_to_dentry().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 38267cc9420c..dded2e5a9f42 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -141,8 +141,8 @@ struct kernfs_node {
 	void			*priv;
 
 	/*
-	 * 64bit unique ID.  Lower 32bits carry the inode number and lower
-	 * generation.
+	 * 64bit unique ID.  On 64bit ino setups, id is the ino.  On 32bit,
+	 * the low 32bits are ino and upper generation.
 	 */
 	u64			id;
 
@@ -177,8 +177,8 @@ struct kernfs_root {
 
 	/* private fields, do not use outside kernfs proper */
 	struct idr		ino_idr;
-	u32			last_ino;
-	u32			next_generation;
+	u32			last_id_lowbits;
+	u32			id_highbits;
 	struct kernfs_syscall_ops *syscall_ops;
 
 	/* list of kernfs_super_info of this root, protected by kernfs_mutex */
@@ -284,12 +284,20 @@ static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 
 static inline ino_t kernfs_id_ino(u64 id)
 {
-	return (u32)id;
+	/* id is ino if ino_t is 64bit; otherwise, low 32bits */
+	if (sizeof(ino_t) >= sizeof(u64))
+		return id;
+	else
+		return (u32)id;
 }
 
 static inline u32 kernfs_id_gen(u64 id)
 {
-	return id >> 32;
+	/* gen is fixed at 1 if ino_t is 64bit; otherwise, high 32bits */
+	if (sizeof(ino_t) >= sizeof(u64))
+		return 1;
+	else
+		return id >> 32;
 }
 
 static inline ino_t kernfs_ino(struct kernfs_node *kn)

commit fe0f726c9fb626b1092a9ea3bf75f57f2eed676e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: combine ino/id lookup functions into kernfs_find_and_get_node_by_id()
    
    kernfs_find_and_get_node_by_ino() looks the kernfs_node matching the
    specified ino.  On top of that, kernfs_get_node_by_id() and
    kernfs_fh_get_inode() implement full ID matching by testing the rest
    of ID.
    
    On surface, confusingly, the two are slightly different in that the
    latter uses 0 gen as wildcard while the former doesn't - does it mean
    that the latter can't uniquely identify inodes w/ 0 gen?  In practice,
    this is a distinction without a difference because generation number
    starts at 1.  There are no actual IDs with 0 gen, so it can always
    safely used as wildcard.
    
    Let's simplify the code by renaming kernfs_find_and_get_node_by_ino()
    to kernfs_find_and_get_node_by_id(), moving all lookup logics into it,
    and removing now unnecessary kernfs_get_node_by_id().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index b2fc5c8ef6d9..38267cc9420c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -393,7 +393,8 @@ void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
 
-struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root, u64 id);
+struct kernfs_node *kernfs_find_and_get_node_by_id(struct kernfs_root *root,
+						   u64 id);
 #else	/* CONFIG_KERNFS */
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)

commit 67c0496e87d193b8356d2af49ab95e8a1b954b3c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:30 2019 -0800

    kernfs: convert kernfs_node->id from union kernfs_node_id to u64
    
    kernfs_node->id is currently a union kernfs_node_id which represents
    either a 32bit (ino, gen) pair or u64 value.  I can't see much value
    in the usage of the union - all that's needed is a 64bit ID which the
    current code is already limited to.  Using a union makes the code
    unnecessarily complicated and prevents using 64bit ino without adding
    practical benefits.
    
    This patch drops union kernfs_node_id and makes kernfs_node->id a u64.
    ino is stored in the lower 32bits and gen upper.  Accessors -
    kernfs[_id]_ino() and kernfs[_id]_gen() - are added to retrieve the
    ino and gen.  This simplifies ID handling less cumbersome and will
    allow using 64bit inos on supported archs.
    
    This patch doesn't make any functional changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index f797ccc650e7..b2fc5c8ef6d9 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -104,21 +104,6 @@ struct kernfs_elem_attr {
 	struct kernfs_node	*notify_next;	/* for kernfs_notify() */
 };
 
-/* represent a kernfs node */
-union kernfs_node_id {
-	struct {
-		/*
-		 * blktrace will export this struct as a simplified 'struct
-		 * fid' (which is a big data struction), so userspace can use
-		 * it to find kernfs node. The layout must match the first two
-		 * fields of 'struct fid' exactly.
-		 */
-		u32		ino;
-		u32		generation;
-	};
-	u64			id;
-};
-
 /*
  * kernfs_node - the building block of kernfs hierarchy.  Each and every
  * kernfs node is represented by single kernfs_node.  Most fields are
@@ -155,7 +140,12 @@ struct kernfs_node {
 
 	void			*priv;
 
-	union kernfs_node_id	id;
+	/*
+	 * 64bit unique ID.  Lower 32bits carry the inode number and lower
+	 * generation.
+	 */
+	u64			id;
+
 	unsigned short		flags;
 	umode_t			mode;
 	struct kernfs_iattrs	*iattr;
@@ -292,6 +282,26 @@ static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 	return kn->flags & KERNFS_TYPE_MASK;
 }
 
+static inline ino_t kernfs_id_ino(u64 id)
+{
+	return (u32)id;
+}
+
+static inline u32 kernfs_id_gen(u64 id)
+{
+	return id >> 32;
+}
+
+static inline ino_t kernfs_ino(struct kernfs_node *kn)
+{
+	return kernfs_id_ino(kn->id);
+}
+
+static inline ino_t kernfs_gen(struct kernfs_node *kn)
+{
+	return kernfs_id_gen(kn->id);
+}
+
 /**
  * kernfs_enable_ns - enable namespace under a directory
  * @kn: directory of interest, should be empty
@@ -383,8 +393,7 @@ void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
 
-struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root,
-	const union kernfs_node_id *id);
+struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root, u64 id);
 #else	/* CONFIG_KERNFS */
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)

commit e23f568aa63f64cd6b355094224cc9356c0f696b
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 4 15:54:29 2019 -0800

    kernfs: fix ino wrap-around detection
    
    When the 32bit ino wraps around, kernfs increments the generation
    number to distinguish reused ino instances.  The wrap-around detection
    tests whether the allocated ino is lower than what the cursor but the
    cursor is pointing to the next ino to allocate so the condition never
    triggers.
    
    Fix it by remembering the last ino and comparing against that.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Fixes: 4a3ef68acacf ("kernfs: implement i_generation")
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: stable@vger.kernel.org # v4.14+

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 936b61bd504e..f797ccc650e7 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -187,6 +187,7 @@ struct kernfs_root {
 
 	/* private fields, do not use outside kernfs proper */
 	struct idr		ino_idr;
+	u32			last_ino;
 	u32			next_generation;
 	struct kernfs_syscall_ops *syscall_ops;
 

commit 55716d26439f5c4008b0bcb7f17d1f7c0d8fbcfc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:42 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 428
    
    Based on 1 normalized pattern(s):
    
      this file is released under the gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 68 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190114.292346262@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 2bf477f86eb1..936b61bd504e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -1,7 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * kernfs.h - pseudo filesystem decoupled from vfs locking
- *
- * This file is released under the GPLv2.
  */
 
 #ifndef __LINUX_KERNFS_H

commit f72dae20891d7bcc43e9263ab206960b6ae5209f
Merge: 498e8631f27e 35a196bef449
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 18:48:09 2019 -0700

    Merge tag 'selinux-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull selinux updates from Paul Moore:
     "We've got a few SELinux patches for the v5.2 merge window, the
      highlights are below:
    
       - Add LSM hooks, and the SELinux implementation, for proper labeling
         of kernfs. While we are only including the SELinux implementation
         here, the rest of the LSM folks have given the hooks a thumbs-up.
    
       - Update the SELinux mdp (Make Dummy Policy) script to actually work
         on a modern system.
    
       - Disallow userspace to change the LSM credentials via
         /proc/self/attr when the task's credentials are already overridden.
    
         The change was made in procfs because all the LSM folks agreed this
         was the Right Thing To Do and duplicating it across each LSM was
         going to be annoying"
    
    * tag 'selinux-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      proc: prevent changes to overridden credentials
      selinux: Check address length before reading address family
      kernfs: fix xattr name handling in LSM helpers
      MAINTAINERS: update SELinux file patterns
      selinux: avoid uninitialized variable warning
      selinux: remove useless assignments
      LSM: lsm_hooks.h - fix missing colon in docstring
      selinux: Make selinux_kernfs_init_security static
      kernfs: initialize security of newly created nodes
      selinux: implement the kernfs_init_security hook
      LSM: add new hook for kernfs node initialization
      kernfs: use simple_xattrs for security attributes
      selinux: try security xattr after genfs for kernfs filesystems
      kernfs: do not alloc iattrs in kernfs_xattr_get
      kernfs: clean up struct kernfs_iattrs
      scripts/selinux: fix build
      selinux: use kernel linux/socket.h for genheaders and mdp
      scripts/selinux: modernize mdp

commit 0d1a393d61e44e2755eeff2e62fc8e91f8b296b6
Author: Christina Quast <cquast@hanoverdisplays.com>
Date:   Tue Apr 2 16:01:46 2019 +0200

    fs: kernfs: Corrected spelling mistake
    
    flies => files
    
    Signed-off-by: Christina Quast <cquast@hanoverdisplays.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index c8893f663470..e446ab97ee0c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -64,7 +64,7 @@ enum kernfs_root_flag {
 	KERNFS_ROOT_CREATE_DEACTIVATED		= 0x0001,
 
 	/*
-	 * For regular flies, if the opener has CAP_DAC_OVERRIDE, open(2)
+	 * For regular files, if the opener has CAP_DAC_OVERRIDE, open(2)
 	 * succeeds regardless of the RW permissions.  sysfs had an extra
 	 * layer of enforcement where open(2) fails with -EACCES regardless
 	 * of CAP_DAC_OVERRIDE if the permission doesn't have the

commit 1537ad15c9c59ce852748578eb5633139053e86b
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Wed Apr 3 09:29:41 2019 +0200

    kernfs: fix xattr name handling in LSM helpers
    
    The implementation of kernfs_security_xattr_*() helpers reuses the
    kernfs_node_xattr_*() functions, which take the suffix of the xattr name
    and extract full xattr name from it using xattr_full_name(). However,
    this function relies on the fact that the suffix passed to xattr
    handlers from VFS is always constructed from the full name by just
    incerementing the pointer. This doesn't necessarily hold for the callers
    of kernfs_security_xattr_*(), so their usage will easily lead to
    out-of-bounds access.
    
    Fix this by moving the xattr name reconstruction to the VFS xattr
    handlers and replacing the kernfs_security_xattr_*() helpers with more
    general kernfs_xattr_*() helpers that take full xattr name and allow
    accessing all kernfs node's xattrs.
    
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Fixes: b230d5aba2d1 ("LSM: add new hook for kernfs node initialization")
    Fixes: ec882da5cda9 ("selinux: implement the kernfs_init_security hook")
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 39eea07c2900..7987e0f89b69 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -371,10 +371,10 @@ __poll_t kernfs_generic_poll(struct kernfs_open_file *of,
 			     struct poll_table_struct *pt);
 void kernfs_notify(struct kernfs_node *kn);
 
-int kernfs_security_xattr_get(struct kernfs_node *kn, const char *suffix,
-			      void *value, size_t size);
-int kernfs_security_xattr_set(struct kernfs_node *kn, const char *suffix,
-			      void *value, size_t size, int flags);
+int kernfs_xattr_get(struct kernfs_node *kn, const char *name,
+		     void *value, size_t size);
+int kernfs_xattr_set(struct kernfs_node *kn, const char *name,
+		     const void *value, size_t size, int flags);
 
 const void *kernfs_super_ns(struct super_block *sb);
 int kernfs_get_tree(struct fs_context *fc);
@@ -478,14 +478,12 @@ static inline int kernfs_setattr(struct kernfs_node *kn,
 
 static inline void kernfs_notify(struct kernfs_node *kn) { }
 
-static inline int kernfs_security_xattr_get(struct kernfs_node *kn,
-					    const char *suffix, void *value,
-					    size_t size)
+static inline int kernfs_xattr_get(struct kernfs_node *kn, const char *name,
+				   void *value, size_t size)
 { return -ENOSYS; }
 
-static inline int kernfs_security_xattr_set(struct kernfs_node *kn,
-					    const char *suffix, void *value,
-					    size_t size, int flags)
+static inline int kernfs_xattr_set(struct kernfs_node *kn, const char *name,
+				   const void *value, size_t size, int flags)
 { return -ENOSYS; }
 
 static inline const void *kernfs_super_ns(struct super_block *sb)

commit b230d5aba2d1a7b0636408889a75bf9eae6b8bc7
Author: Ondrej Mosnacek <omosnace@redhat.com>
Date:   Fri Feb 22 15:57:16 2019 +0100

    LSM: add new hook for kernfs node initialization
    
    This patch introduces a new security hook that is intended for
    initializing the security data for newly created kernfs nodes, which
    provide a way of storing a non-default security context, but need to
    operate independently from mounts (and therefore may not have an
    associated inode at the moment of creation).
    
    The main motivation is to allow kernfs nodes to inherit the context of
    the parent under SELinux, similar to the behavior of
    security_inode_init_security(). Other LSMs may implement their own logic
    for handling the creation of new nodes.
    
    This patch also adds helper functions to <linux/kernfs.h> for
    getting/setting security xattrs of a kernfs node so that LSMs hooks are
    able to do their job. Other important attributes should be accessible
    direcly in the kernfs_node fields (in case there is need for more, then
    new helpers should be added to kernfs.h along with the patch that needs
    them).
    
    Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
    Acked-by: Casey Schaufler <casey@schaufler-ca.com>
    [PM: more manual merge fixes]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index c8893f663470..39eea07c2900 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -371,6 +371,11 @@ __poll_t kernfs_generic_poll(struct kernfs_open_file *of,
 			     struct poll_table_struct *pt);
 void kernfs_notify(struct kernfs_node *kn);
 
+int kernfs_security_xattr_get(struct kernfs_node *kn, const char *suffix,
+			      void *value, size_t size);
+int kernfs_security_xattr_set(struct kernfs_node *kn, const char *suffix,
+			      void *value, size_t size, int flags);
+
 const void *kernfs_super_ns(struct super_block *sb);
 int kernfs_get_tree(struct fs_context *fc);
 void kernfs_free_fs_context(struct fs_context *fc);
@@ -473,6 +478,16 @@ static inline int kernfs_setattr(struct kernfs_node *kn,
 
 static inline void kernfs_notify(struct kernfs_node *kn) { }
 
+static inline int kernfs_security_xattr_get(struct kernfs_node *kn,
+					    const char *suffix, void *value,
+					    size_t size)
+{ return -ENOSYS; }
+
+static inline int kernfs_security_xattr_set(struct kernfs_node *kn,
+					    const char *suffix, void *value,
+					    size_t size, int flags)
+{ return -ENOSYS; }
+
 static inline const void *kernfs_super_ns(struct super_block *sb)
 { return NULL; }
 

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit 147e1a97c4a0bdd43f55a582a9416bb9092563a9
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Tue Mar 5 15:45:45 2019 -0800

    fs: kernfs: add poll file operation
    
    Patch series "psi: pressure stall monitors", v3.
    
    Android is adopting psi to detect and remedy memory pressure that
    results in stuttering and decreased responsiveness on mobile devices.
    
    Psi gives us the stall information, but because we're dealing with
    latencies in the millisecond range, periodically reading the pressure
    files to detect stalls in a timely fashion is not feasible.  Psi also
    doesn't aggregate its averages at a high enough frequency right now.
    
    This patch series extends the psi interface such that users can
    configure sensitive latency thresholds and use poll() and friends to be
    notified when these are breached.
    
    As high-frequency aggregation is costly, it implements an aggregation
    method that is optimized for fast, short-interval averaging, and makes
    the aggregation frequency adaptive, such that high-frequency updates
    only happen while monitored stall events are actively occurring.
    
    With these patches applied, Android can monitor for, and ward off,
    mounting memory shortages before they cause problems for the user.  For
    example, using memory stall monitors in userspace low memory killer
    daemon (lmkd) we can detect mounting pressure and kill less important
    processes before device becomes visibly sluggish.
    
    In our memory stress testing psi memory monitors produce roughly 10x
    less false positives compared to vmpressure signals.  Having ability to
    specify multiple triggers for the same psi metric allows other parts of
    Android framework to monitor memory state of the device and act
    accordingly.
    
    The new interface is straightforward.  The user opens one of the
    pressure files for writing and writes a trigger description into the
    file descriptor that defines the stall state - some or full, and the
    maximum stall time over a given window of time.  E.g.:
    
            /* Signal when stall time exceeds 100ms of a 1s window */
            char trigger[] = "full 100000 1000000";
            fd = open("/proc/pressure/memory");
            write(fd, trigger, sizeof(trigger));
            while (poll() >= 0) {
                    ...
            }
            close(fd);
    
    When the monitored stall state is entered, psi adapts its aggregation
    frequency according to what the configured time window requires in order
    to emit event signals in a timely fashion.  Once the stalling subsides,
    aggregation reverts back to normal.
    
    The trigger is associated with the open file descriptor.  To stop
    monitoring, the user only needs to close the file descriptor and the
    trigger is discarded.
    
    Patches 1-4 prepare the psi code for polling support.  Patch 5
    implements the adaptive polling logic, the pressure growth detection
    optimized for short intervals, and hooks up write() and poll() on the
    pressure files.
    
    The patches were developed in collaboration with Johannes Weiner.
    
    This patch (of 5):
    
    Kernfs has a standardized poll/notification mechanism for waking all
    pollers on all fds when a filesystem node changes.  To allow polling for
    custom events, add a .poll callback that can override the default.
    
    This is in preparation for pollable cgroup pressure files which have
    per-fd trigger configurations.
    
    Link: http://lkml.kernel.org/r/20190124211518.244221-2-surenb@google.com
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Signed-off-by: Suren Baghdasaryan <surenb@google.com>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Li Zefan <lizefan@huawei.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5b36b1287a5a..0cac1207bb00 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -25,6 +25,7 @@ struct seq_file;
 struct vm_area_struct;
 struct super_block;
 struct file_system_type;
+struct poll_table_struct;
 
 struct kernfs_open_node;
 struct kernfs_iattrs;
@@ -261,6 +262,9 @@ struct kernfs_ops {
 	ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
 			 loff_t off);
 
+	__poll_t (*poll)(struct kernfs_open_file *of,
+			 struct poll_table_struct *pt);
+
 	int (*mmap)(struct kernfs_open_file *of, struct vm_area_struct *vma);
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
@@ -350,6 +354,8 @@ int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
 		     const char *new_name, const void *new_ns);
 int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
+__poll_t kernfs_generic_poll(struct kernfs_open_file *of,
+			     struct poll_table_struct *pt);
 void kernfs_notify(struct kernfs_node *kn);
 
 const void *kernfs_super_ns(struct super_block *sb);

commit 23bf1b6be9c291a7130118dcc7384f72ac04d813
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:26 2018 +0000

    kernfs, sysfs, cgroup, intel_rdt: Support fs_context
    
    Make kernfs support superblock creation/mount/remount with fs_context.
    
    This requires that sysfs, cgroup and intel_rdt, which are built on kernfs,
    be made to support fs_context also.
    
    Notes:
    
     (1) A kernfs_fs_context struct is created to wrap fs_context and the
         kernfs mount parameters are moved in here (or are in fs_context).
    
     (2) kernfs_mount{,_ns}() are made into kernfs_get_tree().  The extra
         namespace tag parameter is passed in the context if desired
    
     (3) kernfs_free_fs_context() is provided as a destructor for the
         kernfs_fs_context struct, but for the moment it does nothing except
         get called in the right places.
    
     (4) sysfs doesn't wrap kernfs_fs_context since it has no parameters to
         pass, but possibly this should be done anyway in case someone wants to
         add a parameter in future.
    
     (5) A cgroup_fs_context struct is created to wrap kernfs_fs_context and
         the cgroup v1 and v2 mount parameters are all moved there.
    
     (6) cgroup1 parameter parsing error messages are now handled by invalf(),
         which allows userspace to collect them directly.
    
     (7) cgroup1 parameter cleanup is now done in the context destructor rather
         than in the mount/get_tree and remount functions.
    
    Weirdies:
    
     (*) cgroup_do_get_tree() calls cset_cgroup_from_root() with locks held,
         but then uses the resulting pointer after dropping the locks.  I'm
         told this is okay and needs commenting.
    
     (*) The cgroup refcount web.  This really needs documenting.
    
     (*) cgroup2 only has one root?
    
    Add a suggestion from Thomas Gleixner in which the RDT enablement code is
    placed into its own function.
    
    [folded a leak fix from Andrey Vagin]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tejun Heo <tj@kernel.org>
    cc: Li Zefan <lizefan@huawei.com>
    cc: Johannes Weiner <hannes@cmpxchg.org>
    cc: cgroups@vger.kernel.org
    cc: fenghua.yu@intel.com
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 44acb4c3659c..822a64e65b41 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -25,7 +25,9 @@ struct seq_file;
 struct vm_area_struct;
 struct super_block;
 struct file_system_type;
+struct fs_context;
 
+struct kernfs_fs_context;
 struct kernfs_open_node;
 struct kernfs_iattrs;
 
@@ -167,7 +169,6 @@ struct kernfs_node {
  * kernfs_node parameter.
  */
 struct kernfs_syscall_ops {
-	int (*remount_fs)(struct kernfs_root *root, int *flags, char *data);
 	int (*show_options)(struct seq_file *sf, struct kernfs_root *root);
 
 	int (*mkdir)(struct kernfs_node *parent, const char *name,
@@ -268,6 +269,18 @@ struct kernfs_ops {
 #endif
 };
 
+/*
+ * The kernfs superblock creation/mount parameter context.
+ */
+struct kernfs_fs_context {
+	struct kernfs_root	*root;		/* Root of the hierarchy being mounted */
+	void			*ns_tag;	/* Namespace tag of the mount (or NULL) */
+	unsigned long		magic;		/* File system specific magic number */
+
+	/* The following are set/used by kernfs_mount() */
+	bool			new_sb_created;	/* Set to T if we allocated a new sb */
+};
+
 #ifdef CONFIG_KERNFS
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
@@ -353,9 +366,8 @@ int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
 void kernfs_notify(struct kernfs_node *kn);
 
 const void *kernfs_super_ns(struct super_block *sb);
-struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-			       struct kernfs_root *root, unsigned long magic,
-			       bool *new_sb_created, const void *ns);
+int kernfs_get_tree(struct fs_context *fc);
+void kernfs_free_fs_context(struct fs_context *fc);
 void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
@@ -458,11 +470,10 @@ static inline void kernfs_notify(struct kernfs_node *kn) { }
 static inline const void *kernfs_super_ns(struct super_block *sb)
 { return NULL; }
 
-static inline struct dentry *
-kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-		struct kernfs_root *root, unsigned long magic,
-		bool *new_sb_created, const void *ns)
-{ return ERR_PTR(-ENOSYS); }
+static inline int kernfs_get_tree(struct fs_context *fc)
+{ return -ENOSYS; }
+
+static inline void kernfs_free_fs_context(struct fs_context *fc) { }
 
 static inline void kernfs_kill_sb(struct super_block *sb) { }
 
@@ -545,13 +556,4 @@ static inline int kernfs_rename(struct kernfs_node *kn,
 	return kernfs_rename_ns(kn, new_parent, new_name, NULL);
 }
 
-static inline struct dentry *
-kernfs_mount(struct file_system_type *fs_type, int flags,
-		struct kernfs_root *root, unsigned long magic,
-		bool *new_sb_created)
-{
-	return kernfs_mount_ns(fs_type, flags, root,
-				magic, new_sb_created, NULL);
-}
-
 #endif	/* __LINUX_KERNFS_H */

commit 6d7fbce7da0cd06ff3f3f30e009a15a6243f0bc0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 17 12:02:57 2019 -0500

    kill kernfs_pin_sb()
    
    unused now and impossible to use safely anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5b36b1287a5a..44acb4c3659c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -357,7 +357,6 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 			       struct kernfs_root *root, unsigned long magic,
 			       bool *new_sb_created, const void *ns);
 void kernfs_kill_sb(struct super_block *sb);
-struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns);
 
 void kernfs_init(void);
 

commit 8f5be0ec23bb9ef3f96659c8dff1340b876600bf
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Mon Aug 13 09:52:09 2018 +0300

    kernfs: update comment about kernfs_path() return value
    
    Now it returns the length of the full path or error code.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Fixes: 3abb1d90f5d9 ("kernfs: make kernfs_path*() behave in the style of strlcpy()")
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 814643f7ee52..5b36b1287a5a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -477,10 +477,11 @@ static inline void kernfs_init(void) { }
  * @buf: buffer to copy @kn's name into
  * @buflen: size of @buf
  *
- * Builds and returns the full path of @kn in @buf of @buflen bytes.  The
- * path is built from the end of @buf so the returned pointer usually
- * doesn't match @buf.  If @buf isn't long enough, @buf is nul terminated
- * and %NULL is returned.
+ * If @kn is NULL result will be "(null)".
+ *
+ * Returns the length of the full path.  If the full length is equal to or
+ * greater than @buflen, @buf contains the truncated path with the trailing
+ * '\0'.  On error, -errno is returned.
  */
 static inline int kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)
 {

commit 488dee96bb62f0b3d9e678cf42574034d5b033a5
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Jul 20 21:56:47 2018 +0000

    kernfs: allow creating kernfs objects with arbitrary uid/gid
    
    This change allows creating kernfs files and directories with arbitrary
    uid/gid instead of always using GLOBAL_ROOT_UID/GID by extending
    kernfs_create_dir_ns() and kernfs_create_file_ns() with uid/gid arguments.
    The "simple" kernfs_create_file() and kernfs_create_dir() are left alone
    and always create objects belonging to the global root.
    
    When creating symlinks ownership (uid/gid) is taken from the target kernfs
    object.
    
    Co-Developed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index ab25c8b6d9e3..814643f7ee52 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -15,6 +15,7 @@
 #include <linux/lockdep.h>
 #include <linux/rbtree.h>
 #include <linux/atomic.h>
+#include <linux/uidgid.h>
 #include <linux/wait.h>
 
 struct file;
@@ -325,12 +326,14 @@ void kernfs_destroy_root(struct kernfs_root *root);
 
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
 					 const char *name, umode_t mode,
+					 kuid_t uid, kgid_t gid,
 					 void *priv, const void *ns);
 struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,
 					    const char *name);
 struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
-					 const char *name,
-					 umode_t mode, loff_t size,
+					 const char *name, umode_t mode,
+					 kuid_t uid, kgid_t gid,
+					 loff_t size,
 					 const struct kernfs_ops *ops,
 					 void *priv, const void *ns,
 					 struct lock_class_key *key);
@@ -415,12 +418,14 @@ static inline void kernfs_destroy_root(struct kernfs_root *root) { }
 
 static inline struct kernfs_node *
 kernfs_create_dir_ns(struct kernfs_node *parent, const char *name,
-		     umode_t mode, void *priv, const void *ns)
+		     umode_t mode, kuid_t uid, kgid_t gid,
+		     void *priv, const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct kernfs_node *
 __kernfs_create_file(struct kernfs_node *parent, const char *name,
-		     umode_t mode, loff_t size, const struct kernfs_ops *ops,
+		     umode_t mode, kuid_t uid, kgid_t gid,
+		     loff_t size, const struct kernfs_ops *ops,
 		     void *priv, const void *ns, struct lock_class_key *key)
 { return ERR_PTR(-ENOSYS); }
 
@@ -498,12 +503,15 @@ static inline struct kernfs_node *
 kernfs_create_dir(struct kernfs_node *parent, const char *name, umode_t mode,
 		  void *priv)
 {
-	return kernfs_create_dir_ns(parent, name, mode, priv, NULL);
+	return kernfs_create_dir_ns(parent, name, mode,
+				    GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,
+				    priv, NULL);
 }
 
 static inline struct kernfs_node *
 kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
-		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+		      umode_t mode, kuid_t uid, kgid_t gid,
+		      loff_t size, const struct kernfs_ops *ops,
 		      void *priv, const void *ns)
 {
 	struct lock_class_key *key = NULL;
@@ -511,15 +519,17 @@ kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	key = (struct lock_class_key *)&ops->lockdep_key;
 #endif
-	return __kernfs_create_file(parent, name, mode, size, ops, priv, ns,
-				    key);
+	return __kernfs_create_file(parent, name, mode, uid, gid,
+				    size, ops, priv, ns, key);
 }
 
 static inline struct kernfs_node *
 kernfs_create_file(struct kernfs_node *parent, const char *name, umode_t mode,
 		   loff_t size, const struct kernfs_ops *ops, void *priv)
 {
-	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
+	return kernfs_create_file_ns(parent, name, mode,
+				     GLOBAL_ROOT_UID, GLOBAL_ROOT_GID,
+				     size, ops, priv, NULL);
 }
 
 static inline int kernfs_remove_by_name(struct kernfs_node *parent,

commit 69fd5c391763bd94a40dd152bc72a7f230137150
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:55 2017 -0700

    blktrace: add an option to allow displaying cgroup path
    
    By default we output cgroup id in blktrace. This adds an option to
    display cgroup path. Since get cgroup path is a relativly heavy
    operation, we don't enable it by default.
    
    with the option enabled, blktrace will output something like this:
    dd-1353  [007] d..2   293.015252:   8,0   /test/level  D   R 24 + 8 [dd]
    
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d149361e5875..ab25c8b6d9e3 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -358,6 +358,8 @@ struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns);
 
 void kernfs_init(void);
 
+struct kernfs_node *kernfs_get_node_by_id(struct kernfs_root *root,
+	const union kernfs_node_id *id);
 #else	/* CONFIG_KERNFS */
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)

commit aa8188253474b4053bc2900d9fcb545ce68bdf5c
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:51 2017 -0700

    kernfs: add exportfs operations
    
    Now we have the facilities to implement exportfs operations. The idea is
    cgroup can export the fhandle info to userspace, then userspace uses
    fhandle to find the cgroup name. Another example is userspace can get
    fhandle for a cgroup and BPF uses the fhandle to filter info for the
    cgroup.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 06a0c5913e1d..d149361e5875 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -69,6 +69,12 @@ enum kernfs_root_flag {
 	 * following flag enables that behavior.
 	 */
 	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK	= 0x0002,
+
+	/*
+	 * The filesystem supports exportfs operation, so userspace can use
+	 * fhandle to access nodes of the fs.
+	 */
+	KERNFS_ROOT_SUPPORT_EXPORTOP		= 0x0004,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -98,6 +104,12 @@ struct kernfs_elem_attr {
 /* represent a kernfs node */
 union kernfs_node_id {
 	struct {
+		/*
+		 * blktrace will export this struct as a simplified 'struct
+		 * fid' (which is a big data struction), so userspace can use
+		 * it to find kernfs node. The layout must match the first two
+		 * fields of 'struct fid' exactly.
+		 */
 		u32		ino;
 		u32		generation;
 	};

commit c53cd490b1a491ebf1d8e30da97e7231459a4208
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:50 2017 -0700

    kernfs: introduce kernfs_node_id
    
    inode number and generation can identify a kernfs node. We are going to
    export the identification by exportfs operations, so put ino and
    generation into a separate structure. It's convenient when later patches
    use the identification.
    
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 8c00d28f468a..06a0c5913e1d 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -95,6 +95,15 @@ struct kernfs_elem_attr {
 	struct kernfs_node	*notify_next;	/* for kernfs_notify() */
 };
 
+/* represent a kernfs node */
+union kernfs_node_id {
+	struct {
+		u32		ino;
+		u32		generation;
+	};
+	u64			id;
+};
+
 /*
  * kernfs_node - the building block of kernfs hierarchy.  Each and every
  * kernfs node is represented by single kernfs_node.  Most fields are
@@ -131,11 +140,10 @@ struct kernfs_node {
 
 	void			*priv;
 
+	union kernfs_node_id	id;
 	unsigned short		flags;
 	umode_t			mode;
-	unsigned int		ino;
 	struct kernfs_iattrs	*iattr;
-	u32			generation;
 };
 
 /*

commit 4a3ef68acacf31570066e69593de5cc49cc91638
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:47 2017 -0700

    kernfs: implement i_generation
    
    Set i_generation for kernfs inode. This is required to implement
    exportfs operations. The generation is 32-bit, so it's possible the
    generation wraps up and we find stale files. To reduce the posssibility,
    we don't reuse inode numer immediately. When the inode number allocation
    wraps, we increase generation number. In this way generation/inode
    number consist of a 64-bit number which is unlikely duplicated. This
    does make the idr tree more sparse and waste some memory. Since idr
    manages 32-bit keys, idr uses a 6-level radix tree, each level covers 6
    bits of the key. In a 100k inode kernfs, the worst case will have around
    300k radix tree node. Each node is 576bytes, so the tree will use about
    ~150M memory. Sounds not too bad, if this really is a problem, we should
    find better data structure.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5f5d602eb433..8c00d28f468a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -135,6 +135,7 @@ struct kernfs_node {
 	umode_t			mode;
 	unsigned int		ino;
 	struct kernfs_iattrs	*iattr;
+	u32			generation;
 };
 
 /*
@@ -164,6 +165,7 @@ struct kernfs_root {
 
 	/* private fields, do not use outside kernfs proper */
 	struct idr		ino_idr;
+	u32			next_generation;
 	struct kernfs_syscall_ops *syscall_ops;
 
 	/* list of kernfs_super_info of this root, protected by kernfs_mutex */

commit 7d35079f8277b653d6a3075eea9edd4dbf7c2b29
Author: Shaohua Li <shli@fb.com>
Date:   Wed Jul 12 11:49:46 2017 -0700

    kernfs: use idr instead of ida to manage inode number
    
    kernfs uses ida to manage inode number. The problem is we can't get
    kernfs_node from inode number with ida. Switching to use idr, next patch
    will add an API to get kernfs_node from inode number.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index a9b11b8d06f2..5f5d602eb433 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -163,7 +163,7 @@ struct kernfs_root {
 	unsigned int		flags;	/* KERNFS_ROOT_* flags */
 
 	/* private fields, do not use outside kernfs proper */
-	struct ida		ino_ida;
+	struct idr		ino_idr;
 	struct kernfs_syscall_ops *syscall_ops;
 
 	/* list of kernfs_super_info of this root, protected by kernfs_mutex */

commit 0e67db2f9fe91937e798e3d7d22c50a8438187e1
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 27 14:49:03 2016 -0500

    kernfs: add kernfs_ops->open/release() callbacks
    
    Add ->open/release() methods to kernfs_ops.  ->open() is called when
    the file is opened and ->release() when the file is either released or
    severed.  These callbacks can be used, for example, to manage
    persistent caching objects over multiple seq_file iterations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Acked-by: Zefan Li <lizefan@huawei.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index afd4e5abc4fb..a9b11b8d06f2 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -46,6 +46,7 @@ enum kernfs_node_flag {
 	KERNFS_SUICIDAL		= 0x0400,
 	KERNFS_SUICIDED		= 0x0800,
 	KERNFS_EMPTY_DIR	= 0x1000,
+	KERNFS_HAS_RELEASE	= 0x2000,
 };
 
 /* @flags for kernfs_create_root() */
@@ -175,6 +176,7 @@ struct kernfs_open_file {
 	/* published fields */
 	struct kernfs_node	*kn;
 	struct file		*file;
+	struct seq_file		*seq_file;
 	void			*priv;
 
 	/* private fields, do not use outside kernfs proper */
@@ -186,10 +188,18 @@ struct kernfs_open_file {
 
 	size_t			atomic_write_len;
 	bool			mmapped:1;
+	bool			released:1;
 	const struct vm_operations_struct *vm_ops;
 };
 
 struct kernfs_ops {
+	/*
+	 * Optional open/release methods.  Both are called with
+	 * @of->seq_file populated.
+	 */
+	int (*open)(struct kernfs_open_file *of);
+	void (*release)(struct kernfs_open_file *of);
+
 	/*
 	 * Read is handled by either seq_file or raw_read().
 	 *

commit a1d82aff5df760d933b6ea3a03805dbc2bd73eb8
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 27 14:49:02 2016 -0500

    kernfs: make kernfs_open_file->mmapped a bitfield
    
    More kernfs_open_file->mutex synchronized flags are planned to be
    added.  Convert ->mmapped to a bitfield in preparation.
    
    While at it, make kernfs_fop_mmap() use "true" instead of "1" on
    ->mmapped.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Acked-by: Zefan Li <lizefan@huawei.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 7056238fd9f5..afd4e5abc4fb 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -185,7 +185,7 @@ struct kernfs_open_file {
 	char			*prealloc_buf;
 
 	size_t			atomic_write_len;
-	bool			mmapped;
+	bool			mmapped:1;
 	const struct vm_operations_struct *vm_ops;
 };
 

commit bb09c8634b1e484b8840fb2384d55739bfcb68bd
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Aug 10 11:23:44 2016 -0400

    kernfs: remove kernfs_path_len()
    
    It doesn't have any in-kernel user and the same result can be obtained
    from kernfs_path(@kn, NULL, 0).  Remove it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 4a02b1b49821..7056238fd9f5 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -269,7 +269,6 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 }
 
 int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
-size_t kernfs_path_len(struct kernfs_node *kn);
 int kernfs_path_from_node(struct kernfs_node *root_kn, struct kernfs_node *kn,
 			  char *buf, size_t buflen);
 void pr_cont_kernfs_name(struct kernfs_node *kn);
@@ -340,9 +339,6 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 static inline int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)
 { return -ENOSYS; }
 
-static inline size_t kernfs_path_len(struct kernfs_node *kn)
-{ return 0; }
-
 static inline int kernfs_path_from_node(struct kernfs_node *root_kn,
 					struct kernfs_node *kn,
 					char *buf, size_t buflen)

commit 3abb1d90f5d930c6183534a624aa0158a71bc5eb
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Aug 10 11:23:44 2016 -0400

    kernfs: make kernfs_path*() behave in the style of strlcpy()
    
    kernfs_path*() functions always return the length of the full path but
    the path content is undefined if the length is larger than the
    provided buffer.  This makes its behavior different from strlcpy() and
    requires error handling in all its users even when they don't care
    about truncation.  In addition, the implementation can actully be
    simplified by making it behave properly in strlcpy() style.
    
    * Update kernfs_path_from_node_locked() to always fill up the buffer
      with path.  If the buffer is not large enough, the output is
      truncated and terminated.
    
    * kernfs_path() no longer needs error handling.  Make it a simple
      inline wrapper around kernfs_path_from_node().
    
    * sysfs_warn_dup()'s use of kernfs_path() doesn't need error handling.
      Updated accordingly.
    
    * cgroup_path()'s use of kernfs_path() updated to retain the old
      behavior.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Serge Hallyn <serge.hallyn@ubuntu.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 7d2efd2128bb..4a02b1b49821 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -272,7 +272,6 @@ int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
 size_t kernfs_path_len(struct kernfs_node *kn);
 int kernfs_path_from_node(struct kernfs_node *root_kn, struct kernfs_node *kn,
 			  char *buf, size_t buflen);
-char *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen);
 void pr_cont_kernfs_name(struct kernfs_node *kn);
 void pr_cont_kernfs_path(struct kernfs_node *kn);
 struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
@@ -349,10 +348,6 @@ static inline int kernfs_path_from_node(struct kernfs_node *root_kn,
 					char *buf, size_t buflen)
 { return -ENOSYS; }
 
-static inline char *kernfs_path(struct kernfs_node *kn, char *buf,
-				size_t buflen)
-{ return NULL; }
-
 static inline void pr_cont_kernfs_name(struct kernfs_node *kn) { }
 static inline void pr_cont_kernfs_path(struct kernfs_node *kn) { }
 
@@ -441,6 +436,22 @@ static inline void kernfs_init(void) { }
 
 #endif	/* CONFIG_KERNFS */
 
+/**
+ * kernfs_path - build full path of a given node
+ * @kn: kernfs_node of interest
+ * @buf: buffer to copy @kn's name into
+ * @buflen: size of @buf
+ *
+ * Builds and returns the full path of @kn in @buf of @buflen bytes.  The
+ * path is built from the end of @buf so the returned pointer usually
+ * doesn't match @buf.  If @buf isn't long enough, @buf is nul terminated
+ * and %NULL is returned.
+ */
+static inline int kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen)
+{
+	return kernfs_path_from_node(kn, NULL, buf, buflen);
+}
+
 static inline struct kernfs_node *
 kernfs_find_and_get(struct kernfs_node *kn, const char *name)
 {

commit 0e0b2afdf644aa523f5eb10ce1f9e3c6cd8362ec
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Aug 10 11:23:43 2016 -0400

    kernfs: add dummy implementation of kernfs_path_from_node()
    
    The dummy version of kernfs_path_from_node() was missing.  This
    currently doesn't break anything.  Let's add it for consistency and to
    ease adding wrappers around it.
    
    v2: Removed stray ';' which was causing build failures.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 96356ef012de..7d2efd2128bb 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -344,6 +344,11 @@ static inline int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)
 static inline size_t kernfs_path_len(struct kernfs_node *kn)
 { return 0; }
 
+static inline int kernfs_path_from_node(struct kernfs_node *root_kn,
+					struct kernfs_node *kn,
+					char *buf, size_t buflen)
+{ return -ENOSYS; }
+
 static inline char *kernfs_path(struct kernfs_node *kn, char *buf,
 				size_t buflen)
 { return NULL; }

commit 3aa2fc1667acdd9cca816a2bc9529f494bd61b05
Merge: 5af234401345 c6e360a0d9d2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 21:26:15 2016 -0700

    Merge tag 'driver-core-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the "big" driver core update for 4.7-rc1.
    
      Mostly just debugfs changes, the long-known and messy races with
      removing debugfs files should be fixed thanks to the great work of
      Nicolai Stange.  We also have some isa updates in here (the x86
      maintainers told me to take it through this tree), a new warning when
      we run out of dynamic char major numbers, and a few other assorted
      changes, details in the shortlog.
    
      All have been in linux-next for some time with no reported issues"
    
    * tag 'driver-core-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (32 commits)
      Revert "base: dd: don't remove driver_data in -EPROBE_DEFER case"
      gpio: ws16c48: Utilize the ISA bus driver
      gpio: 104-idio-16: Utilize the ISA bus driver
      gpio: 104-idi-48: Utilize the ISA bus driver
      gpio: 104-dio-48e: Utilize the ISA bus driver
      watchdog: ebc-c384_wdt: Utilize the ISA bus driver
      iio: stx104: Utilize the module_isa_driver and max_num_isa_dev macros
      iio: stx104: Add X86 dependency to STX104 Kconfig option
      Documentation: Add ISA bus driver documentation
      isa: Implement the max_num_isa_dev macro
      isa: Implement the module_isa_driver macro
      pnp: pnpbios: Add explicit X86_32 dependency to PNPBIOS
      isa: Decouple X86_32 dependency from the ISA Kconfig option
      driver-core: use 'dev' argument in dev_dbg_ratelimited stub
      base: dd: don't remove driver_data in -EPROBE_DEFER case
      kernfs: Move faulting copy_user operations outside of the mutex
      devcoredump: add scatterlist support
      debugfs: unproxify files created through debugfs_create_u32_array()
      debugfs: unproxify files created through debugfs_create_blob()
      debugfs: unproxify files created through debugfs_create_bool()
      ...

commit 4f41fc59620fcedaa97cbdf3d7d2956d80fcd922
Author: Serge E. Hallyn <serge.hallyn@ubuntu.com>
Date:   Mon May 9 09:59:55 2016 -0500

    cgroup, kernfs: make mountinfo show properly scoped path for cgroup namespaces
    
    Patch summary:
    
    When showing a cgroupfs entry in mountinfo, show the path of the mount
    root dentry relative to the reader's cgroup namespace root.
    
    Short explanation (courtesy of mkerrisk):
    
    If we create a new cgroup namespace, then we want both /proc/self/cgroup
    and /proc/self/mountinfo to show cgroup paths that are correctly
    virtualized with respect to the cgroup mount point.  Previous to this
    patch, /proc/self/cgroup shows the right info, but /proc/self/mountinfo
    does not.
    
    Long version:
    
    When a uid 0 task which is in freezer cgroup /a/b, unshares a new cgroup
    namespace, and then mounts a new instance of the freezer cgroup, the new
    mount will be rooted at /a/b.  The root dentry field of the mountinfo
    entry will show '/a/b'.
    
     cat > /tmp/do1 << EOF
     mount -t cgroup -o freezer freezer /mnt
     grep freezer /proc/self/mountinfo
     EOF
    
     unshare -Gm  bash /tmp/do1
     > 330 160 0:34 / /sys/fs/cgroup/freezer rw,nosuid,nodev,noexec,relatime - cgroup cgroup rw,freezer
     > 355 133 0:34 /a/b /mnt rw,relatime - cgroup freezer rw,freezer
    
    The task's freezer cgroup entry in /proc/self/cgroup will simply show
    '/':
    
     grep freezer /proc/self/cgroup
     9:freezer:/
    
    If instead the same task simply bind mounts the /a/b cgroup directory,
    the resulting mountinfo entry will again show /a/b for the dentry root.
    However in this case the task will find its own cgroup at /mnt/a/b,
    not at /mnt:
    
     mount --bind /sys/fs/cgroup/freezer/a/b /mnt
     130 25 0:34 /a/b /mnt rw,nosuid,nodev,noexec,relatime shared:21 - cgroup cgroup rw,freezer
    
    In other words, there is no way for the task to know, based on what is
    in mountinfo, which cgroup directory is its own.
    
    Example (by mkerrisk):
    
    First, a little script to save some typing and verbiage:
    
    echo -e "\t/proc/self/cgroup:\t$(cat /proc/self/cgroup | grep freezer)"
    cat /proc/self/mountinfo | grep freezer |
            awk '{print "\tmountinfo:\t\t" $4 "\t" $5}'
    
    Create cgroup, place this shell into the cgroup, and look at the state
    of the /proc files:
    
    2653
    2653                         # Our shell
    14254                        # cat(1)
            /proc/self/cgroup:      10:freezer:/a/b
            mountinfo:              /       /sys/fs/cgroup/freezer
    
    Create a shell in new cgroup and mount namespaces. The act of creating
    a new cgroup namespace causes the process's current cgroups directories
    to become its cgroup root directories. (Here, I'm using my own version
    of the "unshare" utility, which takes the same options as the util-linux
    version):
    
    Look at the state of the /proc files:
    
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /       /sys/fs/cgroup/freezer
    
    The third entry in /proc/self/cgroup (the pathname of the cgroup inside
    the hierarchy) is correctly virtualized w.r.t. the cgroup namespace, which
    is rooted at /a/b in the outer namespace.
    
    However, the info in /proc/self/mountinfo is not for this cgroup
    namespace, since we are seeing a duplicate of the mount from the
    old mount namespace, and the info there does not correspond to the
    new cgroup namespace. However, trying to create a new mount still
    doesn't show us the right information in mountinfo:
    
                                          # propagating to other mountns
            /proc/self/cgroup:      7:freezer:/
            mountinfo:              /a/b    /mnt/freezer
    
    The act of creating a new cgroup namespace caused the process's
    current freezer directory, "/a/b", to become its cgroup freezer root
    directory. In other words, the pathname directory of the directory
    within the newly mounted cgroup filesystem should be "/",
    but mountinfo wrongly shows us "/a/b". The consequence of this is
    that the process in the cgroup namespace cannot correctly construct
    the pathname of its cgroup root directory from the information in
    /proc/PID/mountinfo.
    
    With this patch, the dentry root field in mountinfo is shown relative
    to the reader's cgroup namespace.  So the same steps as above:
    
            /proc/self/cgroup:      10:freezer:/a/b
            mountinfo:              /       /sys/fs/cgroup/freezer
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /../..  /sys/fs/cgroup/freezer
            /proc/self/cgroup:      10:freezer:/
            mountinfo:              /       /mnt/freezer
    
    cgroup.clone_children  freezer.parent_freezing  freezer.state      tasks
    cgroup.procs           freezer.self_freezing    notify_on_release
    3164
    2653                   # First shell that placed in this cgroup
    3164                   # Shell started by 'unshare'
    14197                  # cat(1)
    
    Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
    Tested-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index c06c44242f39..30f089ebe0a4 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -152,6 +152,8 @@ struct kernfs_syscall_ops {
 	int (*rmdir)(struct kernfs_node *kn);
 	int (*rename)(struct kernfs_node *kn, struct kernfs_node *new_parent,
 		      const char *new_name);
+	int (*show_path)(struct seq_file *sf, struct kernfs_node *kn,
+			 struct kernfs_root *root);
 };
 
 struct kernfs_root {

commit e4234a1fc343ca35f852bc527fae56fade879d4a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Mar 31 11:45:06 2016 +0100

    kernfs: Move faulting copy_user operations outside of the mutex
    
    A fault in a user provided buffer may lead anywhere, and lockdep warns
    that we have a potential deadlock between the mm->mmap_sem and the
    kernfs file mutex:
    
    [   82.811702] ======================================================
    [   82.811705] [ INFO: possible circular locking dependency detected ]
    [   82.811709] 4.5.0-rc4-gfxbench+ #1 Not tainted
    [   82.811711] -------------------------------------------------------
    [   82.811714] kms_setmode/5859 is trying to acquire lock:
    [   82.811717]  (&dev->struct_mutex){+.+.+.}, at: [<ffffffff8150d9c1>] drm_gem_mmap+0x1a1/0x270
    [   82.811731]
    but task is already holding lock:
    [   82.811734]  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.811745]
    which lock already depends on the new lock.
    
    [   82.811749]
    the existing dependency chain (in reverse order) is:
    [   82.811752]
    -> #3 (&mm->mmap_sem){++++++}:
    [   82.811761]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811766]        [<ffffffff8118bc65>] __might_fault+0x75/0xa0
    [   82.811771]        [<ffffffff8124da4a>] kernfs_fop_write+0x8a/0x180
    [   82.811787]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811792]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811797]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811801]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811807]
    -> #2 (s_active#6){++++.+}:
    [   82.811814]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811819]        [<ffffffff8124c070>] __kernfs_remove+0x210/0x2f0
    [   82.811823]        [<ffffffff8124d040>] kernfs_remove_by_name_ns+0x40/0xa0
    [   82.811828]        [<ffffffff8124e9e0>] sysfs_remove_file_ns+0x10/0x20
    [   82.811832]        [<ffffffff815318d4>] device_del+0x124/0x250
    [   82.811837]        [<ffffffff81531a19>] device_unregister+0x19/0x60
    [   82.811841]        [<ffffffff8153c051>] cpu_cache_sysfs_exit+0x51/0xb0
    [   82.811846]        [<ffffffff8153c628>] cacheinfo_cpu_callback+0x38/0x70
    [   82.811851]        [<ffffffff8109ae89>] notifier_call_chain+0x39/0xa0
    [   82.811856]        [<ffffffff8109aef9>] __raw_notifier_call_chain+0x9/0x10
    [   82.811860]        [<ffffffff810786de>] cpu_notify+0x1e/0x40
    [   82.811865]        [<ffffffff81078779>] cpu_notify_nofail+0x9/0x20
    [   82.811869]        [<ffffffff81078ac3>] _cpu_down+0x233/0x340
    [   82.811874]        [<ffffffff81079019>] disable_nonboot_cpus+0xc9/0x350
    [   82.811878]        [<ffffffff810d2e11>] suspend_devices_and_enter+0x5a1/0xb50
    [   82.811883]        [<ffffffff810d3903>] pm_suspend+0x543/0x8d0
    [   82.811888]        [<ffffffff810d1b77>] state_store+0x77/0xe0
    [   82.811892]        [<ffffffff813fa68f>] kobj_attr_store+0xf/0x20
    [   82.811897]        [<ffffffff8124e740>] sysfs_kf_write+0x40/0x50
    [   82.811902]        [<ffffffff8124dafc>] kernfs_fop_write+0x13c/0x180
    [   82.811906]        [<ffffffff811d1023>] __vfs_write+0x23/0xe0
    [   82.811910]        [<ffffffff811d1d74>] vfs_write+0xa4/0x190
    [   82.811914]        [<ffffffff811d2c14>] SyS_write+0x44/0xb0
    [   82.811918]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.811923]
    -> #1 (cpu_hotplug.lock){+.+.+.}:
    [   82.811929]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.811933]        [<ffffffff817b6f72>] mutex_lock_nested+0x62/0x3b0
    [   82.811940]        [<ffffffff810784c1>] get_online_cpus+0x61/0x80
    [   82.811944]        [<ffffffff811170eb>] stop_machine+0x1b/0xe0
    [   82.811949]        [<ffffffffa0178edd>] gen8_ggtt_insert_entries__BKL+0x2d/0x30 [i915]
    [   82.812009]        [<ffffffffa017d3a6>] ggtt_bind_vma+0x46/0x70 [i915]
    [   82.812045]        [<ffffffffa017eb70>] i915_vma_bind+0x140/0x290 [i915]
    [   82.812081]        [<ffffffffa01862b9>] i915_gem_object_do_pin+0x899/0xb00 [i915]
    [   82.812117]        [<ffffffffa0186555>] i915_gem_object_pin+0x35/0x40 [i915]
    [   82.812154]        [<ffffffffa019a23e>] intel_init_pipe_control+0xbe/0x210 [i915]
    [   82.812192]        [<ffffffffa0197312>] intel_logical_rings_init+0xe2/0xde0 [i915]
    [   82.812232]        [<ffffffffa0186fe3>] i915_gem_init+0xf3/0x130 [i915]
    [   82.812278]        [<ffffffffa02097ed>] i915_driver_load+0xf2d/0x1770 [i915]
    [   82.812318]        [<ffffffff81512474>] drm_dev_register+0xa4/0xb0
    [   82.812323]        [<ffffffff8151467e>] drm_get_pci_dev+0xce/0x1e0
    [   82.812328]        [<ffffffffa01472cf>] i915_pci_probe+0x2f/0x50 [i915]
    [   82.812360]        [<ffffffff8143f907>] pci_device_probe+0x87/0xf0
    [   82.812366]        [<ffffffff81535f89>] driver_probe_device+0x229/0x450
    [   82.812371]        [<ffffffff81536233>] __driver_attach+0x83/0x90
    [   82.812375]        [<ffffffff81533c61>] bus_for_each_dev+0x61/0xa0
    [   82.812380]        [<ffffffff81535879>] driver_attach+0x19/0x20
    [   82.812384]        [<ffffffff8153535f>] bus_add_driver+0x1ef/0x290
    [   82.812388]        [<ffffffff81536e9b>] driver_register+0x5b/0xe0
    [   82.812393]        [<ffffffff8143e83b>] __pci_register_driver+0x5b/0x60
    [   82.812398]        [<ffffffff81514866>] drm_pci_init+0xd6/0x100
    [   82.812402]        [<ffffffffa027c094>] 0xffffffffa027c094
    [   82.812406]        [<ffffffff810003de>] do_one_initcall+0xae/0x1d0
    [   82.812412]        [<ffffffff811595a0>] do_init_module+0x5b/0x1cb
    [   82.812417]        [<ffffffff81106160>] load_module+0x1c20/0x2480
    [   82.812422]        [<ffffffff81106bae>] SyS_finit_module+0x7e/0xa0
    [   82.812428]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812433]
    -> #0 (&dev->struct_mutex){+.+.+.}:
    [   82.812439]        [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812443]        [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812456]        [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812460]        [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812466]        [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812470]        [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812474]        [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812479]        [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812484]        [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    [   82.812489]
    other info that might help us debug this:
    
    [   82.812493] Chain exists of:
      &dev->struct_mutex --> s_active#6 --> &mm->mmap_sem
    
    [   82.812502]  Possible unsafe locking scenario:
    
    [   82.812506]        CPU0                    CPU1
    [   82.812508]        ----                    ----
    [   82.812510]   lock(&mm->mmap_sem);
    [   82.812514]                                lock(s_active#6);
    [   82.812519]                                lock(&mm->mmap_sem);
    [   82.812522]   lock(&dev->struct_mutex);
    [   82.812526]
     *** DEADLOCK ***
    
    [   82.812531] 1 lock held by kms_setmode/5859:
    [   82.812533]  #0:  (&mm->mmap_sem){++++++}, at: [<ffffffff8117b364>] vm_mmap_pgoff+0x44/0xa0
    [   82.812541]
    stack backtrace:
    [   82.812547] CPU: 0 PID: 5859 Comm: kms_setmode Not tainted 4.5.0-rc4-gfxbench+ #1
    [   82.812550] Hardware name:                  /NUC5CPYB, BIOS PYBSWCEL.86A.0040.2015.0814.1353 08/14/2015
    [   82.812553]  0000000000000000 ffff880079407bf0 ffffffff813f8505 ffffffff825fb270
    [   82.812560]  ffffffff825c4190 ffff880079407c30 ffffffff810c84ac ffff880079407c90
    [   82.812566]  ffff8800797ed328 ffff8800797ecb00 0000000000000001 ffff8800797ed350
    [   82.812573] Call Trace:
    [   82.812578]  [<ffffffff813f8505>] dump_stack+0x67/0x92
    [   82.812582]  [<ffffffff810c84ac>] print_circular_bug+0x1fc/0x310
    [   82.812586]  [<ffffffff810cbe59>] __lock_acquire+0x1fc9/0x20f0
    [   82.812590]  [<ffffffff810cc883>] lock_acquire+0xc3/0x1d0
    [   82.812594]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812599]  [<ffffffff8150d9e7>] drm_gem_mmap+0x1c7/0x270
    [   82.812603]  [<ffffffff8150d9c1>] ? drm_gem_mmap+0x1a1/0x270
    [   82.812608]  [<ffffffff81196a14>] mmap_region+0x334/0x580
    [   82.812612]  [<ffffffff81196fc4>] do_mmap+0x364/0x410
    [   82.812616]  [<ffffffff8117b38d>] vm_mmap_pgoff+0x6d/0xa0
    [   82.812629]  [<ffffffff811950f4>] SyS_mmap_pgoff+0x184/0x220
    [   82.812633]  [<ffffffff8100a0fd>] SyS_mmap+0x1d/0x20
    [   82.812637]  [<ffffffff817bb81b>] entry_SYSCALL_64_fastpath+0x16/0x73
    
    Highly unlikely though this scenario is, we can avoid the issue entirely
    by moving the copy operation from out under the kernfs_get_active()
    tracking by assigning the preallocated buffer its own mutex. The
    temporary buffer allocation doesn't require mutex locking as it is
    entirely local.
    
    The locked section was extended by the addition of the preallocated buf
    to speed up md user operations in
    
    commit 2b75869bba676c248d8d25ae6d2bd9221dfffdb6
    Author: NeilBrown <neilb@suse.de>
    Date:   Mon Oct 13 16:41:28 2014 +1100
    
        sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
    
    Reported-by: Ville Syrjl <ville.syrjala@linux.intel.com>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=94350
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Ville Syrjl <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: NeilBrown <neilb@suse.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index c06c44242f39..d306e282bb1d 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -177,6 +177,7 @@ struct kernfs_open_file {
 
 	/* private fields, do not use outside kernfs proper */
 	struct mutex		mutex;
+	struct mutex		prealloc_mutex;
 	int			event;
 	struct list_head	list;
 	char			*prealloc_buf;

commit fb3c8315650f89a1993fb3ae3e74e9c7e4a1c9c0
Author: Aditya Kali <adityakali@google.com>
Date:   Fri Jan 29 02:54:08 2016 -0600

    kernfs: define kernfs_node_dentry
    
    Add a new kernfs api is added to lookup the dentry for a particular
    kernfs path.
    
    Signed-off-by: Aditya Kali <adityakali@google.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 716bfdede5f5..c06c44242f39 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -284,6 +284,8 @@ struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry);
 struct kernfs_root *kernfs_root_from_sb(struct super_block *sb);
 struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
 
+struct dentry *kernfs_node_dentry(struct kernfs_node *kn,
+				  struct super_block *sb);
 struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
 				       unsigned int flags, void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);

commit 9f6df573a4041f896cbf51f1b3743494196620a7
Author: Aditya Kali <adityakali@google.com>
Date:   Fri Jan 29 02:54:04 2016 -0600

    kernfs: Add API to generate relative kernfs path
    
    The new function kernfs_path_from_node() generates and returns kernfs
    path of a given kernfs_node relative to a given parent kernfs_node.
    
    Signed-off-by: Aditya Kali <adityakali@google.com>
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index af51df35d749..716bfdede5f5 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -267,8 +267,9 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 
 int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
 size_t kernfs_path_len(struct kernfs_node *kn);
-char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
-				size_t buflen);
+int kernfs_path_from_node(struct kernfs_node *root_kn, struct kernfs_node *kn,
+			  char *buf, size_t buflen);
+char *kernfs_path(struct kernfs_node *kn, char *buf, size_t buflen);
 void pr_cont_kernfs_name(struct kernfs_node *kn);
 void pr_cont_kernfs_path(struct kernfs_node *kn);
 struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
@@ -338,8 +339,8 @@ static inline int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)
 static inline size_t kernfs_path_len(struct kernfs_node *kn)
 { return 0; }
 
-static inline char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
-					      size_t buflen)
+static inline char *kernfs_path(struct kernfs_node *kn, char *buf,
+				size_t buflen)
 { return NULL; }
 
 static inline void pr_cont_kernfs_name(struct kernfs_node *kn) { }

commit bd96f76a2454c6b97d70945902e30b4c31510678
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Nov 20 15:55:52 2015 -0500

    kernfs: implement kernfs_walk_and_get()
    
    Implement kernfs_walk_and_get() which is similar to
    kernfs_find_and_get() but can walk a path instead of just a name.
    
    v2: Use strlcpy() instead of strlen() + memcpy() as suggested by
        David.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: David Miller <davem@davemloft.net>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5d4e9c4b821d..af51df35d749 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -274,6 +274,8 @@ void pr_cont_kernfs_path(struct kernfs_node *kn);
 struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
 struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
 					   const char *name, const void *ns);
+struct kernfs_node *kernfs_walk_and_get_ns(struct kernfs_node *parent,
+					   const char *path, const void *ns);
 void kernfs_get(struct kernfs_node *kn);
 void kernfs_put(struct kernfs_node *kn);
 
@@ -350,6 +352,10 @@ static inline struct kernfs_node *
 kernfs_find_and_get_ns(struct kernfs_node *parent, const char *name,
 		       const void *ns)
 { return NULL; }
+static inline struct kernfs_node *
+kernfs_walk_and_get_ns(struct kernfs_node *parent, const char *path,
+		       const void *ns)
+{ return NULL; }
 
 static inline void kernfs_get(struct kernfs_node *kn) { }
 static inline void kernfs_put(struct kernfs_node *kn) { }
@@ -430,6 +436,12 @@ kernfs_find_and_get(struct kernfs_node *kn, const char *name)
 	return kernfs_find_and_get_ns(kn, name, NULL);
 }
 
+static inline struct kernfs_node *
+kernfs_walk_and_get(struct kernfs_node *kn, const char *path)
+{
+	return kernfs_walk_and_get_ns(kn, path, NULL);
+}
+
 static inline struct kernfs_node *
 kernfs_create_dir(struct kernfs_node *parent, const char *name, umode_t mode,
 		  void *priv)

commit 9acee9c551f045d2c5b5261aa587331423fd7d92
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Aug 18 14:54:55 2015 -0700

    kernfs: implement kernfs_path_len()
    
    Add a function to determine the path length of a kernfs node.  This
    for now will be used by writeback tracepoint updates.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 123be25ea15a..5d4e9c4b821d 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -266,6 +266,7 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 }
 
 int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
+size_t kernfs_path_len(struct kernfs_node *kn);
 char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
 				size_t buflen);
 void pr_cont_kernfs_name(struct kernfs_node *kn);
@@ -332,6 +333,9 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 static inline int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)
 { return -ENOSYS; }
 
+static inline size_t kernfs_path_len(struct kernfs_node *kn)
+{ return 0; }
+
 static inline char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
 					      size_t buflen)
 { return NULL; }

commit 0cbee992696236227a7ea411e4b0fbf73b918b6a
Merge: 2fee94b74b45 93e3bce6287e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 3 15:20:57 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace updates from Eric Biederman:
     "Long ago and far away when user namespaces where young it was realized
      that allowing fresh mounts of proc and sysfs with only user namespace
      permissions could violate the basic rule that only root gets to decide
      if proc or sysfs should be mounted at all.
    
      Some hacks were put in place to reduce the worst of the damage could
      be done, and the common sense rule was adopted that fresh mounts of
      proc and sysfs should allow no more than bind mounts of proc and
      sysfs.  Unfortunately that rule has not been fully enforced.
    
      There are two kinds of gaps in that enforcement.  Only filesystems
      mounted on empty directories of proc and sysfs should be ignored but
      the test for empty directories was insufficient.  So in my tree
      directories on proc, sysctl and sysfs that will always be empty are
      created specially.  Every other technique is imperfect as an ordinary
      directory can have entries added even after a readdir returns and
      shows that the directory is empty.  Special creation of directories
      for mount points makes the code in the kernel a smidge clearer about
      it's purpose.  I asked container developers from the various container
      projects to help test this and no holes were found in the set of mount
      points on proc and sysfs that are created specially.
    
      This set of changes also starts enforcing the mount flags of fresh
      mounts of proc and sysfs are consistent with the existing mount of
      proc and sysfs.  I expected this to be the boring part of the work but
      unfortunately unprivileged userspace winds up mounting fresh copies of
      proc and sysfs with noexec and nosuid clear when root set those flags
      on the previous mount of proc and sysfs.  So for now only the atime,
      read-only and nodev attributes which userspace happens to keep
      consistent are enforced.  Dealing with the noexec and nosuid
      attributes remains for another time.
    
      This set of changes also addresses an issue with how open file
      descriptors from /proc/<pid>/ns/* are displayed.  Recently readlink of
      /proc/<pid>/fd has been triggering a WARN_ON that has not been
      meaningful since it was added (as all of the code in the kernel was
      converted) and is not now actively wrong.
    
      There is also a short list of issues that have not been fixed yet that
      I will mention briefly.
    
      It is possible to rename a directory from below to above a bind mount.
      At which point any directory pointers below the renamed directory can
      be walked up to the root directory of the filesystem.  With user
      namespaces enabled a bind mount of the bind mount can be created
      allowing the user to pick a directory whose children they can rename
      to outside of the bind mount.  This is challenging to fix and doubly
      so because all obvious solutions must touch code that is in the
      performance part of pathname resolution.
    
      As mentioned above there is also a question of how to ensure that
      developers by accident or with purpose do not introduce exectuable
      files on sysfs and proc and in doing so introduce security regressions
      in the current userspace that will not be immediately obvious and as
      such are likely to require breaking userspace in painful ways once
      they are recognized"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      vfs: Remove incorrect debugging WARN in prepend_path
      mnt: Update fs_fully_visible to test for permanently empty directories
      sysfs: Create mountpoints with sysfs_create_mount_point
      sysfs: Add support for permanently empty directories to serve as mount points.
      kernfs: Add support for always empty directories.
      proc: Allow creating permanently empty directories that serve as mount points
      sysctl: Allow creating permanently empty directories that serve as mountpoints.
      fs: Add helper functions for permanently empty directories.
      vfs: Ignore unlocked mounts in fs_fully_visible
      mnt: Modify fs_fully_visible to deal with locked ro nodev and atime
      mnt: Refactor the logic for mounting sysfs and proc in a user namespace

commit ea015218f2f7ace2dad9cedd21ed95bdba2886d7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed May 13 16:09:29 2015 -0500

    kernfs: Add support for always empty directories.
    
    Add a new function kernfs_create_empty_dir that can be used to create
    directory that can not be modified.
    
    Update the code to use make_empty_dir_inode when reporting a
    permanently empty directory to the vfs.
    
    Update the code to not allow adding to permanently empty directories.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 71ecdab1671b..29d1896c3ba5 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -45,6 +45,7 @@ enum kernfs_node_flag {
 	KERNFS_LOCKDEP		= 0x0100,
 	KERNFS_SUICIDAL		= 0x0400,
 	KERNFS_SUICIDED		= 0x0800,
+	KERNFS_EMPTY_DIR	= 0x1000,
 };
 
 /* @flags for kernfs_create_root() */
@@ -285,6 +286,8 @@ void kernfs_destroy_root(struct kernfs_root *root);
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
 					 const char *name, umode_t mode,
 					 void *priv, const void *ns);
+struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,
+					    const char *name);
 struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 const char *name,
 					 umode_t mode, loff_t size,

commit fb02915f47181e824339d91f8e385fd4bd746d6a
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 18 16:54:28 2015 -0400

    kernfs: make kernfs_get_inode() public
    
    Move kernfs_get_inode() prototype from fs/kernfs/kernfs-internal.h to
    include/linux/kernfs.h.  It obtains the matching inode for a
    kernfs_node.
    
    It will be used by cgroup for inode based permission checks for now
    but is generally useful.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 71ecdab1671b..e6b2f7db9c0c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -277,6 +277,7 @@ void kernfs_put(struct kernfs_node *kn);
 
 struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry);
 struct kernfs_root *kernfs_root_from_sb(struct super_block *sb);
+struct inode *kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn);
 
 struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
 				       unsigned int flags, void *priv);
@@ -352,6 +353,10 @@ static inline struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry)
 static inline struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)
 { return NULL; }
 
+static inline struct inode *
+kernfs_get_inode(struct super_block *sb, struct kernfs_node *kn)
+{ return NULL; }
+
 static inline struct kernfs_root *
 kernfs_create_root(struct kernfs_syscall_ops *scops, unsigned int flags,
 		   void *priv)

commit dfeb0750b630b72b5d4fb2461bc7179eceb54666
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 13 14:36:31 2015 -0800

    kernfs: remove KERNFS_STATIC_NAME
    
    When a new kernfs node is created, KERNFS_STATIC_NAME is used to avoid
    making a separate copy of its name.  It's currently only used for sysfs
    attributes whose filenames are required to stay accessible and unchanged.
    There are rare exceptions where these names are allocated and formatted
    dynamically but for the vast majority of cases they're consts in the
    rodata section.
    
    Now that kernfs is converted to use kstrdup_const() and kfree_const(),
    there's little point in keeping KERNFS_STATIC_NAME around.  Remove it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d4e01b358341..71ecdab1671b 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -43,7 +43,6 @@ enum kernfs_node_flag {
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,
 	KERNFS_LOCKDEP		= 0x0100,
-	KERNFS_STATIC_NAME	= 0x0200,
 	KERNFS_SUICIDAL		= 0x0400,
 	KERNFS_SUICIDED		= 0x0800,
 };
@@ -291,7 +290,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 umode_t mode, loff_t size,
 					 const struct kernfs_ops *ops,
 					 void *priv, const void *ns,
-					 bool name_is_static,
 					 struct lock_class_key *key);
 struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
@@ -369,8 +367,7 @@ kernfs_create_dir_ns(struct kernfs_node *parent, const char *name,
 static inline struct kernfs_node *
 __kernfs_create_file(struct kernfs_node *parent, const char *name,
 		     umode_t mode, loff_t size, const struct kernfs_ops *ops,
-		     void *priv, const void *ns, bool name_is_static,
-		     struct lock_class_key *key)
+		     void *priv, const void *ns, struct lock_class_key *key)
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct kernfs_node *
@@ -439,7 +436,7 @@ kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
 	key = (struct lock_class_key *)&ops->lockdep_key;
 #endif
 	return __kernfs_create_file(parent, name, mode, size, ops, priv, ns,
-				    false, key);
+				    key);
 }
 
 static inline struct kernfs_node *

commit 2b75869bba676c248d8d25ae6d2bd9221dfffdb6
Author: NeilBrown <neilb@suse.de>
Date:   Mon Oct 13 16:41:28 2014 +1100

    sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
    
    md/raid allows metadata management to be performed in user-space.
    A various times, particularly on device failure, the metadata needs
    to be updated before further writes can be permitted.
    This means that the user-space program which updates metadata much
    not block on writeout, and so must not allocate memory.
    
    mlockall(MCL_CURRENT|MCL_FUTURE) and pre-allocation can avoid all
    memory allocation issues for user-memory, but that does not help
    kernel memory.
    Several kernel objects can be pre-allocated.  e.g. files opened before
    any writes to the array are permitted.
    However some kernel allocation happens in places that cannot be
    pre-allocated.
    In particular, writes to sysfs files (to tell md that it can now
    allow writes to the array) allocate a buffer using GFP_KERNEL.
    
    This patch allows attributes to be marked as "PREALLOC".  In that case
    the maximal buffer is allocated when the file is opened, and then used
    on each write instead of allocating a new buffer.
    
    As the same buffer is now shared for all writes on the same file
    description, the mutex is extended to cover full use of the buffer
    including the copy_from_user().
    
    The new __ATTR_PREALLOC() 'or's a new flag in to the 'mode', which is
    inspected by sysfs_add_file_mode_ns() to determine if the file should be
    marked as requiring prealloc.
    
    Despite the comment, we *do* use ->seq_show together with ->prealloc
    in this patch.  The next patch fixes that.
    
    Signed-off-by: NeilBrown  <neilb@suse.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 30faf797c2c3..d4e01b358341 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -179,6 +179,7 @@ struct kernfs_open_file {
 	struct mutex		mutex;
 	int			event;
 	struct list_head	list;
+	char			*prealloc_buf;
 
 	size_t			atomic_write_len;
 	bool			mmapped;
@@ -214,6 +215,13 @@ struct kernfs_ops {
 	 * larger ones are rejected with -E2BIG.
 	 */
 	size_t atomic_write_len;
+	/*
+	 * "prealloc" causes a buffer to be allocated at open for
+	 * all read/write requests.  As ->seq_show uses seq_read()
+	 * which does its own allocation, it is incompatible with
+	 * ->prealloc.  Provide ->read and ->write with ->prealloc.
+	 */
+	bool prealloc;
 	ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
 			 loff_t off);
 

commit 40f6123737d45b94ae0e4c89252a695ba6794e59
Merge: a805cbf4c4d9 76bb5ab8f6e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 10 11:38:23 2014 -0700

    Merge branch 'for-3.16-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup
    
    Pull cgroup fixes from Tejun Heo:
     "Mostly fixes for the fallouts from the recent cgroup core changes.
    
      The decoupled nature of cgroup dynamic hierarchy management
      (hierarchies are created dynamically on mount but may or may not be
      reused once unmounted depending on remaining usages) led to more
      ugliness being added to kernfs.
    
      Hopefully, this is the last of it"
    
    * 'for-3.16-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/cgroup:
      cpuset: break kernfs active protection in cpuset_write_resmask()
      cgroup: fix a race between cgroup_mount() and cgroup_kill_sb()
      kernfs: introduce kernfs_pin_sb()
      cgroup: fix mount failure in a corner case
      cpuset,mempolicy: fix sleeping function called from invalid context
      cgroup: fix broken css_has_online_children()

commit ecca47ce8294843045e7465d76fee84dbf07a004
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 1 16:41:03 2014 -0400

    kernfs: kernfs_notify() must be useable from non-sleepable contexts
    
    d911d9874801 ("kernfs: make kernfs_notify() trigger inotify events
    too") added fsnotify triggering to kernfs_notify() which requires a
    sleepable context.  There are already existing users of
    kernfs_notify() which invoke it from an atomic context and in general
    it's silly to require a sleepable context for triggering a
    notification.
    
    The following is an invalid context bug triggerd by md invoking
    sysfs_notify() from IO completion path.
    
     BUG: sleeping function called from invalid context at kernel/locking/mutex.c:586
     in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/1
     2 locks held by swapper/1/0:
      #0:  (&(&vblk->vq_lock)->rlock){-.-...}, at: [<ffffffffa0039042>] virtblk_done+0x42/0xe0 [virtio_blk]
      #1:  (&(&bitmap->counts.lock)->rlock){-.....}, at: [<ffffffff81633718>] bitmap_endwrite+0x68/0x240
     irq event stamp: 33518
     hardirqs last  enabled at (33515): [<ffffffff8102544f>] default_idle+0x1f/0x230
     hardirqs last disabled at (33516): [<ffffffff818122ed>] common_interrupt+0x6d/0x72
     softirqs last  enabled at (33518): [<ffffffff810a1272>] _local_bh_enable+0x22/0x50
     softirqs last disabled at (33517): [<ffffffff810a29e0>] irq_enter+0x60/0x80
     CPU: 1 PID: 0 Comm: swapper/1 Not tainted 3.16.0-0.rc2.git2.1.fc21.x86_64 #1
     Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
      0000000000000000 f90db13964f4ee05 ffff88007d403b80 ffffffff81807b4c
      0000000000000000 ffff88007d403ba8 ffffffff810d4f14 0000000000000000
      0000000000441800 ffff880078fa1780 ffff88007d403c38 ffffffff8180caf2
     Call Trace:
      <IRQ>  [<ffffffff81807b4c>] dump_stack+0x4d/0x66
      [<ffffffff810d4f14>] __might_sleep+0x184/0x240
      [<ffffffff8180caf2>] mutex_lock_nested+0x42/0x440
      [<ffffffff812d76a0>] kernfs_notify+0x90/0x150
      [<ffffffff8163377c>] bitmap_endwrite+0xcc/0x240
      [<ffffffffa00de863>] close_write+0x93/0xb0 [raid1]
      [<ffffffffa00df029>] r1_bio_write_done+0x29/0x50 [raid1]
      [<ffffffffa00e0474>] raid1_end_write_request+0xe4/0x260 [raid1]
      [<ffffffff813acb8b>] bio_endio+0x6b/0xa0
      [<ffffffff813b46c4>] blk_update_request+0x94/0x420
      [<ffffffff813bf0ea>] blk_mq_end_io+0x1a/0x70
      [<ffffffffa00392c2>] virtblk_request_done+0x32/0x80 [virtio_blk]
      [<ffffffff813c0648>] __blk_mq_complete_request+0x88/0x120
      [<ffffffff813c070a>] blk_mq_complete_request+0x2a/0x30
      [<ffffffffa0039066>] virtblk_done+0x66/0xe0 [virtio_blk]
      [<ffffffffa002535a>] vring_interrupt+0x3a/0xa0 [virtio_ring]
      [<ffffffff81116177>] handle_irq_event_percpu+0x77/0x340
      [<ffffffff8111647d>] handle_irq_event+0x3d/0x60
      [<ffffffff81119436>] handle_edge_irq+0x66/0x130
      [<ffffffff8101c3e4>] handle_irq+0x84/0x150
      [<ffffffff818146ad>] do_IRQ+0x4d/0xe0
      [<ffffffff818122f2>] common_interrupt+0x72/0x72
      <EOI>  [<ffffffff8105f706>] ? native_safe_halt+0x6/0x10
      [<ffffffff81025454>] default_idle+0x24/0x230
      [<ffffffff81025f9f>] arch_cpu_idle+0xf/0x20
      [<ffffffff810f5adc>] cpu_startup_entry+0x37c/0x7b0
      [<ffffffff8104df1b>] start_secondary+0x25b/0x300
    
    This patch fixes it by punting the notification delivery through a
    work item.  This ends up adding an extra pointer to kernfs_elem_attr
    enlarging kernfs_node by a pointer, which is not ideal but not a very
    big deal either.  If this turns out to be an actual issue, we can move
    kernfs_elem_attr->size to kernfs_node->iattr later.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 17aa1cce6f8e..145375ea0bd9 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -91,6 +91,7 @@ struct kernfs_elem_attr {
 	const struct kernfs_ops	*ops;
 	struct kernfs_open_node	*open;
 	loff_t			size;
+	struct kernfs_node	*notify_next;	/* for kernfs_notify() */
 };
 
 /*

commit 4e26445faad366d67d7723622bf6a60a6f0f5993
Author: Li Zefan <lizefan@huawei.com>
Date:   Mon Jun 30 11:50:28 2014 +0800

    kernfs: introduce kernfs_pin_sb()
    
    kernfs_pin_sb() tries to get a refcnt of the superblock.
    
    This will be used by cgroupfs.
    
    v2:
    - make kernfs_pin_sb() return the superblock.
    - drop kernfs_drop_sb().
    
    tj: Updated the comment a bit.
    
    [ This is a prerequisite for a bugfix. ]
    Cc: <stable@vger.kernel.org> # 3.15
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 17aa1cce6f8e..20f493564917 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -304,6 +304,7 @@ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
 			       struct kernfs_root *root, unsigned long magic,
 			       bool *new_sb_created, const void *ns);
 void kernfs_kill_sb(struct super_block *sb);
+struct super_block *kernfs_pin_sb(struct kernfs_root *root, const void *ns);
 
 void kernfs_init(void);
 

commit 26fc9cd200ec839e0b3095e05ae018f27314e7aa
Author: Jianyu Zhan <nasa4836@gmail.com>
Date:   Sat Apr 26 15:40:28 2014 +0800

    kernfs: move the last knowledge of sysfs out from kernfs
    
    There is still one residue of sysfs remaining: the sb_magic
    SYSFS_MAGIC. However this should be kernfs user specific,
    so this patch moves it out. Kerrnfs user should specify their
    magic number while mouting.
    
    Signed-off-by: Jianyu Zhan <nasa4836@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index c841688a78a3..17aa1cce6f8e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -301,8 +301,8 @@ void kernfs_notify(struct kernfs_node *kn);
 
 const void *kernfs_super_ns(struct super_block *sb);
 struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-			       struct kernfs_root *root, bool *new_sb_created,
-			       const void *ns);
+			       struct kernfs_root *root, unsigned long magic,
+			       bool *new_sb_created, const void *ns);
 void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
@@ -395,7 +395,8 @@ static inline const void *kernfs_super_ns(struct super_block *sb)
 
 static inline struct dentry *
 kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-		struct kernfs_root *root, bool *new_sb_created, const void *ns)
+		struct kernfs_root *root, unsigned long magic,
+		bool *new_sb_created, const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_kill_sb(struct super_block *sb) { }
@@ -453,9 +454,11 @@ static inline int kernfs_rename(struct kernfs_node *kn,
 
 static inline struct dentry *
 kernfs_mount(struct file_system_type *fs_type, int flags,
-	     struct kernfs_root *root, bool *new_sb_created)
+		struct kernfs_root *root, unsigned long magic,
+		bool *new_sb_created)
 {
-	return kernfs_mount_ns(fs_type, flags, root, new_sb_created, NULL);
+	return kernfs_mount_ns(fs_type, flags, root,
+				magic, new_sb_created, NULL);
 }
 
 #endif	/* __LINUX_KERNFS_H */

commit cbfef53360ea88fa7ef9f80def778fba9b05d21e
Merge: d35cc56ddfc9 4b660a7f5c80
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri May 23 10:13:53 2014 +0900

    Merge 3.15-rc6 into driver-core-next
    
    We want the kernfs fixes in this branch as well for testing.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 555724a831b4a146e7bdf16ecc989cda032b076d
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 12 13:56:27 2014 -0400

    kernfs, sysfs, cgroup: restrict extra perm check on open to sysfs
    
    The kernfs open method - kernfs_fop_open() - inherited extra
    permission checks from sysfs.  While the vfs layer allows ignoring the
    read/write permissions checks if the issuer has CAP_DAC_OVERRIDE,
    sysfs explicitly denied open regardless of the cap if the file doesn't
    have any of the UGO perms of the requested access or doesn't implement
    the requested operation.  It can be debated whether this was a good
    idea or not but the behavior is too subtle and dangerous to change at
    this point.
    
    After cgroup got converted to kernfs, this extra perm check also got
    applied to cgroup breaking libcgroup which opens write-only files with
    O_RDWR as root.  This patch gates the extra open permission check with
    a new flag KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK and enables it for sysfs.
    For sysfs, nothing changes.  For cgroup, root now can perform any
    operation regardless of the permissions as it was before kernfs
    conversion.  Note that kernfs still fails unimplemented operations
    with -EINVAL.
    
    While at it, add comments explaining KERNFS_ROOT flags.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Andrey Wagin <avagin@gmail.com>
    Tested-by: Andrey Wagin <avagin@gmail.com>
    Cc: Li Zefan <lizefan@huawei.com>
    References: http://lkml.kernel.org/g/CANaxB-xUm3rJ-Cbp72q-rQJO5mZe1qK6qXsQM=vh0U8upJ44+A@mail.gmail.com
    Fixes: 2bd59d48ebfb ("cgroup: convert to kernfs")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index b0122dc6f96a..ca1be5c9136c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -50,7 +50,24 @@ enum kernfs_node_flag {
 
 /* @flags for kernfs_create_root() */
 enum kernfs_root_flag {
-	KERNFS_ROOT_CREATE_DEACTIVATED = 0x0001,
+	/*
+	 * kernfs_nodes are created in the deactivated state and invisible.
+	 * They require explicit kernfs_activate() to become visible.  This
+	 * can be used to make related nodes become visible atomically
+	 * after all nodes are created successfully.
+	 */
+	KERNFS_ROOT_CREATE_DEACTIVATED		= 0x0001,
+
+	/*
+	 * For regular flies, if the opener has CAP_DAC_OVERRIDE, open(2)
+	 * succeeds regardless of the RW permissions.  sysfs had an extra
+	 * layer of enforcement where open(2) fails with -EACCES regardless
+	 * of CAP_DAC_OVERRIDE if the permission doesn't have the
+	 * respective read or write access at all (none of S_IRUGO or
+	 * S_IWUGO) or the respective operation isn't implemented.  The
+	 * following flag enables that behavior.
+	 */
+	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK	= 0x0002,
 };
 
 /* type-specific structures for kernfs_node union members */

commit 7d568a8383bbb9c1f5167781075906acb2bb1550
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Apr 9 11:07:30 2014 -0400

    kernfs: implement kernfs_root->supers list
    
    Currently, there's no way to find out which super_blocks are
    associated with a given kernfs_root.  Let's implement it - the planned
    inotify extension to kernfs_notify() needs it.
    
    Make kernfs_super_info point back to the super_block and chain it at
    kernfs_root->supers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index b0122dc6f96a..589318b73e61 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -144,6 +144,10 @@ struct kernfs_root {
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
 	struct kernfs_syscall_ops *syscall_ops;
+
+	/* list of kernfs_super_info of this root, protected by kernfs_mutex */
+	struct list_head	supers;
+
 	wait_queue_head_t	deactivate_waitq;
 };
 

commit b7ce40cff0b9f6597f8318fd761accd92727f61f
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 4 15:38:46 2014 -0500

    kernfs: cache atomic_write_len in kernfs_open_file
    
    While implementing atomic_write_len, 4d3773c4bb41 ("kernfs: implement
    kernfs_ops->atomic_write_len") moved data copy from userland inside
    kernfs_get_active() and kernfs_open_file->mutex so that
    kernfs_ops->atomic_write_len can be accessed before copying buffer
    from userland; unfortunately, this could lead to locking order
    inversion involving mmap_sem if copy_from_user() takes a page fault.
    
      ======================================================
      [ INFO: possible circular locking dependency detected ]
      3.14.0-rc4-next-20140228-sasha-00011-g4077c67-dirty #26 Tainted: G        W
      -------------------------------------------------------
      trinity-c236/10658 is trying to acquire lock:
       (&of->mutex#2){+.+.+.}, at: [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
    
      but task is already holding lock:
       (&mm->mmap_sem){++++++}, at: [<mm/util.c:397>] vm_mmap_pgoff+0x6e/0xe0
    
      which lock already depends on the new lock.
    
      the existing dependency chain (in reverse order) is:
    
     -> #1 (&mm->mmap_sem){++++++}:
             [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
             [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
             [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
             [<mm/memory.c:4188>] might_fault+0x7e/0xb0
             [<arch/x86/include/asm/uaccess.h:713 fs/kernfs/file.c:291>] kernfs_fop_write+0xd8/0x190
             [<fs/read_write.c:473>] vfs_write+0xe3/0x1d0
             [<fs/read_write.c:523 fs/read_write.c:515>] SyS_write+0x5d/0xa0
             [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
     -> #0 (&of->mutex#2){+.+.+.}:
             [<kernel/locking/lockdep.c:1840>] check_prev_add+0x13f/0x560
             [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
             [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
             [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
             [<kernel/locking/mutex.c:470 kernel/locking/mutex.c:571>] mutex_lock_nested+0x6a/0x510
             [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
             [<mm/mmap.c:1573>] mmap_region+0x310/0x5c0
             [<mm/mmap.c:1365>] do_mmap_pgoff+0x385/0x430
             [<mm/util.c:399>] vm_mmap_pgoff+0x8f/0xe0
             [<mm/mmap.c:1416 mm/mmap.c:1374>] SyS_mmap_pgoff+0x1b0/0x210
             [<arch/x86/kernel/sys_x86_64.c:72>] SyS_mmap+0x1d/0x20
             [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
      other info that might help us debug this:
    
       Possible unsafe locking scenario:
    
             CPU0                    CPU1
             ----                    ----
        lock(&mm->mmap_sem);
                                     lock(&of->mutex#2);
                                     lock(&mm->mmap_sem);
        lock(&of->mutex#2);
    
       *** DEADLOCK ***
    
      1 lock held by trinity-c236/10658:
       #0:  (&mm->mmap_sem){++++++}, at: [<mm/util.c:397>] vm_mmap_pgoff+0x6e/0xe0
    
      stack backtrace:
      CPU: 2 PID: 10658 Comm: trinity-c236 Tainted: G        W 3.14.0-rc4-next-20140228-sasha-00011-g4077c67-dirty #26
       0000000000000000 ffff88011911fa48 ffffffff8438e945 0000000000000000
       0000000000000000 ffff88011911fa98 ffffffff811a0109 ffff88011911fab8
       ffff88011911fab8 ffff88011911fa98 ffff880119128cc0 ffff880119128cf8
      Call Trace:
       [<lib/dump_stack.c:52>] dump_stack+0x52/0x7f
       [<kernel/locking/lockdep.c:1213>] print_circular_bug+0x129/0x160
       [<kernel/locking/lockdep.c:1840>] check_prev_add+0x13f/0x560
       [<include/linux/spinlock.h:343 mm/slub.c:1933>] ? deactivate_slab+0x511/0x550
       [<kernel/locking/lockdep.c:1945 kernel/locking/lockdep.c:2131>] validate_chain+0x6c5/0x7b0
       [<kernel/locking/lockdep.c:3182>] __lock_acquire+0x4cd/0x5a0
       [<mm/mmap.c:1552>] ? mmap_region+0x24a/0x5c0
       [<arch/x86/include/asm/current.h:14 kernel/locking/lockdep.c:3602>] lock_acquire+0x182/0x1d0
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<kernel/locking/mutex.c:470 kernel/locking/mutex.c:571>] mutex_lock_nested+0x6a/0x510
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<kernel/sched/core.c:2477>] ? get_parent_ip+0x11/0x50
       [<fs/kernfs/file.c:487>] ? kernfs_fop_mmap+0x54/0x120
       [<fs/kernfs/file.c:487>] kernfs_fop_mmap+0x54/0x120
       [<mm/mmap.c:1573>] mmap_region+0x310/0x5c0
       [<mm/mmap.c:1365>] do_mmap_pgoff+0x385/0x430
       [<mm/util.c:397>] ? vm_mmap_pgoff+0x6e/0xe0
       [<mm/util.c:399>] vm_mmap_pgoff+0x8f/0xe0
       [<kernel/rcu/update.c:97>] ? __rcu_read_unlock+0x44/0xb0
       [<fs/file.c:641>] ? dup_fd+0x3c0/0x3c0
       [<mm/mmap.c:1416 mm/mmap.c:1374>] SyS_mmap_pgoff+0x1b0/0x210
       [<arch/x86/kernel/sys_x86_64.c:72>] SyS_mmap+0x1d/0x20
       [<arch/x86/kernel/entry_64.S:749>] tracesys+0xdd/0xe2
    
    Fix it by caching atomic_write_len in kernfs_open_file during open so
    that it can be determined without accessing kernfs_ops in
    kernfs_fop_write().  This restores the structure of kernfs_fop_write()
    before 4d3773c4bb41 with updated @len determination logic.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    References: http://lkml.kernel.org/g/53113485.2090407@oracle.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 09669d092748..b0122dc6f96a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -158,6 +158,7 @@ struct kernfs_open_file {
 	int			event;
 	struct list_head	list;
 
+	size_t			atomic_write_len;
 	bool			mmapped;
 	const struct vm_operations_struct *vm_ops;
 };

commit 13df7977431e3b906a23bb75f29e0f40a8d73f87
Merge: 6d8b3e1ad3d3 0414855fdc4a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Mar 2 20:09:08 2014 -0800

    Merge 3.14-rc5 into driver-core-next
    
    We want the fixes in here.

commit fed95bab8d29b928fcf6225be72d37ded452e8a2
Author: Li Zefan <lizefan@huawei.com>
Date:   Tue Feb 25 19:28:44 2014 +0800

    sysfs: fix namespace refcnt leak
    
    As mount() and kill_sb() is not a one-to-one match, we shoudn't get
    ns refcnt unconditionally in sysfs_mount(), and instead we should
    get the refcnt only when kernfs_mount() allocated a new superblock.
    
    v2:
    - Changed the name of the new argument, suggested by Tejun.
    - Made the argument optional, suggested by Tejun.
    
    v3:
    - Make the new argument as second-to-last arg, suggested by Tejun.
    
    Signed-off-by: Li Zefan <lizefan@huawei.com>
    Acked-by: Tejun Heo <tj@kernel.org>
     ---
     fs/kernfs/mount.c      | 8 +++++++-
     fs/sysfs/mount.c       | 5 +++--
     include/linux/kernfs.h | 9 +++++----
     3 files changed, 15 insertions(+), 7 deletions(-)
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5be9f0228a3b..d267623c28cf 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -249,7 +249,8 @@ void kernfs_notify(struct kernfs_node *kn);
 
 const void *kernfs_super_ns(struct super_block *sb);
 struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-			       struct kernfs_root *root, const void *ns);
+			       struct kernfs_root *root, bool *new_sb_created,
+			       const void *ns);
 void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
@@ -317,7 +318,7 @@ static inline const void *kernfs_super_ns(struct super_block *sb)
 
 static inline struct dentry *
 kernfs_mount_ns(struct file_system_type *fs_type, int flags,
-		struct kernfs_root *root, const void *ns)
+		struct kernfs_root *root, bool *new_sb_created, const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_kill_sb(struct super_block *sb) { }
@@ -368,9 +369,9 @@ static inline int kernfs_remove_by_name(struct kernfs_node *parent,
 
 static inline struct dentry *
 kernfs_mount(struct file_system_type *fs_type, int flags,
-	     struct kernfs_root *root)
+	     struct kernfs_root *root, bool *new_sb_created)
 {
-	return kernfs_mount_ns(fs_type, flags, root, NULL);
+	return kernfs_mount_ns(fs_type, flags, root, new_sb_created, NULL);
 }
 
 #endif	/* __LINUX_KERNFS_H */

commit ba341d55a420ab4fdd1a53fd395fd59bd65de880
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:17 2014 -0500

    kernfs: add CONFIG_KERNFS
    
    As sysfs was kernfs's only user, kernfs has been piggybacking on
    CONFIG_SYSFS; however, kernfs is scheduled to grow a new user very
    soon.  Introduce a separate config option CONFIG_KERNFS which is to be
    selected by kernfs users.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 8736ee86a1d6..649497a56a95 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -201,7 +201,7 @@ struct kernfs_ops {
 #endif
 };
 
-#ifdef CONFIG_SYSFS
+#ifdef CONFIG_KERNFS
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 {
@@ -284,7 +284,7 @@ void kernfs_kill_sb(struct super_block *sb);
 
 void kernfs_init(void);
 
-#else	/* CONFIG_SYSFS */
+#else	/* CONFIG_KERNFS */
 
 static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 { return 0; }	/* whatever */
@@ -379,7 +379,7 @@ static inline void kernfs_kill_sb(struct super_block *sb) { }
 
 static inline void kernfs_init(void) { }
 
-#endif	/* CONFIG_SYSFS */
+#endif	/* CONFIG_KERNFS */
 
 static inline struct kernfs_node *
 kernfs_find_and_get(struct kernfs_node *kn, const char *name)

commit 3eef34ad7dc369b7183ec383908aff3da2f6e5ec
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 7 13:32:07 2014 -0500

    kernfs: implement kernfs_get_parent(), kernfs_name/path() and friends
    
    kernfs_node->parent and ->name are currently marked as "published"
    indicating that kernfs users may access them directly; however, those
    fields may get updated by kernfs_rename[_ns]() and unrestricted access
    may lead to erroneous values or oops.
    
    Protect ->parent and ->name updates with a irq-safe spinlock
    kernfs_rename_lock and implement the following accessors for these
    fields.
    
    * kernfs_name()         - format the node's name into the specified buffer
    * kernfs_path()         - format the node's path into the specified buffer
    * pr_cont_kernfs_name() - pr_cont a node's name (doesn't need buffer)
    * pr_cont_kernfs_path() - pr_cont a node's path (doesn't need buffer)
    * kernfs_get_parent()   - pin and return a node's parent
    
    All can be called under any context.  The recursive sysfs_pathname()
    in fs/sysfs/dir.c is replaced with kernfs_path() and
    sysfs_rename_dir_ns() is updated to use kernfs_get_parent() instead of
    dereferencing parent directly.
    
    v2: Dummy definition of kernfs_path() for !CONFIG_KERNFS was missing
        static inline making it cause a lot of build warnings.  Add it.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 9c899040c05e..8736ee86a1d6 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -91,7 +91,12 @@ struct kernfs_node {
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
-	/* the following two fields are published */
+	/*
+	 * Use kernfs_get_parent() and kernfs_name/path() instead of
+	 * accessing the following two fields directly.  If the node is
+	 * never moved to a different parent, it is safe to access the
+	 * parent directly.
+	 */
 	struct kernfs_node	*parent;
 	const char		*name;
 
@@ -229,6 +234,12 @@ static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 	return kn->flags & KERNFS_NS;
 }
 
+int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen);
+char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
+				size_t buflen);
+void pr_cont_kernfs_name(struct kernfs_node *kn);
+void pr_cont_kernfs_path(struct kernfs_node *kn);
+struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn);
 struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
 					   const char *name, const void *ns);
 void kernfs_get(struct kernfs_node *kn);
@@ -283,6 +294,19 @@ static inline void kernfs_enable_ns(struct kernfs_node *kn) { }
 static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 { return false; }
 
+static inline int kernfs_name(struct kernfs_node *kn, char *buf, size_t buflen)
+{ return -ENOSYS; }
+
+static inline char * __must_check kernfs_path(struct kernfs_node *kn, char *buf,
+					      size_t buflen)
+{ return NULL; }
+
+static inline void pr_cont_kernfs_name(struct kernfs_node *kn) { }
+static inline void pr_cont_kernfs_path(struct kernfs_node *kn) { }
+
+static inline struct kernfs_node *kernfs_get_parent(struct kernfs_node *kn)
+{ return NULL; }
+
 static inline struct kernfs_node *
 kernfs_find_and_get_ns(struct kernfs_node *parent, const char *name,
 		       const void *ns)

commit 0c23b2259a4850494e2c53e864ea840597c6cdd3
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:15 2014 -0500

    kernfs: implement kernfs_node_from_dentry(), kernfs_root_from_sb() and kernfs_rename()
    
    Implement helpers to determine node from dentry and root from
    super_block.  Also add a kernfs_rename_ns() wrapper which assumes NULL
    namespace.  These generally make sense and will be used by cgroup.
    
    v2: Some dummy implementations for !CONFIG_SYSFS was missing.  Fixed.
        Reported by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 9ca0f09757a1..9c899040c05e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -234,6 +234,9 @@ struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
 void kernfs_get(struct kernfs_node *kn);
 void kernfs_put(struct kernfs_node *kn);
 
+struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry);
+struct kernfs_root *kernfs_root_from_sb(struct super_block *sb);
+
 struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
 				       unsigned int flags, void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
@@ -288,6 +291,12 @@ kernfs_find_and_get_ns(struct kernfs_node *parent, const char *name,
 static inline void kernfs_get(struct kernfs_node *kn) { }
 static inline void kernfs_put(struct kernfs_node *kn) { }
 
+static inline struct kernfs_node *kernfs_node_from_dentry(struct dentry *dentry)
+{ return NULL; }
+
+static inline struct kernfs_root *kernfs_root_from_sb(struct super_block *sb)
+{ return NULL; }
+
 static inline struct kernfs_root *
 kernfs_create_root(struct kernfs_syscall_ops *scops, unsigned int flags,
 		   void *priv)
@@ -388,6 +397,13 @@ static inline int kernfs_remove_by_name(struct kernfs_node *parent,
 	return kernfs_remove_by_name_ns(parent, name, NULL);
 }
 
+static inline int kernfs_rename(struct kernfs_node *kn,
+				struct kernfs_node *new_parent,
+				const char *new_name)
+{
+	return kernfs_rename_ns(kn, new_parent, new_name, NULL);
+}
+
 static inline struct dentry *
 kernfs_mount(struct file_system_type *fs_type, int flags,
 	     struct kernfs_root *root)

commit 2536390da0d300b2734c721235c082498879841d
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:14 2014 -0500

    kernfs: add kernfs_open_file->priv
    
    Add a private data field to be used by kernfs file operations.  This
    generally makes sense and will be used by cgroup.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 47f5235a097a..9ca0f09757a1 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -146,6 +146,7 @@ struct kernfs_open_file {
 	/* published fields */
 	struct kernfs_node	*kn;
 	struct file		*file;
+	void			*priv;
 
 	/* private fields, do not use outside kernfs proper */
 	struct mutex		mutex;

commit 4d3773c4bb41ed5228f1ab7a4a52b79e17b10515
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:13 2014 -0500

    kernfs: implement kernfs_ops->atomic_write_len
    
    A write to a kernfs_node is buffered through a kernel buffer.  Writes
    <= PAGE_SIZE are performed atomically, while larger ones are executed
    in PAGE_SIZE chunks.  While this is enough for sysfs, cgroup which is
    scheduled to be converted to use kernfs needs a bit more control over
    it.
    
    This patch adds kernfs_ops->atomic_write_len.  If not set (zero), the
    behavior stays the same.  If set, writes upto the size are executed
    atomically and larger writes are rejected with -E2BIG.
    
    A different implementation strategy would be allowing configuring
    chunking size while making the original write size available to the
    write method; however, such strategy, while being more complicated,
    doesn't really buy anything.  If the write implementation has to
    handle chunking, the specific chunk size shouldn't matter all that
    much.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 4520c86f5cb4..47f5235a097a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -178,9 +178,13 @@ struct kernfs_ops {
 			loff_t off);
 
 	/*
-	 * write() is bounced through kernel buffer and a write larger than
-	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+	 * write() is bounced through kernel buffer.  If atomic_write_len
+	 * is not set, a write larger than PAGE_SIZE results in partial
+	 * operations of PAGE_SIZE chunks.  If atomic_write_len is set,
+	 * writes upto the specified size are executed atomically but
+	 * larger ones are rejected with -E2BIG.
 	 */
+	size_t atomic_write_len;
 	ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
 			 loff_t off);
 

commit d35258ef702cca0c4e66d799f8e38b78c02ce8a5
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:12 2014 -0500

    kernfs: allow nodes to be created in the deactivated state
    
    Currently, kernfs_nodes are made visible to userland on creation,
    which makes it difficult for kernfs users to atomically succeed or
    fail creation of multiple nodes.  In addition, if something fails
    after creating some nodes, the created nodes might already be in use
    and their active refs need to be drained for removal, which has the
    potential to introduce tricky reverse locking dependency on active_ref
    depending on how the error path is synchronized.
    
    This patch introduces per-root flag KERNFS_ROOT_CREATE_DEACTIVATED.
    If set, all nodes under the root are created in the deactivated state
    and stay invisible to userland until explicitly enabled by the new
    kernfs_activate() API.  Also, nodes which have never been activated
    are guaranteed to bypass draining on removal thus allowing error paths
    to not worry about lockding dependency on active_ref draining.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5d5b7e947294..4520c86f5cb4 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -38,6 +38,7 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
+	KERNFS_ACTIVATED	= 0x0010,
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,
@@ -47,6 +48,11 @@ enum kernfs_node_flag {
 	KERNFS_SUICIDED		= 0x0800,
 };
 
+/* @flags for kernfs_create_root() */
+enum kernfs_root_flag {
+	KERNFS_ROOT_CREATE_DEACTIVATED = 0x0001,
+};
+
 /* type-specific structures for kernfs_node union members */
 struct kernfs_elem_dir {
 	unsigned long		subdirs;
@@ -128,6 +134,7 @@ struct kernfs_syscall_ops {
 struct kernfs_root {
 	/* published fields */
 	struct kernfs_node	*kn;
+	unsigned int		flags;	/* KERNFS_ROOT_* flags */
 
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
@@ -223,7 +230,7 @@ void kernfs_get(struct kernfs_node *kn);
 void kernfs_put(struct kernfs_node *kn);
 
 struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
-				       void *priv);
+				       unsigned int flags, void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
 
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
@@ -239,6 +246,7 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
 				       struct kernfs_node *target);
+void kernfs_activate(struct kernfs_node *kn);
 void kernfs_remove(struct kernfs_node *kn);
 void kernfs_break_active_protection(struct kernfs_node *kn);
 void kernfs_unbreak_active_protection(struct kernfs_node *kn);
@@ -276,7 +284,8 @@ static inline void kernfs_get(struct kernfs_node *kn) { }
 static inline void kernfs_put(struct kernfs_node *kn) { }
 
 static inline struct kernfs_root *
-kernfs_create_root(struct kernfs_syscall_ops *scops, void *priv)
+kernfs_create_root(struct kernfs_syscall_ops *scops, unsigned int flags,
+		   void *priv)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_destroy_root(struct kernfs_root *root) { }
@@ -298,6 +307,8 @@ kernfs_create_link(struct kernfs_node *parent, const char *name,
 		   struct kernfs_node *target)
 { return ERR_PTR(-ENOSYS); }
 
+static inline void kernfs_activate(struct kernfs_node *kn) { }
+
 static inline void kernfs_remove(struct kernfs_node *kn) { }
 
 static inline bool kernfs_remove_self(struct kernfs_node *kn)

commit 6a7fed4eefddad48224f1c9d534b4e262f0897f6
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:10 2014 -0500

    kernfs: implement kernfs_syscall_ops->remount_fs() and ->show_options()
    
    Add two super_block related syscall callbacks ->remount_fs() and
    ->show_options() to kernfs_syscall_ops.  These simply forward the
    matching super_operations.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5ddc47450335..5d5b7e947294 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -115,6 +115,9 @@ struct kernfs_node {
  * kernfs_node parameter.
  */
 struct kernfs_syscall_ops {
+	int (*remount_fs)(struct kernfs_root *root, int *flags, char *data);
+	int (*show_options)(struct seq_file *sf, struct kernfs_root *root);
+
 	int (*mkdir)(struct kernfs_node *parent, const char *name,
 		     umode_t mode);
 	int (*rmdir)(struct kernfs_node *kn);

commit 90c07c895c87d38db100b6afcb686ab3ef0d6a64
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:09 2014 -0500

    kernfs: rename kernfs_dir_ops to kernfs_syscall_ops
    
    We're gonna need non-dir syscall callbacks, which will make dir_ops a
    misnomer.  Let's rename kernfs_dir_ops to kernfs_syscall_ops.
    
    This is pure rename.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 58a131ddc6a3..5ddc47450335 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -108,13 +108,13 @@ struct kernfs_node {
 };
 
 /*
- * kernfs_dir_ops may be specified on kernfs_create_root() to support
- * directory manipulation syscalls.  These optional callbacks are invoked
- * on the matching syscalls and can perform any kernfs operations which
- * don't necessarily have to be the exact operation requested.  An active
- * reference is held for each kernfs_node parameter.
+ * kernfs_syscall_ops may be specified on kernfs_create_root() to support
+ * syscalls.  These optional callbacks are invoked on the matching syscalls
+ * and can perform any kernfs operations which don't necessarily have to be
+ * the exact operation requested.  An active reference is held for each
+ * kernfs_node parameter.
  */
-struct kernfs_dir_ops {
+struct kernfs_syscall_ops {
 	int (*mkdir)(struct kernfs_node *parent, const char *name,
 		     umode_t mode);
 	int (*rmdir)(struct kernfs_node *kn);
@@ -128,7 +128,7 @@ struct kernfs_root {
 
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
-	struct kernfs_dir_ops	*dir_ops;
+	struct kernfs_syscall_ops *syscall_ops;
 	wait_queue_head_t	deactivate_waitq;
 };
 
@@ -219,7 +219,7 @@ struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
 void kernfs_get(struct kernfs_node *kn);
 void kernfs_put(struct kernfs_node *kn);
 
-struct kernfs_root *kernfs_create_root(struct kernfs_dir_ops *kdops,
+struct kernfs_root *kernfs_create_root(struct kernfs_syscall_ops *scops,
 				       void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
 
@@ -273,7 +273,7 @@ static inline void kernfs_get(struct kernfs_node *kn) { }
 static inline void kernfs_put(struct kernfs_node *kn) { }
 
 static inline struct kernfs_root *
-kernfs_create_root(struct kernfs_dir_ops *kdops, void *priv)
+kernfs_create_root(struct kernfs_syscall_ops *scops, void *priv)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_destroy_root(struct kernfs_root *root) { }

commit 07c7530dd46728e25e938d0eb291f8085435c365
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:09:08 2014 -0500

    kernfs: invoke dir_ops while holding active ref of the target node
    
    kernfs_dir_ops are currently being invoked without any active
    reference, which makes it tricky for the invoked operations to
    determine whether the objects associated those nodes are safe to
    access and will remain that way for the duration of such operations.
    
    kernfs already has active_ref mechanism to deal with this which makes
    the removal of a given node the synchronization point for gating the
    file operations.  There's no reason for dir_ops to be any different.
    Update the dir_ops handling so that active_ref is held while the
    dir_ops are executing.  This guarantees that while a dir_ops is
    executing the target nodes stay alive.
    
    As kernfs_dir_ops doesn't have any in-kernel user at this point, this
    doesn't affect anybody.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 02ac33435808..58a131ddc6a3 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -111,7 +111,8 @@ struct kernfs_node {
  * kernfs_dir_ops may be specified on kernfs_create_root() to support
  * directory manipulation syscalls.  These optional callbacks are invoked
  * on the matching syscalls and can perform any kernfs operations which
- * don't necessarily have to be the exact operation requested.
+ * don't necessarily have to be the exact operation requested.  An active
+ * reference is held for each kernfs_node parameter.
  */
 struct kernfs_dir_ops {
 	int (*mkdir)(struct kernfs_node *parent, const char *name,

commit 6b0afc2a21726b2d6b6aa441af40cafaf5405cc8
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:01 2014 -0500

    kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers
    
    Sometimes it's necessary to implement a node which wants to delete
    nodes including itself.  This isn't straightforward because of kernfs
    active reference.  While a file operation is in progress, an active
    reference is held and kernfs_remove() waits for all such references to
    drain before completing.  For a self-deleting node, this is a deadlock
    as kernfs_remove() ends up waiting for an active reference that itself
    is sitting on top of.
    
    This currently is worked around in the sysfs layer using
    sysfs_schedule_callback() which makes such removals asynchronous.
    While it works, it's rather cumbersome and inherently breaks
    synchronicity of the operation - the file operation which triggered
    the operation may complete before the removal is finished (or even
    started) and the removal may fail asynchronously.  If a removal
    operation is immmediately followed by another operation which expects
    the specific name to be available (e.g. removal followed by rename
    onto the same name), there's no way to make the latter operation
    reliable.
    
    The thing is there's no inherent reason for this to be asynchrnous.
    All that's necessary to do this synchronous is a dedicated operation
    which drops its own active ref and deactivates self.  This patch
    implements kernfs_remove_self() and its wrappers in sysfs and driver
    core.  kernfs_remove_self() is to be called from one of the file
    operations, drops the active ref the task is holding, removes the self
    node, and restores active ref to the dead node so that the ref is
    balanced afterwards.  __kernfs_remove() is updated so that it takes an
    early exit if the target node is already fully removed so that the
    active ref restored by kernfs_remove_self() after removal doesn't
    confuse the deactivation path.
    
    This makes implementing self-deleting nodes very easy.  The normal
    removal path doesn't even need to be changed to use
    kernfs_remove_self() for the self-deleting node.  The method can
    invoke kernfs_remove_self() on itself before proceeding the normal
    removal path.  kernfs_remove() invoked on the node by the normal
    deletion path will simply be ignored.
    
    This will replace sysfs_schedule_callback().  A subtle feature of
    sysfs_schedule_callback() is that it collapses multiple invocations -
    even if multiple removals are triggered, the removal callback is run
    only once.  An equivalent effect can be achieved by testing the return
    value of kernfs_remove_self() - only the one which gets %true return
    value should proceed with actual deletion.  All other instances of
    kernfs_remove_self() will wait till the enclosing kernfs operation
    which invoked the winning instance of kernfs_remove_self() finishes
    and then return %false.  This trivially makes all users of
    kernfs_remove_self() automatically show correct synchronous behavior
    even when there are multiple concurrent operations - all "echo 1 >
    delete" instances will finish only after the whole operation is
    completed by one of the instances.
    
    Note that manipulation of active ref is implemented in separate public
    functions - kernfs_[un]break_active_protection().
    kernfs_remove_self() is the only user at the moment but this will be
    used to cater to more complex cases.
    
    v2: For !CONFIG_SYSFS, dummy version kernfs_remove_self() was missing
        and sysfs_remove_file_self() had incorrect return type.  Fix it.
        Reported by kbuild test bot.
    
    v3: kernfs_[un]break_active_protection() separated out from
        kernfs_remove_self() and exposed as public API.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 917bc6c1eb04..02ac33435808 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -43,6 +43,8 @@ enum kernfs_node_flag {
 	KERNFS_HAS_MMAP		= 0x0080,
 	KERNFS_LOCKDEP		= 0x0100,
 	KERNFS_STATIC_NAME	= 0x0200,
+	KERNFS_SUICIDAL		= 0x0400,
+	KERNFS_SUICIDED		= 0x0800,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -234,6 +236,9 @@ struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
 				       struct kernfs_node *target);
 void kernfs_remove(struct kernfs_node *kn);
+void kernfs_break_active_protection(struct kernfs_node *kn);
+void kernfs_unbreak_active_protection(struct kernfs_node *kn);
+bool kernfs_remove_self(struct kernfs_node *kn);
 int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
@@ -291,6 +296,9 @@ kernfs_create_link(struct kernfs_node *parent, const char *name,
 
 static inline void kernfs_remove(struct kernfs_node *kn) { }
 
+static inline bool kernfs_remove_self(struct kernfs_node *kn)
+{ return false; }
+
 static inline int kernfs_remove_by_name_ns(struct kernfs_node *kn,
 					   const char *name, const void *ns)
 { return -ENOSYS; }

commit 81c173cb5e87fbb47ccd80630faefe39bbf68449
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:03:00 2014 -0500

    kernfs: remove KERNFS_REMOVED
    
    KERNFS_REMOVED is used to mark half-initialized and dying nodes so
    that they don't show up in lookups and deny adding new nodes under or
    renaming it; however, its role overlaps that of deactivation.
    
    It's necessary to deny addition of new children while removal is in
    progress; however, this role considerably intersects with deactivation
    - KERNFS_REMOVED prevents new children while deactivation prevents new
    file operations.  There's no reason to have them separate making
    things more complex than necessary.
    
    This patch removes KERNFS_REMOVED.
    
    * Instead of KERNFS_REMOVED, each node now starts its life
      deactivated.  This means that we now use both atomic_add() and
      atomic_sub() on KN_DEACTIVATED_BIAS, which is INT_MIN.  The compiler
      generates an overflow warnings when negating INT_MIN as the negation
      can't be represented as a positive number.  Nothing is actually
      broken but let's bump BIAS by one to avoid the warnings for archs
      which negates the subtrahend..
    
    * A new helper kernfs_active() which tests whether kn->active >= 0 is
      added for convenience and lockdep annotation.  All KERNFS_REMOVED
      tests are replaced with negated kernfs_active() tests.
    
    * __kernfs_remove() is updated to deactivate, but not drain, all nodes
      in the subtree instead of setting KERNFS_REMOVED.  This removes
      deactivation from kernfs_deactivate(), which is now renamed to
      kernfs_drain().
    
    * Sanity check on KERNFS_REMOVED in kernfs_put() is replaced with
      checks on the active ref.
    
    * Some comment style updates in the affected area.
    
    v2: Reordered before removal path restructuring.  kernfs_active()
        dropped and kernfs_get/put_active() used instead.  RB_EMPTY_NODE()
        used in the lookup paths.
    
    v3: Reverted most of v2 except for creating a new node with
        KN_DEACTIVATED_BIAS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index dc4cd6c04236..917bc6c1eb04 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -38,7 +38,6 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
-	KERNFS_REMOVED		= 0x0010,
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,

commit 182fd64b66342219d6fcf2b84d337529d120d95c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:02:59 2014 -0500

    kernfs: remove KERNFS_ACTIVE_REF and add kernfs_lockdep()
    
    There currently are two mechanisms gating active ref lockdep
    annotations - KERNFS_LOCKDEP flag and KERNFS_ACTIVE_REF type mask.
    The former disables lockdep annotations in kernfs_get/put_active()
    while the latter disables all of kernfs_deactivate().
    
    While KERNFS_ACTIVE_REF also behaves as an optimization to skip the
    deactivation step for non-file nodes, the benefit is marginal and it
    needlessly diverges code paths.  Let's drop KERNFS_ACTIVE_REF.
    
    While at it, add a test helper kernfs_lockdep() to test KERNFS_LOCKDEP
    flag so that it's more convenient and the related code can be compiled
    out when not enabled.
    
    v2: Refreshed on top of ("kernfs: make kernfs_deactivate() honor
        KERNFS_LOCKDEP flag").  As the earlier patch already added
        KERNFS_LOCKDEP tests to kernfs_deactivate(), those additions are
        dropped from this patch and the existing ones are simply converted
        to kernfs_lockdep().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 38646f6096bc..dc4cd6c04236 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -35,7 +35,6 @@ enum kernfs_node_type {
 };
 
 #define KERNFS_TYPE_MASK	0x000f
-#define KERNFS_ACTIVE_REF	KERNFS_FILE
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {

commit 988cd7afb3f37598891ca70b4c6eb914c338c46a
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:02:58 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release kernfs_mutex itself.
      sysfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Rebased on top of "kernfs: associate a new kernfs_node with its
        parent on creation" which dropped @parent from kernfs_add_one().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 295a3bf642ba..38646f6096bc 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -91,10 +91,6 @@ struct kernfs_node {
 
 	struct rb_node		rb;
 
-	union {
-		struct kernfs_node	*removed_list;
-	} u;
-
 	const void		*ns;	/* namespace tag */
 	unsigned int		hash;	/* ns + name hash */
 	union {

commit abd54f028ec30976d6e797e7474ec91d96186a0c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Feb 3 14:02:55 2014 -0500

    kernfs: replace kernfs_node->u.completion with kernfs_root->deactivate_waitq
    
    kernfs_node->u.completion is used to notify deactivation completion
    from kernfs_put_active() to kernfs_deactivate().  We now allow
    multiple racing removals of the same node and the current removal
    scheme is no longer correct - kernfs_remove() invocation may return
    before the node is properly deactivated if it races against another
    removal.  The removal path will be restructured to address the issue.
    
    To help such restructure which requires supporting multiple waiters,
    this patch replaces kernfs_node->u.completion with
    kernfs_root->deactivate_waitq.  This makes deactivation event
    notifications share a per-root waitqueue_head; however, the wait path
    is quite cold and this will also allow shaving one pointer off
    kernfs_node.
    
    v2: Refreshed on top of ("kernfs: make kernfs_deactivate() honor
        KERNFS_LOCKDEP flag").
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 5be9f0228a3b..295a3bf642ba 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -15,7 +15,7 @@
 #include <linux/lockdep.h>
 #include <linux/rbtree.h>
 #include <linux/atomic.h>
-#include <linux/completion.h>
+#include <linux/wait.h>
 
 struct file;
 struct dentry;
@@ -92,7 +92,6 @@ struct kernfs_node {
 	struct rb_node		rb;
 
 	union {
-		struct completion	*completion;
 		struct kernfs_node	*removed_list;
 	} u;
 
@@ -133,6 +132,7 @@ struct kernfs_root {
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
 	struct kernfs_dir_ops	*dir_ops;
+	wait_queue_head_t	deactivate_waitq;
 };
 
 struct kernfs_open_file {

commit 917f56caaabc215f9658006dad28a9665ec0ce19
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 17 09:57:49 2014 -0500

    kernfs: add struct dentry declaration in kernfs.h
    
    Hello, Greg.
    
    Two misc fixes for kernfs.
    
    Thanks.
    ------- 8< -------
    struct dentry is used in kernfs.h but its declaration was missing,
    leading to compilation errors unless its declaration gets pulled in in
    some other way.  Add the declaration.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d2c439db4efa..5be9f0228a3b 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -18,6 +18,7 @@
 #include <linux/completion.h>
 
 struct file;
+struct dentry;
 struct iattr;
 struct seq_file;
 struct vm_area_struct;

commit 87da149343c8c93f6984c0f4b9da7651709624f7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:43:11 2014 -0800

    Revert "kernfs: replace kernfs_node->u.completion with kernfs_root->deactivate_waitq"
    
    This reverts commit ea1c472dfeada211a0100daa7976e8e8e779b858.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 232f1a632383..d2c439db4efa 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -15,7 +15,7 @@
 #include <linux/lockdep.h>
 #include <linux/rbtree.h>
 #include <linux/atomic.h>
-#include <linux/wait.h>
+#include <linux/completion.h>
 
 struct file;
 struct iattr;
@@ -91,6 +91,7 @@ struct kernfs_node {
 	struct rb_node		rb;
 
 	union {
+		struct completion	*completion;
 		struct kernfs_node	*removed_list;
 	} u;
 
@@ -131,7 +132,6 @@ struct kernfs_root {
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
 	struct kernfs_dir_ops	*dir_ops;
-	wait_queue_head_t	deactivate_waitq;
 };
 
 struct kernfs_open_file {

commit 0890147fe09ff7e8275a162b1ab76ab5e3158c6d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:39:52 2014 -0800

    Revert "kernfs: remove KERNFS_ACTIVE_REF and add kernfs_lockdep()"
    
    This reverts commit a69d001cfc712b96ec9d7ba44d6285702a38dabf.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 42ad32ff22f8..232f1a632383 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -34,6 +34,7 @@ enum kernfs_node_type {
 };
 
 #define KERNFS_TYPE_MASK	0x000f
+#define KERNFS_ACTIVE_REF	KERNFS_FILE
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {

commit 798c75a0d44cdbd6e3d82a6a676e6de38525b3bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:36:03 2014 -0800

    Revert "kernfs: remove KERNFS_REMOVED"
    
    This reverts commit ae34372eb8408b3d07e870f1939f99007a730d28.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 289d4f639ade..42ad32ff22f8 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,6 +37,7 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
+	KERNFS_REMOVED		= 0x0010,
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,

commit 4f4b1b6471cf219d136776f9ff9631a07c4e92b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:30:47 2014 -0800

    Revert "kernfs: restructure removal path to fix possible premature return"
    
    This reverts commit 45a140e587f3d32d8d424ed940dffb61e1739047.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 61bd7ae6b8e0..289d4f639ade 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,7 +37,6 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
-	KERNFS_JUST_DEACTIVATED	= 0x0010, /* used to aid lockdep annotation */
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,

commit 7653fe9d6cddc3fc5e4220608079006d8ac0054c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:20:56 2014 -0800

    Revert "kernfs: remove kernfs_addrm_cxt"
    
    This reverts commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 9b5a4bb88c64..61bd7ae6b8e0 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -89,6 +89,10 @@ struct kernfs_node {
 
 	struct rb_node		rb;
 
+	union {
+		struct kernfs_node	*removed_list;
+	} u;
+
 	const void		*ns;	/* namespace tag */
 	unsigned int		hash;	/* ns + name hash */
 	union {

commit 9b0925a6ff64a33be45497e3c798bfee8790b102
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:09:38 2014 -0800

    Revert "kernfs: implement kernfs_{de|re}activate[_self]()"
    
    This reverts commit 9f010c2ad5194a4b682e747984477850fabd03be.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index ac8693027058..9b5a4bb88c64 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -80,8 +80,6 @@ struct kernfs_elem_attr {
 struct kernfs_node {
 	atomic_t		count;
 	atomic_t		active;
-	int			deact_depth;
-	unsigned int		hash;	/* ns + name hash */
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
@@ -92,6 +90,7 @@ struct kernfs_node {
 	struct rb_node		rb;
 
 	const void		*ns;	/* namespace tag */
+	unsigned int		hash;	/* ns + name hash */
 	union {
 		struct kernfs_elem_dir		dir;
 		struct kernfs_elem_symlink	symlink;
@@ -234,10 +233,6 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
 				       struct kernfs_node *target);
-void kernfs_deactivate(struct kernfs_node *kn);
-void kernfs_reactivate(struct kernfs_node *kn);
-void kernfs_deactivate_self(struct kernfs_node *kn);
-void kernfs_reactivate_self(struct kernfs_node *kn);
 void kernfs_remove(struct kernfs_node *kn);
 int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);

commit a9f138b0e537de55933335d580ebd38c2bc53c47
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 13 14:05:13 2014 -0800

    Revert "kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers"
    
    This reverts commit 1ae06819c77cff1ea2833c94f8c093fe8a5c79db.
    
    Tejun writes:
            I'm sorry but can you please revert the whole series?
            get_active() waiting while a node is deactivated has potential
            to lead to deadlock and that deactivate/reactivate interface is
            something fundamentally flawed and that cgroup will have to work
            with the remove_self() like everybody else.  IOW, I think the
            first posting was correct.
    
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 0b7b7cc352eb..ac8693027058 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -43,8 +43,6 @@ enum kernfs_node_flag {
 	KERNFS_HAS_MMAP		= 0x0080,
 	KERNFS_LOCKDEP		= 0x0100,
 	KERNFS_STATIC_NAME	= 0x0200,
-	KERNFS_SUICIDAL		= 0x0400,
-	KERNFS_SUICIDED		= 0x0800,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -241,7 +239,6 @@ void kernfs_reactivate(struct kernfs_node *kn);
 void kernfs_deactivate_self(struct kernfs_node *kn);
 void kernfs_reactivate_self(struct kernfs_node *kn);
 void kernfs_remove(struct kernfs_node *kn);
-bool kernfs_remove_self(struct kernfs_node *kn);
 int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
@@ -299,9 +296,6 @@ kernfs_create_link(struct kernfs_node *parent, const char *name,
 
 static inline void kernfs_remove(struct kernfs_node *kn) { }
 
-static inline bool kernfs_remove_self(struct kernfs_node *kn)
-{ return false; }
-
 static inline int kernfs_remove_by_name_ns(struct kernfs_node *kn,
 					   const char *name, const void *ns)
 { return -ENOSYS; }

commit 1ae06819c77cff1ea2833c94f8c093fe8a5c79db
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:27 2014 -0500

    kernfs, sysfs, driver-core: implement kernfs_remove_self() and its wrappers
    
    Sometimes it's necessary to implement a node which wants to delete
    nodes including itself.  This isn't straightforward because of kernfs
    active reference.  While a file operation is in progress, an active
    reference is held and kernfs_remove() waits for all such references to
    drain before completing.  For a self-deleting node, this is a deadlock
    as kernfs_remove() ends up waiting for an active reference that itself
    is sitting on top of.
    
    This currently is worked around in the sysfs layer using
    sysfs_schedule_callback() which makes such removals asynchronous.
    While it works, it's rather cumbersome and inherently breaks
    synchronicity of the operation - the file operation which triggered
    the operation may complete before the removal is finished (or even
    started) and the removal may fail asynchronously.  If a removal
    operation is immmediately followed by another operation which expects
    the specific name to be available (e.g. removal followed by rename
    onto the same name), there's no way to make the latter operation
    reliable.
    
    The thing is there's no inherent reason for this to be asynchrnous.
    All that's necessary to do this synchronous is a dedicated operation
    which drops its own active ref and deactivates self.  This patch
    implements kernfs_remove_self() and its wrappers in sysfs and driver
    core.  kernfs_remove_self() is to be called from one of the file
    operations, drops the active ref and deactivates using
    __kernfs_deactivate_self(), removes the self node, and restores active
    ref to the dead node using __kernfs_reactivate_self() so that the ref
    is balanced afterwards.  __kernfs_remove() is updated so that it takes
    an early exit if the target node is already fully removed so that the
    active ref restored by kernfs_remove_self() after removal doesn't
    confuse the deactivation path.
    
    This makes implementing self-deleting nodes very easy.  The normal
    removal path doesn't even need to be changed to use
    kernfs_remove_self() for the self-deleting node.  The method can
    invoke kernfs_remove_self() on itself before proceeding the normal
    removal path.  kernfs_remove() invoked on the node by the normal
    deletion path will simply be ignored.
    
    This will replace sysfs_schedule_callback().  A subtle feature of
    sysfs_schedule_callback() is that it collapses multiple invocations -
    even if multiple removals are triggered, the removal callback is run
    only once.  An equivalent effect can be achieved by testing the return
    value of kernfs_remove_self() - only the one which gets %true return
    value should proceed with actual deletion.  All other instances of
    kernfs_remove_self() will wait till the enclosing kernfs operation
    which invoked the winning instance of kernfs_remove_self() finishes
    and then return %false.  This trivially makes all users of
    kernfs_remove_self() automatically show correct synchronous behavior
    even when there are multiple concurrent operations - all "echo 1 >
    delete" instances will finish only after the whole operation is
    completed by one of the instances.
    
    v2: For !CONFIG_SYSFS, dummy version kernfs_remove_self() was missing
        and sysfs_remove_file_self() had incorrect return type.  Fix it.
        Reported by kbuild test bot.
    
    v3: Updated to use __kernfs_{de|re}activate_self().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index ac8693027058..0b7b7cc352eb 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -43,6 +43,8 @@ enum kernfs_node_flag {
 	KERNFS_HAS_MMAP		= 0x0080,
 	KERNFS_LOCKDEP		= 0x0100,
 	KERNFS_STATIC_NAME	= 0x0200,
+	KERNFS_SUICIDAL		= 0x0400,
+	KERNFS_SUICIDED		= 0x0800,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -239,6 +241,7 @@ void kernfs_reactivate(struct kernfs_node *kn);
 void kernfs_deactivate_self(struct kernfs_node *kn);
 void kernfs_reactivate_self(struct kernfs_node *kn);
 void kernfs_remove(struct kernfs_node *kn);
+bool kernfs_remove_self(struct kernfs_node *kn);
 int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
@@ -296,6 +299,9 @@ kernfs_create_link(struct kernfs_node *parent, const char *name,
 
 static inline void kernfs_remove(struct kernfs_node *kn) { }
 
+static inline bool kernfs_remove_self(struct kernfs_node *kn)
+{ return false; }
+
 static inline int kernfs_remove_by_name_ns(struct kernfs_node *kn,
 					   const char *name, const void *ns)
 { return -ENOSYS; }

commit 9f010c2ad5194a4b682e747984477850fabd03be
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:26 2014 -0500

    kernfs: implement kernfs_{de|re}activate[_self]()
    
    This patch implements four functions to manipulate deactivation state
    - deactivate, reactivate and the _self suffixed pair.  A new fields
    kernfs_node->deact_depth is added so that concurrent and nested
    deactivations are handled properly.  kernfs_node->hash is moved so
    that it's paired with the new field so that it doesn't increase the
    size of kernfs_node.
    
    A kernfs user's lock would normally nest inside active ref but during
    removal the user may want to perform kernfs_remove() while holding the
    said lock, which would introduce a reverse locking dependency.  This
    function can be used to break such reverse dependency by allowing
    deactivation step to performed separately outside user's critical
    section.
    
    This will also be used implement kernfs_remove_self().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 9b5a4bb88c64..ac8693027058 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -80,6 +80,8 @@ struct kernfs_elem_attr {
 struct kernfs_node {
 	atomic_t		count;
 	atomic_t		active;
+	int			deact_depth;
+	unsigned int		hash;	/* ns + name hash */
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
@@ -90,7 +92,6 @@ struct kernfs_node {
 	struct rb_node		rb;
 
 	const void		*ns;	/* namespace tag */
-	unsigned int		hash;	/* ns + name hash */
 	union {
 		struct kernfs_elem_dir		dir;
 		struct kernfs_elem_symlink	symlink;
@@ -233,6 +234,10 @@ struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
 				       struct kernfs_node *target);
+void kernfs_deactivate(struct kernfs_node *kn);
+void kernfs_reactivate(struct kernfs_node *kn);
+void kernfs_deactivate_self(struct kernfs_node *kn);
+void kernfs_reactivate_self(struct kernfs_node *kn);
 void kernfs_remove(struct kernfs_node *kn);
 int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);

commit 99177a34110889a8f2c36420c34e3bcc9bfd8a70
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:24 2014 -0500

    kernfs: remove kernfs_addrm_cxt
    
    kernfs_addrm_cxt and the accompanying kernfs_addrm_start/finish() were
    added because there were operations which should be performed outside
    kernfs_mutex after adding and removing kernfs_nodes.  The necessary
    operations were recorded in kernfs_addrm_cxt and performed by
    kernfs_addrm_finish(); however, after the recent changes which
    relocated deactivation and unmapping so that they're performed
    directly during removal, the only operation kernfs_addrm_finish()
    performs is kernfs_put(), which can be moved inside the removal path
    too.
    
    This patch moves the kernfs_put() of the base ref to __kernfs_remove()
    and remove kernfs_addrm_cxt and kernfs_addrm_start/finish().
    
    * kernfs_add_one() is updated to grab and release the parent's active
      ref and kernfs_mutex itself.  kernfs_get/put_active() and
      kernfs_addrm_start/finish() invocations around it are removed from
      all users.
    
    * __kernfs_remove() puts an unlinked node directly instead of chaining
      it to kernfs_addrm_cxt.  Its callers are updated to grab and release
      kernfs_mutex instead of calling kernfs_addrm_start/finish() around
      it.
    
    v2: Updated to fit the v2 restructuring of removal path.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 61bd7ae6b8e0..9b5a4bb88c64 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -89,10 +89,6 @@ struct kernfs_node {
 
 	struct rb_node		rb;
 
-	union {
-		struct kernfs_node	*removed_list;
-	} u;
-
 	const void		*ns;	/* namespace tag */
 	unsigned int		hash;	/* ns + name hash */
 	union {

commit 45a140e587f3d32d8d424ed940dffb61e1739047
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:22 2014 -0500

    kernfs: restructure removal path to fix possible premature return
    
    The recursive nature of kernfs_remove() means that, even if
    kernfs_remove() is not allowed to be called multiple times on the same
    node, there may be race conditions between removal of parent and its
    descendants.  While we can claim that kernfs_remove() shouldn't be
    called on one of the descendants while the removal of an ancestor is
    in progress, such rule is unnecessarily restrictive and very difficult
    to enforce.  It's better to simply allow invoking kernfs_remove() as
    the caller sees fit as long as the caller ensures that the node is
    accessible.
    
    The current behavior in such situations is broken.  Whoever enters
    removal path first takes the node off the hierarchy and then
    deactivates.  Following removers either return as soon as it notices
    that it's not the first one or can't even find the target node as it
    has already been removed from the hierarchy.  In both cases, the
    following removers may finish prematurely while the nodes which should
    be removed and drained are still being processed by the first one.
    
    This patch restructures so that multiple removers, whether through
    recursion or direction invocation, always follow the following rules.
    
    * When there are multiple concurrent removers, only one puts the base
      ref.
    
    * Regardless of which one puts the base ref, all removers are blocked
      until the target node is fully deactivated and removed.
    
    To achieve the above, removal path now first deactivates the subtree,
    drains it and then unlinks one-by-one.  __kernfs_deactivate() is
    called directly from __kernfs_removal() and drops and regrabs
    kernfs_mutex for each descendant to drain active refs.  As this means
    that multiple removers can enter __kernfs_deactivate() for the same
    node, the function is updated so that it can handle multiple
    deactivators of the same node - only one actually deactivates but all
    wait till drain completion.
    
    The restructured removal path guarantees that a removed node gets
    unlinked only after the node is deactivated and drained.  Combined
    with proper multiple deactivator handling, this guarantees that any
    invocation of kernfs_remove() returns only after the node itself and
    all its descendants are deactivated, drained and removed.
    
    v2: Draining separated into a separate loop (used to be in the same
        loop as unlink) and done from __kernfs_deactivate().  This is to
        allow exposing deactivation as a separate interface later.
    
        Root node removal was broken in v1 patch.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 289d4f639ade..61bd7ae6b8e0 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,6 +37,7 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
+	KERNFS_JUST_DEACTIVATED	= 0x0010, /* used to aid lockdep annotation */
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,

commit ae34372eb8408b3d07e870f1939f99007a730d28
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:21 2014 -0500

    kernfs: remove KERNFS_REMOVED
    
    KERNFS_REMOVED is used to mark half-initialized and dying nodes so
    that they don't show up in lookups and deny adding new nodes under or
    renaming it; however, its role overlaps those of deactivation and
    removal from rbtree.
    
    It's necessary to deny addition of new children while removal is in
    progress; however, this role considerably intersects with deactivation
    - KERNFS_REMOVED prevents new children while deactivation prevents new
    file operations.  There's no reason to have them separate making
    things more complex than necessary.
    
    KERNFS_REMOVED is also used to decide whether a node is still visible
    to vfs layer, which is rather redundant as equivalent determination
    can be made by testing whether the node is on its parent's children
    rbtree or not.
    
    This patch removes KERNFS_REMOVED.
    
    * Instead of KERNFS_REMOVED, each node now starts its life
      deactivated.  This means that we now use both atomic_add() and
      atomic_sub() on KN_DEACTIVATED_BIAS, which is INT_MIN.  The compiler
      generates an overflow warnings when negating INT_MIN as the negation
      can't be represented as a positive number.  Nothing is actually
      broken but let's bump BIAS by one to avoid the warnings for archs
      which negates the subtrahend..
    
    * KERNFS_REMOVED tests in add and rename paths are replaced with
      kernfs_get/put_active() of the target nodes.  Due to the way the add
      path is structured now, active ref handling is done in the callers
      of kernfs_add_one().  This will be consolidated up later.
    
    * kernfs_remove_one() is updated to deactivate instead of setting
      KERNFS_REMOVED.  This removes deactivation from kernfs_deactivate(),
      which is now renamed to kernfs_drain().
    
    * kernfs_dop_revalidate() now tests RB_EMPTY_NODE(&kn->rb) instead of
      KERNFS_REMOVED and KERNFS_REMOVED test in kernfs_dir_pos() is
      dropped.  A node which is removed from the children rbtree is not
      included in the iteration in the first place.  This means that a
      node may be visible through vfs a bit longer - it's now also visible
      after deactivation until the actual removal.  This slightly enlarged
      window difference doesn't make any difference to the userland.
    
    * Sanity check on KERNFS_REMOVED in kernfs_put() is replaced with
      checks on the active ref.
    
    * Some comment style updates in the affected area.
    
    v2: Reordered before removal path restructuring.  kernfs_active()
        dropped and kernfs_get/put_active() used instead.  RB_EMPTY_NODE()
        used in the lookup paths.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 42ad32ff22f8..289d4f639ade 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,7 +37,6 @@ enum kernfs_node_type {
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
-	KERNFS_REMOVED		= 0x0010,
 	KERNFS_NS		= 0x0020,
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,

commit a69d001cfc712b96ec9d7ba44d6285702a38dabf
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:20 2014 -0500

    kernfs: remove KERNFS_ACTIVE_REF and add kernfs_lockdep()
    
    There currently are two mechanisms gating active ref lockdep
    annotations - KERNFS_LOCKDEP flag and KERNFS_ACTIVE_REF type mask.
    The former disables lockdep annotations in kernfs_get/put_active()
    while the latter disables all of kernfs_deactivate().
    
    While KERNFS_ACTIVE_REF also behaves as an optimization to skip the
    deactivation step for non-file nodes, the benefit is marginal and it
    needlessly diverges code paths.  Let's drop KERNFS_ACTIVE_REF and use
    KERNFS_LOCKDEP in kernfs_deactivate() too.
    
    While at it, add a test helper kernfs_lockdep() to test KERNFS_LOCKDEP
    flag so that it's more convenient and the related code can be compiled
    out when not enabled.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 232f1a632383..42ad32ff22f8 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -34,7 +34,6 @@ enum kernfs_node_type {
 };
 
 #define KERNFS_TYPE_MASK	0x000f
-#define KERNFS_ACTIVE_REF	KERNFS_FILE
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {

commit ea1c472dfeada211a0100daa7976e8e8e779b858
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 10 08:57:19 2014 -0500

    kernfs: replace kernfs_node->u.completion with kernfs_root->deactivate_waitq
    
    kernfs_node->u.completion is used to notify deactivation completion
    from kernfs_put_active() to kernfs_deactivate().  We now allow
    multiple racing removals of the same node and the current removal
    scheme is no longer correct - kernfs_remove() invocation may return
    before the node is properly deactivated if it races against another
    removal.  The removal path will be restructured to address the issue.
    
    To help such restructure which requires supporting multiple waiters,
    this patch replaces kernfs_node->u.completion with
    kernfs_root->deactivate_waitq.  This makes deactivation event
    notifications share a per-root waitqueue_head; however, the wait path
    is quite cold and this will also allow shaving one pointer off
    kernfs_node.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d2c439db4efa..232f1a632383 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -15,7 +15,7 @@
 #include <linux/lockdep.h>
 #include <linux/rbtree.h>
 #include <linux/atomic.h>
-#include <linux/completion.h>
+#include <linux/wait.h>
 
 struct file;
 struct iattr;
@@ -91,7 +91,6 @@ struct kernfs_node {
 	struct rb_node		rb;
 
 	union {
-		struct completion	*completion;
 		struct kernfs_node	*removed_list;
 	} u;
 
@@ -132,6 +131,7 @@ struct kernfs_root {
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
 	struct kernfs_dir_ops	*dir_ops;
+	wait_queue_head_t	deactivate_waitq;
 };
 
 struct kernfs_open_file {

commit 80b9bbefc345079bddc4959de016ba4074b0c8d6
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:03:00 2013 -0500

    kernfs: add kernfs_dir_ops
    
    Add support for mkdir(2), rmdir(2) and rename(2) syscalls.  This is
    implemented through optional kernfs_dir_ops callback table which can
    be specified on kernfs_create_root().  An implemented callback is
    invoked when the matching syscall is invoked.
    
    As kernfs keep dcache syncs with internal representation and
    revalidates dentries on each access, the implementation of these
    methods is extremely simple.  Each just discovers the relevant
    kernfs_node(s) and invokes the requested callback which is allowed to
    do any kernfs operations and the end result doesn't necessarily have
    to match the expected semantics of the syscall.
    
    This will be used to convert cgroup to use kernfs instead of its own
    filesystem implementation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 321ed84ad4ce..d2c439db4efa 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -111,12 +111,27 @@ struct kernfs_node {
 	struct kernfs_iattrs	*iattr;
 };
 
+/*
+ * kernfs_dir_ops may be specified on kernfs_create_root() to support
+ * directory manipulation syscalls.  These optional callbacks are invoked
+ * on the matching syscalls and can perform any kernfs operations which
+ * don't necessarily have to be the exact operation requested.
+ */
+struct kernfs_dir_ops {
+	int (*mkdir)(struct kernfs_node *parent, const char *name,
+		     umode_t mode);
+	int (*rmdir)(struct kernfs_node *kn);
+	int (*rename)(struct kernfs_node *kn, struct kernfs_node *new_parent,
+		      const char *new_name);
+};
+
 struct kernfs_root {
 	/* published fields */
 	struct kernfs_node	*kn;
 
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
+	struct kernfs_dir_ops	*dir_ops;
 };
 
 struct kernfs_open_file {
@@ -206,7 +221,8 @@ struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
 void kernfs_get(struct kernfs_node *kn);
 void kernfs_put(struct kernfs_node *kn);
 
-struct kernfs_root *kernfs_create_root(void *priv);
+struct kernfs_root *kernfs_create_root(struct kernfs_dir_ops *kdops,
+				       void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
 
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
@@ -255,7 +271,8 @@ kernfs_find_and_get_ns(struct kernfs_node *parent, const char *name,
 static inline void kernfs_get(struct kernfs_node *kn) { }
 static inline void kernfs_put(struct kernfs_node *kn) { }
 
-static inline struct kernfs_root *kernfs_create_root(void *priv)
+static inline struct kernfs_root *
+kernfs_create_root(struct kernfs_dir_ops *kdops, void *priv)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_destroy_root(struct kernfs_root *root) { }

commit 2063d608f5110d120db60e896ec2c70c95bb7978
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:02:57 2013 -0500

    kernfs: mark static names with KERNFS_STATIC_NAME
    
    Because sysfs used struct attribute which are supposed to stay
    constant, sysfs didn't copy names when creating regular files.  The
    specified string for name was supposed to stay constant.  Such
    distinction isn't inherent for kernfs.  kernfs_create_file[_ns]()
    should be able to take the same @name as kernfs_create_dir[_ns]()
    
    As there can be huge number of sysfs attributes, we still want to be
    able to use static names for sysfs attributes.  This patch renames
    kernfs_create_file_ns_key() to __kernfs_create_file() and adds
    @name_is_static parameter so that the caller can explicitly indicate
    that @name can be used without copying.  kernfs is updated to use
    KERNFS_STATIC_NAME to distinguish static and copied names.
    
    This patch doesn't introduce any behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 0ca2aedfd31b..321ed84ad4ce 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -34,7 +34,6 @@ enum kernfs_node_type {
 };
 
 #define KERNFS_TYPE_MASK	0x000f
-#define KERNFS_COPY_NAME	(KERNFS_DIR | KERNFS_LINK)
 #define KERNFS_ACTIVE_REF	KERNFS_FILE
 #define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
@@ -44,6 +43,7 @@ enum kernfs_node_flag {
 	KERNFS_HAS_SEQ_SHOW	= 0x0040,
 	KERNFS_HAS_MMAP		= 0x0080,
 	KERNFS_LOCKDEP		= 0x0100,
+	KERNFS_STATIC_NAME	= 0x0200,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -212,12 +212,13 @@ void kernfs_destroy_root(struct kernfs_root *root);
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
 					 const char *name, umode_t mode,
 					 void *priv, const void *ns);
-struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
-					      const char *name,
-					      umode_t mode, loff_t size,
-					      const struct kernfs_ops *ops,
-					      void *priv, const void *ns,
-					      struct lock_class_key *key);
+struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
+					 const char *name,
+					 umode_t mode, loff_t size,
+					 const struct kernfs_ops *ops,
+					 void *priv, const void *ns,
+					 bool name_is_static,
+					 struct lock_class_key *key);
 struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
 				       const char *name,
 				       struct kernfs_node *target);
@@ -265,10 +266,10 @@ kernfs_create_dir_ns(struct kernfs_node *parent, const char *name,
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct kernfs_node *
-kernfs_create_file_ns_key(struct kernfs_node *parent, const char *name,
-			  umode_t mode, loff_t size,
-			  const struct kernfs_ops *ops, void *priv,
-			  const void *ns, struct lock_class_key *key)
+__kernfs_create_file(struct kernfs_node *parent, const char *name,
+		     umode_t mode, loff_t size, const struct kernfs_ops *ops,
+		     void *priv, const void *ns, bool name_is_static,
+		     struct lock_class_key *key)
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct kernfs_node *
@@ -330,8 +331,8 @@ kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	key = (struct lock_class_key *)&ops->lockdep_key;
 #endif
-	return kernfs_create_file_ns_key(parent, name, mode, size, ops, priv,
-					 ns, key);
+	return __kernfs_create_file(parent, name, mode, size, ops, priv, ns,
+				    false, key);
 }
 
 static inline struct kernfs_node *

commit bb8b9d095c5c56cce99576cfef0cf9b989f7120d
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 16:02:55 2013 -0500

    kernfs: add @mode to kernfs_create_dir[_ns]()
    
    sysfs assumed 0755 for all newly created directories and kernfs
    inherited it.  This assumption is unnecessarily restrictive and
    inconsistent with kernfs_create_file[_ns]().  This patch adds @mode
    parameter to kernfs_create_dir[_ns]() and update uses in sysfs
    accordingly.  Among others, this will be useful for implementations of
    the planned ->mkdir() method.
    
    This patch doesn't introduce any behavior differences.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index e9c4e3a03960..0ca2aedfd31b 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -210,8 +210,8 @@ struct kernfs_root *kernfs_create_root(void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
 
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
-					 const char *name, void *priv,
-					 const void *ns);
+					 const char *name, umode_t mode,
+					 void *priv, const void *ns);
 struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
 					      const char *name,
 					      umode_t mode, loff_t size,
@@ -260,8 +260,8 @@ static inline struct kernfs_root *kernfs_create_root(void *priv)
 static inline void kernfs_destroy_root(struct kernfs_root *root) { }
 
 static inline struct kernfs_node *
-kernfs_create_dir_ns(struct kernfs_node *parent, const char *name, void *priv,
-		     const void *ns)
+kernfs_create_dir_ns(struct kernfs_node *parent, const char *name,
+		     umode_t mode, void *priv, const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct kernfs_node *
@@ -314,9 +314,10 @@ kernfs_find_and_get(struct kernfs_node *kn, const char *name)
 }
 
 static inline struct kernfs_node *
-kernfs_create_dir(struct kernfs_node *parent, const char *name, void *priv)
+kernfs_create_dir(struct kernfs_node *parent, const char *name, umode_t mode,
+		  void *priv)
 {
-	return kernfs_create_dir_ns(parent, name, priv, NULL);
+	return kernfs_create_dir_ns(parent, name, mode, priv, NULL);
 }
 
 static inline struct kernfs_node *

commit df23fc39bce03bb26e63bea57fc5f5bf6882d74b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:56 2013 -0500

    kernfs: s/sysfs/kernfs/ in constants
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/SYSFS_DIR/KERNFS_DIR/
    * s/SYSFS_KOBJ_ATTR/KERNFS_FILE/
    * s/SYSFS_KOBJ_LINK/KERNFS_LINK/
    * s/SYSFS_{TYPE_FLAGS}/KERNFS_{TYPE_FLAGS}/
    * s/SYSFS_FLAG_{FLAG}/KERNFS_{FLAG}/
    * s/sysfs_type()/kernfs_type()/
    * s/SD_DEACTIVATED_BIAS/KN_DEACTIVATED_BIAS/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 757647c4cb3b..e9c4e3a03960 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -28,22 +28,22 @@ struct kernfs_open_node;
 struct kernfs_iattrs;
 
 enum kernfs_node_type {
-	SYSFS_DIR		= 0x0001,
-	SYSFS_KOBJ_ATTR		= 0x0002,
-	SYSFS_KOBJ_LINK		= 0x0004,
+	KERNFS_DIR		= 0x0001,
+	KERNFS_FILE		= 0x0002,
+	KERNFS_LINK		= 0x0004,
 };
 
-#define SYSFS_TYPE_MASK		0x000f
-#define SYSFS_COPY_NAME		(SYSFS_DIR | SYSFS_KOBJ_LINK)
-#define SYSFS_ACTIVE_REF	SYSFS_KOBJ_ATTR
-#define SYSFS_FLAG_MASK		~SYSFS_TYPE_MASK
+#define KERNFS_TYPE_MASK	0x000f
+#define KERNFS_COPY_NAME	(KERNFS_DIR | KERNFS_LINK)
+#define KERNFS_ACTIVE_REF	KERNFS_FILE
+#define KERNFS_FLAG_MASK	~KERNFS_TYPE_MASK
 
 enum kernfs_node_flag {
-	SYSFS_FLAG_REMOVED	= 0x0010,
-	SYSFS_FLAG_NS		= 0x0020,
-	SYSFS_FLAG_HAS_SEQ_SHOW	= 0x0040,
-	SYSFS_FLAG_HAS_MMAP	= 0x0080,
-	SYSFS_FLAG_LOCKDEP	= 0x0100,
+	KERNFS_REMOVED		= 0x0010,
+	KERNFS_NS		= 0x0020,
+	KERNFS_HAS_SEQ_SHOW	= 0x0040,
+	KERNFS_HAS_MMAP		= 0x0080,
+	KERNFS_LOCKDEP		= 0x0100,
 };
 
 /* type-specific structures for kernfs_node union members */
@@ -170,9 +170,9 @@ struct kernfs_ops {
 
 #ifdef CONFIG_SYSFS
 
-static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
+static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 {
-	return kn->flags & SYSFS_TYPE_MASK;
+	return kn->flags & KERNFS_TYPE_MASK;
 }
 
 /**
@@ -185,9 +185,9 @@ static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
  */
 static inline void kernfs_enable_ns(struct kernfs_node *kn)
 {
-	WARN_ON_ONCE(sysfs_type(kn) != SYSFS_DIR);
+	WARN_ON_ONCE(kernfs_type(kn) != KERNFS_DIR);
 	WARN_ON_ONCE(!RB_EMPTY_ROOT(&kn->dir.children));
-	kn->flags |= SYSFS_FLAG_NS;
+	kn->flags |= KERNFS_NS;
 }
 
 /**
@@ -198,7 +198,7 @@ static inline void kernfs_enable_ns(struct kernfs_node *kn)
  */
 static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 {
-	return kn->flags & SYSFS_FLAG_NS;
+	return kn->flags & KERNFS_NS;
 }
 
 struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
@@ -238,7 +238,7 @@ void kernfs_init(void);
 
 #else	/* CONFIG_SYSFS */
 
-static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
+static inline enum kernfs_node_type kernfs_type(struct kernfs_node *kn)
 { return 0; }	/* whatever */
 
 static inline void kernfs_enable_ns(struct kernfs_node *kn) { }

commit c525aaddc366df23eb095d58a2bdf11cce62a98b
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:55 2013 -0500

    kernfs: s/sysfs/kernfs/ in various data structures
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_open_dirent/kernfs_open_node/
    * s/sysfs_open_file/kernfs_open_file/
    * s/sysfs_inode_attrs/kernfs_iattrs/
    * s/sysfs_addrm_cxt/kernfs_addrm_cxt/
    * s/sysfs_super_info/kernfs_super_info/
    * s/sysfs_info()/kernfs_info()/
    * s/sysfs_open_dirent_lock/kernfs_open_node_lock/
    * s/sysfs_open_file_mutex/kernfs_open_file_mutex/
    * s/sysfs_of()/kernfs_of()/
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 092469f60e3e..757647c4cb3b 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -24,8 +24,8 @@ struct vm_area_struct;
 struct super_block;
 struct file_system_type;
 
-struct sysfs_open_dirent;
-struct sysfs_inode_attrs;
+struct kernfs_open_node;
+struct kernfs_iattrs;
 
 enum kernfs_node_type {
 	SYSFS_DIR		= 0x0001,
@@ -65,7 +65,7 @@ struct kernfs_elem_symlink {
 
 struct kernfs_elem_attr {
 	const struct kernfs_ops	*ops;
-	struct sysfs_open_dirent *open;
+	struct kernfs_open_node	*open;
 	loff_t			size;
 };
 
@@ -108,7 +108,7 @@ struct kernfs_node {
 	unsigned short		flags;
 	umode_t			mode;
 	unsigned int		ino;
-	struct sysfs_inode_attrs *iattr;
+	struct kernfs_iattrs	*iattr;
 };
 
 struct kernfs_root {
@@ -119,7 +119,7 @@ struct kernfs_root {
 	struct ida		ino_ida;
 };
 
-struct sysfs_open_file {
+struct kernfs_open_file {
 	/* published fields */
 	struct kernfs_node	*kn;
 	struct file		*file;
@@ -140,7 +140,7 @@ struct kernfs_ops {
 	 * If seq_show() is present, seq_file path is active.  Other seq
 	 * operations are optional and if not implemented, the behavior is
 	 * equivalent to single_open().  @sf->private points to the
-	 * associated sysfs_open_file.
+	 * associated kernfs_open_file.
 	 *
 	 * read() is bounced through kernel buffer and a read larger than
 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
@@ -151,17 +151,17 @@ struct kernfs_ops {
 	void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
 	void (*seq_stop)(struct seq_file *sf, void *v);
 
-	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+	ssize_t (*read)(struct kernfs_open_file *of, char *buf, size_t bytes,
 			loff_t off);
 
 	/*
 	 * write() is bounced through kernel buffer and a write larger than
 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
 	 */
-	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+	ssize_t (*write)(struct kernfs_open_file *of, char *buf, size_t bytes,
 			 loff_t off);
 
-	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+	int (*mmap)(struct kernfs_open_file *of, struct vm_area_struct *vma);
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lock_class_key	lockdep_key;

commit adc5e8b58f4886d45f79f4ff41a09001a76a6b12
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:54 2013 -0500

    kernfs: drop s_ prefix from kernfs_node members
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    s_ prefix for kernfs members is used inconsistently and a misnomer
    now.  It's not like kernfs_node is used widely across the kernel
    making the ability to grep for the members particularly useful.  Let's
    just drop the prefix.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 195d1c6a8b0c..092469f60e3e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -49,7 +49,7 @@ enum kernfs_node_flag {
 /* type-specific structures for kernfs_node union members */
 struct kernfs_elem_dir {
 	unsigned long		subdirs;
-	/* children rbtree starts here and goes through kn->s_rb */
+	/* children rbtree starts here and goes through kn->rb */
 	struct rb_root		children;
 
 	/*
@@ -79,36 +79,36 @@ struct kernfs_elem_attr {
  * active reference.
  */
 struct kernfs_node {
-	atomic_t		s_count;
-	atomic_t		s_active;
+	atomic_t		count;
+	atomic_t		active;
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
 	/* the following two fields are published */
-	struct kernfs_node	*s_parent;
-	const char		*s_name;
+	struct kernfs_node	*parent;
+	const char		*name;
 
-	struct rb_node		s_rb;
+	struct rb_node		rb;
 
 	union {
 		struct completion	*completion;
 		struct kernfs_node	*removed_list;
 	} u;
 
-	const void		*s_ns; /* namespace tag */
-	unsigned int		s_hash; /* ns + name hash */
+	const void		*ns;	/* namespace tag */
+	unsigned int		hash;	/* ns + name hash */
 	union {
-		struct kernfs_elem_dir		s_dir;
-		struct kernfs_elem_symlink	s_symlink;
-		struct kernfs_elem_attr		s_attr;
+		struct kernfs_elem_dir		dir;
+		struct kernfs_elem_symlink	symlink;
+		struct kernfs_elem_attr		attr;
 	};
 
 	void			*priv;
 
-	unsigned short		s_flags;
-	umode_t			s_mode;
-	unsigned int		s_ino;
-	struct sysfs_inode_attrs *s_iattr;
+	unsigned short		flags;
+	umode_t			mode;
+	unsigned int		ino;
+	struct sysfs_inode_attrs *iattr;
 };
 
 struct kernfs_root {
@@ -172,7 +172,7 @@ struct kernfs_ops {
 
 static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
 {
-	return kn->s_flags & SYSFS_TYPE_MASK;
+	return kn->flags & SYSFS_TYPE_MASK;
 }
 
 /**
@@ -186,8 +186,8 @@ static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
 static inline void kernfs_enable_ns(struct kernfs_node *kn)
 {
 	WARN_ON_ONCE(sysfs_type(kn) != SYSFS_DIR);
-	WARN_ON_ONCE(!RB_EMPTY_ROOT(&kn->s_dir.children));
-	kn->s_flags |= SYSFS_FLAG_NS;
+	WARN_ON_ONCE(!RB_EMPTY_ROOT(&kn->dir.children));
+	kn->flags |= SYSFS_FLAG_NS;
 }
 
 /**
@@ -198,7 +198,7 @@ static inline void kernfs_enable_ns(struct kernfs_node *kn)
  */
 static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 {
-	return kn->s_flags & SYSFS_FLAG_NS;
+	return kn->flags & SYSFS_FLAG_NS;
 }
 
 struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,

commit 324a56e16e44baecac3ca799fd216154145c14bf
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 11 14:11:53 2013 -0500

    kernfs: s/sysfs_dirent/kernfs_node/ and rename its friends accordingly
    
    kernfs has just been separated out from sysfs and we're already in
    full conflict mode.  Nothing can make the situation any worse.  Let's
    take the chance to name things properly.
    
    This patch performs the following renames.
    
    * s/sysfs_elem_dir/kernfs_elem_dir/
    * s/sysfs_elem_symlink/kernfs_elem_symlink/
    * s/sysfs_elem_attr/kernfs_elem_file/
    * s/sysfs_dirent/kernfs_node/
    * s/sd/kn/ in kernfs proper
    * s/parent_sd/parent/
    * s/target_sd/target/
    * s/dir_sd/parent/
    * s/to_sysfs_dirent()/rb_to_kn()/
    * misc renames of local vars when they conflict with the above
    
    Because md, mic and gpio dig into sysfs details, this patch ends up
    modifying them.  All are sysfs_dirent renames and trivial.  While we
    can avoid these by introducing a dummy wrapping struct sysfs_dirent
    around kernfs_node, given the limited usage outside kernfs and sysfs
    proper, I don't think such workaround is called for.
    
    This patch is strictly rename only and doesn't introduce any
    functional difference.
    
    - mic / gpio renames were missing.  Spotted by kbuild test robot.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d65541308419..195d1c6a8b0c 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -46,61 +46,61 @@ enum kernfs_node_flag {
 	SYSFS_FLAG_LOCKDEP	= 0x0100,
 };
 
-/* type-specific structures for sysfs_dirent->s_* union members */
-struct sysfs_elem_dir {
+/* type-specific structures for kernfs_node union members */
+struct kernfs_elem_dir {
 	unsigned long		subdirs;
-	/* children rbtree starts here and goes through sd->s_rb */
+	/* children rbtree starts here and goes through kn->s_rb */
 	struct rb_root		children;
 
 	/*
 	 * The kernfs hierarchy this directory belongs to.  This fits
-	 * better directly in sysfs_dirent but is here to save space.
+	 * better directly in kernfs_node but is here to save space.
 	 */
 	struct kernfs_root	*root;
 };
 
-struct sysfs_elem_symlink {
-	struct sysfs_dirent	*target_sd;
+struct kernfs_elem_symlink {
+	struct kernfs_node	*target_kn;
 };
 
-struct sysfs_elem_attr {
+struct kernfs_elem_attr {
 	const struct kernfs_ops	*ops;
 	struct sysfs_open_dirent *open;
 	loff_t			size;
 };
 
 /*
- * sysfs_dirent - the building block of sysfs hierarchy.  Each and every
- * sysfs node is represented by single sysfs_dirent.  Most fields are
+ * kernfs_node - the building block of kernfs hierarchy.  Each and every
+ * kernfs node is represented by single kernfs_node.  Most fields are
  * private to kernfs and shouldn't be accessed directly by kernfs users.
  *
- * As long as s_count reference is held, the sysfs_dirent itself is
- * accessible.  Dereferencing s_elem or any other outer entity
- * requires s_active reference.
+ * As long as s_count reference is held, the kernfs_node itself is
+ * accessible.  Dereferencing elem or any other outer entity requires
+ * active reference.
  */
-struct sysfs_dirent {
+struct kernfs_node {
 	atomic_t		s_count;
 	atomic_t		s_active;
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 	struct lockdep_map	dep_map;
 #endif
 	/* the following two fields are published */
-	struct sysfs_dirent	*s_parent;
+	struct kernfs_node	*s_parent;
 	const char		*s_name;
 
 	struct rb_node		s_rb;
 
 	union {
 		struct completion	*completion;
-		struct sysfs_dirent	*removed_list;
+		struct kernfs_node	*removed_list;
 	} u;
 
 	const void		*s_ns; /* namespace tag */
 	unsigned int		s_hash; /* ns + name hash */
 	union {
-		struct sysfs_elem_dir		s_dir;
-		struct sysfs_elem_symlink	s_symlink;
-		struct sysfs_elem_attr		s_attr;
+		struct kernfs_elem_dir		s_dir;
+		struct kernfs_elem_symlink	s_symlink;
+		struct kernfs_elem_attr		s_attr;
 	};
 
 	void			*priv;
@@ -113,7 +113,7 @@ struct sysfs_dirent {
 
 struct kernfs_root {
 	/* published fields */
-	struct sysfs_dirent	*sd;
+	struct kernfs_node	*kn;
 
 	/* private fields, do not use outside kernfs proper */
 	struct ida		ino_ida;
@@ -121,7 +121,7 @@ struct kernfs_root {
 
 struct sysfs_open_file {
 	/* published fields */
-	struct sysfs_dirent	*sd;
+	struct kernfs_node	*kn;
 	struct file		*file;
 
 	/* private fields, do not use outside kernfs proper */
@@ -170,64 +170,64 @@ struct kernfs_ops {
 
 #ifdef CONFIG_SYSFS
 
-static inline enum kernfs_node_type sysfs_type(struct sysfs_dirent *sd)
+static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
 {
-	return sd->s_flags & SYSFS_TYPE_MASK;
+	return kn->s_flags & SYSFS_TYPE_MASK;
 }
 
 /**
  * kernfs_enable_ns - enable namespace under a directory
- * @sd: directory of interest, should be empty
+ * @kn: directory of interest, should be empty
  *
- * This is to be called right after @sd is created to enable namespace
- * under it.  All children of @sd must have non-NULL namespace tags and
+ * This is to be called right after @kn is created to enable namespace
+ * under it.  All children of @kn must have non-NULL namespace tags and
  * only the ones which match the super_block's tag will be visible.
  */
-static inline void kernfs_enable_ns(struct sysfs_dirent *sd)
+static inline void kernfs_enable_ns(struct kernfs_node *kn)
 {
-	WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
-	WARN_ON_ONCE(!RB_EMPTY_ROOT(&sd->s_dir.children));
-	sd->s_flags |= SYSFS_FLAG_NS;
+	WARN_ON_ONCE(sysfs_type(kn) != SYSFS_DIR);
+	WARN_ON_ONCE(!RB_EMPTY_ROOT(&kn->s_dir.children));
+	kn->s_flags |= SYSFS_FLAG_NS;
 }
 
 /**
  * kernfs_ns_enabled - test whether namespace is enabled
- * @sd: the node to test
+ * @kn: the node to test
  *
  * Test whether namespace filtering is enabled for the children of @ns.
  */
-static inline bool kernfs_ns_enabled(struct sysfs_dirent *sd)
+static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 {
-	return sd->s_flags & SYSFS_FLAG_NS;
+	return kn->s_flags & SYSFS_FLAG_NS;
 }
 
-struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
-					    const char *name, const void *ns);
-void kernfs_get(struct sysfs_dirent *sd);
-void kernfs_put(struct sysfs_dirent *sd);
+struct kernfs_node *kernfs_find_and_get_ns(struct kernfs_node *parent,
+					   const char *name, const void *ns);
+void kernfs_get(struct kernfs_node *kn);
+void kernfs_put(struct kernfs_node *kn);
 
 struct kernfs_root *kernfs_create_root(void *priv);
 void kernfs_destroy_root(struct kernfs_root *root);
 
-struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
-					  const char *name, void *priv,
-					  const void *ns);
-struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
-					       const char *name,
-					       umode_t mode, loff_t size,
-					       const struct kernfs_ops *ops,
-					       void *priv, const void *ns,
-					       struct lock_class_key *key);
-struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
-					const char *name,
-					struct sysfs_dirent *target);
-void kernfs_remove(struct sysfs_dirent *sd);
-int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
+					 const char *name, void *priv,
+					 const void *ns);
+struct kernfs_node *kernfs_create_file_ns_key(struct kernfs_node *parent,
+					      const char *name,
+					      umode_t mode, loff_t size,
+					      const struct kernfs_ops *ops,
+					      void *priv, const void *ns,
+					      struct lock_class_key *key);
+struct kernfs_node *kernfs_create_link(struct kernfs_node *parent,
+				       const char *name,
+				       struct kernfs_node *target);
+void kernfs_remove(struct kernfs_node *kn);
+int kernfs_remove_by_name_ns(struct kernfs_node *parent, const char *name,
 			     const void *ns);
-int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,
 		     const char *new_name, const void *new_ns);
-int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
-void kernfs_notify(struct sysfs_dirent *sd);
+int kernfs_setattr(struct kernfs_node *kn, const struct iattr *iattr);
+void kernfs_notify(struct kernfs_node *kn);
 
 const void *kernfs_super_ns(struct super_block *sb);
 struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
@@ -238,60 +238,60 @@ void kernfs_init(void);
 
 #else	/* CONFIG_SYSFS */
 
-static inline enum kernfs_node_type sysfs_type(struct sysfs_dirent *sd)
+static inline enum kernfs_node_type sysfs_type(struct kernfs_node *kn)
 { return 0; }	/* whatever */
 
-static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+static inline void kernfs_enable_ns(struct kernfs_node *kn) { }
 
-static inline bool kernfs_ns_enabled(struct sysfs_dirent *sd)
+static inline bool kernfs_ns_enabled(struct kernfs_node *kn)
 { return false; }
 
-static inline struct sysfs_dirent *
-kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
+static inline struct kernfs_node *
+kernfs_find_and_get_ns(struct kernfs_node *parent, const char *name,
 		       const void *ns)
 { return NULL; }
 
-static inline void kernfs_get(struct sysfs_dirent *sd) { }
-static inline void kernfs_put(struct sysfs_dirent *sd) { }
+static inline void kernfs_get(struct kernfs_node *kn) { }
+static inline void kernfs_put(struct kernfs_node *kn) { }
 
 static inline struct kernfs_root *kernfs_create_root(void *priv)
 { return ERR_PTR(-ENOSYS); }
 
 static inline void kernfs_destroy_root(struct kernfs_root *root) { }
 
-static inline struct sysfs_dirent *
-kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+static inline struct kernfs_node *
+kernfs_create_dir_ns(struct kernfs_node *parent, const char *name, void *priv,
 		     const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
-static inline struct sysfs_dirent *
-kernfs_create_file_ns_key(struct sysfs_dirent *parent, const char *name,
+static inline struct kernfs_node *
+kernfs_create_file_ns_key(struct kernfs_node *parent, const char *name,
 			  umode_t mode, loff_t size,
 			  const struct kernfs_ops *ops, void *priv,
 			  const void *ns, struct lock_class_key *key)
 { return ERR_PTR(-ENOSYS); }
 
-static inline struct sysfs_dirent *
-kernfs_create_link(struct sysfs_dirent *parent, const char *name,
-		   struct sysfs_dirent *target)
+static inline struct kernfs_node *
+kernfs_create_link(struct kernfs_node *parent, const char *name,
+		   struct kernfs_node *target)
 { return ERR_PTR(-ENOSYS); }
 
-static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+static inline void kernfs_remove(struct kernfs_node *kn) { }
 
-static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+static inline int kernfs_remove_by_name_ns(struct kernfs_node *kn,
 					   const char *name, const void *ns)
 { return -ENOSYS; }
 
-static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
-				   struct sysfs_dirent *new_parent,
+static inline int kernfs_rename_ns(struct kernfs_node *kn,
+				   struct kernfs_node *new_parent,
 				   const char *new_name, const void *new_ns)
 { return -ENOSYS; }
 
-static inline int kernfs_setattr(struct sysfs_dirent *sd,
+static inline int kernfs_setattr(struct kernfs_node *kn,
 				 const struct iattr *iattr)
 { return -ENOSYS; }
 
-static inline void kernfs_notify(struct sysfs_dirent *sd) { }
+static inline void kernfs_notify(struct kernfs_node *kn) { }
 
 static inline const void *kernfs_super_ns(struct super_block *sb)
 { return NULL; }
@@ -307,20 +307,20 @@ static inline void kernfs_init(void) { }
 
 #endif	/* CONFIG_SYSFS */
 
-static inline struct sysfs_dirent *
-kernfs_find_and_get(struct sysfs_dirent *sd, const char *name)
+static inline struct kernfs_node *
+kernfs_find_and_get(struct kernfs_node *kn, const char *name)
 {
-	return kernfs_find_and_get_ns(sd, name, NULL);
+	return kernfs_find_and_get_ns(kn, name, NULL);
 }
 
-static inline struct sysfs_dirent *
-kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+static inline struct kernfs_node *
+kernfs_create_dir(struct kernfs_node *parent, const char *name, void *priv)
 {
 	return kernfs_create_dir_ns(parent, name, priv, NULL);
 }
 
-static inline struct sysfs_dirent *
-kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+static inline struct kernfs_node *
+kernfs_create_file_ns(struct kernfs_node *parent, const char *name,
 		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
 		      void *priv, const void *ns)
 {
@@ -333,14 +333,14 @@ kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
 					 ns, key);
 }
 
-static inline struct sysfs_dirent *
-kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
+static inline struct kernfs_node *
+kernfs_create_file(struct kernfs_node *parent, const char *name, umode_t mode,
 		   loff_t size, const struct kernfs_ops *ops, void *priv)
 {
 	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
 }
 
-static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+static inline int kernfs_remove_by_name(struct kernfs_node *parent,
 					const char *name)
 {
 	return kernfs_remove_by_name_ns(parent, name, NULL);

commit ac9bba031001704a2339713cc12148857eccc5e5
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Nov 29 17:19:09 2013 -0500

    sysfs, kernfs: implement kernfs_ns_enabled()
    
    fs/sysfs/symlink.c::sysfs_delete_link() tests @sd->s_flags for
    SYSFS_FLAG_NS.  Let's add kernfs_ns_enabled() so that sysfs doesn't
    have to test sysfs_dirent flag directly.  This makes things tidier for
    kernfs proper too.
    
    This is purely cosmetic.
    
    v2: To avoid possible NULL deref, use noop dummy implementation which
        always returns false when !CONFIG_SYSFS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index faaf4f29e33d..d65541308419 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -190,6 +190,17 @@ static inline void kernfs_enable_ns(struct sysfs_dirent *sd)
 	sd->s_flags |= SYSFS_FLAG_NS;
 }
 
+/**
+ * kernfs_ns_enabled - test whether namespace is enabled
+ * @sd: the node to test
+ *
+ * Test whether namespace filtering is enabled for the children of @ns.
+ */
+static inline bool kernfs_ns_enabled(struct sysfs_dirent *sd)
+{
+	return sd->s_flags & SYSFS_FLAG_NS;
+}
+
 struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
 					    const char *name, const void *ns);
 void kernfs_get(struct sysfs_dirent *sd);
@@ -232,6 +243,9 @@ static inline enum kernfs_node_type sysfs_type(struct sysfs_dirent *sd)
 
 static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
 
+static inline bool kernfs_ns_enabled(struct sysfs_dirent *sd)
+{ return false; }
+
 static inline struct sysfs_dirent *
 kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
 		       const void *ns)

commit cf9e5a73aaff0204801dd19cb4bd91d32f32026a
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Nov 29 17:18:32 2013 -0500

    sysfs, kernfs: make sysfs_dirent definition public
    
    sysfs_dirent includes some information which should be available to
    kernfs users - the type, flags, name and parent pointer.  This patch
    moves sysfs_dirent definition from kernfs/kernfs-internal.h to
    include/linux/kernfs.h so that kernfs users can access them.
    
    The type part of flags is exported as enum kernfs_node_type, the flags
    kernfs_node_flag, sysfs_type() and kernfs_enable_ns() are moved to
    include/linux/kernfs.h and the former is updated to return the enum
    type.  sysfs_dirent->s_parent and ->s_name are marked explicitly as
    public.
    
    This patch doesn't introduce any functional changes.
    
    v2: Flags exported too and kernfs_enable_ns() definition moved.
    
    v3: While moving kernfs_enable_ns() to include/linux/kernfs.h, v1 and
        v2 put the definition outside CONFIG_SYSFS replacing the dummy
        implementation with the actual implementation too.  Unfortunately,
        this can lead to oops when !CONFIG_SYSFS because
        kernfs_enable_ns() may be called on a NULL @sd and now tries to
        dereference @sd instead of not doing anything.  This issue was
        reported by Yuanhan Liu.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 75fcbe5c9d65..faaf4f29e33d 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -13,6 +13,9 @@
 #include <linux/mutex.h>
 #include <linux/idr.h>
 #include <linux/lockdep.h>
+#include <linux/rbtree.h>
+#include <linux/atomic.h>
+#include <linux/completion.h>
 
 struct file;
 struct iattr;
@@ -21,7 +24,92 @@ struct vm_area_struct;
 struct super_block;
 struct file_system_type;
 
-struct sysfs_dirent;
+struct sysfs_open_dirent;
+struct sysfs_inode_attrs;
+
+enum kernfs_node_type {
+	SYSFS_DIR		= 0x0001,
+	SYSFS_KOBJ_ATTR		= 0x0002,
+	SYSFS_KOBJ_LINK		= 0x0004,
+};
+
+#define SYSFS_TYPE_MASK		0x000f
+#define SYSFS_COPY_NAME		(SYSFS_DIR | SYSFS_KOBJ_LINK)
+#define SYSFS_ACTIVE_REF	SYSFS_KOBJ_ATTR
+#define SYSFS_FLAG_MASK		~SYSFS_TYPE_MASK
+
+enum kernfs_node_flag {
+	SYSFS_FLAG_REMOVED	= 0x0010,
+	SYSFS_FLAG_NS		= 0x0020,
+	SYSFS_FLAG_HAS_SEQ_SHOW	= 0x0040,
+	SYSFS_FLAG_HAS_MMAP	= 0x0080,
+	SYSFS_FLAG_LOCKDEP	= 0x0100,
+};
+
+/* type-specific structures for sysfs_dirent->s_* union members */
+struct sysfs_elem_dir {
+	unsigned long		subdirs;
+	/* children rbtree starts here and goes through sd->s_rb */
+	struct rb_root		children;
+
+	/*
+	 * The kernfs hierarchy this directory belongs to.  This fits
+	 * better directly in sysfs_dirent but is here to save space.
+	 */
+	struct kernfs_root	*root;
+};
+
+struct sysfs_elem_symlink {
+	struct sysfs_dirent	*target_sd;
+};
+
+struct sysfs_elem_attr {
+	const struct kernfs_ops	*ops;
+	struct sysfs_open_dirent *open;
+	loff_t			size;
+};
+
+/*
+ * sysfs_dirent - the building block of sysfs hierarchy.  Each and every
+ * sysfs node is represented by single sysfs_dirent.  Most fields are
+ * private to kernfs and shouldn't be accessed directly by kernfs users.
+ *
+ * As long as s_count reference is held, the sysfs_dirent itself is
+ * accessible.  Dereferencing s_elem or any other outer entity
+ * requires s_active reference.
+ */
+struct sysfs_dirent {
+	atomic_t		s_count;
+	atomic_t		s_active;
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	dep_map;
+#endif
+	/* the following two fields are published */
+	struct sysfs_dirent	*s_parent;
+	const char		*s_name;
+
+	struct rb_node		s_rb;
+
+	union {
+		struct completion	*completion;
+		struct sysfs_dirent	*removed_list;
+	} u;
+
+	const void		*s_ns; /* namespace tag */
+	unsigned int		s_hash; /* ns + name hash */
+	union {
+		struct sysfs_elem_dir		s_dir;
+		struct sysfs_elem_symlink	s_symlink;
+		struct sysfs_elem_attr		s_attr;
+	};
+
+	void			*priv;
+
+	unsigned short		s_flags;
+	umode_t			s_mode;
+	unsigned int		s_ino;
+	struct sysfs_inode_attrs *s_iattr;
+};
 
 struct kernfs_root {
 	/* published fields */
@@ -82,6 +170,26 @@ struct kernfs_ops {
 
 #ifdef CONFIG_SYSFS
 
+static inline enum kernfs_node_type sysfs_type(struct sysfs_dirent *sd)
+{
+	return sd->s_flags & SYSFS_TYPE_MASK;
+}
+
+/**
+ * kernfs_enable_ns - enable namespace under a directory
+ * @sd: directory of interest, should be empty
+ *
+ * This is to be called right after @sd is created to enable namespace
+ * under it.  All children of @sd must have non-NULL namespace tags and
+ * only the ones which match the super_block's tag will be visible.
+ */
+static inline void kernfs_enable_ns(struct sysfs_dirent *sd)
+{
+	WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
+	WARN_ON_ONCE(!RB_EMPTY_ROOT(&sd->s_dir.children));
+	sd->s_flags |= SYSFS_FLAG_NS;
+}
+
 struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
 					    const char *name, const void *ns);
 void kernfs_get(struct sysfs_dirent *sd);
@@ -107,7 +215,6 @@ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
 		     const char *new_name, const void *new_ns);
-void kernfs_enable_ns(struct sysfs_dirent *sd);
 int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
 void kernfs_notify(struct sysfs_dirent *sd);
 
@@ -120,6 +227,11 @@ void kernfs_init(void);
 
 #else	/* CONFIG_SYSFS */
 
+static inline enum kernfs_node_type sysfs_type(struct sysfs_dirent *sd)
+{ return 0; }	/* whatever */
+
+static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+
 static inline struct sysfs_dirent *
 kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
 		       const void *ns)
@@ -161,8 +273,6 @@ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
 				   const char *new_name, const void *new_ns)
 { return -ENOSYS; }
 
-static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
-
 static inline int kernfs_setattr(struct sysfs_dirent *sd,
 				 const struct iattr *iattr)
 { return -ENOSYS; }

commit 4b93dc9b1c684d0587fe44d36bbfdf45bd3bea9d
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:43 2013 -0500

    sysfs, kernfs: prepare mount path for kernfs
    
    We're in the process of separating out core sysfs functionality into
    kernfs which will deal with sysfs_dirents directly.  This patch
    rearranges mount path so that the kernfs and sysfs parts are separate.
    
    * As sysfs_super_info won't be visible outside kernfs proper,
      kernfs_super_ns() is added to allow kernfs users to access a
      super_block's namespace tag.
    
    * Generic mount operation is separated out into kernfs_mount_ns().
      sysfs_mount() now just performs sysfs-specific permission check,
      acquires namespace tag, and invokes kernfs_mount_ns().
    
    * Generic superblock release is separated out into kernfs_kill_sb()
      which can be used directly as file_system_type->kill_sb().  As sysfs
      needs to put the namespace tag, sysfs_kill_sb() wraps
      kernfs_kill_sb() with ns tag put.
    
    * sysfs_dir_cachep init and sysfs_inode_init() are separated out into
      kernfs_init().  kernfs_init() uses only small amount of memory and
      trying to handle and propagate kernfs_init() failure doesn't make
      much sense.  Use SLAB_PANIC for sysfs_dir_cachep and make
      sysfs_inode_init() panic on failure.
    
      After this change, kernfs_init() should be called before
      sysfs_init(), fs/namespace.c::mnt_init() modified accordingly.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index fad8b986800f..75fcbe5c9d65 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -18,6 +18,8 @@ struct file;
 struct iattr;
 struct seq_file;
 struct vm_area_struct;
+struct super_block;
+struct file_system_type;
 
 struct sysfs_dirent;
 
@@ -109,6 +111,13 @@ void kernfs_enable_ns(struct sysfs_dirent *sd);
 int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
 void kernfs_notify(struct sysfs_dirent *sd);
 
+const void *kernfs_super_ns(struct super_block *sb);
+struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+			       struct kernfs_root *root, const void *ns);
+void kernfs_kill_sb(struct super_block *sb);
+
+void kernfs_init(void);
+
 #else	/* CONFIG_SYSFS */
 
 static inline struct sysfs_dirent *
@@ -160,6 +169,18 @@ static inline int kernfs_setattr(struct sysfs_dirent *sd,
 
 static inline void kernfs_notify(struct sysfs_dirent *sd) { }
 
+static inline const void *kernfs_super_ns(struct super_block *sb)
+{ return NULL; }
+
+static inline struct dentry *
+kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+		struct kernfs_root *root, const void *ns)
+{ return ERR_PTR(-ENOSYS); }
+
+static inline void kernfs_kill_sb(struct super_block *sb) { }
+
+static inline void kernfs_init(void) { }
+
 #endif	/* CONFIG_SYSFS */
 
 static inline struct sysfs_dirent *
@@ -201,4 +222,11 @@ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
 	return kernfs_remove_by_name_ns(parent, name, NULL);
 }
 
+static inline struct dentry *
+kernfs_mount(struct file_system_type *fs_type, int flags,
+	     struct kernfs_root *root)
+{
+	return kernfs_mount_ns(fs_type, flags, root, NULL);
+}
+
 #endif	/* __LINUX_KERNFS_H */

commit bc755553df9ab33f389c1a0a8bd0b4f4646e80ef
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:41 2013 -0500

    sysfs, kernfs: make inode number ida per kernfs_root
    
    kernfs is being updated to allow multiple sysfs_dirent hierarchies so
    that it can also be used by other users.  Currently, inode number is
    allocated using a global ida, sysfs_ino_ida; however, inos for
    different hierarchies should be handled separately.
    
    This patch makes ino allocation per kernfs_root.  sysfs_ino_ida is
    replaced by kernfs_root->ino_ida and sysfs_new_dirent() is updated to
    take @root and allocate ino from it.  ida_simple_get/remove() are used
    instead of sysfs_ino_lock and sysfs_alloc/free_ino().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index f75548b8ed7a..fad8b986800f 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -11,6 +11,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
+#include <linux/idr.h>
 #include <linux/lockdep.h>
 
 struct file;
@@ -23,6 +24,9 @@ struct sysfs_dirent;
 struct kernfs_root {
 	/* published fields */
 	struct sysfs_dirent	*sd;
+
+	/* private fields, do not use outside kernfs proper */
+	struct ida		ino_ida;
 };
 
 struct sysfs_open_file {

commit ba7443bc656e5236c316b2acacc8b551f872910f
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:40 2013 -0500

    sysfs, kernfs: implement kernfs_create/destroy_root()
    
    There currently is single kernfs hierarchy in the whole system which
    is used for sysfs.  kernfs needs to support multiple hierarchies to
    allow other users.  This patch introduces struct kernfs_root which
    serves as the root of each kernfs hierarchy and implements
    kernfs_create/destroy_root().
    
    * Each kernfs_root is associated with a root sd (sysfs_dentry).  The
      root is freed when the root sd is released and kernfs_destory_root()
      simply invokes kernfs_remove() on the root sd.  sysfs_remove_one()
      is updated to handle release of the root sd.  Note that ps_iattr
      update in sysfs_remove_one() is trivially updated for readability.
    
    * Root sd's are now dynamically allocated using sysfs_new_dirent().
      Update sysfs_alloc_ino() so that it gives out ino from 1 so that the
      root sd still gets ino 1.
    
    * While kernfs currently only points to the root sd, it'll soon grow
      fields which are specific to each hierarchy.  As determining a given
      sd's root will be necessary, sd->s_dir.root is added.  This backlink
      fits better as a separate field in sd; however, sd->s_dir is inside
      union with space to spare, so use it to save space and provide
      kernfs_root() accessor to determine the root sd.
    
    * As hierarchies may be destroyed now, each mount needs to hold onto
      the hierarchy it's attached to.  Update sysfs_fill_super() and
      sysfs_kill_sb() so that they get and put the kernfs_root
      respectively.
    
    * sysfs_root is replaced with kernfs_root which is dynamically created
      by invoking kernfs_create_root() from sysfs_init().
    
    This patch doesn't introduce any visible behavior changes.
    
    v2: kernfs_create_root() forgot to set @sd->priv.  Fixed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index fd8f574ef2fe..f75548b8ed7a 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -20,6 +20,11 @@ struct vm_area_struct;
 
 struct sysfs_dirent;
 
+struct kernfs_root {
+	/* published fields */
+	struct sysfs_dirent	*sd;
+};
+
 struct sysfs_open_file {
 	/* published fields */
 	struct sysfs_dirent	*sd;
@@ -76,6 +81,9 @@ struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
 void kernfs_get(struct sysfs_dirent *sd);
 void kernfs_put(struct sysfs_dirent *sd);
 
+struct kernfs_root *kernfs_create_root(void *priv);
+void kernfs_destroy_root(struct kernfs_root *root);
+
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
 					  const char *name, void *priv,
 					  const void *ns);
@@ -107,6 +115,11 @@ kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
 static inline void kernfs_get(struct sysfs_dirent *sd) { }
 static inline void kernfs_put(struct sysfs_dirent *sd) { }
 
+static inline struct kernfs_root *kernfs_create_root(void *priv)
+{ return ERR_PTR(-ENOSYS); }
+
+static inline void kernfs_destroy_root(struct kernfs_root *root) { }
+
 static inline struct sysfs_dirent *
 kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
 		     const void *ns)

commit ccf73cf336dc55bc52748205dee998d2fd4a8808
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:30 2013 -0500

    sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put()
    
    Introduce kernfs interface for finding, getting and putting
    sysfs_dirents.
    
    * sysfs_find_dirent() is renamed to kernfs_find_ns() and lockdep
      assertion for sysfs_mutex is added.
    
    * sysfs_get_dirent_ns() is renamed to kernfs_find_and_get().
    
    * Macro inline dancing around __sysfs_get/put() are removed and
      kernfs_get/put() are made proper functions implemented in
      fs/sysfs/dir.c.
    
    While the conversions are mostly equivalent, there's one difference -
    kernfs_get() doesn't return the input param as its return value.  This
    change is intentional.  While passing through the input increases
    writability in some areas, it is unnecessary and has been shown to
    cause confusion regarding how the last ref is handled.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 105d09dcb064..fd8f574ef2fe 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -71,6 +71,11 @@ struct kernfs_ops {
 
 #ifdef CONFIG_SYSFS
 
+struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
+					    const char *name, const void *ns);
+void kernfs_get(struct sysfs_dirent *sd);
+void kernfs_put(struct sysfs_dirent *sd);
+
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
 					  const char *name, void *priv,
 					  const void *ns);
@@ -94,6 +99,14 @@ void kernfs_notify(struct sysfs_dirent *sd);
 
 #else	/* CONFIG_SYSFS */
 
+static inline struct sysfs_dirent *
+kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
+		       const void *ns)
+{ return NULL; }
+
+static inline void kernfs_get(struct sysfs_dirent *sd) { }
+static inline void kernfs_put(struct sysfs_dirent *sd) { }
+
 static inline struct sysfs_dirent *
 kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
 		     const void *ns)
@@ -132,6 +145,12 @@ static inline void kernfs_notify(struct sysfs_dirent *sd) { }
 
 #endif	/* CONFIG_SYSFS */
 
+static inline struct sysfs_dirent *
+kernfs_find_and_get(struct sysfs_dirent *sd, const char *name)
+{
+	return kernfs_find_and_get_ns(sd, name, NULL);
+}
+
 static inline struct sysfs_dirent *
 kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
 {

commit 517e64f57883bd63c5a4ab8b3d0d3ed68c55d0cf
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:29 2013 -0500

    sysfs, kernfs: revamp sysfs_dirent active_ref lockdep annotation
    
    Currently, sysfs_dirent active_ref lockdep annotation uses
    attribute->[s]key as the lockdep key, which forces
    kernfs_create_file_ns() to assume that sysfs_dirent->priv is pointing
    to a struct attribute which may not be true for non-sysfs users.  This
    patch restructures the lockdep annotation such that
    
    * kernfs_ops contains lockdep_key which is used by default for files
      created kernfs_create_file_ns().
    
    * kernfs_create_file_ns_key() is introduced which takes an extra @key
      argument.  The created file will use the specified key for
      active_ref lockdep annotation.  If NULL is specified, lockdep for
      the file is disabled.
    
    * sysfs_add_file_mode_ns() is updated to use
      kernfs_create_file_ns_key() with the appropriate key from the
      attribute or NULL if ignore_lockdep is set.
    
    This makes the lockdep annotation properly contained in kernfs while
    allowing sysfs to cleanly keep its current behavior.  This patch
    doesn't introduce any behavior differences.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index f20796ecc76e..105d09dcb064 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -11,6 +11,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
+#include <linux/lockdep.h>
 
 struct file;
 struct iattr;
@@ -62,6 +63,10 @@ struct kernfs_ops {
 			 loff_t off);
 
 	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lock_class_key	lockdep_key;
+#endif
 };
 
 #ifdef CONFIG_SYSFS
@@ -69,11 +74,12 @@ struct kernfs_ops {
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
 					  const char *name, void *priv,
 					  const void *ns);
-struct sysfs_dirent *kernfs_create_file_ns(struct sysfs_dirent *parent,
-					   const char *name,
-					   umode_t mode, loff_t size,
-					   const struct kernfs_ops *ops,
-					   void *priv, const void *ns);
+struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
+					       const char *name,
+					       umode_t mode, loff_t size,
+					       const struct kernfs_ops *ops,
+					       void *priv, const void *ns,
+					       struct lock_class_key *key);
 struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
 					const char *name,
 					struct sysfs_dirent *target);
@@ -94,9 +100,10 @@ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct sysfs_dirent *
-kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
-		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
-		      void *priv, const void *ns)
+kernfs_create_file_ns_key(struct sysfs_dirent *parent, const char *name,
+			  umode_t mode, loff_t size,
+			  const struct kernfs_ops *ops, void *priv,
+			  const void *ns, struct lock_class_key *key)
 { return ERR_PTR(-ENOSYS); }
 
 static inline struct sysfs_dirent *
@@ -131,6 +138,20 @@ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
 	return kernfs_create_dir_ns(parent, name, priv, NULL);
 }
 
+static inline struct sysfs_dirent *
+kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+		      void *priv, const void *ns)
+{
+	struct lock_class_key *key = NULL;
+
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	key = (struct lock_class_key *)&ops->lockdep_key;
+#endif
+	return kernfs_create_file_ns_key(parent, name, mode, size, ops, priv,
+					 ns, key);
+}
+
 static inline struct sysfs_dirent *
 kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
 		   loff_t size, const struct kernfs_ops *ops, void *priv)

commit 024f647117d697165aaadf3f1af1343b7000149a
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:27 2013 -0500

    sysfs, kernfs: introduce kernfs_notify()
    
    Introduce kernfs interface to wake up poll(2) which takes and returns
    sysfs_dirents.
    
    sysfs_notify_dirent() is renamed to kernfs_notify() and sysfs_notify()
    is updated so that it doesn't directly grab sysfs_mutex but acquires
    the target sysfs_dirents using sysfs_get_dirent().
    sysfs_notify_dirent() is reimplemented as a dumb inline wrapper around
    kernfs_notify().
    
    This patch doesn't introduce any behavior changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index ba993ebcd81e..f20796ecc76e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -84,6 +84,7 @@ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
 		     const char *new_name, const void *new_ns);
 void kernfs_enable_ns(struct sysfs_dirent *sd);
 int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+void kernfs_notify(struct sysfs_dirent *sd);
 
 #else	/* CONFIG_SYSFS */
 
@@ -120,6 +121,8 @@ static inline int kernfs_setattr(struct sysfs_dirent *sd,
 				 const struct iattr *iattr)
 { return -ENOSYS; }
 
+static inline void kernfs_notify(struct sysfs_dirent *sd) { }
+
 #endif	/* CONFIG_SYSFS */
 
 static inline struct sysfs_dirent *

commit d19b9846df64d8845be682b6318bd1aee246cf60
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:26 2013 -0500

    sysfs, kernfs: add kernfs_ops->seq_{start|next|stop}()
    
    kernfs_ops currently only supports single_open() behavior which is
    pretty restrictive.  Add optional callbacks ->seq_{start|next|stop}()
    which, when implemented, are invoked for seq_file traversal.  This
    allows full seq_file functionality for kernfs users.  This currently
    doesn't have any user and doesn't change any behavior.
    
    v2: Refreshed on top of the updated "sysfs, kernfs: prepare read path
        for kernfs".
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index d0912cf02087..ba993ebcd81e 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -37,8 +37,9 @@ struct kernfs_ops {
 	/*
 	 * Read is handled by either seq_file or raw_read().
 	 *
-	 * If seq_show() is present, seq_file path is active.  The behavior
-	 * is equivalent to single_open().  @sf->private points to the
+	 * If seq_show() is present, seq_file path is active.  Other seq
+	 * operations are optional and if not implemented, the behavior is
+	 * equivalent to single_open().  @sf->private points to the
 	 * associated sysfs_open_file.
 	 *
 	 * read() is bounced through kernel buffer and a read larger than
@@ -46,6 +47,10 @@ struct kernfs_ops {
 	 */
 	int (*seq_show)(struct seq_file *sf, void *v);
 
+	void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
+	void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
+	void (*seq_stop)(struct seq_file *sf, void *v);
+
 	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
 			loff_t off);
 

commit 496f73944a4a974f89d48920bf368aec8841b195
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:24 2013 -0500

    sysfs, kernfs: introduce kernfs_create_file[_ns]()
    
    Introduce kernfs interface to create a file which takes and returns
    sysfs_dirents.
    
    The actual file creation part is separated out from
    sysfs_add_file_mode_ns() into kernfs_create_file_ns().  The former now
    only decides the kernfs_ops to use and the file's size and invokes the
    latter.
    
    This patch doesn't introduce behavior changes.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 97c6c0f91325..d0912cf02087 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -64,6 +64,11 @@ struct kernfs_ops {
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
 					  const char *name, void *priv,
 					  const void *ns);
+struct sysfs_dirent *kernfs_create_file_ns(struct sysfs_dirent *parent,
+					   const char *name,
+					   umode_t mode, loff_t size,
+					   const struct kernfs_ops *ops,
+					   void *priv, const void *ns);
 struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
 					const char *name,
 					struct sysfs_dirent *target);
@@ -82,6 +87,12 @@ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
 		     const void *ns)
 { return ERR_PTR(-ENOSYS); }
 
+static inline struct sysfs_dirent *
+kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+		      void *priv, const void *ns)
+{ return ERR_PTR(-ENOSYS); }
+
 static inline struct sysfs_dirent *
 kernfs_create_link(struct sysfs_dirent *parent, const char *name,
 		   struct sysfs_dirent *target)
@@ -112,6 +123,13 @@ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
 	return kernfs_create_dir_ns(parent, name, priv, NULL);
 }
 
+static inline struct sysfs_dirent *
+kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
+		   loff_t size, const struct kernfs_ops *ops, void *priv)
+{
+	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
+}
+
 static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
 					const char *name)
 {

commit f6acf8bb6a40ba3bfcf542e4c4c9e8968c8cb57a
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:21 2013 -0500

    sysfs, kernfs: introduce kernfs_ops
    
    We're in the process of separating out core sysfs functionality into
    kernfs which will deal with sysfs_dirents directly.  This patch
    introduces kernfs_ops which hosts methods kernfs users implement and
    updates fs/sysfs/file.c such that sysfs_kf_*() functions populate
    kernfs_ops and kernfs_file_*() functions call the matching entries
    from kernfs_ops.
    
    kernfs_ops contains the following groups of methods.
    
    * seq_show() - for kernfs files which use seq_file for reads.
    
    * read() - for direct read implementations.  Used iff seq_show() is
      not implemented.
    
    * write() - for writes.
    
    * mmap() - for mmaps.
    
    Notes:
    
    * sysfs_elem_attr->ops is added so that kernfs_ops can be accessed
      from sysfs_dirent.  kernfs_ops() helper is added to verify locking
      and access the field.
    
    * SYSFS_FLAG_HAS_(SEQ_SHOW|MMAP) added.  sd->s_attr->ops is accessible
      only while holding active_ref and there are cases where we want to
      take different actions depending on which ops are implemented.
      These two flags cache whether the two ops are implemented for those.
    
    * kernfs_file_*() no longer test sysfs type but chooses different
      behaviors depending on which methods in kernfs_ops are implemented.
      The conversions are trivial except for the open path.  As
      kernfs_file_open() now decides whether to allow read/write accesses
      depending on the kernfs_ops implemented, the presence of methods in
      kobjs and attribute_bin should be propagated to kernfs_ops.
      sysfs_add_file_mode_ns() is updated so that it propagates presence /
      absence of the callbacks through _empty, _ro, _wo, _rw kernfs_ops.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index b923052c29d0..97c6c0f91325 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -33,6 +33,32 @@ struct sysfs_open_file {
 	const struct vm_operations_struct *vm_ops;
 };
 
+struct kernfs_ops {
+	/*
+	 * Read is handled by either seq_file or raw_read().
+	 *
+	 * If seq_show() is present, seq_file path is active.  The behavior
+	 * is equivalent to single_open().  @sf->private points to the
+	 * associated sysfs_open_file.
+	 *
+	 * read() is bounced through kernel buffer and a read larger than
+	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+	 */
+	int (*seq_show)(struct seq_file *sf, void *v);
+
+	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+			loff_t off);
+
+	/*
+	 * write() is bounced through kernel buffer and a write larger than
+	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+	 */
+	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+			 loff_t off);
+
+	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+};
+
 #ifdef CONFIG_SYSFS
 
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,

commit dd8a5b036b6e8d50854e130555f90f062c5eacec
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:20 2013 -0500

    sysfs, kernfs: move sysfs_open_file to include/linux/kernfs.h
    
    sysfs_open_file will be used as the primary handle for kernfs methods.
    Move its definition from fs/sysfs/file.c to include/linux/kernfs.h and
    mark the public and private fields.
    
    This is pure relocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index e8b73d4a08d2..b923052c29d0 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -9,12 +9,30 @@
 
 #include <linux/kernel.h>
 #include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
 
 struct file;
 struct iattr;
+struct seq_file;
+struct vm_area_struct;
 
 struct sysfs_dirent;
 
+struct sysfs_open_file {
+	/* published fields */
+	struct sysfs_dirent	*sd;
+	struct file		*file;
+
+	/* private fields, do not use outside kernfs proper */
+	struct mutex		mutex;
+	int			event;
+	struct list_head	list;
+
+	bool			mmapped;
+	const struct vm_operations_struct *vm_ops;
+};
+
 #ifdef CONFIG_SYSFS
 
 struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,

commit 93b2b8e4aa4317e3fe6414d117deb5f3c362e8bb
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Nov 28 14:54:15 2013 -0500

    sysfs, kernfs: introduce kernfs_create_dir[_ns]()
    
    Introduce kernfs interface to manipulate a directory which takes and
    returns sysfs_dirents.
    
    create_dir() is renamed to kernfs_create_dir_ns() and its argumantes
    and return value are updated.  create_dir() usages are replaced with
    kernfs_create_dir_ns() and sysfs_create_subdir() usages are replaced
    with kernfs_create_dir().  Dup warnings are handled explicitly by
    sysfs users of the kernfs interface.
    
    sysfs_enable_ns() is renamed to kernfs_enable_ns().
    
    This patch doesn't introduce any behavior changes.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    v3: kernfs_enable_ns() added.
    
    v4: Refreshed on top of "sysfs: drop kobj_ns_type handling, take #2"
        so that this patch removes sysfs_enable_ns().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 8cb673875715..e8b73d4a08d2 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -17,6 +17,9 @@ struct sysfs_dirent;
 
 #ifdef CONFIG_SYSFS
 
+struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+					  const char *name, void *priv,
+					  const void *ns);
 struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
 					const char *name,
 					struct sysfs_dirent *target);
@@ -25,10 +28,16 @@ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
 		     const char *new_name, const void *new_ns);
+void kernfs_enable_ns(struct sysfs_dirent *sd);
 int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
 
 #else	/* CONFIG_SYSFS */
 
+static inline struct sysfs_dirent *
+kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+		     const void *ns)
+{ return ERR_PTR(-ENOSYS); }
+
 static inline struct sysfs_dirent *
 kernfs_create_link(struct sysfs_dirent *parent, const char *name,
 		   struct sysfs_dirent *target)
@@ -45,12 +54,20 @@ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
 				   const char *new_name, const void *new_ns)
 { return -ENOSYS; }
 
+static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+
 static inline int kernfs_setattr(struct sysfs_dirent *sd,
 				 const struct iattr *iattr)
 { return -ENOSYS; }
 
 #endif	/* CONFIG_SYSFS */
 
+static inline struct sysfs_dirent *
+kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+{
+	return kernfs_create_dir_ns(parent, name, priv, NULL);
+}
+
 static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
 					const char *name)
 {

commit 5d60418e54751c856f5aecc308620fde9572e481
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:21:52 2013 -0500

    sysfs, kernfs: introduce kernfs_setattr()
    
    Introduce kernfs setattr interface - kernfs_setattr().
    
    sysfs_sd_setattr() is renamed to __kernfs_setattr() and
    kernfs_setattr() is a simple wrapper around it with sysfs_mutex
    locking.  sysfs_chmod_file() is updated to get an explicit ref on
    kobj->sd and then invoke kernfs_setattr() so that it doesn't have to
    use internal interface.
    
    This patch doesn't introduce any behavior differences.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 803d9600cf72..8cb673875715 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -10,6 +10,9 @@
 #include <linux/kernel.h>
 #include <linux/err.h>
 
+struct file;
+struct iattr;
+
 struct sysfs_dirent;
 
 #ifdef CONFIG_SYSFS
@@ -22,6 +25,7 @@ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
 			     const void *ns);
 int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
 		     const char *new_name, const void *new_ns);
+int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
 
 #else	/* CONFIG_SYSFS */
 
@@ -41,6 +45,10 @@ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
 				   const char *new_name, const void *new_ns)
 { return -ENOSYS; }
 
+static inline int kernfs_setattr(struct sysfs_dirent *sd,
+				 const struct iattr *iattr)
+{ return -ENOSYS; }
+
 #endif	/* CONFIG_SYSFS */
 
 static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,

commit 890ece160c6465b49c42975d529c3481d89da8f5
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:21:51 2013 -0500

    sysfs, kernfs: introduce kernfs_rename[_ns]()
    
    Introduce kernfs rename interface, krenfs_rename[_ns]().
    
    This is just rename of sysfs_rename().  No functional changes.
    Function comment is added to kernfs_rename_ns() and @new_parent_sd is
    renamed to @new_parent for consistency with other kernfs interfaces.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index fe6290d41776..803d9600cf72 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -20,6 +20,8 @@ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
 void kernfs_remove(struct sysfs_dirent *sd);
 int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
 			     const void *ns);
+int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+		     const char *new_name, const void *new_ns);
 
 #else	/* CONFIG_SYSFS */
 
@@ -34,6 +36,11 @@ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
 					   const char *name, const void *ns)
 { return -ENOSYS; }
 
+static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+				   struct sysfs_dirent *new_parent,
+				   const char *new_name, const void *new_ns)
+{ return -ENOSYS; }
+
 #endif	/* CONFIG_SYSFS */
 
 static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,

commit 5d0e26bb59a680a5d97db5b6629941603e8de229
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:21:50 2013 -0500

    sysfs, kernfs: introduce kernfs_create_link()
    
    Separate out kernfs symlink interface - kernfs_create_link() - which
    takes and returns sysfs_dirents, from sysfs_do_create_link_sd().
    sysfs_do_create_link_sd() now just determines the parent and target
    sysfs_dirents and invokes the new interface and handles dup warning.
    
    This patch doesn't introduce behavior changes.
    
    v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 83e151ad0619..fe6290d41776 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -8,17 +8,26 @@
 #define __LINUX_KERNFS_H
 
 #include <linux/kernel.h>
+#include <linux/err.h>
 
 struct sysfs_dirent;
 
 #ifdef CONFIG_SYSFS
 
+struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+					const char *name,
+					struct sysfs_dirent *target);
 void kernfs_remove(struct sysfs_dirent *sd);
 int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
 			     const void *ns);
 
 #else	/* CONFIG_SYSFS */
 
+static inline struct sysfs_dirent *
+kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+		   struct sysfs_dirent *target)
+{ return ERR_PTR(-ENOSYS); }
+
 static inline void kernfs_remove(struct sysfs_dirent *sd) { }
 
 static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,

commit 879f40d193bb3c6c13930e88e3e9d5d7baf84d19
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 23 17:21:49 2013 -0500

    sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]()
    
    Introduce kernfs removal interfaces - kernfs_remove() and
    kernfs_remove_by_name[_ns]().
    
    These are just renames of sysfs_remove() and sysfs_hash_and_remove().
    No functional changes.
    
    v2: Dummy kernfs_remove_by_name_ns() for !CONFIG_SYSFS updated to
        return -ENOSYS instead of 0.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 254b9e872b09..83e151ad0619 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -7,6 +7,30 @@
 #ifndef __LINUX_KERNFS_H
 #define __LINUX_KERNFS_H
 
+#include <linux/kernel.h>
+
 struct sysfs_dirent;
 
+#ifdef CONFIG_SYSFS
+
+void kernfs_remove(struct sysfs_dirent *sd);
+int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+			     const void *ns);
+
+#else	/* CONFIG_SYSFS */
+
+static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+
+static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+					   const char *name, const void *ns)
+{ return -ENOSYS; }
+
+#endif	/* CONFIG_SYSFS */
+
+static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+					const char *name)
+{
+	return kernfs_remove_by_name_ns(parent, name, NULL);
+}
+
 #endif	/* __LINUX_KERNFS_H */

commit b8441ed279bff09a0a5ddeacf8f4087d2fb424ca
Author: Tejun Heo <tj@kernel.org>
Date:   Sun Nov 24 09:54:58 2013 -0500

    sysfs, kernfs: add skeletons for kernfs
    
    Core sysfs implementation will be separated into kernfs so that it can
    be used by other non-kobject users.
    
    This patch creates fs/kernfs/ directory and makes boilerplate changes.
    kernfs interface will be directly based on sysfs_dirent and its
    forward declaration is moved to include/linux/kernfs.h which is
    included from include/linux/sysfs.h.  sysfs core implementation will
    be gradually separated out and moved to kernfs.
    
    This patch doesn't introduce any functional changes.
    
    v2: mount.c added.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
new file mode 100644
index 000000000000..254b9e872b09
--- /dev/null
+++ b/include/linux/kernfs.h
@@ -0,0 +1,12 @@
+/*
+ * kernfs.h - pseudo filesystem decoupled from vfs locking
+ *
+ * This file is released under the GPLv2.
+ */
+
+#ifndef __LINUX_KERNFS_H
+#define __LINUX_KERNFS_H
+
+struct sysfs_dirent;
+
+#endif	/* __LINUX_KERNFS_H */
