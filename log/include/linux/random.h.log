commit 253d3194c2b58152fe830fd27c2fd83ebc6fe5ee
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Mon Feb 10 13:00:13 2020 +0000

    random: add arch_get_random_*long_early()
    
    Some architectures (e.g. arm64) can have heterogeneous CPUs, and the
    boot CPU may be able to provide entropy while secondary CPUs cannot. On
    such systems, arch_get_random_long() and arch_get_random_seed_long()
    will fail unless support for RNG instructions has been detected on all
    CPUs. This prevents the boot CPU from being able to provide
    (potentially) trusted entropy when seeding the primary CRNG.
    
    To make it possible to seed the primary CRNG from the boot CPU without
    adversely affecting the runtime versions of arch_get_random_long() and
    arch_get_random_seed_long(), this patch adds new early versions of the
    functions used when initializing the primary CRNG.
    
    Default implementations are provided atop of the existing
    arch_get_random_long() and arch_get_random_seed_long() so that only
    architectures with such constraints need to provide the new helpers.
    
    There should be no functional change as a result of this patch.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Link: https://lore.kernel.org/r/20200210130015.17664-3-mark.rutland@arm.com
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index d319f9a1e429..45e1f8fa742b 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -7,6 +7,8 @@
 #ifndef _LINUX_RANDOM_H
 #define _LINUX_RANDOM_H
 
+#include <linux/bug.h>
+#include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/once.h>
 
@@ -185,6 +187,26 @@ static inline bool __must_check arch_get_random_seed_int(unsigned int *v)
 }
 #endif
 
+/*
+ * Called from the boot CPU during startup; not valid to call once
+ * secondary CPUs are up and preemption is possible.
+ */
+#ifndef arch_get_random_seed_long_early
+static inline bool __init arch_get_random_seed_long_early(unsigned long *v)
+{
+	WARN_ON(system_state != SYSTEM_BOOTING);
+	return arch_get_random_seed_long(v);
+}
+#endif
+
+#ifndef arch_get_random_long_early
+static inline bool __init arch_get_random_long_early(unsigned long *v)
+{
+	WARN_ON(system_state != SYSTEM_BOOTING);
+	return arch_get_random_long(v);
+}
+#endif
+
 /* Pseudo random number generator from numerical recipes. */
 static inline u32 next_pseudo_random32(u32 seed)
 {

commit 904caa6413c87aacbf7d0682da617c39ca18cf1a
Author: Richard Henderson <richard.henderson@linaro.org>
Date:   Fri Jan 10 14:54:18 2020 +0000

    linux/random.h: Mark CONFIG_ARCH_RANDOM functions __must_check
    
    We must not use the pointer output without validating the
    success of the random read.
    
    Reviewed-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20200110145422.49141-7-broonie@kernel.org
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index ea0e2f5f1ec5..d319f9a1e429 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -167,19 +167,19 @@ static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 #ifdef CONFIG_ARCH_RANDOM
 # include <asm/archrandom.h>
 #else
-static inline bool arch_get_random_long(unsigned long *v)
+static inline bool __must_check arch_get_random_long(unsigned long *v)
 {
 	return false;
 }
-static inline bool arch_get_random_int(unsigned int *v)
+static inline bool __must_check arch_get_random_int(unsigned int *v)
 {
 	return false;
 }
-static inline bool arch_get_random_seed_long(unsigned long *v)
+static inline bool __must_check arch_get_random_seed_long(unsigned long *v)
 {
 	return false;
 }
-static inline bool arch_get_random_seed_int(unsigned int *v)
+static inline bool __must_check arch_get_random_seed_int(unsigned int *v)
 {
 	return false;
 }

commit 66f5ae899ada79c0e9a3d8d954f93a72344cd350
Author: Richard Henderson <richard.henderson@linaro.org>
Date:   Fri Jan 10 14:54:17 2020 +0000

    linux/random.h: Use false with bool
    
    Keep the generic fallback versions in sync with the other architecture
    specific implementations and use the proper name for false.
    
    Suggested-by: Ard Biesheuvel <ardb@kernel.org>
    Signed-off-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20200110145422.49141-6-broonie@kernel.org
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 7fd0360908d2..ea0e2f5f1ec5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -169,19 +169,19 @@ static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 #else
 static inline bool arch_get_random_long(unsigned long *v)
 {
-	return 0;
+	return false;
 }
 static inline bool arch_get_random_int(unsigned int *v)
 {
-	return 0;
+	return false;
 }
 static inline bool arch_get_random_seed_long(unsigned long *v)
 {
-	return 0;
+	return false;
 }
 static inline bool arch_get_random_seed_int(unsigned int *v)
 {
-	return 0;
+	return false;
 }
 #endif
 

commit 647f50d5d9d933b644b29c54f13ac52af1b1774d
Author: Richard Henderson <richard.henderson@linaro.org>
Date:   Fri Jan 10 14:54:16 2020 +0000

    linux/random.h: Remove arch_has_random, arch_has_random_seed
    
    The arm64 version of archrandom.h will need to be able to test for
    support and read the random number without preemption, so a separate
    query predicate is not practical.
    
    Since this part of the generic interface is unused, remove it.
    
    Signed-off-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20200110145422.49141-5-broonie@kernel.org
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index f189c927fdea..7fd0360908d2 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -175,10 +175,6 @@ static inline bool arch_get_random_int(unsigned int *v)
 {
 	return 0;
 }
-static inline bool arch_has_random(void)
-{
-	return 0;
-}
 static inline bool arch_get_random_seed_long(unsigned long *v)
 {
 	return 0;
@@ -187,10 +183,6 @@ static inline bool arch_get_random_seed_int(unsigned int *v)
 {
 	return 0;
 }
-static inline bool arch_has_random_seed(void)
-{
-	return 0;
-}
 #endif
 
 /* Pseudo random number generator from numerical recipes. */

commit 428826f5358c922dc378830a1717b682c0823160
Author: Hsin-Yi Wang <hsinyi@chromium.org>
Date:   Fri Aug 23 14:24:51 2019 +0800

    fdt: add support for rng-seed
    
    Introducing a chosen node, rng-seed, which is an entropy that can be
    passed to kernel called very early to increase initial device
    randomness. Bootloader should provide this entropy and the value is
    read from /chosen/rng-seed in DT.
    
    Obtain of_fdt_crc32 for CRC check after early_init_dt_scan_nodes(),
    since early_init_dt_scan_chosen() would modify fdt to erase rng-seed.
    
    Add a new interface add_bootloader_randomness() for rng-seed use case.
    Depends on whether the seed is trustworthy, rng seed would be passed to
    add_hwgenerator_randomness(). Otherwise it would be passed to
    add_device_randomness(). Decision is controlled by kernel config
    RANDOM_TRUST_BOOTLOADER.
    
    Signed-off-by: Hsin-Yi Wang <hsinyi@chromium.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu> # drivers/char/random.c
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 1f7dced2bba6..f189c927fdea 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -19,6 +19,7 @@ struct random_ready_callback {
 };
 
 extern void add_device_randomness(const void *, unsigned int);
+extern void add_bootloader_randomness(const void *, unsigned int);
 
 #if defined(LATENT_ENTROPY_PLUGIN) && !defined(__CHECKER__)
 static inline void add_latent_entropy(void)

commit 80111bfb672d8c04d60c25559243554f732f2848
Merge: bf8a9a475573 f3e20ad67b4c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 17 10:08:59 2019 -0700

    Merge tag 's390-5.2-2' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull more s390 updates from Martin Schwidefsky:
    
     - Enhancements for the QDIO layer
    
     - Remove the RCP trace event
    
     - Avoid three build issues
    
     - Move the defconfig to the configs directory
    
    * tag 's390-5.2-2' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux:
      s390: move arch/s390/defconfig to arch/s390/configs/defconfig
      s390/qdio: optimize state inspection of HW-owned SBALs
      s390/qdio: use get_buf_state() in debug_get_buf_state()
      s390/qdio: allow to scan all Output SBALs in one go
      s390/cio: Remove tracing for rchp instruction
      s390/kasan: adapt disabled_wait usage to avoid build error
      latent_entropy: avoid build error when plugin cflags are not set
      s390/boot: fix compiler error due to missing awk strtonum

commit 7e756f423af808b6571fed3144747db2ef7fa1c5
Author: Vasily Gorbik <gor@linux.ibm.com>
Date:   Tue May 7 16:28:15 2019 +0200

    latent_entropy: avoid build error when plugin cflags are not set
    
    Some architectures set up CFLAGS for linux decompressor phase from
    scratch and do not include GCC_PLUGINS_CFLAGS. Since "latent_entropy"
    variable declaration is generated by the plugin code itself including
    linux/random.h in decompressor code then would cause a build
    error. E.g. on s390:
    
    In file included from ./include/linux/net.h:22,
                     from ./include/linux/skbuff.h:29,
                     from ./include/linux/if_ether.h:23,
                     from ./arch/s390/include/asm/diag.h:12,
                     from arch/s390/boot/startup.c:8:
    ./include/linux/random.h: In function 'add_latent_entropy':
    ./include/linux/random.h:26:39: error: 'latent_entropy' undeclared
    (first use in this function); did you mean 'add_latent_entropy'?
       26 |  add_device_randomness((const void *)&latent_entropy,
          |                                       ^~~~~~~~~~~~~~
          |                                       add_latent_entropy
    ./include/linux/random.h:26:39: note: each undeclared identifier is
    reported only once for each function it appears in
    
    The build error is triggered by commit a80313ff91ab ("s390/kernel:
    introduce .dma sections") which made it into 5.2 merge window.
    
    To address that avoid using CONFIG_GCC_PLUGIN_LATENT_ENTROPY in
    favour of LATENT_ENTROPY_PLUGIN definition which is defined as a
    part of gcc plugins cflags and hence reflect more accurately when gcc
    plugin is active. Besides that it is also used for similar purpose in
    linux/compiler-gcc.h for latent_entropy attribute definition.
    
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/linux/random.h b/include/linux/random.h
index 445a0ea4ff49..d4eb9b3789ad 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -20,7 +20,7 @@ struct random_ready_callback {
 
 extern void add_device_randomness(const void *, unsigned int);
 
-#if defined(CONFIG_GCC_PLUGIN_LATENT_ENTROPY) && !defined(__CHECKER__)
+#if defined(LATENT_ENTROPY_PLUGIN) && !defined(__CHECKER__)
 static inline void add_latent_entropy(void)
 {
 	add_device_randomness((const void *)&latent_entropy,

commit d55535232c3dbde9a523a9d10d68670f5fe5dec3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 19 23:27:05 2019 -0400

    random: move rand_initialize() earlier
    
    Right now rand_initialize() is run as an early_initcall(), but it only
    depends on timekeeping_init() (for mixing ktime_get_real() into the
    pools). However, the call to boot_init_stack_canary() for stack canary
    initialization runs earlier, which triggers a warning at boot:
    
    random: get_random_bytes called from start_kernel+0x357/0x548 with crng_init=0
    
    Instead, this moves rand_initialize() to after timekeeping_init(), and moves
    canary initialization here as well.
    
    Note that this warning may still remain for machines that do not have
    UEFI RNG support (which initializes the RNG pools during setup_arch()),
    or for x86 machines without RDRAND (or booting without "random.trust=on"
    or CONFIG_RANDOM_TRUST_CPU=y).
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 445a0ea4ff49..13aeaf5a4bd4 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -36,6 +36,7 @@ extern void add_interrupt_randomness(int irq, int irq_flags) __latent_entropy;
 
 extern void get_random_bytes(void *buf, int nbytes);
 extern int wait_for_random_bytes(void);
+extern int __init rand_initialize(void);
 extern bool rng_is_initialized(void);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);

commit 9a47249d444d344051c7c0e909fad0e88515a5c2
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Tue Jul 31 21:11:00 2018 +0200

    random: Make crng state queryable
    
    It is very useful to be able to know whether or not get_random_bytes_wait
    / wait_for_random_bytes is going to block or not, or whether plain
    get_random_bytes is going to return good randomness or bad randomness.
    
    The particular use case is for mitigating certain attacks in WireGuard.
    A handshake packet arrives and is queued up. Elsewhere a worker thread
    takes items from the queue and processes them. In replying to these
    items, it needs to use some random data, and it has to be good random
    data. If we simply block until we can have good randomness, then it's
    possible for an attacker to fill the queue up with packets waiting to be
    processed. Upon realizing the queue is full, WireGuard will detect that
    it's under a denial of service attack, and behave accordingly. A better
    approach is just to drop incoming handshake packets if the crng is not
    yet initialized.
    
    This patch, therefore, makes that information directly accessible.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index f1c9bc5cd231..445a0ea4ff49 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -36,6 +36,7 @@ extern void add_interrupt_randomness(int irq, int irq_flags) __latent_entropy;
 
 extern void get_random_bytes(void *buf, int nbytes);
 extern int wait_for_random_bytes(void);
+extern bool rng_is_initialized(void);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern int __must_check get_random_bytes_arch(void *buf, int nbytes);

commit 753d433b586d1d43c487e3d660f5778c7c8d58ea
Author: Tobin C. Harding <me@tobin.cc>
Date:   Fri Jun 22 09:15:32 2018 +1000

    random: Return nbytes filled from hw RNG
    
    Currently the function get_random_bytes_arch() has return value 'void'.
    If the hw RNG fails we currently fall back to using get_random_bytes().
    This defeats the purpose of requesting random material from the hw RNG
    in the first place.
    
    There are currently no intree users of get_random_bytes_arch().
    
    Only get random bytes from the hw RNG, make function return the number
    of bytes retrieved from the hw RNG.
    
    Acked-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Tobin C. Harding <me@tobin.cc>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 2ddf13b4281e..f1c9bc5cd231 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -38,7 +38,7 @@ extern void get_random_bytes(void *buf, int nbytes);
 extern int wait_for_random_bytes(void);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
-extern void get_random_bytes_arch(void *buf, int nbytes);
+extern int __must_check get_random_bytes_arch(void *buf, int nbytes);
 
 #ifndef MODULE
 extern const struct file_operations random_fops, urandom_fops;

commit 25e3fca492035a2e1d4ac6e3b1edd9c1acd48897
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Feb 4 23:07:46 2018 +0100

    random: always fill buffer in get_random_bytes_wait
    
    In the unfortunate event that a developer fails to check the return
    value of get_random_bytes_wait, or simply wants to make a "best effort"
    attempt, for whatever that's worth, it's much better to still fill the
    buffer with _something_ rather than catastrophically failing in the case
    of an interruption. This is both a defense in depth measure against
    inevitable programming bugs, as well as a means of making the API a bit
    more useful.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 4024f7d9c77d..2ddf13b4281e 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -85,10 +85,8 @@ static inline unsigned long get_random_canary(void)
 static inline int get_random_bytes_wait(void *buf, int nbytes)
 {
 	int ret = wait_for_random_bytes();
-	if (unlikely(ret))
-		return ret;
 	get_random_bytes(buf, nbytes);
-	return 0;
+	return ret;
 }
 
 #define declare_get_random_var_wait(var) \

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index eafea6a09361..4024f7d9c77d 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * include/linux/random.h
  *

commit 52f6c588c77b76d548201470c2a28263a41b462b
Merge: 78dcf73421a8 72e5c740f633
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:44:02 2017 -0700

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull random updates from Ted Ts'o:
     "Add wait_for_random_bytes() and get_random_*_wait() functions so that
      callers can more safely get random bytes if they can block until the
      CRNG is initialized.
    
      Also print a warning if get_random_*() is called before the CRNG is
      initialized. By default, only one single-line warning will be printed
      per boot. If CONFIG_WARN_ALL_UNSEEDED_RANDOM is defined, then a
      warning will be printed for each function which tries to get random
      bytes before the CRNG is initialized. This can get spammy for certain
      architecture types, so it is not enabled by default"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      random: reorder READ_ONCE() in get_random_uXX
      random: suppress spammy warnings about unseeded randomness
      random: warn when kernel uses unseeded randomness
      net/route: use get_random_int for random counter
      net/neighbor: use get_random_u32 for 32-bit hash random
      rhashtable: use get_random_u32 for hash_rnd
      ceph: ensure RNG is seeded before using
      iscsi: ensure RNG is seeded before use
      cifs: use get_random_u32 for 32-bit lock random
      random: add get_random_{bytes,u32,u64,int,long,once}_wait family
      random: add wait_for_random_bytes() API

commit 022c204040f3fd22d6445bc35517786195b7ae80
Author: Rik van Riel <riel@redhat.com>
Date:   Wed Jul 12 14:36:17 2017 -0700

    random,stackprotect: introduce get_random_canary function
    
    Patch series "stackprotector: ascii armor the stack canary", v2.
    
    Zero out the first byte of the stack canary value on 64 bit systems, in
    order to mitigate unterminated C string overflows.
    
    The null byte both prevents C string functions from reading the canary,
    and from writing it if the canary value were guessed or obtained through
    some other means.
    
    Reducing the entropy by 8 bits is acceptable on 64-bit systems, which
    will still have 56 bits of entropy left, but not on 32 bit systems, so
    the "ascii armor" canary is only implemented on 64-bit systems.
    
    Inspired by the "ascii armor" code in execshield and Daniel Micay's
    linux-hardened tree.
    
    Also see https://github.com/thestinger/linux-hardened/
    
    This patch (of 5):
    
    Introduce get_random_canary(), which provides a random unsigned long
    canary value with the first byte zeroed out on 64 bit architectures, in
    order to mitigate non-terminated C string overflows.
    
    The null byte both prevents C string functions from reading the canary,
    and from writing it if the canary value were guessed or obtained through
    some other means.
    
    Reducing the entropy by 8 bits is acceptable on 64-bit systems, which
    will still have 56 bits of entropy left, but not on 32 bit systems, so
    the "ascii armor" canary is only implemented on 64-bit systems.
    
    Inspired by the "ascii armor" code in the old execshield patches, and
    Daniel Micay's linux-hardened tree.
    
    Link: http://lkml.kernel.org/r/20170524155751.424-2-riel@redhat.com
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Daniel Micay <danielmicay@gmail.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index ed5c3838780d..1fa0dc880bd7 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -57,6 +57,27 @@ static inline unsigned long get_random_long(void)
 #endif
 }
 
+/*
+ * On 64-bit architectures, protect against non-terminated C string overflows
+ * by zeroing out the first byte of the canary; this leaves 56 bits of entropy.
+ */
+#ifdef CONFIG_64BIT
+# ifdef __LITTLE_ENDIAN
+#  define CANARY_MASK 0xffffffffffffff00UL
+# else /* big endian, 64 bits: */
+#  define CANARY_MASK 0x00ffffffffffffffUL
+# endif
+#else /* 32 bits: */
+# define CANARY_MASK 0xffffffffUL
+#endif
+
+static inline unsigned long get_random_canary(void)
+{
+	unsigned long val = get_random_long();
+
+	return val & CANARY_MASK;
+}
+
 unsigned long randomize_page(unsigned long start, unsigned long range);
 
 u32 prandom_u32(void);

commit da9ba564bd683374b8d319756f312821b8265b06
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 7 20:05:02 2017 -0400

    random: add get_random_{bytes,u32,u64,int,long,once}_wait family
    
    These functions are simple convenience wrappers that call
    wait_for_random_bytes before calling the respective get_random_*
    function.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index e29929347c95..4aecc339558d 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -58,6 +58,31 @@ static inline unsigned long get_random_long(void)
 #endif
 }
 
+/* Calls wait_for_random_bytes() and then calls get_random_bytes(buf, nbytes).
+ * Returns the result of the call to wait_for_random_bytes. */
+static inline int get_random_bytes_wait(void *buf, int nbytes)
+{
+	int ret = wait_for_random_bytes();
+	if (unlikely(ret))
+		return ret;
+	get_random_bytes(buf, nbytes);
+	return 0;
+}
+
+#define declare_get_random_var_wait(var) \
+	static inline int get_random_ ## var ## _wait(var *out) { \
+		int ret = wait_for_random_bytes(); \
+		if (unlikely(ret)) \
+			return ret; \
+		*out = get_random_ ## var(); \
+		return 0; \
+	}
+declare_get_random_var_wait(u32)
+declare_get_random_var_wait(u64)
+declare_get_random_var_wait(int)
+declare_get_random_var_wait(long)
+#undef declare_get_random_var
+
 unsigned long randomize_page(unsigned long start, unsigned long range);
 
 u32 prandom_u32(void);

commit e297a783e41560b44e3c14f38e420cba518113b8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Jun 7 19:58:56 2017 -0400

    random: add wait_for_random_bytes() API
    
    This enables users of get_random_{bytes,u32,u64,int,long} to wait until
    the pool is ready before using this function, in case they actually want
    to have reliable randomness.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index ed5c3838780d..e29929347c95 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -34,6 +34,7 @@ extern void add_input_randomness(unsigned int type, unsigned int code,
 extern void add_interrupt_randomness(int irq, int irq_flags) __latent_entropy;
 
 extern void get_random_bytes(void *buf, int nbytes);
+extern int wait_for_random_bytes(void);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);

commit c440408cf6901eeb2c09563397e24a9097907078
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Sun Jan 22 16:34:08 2017 +0100

    random: convert get_random_int/long into get_random_u32/u64
    
    Many times, when a user wants a random number, he wants a random number
    of a guaranteed size. So, thinking of get_random_int and get_random_long
    in terms of get_random_u32 and get_random_u64 makes it much easier to
    achieve this. It also makes the code simpler.
    
    On 32-bit platforms, get_random_int and get_random_long are both aliased
    to get_random_u32. On 64-bit platforms, int->u32 and long->u64.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 16ab429735a7..ed5c3838780d 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -42,8 +42,21 @@ extern void get_random_bytes_arch(void *buf, int nbytes);
 extern const struct file_operations random_fops, urandom_fops;
 #endif
 
-unsigned int get_random_int(void);
-unsigned long get_random_long(void);
+u32 get_random_u32(void);
+u64 get_random_u64(void);
+static inline unsigned int get_random_int(void)
+{
+	return get_random_u32();
+}
+static inline unsigned long get_random_long(void)
+{
+#if BITS_PER_LONG == 64
+	return get_random_u64();
+#else
+	return get_random_u32();
+#endif
+}
+
 unsigned long randomize_page(unsigned long start, unsigned long range);
 
 u32 prandom_u32(void);

commit f5b98461cb8167ba362ad9f74c41d126b7becea7
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jan 6 19:32:01 2017 +0100

    random: use chacha20 for get_random_int/long
    
    Now that our crng uses chacha20, we can rely on its speedy
    characteristics for replacing MD5, while simultaneously achieving a
    higher security guarantee. Before the idea was to use these functions if
    you wanted random integers that aren't stupidly insecure but aren't
    necessarily secure either, a vague gray zone, that hopefully was "good
    enough" for its users. With chacha20, we can strengthen this claim,
    since either we're using an rdrand-like instruction, or we're using the
    same crng as /dev/urandom. And it's faster than what was before.
    
    We could have chosen to replace this with a SipHash-derived function,
    which might be slightly faster, but at the cost of having yet another
    RNG construction in the kernel. By moving to chacha20, we have a single
    RNG to analyze and verify, and we also already get good performance
    improvements on all platforms.
    
    Implementation-wise, rather than use a generic buffer for both
    get_random_int/long and memcpy based on the size needs, we use a
    specific buffer for 32-bit reads and for 64-bit reads. This way, we're
    guaranteed to always have aligned accesses on all platforms. While
    slightly more verbose in C, the assembly this generates is a lot
    simpler than otherwise.
    
    Finally, on 32-bit platforms where longs and ints are the same size,
    we simply alias get_random_int to get_random_long.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Suggested-by: Theodore Ts'o <tytso@mit.edu>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 7bd2403e4fef..16ab429735a7 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -37,7 +37,6 @@ extern void get_random_bytes(void *buf, int nbytes);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);
-extern int random_int_secret_init(void);
 
 #ifndef MODULE
 extern const struct file_operations random_fops, urandom_fops;

commit 9ffc66941df278c9f4df979b6bcf6c6ddafedd16
Merge: 133d970e0dad 0766f788eb72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 15 10:03:15 2016 -0700

    Merge tag 'gcc-plugins-v4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull gcc plugins update from Kees Cook:
     "This adds a new gcc plugin named "latent_entropy". It is designed to
      extract as much possible uncertainty from a running system at boot
      time as possible, hoping to capitalize on any possible variation in
      CPU operation (due to runtime data differences, hardware differences,
      SMP ordering, thermal timing variation, cache behavior, etc).
    
      At the very least, this plugin is a much more comprehensive example
      for how to manipulate kernel code using the gcc plugin internals"
    
    * tag 'gcc-plugins-v4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      latent_entropy: Mark functions with __latent_entropy
      gcc-plugins: Add latent_entropy plugin

commit 7425154d3bbf5fcc7554738cab6dfac559ffbdda
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Oct 11 13:54:11 2016 -0700

    random: remove unused randomize_range()
    
    All call sites for randomize_range have been updated to use the much
    simpler and more robust randomize_addr().  Remove the now unnecessary
    code.
    
    Link: http://lkml.kernel.org/r/20160803233913.32511-8-jason@lakedaemon.net
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 26741892828a..f7bb7a355cf7 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -34,7 +34,6 @@ extern const struct file_operations random_fops, urandom_fops;
 
 unsigned int get_random_int(void);
 unsigned long get_random_long(void);
-unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 unsigned long randomize_page(unsigned long start, unsigned long range);
 
 u32 prandom_u32(void);

commit 99fdafdeacfa99ca9047641b684fa2aaf094a661
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Oct 11 13:53:52 2016 -0700

    random: simplify API for random address requests
    
    To date, all callers of randomize_range() have set the length to 0, and
    check for a zero return value.  For the current callers, the only way to
    get zero returned is if end <= start.  Since they are all adding a
    constant to the start address, this is unnecessary.
    
    We can remove a bunch of needless checks by simplifying the API to do just
    what everyone wants, return an address between [start, start + range).
    
    While we're here, s/get_random_int/get_random_long/.  No current call site
    is adversely affected by get_random_int(), since all current range
    requests are < UINT_MAX.  However, we should match caller expectations to
    avoid coming up short (ha!) in the future.
    
    All current callers to randomize_range() chose to use the start address if
    randomize_range() failed.  Therefore, we simplify things by just returning
    the start address on error.
    
    randomize_range() will be removed once all callers have been converted
    over to randomize_addr().
    
    Link: http://lkml.kernel.org/r/20160803233913.32511-2-jason@lakedaemon.net
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: "Roberts, William C" <william.c.roberts@intel.com>
    Cc: Yann Droneaud <ydroneaud@opteya.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H . Peter Anvin" <hpa@zytor.com>
    Cc: Nick Kralevich <nnk@google.com>
    Cc: Jeffrey Vander Stoep <jeffv@google.com>
    Cc: Daniel Cashman <dcashman@android.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 3d6e9815cd85..26741892828a 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -35,6 +35,7 @@ extern const struct file_operations random_fops, urandom_fops;
 unsigned int get_random_int(void);
 unsigned long get_random_long(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
+unsigned long randomize_page(unsigned long start, unsigned long range);
 
 u32 prandom_u32(void);
 void prandom_bytes(void *buf, size_t nbytes);

commit 0766f788eb727e2e330d55d30545db65bcf2623f
Author: Emese Revfy <re.emese@gmail.com>
Date:   Mon Jun 20 20:42:34 2016 +0200

    latent_entropy: Mark functions with __latent_entropy
    
    The __latent_entropy gcc attribute can be used only on functions and
    variables.  If it is on a function then the plugin will instrument it for
    gathering control-flow entropy. If the attribute is on a variable then
    the plugin will initialize it with random contents.  The variable must
    be an integer, an integer array type or a structure with integer fields.
    
    These specific functions have been selected because they are init
    functions (to help gather boot-time entropy), are called at unpredictable
    times, or they have variable loops, each of which provide some level of
    latent entropy.
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    [kees: expanded commit message]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index a59c74cdb1eb..d80a4388a4fd 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -30,8 +30,8 @@ static inline void add_latent_entropy(void) {}
 #endif
 
 extern void add_input_randomness(unsigned int type, unsigned int code,
-				 unsigned int value);
-extern void add_interrupt_randomness(int irq, int irq_flags);
+				 unsigned int value) __latent_entropy;
+extern void add_interrupt_randomness(int irq, int irq_flags) __latent_entropy;
 
 extern void get_random_bytes(void *buf, int nbytes);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);

commit 38addce8b600ca335dc86fa3d48c890f1c6fa1f4
Author: Emese Revfy <re.emese@gmail.com>
Date:   Mon Jun 20 20:41:19 2016 +0200

    gcc-plugins: Add latent_entropy plugin
    
    This adds a new gcc plugin named "latent_entropy". It is designed to
    extract as much possible uncertainty from a running system at boot time as
    possible, hoping to capitalize on any possible variation in CPU operation
    (due to runtime data differences, hardware differences, SMP ordering,
    thermal timing variation, cache behavior, etc).
    
    At the very least, this plugin is a much more comprehensive example for
    how to manipulate kernel code using the gcc plugin internals.
    
    The need for very-early boot entropy tends to be very architecture or
    system design specific, so this plugin is more suited for those sorts
    of special cases. The existing kernel RNG already attempts to extract
    entropy from reliable runtime variation, but this plugin takes the idea to
    a logical extreme by permuting a global variable based on any variation
    in code execution (e.g. a different value (and permutation function)
    is used to permute the global based on loop count, case statement,
    if/then/else branching, etc).
    
    To do this, the plugin starts by inserting a local variable in every
    marked function. The plugin then adds logic so that the value of this
    variable is modified by randomly chosen operations (add, xor and rol) and
    random values (gcc generates separate static values for each location at
    compile time and also injects the stack pointer at runtime). The resulting
    value depends on the control flow path (e.g., loops and branches taken).
    
    Before the function returns, the plugin mixes this local variable into
    the latent_entropy global variable. The value of this global variable
    is added to the kernel entropy pool in do_one_initcall() and _do_fork(),
    though it does not credit any bytes of entropy to the pool; the contents
    of the global are just used to mix the pool.
    
    Additionally, the plugin can pre-initialize arrays with build-time
    random contents, so that two different kernel builds running on identical
    hardware will not have the same starting values.
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    [kees: expanded commit message and code comments]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 3d6e9815cd85..a59c74cdb1eb 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -18,6 +18,17 @@ struct random_ready_callback {
 };
 
 extern void add_device_randomness(const void *, unsigned int);
+
+#if defined(CONFIG_GCC_PLUGIN_LATENT_ENTROPY) && !defined(__CHECKER__)
+static inline void add_latent_entropy(void)
+{
+	add_device_randomness((const void *)&latent_entropy,
+			      sizeof(latent_entropy));
+}
+#else
+static inline void add_latent_entropy(void) {}
+#endif
+
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq, int irq_flags);

commit 117780eef7740729e803bdcc0d5f2f48137ea8e3
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Wed Jun 8 12:38:38 2016 -0700

    x86, asm: use bool for bitops and other assembly outputs
    
    The gcc people have confirmed that using "bool" when combined with
    inline assembly always is treated as a byte-sized operand that can be
    assumed to be 0 or 1, which is exactly what the SET instruction
    emits.  Change the output types and intermediate variables of as many
    operations as practical to "bool".
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Link: http://lkml.kernel.org/r/1465414726-197858-3-git-send-email-hpa@linux.intel.com
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index e47e533742b5..3d6e9815cd85 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -95,27 +95,27 @@ static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 #ifdef CONFIG_ARCH_RANDOM
 # include <asm/archrandom.h>
 #else
-static inline int arch_get_random_long(unsigned long *v)
+static inline bool arch_get_random_long(unsigned long *v)
 {
 	return 0;
 }
-static inline int arch_get_random_int(unsigned int *v)
+static inline bool arch_get_random_int(unsigned int *v)
 {
 	return 0;
 }
-static inline int arch_has_random(void)
+static inline bool arch_has_random(void)
 {
 	return 0;
 }
-static inline int arch_get_random_seed_long(unsigned long *v)
+static inline bool arch_get_random_seed_long(unsigned long *v)
 {
 	return 0;
 }
-static inline int arch_get_random_seed_int(unsigned int *v)
+static inline bool arch_get_random_seed_int(unsigned int *v)
 {
 	return 0;
 }
-static inline int arch_has_random_seed(void)
+static inline bool arch_has_random_seed(void)
 {
 	return 0;
 }

commit 8da4b8c48e7b43cb16d05e1dbb34ad9f73ab7efd
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri May 20 17:01:00 2016 -0700

    lib/uuid.c: move generate_random_uuid() to uuid.c
    
    Let's gather the UUID related functions under one hood.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>
    Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 9c29122037f9..e47e533742b5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -26,7 +26,6 @@ extern void get_random_bytes(void *buf, int nbytes);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);
-void generate_random_uuid(unsigned char uuid_out[16]);
 extern int random_int_secret_init(void);
 
 #ifndef MODULE

commit ec9ee4acd97c0039a61c0ae4f12705767ae62153
Author: Daniel Cashman <dcashman@android.com>
Date:   Fri Feb 26 15:19:34 2016 -0800

    drivers: char: random: add get_random_long()
    
    Commit d07e22597d1d ("mm: mmap: add new /proc tunable for mmap_base
    ASLR") added the ability to choose from a range of values to use for
    entropy count in generating the random offset to the mmap_base address.
    
    The maximum value on this range was set to 32 bits for 64-bit x86
    systems, but this value could be increased further, requiring more than
    the 32 bits of randomness provided by get_random_int(), as is already
    possible for arm64.  Add a new function: get_random_long() which more
    naturally fits with the mmap usage of get_random_int() but operates
    exactly the same as get_random_int().
    
    Also, fix the shifting constant in mmap_rnd() to be an unsigned long so
    that values greater than 31 bits generate an appropriate mask without
    overflow.  This is especially important on x86, as its shift instruction
    uses a 5-bit mask for the shift operand, which meant that any value for
    mmap_rnd_bits over 31 acts as a no-op and effectively disables mmap_base
    randomization.
    
    Finally, replace calls to get_random_int() with get_random_long() where
    appropriate.
    
    This patch (of 2):
    
    Add get_random_long().
    
    Signed-off-by: Daniel Cashman <dcashman@android.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Nick Kralevich <nnk@google.com>
    Cc: Jeff Vander Stoep <jeffv@google.com>
    Cc: Mark Salyzyn <salyzyn@android.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index a75840c1aa71..9c29122037f9 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -34,6 +34,7 @@ extern const struct file_operations random_fops, urandom_fops;
 #endif
 
 unsigned int get_random_int(void);
+unsigned long get_random_long(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 
 u32 prandom_u32(void);

commit 897ece56e714a2cc64e6914cb89a362d7021b36e
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Oct 8 01:20:38 2015 +0200

    random32: add prandom_init_once helper for own rngs
    
    Add a prandom_init_once() facility that works on the rnd_state, so that
    users that are keeping their own state independent from prandom_u32() can
    initialize their taus113 per cpu states.
    
    The motivation here is similar to net_get_random_once(): initialize the
    state as late as possible in the hope that enough entropy has been
    collected for the seeding. prandom_init_once() makes use of the recently
    introduced prandom_seed_full_state() helper and is generic enough so that
    it could also be used on fast-paths due to the DO_ONCE().
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index e651874df2c9..a75840c1aa71 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -7,6 +7,8 @@
 #define _LINUX_RANDOM_H
 
 #include <linux/list.h>
+#include <linux/once.h>
+
 #include <uapi/linux/random.h>
 
 struct random_ready_callback {
@@ -45,6 +47,10 @@ struct rnd_state {
 
 u32 prandom_u32_state(struct rnd_state *state);
 void prandom_bytes_state(struct rnd_state *state, void *buf, size_t nbytes);
+void prandom_seed_full_state(struct rnd_state __percpu *pcpu_state);
+
+#define prandom_init_once(pcpu_state)			\
+	DO_ONCE(prandom_seed_full_state, (pcpu_state))
 
 /**
  * prandom_u32_max - returns a pseudo-random number in interval [0, ep_ro)

commit c2719503f5e1e6213d716bb078bdad01e28ebcbf
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Jun 9 18:19:42 2015 +0800

    random: Remove kernel blocking API
    
    This patch removes the kernel blocking API as it has been completely
    replaced by the callback API.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/random.h b/include/linux/random.h
index 30e2aca0b16a..e651874df2c9 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -21,7 +21,6 @@ extern void add_input_randomness(unsigned int type, unsigned int code,
 extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
-extern void get_blocking_random_bytes(void *buf, int nbytes);
 extern int add_random_ready_callback(struct random_ready_callback *rdy);
 extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);

commit 205a525c334295e3cd4cc7755fd2c0398e3a787f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Jun 9 18:19:39 2015 +0800

    random: Add callback API for random pool readiness
    
    The get_blocking_random_bytes API is broken because the wait can
    be arbitrarily long (potentially forever) so there is no safe way
    of calling it from within the kernel.
    
    This patch replaces it with a callback API instead.  The callback
    is invoked potentially from interrupt context so the user needs
    to schedule their own work thread if necessary.
    
    In addition to adding callbacks, they can also be removed as
    otherwise this opens up a way for user-space to allocate kernel
    memory with no bound (by opening algif_rng descriptors and then
    closing them).
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/random.h b/include/linux/random.h
index 796267d56901..30e2aca0b16a 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -6,8 +6,15 @@
 #ifndef _LINUX_RANDOM_H
 #define _LINUX_RANDOM_H
 
+#include <linux/list.h>
 #include <uapi/linux/random.h>
 
+struct random_ready_callback {
+	struct list_head list;
+	void (*func)(struct random_ready_callback *rdy);
+	struct module *owner;
+};
+
 extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
@@ -15,6 +22,8 @@ extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
 extern void get_blocking_random_bytes(void *buf, int nbytes);
+extern int add_random_ready_callback(struct random_ready_callback *rdy);
+extern void del_random_ready_callback(struct random_ready_callback *rdy);
 extern void get_random_bytes_arch(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 extern int random_int_secret_init(void);

commit 16b369a91d0dd80be214b7f7801fbc51875454cc
Author: Stephan Mueller <smueller@chronox.de>
Date:   Mon May 25 15:08:47 2015 +0200

    random: Blocking API for accessing nonblocking_pool
    
    The added API calls provide a synchronous function call
    get_blocking_random_bytes where the caller is blocked until
    the nonblocking_pool is initialized.
    
    CC: Andreas Steffen <andreas.steffen@strongswan.org>
    CC: Theodore Ts'o <tytso@mit.edu>
    CC: Sandy Harris <sandyinchina@gmail.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/random.h b/include/linux/random.h
index b05856e16b75..796267d56901 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -14,6 +14,7 @@ extern void add_input_randomness(unsigned int type, unsigned int code,
 extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
+extern void get_blocking_random_bytes(void *buf, int nbytes);
 extern void get_random_bytes_arch(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 extern int random_int_secret_init(void);

commit a98406e22c12e514bac28fec0a49dc793edaf3a8
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Sat Aug 23 17:03:28 2014 +0200

    random32: improvements to prandom_bytes
    
    This patch addresses a couple of minor items, mostly addesssing
    prandom_bytes(): 1) prandom_bytes{,_state}() should use size_t
    for length arguments, 2) We can use put_unaligned() when filling
    the array instead of open coding it [ perhaps some archs will
    further benefit from their own arch specific implementation when
    GCC cannot make up for it ], 3) Fix a typo, 4) Better use unsigned
    int as type for getting the arch seed, 5) Make use of
    prandom_u32_max() for timer slack.
    
    Regarding the change to put_unaligned(), callers of prandom_bytes()
    which internally invoke prandom_bytes_state(), don't bother as
    they expect the array to be filled randomly and don't have any
    control of the internal state what-so-ever (that's also why we
    have periodic reseeding there, etc), so they really don't care.
    
    Now for the direct callers of prandom_bytes_state(), which
    are solely located in test cases for MTD devices, that is,
    drivers/mtd/tests/{oobtest.c,pagetest.c,subpagetest.c}:
    
    These tests basically fill a test write-vector through
    prandom_bytes_state() with an a-priori defined seed each time
    and write that to a MTD device. Later on, they set up a read-vector
    and read back that blocks from the device. So in the verification
    phase, the write-vector is being re-setup [ so same seed and
    prandom_bytes_state() called ], and then memcmp()'ed against the
    read-vector to check if the data is the same.
    
    Akinobu, Lothar and I also tested this patch and it runs through
    the 3 relevant MTD test cases w/o any errors on the nandsim device
    (simulator for MTD devs) for x86_64, ppc64, ARM (i.MX28, i.MX53
    and i.MX6):
    
      # modprobe nandsim first_id_byte=0x20 second_id_byte=0xac \
                         third_id_byte=0x00 fourth_id_byte=0x15
      # modprobe mtd_oobtest dev=0
      # modprobe mtd_pagetest dev=0
      # modprobe mtd_subpagetest dev=0
    
    We also don't have any users depending directly on a particular
    result of the PRNG (except the PRNG self-test itself), and that's
    just fine as it e.g. allowed us easily to do things like upgrading
    from taus88 to taus113.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Tested-by: Akinobu Mita <akinobu.mita@gmail.com>
    Tested-by: Lothar Waßmann <LW@KARO-electronics.de>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 57fbbffd77a0..b05856e16b75 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -26,7 +26,7 @@ unsigned int get_random_int(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 
 u32 prandom_u32(void);
-void prandom_bytes(void *buf, int nbytes);
+void prandom_bytes(void *buf, size_t nbytes);
 void prandom_seed(u32 seed);
 void prandom_reseed_late(void);
 
@@ -35,7 +35,7 @@ struct rnd_state {
 };
 
 u32 prandom_u32_state(struct rnd_state *state);
-void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
+void prandom_bytes_state(struct rnd_state *state, void *buf, size_t nbytes);
 
 /**
  * prandom_u32_max - returns a pseudo-random number in interval [0, ep_ro)

commit 7b878d4b48c4e04b936918bb83836a107ba453b3
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Mon Mar 17 16:36:30 2014 -0700

    random: Add arch_has_random[_seed]()
    
    Add predicate functions for having arch_get_random[_seed]*().  The
    only current use is to avoid the loop in arch_random_refill() when
    arch_get_random_seed_long() is unavailable.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index c2f08131050d..57fbbffd77a0 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -88,6 +88,10 @@ static inline int arch_get_random_int(unsigned int *v)
 {
 	return 0;
 }
+static inline int arch_has_random(void)
+{
+	return 0;
+}
 static inline int arch_get_random_seed_long(unsigned long *v)
 {
 	return 0;
@@ -96,6 +100,10 @@ static inline int arch_get_random_seed_int(unsigned int *v)
 {
 	return 0;
 }
+static inline int arch_has_random_seed(void)
+{
+	return 0;
+}
 #endif
 
 /* Pseudo random number generator from numerical recipes. */

commit d20f78d252778e0fae8f8256e602bd682eb2185c
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Mon Mar 17 16:36:27 2014 -0700

    x86, random: Enable the RDSEED instruction
    
    Upcoming Intel silicon adds a new RDSEED instruction, which is similar
    to RDRAND but provides a stronger guarantee: unlike RDRAND, RDSEED
    will always reseed the PRNG from the true random number source between
    each read.  Thus, the output of RDSEED is guaranteed to be 100%
    entropic, unlike RDRAND which is only architecturally guaranteed to be
    1/512 entropic (although in practice is much more.)
    
    The RDSEED instruction takes the same time to execute as RDRAND, but
    RDSEED unlike RDRAND can legitimately return failure (CF=0) due to
    entropy exhaustion if too many threads on too many cores are hammering
    the RDSEED instruction at the same time.  Therefore, we have to be
    more conservative and only use it in places where we can tolerate
    failures.
    
    This patch introduces the primitives arch_get_random_seed_{int,long}()
    but does not use it yet.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 1cfce0e24dbd..c2f08131050d 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -88,6 +88,14 @@ static inline int arch_get_random_int(unsigned int *v)
 {
 	return 0;
 }
+static inline int arch_get_random_seed_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_seed_int(unsigned int *v)
+{
+	return 0;
+}
 #endif
 
 /* Pseudo random number generator from numerical recipes. */

commit f337db64af059c9a94278a8b0ab97d87259ff62f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Jan 22 02:29:39 2014 +0100

    random32: add prandom_u32_max and convert open coded users
    
    Many functions have open coded a function that returns a random
    number in range [0,N-1]. Under the assumption that we have a PRNG
    such as taus113 with being well distributed in [0, ~0U] space,
    we can implement such a function as uword t = (n*m')>>32, where
    m' is a random number obtained from PRNG, n the right open interval
    border and t our resulting random number, with n,m',t in u32 universe.
    
    Lets go with Joe and simply call it prandom_u32_max(), although
    technically we have an right open interval endpoint, but that we
    have documented. Other users can further be migrated to the new
    prandom_u32_max() function later on; for now, we need to make sure
    to migrate reciprocal_divide() users for the reciprocal_divide()
    follow-up fixup since their function signatures are going to change.
    
    Joint work with Hannes Frederic Sowa.
    
    Cc: Jakub Zawadzki <darkjames-ws@darkjames.pl>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 4002b3df4c85..1cfce0e24dbd 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -8,7 +8,6 @@
 
 #include <uapi/linux/random.h>
 
-
 extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
@@ -38,6 +37,23 @@ struct rnd_state {
 u32 prandom_u32_state(struct rnd_state *state);
 void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
 
+/**
+ * prandom_u32_max - returns a pseudo-random number in interval [0, ep_ro)
+ * @ep_ro: right open interval endpoint
+ *
+ * Returns a pseudo-random number that is in interval [0, ep_ro). Note
+ * that the result depends on PRNG being well distributed in [0, ~0U]
+ * u32 space. Here we use maximally equidistributed combined Tausworthe
+ * generator, that is, prandom_u32(). This is useful when requesting a
+ * random index of an array containing ep_ro elements, for example.
+ *
+ * Returns: pseudo-random number in interval [0, ep_ro)
+ */
+static inline u32 prandom_u32_max(u32 ep_ro)
+{
+	return (u32)(((u64) prandom_u32() * ep_ro) >> 32);
+}
+
 /*
  * Handle minimum values for seeds
  */

commit a98814cef87946d2708812ad9f8b1e03b8366b6f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Nov 11 12:20:36 2013 +0100

    random32: upgrade taus88 generator to taus113 from errata paper
    
    Since we use prandom*() functions quite often in networking code
    i.e. in UDP port selection, netfilter code, etc, upgrade the PRNG
    from Pierre L'Ecuyer's original paper "Maximally Equidistributed
    Combined Tausworthe Generators", Mathematics of Computation, 65,
    213 (1996), 203--213 to the version published in his errata paper [1].
    
    The Tausworthe generator is a maximally-equidistributed generator,
    that is fast and has good statistical properties [1].
    
    The version presented there upgrades the 3 state LFSR to a 4 state
    LFSR with increased periodicity from about 2^88 to 2^113. The
    algorithm is presented in [1] by the very same author who also
    designed the original algorithm in [2].
    
    Also, by increasing the state, we make it a bit harder for attackers
    to "guess" the PRNGs internal state. See also discussion in [3].
    
    Now, as we use this sort of weak initialization discussed in [3]
    only between core_initcall() until late_initcall() time [*] for
    prandom32*() users, namely in prandom_init(), it is less relevant
    from late_initcall() onwards as we overwrite seeds through
    prandom_reseed() anyways with a seed source of higher entropy, that
    is, get_random_bytes(). In other words, a exhaustive keysearch of
    96 bit would be needed. Now, with the help of this patch, this
    state-search increases further to 128 bit. Initialization needs
    to make sure that s1 > 1, s2 > 7, s3 > 15, s4 > 127.
    
    taus88 and taus113 algorithm is also part of GSL. I added a test
    case in the next patch to verify internal behaviour of this patch
    with GSL and ran tests with the dieharder 3.31.1 RNG test suite:
    
    $ dieharder -g 052 -a -m 10 -s 1 -S 4137730333 #taus88
    $ dieharder -g 054 -a -m 10 -s 1 -S 4137730333 #taus113
    
    With this seed configuration, in order to compare both, we get
    the following differences:
    
    algorithm                 taus88           taus113
    rands/second [**]         1.61e+08         1.37e+08
    sts_serial(4, 1st run)    WEAK             PASSED
    sts_serial(9, 2nd run)    WEAK             PASSED
    rgb_lagged_sum(31)        WEAK             PASSED
    
    We took out diehard_sums test as according to the authors it is
    considered broken and unusable [4]. Despite that and the slight
    decrease in performance (which is acceptable), taus113 here passes
    all 113 tests (only rgb_minimum_distance_5 in WEAK, the rest PASSED).
    In general, taus/taus113 is considered "very good" by the authors
    of dieharder [5].
    
    The papers [1][2] states a single warm-up step is sufficient by
    running quicktaus once on each state to ensure proper initialization
    of ~s_{0}:
    
    Our selection of (s) according to Table 1 of [1] row 1 holds the
    condition L - k <= r - s, that is,
    
      (32 32 32 32) - (31 29 28 25) <= (25 27 15 22) - (18 2 7 13)
    
    with r = k - q and q = (6 2 13 3) as also stated by the paper.
    So according to [2] we are safe with one round of quicktaus for
    initialization. However we decided to include the warm-up phase
    of the PRNG as done in GSL in every case as a safety net. We also
    use the warm up phase to make the output of the RNG easier to
    verify by the GSL output.
    
    In prandom_init(), we also mix random_get_entropy() into it, just
    like drivers/char/random.c does it, jiffies ^ random_get_entropy().
    random-get_entropy() is get_cycles(). xor is entropy preserving so
    it is fine if it is not implemented by some architectures.
    
    Note, this PRNG is *not* used for cryptography in the kernel, but
    rather as a fast PRNG for various randomizations i.e. in the
    networking code, or elsewhere for debugging purposes, for example.
    
    [*]: In order to generate some "sort of pseduo-randomness", since
    get_random_bytes() is not yet available for us, we use jiffies and
    initialize states s1 - s3 with a simple linear congruential generator
    (LCG), that is x <- x * 69069; and derive s2, s3, from the 32bit
    initialization from s1. So the above quote from [3] accounts only
    for the time from core to late initcall, not afterwards.
    [**] Single threaded run on MacBook Air w/ Intel Core i5-3317U
    
     [1] http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
     [2] http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
     [3] http://thread.gmane.org/gmane.comp.encryption.general/12103/
     [4] http://code.google.com/p/dieharder/source/browse/trunk/libdieharder/diehard_sums.c?spec=svn490&r=490#20
     [5] http://www.phy.duke.edu/~rgb/General/dieharder.php
    
    Joint work with Hannes Frederic Sowa.
    
    Cc: Florian Weimer <fweimer@redhat.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 8ef0b70bd1f9..4002b3df4c85 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -32,10 +32,10 @@ void prandom_seed(u32 seed);
 void prandom_reseed_late(void);
 
 struct rnd_state {
-	__u32 s1, s2, s3;
+	__u32 s1, s2, s3, s4;
 };
 
-u32 prandom_u32_state(struct rnd_state *);
+u32 prandom_u32_state(struct rnd_state *state);
 void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
 
 /*
@@ -55,9 +55,10 @@ static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 {
 	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
 
-	state->s1 = __seed(i, 2);
-	state->s2 = __seed(i, 8);
-	state->s3 = __seed(i, 16);
+	state->s1 = __seed(i,   2U);
+	state->s2 = __seed(i,   8U);
+	state->s3 = __seed(i,  16U);
+	state->s4 = __seed(i, 128U);
 }
 
 #ifdef CONFIG_ARCH_RANDOM

commit 38e9efcdb33270b4da72143d8e7ca4dcf7f0989b
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Nov 11 12:20:35 2013 +0100

    random32: move rnd_state to linux/random.h
    
    struct rnd_state got mistakenly pulled into uapi header. It is not
    used anywhere and does also not belong there!
    
    Commit 5960164fde ("lib/random32: export pseudo-random number
    generator for modules"), the last commit on rnd_state before it
    got moved to uapi, says:
    
      This patch moves the definition of struct rnd_state and the inline
      __seed() function to linux/random.h.  It renames the static __random32()
      function to prandom32() and exports it for use in modules.
    
    Hence, the structure was moved from lib/random32.c to linux/random.h
    so that it can be used within modules (FCoE-related code in this
    case), but not from user space. However, it seems to have been
    mistakenly moved to uapi header through the uapi script. Since no-one
    should make use of it from the linux headers, move the structure back
    to the kernel for internal use, so that it can be modified on demand.
    
    Joint work with Hannes Frederic Sowa.
    
    Cc: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 5117ae348fe8..8ef0b70bd1f9 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -31,6 +31,10 @@ void prandom_bytes(void *buf, int nbytes);
 void prandom_seed(u32 seed);
 void prandom_reseed_late(void);
 
+struct rnd_state {
+	__u32 s1, s2, s3;
+};
+
 u32 prandom_u32_state(struct rnd_state *);
 void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
 

commit 4af712e8df998475736f3e2727701bd31e3751a9
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Nov 11 12:20:34 2013 +0100

    random32: add prandom_reseed_late() and call when nonblocking pool becomes initialized
    
    The Tausworthe PRNG is initialized at late_initcall time. At that time the
    entropy pool serving get_random_bytes is not filled sufficiently. This
    patch adds an additional reseeding step as soon as the nonblocking pool
    gets marked as initialized.
    
    On some machines it might be possible that late_initcall gets called after
    the pool has been initialized. In this situation we won't reseed again.
    
    (A call to prandom_seed_late blocks later invocations of early reseed
    attempts.)
    
    Joint work with Daniel Borkmann.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index bf9085e89fb5..5117ae348fe8 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -29,6 +29,7 @@ unsigned long randomize_range(unsigned long start, unsigned long end, unsigned l
 u32 prandom_u32(void);
 void prandom_bytes(void *buf, int nbytes);
 void prandom_seed(u32 seed);
+void prandom_reseed_late(void);
 
 u32 prandom_u32_state(struct rnd_state *);
 void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);

commit 51c37a70aaa3f95773af560e6db3073520513912
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Nov 11 12:20:32 2013 +0100

    random32: fix off-by-one in seeding requirement
    
    For properly initialising the Tausworthe generator [1], we have
    a strict seeding requirement, that is, s1 > 1, s2 > 7, s3 > 15.
    
    Commit 697f8d0348 ("random32: seeding improvement") introduced
    a __seed() function that imposes boundary checks proposed by the
    errata paper [2] to properly ensure above conditions.
    
    However, we're off by one, as the function is implemented as:
    "return (x < m) ? x + m : x;", and called with __seed(X, 1),
    __seed(X, 7), __seed(X, 15). Thus, an unwanted seed of 1, 7, 15
    would be possible, whereas the lower boundary should actually
    be of at least 2, 8, 16, just as GSL does. Fix this, as otherwise
    an initialization with an unwanted seed could have the effect
    that Tausworthe's PRNG properties cannot not be ensured.
    
    Note that this PRNG is *not* used for cryptography in the kernel.
    
     [1] http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps
     [2] http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps
    
    Joint work with Hannes Frederic Sowa.
    
    Fixes: 697f8d0348a6 ("random32: seeding improvement")
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Florian Weimer <fweimer@redhat.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 6312dd9ba449..bf9085e89fb5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -50,9 +50,9 @@ static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 {
 	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
 
-	state->s1 = __seed(i, 1);
-	state->s2 = __seed(i, 7);
-	state->s3 = __seed(i, 15);
+	state->s1 = __seed(i, 2);
+	state->s2 = __seed(i, 8);
+	state->s3 = __seed(i, 16);
 }
 
 #ifdef CONFIG_ARCH_RANDOM

commit 47d06e532e95b71c0db3839ebdef3fe8812fca2c
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue Sep 10 10:52:35 2013 -0400

    random: run random_int_secret_init() run after all late_initcalls
    
    The some platforms (e.g., ARM) initializes their clocks as
    late_initcalls for some unknown reason.  So make sure
    random_int_secret_init() is run after all of the late_initcalls are
    run.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 3b9377d6b7a5..6312dd9ba449 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -17,6 +17,7 @@ extern void add_interrupt_randomness(int irq, int irq_flags);
 extern void get_random_bytes(void *buf, int nbytes);
 extern void get_random_bytes_arch(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
+extern int random_int_secret_init(void);
 
 #ifndef MODULE
 extern const struct file_operations random_fops, urandom_fops;

commit 22ea9c070350b824d6c3b65bce06ee7c6cc87b99
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue May 7 16:18:17 2013 -0700

    remove unused random32() and srandom32()
    
    After finishing a naming transition, remove unused backward
    compatibility wrapper macros
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 347ce553a306..3b9377d6b7a5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -29,13 +29,6 @@ u32 prandom_u32(void);
 void prandom_bytes(void *buf, int nbytes);
 void prandom_seed(u32 seed);
 
-/*
- * These macros are preserved for backward compatibility and should be
- * removed as soon as a transition is finished.
- */
-#define random32() prandom_u32()
-#define srandom32(seed) prandom_seed(seed)
-
 u32 prandom_u32_state(struct rnd_state *);
 void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
 

commit 055dc21a1d1d219608cd4baac7d0683fb2cbbe8a
Author: Tom Herbert <therbert@google.com>
Date:   Tue Jan 22 09:49:50 2013 +0000

    soreuseport: infrastructure
    
    Definitions and macros for implementing soreusport.
    
    Signed-off-by: Tom Herbert <therbert@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index d9846088c2c5..347ce553a306 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -74,4 +74,10 @@ static inline int arch_get_random_int(unsigned int *v)
 }
 #endif
 
+/* Pseudo random number generator from numerical recipes. */
+static inline u32 next_pseudo_random32(u32 seed)
+{
+	return seed * 1664525 + 1013904223;
+}
+
 #endif /* _LINUX_RANDOM_H */

commit 6582c665d6b882dad8329e05749fbcf119f1ab88
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Dec 17 16:04:25 2012 -0800

    prandom: introduce prandom_bytes() and prandom_bytes_state()
    
    Add functions to get the requested number of pseudo-random bytes.
    
    The difference from get_random_bytes() is that it generates pseudo-random
    numbers by prandom_u32().  It doesn't consume the entropy pool, and the
    sequence is reproducible if the same rnd_state is used.  So it is suitable
    for generating random bytes for testing.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Eilon Greenstein <eilong@broadcom.com>
    Cc: David Laight <david.laight@aculab.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Robert Love <robert.w.love@intel.com>
    Cc: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index db6debc6649e..d9846088c2c5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -26,6 +26,7 @@ unsigned int get_random_int(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 
 u32 prandom_u32(void);
+void prandom_bytes(void *buf, int nbytes);
 void prandom_seed(u32 seed);
 
 /*
@@ -36,6 +37,7 @@ void prandom_seed(u32 seed);
 #define srandom32(seed) prandom_seed(seed)
 
 u32 prandom_u32_state(struct rnd_state *);
+void prandom_bytes_state(struct rnd_state *state, void *buf, int nbytes);
 
 /*
  * Handle minimum values for seeds

commit 496f2f93b1cc286f5a4f4f9acdc1e5314978683f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Dec 17 16:04:23 2012 -0800

    random32: rename random32 to prandom
    
    This renames all random32 functions to have 'prandom_' prefix as follows:
    
      void prandom_seed(u32 seed);  /* rename from srandom32() */
      u32 prandom_u32(void);                /* rename from random32() */
      void prandom_seed_state(struct rnd_state *state, u64 seed);
                                    /* rename from prandom32_seed() */
      u32 prandom_u32_state(struct rnd_state *state);
                                    /* rename from prandom32() */
    
    The purpose of this renaming is to prevent some kernel developers from
    assuming that prandom32() and random32() might imply that only
    prandom32() was the one using a pseudo-random number generator by
    prandom32's "p", and the result may be a very embarassing security
    exposure.  This concern was expressed by Theodore Ts'o.
    
    And furthermore, I'm going to introduce new functions for getting the
    requested number of pseudo-random bytes.  If I continue to use both
    prandom32 and random32 prefixes for these functions, the confusion
    is getting worse.
    
    As a result of this renaming, "prandom_" is the common prefix for
    pseudo-random number library.
    
    Currently, srandom32() and random32() are preserved because it is
    difficult to rename too many users at once.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Robert Love <robert.w.love@intel.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Cc: David Laight <david.laight@aculab.com>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Eilon Greenstein <eilong@broadcom.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 6330ed47b38b..db6debc6649e 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -25,10 +25,17 @@ extern const struct file_operations random_fops, urandom_fops;
 unsigned int get_random_int(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 
-u32 random32(void);
-void srandom32(u32 seed);
+u32 prandom_u32(void);
+void prandom_seed(u32 seed);
 
-u32 prandom32(struct rnd_state *);
+/*
+ * These macros are preserved for backward compatibility and should be
+ * removed as soon as a transition is finished.
+ */
+#define random32() prandom_u32()
+#define srandom32(seed) prandom_seed(seed)
+
+u32 prandom_u32_state(struct rnd_state *);
 
 /*
  * Handle minimum values for seeds
@@ -39,11 +46,11 @@ static inline u32 __seed(u32 x, u32 m)
 }
 
 /**
- * prandom32_seed - set seed for prandom32().
+ * prandom_seed_state - set seed for prandom_u32_state().
  * @state: pointer to state structure to receive the seed.
  * @seed: arbitrary 64-bit value to use as a seed.
  */
-static inline void prandom32_seed(struct rnd_state *state, u64 seed)
+static inline void prandom_seed_state(struct rnd_state *state, u64 seed)
 {
 	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/random.h b/include/linux/random.h
index ac621ce886ca..6330ed47b38b 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -3,50 +3,11 @@
  *
  * Include file for the random number generator.
  */
-
 #ifndef _LINUX_RANDOM_H
 #define _LINUX_RANDOM_H
 
-#include <linux/types.h>
-#include <linux/ioctl.h>
-#include <linux/irqnr.h>
-
-/* ioctl()'s for the random number generator */
-
-/* Get the entropy count. */
-#define RNDGETENTCNT	_IOR( 'R', 0x00, int )
-
-/* Add to (or subtract from) the entropy count.  (Superuser only.) */
-#define RNDADDTOENTCNT	_IOW( 'R', 0x01, int )
-
-/* Get the contents of the entropy pool.  (Superuser only.) */
-#define RNDGETPOOL	_IOR( 'R', 0x02, int [2] )
-
-/* 
- * Write bytes into the entropy pool and add to the entropy count.
- * (Superuser only.)
- */
-#define RNDADDENTROPY	_IOW( 'R', 0x03, int [2] )
+#include <uapi/linux/random.h>
 
-/* Clear entropy count to 0.  (Superuser only.) */
-#define RNDZAPENTCNT	_IO( 'R', 0x04 )
-
-/* Clear the entropy pool and associated counters.  (Superuser only.) */
-#define RNDCLEARPOOL	_IO( 'R', 0x06 )
-
-struct rand_pool_info {
-	int	entropy_count;
-	int	buf_size;
-	__u32	buf[0];
-};
-
-struct rnd_state {
-	__u32 s1, s2, s3;
-};
-
-/* Exported functions */
-
-#ifdef __KERNEL__
 
 extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
@@ -104,6 +65,4 @@ static inline int arch_get_random_int(unsigned int *v)
 }
 #endif
 
-#endif /* __KERNEL___ */
-
 #endif /* _LINUX_RANDOM_H */

commit c5857ccf293968348e5eb4ebedc68074de3dcda6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Jul 14 20:27:52 2012 -0400

    random: remove rand_initialize_irq()
    
    With the new interrupt sampling system, we are no longer using the
    timer_rand_state structure in the irq descriptor, so we can stop
    initializing it now.
    
    [ Merged in fixes from Sedat to find some last missing references to
      rand_initialize_irq() ]
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Sedat Dilek <sedat.dilek@gmail.com>

diff --git a/include/linux/random.h b/include/linux/random.h
index 29e217a7e6d0..ac621ce886ca 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -48,8 +48,6 @@ struct rnd_state {
 
 #ifdef __KERNEL__
 
-extern void rand_initialize_irq(int irq);
-
 extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);

commit c2557a303ab6712bb6e09447df828c557c710ac9
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Jul 5 10:35:23 2012 -0400

    random: add new get_random_bytes_arch() function
    
    Create a new function, get_random_bytes_arch() which will use the
    architecture-specific hardware random number generator if it is
    present.  Change get_random_bytes() to not use the HW RNG, even if it
    is avaiable.
    
    The reason for this is that the hw random number generator is fast (if
    it is present), but it requires that we trust the hardware
    manufacturer to have not put in a back door.  (For example, an
    increasing counter encrypted by an AES key known to the NSA.)
    
    It's unlikely that Intel (for example) was paid off by the US
    Government to do this, but it's impossible for them to prove otherwise
    --- especially since Bull Mountain is documented to use AES as a
    whitener.  Hence, the output of an evil, trojan-horse version of
    RDRAND is statistically indistinguishable from an RDRAND implemented
    to the specifications claimed by Intel.  Short of using a tunnelling
    electronic microscope to reverse engineer an Ivy Bridge chip and
    disassembling and analyzing the CPU microcode, there's no way for us
    to tell for sure.
    
    Since users of get_random_bytes() in the Linux kernel need to be able
    to support hardware systems where the HW RNG is not present, most
    time-sensitive users of this interface have already created their own
    cryptographic RNG interface which uses get_random_bytes() as a seed.
    So it's much better to use the HW RNG to improve the existing random
    number generator, by mixing in any entropy returned by the HW RNG into
    /dev/random's entropy pool, but to always _use_ /dev/random's entropy
    pool.
    
    This way we get almost of the benefits of the HW RNG without any
    potential liabilities.  The only benefits we forgo is the
    speed/performance enhancements --- and generic kernel code can't
    depend on depend on get_random_bytes() having the speed of a HW RNG
    anyway.
    
    For those places that really want access to the arch-specific HW RNG,
    if it is available, we provide get_random_bytes_arch().
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/random.h b/include/linux/random.h
index e14b4387354a..29e217a7e6d0 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -56,6 +56,7 @@ extern void add_input_randomness(unsigned int type, unsigned int code,
 extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
+extern void get_random_bytes_arch(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
 #ifndef MODULE

commit a2080a67abe9e314f9e9c2cc3a4a176e8a8f8793
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 4 11:16:01 2012 -0400

    random: create add_device_randomness() interface
    
    Add a new interface, add_device_randomness() for adding data to the
    random pool that is likely to differ between two devices (or possibly
    even per boot).  This would be things like MAC addresses or serial
    numbers, or the read-out of the RTC. This does *not* add any actual
    entropy to the pool, but it initializes the pool to different values
    for devices that might otherwise be identical and have very little
    entropy available to them (particularly common in the embedded world).
    
    [ Modified by tytso to mix in a timestamp, since there may be some
      variability caused by the time needed to detect/configure the hardware
      in question. ]
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/random.h b/include/linux/random.h
index 6ef39d7f2db1..e14b4387354a 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -50,6 +50,7 @@ struct rnd_state {
 
 extern void rand_initialize_irq(int irq);
 
+extern void add_device_randomness(const void *, unsigned int);
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq, int irq_flags);

commit 775f4b297b780601e61787b766f306ed3e1d23eb
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Mon Jul 2 07:52:16 2012 -0400

    random: make 'add_interrupt_randomness()' do something sane
    
    We've been moving away from add_interrupt_randomness() for various
    reasons: it's too expensive to do on every interrupt, and flooding the
    CPU with interrupts could theoretically cause bogus floods of entropy
    from a somewhat externally controllable source.
    
    This solves both problems by limiting the actual randomness addition
    to just once a second or after 64 interrupts, whicever comes first.
    During that time, the interrupt cycle data is buffered up in a per-cpu
    pool.  Also, we make sure the the nonblocking pool used by urandom is
    initialized before we start feeding the normal input pool.  This
    assures that /dev/urandom is returning unpredictable data as soon as
    possible.
    
    (Based on an original patch by Linus, but significantly modified by
    tytso.)
    
    Tested-by: Eric Wustrow <ewust@umich.edu>
    Reported-by: Eric Wustrow <ewust@umich.edu>
    Reported-by: Nadia Heninger <nadiah@cs.ucsd.edu>
    Reported-by: Zakir Durumeric <zakir@umich.edu>
    Reported-by: J. Alex Halderman <jhalderm@umich.edu>.
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/random.h b/include/linux/random.h
index 8f74538c96db..6ef39d7f2db1 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -52,7 +52,7 @@ extern void rand_initialize_irq(int irq);
 
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
-extern void add_interrupt_randomness(int irq);
+extern void add_interrupt_randomness(int irq, int irq_flags);
 
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);

commit 8e6d539e0fd0c2124a20a207da70f2af7a9ae52c
Merge: 8237eb946a1a 49d859d78c5a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 05:29:07 2011 -0700

    Merge branch 'x86-rdrand-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'x86-rdrand-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86, random: Verify RDRAND functionality and allow it to be disabled
      x86, random: Architectural inlines to get random integers with RDRAND
      random: Add support for architectural random hooks
    
    Fix up trivial conflicts in drivers/char/random.c: the architectural
    random hooks touched "get_random_int()" that was simplified to use MD5
    and not do the keyptr thing any more (see commit 6e5714eaf77d: "net:
    Compute protocol sequence numbers and fragment IDs using MD5").

commit 6e5714eaf77d79ae1c8b47e3e040ff5411b717ec
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 3 20:50:44 2011 -0700

    net: Compute protocol sequence numbers and fragment IDs using MD5.
    
    Computers have become a lot faster since we compromised on the
    partial MD4 hash which we use currently for performance reasons.
    
    MD5 is a much safer choice, and is inline with both RFC1948 and
    other ISS generators (OpenBSD, Solaris, etc.)
    
    Furthermore, only having 24-bits of the sequence number be truly
    unpredictable is a very serious limitation.  So the periodic
    regeneration and 8-bit counter have been removed.  We compute and
    use a full 32-bit sequence number.
    
    For ipv6, DCCP was found to use a 32-bit truncated initial sequence
    number (it needs 43-bits) and that is fixed here as well.
    
    Reported-by: Dan Kaminsky <dan@doxpara.com>
    Tested-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index ce29a040c8dc..d13059f3ea32 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -57,18 +57,6 @@ extern void add_interrupt_randomness(int irq);
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
-extern __u32 secure_ip_id(__be32 daddr);
-extern __u32 secure_ipv6_id(const __be32 daddr[4]);
-extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
-extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
-				      __be16 dport);
-extern __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
-					__be16 sport, __be16 dport);
-extern __u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,
-					  __be16 sport, __be16 dport);
-extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
-				       __be16 sport, __be16 dport);
-
 #ifndef MODULE
 extern const struct file_operations random_fops, urandom_fops;
 #endif

commit 63d77173266c1791f1553e9e8ccea65dc87c4485
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Sun Jul 31 13:54:50 2011 -0700

    random: Add support for architectural random hooks
    
    Add support for architecture-specific hooks into the kernel-directed
    random number generator interfaces.  This patchset does not use the
    architecture random number generator interfaces for the
    userspace-directed interfaces (/dev/random and /dev/urandom), thus
    eliminating the need to distinguish between them based on a pool
    pointer.
    
    Changes in version 3:
    - Moved the hooks from extract_entropy() to get_random_bytes().
    - Changes the hooks to inlines.
    
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/random.h b/include/linux/random.h
index fb7ab9de5f36..079cbba39a28 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -102,6 +102,19 @@ static inline void prandom32_seed(struct rnd_state *state, u64 seed)
 	state->s3 = __seed(i, 15);
 }
 
+#ifdef CONFIG_ARCH_RANDOM
+# include <asm/archrandom.h>
+#else
+static inline int arch_get_random_long(unsigned long *v)
+{
+	return 0;
+}
+static inline int arch_get_random_int(unsigned int *v)
+{
+	return 0;
+}
+#endif
+
 #endif /* __KERNEL___ */
 
 #endif /* _LINUX_RANDOM_H */

commit 87c48fa3b4630905f98268dde838ee43626a060c
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jul 21 21:25:58 2011 -0700

    ipv6: make fragment identifications less predictable
    
    IPv6 fragment identification generation is way beyond what we use for
    IPv4 : It uses a single generator. Its not scalable and allows DOS
    attacks.
    
    Now inetpeer is IPv6 aware, we can use it to provide a more secure and
    scalable frag ident generator (per destination, instead of system wide)
    
    This patch :
    1) defines a new secure_ipv6_id() helper
    2) extends inet_getid() to provide 32bit results
    3) extends ipv6_select_ident() with a new dest parameter
    
    Reported-by: Fernando Gont <fernando@gont.com.ar>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index fb7ab9de5f36..ce29a040c8dc 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -58,6 +58,7 @@ extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
 extern __u32 secure_ip_id(__be32 daddr);
+extern __u32 secure_ipv6_id(const __be32 daddr[4]);
 extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
 extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
 				      __be16 dport);

commit 5960164fde9bc2f2a99e751d3393faea316e7e36
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Wed May 26 14:44:13 2010 -0700

    lib/random32: export pseudo-random number generator for modules
    
    This patch moves the definition of struct rnd_state and the inline
    __seed() function to linux/random.h.  It renames the static __random32()
    function to prandom32() and exports it for use in modules.
    
    prandom32() is useful as a privately-seeded pseudo random number generator
    that can give the same result every time it is initialized.
    
    For FCoE FC-BB-6 VN2VN mode self-selected unique FC address generation, we
    need an pseudo-random number generator seeded with the 64-bit world-wide
    port name.  A truly random generator or one seeded with randomness won't
    do because the same sequence of numbers should be generated each time we
    boot or the link comes up.
    
    A prandom32_seed() inline function is added to the header file.  It is
    inlined not for speed, but so the function won't be expanded in the base
    kernel, but only in the module that uses it.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 25d02fe5c9b5..fb7ab9de5f36 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -40,6 +40,10 @@ struct rand_pool_info {
 	__u32	buf[0];
 };
 
+struct rnd_state {
+	__u32 s1, s2, s3;
+};
+
 /* Exported functions */
 
 #ifdef __KERNEL__
@@ -74,6 +78,30 @@ unsigned long randomize_range(unsigned long start, unsigned long end, unsigned l
 u32 random32(void);
 void srandom32(u32 seed);
 
+u32 prandom32(struct rnd_state *);
+
+/*
+ * Handle minimum values for seeds
+ */
+static inline u32 __seed(u32 x, u32 m)
+{
+	return (x < m) ? x + m : x;
+}
+
+/**
+ * prandom32_seed - set seed for prandom32().
+ * @state: pointer to state structure to receive the seed.
+ * @seed: arbitrary 64-bit value to use as a seed.
+ */
+static inline void prandom32_seed(struct rnd_state *state, u64 seed)
+{
+	u32 i = (seed >> 32) ^ (seed << 10) ^ seed;
+
+	state->s1 = __seed(i, 1);
+	state->s2 = __seed(i, 7);
+	state->s3 = __seed(i, 15);
+}
+
 #endif /* __KERNEL___ */
 
 #endif /* _LINUX_RANDOM_H */

commit 68622c61dc7971382f5d69cd5d881e618ea30414
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Fri Jan 30 22:11:32 2009 +0530

    headers_check fix: linux/random.h
    
    fix the following 'make headers_check' warning:
    
      usr/include/linux/random.h:39: found __[us]{8,16,32,64} type without #include <linux/types.h>
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/include/linux/random.h b/include/linux/random.h
index 407ea3646f8f..25d02fe5c9b5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -7,6 +7,7 @@
 #ifndef _LINUX_RANDOM_H
 #define _LINUX_RANDOM_H
 
+#include <linux/types.h>
 #include <linux/ioctl.h>
 #include <linux/irqnr.h>
 

commit 2f983570010a0dcb26d988da02d7ccfad00c807c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 3 00:06:34 2009 -0800

    sparseirq: move set/get_timer_rand_state back to .c
    
    those two functions only used in that C file
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index adbf3bd3c6b3..407ea3646f8f 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -45,56 +45,6 @@ struct rand_pool_info {
 
 extern void rand_initialize_irq(int irq);
 
-struct timer_rand_state;
-#ifndef CONFIG_SPARSE_IRQ
-
-extern struct timer_rand_state *irq_timer_state[];
-
-static inline struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	if (irq >= nr_irqs)
-		return NULL;
-
-	return irq_timer_state[irq];
-}
-
-static inline void set_timer_rand_state(unsigned int irq, struct timer_rand_state *state)
-{
-	if (irq >= nr_irqs)
-		return;
-
-	irq_timer_state[irq] = state;
-}
-
-#else
-
-#include <linux/irq.h>
-static inline struct timer_rand_state *get_timer_rand_state(unsigned int irq)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-
-	if (!desc)
-		return NULL;
-
-	return desc->timer_rand_state;
-}
-
-static inline void set_timer_rand_state(unsigned int irq, struct timer_rand_state *state)
-{
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-
-	if (!desc)
-		return;
-
-	desc->timer_rand_state = state;
-}
-#endif
-
-
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq);

commit 0ebb26e7a4e2c5337502e98b2221e037fda911b9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Dec 12 11:26:39 2008 +0100

    sparse irqs: handle !GENIRQ platforms
    
    Impact: build fix
    
    fix:
    
     In file included from /home/mingo/tip/arch/m68k/amiga/amiints.c:39:
     /home/mingo/tip/include/linux/interrupt.h:21: error: expected identifier or '('
     /home/mingo/tip/arch/m68k/amiga/amiints.c: In function 'amiga_init_IRQ':
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/random.h b/include/linux/random.h
index ad9daa2374d5..adbf3bd3c6b3 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -8,6 +8,7 @@
 #define _LINUX_RANDOM_H
 
 #include <linux/ioctl.h>
+#include <linux/irqnr.h>
 
 /* ioctl()'s for the random number generator */
 
@@ -49,7 +50,6 @@ struct timer_rand_state;
 
 extern struct timer_rand_state *irq_timer_state[];
 
-extern int nr_irqs;
 static inline struct timer_rand_state *get_timer_rand_state(unsigned int irq)
 {
 	if (irq >= nr_irqs)

commit 0b8f1efad30bd58f89961b82dfe68b9edf8fd2ac
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 5 18:58:31 2008 -0800

    sparse irq_desc[] array: core kernel and x86 changes
    
    Impact: new feature
    
    Problem on distro kernels: irq_desc[NR_IRQS] takes megabytes of RAM with
    NR_CPUS set to large values. The goal is to be able to scale up to much
    larger NR_IRQS value without impacting the (important) common case.
    
    To solve this, we generalize irq_desc[NR_IRQS] to an (optional) array of
    irq_desc pointers.
    
    When CONFIG_SPARSE_IRQ=y is used, we use kzalloc_node to get irq_desc,
    this also makes the IRQ descriptors NUMA-local (to the site that calls
    request_irq()).
    
    This gets rid of the irq_cfg[] static array on x86 as well: irq_cfg now
    uses desc->chip_data for x86 to store irq_cfg.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/random.h b/include/linux/random.h
index 36f125c0c603..ad9daa2374d5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -44,6 +44,57 @@ struct rand_pool_info {
 
 extern void rand_initialize_irq(int irq);
 
+struct timer_rand_state;
+#ifndef CONFIG_SPARSE_IRQ
+
+extern struct timer_rand_state *irq_timer_state[];
+
+extern int nr_irqs;
+static inline struct timer_rand_state *get_timer_rand_state(unsigned int irq)
+{
+	if (irq >= nr_irqs)
+		return NULL;
+
+	return irq_timer_state[irq];
+}
+
+static inline void set_timer_rand_state(unsigned int irq, struct timer_rand_state *state)
+{
+	if (irq >= nr_irqs)
+		return;
+
+	irq_timer_state[irq] = state;
+}
+
+#else
+
+#include <linux/irq.h>
+static inline struct timer_rand_state *get_timer_rand_state(unsigned int irq)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+
+	if (!desc)
+		return NULL;
+
+	return desc->timer_rand_state;
+}
+
+static inline void set_timer_rand_state(unsigned int irq, struct timer_rand_state *state)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+
+	if (!desc)
+		return;
+
+	desc->timer_rand_state = state;
+}
+#endif
+
+
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
 extern void add_interrupt_randomness(int irq);

commit 540473208f8ac71c25a87e1a2670c3c18dd4d6db
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:28 2007 -0800

    [PATCH] mark struct file_operations const 1
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 01ad71033d65..36f125c0c603 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -63,7 +63,7 @@ extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
 				       __be16 sport, __be16 dport);
 
 #ifndef MODULE
-extern struct file_operations random_fops, urandom_fops;
+extern const struct file_operations random_fops, urandom_fops;
 #endif
 
 unsigned int get_random_int(void);

commit b09b845ca6724c3bbdc00c0cb2313258c7189ca9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 14 20:52:19 2006 -0800

    [RANDOM]: Annotate random.h IP helpers.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 0248b30e306d..01ad71033d65 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -51,16 +51,16 @@ extern void add_interrupt_randomness(int irq);
 extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
-extern __u32 secure_ip_id(__u32 daddr);
-extern u32 secure_ipv4_port_ephemeral(__u32 saddr, __u32 daddr, __u16 dport);
-extern u32 secure_ipv6_port_ephemeral(const __u32 *saddr, const __u32 *daddr, 
-				      __u16 dport);
-extern __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,
-					__u16 sport, __u16 dport);
-extern __u32 secure_tcpv6_sequence_number(__u32 *saddr, __u32 *daddr,
-					  __u16 sport, __u16 dport);
-extern u64 secure_dccp_sequence_number(__u32 saddr, __u32 daddr,
-				       __u16 sport, __u16 dport);
+extern __u32 secure_ip_id(__be32 daddr);
+extern u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport);
+extern u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
+				      __be16 dport);
+extern __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
+					__be16 sport, __be16 dport);
+extern __u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,
+					  __be16 sport, __be16 dport);
+extern u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
+				       __be16 sport, __be16 dport);
 
 #ifndef MODULE
 extern struct file_operations random_fops, urandom_fops;

commit aaa248f6c9c81b2683db7dbb0689cd5ed1c86d88
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Tue Oct 17 00:09:42 2006 -0700

    [PATCH] rename net_random to random32
    
    Make net_random() more widely available by calling it random32
    
    akpm: hopefully this will permit the removal of carta_random32.  That needs
    confirmation from Stephane - this code looks somewhat more computationally
    expensive, and has a different (ie: callee-stateful) interface.
    
    [akpm@osdl.org: lots of build fixes, cleanups]
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Cc: Stephane Eranian <eranian@hpl.hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/random.h b/include/linux/random.h
index 5d6456bcdeba..0248b30e306d 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -69,6 +69,9 @@ extern struct file_operations random_fops, urandom_fops;
 unsigned int get_random_int(void);
 unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
 
+u32 random32(void);
+void srandom32(u32 seed);
+
 #endif /* __KERNEL___ */
 
 #endif /* _LINUX_RANDOM_H */

commit d8313f5ca2b1f86b7df6c99fc4b3fffa1f84e92b
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 13 23:25:44 2005 -0800

    [INET6]: Generalise tcp_v6_hash_connect
    
    Renaming it to inet6_hash_connect, making it possible to ditch
    dccp_v6_hash_connect and share the same code with TCP instead.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 01424a8e621c..5d6456bcdeba 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -53,8 +53,8 @@ void generate_random_uuid(unsigned char uuid_out[16]);
 
 extern __u32 secure_ip_id(__u32 daddr);
 extern u32 secure_ipv4_port_ephemeral(__u32 saddr, __u32 daddr, __u16 dport);
-extern u32 secure_tcpv6_port_ephemeral(const __u32 *saddr, const __u32 *daddr, 
-				       __u16 dport);
+extern u32 secure_ipv6_port_ephemeral(const __u32 *saddr, const __u32 *daddr, 
+				      __u16 dport);
 extern __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,
 					__u16 sport, __u16 dport);
 extern __u32 secure_tcpv6_sequence_number(__u32 *saddr, __u32 *daddr,

commit a7f5e7f164788a22eb5d3de8e2d3cee1bf58fdca
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 13 23:25:31 2005 -0800

    [INET]: Generalise tcp_v4_hash_connect
    
    Renaming it to inet_hash_connect, making it possible to ditch
    dccp_v4_hash_connect and share the same code with TCP instead.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index 7b2adb3322d5..01424a8e621c 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -52,7 +52,7 @@ extern void get_random_bytes(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
 extern __u32 secure_ip_id(__u32 daddr);
-extern u32 secure_tcp_port_ephemeral(__u32 saddr, __u32 daddr, __u16 dport);
+extern u32 secure_ipv4_port_ephemeral(__u32 saddr, __u32 daddr, __u16 dport);
 extern u32 secure_tcpv6_port_ephemeral(const __u32 *saddr, const __u32 *daddr, 
 				       __u16 dport);
 extern __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,

commit c4365c9235f80128c3c3d5993074173941b1c1f0
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:12:30 2005 -0700

    [RANDOM]: Introduce secure_dccp_sequence_number
    
    Code contributed by Stephen Hemminger.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/random.h b/include/linux/random.h
index cc6703449916..7b2adb3322d5 100644
--- a/include/linux/random.h
+++ b/include/linux/random.h
@@ -59,6 +59,8 @@ extern __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,
 					__u16 sport, __u16 dport);
 extern __u32 secure_tcpv6_sequence_number(__u32 *saddr, __u32 *daddr,
 					  __u16 sport, __u16 dport);
+extern u64 secure_dccp_sequence_number(__u32 saddr, __u32 daddr,
+				       __u16 sport, __u16 dport);
 
 #ifndef MODULE
 extern struct file_operations random_fops, urandom_fops;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/random.h b/include/linux/random.h
new file mode 100644
index 000000000000..cc6703449916
--- /dev/null
+++ b/include/linux/random.h
@@ -0,0 +1,72 @@
+/*
+ * include/linux/random.h
+ *
+ * Include file for the random number generator.
+ */
+
+#ifndef _LINUX_RANDOM_H
+#define _LINUX_RANDOM_H
+
+#include <linux/ioctl.h>
+
+/* ioctl()'s for the random number generator */
+
+/* Get the entropy count. */
+#define RNDGETENTCNT	_IOR( 'R', 0x00, int )
+
+/* Add to (or subtract from) the entropy count.  (Superuser only.) */
+#define RNDADDTOENTCNT	_IOW( 'R', 0x01, int )
+
+/* Get the contents of the entropy pool.  (Superuser only.) */
+#define RNDGETPOOL	_IOR( 'R', 0x02, int [2] )
+
+/* 
+ * Write bytes into the entropy pool and add to the entropy count.
+ * (Superuser only.)
+ */
+#define RNDADDENTROPY	_IOW( 'R', 0x03, int [2] )
+
+/* Clear entropy count to 0.  (Superuser only.) */
+#define RNDZAPENTCNT	_IO( 'R', 0x04 )
+
+/* Clear the entropy pool and associated counters.  (Superuser only.) */
+#define RNDCLEARPOOL	_IO( 'R', 0x06 )
+
+struct rand_pool_info {
+	int	entropy_count;
+	int	buf_size;
+	__u32	buf[0];
+};
+
+/* Exported functions */
+
+#ifdef __KERNEL__
+
+extern void rand_initialize_irq(int irq);
+
+extern void add_input_randomness(unsigned int type, unsigned int code,
+				 unsigned int value);
+extern void add_interrupt_randomness(int irq);
+
+extern void get_random_bytes(void *buf, int nbytes);
+void generate_random_uuid(unsigned char uuid_out[16]);
+
+extern __u32 secure_ip_id(__u32 daddr);
+extern u32 secure_tcp_port_ephemeral(__u32 saddr, __u32 daddr, __u16 dport);
+extern u32 secure_tcpv6_port_ephemeral(const __u32 *saddr, const __u32 *daddr, 
+				       __u16 dport);
+extern __u32 secure_tcp_sequence_number(__u32 saddr, __u32 daddr,
+					__u16 sport, __u16 dport);
+extern __u32 secure_tcpv6_sequence_number(__u32 *saddr, __u32 *daddr,
+					  __u16 sport, __u16 dport);
+
+#ifndef MODULE
+extern struct file_operations random_fops, urandom_fops;
+#endif
+
+unsigned int get_random_int(void);
+unsigned long randomize_range(unsigned long start, unsigned long end, unsigned long len);
+
+#endif /* __KERNEL___ */
+
+#endif /* _LINUX_RANDOM_H */
