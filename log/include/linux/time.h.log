commit 639fff1cce0f7462bb4440deeffc1048ecfc6ebb
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Fri Mar 20 14:53:35 2020 +0000

    linux/time.h: Extract common header for vDSO
    
    The vDSO library should only include the necessary headers required for
    a userspace library (UAPI and a minimal set of kernel headers). To make
    this possible it is necessary to isolate from the kernel headers the
    common parts that are strictly necessary to build the library.
    
    Split time.h into linux and common headers to make the latter suitable
    for inclusion in the vDSO library.
    
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lkml.kernel.org/r/20200320145351.32292-11-vincenzo.frascino@arm.com

diff --git a/include/linux/time.h b/include/linux/time.h
index 8ef5e5cc9f57..4c325bf44ce0 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -111,9 +111,6 @@ static inline bool itimerspec64_valid(const struct itimerspec64 *its)
  */
 #define time_between32(t, l, h) ((u32)(h) - (u32)(l) >= (u32)(t) - (u32)(l))
 
-struct timens_offset {
-	s64	sec;
-	u64	nsec;
-};
+# include <vdso/time.h>
 
 #endif

commit 660fd04f9317172ae90f414c68b18a26ae88a829
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 12 01:27:09 2019 +0000

    lib/vdso: Prepare for time namespace support
    
    To support time namespaces in the vdso with a minimal impact on regular non
    time namespace affected tasks, the namespace handling needs to be hidden in
    a slow path.
    
    The most obvious place is vdso_seq_begin(). If a task belongs to a time
    namespace then the VVAR page which contains the system wide vdso data is
    replaced with a namespace specific page which has the same layout as the
    VVAR page. That page has vdso_data->seq set to 1 to enforce the slow path
    and vdso_data->clock_mode set to VCLOCK_TIMENS to enforce the time
    namespace handling path.
    
    The extra check in the case that vdso_data->seq is odd, e.g. a concurrent
    update of the vdso data is in progress, is not really affecting regular
    tasks which are not part of a time namespace as the task is spin waiting
    for the update to finish and vdso_data->seq to become even again.
    
    If a time namespace task hits that code path, it invokes the corresponding
    time getter function which retrieves the real VVAR page, reads host time
    and then adds the offset for the requested clock which is stored in the
    special VVAR page.
    
    If VDSO time namespace support is disabled the whole magic is compiled out.
    
    Initial testing shows that the disabled case is almost identical to the
    host case which does not take the slow timens path. With the special timens
    page installed the performance hit is constant time and in the range of
    5-7%.
    
    For the vdso functions which are not using the sequence count an
    unconditional check for vdso_data->clock_mode is added which switches to
    the real vdso when the clock_mode is VCLOCK_TIMENS.
    
    [avagin: Make do_hres_timens() work with raw clocks too: choose vdso_data
     pointer by CS_RAW offset.]
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Link: https://lore.kernel.org/r/20191112012724.250792-21-dima@arista.com

diff --git a/include/linux/time.h b/include/linux/time.h
index 8e10b9dbd8c2..8ef5e5cc9f57 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -110,4 +110,10 @@ static inline bool itimerspec64_valid(const struct itimerspec64 *its)
  * Equivalent to !(time_before32(@t, @l) || time_after32(@t, @h)).
  */
 #define time_between32(t, l, h) ((u32)(h) - (u32)(l) >= (u32)(t) - (u32)(l))
+
+struct timens_offset {
+	s64	sec;
+	u64	nsec;
+};
+
 #endif

commit 04d26e7b159a396372646a480f4caa166d1b6720
Author: Guillaume Nault <gnault@redhat.com>
Date:   Fri Dec 6 12:38:36 2019 +0100

    tcp: fix rejected syncookies due to stale timestamps
    
    If no synflood happens for a long enough period of time, then the
    synflood timestamp isn't refreshed and jiffies can advance so much
    that time_after32() can't accurately compare them any more.
    
    Therefore, we can end up in a situation where time_after32(now,
    last_overflow + HZ) returns false, just because these two values are
    too far apart. In that case, the synflood timestamp isn't updated as
    it should be, which can trick tcp_synq_no_recent_overflow() into
    rejecting valid syncookies.
    
    For example, let's consider the following scenario on a system
    with HZ=1000:
    
      * The synflood timestamp is 0, either because that's the timestamp
        of the last synflood or, more commonly, because we're working with
        a freshly created socket.
    
      * We receive a new SYN, which triggers synflood protection. Let's say
        that this happens when jiffies == 2147484649 (that is,
        'synflood timestamp' + HZ + 2^31 + 1).
    
      * Then tcp_synq_overflow() doesn't update the synflood timestamp,
        because time_after32(2147484649, 1000) returns false.
        With:
          - 2147484649: the value of jiffies, aka. 'now'.
          - 1000: the value of 'last_overflow' + HZ.
    
      * A bit later, we receive the ACK completing the 3WHS. But
        cookie_v[46]_check() rejects it because tcp_synq_no_recent_overflow()
        says that we're not under synflood. That's because
        time_after32(2147484649, 120000) returns false.
        With:
          - 2147484649: the value of jiffies, aka. 'now'.
          - 120000: the value of 'last_overflow' + TCP_SYNCOOKIE_VALID.
    
        Of course, in reality jiffies would have increased a bit, but this
        condition will last for the next 119 seconds, which is far enough
        to accommodate for jiffie's growth.
    
    Fix this by updating the overflow timestamp whenever jiffies isn't
    within the [last_overflow, last_overflow + HZ] range. That shouldn't
    have any performance impact since the update still happens at most once
    per second.
    
    Now we're guaranteed to have fresh timestamps while under synflood, so
    tcp_synq_no_recent_overflow() can safely use it with time_after32() in
    such situations.
    
    Stale timestamps can still make tcp_synq_no_recent_overflow() return
    the wrong verdict when not under synflood. This will be handled in the
    next patch.
    
    For 64 bits architectures, the problem was introduced with the
    conversion of ->tw_ts_recent_stamp to 32 bits integer by commit
    cca9bab1b72c ("tcp: use monotonic timestamps for PAWS").
    The problem has always been there on 32 bits architectures.
    
    Fixes: cca9bab1b72c ("tcp: use monotonic timestamps for PAWS")
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/time.h b/include/linux/time.h
index 0760a4f5a15c..8e10b9dbd8c2 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -97,4 +97,17 @@ static inline bool itimerspec64_valid(const struct itimerspec64 *its)
  */
 #define time_after32(a, b)	((s32)((u32)(b) - (u32)(a)) < 0)
 #define time_before32(b, a)	time_after32(a, b)
+
+/**
+ * time_between32 - check if a 32-bit timestamp is within a given time range
+ * @t:	the time which may be within [l,h]
+ * @l:	the lower bound of the range
+ * @h:	the higher bound of the range
+ *
+ * time_before32(t, l, h) returns true if @l <= @t <= @h. All operands are
+ * treated as 32-bit integers.
+ *
+ * Equivalent to !(time_before32(@t, @l) || time_after32(@t, @h)).
+ */
+#define time_between32(t, l, h) ((u32)(h) - (u32)(l) >= (u32)(t) - (u32)(l))
 #endif

commit ddbc7d0657e9fd38b69f16bd0310703367b52d29
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Oct 25 21:37:43 2019 +0200

    y2038: move itimer reset into itimer.c
    
    Preparing for a change to the itimer internals, stop using the
    do_setitimer() symbol and instead use a new higher-level interface.
    
    The do_getitimer()/do_setitimer functions can now be made static,
    allowing the compiler to potentially produce better object code.
    
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 27d83fd2ae61..0760a4f5a15c 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -35,10 +35,11 @@ extern time64_t mktime64(const unsigned int year, const unsigned int mon,
 extern u32 (*arch_gettimeoffset)(void);
 #endif
 
-struct itimerval;
-extern int do_setitimer(int which, struct itimerval *value,
-			struct itimerval *ovalue);
-extern int do_getitimer(int which, struct itimerval *value);
+#ifdef CONFIG_POSIX_TIMERS
+extern void clear_itimer(void);
+#else
+static inline void clear_itimer(void) {}
+#endif
 
 extern long do_utimes(int dfd, const char __user *filename, struct timespec64 *times, int flags);
 

commit d0dd63a8aee1ef89f2e48e554b796b9f9e4fcadb
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sat Jun 16 22:11:42 2018 -0700

    time: Introduce struct __kernel_itimerspec
    
    struct itimerspec is not y2038-safe.
    
    Introduce a new struct __kernel_itimerspec based on the kernel internal
    y2038-safe struct itimerspec64.
    
    The definition of struct __kernel_itimerspec includes two struct
    __kernel_timespec.
    
    Since struct __kernel_timespec has the same representation in native and
    compat modes, so does struct __kernel_itimerspec. This helps have a common
    entry point for syscalls using struct __kernel_itimerspec.
    
    New y2038-safe syscalls will use this new type. Since most of the new
    syscalls are just an update to the native syscalls with the type update,
    place the new definition under CONFIG_64BIT_TIME. This helps architectures
    that do not support the above config to keep using the old definition of
    struct itimerspec.
    
    Also change the get/put_itimerspec64 to use struct__kernel_itimerspec.
    This will help 32 bit architectures to use the new syscalls when
    architectures select CONFIG_64BIT_TIME.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: viro@zeniv.linux.org.uk
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-api@vger.kernel.org
    Cc: y2038@lists.linaro.org
    Link: https://lkml.kernel.org/r/20180617051144.29756-2-deepa.kernel@gmail.com

diff --git a/include/linux/time.h b/include/linux/time.h
index aed74463592d..27d83fd2ae61 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -14,9 +14,9 @@ int get_timespec64(struct timespec64 *ts,
 int put_timespec64(const struct timespec64 *ts,
 		struct __kernel_timespec __user *uts);
 int get_itimerspec64(struct itimerspec64 *it,
-			const struct itimerspec __user *uit);
+			const struct __kernel_itimerspec __user *uit);
 int put_itimerspec64(const struct itimerspec64 *it,
-			struct itimerspec __user *uit);
+			struct __kernel_itimerspec __user *uit);
 
 extern time64_t mktime64(const unsigned int year, const unsigned int mon,
 			const unsigned int day, const unsigned int hour,

commit ea2ce8f3514e2074a1910d8d721842d7341d5c81
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue Mar 13 21:03:31 2018 -0700

    time: Fix get_timespec64() for y2038 safe compat interfaces
    
    get/put_timespec64() interfaces will eventually be used for
    conversions between the new y2038 safe struct __kernel_timespec
    and struct timespec64.
    
    The new y2038 safe syscalls have a common entry for native
    and compat interfaces.
    On compat interfaces, the high order bits of nanoseconds
    should be zeroed out. This is because the application code
    or the libc do not guarantee zeroing of these. If used without
    zeroing, kernel might be at risk of using timespec values
    incorrectly.
    
    Note that clearing of bits is dependent on CONFIG_64BIT_TIME
    for now. This is until COMPAT_USE_64BIT_TIME has been handled
    correctly. x86 will be the first architecture that will use the
    CONFIG_64BIT_TIME.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4b62a2c0a661..aed74463592d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -10,9 +10,9 @@
 extern struct timezone sys_tz;
 
 int get_timespec64(struct timespec64 *ts,
-		const struct timespec __user *uts);
+		const struct __kernel_timespec __user *uts);
 int put_timespec64(const struct timespec64 *ts,
-		struct timespec __user *uts);
+		struct __kernel_timespec __user *uts);
 int get_itimerspec64(struct itimerspec64 *it,
 			const struct itimerspec __user *uit);
 int put_itimerspec64(const struct itimerspec64 *it,

commit 2bcc673101268dc50e52b83226c5bbf38391e16d
Merge: 670310dfbae0 b24591e2fcf8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 17:56:58 2017 -0800

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer updates from Thomas Gleixner:
     "Yet another big pile of changes:
    
       - More year 2038 work from Arnd slowly reaching the point where we
         need to think about the syscalls themself.
    
       - A new timer function which allows to conditionally (re)arm a timer
         only when it's either not running or the new expiry time is sooner
         than the armed expiry time. This allows to use a single timer for
         multiple timeout requirements w/o caring about the first expiry
         time at the call site.
    
       - A new NMI safe accessor to clock real time for the printk timestamp
         work. Can be used by tracing, perf as well if required.
    
       - A large number of timer setup conversions from Kees which got
         collected here because either maintainers requested so or they
         simply got ignored. As Kees pointed out already there are a few
         trivial merge conflicts and some redundant commits which was
         unavoidable due to the size of this conversion effort.
    
       - Avoid a redundant iteration in the timer wheel softirq processing.
    
       - Provide a mechanism to treat RTC implementations depending on their
         hardware properties, i.e. don't inflict the write at the 0.5
         seconds boundary which originates from the PC CMOS RTC to all RTCs.
         No functional change as drivers need to be updated separately.
    
       - The usual small updates to core code clocksource drivers. Nothing
         really exciting"
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (111 commits)
      timers: Add a function to start/reduce a timer
      pstore: Use ktime_get_real_fast_ns() instead of __getnstimeofday()
      timer: Prepare to change all DEFINE_TIMER() callbacks
      netfilter: ipvs: Convert timers to use timer_setup()
      scsi: qla2xxx: Convert timers to use timer_setup()
      block/aoe: discover_timer: Convert timers to use timer_setup()
      ide: Convert timers to use timer_setup()
      drbd: Convert timers to use timer_setup()
      mailbox: Convert timers to use timer_setup()
      crypto: Convert timers to use timer_setup()
      drivers/pcmcia: omap1: Fix error in automated timer conversion
      ARM: footbridge: Fix typo in timer conversion
      drivers/sgi-xp: Convert timers to use timer_setup()
      drivers/pcmcia: Convert timers to use timer_setup()
      drivers/memstick: Convert timers to use timer_setup()
      drivers/macintosh: Convert timers to use timer_setup()
      hwrng/xgene-rng: Convert timers to use timer_setup()
      auxdisplay: Convert timers to use timer_setup()
      sparc/led: Convert timers to use timer_setup()
      mips: ip22/32: Convert timers to use timer_setup()
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 9bc1f945777c..87c36cf1cec2 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_TIME_H
 #define _LINUX_TIME_H
 

commit 5dbf20127f8cca8588ad0b0e3e8ded587ac7afa0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:47 2017 +0200

    time: Move time_t based interfaces to time32.h
    
    Interfaces based on 'struct timespec' or 'struct timeval' should no
    longer be used for new code, which can use either ktime_t or 'struct
    timespec64' instead.
    
    To make this a little clearer, this moves the various helpers into a new
    time32.h header. For the moment, this gets included by the normal time.h,
    but we may be able to separate it entirely when most users of time32.h
    are gone.
    
    Individual helpers in the new file can get removed once they become unused
    in the future.
    
    Since the contents of time32.h look a lot like what's in time64.h, I'm
    reordering them during the move to make them more similar, and to allow
    a follow-up patch to redirect the 'timespec' based functions to thei
    'timespec64' based counterparts on 64-bit architectures later.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [jstultz: Whitespace & checkpatch fixups]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 0e8a80918484..c375f54a678d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -17,105 +17,10 @@ int get_itimerspec64(struct itimerspec64 *it,
 int put_itimerspec64(const struct itimerspec64 *it,
 			struct itimerspec __user *uit);
 
-#define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
-
-static inline int timespec_equal(const struct timespec *a,
-                                 const struct timespec *b)
-{
-	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
-}
-
-/*
- * lhs < rhs:  return <0
- * lhs == rhs: return 0
- * lhs > rhs:  return >0
- */
-static inline int timespec_compare(const struct timespec *lhs, const struct timespec *rhs)
-{
-	if (lhs->tv_sec < rhs->tv_sec)
-		return -1;
-	if (lhs->tv_sec > rhs->tv_sec)
-		return 1;
-	return lhs->tv_nsec - rhs->tv_nsec;
-}
-
 extern time64_t mktime64(const unsigned int year, const unsigned int mon,
 			const unsigned int day, const unsigned int hour,
 			const unsigned int min, const unsigned int sec);
 
-/**
- * Deprecated. Use mktime64().
- */
-static inline unsigned long mktime(const unsigned int year,
-			const unsigned int mon, const unsigned int day,
-			const unsigned int hour, const unsigned int min,
-			const unsigned int sec)
-{
-	return mktime64(year, mon, day, hour, min, sec);
-}
-
-extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
-
-static inline struct timespec timespec_add(struct timespec lhs,
-						struct timespec rhs)
-{
-	struct timespec ts_delta;
-	set_normalized_timespec(&ts_delta, lhs.tv_sec + rhs.tv_sec,
-				lhs.tv_nsec + rhs.tv_nsec);
-	return ts_delta;
-}
-
-/*
- * sub = lhs - rhs, in normalized form
- */
-static inline struct timespec timespec_sub(struct timespec lhs,
-						struct timespec rhs)
-{
-	struct timespec ts_delta;
-	set_normalized_timespec(&ts_delta, lhs.tv_sec - rhs.tv_sec,
-				lhs.tv_nsec - rhs.tv_nsec);
-	return ts_delta;
-}
-
-/*
- * Returns true if the timespec is norm, false if denorm:
- */
-static inline bool timespec_valid(const struct timespec *ts)
-{
-	/* Dates before 1970 are bogus */
-	if (ts->tv_sec < 0)
-		return false;
-	/* Can't have more nanoseconds then a second */
-	if ((unsigned long)ts->tv_nsec >= NSEC_PER_SEC)
-		return false;
-	return true;
-}
-
-static inline bool timespec_valid_strict(const struct timespec *ts)
-{
-	if (!timespec_valid(ts))
-		return false;
-	/* Disallow values that could overflow ktime_t */
-	if ((unsigned long long)ts->tv_sec >= KTIME_SEC_MAX)
-		return false;
-	return true;
-}
-
-static inline bool timeval_valid(const struct timeval *tv)
-{
-	/* Dates before 1970 are bogus */
-	if (tv->tv_sec < 0)
-		return false;
-
-	/* Can't have more microseconds then a second */
-	if (tv->tv_usec < 0 || tv->tv_usec >= USEC_PER_SEC)
-		return false;
-
-	return true;
-}
-
-extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
-
 /* Some architectures do not supply their own clocksource.
  * This is mainly the case in architectures that get their
  * inter-tick times by reading the counter on their interval
@@ -164,73 +69,7 @@ struct tm {
 
 void time64_to_tm(time64_t totalsecs, int offset, struct tm *result);
 
-/**
- * time_to_tm - converts the calendar time to local broken-down time
- *
- * @totalsecs	the number of seconds elapsed since 00:00:00 on January 1, 1970,
- *		Coordinated Universal Time (UTC).
- * @offset	offset seconds adding to totalsecs.
- * @result	pointer to struct tm variable to receive broken-down time
- */
-static inline void time_to_tm(time_t totalsecs, int offset, struct tm *result)
-{
-	time64_to_tm(totalsecs, offset, result);
-}
-
-/**
- * timespec_to_ns - Convert timespec to nanoseconds
- * @ts:		pointer to the timespec variable to be converted
- *
- * Returns the scalar nanosecond representation of the timespec
- * parameter.
- */
-static inline s64 timespec_to_ns(const struct timespec *ts)
-{
-	return ((s64) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
-}
-
-/**
- * timeval_to_ns - Convert timeval to nanoseconds
- * @ts:		pointer to the timeval variable to be converted
- *
- * Returns the scalar nanosecond representation of the timeval
- * parameter.
- */
-static inline s64 timeval_to_ns(const struct timeval *tv)
-{
-	return ((s64) tv->tv_sec * NSEC_PER_SEC) +
-		tv->tv_usec * NSEC_PER_USEC;
-}
-
-/**
- * ns_to_timespec - Convert nanoseconds to timespec
- * @nsec:	the nanoseconds value to be converted
- *
- * Returns the timespec representation of the nsec parameter.
- */
-extern struct timespec ns_to_timespec(const s64 nsec);
-
-/**
- * ns_to_timeval - Convert nanoseconds to timeval
- * @nsec:	the nanoseconds value to be converted
- *
- * Returns the timeval representation of the nsec parameter.
- */
-extern struct timeval ns_to_timeval(const s64 nsec);
-
-/**
- * timespec_add_ns - Adds nanoseconds to a timespec
- * @a:		pointer to timespec to be incremented
- * @ns:		unsigned nanoseconds value to be added
- *
- * This must always be inlined because its used from the x86-64 vdso,
- * which cannot call other kernel functions.
- */
-static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
-{
-	a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
-	a->tv_nsec = ns;
-}
+# include <linux/time32.h>
 
 static inline bool itimerspec64_valid(const struct itimerspec64 *its)
 {

commit 85bf19e7df2479140eff2348a4e6a9c19b5c3960
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:46 2017 +0200

    time: Remove unused functions
    
    The (slow but) ongoing work on conversion from timespec to timespec64
    has led some timespec based helper functions to become unused.
    
    No new code should use them, so we can remove the functions entirely.
    I'm planning to obsolete additional interfaces next and remove
    more of these.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index c0fbad08448f..0e8a80918484 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -39,15 +39,6 @@ static inline int timespec_compare(const struct timespec *lhs, const struct time
 	return lhs->tv_nsec - rhs->tv_nsec;
 }
 
-static inline int timeval_compare(const struct timeval *lhs, const struct timeval *rhs)
-{
-	if (lhs->tv_sec < rhs->tv_sec)
-		return -1;
-	if (lhs->tv_sec > rhs->tv_sec)
-		return 1;
-	return lhs->tv_usec - rhs->tv_usec;
-}
-
 extern time64_t mktime64(const unsigned int year, const unsigned int mon,
 			const unsigned int day, const unsigned int hour,
 			const unsigned int min, const unsigned int sec);
@@ -65,15 +56,6 @@ static inline unsigned long mktime(const unsigned int year,
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
 
-/*
- * timespec_add_safe assumes both values are positive and checks
- * for overflow. It will return TIME_T_MAX if the reutrn would be
- * smaller then either of the arguments.
- */
-extern struct timespec timespec_add_safe(const struct timespec lhs,
-					 const struct timespec rhs);
-
-
 static inline struct timespec timespec_add(struct timespec lhs,
 						struct timespec rhs)
 {

commit e0956dcc4ba74ec4b17e32fc9a156fcba1ef6610
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 13:14:44 2017 +0200

    timekeeping: Consolidate timekeeping_inject_offset code
    
    The code to check the adjtimex() or clock_adjtime() arguments is spread
    out across multiple files for presumably only historic reasons. As a
    preparatation for a rework to get rid of the use of 'struct timeval'
    and 'struct timespec' in there, this moves all the portions into
    kernel/time/timekeeping.c and marks them as 'static'.
    
    The warp_clock() function here is not as closely related as the others,
    but I feel it still makes sense to move it here in order to consolidate
    all callers of timekeeping_inject_offset().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Miroslav Lichvar <mlichvar@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Stephen Boyd <stephen.boyd@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [jstultz: Whitespace fixup]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 9bc1f945777c..c0fbad08448f 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -134,32 +134,6 @@ static inline bool timeval_valid(const struct timeval *tv)
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
-/*
- * Validates if a timespec/timeval used to inject a time offset is valid.
- * Offsets can be postive or negative. The value of the timeval/timespec
- * is the sum of its fields, but *NOTE*: the field tv_usec/tv_nsec must
- * always be non-negative.
- */
-static inline bool timeval_inject_offset_valid(const struct timeval *tv)
-{
-	/* We don't check the tv_sec as it can be positive or negative */
-
-	/* Can't have more microseconds then a second */
-	if (tv->tv_usec < 0 || tv->tv_usec >= USEC_PER_SEC)
-		return false;
-	return true;
-}
-
-static inline bool timespec_inject_offset_valid(const struct timespec *ts)
-{
-	/* We don't check the tv_sec as it can be positive or negative */
-
-	/* Can't have more nanoseconds then a second */
-	if (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)
-		return false;
-	return true;
-}
-
 /* Some architectures do not supply their own clocksource.
  * This is mainly the case in architectures that get their
  * inter-tick times by reading the counter on their interval

commit cc73fee0bae2d66594d1fa2df92bbd783aa98e04
Merge: e7cdb60fd28b aaed2dd8a313
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 17:37:26 2017 -0700

    Merge branch 'work.ipc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ipc compat cleanup and 64-bit time_t from Al Viro:
     "IPC copyin/copyout sanitizing, including 64bit time_t work from Deepa
      Dinamani"
    
    * 'work.ipc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      utimes: Make utimes y2038 safe
      ipc: shm: Make shmid_kernel timestamps y2038 safe
      ipc: sem: Make sem_array timestamps y2038 safe
      ipc: msg: Make msg_queue timestamps y2038 safe
      ipc: mqueue: Replace timespec with timespec64
      ipc: Make sys_semtimedop() y2038 safe
      get rid of SYSVIPC_COMPAT on ia64
      semtimedop(): move compat to native
      shmat(2): move compat to native
      msgrcv(2), msgsnd(2): move compat to native
      ipc(2): move compat to native
      ipc: make use of compat ipc_perm helpers
      semctl(): move compat to native
      semctl(): separate all layout-dependent copyin/copyout
      msgctl(): move compat to native
      msgctl(): split the actual work from copyin/copyout
      ipc: move compat shmctl to native
      shmctl: split the work from copyin/copyout

commit aaed2dd8a31359e5767ee099ecbb078d55be4d29
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Aug 2 19:51:15 2017 -0700

    utimes: Make utimes y2038 safe
    
    struct timespec is not y2038 safe on 32 bit machines.
    Replace timespec with y2038 safe struct timespec64.
    
    Note that the patch only changes the internals without
    modifying the syscall interfaces. This will be part
    of a separate series.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4abb32d4c6b8..3d0cd017f0d7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -178,7 +178,7 @@ extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 
-extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
+extern long do_utimes(int dfd, const char __user *filename, struct timespec64 *times, int flags);
 
 /*
  * Similar to the struct tm in userspace <time.h>, but it needs to be here so

commit b5f515735bea4ae71c248aea3e049073f8852889
Author: Andreas Dilger <adilger@dilger.ca>
Date:   Thu Aug 31 11:09:45 2017 -0400

    ext4: avoid Y2038 overflow in recently_deleted()
    
    Avoid a 32-bit time overflow in recently_deleted() since i_dtime
    (inode deletion time) is stored only as a 32-bit value on disk.
    Since i_dtime isn't used for much beyond a boolean value in e2fsck
    and is otherwise only used in this function in the kernel, there is
    no benefit to use more space in the inode for this field on disk.
    
    Instead, compare only the relative deletion time with the low
    32 bits of the time using the newly-added time_before32() helper,
    which is similar to time_before() and time_after() for jiffies.
    
    Increase RECENTCY_DIRTY to 300s based on Ted's comments about
    usage experience at Google.
    
    Signed-off-by: Andreas Dilger <adilger@dilger.ca>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4abb32d4c6b8..3877136bbdf8 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -285,4 +285,19 @@ static inline bool itimerspec64_valid(const struct itimerspec64 *its)
 	return true;
 }
 
+/**
+ * time_after32 - compare two 32-bit relative times
+ * @a:	the time which may be after @b
+ * @b:	the time which may be before @a
+ *
+ * time_after32(a, b) returns true if the time @a is after time @b.
+ * time_before32(b, a) returns true if the time @b is before time @a.
+ *
+ * Similar to time_after(), compare two 32-bit timestamps for relative
+ * times.  This is useful for comparing 32-bit seconds values that can't
+ * be converted to 64-bit values (e.g. due to disk format or wire protocol
+ * issues) when it is known that the times are less than 68 years apart.
+ */
+#define time_after32(a, b)	((s32)((u32)(b) - (u32)(a)) < 0)
+#define time_before32(b, a)	time_after32(a, b)
 #endif

commit c856863988ebf612d159e55eeddbcd27de63b40d
Merge: 771d3feb4b79 0d0606060bae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 20:57:13 2017 -0700

    Merge branch 'misc.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc compat stuff updates from Al Viro:
     "This part is basically untangling various compat stuff. Compat
      syscalls moved to their native counterparts, getting rid of quite a
      bit of double-copying and/or set_fs() uses. A lot of field-by-field
      copyin/copyout killed off.
    
       - kernel/compat.c is much closer to containing just the
         copyin/copyout of compat structs. Not all compat syscalls are gone
         from it yet, but it's getting there.
    
       - ipc/compat_mq.c killed off completely.
    
       - block/compat_ioctl.c cleaned up; floppy compat ioctls moved to
         drivers/block/floppy.c where they belong. Yes, there are several
         drivers that implement some of the same ioctls. Some are m68k and
         one is 32bit-only pmac. drivers/block/floppy.c is the only one in
         that bunch that can be built on biarch"
    
    * 'misc.compat' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      mqueue: move compat syscalls to native ones
      usbdevfs: get rid of field-by-field copyin
      compat_hdio_ioctl: get rid of set_fs()
      take floppy compat ioctls to sodding floppy.c
      ipmi: get rid of field-by-field __get_user()
      ipmi: get COMPAT_IPMICTL_RECEIVE_MSG in sync with the native one
      rt_sigtimedwait(): move compat to native
      select: switch compat_{get,put}_fd_set() to compat_{get,put}_bitmap()
      put_compat_rusage(): switch to copy_to_user()
      sigpending(): move compat to native
      getrlimit()/setrlimit(): move compat to native
      times(2): move compat to native
      compat_{get,put}_bitmap(): use unsafe_{get,put}_user()
      fb_get_fscreeninfo(): don't bother with do_fb_ioctl()
      do_sigaltstack(): lift copying to/from userland into callers
      take compat_sys_old_getrlimit() to native syscall
      trim __ARCH_WANT_SYS_OLD_GETRLIMIT

commit d5b7ffbfbdacc29e4db035f90665951668fa9c58
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sat Jun 24 11:45:03 2017 -0700

    time: introduce {get,put}_itimerspec64
    
    As we change the user space type for the timerfd and posix timer
    functions to newer data types, we need some form of conversion
    helpers to avoid duplicating that logic.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/time.h b/include/linux/time.h
index 36afb579495f..f9858d7e6361 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -12,6 +12,10 @@ int get_timespec64(struct timespec64 *ts,
 		const struct timespec __user *uts);
 int put_timespec64(const struct timespec64 *ts,
 		struct timespec __user *uts);
+int get_itimerspec64(struct itimerspec64 *it,
+			const struct itimerspec __user *uit);
+int put_itimerspec64(const struct itimerspec64 *it,
+			struct itimerspec __user *uit);
 
 #define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 
@@ -275,4 +279,13 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 	a->tv_nsec = ns;
 }
 
+static inline bool itimerspec64_valid(const struct itimerspec64 *its)
+{
+	if (!timespec64_valid(&(its->it_interval)) ||
+		!timespec64_valid(&(its->it_value)))
+		return false;
+
+	return true;
+}
+
 #endif

commit f59dd9c886acb3abb188e8e94a99436560976835
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sat Jun 24 11:45:02 2017 -0700

    time: add get_timespec64 and put_timespec64
    
    Add helper functions to convert between struct timespec64 and
    struct timespec at userspace boundaries.
    
    This is a preparatory patch to use timespec64 as the basic type
    internally in the kernel as timespec is not y2038 safe on 32 bit systems.
    The patch helps the cause by containing all data conversions at the
    userspace boundaries within these functions.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/time.h b/include/linux/time.h
index c0543f5f25de..36afb579495f 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -8,6 +8,11 @@
 
 extern struct timezone sys_tz;
 
+int get_timespec64(struct timespec64 *ts,
+		const struct timespec __user *uts);
+int put_timespec64(const struct timespec64 *ts,
+		struct timespec __user *uts);
+
 #define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 
 static inline int timespec_equal(const struct timespec *a,

commit ca2406ed58fef3f7c8ef6470cba807bfc3415605
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 31 04:22:44 2017 -0400

    times(2): move compat to native
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/time.h b/include/linux/time.h
index c0543f5f25de..f769ea88250d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -171,9 +171,6 @@ extern int do_getitimer(int which, struct itimerval *value);
 
 extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 
-struct tms;
-extern void do_sys_times(struct tms *);
-
 /*
  * Similar to the struct tm in userspace <time.h>, but it needs to be here so
  * that the kernel source is self contained.

commit bfe1c566453a0979c0b3cd3728d0de962272f034
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon May 8 15:59:37 2017 -0700

    time: delete CURRENT_TIME_SEC and CURRENT_TIME
    
    All uses of CURRENT_TIME_SEC and CURRENT_TIME macros have been replaced
    by other time functions.  These macros are also not y2038 safe.  And,
    all their use cases can be fulfilled by y2038 safe ktime_get_* variants.
    
    Link: http://lkml.kernel.org/r/1491613030-11599-12-git-send-email-deepa.kernel@gmail.com
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 23f0f5ce3090..c0543f5f25de 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -151,9 +151,6 @@ static inline bool timespec_inject_offset_valid(const struct timespec *ts)
 	return true;
 }
 
-#define CURRENT_TIME		(current_kernel_time())
-#define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
-
 /* Some architectures do not supply their own clocksource.
  * This is mainly the case in architectures that get their
  * inter-tick times by reading the counter on their interval

commit 74ba181e61c6accf9066d6980f44588de2f854f6
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Nov 11 00:10:08 2016 -0500

    timer: Move sys_alarm from timer.c to itimer.c
    
    Move the only user of alarm_setitimer to itimer.c where it is defined.
    This allows for making alarm_setitimer static, and dropping it from the
    build when __ARCH_WANT_SYS_ALARM is not defined.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Cc: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-kbuild@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Michal Marek <mmarek@suse.com>
    Cc: Edward Cree <ecree@solarflare.com>
    Link: http://lkml.kernel.org/r/1478841010-28605-5-git-send-email-nicolas.pitre@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4cea09d94208..23f0f5ce3090 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -172,8 +172,6 @@ extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 
-extern unsigned int alarm_setitimer(unsigned int seconds);
-
 extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 
 struct tms;

commit e6c2682a1da36a2e79d9bab470412374434ce89e
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Jun 8 22:04:59 2016 -0700

    time: Add time64_to_tm()
    
    time_to_tm() takes time_t as an argument.
    time_t is not y2038 safe.
    Add time64_to_tm() that takes time64_t as an argument
    which is y2038 safe.
    The plan is to eventually replace all calls to time_to_tm()
    by time64_to_tm().
    
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 297f09f23896..4cea09d94208 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -205,7 +205,20 @@ struct tm {
 	int tm_yday;
 };
 
-void time_to_tm(time_t totalsecs, int offset, struct tm *result);
+void time64_to_tm(time64_t totalsecs, int offset, struct tm *result);
+
+/**
+ * time_to_tm - converts the calendar time to local broken-down time
+ *
+ * @totalsecs	the number of seconds elapsed since 00:00:00 on January 1, 1970,
+ *		Coordinated Universal Time (UTC).
+ * @offset	offset seconds adding to totalsecs.
+ * @result	pointer to struct tm variable to receive broken-down time
+ */
+static inline void time_to_tm(time_t totalsecs, int offset, struct tm *result)
+{
+	time64_to_tm(totalsecs, offset, result);
+}
 
 /**
  * timespec_to_ns - Convert timespec to nanoseconds

commit 37cf4dc3370fbca0344e23bb96446eb2c3548ba7
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Dec 3 22:09:31 2015 -0500

    time: Verify time values in adjtimex ADJ_SETOFFSET to avoid overflow
    
    For adjtimex()'s ADJ_SETOFFSET, make sure the tv_usec value is
    sane. We might multiply them later which can cause an overflow
    and undefined behavior.
    
    This patch introduces new helper functions to simplify the
    checking code and adds comments to clarify
    
    Orginally this patch was by Sasha Levin, but I've basically
    rewritten it, so he should get credit for finding the issue
    and I should get the blame for any mistakes made since.
    
    Also, credit to Richard Cochran for the phrasing used in the
    comment for what is considered valid here.
    
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index beebe3a02d43..297f09f23896 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -125,6 +125,32 @@ static inline bool timeval_valid(const struct timeval *tv)
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
+/*
+ * Validates if a timespec/timeval used to inject a time offset is valid.
+ * Offsets can be postive or negative. The value of the timeval/timespec
+ * is the sum of its fields, but *NOTE*: the field tv_usec/tv_nsec must
+ * always be non-negative.
+ */
+static inline bool timeval_inject_offset_valid(const struct timeval *tv)
+{
+	/* We don't check the tv_sec as it can be positive or negative */
+
+	/* Can't have more microseconds then a second */
+	if (tv->tv_usec < 0 || tv->tv_usec >= USEC_PER_SEC)
+		return false;
+	return true;
+}
+
+static inline bool timespec_inject_offset_valid(const struct timespec *ts)
+{
+	/* We don't check the tv_sec as it can be positive or negative */
+
+	/* Can't have more nanoseconds then a second */
+	if (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)
+		return false;
+	return true;
+}
+
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
 

commit 5fbaba8603d5bbc9e40bcb970bae64cb7e093755
Merge: f2a5473861cf 5e5aeb4367b4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Jan 22 12:26:41 2015 +0100

    Merge branch 'fortglx/3.19-stable/time' of https://git.linaro.org/people/john.stultz/linux into timers/urgent
    
    Pull urgent fixes from John Stultz:
    
      Two urgent fixes for user triggerable time related overflow issues

commit 6ada1fc0e1c4775de0e043e1bd3ae9d065491aa5
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Dec 3 19:22:48 2014 -0500

    time: settimeofday: Validate the values of tv from user
    
    An unvalidated user input is multiplied by a constant, which can result in
    an undefined behaviour for large values. While this is validated later,
    we should avoid triggering undefined behaviour.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    [jstultz: include trivial milisecond->microsecond correction noticed
    by Andy]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 8c42cf8d2444..5989b0ead1ec 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -99,6 +99,19 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 	return true;
 }
 
+static inline bool timeval_valid(const struct timeval *tv)
+{
+	/* Dates before 1970 are bogus */
+	if (tv->tv_sec < 0)
+		return false;
+
+	/* Can't have more microseconds then a second */
+	if (tv->tv_usec < 0 || tv->tv_usec >= USEC_PER_SEC)
+		return false;
+
+	return true;
+}
+
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
 #define CURRENT_TIME		(current_kernel_time())

commit 90b6ce9c4066e0b2098dff65e52e6e7df1a51079
Author: pang.xunlei <pang.xunlei@linaro.org>
Date:   Tue Nov 18 19:15:18 2014 +0800

    time: Provide y2038 safe mktime() replacement
    
    As part of addressing "y2038 problem" for in-kernel uses, this
    patch adds safe mktime64() using time64_t.
    
    After this patch, mktime() is deprecated and all its call sites
    will be fixed using mktime64(), after that it can be removed.
    
    Signed-off-by: pang.xunlei <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 8c42cf8d2444..203c2ad40d71 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -39,9 +39,20 @@ static inline int timeval_compare(const struct timeval *lhs, const struct timeva
 	return lhs->tv_usec - rhs->tv_usec;
 }
 
-extern unsigned long mktime(const unsigned int year, const unsigned int mon,
-			    const unsigned int day, const unsigned int hour,
-			    const unsigned int min, const unsigned int sec);
+extern time64_t mktime64(const unsigned int year, const unsigned int mon,
+			const unsigned int day, const unsigned int hour,
+			const unsigned int min, const unsigned int sec);
+
+/**
+ * Deprecated. Use mktime64().
+ */
+static inline unsigned long mktime(const unsigned int year,
+			const unsigned int mon, const unsigned int day,
+			const unsigned int hour, const unsigned int min,
+			const unsigned int sec)
+{
+	return mktime64(year, mon, day, hour, min, sec);
+}
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
 

commit 8b094cd03b4a3793220d8d8d86a173bfea8c285b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jul 16 21:04:02 2014 +0000

    time: Consolidate the time accessor prototypes
    
    Right now we have time related prototypes in 3 different header
    files. Move it to a single timekeeping header file and move the core
    internal stuff into a core private header.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 234feac7f1c3..8c42cf8d2444 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -99,25 +99,7 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 	return true;
 }
 
-extern bool persistent_clock_exist;
-
-static inline bool has_persistent_clock(void)
-{
-	return persistent_clock_exist;
-}
-
-extern void read_persistent_clock(struct timespec *ts);
-extern void read_boot_clock(struct timespec *ts);
-extern int persistent_clock_is_local;
-extern int update_persistent_clock(struct timespec now);
-void timekeeping_init(void);
-extern int timekeeping_suspended;
-
-unsigned long get_seconds(void);
-struct timespec current_kernel_time(void);
-struct timespec __current_kernel_time(void); /* does not take xtime_lock */
-struct timespec get_monotonic_coarse(void);
-void timekeeping_inject_sleeptime(struct timespec *delta);
+extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
@@ -135,33 +117,14 @@ void timekeeping_inject_sleeptime(struct timespec *delta);
 extern u32 (*arch_gettimeoffset)(void);
 #endif
 
-extern void do_gettimeofday(struct timeval *tv);
-extern int do_settimeofday(const struct timespec *tv);
-extern int do_sys_settimeofday(const struct timespec *tv,
-			       const struct timezone *tz);
-#define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
-extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
-extern int __getnstimeofday(struct timespec *tv);
-extern void getnstimeofday(struct timespec *tv);
-extern void getrawmonotonic(struct timespec *ts);
-extern void getnstime_raw_and_real(struct timespec *ts_raw,
-		struct timespec *ts_real);
-extern void getboottime(struct timespec *ts);
-extern void monotonic_to_bootbased(struct timespec *ts);
-extern void get_monotonic_boottime(struct timespec *ts);
 
-extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
-extern int timekeeping_valid_for_hres(void);
-extern u64 timekeeping_max_deferment(void);
-extern int timekeeping_inject_offset(struct timespec *ts);
-extern s32 timekeeping_get_tai_offset(void);
-extern void timekeeping_set_tai_offset(s32 tai_offset);
-extern void timekeeping_clocktai(struct timespec *ts);
+extern unsigned int alarm_setitimer(unsigned int seconds);
+
+extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 
 struct tms;
 extern void do_sys_times(struct tms *);

commit 361a3bf00582469877f8d18ff20f1efa6b781274
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 16 21:03:58 2014 +0000

    time64: Add time64.h header and define struct timespec64
    
    Define the timespec64 structure and standard helper functions.
    
    [ tglx: Make it 32bit only. 64bit really can map timespec to timespec64 ]
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 129f0bd36a8d..234feac7f1c3 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -4,25 +4,12 @@
 # include <linux/cache.h>
 # include <linux/seqlock.h>
 # include <linux/math64.h>
-#include <uapi/linux/time.h>
+# include <linux/time64.h>
 
 extern struct timezone sys_tz;
 
-/* Parameters used to convert the timespec values: */
-#define MSEC_PER_SEC	1000L
-#define USEC_PER_MSEC	1000L
-#define NSEC_PER_USEC	1000L
-#define NSEC_PER_MSEC	1000000L
-#define USEC_PER_SEC	1000000L
-#define NSEC_PER_SEC	1000000000L
-#define FSEC_PER_SEC	1000000000000000LL
-
 #define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 
-/* Located here for timespec_valid_strict */
-#define KTIME_MAX			((s64)~((u64)1 << 63))
-#define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
-
 static inline int timespec_equal(const struct timespec *a,
                                  const struct timespec *b)
 {

commit 24e4a8c3e8868874835b0f1ad6dd417341e99822
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 16 21:03:53 2014 +0000

    ktime: Kill non-scalar ktime_t implementation for 2038
    
    The non-scalar ktime_t implementation is basically a timespec
    which has to be changed to support dates past 2038 on 32bit
    systems.
    
    This patch removes the non-scalar ktime_t implementation, forcing
    the scalar s64 nanosecond version on all architectures.
    
    This may have additional performance overhead on some 32bit
    systems when converting between ktime_t and timespec structures,
    however the majority of 32bit systems (arm and i386) were already
    using scalar ktime_t, so no performance regressions will be seen
    on those platforms.
    
    On affected platforms, I'm open to finding optimizations, including
    avoiding converting to timespecs where possible.
    
    [ tglx: We can now cleanup the ktime_t.tv64 mess, but thats a
      different issue and we can throw a coccinelle script at it ]
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index f6d990d1c79a..129f0bd36a8d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -19,6 +19,10 @@ extern struct timezone sys_tz;
 
 #define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 
+/* Located here for timespec_valid_strict */
+#define KTIME_MAX			((s64)~((u64)1 << 63))
+#define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
+
 static inline int timespec_equal(const struct timespec *a,
                                  const struct timespec *b)
 {
@@ -84,13 +88,6 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 	return ts_delta;
 }
 
-#define KTIME_MAX			((s64)~((u64)1 << 63))
-#if (BITS_PER_LONG == 64)
-# define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
-#else
-# define KTIME_SEC_MAX			LONG_MAX
-#endif
-
 /*
  * Returns true if the timespec is norm, false if denorm:
  */

commit 76f4108892d9a9e3408bba839914f97a54086a6f
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Jul 16 21:03:52 2014 +0000

    hrtimer: Cleanup hrtimer accessors to the timekepeing state
    
    Rather then having two similar but totally different implementations
    that provide timekeeping state to the hrtimer code, try to unify the
    two implementations to be more simliar.
    
    Thus this clarifies ktime_get_update_offsets to
    ktime_get_update_offsets_now and changes get_xtime...  to
    ktime_get_update_offsets_tick.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index d5d229b2e5af..f6d990d1c79a 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -133,8 +133,6 @@ unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
 struct timespec __current_kernel_time(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
-void get_xtime_and_monotonic_and_sleep_offset(struct timespec *xtim,
-				struct timespec *wtom, struct timespec *sleep);
 void timekeeping_inject_sleeptime(struct timespec *delta);
 
 #define CURRENT_TIME		(current_kernel_time())

commit b4f711ee03d28f776fd2324fd0bd999cc428e4d2
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 24 11:32:56 2013 -0700

    time: Revert ALWAYS_USE_PERSISTENT_CLOCK compile time optimizaitons
    
    Kay Sievers noted that the ALWAYS_USE_PERSISTENT_CLOCK config,
    which enables some minor compile time optimization to avoid
    uncessary code in mostly the suspend/resume path could cause
    problems for userland.
    
    In particular, the dependency for RTC_HCTOSYS on
    !ALWAYS_USE_PERSISTENT_CLOCK, which avoids setting the time
    twice and simplifies suspend/resume, has the side effect
    of causing the /sys/class/rtc/rtcN/hctosys flag to always be
    zero, and this flag is commonly used by udev to setup the
    /dev/rtc symlink to /dev/rtcN, which can cause pain for
    older applications.
    
    While the udev rules could use some work to be less fragile,
    breaking userland should strongly be avoided. Additionally
    the compile time optimizations are fairly minor, and the code
    being optimized is likely to be reworked in the future, so
    lets revert this change.
    
    Reported-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: stable <stable@vger.kernel.org> #3.9
    Cc: Feng Tang <feng.tang@intel.com>
    Cc: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Link: http://lkml.kernel.org/r/1366828376-18124-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 22d81b3c955b..d5d229b2e5af 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -117,14 +117,10 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 
 extern bool persistent_clock_exist;
 
-#ifdef ALWAYS_USE_PERSISTENT_CLOCK
-#define has_persistent_clock()	true
-#else
 static inline bool has_persistent_clock(void)
 {
 	return persistent_clock_exist;
 }
-#endif
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);

commit 1ff3c9677bff7e468e0c487d0ffefe4e901d33f4
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu May 3 12:43:40 2012 -0700

    timekeeping: Add CLOCK_TAI clockid
    
    This add a CLOCK_TAI clockid and the needed accessors.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 47210a175e78..22d81b3c955b 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -183,6 +183,7 @@ extern u64 timekeeping_max_deferment(void);
 extern int timekeeping_inject_offset(struct timespec *ts);
 extern s32 timekeeping_get_tai_offset(void);
 extern void timekeeping_set_tai_offset(s32 tai_offset);
+extern void timekeeping_clocktai(struct timespec *ts);
 
 struct tms;
 extern void do_sys_times(struct tms *);

commit cc244ddae6d4c6902ac9d7d64023534f8c44a7eb
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu May 3 12:30:07 2012 -0700

    timekeeping: Move TAI managment into timekeeping core from ntp
    
    Currently NTP manages the TAI offset. Since there's plans for a
    CLOCK_TAI clockid, push the TAI management into the timekeeping
    core.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index d4835dfdf25e..47210a175e78 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -181,6 +181,8 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
 extern int timekeeping_inject_offset(struct timespec *ts);
+extern s32 timekeeping_get_tai_offset(void);
+extern void timekeeping_set_tai_offset(s32 tai_offset);
 
 struct tms;
 extern void do_sys_times(struct tms *);

commit b274776c54c320763bc12eb035c0e244f76ccb43
Merge: b24174b0cbbe 3b1209e7994c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 14:58:40 2013 -0800

    Merge tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "A large number of cleanups, all over the platforms.  This is dominated
      largely by the Samsung platforms (s3c, s5p, exynos) and a few of the
      others moving code out of arch/arm into more appropriate subsystems.
    
      The clocksource and irqchip drivers are now abstracted to the point
      where platforms that are already cleaned up do not need to even
      specify the driver they use, it can all get configured from the device
      tree as we do for normal device drivers.  The clocksource changes
      basically touch every single platform in the process.
    
      We further clean up the use of platform specific header files here,
      with the goal of turning more of the platforms over to being
      "multiplatform" enabled, which implies that they cannot expose their
      headers to architecture independent code any more.
    
      It is expected that no functional changes are part of the cleanup.
      The overall reduction in total code lines is mostly the result of
      removing broken and obsolete code."
    
    * tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (133 commits)
      ARM: mvebu: correct gated clock documentation
      ARM: kirkwood: add missing include for nsa310
      ARM: exynos: move exynos4210-combiner to drivers/irqchip
      mfd: db8500-prcmu: update resource passing
      drivers/db8500-cpufreq: delete dangling include
      ARM: at91: remove NEOCORE 926 board
      sunxi: Cleanup the reset code and add meaningful registers defines
      ARM: S3C24XX: header mach/regs-mem.h local
      ARM: S3C24XX: header mach/regs-power.h local
      ARM: S3C24XX: header mach/regs-s3c2412-mem.h local
      ARM: S3C24XX: Remove plat-s3c24xx directory in arch/arm/
      ARM: S3C24XX: transform s3c2443 subirqs into new structure
      ARM: S3C24XX: modify s3c2443 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2443 irq code to irq.c
      ARM: S3C24XX: transform s3c2416 irqs into new structure
      ARM: S3C24XX: modify s3c2416 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2416 irq init to common irq code
      ARM: S3C24XX: Modify s3c_irq_wake to use the hwirq property
      ARM: S3C24XX: Move irq syscore-ops to irq-pm
      clocksource: always define CLOCKSOURCE_OF_DECLARE
      ...

commit 84e345e4e209cbe796c88fa2ad1732d7121ec100
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Fri Feb 8 17:59:53 2013 -0500

    time, Fix setting of hardware clock in NTP code
    
    At init time, if the system time is "warped" forward in warp_clock()
    it will differ from the hardware clock by sys_tz.tz_minuteswest.  This time
    difference is not taken into account when ntp updates the hardware clock,
    and this causes the system time to jump forward by this offset every reboot.
    
    The kernel must take this offset into account when writing the system time
    to the hardware clock in the ntp code.  This patch adds
    persistent_clock_is_local which indicates that an offset has been applied
    in warp_clock() and accounts for the "warp" before writing the hardware
    clock.
    
    x86 does not have this problem as rtc writes are software limited to a
    +/-15 minute window relative to the current rtc time.  Other arches, such
    as powerpc, however do a full synchronization of the system time to the
    rtc and will see this problem.
    
    [v2]: generated against tip/timers/core
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 476e1d7b2c37..a3ab6a814a9c 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -128,6 +128,7 @@ static inline bool has_persistent_clock(void)
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);
+extern int persistent_clock_is_local;
 extern int update_persistent_clock(struct timespec now);
 void timekeeping_init(void);
 extern int timekeeping_suspended;

commit 6f16eebe1ff82176339a0439c98ebec9768b0ee2
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Jan 25 17:08:12 2013 -0800

    timekeeping: Switch HAS_PERSISTENT_CLOCK to ALWAYS_USE_PERSISTENT_CLOCK
    
    Jason pointed out the HAS_PERSISTENT_CLOCK name isn't
    quite accurate for the config, as some systems may have
    the persistent_clock in some cases, but not always.
    
    So change the config name to the more clear
    ALWAYS_USE_PERSISTENT_CLOCK.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 369b6e3b87d8..476e1d7b2c37 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -117,7 +117,7 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 
 extern bool persistent_clock_exist;
 
-#ifdef CONFIG_HAS_PERSISTENT_CLOCK
+#ifdef ALWAYS_USE_PERSISTENT_CLOCK
 #define has_persistent_clock()	true
 #else
 static inline bool has_persistent_clock(void)

commit 05ad717c77b1b8e98a1dd768c3700036d634629e
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Jan 16 00:09:49 2013 +0800

    timekeeping: Add CONFIG_HAS_PERSISTENT_CLOCK option
    
    Make the persistent clock check a kernel config option, so that some
    platform can explicitely select it, also make CONFIG_RTC_HCTOSYS and
    RTC_SYSTOHC depend on its non-existence, which could prevent the
    persistent clock and RTC code from doing similar thing twice during
    system's init/suspend/resume phases.
    
    If the CONFIG_HAS_PERSISTENT_CLOCK=n, then no change happens for kernel
    which still does the persistent clock check in timekeeping_init().
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Suggested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    [jstultz: Added dependency for RTC_SYSTOHC as well]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index dfbc4e82e8ba..369b6e3b87d8 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -116,10 +116,15 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 }
 
 extern bool persistent_clock_exist;
+
+#ifdef CONFIG_HAS_PERSISTENT_CLOCK
+#define has_persistent_clock()	true
+#else
 static inline bool has_persistent_clock(void)
 {
 	return persistent_clock_exist;
 }
+#endif
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);

commit 31ade30692dc9680bfc95700d794818fa3f754ac
Author: Feng Tang <feng.tang@intel.com>
Date:   Wed Jan 16 00:09:47 2013 +0800

    timekeeping: Add persistent_clock_exist flag
    
    In current kernel, there are several places which need to check
    whether there is a persistent clock for the platform. Current check
    is done by calling the read_persistent_clock() and validating its
    return value.
    
    So one optimization is to do the check only once in timekeeping_init(),
    and use a flag persistent_clock_exist to record it.
    
    v2: Add a has_persistent_clock() helper function, as suggested by John.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 0015aea4c4a7..dfbc4e82e8ba 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -115,6 +115,12 @@ static inline bool timespec_valid_strict(const struct timespec *ts)
 	return true;
 }
 
+extern bool persistent_clock_exist;
+static inline bool has_persistent_clock(void)
+{
+	return persistent_clock_exist;
+}
+
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);
 extern int update_persistent_clock(struct timespec now);

commit 1e817fb62cd185a2232ad4302579491805609489
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Nov 19 10:26:16 2012 -0800

    time: create __getnstimeofday for WARNless calls
    
    The pstore RAM backend can get called during resume, and must be defensive
    against a suspended time source. Expose getnstimeofday logic that returns
    an error instead of a WARN. This can be detected and the timestamp can
    be zeroed out.
    
    Reported-by: Doug Anderson <dianders@chromium.org>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Anton Vorontsov <anton.vorontsov@linaro.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4d358e9d10f1..0015aea4c4a7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -158,6 +158,7 @@ extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
 extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
+extern int __getnstimeofday(struct timespec *tv);
 extern void getnstimeofday(struct timespec *tv);
 extern void getrawmonotonic(struct timespec *ts);
 extern void getnstime_raw_and_real(struct timespec *ts_raw,

commit 7b1f62076bba10786d2118006ae68ac120cd6c56
Author: Stephen Warren <swarren@nvidia.com>
Date:   Wed Nov 7 17:58:54 2012 -0700

    time: convert arch_gettimeoffset to a pointer
    
    Currently, whenever CONFIG_ARCH_USES_GETTIMEOFFSET is enabled, each
    arch core provides a single implementation of arch_gettimeoffset(). In
    many cases, different sub-architectures, different machines, or
    different timer providers exist, and so the arch ends up implementing
    arch_gettimeoffset() as a call-through-pointer anyway. Examples are
    ARM, Cris, M68K, and it's arguable that the remaining architectures,
    M32R and Blackfin, should be doing this anyway.
    
    Modify arch_gettimeoffset so that it itself is a function pointer, which
    the arch initializes. This will allow later changes to move the
    initialization of this function into individual machine support or timer
    drivers. This is particularly useful for code in drivers/clocksource
    which should rely on an arch-independant mechanism to register their
    implementation of arch_gettimeoffset().
    
    This patch also converts the Cris architecture to set arch_gettimeoffset
    directly to the final implementation in time_init(), because Cris already
    had separate time_init() functions per sub-architecture. M68K and ARM
    are converted to set arch_gettimeoffset to the final implementation in
    later patches, because they already have function pointers in place for
    this purpose.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4d358e9d10f1..05e32a72103c 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -142,9 +142,7 @@ void timekeeping_inject_sleeptime(struct timespec *delta);
  * finer then tick granular time.
  */
 #ifdef CONFIG_ARCH_USES_GETTIMEOFFSET
-extern u32 arch_gettimeoffset(void);
-#else
-static inline u32 arch_gettimeoffset(void) { return 0; }
+extern u32 (*arch_gettimeoffset)(void);
 #endif
 
 extern void do_gettimeofday(struct timeval *tv);

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/time.h b/include/linux/time.h
index b51e664c83e7..4d358e9d10f1 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -1,33 +1,10 @@
 #ifndef _LINUX_TIME_H
 #define _LINUX_TIME_H
 
-#include <linux/types.h>
-
-#ifdef __KERNEL__
 # include <linux/cache.h>
 # include <linux/seqlock.h>
 # include <linux/math64.h>
-#endif
-
-#ifndef _STRUCT_TIMESPEC
-#define _STRUCT_TIMESPEC
-struct timespec {
-	__kernel_time_t	tv_sec;			/* seconds */
-	long		tv_nsec;		/* nanoseconds */
-};
-#endif
-
-struct timeval {
-	__kernel_time_t		tv_sec;		/* seconds */
-	__kernel_suseconds_t	tv_usec;	/* microseconds */
-};
-
-struct timezone {
-	int	tz_minuteswest;	/* minutes west of Greenwich */
-	int	tz_dsttime;	/* type of dst correction */
-};
-
-#ifdef __KERNEL__
+#include <uapi/linux/time.h>
 
 extern struct timezone sys_tz;
 
@@ -280,51 +257,4 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 	a->tv_nsec = ns;
 }
 
-#endif /* __KERNEL__ */
-
-/*
- * Names of the interval timers, and structure
- * defining a timer setting:
- */
-#define	ITIMER_REAL		0
-#define	ITIMER_VIRTUAL		1
-#define	ITIMER_PROF		2
-
-struct itimerspec {
-	struct timespec it_interval;	/* timer period */
-	struct timespec it_value;	/* timer expiration */
-};
-
-struct itimerval {
-	struct timeval it_interval;	/* timer interval */
-	struct timeval it_value;	/* current value */
-};
-
-/*
- * The IDs of the various system clocks (for POSIX.1b interval timers):
- */
-#define CLOCK_REALTIME			0
-#define CLOCK_MONOTONIC			1
-#define CLOCK_PROCESS_CPUTIME_ID	2
-#define CLOCK_THREAD_CPUTIME_ID		3
-#define CLOCK_MONOTONIC_RAW		4
-#define CLOCK_REALTIME_COARSE		5
-#define CLOCK_MONOTONIC_COARSE		6
-#define CLOCK_BOOTTIME			7
-#define CLOCK_REALTIME_ALARM		8
-#define CLOCK_BOOTTIME_ALARM		9
-
-/*
- * The IDs of various hardware clocks:
- */
-#define CLOCK_SGI_CYCLE			10
-#define MAX_CLOCKS			16
-#define CLOCKS_MASK			(CLOCK_REALTIME | CLOCK_MONOTONIC)
-#define CLOCKS_MONO			CLOCK_MONOTONIC
-
-/*
- * The various flags for setting POSIX.1b interval timers:
- */
-#define TIMER_ABSTIME			0x01
-
 #endif

commit cee58483cf56e0ba355fdd97ff5e8925329aa936
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Aug 31 13:30:06 2012 -0400

    time: Move ktime_t overflow checking into timespec_valid_strict
    
    Andreas Bombe reported that the added ktime_t overflow checking added to
    timespec_valid in commit 4e8b14526ca7 ("time: Improve sanity checking of
    timekeeping inputs") was causing problems with X.org because it caused
    timeouts larger then KTIME_T to be invalid.
    
    Previously, these large timeouts would be clamped to KTIME_MAX and would
    never expire, which is valid.
    
    This patch splits the ktime_t overflow checking into a new
    timespec_valid_strict function, and converts the timekeeping codes
    internal checking to use this more strict function.
    
    Reported-and-tested-by: Andreas Bombe <aeb@debian.org>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index b0bbd8f0130d..b51e664c83e7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -125,6 +125,13 @@ static inline bool timespec_valid(const struct timespec *ts)
 	/* Can't have more nanoseconds then a second */
 	if ((unsigned long)ts->tv_nsec >= NSEC_PER_SEC)
 		return false;
+	return true;
+}
+
+static inline bool timespec_valid_strict(const struct timespec *ts)
+{
+	if (!timespec_valid(ts))
+		return false;
 	/* Disallow values that could overflow ktime_t */
 	if ((unsigned long long)ts->tv_sec >= KTIME_SEC_MAX)
 		return false;

commit 4e8b14526ca7fb046a81c94002c1c43b6fdf0e9b
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Aug 8 15:36:20 2012 -0400

    time: Improve sanity checking of timekeeping inputs
    
    Unexpected behavior could occur if the time is set to a value large
    enough to overflow a 64bit ktime_t (which is something larger then the
    year 2262).
    
    Also unexpected behavior could occur if large negative offsets are
    injected via adjtimex.
    
    So this patch improves the sanity check timekeeping inputs by
    improving the timespec_valid() check, and then makes better use of
    timespec_valid() to make sure we don't set the time to an invalid
    negative value or one that overflows ktime_t.
    
    Note: This does not protect from setting the time close to overflowing
    ktime_t and then letting natural accumulation cause the overflow.
    
    Reported-by: CAI Qian <caiqian@redhat.com>
    Reported-by: Sasha Levin <levinsasha928@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Zhouping Liu <zliu@redhat.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/1344454580-17031-1-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index c81c5e40fcb5..b0bbd8f0130d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -107,11 +107,29 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 	return ts_delta;
 }
 
+#define KTIME_MAX			((s64)~((u64)1 << 63))
+#if (BITS_PER_LONG == 64)
+# define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
+#else
+# define KTIME_SEC_MAX			LONG_MAX
+#endif
+
 /*
  * Returns true if the timespec is norm, false if denorm:
  */
-#define timespec_valid(ts) \
-	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
+static inline bool timespec_valid(const struct timespec *ts)
+{
+	/* Dates before 1970 are bogus */
+	if (ts->tv_sec < 0)
+		return false;
+	/* Can't have more nanoseconds then a second */
+	if ((unsigned long)ts->tv_nsec >= NSEC_PER_SEC)
+		return false;
+	/* Disallow values that could overflow ktime_t */
+	if ((unsigned long long)ts->tv_sec >= KTIME_SEC_MAX)
+		return false;
+	return true;
+}
 
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);

commit 8ded2bbc1845e19c771eb55209aab166ef011243
Author: Josh Boyer <jwboyer@redhat.com>
Date:   Wed Jul 25 10:40:34 2012 -0400

    posix_types.h: Cleanup stale __NFDBITS and related definitions
    
    Recently, glibc made a change to suppress sign-conversion warnings in
    FD_SET (glibc commit ceb9e56b3d1).  This uncovered an issue with the
    kernel's definition of __NFDBITS if applications #include
    <linux/types.h> after including <sys/select.h>.  A build failure would
    be seen when passing the -Werror=sign-compare and -D_FORTIFY_SOURCE=2
    flags to gcc.
    
    It was suggested that the kernel should either match the glibc
    definition of __NFDBITS or remove that entirely.  The current in-kernel
    uses of __NFDBITS can be replaced with BITS_PER_LONG, and there are no
    uses of the related __FDELT and __FDMASK defines.  Given that, we'll
    continue the cleanup that was started with commit 8b3d1cda4f5f
    ("posix_types: Remove fd_set macros") and drop the remaining unused
    macros.
    
    Additionally, linux/time.h has similar macros defined that expand to
    nothing so we'll remove those at the same time.
    
    Reported-by: Jeff Law <law@redhat.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Josh Boyer <jwboyer@redhat.com>
    [ .. and fix up whitespace as per akpm ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 179f4d6755fc..c81c5e40fcb5 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -257,14 +257,6 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 
 #endif /* __KERNEL__ */
 
-#define NFDBITS			__NFDBITS
-
-#define FD_SETSIZE		__FD_SETSIZE
-#define FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)
-#define FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)
-#define FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)
-#define FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)
-
 /*
  * Names of the interval timers, and structure
  * defining a timer setting:

commit 190d3b6b4ab0e1ce991e8bc94ad95f00b0dc476b
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri May 18 16:09:53 2012 +0200

    time: remove obsolete declaration
    
    The function, timekeeping_leap_insert, was removed in commit
    6b43ae8a619d17c4935c3320d2ef9e92bdeed05d
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 33a92ead4d88..179f4d6755fc 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -167,7 +167,6 @@ extern void get_monotonic_boottime(struct timespec *ts);
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
-extern void timekeeping_leap_insert(int leapsecond);
 extern int timekeeping_inject_offset(struct timespec *ts);
 
 struct tms;

commit a591afc01d9e48affbacb365558a31e53c85af45
Merge: 820d41cf0cd0 31796ac4e8f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 18:12:23 2012 -0700

    Merge branch 'x86-x32-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x32 support for x86-64 from Ingo Molnar:
     "This tree introduces the X32 binary format and execution mode for x86:
      32-bit data space binaries using 64-bit instructions and 64-bit kernel
      syscalls.
    
      This allows applications whose working set fits into a 32 bits address
      space to make use of 64-bit instructions while using a 32-bit address
      space with shorter pointers, more compressed data structures, etc."
    
    Fix up trivial context conflicts in arch/x86/{Kconfig,vdso/vma.c}
    
    * 'x86-x32-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (71 commits)
      x32: Fix alignment fail in struct compat_siginfo
      x32: Fix stupid ia32/x32 inversion in the siginfo format
      x32: Add ptrace for x32
      x32: Switch to a 64-bit clock_t
      x32: Provide separate is_ia32_task() and is_x32_task() predicates
      x86, mtrr: Use explicit sizing and padding for the 64-bit ioctls
      x86/x32: Fix the binutils auto-detect
      x32: Warn and disable rather than error if binutils too old
      x32: Only clear TIF_X32 flag once
      x32: Make sure TS_COMPAT is cleared for x32 tasks
      fs: Remove missed ->fds_bits from cessation use of fd_set structs internally
      fs: Fix close_on_exec pointer in alloc_fdtable
      x32: Drop non-__vdso weak symbols from the x32 VDSO
      x32: Fix coding style violations in the x32 VDSO code
      x32: Add x32 VDSO support
      x32: Allow x32 to be configured
      x32: If configured, add x32 system calls to system call tables
      x32: Handle process creation
      x32: Signal-related system calls
      x86: Add #ifdef CONFIG_COMPAT to <asm/sys_ia32.h>
      ...

commit 335dd85895abeca1957d5eaa3013dfe8dc60c7d7
Author: Cesar Eduardo Barros <cesarb@cesarb.net>
Date:   Sat Feb 11 17:54:59 2012 -0200

    time: remove no_sync_cmos_clock
    
    Commit 9863c90f682fba34cdc26c3437e8c00da6c83fa4 (x86, vmware: Remove
    deprecated VMI kernel support) removed the only place which set
    no_sync_cmos_clock. Since that commit, this variable is never set.
    
    Signed-off-by: Cesar Eduardo Barros <cesarb@cesarb.net>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index b3061782dec3..97734e9409c6 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -116,7 +116,6 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);
 extern int update_persistent_clock(struct timespec now);
-extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);
 extern int timekeeping_suspended;
 

commit cf420048b3b2af9ce928d35cc5455c646c9dd2f7
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 16 17:50:06 2012 +0000

    Delete the __FD_*() funcs for operating on fd_set from linux/time.h
    
    Delete the __FD_*() functions for operating on fd_set structs from
    linux/time.h as they're no longer used within the kernel with the preceding
    patch and are not exported to userspace.
    
    Whilst linux/time.h *does* export the FD_*() equivalents as wrappers around
    __FD_*(), userspace provides its own definition of __FD_*().
    
    Note that the definition of FD_ZERO() in linux/time.h may not be used with the
    fd_sets associated with struct fdtable as the fd_set may have been allocated in
    a truncated fashion.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Link: http://lkml.kernel.org/r/20120216175006.23314.18984.stgit@warthog.procyon.org.uk
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/time.h b/include/linux/time.h
index 93277a0b2293..9f43487facdf 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -4,11 +4,8 @@
 #include <linux/types.h>
 
 #ifdef __KERNEL__
-# include <linux/bitops.h>
 # include <linux/cache.h>
-# include <linux/posix_types.h>
 # include <linux/seqlock.h>
-# include <linux/string.h>
 # include <linux/math64.h>
 #endif
 
@@ -260,26 +257,6 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 	a->tv_nsec = ns;
 }
 
-static inline void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
-{
-	__set_bit(__fd, __fdsetp->fds_bits);
-}
-
-static inline void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
-{
-	__clear_bit(__fd, __fdsetp->fds_bits);
-}
-
-static inline int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__fdsetp)
-{
-	return test_bit(__fd, __fdsetp->fds_bits);
-}
-
-static inline void __FD_ZERO(__kernel_fd_set *__fdsetp)
-{
-	memset(__fdsetp->fds_bits, 0, sizeof __fdsetp->fds_bits);
-}
-
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS

commit 8b3d1cda4f5ff0d7c2ae910ea8fd03493996912f
Author: H. Peter Anvin <hpa@zytor.com>
Date:   Tue Feb 7 21:09:05 2012 -0800

    posix_types: Remove fd_set macros
    
    <asm/posix_types.h> includes a set of macros that operate on file
    descriptors.  Way long ago those were exported to user space, but
    nowadays they are #ifdef __KERNEL__.
    
    However, they are nothing but standard (nonatomic) bit operations, and
    we already have optimized versions of bit operations in the kernel.
    We can't include <linux/bitops.h> in <asm/posix_types.h> but we can
    move the definitions to <linux/time.h> and define them there in terms
    of standard kernel bitops.
    
    [ v2: folds the following fixes in:
    
      a) Stray space in __FD_SET(), reported by Andrew Morton
      b) #include <linux/string.h> needed for memset(), reported by Tony Luck ]
    
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Link: http://lkml.kernel.org/r/1328677745-20121-22-git-send-email-hpa@zytor.com
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index b3061782dec3..93277a0b2293 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -4,8 +4,11 @@
 #include <linux/types.h>
 
 #ifdef __KERNEL__
+# include <linux/bitops.h>
 # include <linux/cache.h>
+# include <linux/posix_types.h>
 # include <linux/seqlock.h>
+# include <linux/string.h>
 # include <linux/math64.h>
 #endif
 
@@ -256,6 +259,27 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 	a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
 	a->tv_nsec = ns;
 }
+
+static inline void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	__set_bit(__fd, __fdsetp->fds_bits);
+}
+
+static inline void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	__clear_bit(__fd, __fdsetp->fds_bits);
+}
+
+static inline int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__fdsetp)
+{
+	return test_bit(__fd, __fdsetp->fds_bits);
+}
+
+static inline void __FD_ZERO(__kernel_fd_set *__fdsetp)
+{
+	memset(__fdsetp->fds_bits, 0, sizeof __fdsetp->fds_bits);
+}
+
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS

commit 9a7adcf5c6dea63d2e47e6f6d2f7a6c9f48b9337
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Jan 11 09:54:33 2011 -0800

    timers: Posix interface for alarm-timers
    
    This patch exposes alarm-timers to userland via the posix clock
    and timers interface, using two new clockids: CLOCK_REALTIME_ALARM
    and CLOCK_BOOTTIME_ALARM. Both clockids behave identically to
    CLOCK_REALTIME and CLOCK_BOOTTIME, respectively, but timers
    set against the _ALARM suffixed clockids will wake the system if
    it is suspended.
    
    Some background can be found here:
            https://lwn.net/Articles/429925/
    
    The concept for Alarm-timers was inspired by the Android Alarm
    driver (by Arve Hjønnevåg) found in the Android kernel tree.
    
    See: http://android.git.kernel.org/?p=kernel/common.git;a=blob;f=drivers/rtc/alarm.c;h=1250edfbdf3302f5e4ea6194847c6ef4bb7beb1c;hb=android-2.6.36
    
    While the in-kernel interface is pretty similar between
    alarm-timers and Android alarm driver, the user-space interface
    for the Android alarm driver is via ioctls to a new char device.
    As mentioned above, I've instead chosen to export this functionality
    via the posix interface, as it seemed a little simpler and avoids
    creating duplicate interfaces to things like CLOCK_REALTIME and
    CLOCK_MONOTONIC under alternate names (ie:ANDROID_ALARM_RTC and
    ANDROID_ALARM_SYSTEMTIME).
    
    The semantics of the Android alarm driver are different from what
    this posix interface provides. For instance, threads other then
    the thread waiting on the Android alarm driver are able to modify
    the alarm being waited on. Also this interface does not allow
    the same wakelock semantics that the Android driver provides
    (ie: kernel takes a wakelock on RTC alarm-interupt, and holds it
    through process wakeup, and while the process runs, until the
    process either closes the char device or calls back in to wait
    on a new alarm).
    
    One potential way to implement similar semantics may be via
    the timerfd infrastructure, but this needs more research.
    
    There may also need to be some sort of sysfs system level policy
    hooks that allow alarm timers to be disabled to keep them
    from firing at inappropriate times (ie: laptop in a well insulated
    bag, mid-flight).
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alessandro Zummo <a.zummo@towertech.it>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4ea5a75fcacd..b3061782dec3 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -295,6 +295,8 @@ struct itimerval {
 #define CLOCK_REALTIME_COARSE		5
 #define CLOCK_MONOTONIC_COARSE		6
 #define CLOCK_BOOTTIME			7
+#define CLOCK_REALTIME_ALARM		8
+#define CLOCK_BOOTTIME_ALARM		9
 
 /*
  * The IDs of various hardware clocks:

commit 304529b1b6f8612ccbb4582e997051b48b94f4a4
Author: John Stultz <john.stultz@linaro.org>
Date:   Fri Apr 1 14:32:09 2011 -0700

    time: Add timekeeping_inject_sleeptime
    
    Some platforms cannot implement read_persistent_clock, as
    their RTC devices are only accessible when interrupts are enabled.
    This keeps them from being used by the timekeeping code on resume
    to measure the time in suspend.
    
    The RTC layer tries to work around this, by calling do_settimeofday
    on resume after irqs are reenabled to set the time properly. However,
    this only corrects CLOCK_REALTIME, and does not properly adjust
    the sleep time value. This causes btime in /proc/stat to be incorrect
    as well as making the new CLOCK_BOTTTIME inaccurate.
    
    This patch resolves the issue by introducing a new timekeeping hook
    to allow the RTC layer to inject the sleep time on resume.
    
    The code also checks to make sure that read_persistent_clock is
    nonfunctional before setting the sleep time, so that should the RTC's
    HCTOSYS option be configured in on a system that does support
    read_persistent_clock we will not increase the total_sleep_time twice.
    
    CC: Arve Hjønnevåg <arve@android.com>
    CC: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 454a26205787..4ea5a75fcacd 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -126,6 +126,7 @@ struct timespec __current_kernel_time(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
 void get_xtime_and_monotonic_and_sleep_offset(struct timespec *xtim,
 				struct timespec *wtom, struct timespec *sleep);
+void timekeeping_inject_sleeptime(struct timespec *delta);
 
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })

commit 70a08cca1227dc31c784ec930099a4417a06e7d0
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 15 10:45:16 2011 -0800

    timers: Add CLOCK_BOOTTIME hrtimer base
    
    CLOCK_MONOTONIC stops while the system is in suspend. This is because
    to applications system suspend is invisible. However, there is a
    growing set of applications that are wanting to be suspend-aware,
    but do not want to deal with the complications of CLOCK_REALTIME
    (which might jump around if settimeofday is called).
    
    For these applications, I propose a new clockid: CLOCK_BOOTTIME.
    CLOCK_BOOTTIME is idential to CLOCK_MONOTONIC, except it also
    includes any time spent in suspend.
    
    This patch add hrtimer base for CLOCK_BOOTTIME, using
    get_monotonic_boottime/ktime_get_boottime, to allow
    in kernel users to set timers against.
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 02d48fb30b41..454a26205787 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -293,6 +293,7 @@ struct itimerval {
 #define CLOCK_MONOTONIC_RAW		4
 #define CLOCK_REALTIME_COARSE		5
 #define CLOCK_MONOTONIC_COARSE		6
+#define CLOCK_BOOTTIME			7
 
 /*
  * The IDs of various hardware clocks:

commit 314ac37150011ebb398f522db528d2dbcc611189
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 14 18:43:08 2011 -0800

    time: Extend get_xtime_and_monotonic_offset() to also return sleep
    
    Extend get_xtime_and_monotonic_offset to
    get_xtime_and_monotonic_and_sleep_offset().
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index fa39150cb816..02d48fb30b41 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -124,7 +124,8 @@ unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
 struct timespec __current_kernel_time(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
-void get_xtime_and_monotonic_offset(struct timespec *xtim, struct timespec *wtom);
+void get_xtime_and_monotonic_and_sleep_offset(struct timespec *xtim,
+				struct timespec *wtom, struct timespec *sleep);
 
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })

commit abb3a4ea2e0ea7114a4475745da2f32bd9ad5b73
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Feb 14 17:52:09 2011 -0800

    time: Introduce get_monotonic_boottime and ktime_get_boottime
    
    This adds new functions that return the monotonic time since boot
    (in other words, CLOCK_MONOTONIC + suspend time).
    
    CC: Jamie Lokier <jamie@shareable.org>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Alexander Shishkin <virtuoso@slind.org>
    CC: Arve Hjønnevåg <arve@android.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 379b9037b5b4..fa39150cb816 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -161,6 +161,7 @@ extern void getnstime_raw_and_real(struct timespec *ts_raw,
 		struct timespec *ts_real);
 extern void getboottime(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
+extern void get_monotonic_boottime(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);

commit c528f7c6c208f1fae6b4025957173dec045e5f21
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 1 13:52:17 2011 +0000

    time: Introduce timekeeping_inject_offset
    
    This adds a kernel-internal timekeeping interface to add or subtract
    a fixed amount from CLOCK_REALTIME. This makes it so kernel users or
    interfaces trying to do so do not have to read the time, then add an
    offset and then call settimeofday(), which adds some extra error in
    comparision to just simply adding the offset in the kernel timekeeping
    core.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    LKML-Reference: <20110201134419.584311693@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 7c44e7778033..379b9037b5b4 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -166,6 +166,7 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
 extern void timekeeping_leap_insert(int leapsecond);
+extern int timekeeping_inject_offset(struct timespec *ts);
 
 struct tms;
 extern void do_sys_times(struct tms *);

commit 1e6d767924c74929c0cfe839ae8f37bcee9e544e
Author: Richard Cochran <richard.cochran@omicron.at>
Date:   Tue Feb 1 13:50:58 2011 +0000

    time: Correct the *settime* parameters
    
    Both settimeofday() and clock_settime() promise with a 'const'
    attribute not to alter the arguments passed in. This patch adds the
    missing 'const' attribute into the various kernel functions
    implementing these calls.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <20110201134417.545698637@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 38c5206c2673..7c44e7778033 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -145,8 +145,9 @@ static inline u32 arch_gettimeoffset(void) { return 0; }
 #endif
 
 extern void do_gettimeofday(struct timeval *tv);
-extern int do_settimeofday(struct timespec *tv);
-extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
+extern int do_settimeofday(const struct timespec *tv);
+extern int do_sys_settimeofday(const struct timespec *tv,
+			       const struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
 extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 struct itimerval;

commit e2830b5c1b2b2217894370a3b95af87d4a958401
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 16:00:32 2011 +0100

    time: Make do_timer() and xtime_lock local to kernel/time/
    
    All callers of do_timer() are converted to xtime_update(). The only
    users of xtime_lock are in kernel/time/. Make both local to
    kernel/time/ and remove them from the global header files.
    
    [ tglx: Reuse tick-internal.h instead of creating another local header
            file. Massaged changelog ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index ce29c86882b1..38c5206c2673 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -113,8 +113,6 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 #define timespec_valid(ts) \
 	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
 
-extern seqlock_t xtime_lock;
-
 extern void read_persistent_clock(struct timespec *ts);
 extern void read_boot_clock(struct timespec *ts);
 extern int update_persistent_clock(struct timespec now);

commit 79ecaf0d15344d78904becf0f25de3fc9b49d430
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 31 11:07:54 2011 +0100

    time: Remove unused __get_wall_to_monotonic()
    
    No users left. Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4007a12a1b50..ce29c86882b1 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -125,7 +125,6 @@ extern int timekeeping_suspended;
 unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
 struct timespec __current_kernel_time(void); /* does not take xtime_lock */
-struct timespec __get_wall_to_monotonic(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
 void get_xtime_and_monotonic_offset(struct timespec *xtim, struct timespec *wtom);
 

commit 48cf76f7104f655bbd48a75c7759dce82c3e1ab6
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 15:59:05 2011 +0100

    time: Provide get_xtime_and_monotonic_offset()
    
    The hrtimer code accesses timekeeping variables under
    xtime_lock. Provide a sensible accessor function and use it.
    
    [ tglx: Removed the conditionals, unused variable, fixed codingstyle
            and massaged changelog ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    LKML-Reference: <20110127145905.23248.30458.stgit@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 86a9c487fdd8..4007a12a1b50 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -127,6 +127,7 @@ struct timespec current_kernel_time(void);
 struct timespec __current_kernel_time(void); /* does not take xtime_lock */
 struct timespec __get_wall_to_monotonic(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
+void get_xtime_and_monotonic_offset(struct timespec *xtim, struct timespec *wtom);
 
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })

commit 871cf1e5f2a17702f58539a3af8b18fc8666ad4c
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 15:58:55 2011 +0100

    time: Move do_timer() to kernel/time/timekeeping.c
    
    do_timer() is primary timekeeping related. calc_global_load() is
    called from do_timer() as well, but that's more for historical
    reasons.
    
    [ tglx: Fixed up the calc_global_load() reject andmassaged changelog ]
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: yong.zhang0@gmail.com
    Cc: hch@infradead.org
    LKML-Reference: <20110127145855.23248.56933.stgit@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 1e6d3b59238d..86a9c487fdd8 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -166,7 +166,6 @@ extern void monotonic_to_bootbased(struct timespec *ts);
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
-extern void update_wall_time(void);
 extern void timekeeping_leap_insert(int leapsecond);
 
 struct tms;

commit e2c18e49a0d4f822ffc29fb4958943beb1ff08b7
Author: Alexander Gordeev <lasaine@lvk.cs.msu.su>
Date:   Wed Jan 12 17:00:57 2011 -0800

    pps: capture MONOTONIC_RAW timestamps as well
    
    MONOTONIC_RAW clock timestamps are ideally suited for frequency
    calculation and also fit well into the original NTP hardpps design.  Now
    phase and frequency can be adjusted separately: the former based on
    REALTIME clock and the latter based on MONOTONIC_RAW clock.
    
    A new function getnstime_raw_and_real is added to timekeeping subsystem to
    capture both timestamps at the same time and atomically.
    
    Signed-off-by: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Rodolfo Giometti <giometti@enneenne.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 9f15ac7ab92a..1e6d3b59238d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -158,6 +158,8 @@ extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
 extern void getrawmonotonic(struct timespec *ts);
+extern void getnstime_raw_and_real(struct timespec *ts_raw,
+		struct timespec *ts_real);
 extern void getboottime(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
 

commit c7887325230aec47d47a32562a6e26014a0fafca
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 11 11:26:22 2010 +0100

    Mark arguments to certain syscalls as being const
    
    Mark arguments to certain system calls as being const where they should be but
    aren't.  The list includes:
    
     (*) The filename arguments of various stat syscalls, execve(), various utimes
         syscalls and some mount syscalls.
    
     (*) The filename arguments of some syscall helpers relating to the above.
    
     (*) The buffer argument of various write syscalls.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 12612701b1ae..9f15ac7ab92a 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -150,7 +150,7 @@ extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-extern long do_utimes(int dfd, char __user *filename, struct timespec *times, int flags);
+extern long do_utimes(int dfd, const char __user *filename, struct timespec *times, int flags);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);

commit 4936a3b90d79dd8775c6ac23c2cf2dcebe29abde
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Aug 9 14:20:10 2010 -0700

    x86/hpet: Use the FSEC_PER_SEC constant for femto-second periods
    
    The current computation, introduced with f12a15be63, of FSEC_PER_SEC using
    the multiplication of (FSEC_PER_NSEC * NSEC_PER_SEC) is performed only
    with 32bit integers on small machines, resulting in an overflow and a
    *very* short intervals being programmed.  An interrupt storm follows.
    
    Note that we also have to specify FSEC_PER_SEC as being long long to
    overcome the same limitations.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index cb34e35fabac..12612701b1ae 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -38,7 +38,7 @@ extern struct timezone sys_tz;
 #define NSEC_PER_MSEC	1000000L
 #define USEC_PER_SEC	1000000L
 #define NSEC_PER_SEC	1000000000L
-#define FSEC_PER_SEC	1000000000000000L
+#define FSEC_PER_SEC	1000000000000000LL
 
 #define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
 

commit 0fb86b06298b6cd3205cac2e68a499f269282dac
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:26 2010 -0700

    timekeeping: Make xtime and wall_to_monotonic static
    
    This patch makes xtime and wall_to_monotonic static, as planned in
    Documentation/feature-removal-schedule.txt. This will allow for
    further cleanups to the timekeeping core.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1279068988-21864-10-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index a57e0f67b3d0..cb34e35fabac 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -113,8 +113,6 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 #define timespec_valid(ts) \
 	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
 
-extern struct timespec xtime;
-extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
 
 extern void read_persistent_clock(struct timespec *ts);

commit 8ab4351a4c888016620f43bde605b3d0964af339
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:25 2010 -0700

    hrtimer: Cleanup direct access to wall_to_monotonic
    
    Provides an accessor function to replace hrtimer.c's
    direct access of wall_to_monotonic.
    
    This will allow wall_to_monotonic to be made static as
    planned in Documentation/feature-removal-schedule.txt
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1279068988-21864-9-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 9072df83de1f..a57e0f67b3d0 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -126,7 +126,8 @@ extern int timekeeping_suspended;
 
 unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
-struct timespec __current_kernel_time(void); /* does not hold xtime_lock */
+struct timespec __current_kernel_time(void); /* does not take xtime_lock */
+struct timespec __get_wall_to_monotonic(void); /* does not take xtime_lock */
 struct timespec get_monotonic_coarse(void);
 
 #define CURRENT_TIME		(current_kernel_time())

commit ce3bf7ab22527183634a76512d9854a38615e4d5
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Jul 13 17:56:19 2010 -0700

    time: Implement timespec_add
    
    After accidentally misusing timespec_add_safe, I wanted to make sure
    we don't accidently trip over that issue again, so I created a simple
    timespec_add() function which we can use to replace the instances
    of timespec_add_safe() that don't want the overflow detection.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1279068988-21864-3-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index ea3559f0b3f2..9072df83de1f 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -76,9 +76,25 @@ extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 			    const unsigned int min, const unsigned int sec);
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
+
+/*
+ * timespec_add_safe assumes both values are positive and checks
+ * for overflow. It will return TIME_T_MAX if the reutrn would be
+ * smaller then either of the arguments.
+ */
 extern struct timespec timespec_add_safe(const struct timespec lhs,
 					 const struct timespec rhs);
 
+
+static inline struct timespec timespec_add(struct timespec lhs,
+						struct timespec rhs)
+{
+	struct timespec ts_delta;
+	set_normalized_timespec(&ts_delta, lhs.tv_sec + rhs.tv_sec,
+				lhs.tv_nsec + rhs.tv_nsec);
+	return ts_delta;
+}
+
 /*
  * sub = lhs - rhs, in normalized form
  */

commit 6a867a395558a7f882d041783e4cdea6744ca2bf
Author: John Stultz <johnstul@us.ibm.com>
Date:   Tue Apr 6 14:30:51 2010 -0700

    time: Remove xtime_cache
    
    With the earlier logarithmic time accumulation patch, xtime will now
    always be within one "tick" of the current time, instead of possibly
    half a second off.
    
    This removes the need for the xtime_cache value, which always stored the
    time at the last interrupt, so this patch cleans that up removing the
    xtime_cache related code.
    
    This patch also addresses an issue with an earlier version of this change,
    where xtime_cache was normalizing xtime, which could in some cases be
    not valid (ie: tv_nsec == NSEC_PER_SEC). This is fixed by handling
    the edge case in update_wall_time().
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Petr Titěra <P.Titera@century.cz>
    LKML-Reference: <1270589451-30773-1-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 6e026e45a179..ea3559f0b3f2 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -150,7 +150,6 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern u64 timekeeping_max_deferment(void);
 extern void update_wall_time(void);
-extern void update_xtime_cache(u64 nsec);
 extern void timekeeping_leap_insert(int leapsecond);
 
 struct tms;

commit 98962465ed9e6ea99c38e0af63fe1dcb5a79dc25
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Tue Aug 18 12:45:10 2009 -0500

    nohz: Prevent clocksource wrapping during idle
    
    The dynamic tick allows the kernel to sleep for periods longer than a
    single tick, but it does not limit the sleep time currently. In the
    worst case the kernel could sleep longer than the wrap around time of
    the time keeping clock source which would result in losing track of
    time.
    
    Prevent this by limiting it to the safe maximum sleep time of the
    current time keeping clock source. The value is calculated when the
    clock source is registered.
    
    [ tglx: simplified the code a bit and massaged the commit msg ]
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    LKML-Reference: <1250617512-23567-2-git-send-email-jon-hunter@ti.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index fe04e5ef6a59..6e026e45a179 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -148,6 +148,7 @@ extern void monotonic_to_bootbased(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
+extern u64 timekeeping_max_deferment(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 extern void timekeeping_leap_insert(int leapsecond);

commit 57f1f0874f426a9bdfc5cd3f886113dd5cd17834
Author: Zhaolei <zhaolei@cn.fujitsu.com>
Date:   Wed Sep 23 15:56:10 2009 -0700

    time: add function to convert between calendar time and broken-down time for universal use
    
    There are many similar code in kernel for one object: convert time between
    calendar time and broken-down time.
    
    Here is some source I found:
      fs/ncpfs/dir.c
      fs/smbfs/proc.c
      fs/fat/misc.c
      fs/udf/udftime.c
      fs/cifs/netmisc.c
      net/netfilter/xt_time.c
      drivers/scsi/ips.c
      drivers/input/misc/hp_sdc_rtc.c
      drivers/rtc/rtc-lib.c
      arch/ia64/hp/sim/boot/fw-emu.c
      arch/m68k/mac/misc.c
      arch/powerpc/kernel/time.c
      arch/parisc/include/asm/rtc.h
      ...
    
    We can make a common function for this type of conversion, At least we
    can get following benefit:
    
    1: Make kernel simple and unify
    2: Easy to fix bug in converting code
    3: Reduce clone of code in future
       For example, I'm trying to make ftrace display walltime,
       this patch will make me easy.
    
    This code is based on code from glibc-2.6
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 56787c093345..fe04e5ef6a59 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -155,6 +155,34 @@ extern void timekeeping_leap_insert(int leapsecond);
 struct tms;
 extern void do_sys_times(struct tms *);
 
+/*
+ * Similar to the struct tm in userspace <time.h>, but it needs to be here so
+ * that the kernel source is self contained.
+ */
+struct tm {
+	/*
+	 * the number of seconds after the minute, normally in the range
+	 * 0 to 59, but can be up to 60 to allow for leap seconds
+	 */
+	int tm_sec;
+	/* the number of minutes after the hour, in the range 0 to 59*/
+	int tm_min;
+	/* the number of hours past midnight, in the range 0 to 23 */
+	int tm_hour;
+	/* the day of the month, in the range 1 to 31 */
+	int tm_mday;
+	/* the number of months since January, in the range 0 to 11 */
+	int tm_mon;
+	/* the number of years since 1900 */
+	long tm_year;
+	/* the number of days since Sunday, in the range 0 to 6 */
+	int tm_wday;
+	/* the number of days since January 1, in the range 0 to 365 */
+	int tm_yday;
+};
+
+void time_to_tm(time_t totalsecs, int offset, struct tm *result);
+
 /**
  * timespec_to_ns - Convert timespec to nanoseconds
  * @ts:		pointer to the timespec variable to be converted

commit 12e09337fe238981cb0c87543306e23775d1a143
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 23:37:40 2009 +0200

    time: Prevent 32 bit overflow with set_normalized_timespec()
    
    set_normalized_timespec() nsec argument is of type long. The recent
    timekeeping changes of ktime_get_ts() feed
    
            ts->tv_nsec + tomono.tv_nsec + nsecs
    
    to set_normalized_timespec(). On 32 bit machines that sum can be
    larger than (1 << 31) and therefor result in a negative value which
    screws up the result completely.
    
    Make the nsec argument of set_normalized_timespec() s64 to fix the
    problem at hand. This also prevents similar problems for future users
    of set_normalized_timespec().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Carsten Emde <carsten.emde@osadl.org>
    LKML-Reference: <new-submission>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: John Stultz <johnstul@us.ibm.com>

diff --git a/include/linux/time.h b/include/linux/time.h
index 256232f7e5e6..56787c093345 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -75,7 +75,7 @@ extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 			    const unsigned int day, const unsigned int hour,
 			    const unsigned int min, const unsigned int sec);
 
-extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
+extern void set_normalized_timespec(struct timespec *ts, time_t sec, s64 nsec);
 extern struct timespec timespec_add_safe(const struct timespec lhs,
 					 const struct timespec rhs);
 

commit da15cfdae03351c689736f8d142618592e3cebc3
Author: john stultz <johnstul@us.ibm.com>
Date:   Wed Aug 19 19:13:34 2009 -0700

    time: Introduce CLOCK_REALTIME_COARSE
    
    After talking with some application writers who want very fast, but not
    fine-grained timestamps, I decided to try to implement new clock_ids
    to clock_gettime(): CLOCK_REALTIME_COARSE and CLOCK_MONOTONIC_COARSE
    which returns the time at the last tick. This is very fast as we don't
    have to access any hardware (which can be very painful if you're using
    something like the acpi_pm clocksource), and we can even use the vdso
    clock_gettime() method to avoid the syscall. The only trade off is you
    only get low-res tick grained time resolution.
    
    This isn't a new idea, I know Ingo has a patch in the -rt tree that made
    the vsyscall gettimeofday() return coarse grained time when the
    vsyscall64 sysctrl was set to 2. However this affects all applications
    on a system.
    
    With this method, applications can choose the proper speed/granularity
    trade-off for themselves.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: nikolag@ca.ibm.com
    Cc: Darren Hart <dvhltc@us.ibm.com>
    Cc: arjan@infradead.org
    Cc: jonathan@jonmasters.org
    LKML-Reference: <1250734414.6897.5.camel@localhost.localdomain>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index f505988398e6..256232f7e5e6 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -110,6 +110,8 @@ extern int timekeeping_suspended;
 
 unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
+struct timespec __current_kernel_time(void); /* does not hold xtime_lock */
+struct timespec get_monotonic_coarse(void);
 
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
@@ -243,6 +245,8 @@ struct itimerval {
 #define CLOCK_PROCESS_CPUTIME_ID	2
 #define CLOCK_THREAD_CPUTIME_ID		3
 #define CLOCK_MONOTONIC_RAW		4
+#define CLOCK_REALTIME_COARSE		5
+#define CLOCK_MONOTONIC_COARSE		6
 
 /*
  * The IDs of various hardware clocks:

commit 23970e389e9cee43c4b41023935e1417271708b2
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:32 2009 +0200

    timekeeping: Introduce read_boot_clock
    
    Add the new function read_boot_clock to get the exact time the system
    has been started. For architectures without support for exact boot
    time a new weak function is added that returns 0.  Use the exact boot
    time to initialize wall_to_monotonic, or xtime if the read_boot_clock
    returned 0.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.296703241@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 53a3216f0d1b..f505988398e6 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -102,6 +102,7 @@ extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
 
 extern void read_persistent_clock(struct timespec *ts);
+extern void read_boot_clock(struct timespec *ts);
 extern int update_persistent_clock(struct timespec now);
 extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);

commit d4f587c67fc39e0030ddd718675e252e208da4d7
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:31 2009 +0200

    timekeeping: Increase granularity of read_persistent_clock()
    
    The persistent clock of some architectures (e.g. s390) have a
    better granularity than seconds. To reduce the delta between the
    host clock and the guest clock in a virtualized system change the
    read_persistent_clock function to return a struct timespec.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.013873340@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index e7c844558884..53a3216f0d1b 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -101,7 +101,7 @@ extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
 
-extern unsigned long read_persistent_clock(void);
+extern void read_persistent_clock(struct timespec *ts);
 extern int update_persistent_clock(struct timespec now);
 extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);

commit 31089c13bcb18d2cd2a3ddfbe3a28666346f237e
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Aug 14 15:47:18 2009 +0200

    timekeeping: Introduce timekeeping_leap_insert
    
    Move the adjustment of xtime, wall_to_monotonic and the update of the
    vsyscall variables to the timekeeping code.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <20090814134807.609730216@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index ea16c1a01d51..e7c844558884 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -147,6 +147,7 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_valid_for_hres(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
+extern void timekeeping_leap_insert(int leapsecond);
 
 struct tms;
 extern void do_sys_times(struct tms *);

commit 7d27558c4138ac6b3684dea35c2f4379b940a7dd
Author: john stultz <johnstul@us.ibm.com>
Date:   Fri May 1 13:10:26 2009 -0700

    timekeeping: create arch_gettimeoffset infrastructure
    
    Some arches don't supply their own clocksource. This is mainly the
    case in architectures that get their inter-tick times by reading the
    counter on their interval timer.  Since these timers wrap every tick,
    they're not really useful as clocksources.  Wrapping them to act like
    one is possible but not very efficient. So we provide a callout these
    arches can implement for use with the jiffies clocksource to provide
    finer then tick granular time.
    
    [ Impact: ease the migration to generic time keeping ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 242f62499bb7..ea16c1a01d51 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -113,6 +113,21 @@ struct timespec current_kernel_time(void);
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
 
+/* Some architectures do not supply their own clocksource.
+ * This is mainly the case in architectures that get their
+ * inter-tick times by reading the counter on their interval
+ * timer. Since these timers wrap every tick, they're not really
+ * useful as clocksources. Wrapping them to act like one is possible
+ * but not very efficient. So we provide a callout these arches
+ * can implement for use with the jiffies clocksource to provide
+ * finer then tick granular time.
+ */
+#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET
+extern u32 arch_gettimeoffset(void);
+#else
+static inline u32 arch_gettimeoffset(void) { return 0; }
+#endif
+
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);

commit 85efde6f4e0de9577256c5f0030088d3fd4347c1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 26 00:51:39 2009 +0100

    make exported headers use strict posix types
    
    A number of standard posix types are used in exported headers, which
    is not allowed if __STRICT_KERNEL_NAMES is defined. In order to
    get rid of the non-__STRICT_KERNEL_NAMES part and to make sane headers
    the default, we have to change them all to safe types.
    
    There are also still some leftovers in reiserfs_fs.h, elfcore.h
    and coda.h, but these files have not compiled in user space for
    a long time.
    
    This leaves out the various integer types ({u_,u,}int{8,16,32,64}_t),
    which we take care of separately.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Cc: netdev@vger.kernel.org
    Cc: linux-ppp@vger.kernel.org
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index fbbd2a1c92ba..242f62499bb7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -12,14 +12,14 @@
 #ifndef _STRUCT_TIMESPEC
 #define _STRUCT_TIMESPEC
 struct timespec {
-	time_t	tv_sec;		/* seconds */
-	long	tv_nsec;	/* nanoseconds */
+	__kernel_time_t	tv_sec;			/* seconds */
+	long		tv_nsec;		/* nanoseconds */
 };
 #endif
 
 struct timeval {
-	time_t		tv_sec;		/* seconds */
-	suseconds_t	tv_usec;	/* microseconds */
+	__kernel_time_t		tv_sec;		/* seconds */
+	__kernel_suseconds_t	tv_usec;	/* microseconds */
 };
 
 struct timezone {

commit 1c5745aa380efb6417b5681104b007c8612fb496
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Dec 22 23:05:28 2008 +0100

    sched_clock: prevent scd->clock from moving backwards, take #2
    
    Redo:
    
      5b7dba4: sched_clock: prevent scd->clock from moving backwards
    
    which had to be reverted due to s2ram hangs:
    
      ca7e716: Revert "sched_clock: prevent scd->clock from moving backwards"
    
    ... this time with resume restoring GTOD later in the sequence
    taken into account as well.
    
    The "timekeeping_suspended" flag is not very nice but we cannot call into
    GTOD before it has been properly resumed and the scheduler will run very
    early in the resume sequence.
    
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index ce321ac5c8f8..fbbd2a1c92ba 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -105,6 +105,7 @@ extern unsigned long read_persistent_clock(void);
 extern int update_persistent_clock(struct timespec now);
 extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);
+extern int timekeeping_suspended;
 
 unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);

commit 268a3dcfea2077fca60d3715caa5c96f9b5e6ea7
Merge: c4bd822e7b12 592aa999d6a2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Oct 22 09:48:06 2008 +0200

    Merge branch 'timers/range-hrtimers' into v28-range-hrtimers-for-linus-v2
    
    Conflicts:
    
            kernel/time/tick-sched.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit c465a76af658b443075d6efee1c3131257643020
Merge: 2d42244ae71d 1b02469088ac fb02fbc14d17 d40e944c25fb 1508487e7f16 322acf6585f3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Oct 20 13:14:06 2008 +0200

    Merge branches 'timers/clocksource', 'timers/hrtimers', 'timers/nohz', 'timers/ntp', 'timers/posixtimers' and 'timers/debug' into v28-timers-for-linus

commit 651dab4264e4ba0e563f5ff56f748127246e9065
Merge: 40b860625355 2e532d68a2b3
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Fri Oct 17 09:20:26 2008 -0700

    Merge commit 'linus/master' into merge-linus
    
    Conflicts:
    
            arch/x86/kvm/i8254.c

commit b418da16dd44810e5d5a22bba377cca80512a524
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 15 22:02:06 2008 -0700

    compat: generic compat get/settimeofday
    
    Nothing arch specific in get/settimeofday.  The details of the timeval
    conversion varied a little from arch to arch, but all with the same
    results.
    
    Also add an extern declaration for sys_tz to linux/time.h because externs
    in .c files are fowned upon.  I'll kill the externs in various other files
    in a sparate patch.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: David S. Miller <davem@davemloft.net> [ sparc bits ]
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index e15206a7e82e..51e883df0fa5 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -29,6 +29,8 @@ struct timezone {
 
 #ifdef __KERNEL__
 
+extern struct timezone sys_tz;
+
 /* Parameters used to convert the timespec values: */
 #define MSEC_PER_SEC	1000L
 #define USEC_PER_MSEC	1000L

commit f06febc96ba8e0af80bcc3eaec0a109e88275fac
Author: Frank Mayhar <fmayhar@google.com>
Date:   Fri Sep 12 09:54:39 2008 -0700

    timers: fix itimer/many thread hang
    
    Overview
    
    This patch reworks the handling of POSIX CPU timers, including the
    ITIMER_PROF, ITIMER_VIRT timers and rlimit handling.  It was put together
    with the help of Roland McGrath, the owner and original writer of this code.
    
    The problem we ran into, and the reason for this rework, has to do with using
    a profiling timer in a process with a large number of threads.  It appears
    that the performance of the old implementation of run_posix_cpu_timers() was
    at least O(n*3) (where "n" is the number of threads in a process) or worse.
    Everything is fine with an increasing number of threads until the time taken
    for that routine to run becomes the same as or greater than the tick time, at
    which point things degrade rather quickly.
    
    This patch fixes bug 9906, "Weird hang with NPTL and SIGPROF."
    
    Code Changes
    
    This rework corrects the implementation of run_posix_cpu_timers() to make it
    run in constant time for a particular machine.  (Performance may vary between
    one machine and another depending upon whether the kernel is built as single-
    or multiprocessor and, in the latter case, depending upon the number of
    running processors.)  To do this, at each tick we now update fields in
    signal_struct as well as task_struct.  The run_posix_cpu_timers() function
    uses those fields to make its decisions.
    
    We define a new structure, "task_cputime," to contain user, system and
    scheduler times and use these in appropriate places:
    
    struct task_cputime {
            cputime_t utime;
            cputime_t stime;
            unsigned long long sum_exec_runtime;
    };
    
    This is included in the structure "thread_group_cputime," which is a new
    substructure of signal_struct and which varies for uniprocessor versus
    multiprocessor kernels.  For uniprocessor kernels, it uses "task_cputime" as
    a simple substructure, while for multiprocessor kernels it is a pointer:
    
    struct thread_group_cputime {
            struct task_cputime totals;
    };
    
    struct thread_group_cputime {
            struct task_cputime *totals;
    };
    
    We also add a new task_cputime substructure directly to signal_struct, to
    cache the earliest expiration of process-wide timers, and task_cputime also
    replaces the it_*_expires fields of task_struct (used for earliest expiration
    of thread timers).  The "thread_group_cputime" structure contains process-wide
    timers that are updated via account_user_time() and friends.  In the non-SMP
    case the structure is a simple aggregator; unfortunately in the SMP case that
    simplicity was not achievable due to cache-line contention between CPUs (in
    one measured case performance was actually _worse_ on a 16-cpu system than
    the same test on a 4-cpu system, due to this contention).  For SMP, the
    thread_group_cputime counters are maintained as a per-cpu structure allocated
    using alloc_percpu().  The timer functions update only the timer field in
    the structure corresponding to the running CPU, obtained using per_cpu_ptr().
    
    We define a set of inline functions in sched.h that we use to maintain the
    thread_group_cputime structure and hide the differences between UP and SMP
    implementations from the rest of the kernel.  The thread_group_cputime_init()
    function initializes the thread_group_cputime structure for the given task.
    The thread_group_cputime_alloc() is a no-op for UP; for SMP it calls the
    out-of-line function thread_group_cputime_alloc_smp() to allocate and fill
    in the per-cpu structures and fields.  The thread_group_cputime_free()
    function, also a no-op for UP, in SMP frees the per-cpu structures.  The
    thread_group_cputime_clone_thread() function (also a UP no-op) for SMP calls
    thread_group_cputime_alloc() if the per-cpu structures haven't yet been
    allocated.  The thread_group_cputime() function fills the task_cputime
    structure it is passed with the contents of the thread_group_cputime fields;
    in UP it's that simple but in SMP it must also safely check that tsk->signal
    is non-NULL (if it is it just uses the appropriate fields of task_struct) and,
    if so, sums the per-cpu values for each online CPU.  Finally, the three
    functions account_group_user_time(), account_group_system_time() and
    account_group_exec_runtime() are used by timer functions to update the
    respective fields of the thread_group_cputime structure.
    
    Non-SMP operation is trivial and will not be mentioned further.
    
    The per-cpu structure is always allocated when a task creates its first new
    thread, via a call to thread_group_cputime_clone_thread() from copy_signal().
    It is freed at process exit via a call to thread_group_cputime_free() from
    cleanup_signal().
    
    All functions that formerly summed utime/stime/sum_sched_runtime values from
    from all threads in the thread group now use thread_group_cputime() to
    snapshot the values in the thread_group_cputime structure or the values in
    the task structure itself if the per-cpu structure hasn't been allocated.
    
    Finally, the code in kernel/posix-cpu-timers.c has changed quite a bit.
    The run_posix_cpu_timers() function has been split into a fast path and a
    slow path; the former safely checks whether there are any expired thread
    timers and, if not, just returns, while the slow path does the heavy lifting.
    With the dedicated thread group fields, timers are no longer "rebalanced" and
    the process_timer_rebalance() function and related code has gone away.  All
    summing loops are gone and all code that used them now uses the
    thread_group_cputime() inline.  When process-wide timers are set, the new
    task_cputime structure in signal_struct is used to cache the earliest
    expiration; this is checked in the fast path.
    
    Performance
    
    The fix appears not to add significant overhead to existing operations.  It
    generally performs the same as the current code except in two cases, one in
    which it performs slightly worse (Case 5 below) and one in which it performs
    very significantly better (Case 2 below).  Overall it's a wash except in those
    two cases.
    
    I've since done somewhat more involved testing on a dual-core Opteron system.
    
    Case 1: With no itimer running, for a test with 100,000 threads, the fixed
            kernel took 1428.5 seconds, 513 seconds more than the unfixed system,
            all of which was spent in the system.  There were twice as many
            voluntary context switches with the fix as without it.
    
    Case 2: With an itimer running at .01 second ticks and 4000 threads (the most
            an unmodified kernel can handle), the fixed kernel ran the test in
            eight percent of the time (5.8 seconds as opposed to 70 seconds) and
            had better tick accuracy (.012 seconds per tick as opposed to .023
            seconds per tick).
    
    Case 3: A 4000-thread test with an initial timer tick of .01 second and an
            interval of 10,000 seconds (i.e. a timer that ticks only once) had
            very nearly the same performance in both cases:  6.3 seconds elapsed
            for the fixed kernel versus 5.5 seconds for the unfixed kernel.
    
    With fewer threads (eight in these tests), the Case 1 test ran in essentially
    the same time on both the modified and unmodified kernels (5.2 seconds versus
    5.8 seconds).  The Case 2 test ran in about the same time as well, 5.9 seconds
    versus 5.4 seconds but again with much better tick accuracy, .013 seconds per
    tick versus .025 seconds per tick for the unmodified kernel.
    
    Since the fix affected the rlimit code, I also tested soft and hard CPU limits.
    
    Case 4: With a hard CPU limit of 20 seconds and eight threads (and an itimer
            running), the modified kernel was very slightly favored in that while
            it killed the process in 19.997 seconds of CPU time (5.002 seconds of
            wall time), only .003 seconds of that was system time, the rest was
            user time.  The unmodified kernel killed the process in 20.001 seconds
            of CPU (5.014 seconds of wall time) of which .016 seconds was system
            time.  Really, though, the results were too close to call.  The results
            were essentially the same with no itimer running.
    
    Case 5: With a soft limit of 20 seconds and a hard limit of 2000 seconds
            (where the hard limit would never be reached) and an itimer running,
            the modified kernel exhibited worse tick accuracy than the unmodified
            kernel: .050 seconds/tick versus .028 seconds/tick.  Otherwise,
            performance was almost indistinguishable.  With no itimer running this
            test exhibited virtually identical behavior and times in both cases.
    
    In times past I did some limited performance testing.  those results are below.
    
    On a four-cpu Opteron system without this fix, a sixteen-thread test executed
    in 3569.991 seconds, of which user was 3568.435s and system was 1.556s.  On
    the same system with the fix, user and elapsed time were about the same, but
    system time dropped to 0.007 seconds.  Performance with eight, four and one
    thread were comparable.  Interestingly, the timer ticks with the fix seemed
    more accurate:  The sixteen-thread test with the fix received 149543 ticks
    for 0.024 seconds per tick, while the same test without the fix received 58720
    for 0.061 seconds per tick.  Both cases were configured for an interval of
    0.01 seconds.  Again, the other tests were comparable.  Each thread in this
    test computed the primes up to 25,000,000.
    
    I also did a test with a large number of threads, 100,000 threads, which is
    impossible without the fix.  In this case each thread computed the primes only
    up to 10,000 (to make the runtime manageable).  System time dominated, at
    1546.968 seconds out of a total 2176.906 seconds (giving a user time of
    629.938s).  It received 147651 ticks for 0.015 seconds per tick, still quite
    accurate.  There is obviously no comparable test without the fix.
    
    Signed-off-by: Frank Mayhar <fmayhar@google.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index e15206a7e82e..1b70b3c293e9 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -125,6 +125,9 @@ extern int timekeeping_valid_for_hres(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 
+struct tms;
+extern void do_sys_times(struct tms *);
+
 /**
  * timespec_to_ns - Convert timespec to nanoseconds
  * @ts:		pointer to the timespec variable to be converted

commit df0cc0539b4127bd02f64de2c335b4af1fdb3845
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Aug 31 08:09:53 2008 -0700

    select: add a timespec_add_safe() function
    
    For the select() rework, it's important to be able to add timespec
    structures in an overflow-safe manner.
    
    This patch adds a timespec_add_safe() function for this which is similar in
    operation to ktime_add_safe(), but works on a struct timespec.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/include/linux/time.h b/include/linux/time.h
index e15206a7e82e..726976478480 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -38,6 +38,8 @@ struct timezone {
 #define NSEC_PER_SEC	1000000000L
 #define FSEC_PER_SEC	1000000000000000L
 
+#define TIME_T_MAX	(time_t)((1UL << ((sizeof(time_t) << 3) - 1)) - 1)
+
 static inline int timespec_equal(const struct timespec *a,
                                  const struct timespec *b)
 {
@@ -72,6 +74,8 @@ extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 			    const unsigned int min, const unsigned int sec);
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
+extern struct timespec timespec_add_safe(const struct timespec lhs,
+					 const struct timespec rhs);
 
 /*
  * sub = lhs - rhs, in normalized form

commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Aug 20 16:37:30 2008 -0700

    clocksource: introduce CLOCK_MONOTONIC_RAW
    
    In talking with Josip Loncaric, and his work on clock synchronization (see
    btime.sf.net), he mentioned that for really close synchronization, it is
    useful to have access to "hardware time", that is a notion of time that is
    not in any way adjusted by the clock slewing done to keep close time sync.
    
    Part of the issue is if we are using the kernel's ntp adjusted
    representation of time in order to measure how we should correct time, we
    can run into what Paul McKenney aptly described as "Painting a road using
    the lines we're painting as the guide".
    
    I had been thinking of a similar problem, and was trying to come up with a
    way to give users access to a purely hardware based time representation
    that avoided users having to know the underlying frequency and mask values
    needed to deal with the wide variety of possible underlying hardware
    counters.
    
    My solution is to introduce CLOCK_MONOTONIC_RAW.  This exposes a
    nanosecond based time value, that increments starting at bootup and has no
    frequency adjustments made to it what so ever.
    
    The time is accessed from userspace via the posix_clock_gettime() syscall,
    passing CLOCK_MONOTONIC_RAW as the clock_id.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index e15206a7e82e..205f974b9ebf 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -117,6 +117,7 @@ extern int do_setitimer(int which, struct itimerval *value,
 extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
+extern void getrawmonotonic(struct timespec *ts);
 extern void getboottime(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
 
@@ -214,6 +215,7 @@ struct itimerval {
 #define CLOCK_MONOTONIC			1
 #define CLOCK_PROCESS_CPUTIME_ID	2
 #define CLOCK_THREAD_CPUTIME_ID		3
+#define CLOCK_MONOTONIC_RAW		4
 
 /*
  * The IDs of various hardware clocks:

commit 9412e28649d0272df5e4af57bb378926fd4df580
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Thu Jun 12 10:48:00 2008 +0200

    always_inline timespec_add_ns
    
    timespec_add_ns is used from the x86-64 vdso, which cannot call out to
    other kernel code.  Make sure that timespec_add_ns is always inlined
    (and only uses always_inlined functions) to make sure there are no
    unexpected calls.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index 05f9517a8ed1..e15206a7e82e 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -170,10 +170,13 @@ extern struct timeval ns_to_timeval(const s64 nsec);
  * timespec_add_ns - Adds nanoseconds to a timespec
  * @a:		pointer to timespec to be incremented
  * @ns:		unsigned nanoseconds value to be added
+ *
+ * This must always be inlined because its used from the x86-64 vdso,
+ * which cannot call other kernel functions.
  */
-static inline void timespec_add_ns(struct timespec *a, u64 ns)
+static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 {
-	a->tv_sec += iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
+	a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
 	a->tv_nsec = ns;
 }
 #endif /* __KERNEL__ */

commit f595ec964daf7f99668039d7303ddedd09a75142
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Thu Jun 12 10:47:56 2008 +0200

    common implementation of iterative div/mod
    
    We have a few instances of the open-coded iterative div/mod loop, used
    when we don't expcet the dividend to be much bigger than the divisor.
    Unfortunately modern gcc's have the tendency to strength "reduce" this
    into a full mod operation, which isn't necessarily any faster, and
    even if it were, doesn't exist if gcc implements it in libgcc.
    
    The workaround is to put a dummy asm statement in the loop to prevent
    gcc from performing the transformation.
    
    This patch creates a single implementation of this loop, and uses it
    to replace the open-coded versions I know about.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: Christian Kujau <lists@nerdbynature.de>
    Cc: Robert Hancock <hancockr@shaw.ca>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index d32ef0ad4c0a..05f9517a8ed1 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -6,6 +6,7 @@
 #ifdef __KERNEL__
 # include <linux/cache.h>
 # include <linux/seqlock.h>
+# include <linux/math64.h>
 #endif
 
 #ifndef _STRUCT_TIMESPEC
@@ -172,15 +173,7 @@ extern struct timeval ns_to_timeval(const s64 nsec);
  */
 static inline void timespec_add_ns(struct timespec *a, u64 ns)
 {
-	ns += a->tv_nsec;
-	while(unlikely(ns >= NSEC_PER_SEC)) {
-		/* The following asm() prevents the compiler from
-		 * optimising this loop into a modulo operation.  */
-		asm("" : "+r"(ns));
-
-		ns -= NSEC_PER_SEC;
-		a->tv_sec++;
-	}
+	a->tv_sec += iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
 	a->tv_nsec = ns;
 }
 #endif /* __KERNEL__ */

commit 38332cb98772f5ea757e6486bed7ed0381cb5f98
Author: Segher Boessenkool <segher@kernel.crashing.org>
Date:   Tue Mar 4 14:59:54 2008 -0800

    time: prevent the loop in timespec_add_ns() from being optimised away
    
    Since some architectures don't support __udivdi3().
    
    Signed-off-by: Segher Boessenkool <segher@kernel.crashing.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/time.h b/include/linux/time.h
index 2091a19f1655..d32ef0ad4c0a 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -174,6 +174,10 @@ static inline void timespec_add_ns(struct timespec *a, u64 ns)
 {
 	ns += a->tv_nsec;
 	while(unlikely(ns >= NSEC_PER_SEC)) {
+		/* The following asm() prevents the compiler from
+		 * optimising this loop into a modulo operation.  */
+		asm("" : "+r"(ns));
+
 		ns -= NSEC_PER_SEC;
 		a->tv_sec++;
 	}

commit cf4fc6cb76e50b01666e28a9f4b2e6fbcbb96d5f
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Feb 8 04:19:24 2008 -0800

    timekeeping: rename timekeeping_is_continuous to timekeeping_valid_for_hres
    
    Function timekeeping_is_continuous() no longer checks flag
    CLOCK_IS_CONTINUOUS, and it checks CLOCK_SOURCE_VALID_FOR_HRES now.  So rename
    the function accordingly.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index ceaab9fff155..2091a19f1655 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -120,7 +120,7 @@ extern void getboottime(struct timespec *ts);
 extern void monotonic_to_bootbased(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
-extern int timekeeping_is_continuous(void);
+extern int timekeeping_valid_for_hres(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 

commit 1001d0a9ee74a468077dfd4da0565174e88de26b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 1 17:45:13 2008 +0100

    timekeeping: update xtime_cache when time(zone) changes
    
    xtime_cache needs to be updated whenever xtime and or wall_to_monotic
    are changed. Otherwise users of xtime_cache might see a stale (and in
    the case of timezone changes utterly wrong) value until the next
    update happens.
    
    Fixup the obvious places, which miss this update.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Tested-by: Dhaval Giani <dhaval@linux.vnet.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/time.h b/include/linux/time.h
index b04136d60a2f..ceaab9fff155 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -122,6 +122,7 @@ extern void monotonic_to_bootbased(struct timespec *ts);
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_is_continuous(void);
 extern void update_wall_time(void);
+extern void update_xtime_cache(u64 nsec);
 
 /**
  * timespec_to_ns - Convert timespec to nanoseconds

commit ba2a631b14fe8a9c122801c648c49a543d020d8d
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 23:27:16 2007 -0700

    kernel/time/timekeeping.c: cleanups
    
    - remove the no longer required __attribute__((weak)) of xtime_lock
    - remove the following no longer used EXPORT_SYMBOL's:
      - xtime
      - xtime_lock
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 6a5f503b4f1d..b04136d60a2f 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -92,7 +92,7 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
-extern seqlock_t xtime_lock __attribute__((weak));
+extern seqlock_t xtime_lock;
 
 extern unsigned long read_persistent_clock(void);
 extern int update_persistent_clock(struct timespec now);

commit 17c38b7490b3f0300c7812aefdae2ddda7ab4112
Author: john stultz <johnstul@us.ibm.com>
Date:   Tue Jul 24 18:38:34 2007 -0700

    Cache xtime every call to update_wall_time
    
    This avoids xtime lag seen with dynticks, because while 'xtime' itself
    is still not updated often, we keep a 'xtime_cache' variable around that
    contains the approximate real-time that _is_ updated each time we do a
    'update_wall_time()', and is thus never off by more than one tick.
    
    IOW, this restores the original semantics for 'xtime' users, as long as
    you use the proper abstraction functions (ie 'current_kernel_time()' or
    'get_seconds()' depending on whether you want a timespec or just the
    seconds field).
    
    [ Updated Patch.  As penance for my sins I've also yanked another #ifdef
      that was added to avoid the xtime lag w/ hrtimers.  ]
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 71181df8b744..6a5f503b4f1d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -99,11 +99,7 @@ extern int update_persistent_clock(struct timespec now);
 extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);
 
-static inline unsigned long get_seconds(void)
-{
-	return xtime.tv_sec;
-}
-
+unsigned long get_seconds(void);
 struct timespec current_kernel_time(void);
 
 #define CURRENT_TIME		(current_kernel_time())

commit 2c6b47de17c75d553de3e2fb426d8298d2074585
Author: john stultz <johnstul@us.ibm.com>
Date:   Tue Jul 24 17:47:43 2007 -0700

    Cleanup non-arch xtime uses, use get_seconds() or current_kernel_time().
    
    This avoids use of the kernel-internal "xtime" variable directly outside
    of the actual time-related functions.  Instead, use the helper functions
    that we already have available to us.
    
    This doesn't actually change any behaviour, but this will allow us to
    fix the fact that "xtime" isn't updated very often with CONFIG_NO_HZ
    (because much of the realtime information is maintained as separate
    offsets to 'xtime'), which has caused interfaces that use xtime directly
    to get a time that is out of sync with the real-time clock by up to a
    third of a second or so.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index e6aea5146e5d..71181df8b744 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -107,7 +107,7 @@ static inline unsigned long get_seconds(void)
 struct timespec current_kernel_time(void);
 
 #define CURRENT_TIME		(current_kernel_time())
-#define CURRENT_TIME_SEC	((struct timespec) { xtime.tv_sec, 0 })
+#define CURRENT_TIME_SEC	((struct timespec) { get_seconds(), 0 })
 
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);

commit 82644459c592a28a3eab682f9b88d81019ddfe8b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:37 2007 -0700

    NTP: move the cmos update code into ntp.c
    
    i386 and sparc64 have the identical code to update the cmos clock.  Move it
    into kernel/time/ntp.c as there are other architectures coming along with the
    same requirements.
    
    [akpm@linux-foundation.org: build fixes]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index ec3b0ced0afe..e6aea5146e5d 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -4,6 +4,7 @@
 #include <linux/types.h>
 
 #ifdef __KERNEL__
+# include <linux/cache.h>
 # include <linux/seqlock.h>
 #endif
 
@@ -94,6 +95,8 @@ extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock __attribute__((weak));
 
 extern unsigned long read_persistent_clock(void);
+extern int update_persistent_clock(struct timespec now);
+extern int no_sync_cmos_clock __read_mostly;
 void timekeeping_init(void);
 
 static inline unsigned long get_seconds(void)

commit 5b78cc9ac8602baafebb75a09025ffb17d1aebc2
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Tue Jul 17 04:03:53 2007 -0700

    make timespec_equal() take const arguments
    
    Make arguments of timespec_equal() const struct timespec.
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4bb05a829be9..ec3b0ced0afe 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -36,7 +36,8 @@ struct timezone {
 #define NSEC_PER_SEC	1000000000L
 #define FSEC_PER_SEC	1000000000000000L
 
-static inline int timespec_equal(struct timespec *a, struct timespec *b)
+static inline int timespec_equal(const struct timespec *a,
+                                 const struct timespec *b)
 {
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
 }

commit 7c3f1a573237b90ef331267260358a0ec4ac9079
Author: Tomas Janousek <tjanouse@redhat.com>
Date:   Sun Jul 15 23:39:41 2007 -0700

    Introduce boot based time
    
    The commits
    
      411187fb05cd11676b0979d9fbf3291db69dbce2 (GTOD: persistent clock support)
      c1d370e167d66b10bca3b602d3740405469383de (i386: use GTOD persistent clock
        support)
    
    changed the monotonic time so that it no longer jumps after resume, but it's
    not possible to use it for boot time and process start time calculations then.
     Also, the uptime no longer increases during suspend.
    
    I add a variable to track the wall_to_monotonic changes, a function to get the
    real boot time and a function to get the boot based time from the monotonic
    one.
    
    [akpm@linux-foundation.org: remove exports, add comment]
    Signed-off-by: Tomas Janousek <tjanouse@redhat.com>
    Cc: Tomas Smetana <tsmetana@redhat.com>
    Cc: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index dda9be685ab6..4bb05a829be9 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -116,6 +116,8 @@ extern int do_setitimer(int which, struct itimerval *value,
 extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
+extern void getboottime(struct timespec *ts);
+extern void monotonic_to_bootbased(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_is_continuous(void);

commit 1c710c896eb461895d3c399e15bb5f20b39c9073
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Tue May 8 00:33:25 2007 -0700

    utimensat implementation
    
    Implement utimensat(2) which is an extension to futimesat(2) in that it
    
    a) supports nano-second resolution for the timestamps
    b) allows to selectively ignore the atime/mtime value
    c) allows to selectively use the current time for either atime or mtime
    d) supports changing the atime/mtime of a symlink itself along the lines
       of the BSD lutimes(3) functions
    
    For this change the internally used do_utimes() functions was changed to
    accept a timespec time value and an additional flags parameter.
    
    Additionally the sys_utime function was changed to match compat_sys_utime
    which already use do_utimes instead of duplicating the work.
    
    Also, the completely missing futimensat() functionality is added.  We have
    such a function in glibc but we have to resort to using /proc/self/fd/* which
    not everybody likes (chroot etc).
    
    Test application (the syscall number will need per-arch editing):
    
    #include <errno.h>
    #include <fcntl.h>
    #include <time.h>
    #include <sys/time.h>
    #include <stddef.h>
    #include <syscall.h>
    
    #define __NR_utimensat 280
    
    #define UTIME_NOW       ((1l << 30) - 1l)
    #define UTIME_OMIT      ((1l << 30) - 2l)
    
    int
    main(void)
    {
      int status = 0;
    
      int fd = open("ttt", O_RDWR|O_CREAT|O_EXCL, 0666);
      if (fd == -1)
        error (1, errno, "failed to create test file \"ttt\"");
    
      struct stat64 st1;
      if (fstat64 (fd, &st1) != 0)
        error (1, errno, "fstat failed");
    
      struct timespec t[2];
      t[0].tv_sec = 0;
      t[0].tv_nsec = 0;
      t[1].tv_sec = 0;
      t[1].tv_nsec = 0;
      if (syscall(__NR_utimensat, AT_FDCWD, "ttt", t, 0) != 0)
        error (1, errno, "utimensat failed");
    
      struct stat64 st2;
      if (fstat64 (fd, &st2) != 0)
        error (1, errno, "fstat failed");
    
      if (st2.st_atim.tv_sec != 0 || st2.st_atim.tv_nsec != 0)
        {
          puts ("atim not reset to zero");
          status = 1;
        }
      if (st2.st_mtim.tv_sec != 0 || st2.st_mtim.tv_nsec != 0)
        {
          puts ("mtim not reset to zero");
          status = 1;
        }
      if (status != 0)
        goto out;
    
      t[0] = st1.st_atim;
      t[1].tv_sec = 0;
      t[1].tv_nsec = UTIME_OMIT;
      if (syscall(__NR_utimensat, AT_FDCWD, "ttt", t, 0) != 0)
        error (1, errno, "utimensat failed");
    
      if (fstat64 (fd, &st2) != 0)
        error (1, errno, "fstat failed");
    
      if (st2.st_atim.tv_sec != st1.st_atim.tv_sec
          || st2.st_atim.tv_nsec != st1.st_atim.tv_nsec)
        {
          puts ("atim not set");
          status = 1;
        }
      if (st2.st_mtim.tv_sec != 0 || st2.st_mtim.tv_nsec != 0)
        {
          puts ("mtim changed from zero");
          status = 1;
        }
      if (status != 0)
        goto out;
    
      t[0].tv_sec = 0;
      t[0].tv_nsec = UTIME_OMIT;
      t[1] = st1.st_mtim;
      if (syscall(__NR_utimensat, AT_FDCWD, "ttt", t, 0) != 0)
        error (1, errno, "utimensat failed");
    
      if (fstat64 (fd, &st2) != 0)
        error (1, errno, "fstat failed");
    
      if (st2.st_atim.tv_sec != st1.st_atim.tv_sec
          || st2.st_atim.tv_nsec != st1.st_atim.tv_nsec)
        {
          puts ("mtim changed from original time");
          status = 1;
        }
      if (st2.st_mtim.tv_sec != st1.st_mtim.tv_sec
          || st2.st_mtim.tv_nsec != st1.st_mtim.tv_nsec)
        {
          puts ("mtim not set");
          status = 1;
        }
      if (status != 0)
        goto out;
    
      sleep (2);
    
      t[0].tv_sec = 0;
      t[0].tv_nsec = UTIME_NOW;
      t[1].tv_sec = 0;
      t[1].tv_nsec = UTIME_NOW;
      if (syscall(__NR_utimensat, AT_FDCWD, "ttt", t, 0) != 0)
        error (1, errno, "utimensat failed");
    
      if (fstat64 (fd, &st2) != 0)
        error (1, errno, "fstat failed");
    
      struct timeval tv;
      gettimeofday(&tv,NULL);
    
      if (st2.st_atim.tv_sec <= st1.st_atim.tv_sec
          || st2.st_atim.tv_sec > tv.tv_sec)
        {
          puts ("atim not set to NOW");
          status = 1;
        }
      if (st2.st_mtim.tv_sec <= st1.st_mtim.tv_sec
          || st2.st_mtim.tv_sec > tv.tv_sec)
        {
          puts ("mtim not set to NOW");
          status = 1;
        }
    
      if (symlink ("ttt", "tttsym") != 0)
        error (1, errno, "cannot create symlink");
    
      t[0].tv_sec = 0;
      t[0].tv_nsec = 0;
      t[1].tv_sec = 0;
      t[1].tv_nsec = 0;
      if (syscall(__NR_utimensat, AT_FDCWD, "tttsym", t, AT_SYMLINK_NOFOLLOW) != 0)
        error (1, errno, "utimensat failed");
    
      if (lstat64 ("tttsym", &st2) != 0)
        error (1, errno, "lstat failed");
    
      if (st2.st_atim.tv_sec != 0 || st2.st_atim.tv_nsec != 0)
        {
          puts ("symlink atim not reset to zero");
          status = 1;
        }
      if (st2.st_mtim.tv_sec != 0 || st2.st_mtim.tv_nsec != 0)
        {
          puts ("symlink mtim not reset to zero");
          status = 1;
        }
      if (status != 0)
        goto out;
    
      t[0].tv_sec = 1;
      t[0].tv_nsec = 0;
      t[1].tv_sec = 1;
      t[1].tv_nsec = 0;
      if (syscall(__NR_utimensat, fd, NULL, t, 0) != 0)
        error (1, errno, "utimensat failed");
    
      if (fstat64 (fd, &st2) != 0)
        error (1, errno, "fstat failed");
    
      if (st2.st_atim.tv_sec != 1 || st2.st_atim.tv_nsec != 0)
        {
          puts ("atim not reset to one");
          status = 1;
        }
      if (st2.st_mtim.tv_sec != 1 || st2.st_mtim.tv_nsec != 0)
        {
          puts ("mtim not reset to one");
          status = 1;
        }
    
      if (status == 0)
         puts ("all OK");
    
     out:
      close (fd);
      unlink ("ttt");
      unlink ("tttsym");
    
      return status;
    }
    
    [akpm@linux-foundation.org: add missing i386 syscall table entry]
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Cc: Alexey Dobriyan <adobriyan@openvz.org>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 50e31b1659a7..dda9be685ab6 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -109,7 +109,7 @@ extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-extern long do_utimes(int dfd, char __user *filename, struct timeval *times);
+extern long do_utimes(int dfd, char __user *filename, struct timespec *times, int flags);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);

commit 8524070b7982d76258942275908b7434cfcab4b4
Author: john stultz <johnstul@us.ibm.com>
Date:   Tue May 8 00:27:59 2007 -0700

    Move timekeeping code to timekeeping.c
    
    Move the timekeeping code out of kernel/timer.c and into
    kernel/time/timekeeping.c.  I made no cleanups or other changes in transit.
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 8ea8dea713c7..50e31b1659a7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -119,6 +119,7 @@ extern void getnstimeofday(struct timespec *tv);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_is_continuous(void);
+extern void update_wall_time(void);
 
 /**
  * timespec_to_ns - Convert timespec to nanoseconds

commit 411187fb05cd11676b0979d9fbf3291db69dbce2
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Feb 16 01:27:30 2007 -0800

    [PATCH] GTOD: persistent clock support
    
    Persistent clock support: do proper timekeeping across suspend/resume.
    
    [bunk@stusta.de: cleanup]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index eceb1a59b078..8ea8dea713c7 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -92,6 +92,7 @@ extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock __attribute__((weak));
 
+extern unsigned long read_persistent_clock(void);
 void timekeeping_init(void);
 
 static inline unsigned long get_seconds(void)

commit 5809f9d442e9dbb23859e2c37d8c47043f6b5cc9
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Tue Feb 13 13:26:21 2007 +0100

    [PATCH] x86-64: get rid of ARCH_HAVE_XTIME_LOCK
    
    ARCH_HAVE_XTIME_LOCK is used by x86_64 arch .  This arch needs to place a
    read only copy of xtime_lock into vsyscall page.  This read only copy is
    named __xtime_lock, and xtime_lock is defined in
    arch/x86_64/kernel/vmlinux.lds.S as an alias.  So the declaration of
    xtime_lock in kernel/timer.c was guarded by ARCH_HAVE_XTIME_LOCK define,
    defined to true on x86_64.
    
    We can get same result with _attribute__((weak)) in the declaration. linker
    should do the job.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 55cee172d723..eceb1a59b078 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -90,7 +90,7 @@ static inline struct timespec timespec_sub(struct timespec lhs,
 
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
-extern seqlock_t xtime_lock;
+extern seqlock_t xtime_lock __attribute__((weak));
 
 void timekeeping_init(void);
 

commit 77adbfbf4cf96fedf9b75bb330704828c187b190
Author: Rolf Eike Beer <eike-kernel@sf-tec.de>
Date:   Sat Feb 10 01:45:49 2007 -0800

    [PATCH] Add const for time{spec,val}_compare arguments
    
    The arguments are really const.  Mark them const to allow these functions
    being called from places where the arguments are const without getting
    useless compiler warnings.
    
    Signed-off-by: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index a5b739967b74..55cee172d723 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -46,7 +46,7 @@ static inline int timespec_equal(struct timespec *a, struct timespec *b)
  * lhs == rhs: return 0
  * lhs > rhs:  return >0
  */
-static inline int timespec_compare(struct timespec *lhs, struct timespec *rhs)
+static inline int timespec_compare(const struct timespec *lhs, const struct timespec *rhs)
 {
 	if (lhs->tv_sec < rhs->tv_sec)
 		return -1;
@@ -55,7 +55,7 @@ static inline int timespec_compare(struct timespec *lhs, struct timespec *rhs)
 	return lhs->tv_nsec - rhs->tv_nsec;
 }
 
-static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
+static inline int timeval_compare(const struct timeval *lhs, const struct timeval *rhs)
 {
 	if (lhs->tv_sec < rhs->tv_sec)
 		return -1;

commit ca74e92b4698276b6696f15a801759f50944f387
Author: Shailabh Nagar <nagar@watson.ibm.com>
Date:   Fri Jul 14 00:24:36 2006 -0700

    [PATCH] per-task-delay-accounting: setup
    
    Initialization code related to collection of per-task "delay" statistics which
    measure how long it had to wait for cpu, sync block io, swapping etc.  The
    collection of statistics and the interface are in other patches.  This patch
    sets up the data structures and allows the statistics collection to be
    disabled through a kernel boot parameter.
    
    Signed-off-by: Shailabh Nagar <nagar@watson.ibm.com>
    Signed-off-by: Balbir Singh <balbir@in.ibm.com>
    Cc: Jes Sorensen <jes@sgi.com>
    Cc: Peter Chubb <peterc@gelato.unsw.edu.au>
    Cc: Erich Focht <efocht@ess.nec.de>
    Cc: Levent Serinol <lserinol@gmail.com>
    Cc: Jay Lan <jlan@engr.sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index c05f8bb9a323..a5b739967b74 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -70,6 +70,18 @@ extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
 
+/*
+ * sub = lhs - rhs, in normalized form
+ */
+static inline struct timespec timespec_sub(struct timespec lhs,
+						struct timespec rhs)
+{
+	struct timespec ts_delta;
+	set_normalized_timespec(&ts_delta, lhs.tv_sec - rhs.tv_sec,
+				lhs.tv_nsec - rhs.tv_nsec);
+	return ts_delta;
+}
+
 /*
  * Returns true if the timespec is norm, false if denorm:
  */

commit 81a07d7588d376c530d006e24d7981304ce96e16
Merge: 8871e73fdbde 8501a2fbe762
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jun 26 10:51:09 2006 -0700

    Merge branch 'x86-64'
    
    * x86-64: (83 commits)
      [PATCH] x86_64: x86_64 stack usage debugging
      [PATCH] x86_64: (resend) x86_64 stack overflow debugging
      [PATCH] x86_64: msi_apic.c build fix
      [PATCH] x86_64: i386/x86-64 Add nmi watchdog support for new Intel CPUs
      [PATCH] x86_64: Avoid broadcasting NMI IPIs
      [PATCH] x86_64: fix apic error on bootup
      [PATCH] x86_64: enlarge window for stack growth
      [PATCH] x86_64: Minor string functions optimizations
      [PATCH] x86_64: Move export symbols to their C functions
      [PATCH] x86_64: Standardize i386/x86_64 handling of NMI_VECTOR
      [PATCH] x86_64: Fix modular pc speaker
      [PATCH] x86_64: remove sys32_ni_syscall()
      [PATCH] x86_64: Do not use -ffunction-sections for modules
      [PATCH] x86_64: Add cpu_relax to apic_wait_icr_idle
      [PATCH] x86_64: adjust kstack_depth_to_print default
      [PATCH] i386/x86-64: adjust /proc/interrupts column headings
      [PATCH] x86_64: Fix race in cpu_local_* on preemptible kernels
      [PATCH] x86_64: Fix fast check in safe_smp_processor_id
      [PATCH] x86_64: x86_64 setup.c - printing cmp related boottime information
      [PATCH] i386/x86-64/ia64: Move polling flag into thread_info_status
      ...
    
    Manual resolve of trivial conflict in arch/i386/kernel/Makefile

commit 05ebb76109f302b949e745724bbf0f0634dba43f
Author: Vojtech Pavlik <vojtech@suse.cz>
Date:   Mon Jun 26 13:58:20 2006 +0200

    [PATCH] x86_64: Add useful constants to time.h
    
    In timekeeping code, one often does need to use conversion constants. Naming
    these leads to code that's easier to understand, showing the reader between
    which units the conversion is made.
    
    Signed-off-by: Vojtech Pavlik <vojtech@suse.cz>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 0cd696cee998..2fa2987c9a07 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -28,10 +28,13 @@ struct timezone {
 #ifdef __KERNEL__
 
 /* Parameters used to convert the timespec values: */
-#define MSEC_PER_SEC		1000L
-#define USEC_PER_SEC		1000000L
-#define NSEC_PER_SEC		1000000000L
-#define NSEC_PER_USEC		1000L
+#define MSEC_PER_SEC	1000L
+#define USEC_PER_MSEC	1000L
+#define NSEC_PER_USEC	1000L
+#define NSEC_PER_MSEC	1000000L
+#define USEC_PER_SEC	1000000L
+#define NSEC_PER_SEC	1000000000L
+#define FSEC_PER_SEC	1000000000000000L
 
 static inline int timespec_equal(struct timespec *a, struct timespec *b)
 {

commit cf3c769b4b0dd1146da84d5cf045dcfe53bd0f13
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:08 2006 -0700

    [PATCH] Time: Introduce arch generic time accessors
    
    Introduces clocksource switching code and the arch generic time accessor
    functions that use the clocksource infrastructure.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 88d3b812841e..65dd85b2105e 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -102,6 +102,7 @@ extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
+extern int timekeeping_is_continuous(void);
 
 /**
  * timespec_to_ns - Convert timespec to nanoseconds
@@ -144,6 +145,20 @@ extern struct timespec ns_to_timespec(const s64 nsec);
  */
 extern struct timeval ns_to_timeval(const s64 nsec);
 
+/**
+ * timespec_add_ns - Adds nanoseconds to a timespec
+ * @a:		pointer to timespec to be incremented
+ * @ns:		unsigned nanoseconds value to be added
+ */
+static inline void timespec_add_ns(struct timespec *a, u64 ns)
+{
+	ns += a->tv_nsec;
+	while(unlikely(ns >= NSEC_PER_SEC)) {
+		ns -= NSEC_PER_SEC;
+		a->tv_sec++;
+	}
+	a->tv_nsec = ns;
+}
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS

commit ad596171ed635c51a9eef829187af100cbf8dcf7
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jun 26 00:25:06 2006 -0700

    [PATCH] Time: Use clocksource infrastructure for update_wall_time
    
    Modify the update_wall_time function so it increments time using the
    clocksource abstraction instead of jiffies.  Since the only clocksource driver
    currently provided is the jiffies clocksource, this should result in no
    functional change.  Additionally, a timekeeping_init and timekeeping_resume
    function has been added to initialize and maintain some of the new timekeping
    state.
    
    [hirofumi@mail.parknet.co.jp: fixlet]
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 0cd696cee998..88d3b812841e 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -77,6 +77,8 @@ extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
 
+void timekeeping_init(void);
+
 static inline unsigned long get_seconds(void)
 {
 	return xtime.tv_sec;

commit df869b630d9d9131c10cf073fb61646048874b2f
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Mar 26 01:38:11 2006 -0800

    [PATCH] hrtimers: remove nsec_t typedef
    
    nsec_t predates ktime_t and has mostly been superseded by it.  In the few
    places that are left it's better to make it explicit that we're dealing with
    64 bit values here.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index bf0e785e2e03..0cd696cee998 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -73,12 +73,6 @@ extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
 #define timespec_valid(ts) \
 	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
 
-/*
- * 64-bit nanosec type. Large enough to span 292+ years in nanosecond
- * resolution. Ought to be enough for a while.
- */
-typedef s64 nsec_t;
-
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
@@ -114,9 +108,9 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
  * Returns the scalar nanosecond representation of the timespec
  * parameter.
  */
-static inline nsec_t timespec_to_ns(const struct timespec *ts)
+static inline s64 timespec_to_ns(const struct timespec *ts)
 {
-	return ((nsec_t) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
+	return ((s64) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
 }
 
 /**
@@ -126,9 +120,9 @@ static inline nsec_t timespec_to_ns(const struct timespec *ts)
  * Returns the scalar nanosecond representation of the timeval
  * parameter.
  */
-static inline nsec_t timeval_to_ns(const struct timeval *tv)
+static inline s64 timeval_to_ns(const struct timeval *tv)
 {
-	return ((nsec_t) tv->tv_sec * NSEC_PER_SEC) +
+	return ((s64) tv->tv_sec * NSEC_PER_SEC) +
 		tv->tv_usec * NSEC_PER_USEC;
 }
 
@@ -138,7 +132,7 @@ static inline nsec_t timeval_to_ns(const struct timeval *tv)
  *
  * Returns the timespec representation of the nsec parameter.
  */
-extern struct timespec ns_to_timespec(const nsec_t nsec);
+extern struct timespec ns_to_timespec(const s64 nsec);
 
 /**
  * ns_to_timeval - Convert nanoseconds to timeval
@@ -146,7 +140,7 @@ extern struct timespec ns_to_timespec(const nsec_t nsec);
  *
  * Returns the timeval representation of the nsec parameter.
  */
-extern struct timeval ns_to_timeval(const nsec_t nsec);
+extern struct timeval ns_to_timeval(const s64 nsec);
 
 #endif /* __KERNEL__ */
 

commit c08b8a49100715b20e6f7c997e992428b5e06078
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Mar 25 03:06:33 2006 -0800

    [PATCH] sys_alarm() unsigned signed conversion fixup
    
    alarm() calls the kernel with an unsigend int timeout in seconds.  The
    value is stored in the tv_sec field of a struct timeval to setup the
    itimer.  The tv_sec field of struct timeval is of type long, which causes
    the tv_sec value to be negative on 32 bit machines if seconds > INT_MAX.
    
    Before the hrtimer merge (pre 2.6.16) such a negative value was converted
    to the maximum jiffies timeout by the timeval_to_jiffies conversion.  It's
    not clear whether this was intended or just happened to be done by the
    timeval_to_jiffies code.
    
    hrtimers expect a timeval in canonical form and treat a negative timeout as
    already expired.  This breaks the legitimate usage of alarm() with a
    timeout value > INT_MAX seconds.
    
    For 32 bit machines it is therefor necessary to limit the internal seconds
    value to avoid API breakage.  Instead of doing this in all implementations
    of sys_alarm the duplicated sys_alarm code is moved into a common function
    in itimer.c
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index d9cdba54b789..bf0e785e2e03 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -101,6 +101,7 @@ extern long do_utimes(int dfd, char __user *filename, struct timeval *times);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
+extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
 

commit 643a654540579b0dcc7a206a4a7475276a41aff0
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Feb 11 17:55:52 2006 -0800

    [PATCH] select: fix returned timeval
    
    With David Woodhouse <dwmw2@infradead.org>
    
    select() presently has a habit of increasing the value of the user's
    `timeout' argument on return.
    
    We were writing back a timeout larger than the original.  We _deliberately_
    round up, since we know we must wait at _least_ as long as the caller asks
    us to.
    
    The patch adds a couple of helper functions for magnitude comparison of
    timespecs and of timevals, and uses them to prevent the various poll and
    select functions from returning a timeout which is larger than the one which
    was passed in.
    
    The patch also fixes a bug in compat_sys_pselect7(): it was adding the new
    timeout value to the old one and was returning that.  It should just return
    the new timeout value.
    
    (We have various handy timespec/timeval-to-from-nsec conversion functions in
    time.h.  But this code open-codes it all).
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Ulrich Drepper <drepper@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: george anzinger <george@mvista.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 7b4dc36532bb..d9cdba54b789 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -33,11 +33,34 @@ struct timezone {
 #define NSEC_PER_SEC		1000000000L
 #define NSEC_PER_USEC		1000L
 
-static __inline__ int timespec_equal(struct timespec *a, struct timespec *b)
+static inline int timespec_equal(struct timespec *a, struct timespec *b)
 {
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
 }
 
+/*
+ * lhs < rhs:  return <0
+ * lhs == rhs: return 0
+ * lhs > rhs:  return >0
+ */
+static inline int timespec_compare(struct timespec *lhs, struct timespec *rhs)
+{
+	if (lhs->tv_sec < rhs->tv_sec)
+		return -1;
+	if (lhs->tv_sec > rhs->tv_sec)
+		return 1;
+	return lhs->tv_nsec - rhs->tv_nsec;
+}
+
+static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
+{
+	if (lhs->tv_sec < rhs->tv_sec)
+		return -1;
+	if (lhs->tv_sec > rhs->tv_sec)
+		return 1;
+	return lhs->tv_usec - rhs->tv_usec;
+}
+
 extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 			    const unsigned int day, const unsigned int hour,
 			    const unsigned int min, const unsigned int sec);

commit bd3f8f2b12bcf4ea25c89b84adeaafad232662c8
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Tue Jan 31 19:10:23 2006 -0800

    [PATCH] Make sure to always check upper bits of tv_nsec in timespec_valid.
    
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 614dd8465839..7b4dc36532bb 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -48,7 +48,7 @@ extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
  * Returns true if the timespec is norm, false if denorm:
  */
 #define timespec_valid(ts) \
-	(((ts)->tv_sec >= 0) && (((unsigned) (ts)->tv_nsec) < NSEC_PER_SEC))
+	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
 
 /*
  * 64-bit nanosec type. Large enough to span 292+ years in nanosecond

commit 5590ff0d5528b60153c0b4e7b771472b5a95e297
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jan 18 17:43:53 2006 -0800

    [PATCH] vfs: *at functions: core
    
    Here is a series of patches which introduce in total 13 new system calls
    which take a file descriptor/filename pair instead of a single file
    name.  These functions, openat etc, have been discussed on numerous
    occasions.  They are needed to implement race-free filesystem traversal,
    they are necessary to implement a virtual per-thread current working
    directory (think multi-threaded backup software), etc.
    
    We have in glibc today implementations of the interfaces which use the
    /proc/self/fd magic.  But this code is rather expensive.  Here are some
    results (similar to what Jim Meyering posted before).
    
    The test creates a deep directory hierarchy on a tmpfs filesystem.  Then
    rm -fr is used to remove all directories.  Without syscall support I get
    this:
    
    real    0m31.921s
    user    0m0.688s
    sys     0m31.234s
    
    With syscall support the results are much better:
    
    real    0m20.699s
    user    0m0.536s
    sys     0m20.149s
    
    The interfaces are for obvious reasons currently not much used.  But they'll
    be used.  coreutils (and Jeff's posixutils) are already using them.
    Furthermore, code like ftw/fts in libc (maybe even glob) will also start using
    them.  I expect a patch to make follow soon.  Every program which is walking
    the filesystem tree will benefit.
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index f2aca7ec6325..614dd8465839 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -74,7 +74,7 @@ extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-extern long do_utimes(char __user *filename, struct timeval *times);
+extern long do_utimes(int dfd, char __user *filename, struct timeval *times);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);

commit d1c0b8f835aeba85aa428aaec6d521ef4639c7fa
Author: Matt Helsley <matthltc@us.ibm.com>
Date:   Mon Jan 9 20:52:40 2006 -0800

    [PATCH] Remove getnstimestamp()
    
    Remove getnstimestamp() in favor of ktime.h's ktime_get_ts()
    
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 1201155b2202..f2aca7ec6325 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -80,7 +80,6 @@ extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
-extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 

commit becf8b5d00f4b47e847f98322cdaf8cd16243861
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 9 20:52:38 2006 -0800

    [PATCH] hrtimer: convert posix timers completely
    
    - convert posix-timers.c to use hrtimers
    
    - remove the now obsolete abslist code
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index f639fde29253..1201155b2202 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -73,8 +73,7 @@ struct timespec current_kernel_time(void);
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
-extern void clock_was_set(void); // call whenever the clock is set
-extern int do_posix_clock_monotonic_gettime(struct timespec *tp);
+#define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
 extern long do_utimes(char __user *filename, struct timeval *times);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,

commit f8f46da3b4cbb03b43a102b1eb92b63419e10f90
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 9 20:52:30 2006 -0800

    [PATCH] hrtimer: introduce nsec_t type and conversion functions
    
    - introduce the nsec_t type
    
    - basic nsec conversion routines: timespec_to_ns(), timeval_to_ns(),
      ns_to_timespec(), ns_to_timeval().
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 64e797464589..f639fde29253 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -50,6 +50,12 @@ extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
 #define timespec_valid(ts) \
 	(((ts)->tv_sec >= 0) && (((unsigned) (ts)->tv_nsec) < NSEC_PER_SEC))
 
+/*
+ * 64-bit nanosec type. Large enough to span 292+ years in nanosecond
+ * resolution. Ought to be enough for a while.
+ */
+typedef s64 nsec_t;
+
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
@@ -79,6 +85,47 @@ extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
+/**
+ * timespec_to_ns - Convert timespec to nanoseconds
+ * @ts:		pointer to the timespec variable to be converted
+ *
+ * Returns the scalar nanosecond representation of the timespec
+ * parameter.
+ */
+static inline nsec_t timespec_to_ns(const struct timespec *ts)
+{
+	return ((nsec_t) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
+}
+
+/**
+ * timeval_to_ns - Convert timeval to nanoseconds
+ * @ts:		pointer to the timeval variable to be converted
+ *
+ * Returns the scalar nanosecond representation of the timeval
+ * parameter.
+ */
+static inline nsec_t timeval_to_ns(const struct timeval *tv)
+{
+	return ((nsec_t) tv->tv_sec * NSEC_PER_SEC) +
+		tv->tv_usec * NSEC_PER_USEC;
+}
+
+/**
+ * ns_to_timespec - Convert nanoseconds to timespec
+ * @nsec:	the nanoseconds value to be converted
+ *
+ * Returns the timespec representation of the nsec parameter.
+ */
+extern struct timespec ns_to_timespec(const nsec_t nsec);
+
+/**
+ * ns_to_timeval - Convert nanoseconds to timeval
+ * @nsec:	the nanoseconds value to be converted
+ *
+ * Returns the timeval representation of the nsec parameter.
+ */
+extern struct timeval ns_to_timeval(const nsec_t nsec);
+
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS

commit 5f82b2b77e66d452c3037cc47f436d2d76fd5f06
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 9 20:52:29 2006 -0800

    [PATCH] hrtimer: create and use timespec_valid macro
    
    add timespec_valid(ts) [returns false if the timespec is denorm]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 4d49cabb9b47..64e797464589 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -44,6 +44,12 @@ extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 
 extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
 
+/*
+ * Returns true if the timespec is norm, false if denorm:
+ */
+#define timespec_valid(ts) \
+	(((ts)->tv_sec >= 0) && (((unsigned) (ts)->tv_nsec) < NSEC_PER_SEC))
+
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;

commit 57a558757bdbb877b54ed5ea15bd0892e02a707d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 9 20:52:26 2006 -0800

    [PATCH] hrtimer: coding style and white space cleanup
    
    style and whitespace cleanup of the rest of time.h.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index aded44c48d42..4d49cabb9b47 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -4,7 +4,7 @@
 #include <linux/types.h>
 
 #ifdef __KERNEL__
-#include <linux/seqlock.h>
+# include <linux/seqlock.h>
 #endif
 
 #ifndef _STRUCT_TIMESPEC
@@ -13,7 +13,7 @@ struct timespec {
 	time_t	tv_sec;		/* seconds */
 	long	tv_nsec;	/* nanoseconds */
 };
-#endif /* _STRUCT_TIMESPEC */
+#endif
 
 struct timeval {
 	time_t		tv_sec;		/* seconds */
@@ -27,16 +27,16 @@ struct timezone {
 
 #ifdef __KERNEL__
 
-/* Parameters used to convert the timespec values */
-#define MSEC_PER_SEC (1000L)
-#define USEC_PER_SEC (1000000L)
-#define NSEC_PER_SEC (1000000000L)
-#define NSEC_PER_USEC (1000L)
+/* Parameters used to convert the timespec values: */
+#define MSEC_PER_SEC		1000L
+#define USEC_PER_SEC		1000000L
+#define NSEC_PER_SEC		1000000000L
+#define NSEC_PER_USEC		1000L
 
-static __inline__ int timespec_equal(struct timespec *a, struct timespec *b) 
-{ 
+static __inline__ int timespec_equal(struct timespec *a, struct timespec *b)
+{
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
-} 
+}
 
 extern unsigned long mktime(const unsigned int year, const unsigned int mon,
 			    const unsigned int day, const unsigned int hour,
@@ -49,25 +49,26 @@ extern struct timespec wall_to_monotonic;
 extern seqlock_t xtime_lock;
 
 static inline unsigned long get_seconds(void)
-{ 
+{
 	return xtime.tv_sec;
 }
 
 struct timespec current_kernel_time(void);
 
-#define CURRENT_TIME (current_kernel_time())
-#define CURRENT_TIME_SEC ((struct timespec) { xtime.tv_sec, 0 })
+#define CURRENT_TIME		(current_kernel_time())
+#define CURRENT_TIME_SEC	((struct timespec) { xtime.tv_sec, 0 })
 
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
-extern void clock_was_set(void); // call when ever the clock is set
+extern void clock_was_set(void); // call whenever the clock is set
 extern int do_posix_clock_monotonic_gettime(struct timespec *tp);
-extern long do_utimes(char __user * filename, struct timeval * times);
+extern long do_utimes(char __user *filename, struct timeval *times);
 struct itimerval;
-extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
+extern int do_setitimer(int which, struct itimerval *value,
+			struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
-extern void getnstimeofday (struct timespec *tv);
+extern void getnstimeofday(struct timespec *tv);
 extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
@@ -84,24 +85,24 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
 /*
  * Names of the interval timers, and structure
- * defining a timer setting.
+ * defining a timer setting:
  */
-#define	ITIMER_REAL	0
-#define	ITIMER_VIRTUAL	1
-#define	ITIMER_PROF	2
+#define	ITIMER_REAL		0
+#define	ITIMER_VIRTUAL		1
+#define	ITIMER_PROF		2
 
-struct  itimerspec {
-        struct  timespec it_interval;    /* timer period */
-        struct  timespec it_value;       /* timer expiration */
+struct itimerspec {
+	struct timespec it_interval;	/* timer period */
+	struct timespec it_value;	/* timer expiration */
 };
 
-struct	itimerval {
-	struct	timeval it_interval;	/* timer interval */
-	struct	timeval it_value;	/* current value */
+struct itimerval {
+	struct timeval it_interval;	/* timer interval */
+	struct timeval it_value;	/* current value */
 };
 
 /*
- * The IDs of the various system clocks (for POSIX.1b interval timers).
+ * The IDs of the various system clocks (for POSIX.1b interval timers):
  */
 #define CLOCK_REALTIME			0
 #define CLOCK_MONOTONIC			1
@@ -109,7 +110,7 @@ struct	itimerval {
 #define CLOCK_THREAD_CPUTIME_ID		3
 
 /*
- * The IDs of various hardware clocks
+ * The IDs of various hardware clocks:
  */
 #define CLOCK_SGI_CYCLE			10
 #define MAX_CLOCKS			16
@@ -117,7 +118,7 @@ struct	itimerval {
 #define CLOCKS_MONO			CLOCK_MONOTONIC
 
 /*
- * The various flags for setting POSIX.1b interval timers.
+ * The various flags for setting POSIX.1b interval timers:
  */
 #define TIMER_ABSTIME			0x01
 

commit 1ad106ca185e66dc312518e18e2ffaedf376a160
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 9 20:52:25 2006 -0800

    [PATCH] hrtimer: coding style clean up of clock constants
    
    clean up the CLOCK_ portions of time.h
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index ea64cde7c450..aded44c48d42 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -100,30 +100,25 @@ struct	itimerval {
 	struct	timeval it_value;	/* current value */
 };
 
-
 /*
  * The IDs of the various system clocks (for POSIX.1b interval timers).
  */
-#define CLOCK_REALTIME		 0
-#define CLOCK_MONOTONIC	  	 1
-#define CLOCK_PROCESS_CPUTIME_ID 2
-#define CLOCK_THREAD_CPUTIME_ID	 3
+#define CLOCK_REALTIME			0
+#define CLOCK_MONOTONIC			1
+#define CLOCK_PROCESS_CPUTIME_ID	2
+#define CLOCK_THREAD_CPUTIME_ID		3
 
 /*
  * The IDs of various hardware clocks
  */
-
-
-#define CLOCK_SGI_CYCLE 10
-#define MAX_CLOCKS 16
-#define CLOCKS_MASK  (CLOCK_REALTIME | CLOCK_MONOTONIC)
-#define CLOCKS_MONO (CLOCK_MONOTONIC)
+#define CLOCK_SGI_CYCLE			10
+#define MAX_CLOCKS			16
+#define CLOCKS_MASK			(CLOCK_REALTIME | CLOCK_MONOTONIC)
+#define CLOCKS_MONO			CLOCK_MONOTONIC
 
 /*
  * The various flags for setting POSIX.1b interval timers.
  */
-
-#define TIMER_ABSTIME 0x01
-
+#define TIMER_ABSTIME			0x01
 
 #endif

commit 0c4f6eeca98a805fd0c2536b55039383eb56d2ba
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 9 20:52:25 2006 -0800

    [PATCH] hrtimer: remove unused clock constants
    
    remove unused CLOCK_ constants from time.h
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 773b83ddd8ef..ea64cde7c450 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -104,12 +104,10 @@ struct	itimerval {
 /*
  * The IDs of the various system clocks (for POSIX.1b interval timers).
  */
-#define CLOCK_REALTIME		  0
-#define CLOCK_MONOTONIC	  1
+#define CLOCK_REALTIME		 0
+#define CLOCK_MONOTONIC	  	 1
 #define CLOCK_PROCESS_CPUTIME_ID 2
 #define CLOCK_THREAD_CPUTIME_ID	 3
-#define CLOCK_REALTIME_HR	 4
-#define CLOCK_MONOTONIC_HR	  5
 
 /*
  * The IDs of various hardware clocks
@@ -118,9 +116,8 @@ struct	itimerval {
 
 #define CLOCK_SGI_CYCLE 10
 #define MAX_CLOCKS 16
-#define CLOCKS_MASK  (CLOCK_REALTIME | CLOCK_MONOTONIC | \
-                     CLOCK_REALTIME_HR | CLOCK_MONOTONIC_HR)
-#define CLOCKS_MONO (CLOCK_MONOTONIC & CLOCK_MONOTONIC_HR)
+#define CLOCKS_MASK  (CLOCK_REALTIME | CLOCK_MONOTONIC)
+#define CLOCKS_MONO (CLOCK_MONOTONIC)
 
 /*
  * The various flags for setting POSIX.1b interval timers.

commit f4818900fa3ee1c56e96f6dede7cc4c05ed383d1
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 9 20:52:23 2006 -0800

    [PATCH] hrtimer: clean up mktime and make arguments const
    
    add 'const' to mktime arguments, and clean it up a bit
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 9c444d9c4aa0..773b83ddd8ef 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -38,9 +38,11 @@ static __inline__ int timespec_equal(struct timespec *a, struct timespec *b)
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
 } 
 
-extern unsigned long mktime (unsigned int year, unsigned int mon,
-			     unsigned int day, unsigned int hour,
-			     unsigned int min, unsigned int sec);
+extern unsigned long mktime(const unsigned int year, const unsigned int mon,
+			    const unsigned int day, const unsigned int hour,
+			    const unsigned int min, const unsigned int sec);
+
+extern void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec);
 
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
@@ -51,8 +53,6 @@ static inline unsigned long get_seconds(void)
 	return xtime.tv_sec;
 }
 
-extern void set_normalized_timespec (struct timespec *ts, time_t sec, long nsec);
-
 struct timespec current_kernel_time(void);
 
 #define CURRENT_TIME (current_kernel_time())

commit 753be6222728996974e9e12c185108fcabbb7c6e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jan 9 20:52:22 2006 -0800

    [PATCH] hrtimer: deinline mktime and set_normalized_timespec
    
    mktime() and set_normalized_timespec() are large inline functions used in many
    places: deinline them.
    
    From: George Anzinger, off-by-1 bugfix
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 797ccd813bb0..9c444d9c4aa0 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -38,38 +38,9 @@ static __inline__ int timespec_equal(struct timespec *a, struct timespec *b)
 	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
 } 
 
-/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
- * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
- * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.
- *
- * [For the Julian calendar (which was used in Russia before 1917,
- * Britain & colonies before 1752, anywhere else before 1582,
- * and is still in use by some communities) leave out the
- * -year/100+year/400 terms, and add 10.]
- *
- * This algorithm was first published by Gauss (I think).
- *
- * WARNING: this function will overflow on 2106-02-07 06:28:16 on
- * machines were long is 32-bit! (However, as time_t is signed, we
- * will already get problems at other places on 2038-01-19 03:14:08)
- */
-static inline unsigned long
-mktime (unsigned int year, unsigned int mon,
-	unsigned int day, unsigned int hour,
-	unsigned int min, unsigned int sec)
-{
-	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
-		mon += 12;		/* Puts Feb last since it has leap day */
-		year -= 1;
-	}
-
-	return (((
-		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
-			year*365 - 719499
-	    )*24 + hour /* now have hours */
-	  )*60 + min /* now have minutes */
-	)*60 + sec; /* finally seconds */
-}
+extern unsigned long mktime (unsigned int year, unsigned int mon,
+			     unsigned int day, unsigned int hour,
+			     unsigned int min, unsigned int sec);
 
 extern struct timespec xtime;
 extern struct timespec wall_to_monotonic;
@@ -80,6 +51,8 @@ static inline unsigned long get_seconds(void)
 	return xtime.tv_sec;
 }
 
+extern void set_normalized_timespec (struct timespec *ts, time_t sec, long nsec);
+
 struct timespec current_kernel_time(void);
 
 #define CURRENT_TIME (current_kernel_time())
@@ -99,21 +72,6 @@ extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
-static inline void
-set_normalized_timespec (struct timespec *ts, time_t sec, long nsec)
-{
-	while (nsec >= NSEC_PER_SEC) {
-		nsec -= NSEC_PER_SEC;
-		++sec;
-	}
-	while (nsec < 0) {
-		nsec += NSEC_PER_SEC;
-		--sec;
-	}
-	ts->tv_sec = sec;
-	ts->tv_nsec = nsec;
-}
-
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS

commit 64123fd42c7a1e4ebf6acd2399c98caddc7e0c26
Author: Matt Helsley <matthltc@us.ibm.com>
Date:   Mon Dec 12 00:37:09 2005 -0800

    [PATCH] Add getnstimestamp function
    
    There are several functions that might seem appropriate for a timestamp:
    
    get_cycles()
    current_kernel_time()
    do_gettimeofday()
    <read jiffies/jiffies_64>
    
    Each has problems with combinations of SMP-safety, low resolution, and
    monotonicity. This patch adds a new function that returns a monotonic SMP-safe
    timestamp with nanosecond resolution where available.
    
    Changes:
            Split timestamp into separate patch
            Moved to kernel/time.c
            Renamed to getnstimestamp
            Fixed unintended-pointer-arithmetic bug
    
    Signed-off-by: Matt Helsley <matthltc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index bfbe92d0767c..797ccd813bb0 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -95,6 +95,7 @@ struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday (struct timespec *tv);
+extern void getnstimestamp(struct timespec *ts);
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 

commit 3f39894d1b5c253b10fcb8fbbbcf65a330f6cdc7
Author: George Anzinger <george@mvista.com>
Date:   Sun Nov 13 16:07:44 2005 -0800

    [PATCH] timespec: normalize off by one errors
    
    It would appear that the timespec normalize code has an off by one error.
    Found in three places.  Thanks to Ben for spotting.
    
    Signed-off-by: George Anzinger<george@mvista.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 8e83f4e778bb..bfbe92d0767c 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -101,7 +101,7 @@ extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 static inline void
 set_normalized_timespec (struct timespec *ts, time_t sec, long nsec)
 {
-	while (nsec > NSEC_PER_SEC) {
+	while (nsec >= NSEC_PER_SEC) {
 		nsec -= NSEC_PER_SEC;
 		++sec;
 	}

commit 373016e9e1353f2af871993d27d00768f08cc883
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Sep 10 00:27:23 2005 -0700

    [PATCH] time.h: remove ifdefs
    
    Remove these ifdefs - there's no need to have more than one definition of
    these multipliers anywhere.
    
    Cc: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 36fb2ef13cff..8e83f4e778bb 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -29,18 +29,9 @@ struct timezone {
 
 /* Parameters used to convert the timespec values */
 #define MSEC_PER_SEC (1000L)
-
-#ifndef USEC_PER_SEC
 #define USEC_PER_SEC (1000000L)
-#endif
-
-#ifndef NSEC_PER_SEC
 #define NSEC_PER_SEC (1000000000L)
-#endif
-
-#ifndef NSEC_PER_USEC
 #define NSEC_PER_USEC (1000L)
-#endif
 
 static __inline__ int timespec_equal(struct timespec *a, struct timespec *b) 
 { 

commit 84f902c0903a98a315b45a4fba3d2ac0de388256
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Sep 10 00:27:22 2005 -0700

    [PATCH] include: update jiffies/{m,u}secs conversion functions
    
    Clarify the human-time units to jiffies conversion functions by using the
    constants in time.h.  This makes many of the subsequent patches direct
    copies of the current code.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index c10d4c21c183..36fb2ef13cff 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -28,6 +28,8 @@ struct timezone {
 #ifdef __KERNEL__
 
 /* Parameters used to convert the timespec values */
+#define MSEC_PER_SEC (1000L)
+
 #ifndef USEC_PER_SEC
 #define USEC_PER_SEC (1000000L)
 #endif

commit f23ef184b486ac021b6a471b4e94cfa04860d3b0
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 6 15:17:29 2005 -0700

    [PATCH] Delete unused do_nanosleep declaration
    
    There is no do_nanosleep function so kill it's declaration in <linux/time.h>.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/time.h b/include/linux/time.h
index 5634497ff5df..c10d4c21c183 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -97,7 +97,6 @@ extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 extern void clock_was_set(void); // call when ever the clock is set
 extern int do_posix_clock_monotonic_gettime(struct timespec *tp);
-extern long do_nanosleep(struct timespec *t);
 extern long do_utimes(char __user * filename, struct timeval * times);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/time.h b/include/linux/time.h
new file mode 100644
index 000000000000..5634497ff5df
--- /dev/null
+++ b/include/linux/time.h
@@ -0,0 +1,181 @@
+#ifndef _LINUX_TIME_H
+#define _LINUX_TIME_H
+
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+#include <linux/seqlock.h>
+#endif
+
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC
+struct timespec {
+	time_t	tv_sec;		/* seconds */
+	long	tv_nsec;	/* nanoseconds */
+};
+#endif /* _STRUCT_TIMESPEC */
+
+struct timeval {
+	time_t		tv_sec;		/* seconds */
+	suseconds_t	tv_usec;	/* microseconds */
+};
+
+struct timezone {
+	int	tz_minuteswest;	/* minutes west of Greenwich */
+	int	tz_dsttime;	/* type of dst correction */
+};
+
+#ifdef __KERNEL__
+
+/* Parameters used to convert the timespec values */
+#ifndef USEC_PER_SEC
+#define USEC_PER_SEC (1000000L)
+#endif
+
+#ifndef NSEC_PER_SEC
+#define NSEC_PER_SEC (1000000000L)
+#endif
+
+#ifndef NSEC_PER_USEC
+#define NSEC_PER_USEC (1000L)
+#endif
+
+static __inline__ int timespec_equal(struct timespec *a, struct timespec *b) 
+{ 
+	return (a->tv_sec == b->tv_sec) && (a->tv_nsec == b->tv_nsec);
+} 
+
+/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
+ * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
+ * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.
+ *
+ * [For the Julian calendar (which was used in Russia before 1917,
+ * Britain & colonies before 1752, anywhere else before 1582,
+ * and is still in use by some communities) leave out the
+ * -year/100+year/400 terms, and add 10.]
+ *
+ * This algorithm was first published by Gauss (I think).
+ *
+ * WARNING: this function will overflow on 2106-02-07 06:28:16 on
+ * machines were long is 32-bit! (However, as time_t is signed, we
+ * will already get problems at other places on 2038-01-19 03:14:08)
+ */
+static inline unsigned long
+mktime (unsigned int year, unsigned int mon,
+	unsigned int day, unsigned int hour,
+	unsigned int min, unsigned int sec)
+{
+	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
+		mon += 12;		/* Puts Feb last since it has leap day */
+		year -= 1;
+	}
+
+	return (((
+		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
+			year*365 - 719499
+	    )*24 + hour /* now have hours */
+	  )*60 + min /* now have minutes */
+	)*60 + sec; /* finally seconds */
+}
+
+extern struct timespec xtime;
+extern struct timespec wall_to_monotonic;
+extern seqlock_t xtime_lock;
+
+static inline unsigned long get_seconds(void)
+{ 
+	return xtime.tv_sec;
+}
+
+struct timespec current_kernel_time(void);
+
+#define CURRENT_TIME (current_kernel_time())
+#define CURRENT_TIME_SEC ((struct timespec) { xtime.tv_sec, 0 })
+
+extern void do_gettimeofday(struct timeval *tv);
+extern int do_settimeofday(struct timespec *tv);
+extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
+extern void clock_was_set(void); // call when ever the clock is set
+extern int do_posix_clock_monotonic_gettime(struct timespec *tp);
+extern long do_nanosleep(struct timespec *t);
+extern long do_utimes(char __user * filename, struct timeval * times);
+struct itimerval;
+extern int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue);
+extern int do_getitimer(int which, struct itimerval *value);
+extern void getnstimeofday (struct timespec *tv);
+
+extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
+
+static inline void
+set_normalized_timespec (struct timespec *ts, time_t sec, long nsec)
+{
+	while (nsec > NSEC_PER_SEC) {
+		nsec -= NSEC_PER_SEC;
+		++sec;
+	}
+	while (nsec < 0) {
+		nsec += NSEC_PER_SEC;
+		--sec;
+	}
+	ts->tv_sec = sec;
+	ts->tv_nsec = nsec;
+}
+
+#endif /* __KERNEL__ */
+
+#define NFDBITS			__NFDBITS
+
+#define FD_SETSIZE		__FD_SETSIZE
+#define FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)
+#define FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)
+#define FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)
+#define FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)
+
+/*
+ * Names of the interval timers, and structure
+ * defining a timer setting.
+ */
+#define	ITIMER_REAL	0
+#define	ITIMER_VIRTUAL	1
+#define	ITIMER_PROF	2
+
+struct  itimerspec {
+        struct  timespec it_interval;    /* timer period */
+        struct  timespec it_value;       /* timer expiration */
+};
+
+struct	itimerval {
+	struct	timeval it_interval;	/* timer interval */
+	struct	timeval it_value;	/* current value */
+};
+
+
+/*
+ * The IDs of the various system clocks (for POSIX.1b interval timers).
+ */
+#define CLOCK_REALTIME		  0
+#define CLOCK_MONOTONIC	  1
+#define CLOCK_PROCESS_CPUTIME_ID 2
+#define CLOCK_THREAD_CPUTIME_ID	 3
+#define CLOCK_REALTIME_HR	 4
+#define CLOCK_MONOTONIC_HR	  5
+
+/*
+ * The IDs of various hardware clocks
+ */
+
+
+#define CLOCK_SGI_CYCLE 10
+#define MAX_CLOCKS 16
+#define CLOCKS_MASK  (CLOCK_REALTIME | CLOCK_MONOTONIC | \
+                     CLOCK_REALTIME_HR | CLOCK_MONOTONIC_HR)
+#define CLOCKS_MONO (CLOCK_MONOTONIC & CLOCK_MONOTONIC_HR)
+
+/*
+ * The various flags for setting POSIX.1b interval timers.
+ */
+
+#define TIMER_ABSTIME 0x01
+
+
+#endif
