commit dce05aa6eec977f1472abed95ccd71276b9a3864
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Feb 19 08:39:43 2020 +0100

    vt: selection, introduce vc_is_sel
    
    Avoid global variables (namely sel_cons) by introducing vc_is_sel. It
    checks whether the parameter is the current selection console. This will
    help putting sel_cons to a struct later.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Link: https://lore.kernel.org/r/20200219073951.16151-1-jslaby@suse.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index e2c1f96bf059..5b890ef5b59f 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -11,8 +11,8 @@
 #include <linux/tiocl.h>
 #include <linux/vt_buffer.h>
 
-extern struct vc_data *sel_cons;
 struct tty_struct;
+struct vc_data;
 
 extern void clear_selection(void);
 extern int set_selection_user(const struct tiocl_selection __user *sel,
@@ -24,6 +24,8 @@ extern int sel_loadlut(char __user *p);
 extern int mouse_reporting(void);
 extern void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry);
 
+bool vc_is_sel(struct vc_data *vc);
+
 extern int console_blanked;
 
 extern const unsigned char color_table[];

commit 496124e5e16e4974c71404bc9ddaa016156f8cb0
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Wed Apr 17 13:21:13 2019 +0100

    vt: selection: allow functions to be called from inside kernel
    
    This patch breaks set_selection() into two functions so that when
    called from kernel, copy_from_user() can be avoided. The two functions
    are called set_selection_user() and set_selection_kernel() in order to
    be explicit about their purposes. This also means updating any
    references to set_selection() and fixing for name change. It also
    exports set_selection_kernel() and paste_selection().
    
    These changes are used the following patch where speakup's selection
    functionality calls into the above functions, thereby doing away with
    parallel implementation.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Tested-by: Gregory Nowak <greg@gregn.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index a8f5b97b216f..e2c1f96bf059 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -11,13 +11,14 @@
 #include <linux/tiocl.h>
 #include <linux/vt_buffer.h>
 
-struct tty_struct;
-
 extern struct vc_data *sel_cons;
 struct tty_struct;
 
 extern void clear_selection(void);
-extern int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty);
+extern int set_selection_user(const struct tiocl_selection __user *sel,
+			      struct tty_struct *tty);
+extern int set_selection_kernel(struct tiocl_selection *v,
+				struct tty_struct *tty);
 extern int paste_selection(struct tty_struct *tty);
 extern int sel_loadlut(char __user *p);
 extern int mouse_reporting(void);

commit 9bfdc2611d417be453c3deb7a7ef2ffc718febfa
Author: Adam Borowski <kilobyte@angband.pl>
Date:   Wed Jul 18 04:10:44 2018 +0200

    vt: selection: take screen contents from uniscr if available
    
    This preserves whatever was written even if we can't currently display the
    given glyph.  Mouse paste won't corrupt any character of wcwidth() == 1
    anymore.
    
    Note that for now uniscr doesn't get allocated until something reads
    /dev/vcsuN for that console, making this code dormant for most users.
    
    Signed-off-by: Adam Borowski <kilobyte@angband.pl>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 067d2e99c79f..a8f5b97b216f 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -32,6 +32,7 @@ extern unsigned char default_blu[];
 
 extern unsigned short *screen_pos(struct vc_data *vc, int w_offset, int viewed);
 extern u16 screen_glyph(struct vc_data *vc, int offset);
+extern u32 screen_glyph_unicode(struct vc_data *vc, int offset);
 extern void complement_pos(struct vc_data *vc, int offset);
 extern void invert_screen(struct vc_data *vc, int offset, int count, int shift);
 

commit 708d0bff9121506db08adb73845a3c70312fadf3
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jun 26 23:56:42 2018 -0400

    vt: unicode fallback for scrollback
    
    There is currently no provision for scrollback content in the core code,
    leaving that to backend video drivers where this can be highly optimized.
    There is currently no common method for those drivers to tell the core
    what part of the scrollback is actually displayed and what size the
    scrollback buffer is either. Because of that, the unicode screen buffer
    has no provision for any scrollback.
    
    At least we can provide backtranslated glyph values when the scrollback
    is active which should be plenty good enough for now.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Dave Mielke <Dave@mielke.cc>
    Acked-by: Adam Borowski <kilobyte@angband.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 2b34df9f1e26..067d2e99c79f 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -43,7 +43,7 @@ extern void vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org);
 extern void vcs_scr_updated(struct vc_data *vc);
 
 extern int vc_uniscr_check(struct vc_data *vc);
-extern void vc_uniscr_copy_line(struct vc_data *vc, void *dest,
+extern void vc_uniscr_copy_line(struct vc_data *vc, void *dest, int viewed,
 				unsigned int row, unsigned int col,
 				unsigned int nr);
 

commit d21b0be246bf3bbf569e6e239f56abb529c7154e
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jun 26 23:56:41 2018 -0400

    vt: introduce unicode mode for /dev/vcs
    
    Now that the core vt code knows how to preserve unicode values for each
    displayed character, it is then possible to let user space access it via
    /dev/vcs*.
    
    Unicode characters are presented as 32 bit values in native endianity
    via the /dev/vcsu* devices, mimicking the simple /dev/vcs* devices.
    Unicode with attributes (similarly to /dev/vcsa*) is not supported at
    the moment.
    
    Data is available only as long as the console is in UTF-8 mode. ENODATA
    is returned otherwise.
    
    This was tested with the latest development version (to become
    version 5.7) of BRLTTY. Amongst other things, this allows ⠋⠕⠗ ⠞⠓⠊⠎
    ⠃⠗⠁⠊⠇⠇⠑⠀⠞⠑⠭⠞⠀to appear directly on braille displays regardless of the
    console font being used.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Dave Mielke <Dave@mielke.cc>
    Acked-by: Adam Borowski <kilobyte@angband.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 5b278ce99d8d..2b34df9f1e26 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -42,4 +42,9 @@ extern u16 vcs_scr_readw(struct vc_data *vc, const u16 *org);
 extern void vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org);
 extern void vcs_scr_updated(struct vc_data *vc);
 
+extern int vc_uniscr_check(struct vc_data *vc);
+extern void vc_uniscr_copy_line(struct vc_data *vc, void *dest,
+				unsigned int row, unsigned int col,
+				unsigned int nr);
+
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 8e4624efdb6f..5b278ce99d8d 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * selection.h
  *

commit 91e74ca5e7ac4ec6c61b84d6618eb5e401f852f0
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Mar 31 10:08:17 2016 +0200

    tty: vt, use proper type for default colors
    
    Every user of default_red, default_grn, and default_blu treats them as
    unsigned char. So make it really unsigned char.
    
    And indent the initializers and module_param properly.
    
    This saves ~ 100 bytes of data.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 7e6c4450b8a5..8e4624efdb6f 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -25,9 +25,9 @@ extern void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry);
 extern int console_blanked;
 
 extern const unsigned char color_table[];
-extern int default_red[];
-extern int default_grn[];
-extern int default_blu[];
+extern unsigned char default_red[];
+extern unsigned char default_grn[];
+extern unsigned char default_blu[];
 
 extern unsigned short *screen_pos(struct vc_data *vc, int w_offset, int viewed);
 extern u16 screen_glyph(struct vc_data *vc, int offset);

commit 8ede5cce4f0baff77ef63aa3cb3afc65d0317e0b
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Mar 31 10:08:16 2016 +0200

    tty: vt, make color_table const
    
    This means all ->con_set_palette have to have the second parameter
    const too now.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 85193aa8c1e3..7e6c4450b8a5 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -24,7 +24,7 @@ extern void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry);
 
 extern int console_blanked;
 
-extern unsigned char color_table[];
+extern const unsigned char color_table[];
 extern int default_red[];
 extern int default_grn[];
 extern int default_blu[];

commit 432c9ed22aff641039ccd400cdabf983fabc285e
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Fri Oct 1 00:10:44 2010 -0400

    vcs: invoke the vt update callback when /dev/vcs* is written to
    
    A notifier chain is called whenever the vt code modifies a terminal
    content, except for one case which is when the modification comes
    through writes to /dev/vcs* devices.  Let's add the missing notifier
    invocation at the end of vcs_write() for that case too.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@canonical.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index 8cdaa1151d2e..85193aa8c1e3 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -39,5 +39,6 @@ extern void putconsxy(struct vc_data *vc, unsigned char *p);
 
 extern u16 vcs_scr_readw(struct vc_data *vc, const u16 *org);
 extern void vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org);
+extern void vcs_scr_updated(struct vc_data *vc);
 
 #endif

commit 120c0b6d57257b2a3508d96bdaf54781935439f6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 16 01:29:04 2007 -0700

    vt: Fix warnings in selection.h
    
    <linux/selection.h> assumes that struct tty_struct has previously been
    included.  If not, this pile of warnings will result:
    
      CC [M]  drivers/video/console/newport_con.o
    In file included from drivers/video/console/newport_con.c:18:
    include/linux/selection.h:16: warning: 'struct tty_struct' declared inside param
    eter list
    include/linux/selection.h:16: warning: its scope is only this definition or decl
    aration, which is probably not what you want
    include/linux/selection.h:17: warning: 'struct tty_struct' declared inside param
    eter list
    include/linux/selection.h:20: warning: 'struct tty_struct' declared inside param
    eter list
    
    Fixed by adding a forward declaration of struct tty_struct.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Antonino Daplas <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index f9457861937c..8cdaa1151d2e 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -13,6 +13,7 @@
 struct tty_struct;
 
 extern struct vc_data *sel_cons;
+struct tty_struct;
 
 extern void clear_selection(void);
 extern int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty);

commit 0aa42632d3a0024700b25f57fd0fca56f6abad24
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Aug 22 14:02:01 2007 -0700

    selection.h: add tty_struct forward declaration
    
    In file included from drivers/video/console/newport_con.c:16:
    include/linux/selection.h:16: warning: "struct tty_struct" declared inside parameter list
    include/linux/selection.h:16: warning: its scope is only this definition or declaration, which is probably not what you want
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/selection.h b/include/linux/selection.h
index ed3408b400f1..f9457861937c 100644
--- a/include/linux/selection.h
+++ b/include/linux/selection.h
@@ -10,6 +10,8 @@
 #include <linux/tiocl.h>
 #include <linux/vt_buffer.h>
 
+struct tty_struct;
+
 extern struct vc_data *sel_cons;
 
 extern void clear_selection(void);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/selection.h b/include/linux/selection.h
new file mode 100644
index 000000000000..ed3408b400f1
--- /dev/null
+++ b/include/linux/selection.h
@@ -0,0 +1,40 @@
+/*
+ * selection.h
+ *
+ * Interface between console.c, tty_io.c, vt.c, vc_screen.c and selection.c
+ */
+
+#ifndef _LINUX_SELECTION_H_
+#define _LINUX_SELECTION_H_
+
+#include <linux/tiocl.h>
+#include <linux/vt_buffer.h>
+
+extern struct vc_data *sel_cons;
+
+extern void clear_selection(void);
+extern int set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty);
+extern int paste_selection(struct tty_struct *tty);
+extern int sel_loadlut(char __user *p);
+extern int mouse_reporting(void);
+extern void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry);
+
+extern int console_blanked;
+
+extern unsigned char color_table[];
+extern int default_red[];
+extern int default_grn[];
+extern int default_blu[];
+
+extern unsigned short *screen_pos(struct vc_data *vc, int w_offset, int viewed);
+extern u16 screen_glyph(struct vc_data *vc, int offset);
+extern void complement_pos(struct vc_data *vc, int offset);
+extern void invert_screen(struct vc_data *vc, int offset, int count, int shift);
+
+extern void getconsxy(struct vc_data *vc, unsigned char *p);
+extern void putconsxy(struct vc_data *vc, unsigned char *p);
+
+extern u16 vcs_scr_readw(struct vc_data *vc, const u16 *org);
+extern void vcs_scr_writew(struct vc_data *vc, u16 val, u16 *org);
+
+#endif
