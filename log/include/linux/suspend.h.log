commit ad1e4f74c072eaa2c6d77dd710db31aafecd614f
Author: Domenico Andreoli <domenico.andreoli@linux.com>
Date:   Tue May 19 20:14:10 2020 +0200

    PM: hibernate: Restrict writes to the resume device
    
    Hibernation via snapshot device requires write permission to the swap
    block device, the one that more often (but not necessarily) is used to
    store the hibernation image.
    
    With this patch, such permissions are granted iff:
    
     1) snapshot device config option is enabled
     2) swap partition is used as resume device
    
    In other circumstances the swap device is not writable from userspace.
    
    In order to achieve this, every write attempt to a swap device is
    checked against the device configured as part of the uswsusp API [0]
    using a pointer to the inode struct in memory. If the swap device being
    written was not configured for resuming, the write request is denied.
    
    NOTE: this implementation works only for swap block devices, where the
    inode configured by swapon (which sets S_SWAPFILE) is the same used
    by SNAPSHOT_SET_SWAP_AREA.
    
    In case of swap file, SNAPSHOT_SET_SWAP_AREA indeed receives the inode
    of the block device containing the filesystem where the swap file is
    located (+ offset in it) which is never passed to swapon and then has
    not set S_SWAPFILE.
    
    As result, the swap file itself (as a file) has never an option to be
    written from userspace. Instead it remains writable if accessed directly
    from the containing block device, which is always writeable from root.
    
    [0] Documentation/power/userland-swsusp.rst
    
    v2:
     - rename is_hibernate_snapshot_dev() to is_hibernate_resume_dev()
     - fix description so to correctly refer to the resume device
    
    Signed-off-by: Domenico Andreoli <domenico.andreoli@linux.com>
    Acked-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 4fcc6fd0cbd6..b960098acfb0 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -466,6 +466,12 @@ static inline bool system_entering_hibernation(void) { return false; }
 static inline bool hibernation_available(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
+#ifdef CONFIG_HIBERNATION_SNAPSHOT_DEV
+int is_hibernate_resume_dev(const struct inode *);
+#else
+static inline int is_hibernate_resume_dev(const struct inode *i) { return 0; }
+#endif
+
 /* Hibernation and suspend events */
 #define PM_HIBERNATION_PREPARE	0x0001 /* Going to hibernate */
 #define PM_POST_HIBERNATION	0x0002 /* Hibernation finished */

commit 086b2d78375cffe58f5341359bebec0650793811
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Mar 18 20:55:20 2020 +0100

    PM: remove s390 specific callbacks
    
    ARCH_SAVE_PAGE_KEYS has been introduced in order to be able to save
    and restore s390 specific storage keys into a hibernation image.
    With hibernation support removed from s390 there is no point in
    keeping the callbacks.
    
    Acked-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Acked-by: Peter Oberparleiter <oberpar@linux.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 2b2055b035ee..4fcc6fd0cbd6 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -566,38 +566,4 @@ static inline void queue_up_suspend_work(void) {}
 
 #endif /* !CONFIG_PM_AUTOSLEEP */
 
-#ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
-/*
- * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture
- * to save/restore additional information to/from the array of page
- * frame numbers in the hibernation image. For s390 this is used to
- * save and restore the storage key for each page that is included
- * in the hibernation image.
- */
-unsigned long page_key_additional_pages(unsigned long pages);
-int page_key_alloc(unsigned long pages);
-void page_key_free(void);
-void page_key_read(unsigned long *pfn);
-void page_key_memorize(unsigned long *pfn);
-void page_key_write(void *address);
-
-#else /* !CONFIG_ARCH_SAVE_PAGE_KEYS */
-
-static inline unsigned long page_key_additional_pages(unsigned long pages)
-{
-	return 0;
-}
-
-static inline int  page_key_alloc(unsigned long pages)
-{
-	return 0;
-}
-
-static inline void page_key_free(void) {}
-static inline void page_key_read(unsigned long *pfn) {}
-static inline void page_key_memorize(unsigned long *pfn) {}
-static inline void page_key_write(void *address) {}
-
-#endif /* !CONFIG_ARCH_SAVE_PAGE_KEYS */
-
 #endif /* _LINUX_SUSPEND_H */

commit e3728b50cd9be7d4b1469447cdf1feb93e3b7adb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 10:11:02 2020 +0100

    ACPI: PM: s2idle: Avoid possible race related to the EC GPE
    
    It is theoretically possible for the ACPI EC GPE to be set after the
    s2idle_ops->wake() called from s2idle_loop() has returned and before
    the subsequent pm_wakeup_pending() check is carried out.  If that
    happens, the resulting wakeup event will cause the system to resume
    even though it may be a spurious one.
    
    To avoid that race, first make the ->wake() callback in struct
    platform_s2idle_ops return a bool value indicating whether or not
    to let the system resume and rearrange s2idle_loop() to use that
    value instad of the direct pm_wakeup_pending() call if ->wake() is
    present.
    
    Next, rework acpi_s2idle_wake() to process EC events and check
    pm_wakeup_pending() before re-arming the SCI for system wakeup
    to prevent it from triggering prematurely and add comments to
    that function to explain the rationale for the new code flow.
    
    Fixes: 56b991849009 ("PM: sleep: Simplify suspend-to-idle control flow")
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 4a230c2f1c31..2b2055b035ee 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -191,7 +191,7 @@ struct platform_s2idle_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
 	int (*prepare_late)(void);
-	void (*wake)(void);
+	bool (*wake)(void);
 	void (*restore_early)(void);
 	void (*restore)(void);
 	void (*end)(void);

commit c052bf82c6b00ca27aab0859addc4b3159dfd3a4
Author: Jonas Meurer <jonas@freesources.org>
Date:   Thu Jan 16 12:53:54 2020 +0100

    PM: suspend: Add sysfs attribute to control the "sync on suspend" behavior
    
    The sysfs attribute `/sys/power/sync_on_suspend` controls, whether or not
    filesystems are synced by the kernel before system suspend.
    
    Congruously, the behaviour of build-time switch CONFIG_SUSPEND_SKIP_SYNC
    is slightly changed: It now defines the run-tim default for the new sysfs
    attribute `/sys/power/sync_on_suspend`.
    
    The run-time attribute is added because the existing corresponding
    build-time Kconfig flag for (`CONFIG_SUSPEND_SKIP_SYNC`) is not flexible
    enough. E.g. Linux distributions that provide pre-compiled kernels
    usually want to stick with the default (sync filesystems before suspend)
    but under special conditions this needs to be changed.
    
    One example for such a special condition is user-space handling of
    suspending block devices (e.g. using `cryptsetup luksSuspend` or `dmsetup
    suspend`) before system suspend. The Kernel trying to sync filesystems
    after the underlying block device already got suspended obviously leads
    to dead-locks. Be aware that you have to take care of the filesystem sync
    yourself before suspending the system in those scenarios.
    
    Signed-off-by: Jonas Meurer <jonas@freesources.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 6fc8843f1c9e..4a230c2f1c31 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -329,6 +329,7 @@ extern void arch_suspend_disable_irqs(void);
 extern void arch_suspend_enable_irqs(void);
 
 extern int pm_suspend(suspend_state_t state);
+extern bool sync_on_suspend_enabled;
 #else /* !CONFIG_SUSPEND */
 #define suspend_valid_only_mem	NULL
 
@@ -342,6 +343,7 @@ static inline bool pm_suspend_default_s2idle(void) { return false; }
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+static inline bool sync_on_suspend_enabled(void) { return true; }
 static inline bool idle_should_enter_s2idle(void) { return false; }
 static inline void __init pm_states_init(void) {}
 static inline void s2idle_set_ops(const struct platform_s2idle_ops *ops) {}

commit ac9eafbe930abb589e9289842a99cc575cadb854
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 1 19:31:10 2019 +0200

    ACPI: PM: s2idle: Execute LPS0 _DSM functions with suspended devices
    
    According to Section 3.5 of the "Intel Low Power S0 Idle" document [1],
    Function 5 of the LPS0 _DSM is expected to be invoked when the system
    configuration matches the criteria for entering the target low-power
    state of the platform.  In particular, this means that all devices
    should be suspended and in low-power states already when that function
    is invoked.
    
    This is not the case currently, however, because Function 5 of the
    LPS0 _DSM is invoked by it before the "noirq" phase of device suspend,
    which means that some devices may not have been put into low-power
    states yet at that point.  That is a consequence of the previous
    design of the suspend-to-idle flow that allowed the "noirq" phase of
    device suspend and the "noirq" phase of device resume to be carried
    out for multiple times while "suspended" (if any spurious wakeup
    events were detected) and the point of the LPS0 _DSM Function 5
    invocation was chosen so as to call it (and LPS0 _DSM Function 6
    analogously) once per suspend-resume cycle (regardless of how many
    times the "noirq" phases of device suspend and resume were carried
    out while "suspended").
    
    Now that the suspend-to-idle flow has been redesigned to carry out
    the "noirq" phases of device suspend and resume once in each cycle,
    the code can be reordered to follow the specification that it is
    based on more closely.
    
    For this purpose, add ->prepare_late and ->restore_early platform
    callbacks for suspend-to-idle, to be executed, respectively, after
    the "noirq" phase of suspending devices and before the "noirq"
    phase of resuming them and make ACPI use them for the invocation
    of LPS0 _DSM functions as appropriate.
    
    While at it, move the LPS0 entry requirements check to be made
    before invoking Functions 3 and 5 of the LPS0 _DSM (also once
    per cycle) as follows from the specification [1].
    
    Link: https://uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf # [1]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index f0c4a8445140..6fc8843f1c9e 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -190,7 +190,9 @@ struct platform_suspend_ops {
 struct platform_s2idle_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
+	int (*prepare_late)(void);
 	void (*wake)(void);
+	void (*restore_early)(void);
 	void (*restore)(void);
 	void (*end)(void);
 };

commit 10a08fd65ec1a68ccd86b19ec822ed5f2e50113f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jul 30 11:55:59 2019 +0200

    ACPI: PM: Set up EC GPE for system wakeup from drivers that need it
    
    The EC GPE needs to be set up for system wakeup only if there is a
    driver depending on it, either intel-hid or intel-vbtn, bound to a
    button device that is expected to wake up the system from sleep (such
    as the power button on some Dell systems, like the XPS13 9360).  It
    doesn't need to be set up for waking up the system from sleep in any
    other cases and whether or not it is expected to wake up the system
    from sleep doesn't depend on whether or not the LPS0 device is
    present in the ACPI namespace.
    
    For this reason, rearrange the ACPI suspend-to-idle code to make the
    drivers depending on the EC GPE wakeup take care of setting it up and
    decouple that from the LPS0 device handling.
    
    While at it, make intel-hid and intel-vbtn prepare for system wakeup
    only if they are allowed to wake up the system from sleep by user
    space (via sysfs).
    
    [Note that acpi_ec_mark_gpe_for_wake() and acpi_ec_set_gpe_wake_mask()
     are there to prevent the EC GPE from being disabled by the
     acpi_enable_all_wakeup_gpes() call in acpi_s2idle_prepare(), so on
     systems with either intel-hid or intel-vbtn this change doesn't
     affect any interactions with the hardware or platform firmware.]
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 66ce3871ed61..f0c4a8445140 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -335,6 +335,7 @@ static inline void pm_set_suspend_via_firmware(void) {}
 static inline void pm_set_resume_via_firmware(void) {}
 static inline bool pm_suspend_via_firmware(void) { return false; }
 static inline bool pm_resume_via_firmware(void) { return false; }
+static inline bool pm_suspend_no_platform(void) { return false; }
 static inline bool pm_suspend_default_s2idle(void) { return false; }
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}

commit 56b991849009f5def0443bfb2f48c8321d888e15
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 23:52:03 2019 +0200

    PM: sleep: Simplify suspend-to-idle control flow
    
    After commit 33e4f80ee69b ("ACPI / PM: Ignore spurious SCI wakeups
    from suspend-to-idle") the "noirq" phases of device suspend and
    resume may run for multiple times during suspend-to-idle, if there
    are spurious system wakeup events while suspended.  However, this
    is complicated and fragile and actually unnecessary.
    
    The main reason for doing this is that on some systems the EC may
    signal system wakeup events (power button events, for example) as
    well as events that should not cause the system to resume (spurious
    system wakeup events).  Thus, in order to determine whether or not
    a given event signaled by the EC while suspended is a proper system
    wakeup one, the EC GPE needs to be dispatched and to start with that
    was achieved by allowing the ACPI SCI action handler to run, which
    was only possible after calling resume_device_irqs().
    
    However, dispatching the EC GPE this way turned out to take too much
    time in some cases and some EC events might be missed due to that, so
    commit 68e22011856f ("ACPI: EC: Dispatch the EC GPE directly on
    s2idle wake") started to dispatch the EC GPE right after a wakeup
    event has been detected, so in fact the full ACPI SCI action handler
    doesn't need to run any more to deal with the wakeups coming from the
    EC.
    
    Use this observation to simplify the suspend-to-idle control flow
    so that the "noirq" phases of device suspend and resume are each
    run only once in every suspend-to-idle cycle, which is reported to
    significantly reduce power drawn by some systems when suspended to
    idle (by allowing them to reach a deep platform-wide low-power state
    through the suspend-to-idle flow).  [What appears to happen is that
    the "noirq" resume of devices after a spurious EC wakeup brings some
    devices into a state in which they prevent the platform from reaching
    the deep low-power state going forward, even after a subsequent
    "noirq" suspend phase, and on some systems the EC triggers such
    wakeups already when the "noirq" suspend of devices is running for
    the first time in the given suspend/resume cycle, so the platform
    cannot reach the deep low-power state at all.]
    
    First, make acpi_s2idle_wake() use the acpi_ec_dispatch_gpe() return
    value to determine whether or not the wakeup may have been triggered
    by the EC (in which case the system wakeup is canceled and ACPI
    events are processed in order to determine whether or not the event
    is a proper system wakeup one) and use rearm_wake_irq() (introduced
    by a previous change) in it to rearm the ACPI SCI for system wakeup
    detection in case the system will remain suspended.
    
    Second, drop acpi_s2idle_sync(), which is not needed any more, and
    the corresponding global platform suspend-to-idle callback.
    
    Next, drop the pm_wakeup_pending() check (which is an optimization
    only) from __device_suspend_noirq() to prevent it from returning
    errors on system wakeups occurring before the "noirq" phase of
    device suspend is complete (as in the case of suspend-to-idle it is
    not known whether or not these wakeups are suprious at that point),
    in order to avoid having to carry out a "noirq" resume of devices
    on a spurious system wakeup.
    
    Finally, change the code flow in s2idle_loop() to (1) run the
    "noirq" suspend of devices once before starting the loop, (2) check
    for spurious EC wakeups (via the platform ->wake callback) for the
    first time before calling s2idle_enter(), and (3) run the "noirq"
    resume of devices once after leaving the loop.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 9c0ad1a3a727..66ce3871ed61 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -191,7 +191,6 @@ struct platform_s2idle_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
 	void (*wake)(void);
-	void (*sync)(void);
 	void (*restore)(void);
 	void (*end)(void);
 };

commit 3dbeb448543efc01f04cadd6d358b9f33dd20d31
Merge: 50e163d43ab1 02bd45a28bf3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 8 10:51:25 2019 +0200

    Merge branch 'pm-sleep'
    
    * pm-sleep:
      PM: sleep: Drop dev_pm_skip_next_resume_phases()
      ACPI: PM: Drop unused function and function header
      ACPI: PM: Introduce "poweroff" callbacks for ACPI PM domain and LPSS
      ACPI: PM: Simplify and fix PM domain hibernation callbacks
      PCI: PM: Simplify bus-level hibernation callbacks
      PM: ACPI/PCI: Resume all devices during hibernation
      kernel: power: swap: use kzalloc() instead of kmalloc() followed by memset()
      PM: sleep: Update struct wakeup_source documentation
      drivers: base: power: remove wakeup_sources_stats_dentry variable
      PM: suspend: Rename pm_suspend_via_s2idle()
      PM: sleep: Show how long dpm_suspend_start() and dpm_suspend_end() take
      PM: hibernate: powerpc: Expose pfn_is_nosave() prototype

commit 471a739a47aa7d582f0cdf9d392957d04632bae2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 26 00:20:23 2019 +0200

    PCI: PM: Avoid skipping bus-level PM on platforms without ACPI
    
    There are platforms that do not call pm_set_suspend_via_firmware(),
    so pm_suspend_via_firmware() returns 'false' on them, but the power
    states of PCI devices (PCIe ports in particular) are changed as a
    result of powering down core platform components during system-wide
    suspend.  Thus the pm_suspend_via_firmware() checks in
    pci_pm_suspend_noirq() and pci_pm_resume_noirq() introduced by
    commit 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-
    idle") are not sufficient to determine that devices left in D0
    during suspend will remain in D0 during resume and so the bus-level
    power management can be skipped for them.
    
    For this reason, introduce a new global suspend flag,
    PM_SUSPEND_FLAG_NO_PLATFORM, set it for suspend-to-idle only
    and replace the pm_suspend_via_firmware() checks mentioned above
    with checks against this flag.
    
    Fixes: 3e26c5feed2a ("PCI: PM: Skip devices in D0 for suspend-to-idle")
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 8594001e8be8..f0d262ad7b78 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -209,8 +209,9 @@ extern int suspend_valid_only_mem(suspend_state_t state);
 
 extern unsigned int pm_suspend_global_flags;
 
-#define PM_SUSPEND_FLAG_FW_SUSPEND	(1 << 0)
-#define PM_SUSPEND_FLAG_FW_RESUME	(1 << 1)
+#define PM_SUSPEND_FLAG_FW_SUSPEND	BIT(0)
+#define PM_SUSPEND_FLAG_FW_RESUME	BIT(1)
+#define PM_SUSPEND_FLAG_NO_PLATFORM	BIT(2)
 
 static inline void pm_suspend_clear_flags(void)
 {
@@ -227,6 +228,11 @@ static inline void pm_set_resume_via_firmware(void)
 	pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;
 }
 
+static inline void pm_set_suspend_no_platform(void)
+{
+	pm_suspend_global_flags |= PM_SUSPEND_FLAG_NO_PLATFORM;
+}
+
 /**
  * pm_suspend_via_firmware - Check if platform firmware will suspend the system.
  *
@@ -268,6 +274,22 @@ static inline bool pm_resume_via_firmware(void)
 	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_RESUME);
 }
 
+/**
+ * pm_suspend_no_platform - Check if platform may change device power states.
+ *
+ * To be called during system-wide power management transitions to sleep states
+ * or during the subsequent system-wide transitions back to the working state.
+ *
+ * Return 'true' if the power states of devices remain under full control of the
+ * kernel throughout the system-wide suspend and resume cycle in progress (that
+ * is, if a device is put into a certain power state during suspend, it can be
+ * expected to remain in that state during resume).
+ */
+static inline bool pm_suspend_no_platform(void)
+{
+	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_NO_PLATFORM);
+}
+
 /* Suspend-to-idle state machnine. */
 enum s2idle_states {
 	S2IDLE_STATE_NONE,      /* Not suspended/suspending. */

commit 0b385a0c3bd3f6d1044728b732bfc7dfb01c9fb5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 18 10:18:28 2019 +0200

    PM: suspend: Rename pm_suspend_via_s2idle()
    
    The name of pm_suspend_via_s2idle() is confusing, as it doesn't
    reflect the purpose of the function precisely enough and it is
    very similar to pm_suspend_via_firmware(), which has a different
    purpose, so rename it as pm_suspend_default_s2idle() and update
    its only caller, i8042_register_ports(), accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 05645f726815..d07ae7fb9315 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -282,7 +282,7 @@ static inline bool idle_should_enter_s2idle(void)
 	return unlikely(s2idle_state == S2IDLE_STATE_ENTER);
 }
 
-extern bool pm_suspend_via_s2idle(void);
+extern bool pm_suspend_default_s2idle(void);
 extern void __init pm_states_init(void);
 extern void s2idle_set_ops(const struct platform_s2idle_ops *ops);
 extern void s2idle_wake(void);
@@ -314,7 +314,7 @@ static inline void pm_set_suspend_via_firmware(void) {}
 static inline void pm_set_resume_via_firmware(void) {}
 static inline bool pm_suspend_via_firmware(void) { return false; }
 static inline bool pm_resume_via_firmware(void) { return false; }
-static inline bool pm_suspend_via_s2idle(void) { return false; }
+static inline bool pm_suspend_default_s2idle(void) { return false; }
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }

commit 1ec0cd8286f35988134e05367ab5e66213b84e7c
Author: Mathieu Malaterre <malat@debian.org>
Date:   Fri May 24 12:44:18 2019 +0200

    PM: hibernate: powerpc: Expose pfn_is_nosave() prototype
    
    The declaration for pfn_is_nosave is only available in
    kernel/power/power.h. Since this function can be override in arch,
    expose it globally. Having a prototype will make sure to avoid warning
    (sometime treated as error with W=1) such as:
    
      arch/powerpc/kernel/suspend.c:18:5: error: no previous prototype for 'pfn_is_nosave' [-Werror=missing-prototypes]
    
    This moves the declaration into a globally visible header file and add
    missing include to avoid a warning on powerpc.
    
    Also remove the duplicated prototypes since not required anymore.
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 8594001e8be8..05645f726815 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -426,6 +426,7 @@ extern bool system_entering_hibernation(void);
 extern bool hibernation_available(void);
 asmlinkage int swsusp_save(void);
 extern struct pbe *restore_pblist;
+int pfn_is_nosave(unsigned long pfn);
 #else /* CONFIG_HIBERNATION */
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
 static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}

commit a61373476127edac8bcc5ee9d68a74dc1b864f53
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 27 12:45:18 2019 +0200

    PM: sleep: Add kerneldoc comments to some functions
    
    Add kerneldoc comments to pm_suspend_via_firmware(),
    pm_resume_via_firmware() and pm_suspend_via_s2idle()
    to explain what they do.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 4a2ffd678887..8594001e8be8 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -227,11 +227,42 @@ static inline void pm_set_resume_via_firmware(void)
 	pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;
 }
 
+/**
+ * pm_suspend_via_firmware - Check if platform firmware will suspend the system.
+ *
+ * To be called during system-wide power management transitions to sleep states
+ * or during the subsequent system-wide transitions back to the working state.
+ *
+ * Return 'true' if the platform firmware is going to be invoked at the end of
+ * the system-wide power management transition (to a sleep state) in progress in
+ * order to complete it, or if the platform firmware has been invoked in order
+ * to complete the last (or preceding) transition of the system to a sleep
+ * state.
+ *
+ * This matters if the caller needs or wants to carry out some special actions
+ * depending on whether or not control will be passed to the platform firmware
+ * subsequently (for example, the device may need to be reset before letting the
+ * platform firmware manipulate it, which is not necessary when the platform
+ * firmware is not going to be invoked) or when such special actions may have
+ * been carried out during the preceding transition of the system to a sleep
+ * state (as they may need to be taken into account).
+ */
 static inline bool pm_suspend_via_firmware(void)
 {
 	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_SUSPEND);
 }
 
+/**
+ * pm_resume_via_firmware - Check if platform firmware has woken up the system.
+ *
+ * To be called during system-wide power management transitions from sleep
+ * states.
+ *
+ * Return 'true' if the platform firmware has passed control to the kernel at
+ * the beginning of the system-wide power management transition in progress, so
+ * the event that woke up the system from sleep has been handled by the platform
+ * firmware.
+ */
 static inline bool pm_resume_via_firmware(void)
 {
 	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_RESUME);

commit bb1869012d7b78d1474808cb4c8bd8b272645876
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 12:43:19 2019 +0200

    ACPI: PM: Call pm_set_suspend_via_firmware() during hibernation
    
    On systems with ACPI platform firmware the last stage of hibernation
    is analogous to system suspend to S3 (suspend-to-RAM), so it should
    be handled analogously.  In particular, pm_suspend_via_firmware()
    should return 'true' in that stage to let the callers of it know that
    control will be passed to the platform firmware going forward, so
    pm_set_suspend_via_firmware() needs to be called then in analogy with
    acpi_suspend_begin().
    
    However, the platform hibernation ->begin() callback is invoked
    during the "freeze" transition (before creating a snapshot image of
    system memory) as well as during the "hibernate" transition which is
    the last stage of it and pm_set_suspend_via_firmware() should be
    invoked by that callback in the latter stage only.
    
    In order to implement that redefine the hibernation ->begin()
    callback to take a pm_message_t argument to indicate which stage
    of hibernation is taking place and rework acpi_hibernation_begin()
    and acpi_hibernation_begin_old() to take it into account as needed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 6b3ea9ea6a9e..4a2ffd678887 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -359,7 +359,7 @@ extern void mark_free_pages(struct zone *zone);
  *	platforms which require special recovery actions in that situation.
  */
 struct platform_hibernation_ops {
-	int (*begin)(void);
+	int (*begin)(pm_message_t stage);
 	void (*end)(void);
 	int (*pre_snapshot)(void);
 	void (*finish)(void);

commit b5dee3130bb4014511f5d0dd46855ed843e3fdc8
Author: Harry Pan <harry.pan@intel.com>
Date:   Mon Feb 25 20:36:41 2019 +0800

    PM / sleep: Refactor filesystems sync to reduce duplication
    
    Create a common helper to sync filesystems for system suspend and
    hibernation.
    
    Signed-off-by: Harry Pan <harry.pan@intel.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 3f529ad9a9d2..6b3ea9ea6a9e 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -425,6 +425,7 @@ void restore_processor_state(void);
 /* kernel/power/main.c */
 extern int register_pm_notifier(struct notifier_block *nb);
 extern int unregister_pm_notifier(struct notifier_block *nb);
+extern void ksys_sync_helper(void);
 
 #define pm_notifier(fn, pri) {				\
 	static struct notifier_block fn##_nb =			\
@@ -462,6 +463,8 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 	return 0;
 }
 
+static inline void ksys_sync_helper(void) {}
+
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 
 static inline bool pm_wakeup_pending(void) { return false; }

commit eb81bfb224ced3701bcc7b08f309665bf0549252
Merge: 0c53b6a5f82a cecf10704899
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Oct 12 12:35:02 2018 +0200

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    Dmitry writes:
      "Input updates for v4.19-rc7
    
       - we added a few scheduling points into various input interfaces to
         ensure that large writes will not cause RCU stalls
       - fixed configuring PS/2 keyboards as wakeup devices on newer
         platforms
       - added a new Xbox gamepad ID."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: uinput - add a schedule point in uinput_inject_events()
      Input: evdev - add a schedule point in evdev_write()
      Input: mousedev - add a schedule point in mousedev_write()
      Input: i8042 - enable keyboard wakeups by default when s2idle is used
      Input: xpad - add support for Xbox1 PDP Camo series gamepad

commit 684bec1092b6991ff2a7751e8a763898576eb5c2
Author: Daniel Drake <drake@endlessm.com>
Date:   Mon Oct 1 15:55:22 2018 -0700

    Input: i8042 - enable keyboard wakeups by default when s2idle is used
    
    Previously, on typical consumer laptops, pressing a key on the keyboard
    when the system is in suspend would cause it to wake up (default or
    unconditional behaviour). This happens because the EC generates a SCI
    interrupt in this scenario.
    
    That is no longer true on modern laptops based on Intel WhiskeyLake,
    including Acer Swift SF314-55G, Asus UX333FA, Asus UX433FN and Asus
    UX533FD. We confirmed with Asus EC engineers that the "Modern Standby"
    design has been modified so that the EC no longer generates a SCI
    in this case; the keyboard controller itself should be used for wakeup.
    
    In order to retain the standard behaviour of being able to use the
    keyboard to wake up the system, enable serio wakeups by default on
    platforms that are using s2idle.
    
    Link: https://lkml.kernel.org/r/CAB4CAwfQ0mPMqCLp95TVjw4J0r5zKPWkSvvkK4cpZUGE--w8bQ@mail.gmail.com
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 440b62f7502e..206b735f383f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -251,6 +251,7 @@ static inline bool idle_should_enter_s2idle(void)
 	return unlikely(s2idle_state == S2IDLE_STATE_ENTER);
 }
 
+extern bool pm_suspend_via_s2idle(void);
 extern void __init pm_states_init(void);
 extern void s2idle_set_ops(const struct platform_s2idle_ops *ops);
 extern void s2idle_wake(void);
@@ -282,6 +283,7 @@ static inline void pm_set_suspend_via_firmware(void) {}
 static inline void pm_set_resume_via_firmware(void) {}
 static inline bool pm_suspend_via_firmware(void) { return false; }
 static inline bool pm_resume_via_firmware(void) { return false; }
+static inline bool pm_suspend_via_s2idle(void) { return false; }
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }

commit 55f2503c3b69328735e88031ff8d6ba291bd952b
Author: Pingfan Liu <kernelfans@gmail.com>
Date:   Tue Jul 31 16:51:32 2018 +0800

    PM / reboot: Eliminate race between reboot and suspend
    
    At present, "systemctl suspend" and "shutdown" can run in parrallel. A
    system can suspend after devices_shutdown(), and resume. Then the shutdown
    task goes on to power off. This causes many devices are not really shut
    off. Hence replacing reboot_mutex with system_transition_mutex (renamed
    from pm_mutex) to achieve the exclusion. The renaming of pm_mutex as
    system_transition_mutex can be better to reflect the purpose of the mutex.
    
    Signed-off-by: Pingfan Liu <kernelfans@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 440b62f7502e..5a28ac9284f0 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -414,7 +414,7 @@ static inline bool hibernation_available(void) { return false; }
 #define PM_RESTORE_PREPARE	0x0005 /* Going to restore a saved image */
 #define PM_POST_RESTORE		0x0006 /* Restore failed */
 
-extern struct mutex pm_mutex;
+extern struct mutex system_transition_mutex;
 
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);

commit 328008a72d38b5bde6491e463405c34a81a65d3e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Feb 2 15:56:18 2018 +0100

    x86/power: Fix swsusp_arch_resume prototype
    
    The declaration for swsusp_arch_resume marks it as 'asmlinkage', but the
    definition in x86-32 does not, and it fails to include the header with the
    declaration. This leads to a warning when building with
    link-time-optimizations:
    
    kernel/power/power.h:108:23: error: type of 'swsusp_arch_resume' does not match original declaration [-Werror=lto-type-mismatch]
     extern asmlinkage int swsusp_arch_resume(void);
                           ^
    arch/x86/power/hibernate_32.c:148:0: note: 'swsusp_arch_resume' was previously declared here
     int swsusp_arch_resume(void)
    
    This moves the declaration into a globally visible header file and fixes up
    both x86 definitions to match it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: linux-pm@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    Link: https://lkml.kernel.org/r/20180202145634.200291-2-arnd@arndb.de

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index cc22a24516d6..440b62f7502e 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -384,6 +384,8 @@ extern int swsusp_page_is_forbidden(struct page *);
 extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
+extern asmlinkage int swsusp_arch_suspend(void);
+extern asmlinkage int swsusp_arch_resume(void);
 
 extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);

commit 4bf236a3330e97d275e5848420f7e31948fef07a
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Jan 5 09:19:08 2018 -0800

    PM / sleep: Make lock/unlock_system_sleep() available to kernel modules
    
    Since pm_mutex is not exported using lock/unlock_system_sleep() from
    inside a kernel module causes a "pm_mutex undefined" linker error.
    Hence move lock/unlock_system_sleep() into kernel/power/main.c and
    export these.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d60b0f5c38d5..cc22a24516d6 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -443,32 +443,8 @@ extern bool pm_save_wakeup_count(unsigned int count);
 extern void pm_wakep_autosleep_enabled(bool set);
 extern void pm_print_active_wakeup_sources(void);
 
-static inline void lock_system_sleep(void)
-{
-	current->flags |= PF_FREEZER_SKIP;
-	mutex_lock(&pm_mutex);
-}
-
-static inline void unlock_system_sleep(void)
-{
-	/*
-	 * Don't use freezer_count() because we don't want the call to
-	 * try_to_freeze() here.
-	 *
-	 * Reason:
-	 * Fundamentally, we just don't need it, because freezing condition
-	 * doesn't come into effect until we release the pm_mutex lock,
-	 * since the freezer always works with pm_mutex held.
-	 *
-	 * More importantly, in the case of hibernation,
-	 * unlock_system_sleep() gets called in snapshot_read() and
-	 * snapshot_write() when the freezing condition is still in effect.
-	 * Which means, if we use try_to_freeze() here, it would make them
-	 * enter the refrigerator, thus causing hibernation to lockup.
-	 */
-	current->flags &= ~PF_FREEZER_SKIP;
-	mutex_unlock(&pm_mutex);
-}
+extern void lock_system_sleep(void);
+extern void unlock_system_sleep(void);
 
 #else /* !CONFIG_PM_SLEEP */
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d10b7980799d..d60b0f5c38d5 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_SUSPEND_H
 #define _LINUX_SUSPEND_H
 

commit 726fb6b4f2a82a14a906f39bdabac4863b87c01a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Aug 15 18:16:59 2017 -0700

    ACPI / PM: Check low power idle constraints for debug only
    
    For SoC to achieve its lowest power platform idle state a set of hardware
    preconditions must be met. These preconditions or constraints can be
    obtained by issuing a device specific method (_DSM) with function "1".
    Refer to the document provided in the link below.
    
    Here during initialization (from attach() callback of LPS0 device), invoke
    function 1 to get the device constraints. Each enabled constraint is
    stored in a table.
    
    The devices in this table are used to check whether they were in required
    minimum state, while entering suspend. This check is done from platform
    freeze wake() callback, only when /sys/power/pm_debug_messages attribute
    is non zero.
    
    If any constraint is not met and device is ACPI power managed then it
    prints the device information to kernel logs.
    
    Also if debug is enabled in acpi/sleep.c, the constraint table and state
    of each device on wake is dumped in kernel logs.
    
    Since pm_debug_messages_on setting is used as condition to check
    constraints outside kernel/power/main.c, pm_debug_messages_on is changed
    to a global variable.
    
    Link: http://www.uefi.org/sites/default/files/resources/Intel_ACPI_Low_Power_S0_Idle.pdf
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0d41daf7e89d..d10b7980799d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -495,9 +495,11 @@ static inline void unlock_system_sleep(void) {}
 
 #ifdef CONFIG_PM_SLEEP_DEBUG
 extern bool pm_print_times_enabled;
+extern bool pm_debug_messages_on;
 extern __printf(2, 3) void __pm_pr_dbg(bool defer, const char *fmt, ...);
 #else
 #define pm_print_times_enabled	(false)
+#define pm_debug_messages_on	(false)
 
 #include <linux/printk.h>
 

commit 23d5855f4774f4f7c246a67057ecacc904696d8a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:15:30 2017 +0200

    PM / s2idle: Rename platform operations structure
    
    Rename struct platform_freeze_ops to platform_s2idle_ops to make it
    clear that the callbacks in it are used during suspend-to-idle
    suspend/resume transitions and rename the related functions,
    variables and so on accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index feb43dfbf7bc..0d41daf7e89d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -186,7 +186,7 @@ struct platform_suspend_ops {
 	void (*recover)(void);
 };
 
-struct platform_freeze_ops {
+struct platform_s2idle_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
 	void (*wake)(void);
@@ -251,7 +251,7 @@ static inline bool idle_should_enter_s2idle(void)
 }
 
 extern void __init pm_states_init(void);
-extern void freeze_set_ops(const struct platform_freeze_ops *ops);
+extern void s2idle_set_ops(const struct platform_s2idle_ops *ops);
 extern void s2idle_wake(void);
 
 /**
@@ -286,7 +286,7 @@ static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
 static inline bool idle_should_enter_s2idle(void) { return false; }
 static inline void __init pm_states_init(void) {}
-static inline void freeze_set_ops(const struct platform_freeze_ops *ops) {}
+static inline void s2idle_set_ops(const struct platform_s2idle_ops *ops) {}
 static inline void s2idle_wake(void) {}
 #endif /* !CONFIG_SUSPEND */
 

commit f02f4f9d826590f1ef1b087374d3e3cfb7949eac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:13:56 2017 +0200

    PM / s2idle: Rename freeze_state enum and related items
    
    Rename the freeze_state enum representing the suspend-to-idle state
    machine states to s2idle_states and rename the related variables and
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d43654be0097..feb43dfbf7bc 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -237,22 +237,22 @@ static inline bool pm_resume_via_firmware(void)
 }
 
 /* Suspend-to-idle state machnine. */
-enum freeze_state {
-	FREEZE_STATE_NONE,      /* Not suspended/suspending. */
-	FREEZE_STATE_ENTER,     /* Enter suspend-to-idle. */
-	FREEZE_STATE_WAKE,      /* Wake up from suspend-to-idle. */
+enum s2idle_states {
+	S2IDLE_STATE_NONE,      /* Not suspended/suspending. */
+	S2IDLE_STATE_ENTER,     /* Enter suspend-to-idle. */
+	S2IDLE_STATE_WAKE,      /* Wake up from suspend-to-idle. */
 };
 
-extern enum freeze_state __read_mostly suspend_freeze_state;
+extern enum s2idle_states __read_mostly s2idle_state;
 
-static inline bool idle_should_freeze(void)
+static inline bool idle_should_enter_s2idle(void)
 {
-	return unlikely(suspend_freeze_state == FREEZE_STATE_ENTER);
+	return unlikely(s2idle_state == S2IDLE_STATE_ENTER);
 }
 
 extern void __init pm_states_init(void);
 extern void freeze_set_ops(const struct platform_freeze_ops *ops);
-extern void freeze_wake(void);
+extern void s2idle_wake(void);
 
 /**
  * arch_suspend_disable_irqs - disable IRQs for suspend
@@ -284,10 +284,10 @@ static inline bool pm_resume_via_firmware(void) { return false; }
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
-static inline bool idle_should_freeze(void) { return false; }
+static inline bool idle_should_enter_s2idle(void) { return false; }
 static inline void __init pm_states_init(void) {}
 static inline void freeze_set_ops(const struct platform_freeze_ops *ops) {}
-static inline void freeze_wake(void) {}
+static inline void s2idle_wake(void) {}
 #endif /* !CONFIG_SUSPEND */
 
 /* struct pbe is used for creating lists of pages that should be restored

commit 690cbb90a709c1b9389c6cb8e1978e77553ce0fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:13:07 2017 +0200

    PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
    
    To make it clear that the symbol in question refers to
    suspend-to-idle, rename it from PM_SUSPEND_FREEZE to
    PM_SUSPEND_TO_IDLE.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 8c3b0b1e6786..d43654be0097 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -33,10 +33,10 @@ static inline void pm_restore_console(void)
 typedef int __bitwise suspend_state_t;
 
 #define PM_SUSPEND_ON		((__force suspend_state_t) 0)
-#define PM_SUSPEND_FREEZE	((__force suspend_state_t) 1)
+#define PM_SUSPEND_TO_IDLE	((__force suspend_state_t) 1)
 #define PM_SUSPEND_STANDBY	((__force suspend_state_t) 2)
 #define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
-#define PM_SUSPEND_MIN		PM_SUSPEND_FREEZE
+#define PM_SUSPEND_MIN		PM_SUSPEND_TO_IDLE
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
 enum suspend_stat_step {

commit e870c6c87cf9484090d28f2a68aa29e008960c93
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 31 23:43:18 2017 +0200

    ACPI / PM: Prefer suspend-to-idle over S3 on some systems
    
    Modify the ACPI system sleep support setup code to select
    suspend-to-idle as the default system sleep state if
    (1) the ACPI_FADT_LOW_POWER_S0 flag is set in the FADT and
    (2) the Low Power Idle S0 _DSM interface has been discovered and
    (3) the default sleep state was not selected from the kernel command
    line.
    
    The main motivation for this change is that systems where the (1) and
    (2) conditions are met typically ship with OSes that don't exercise
    the S3 path in the platform firmware which remains untested and turns
    out to be non-functional at least in some cases.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 97e394feabdb..8c3b0b1e6786 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -196,6 +196,9 @@ struct platform_freeze_ops {
 };
 
 #ifdef CONFIG_SUSPEND
+extern suspend_state_t mem_sleep_current;
+extern suspend_state_t mem_sleep_default;
+
 /**
  * suspend_set_ops - set platform dependent suspend operations
  * @ops: The new suspend operations to set.

commit cb08e0353c249a27aed10c6f60a13871ae449d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 23 00:03:43 2017 +0200

    PM / timekeeping: Print debug messages when requested
    
    The messages printed by tk_debug_account_sleep_time() are basically
    useful for system sleep debugging, so print them only when the other
    debug messages from the core suspend/hibernate code are enabled.
    
    While at it, make it clear that the messages from
    tk_debug_account_sleep_time() are about timekeeping suspend
    duration, because in general timekeeping may be suspeded and
    resumed for multiple times during one system suspend-resume cycle.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 707e4cdf21c2..97e394feabdb 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -492,16 +492,22 @@ static inline void unlock_system_sleep(void) {}
 
 #ifdef CONFIG_PM_SLEEP_DEBUG
 extern bool pm_print_times_enabled;
-extern __printf(1, 2) void pm_pr_dbg(const char *fmt, ...);
+extern __printf(2, 3) void __pm_pr_dbg(bool defer, const char *fmt, ...);
 #else
 #define pm_print_times_enabled	(false)
 
 #include <linux/printk.h>
 
-#define pm_pr_dbg(fmt, ...) \
+#define __pm_pr_dbg(defer, fmt, ...) \
 	no_printk(KERN_DEBUG fmt, ##__VA_ARGS__)
 #endif
 
+#define pm_pr_dbg(fmt, ...) \
+	__pm_pr_dbg(false, fmt, ##__VA_ARGS__)
+
+#define pm_deferred_pr_dbg(fmt, ...) \
+	__pm_pr_dbg(true, fmt, ##__VA_ARGS__)
+
 #ifdef CONFIG_PM_AUTOSLEEP
 
 /* kernel/power/autosleep.c */

commit 8d8b2441db9647890251538f60b75a4e45fdef8d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 19 02:38:44 2017 +0200

    PM / sleep: Do not print debug messages by default
    
    Debug messages from the system suspend/hibernation infrastructure can
    fill up the entire kernel log buffer in some cases and anyway they
    are only useful for debugging.  They depend on CONFIG_PM_DEBUG, but
    that is set as a rule as some generally useful diagnostic facilities
    depend on it too.
    
    For this reason, avoid printing those messages by default, but make
    it possible to turn them on as needed with the help of a new sysfs
    attribute under /sys/power/.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 2159f6841768..707e4cdf21c2 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -492,8 +492,14 @@ static inline void unlock_system_sleep(void) {}
 
 #ifdef CONFIG_PM_SLEEP_DEBUG
 extern bool pm_print_times_enabled;
+extern __printf(1, 2) void pm_pr_dbg(const char *fmt, ...);
 #else
 #define pm_print_times_enabled	(false)
+
+#include <linux/printk.h>
+
+#define pm_pr_dbg(fmt, ...) \
+	no_printk(KERN_DEBUG fmt, ##__VA_ARGS__)
 #endif
 
 #ifdef CONFIG_PM_AUTOSLEEP

commit bd8c9ba3b1e2037af5af4e48aea1087212838179
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jul 17 17:19:25 2017 -0700

    PM / suspend: Export pm_suspend_target_state
    
    Have the core suspend/resume framework store the system-wide suspend
    state (suspend_state_t) we are about to enter, and expose it to drivers
    via pm_suspend_target_state in order to retrieve that. The state is
    assigned in suspend_devices_and_enter().
    
    This is useful for platform specific drivers that may need to take a
    slightly different suspend/resume path based on the system's
    suspend/resume state being entered.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0b1cf32edfd7..2159f6841768 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -427,6 +427,7 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 /* drivers/base/power/wakeup.c */
 extern bool events_check_enabled;
 extern unsigned int pm_wakeup_irq;
+extern suspend_state_t pm_suspend_target_state;
 
 extern bool pm_wakeup_pending(void);
 extern void pm_system_wakeup(void);

commit 33e4f80ee69b5168badf37edbfed796eb48434b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:56:34 2017 +0200

    ACPI / PM: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled.  However, to preserve the existing
    behavior with respect to suspend-to-RAM, this only is done in
    the suspend-to-idle case and only if an SCI has occurred while
    suspended.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d9718378a8be..0b1cf32edfd7 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -189,6 +189,8 @@ struct platform_suspend_ops {
 struct platform_freeze_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
+	void (*wake)(void);
+	void (*sync)(void);
 	void (*restore)(void);
 	void (*end)(void);
 };
@@ -428,7 +430,8 @@ extern unsigned int pm_wakeup_irq;
 
 extern bool pm_wakeup_pending(void);
 extern void pm_system_wakeup(void);
-extern void pm_wakeup_clear(void);
+extern void pm_system_cancel_wakeup(void);
+extern void pm_wakeup_clear(bool reset);
 extern void pm_system_irq_wakeup(unsigned int irq_number);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
@@ -478,7 +481,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 
 static inline bool pm_wakeup_pending(void) { return false; }
 static inline void pm_system_wakeup(void) {}
-static inline void pm_wakeup_clear(void) {}
+static inline void pm_wakeup_clear(bool reset) {}
 static inline void pm_system_irq_wakeup(unsigned int irq_number) {}
 
 static inline void lock_system_sleep(void) {}

commit f3b7eaae1b35eb8077610eb7c7db042c9b0645e1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jun 7 00:57:37 2017 +0200

    Revert "ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle"
    
    Revert commit eed4d47efe95 (ACPI / sleep: Ignore spurious SCI wakeups
    from suspend-to-idle) as it turned out to be premature and triggered
    a number of different issues on various systems.
    
    That includes, but is not limited to, premature suspend-to-RAM aborts
    on Dell XPS 13 (9343) reported by Dominik.
    
    The issue the commit in question attempted to address is real and
    will need to be taken care of going forward, but evidently more work
    is needed for this purpose.
    
    Reported-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0b1cf32edfd7..d9718378a8be 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -189,8 +189,6 @@ struct platform_suspend_ops {
 struct platform_freeze_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
-	void (*wake)(void);
-	void (*sync)(void);
 	void (*restore)(void);
 	void (*end)(void);
 };
@@ -430,8 +428,7 @@ extern unsigned int pm_wakeup_irq;
 
 extern bool pm_wakeup_pending(void);
 extern void pm_system_wakeup(void);
-extern void pm_system_cancel_wakeup(void);
-extern void pm_wakeup_clear(bool reset);
+extern void pm_wakeup_clear(void);
 extern void pm_system_irq_wakeup(unsigned int irq_number);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
@@ -481,7 +478,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 
 static inline bool pm_wakeup_pending(void) { return false; }
 static inline void pm_system_wakeup(void) {}
-static inline void pm_wakeup_clear(bool reset) {}
+static inline void pm_wakeup_clear(void) {}
 static inline void pm_system_irq_wakeup(unsigned int irq_number) {}
 
 static inline void lock_system_sleep(void) {}

commit eed4d47efe9508b855b09754cf6de4325d8a2f0d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 26 23:23:03 2017 +0200

    ACPI / sleep: Ignore spurious SCI wakeups from suspend-to-idle
    
    The ACPI SCI (System Control Interrupt) is set up as a wakeup IRQ
    during suspend-to-idle transitions and, consequently, any events
    signaled through it wake up the system from that state.  However,
    on some systems some of the events signaled via the ACPI SCI while
    suspended to idle should not cause the system to wake up.  In fact,
    quite often they should just be discarded.
    
    Arguably, systems should not resume entirely on such events, but in
    order to decide which events really should cause the system to resume
    and which are spurious, it is necessary to resume up to the point
    when ACPI SCIs are actually handled and processed, which is after
    executing dpm_resume_noirq() in the system resume path.
    
    For this reasons, add a loop around freeze_enter() in which the
    platforms can process events signaled via multiplexed IRQ lines
    like the ACPI SCI and add suspend-to-idle hooks that can be
    used for this purpose to struct platform_freeze_ops.
    
    In the ACPI case, the ->wake hook is used for checking if the SCI
    has triggered while suspended and deferring the interrupt-induced
    system wakeup until the events signaled through it are actually
    processed sufficiently to decide whether or not the system should
    resume.  In turn, the ->sync hook allows all of the relevant event
    queues to be flushed so as to prevent events from being missed due
    to race conditions.
    
    In addition to that, some ACPI code processing wakeup events needs
    to be modified to use the "hard" version of wakeup triggers, so that
    it will cause a system resume to happen on device-induced wakeup
    events even if the "soft" mechanism to prevent the system from
    suspending is not enabled (that also helps to catch device-induced
    wakeup events occurring during suspend transitions in progress).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d9718378a8be..0b1cf32edfd7 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -189,6 +189,8 @@ struct platform_suspend_ops {
 struct platform_freeze_ops {
 	int (*begin)(void);
 	int (*prepare)(void);
+	void (*wake)(void);
+	void (*sync)(void);
 	void (*restore)(void);
 	void (*end)(void);
 };
@@ -428,7 +430,8 @@ extern unsigned int pm_wakeup_irq;
 
 extern bool pm_wakeup_pending(void);
 extern void pm_system_wakeup(void);
-extern void pm_wakeup_clear(void);
+extern void pm_system_cancel_wakeup(void);
+extern void pm_wakeup_clear(bool reset);
 extern void pm_system_irq_wakeup(unsigned int irq_number);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
@@ -478,7 +481,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 
 static inline bool pm_wakeup_pending(void) { return false; }
 static inline void pm_system_wakeup(void) {}
-static inline void pm_wakeup_clear(void) {}
+static inline void pm_wakeup_clear(bool reset) {}
 static inline void pm_system_irq_wakeup(unsigned int irq_number) {}
 
 static inline void lock_system_sleep(void) {}

commit e326ce013a8e851193eb337aafb1aa396c533a61
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 20 03:25:34 2017 +0100

    Revert "PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag"
    
    Revert commit 08b98d329165 (PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0
    flag) as it caused system suspend (in the default configuration) to fail
    on Dell XPS13 (9360) with the Kaby Lake processor.
    
    Fixes: 08b98d329165 (PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag)
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0c729c3c8549..d9718378a8be 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -194,8 +194,6 @@ struct platform_freeze_ops {
 };
 
 #ifdef CONFIG_SUSPEND
-extern suspend_state_t mem_sleep_default;
-
 /**
  * suspend_set_ops - set platform dependent suspend operations
  * @ops: The new suspend operations to set.

commit 08b98d3291652bdcd1029a059e39fbcae5ad93e2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 17 03:28:53 2016 +0100

    PM / sleep / ACPI: Use the ACPI_FADT_LOW_POWER_S0 flag
    
    Modify the ACPI system sleep support setup code to select
    suspend-to-idle as the default system sleep state if the
    ACPI_FADT_LOW_POWER_S0 flag is set in the FADT and the
    default sleep state was not selected from the kernel command
    line.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Mario Limonciello <mario.limonciello@dell.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d9718378a8be..0c729c3c8549 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -194,6 +194,8 @@ struct platform_freeze_ops {
 };
 
 #ifdef CONFIG_SUSPEND
+extern suspend_state_t mem_sleep_default;
+
 /**
  * suspend_set_ops - set platform dependent suspend operations
  * @ops: The new suspend operations to set.

commit fa7fd6fa38e36d88bc9f2d0e45e5b9bd0387079f
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Fri Aug 19 14:41:00 2016 +0100

    PM / sleep: enable suspend-to-idle even without registered suspend_ops
    
    Suspend-to-idle (aka the "freeze" sleep state) is a system sleep state
    in which all of the processors enter deepest possible idle state and
    wait for interrupts right after suspending all the devices.
    
    There is no hard requirement for a platform to support and register
    platform specific suspend_ops to enter suspend-to-idle/freeze state.
    Only deeper system sleep states like PM_SUSPEND_STANDBY and
    PM_SUSPEND_MEM rely on such low level support/implementation.
    
    suspend-to-idle can be entered as along as all the devices can be
    suspended. This patch enables the support for suspend-to-idle even on
    systems that don't have any low level support for deeper system sleep
    states and/or don't register any platform specific suspend_ops.
    
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 7693e39b14fe..d9718378a8be 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -245,6 +245,7 @@ static inline bool idle_should_freeze(void)
 	return unlikely(suspend_freeze_state == FREEZE_STATE_ENTER);
 }
 
+extern void __init pm_states_init(void);
 extern void freeze_set_ops(const struct platform_freeze_ops *ops);
 extern void freeze_wake(void);
 
@@ -279,6 +280,7 @@ static inline bool pm_resume_via_firmware(void) { return false; }
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
 static inline bool idle_should_freeze(void) { return false; }
+static inline void __init pm_states_init(void) {}
 static inline void freeze_set_ops(const struct platform_freeze_ops *ops) {}
 static inline void freeze_wake(void) {}
 #endif /* !CONFIG_SUSPEND */

commit ca5f2b4c4fb7bb7397317ee2ead83485aa295a3e
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Jun 14 16:23:22 2016 +0200

    PM / sleep: Make pm_prepare_console() return void
    
    Nothing is using its return value so change it to return void.
    
    No functionality change.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 8b6ec7ef0854..7693e39b14fe 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -18,12 +18,11 @@ static inline void pm_set_vt_switch(int do_switch)
 #endif
 
 #ifdef CONFIG_VT_CONSOLE_SLEEP
-extern int pm_prepare_console(void);
+extern void pm_prepare_console(void);
 extern void pm_restore_console(void);
 #else
-static inline int pm_prepare_console(void)
+static inline void pm_prepare_console(void)
 {
-	return 0;
 }
 
 static inline void pm_restore_console(void)

commit ef25ba0476015908ef5960f9faac149ddf34ede0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:49:34 2015 +0200

    PM / sleep: Add flags to indicate platform firmware involvement
    
    There are quite a few cases in which device drivers, bus types or
    even the PM core itself may benefit from knowing whether or not
    the platform firmware will be involved in the upcoming system power
    transition (during system suspend) or whether or not it was involved
    in it (during system resume).
    
    For this reason, introduce global system suspend flags that can be
    used by the platform code to expose that information for the benefit
    of the other parts of the kernel and make the ACPI core set them
    as appropriate.
    
    Users of the new flags will be added later.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 33aaf9a9596c..8b6ec7ef0854 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -202,6 +202,36 @@ struct platform_freeze_ops {
 extern void suspend_set_ops(const struct platform_suspend_ops *ops);
 extern int suspend_valid_only_mem(suspend_state_t state);
 
+extern unsigned int pm_suspend_global_flags;
+
+#define PM_SUSPEND_FLAG_FW_SUSPEND	(1 << 0)
+#define PM_SUSPEND_FLAG_FW_RESUME	(1 << 1)
+
+static inline void pm_suspend_clear_flags(void)
+{
+	pm_suspend_global_flags = 0;
+}
+
+static inline void pm_set_suspend_via_firmware(void)
+{
+	pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_SUSPEND;
+}
+
+static inline void pm_set_resume_via_firmware(void)
+{
+	pm_suspend_global_flags |= PM_SUSPEND_FLAG_FW_RESUME;
+}
+
+static inline bool pm_suspend_via_firmware(void)
+{
+	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_SUSPEND);
+}
+
+static inline bool pm_resume_via_firmware(void)
+{
+	return !!(pm_suspend_global_flags & PM_SUSPEND_FLAG_FW_RESUME);
+}
+
 /* Suspend-to-idle state machnine. */
 enum freeze_state {
 	FREEZE_STATE_NONE,      /* Not suspended/suspending. */
@@ -241,6 +271,12 @@ extern int pm_suspend(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 #define suspend_valid_only_mem	NULL
 
+static inline void pm_suspend_clear_flags(void) {}
+static inline void pm_set_suspend_via_firmware(void) {}
+static inline void pm_set_resume_via_firmware(void) {}
+static inline bool pm_suspend_via_firmware(void) { return false; }
+static inline bool pm_resume_via_firmware(void) { return false; }
+
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
 static inline bool idle_should_freeze(void) { return false; }

commit a6f5f0dd4e21191ce35030dd4d6421e1cca10ee4
Author: Alexandra Yates <alexandra.yates@linux.intel.com>
Date:   Tue Sep 15 10:32:46 2015 -0700

    PM / sleep: Report interrupt that caused system wakeup
    
    Add a sysfs attribute, /sys/power/pm_wakeup_irq, reporting the IRQ
    number of the first wakeup interrupt (that is, the first interrupt
    from an IRQ line armed for system wakeup) seen by the kernel during
    the most recent system suspend/resume cycle.
    
    This feature will be useful for system wakeup diagnostics of
    spurious wakeup interrupts.
    
    Signed-off-by: Alexandra Yates <alexandra.yates@linux.intel.com>
    [ rjw: Fixed up pm_wakeup_irq definition ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 5efe743ce1e8..33aaf9a9596c 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -387,10 +387,12 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 
 /* drivers/base/power/wakeup.c */
 extern bool events_check_enabled;
+extern unsigned int pm_wakeup_irq;
 
 extern bool pm_wakeup_pending(void);
 extern void pm_system_wakeup(void);
 extern void pm_wakeup_clear(void);
+extern void pm_system_irq_wakeup(unsigned int irq_number);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
 extern void pm_wakep_autosleep_enabled(bool set);
@@ -440,6 +442,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 static inline bool pm_wakeup_pending(void) { return false; }
 static inline void pm_system_wakeup(void) {}
 static inline void pm_wakeup_clear(void) {}
+static inline void pm_system_irq_wakeup(unsigned int irq_number) {}
 
 static inline void lock_system_sleep(void) {}
 static inline void unlock_system_sleep(void) {}

commit 3810631332465d967ba5e27ea2c7dff2c9afac6c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 12 23:33:15 2015 +0100

    PM / sleep: Re-implement suspend-to-idle handling
    
    In preparation for adding support for quiescing timers in the final
    stage of suspend-to-idle transitions, rework the freeze_enter()
    function making the system wait on a wakeup event, the freeze_wake()
    function terminating the suspend-to-idle loop and the mechanism by
    which deep idle states are entered during suspend-to-idle.
    
    First of all, introduce a simple state machine for suspend-to-idle
    and make the code in question use it.
    
    Second, prevent freeze_enter() from losing wakeup events due to race
    conditions and ensure that the number of online CPUs won't change
    while it is being executed.  In addition to that, make it force
    all of the CPUs re-enter the idle loop in case they are in idle
    states already (so they can enter deeper idle states if possible).
    
    Next, drop cpuidle_use_deepest_state() and replace use_deepest_state
    checks in cpuidle_select() and cpuidle_reflect() with a single
    suspend-to-idle state check in cpuidle_idle_call().
    
    Finally, introduce cpuidle_enter_freeze() that will simply find the
    deepest idle state available to the given CPU and enter it using
    cpuidle_enter().
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 3388c1b6f7d8..5efe743ce1e8 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -201,6 +201,21 @@ struct platform_freeze_ops {
  */
 extern void suspend_set_ops(const struct platform_suspend_ops *ops);
 extern int suspend_valid_only_mem(suspend_state_t state);
+
+/* Suspend-to-idle state machnine. */
+enum freeze_state {
+	FREEZE_STATE_NONE,      /* Not suspended/suspending. */
+	FREEZE_STATE_ENTER,     /* Enter suspend-to-idle. */
+	FREEZE_STATE_WAKE,      /* Wake up from suspend-to-idle. */
+};
+
+extern enum freeze_state __read_mostly suspend_freeze_state;
+
+static inline bool idle_should_freeze(void)
+{
+	return unlikely(suspend_freeze_state == FREEZE_STATE_ENTER);
+}
+
 extern void freeze_set_ops(const struct platform_freeze_ops *ops);
 extern void freeze_wake(void);
 
@@ -228,6 +243,7 @@ extern int pm_suspend(suspend_state_t state);
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+static inline bool idle_should_freeze(void) { return false; }
 static inline void freeze_set_ops(const struct platform_freeze_ops *ops) {}
 static inline void freeze_wake(void) {}
 #endif /* !CONFIG_SUSPEND */

commit a8d46b9e4e487301affe84fa53de40b890898604
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:29:01 2014 +0200

    ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
    
    The ACPI GPE wakeup from suspend-to-idle is currently based on using
    the IRQF_NO_SUSPEND flag for the ACPI SCI, but that is problematic
    for a couple of reasons.  First, in principle the ACPI SCI may be
    shared and IRQF_NO_SUSPEND does not really work well with shared
    interrupts.  Second, it may require the ACPI subsystem to special-case
    the handling of device notifications depending on whether or not
    they are received during suspend-to-idle in some places which would
    lead to fragile code.  Finally, it's better the handle ACPI wakeup
    interrupts consistently with wakeup interrupts from other sources.
    
    For this reason, remove the IRQF_NO_SUSPEND flag from the ACPI SCI
    and use enable_irq_wake()/disable_irq_wake() with it instead, which
    requires two additional platform hooks to be added to struct
    platform_freeze_ops.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 06a9910827c2..3388c1b6f7d8 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -189,6 +189,8 @@ struct platform_suspend_ops {
 
 struct platform_freeze_ops {
 	int (*begin)(void);
+	int (*prepare)(void);
+	void (*restore)(void);
 	void (*end)(void);
 };
 

commit 068765ba7987e73d4381edfe47b70aa121c7155c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 1 13:47:49 2014 +0200

    PM / sleep: Mechanism for aborting system suspends unconditionally
    
    It sometimes may be necessary to abort a system suspend in
    progress or wake up the system from suspend-to-idle even if the
    pm_wakeup_event()/pm_stay_awake() mechanism is not enabled.
    
    For this purpose, introduce a new global variable pm_abort_suspend
    and make pm_wakeup_pending() check its value.  Also add routines
    for manipulating that variable.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 519064e0c943..06a9910827c2 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -371,6 +371,8 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 extern bool events_check_enabled;
 
 extern bool pm_wakeup_pending(void);
+extern void pm_system_wakeup(void);
+extern void pm_wakeup_clear(void);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
 extern void pm_wakep_autosleep_enabled(bool set);
@@ -418,6 +420,8 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 
 static inline bool pm_wakeup_pending(void) { return false; }
+static inline void pm_system_wakeup(void) {}
+static inline void pm_wakeup_clear(void) {}
 
 static inline void lock_system_sleep(void) {}
 static inline void unlock_system_sleep(void) {}

commit a6e15a39048ec3229b9a53425f4384f55f6cc1b3
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Jun 13 13:30:35 2014 -0700

    PM / hibernate: introduce "nohibernate" boot parameter
    
    To support using kernel features that are not compatible with hibernation,
    this creates the "nohibernate" kernel boot parameter to disable both
    hibernation and resume. This allows hibernation support to be a boot-time
    choice instead of only a compile-time choice.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index f76994b9396c..519064e0c943 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -327,6 +327,7 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 extern bool system_entering_hibernation(void);
+extern bool hibernation_available(void);
 asmlinkage int swsusp_save(void);
 extern struct pbe *restore_pblist;
 #else /* CONFIG_HIBERNATION */
@@ -339,6 +340,7 @@ static inline void swsusp_unset_page_free(struct page *p) {}
 static inline void hibernation_set_ops(const struct platform_hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
 static inline bool system_entering_hibernation(void) { return false; }
+static inline bool hibernation_available(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
 /* Hibernation and suspend events */

commit eb3d3ec567e868c8a3bfbfdfc9465ffd52983d11
Merge: c3c55a072039 bd63ce27d9d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 5 15:57:04 2014 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm into next
    
    Pull ARM updates from Russell King:
    
     - Major clean-up of the L2 cache support code.  The existing mess was
       becoming rather unmaintainable through all the additions that others
       have done over time.  This turns it into a much nicer structure, and
       implements a few performance improvements as well.
    
     - Clean up some of the CP15 control register tweaks for alignment
       support, moving some code and data into alignment.c
    
     - DMA properties for ARM, from Santosh and reviewed by DT people.  This
       adds DT properties to specify bus translations we can't discover
       automatically, and to indicate whether devices are coherent.
    
     - Hibernation support for ARM
    
     - Make ftrace work with read-only text in modules
    
     - add suspend support for PJ4B CPUs
    
     - rework interrupt masking for undefined instruction handling, which
       allows us to enable interrupts earlier in the handling of these
       exceptions.
    
     - support for big endian page tables
    
     - fix stacktrace support to exclude stacktrace functions from the
       trace, and add save_stack_trace_regs() implementation so that kprobes
       can record stack traces.
    
     - Add support for the Cortex-A17 CPU.
    
     - Remove last vestiges of ARM710 support.
    
     - Removal of ARM "meminfo" structure, finally converting us solely to
       memblock to handle the early memory initialisation.
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (142 commits)
      ARM: ensure C page table setup code follows assembly code (part II)
      ARM: ensure C page table setup code follows assembly code
      ARM: consolidate last remaining open-coded alignment trap enable
      ARM: remove global cr_no_alignment
      ARM: remove CPU_CP15 conditional from alignment.c
      ARM: remove unused adjust_cr() function
      ARM: move "noalign" command line option to alignment.c
      ARM: provide common method to clear bits in CPU control register
      ARM: 8025/1: Get rid of meminfo
      ARM: 8060/1: mm: allow sub-architectures to override PCI I/O memory type
      ARM: 8066/1: correction for ARM patch 8031/2
      ARM: 8049/1: ftrace/add save_stack_trace_regs() implementation
      ARM: 8065/1: remove last use of CONFIG_CPU_ARM710
      ARM: 8062/1: Modify ldrt fixup handler to re-execute the userspace instruction
      ARM: 8047/1: rwsem: use asm-generic rwsem implementation
      ARM: l2c: trial at enabling some Cortex-A9 optimisations
      ARM: l2c: add warnings for stuff modifying aux_ctrl register values
      ARM: l2c: print a warning with L2C-310 caches if the cache size is modified
      ARM: l2c: remove old .set_debug method
      ARM: l2c: kill L2X0_AUX_CTRL_MASK before anyone else makes use of this
      ...

commit 1f0b63866fc1be700260547be8edf8e6f0af37f2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 15 23:29:57 2014 +0200

    ACPI / PM: Hold ACPI scan lock over the "freeze" sleep state
    
    The "freeze" sleep state suffers from the same issue that was
    addressed by commit ad07277e82de (ACPI / PM: Hold acpi_scan_lock over
    system PM transitions) for ACPI sleep states, that is, things break
    if ->remove() is called for devices whose system resume callbacks
    haven't been executed yet.
    
    It also can be addressed in the same way, by holding the ACPI scan
    lock over the "freeze" sleep state and PM transitions to and from
    that state, but ->begin() and ->end() platform operations for the
    "freeze" sleep state are needed for this purpose.
    
    This change has been tested on Acer Aspire S5 with Thunderbolt.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index f73cabf59012..91d66fd8dce1 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -187,6 +187,11 @@ struct platform_suspend_ops {
 	void (*recover)(void);
 };
 
+struct platform_freeze_ops {
+	int (*begin)(void);
+	void (*end)(void);
+};
+
 #ifdef CONFIG_SUSPEND
 /**
  * suspend_set_ops - set platform dependent suspend operations
@@ -194,6 +199,7 @@ struct platform_suspend_ops {
  */
 extern void suspend_set_ops(const struct platform_suspend_ops *ops);
 extern int suspend_valid_only_mem(suspend_state_t state);
+extern void freeze_set_ops(const struct platform_freeze_ops *ops);
 extern void freeze_wake(void);
 
 /**
@@ -220,6 +226,7 @@ extern int pm_suspend(suspend_state_t state);
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+static inline void freeze_set_ops(const struct platform_freeze_ops *ops) {}
 static inline void freeze_wake(void) {}
 #endif /* !CONFIG_SUSPEND */
 

commit 603fb42a66499ab353466c7afa3d38beea20a8a9
Author: Sebastian Capella <sebastian.capella@linaro.org>
Date:   Tue Mar 25 01:20:29 2014 +0100

    ARM: 8011/1: ARM hibernation / suspend-to-disk
    
    Enable hibernation for ARM architectures and provide ARM
    architecture specific calls used during hibernation.
    
    The swsusp hibernation framework depends on the
    platform first having functional suspend/resume.
    
    Then, in order to enable hibernation on a given platform, a
    platform_hibernation_ops structure may need to be registered with
    the system in order to save/restore any SoC-specific / cpu specific
    state needing (re)init over a suspend-to-disk/resume-from-disk cycle.
    
    For example:
    
         - "secure" SoCs that have different sets of control registers
           and/or different CR reg access patterns.
    
         - SoCs with L2 caches as the activation sequence there is
           SoC-dependent; a full off-on cycle for L2 is not done
           by the hibernation support code.
    
         - SoCs requiring steps on wakeup _before_ the "generic" parts
           done by cpu_suspend / cpu_resume can work correctly.
    
         - SoCs having persistent state which is maintained during suspend
           and resume, but will be lost during the power off cycle after
           suspend-to-disk.
    
    This is a rebase/rework of Frank Hofmann's v5 hibernation patchset.
    
    Acked-by: Russ Dill <Russ.Dill@ti.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Sebastian Capella <sebastian.capella@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [fixed duplicate virt_to_pfn() definition --rmk]
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index f73cabf59012..38bbf95109da 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -320,6 +320,8 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 extern bool system_entering_hibernation(void);
+asmlinkage int swsusp_save(void);
+extern struct pbe *restore_pblist;
 #else /* CONFIG_HIBERNATION */
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
 static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}

commit bb177fedd348c92c2bea6adc9a2163ebff15272e
Author: Julius Werner <jwerner@chromium.org>
Date:   Wed Jun 12 12:55:22 2013 -0700

    PM / Sleep: Print last wakeup source on failed wakeup_count write
    
    Commit a938da06 introduced a useful little log message to tell
    users/debuggers which wakeup source aborted a suspend.  However,
    this message is only printed if the abort happens during the
    in-kernel suspend path (after writing /sys/power/state).
    
    The full specification of the /sys/power/wakeup_count facility
    allows user-space power managers to double-check if wakeups have
    already happened before it actually tries to suspend (e.g. while it
    was running user-space pre-suspend hooks), by writing the last known
    wakeup_count value to /sys/power/wakeup_count.  This patch changes
    the sysfs handler for that node to also print said log message if
    that write fails, so that we can figure out the offending wakeup
    source for both kinds of suspend aborts.
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d4e3f16d5e89..f73cabf59012 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -363,6 +363,7 @@ extern bool pm_wakeup_pending(void);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
 extern void pm_wakep_autosleep_enabled(bool set);
+extern void pm_print_active_wakeup_sources(void);
 
 static inline void lock_system_sleep(void)
 {

commit 7e73c5ae6e7991a6c01f6d096ff8afaef4458c36
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Wed Feb 6 13:00:36 2013 +0100

    PM: Introduce suspend state PM_SUSPEND_FREEZE
    
    PM_SUSPEND_FREEZE state is a general state that
    does not need any platform specific support, it equals
    frozen processes + suspended devices + idle processors.
    
    Compared with PM_SUSPEND_MEMORY,
    PM_SUSPEND_FREEZE saves less power
    because the system is still in a running state.
    PM_SUSPEND_FREEZE has less resume latency because it does not
    touch BIOS, and the processors are in idle state.
    
    Compared with RTPM/idle,
    PM_SUSPEND_FREEZE saves more power as
    1. the processor has longer sleep time because processes are frozen.
       The deeper c-state the processor supports, more power saving we can get.
    2. PM_SUSPEND_FREEZE uses system suspend code path, thus we can get
       more power saving from the devices that does not have good RTPM support.
    
    This state is useful for
    1) platforms that do not have STR, or have a broken STR.
    2) platforms that have an extremely low power idle state,
       which can be used to replace STR.
    
    The following describes how PM_SUSPEND_FREEZE state works.
    1. echo freeze > /sys/power/state
    2. the processes are frozen.
    3. all the devices are suspended.
    4. all the processors are blocked by a wait queue
    5. all the processors idles and enters (Deep) c-state.
    6. an interrupt fires.
    7. a processor is woken up and handles the irq.
    8. if it is a general event,
       a) the irq handler runs and quites.
       b) goto step 4.
    9. if it is a real wake event, say, power button pressing, keyboard touch, mouse moving,
       a) the irq handler runs and activate the wakeup source
       b) wakeup_source_activate() notifies the wait queue.
       c) system starts resuming from PM_SUSPEND_FREEZE
    10. all the devices are resumed.
    11. all the processes are unfrozen.
    12. system is back to working.
    
    Known Issue:
    The wakeup of this new PM_SUSPEND_FREEZE state may behave differently
    from the previous suspend state.
    Take ACPI platform for example, there are some GPEs that only enabled
    when the system is in sleep state, to wake the system backk from S3/S4.
    But we are not touching these GPEs during transition to PM_SUSPEND_FREEZE.
    This means we may lose some wake event.
    But on the other hand, as we do not disable all the Interrupts during
    PM_SUSPEND_FREEZE, we may get some extra "wakeup" Interrupts, that are
    not available for S3/S4.
    
    The patches has been tested on an old Sony laptop, and here are the results:
    
    Average Power:
    1. RPTM/idle for half an hour:
       14.8W, 12.6W, 14.1W, 12.5W, 14.4W, 13.2W, 12.9W
    2. Freeze for half an hour:
       11W, 10.4W, 9.4W, 11.3W 10.5W
    3. RTPM/idle for three hours:
       11.6W
    4. Freeze for three hours:
       10W
    5. Suspend to Memory:
       0.5~0.9W
    
    Average Resume Latency:
    1. RTPM/idle with a black screen: (From pressing keyboard to screen back)
       Less than 0.2s
    2. Freeze: (From pressing power button to screen back)
       2.50s
    3. Suspend to Memory: (From pressing power button to screen back)
       4.33s
    
    >From the results, we can see that all the platforms should benefit from
    this patch, even if it does not have Low Power S0.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0c808d7fa579..d4e3f16d5e89 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -34,8 +34,10 @@ static inline void pm_restore_console(void)
 typedef int __bitwise suspend_state_t;
 
 #define PM_SUSPEND_ON		((__force suspend_state_t) 0)
-#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
+#define PM_SUSPEND_FREEZE	((__force suspend_state_t) 1)
+#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 2)
 #define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
+#define PM_SUSPEND_MIN		PM_SUSPEND_FREEZE
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
 enum suspend_stat_step {
@@ -192,6 +194,7 @@ struct platform_suspend_ops {
  */
 extern void suspend_set_ops(const struct platform_suspend_ops *ops);
 extern int suspend_valid_only_mem(suspend_state_t state);
+extern void freeze_wake(void);
 
 /**
  * arch_suspend_disable_irqs - disable IRQs for suspend
@@ -217,6 +220,7 @@ extern int pm_suspend(suspend_state_t state);
 
 static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+static inline void freeze_wake(void) {}
 #endif /* !CONFIG_SUSPEND */
 
 /* struct pbe is used for creating lists of pages that should be restored

commit b2df1d4f8b95d9d1e3f064cef02fc5c5116b05cf
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 21 00:19:33 2012 +0200

    PM / Sleep: Separate printing suspend times from initcall_debug
    
    Change the behavior of the newly introduced
    /sys/power/pm_print_times attribute so that its initial value
    depends on initcall_debug, but setting it to 0 will cause device
    suspend/resume times not to be printed, even if initcall_debug has
    been set.  This way, the people who use initcall_debug for reasons
    other than PM debugging will be able to switch the suspend/resume
    times printing off, if need be.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index cd83059fb592..0c808d7fa579 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -408,6 +408,12 @@ static inline void unlock_system_sleep(void) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_SLEEP_DEBUG
+extern bool pm_print_times_enabled;
+#else
+#define pm_print_times_enabled	(false)
+#endif
+
 #ifdef CONFIG_PM_AUTOSLEEP
 
 /* kernel/power/autosleep.c */

commit 55850945e872531644f31fefd217d61dd15dcab8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:32 2012 +0200

    PM / Sleep: Add "prevent autosleep time" statistics to wakeup sources
    
    Android uses one wakelock statistics that is only necessary for
    opportunistic sleep.  Namely, the prevent_suspend_time field
    accumulates the total time the given wakelock has been locked
    while "automatic suspend" was enabled.  Add an analogous field,
    prevent_sleep_time, to wakeup sources and make it behave in a similar
    way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 76b7ec7d3a81..cd83059fb592 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -358,6 +358,7 @@ extern bool events_check_enabled;
 extern bool pm_wakeup_pending(void);
 extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
+extern void pm_wakep_autosleep_enabled(bool set);
 
 static inline void lock_system_sleep(void)
 {

commit 7483b4a4d9abf9dcf1ffe6e805ead2847ec3264e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:53:22 2012 +0200

    PM / Sleep: Implement opportunistic sleep, v2
    
    Introduce a mechanism by which the kernel can trigger global
    transitions to a sleep state chosen by user space if there are no
    active wakeup sources.
    
    It consists of a new sysfs attribute, /sys/power/autosleep, that
    can be written one of the strings returned by reads from
    /sys/power/state, an ordered workqueue and a work item carrying out
    the "suspend" operations.  If a string representing the system's
    sleep state is written to /sys/power/autosleep, the work item
    triggering transitions to that state is queued up and it requeues
    itself after every execution until user space writes "off" to
    /sys/power/autosleep.
    
    That work item enables the detection of wakeup events using the
    functions already defined in drivers/base/power/wakeup.c (with one
    small modification) and calls either pm_suspend(), or hibernate() to
    put the system into a sleep state.  If a wakeup event is reported
    while the transition is in progress, it will abort the transition and
    the "system suspend" work item will be queued up again.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: NeilBrown <neilb@suse.de>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ac1c114c499d..76b7ec7d3a81 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -356,7 +356,7 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 extern bool events_check_enabled;
 
 extern bool pm_wakeup_pending(void);
-extern bool pm_get_wakeup_count(unsigned int *count);
+extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
 
 static inline void lock_system_sleep(void)
@@ -407,6 +407,17 @@ static inline void unlock_system_sleep(void) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_AUTOSLEEP
+
+/* kernel/power/autosleep.c */
+void queue_up_suspend_work(void);
+
+#else /* !CONFIG_PM_AUTOSLEEP */
+
+static inline void queue_up_suspend_work(void) {}
+
+#endif /* !CONFIG_PM_AUTOSLEEP */
+
 #ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
 /*
  * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture

commit bc25cf508942c56810d4fb623ef27b56ccef7783
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:33 2012 +0100

    PM / Sleep: Drop suspend_stats_update()
    
    Since suspend_stats_update() is only called from pm_suspend(),
    move its code directly into that function and remove the static
    inline definition from include/linux/suspend.h.  Clean_up
    pm_suspend() in the process.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index b90191894441..ac1c114c499d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -94,22 +94,6 @@ static inline void dpm_save_failed_step(enum suspend_stat_step step)
 	suspend_stats.last_failed_step %= REC_FAILED_NUM;
 }
 
-/**
- * suspend_stats_update - Update success/failure statistics of suspend-to-ram
- *
- * @error: Value returned by enter_state() function
- */
-static inline void suspend_stats_update(int error)
-{
-	if (error) {
-		suspend_stats.fail++;
-		dpm_save_failed_errno(error);
-	} else {
-		suspend_stats.success++;
-	}
-}
-
-
 /**
  * struct platform_suspend_ops - Callbacks for managing platform dependent
  *	system sleep states.

commit 8916e3702ec422b57cc549fbae3986106292100f
Author: Marcos Paulo de Souza <marcos.mage@gmail.com>
Date:   Sat Feb 4 22:26:13 2012 +0100

    PM / Suspend: Avoid code duplication in suspend statistics update
    
    The code
           if (error) {
                   suspend_stats.fail++;
                   dpm_save_failed_errno(error);
           } else
                   suspend_stats.success++;
    
    Appears in the kernel/power/main.c and kernel/power/suspend.c.
    
    This patch just creates a new function to avoid duplicated code.
    
    Suggested-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Marcos Paulo de Souza <marcos.mage@gmail.com>
    Acked-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ac1c114c499d..b90191894441 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -94,6 +94,22 @@ static inline void dpm_save_failed_step(enum suspend_stat_step step)
 	suspend_stats.last_failed_step %= REC_FAILED_NUM;
 }
 
+/**
+ * suspend_stats_update - Update success/failure statistics of suspend-to-ram
+ *
+ * @error: Value returned by enter_state() function
+ */
+static inline void suspend_stats_update(int error)
+{
+	if (error) {
+		suspend_stats.fail++;
+		dpm_save_failed_errno(error);
+	} else {
+		suspend_stats.success++;
+	}
+}
+
+
 /**
  * struct platform_suspend_ops - Callbacks for managing platform dependent
  *	system sleep states.

commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:38:29 2012 +0100

    PM / Sleep: Introduce "late suspend" and "early resume" of devices
    
    The current device suspend/resume phases during system-wide power
    transitions appear to be insufficient for some platforms that want
    to use the same callback routines for saving device states and
    related operations during runtime suspend/resume as well as during
    system suspend/resume.  In principle, they could point their
    .suspend_noirq() and .resume_noirq() to the same callback routines
    as their .runtime_suspend() and .runtime_resume(), respectively,
    but at least some of them require device interrupts to be enabled
    while the code in those routines is running.
    
    It also makes sense to have device suspend-resume callbacks that will
    be executed with runtime PM disabled and with device interrupts
    enabled in case someone needs to run some special code in that
    context during system-wide power transitions.
    
    Apart from this, .suspend_noirq() and .resume_noirq() were introduced
    as a workaround for drivers using shared interrupts and failing to
    prevent their interrupt handlers from accessing suspended hardware.
    It appears to be better not to use them for other porposes, or we may
    have to deal with some serious confusion (which seems to be happening
    already).
    
    For the above reasons, introduce new device suspend/resume phases,
    "late suspend" and "early resume" (and analogously for hibernation)
    whose callback will be executed with runtime PM disabled and with
    device interrupts enabled and whose callback pointers generally may
    point to runtime suspend/resume routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 91784a4f8608..ac1c114c499d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -42,8 +42,10 @@ enum suspend_stat_step {
 	SUSPEND_FREEZE = 1,
 	SUSPEND_PREPARE,
 	SUSPEND_SUSPEND,
+	SUSPEND_SUSPEND_LATE,
 	SUSPEND_SUSPEND_NOIRQ,
 	SUSPEND_RESUME_NOIRQ,
+	SUSPEND_RESUME_EARLY,
 	SUSPEND_RESUME
 };
 
@@ -53,8 +55,10 @@ struct suspend_stats {
 	int	failed_freeze;
 	int	failed_prepare;
 	int	failed_suspend;
+	int	failed_suspend_late;
 	int	failed_suspend_noirq;
 	int	failed_resume;
+	int	failed_resume_early;
 	int	failed_resume_noirq;
 #define	REC_FAILED_NUM	2
 	int	last_failed_dev;

commit 72081624d5ad3cf56deb6e727b78c4e7a55e4eec
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Thu Jan 19 23:25:33 2012 +0100

    PM / Hibernate: Rewrite unlock_system_sleep() to fix s2disk regression
    
    Commit 33e638b, "PM / Sleep: Use the freezer_count() functions in
    [un]lock_system_sleep() APIs" introduced an undesirable change in the
    behaviour of unlock_system_sleep() since freezer_count() internally calls
    try_to_freeze() - which we don't need in unlock_system_sleep().
    
    And commit bcda53f, "PM / Sleep: Replace mutex_[un]lock(&pm_mutex) with
    [un]lock_system_sleep()" made these APIs wide-spread. This caused a
    regression in suspend-to-disk where snapshot_read() and snapshot_write()
    were getting frozen due to the try_to_freeze embedded in
    unlock_system_sleep(), since these functions were invoked when the freezing
    condition was still in effect.
    
    Fix this by rewriting unlock_system_sleep() by open-coding freezer_count()
    and dropping the try_to_freeze() part. Not only will this fix the
    regression but this will also ensure that the API only does what it is
    intended to do, and nothing more, under the hood.
    
    While at it, make the code more correct and robust by ensuring that the
    PF_FREEZER_SKIP flag gets cleared with pm_mutex held, to avoid a race with
    the freezer.
    
    Also, to be on the safer side, open-code freezer_do_not_count() as well
    (inside lock_system_sleep()), to ensure that any unrelated modification to
    freezer[_do_not]_count() does not break things again!
    
    Reported-and-tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 95040cc33107..91784a4f8608 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -357,14 +357,29 @@ extern bool pm_save_wakeup_count(unsigned int count);
 
 static inline void lock_system_sleep(void)
 {
-	freezer_do_not_count();
+	current->flags |= PF_FREEZER_SKIP;
 	mutex_lock(&pm_mutex);
 }
 
 static inline void unlock_system_sleep(void)
 {
+	/*
+	 * Don't use freezer_count() because we don't want the call to
+	 * try_to_freeze() here.
+	 *
+	 * Reason:
+	 * Fundamentally, we just don't need it, because freezing condition
+	 * doesn't come into effect until we release the pm_mutex lock,
+	 * since the freezer always works with pm_mutex held.
+	 *
+	 * More importantly, in the case of hibernation,
+	 * unlock_system_sleep() gets called in snapshot_read() and
+	 * snapshot_write() when the freezing condition is still in effect.
+	 * Which means, if we use try_to_freeze() here, it would make them
+	 * enter the refrigerator, thus causing hibernation to lockup.
+	 */
+	current->flags &= ~PF_FREEZER_SKIP;
 	mutex_unlock(&pm_mutex);
-	freezer_count();
 }
 
 #else /* !CONFIG_PM_SLEEP */

commit 9b6fc5dc879bc90f765db0e95eefcf123d0d06dd
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Tue Dec 6 23:24:38 2011 +0100

    PM / Sleep: Make [un]lock_system_sleep() generic
    
    The [un]lock_system_sleep() APIs were originally introduced to mutually
    exclude memory hotplug and hibernation.
    
    Directly using mutex_lock(&pm_mutex) to achieve mutual exclusion with
    suspend or hibernation code can lead to freezing failures. However, the
    APIs [un]lock_system_sleep() can be safely used to achieve the same,
    without causing freezing failures.
    
    So, since it would be beneficial to modify all the existing users of
    mutex_lock(&pm_mutex) (in all parts of the kernel), so that they use these
    safe APIs intead, make these APIs generic by removing the restriction that
    they work only when CONFIG_HIBERNATE_CALLBACKS is set. Moreover, that
    restriction didn't buy us anything anyway.
    
    Suggested-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 906d62cfc15c..95040cc33107 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -332,6 +332,8 @@ static inline bool system_entering_hibernation(void) { return false; }
 #define PM_RESTORE_PREPARE	0x0005 /* Going to restore a saved image */
 #define PM_POST_RESTORE		0x0006 /* Restore failed */
 
+extern struct mutex pm_mutex;
+
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
 void restore_processor_state(void);
@@ -352,6 +354,19 @@ extern bool events_check_enabled;
 extern bool pm_wakeup_pending(void);
 extern bool pm_get_wakeup_count(unsigned int *count);
 extern bool pm_save_wakeup_count(unsigned int count);
+
+static inline void lock_system_sleep(void)
+{
+	freezer_do_not_count();
+	mutex_lock(&pm_mutex);
+}
+
+static inline void unlock_system_sleep(void)
+{
+	mutex_unlock(&pm_mutex);
+	freezer_count();
+}
+
 #else /* !CONFIG_PM_SLEEP */
 
 static inline int register_pm_notifier(struct notifier_block *nb)
@@ -367,30 +382,11 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 
 static inline bool pm_wakeup_pending(void) { return false; }
-#endif /* !CONFIG_PM_SLEEP */
-
-extern struct mutex pm_mutex;
 
-#ifndef CONFIG_HIBERNATE_CALLBACKS
 static inline void lock_system_sleep(void) {}
 static inline void unlock_system_sleep(void) {}
 
-#else
-
-/* Let some subsystems like memory hotadd exclude hibernation */
-
-static inline void lock_system_sleep(void)
-{
-	freezer_do_not_count();
-	mutex_lock(&pm_mutex);
-}
-
-static inline void unlock_system_sleep(void)
-{
-	mutex_unlock(&pm_mutex);
-	freezer_count();
-}
-#endif
+#endif /* !CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
 /*

commit 33e638b9070ba5e8812836e20390da6a6af13900
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Tue Dec 6 23:18:12 2011 +0100

    PM / Sleep: Use the freezer_count() functions in [un]lock_system_sleep() APIs
    
    Now that freezer_count() and freezer_do_not_count() don't have the restriction
    that they are effective only when called by userspace processes, use
    them in lock_system_sleep() and unlock_system_sleep() instead of open-coding
    their parts.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 1f7fff47cfac..906d62cfc15c 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -6,6 +6,7 @@
 #include <linux/init.h>
 #include <linux/pm.h>
 #include <linux/mm.h>
+#include <linux/freezer.h>
 #include <asm/errno.h>
 
 #ifdef CONFIG_VT
@@ -380,16 +381,14 @@ static inline void unlock_system_sleep(void) {}
 
 static inline void lock_system_sleep(void)
 {
-	/* simplified freezer_do_not_count() */
-	current->flags |= PF_FREEZER_SKIP;
+	freezer_do_not_count();
 	mutex_lock(&pm_mutex);
 }
 
 static inline void unlock_system_sleep(void)
 {
 	mutex_unlock(&pm_mutex);
-	/* simplified freezer_count() */
-	current->flags &= ~PF_FREEZER_SKIP;
+	freezer_count();
 }
 #endif
 

commit 6a76b7a9cc93dec6ae58d70f1257d234291908e0
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Mon Nov 21 23:32:35 2011 +0100

    PM / Memory-hotplug: Avoid task freezing failures
    
    The lock_system_sleep() function is used in the memory hotplug code at
    several places in order to implement mutual exclusion with hibernation.
    However, this function tries to acquire the 'pm_mutex' lock using
    mutex_lock() and hence blocks in TASK_UNINTERRUPTIBLE state if it doesn't
    get the lock. This would lead to task freezing failures and hence
    hibernation failure as a consequence, even though the hibernation call path
    successfully acquired the lock.
    
    But it is to be noted that, since this task tries to acquire pm_mutex, if it
    blocks due to this, we are *100% sure* that this task is not going to run
    as long as hibernation sequence is in progress, since hibernation releases
    'pm_mutex' only at the very end, when everything is done.
    And this means, this task is going to be anyway blocked for much more longer
    than what the freezer intends to achieve; which means, freezing and thawing
    doesn't really make any difference to this task!
    
    So, to fix freezing failures, we just ask the freezer to skip freezing this
    task, since it is already "frozen enough".
    
    But instead of calling freezer_do_not_count() and freezer_count() as it is,
    we use only the relevant parts of those functions, because restrictions
    such as 'the task should be a userspace one' etc., might not be relevant in
    this scenario.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 57a692432f8a..1f7fff47cfac 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -380,12 +380,16 @@ static inline void unlock_system_sleep(void) {}
 
 static inline void lock_system_sleep(void)
 {
+	/* simplified freezer_do_not_count() */
+	current->flags |= PF_FREEZER_SKIP;
 	mutex_lock(&pm_mutex);
 }
 
 static inline void unlock_system_sleep(void)
 {
 	mutex_unlock(&pm_mutex);
+	/* simplified freezer_count() */
+	current->flags &= ~PF_FREEZER_SKIP;
 }
 #endif
 

commit 37cce26b32142f09a8967f6d238178af654b20de
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Wed Sep 21 22:47:55 2011 +0200

    PM / VT: Cleanup #if defined uglyness and fix compile error
    
    Introduce the config option CONFIG_VT_CONSOLE_SLEEP in order to cleanup
    the #if defined ugliness for the vt suspend support functions. Note that
    CONFIG_VT_CONSOLE is already dependant on CONFIG_VT.
    
    The function pm_set_vt_switch is actually dependant on CONFIG_VT and not
    CONFIG_PM_SLEEP. This fixes a compile error when CONFIG_PM_SLEEP is
    not set:
    
    drivers/tty/vt/vt_ioctl.c:1794: error: redefinition of 'pm_set_vt_switch'
    include/linux/suspend.h:17: error: previous definition of 'pm_set_vt_switch' was here
    
    Also, remove the incorrect path from the comment in console.c.
    
    [rjw: Replaced #if defined() with #ifdef in suspend.h.]
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 46f3548aef2d..57a692432f8a 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -8,15 +8,18 @@
 #include <linux/mm.h>
 #include <asm/errno.h>
 
-#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#ifdef CONFIG_VT
 extern void pm_set_vt_switch(int);
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
 #else
 static inline void pm_set_vt_switch(int do_switch)
 {
 }
+#endif
 
+#ifdef CONFIG_VT_CONSOLE_SLEEP
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+#else
 static inline int pm_prepare_console(void)
 {
 	return 0;

commit 85055dd805f0822f13f736bee2a521e222c38293
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Wed Aug 17 20:42:24 2011 +0200

    PM / Hibernate: Include storage keys in hibernation image on s390
    
    For s390 there is one additional byte associated with each page,
    the storage key. This byte contains the referenced and changed
    bits and needs to be included into the hibernation image.
    If the storage keys are not restored to their previous state all
    original pages would appear to be dirty. This can cause
    inconsistencies e.g. with read-only filesystems.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 76f42e49b72d..46f3548aef2d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -386,4 +386,38 @@ static inline void unlock_system_sleep(void)
 }
 #endif
 
+#ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
+/*
+ * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture
+ * to save/restore additional information to/from the array of page
+ * frame numbers in the hibernation image. For s390 this is used to
+ * save and restore the storage key for each page that is included
+ * in the hibernation image.
+ */
+unsigned long page_key_additional_pages(unsigned long pages);
+int page_key_alloc(unsigned long pages);
+void page_key_free(void);
+void page_key_read(unsigned long *pfn);
+void page_key_memorize(unsigned long *pfn);
+void page_key_write(void *address);
+
+#else /* !CONFIG_ARCH_SAVE_PAGE_KEYS */
+
+static inline unsigned long page_key_additional_pages(unsigned long pages)
+{
+	return 0;
+}
+
+static inline int  page_key_alloc(unsigned long pages)
+{
+	return 0;
+}
+
+static inline void page_key_free(void) {}
+static inline void page_key_read(unsigned long *pfn) {}
+static inline void page_key_memorize(unsigned long *pfn) {}
+static inline void page_key_write(void *address) {}
+
+#endif /* !CONFIG_ARCH_SAVE_PAGE_KEYS */
+
 #endif /* _LINUX_SUSPEND_H */

commit 2a77c46de1e3dace73745015635ebbc648eca69c
Author: ShuoX Liu <shuox.liu@intel.com>
Date:   Wed Aug 10 23:01:26 2011 +0200

    PM / Suspend: Add statistics debugfs file for suspend to RAM
    
    Record S3 failure time about each reason and the latest two failed
    devices' names in S3 progress.
    We can check it through 'suspend_stats' entry in debugfs.
    
    The motivation of the patch:
    
    We are enabling power features on Medfield. Comparing with PC/notebook,
    a mobile enters/exits suspend-2-ram (we call it s3 on Medfield) far
    more frequently. If it can't enter suspend-2-ram in time, the power
    might be used up soon.
    
    We often find sometimes, a device suspend fails. Then, system retries
    s3 over and over again. As display is off, testers and developers
    don't know what happens.
    
    Some testers and developers complain they don't know if system
    tries suspend-2-ram, and what device fails to suspend. They need
    such info for a quick check. The patch adds suspend_stats under
    debugfs for users to check suspend to RAM statistics quickly.
    
    If not using this patch, we have other methods to get info about
    what device fails. One is to turn on  CONFIG_PM_DEBUG, but users
    would get too much info and testers need recompile the system.
    
    In addition, dynamic debug is another good tool to dump debug info.
    But it still doesn't match our utilization scenario closely.
    1) user need write a user space parser to process the syslog output;
    2) Our testing scenario is we leave the mobile for at least hours.
       Then, check its status. No serial console available during the
       testing. One is because console would be suspended, and the other
       is serial console connecting with spi or HSU devices would consume
       power. These devices are powered off at suspend-2-ram.
    
    Signed-off-by: ShuoX Liu <shuox.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 6bbcef22e105..76f42e49b72d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -34,6 +34,58 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
+enum suspend_stat_step {
+	SUSPEND_FREEZE = 1,
+	SUSPEND_PREPARE,
+	SUSPEND_SUSPEND,
+	SUSPEND_SUSPEND_NOIRQ,
+	SUSPEND_RESUME_NOIRQ,
+	SUSPEND_RESUME
+};
+
+struct suspend_stats {
+	int	success;
+	int	fail;
+	int	failed_freeze;
+	int	failed_prepare;
+	int	failed_suspend;
+	int	failed_suspend_noirq;
+	int	failed_resume;
+	int	failed_resume_noirq;
+#define	REC_FAILED_NUM	2
+	int	last_failed_dev;
+	char	failed_devs[REC_FAILED_NUM][40];
+	int	last_failed_errno;
+	int	errno[REC_FAILED_NUM];
+	int	last_failed_step;
+	enum suspend_stat_step	failed_steps[REC_FAILED_NUM];
+};
+
+extern struct suspend_stats suspend_stats;
+
+static inline void dpm_save_failed_dev(const char *name)
+{
+	strlcpy(suspend_stats.failed_devs[suspend_stats.last_failed_dev],
+		name,
+		sizeof(suspend_stats.failed_devs[0]));
+	suspend_stats.last_failed_dev++;
+	suspend_stats.last_failed_dev %= REC_FAILED_NUM;
+}
+
+static inline void dpm_save_failed_errno(int err)
+{
+	suspend_stats.errno[suspend_stats.last_failed_errno] = err;
+	suspend_stats.last_failed_errno++;
+	suspend_stats.last_failed_errno %= REC_FAILED_NUM;
+}
+
+static inline void dpm_save_failed_step(enum suspend_stat_step step)
+{
+	suspend_stats.failed_steps[suspend_stats.last_failed_step] = step;
+	suspend_stats.last_failed_step++;
+	suspend_stats.last_failed_step %= REC_FAILED_NUM;
+}
+
 /**
  * struct platform_suspend_ops - Callbacks for managing platform dependent
  *	system sleep states.

commit 35eb6db11ed9cbf9702ec90a28779a51fe4a21a9
Author: Amerigo Wang <amwang@redhat.com>
Date:   Mon Jul 25 17:13:11 2011 -0700

    notifiers: pm: move pm notifiers into suspend.h
    
    It is not necessary to share the same notifier.h.
    
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Cc: David Miller <davem@davemloft.net>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e1e3742733be..6bbcef22e105 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -268,6 +268,14 @@ static inline int hibernate(void) { return -ENOSYS; }
 static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
+/* Hibernation and suspend events */
+#define PM_HIBERNATION_PREPARE	0x0001 /* Going to hibernate */
+#define PM_POST_HIBERNATION	0x0002 /* Hibernation finished */
+#define PM_SUSPEND_PREPARE	0x0003 /* Going to suspend the system */
+#define PM_POST_SUSPEND		0x0004 /* Suspend finished */
+#define PM_RESTORE_PREPARE	0x0005 /* Going to restore a saved image */
+#define PM_POST_RESTORE		0x0006 /* Restore failed */
+
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
 void restore_processor_state(void);

commit 3b5fe85252326217cd96f24a7bda4460d8f71bee
Author: MyungJoo Ham <myungjoo.ham@samsung.com>
Date:   Sun Jun 12 15:57:05 2011 +0200

    PM / Suspend: Add .suspend_again() callback to suspend_ops
    
    A system or a device may need to control suspend/wakeup events. It may
    want to wakeup the system after a predefined amount of time or at a
    predefined event decided while entering suspend for polling or delayed
    work. Then, it may want to enter suspend again if its predefined wakeup
    condition is the only wakeup reason and there is no outstanding events;
    thus, it does not wakeup the userspace unnecessary or unnecessary
    devices and keeps suspended as long as possible (saving the power).
    
    Enabling a system to wakeup after a specified time can be easily
    achieved by using RTC. However, to enter suspend again immediately
    without invoking userland and unrelated devices, we need additional
    features in the suspend framework.
    
    Such need comes from:
    
     1. Monitoring a critical device status without interrupts that can
    wakeup the system. (in-suspend polling)
     An example is ambient temperature monitoring that needs to shut down
    the system or a specific device function if it is too hot or cold. The
    temperature of a specific device may be needed to be monitored as well;
    e.g., a charger monitors battery temperature in order to stop charging
    if overheated.
    
     2. Execute critical "delayed work" at suspend.
     A driver or a system/board may have a delayed work (or any similar
    things) that it wants to execute at the requested time.
     For example, some chargers want to check the battery voltage some
    time (e.g., 30 seconds) after the battery is fully charged and the
    charger has stopped. Then, the charger restarts charging if the voltage
    has dropped more than a threshold, which is smaller than "restart-charger"
    voltage, which is a threshold to restart charging regardless of the
    time passed.
    
    This patch allows to add "suspend_again" callback at struct
    platform_suspend_ops and let the "suspend_again" callback return true if
    the system is required to enter suspend again after the current instance
    of wakeup. Device-wise suspend_again implemented at dev_pm_ops or
    syscore is not done because: a) suspend_again feature is usually under
    platform-wise decision and controls the behavior of the whole platform
    and b) There are very limited devices related to the usage cases of
    suspend_again; chargers and temperature sensors are mentioned so far.
    
    With suspend_again callback registered at struct platform_suspend_ops
    suspend_ops in kernel/power/suspend.c with suspend_set_ops by the
    platform, the suspend framework tries to enter suspend again by
    looping suspend_enter() if suspend_again has returned true and there has
    been no errors in the suspending sequence or pending wakeups (by
    pm_wakeup_pending).
    
    Tested at Exynos4-NURI.
    
    [rjw: Fixed up kerneldoc comment for suspend_enter().]
    
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 083ffea7ba18..e1e3742733be 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -92,6 +92,13 @@ typedef int __bitwise suspend_state_t;
  *	@enter() and @wake(), even if any of them fails.  It is executed after
  *	a failing @prepare.
  *
+ * @suspend_again: Returns whether the system should suspend again (true) or
+ *	not (false). If the platform wants to poll sensors or execute some
+ *	code during suspended without invoking userspace and most of devices,
+ *	suspend_again callback is the place assuming that periodic-wakeup or
+ *	alarm-wakeup is already setup. This allows to execute some codes while
+ *	being kept suspended in the view of userland and devices.
+ *
  * @end: Called by the PM core right after resuming devices, to indicate to
  *	the platform that the system has returned to the working state or
  *	the transition to the sleep state has been aborted.
@@ -113,6 +120,7 @@ struct platform_suspend_ops {
 	int (*enter)(suspend_state_t state);
 	void (*wake)(void);
 	void (*finish)(void);
+	bool (*suspend_again)(void);
 	void (*end)(void);
 	void (*recover)(void);
 };

commit 1f112cee07b314e244ee9e71d9c1e6950dc13327
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 11 22:54:42 2011 +0200

    PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS
    
    Xen save/restore is going to use hibernate device callbacks for
    quiescing devices and putting them back to normal operations and it
    would need to select CONFIG_HIBERNATION for this purpose.  However,
    that also would cause the hibernate interfaces for user space to be
    enabled, which might confuse user space, because the Xen kernels
    don't support hibernation.  Moreover, it would be wasteful, as it
    would make the Xen kernels include a substantial amount of code that
    they would never use.
    
    To address this issue introduce new power management Kconfig option
    CONFIG_HIBERNATE_CALLBACKS, such that it will only select the code
    that is necessary for the hibernate device callbacks to work and make
    CONFIG_HIBERNATION select it.  Then, Xen save/restore will be able to
    select CONFIG_HIBERNATE_CALLBACKS without dragging the entire
    hibernate code along with it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 5a89e3612875..083ffea7ba18 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -249,6 +249,8 @@ extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 extern bool system_entering_hibernation(void);
 #else /* CONFIG_HIBERNATION */
+static inline void register_nosave_region(unsigned long b, unsigned long e) {}
+static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
@@ -297,14 +299,7 @@ static inline bool pm_wakeup_pending(void) { return false; }
 
 extern struct mutex pm_mutex;
 
-#ifndef CONFIG_HIBERNATION
-static inline void register_nosave_region(unsigned long b, unsigned long e)
-{
-}
-static inline void register_nosave_region_late(unsigned long b, unsigned long e)
-{
-}
-
+#ifndef CONFIG_HIBERNATE_CALLBACKS
 static inline void lock_system_sleep(void) {}
 static inline void unlock_system_sleep(void) {}
 

commit 52cfd503ad7176d23a5dd7af3981744feb60622f
Merge: dc8e7e3ec60b 4263d9a3ae4d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 20:15:35 2011 -0800

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (59 commits)
      ACPI / PM: Fix build problems for !CONFIG_ACPI related to NVS rework
      ACPI: fix resource check message
      ACPI / Battery: Update information on info notification and resume
      ACPI: Drop device flag wake_capable
      ACPI: Always check if _PRW is present before trying to evaluate it
      ACPI / PM: Check status of power resources under mutexes
      ACPI / PM: Rename acpi_power_off_device()
      ACPI / PM: Drop acpi_power_nocheck
      ACPI / PM: Drop acpi_bus_get_power()
      Platform / x86: Make fujitsu_laptop use acpi_bus_update_power()
      ACPI / Fan: Rework the handling of power resources
      ACPI / PM: Register power resource devices as soon as they are needed
      ACPI / PM: Register acpi_power_driver early
      ACPI / PM: Add function for updating device power state consistently
      ACPI / PM: Add function for device power state initialization
      ACPI / PM: Introduce __acpi_bus_get_power()
      ACPI / PM: Introduce function for refcounting device power resources
      ACPI / PM: Add functions for manipulating lists of power resources
      ACPI / PM: Prevent acpi_power_get_inferred_state() from making changes
      ACPICA: Update version to 20101209
      ...

commit 008d23e4852d78bb2618f2035f8b2110b6a6b968
Merge: 8f685fbda43d bfc672dcf323
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:05:56 2011 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      Documentation/trace/events.txt: Remove obsolete sched_signal_send.
      writeback: fix global_dirty_limits comment runtime -> real-time
      ppc: fix comment typo singal -> signal
      drivers: fix comment typo diable -> disable.
      m68k: fix comment typo diable -> disable.
      wireless: comment typo fix diable -> disable.
      media: comment typo fix diable -> disable.
      remove doc for obsolete dynamic-printk kernel-parameter
      remove extraneous 'is' from Documentation/iostats.txt
      Fix spelling milisec -> ms in snd_ps3 module parameter description
      Fix spelling mistakes in comments
      Revert conflicting V4L changes
      i7core_edac: fix typos in comments
      mm/rmap.c: fix comment
      sound, ca0106: Fix assignment to 'channel'.
      hrtimer: fix a typo in comment
      init/Kconfig: fix typo
      anon_inodes: fix wrong function name in comment
      fix comment typos concerning "consistent"
      poll: fix a typo in comment
      ...
    
    Fix up trivial conflicts in:
     - drivers/net/wireless/iwlwifi/iwl-core.c (moved to iwl-legacy.c)
     - fs/ext4/ext4.h
    
    Also fix missed 'diabled' typo in drivers/net/bnx2x/bnx2x.h while at it.

commit 976513dbfc1547c7b1822566923058655f0c32fd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 01:43:44 2011 +0100

    PM / ACPI: Move NVS saving and restoring code to drivers/acpi
    
    The saving of the ACPI NVS area during hibernation and suspend and
    restoring it during the subsequent resume is entirely specific to
    ACPI, so move it to drivers/acpi and drop the CONFIG_SUSPEND_NVS
    configuration option which is redundant.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index acb7d911bb0c..0e288e3c37be 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -258,23 +258,6 @@ static inline int hibernate(void) { return -ENOSYS; }
 static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
-#ifdef CONFIG_SUSPEND_NVS
-extern int suspend_nvs_register(unsigned long start, unsigned long size);
-extern int suspend_nvs_alloc(void);
-extern void suspend_nvs_free(void);
-extern int suspend_nvs_save(void);
-extern void suspend_nvs_restore(void);
-#else /* CONFIG_SUSPEND_NVS */
-static inline int suspend_nvs_register(unsigned long a, unsigned long b)
-{
-	return 0;
-}
-static inline int suspend_nvs_alloc(void) { return 0; }
-static inline void suspend_nvs_free(void) {}
-static inline int suspend_nvs_save(void) {}
-static inline void suspend_nvs_restore(void) {}
-#endif /* CONFIG_SUSPEND_NVS */
-
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
 void restore_processor_state(void);

commit 26fcaf60fe3861409eb4c455c5c0d0f00f599b08
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri Jan 7 01:42:31 2011 +0100

    PM: Fix oops in suspend/hibernate code related to failing ioremap()
    
    When ioremap() fails (which might happen for some reason), we nicely
    oops in suspend_nvs_save() due to NULL dereference by memcpy() in there.
    Fail gracefully instead.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 26697514c5ec..acb7d911bb0c 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -262,7 +262,7 @@ static inline bool system_entering_hibernation(void) { return false; }
 extern int suspend_nvs_register(unsigned long start, unsigned long size);
 extern int suspend_nvs_alloc(void);
 extern void suspend_nvs_free(void);
-extern void suspend_nvs_save(void);
+extern int suspend_nvs_save(void);
 extern void suspend_nvs_restore(void);
 #else /* CONFIG_SUSPEND_NVS */
 static inline int suspend_nvs_register(unsigned long a, unsigned long b)
@@ -271,7 +271,7 @@ static inline int suspend_nvs_register(unsigned long a, unsigned long b)
 }
 static inline int suspend_nvs_alloc(void) { return 0; }
 static inline void suspend_nvs_free(void) {}
-static inline void suspend_nvs_save(void) {}
+static inline int suspend_nvs_save(void) {}
 static inline void suspend_nvs_restore(void) {}
 #endif /* CONFIG_SUSPEND_NVS */
 

commit a2867e08c8e3bdbc00caf56bc3bdde19ccc058e3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Dec 3 22:58:31 2010 +0100

    PM / Wakeup: Replace pm_check_wakeup_events() with pm_wakeup_pending()
    
    To avoid confusion with the meaning and return value of
    pm_check_wakeup_events() replace it with pm_wakeup_pending() that
    will work the other way around (ie. return true when system-wide
    power transition should be aborted).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 26697514c5ec..144b34be5c32 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -292,7 +292,7 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 /* drivers/base/power/wakeup.c */
 extern bool events_check_enabled;
 
-extern bool pm_check_wakeup_events(void);
+extern bool pm_wakeup_pending(void);
 extern bool pm_get_wakeup_count(unsigned int *count);
 extern bool pm_save_wakeup_count(unsigned int count);
 #else /* !CONFIG_PM_SLEEP */
@@ -309,7 +309,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 
-static inline bool pm_check_wakeup_events(void) { return true; }
+static inline bool pm_wakeup_pending(void) { return false; }
 #endif /* !CONFIG_PM_SLEEP */
 
 extern struct mutex pm_mutex;

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 40ead943fd6a..f45f3ccfdfa9 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -122,7 +122,7 @@ struct platform_suspend_ops {
  * suspend_set_ops - set platform dependent suspend operations
  * @ops: The new suspend operations to set.
  */
-extern void suspend_set_ops(struct platform_suspend_ops *ops);
+extern void suspend_set_ops(const struct platform_suspend_ops *ops);
 extern int suspend_valid_only_mem(suspend_state_t state);
 
 /**
@@ -147,7 +147,7 @@ extern int pm_suspend(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 #define suspend_valid_only_mem	NULL
 
-static inline void suspend_set_ops(struct platform_suspend_ops *ops) {}
+static inline void suspend_set_ops(const struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
 #endif /* !CONFIG_SUSPEND */
 

commit 073ef1f6e508688392580e4f35dcad9aabd1e100
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 9 21:48:49 2010 +0100

    hibernation: constify platform_hibernation_ops
    
    Patch against mainline.
    
    Changes since v1: added one hunk; no longer adding "const" qualifier to
    pointers in platform_hibernation_ops after seeing
    b4144e4f6e3b448d322095ca08af393682a69e33.
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 26697514c5ec..40ead943fd6a 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -245,7 +245,7 @@ extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
 
-extern void hibernation_set_ops(struct platform_hibernation_ops *ops);
+extern void hibernation_set_ops(const struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 extern bool system_entering_hibernation(void);
 #else /* CONFIG_HIBERNATION */
@@ -253,7 +253,7 @@ static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
 
-static inline void hibernation_set_ops(struct platform_hibernation_ops *ops) {}
+static inline void hibernation_set_ops(const struct platform_hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
 static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */

commit dbeeec5fe868f2e2e92fe94daa2c5a047240fdc4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 4 22:07:32 2010 +0200

    PM: Allow wakeup events to abort freezing of tasks
    
    If there is a wakeup event during the freezing of tasks, suspend or
    hibernation will fail anyway.  Since try_to_freeze_tasks() can take
    up to 20 seconds to complete or fail, aborting it as soon as a wakeup
    event is detected improves the worst case wakeup latency.
    
    Based on a patch from Arve Hjnnevg.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 6b1712c51102..26697514c5ec 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -308,6 +308,8 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 }
 
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
+
+static inline bool pm_check_wakeup_events(void) { return true; }
 #endif /* !CONFIG_PM_SLEEP */
 
 extern struct mutex pm_mutex;

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 4af270ec2204..6b1712c51102 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -293,8 +293,8 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 extern bool events_check_enabled;
 
 extern bool pm_check_wakeup_events(void);
-extern bool pm_get_wakeup_count(unsigned long *count);
-extern bool pm_save_wakeup_count(unsigned long count);
+extern bool pm_get_wakeup_count(unsigned int *count);
+extern bool pm_save_wakeup_count(unsigned int count);
 #else /* !CONFIG_PM_SLEEP */
 
 static inline int register_pm_notifier(struct notifier_block *nb)

commit ce4410116c5debfb0e049f5db4b5cd6211e05b80
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 7 23:43:45 2010 +0200

    PM / Suspend: Fix ordering of calls in suspend error paths
    
    The ACPI suspend code calls suspend_nvs_free() at a wrong place,
    which may lead to a memory leak if there's an error executing
    acpi_pm_prepare(), because acpi_pm_finish() will not be called in
    that case.  However, the root cause of this problem is the
    apparently confusing ordering of calls in suspend error paths that
    needs to be fixed.
    
    In addition to that, fix a typo in a label name in suspend.c.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index bf1bab7b059c..4af270ec2204 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -61,14 +61,15 @@ typedef int __bitwise suspend_state_t;
  *	before device drivers' late suspend callbacks are executed.  It returns
  *	0 on success or a negative error code otherwise, in which case the
  *	system cannot enter the desired sleep state (@prepare_late(), @enter(),
- *	@wake(), and @finish() will not be called in that case).
+ *	and @wake() will not be called in that case).
  *
  * @prepare_late: Finish preparing the platform for entering the system sleep
  *	state indicated by @begin().
  *	@prepare_late is called before disabling nonboot CPUs and after
  *	device drivers' late suspend callbacks have been executed.  It returns
  *	0 on success or a negative error code otherwise, in which case the
- *	system cannot enter the desired sleep state (@enter() and @wake()).
+ *	system cannot enter the desired sleep state (@enter() will not be
+ *	executed).
  *
  * @enter: Enter the system sleep state indicated by @begin() or represented by
  *	the argument if @begin() is not implemented.
@@ -81,14 +82,15 @@ typedef int __bitwise suspend_state_t;
  *	resume callbacks are executed.
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare_late().  If implemented, it is always called
- *	after @enter(), even if @enter() fails.
+ *	after @prepare_late and @enter(), even if one of them fails.
  *
  * @finish: Finish wake-up of the platform.
  *	@finish is called right prior to calling device drivers' regular suspend
  *	callbacks.
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare().  If implemented, it is always called after
- *	@enter() and @wake(), if implemented, even if any of them fails.
+ *	@enter() and @wake(), even if any of them fails.  It is executed after
+ *	a failing @prepare.
  *
  * @end: Called by the PM core right after resuming devices, to indicate to
  *	the platform that the system has returned to the working state or

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index bc7d6bb4cd8e..bf1bab7b059c 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -286,6 +286,13 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 		{ .notifier_call = fn, .priority = pri };	\
 	register_pm_notifier(&fn##_nb);			\
 }
+
+/* drivers/base/power/wakeup.c */
+extern bool events_check_enabled;
+
+extern bool pm_check_wakeup_events(void);
+extern bool pm_get_wakeup_count(unsigned long *count);
+extern bool pm_save_wakeup_count(unsigned long count);
 #else /* !CONFIG_PM_SLEEP */
 
 static inline int register_pm_notifier(struct notifier_block *nb)

commit dd4c4f17d722ffeb2515bf781400675a30fcead7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 28 16:32:14 2010 -0400

    suspend: Move NVS save/restore code to generic suspend functionality
    
    Saving platform non-volatile state may be required for suspend to RAM as
    well as hibernation. Move it to more generic code.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 5e781d824e6d..bc7d6bb4cd8e 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -256,22 +256,22 @@ static inline int hibernate(void) { return -ENOSYS; }
 static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
-#ifdef CONFIG_HIBERNATION_NVS
-extern int hibernate_nvs_register(unsigned long start, unsigned long size);
-extern int hibernate_nvs_alloc(void);
-extern void hibernate_nvs_free(void);
-extern void hibernate_nvs_save(void);
-extern void hibernate_nvs_restore(void);
-#else /* CONFIG_HIBERNATION_NVS */
-static inline int hibernate_nvs_register(unsigned long a, unsigned long b)
+#ifdef CONFIG_SUSPEND_NVS
+extern int suspend_nvs_register(unsigned long start, unsigned long size);
+extern int suspend_nvs_alloc(void);
+extern void suspend_nvs_free(void);
+extern void suspend_nvs_save(void);
+extern void suspend_nvs_restore(void);
+#else /* CONFIG_SUSPEND_NVS */
+static inline int suspend_nvs_register(unsigned long a, unsigned long b)
 {
 	return 0;
 }
-static inline int hibernate_nvs_alloc(void) { return 0; }
-static inline void hibernate_nvs_free(void) {}
-static inline void hibernate_nvs_save(void) {}
-static inline void hibernate_nvs_restore(void) {}
-#endif /* CONFIG_HIBERNATION_NVS */
+static inline int suspend_nvs_alloc(void) { return 0; }
+static inline void suspend_nvs_free(void) {}
+static inline void suspend_nvs_save(void) {}
+static inline void suspend_nvs_restore(void) {}
+#endif /* CONFIG_SUSPEND_NVS */
 
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);

commit 6ad696d2cf535772dff659298ec7e7260e344595
Author: Andi Kleen <andi@firstfloor.org>
Date:   Tue Nov 17 14:06:22 2009 -0800

    mm: allow memory hotplug and hibernation in the same kernel
    
    Allow memory hotplug and hibernation in the same kernel
    
    Memory hotplug and hibernation were exclusive in Kconfig.  This is
    obviously a problem for distribution kernels who want to support both in
    the same image.
    
    After some discussions with Rafael and others the only problem is with
    parallel memory hotadd or removal while a hibernation operation is in
    process.  It was also working for s390 before.
    
    This patch removes the Kconfig level exclusion, and simply makes the
    memory add / remove functions grab the pm_mutex to exclude against
    hibernation.
    
    Fixes a regression - old kernels didn't exclude memory hotadd and
    hibernation.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index cd15df6c63cd..5e781d824e6d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -301,6 +301,8 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 #endif /* !CONFIG_PM_SLEEP */
 
+extern struct mutex pm_mutex;
+
 #ifndef CONFIG_HIBERNATION
 static inline void register_nosave_region(unsigned long b, unsigned long e)
 {
@@ -308,8 +310,23 @@ static inline void register_nosave_region(unsigned long b, unsigned long e)
 static inline void register_nosave_region_late(unsigned long b, unsigned long e)
 {
 }
-#endif
 
-extern struct mutex pm_mutex;
+static inline void lock_system_sleep(void) {}
+static inline void unlock_system_sleep(void) {}
+
+#else
+
+/* Let some subsystems like memory hotadd exclude hibernation */
+
+static inline void lock_system_sleep(void)
+{
+	mutex_lock(&pm_mutex);
+}
+
+static inline void unlock_system_sleep(void)
+{
+	mutex_unlock(&pm_mutex);
+}
+#endif
 
 #endif /* _LINUX_SUSPEND_H */

commit fce2b111fae9151a53dabb36513b398d03337a19
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Jun 10 01:28:19 2009 +0200

    PM/Hibernate: Move NVS routines into a seperate file (v2).
    
    The *_nvs_* routines in swsusp.c make use of the io*map()
    functions, which are only provided for HAS_IOMEM, thus
    breaking compilation if HAS_IOMEM is not set. Fix this
    by moving the *_nvs_* routines into hibernate_nvs.c, which
    is only compiled if HAS_IOMEM is set.
    
    [rjw: Change the name of the new file to hibernate_nvs.c, add the
     license line to the header comment.]
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 795032edfc46..cd15df6c63cd 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -245,11 +245,6 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 
 extern void hibernation_set_ops(struct platform_hibernation_ops *ops);
 extern int hibernate(void);
-extern int hibernate_nvs_register(unsigned long start, unsigned long size);
-extern int hibernate_nvs_alloc(void);
-extern void hibernate_nvs_free(void);
-extern void hibernate_nvs_save(void);
-extern void hibernate_nvs_restore(void);
 extern bool system_entering_hibernation(void);
 #else /* CONFIG_HIBERNATION */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
@@ -258,6 +253,16 @@ static inline void swsusp_unset_page_free(struct page *p) {}
 
 static inline void hibernation_set_ops(struct platform_hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
+static inline bool system_entering_hibernation(void) { return false; }
+#endif /* CONFIG_HIBERNATION */
+
+#ifdef CONFIG_HIBERNATION_NVS
+extern int hibernate_nvs_register(unsigned long start, unsigned long size);
+extern int hibernate_nvs_alloc(void);
+extern void hibernate_nvs_free(void);
+extern void hibernate_nvs_save(void);
+extern void hibernate_nvs_restore(void);
+#else /* CONFIG_HIBERNATION_NVS */
 static inline int hibernate_nvs_register(unsigned long a, unsigned long b)
 {
 	return 0;
@@ -266,8 +271,7 @@ static inline int hibernate_nvs_alloc(void) { return 0; }
 static inline void hibernate_nvs_free(void) {}
 static inline void hibernate_nvs_save(void) {}
 static inline void hibernate_nvs_restore(void) {}
-static inline bool system_entering_hibernation(void) { return false; }
-#endif /* CONFIG_HIBERNATION */
+#endif /* CONFIG_HIBERNATION_NVS */
 
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);

commit 6a7c7eaf71b636f197d73b381a2ab729ebdcfb2e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 19 20:08:42 2009 +0200

    PM/Suspend: Introduce two new platform callbacks to avoid breakage
    
    Commit 900af0d973856d6feb6fc088c2d0d3fde57707d3 (PM: Change suspend
    code ordering) changed the ordering of suspend code in such a way
    that the platform .prepare() callback is now executed after the
    device drivers' late suspend callbacks have run.  Unfortunately, this
    turns out to break ARM platforms that need to talk via I2C to power
    control devices during the .prepare() callback.
    
    For this reason introduce two new platform suspend callbacks,
    .prepare_late() and .wake(), that will be called just prior to
    disabling non-boot CPUs and right after bringing them back on line,
    respectively, and use them instead of .prepare() and .finish() for
    ACPI suspend.  Make the PM core execute the .prepare() and .finish()
    platform suspend callbacks where they were executed previously (that
    is, right after calling the regular suspend methods provided by
    device drivers and right before executing their regular resume
    methods, respectively).
    
    It is not necessary to make analogous changes to the hibernation
    code and data structures at the moment, because they are only used
    by ACPI platforms.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 3e3a4364cbff..795032edfc46 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -58,10 +58,17 @@ typedef int __bitwise suspend_state_t;
  *	by @begin().
  *	@prepare() is called right after devices have been suspended (ie. the
  *	appropriate .suspend() method has been executed for each device) and
- *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
- *	This callback is optional.  It returns 0 on success or a negative
- *	error code otherwise, in which case the system cannot enter the desired
- *	sleep state (@enter() and @finish() will not be called in that case).
+ *	before device drivers' late suspend callbacks are executed.  It returns
+ *	0 on success or a negative error code otherwise, in which case the
+ *	system cannot enter the desired sleep state (@prepare_late(), @enter(),
+ *	@wake(), and @finish() will not be called in that case).
+ *
+ * @prepare_late: Finish preparing the platform for entering the system sleep
+ *	state indicated by @begin().
+ *	@prepare_late is called before disabling nonboot CPUs and after
+ *	device drivers' late suspend callbacks have been executed.  It returns
+ *	0 on success or a negative error code otherwise, in which case the
+ *	system cannot enter the desired sleep state (@enter() and @wake()).
  *
  * @enter: Enter the system sleep state indicated by @begin() or represented by
  *	the argument if @begin() is not implemented.
@@ -69,19 +76,26 @@ typedef int __bitwise suspend_state_t;
  *	error code otherwise, in which case the system cannot enter the desired
  *	sleep state.
  *
- * @finish: Called when the system has just left a sleep state, right after
- *	the nonboot CPUs have been enabled and before devices are resumed (it is
- *	executed with IRQs enabled).
+ * @wake: Called when the system has just left a sleep state, right after
+ *	the nonboot CPUs have been enabled and before device drivers' early
+ *	resume callbacks are executed.
+ *	This callback is optional, but should be implemented by the platforms
+ *	that implement @prepare_late().  If implemented, it is always called
+ *	after @enter(), even if @enter() fails.
+ *
+ * @finish: Finish wake-up of the platform.
+ *	@finish is called right prior to calling device drivers' regular suspend
+ *	callbacks.
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare().  If implemented, it is always called after
- *	@enter() (even if @enter() fails).
+ *	@enter() and @wake(), if implemented, even if any of them fails.
  *
  * @end: Called by the PM core right after resuming devices, to indicate to
  *	the platform that the system has returned to the working state or
  *	the transition to the sleep state has been aborted.
  *	This callback is optional, but should be implemented by the platforms
- *	that implement @begin(), but platforms implementing @begin() should
- *	also provide a @end() which cleans up transitions aborted before
+ *	that implement @begin().  Accordingly, platforms implementing @begin()
+ *	should also provide a @end() which cleans up transitions aborted before
  *	@enter().
  *
  * @recover: Recover the platform from a suspend failure.
@@ -93,7 +107,9 @@ struct platform_suspend_ops {
 	int (*valid)(suspend_state_t state);
 	int (*begin)(suspend_state_t state);
 	int (*prepare)(void);
+	int (*prepare_late)(void);
 	int (*enter)(suspend_state_t state);
+	void (*wake)(void);
 	void (*finish)(void);
 	void (*end)(void);
 	void (*recover)(void);

commit a8af78982ff4c0b3731527b0217d286a343a3089
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Mar 31 15:23:37 2009 -0700

    pm: rework includes, remove arch ifdefs
    
    Make the following header file changes:
    
     - remove arch ifdefs and asm/suspend.h from linux/suspend.h
     - add asm/suspend.h to disk.c (for arch_prepare_suspend())
     - add linux/io.h to swsusp.c (for ioremap())
     - x86 32/64 bit compile fixes
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index c7d9bb1832ba..3e3a4364cbff 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -1,9 +1,6 @@
 #ifndef _LINUX_SUSPEND_H
 #define _LINUX_SUSPEND_H
 
-#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
-#include <asm/suspend.h>
-#endif
 #include <linux/swap.h>
 #include <linux/notifier.h>
 #include <linux/init.h>

commit abfe2d7b915c872f3a1fd203267cedebf90daa45
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jan 19 20:54:54 2009 +0100

    Hibernation: Introduce system_entering_hibernation
    
    Introduce boolean function system_entering_hibernation() returning
    'true' during the last phase of hibernation, in which devices are
    being put into low power states and the sleep state (for example,
    ACPI S4) is finally entered.
    
    Some device drivers need such a function to check if the system is
    in the final phase of hibernation.  In particular, some SATA drivers
    are going to use it for blacklisting systems in which the disks
    should not be spun down during the last phase of hibernation (the
    BIOS will do that anyway).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 2b409c44db83..c7d9bb1832ba 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -237,6 +237,7 @@ extern int hibernate_nvs_alloc(void);
 extern void hibernate_nvs_free(void);
 extern void hibernate_nvs_save(void);
 extern void hibernate_nvs_restore(void);
+extern bool system_entering_hibernation(void);
 #else /* CONFIG_HIBERNATION */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
@@ -252,6 +253,7 @@ static inline int hibernate_nvs_alloc(void) { return 0; }
 static inline void hibernate_nvs_free(void) {}
 static inline void hibernate_nvs_save(void) {}
 static inline void hibernate_nvs_restore(void) {}
+static inline bool system_entering_hibernation(void) { return false; }
 #endif /* CONFIG_HIBERNATION */
 
 #ifdef CONFIG_PM_SLEEP

commit 3f4b0ef7f2899c91b1d6958779f084b44dd59d32
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 26 20:52:15 2008 +0100

    ACPI hibernate: Add a mechanism to save/restore ACPI NVS memory
    
    According to the ACPI Specification 3.0b, Section 15.3.2,
    "OSPM will call the _PTS control method some time before entering a
    sleeping state, to allow the platform's AML code to update this
    memory image before entering the sleeping state. After the system
    awakes from an S4 state, OSPM will restore this memory area and call
    the _WAK control method to enable the BIOS to reclaim its memory
    image."  For this reason, implement a mechanism allowing us to save
    the NVS memory during hibernation and to restore it during the
    subsequent resume.
    
    Based on a patch by Zhang Rui.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Nigel Cunningham <nigel@tuxonice.net>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 2ce8207686e2..2b409c44db83 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -232,6 +232,11 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 
 extern void hibernation_set_ops(struct platform_hibernation_ops *ops);
 extern int hibernate(void);
+extern int hibernate_nvs_register(unsigned long start, unsigned long size);
+extern int hibernate_nvs_alloc(void);
+extern void hibernate_nvs_free(void);
+extern void hibernate_nvs_save(void);
+extern void hibernate_nvs_restore(void);
 #else /* CONFIG_HIBERNATION */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
@@ -239,6 +244,14 @@ static inline void swsusp_unset_page_free(struct page *p) {}
 
 static inline void hibernation_set_ops(struct platform_hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
+static inline int hibernate_nvs_register(unsigned long a, unsigned long b)
+{
+	return 0;
+}
+static inline int hibernate_nvs_alloc(void) { return 0; }
+static inline void hibernate_nvs_free(void) {}
+static inline void hibernate_nvs_save(void) {}
+static inline void hibernate_nvs_restore(void) {}
 #endif /* CONFIG_HIBERNATION */
 
 #ifdef CONFIG_PM_SLEEP

commit ce289e89726948b50a58c9e8f4e81174a8c9c254
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Fri Aug 15 00:40:19 2008 -0700

    suspend: fix section mismatch warning - register_nosave_region
    
    WARNING: vmlinux.o(.text+0xe684): Section mismatch in reference from the function register_nosave_region() to the function .init.text:__register_nosave_region()
      The function register_nosave_region() references
      the function __init __register_nosave_region().
      This is often because register_nosave_region lacks a __init
      annotation or the annotation of __register_nosave_region is wrong.
    
    register_nosave_region calls __init function and is called only from
    __init functions
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index c63435095970..2ce8207686e2 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -217,11 +217,11 @@ struct platform_hibernation_ops {
 #ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */
 extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
-static inline void register_nosave_region(unsigned long b, unsigned long e)
+static inline void __init register_nosave_region(unsigned long b, unsigned long e)
 {
 	__register_nosave_region(b, e, 0);
 }
-static inline void register_nosave_region_late(unsigned long b, unsigned long e)
+static inline void __init register_nosave_region_late(unsigned long b, unsigned long e)
 {
 	__register_nosave_region(b, e, 1);
 }

commit 89081d17f7bb81d89fa1aa9b70f821c5cf4d39e9
Author: Huang Ying <ying.huang@intel.com>
Date:   Fri Jul 25 19:45:10 2008 -0700

    kexec jump: save/restore device state
    
    This patch implements devices state save/restore before after kexec.
    
    This patch together with features in kexec_jump patch can be used for
    following:
    
    - A simple hibernation implementation without ACPI support.  You can kexec a
      hibernating kernel, save the memory image of original system and shutdown
      the system.  When resuming, you restore the memory image of original system
      via ordinary kexec load then jump back.
    
    - Kernel/system debug through making system snapshot.  You can make system
      snapshot, jump back, do some thing and make another system snapshot.
    
    - Cooperative multi-kernel/system.  With kexec jump, you can switch between
      several kernels/systems quickly without boot process except the first time.
      This appears like swap a whole kernel/system out/in.
    
    - A general method to call program in physical mode (paging turning
      off). This can be used to invoke BIOS code under Linux.
    
    The following user-space tools can be used with kexec jump:
    
    - kexec-tools needs to be patched to support kexec jump. The patches
      and the precompiled kexec can be download from the following URL:
           source: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec-tools-src_git_kh10.tar.bz2
           patches: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec-tools-patches_git_kh10.tar.bz2
           binary: http://khibernation.sourceforge.net/download/release_v10/kexec-tools/kexec_git_kh10
    
    - makedumpfile with patches are used as memory image saving tool, it
      can exclude free pages from original kernel memory image file. The
      patches and the precompiled makedumpfile can be download from the
      following URL:
           source: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile-src_cvs_kh10.tar.bz2
           patches: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile-patches_cvs_kh10.tar.bz2
           binary: http://khibernation.sourceforge.net/download/release_v10/makedumpfile/makedumpfile_cvs_kh10
    
    - An initramfs image can be used as the root file system of kexeced
      kernel. An initramfs image built with "BuildRoot" can be downloaded
      from the following URL:
           initramfs image: http://khibernation.sourceforge.net/download/release_v10/initramfs/rootfs_cvs_kh10.gz
      All user space tools above are included in the initramfs image.
    
    Usage example of simple hibernation:
    
    1. Compile and install patched kernel with following options selected:
    
    CONFIG_X86_32=y
    CONFIG_RELOCATABLE=y
    CONFIG_KEXEC=y
    CONFIG_CRASH_DUMP=y
    CONFIG_PM=y
    CONFIG_HIBERNATION=y
    CONFIG_KEXEC_JUMP=y
    
    2. Build an initramfs image contains kexec-tool and makedumpfile, or
       download the pre-built initramfs image, called rootfs.gz in
       following text.
    
    3. Prepare a partition to save memory image of original kernel, called
       hibernating partition in following text.
    
    4. Boot kernel compiled in step 1 (kernel A).
    
    5. In the kernel A, load kernel compiled in step 1 (kernel B) with
       /sbin/kexec. The shell command line can be as follow:
    
       /sbin/kexec --load-preserve-context /boot/bzImage --mem-min=0x100000
         --mem-max=0xffffff --initrd=rootfs.gz
    
    6. Boot the kernel B with following shell command line:
    
       /sbin/kexec -e
    
    7. The kernel B will boot as normal kexec. In kernel B the memory
       image of kernel A can be saved into hibernating partition as
       follow:
    
       jump_back_entry=`cat /proc/cmdline | tr ' ' '\n' | grep kexec_jump_back_entry | cut -d '='`
       echo $jump_back_entry > kexec_jump_back_entry
       cp /proc/vmcore dump.elf
    
       Then you can shutdown the machine as normal.
    
    8. Boot kernel compiled in step 1 (kernel C). Use the rootfs.gz as
       root file system.
    
    9. In kernel C, load the memory image of kernel A as follow:
    
       /sbin/kexec -l --args-none --entry=`cat kexec_jump_back_entry` dump.elf
    
    10. Jump back to the kernel A as follow:
    
       /sbin/kexec -e
    
       Then, kernel A is resumed.
    
    Implementation point:
    
    To support jumping between two kernels, before jumping to (executing)
    the new kernel and jumping back to the original kernel, the devices
    are put into quiescent state, and the state of devices and CPU is
    saved. After jumping back from kexeced kernel and jumping to the new
    kernel, the state of devices and CPU are restored accordingly. The
    devices/CPU state save/restore code of software suspend is called to
    implement corresponding function.
    
    Known issues:
    
    - Because the segment number supported by sys_kexec_load is limited,
      hibernation image with many segments may not be load. This is
      planned to be eliminated by adding a new flag to sys_kexec_load to
      make a image can be loaded with multiple sys_kexec_load invoking.
    
    Now, only the i386 architecture is supported.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e8e69159af71..c63435095970 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -278,4 +278,6 @@ static inline void register_nosave_region_late(unsigned long b, unsigned long e)
 }
 #endif
 
+extern struct mutex pm_mutex;
+
 #endif /* _LINUX_SUSPEND_H */

commit d8f3de0d2412bb91639cfefc5b3c79dbf3812212
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 12 23:24:06 2008 +0200

    Suspend-related patches for 2.6.27
    
    ACPI PM: Add possibility to change suspend sequence
    
    There are some systems out there that don't work correctly with
    our current suspend/hibernation code ordering.  Provide a workaround
    for these systems allowing them to pass 'acpi_sleep=old_ordering' in
    the kernel command line so that it will use the pre-ACPI 2.0 ("old")
    suspend code ordering.
    
    Unfortunately, this requires us to add a platform hook to the
    resuming of devices for recovering the platform in case one of the
    device drivers' .suspend() routines returns error code.  Namely,
    ACPI 1.0 specifies that _PTS should be called before suspending
    devices, but _WAK still should be called before resuming them in
    order to undo the changes made by _PTS.  However, if there is an
    error during suspending devices, they are automatically resumed
    without returning control to the PM core, so the _WAK has to be
    called from within device_resume() in that cases.
    
    The patch also reorders and refactors the ACPI suspend/hibernation
    code to avoid duplication as far as reasonably possible.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index a6977423baf7..e8e69159af71 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -86,6 +86,11 @@ typedef int __bitwise suspend_state_t;
  *	that implement @begin(), but platforms implementing @begin() should
  *	also provide a @end() which cleans up transitions aborted before
  *	@enter().
+ *
+ * @recover: Recover the platform from a suspend failure.
+ *	Called by the PM core if the suspending of devices fails.
+ *	This callback is optional and should only be implemented by platforms
+ *	which require special recovery actions in that situation.
  */
 struct platform_suspend_ops {
 	int (*valid)(suspend_state_t state);
@@ -94,6 +99,7 @@ struct platform_suspend_ops {
 	int (*enter)(suspend_state_t state);
 	void (*finish)(void);
 	void (*end)(void);
+	void (*recover)(void);
 };
 
 #ifdef CONFIG_SUSPEND
@@ -149,7 +155,7 @@ extern void mark_free_pages(struct zone *zone);
  * The methods in this structure allow a platform to carry out special
  * operations required by it during a hibernation transition.
  *
- * All the methods below must be implemented.
+ * All the methods below, except for @recover(), must be implemented.
  *
  * @begin: Tell the platform driver that we're starting hibernation.
  *	Called right after shrinking memory and before freezing devices.
@@ -189,6 +195,11 @@ extern void mark_free_pages(struct zone *zone);
  * @restore_cleanup: Clean up after a failing image restoration.
  *	Called right after the nonboot CPUs have been enabled and before
  *	thawing devices (runs with IRQs on).
+ *
+ * @recover: Recover the platform from a failure to suspend devices.
+ *	Called by the PM core if the suspending of devices during hibernation
+ *	fails.  This callback is optional and should only be implemented by
+ *	platforms which require special recovery actions in that situation.
  */
 struct platform_hibernation_ops {
 	int (*begin)(void);
@@ -200,6 +211,7 @@ struct platform_hibernation_ops {
 	void (*leave)(void);
 	int (*pre_restore)(void);
 	void (*restore_cleanup)(void);
+	void (*recover)(void);
 };
 
 #ifdef CONFIG_HIBERNATION

commit b6f448e99ce7955b9707ed36a46cab2c6ddf7ddc
Author: Andres Salomon <dilinger@queued.net>
Date:   Mon Apr 28 02:15:03 2008 -0700

    PM/gxfb: add hook to PM console layer that allows disabling of suspend VT switch
    
    Prior to suspend, we allocate and switch to a new VT; after suspend, we switch
    back to the original VT.  This can be slow, and is completely unnecessary if
    the framebuffer we're using can restore video properly.
    
    This adds a hook that allows drivers to select whether or not to do this vt
    switch, and changes the gxfb driver to call this hook.  It also adds a module
    param to gxfb to allow controlling of the vt switch (defaulting to no switch).
    
    (Note: I'm not convinced that console_sem is the best way to protect this, but
    we should probably have some form of locking..)
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Andres Salomon <dilinger@debian.org>
    Cc: Jordan Crouse <jordan.crouse@amd.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 1d7d4c5797ee..a6977423baf7 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -12,11 +12,22 @@
 #include <asm/errno.h>
 
 #if defined(CONFIG_PM_SLEEP) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+extern void pm_set_vt_switch(int);
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
 #else
-static inline int pm_prepare_console(void) { return 0; }
-static inline void pm_restore_console(void) {}
+static inline void pm_set_vt_switch(int do_switch)
+{
+}
+
+static inline int pm_prepare_console(void)
+{
+	return 0;
+}
+
+static inline void pm_restore_console(void)
+{
+}
 #endif
 
 typedef int __bitwise suspend_state_t;

commit 9f8f2172537de7af0b0fbd33502d18d52b1339bc
Author: Christoph Lameter <clameter@sgi.com>
Date:   Mon Feb 4 22:29:11 2008 -0800

    Page allocator: clean up pcp draining functions
    
    - Add comments explaing how drain_pages() works.
    
    - Eliminate useless functions
    
    - Rename drain_all_local_pages to drain_all_pages(). It does drain
      all pages not only those of the local processor.
    
    - Eliminate useless interrupt off / on sequences. drain_pages()
      disables interrupts on its own. The execution thread is
      pinned to processor by the caller. So there is no need to
      disable interrupts.
    
    - Put drain_all_pages() declaration in gfp.h and remove the
      declarations from suspend.h and from mm/memory_hotplug.c
    
    - Make software suspend call drain_all_pages(). The draining
      of processor local pages is may not the right approach if
      software suspend wants to support SMP. If they call drain_all_pages
      then we can make drain_pages() static.
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Acked-by: Mel Gorman <mel@csn.ul.ie>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Daniel Walker <dwalker@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 646ce2d068d4..1d7d4c5797ee 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -130,7 +130,6 @@ struct pbe {
 };
 
 /* mm/page_alloc.c */
-extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
 
 /**

commit caea99ef339af8e07cda8d03fa415e4b8820f400
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 8 00:08:44 2008 +0100

    Hibernation: Introduce begin() and end() callbacks
    
    Introduce global hibernation callback .end() and rename global
    hibernation callback .start() to .begin(), in analogy with the
    recent modifications of the global suspend callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index a0b1dbb5919f..646ce2d068d4 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -136,14 +136,17 @@ extern void mark_free_pages(struct zone *zone);
 /**
  * struct platform_hibernation_ops - hibernation platform support
  *
- * The methods in this structure allow a platform to override the default
- * mechanism of shutting down the machine during a hibernation transition.
+ * The methods in this structure allow a platform to carry out special
+ * operations required by it during a hibernation transition.
  *
- * All three methods must be assigned.
+ * All the methods below must be implemented.
  *
- * @start: Tell the platform driver that we're starting hibernation.
+ * @begin: Tell the platform driver that we're starting hibernation.
  *	Called right after shrinking memory and before freezing devices.
  *
+ * @end: Called by the PM core right after resuming devices, to indicate to
+ *	the platform that the system has returned to the working state.
+ *
  * @pre_snapshot: Prepare the platform for creating the hibernation image.
  *	Called right after devices have been frozen and before the nonboot
  *	CPUs are disabled (runs with IRQs on).
@@ -178,7 +181,8 @@ extern void mark_free_pages(struct zone *zone);
  *	thawing devices (runs with IRQs on).
  */
 struct platform_hibernation_ops {
-	int (*start)(void);
+	int (*begin)(void);
+	void (*end)(void);
 	int (*pre_snapshot)(void);
 	void (*finish)(void);
 	int (*prepare)(void);

commit c697eecebc6cfc0b393afea3c4ff1a5041526ad1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 8 00:04:17 2008 +0100

    Suspend: Introduce begin() and end() callbacks
    
    On ACPI systems the target state set by acpi_pm_set_target() is
    reset by acpi_pm_finish(), but that need not be called if the
    suspend fails. All platforms that use the .set_target() global
    suspend callback are affected by analogous issues.
    
    For this reason, we need an additional global suspend callback that
    will reset the target state regardless of whether or not the suspend
    is successful. Also, it is reasonable to rename the .set_target()
    callback, since it will be used for a different purpose on ACPI
    systems (due to ACPI 1.0x code ordering requirements).
    
    Introduce the global suspend callback .end() to be executed at the
    end of the suspend sequence and rename the .set_target() global
    suspend callback to .begin().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 51283e0745b3..a0b1dbb5919f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -38,18 +38,16 @@ typedef int __bitwise suspend_state_t;
  *	There is the %suspend_valid_only_mem function available that can be
  *	assigned to this if the platform only supports mem sleep.
  *
- * @set_target: Tell the platform which system sleep state is going to be
- *	entered.
- *	@set_target() is executed right prior to suspending devices.  The
- *	information conveyed to the platform code by @set_target() should be
- *	disregarded by the platform as soon as @finish() is executed and if
- *	@prepare() fails.  If @set_target() fails (ie. returns nonzero),
+ * @begin: Initialise a transition to given system sleep state.
+ *	@begin() is executed right prior to suspending devices.  The information
+ *	conveyed to the platform code by @begin() should be disregarded by it as
+ *	soon as @end() is executed.  If @begin() fails (ie. returns nonzero),
  *	@prepare(), @enter() and @finish() will not be called by the PM core.
  *	This callback is optional.  However, if it is implemented, the argument
- *	passed to @enter() is meaningless and should be ignored.
+ *	passed to @enter() is redundant and should be ignored.
  *
  * @prepare: Prepare the platform for entering the system sleep state indicated
- *	by @set_target().
+ *	by @begin().
  *	@prepare() is called right after devices have been suspended (ie. the
  *	appropriate .suspend() method has been executed for each device) and
  *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
@@ -57,8 +55,8 @@ typedef int __bitwise suspend_state_t;
  *	error code otherwise, in which case the system cannot enter the desired
  *	sleep state (@enter() and @finish() will not be called in that case).
  *
- * @enter: Enter the system sleep state indicated by @set_target() or
- *	represented by the argument if @set_target() is not implemented.
+ * @enter: Enter the system sleep state indicated by @begin() or represented by
+ *	the argument if @begin() is not implemented.
  *	This callback is mandatory.  It returns 0 on success or a negative
  *	error code otherwise, in which case the system cannot enter the desired
  *	sleep state.
@@ -69,13 +67,22 @@ typedef int __bitwise suspend_state_t;
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare().  If implemented, it is always called after
  *	@enter() (even if @enter() fails).
+ *
+ * @end: Called by the PM core right after resuming devices, to indicate to
+ *	the platform that the system has returned to the working state or
+ *	the transition to the sleep state has been aborted.
+ *	This callback is optional, but should be implemented by the platforms
+ *	that implement @begin(), but platforms implementing @begin() should
+ *	also provide a @end() which cleans up transitions aborted before
+ *	@enter().
  */
 struct platform_suspend_ops {
 	int (*valid)(suspend_state_t state);
-	int (*set_target)(suspend_state_t state);
+	int (*begin)(suspend_state_t state);
 	int (*prepare)(void);
 	int (*enter)(suspend_state_t state);
 	void (*finish)(void);
+	void (*end)(void);
 };
 
 #ifdef CONFIG_SUSPEND

commit 825257569350e913bee3bc918508c0aa6e3398cd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 19 23:49:18 2007 +0100

    PM: Convert PM notifiers to out-of-line code
    
    This patch (as1008b) converts the PM notifier routines from inline
    calls to out-of-line code.  It also prevents pm_chain_head from
    being created when CONFIG_PM_SLEEP isn't enabled, and EXPORTs the
    notifier registration and unregistration routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 40280df2a3db..51283e0745b3 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -213,17 +213,8 @@ void save_processor_state(void);
 void restore_processor_state(void);
 
 /* kernel/power/main.c */
-extern struct blocking_notifier_head pm_chain_head;
-
-static inline int register_pm_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&pm_chain_head, nb);
-}
-
-static inline int unregister_pm_notifier(struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&pm_chain_head, nb);
-}
+extern int register_pm_notifier(struct notifier_block *nb);
+extern int unregister_pm_notifier(struct notifier_block *nb);
 
 #define pm_notifier(fn, pri) {				\
 	static struct notifier_block fn##_nb =			\

commit cae4595764cb3b08f6517e99bac1e3862854b1a1
Author: Jan Beulich <jbeulich@novell.com>
Date:   Wed Jan 30 13:31:23 2008 +0100

    x86: make __{save,restore}_processor_state static
    
    .. allowing to remove their declarations from a global include file
    (the symbols don't exist for anything but x86).
    
    Likewise for 64-bits' fix_processor_context(), just that that one was
    properly declared in an arch-specific header.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 4360e0816956..40280df2a3db 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -211,9 +211,6 @@ static inline int hibernate(void) { return -ENOSYS; }
 #ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
 void restore_processor_state(void);
-struct saved_context;
-void __save_processor_state(struct saved_context *ctxt);
-void __restore_processor_state(struct saved_context *ctxt);
 
 /* kernel/power/main.c */
 extern struct blocking_notifier_head pm_chain_head;

commit c7e0831d385d620a58d95b25e4afa9b643f9a411
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:55 2007 -0700

    Hibernation: Check if ACPI is enabled during restore in the right place
    
    The following scenario leads to total confusion of the platform firmware on
    some boxes (eg. HPC nx6325):
    * Hibernate with ACPI enabled
    * Resume passing "acpi=off" to the boot kernel
    
    To prevent this from happening it's necessary to check if ACPI is enabled (and
    enable it if that's not the case) _right_ _after_ control has been transfered
    from the boot kernel to the image kernel, before device_power_up() is called
    (ie.  with interrupts disabled).  Enabling ACPI after calling
    device_power_up() turns out to be insufficient.
    
    For this reason, introduce new hibernation callback ->leave() that will be
    executed before device_power_up() by the restored image kernel.  To make it
    work, it also is necessary to move swsusp_suspend() from swsusp.c to disk.c
    (it's name is changed to "create_image", which is more up to the point).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 9fd2b9acf7d9..4360e0816956 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -156,6 +156,12 @@ extern void mark_free_pages(struct zone *zone);
  *	Called after the nonboot CPUs have been disabled and all of the low
  *	level devices have been shut down (runs with IRQs off).
  *
+ * @leave: Perform the first stage of the cleanup after the system sleep state
+ *	indicated by @set_target() has been left.
+ *	Called right after the control has been passed from the boot kernel to
+ *	the image kernel, before the nonboot CPUs are enabled and before devices
+ *	are resumed.  Executed with interrupts disabled.
+ *
  * @pre_restore: Prepare system for the restoration from a hibernation image.
  *	Called right after devices have been frozen and before the nonboot
  *	CPUs are disabled (runs with IRQs on).
@@ -170,6 +176,7 @@ struct platform_hibernation_ops {
 	void (*finish)(void);
 	int (*prepare)(void);
 	int (*enter)(void);
+	void (*leave)(void);
 	int (*pre_restore)(void);
 	void (*restore_cleanup)(void);
 };

commit b3dac3b304bdfbb06e92b0d4bba9ecab006795e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:43 2007 -0700

    PM: Rename hibernation_ops to platform_hibernation_ops
    
    Rename 'struct hibernation_ops' to 'struct platform_hibernation_ops' in
    analogy with 'struct platform_suspend_ops'.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 0044483dd477..9fd2b9acf7d9 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -127,7 +127,7 @@ extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
 
 /**
- * struct hibernation_ops - hibernation platform support
+ * struct platform_hibernation_ops - hibernation platform support
  *
  * The methods in this structure allow a platform to override the default
  * mechanism of shutting down the machine during a hibernation transition.
@@ -164,7 +164,7 @@ extern void mark_free_pages(struct zone *zone);
  *	Called right after the nonboot CPUs have been enabled and before
  *	thawing devices (runs with IRQs on).
  */
-struct hibernation_ops {
+struct platform_hibernation_ops {
 	int (*start)(void);
 	int (*pre_snapshot)(void);
 	void (*finish)(void);
@@ -190,14 +190,14 @@ extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
 
-extern void hibernation_set_ops(struct hibernation_ops *ops);
+extern void hibernation_set_ops(struct platform_hibernation_ops *ops);
 extern int hibernate(void);
 #else /* CONFIG_HIBERNATION */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
 
-static inline void hibernation_set_ops(struct hibernation_ops *ops) {}
+static inline void hibernation_set_ops(struct platform_hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
 #endif /* CONFIG_HIBERNATION */
 

commit 74f270af0c1ed5b9d4413784256959dcfe3593ce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:42 2007 -0700

    PM: Rework struct hibernation_ops
    
    During hibernation we also need to tell the ACPI core that we're going to put
    the system into the S4 sleep state.  For this reason, an additional method in
    'struct hibernation_ops' is needed, playing the role of set_target() in
    'struct platform_suspend_operations'.  Moreover, the role of the .prepare()
    method is now different, so it's better to introduce another method, that in
    general may be different from .prepare(), that will be used to prepare the
    platform for creating the hibernation image (.prepare() is used anyway to
    notify the platform that we're going to enter the low power state after the
    image has been saved).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index dee416c5477f..0044483dd477 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -134,16 +134,42 @@ extern void mark_free_pages(struct zone *zone);
  *
  * All three methods must be assigned.
  *
- * @prepare: prepare system for hibernation
- * @enter: shut down system after state has been saved to disk
- * @finish: finish/clean up after state has been reloaded
- * @pre_restore: prepare system for the restoration from a hibernation image
- * @restore_cleanup: clean up after a failing image restoration
+ * @start: Tell the platform driver that we're starting hibernation.
+ *	Called right after shrinking memory and before freezing devices.
+ *
+ * @pre_snapshot: Prepare the platform for creating the hibernation image.
+ *	Called right after devices have been frozen and before the nonboot
+ *	CPUs are disabled (runs with IRQs on).
+ *
+ * @finish: Restore the previous state of the platform after the hibernation
+ *	image has been created *or* put the platform into the normal operation
+ *	mode after the hibernation (the same method is executed in both cases).
+ *	Called right after the nonboot CPUs have been enabled and before
+ *	thawing devices (runs with IRQs on).
+ *
+ * @prepare: Prepare the platform for entering the low power state.
+ *	Called right after the hibernation image has been saved and before
+ *	devices are prepared for entering the low power state.
+ *
+ * @enter: Put the system into the low power state after the hibernation image
+ *	has been saved to disk.
+ *	Called after the nonboot CPUs have been disabled and all of the low
+ *	level devices have been shut down (runs with IRQs off).
+ *
+ * @pre_restore: Prepare system for the restoration from a hibernation image.
+ *	Called right after devices have been frozen and before the nonboot
+ *	CPUs are disabled (runs with IRQs on).
+ *
+ * @restore_cleanup: Clean up after a failing image restoration.
+ *	Called right after the nonboot CPUs have been enabled and before
+ *	thawing devices (runs with IRQs on).
  */
 struct hibernation_ops {
+	int (*start)(void);
+	int (*pre_snapshot)(void);
+	void (*finish)(void);
 	int (*prepare)(void);
 	int (*enter)(void);
-	void (*finish)(void);
 	int (*pre_restore)(void);
 	void (*restore_cleanup)(void);
 };

commit f242d9196fd1ef4e6bf0e50d2e7f32866fb145c2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:41 2007 -0700

    PM: Make suspend_ops static
    
    The variable suspend_ops representing the set of global platform-specific
    suspend-related operations, used by the PM core, need not be exported outside
    of kernel/power/main.c .  Make it static.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 541f0c46d34f..dee416c5477f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -79,8 +79,6 @@ struct platform_suspend_ops {
 };
 
 #ifdef CONFIG_SUSPEND
-extern struct platform_suspend_ops *suspend_ops;
-
 /**
  * suspend_set_ops - set platform dependent suspend operations
  * @ops: The new suspend operations to set.

commit e6c5eb9541f2197a3ffab90b1c7a3250a9b51bf6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:41 2007 -0700

    PM: Rework struct platform_suspend_ops
    
    There is no reason why the .prepare() and .finish() methods in 'struct
    platform_suspend_ops' should take any arguments, since architectures don't use
    these methods' argument in any practically meaningful way (ie.  either the
    target system sleep state is conveyed to the platform by .set_target(), or
    there is only one suspend state supported and it is indicated to the PM core
    by .valid(), or .prepare() and .finish() aren't defined at all).  There also
    is no reason why .finish() should return any result.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index dce47825dbb8..541f0c46d34f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -46,12 +46,10 @@ typedef int __bitwise suspend_state_t;
  *	@prepare() fails.  If @set_target() fails (ie. returns nonzero),
  *	@prepare(), @enter() and @finish() will not be called by the PM core.
  *	This callback is optional.  However, if it is implemented, the argument
- *	passed to @prepare(), @enter() and @finish() is meaningless and should
- *	be ignored.
+ *	passed to @enter() is meaningless and should be ignored.
  *
  * @prepare: Prepare the platform for entering the system sleep state indicated
- *	by @set_target() or represented by the argument if @set_target() is not
- *	implemented.
+ *	by @set_target().
  *	@prepare() is called right after devices have been suspended (ie. the
  *	appropriate .suspend() method has been executed for each device) and
  *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
@@ -67,8 +65,7 @@ typedef int __bitwise suspend_state_t;
  *
  * @finish: Called when the system has just left a sleep state, right after
  *	the nonboot CPUs have been enabled and before devices are resumed (it is
- *	executed with IRQs enabled).  If @set_target() is not implemented, the
- *	argument represents the sleep state being left.
+ *	executed with IRQs enabled).
  *	This callback is optional, but should be implemented by the platforms
  *	that implement @prepare().  If implemented, it is always called after
  *	@enter() (even if @enter() fails).
@@ -76,9 +73,9 @@ typedef int __bitwise suspend_state_t;
 struct platform_suspend_ops {
 	int (*valid)(suspend_state_t state);
 	int (*set_target)(suspend_state_t state);
-	int (*prepare)(suspend_state_t state);
+	int (*prepare)(void);
 	int (*enter)(suspend_state_t state);
-	int (*finish)(suspend_state_t state);
+	void (*finish)(void);
 };
 
 #ifdef CONFIG_SUSPEND

commit 26398a70ea35f153feb799fa850c71685667712b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:40 2007 -0700

    PM: Rename struct pm_ops and related things
    
    The name of 'struct pm_ops' suggests that it is related to the power
    management in general, but in fact it is only related to suspend.  Moreover,
    its name should indicate what this structure is used for, so it seems
    reasonable to change it to 'struct platform_suspend_ops'.  In that case, the
    name of the global variable of this type used by the PM core and the names of
    related functions should be changed accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index c230680d5252..dce47825dbb8 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -27,16 +27,16 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
 /**
- * struct pm_ops - Callbacks for managing platform dependent system sleep
- *	states.
+ * struct platform_suspend_ops - Callbacks for managing platform dependent
+ *	system sleep states.
  *
  * @valid: Callback to determine if given system sleep state is supported by
  *	the platform.
  *	Valid (ie. supported) states are advertised in /sys/power/state.  Note
  *	that it still may be impossible to enter given system sleep state if the
  *	conditions aren't right.
- *	There is the %pm_valid_only_mem function available that can be assigned
- *	to this if the platform only supports mem sleep.
+ *	There is the %suspend_valid_only_mem function available that can be
+ *	assigned to this if the platform only supports mem sleep.
  *
  * @set_target: Tell the platform which system sleep state is going to be
  *	entered.
@@ -73,7 +73,7 @@ typedef int __bitwise suspend_state_t;
  *	that implement @prepare().  If implemented, it is always called after
  *	@enter() (even if @enter() fails).
  */
-struct pm_ops {
+struct platform_suspend_ops {
 	int (*valid)(suspend_state_t state);
 	int (*set_target)(suspend_state_t state);
 	int (*prepare)(suspend_state_t state);
@@ -82,14 +82,14 @@ struct pm_ops {
 };
 
 #ifdef CONFIG_SUSPEND
-extern struct pm_ops *pm_ops;
+extern struct platform_suspend_ops *suspend_ops;
 
 /**
- * pm_set_ops - set platform dependent power management ops
- * @pm_ops: The new power management operations to set.
+ * suspend_set_ops - set platform dependent suspend operations
+ * @ops: The new suspend operations to set.
  */
-extern void pm_set_ops(struct pm_ops *pm_ops);
-extern int pm_valid_only_mem(suspend_state_t state);
+extern void suspend_set_ops(struct platform_suspend_ops *ops);
+extern int suspend_valid_only_mem(suspend_state_t state);
 
 /**
  * arch_suspend_disable_irqs - disable IRQs for suspend
@@ -113,7 +113,7 @@ extern int pm_suspend(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
 #define suspend_valid_only_mem	NULL
 
-static inline void pm_set_ops(struct pm_ops *pm_ops) {}
+static inline void suspend_set_ops(struct platform_suspend_ops *ops) {}
 static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
 #endif /* !CONFIG_SUSPEND */
 

commit 95d9ffbe01fb21d524c86bf77871255066bc6e55
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:39 2007 -0700

    PM: Move definition of struct pm_ops to suspend.h
    
    Move the definition of 'struct pm_ops' and related functions from <linux/pm.h>
    to <linux/suspend.h> .
    
    There are, at least, the following reasons to do that:
    * 'struct pm_ops' is specifically related to suspend and not to the power
      management in general.
    * As long as 'struct pm_ops' is defined in <linux/pm.h>, any modification of it
      causes the entire kernel to be recompiled, which is unnecessary and annoying.
    * Some suspend-related features are already defined in <linux/suspend.h>, so it
      is logical to move the definition of 'struct pm_ops' into there.
    * 'struct hibernation_ops', being the hibernation-related counterpart of
      'struct pm_ops', is defined in <linux/suspend.h> .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 388cace9751f..c230680d5252 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -1,5 +1,5 @@
-#ifndef _LINUX_SWSUSP_H
-#define _LINUX_SWSUSP_H
+#ifndef _LINUX_SUSPEND_H
+#define _LINUX_SUSPEND_H
 
 #if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
 #include <asm/suspend.h>
@@ -9,6 +9,113 @@
 #include <linux/init.h>
 #include <linux/pm.h>
 #include <linux/mm.h>
+#include <asm/errno.h>
+
+#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+#else
+static inline int pm_prepare_console(void) { return 0; }
+static inline void pm_restore_console(void) {}
+#endif
+
+typedef int __bitwise suspend_state_t;
+
+#define PM_SUSPEND_ON		((__force suspend_state_t) 0)
+#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
+#define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
+#define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
+
+/**
+ * struct pm_ops - Callbacks for managing platform dependent system sleep
+ *	states.
+ *
+ * @valid: Callback to determine if given system sleep state is supported by
+ *	the platform.
+ *	Valid (ie. supported) states are advertised in /sys/power/state.  Note
+ *	that it still may be impossible to enter given system sleep state if the
+ *	conditions aren't right.
+ *	There is the %pm_valid_only_mem function available that can be assigned
+ *	to this if the platform only supports mem sleep.
+ *
+ * @set_target: Tell the platform which system sleep state is going to be
+ *	entered.
+ *	@set_target() is executed right prior to suspending devices.  The
+ *	information conveyed to the platform code by @set_target() should be
+ *	disregarded by the platform as soon as @finish() is executed and if
+ *	@prepare() fails.  If @set_target() fails (ie. returns nonzero),
+ *	@prepare(), @enter() and @finish() will not be called by the PM core.
+ *	This callback is optional.  However, if it is implemented, the argument
+ *	passed to @prepare(), @enter() and @finish() is meaningless and should
+ *	be ignored.
+ *
+ * @prepare: Prepare the platform for entering the system sleep state indicated
+ *	by @set_target() or represented by the argument if @set_target() is not
+ *	implemented.
+ *	@prepare() is called right after devices have been suspended (ie. the
+ *	appropriate .suspend() method has been executed for each device) and
+ *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
+ *	This callback is optional.  It returns 0 on success or a negative
+ *	error code otherwise, in which case the system cannot enter the desired
+ *	sleep state (@enter() and @finish() will not be called in that case).
+ *
+ * @enter: Enter the system sleep state indicated by @set_target() or
+ *	represented by the argument if @set_target() is not implemented.
+ *	This callback is mandatory.  It returns 0 on success or a negative
+ *	error code otherwise, in which case the system cannot enter the desired
+ *	sleep state.
+ *
+ * @finish: Called when the system has just left a sleep state, right after
+ *	the nonboot CPUs have been enabled and before devices are resumed (it is
+ *	executed with IRQs enabled).  If @set_target() is not implemented, the
+ *	argument represents the sleep state being left.
+ *	This callback is optional, but should be implemented by the platforms
+ *	that implement @prepare().  If implemented, it is always called after
+ *	@enter() (even if @enter() fails).
+ */
+struct pm_ops {
+	int (*valid)(suspend_state_t state);
+	int (*set_target)(suspend_state_t state);
+	int (*prepare)(suspend_state_t state);
+	int (*enter)(suspend_state_t state);
+	int (*finish)(suspend_state_t state);
+};
+
+#ifdef CONFIG_SUSPEND
+extern struct pm_ops *pm_ops;
+
+/**
+ * pm_set_ops - set platform dependent power management ops
+ * @pm_ops: The new power management operations to set.
+ */
+extern void pm_set_ops(struct pm_ops *pm_ops);
+extern int pm_valid_only_mem(suspend_state_t state);
+
+/**
+ * arch_suspend_disable_irqs - disable IRQs for suspend
+ *
+ * Disables IRQs (in the default case). This is a weak symbol in the common
+ * code and thus allows architectures to override it if more needs to be
+ * done. Not called for suspend to disk.
+ */
+extern void arch_suspend_disable_irqs(void);
+
+/**
+ * arch_suspend_enable_irqs - enable IRQs after suspend
+ *
+ * Enables IRQs (in the default case). This is a weak symbol in the common
+ * code and thus allows architectures to override it if more needs to be
+ * done. Not called for suspend to disk.
+ */
+extern void arch_suspend_enable_irqs(void);
+
+extern int pm_suspend(suspend_state_t state);
+#else /* !CONFIG_SUSPEND */
+#define suspend_valid_only_mem	NULL
+
+static inline void pm_set_ops(struct pm_ops *pm_ops) {}
+static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+#endif /* !CONFIG_SUSPEND */
 
 /* struct pbe is used for creating lists of pages that should be restored
  * atomically during the resume from disk, because the page frames they have
@@ -24,14 +131,6 @@ struct pbe {
 extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
 
-#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
-#else
-static inline int pm_prepare_console(void) { return 0; }
-static inline void pm_restore_console(void) {}
-#endif
-
 /**
  * struct hibernation_ops - hibernation platform support
  *
@@ -130,4 +229,4 @@ static inline void register_nosave_region_late(unsigned long b, unsigned long e)
 }
 #endif
 
-#endif /* _LINUX_SWSUSP_H */
+#endif /* _LINUX_SUSPEND_H */

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d16c1b85d512..388cace9751f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -24,7 +24,7 @@ struct pbe {
 extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
 
-#if defined(CONFIG_PM) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#if defined(CONFIG_PM_SLEEP) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
 #else
@@ -54,7 +54,6 @@ struct hibernation_ops {
 	void (*restore_cleanup)(void);
 };
 
-#ifdef CONFIG_PM
 #ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */
 extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
@@ -82,6 +81,7 @@ static inline void hibernation_set_ops(struct hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
 #endif /* CONFIG_HIBERNATION */
 
+#ifdef CONFIG_PM_SLEEP
 void save_processor_state(void);
 void restore_processor_state(void);
 struct saved_context;
@@ -106,7 +106,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 		{ .notifier_call = fn, .priority = pri };	\
 	register_pm_notifier(&fn##_nb);			\
 }
-#else /* CONFIG_PM */
+#else /* !CONFIG_PM_SLEEP */
 
 static inline int register_pm_notifier(struct notifier_block *nb)
 {
@@ -119,9 +119,9 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 }
 
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
-#endif /* CONFIG_PM */
+#endif /* !CONFIG_PM_SLEEP */
 
-#if !defined CONFIG_HIBERNATION || !defined(CONFIG_PM)
+#ifndef CONFIG_HIBERNATION
 static inline void register_nosave_region(unsigned long b, unsigned long e)
 {
 }

commit b0cb1a19d05b8ea8611a9ef48a17fe417f1832e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:24:36 2007 +0200

    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION
    
    Replace CONFIG_SOFTWARE_SUSPEND with CONFIG_HIBERNATION to avoid
    confusion (among other things, with CONFIG_SUSPEND introduced in the
    next patch).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 618f93c32b7f..d16c1b85d512 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -55,7 +55,7 @@ struct hibernation_ops {
 };
 
 #ifdef CONFIG_PM
-#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef CONFIG_HIBERNATION
 /* kernel/power/snapshot.c */
 extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
 static inline void register_nosave_region(unsigned long b, unsigned long e)
@@ -73,14 +73,14 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 
 extern void hibernation_set_ops(struct hibernation_ops *ops);
 extern int hibernate(void);
-#else /* CONFIG_SOFTWARE_SUSPEND */
+#else /* CONFIG_HIBERNATION */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
 
 static inline void hibernation_set_ops(struct hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
-#endif /* CONFIG_SOFTWARE_SUSPEND */
+#endif /* CONFIG_HIBERNATION */
 
 void save_processor_state(void);
 void restore_processor_state(void);
@@ -121,7 +121,7 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 #define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
 #endif /* CONFIG_PM */
 
-#if !defined CONFIG_SOFTWARE_SUSPEND || !defined(CONFIG_PM)
+#if !defined CONFIG_HIBERNATION || !defined(CONFIG_PM)
 static inline void register_nosave_region(unsigned long b, unsigned long e)
 {
 }

commit 70f38db60cc5c8c6c3a95f0d2e6360272d6014a3
Author: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
Date:   Thu Jul 26 10:40:59 2007 -0700

    PM: fix compiler error of PPC dart_iommu
    
    A dummy inline function of register_nosave_region_late was accidentally
    removed by the recent PM patch that introduced suspend notifiers.
    This elimination causes the following compiler error on PPC machines.
    
      CC      arch/powerpc/sysdev/dart_iommu.o
    arch/powerpc/sysdev/dart_iommu.c: In function 'iommu_init_late_dart':
    arch/powerpc/sysdev/dart_iommu.c:376: error: implicit declaration of function
    'register_nosave_region_late'
    make[1]: *** [arch/powerpc/sysdev/dart_iommu.o] Error 1
    make: *** [arch/powerpc/sysdev] Error 2
    
    This patch fixes the problem.
    
    Signed-off-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e8e6da394c92..618f93c32b7f 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -125,6 +125,9 @@ static inline int unregister_pm_notifier(struct notifier_block *nb)
 static inline void register_nosave_region(unsigned long b, unsigned long e)
 {
 }
+static inline void register_nosave_region_late(unsigned long b, unsigned long e)
+{
+}
 #endif
 
 #endif /* _LINUX_SWSUSP_H */

commit b10d911749d37dccfa5873d2088aea3f074b9e45
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:36 2007 -0700

    PM: introduce hibernation and suspend notifiers
    
    Make it possible to register hibernation and suspend notifiers, so that
    subsystems can perform hibernation-related or suspend-related operations that
    should not be carried out by device drivers' .suspend() and .resume()
    routines.
    
    [akpm@linux-foundation.org: build fixes]
    [akpm@linux-foundation.org: cleanups]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index d235c146da2b..e8e6da394c92 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -54,7 +54,8 @@ struct hibernation_ops {
 	void (*restore_cleanup)(void);
 };
 
-#if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)
+#ifdef CONFIG_PM
+#ifdef CONFIG_SOFTWARE_SUSPEND
 /* kernel/power/snapshot.c */
 extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
 static inline void register_nosave_region(unsigned long b, unsigned long e)
@@ -72,16 +73,14 @@ extern unsigned long get_safe_page(gfp_t gfp_mask);
 
 extern void hibernation_set_ops(struct hibernation_ops *ops);
 extern int hibernate(void);
-#else
-static inline void register_nosave_region(unsigned long b, unsigned long e) {}
-static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}
+#else /* CONFIG_SOFTWARE_SUSPEND */
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
 
 static inline void hibernation_set_ops(struct hibernation_ops *ops) {}
 static inline int hibernate(void) { return -ENOSYS; }
-#endif /* defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND) */
+#endif /* CONFIG_SOFTWARE_SUSPEND */
 
 void save_processor_state(void);
 void restore_processor_state(void);
@@ -89,4 +88,43 @@ struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
 
+/* kernel/power/main.c */
+extern struct blocking_notifier_head pm_chain_head;
+
+static inline int register_pm_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&pm_chain_head, nb);
+}
+
+static inline int unregister_pm_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&pm_chain_head, nb);
+}
+
+#define pm_notifier(fn, pri) {				\
+	static struct notifier_block fn##_nb =			\
+		{ .notifier_call = fn, .priority = pri };	\
+	register_pm_notifier(&fn##_nb);			\
+}
+#else /* CONFIG_PM */
+
+static inline int register_pm_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline int unregister_pm_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+#define pm_notifier(fn, pri)	do { (void)(fn); } while (0)
+#endif /* CONFIG_PM */
+
+#if !defined CONFIG_SOFTWARE_SUSPEND || !defined(CONFIG_PM)
+static inline void register_nosave_region(unsigned long b, unsigned long e)
+{
+}
+#endif
+
 #endif /* _LINUX_SWSUSP_H */

commit a634cc10164d1c229fbeca33923e6a0ed939e894
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:30 2007 -0700

    swsusp: introduce restore platform operations
    
    At least on some machines it is necessary to prepare the ACPI firmware for the
    restoration of the system memory state from the hibernation image if the
    "platform" mode of hibernation has been used.  Namely, in that cases we need
    to disable the GPEs before replacing the "boot" kernel with the "frozen"
    kernel (cf.  http://bugzilla.kernel.org/show_bug.cgi?id=7887).  After the
    restore they will be re-enabled by hibernation_ops->finish(), but if the
    restore fails, they have to be re-enabled by the restore code explicitly.
    
    For this purpose we can introduce two additional hibernation operations,
    called pre_restore() and restore_cleanup() and call them from the restore code
    path.  Still, they should be called if the "platform" mode of hibernation has
    been used, so we need to pass the information about the hibernation mode from
    the "frozen" kernel to the "boot" kernel in the image header.
    
    Apparently, we can't drop the disabling of GPEs before the restore because of
    Bug #7887 .  We also can't do it unconditionally, because the GPEs wouldn't
    have been enabled after a successful restore if the suspend had been done in
    the 'shutdown' or 'reboot' mode.
    
    In principle we could (and probably should) unconditionally disable the GPEs
    before each snapshot creation *and* before the restore, but then we'd have to
    unconditionally enable them after the snapshot creation as well as after the
    restore (or restore failure)  Still, for this purpose we'd need to modify
    acpi_enter_sleep_state_prep() and acpi_leave_sleep_state() and we'd have to
    introduce some mechanism synchronizing the disablind/enabling of the GPEs with
    the device drivers' .suspend()/.resume() routines and with
    disable_/enable_nonboot_cpus().  However, this would have affected the
    suspend (ie.  s2ram) code as well as the hibernation, which I'd like to avoid
    in this patch series.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 9c7cb6430666..d235c146da2b 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -43,11 +43,15 @@ static inline void pm_restore_console(void) {}
  * @prepare: prepare system for hibernation
  * @enter: shut down system after state has been saved to disk
  * @finish: finish/clean up after state has been reloaded
+ * @pre_restore: prepare system for the restoration from a hibernation image
+ * @restore_cleanup: clean up after a failing image restoration
  */
 struct hibernation_ops {
 	int (*prepare)(void);
 	int (*enter)(void);
 	void (*finish)(void);
+	int (*pre_restore)(void);
+	void (*restore_cleanup)(void);
 };
 
 #if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)

commit aabded9c3aab5160ae2ca3dd1fa0fa37f3d510e4
Merge: 9a9136e270af f1a1eb299a84
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed May 9 12:56:01 2007 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc:
      [POWERPC] Further fixes for the removal of 4level-fixup hack from ppc32
      [POWERPC] EEH: log all PCI-X and PCI-E AER registers
      [POWERPC] EEH: capture and log pci state on error
      [POWERPC] EEH: Split up long error msg
      [POWERPC] EEH: log error only after driver notification.
      [POWERPC] fsl_soc: Make mac_addr const in fs_enet_of_init().
      [POWERPC] Don't use SLAB/SLUB for PTE pages
      [POWERPC] Spufs support for 64K LS mappings on 4K kernels
      [POWERPC] Add ability to 4K kernel to hash in 64K pages
      [POWERPC] Introduce address space "slices"
      [POWERPC] Small fixes & cleanups in segment page size demotion
      [POWERPC] iSeries: Make HVC_ISERIES the default
      [POWERPC] iSeries: suppress build warning in lparmap.c
      [POWERPC] Mark pages that don't exist as nosave
      [POWERPC] swsusp: Introduce register_nosave_region_late

commit a3d25c275d383975504dc53c25b691df59bd3c48
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 9 02:33:18 2007 -0700

    PM: Separate hibernation code from suspend code
    
    [ With Johannes Berg <johannes@sipsolutions.net> ]
    
    Separate the hibernation (aka suspend to disk code) from the other suspend
    code.  In particular:
    
     * Remove the definitions related to hibernation from include/linux/pm.h
     * Introduce struct hibernation_ops and a new hibernate() function to hibernate
       the system, defined in include/linux/suspend.h
     * Separate suspend code in kernel/power/main.c from hibernation-related code
       in kernel/power/disk.c and kernel/power/user.c (with the help of
       hibernation_ops)
     * Switch ACPI (the only user of pm_ops.pm_disk_mode) to hibernation_ops
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 9d2aa1a12aa0..d74da9122b60 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -32,6 +32,24 @@ static inline int pm_prepare_console(void) { return 0; }
 static inline void pm_restore_console(void) {}
 #endif
 
+/**
+ * struct hibernation_ops - hibernation platform support
+ *
+ * The methods in this structure allow a platform to override the default
+ * mechanism of shutting down the machine during a hibernation transition.
+ *
+ * All three methods must be assigned.
+ *
+ * @prepare: prepare system for hibernation
+ * @enter: shut down system after state has been saved to disk
+ * @finish: finish/clean up after state has been reloaded
+ */
+struct hibernation_ops {
+	int (*prepare)(void);
+	int (*enter)(void);
+	void (*finish)(void);
+};
+
 #if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)
 /* kernel/power/snapshot.c */
 extern void __init register_nosave_region(unsigned long, unsigned long);
@@ -39,11 +57,17 @@ extern int swsusp_page_is_forbidden(struct page *);
 extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
+
+extern void hibernation_set_ops(struct hibernation_ops *ops);
+extern int hibernate(void);
 #else
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}
+
+static inline void hibernation_set_ops(struct hibernation_ops *ops) {}
+static inline int hibernate(void) { return -ENOSYS; }
 #endif /* defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND) */
 
 void save_processor_state(void);

commit 940d67f6b95166475ff6e600ef7658e1cd441278
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue May 8 19:23:49 2007 +1000

    [POWERPC] swsusp: Introduce register_nosave_region_late
    
    This patch introduces a new register_nosave_region_late function that
    can be called from initcalls when register_nosave_region can no longer
    be used because it uses bootmem.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 9d2aa1a12aa0..1f2f7ba9e709 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -34,13 +34,22 @@ static inline void pm_restore_console(void) {}
 
 #if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)
 /* kernel/power/snapshot.c */
-extern void __init register_nosave_region(unsigned long, unsigned long);
+extern void __register_nosave_region(unsigned long b, unsigned long e, int km);
+static inline void register_nosave_region(unsigned long b, unsigned long e)
+{
+	__register_nosave_region(b, e, 0);
+}
+static inline void register_nosave_region_late(unsigned long b, unsigned long e)
+{
+	__register_nosave_region(b, e, 1);
+}
 extern int swsusp_page_is_forbidden(struct page *);
 extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
 #else
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
+static inline void register_nosave_region_late(unsigned long b, unsigned long e) {}
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}
 static inline void swsusp_unset_page_free(struct page *p) {}

commit 02bbc0f09c90cefdb2837605c96a66c5ce4ba2e1
Merge: 7487a2245b88 5b94f675f57e
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue May 8 13:37:51 2007 +1000

    Merge branch 'linux-2.6'

commit 56f99bcb52d64d70078b41cc176dd8b6f5763108
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:52 2007 -0700

    swsusp: free more memory
    
    Move the definition of PAGES_FOR_IO to kernel/power/power.h and introduce
    SPARE_PAGES representing the number of pages that should be freed by the
    swsusp's memory shrinker in addition to PAGES_FOR_IO so that device drivers
    can allocate some memory (up to 1 MB total) in their .suspend() routines
    without causing the suspend to fail.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 3aecc96acc76..96868be9c211 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -52,10 +52,4 @@ struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
 
-/*
- * XXX: We try to keep some more pages free so that I/O operations succeed
- * without paging. Might this be more?
- */
-#define PAGES_FOR_IO	1024
-
 #endif /* _LINUX_SWSUSP_H */

commit ab3bfca7abf3fd0fe41d26d839610a787aa7e587
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sun May 6 14:50:49 2007 -0700

    remove software_suspend()
    
    Remove software_suspend() and all its users since
    pm_suspend(PM_SUSPEND_DISK) should be equivalent and there's no point in
    having two interfaces for the same thing.
    
    The patch also changes the valid_state function to return 0 (false) for
    PM_SUSPEND_DISK when SOFTWARE_SUSPEND is not configured instead of
    accepting it and having the whole thing fail later.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 3cc4d6394c07..3aecc96acc76 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -33,8 +33,6 @@ static inline void pm_restore_console(void) {}
 #endif
 
 #if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)
-/* kernel/power/swsusp.c */
-extern int software_suspend(void);
 /* kernel/power/snapshot.c */
 extern void __init register_nosave_region(unsigned long, unsigned long);
 extern int swsusp_page_is_forbidden(struct page *);
@@ -42,12 +40,6 @@ extern void swsusp_set_page_free(struct page *);
 extern void swsusp_unset_page_free(struct page *);
 extern unsigned long get_safe_page(gfp_t gfp_mask);
 #else
-static inline int software_suspend(void)
-{
-	printk("Warning: fake suspend called\n");
-	return -ENOSYS;
-}
-
 static inline void register_nosave_region(unsigned long b, unsigned long e) {}
 static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
 static inline void swsusp_set_page_free(struct page *p) {}

commit 74dfd666de861c97d47bdbd892f6d21b801d0247
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:43 2007 -0700

    swsusp: do not use page flags
    
    Make swsusp use memory bitmaps instead of page flags for marking 'nosave' and
    free pages.  This allows us to 'recycle' two page flags that can be used for
    other purposes.  Also, the memory needed to store the bitmaps is allocated
    when necessary (ie.  before the suspend) and freed after the resume which is
    more reasonable.
    
    The patch is designed to minimize the amount of changes and there are some
    nice simplifications and optimizations possible on top of it.  I am going to
    implement them separately in the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index a45b9f514492..3cc4d6394c07 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -24,63 +24,41 @@ struct pbe {
 extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
 
-#ifdef CONFIG_PM
-/* kernel/power/swsusp.c */
-extern int software_suspend(void);
-
-#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+#if defined(CONFIG_PM) && defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
 extern int pm_prepare_console(void);
 extern void pm_restore_console(void);
 #else
 static inline int pm_prepare_console(void) { return 0; }
 static inline void pm_restore_console(void) {}
-#endif /* defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE) */
+#endif
+
+#if defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND)
+/* kernel/power/swsusp.c */
+extern int software_suspend(void);
+/* kernel/power/snapshot.c */
+extern void __init register_nosave_region(unsigned long, unsigned long);
+extern int swsusp_page_is_forbidden(struct page *);
+extern void swsusp_set_page_free(struct page *);
+extern void swsusp_unset_page_free(struct page *);
+extern unsigned long get_safe_page(gfp_t gfp_mask);
 #else
 static inline int software_suspend(void)
 {
 	printk("Warning: fake suspend called\n");
 	return -ENOSYS;
 }
-#endif /* CONFIG_PM */
+
+static inline void register_nosave_region(unsigned long b, unsigned long e) {}
+static inline int swsusp_page_is_forbidden(struct page *p) { return 0; }
+static inline void swsusp_set_page_free(struct page *p) {}
+static inline void swsusp_unset_page_free(struct page *p) {}
+#endif /* defined(CONFIG_PM) && defined(CONFIG_SOFTWARE_SUSPEND) */
 
 void save_processor_state(void);
 void restore_processor_state(void);
 struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
-unsigned long get_safe_page(gfp_t gfp_mask);
-
-/* Page management functions for the software suspend (swsusp) */
-
-static inline void swsusp_set_page_forbidden(struct page *page)
-{
-	SetPageNosave(page);
-}
-
-static inline int swsusp_page_is_forbidden(struct page *page)
-{
-	return PageNosave(page);
-}
-
-static inline void swsusp_unset_page_forbidden(struct page *page)
-{
-	ClearPageNosave(page);
-}
-
-static inline void swsusp_set_page_free(struct page *page)
-{
-	SetPageNosaveFree(page);
-}
-
-static inline int swsusp_page_is_free(struct page *page)
-{
-	return PageNosaveFree(page);
-}
-
-static inline void swsusp_unset_page_free(struct page *page)
-{
-	ClearPageNosaveFree(page);
-}
 
 /*
  * XXX: We try to keep some more pages free so that I/O operations succeed

commit 7be9823491ecbaf9700d7d3502cb4b4dd0ed868a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 6 14:50:42 2007 -0700

    swsusp: use inline functions for changing page flags
    
    Replace direct invocations of SetPageNosave(), SetPageNosaveFree() etc.  with
    calls to inline functions that can be changed in subsequent patches without
    modifying the code calling them.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index bf99bd49f8ef..a45b9f514492 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -8,6 +8,7 @@
 #include <linux/notifier.h>
 #include <linux/init.h>
 #include <linux/pm.h>
+#include <linux/mm.h>
 
 /* struct pbe is used for creating lists of pages that should be restored
  * atomically during the resume from disk, because the page frames they have
@@ -49,6 +50,38 @@ void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
 unsigned long get_safe_page(gfp_t gfp_mask);
 
+/* Page management functions for the software suspend (swsusp) */
+
+static inline void swsusp_set_page_forbidden(struct page *page)
+{
+	SetPageNosave(page);
+}
+
+static inline int swsusp_page_is_forbidden(struct page *page)
+{
+	return PageNosave(page);
+}
+
+static inline void swsusp_unset_page_forbidden(struct page *page)
+{
+	ClearPageNosave(page);
+}
+
+static inline void swsusp_set_page_free(struct page *page)
+{
+	SetPageNosaveFree(page);
+}
+
+static inline int swsusp_page_is_free(struct page *page)
+{
+	return PageNosaveFree(page);
+}
+
+static inline void swsusp_unset_page_free(struct page *page)
+{
+	ClearPageNosaveFree(page);
+}
+
 /*
  * XXX: We try to keep some more pages free so that I/O operations succeed
  * without paging. Might this be more?

commit 543b9fd3528f64c4b20439de0edb453764482de7
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu May 3 22:31:38 2007 +1000

    [POWERPC] powermac: Suspend to disk on G5
    
    Powermac G5 suspend to disk implementation.  The code is platform
    agnostic but only tested on powermac, no other 64-bit powerpc
    machines.
    
    Because nvidiafb still breaks suspend I have marked it EXPERIMENTAL on
    powermac and because I can't test it and some lowlevel code will need
    changes it is BROKEN on all other 64-bit platforms.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index bf99bd49f8ef..a34835ae0e75 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -1,7 +1,7 @@
 #ifndef _LINUX_SWSUSP_H
 #define _LINUX_SWSUSP_H
 
-#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32)
+#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
 #include <asm/suspend.h>
 #endif
 #include <linux/swap.h>

commit 8357376d3df21b7d6f857931a57ac50da9c66e26
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 6 20:34:18 2006 -0800

    [PATCH] swsusp: Improve handling of highmem
    
    Currently swsusp saves the contents of highmem pages by copying them to the
    normal zone which is quite inefficient (eg.  it requires two normal pages
    to be used for saving one highmem page).  This may be improved by using
    highmem for saving the contents of saveable highmem pages.
    
    Namely, during the suspend phase of the suspend-resume cycle we try to
    allocate as many free highmem pages as there are saveable highmem pages.
    If there are not enough highmem image pages to store the contents of all of
    the saveable highmem pages, some of them will be stored in the "normal"
    memory.  Next, we allocate as many free "normal" pages as needed to store
    the (remaining) image data.  We use a memory bitmap to mark the allocated
    free pages (ie.  highmem as well as "normal" image pages).
    
    Now, we use another memory bitmap to mark all of the saveable pages
    (highmem as well as "normal") and the contents of the saveable pages are
    copied into the image pages.  Then, the second bitmap is used to save the
    pfns corresponding to the saveable pages and the first one is used to save
    their data.
    
    During the resume phase the pfns of the pages that were saveable during the
    suspend are loaded from the image and used to mark the "unsafe" page
    frames.  Next, we try to allocate as many free highmem page frames as to
    load all of the image data that had been in the highmem before the suspend
    and we allocate so many free "normal" page frames that the total number of
    allocated free pages (highmem and "normal") is equal to the size of the
    image.  While doing this we have to make sure that there will be some extra
    free "normal" and "safe" page frames for two lists of PBEs constructed
    later.
    
    Now, the image data are loaded, if possible, into their "original" page
    frames.  The image data that cannot be written into their "original" page
    frames are loaded into "safe" page frames and their "original" kernel
    virtual addresses, as well as the addresses of the "safe" pages containing
    their copies, are stored in one of two lists of PBEs.
    
    One list of PBEs is for the copies of "normal" suspend pages (ie.  "normal"
    pages that were saveable during the suspend) and it is used in the same way
    as previously (ie.  by the architecture-dependent parts of swsusp).  The
    other list of PBEs is for the copies of highmem suspend pages.  The pages
    in this list are restored (in a reversible way) right before the
    arch-dependent code is called.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index b1237f16ecde..bf99bd49f8ef 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -9,10 +9,13 @@
 #include <linux/init.h>
 #include <linux/pm.h>
 
-/* page backup entry */
+/* struct pbe is used for creating lists of pages that should be restored
+ * atomically during the resume from disk, because the page frames they have
+ * occupied before the suspend are in use.
+ */
 struct pbe {
-	unsigned long address;		/* address of the copy */
-	unsigned long orig_address;	/* original address of page */
+	void *address;		/* address of the copy */
+	void *orig_address;	/* original address of a page */
 	struct pbe *next;
 };
 

commit 940864ddabdb180e02041c4dcd46ba6f9eee732f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:55 2006 -0700

    [PATCH] swsusp: Use memory bitmaps during resume
    
    Make swsusp use memory bitmaps to store its internal information during the
    resume phase of the suspend-resume cycle.
    
    If the pfns of saveable pages are saved during the suspend phase instead of
    the kernel virtual addresses of these pages, we can use them during the resume
    phase directly to set the corresponding bits in a memory bitmap.  Then, this
    bitmap is used to mark the page frames corresponding to the pages that were
    saveable before the suspend (aka "unsafe" page frames).
    
    Next, we allocate as many page frames as needed to store the entire suspend
    image and make sure that there will be some extra free "safe" page frames for
    the list of PBEs constructed later.  Subsequently, the image is loaded and, if
    possible, the data loaded from it are written into their "original" page
    frames (ie.  the ones they had occupied before the suspend).
    
    The image data that cannot be written into their "original" page frames are
    loaded into "safe" page frames and their "original" kernel virtual addresses,
    as well as the addresses of the "safe" pages containing their copies, are
    stored in a list of PBEs.  Finally, the list of PBEs is used to copy the
    remaining image data into their "original" page frames (this is done
    atomically, by the architecture-dependent parts of swsusp).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index c11cacf1a13b..b1237f16ecde 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -16,15 +16,6 @@ struct pbe {
 	struct pbe *next;
 };
 
-#define for_each_pbe(pbe, pblist) \
-	for (pbe = pblist ; pbe ; pbe = pbe->next)
-
-#define PBES_PER_PAGE      (PAGE_SIZE/sizeof(struct pbe))
-#define PB_PAGE_SKIP       (PBES_PER_PAGE-1)
-
-#define for_each_pb_page(pbe, pblist) \
-	for (pbe = pblist ; pbe ; pbe = (pbe+PB_PAGE_SKIP)->next)
-
 /* mm/page_alloc.c */
 extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);

commit dcbb5a54f6e3984efa24772394f2225b11495c55
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:51 2006 -0700

    [PATCH] swsusp: clean up suspend header
    
    Remove some things that are no longer used or defined elsewhere from suspend.h
    and make the inline version of software_suspend() return the right error code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 6e8a06c950f4..c11cacf1a13b 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -10,11 +10,11 @@
 #include <linux/pm.h>
 
 /* page backup entry */
-typedef struct pbe {
+struct pbe {
 	unsigned long address;		/* address of the copy */
 	unsigned long orig_address;	/* original address of page */
 	struct pbe *next;
-} suspend_pagedir_t;
+};
 
 #define for_each_pbe(pbe, pblist) \
 	for (pbe = pblist ; pbe ; pbe = pbe->next)
@@ -25,15 +25,6 @@ typedef struct pbe {
 #define for_each_pb_page(pbe, pblist) \
 	for (pbe = pblist ; pbe ; pbe = (pbe+PB_PAGE_SKIP)->next)
 
-
-#define SWAP_FILENAME_MAXLENGTH	32
-
-
-extern dev_t swsusp_resume_device;
-   
-/* mm/vmscan.c */
-extern int shrink_mem(void);
-
 /* mm/page_alloc.c */
 extern void drain_local_pages(void);
 extern void mark_free_pages(struct zone *zone);
@@ -53,7 +44,7 @@ static inline void pm_restore_console(void) {}
 static inline int software_suspend(void)
 {
 	printk("Warning: fake suspend called\n");
-	return -EPERM;
+	return -ENOSYS;
 }
 #endif /* CONFIG_PM */
 

commit e3920fb42c8ddfe63befb54d95c0e13eabacea9b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 25 23:32:48 2006 -0700

    [PATCH] Disable CPU hotplug during suspend
    
    The current suspend code has to be run on one CPU, so we use the CPU
    hotplug to take the non-boot CPUs offline on SMP machines.  However, we
    should also make sure that these CPUs will not be enabled by someone else
    after we have disabled them.
    
    The functions disable_nonboot_cpus() and enable_nonboot_cpus() are moved to
    kernel/cpu.c, because they now refer to some stuff in there that should
    better be static.  Also it's better if disable_nonboot_cpus() returns an
    error instead of panicking if something goes wrong, and
    enable_nonboot_cpus() has no reason to panic(), because the CPUs may have
    been enabled by the userland before it tries to take them online.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 96e31aa64cc7..6e8a06c950f4 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -57,14 +57,6 @@ static inline int software_suspend(void)
 }
 #endif /* CONFIG_PM */
 
-#ifdef CONFIG_SUSPEND_SMP
-extern void disable_nonboot_cpus(void);
-extern void enable_nonboot_cpus(void);
-#else
-static inline void disable_nonboot_cpus(void) {}
-static inline void enable_nonboot_cpus(void) {}
-#endif
-
 void save_processor_state(void);
 void restore_processor_state(void);
 struct saved_context;

commit 3448097fccdce4ea8f0fcad4f37f502a8cd72e68
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jun 25 18:41:00 2006 -0700

    Revert "swsusp special saveable pages support" commits
    
    This reverts commits
    
      3e3318dee0878d42ed62a19c292a2ac284135db3 [PATCH] swsusp: x86_64 mark special saveable/unsaveable pages
      b6370d96e09944c6e3ae8d5743ca8a8ab1f79f6c [PATCH] swsusp: i386 mark special saveable/unsaveable pages
      ce4ab0012b32c1a4a1d6e934aeb73bf3151c48d9 [PATCH] swsusp: add architecture special saveable pages support
    
    because not only do they apparently cause page faults on x86, the
    infrastructure doesn't compile on powerpc.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e82cb10fb3ea..96e31aa64cc7 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -71,7 +71,6 @@ struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
 unsigned long get_safe_page(gfp_t gfp_mask);
-int swsusp_add_arch_pages(unsigned long start, unsigned long end);
 
 /*
  * XXX: We try to keep some more pages free so that I/O operations succeed

commit ce4ab0012b32c1a4a1d6e934aeb73bf3151c48d9
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jun 23 02:04:44 2006 -0700

    [PATCH] swsusp: add architecture special saveable pages support
    
    1. Add architecture specific pages save/restore support.  Next two patches
       will use this to save/restore 'ACPI NVS' pages.
    
    2. Allow reserved pages 'nosave'.  This could avoid save/restore BIOS
       reserved pages.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 96e31aa64cc7..e82cb10fb3ea 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -71,6 +71,7 @@ struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
 unsigned long get_safe_page(gfp_t gfp_mask);
+int swsusp_add_arch_pages(unsigned long start, unsigned long end);
 
 /*
  * XXX: We try to keep some more pages free so that I/O operations succeed

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 37c1c76fd547..96e31aa64cc7 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -6,7 +6,6 @@
 #endif
 #include <linux/swap.h>
 #include <linux/notifier.h>
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/pm.h>
 

commit 46cd2f32baf181b74b16cceb123bab6fe1f61f85
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 7 12:58:50 2006 -0800

    [PATCH] Fix build failure in recent pm_prepare_* changes.
    
    Fix compilation problem in PM headers.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 43bcd13eb1ec..37c1c76fd547 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -42,13 +42,21 @@ extern void mark_free_pages(struct zone *zone);
 #ifdef CONFIG_PM
 /* kernel/power/swsusp.c */
 extern int software_suspend(void);
+
+#if defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE)
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+#else
+static inline int pm_prepare_console(void) { return 0; }
+static inline void pm_restore_console(void) {}
+#endif /* defined(CONFIG_VT) && defined(CONFIG_VT_CONSOLE) */
 #else
 static inline int software_suspend(void)
 {
 	printk("Warning: fake suspend called\n");
 	return -EPERM;
 }
-#endif
+#endif /* CONFIG_PM */
 
 #ifdef CONFIG_SUSPEND_SMP
 extern void disable_nonboot_cpus(void);

commit c0c1633bdb844ec5b4ac15c97ab8927d80550c42
Author: Dave Jones <davej@redhat.com>
Date:   Fri Feb 3 03:03:44 2006 -0800

    [PATCH] Fix build failure in recent pm_prepare_* changes.
    
    kernel/power/power.h:49: error: static declaration of 'pm_prepare_console' follows non-static declaration
    include/linux/suspend.h:46: error: previous declaration of 'pm_prepare_console' was here
    kernel/power/power.h:50: error: static declaration of 'pm_restore_console' follows non-static declaration
    include/linux/suspend.h:47: error: previous declaration of 'pm_restore_console' was here
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 5dc94e777fab..43bcd13eb1ec 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -42,10 +42,6 @@ extern void mark_free_pages(struct zone *zone);
 #ifdef CONFIG_PM
 /* kernel/power/swsusp.c */
 extern int software_suspend(void);
-
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
-
 #else
 static inline int software_suspend(void)
 {

commit 72a97e08394a3b2e75481ff680ec2a0591e3cba4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:13:46 2006 -0800

    [PATCH] swsusp: improve freeing of memory
    
    This patch makes swsusp free only as much memory as needed to complete the
    suspend and not as much as possible.  In the most of cases this should speed
    up the suspend and make the system much more responsive after resume,
    especially if a GUI (eg.  X Windows) is used.
    
    If needed, the old behavior (ie to free as much memory as possible during
    suspend) can be restored by unsetting FAST_FREE in power.h
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 33bbaea23aaf..5dc94e777fab 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -73,6 +73,6 @@ unsigned long get_safe_page(gfp_t gfp_mask);
  * XXX: We try to keep some more pages free so that I/O operations succeed
  * without paging. Might this be more?
  */
-#define PAGES_FOR_IO	512
+#define PAGES_FOR_IO	1024
 
 #endif /* _LINUX_SWSUSP_H */

commit 7088a5c00103ef48782d6c359cd12b13a10666e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 6 00:13:05 2006 -0800

    [PATCH] swsusp: introduce the swap map structure
    
    This patch introduces the swap map structure that can be used by swsusp for
    keeping tracks of data pages written to the swap.  The structure itself is
    described in a comment within the patch.
    
    The overall idea is to reduce the amount of metadata written to the swap and
    to write and read the image pages sequentially, in a file-alike way.  This
    makes the swap-handling part of swsusp fairly independent of its
    snapshot-handling part and will hopefully allow us to completely separate
    these two parts in the future.
    
    This patch is needed to remove the suspend image size limit imposed by the
    limited size of the swsusp_info structure, which is essential for x86-64
    systems with more than 512 MB of RAM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index a61c04f804b2..33bbaea23aaf 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -14,11 +14,7 @@
 typedef struct pbe {
 	unsigned long address;		/* address of the copy */
 	unsigned long orig_address;	/* original address of page */
-	swp_entry_t swap_address;	
-
-	struct pbe *next;	/* also used as scratch space at
-				 * end of page (see link, diskpage)
-				 */
+	struct pbe *next;
 } suspend_pagedir_t;
 
 #define for_each_pbe(pbe, pblist) \

commit 2c1b4a5ca48831595979a850f40ced8e7da026f8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 14:59:58 2005 -0800

    [PATCH] swsusp: rework memory freeing on resume
    
    The following patch makes swsusp use the PG_nosave and PG_nosave_free flags to
    mark pages that should be freed in case of an error during resume.
    
    This allows us to simplify the code and to use swsusp_free() in all of the
    swsusp's resume error paths, which makes them actually work.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 380915e9563d..a61c04f804b2 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -71,8 +71,7 @@ void restore_processor_state(void);
 struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
-extern unsigned long get_usable_page(gfp_t gfp_mask);
-extern void free_eaten_memory(void);
+unsigned long get_safe_page(gfp_t gfp_mask);
 
 /*
  * XXX: We try to keep some more pages free so that I/O operations succeed

commit 25761b6eb7b33823bcfff6bfe2a015badcd76fb8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 30 14:59:56 2005 -0800

    [PATCH] swsusp: move snapshot functionality to separate file
    
    The following patch moves the functionality of swsusp related to creating and
    handling the snapshot of memory to a separate file, snapshot.c
    
    This should enable us to untangle the code in the future and eventually to
    implement some parts of swsusp.c in the user space.
    
    The patch does not change the code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ba448c760168..380915e9563d 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -74,4 +74,10 @@ void __restore_processor_state(struct saved_context *ctxt);
 extern unsigned long get_usable_page(gfp_t gfp_mask);
 extern void free_eaten_memory(void);
 
+/*
+ * XXX: We try to keep some more pages free so that I/O operations succeed
+ * without paging. Might this be more?
+ */
+#define PAGES_FOR_IO	512
+
 #endif /* _LINUX_SWSUSP_H */

commit 9796fdd829da626374458e8706daedcc0e432ddd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:22:03 2005 -0400

    [PATCH] gfp_t: kernel/*
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ad15a54806d8..ba448c760168 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -71,7 +71,7 @@ void restore_processor_state(void);
 struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
-extern unsigned long get_usable_page(unsigned gfp_mask);
+extern unsigned long get_usable_page(gfp_t gfp_mask);
 extern void free_eaten_memory(void);
 
 #endif /* _LINUX_SWSUSP_H */

commit 3dd083255ddcfa87751fa8e32f61a9547a15a541
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 9 21:19:40 2005 +0200

    [PATCH] x86_64: Set up safe page tables during resume
    
    The following patch makes swsusp avoid the possible temporary corruption
    of page translation tables during resume on x86-64.  This is achieved by
    creating a copy of the relevant page tables that will not be modified by
    swsusp and can be safely used by it on resume.
    
    The problem is that during resume on x86-64 swsusp may temporarily
    corrupt the page tables used for the direct mapping of RAM.  If that
    happens, a page fault occurs and cannot be handled properly, which leads
    to the solid hang of the affected system.  This leads to the loss of the
    system's state from before suspend and may result in the loss of data or
    the corruption of filesystems, so it is a serious issue.  Also, it
    appears to happen quite often (for me, as often as 50% of the time).
    
    The problem is related to the fact that (at least) one of the PMD
    entries used in the direct memory mapping (starting at PAGE_OFFSET)
    points to a page table the physical address of which is much greater
    than the physical address of the PMD entry itself.  Moreover,
    unfortunately, the physical address of the page table before suspend
    (i.e.  the one stored in the suspend image) happens to be different to
    the physical address of the corresponding page table used during resume
    (i.e.  the one that is valid right before swsusp_arch_resume() in
    arch/x86_64/kernel/suspend_asm.S is executed).  Thus while the image is
    restored, the "offending" PMD entry gets overwritten, so it does not
    point to the right physical address any more (i.e.  there's no page
    table at the address pointed to by it, because it points to the address
    the page table has been at during suspend).  Consequently, if the PMD
    entry is used later on, and it _is_ used in the process of copying the
    image pages, a page fault occurs, but it cannot be handled in the normal
    way and the system hangs.
    
    In principle we can call create_resume_mapping() from
    swsusp_arch_resume() (ie.  from suspend_asm.S), but then the memory
    allocations in create_resume_mapping(), resume_pud_mapping(), and
    resume_pmd_mapping() must be made carefully so that we use _only_
    NosaveFree pages in them (the other pages are overwritten by the loop in
    swsusp_arch_resume()).  Additionally, we are in atomic context at that
    time, so we cannot use GFP_KERNEL.  Moreover, if one of the allocations
    fails, we should free all of the allocated pages, so we need to trace
    them somehow.
    
    All of this is done in the appended patch, except that the functions
    populating the page tables are located in arch/x86_64/kernel/suspend.c
    rather than in init.c.  It may be done in a more elegan way in the
    future, with the help of some swsusp patches that are in the works now.
    
    [AK: move some externs into headers, renamed a function]
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index f2e96fdfaae0..ad15a54806d8 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -71,5 +71,7 @@ void restore_processor_state(void);
 struct saved_context;
 void __save_processor_state(struct saved_context *ctxt);
 void __restore_processor_state(struct saved_context *ctxt);
+extern unsigned long get_usable_page(unsigned gfp_mask);
+extern void free_eaten_memory(void);
 
 #endif /* _LINUX_SWSUSP_H */

commit 5a72e04df5470df0ec646029d31e5528167ab1a7
Author: Li Shaohua <shaohua.li@intel.com>
Date:   Sat Jun 25 14:55:06 2005 -0700

    [PATCH] suspend/resume SMP support
    
    Using CPU hotplug to support suspend/resume SMP.  Both S3 and S4 use
    disable/enable_nonboot_cpus API.  The S4 part is based on Pavel's original S4
    SMP patch.
    
    Signed-off-by: Li Shaohua<shaohua.li@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 2bf0d5fabcdb..f2e96fdfaae0 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -58,7 +58,7 @@ static inline int software_suspend(void)
 }
 #endif
 
-#ifdef CONFIG_SMP
+#ifdef CONFIG_SUSPEND_SMP
 extern void disable_nonboot_cpus(void);
 extern void enable_nonboot_cpus(void);
 #else

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
new file mode 100644
index 000000000000..2bf0d5fabcdb
--- /dev/null
+++ b/include/linux/suspend.h
@@ -0,0 +1,75 @@
+#ifndef _LINUX_SWSUSP_H
+#define _LINUX_SWSUSP_H
+
+#if defined(CONFIG_X86) || defined(CONFIG_FRV) || defined(CONFIG_PPC32)
+#include <asm/suspend.h>
+#endif
+#include <linux/swap.h>
+#include <linux/notifier.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+
+/* page backup entry */
+typedef struct pbe {
+	unsigned long address;		/* address of the copy */
+	unsigned long orig_address;	/* original address of page */
+	swp_entry_t swap_address;	
+
+	struct pbe *next;	/* also used as scratch space at
+				 * end of page (see link, diskpage)
+				 */
+} suspend_pagedir_t;
+
+#define for_each_pbe(pbe, pblist) \
+	for (pbe = pblist ; pbe ; pbe = pbe->next)
+
+#define PBES_PER_PAGE      (PAGE_SIZE/sizeof(struct pbe))
+#define PB_PAGE_SKIP       (PBES_PER_PAGE-1)
+
+#define for_each_pb_page(pbe, pblist) \
+	for (pbe = pblist ; pbe ; pbe = (pbe+PB_PAGE_SKIP)->next)
+
+
+#define SWAP_FILENAME_MAXLENGTH	32
+
+
+extern dev_t swsusp_resume_device;
+   
+/* mm/vmscan.c */
+extern int shrink_mem(void);
+
+/* mm/page_alloc.c */
+extern void drain_local_pages(void);
+extern void mark_free_pages(struct zone *zone);
+
+#ifdef CONFIG_PM
+/* kernel/power/swsusp.c */
+extern int software_suspend(void);
+
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+
+#else
+static inline int software_suspend(void)
+{
+	printk("Warning: fake suspend called\n");
+	return -EPERM;
+}
+#endif
+
+#ifdef CONFIG_SMP
+extern void disable_nonboot_cpus(void);
+extern void enable_nonboot_cpus(void);
+#else
+static inline void disable_nonboot_cpus(void) {}
+static inline void enable_nonboot_cpus(void) {}
+#endif
+
+void save_processor_state(void);
+void restore_processor_state(void);
+struct saved_context;
+void __save_processor_state(struct saved_context *ctxt);
+void __restore_processor_state(struct saved_context *ctxt);
+
+#endif /* _LINUX_SWSUSP_H */
