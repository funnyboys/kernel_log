commit ba58d1020a54933c6b087a3107661c8513556cb8
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Nov 28 14:35:19 2016 -0800

    timekeeping: Ignore the bogus sleep time if pm_trace is enabled
    
    Power management suspend/resume tracing (ab)uses the RTC to store
    suspend/resume information persistently. As a consequence the RTC value is
    clobbered when timekeeping is resumed and tries to inject the sleep time.
    
    Commit a4f8f6667f09 ("timekeeping: Cap array access in timekeeping_debug")
    plugged a out of bounds array access in the timekeeping debug code which
    was caused by the clobbered RTC value, but we still use the clobbered RTC
    value for sleep time injection into kernel timekeeping, which will result
    in random adjustments depending on the stored "hash" value.
    
    To prevent this keep track of the RTC clobbering and ignore the invalid RTC
    timestamp at resume. If the system resumed successfully clear the flag,
    which marks the RTC as unusable, warn the user about the RTC clobber and
    recommend to adjust the RTC with 'ntpdate' or 'rdate'.
    
    [jstultz: Fixed up pr_warn formating, and implemented suggestions from Ingo]
    [ tglx: Rewrote changelog ]
    
    Originally-from: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Xunlei Pang <xlpang@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Link: http://lkml.kernel.org/r/1480372524-15181-3-git-send-email-john.stultz@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index a585b4b5fa0e..0661af17a758 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -16,6 +16,7 @@
 #include <asm/mc146818rtc.h>		/* register access macros */
 #include <linux/bcd.h>
 #include <linux/delay.h>
+#include <linux/pm-trace.h>
 
 #ifdef __KERNEL__
 #include <linux/spinlock.h>		/* spinlock_t */

commit d6faca40f40b62aca8ea8c29289c7bf7456172bb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 1 16:46:23 2016 +0200

    rtc: move mc146818 helper functions out-of-line
    
    The mc146818_get_time/mc146818_set_time functions are rather large
    inline functions in a global header file and are used in several
    drivers and in x86 specific code.
    
    Here we move them into a separate .c file that is compiled whenever
    any of the users require it. This also lets us remove the linux/acpi.h
    header inclusion from mc146818rtc.h, which in turn avoids some
    warnings about duplicate definition of the TRUE/FALSE macros.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index e9e346b37846..a585b4b5fa0e 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -17,10 +17,6 @@
 #include <linux/bcd.h>
 #include <linux/delay.h>
 
-#ifdef CONFIG_ACPI
-#include <linux/acpi.h>
-#endif
-
 #ifdef __KERNEL__
 #include <linux/spinlock.h>		/* spinlock_t */
 extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
@@ -126,192 +122,7 @@ struct cmos_rtc_board_info {
 #define RTC_IO_EXTENT_USED      RTC_IO_EXTENT
 #endif /* ARCH_RTC_LOCATION */
 
-/*
- * Returns true if a clock update is in progress
- */
-static inline unsigned char mc146818_is_updating(void)
-{
-	unsigned char uip;
-	unsigned long flags;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-	return uip;
-}
-
-static inline unsigned int mc146818_get_time(struct rtc_time *time)
-{
-	unsigned char ctrl;
-	unsigned long flags;
-	unsigned char century = 0;
-
-#ifdef CONFIG_MACH_DECSTATION
-	unsigned int real_year;
-#endif
-
-	/*
-	 * read RTC once any update in progress is done. The update
-	 * can take just over 2ms. We wait 20ms. There is no need to
-	 * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.
-	 * If you need to know *exactly* when a second has started, enable
-	 * periodic update complete interrupts, (via ioctl) and then 
-	 * immediately read /dev/rtc which will block until you get the IRQ.
-	 * Once the read clears, read the RTC time (again via ioctl). Easy.
-	 */
-	if (mc146818_is_updating())
-		mdelay(20);
-
-	/*
-	 * Only the values that we read from the RTC are set. We leave
-	 * tm_wday, tm_yday and tm_isdst untouched. Even though the
-	 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
-	 * by the RTC when initially set to a non-zero value.
-	 */
-	spin_lock_irqsave(&rtc_lock, flags);
-	time->tm_sec = CMOS_READ(RTC_SECONDS);
-	time->tm_min = CMOS_READ(RTC_MINUTES);
-	time->tm_hour = CMOS_READ(RTC_HOURS);
-	time->tm_mday = CMOS_READ(RTC_DAY_OF_MONTH);
-	time->tm_mon = CMOS_READ(RTC_MONTH);
-	time->tm_year = CMOS_READ(RTC_YEAR);
-#ifdef CONFIG_MACH_DECSTATION
-	real_year = CMOS_READ(RTC_DEC_YEAR);
-#endif
-#ifdef CONFIG_ACPI
-	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
-	    acpi_gbl_FADT.century)
-		century = CMOS_READ(acpi_gbl_FADT.century);
-#endif
-	ctrl = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-
-	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
-	{
-		time->tm_sec = bcd2bin(time->tm_sec);
-		time->tm_min = bcd2bin(time->tm_min);
-		time->tm_hour = bcd2bin(time->tm_hour);
-		time->tm_mday = bcd2bin(time->tm_mday);
-		time->tm_mon = bcd2bin(time->tm_mon);
-		time->tm_year = bcd2bin(time->tm_year);
-		century = bcd2bin(century);
-	}
-
-#ifdef CONFIG_MACH_DECSTATION
-	time->tm_year += real_year - 72;
-#endif
-
-	if (century)
-		time->tm_year += (century - 19) * 100;
-
-	/*
-	 * Account for differences between how the RTC uses the values
-	 * and how they are defined in a struct rtc_time;
-	 */
-	if (time->tm_year <= 69)
-		time->tm_year += 100;
-
-	time->tm_mon--;
-
-	return RTC_24H;
-}
-
-/* Set the current date and time in the real time clock. */
-static inline int mc146818_set_time(struct rtc_time *time)
-{
-	unsigned long flags;
-	unsigned char mon, day, hrs, min, sec;
-	unsigned char save_control, save_freq_select;
-	unsigned int yrs;
-#ifdef CONFIG_MACH_DECSTATION
-	unsigned int real_yrs, leap_yr;
-#endif
-	unsigned char century = 0;
-
-	yrs = time->tm_year;
-	mon = time->tm_mon + 1;   /* tm_mon starts at zero */
-	day = time->tm_mday;
-	hrs = time->tm_hour;
-	min = time->tm_min;
-	sec = time->tm_sec;
-
-	if (yrs > 255)	/* They are unsigned */
-		return -EINVAL;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-#ifdef CONFIG_MACH_DECSTATION
-	real_yrs = yrs;
-	leap_yr = ((!((yrs + 1900) % 4) && ((yrs + 1900) % 100)) ||
-			!((yrs + 1900) % 400));
-	yrs = 72;
-
-	/*
-	 * We want to keep the year set to 73 until March
-	 * for non-leap years, so that Feb, 29th is handled
-	 * correctly.
-	 */
-	if (!leap_yr && mon < 3) {
-		real_yrs--;
-		yrs = 73;
-	}
-#endif
-
-#ifdef CONFIG_ACPI
-	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
-	    acpi_gbl_FADT.century) {
-		century = (yrs + 1900) / 100;
-		yrs %= 100;
-	}
-#endif
-
-	/* These limits and adjustments are independent of
-	 * whether the chip is in binary mode or not.
-	 */
-	if (yrs > 169) {
-		spin_unlock_irqrestore(&rtc_lock, flags);
-		return -EINVAL;
-	}
-
-	if (yrs >= 100)
-		yrs -= 100;
-
-	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY)
-	    || RTC_ALWAYS_BCD) {
-		sec = bin2bcd(sec);
-		min = bin2bcd(min);
-		hrs = bin2bcd(hrs);
-		day = bin2bcd(day);
-		mon = bin2bcd(mon);
-		yrs = bin2bcd(yrs);
-		century = bin2bcd(century);
-	}
-
-	save_control = CMOS_READ(RTC_CONTROL);
-	CMOS_WRITE((save_control|RTC_SET), RTC_CONTROL);
-	save_freq_select = CMOS_READ(RTC_FREQ_SELECT);
-	CMOS_WRITE((save_freq_select|RTC_DIV_RESET2), RTC_FREQ_SELECT);
-
-#ifdef CONFIG_MACH_DECSTATION
-	CMOS_WRITE(real_yrs, RTC_DEC_YEAR);
-#endif
-	CMOS_WRITE(yrs, RTC_YEAR);
-	CMOS_WRITE(mon, RTC_MONTH);
-	CMOS_WRITE(day, RTC_DAY_OF_MONTH);
-	CMOS_WRITE(hrs, RTC_HOURS);
-	CMOS_WRITE(min, RTC_MINUTES);
-	CMOS_WRITE(sec, RTC_SECONDS);
-#ifdef CONFIG_ACPI
-	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
-	    acpi_gbl_FADT.century)
-		CMOS_WRITE(century, acpi_gbl_FADT.century);
-#endif
-
-	CMOS_WRITE(save_control, RTC_CONTROL);
-	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
-
-	spin_unlock_irqrestore(&rtc_lock, flags);
-
-	return 0;
-}
+unsigned int mc146818_get_time(struct rtc_time *time);
+int mc146818_set_time(struct rtc_time *time);
 
 #endif /* _MC146818RTC_H */

commit 5ab788d7383289bfc141ab357767bc6c11bbf77f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 30 20:57:50 2016 +0200

    rtc: cmos: move mc146818rtc code out of asm-generic/rtc.h
    
    Drivers should not really include stuff from asm-generic directly,
    and the PC-style cmos rtc driver does this in order to reuse the
    mc146818 implementation of get_rtc_time/set_rtc_time rather than
    the architecture specific one for the architecture it gets built for.
    
    To make it more obvious what is going on, this moves and renames the
    two functions into include/linux/mc146818rtc.h, which holds the
    other mc146818 specific code. Ideally it would be in a .c file,
    but that would require extra infrastructure as the functions are
    called by multiple drivers with conflicting dependencies.
    
    With this change, the asm-generic/rtc.h header also becomes much
    more generic, so it can be reused more easily across any architecture
    that still relies on the genrtc driver.
    
    The only caller of the internal __get_rtc_time/__set_rtc_time
    functions is in arch/alpha/kernel/rtc.c, and we just change those
    over to the new naming.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index 433e0c74d643..e9e346b37846 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -14,6 +14,12 @@
 #include <asm/io.h>
 #include <linux/rtc.h>			/* get the user-level API */
 #include <asm/mc146818rtc.h>		/* register access macros */
+#include <linux/bcd.h>
+#include <linux/delay.h>
+
+#ifdef CONFIG_ACPI
+#include <linux/acpi.h>
+#endif
 
 #ifdef __KERNEL__
 #include <linux/spinlock.h>		/* spinlock_t */
@@ -120,4 +126,192 @@ struct cmos_rtc_board_info {
 #define RTC_IO_EXTENT_USED      RTC_IO_EXTENT
 #endif /* ARCH_RTC_LOCATION */
 
+/*
+ * Returns true if a clock update is in progress
+ */
+static inline unsigned char mc146818_is_updating(void)
+{
+	unsigned char uip;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
+	spin_unlock_irqrestore(&rtc_lock, flags);
+	return uip;
+}
+
+static inline unsigned int mc146818_get_time(struct rtc_time *time)
+{
+	unsigned char ctrl;
+	unsigned long flags;
+	unsigned char century = 0;
+
+#ifdef CONFIG_MACH_DECSTATION
+	unsigned int real_year;
+#endif
+
+	/*
+	 * read RTC once any update in progress is done. The update
+	 * can take just over 2ms. We wait 20ms. There is no need to
+	 * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.
+	 * If you need to know *exactly* when a second has started, enable
+	 * periodic update complete interrupts, (via ioctl) and then 
+	 * immediately read /dev/rtc which will block until you get the IRQ.
+	 * Once the read clears, read the RTC time (again via ioctl). Easy.
+	 */
+	if (mc146818_is_updating())
+		mdelay(20);
+
+	/*
+	 * Only the values that we read from the RTC are set. We leave
+	 * tm_wday, tm_yday and tm_isdst untouched. Even though the
+	 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
+	 * by the RTC when initially set to a non-zero value.
+	 */
+	spin_lock_irqsave(&rtc_lock, flags);
+	time->tm_sec = CMOS_READ(RTC_SECONDS);
+	time->tm_min = CMOS_READ(RTC_MINUTES);
+	time->tm_hour = CMOS_READ(RTC_HOURS);
+	time->tm_mday = CMOS_READ(RTC_DAY_OF_MONTH);
+	time->tm_mon = CMOS_READ(RTC_MONTH);
+	time->tm_year = CMOS_READ(RTC_YEAR);
+#ifdef CONFIG_MACH_DECSTATION
+	real_year = CMOS_READ(RTC_DEC_YEAR);
+#endif
+#ifdef CONFIG_ACPI
+	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
+	    acpi_gbl_FADT.century)
+		century = CMOS_READ(acpi_gbl_FADT.century);
+#endif
+	ctrl = CMOS_READ(RTC_CONTROL);
+	spin_unlock_irqrestore(&rtc_lock, flags);
+
+	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
+	{
+		time->tm_sec = bcd2bin(time->tm_sec);
+		time->tm_min = bcd2bin(time->tm_min);
+		time->tm_hour = bcd2bin(time->tm_hour);
+		time->tm_mday = bcd2bin(time->tm_mday);
+		time->tm_mon = bcd2bin(time->tm_mon);
+		time->tm_year = bcd2bin(time->tm_year);
+		century = bcd2bin(century);
+	}
+
+#ifdef CONFIG_MACH_DECSTATION
+	time->tm_year += real_year - 72;
+#endif
+
+	if (century)
+		time->tm_year += (century - 19) * 100;
+
+	/*
+	 * Account for differences between how the RTC uses the values
+	 * and how they are defined in a struct rtc_time;
+	 */
+	if (time->tm_year <= 69)
+		time->tm_year += 100;
+
+	time->tm_mon--;
+
+	return RTC_24H;
+}
+
+/* Set the current date and time in the real time clock. */
+static inline int mc146818_set_time(struct rtc_time *time)
+{
+	unsigned long flags;
+	unsigned char mon, day, hrs, min, sec;
+	unsigned char save_control, save_freq_select;
+	unsigned int yrs;
+#ifdef CONFIG_MACH_DECSTATION
+	unsigned int real_yrs, leap_yr;
+#endif
+	unsigned char century = 0;
+
+	yrs = time->tm_year;
+	mon = time->tm_mon + 1;   /* tm_mon starts at zero */
+	day = time->tm_mday;
+	hrs = time->tm_hour;
+	min = time->tm_min;
+	sec = time->tm_sec;
+
+	if (yrs > 255)	/* They are unsigned */
+		return -EINVAL;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+#ifdef CONFIG_MACH_DECSTATION
+	real_yrs = yrs;
+	leap_yr = ((!((yrs + 1900) % 4) && ((yrs + 1900) % 100)) ||
+			!((yrs + 1900) % 400));
+	yrs = 72;
+
+	/*
+	 * We want to keep the year set to 73 until March
+	 * for non-leap years, so that Feb, 29th is handled
+	 * correctly.
+	 */
+	if (!leap_yr && mon < 3) {
+		real_yrs--;
+		yrs = 73;
+	}
+#endif
+
+#ifdef CONFIG_ACPI
+	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
+	    acpi_gbl_FADT.century) {
+		century = (yrs + 1900) / 100;
+		yrs %= 100;
+	}
+#endif
+
+	/* These limits and adjustments are independent of
+	 * whether the chip is in binary mode or not.
+	 */
+	if (yrs > 169) {
+		spin_unlock_irqrestore(&rtc_lock, flags);
+		return -EINVAL;
+	}
+
+	if (yrs >= 100)
+		yrs -= 100;
+
+	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY)
+	    || RTC_ALWAYS_BCD) {
+		sec = bin2bcd(sec);
+		min = bin2bcd(min);
+		hrs = bin2bcd(hrs);
+		day = bin2bcd(day);
+		mon = bin2bcd(mon);
+		yrs = bin2bcd(yrs);
+		century = bin2bcd(century);
+	}
+
+	save_control = CMOS_READ(RTC_CONTROL);
+	CMOS_WRITE((save_control|RTC_SET), RTC_CONTROL);
+	save_freq_select = CMOS_READ(RTC_FREQ_SELECT);
+	CMOS_WRITE((save_freq_select|RTC_DIV_RESET2), RTC_FREQ_SELECT);
+
+#ifdef CONFIG_MACH_DECSTATION
+	CMOS_WRITE(real_yrs, RTC_DEC_YEAR);
+#endif
+	CMOS_WRITE(yrs, RTC_YEAR);
+	CMOS_WRITE(mon, RTC_MONTH);
+	CMOS_WRITE(day, RTC_DAY_OF_MONTH);
+	CMOS_WRITE(hrs, RTC_HOURS);
+	CMOS_WRITE(min, RTC_MINUTES);
+	CMOS_WRITE(sec, RTC_SECONDS);
+#ifdef CONFIG_ACPI
+	if (acpi_gbl_FADT.header.revision >= FADT2_REVISION_ID &&
+	    acpi_gbl_FADT.century)
+		CMOS_WRITE(century, acpi_gbl_FADT.century);
+#endif
+
+	CMOS_WRITE(save_control, RTC_CONTROL);
+	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
+
+	spin_unlock_irqrestore(&rtc_lock, flags);
+
+	return 0;
+}
+
 #endif /* _MC146818RTC_H */

commit 31632dbdba85aafc8a6772d578c5c14f84a1fe17
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Jun 6 14:35:49 2014 -0700

    drivers/rtc/rtc-cmos.c: drivers/char/rtc.c features for DECstation support
    
    This brings in drivers/char/rtc.c functionality required for DECstation
    and, should the maintainers decide to switch, Alpha systems to use
    rtc-cmos.
    
    Specifically these features are made available:
    
    * RTC iomem rather than x86/PCI port I/O mapping, controlled with the
      RTC_IOMAPPED macro as with the original driver.  The DS1287A chip in all
      DECstation systems is mapped in the host bus address space as a
      contiguous block of 64 32-bit words of which the least significant byte
      accesses the RTC chip for both reads and writes.  All the address and
      data window register accesses are made transparently by the chipset glue
      logic so that the device appears directly mapped on the host bus.
    
    * A way to set the size of the address space explicitly with the
      newly-added `address_space' member of the platform part of the RTC
      device structure.  This avoids the unreliable heuristics that does not
      work in a setup where the RTC is not explicitly accessed with the usual
      address and data window register pair.
    
    * The ability to use the RTC periodic interrupt as a system clock
      device, which is implemented by arch/mips/kernel/cevt-ds1287.c for
      DECstation systems and takes the RTC interrupt away from the RTC driver.
       Eventually hooking back to the clock device's interrupt handler should
      be possible for the purpose of the alarm clock and possibly also
      update-in-progress interrupt, but this is not done by this change.
    
      o To avoid interfering with the clock interrupt all the places where
        the RTC interrupt mask is fiddled with are only executed if and IRQ
        has been assigned to the RTC driver.
    
      o To avoid changing the clock setup Register A is not fiddled with
        if CMOS_RTC_FLAGS_NOFREQ is set in the newly-added `flags' member of
        the platform part of the RTC device structure.  Originally, in
        drivers/char/rtc.c, this was keyed with the absence of the RTC
        interrupt, just like the interrupt mask, but there only the periodic
        interrupt frequency is set, whereas rtc-cmos also sets the divider
        bits.  Therefore a new flag is introduced so that systems where the
        RTC interrupt is not usable rather than used as a system clock device
        can fully initialise the RTC.
    
    * A small clean-up is made to the IRQ assignment code that makes the IRQ
      number hardcoded to -1 rather than arbitrary -ENXIO (or whatever error
      happens to be returned by platform_get_irq) where no IRQ has been
      assigned to the RTC driver (NO_IRQ might be another candidate, but it
      looks like this macro has inconsistent or missing definitions and
      limited use and might therefore be unsafe).
    
    Verified to work correctly with a DECstation 5000/240 system.
    
    [akpm@linux-foundation.org: fix weird code layout]
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index 2f4e957af656..433e0c74d643 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -31,6 +31,10 @@ struct cmos_rtc_board_info {
 	void	(*wake_on)(struct device *dev);
 	void	(*wake_off)(struct device *dev);
 
+	u32	flags;
+#define CMOS_RTC_FLAGS_NOFREQ	(1 << 0)
+	int	address_space;
+
 	u8	rtc_day_alarm;		/* zero, or register index */
 	u8	rtc_mon_alarm;		/* zero, or register index */
 	u8	rtc_century;		/* zero, or register index */

commit 9626f1f117be21b6e4b7a1cb49814fc065dd3d2d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 14 16:59:57 2007 -0800

    rtc: fall back to requesting only the ports we actually use
    
    Firmware like PNPBIOS or ACPI can report the address space consumed by the
    RTC.  The actual space consumed may be less than the size (RTC_IO_EXTENT)
    assumed by the RTC driver.
    
    The PNP core doesn't request resources yet, but I'd like to make it do so.
    If/when it does, the RTC_IO_EXTENT request may fail, which prevents the RTC
    driver from loading.
    
    Since we only use the RTC index and data registers at RTC_PORT(0) and
    RTC_PORT(1), we can fall back to requesting just enough space for those.
    
    If the PNP core requests resources, this results in typical I/O port usage
    like this:
    
        0070-0073 : 00:06           <-- PNP device 00:06 responds to 70-73
          0070-0071 : rtc           <-- RTC driver uses only 70-71
    
    instead of the current:
    
        0070-0077 : rtc             <-- RTC_IO_EXTENT == 8
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index 580b3f4956ee..2f4e957af656 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -109,8 +109,11 @@ struct cmos_rtc_board_info {
 #ifndef ARCH_RTC_LOCATION	/* Override by <asm/mc146818rtc.h>? */
 
 #define RTC_IO_EXTENT	0x8
+#define RTC_IO_EXTENT_USED	0x2
 #define RTC_IOMAPPED	1	/* Default to I/O mapping. */
 
+#else
+#define RTC_IO_EXTENT_USED      RTC_IO_EXTENT
 #endif /* ARCH_RTC_LOCATION */
 
 #endif /* _MC146818RTC_H */

commit 87ac84f42a7a580d0dd72ae31d6a5eb4bfe04c6d
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:34:00 2007 -0700

    rtc-cmos wakeup interface
    
    I finally got around to testing the updated wakeup event hooks for rtc-cmos,
    and they follow in two patches:
    
     - Interface update ... when a simple enable_irq_wake() doesn't suffice,
       the platform data can hold suspend/resume callback hooks.
    
     - ACPI implementation ... provides callback hooks to do ACPI magic, and
       eliminate the legacy /proc/acpi/alarm file.
    
    The interface update could go into 2.6.21, but that's not essential; they
    will be NOPs on most PCs, without the ACPI stuff.
    
    I suspect the ACPI folk may have opinions about how to merge that second
    patch, and how to obsolete that legacy procfs file.  I'd like to see that
    merge into 2.6.22 if possible...
    
    As for how to kick it in ... two ways:
    
     - The appended "rtcwake" program; updated since the last time it was
       posted, it deals much better with timezones and DST.
    
     - Write the /sys/class/rtc/.../wakealarm file, then go to sleep.
    
    For some reason RTC wake from "swsusp" stopped working on a system where
    it previously worked; the alarm setting appears to get clobbered.  But
    on the bright side, RTC wake from "standby" worked on a system that had
    never been able to resume from that state before ... IDEACPI is my guess
    as to why it finally started to work.  It's the old "two steps forward,
    one step back" dance, I guess.
    
    - Dave
    
    /* gcc -Wall -Os -o rtcwake rtcwake.c */
    
    #include <stdio.h>
    #include <getopt.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <errno.h>
    #include <time.h>
    
    #include <sys/ioctl.h>
    #include <sys/time.h>
    #include <sys/types.h>
    
    #include <linux/rtc.h>
    
    /* constants from legacy PC/AT hardware */
    #define RTC_PF  0x40
    #define RTC_AF  0x20
    #define RTC_UF  0x10
    
    /*
     * rtcwake -- enter a system sleep state until specified wakeup time.
     *
     * This uses cross-platform Linux interfaces to enter a system sleep state,
     * and leave it no later than a specified time.  It uses any RTC framework
     * driver that supports standard driver model wakeup flags.
     *
     * This is normally used like the old "apmsleep" utility, to wake from a
     * suspend state like ACPI S1 (standby) or S3 (suspend-to-RAM).  Most
     * platforms can implement those without analogues of BIOS, APM, or ACPI.
     *
     * On some systems, this can also be used like "nvram-wakeup", waking
     * from states like ACPI S4 (suspend to disk).  Not all systems have
     * persistent media that are appropriate for such suspend modes.
     *
     * The best way to set the system's RTC is so that it holds the current
     * time in UTC.  Use the "-l" flag to tell this program that the system
     * RTC uses a local timezone instead (maybe you dual-boot MS-Windows).
     */
    
    static char             *progname;
    
    #ifdef  DEBUG
    #define VERSION "1.0 dev (" __DATE__ " " __TIME__ ")"
    #else
    #define VERSION "0.9"
    #endif
    
    static unsigned         verbose;
    static int              rtc_is_utc = -1;
    
    static int may_wakeup(const char *devname)
    {
            char    buf[128], *s;
            FILE    *f;
    
            snprintf(buf, sizeof buf, "/sys/class/rtc/%s/device/power/wakeup",
                            devname);
            f = fopen(buf, "r");
            if (!f) {
                    perror(buf);
                    return 0;
            }
            fgets(buf, sizeof buf, f);
            fclose(f);
    
            s = strchr(buf, '\n');
            if (!s)
                    return 0;
            *s = 0;
    
            /* wakeup events could be disabled or not supported */
            return strcmp(buf, "enabled") == 0;
    }
    
    /* all times should be in UTC */
    static time_t   sys_time;
    static time_t   rtc_time;
    
    static int get_basetimes(int fd)
    {
            struct tm       tm;
            struct rtc_time rtc;
    
            /* this process works in RTC time, except when working
             * with the system clock (which always uses UTC).
             */
            if (rtc_is_utc)
                    setenv("TZ", "UTC", 1);
            tzset();
    
            /* read rtc and system clocks "at the same time", or as
             * precisely (+/- a second) as we can read them.
             */
            if (ioctl(fd, RTC_RD_TIME, &rtc) < 0) {
                    perror("read rtc time");
                    return 0;
            }
            sys_time = time(0);
            if (sys_time == (time_t)-1) {
                    perror("read system time");
                    return 0;
            }
    
            /* convert rtc_time to normal arithmetic-friendly form,
             * updating tm.tm_wday as used by asctime().
             */
            memset(&tm, 0, sizeof tm);
            tm.tm_sec = rtc.tm_sec;
            tm.tm_min = rtc.tm_min;
            tm.tm_hour = rtc.tm_hour;
            tm.tm_mday = rtc.tm_mday;
            tm.tm_mon = rtc.tm_mon;
            tm.tm_year = rtc.tm_year;
            tm.tm_isdst = rtc.tm_isdst;     /* stays unspecified? */
            rtc_time = mktime(&tm);
    
            if (rtc_time == (time_t)-1) {
                    perror("convert rtc time");
                    return 0;
            }
    
            if (verbose) {
                    if (!rtc_is_utc) {
                            printf("\ttzone   = %ld\n", timezone);
                            printf("\ttzname  = %s\n", tzname[daylight]);
                            gmtime_r(&rtc_time, &tm);
                    }
                    printf("\tsystime = %ld, (UTC) %s",
                                    (long) sys_time, asctime(gmtime(&sys_time)));
                    printf("\trtctime = %ld, (UTC) %s",
                                    (long) rtc_time, asctime(&tm));
            }
    
            return 1;
    }
    
    static int setup_alarm(int fd, time_t *wakeup)
    {
            struct tm               *tm;
            struct rtc_wkalrm       wake;
    
            tm = gmtime(wakeup);
    
            wake.time.tm_sec = tm->tm_sec;
            wake.time.tm_min = tm->tm_min;
            wake.time.tm_hour = tm->tm_hour;
            wake.time.tm_mday = tm->tm_mday;
            wake.time.tm_mon = tm->tm_mon;
            wake.time.tm_year = tm->tm_year;
            wake.time.tm_wday = tm->tm_wday;
            wake.time.tm_yday = tm->tm_yday;
            wake.time.tm_isdst = tm->tm_isdst;
    
            /* many rtc alarms only support up to 24 hours from 'now' ... */
            if ((rtc_time + (24 * 60 * 60)) > *wakeup) {
                    if (ioctl(fd, RTC_ALM_SET, &wake.time) < 0) {
                            perror("set rtc alarm");
                            return 0;
                    }
                    if (ioctl(fd, RTC_AIE_ON, 0) < 0) {
                            perror("enable rtc alarm");
                            return 0;
                    }
    
            /* ... so use the "more than 24 hours" request only if we must */
            } else {
                    /* avoid an extra AIE_ON call */
                    wake.enabled = 1;
    
                    if (ioctl(fd, RTC_WKALM_SET, &wake) < 0) {
                            perror("set rtc wake alarm");
                            return 0;
                    }
            }
    
            return 1;
    }
    
    static void suspend_system(const char *suspend)
    {
            FILE    *f = fopen("/sys/power/state", "w");
    
            if (!f) {
                    perror("/sys/power/state");
                    return;
            }
    
            fprintf(f, "%s\n", suspend);
            fflush(f);
    
            /* this executes after wake from suspend */
            fclose(f);
    }
    
    int main(int argc, char **argv)
    {
            static char             *devname = "rtc0";
            static unsigned         seconds = 0;
            static char             *suspend = "standby";
    
            int             t;
            int             fd;
            time_t          alarm = 0;
    
            progname = strrchr(argv[0], '/');
            if (progname)
                    progname++;
            else
                    progname = argv[0];
            if (chdir("/dev/") < 0) {
                    perror("chdir /dev");
                    return 1;
            }
    
            while ((t = getopt(argc, argv, "d:lm:s:t:uVv")) != EOF) {
                    switch (t) {
    
                    case 'd':
                            devname = optarg;
                            break;
    
                    case 'l':
                            rtc_is_utc = 0;
                            break;
    
                    /* what system power mode to use?  for now handle only
                     * standardized mode names; eventually when systems define
                     * their own state names, parse /sys/power/state.
                     *
                     * "on" is used just to test the RTC alarm mechanism,
                     * bypassing all the wakeup-from-sleep infrastructure.
                     */
                    case 'm':
                            if (strcmp(optarg, "standby") == 0
                                            || strcmp(optarg, "mem") == 0
                                            || strcmp(optarg, "disk") == 0
                                            || strcmp(optarg, "on") == 0
                                            ) {
                                    suspend = optarg;
                                    break;
                            }
                            printf("%s: unrecognized suspend state '%s'\n",
                                            progname, optarg);
                            goto usage;
    
                    /* alarm time, seconds-to-sleep (relative) */
                    case 's':
                            t = atoi(optarg);
                            if (t < 0) {
                                    printf("%s: illegal interval %s seconds\n",
                                                    progname, optarg);
                                    goto usage;
                            }
                            seconds = t;
                            break;
    
                    /* alarm time, time_t (absolute, seconds since 1/1 1970 UTC) */
                    case 't':
                            t = atoi(optarg);
                            if (t < 0) {
                                    printf("%s: illegal time_t value %s\n",
                                                    progname, optarg);
                                    goto usage;
                            }
                            alarm = t;
                            break;
    
                    case 'u':
                            rtc_is_utc = 1;
                            break;
    
                    case 'v':
                            verbose++;
                            break;
    
                    case 'V':
                            printf("%s: version %s\n", progname, VERSION);
                            break;
    
                    default:
    usage:
                            printf("usage: %s [options]"
                                    "\n\t"
                                    "-d rtc0|rtc1|...\t(select rtc)"
                                    "\n\t"
                                    "-l\t\t\t(RTC uses local timezone)"
                                    "\n\t"
                                    "-m standby|mem|...\t(sleep mode)"
                                    "\n\t"
                                    "-s seconds\t\t(seconds to sleep)"
                                    "\n\t"
                                    "-t time_t\t\t(time to wake)"
                                    "\n\t"
                                    "-u\t\t\t(RTC uses UTC)"
                                    "\n\t"
                                    "-v\t\t\t(verbose messages)"
                                    "\n\t"
                                    "-V\t\t\t(show version)"
                                    "\n",
                                    progname);
                            return 1;
                    }
            }
    
            if (!alarm && !seconds) {
                    printf("%s: must provide wake time\n", progname);
                    goto usage;
            }
    
            /* REVISIT:  if /etc/adjtime exists, read it to see what
             * the util-linux version of hwclock assumes.
             */
            if (rtc_is_utc == -1) {
                    printf("%s: assuming RTC uses UTC ...\n", progname);
                    rtc_is_utc = 1;
            }
    
            /* this RTC must exist and (if we'll sleep) be wakeup-enabled */
            fd = open(devname, O_RDONLY);
            if (fd < 0) {
                    perror(devname);
                    return 1;
            }
            if (strcmp(suspend, "on") != 0 && !may_wakeup(devname)) {
                    printf("%s: %s not enabled for wakeup events\n",
                                    progname, devname);
                    return 1;
            }
    
            /* relative or absolute alarm time, normalized to time_t */
            if (!get_basetimes(fd))
                    return 1;
            if (verbose)
                    printf("alarm %ld, sys_time %ld, rtc_time %ld, seconds %u\n",
                                    alarm, sys_time, rtc_time, seconds);
            if (alarm) {
                    if (alarm < sys_time) {
                            printf("%s: time doesn't go backward to %s",
                                            progname, ctime(&alarm));
                            return 1;
                    }
                    alarm += sys_time - rtc_time;
            } else
                    alarm = rtc_time + seconds + 1;
            if (setup_alarm(fd, &alarm) < 0)
                    return 1;
    
            sync();
            printf("%s: wakeup from \"%s\" using %s at %s",
                            progname, suspend, devname,
                            ctime(&alarm));
            fflush(stdout);
            usleep(10 * 1000);
    
            if (strcmp(suspend, "on") != 0)
                    suspend_system(suspend);
            else {
                    unsigned long data;
    
                    do {
                            t = read(fd, &data, sizeof data);
                            if (t < 0) {
                                    perror("rtc read");
                                    break;
                            }
                            if (verbose)
                                    printf("... %s: %03lx\n", devname, data);
                    } while (!(data & RTC_AF));
            }
    
            if (ioctl(fd, RTC_AIE_OFF, 0) < 0)
                    perror("disable rtc alarm interrupt");
    
            close(fd);
            return 0;
    }
    
    This patch:
    
    Make rtc-cmos do the relevant magic so this RTC can wake the system from a
    sleep state.  That magic comes in two basic flavors:
    
     - Straightforward:  enable_irq_wake(), the way it'd work on most SOC chips;
       or generally with system sleep states which don't disable core IRQ logic.
    
     - Roundabout, using non-IRQ platform hooks.  This is needed with ACPI and
       one almost-clone chip which uses a special wakeup-only alarm.  (That's
       the RTC used on Footbridge boards, FWIW, which don't do PM in Linux.)
    
    A separate patch implements those hooks for ACPI platforms, so that rtc_cmos
    can issue system wakeup events (and its sysfs "wakealarm" attribute works on
    at least some systems).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index bdc01127dced..580b3f4956ee 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -22,8 +22,15 @@ extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
 /* Some RTCs extend the mc146818 register set to support alarms of more
  * than 24 hours in the future; or dates that include a century code.
  * This platform_data structure can pass this information to the driver.
+ *
+ * Also, some platforms need suspend()/resume() hooks to kick in special
+ * handling of wake alarms, e.g. activating ACPI BIOS hooks or setting up
+ * a separate wakeup alarm used by some almost-clone chips.
  */
 struct cmos_rtc_board_info {
+	void	(*wake_on)(struct device *dev);
+	void	(*wake_off)(struct device *dev);
+
 	u8	rtc_day_alarm;		/* zero, or register index */
 	u8	rtc_mon_alarm;		/* zero, or register index */
 	u8	rtc_century;		/* zero, or register index */

commit 7be2c7c96aff2871240d61fef508c41176c688b5
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Feb 10 01:46:02 2007 -0800

    [PATCH] RTC framework driver for CMOS RTCs
    
    This is an "RTC framework" driver for the "CMOS" RTCs which are standard on
    PCs and some other platforms.  That's MC146818 compatible silicon.
    Advantages of this vs.  drivers/char/rtc.c (use one _or_ the other, only
    one will be able to claim the RTC irq) include:
    
     - This leverages both the new RTC framework and the driver model; both
       PNPACPI and platform device modes are supported.  (A separate patch
       creates a platform device on PCs where PNPACPI isn't configured.)
    
     - It supports common extensions like longer alarms.  (A separate patch
       exports that information from ACPI through platform_data.)
    
     - Likewise, system wakeup events use "real driver model support", with
       policy control via sysfs "wakeup" attributes and and using normal rtc
       ioctls to manage wakeup.  (Patch in the works.  The ACPI hooks are
       known; /proc/acpi/alarm can vanish.  Making it work with EFI will
       be a minor challenge to someone with e.g. a MiniMac.)
    
    It's not yet been tested on non-x86 systems, without ACPI, or with HPET.
    And the RTC framework will surely have teething pains on "mainstream"
    PC-based systems (though must embedded Linux systems use it heavily), not
    limited to sorting out the "/dev/rtc0" issue (udev easily tweaked).  Also,
    the ALSA rtctimer code doesn't use the new RTC API.
    
    Otherwise, this should be a no-known-regressions replacement for the old
    drivers/char/rtc.c driver, and should help the non-embedded distros (and
    the new timekeeping code) start to switch to the framework.
    
    Note also that any systems using "rtc-m48t86" are candidates to switch over
    to this more functional driver; the platform data is different, and the way
    bytes are read is different, but otherwise those chips should be compatible.
    
    [akpm@osdl.org: sparc32 fix]
    [akpm@osdl.org: sparc64 fix]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Woody Suwalski <woodys@xandros.com>
    Cc: Alessandro Zummo <alessandro.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index 432b2fa24929..bdc01127dced 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -18,6 +18,16 @@
 #ifdef __KERNEL__
 #include <linux/spinlock.h>		/* spinlock_t */
 extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
+
+/* Some RTCs extend the mc146818 register set to support alarms of more
+ * than 24 hours in the future; or dates that include a century code.
+ * This platform_data structure can pass this information to the driver.
+ */
+struct cmos_rtc_board_info {
+	u8	rtc_day_alarm;		/* zero, or register index */
+	u8	rtc_mon_alarm;		/* zero, or register index */
+	u8	rtc_century;		/* zero, or register index */
+};
 #endif
 
 /**********************************************************************

commit 38e0e8c0550eaed1af48ec5ad9ddb8a25e8b04ae
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Jul 10 04:45:30 2006 -0700

    [PATCH] char/rtc: Handle memory-mapped chips properly
    
    Handle memory-mapped chips properly, needed for example on DECstations.
    This support was in Linux 2.4 but for some reason got lost in 2.6.  This
    patch is taken directly from the linux-mips repository.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Martin Michlmayr <tbm@cyrius.com>
    Cc: Paul Gortmaker <penguin@muskoka.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index bbc93ae217e1..432b2fa24929 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -89,4 +89,11 @@ extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
 # define RTC_VRT 0x80		/* valid RAM and time */
 /**********************************************************************/
 
+#ifndef ARCH_RTC_LOCATION	/* Override by <asm/mc146818rtc.h>? */
+
+#define RTC_IO_EXTENT	0x8
+#define RTC_IOMAPPED	1	/* Default to I/O mapping. */
+
+#endif /* ARCH_RTC_LOCATION */
+
 #endif /* _MC146818RTC_H */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
new file mode 100644
index 000000000000..bbc93ae217e1
--- /dev/null
+++ b/include/linux/mc146818rtc.h
@@ -0,0 +1,92 @@
+/* mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
+ * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
+ * derived from Data Sheet, Copyright Motorola 1984 (!).
+ * It was written to be part of the Linux operating system.
+ */
+/* permission is hereby granted to copy, modify and redistribute this code
+ * in terms of the GNU Library General Public License, Version 2 or later,
+ * at your option.
+ */
+
+#ifndef _MC146818RTC_H
+#define _MC146818RTC_H
+
+#include <asm/io.h>
+#include <linux/rtc.h>			/* get the user-level API */
+#include <asm/mc146818rtc.h>		/* register access macros */
+
+#ifdef __KERNEL__
+#include <linux/spinlock.h>		/* spinlock_t */
+extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
+#endif
+
+/**********************************************************************
+ * register summary
+ **********************************************************************/
+#define RTC_SECONDS		0
+#define RTC_SECONDS_ALARM	1
+#define RTC_MINUTES		2
+#define RTC_MINUTES_ALARM	3
+#define RTC_HOURS		4
+#define RTC_HOURS_ALARM		5
+/* RTC_*_alarm is always true if 2 MSBs are set */
+# define RTC_ALARM_DONT_CARE 	0xC0
+
+#define RTC_DAY_OF_WEEK		6
+#define RTC_DAY_OF_MONTH	7
+#define RTC_MONTH		8
+#define RTC_YEAR		9
+
+/* control registers - Moto names
+ */
+#define RTC_REG_A		10
+#define RTC_REG_B		11
+#define RTC_REG_C		12
+#define RTC_REG_D		13
+
+/**********************************************************************
+ * register details
+ **********************************************************************/
+#define RTC_FREQ_SELECT	RTC_REG_A
+
+/* update-in-progress  - set to "1" 244 microsecs before RTC goes off the bus,
+ * reset after update (may take 1.984ms @ 32768Hz RefClock) is complete,
+ * totalling to a max high interval of 2.228 ms.
+ */
+# define RTC_UIP		0x80
+# define RTC_DIV_CTL		0x70
+   /* divider control: refclock values 4.194 / 1.049 MHz / 32.768 kHz */
+#  define RTC_REF_CLCK_4MHZ	0x00
+#  define RTC_REF_CLCK_1MHZ	0x10
+#  define RTC_REF_CLCK_32KHZ	0x20
+   /* 2 values for divider stage reset, others for "testing purposes only" */
+#  define RTC_DIV_RESET1	0x60
+#  define RTC_DIV_RESET2	0x70
+  /* Periodic intr. / Square wave rate select. 0=none, 1=32.8kHz,... 15=2Hz */
+# define RTC_RATE_SELECT 	0x0F
+
+/**********************************************************************/
+#define RTC_CONTROL	RTC_REG_B
+# define RTC_SET 0x80		/* disable updates for clock setting */
+# define RTC_PIE 0x40		/* periodic interrupt enable */
+# define RTC_AIE 0x20		/* alarm interrupt enable */
+# define RTC_UIE 0x10		/* update-finished interrupt enable */
+# define RTC_SQWE 0x08		/* enable square-wave output */
+# define RTC_DM_BINARY 0x04	/* all time/date values are BCD if clear */
+# define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
+# define RTC_DST_EN 0x01	/* auto switch DST - works f. USA only */
+
+/**********************************************************************/
+#define RTC_INTR_FLAGS	RTC_REG_C
+/* caution - cleared by read */
+# define RTC_IRQF 0x80		/* any of the following 3 is active */
+# define RTC_PF 0x40
+# define RTC_AF 0x20
+# define RTC_UF 0x10
+
+/**********************************************************************/
+#define RTC_VALID	RTC_REG_D
+# define RTC_VRT 0x80		/* valid RAM and time */
+/**********************************************************************/
+
+#endif /* _MC146818RTC_H */
