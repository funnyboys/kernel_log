commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fd.h b/include/linux/fd.h
index 69275bccc3e4..ece5ea53205b 100644
--- a/include/linux/fd.h
+++ b/include/linux/fd.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_FD_H
 #define _LINUX_FD_H
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/fd.h b/include/linux/fd.h
index 72202b1b9a6a..69275bccc3e4 100644
--- a/include/linux/fd.h
+++ b/include/linux/fd.h
@@ -1,384 +1,8 @@
 #ifndef _LINUX_FD_H
 #define _LINUX_FD_H
 
-#include <linux/ioctl.h>
-#include <linux/compiler.h>
+#include <uapi/linux/fd.h>
 
-/* New file layout: Now the ioctl definitions immediately follow the
- * definitions of the structures that they use */
-
-/*
- * Geometry
- */
-struct floppy_struct {
-	unsigned int	size,		/* nr of sectors total */
-			sect,		/* sectors per track */
-			head,		/* nr of heads */
-			track,		/* nr of tracks */
-			stretch;	/* bit 0 !=0 means double track steps */
-					/* bit 1 != 0 means swap sides */
-					/* bits 2..9 give the first sector */
-					/*  number (the LSB is flipped) */
-#define FD_STRETCH 1
-#define FD_SWAPSIDES 2
-#define FD_ZEROBASED 4
-#define FD_SECTBASEMASK 0x3FC
-#define FD_MKSECTBASE(s) (((s) ^ 1) << 2)
-#define FD_SECTBASE(floppy) ((((floppy)->stretch & FD_SECTBASEMASK) >> 2) ^ 1)
-
-	unsigned char	gap,		/* gap1 size */
-
-			rate,		/* data rate. |= 0x40 for perpendicular */
-#define FD_2M 0x4
-#define FD_SIZECODEMASK 0x38
-#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
-#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
-			     512 : 128 << FD_SIZECODE(floppy) )
-#define FD_PERP 0x40
-
-			spec1,		/* stepping rate, head unload time */
-			fmt_gap;	/* gap2 size */
-	const char	* name; /* used only for predefined formats */
-};
-
-
-/* commands needing write access have 0x40 set */
-/* commands needing super user access have 0x80 set */
-
-#define FDCLRPRM _IO(2, 0x41)
-/* clear user-defined parameters */
-
-#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) 
-#define FDSETMEDIAPRM FDSETPRM
-/* set user-defined parameters for current media */
-
-#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) 
-#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
-#define FDDEFMEDIAPRM FDDEFPRM
-#define FDGETMEDIAPRM FDGETPRM
-/* set/get disk parameters */
-
-
-#define	FDMSGON  _IO(2,0x45)
-#define	FDMSGOFF _IO(2,0x46)
-/* issue/don't issue kernel messages on media type change */
-
-
-/* 
- * Formatting (obsolete)
- */
-#define FD_FILL_BYTE 0xF6 /* format fill byte. */
-
-struct format_descr {
-	unsigned int device,head,track;
-};
-
-#define FDFMTBEG _IO(2,0x47)
-/* begin formatting a disk */
-#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
-/* format the specified track */
-#define FDFMTEND _IO(2,0x49)
-/* end formatting a disk */
-
-
-/*
- * Error thresholds
- */
-struct floppy_max_errors {
-	unsigned int
-	  abort,      /* number of errors to be reached before aborting */
-	  read_track, /* maximal number of errors permitted to read an
-		       * entire track at once */
-	  reset,      /* maximal number of errors before a reset is tried */
-	  recal,      /* maximal number of errors before a recalibrate is
-		       * tried */
-
-	  /*
-	   * Threshold for reporting FDC errors to the console.
-	   * Setting this to zero may flood your screen when using
-	   * ultra cheap floppies ;-)
-	   */
-	  reporting;
-
-};
-
-#define FDSETEMSGTRESH	_IO(2,0x4a)
-/* set fdc error reporting threshold */
-
-#define FDFLUSH  _IO(2,0x4b)
-/* flush buffers for media; either for verifying media, or for
- * handling a media change without closing the file descriptor */
-
-#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)
-#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)
-/* set/get abortion and read_track threshold. See also floppy_drive_params
- * structure */
-
-
-typedef char floppy_drive_name[16];
-#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)
-/* get drive type: 5 1/4 or 3 1/2 */
-
-
-/*
- * Drive parameters (user modifiable)
- */
-struct floppy_drive_params {
-	signed char cmos;		/* CMOS type */
-	
-	/* Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms 
-	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
-	 */
-	unsigned long max_dtr;		/* Step rate, usec */
-	unsigned long hlt;     		/* Head load/settle time, msec */
-	unsigned long hut;     		/* Head unload time (remnant of 
-					 * 8" drives) */
-	unsigned long srt;     		/* Step rate, usec */
-
-	unsigned long spinup;		/* time needed for spinup (expressed
-					 * in jiffies) */
-	unsigned long spindown;		/* timeout needed for spindown */
-	unsigned char spindown_offset;	/* decides in which position the disk
-					 * will stop */
-	unsigned char select_delay;	/* delay to wait after select */
-	unsigned char rps;		/* rotations per second */
-	unsigned char tracks;		/* maximum number of tracks */
-	unsigned long timeout;		/* timeout for interrupt requests */
-	
-	unsigned char interleave_sect;	/* if there are more sectors, use 
-					 * interleave */
-	
-	struct floppy_max_errors max_errors;
-	
-	char flags;			/* various flags, including ftd_msg */
-/*
- * Announce successful media type detection and media information loss after
- * disk changes.
- * Also used to enable/disable printing of overrun warnings.
- */
-
-#define FTD_MSG 0x10
-#define FD_BROKEN_DCL 0x20
-#define FD_DEBUG 0x02
-#define FD_SILENT_DCL_CLEAR 0x4
-#define FD_INVERTED_DCL 0x80 /* must be 0x80, because of hardware 
-				considerations */
-
-	char read_track;		/* use readtrack during probing? */
-
-/*
- * Auto-detection. Each drive type has eight formats which are
- * used in succession to try to read the disk. If the FDC cannot lock onto
- * the disk, the next format is tried. This uses the variable 'probing'.
- */
-	short autodetect[8];		/* autodetected formats */
-	
-	int checkfreq; /* how often should the drive be checked for disk 
-			* changes */
-	int native_format; /* native format of this drive */
-};
-
-enum {
-	FD_NEED_TWADDLE_BIT,	/* more magic */
-	FD_VERIFY_BIT,		/* inquire for write protection */
-	FD_DISK_NEWCHANGE_BIT,	/* change detected, and no action undertaken yet
-				 * to clear media change status */
-	FD_UNUSED_BIT,
-	FD_DISK_CHANGED_BIT,	/* disk has been changed since last i/o */
-	FD_DISK_WRITABLE_BIT	/* disk is writable */
-};
-
-#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)
-#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)
-/* set/get drive parameters */
-
-
-/*
- * Current drive state (not directly modifiable by user, readonly)
- */
-struct floppy_drive_struct {
-	unsigned long flags;
-/* values for these flags */
-#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)
-#define FD_VERIFY (1 << FD_VERIFY_BIT)
-#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)
-#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)
-#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)
-
-	unsigned long spinup_date;
-	unsigned long select_date;
-	unsigned long first_read_date;
-	short probed_format;
-	short track; /* current track */
-	short maxblock; /* id of highest block read */
-	short maxtrack; /* id of highest half track read */
-	int generation; /* how many diskchanges? */
-
-/*
- * (User-provided) media information is _not_ discarded after a media change
- * if the corresponding keep_data flag is non-zero. Positive values are
- * decremented after each probe.
- */
-	int keep_data;
-	
-	/* Prevent "aliased" accesses. */
-	int fd_ref;
-	int fd_device;
-	unsigned long last_checked; /* when was the drive last checked for a disk 
-			   * change? */
-	
-	char *dmabuf;
-	int bufblocks;
-};
-
-#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)
-#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)
-/* get drive state: GET returns the cached state, POLL polls for new state */
-
-
-/*
- * reset FDC
- */
-enum reset_mode {
-	FD_RESET_IF_NEEDED,	/* reset only if the reset flags is set */
-	FD_RESET_IF_RAWCMD,	/* obsolete */
-	FD_RESET_ALWAYS		/* reset always */
-};
-#define FDRESET _IO(2, 0x54)
-
-
-/*
- * FDC state
- */
-struct floppy_fdc_state {	
-	int spec1;		/* spec1 value last used */
-	int spec2;		/* spec2 value last used */
-	int dtr;
-	unsigned char version;	/* FDC version code */
-	unsigned char dor;
-	unsigned long address;	/* io address */
-	unsigned int rawcmd:2;
-	unsigned int reset:1;
-	unsigned int need_configure:1;
-	unsigned int perp_mode:2;
-	unsigned int has_fifo:1;
-	unsigned int driver_version;	/* version code for floppy driver */
-#define FD_DRIVER_VERSION 0x100
-/* user programs using the floppy API should use floppy_fdc_state to
- * get the version number of the floppy driver that they are running
- * on. If this version number is bigger than the one compiled into the
- * user program (the FD_DRIVER_VERSION define), it should be prepared
- * to bigger structures
- */
-
-	unsigned char track[4];
-	/* Position of the heads of the 4 units attached to this FDC,
-	 * as stored on the FDC. In the future, the position as stored
-	 * on the FDC might not agree with the actual physical
-	 * position of these drive heads. By allowing such
-	 * disagreement, it will be possible to reset the FDC without
-	 * incurring the expensive cost of repositioning all heads.
-	 * Right now, these positions are hard wired to 0. */
-
-};
-
-#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)
-
-
-/*
- * Asynchronous Write error tracking
- */
-struct floppy_write_errors {
-	/* Write error logging.
-	 *
-	 * These fields can be cleared with the FDWERRORCLR ioctl.
-	 * Only writes that were attempted but failed due to a physical media
-	 * error are logged.  write(2) calls that fail and return an error code
-	 * to the user process are not counted.
-	 */
-
-	unsigned int write_errors;  /* number of physical write errors 
-				     * encountered */
-	
-	/* position of first and last write errors */
-	unsigned long first_error_sector;
-	int           first_error_generation;
-	unsigned long last_error_sector;
-	int           last_error_generation;
-	
-	unsigned int badness; /* highest retry count for a read or write 
-			       * operation */
-};
-
-#define FDWERRORCLR  _IO(2, 0x56)
-/* clear write error and badness information */
-#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)
-/* get write error and badness information */
-
-
-/*
- * Raw commands
- */
-/* new interface flag: now we can do them in batches */
-#define FDHAVEBATCHEDRAWCMD
-
-struct floppy_raw_cmd {
-	unsigned int flags;
-#define FD_RAW_READ 1
-#define FD_RAW_WRITE 2
-#define FD_RAW_NO_MOTOR 4
-#define FD_RAW_DISK_CHANGE 4 /* out: disk change flag was set */
-#define FD_RAW_INTR 8    /* wait for an interrupt */
-#define FD_RAW_SPIN 0x10 /* spin up the disk for this command */
-#define FD_RAW_NO_MOTOR_AFTER 0x20 /* switch the motor off after command 
-				    * completion */
-#define FD_RAW_NEED_DISK 0x40  /* this command needs a disk to be present */
-#define FD_RAW_NEED_SEEK 0x80  /* this command uses an implied seek (soft) */
-
-/* more "in" flags */
-#define FD_RAW_MORE 0x100  /* more records follow */
-#define FD_RAW_STOP_IF_FAILURE 0x200 /* stop if we encounter a failure */
-#define FD_RAW_STOP_IF_SUCCESS 0x400 /* stop if command successful */
-#define FD_RAW_SOFTFAILURE 0x800 /* consider the return value for failure
-				  * detection too */
-
-/* more "out" flags */
-#define FD_RAW_FAILURE 0x10000 /* command sent to fdc, fdc returned error */
-#define FD_RAW_HARDFAILURE 0x20000 /* fdc had to be reset, or timed out */
-
-	void __user *data;
-	char *kernel_data; /* location of data buffer in the kernel */
-	struct floppy_raw_cmd *next; /* used for chaining of raw cmd's 
-				      * within the kernel */
-	long length; /* in: length of dma transfer. out: remaining bytes */
-	long phys_length; /* physical length, if different from dma length */
-	int buffer_length; /* length of allocated buffer */
-
-	unsigned char rate;
-	unsigned char cmd_count;
-	unsigned char cmd[16];
-	unsigned char reply_count;
-	unsigned char reply[16];
-	int track;
-	int resultcode;
-
-	int reserved1;
-	int reserved2;
-};
-
-#define FDRAWCMD _IO(2, 0x58)
-/* send a raw command to the fdc. Structure size not included, because of
- * batches */
-
-#define FDTWADDLE _IO(2, 0x59)
-/* flicker motor-on bit before reading a sector. Experimental */
-
-
-#define FDEJECT _IO(2, 0x5a)
-/* eject the disk */
-
-
-#ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 
@@ -398,5 +22,3 @@ struct compat_floppy_struct {
 #define FDGETPRM32 _IOR(2, 0x04, struct compat_floppy_struct)
 #endif
 #endif
-
-#endif

commit 719c0c590609809365c6f3da2f923cd84dc99113
Author: Johannes Stezenbach <js@sig21.net>
Date:   Thu Jul 7 08:18:18 2011 +0200

    compat_ioctl: fix make headers_check regression
    
    Fix headers_check error introduced by 390192b30057:
    
    include/linux/fd.h:6: included file 'linux/compat.h' is not exported
    
    Signed-off-by: Johannes Stezenbach <js@sig21.net>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fd.h b/include/linux/fd.h
index c6a68d011608..72202b1b9a6a 100644
--- a/include/linux/fd.h
+++ b/include/linux/fd.h
@@ -3,7 +3,6 @@
 
 #include <linux/ioctl.h>
 #include <linux/compiler.h>
-#include <linux/compat.h>
 
 /* New file layout: Now the ioctl definitions immediately follow the
  * definitions of the structures that they use */
@@ -378,7 +377,11 @@ struct floppy_raw_cmd {
 #define FDEJECT _IO(2, 0x5a)
 /* eject the disk */
 
+
+#ifdef __KERNEL__
 #ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+
 struct compat_floppy_struct {
 	compat_uint_t	size;
 	compat_uint_t	sect;
@@ -394,5 +397,6 @@ struct compat_floppy_struct {
 
 #define FDGETPRM32 _IOR(2, 0x04, struct compat_floppy_struct)
 #endif
+#endif
 
 #endif

commit 390192b300570b2bc721d77067ca133f58015ae8
Author: Johannes Stezenbach <js@sig21.net>
Date:   Fri Jul 1 22:32:26 2011 +0200

    compat_ioctl: fix warning caused by qemu
    
    On Linux x86_64 host with 32bit userspace, running
    qemu or even just "qemu-img create -f qcow2 some.img 1G"
    causes a kernel warning:
    
    ioctl32(qemu-img:5296): Unknown cmd fd(3) cmd(00005326){t:'S';sz:0} arg(7fffffff) on some.img
    ioctl32(qemu-img:5296): Unknown cmd fd(3) cmd(801c0204){t:02;sz:28} arg(fff77350) on some.img
    
    ioctl 00005326 is CDROM_DRIVE_STATUS,
    ioctl 801c0204 is FDGETPRM.
    
    The warning appears because the Linux compat-ioctl handler for these
    ioctls only applies to block devices, while qemu also uses the ioctls on
    plain files.
    
    Signed-off-by: Johannes Stezenbach <js@sig21.net>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fd.h b/include/linux/fd.h
index f5d194af07a8..c6a68d011608 100644
--- a/include/linux/fd.h
+++ b/include/linux/fd.h
@@ -3,6 +3,7 @@
 
 #include <linux/ioctl.h>
 #include <linux/compiler.h>
+#include <linux/compat.h>
 
 /* New file layout: Now the ioctl definitions immediately follow the
  * definitions of the structures that they use */
@@ -377,4 +378,21 @@ struct floppy_raw_cmd {
 #define FDEJECT _IO(2, 0x5a)
 /* eject the disk */
 
+#ifdef CONFIG_COMPAT
+struct compat_floppy_struct {
+	compat_uint_t	size;
+	compat_uint_t	sect;
+	compat_uint_t	head;
+	compat_uint_t	track;
+	compat_uint_t	stretch;
+	unsigned char	gap;
+	unsigned char	rate;
+	unsigned char	spec1;
+	unsigned char	fmt_gap;
+	const compat_caddr_t name;
+};
+
+#define FDGETPRM32 _IOR(2, 0x04, struct compat_floppy_struct)
+#endif
+
 #endif

commit 9e49184c82e9ec3ab4d45f9ea5a17ccaf43869f0
Author: Keith Wansbrough <keith@lochan.org>
Date:   Mon Sep 22 14:57:17 2008 -0700

    floppy: support arbitrary first-sector numbers
    
    The current floppy_struct allows floppies to number sectors starting
    from 0 or 1.  This patch allows arbitrary first-sector numbers - for
    example, 0xC1 for Amstrad CPC disks.
    
    This extends the existing 1-bit field (FD_ZEROBASED, bit 2 of stretch)
    to 8 bits (FD_SECTMASK, bits 2 to 9).
    
    Currently 0x00 denotes a first sector number of 1, and 0x01 denotes a
    first sector number of 0.  We extend this by interpreting FD_SECTMASK
    as the first sector number with the LSB flipped.
    
    Signed-off-by: Keith Wansbrough <keith@lochan.org>
    Cc: Alain Knaff <alain@linux.lu>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: Karel Zak <kzak@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fd.h b/include/linux/fd.h
index b6bd41d2b460..f5d194af07a8 100644
--- a/include/linux/fd.h
+++ b/include/linux/fd.h
@@ -15,10 +15,16 @@ struct floppy_struct {
 			sect,		/* sectors per track */
 			head,		/* nr of heads */
 			track,		/* nr of tracks */
-			stretch;	/* !=0 means double track steps */
+			stretch;	/* bit 0 !=0 means double track steps */
+					/* bit 1 != 0 means swap sides */
+					/* bits 2..9 give the first sector */
+					/*  number (the LSB is flipped) */
 #define FD_STRETCH 1
 #define FD_SWAPSIDES 2
 #define FD_ZEROBASED 4
+#define FD_SECTBASEMASK 0x3FC
+#define FD_MKSECTBASE(s) (((s) ^ 1) << 2)
+#define FD_SECTBASE(floppy) ((((floppy)->stretch & FD_SECTBASEMASK) >> 2) ^ 1)
 
 	unsigned char	gap,		/* gap1 size */
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/fd.h b/include/linux/fd.h
new file mode 100644
index 000000000000..b6bd41d2b460
--- /dev/null
+++ b/include/linux/fd.h
@@ -0,0 +1,374 @@
+#ifndef _LINUX_FD_H
+#define _LINUX_FD_H
+
+#include <linux/ioctl.h>
+#include <linux/compiler.h>
+
+/* New file layout: Now the ioctl definitions immediately follow the
+ * definitions of the structures that they use */
+
+/*
+ * Geometry
+ */
+struct floppy_struct {
+	unsigned int	size,		/* nr of sectors total */
+			sect,		/* sectors per track */
+			head,		/* nr of heads */
+			track,		/* nr of tracks */
+			stretch;	/* !=0 means double track steps */
+#define FD_STRETCH 1
+#define FD_SWAPSIDES 2
+#define FD_ZEROBASED 4
+
+	unsigned char	gap,		/* gap1 size */
+
+			rate,		/* data rate. |= 0x40 for perpendicular */
+#define FD_2M 0x4
+#define FD_SIZECODEMASK 0x38
+#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
+#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
+			     512 : 128 << FD_SIZECODE(floppy) )
+#define FD_PERP 0x40
+
+			spec1,		/* stepping rate, head unload time */
+			fmt_gap;	/* gap2 size */
+	const char	* name; /* used only for predefined formats */
+};
+
+
+/* commands needing write access have 0x40 set */
+/* commands needing super user access have 0x80 set */
+
+#define FDCLRPRM _IO(2, 0x41)
+/* clear user-defined parameters */
+
+#define FDSETPRM _IOW(2, 0x42, struct floppy_struct) 
+#define FDSETMEDIAPRM FDSETPRM
+/* set user-defined parameters for current media */
+
+#define FDDEFPRM _IOW(2, 0x43, struct floppy_struct) 
+#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
+#define FDDEFMEDIAPRM FDDEFPRM
+#define FDGETMEDIAPRM FDGETPRM
+/* set/get disk parameters */
+
+
+#define	FDMSGON  _IO(2,0x45)
+#define	FDMSGOFF _IO(2,0x46)
+/* issue/don't issue kernel messages on media type change */
+
+
+/* 
+ * Formatting (obsolete)
+ */
+#define FD_FILL_BYTE 0xF6 /* format fill byte. */
+
+struct format_descr {
+	unsigned int device,head,track;
+};
+
+#define FDFMTBEG _IO(2,0x47)
+/* begin formatting a disk */
+#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
+/* format the specified track */
+#define FDFMTEND _IO(2,0x49)
+/* end formatting a disk */
+
+
+/*
+ * Error thresholds
+ */
+struct floppy_max_errors {
+	unsigned int
+	  abort,      /* number of errors to be reached before aborting */
+	  read_track, /* maximal number of errors permitted to read an
+		       * entire track at once */
+	  reset,      /* maximal number of errors before a reset is tried */
+	  recal,      /* maximal number of errors before a recalibrate is
+		       * tried */
+
+	  /*
+	   * Threshold for reporting FDC errors to the console.
+	   * Setting this to zero may flood your screen when using
+	   * ultra cheap floppies ;-)
+	   */
+	  reporting;
+
+};
+
+#define FDSETEMSGTRESH	_IO(2,0x4a)
+/* set fdc error reporting threshold */
+
+#define FDFLUSH  _IO(2,0x4b)
+/* flush buffers for media; either for verifying media, or for
+ * handling a media change without closing the file descriptor */
+
+#define FDSETMAXERRS _IOW(2, 0x4c, struct floppy_max_errors)
+#define FDGETMAXERRS _IOR(2, 0x0e, struct floppy_max_errors)
+/* set/get abortion and read_track threshold. See also floppy_drive_params
+ * structure */
+
+
+typedef char floppy_drive_name[16];
+#define FDGETDRVTYP _IOR(2, 0x0f, floppy_drive_name)
+/* get drive type: 5 1/4 or 3 1/2 */
+
+
+/*
+ * Drive parameters (user modifiable)
+ */
+struct floppy_drive_params {
+	signed char cmos;		/* CMOS type */
+	
+	/* Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms 
+	 * etc) and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).
+	 */
+	unsigned long max_dtr;		/* Step rate, usec */
+	unsigned long hlt;     		/* Head load/settle time, msec */
+	unsigned long hut;     		/* Head unload time (remnant of 
+					 * 8" drives) */
+	unsigned long srt;     		/* Step rate, usec */
+
+	unsigned long spinup;		/* time needed for spinup (expressed
+					 * in jiffies) */
+	unsigned long spindown;		/* timeout needed for spindown */
+	unsigned char spindown_offset;	/* decides in which position the disk
+					 * will stop */
+	unsigned char select_delay;	/* delay to wait after select */
+	unsigned char rps;		/* rotations per second */
+	unsigned char tracks;		/* maximum number of tracks */
+	unsigned long timeout;		/* timeout for interrupt requests */
+	
+	unsigned char interleave_sect;	/* if there are more sectors, use 
+					 * interleave */
+	
+	struct floppy_max_errors max_errors;
+	
+	char flags;			/* various flags, including ftd_msg */
+/*
+ * Announce successful media type detection and media information loss after
+ * disk changes.
+ * Also used to enable/disable printing of overrun warnings.
+ */
+
+#define FTD_MSG 0x10
+#define FD_BROKEN_DCL 0x20
+#define FD_DEBUG 0x02
+#define FD_SILENT_DCL_CLEAR 0x4
+#define FD_INVERTED_DCL 0x80 /* must be 0x80, because of hardware 
+				considerations */
+
+	char read_track;		/* use readtrack during probing? */
+
+/*
+ * Auto-detection. Each drive type has eight formats which are
+ * used in succession to try to read the disk. If the FDC cannot lock onto
+ * the disk, the next format is tried. This uses the variable 'probing'.
+ */
+	short autodetect[8];		/* autodetected formats */
+	
+	int checkfreq; /* how often should the drive be checked for disk 
+			* changes */
+	int native_format; /* native format of this drive */
+};
+
+enum {
+	FD_NEED_TWADDLE_BIT,	/* more magic */
+	FD_VERIFY_BIT,		/* inquire for write protection */
+	FD_DISK_NEWCHANGE_BIT,	/* change detected, and no action undertaken yet
+				 * to clear media change status */
+	FD_UNUSED_BIT,
+	FD_DISK_CHANGED_BIT,	/* disk has been changed since last i/o */
+	FD_DISK_WRITABLE_BIT	/* disk is writable */
+};
+
+#define FDSETDRVPRM _IOW(2, 0x90, struct floppy_drive_params)
+#define FDGETDRVPRM _IOR(2, 0x11, struct floppy_drive_params)
+/* set/get drive parameters */
+
+
+/*
+ * Current drive state (not directly modifiable by user, readonly)
+ */
+struct floppy_drive_struct {
+	unsigned long flags;
+/* values for these flags */
+#define FD_NEED_TWADDLE (1 << FD_NEED_TWADDLE_BIT)
+#define FD_VERIFY (1 << FD_VERIFY_BIT)
+#define FD_DISK_NEWCHANGE (1 << FD_DISK_NEWCHANGE_BIT)
+#define FD_DISK_CHANGED (1 << FD_DISK_CHANGED_BIT)
+#define FD_DISK_WRITABLE (1 << FD_DISK_WRITABLE_BIT)
+
+	unsigned long spinup_date;
+	unsigned long select_date;
+	unsigned long first_read_date;
+	short probed_format;
+	short track; /* current track */
+	short maxblock; /* id of highest block read */
+	short maxtrack; /* id of highest half track read */
+	int generation; /* how many diskchanges? */
+
+/*
+ * (User-provided) media information is _not_ discarded after a media change
+ * if the corresponding keep_data flag is non-zero. Positive values are
+ * decremented after each probe.
+ */
+	int keep_data;
+	
+	/* Prevent "aliased" accesses. */
+	int fd_ref;
+	int fd_device;
+	unsigned long last_checked; /* when was the drive last checked for a disk 
+			   * change? */
+	
+	char *dmabuf;
+	int bufblocks;
+};
+
+#define FDGETDRVSTAT _IOR(2, 0x12, struct floppy_drive_struct)
+#define FDPOLLDRVSTAT _IOR(2, 0x13, struct floppy_drive_struct)
+/* get drive state: GET returns the cached state, POLL polls for new state */
+
+
+/*
+ * reset FDC
+ */
+enum reset_mode {
+	FD_RESET_IF_NEEDED,	/* reset only if the reset flags is set */
+	FD_RESET_IF_RAWCMD,	/* obsolete */
+	FD_RESET_ALWAYS		/* reset always */
+};
+#define FDRESET _IO(2, 0x54)
+
+
+/*
+ * FDC state
+ */
+struct floppy_fdc_state {	
+	int spec1;		/* spec1 value last used */
+	int spec2;		/* spec2 value last used */
+	int dtr;
+	unsigned char version;	/* FDC version code */
+	unsigned char dor;
+	unsigned long address;	/* io address */
+	unsigned int rawcmd:2;
+	unsigned int reset:1;
+	unsigned int need_configure:1;
+	unsigned int perp_mode:2;
+	unsigned int has_fifo:1;
+	unsigned int driver_version;	/* version code for floppy driver */
+#define FD_DRIVER_VERSION 0x100
+/* user programs using the floppy API should use floppy_fdc_state to
+ * get the version number of the floppy driver that they are running
+ * on. If this version number is bigger than the one compiled into the
+ * user program (the FD_DRIVER_VERSION define), it should be prepared
+ * to bigger structures
+ */
+
+	unsigned char track[4];
+	/* Position of the heads of the 4 units attached to this FDC,
+	 * as stored on the FDC. In the future, the position as stored
+	 * on the FDC might not agree with the actual physical
+	 * position of these drive heads. By allowing such
+	 * disagreement, it will be possible to reset the FDC without
+	 * incurring the expensive cost of repositioning all heads.
+	 * Right now, these positions are hard wired to 0. */
+
+};
+
+#define FDGETFDCSTAT _IOR(2, 0x15, struct floppy_fdc_state)
+
+
+/*
+ * Asynchronous Write error tracking
+ */
+struct floppy_write_errors {
+	/* Write error logging.
+	 *
+	 * These fields can be cleared with the FDWERRORCLR ioctl.
+	 * Only writes that were attempted but failed due to a physical media
+	 * error are logged.  write(2) calls that fail and return an error code
+	 * to the user process are not counted.
+	 */
+
+	unsigned int write_errors;  /* number of physical write errors 
+				     * encountered */
+	
+	/* position of first and last write errors */
+	unsigned long first_error_sector;
+	int           first_error_generation;
+	unsigned long last_error_sector;
+	int           last_error_generation;
+	
+	unsigned int badness; /* highest retry count for a read or write 
+			       * operation */
+};
+
+#define FDWERRORCLR  _IO(2, 0x56)
+/* clear write error and badness information */
+#define FDWERRORGET  _IOR(2, 0x17, struct floppy_write_errors)
+/* get write error and badness information */
+
+
+/*
+ * Raw commands
+ */
+/* new interface flag: now we can do them in batches */
+#define FDHAVEBATCHEDRAWCMD
+
+struct floppy_raw_cmd {
+	unsigned int flags;
+#define FD_RAW_READ 1
+#define FD_RAW_WRITE 2
+#define FD_RAW_NO_MOTOR 4
+#define FD_RAW_DISK_CHANGE 4 /* out: disk change flag was set */
+#define FD_RAW_INTR 8    /* wait for an interrupt */
+#define FD_RAW_SPIN 0x10 /* spin up the disk for this command */
+#define FD_RAW_NO_MOTOR_AFTER 0x20 /* switch the motor off after command 
+				    * completion */
+#define FD_RAW_NEED_DISK 0x40  /* this command needs a disk to be present */
+#define FD_RAW_NEED_SEEK 0x80  /* this command uses an implied seek (soft) */
+
+/* more "in" flags */
+#define FD_RAW_MORE 0x100  /* more records follow */
+#define FD_RAW_STOP_IF_FAILURE 0x200 /* stop if we encounter a failure */
+#define FD_RAW_STOP_IF_SUCCESS 0x400 /* stop if command successful */
+#define FD_RAW_SOFTFAILURE 0x800 /* consider the return value for failure
+				  * detection too */
+
+/* more "out" flags */
+#define FD_RAW_FAILURE 0x10000 /* command sent to fdc, fdc returned error */
+#define FD_RAW_HARDFAILURE 0x20000 /* fdc had to be reset, or timed out */
+
+	void __user *data;
+	char *kernel_data; /* location of data buffer in the kernel */
+	struct floppy_raw_cmd *next; /* used for chaining of raw cmd's 
+				      * within the kernel */
+	long length; /* in: length of dma transfer. out: remaining bytes */
+	long phys_length; /* physical length, if different from dma length */
+	int buffer_length; /* length of allocated buffer */
+
+	unsigned char rate;
+	unsigned char cmd_count;
+	unsigned char cmd[16];
+	unsigned char reply_count;
+	unsigned char reply[16];
+	int track;
+	int resultcode;
+
+	int reserved1;
+	int reserved2;
+};
+
+#define FDRAWCMD _IO(2, 0x58)
+/* send a raw command to the fdc. Structure size not included, because of
+ * batches */
+
+#define FDTWADDLE _IO(2, 0x59)
+/* flicker motor-on bit before reading a sector. Experimental */
+
+
+#define FDEJECT _IO(2, 0x5a)
+/* eject the disk */
+
+#endif
